{
    "0": "Here's a complete implementation of a Tic-Tac-Toe game with a command line interface in Python:\n\n```python\nclass TicTacToe:\n    def __init__(self):\n        self.board = [' ' for _ in range(9)]  # A list to hold the board state\n        self.current_player = 'X'\n\n    def print_board(self):\n        print('---------')\n        for i in range(3):\n            print(f'| {\" | \".join(self.board[i * 3:(i + 1) * 3])} |')\n            print('---------')\n\n    def check_winner(self):\n        winning_combinations = [\n            (0, 1, 2), (3, 4, 5), (6, 7, 8),  # horizontal\n            (0, 3, 6), (1, 4, 7), (2, 5, 8),  # vertical\n            (0, 4, 8), (2, 4, 6)               # diagonal\n        ]\n        for a, b, c in winning_combinations:\n            if self.board[a] == self.board[b] == self.board[c] != ' ':\n                return self.board[a]\n        return None\n\n    def is_board_full(self):\n        return ' ' not in self.board\n\n    def play(self):\n        while True:\n            self.print_board()\n            move = input(f\"Player {self.current_player}, enter your move (1-9): \")\n            try:\n                move = int(move) - 1\n                if move < 0 or move > 8 or self.board[move] != ' ':\n                    print(\"Invalid move. Try again.\")\n                    continue\n            except ValueError:\n                print(\"Invalid input. Please enter a number between 1 and 9.\")\n                continue\n\n            self.board[move] = self.current_player\n            winner = self.check_winner()\n\n            if winner:\n                self.print_board()\n                print(f\"Congratulations! Player {winner} wins!\")\n                break\n            elif self.is_board_full():\n                self.print_board()\n                print(\"It's a draw!\")\n                break\n\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n\n\nif __name__ == \"__main__\":\n    game = TicTacToe()\n    game.play()\n```\n\nYou can run this code in a Python environment. The game will prompt two players to take turns entering their moves until there is a winner or the game ends in a draw.",
    "1": "Here is a complete implementation of the Hangman game with a command line interface in Python:\n\n```python\nimport random\n\ndef choose_word():\n    word_list = [\"python\", \"hangman\", \"challenge\", \"programming\", \"software\"]\n    return random.choice(word_list)\n\ndef display_hangman(tries):\n    stages = [\n        \"\"\"\n           ------\n           |    |\n           |    O\n           |   /|\\\\\n           |   / \\\\\n           |\n        \"\"\",\n        \"\"\"\n           ------\n           |    |\n           |    O\n           |   /|\\\\\n           |   /\n           |\n        \"\"\",\n        \"\"\"\n           ------\n           |    |\n           |    O\n           |   /|\n           |   \n           |\n        \"\"\",\n        \"\"\"\n           ------\n           |    |\n           |    O\n           |    \n           |   \n           |\n        \"\"\",\n        \"\"\"\n           ------\n           |    |\n           |    \n           |    \n           |   \n           |\n        \"\"\",\n        \"\"\"\n           ------\n           |    \n           |    \n           |    \n           |   \n           |\n        \"\"\",\n        \"\"\"\n           ------\n           |    \n           |    \n           |    \n           |   \n           |\n        \"\"\",\n    ]\n    return stages[tries]\n\ndef play():\n    word = choose_word()\n    word_completion = \"_\" * len(word)\n    guessed = False\n    guessed_letters = []\n    guessed_words = []\n    tries = 6\n\n    print(\"Let's play Hangman!\")\n    print(display_hangman(tries))\n    print(word_completion)\n\n    while not guessed and tries > 0:\n        guess = input(\"Please guess a letter or word: \").lower()\n\n        if len(guess) == 1 and guess.isalpha():\n            if guess in guessed_letters:\n                print(\"You've already guessed that letter.\")\n            elif guess not in word:\n                print(f\"{guess} is not in the word.\")\n                tries -= 1\n                guessed_letters.append(guess)\n            else:\n                print(f\"Good job! {guess} is in the word.\")\n                guessed_letters.append(guess)\n                word_completion = \"\".join(\n                    [letter if letter in guessed_letters else \"_\" for letter in word]\n                )\n                if \"_\" not in word_completion:\n                    guessed = True\n        elif len(guess) == len(word) and guess.isalpha():\n            if guess in guessed_words:\n                print(\"You've already guessed that word.\")\n            elif guess != word:\n                print(f\"{guess} is not the word.\")\n                tries -= 1\n                guessed_words.append(guess)\n            else:\n                guessed = True\n                word_completion = word\n        else:\n            print(\"Invalid input. Please try again.\")\n\n        print(display_hangman(tries))\n        print(word_completion)\n\n    if guessed:\n        print(\"Congratulations! You've guessed the word!\")\n    else:\n        print(f\"Sorry, you've run out of tries. The word was '{word}'.\")\n\nif __name__ == \"__main__\":\n    play()\n```\n\nYou can run this code in a Python environment, and it will allow you to play the Hangman game through the command line interface.",
    "2": "```python\nimport random\n\ndef get_user_choice():\n    user_input = input(\"Enter your choice (rock, paper, scissors): \").lower()\n    while user_input not in ['rock', 'paper', 'scissors']:\n        print(\"Invalid choice. Please try again.\")\n        user_input = input(\"Enter your choice (rock, paper, scissors): \").lower()\n    return user_input\n\ndef get_computer_choice():\n    return random.choice(['rock', 'paper', 'scissors'])\n\ndef determine_winner(user_choice, computer_choice):\n    if user_choice == computer_choice:\n        return \"It's a tie!\"\n    elif (user_choice == 'rock' and computer_choice == 'scissors') or \\\n         (user_choice == 'paper' and computer_choice == 'rock') or \\\n         (user_choice == 'scissors' and computer_choice == 'paper'):\n        return \"You win!\"\n    else:\n        return \"You lose!\"\n\ndef play_game():\n    print(\"Welcome to Rock-Paper-Scissors!\")\n    while True:\n        user_choice = get_user_choice()\n        computer_choice = get_computer_choice()\n        print(f\"Computer chose: {computer_choice}\")\n        result = determine_winner(user_choice, computer_choice)\n        print(result)\n        \n        play_again = input(\"Do you want to play again? (yes/no): \").lower()\n        if play_again != 'yes':\n            break\n    print(\"Thanks for playing!\")\n\nif __name__ == \"__main__\":\n    play_game()\n```",
    "3": "Here's a simple implementation of the Snake game in Python with a command-line interface using the `curses` library. You can run this code in a terminal that supports `curses`.\n\n```python\nimport curses\nfrom random import randint\n\n# Setting up the window\nstdscr = curses.initscr()\ncurses.curs_set(0)\nsh, sw = stdscr.getmaxyx()  # height and width of window\nw = curses.newwin(sh, sw, 0, 0)  # create a new window\nw.keypad(1)  # enable keypad input\nw.timeout(100)  # refresh every 100 milliseconds\n\n# Initializing the snake and food\nsnk_x = sw // 4  # starting x coordinate\nsnk_y = sh // 2  # starting y coordinate\nsnake = [\n    [snk_y, snk_x],\n    [snk_y, snk_x - 1],\n    [snk_y, snk_x - 2]\n]\nfood = [sh // 2, sw // 2]  # food position\nw.addch(int(food[0]), int(food[1]), curses.ACS_PI)  # place food on the window\n\nkey = curses.KEY_RIGHT  # initial direction\n\nwhile True:\n    next_key = w.getch()  # get user input\n    key = key if next_key == -1 else next_key  # update direction if input is available\n\n    # Calculate new head of the snake\n    new_head = [snake[0][0], snake[0][1]]\n\n    if key == curses.KEY_DOWN:\n        new_head[0] += 1\n    if key == curses.KEY_UP:\n        new_head[0] -= 1\n    if key == curses.KEY_LEFT:\n        new_head[1] -= 1\n    if key == curses.KEY_RIGHT:\n        new_head[1] += 1\n\n    # Insert new head\n    snake.insert(0, new_head)\n\n    # Check if snake has eaten the food\n    if snake[0] == food:\n        food = None\n        while food is None:\n            nf = [\n                randint(1, sh - 1),\n                randint(1, sw - 1)\n            ]\n            food = nf if nf not in snake else None\n        w.addch(int(food[0]), int(food[1]), curses.ACS_PI)  # place new food\n    else:\n        # Remove the last segment of snake\n        tail = snake.pop()\n        w.addch(int(tail[0]), int(tail[1]), ' ')  # clear the tail\n\n    # Game Over conditions\n    if (snake[0][0] in [0, sh]) or (snake[0][1] in [0, sw]) or (snake[0] in snake[1:]):\n        curses.endwin()\n        quit()\n\n    # Drawing the snake\n    w.addch(int(snake[0][0]), int(snake[0][1]), curses.ACS_CKBOARD)  # draw the head\n```\n\n### Instructions to run the code:\n1. Make sure you have Python installed on your system.\n2. Save the code to a file named `snake.py`.\n3. Open a terminal and navigate to the directory where you saved the file.\n4. Run the code using the command:\n   ```\n   python snake.py\n   ```\n5. Use the arrow keys to control the snake.\n\n### Note:\n- The game will exit if the snake runs into the wall or itself.",
    "4": "Here's a full implementation of the Minesweeper game with a command line interface in Python:\n\n```python\nimport random\n\nclass Minesweeper:\n    def __init__(self, width, height, mines):\n        self.width = width\n        self.height = height\n        self.mines = mines\n        self.board = [[' ' for _ in range(width)] for _ in range(height)]\n        self.visible = [[' ' for _ in range(width)] for _ in range(height)]\n        self.game_over = False\n        self.populate_mines()\n\n    def populate_mines(self):\n        mine_positions = set()\n        while len(mine_positions) < self.mines:\n            position = (random.randint(0, self.height - 1), random.randint(0, self.width - 1))\n            mine_positions.add(position)\n        for (y, x) in mine_positions:\n            self.board[y][x] = '*'\n            for dy in range(-1, 2):\n                for dx in range(-1, 2):\n                    if 0 <= y + dy < self.height and 0 <= x + dx < self.width:\n                        if self.board[y + dy][x + dx] != '*':\n                            self.board[y + dy][x + dx] = str(int(self.board[y + dy][x + dx]) + 1) if self.board[y + dy][x + dx] != ' ' else '1'\n\n    def display_board(self):\n        print(\"   \" + \" \".join(str(x) for x in range(self.width)))\n        for y in range(self.height):\n            print(f\"{y} | \" + \" \".join(self.visible[y]))\n\n    def reveal(self, y, x):\n        if self.board[y][x] == '*':\n            self.game_over = True\n            return\n        self._reveal(y, x)\n\n    def _reveal(self, y, x):\n        if self.visible[y][x] == ' ':\n            self.visible[y][x] = self.board[y][x]\n            if self.board[y][x] == '0':\n                for dy in range(-1, 2):\n                    for dx in range(-1, 2):\n                        if 0 <= y + dy < self.height and 0 <= x + dx < self.width:\n                            self._reveal(y + dy, x + dx)\n\n    def play(self):\n        while not self.game_over:\n            self.display_board()\n            try:\n                y, x = map(int, input(\"Enter row and column to reveal (e.g., '1 2'): \").split())\n                if 0 <= y < self.height and 0 <= x < self.width:\n                    self.reveal(y, x)\n                else:\n                    print(\"Invalid coordinates. Please try again.\")\n            except ValueError:\n                print(\"Invalid input. Please enter two numbers separated by a space.\")\n\n        print(\"Game Over! You hit a mine.\")\n        self.display_board()\n\nif __name__ == \"__main__\":\n    width = 10\n    height = 10\n    mines = 10\n    game = Minesweeper(width, height, mines)\n    game.play()\n```\n\nTo run this code, make sure you have Python installed. You can save this code to a file named `minesweeper.py`, and then run it from the command line using the command:\n\n```bash\npython minesweeper.py\n```\n\nThis implementation creates a simple command-line version of Minesweeper. The player can input row and column numbers to reveal spaces, and the game will continue until they hit a mine.",
    "5": "```python\nimport random\n\nclass Mastermind:\n    def __init__(self, code_length=4, num_colors=6):\n        self.code_length = code_length\n        self.num_colors = num_colors\n        self.secret_code = self.generate_code()\n\n    def generate_code(self):\n        return [random.randint(1, self.num_colors) for _ in range(self.code_length)]\n\n    def get_feedback(self, guess):\n        correct_positions = sum(1 for i in range(self.code_length) if guess[i] == self.secret_code[i])\n        correct_colors = sum(min(guess.count(color), self.secret_code.count(color)) for color in set(guess))\n        correct_colors -= correct_positions  # Remove correct positions from correct colors\n        return correct_positions, correct_colors\n\n    def play(self):\n        attempts = 10\n        print(\"Welcome to Mastermind!\")\n        print(f\"Guess the code of length {self.code_length} using {self.num_colors} colors (1 to {self.num_colors}).\")\n        \n        while attempts > 0:\n            guess_input = input(f\"You have {attempts} attempts left. Enter your guess: \")\n            try:\n                guess = list(map(int, guess_input.split()))\n                if len(guess) != self.code_length or any(color < 1 or color > self.num_colors for color in guess):\n                    print(f\"Invalid input. Please enter {self.code_length} numbers between 1 and {self.num_colors}.\")\n                    continue\n            except ValueError:\n                print(\"Invalid input. Please enter numbers only.\")\n                continue\n\n            correct_positions, correct_colors = self.get_feedback(guess)\n            print(f\"Feedback: {correct_positions} correct positions and {correct_colors} correct colors.\")\n            \n            if correct_positions == self.code_length:\n                print(\"Congratulations! You've cracked the code!\")\n                break\n\n            attempts -= 1\n\n        if attempts == 0:\n            print(\"You've run out of attempts! The secret code was:\", self.secret_code)\n\nif __name__ == \"__main__\":\n    game = Mastermind()\n    game.play()\n```",
    "6": "Here's a simple implementation of the game Battleship in Python with a command line interface:\n\n```python\nimport random\n\nclass Battleship:\n    def __init__(self):\n        self.board_size = 5\n        self.board = [['~'] * self.board_size for _ in range(self.board_size)]\n        self.ship_position = self.place_ship()\n        self.guesses = []\n        self.max_guesses = 7\n\n    def place_ship(self):\n        x = random.randint(0, self.board_size - 1)\n        y = random.randint(0, self.board_size - 1)\n        return (x, y)\n\n    def print_board(self):\n        print(\"Current Board:\")\n        for row in self.board:\n            print(\" \".join(row))\n        print()\n\n    def make_guess(self, x, y):\n        if (x, y) in self.guesses:\n            print(\"You've already guessed that position.\")\n            return False\n\n        self.guesses.append((x, y))\n\n        if (x, y) == self.ship_position:\n            print(\"Congratulations! You sunk my battleship!\")\n            return True\n        else:\n            print(\"Miss!\")\n            self.board[x][y] = 'X'\n            return False\n\n    def is_game_over(self):\n        return len(self.guesses) >= self.max_guesses\n\n    def start_game(self):\n        print(\"Welcome to Battleship!\")\n        while True:\n            self.print_board()\n            print(f\"You have {self.max_guesses - len(self.guesses)} guesses left.\")\n            try:\n                x = int(input(\"Enter your guess row (0-4): \"))\n                y = int(input(\"Enter your guess column (0-4): \"))\n            except ValueError:\n                print(\"Please enter valid integers.\")\n                continue\n\n            if x < 0 or x >= self.board_size or y < 0 or y >= self.board_size:\n                print(\"Guess out of bounds. Please try again.\")\n                continue\n\n            if self.make_guess(x, y):\n                self.print_board()\n                break\n\n            if self.is_game_over():\n                print(\"Game Over! You've run out of guesses.\")\n                print(f\"The ship was at {self.ship_position}.\")\n                self.print_board()\n                break\n\n\nif __name__ == \"__main__\":\n    game = Battleship()\n    game.start_game()\n```\n\nTo run the game, simply copy the code into a file named `battleship.py` and execute it using Python in your command line. Enjoy playing!",
    "7": "Here's a full implementation of Conway's Game of Life with a command-line interface in Python:\n\n```python\nimport numpy as np\nimport os\nimport time\nimport sys\n\nclass GameOfLife:\n    def __init__(self, width=20, height=10):\n        self.width = width\n        self.height = height\n        self.board = np.zeros((height, width), dtype=int)\n\n    def randomize(self):\n        self.board = np.random.choice([0, 1], size=(self.height, self.width))\n\n    def display(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        print(\"\\n\".join(\"\".join(\"█\" if cell else \" \" for cell in row) for row in self.board))\n\n    def update(self):\n        new_board = np.copy(self.board)\n        for y in range(self.height):\n            for x in range(self.width):\n                alive_neighbors = np.sum(self.board[y-1:y+2, x-1:x+2]) - self.board[y, x]\n                if self.board[y, x] == 1:\n                    if alive_neighbors < 2 or alive_neighbors > 3:\n                        new_board[y, x] = 0\n                else:\n                    if alive_neighbors == 3:\n                        new_board[y, x] = 1\n        self.board = new_board\n\n    def run(self, iterations=100, delay=0.5):\n        for _ in range(iterations):\n            self.display()\n            self.update()\n            time.sleep(delay)\n\ndef main():\n    width = 20\n    height = 10\n    game = GameOfLife(width, height)\n    game.randomize()\n    iterations = int(input(\"Enter number of iterations (default 100): \") or 100)\n    delay = float(input(\"Enter delay in seconds (default 0.5): \") or 0.5)\n    game.run(iterations, delay)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nTo run the game, simply copy the code into a Python file, for example, `game_of_life.py`, and execute it using Python in your command line. Enjoy playing!",
    "8": "Here's a simple implementation of the Connect Four game with a command line interface in Python:\n\n```python\nimport numpy as np\n\nROWS = 6\nCOLUMNS = 7\nEMPTY = 0\nPLAYER1 = 1\nPLAYER2 = 2\n\nclass ConnectFour:\n    def __init__(self):\n        self.board = np.zeros((ROWS, COLUMNS), dtype=int)\n        self.current_player = PLAYER1\n\n    def print_board(self):\n        print(np.flip(self.board, 0))\n\n    def drop_piece(self, column):\n        for row in range(ROWS):\n            if self.board[row][column] == EMPTY:\n                self.board[row][column] = self.current_player\n                return row\n        return -1\n\n    def is_valid_location(self, column):\n        return self.board[ROWS - 1][column] == EMPTY\n\n    def winning_move(self, row, column):\n        # Check horizontal\n        for c in range(COLUMNS - 3):\n            if (self.board[row][c] == self.current_player and\n                self.board[row][c + 1] == self.current_player and\n                self.board[row][c + 2] == self.current_player and\n                self.board[row][c + 3] == self.current_player):\n                return True\n\n        # Check vertical\n        for r in range(ROWS - 3):\n            if (self.board[r][column] == self.current_player and\n                self.board[r + 1][column] == self.current_player and\n                self.board[r + 2][column] == self.current_player and\n                self.board[r + 3][column] == self.current_player):\n                return True\n\n        # Check positively sloped diagonals\n        for r in range(ROWS - 3):\n            for c in range(COLUMNS - 3):\n                if (self.board[r][c] == self.current_player and\n                    self.board[r + 1][c + 1] == self.current_player and\n                    self.board[r + 2][c + 2] == self.current_player and\n                    self.board[r + 3][c + 3] == self.current_player):\n                    return True\n\n        # Check negatively sloped diagonals\n        for r in range(3, ROWS):\n            for c in range(COLUMNS - 3):\n                if (self.board[r][c] == self.current_player and\n                    self.board[r - 1][c + 1] == self.current_player and\n                    self.board[r - 2][c + 2] == self.current_player and\n                    self.board[r - 3][c + 3] == self.current_player):\n                    return True\n\n        return False\n\n    def switch_player(self):\n        self.current_player = PLAYER1 if self.current_player == PLAYER2 else PLAYER2\n\n    def play(self):\n        game_over = False\n        while not game_over:\n            self.print_board()\n            column = int(input(f\"Player {self.current_player}, select a column (0-{COLUMNS - 1}): \"))\n            \n            if column < 0 or column >= COLUMNS or not self.is_valid_location(column):\n                print(\"Invalid column. Try again.\")\n                continue\n\n            row = self.drop_piece(column)\n\n            if self.winning_move(row, column):\n                self.print_board()\n                print(f\"Player {self.current_player} wins!\")\n                game_over = True\n            else:\n                self.switch_player()\n\nif __name__ == \"__main__\":\n    game = ConnectFour()\n    game.play()\n```\n\nTo run the game, simply copy the code into a Python environment and execute it. Players will take turns selecting a column to drop their piece, and the game will announce the winner when a player connects four pieces.",
    "9": "Sure! Below is a full implementation of a simple Blackjack game with a command line interface in Python.\n\n```python\nimport random\n\n# Constants\nCARD_VALUES = {\n    '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,\n    '10': 10, 'J': 10, 'Q': 10, 'K': 10, 'A': 11\n}\n\nSUITS = ['Hearts', 'Diamonds', 'Clubs', 'Spades']\nRANKS = list(CARD_VALUES.keys())\n\nclass Card:\n    def __init__(self, rank, suit):\n        self.rank = rank\n        self.suit = suit\n\n    def value(self):\n        return CARD_VALUES[self.rank]\n\n    def __str__(self):\n        return f\"{self.rank} of {self.suit}\"\n\nclass Deck:\n    def __init__(self):\n        self.cards = [Card(rank, suit) for suit in SUITS for rank in RANKS]\n        random.shuffle(self.cards)\n\n    def deal(self):\n        return self.cards.pop() if self.cards else None\n\nclass Hand:\n    def __init__(self):\n        self.cards = []\n\n    def add_card(self, card):\n        self.cards.append(card)\n\n    def value(self):\n        value, aces = 0, 0\n        for card in self.cards:\n            value += card.value()\n            if card.rank == 'A':\n                aces += 1\n        while value > 21 and aces:\n            value -= 10\n            aces -= 1\n        return value\n\n    def __str__(self):\n        return ', '.join(str(card) for card in self.cards)\n\ndef play_blackjack():\n    print(\"Welcome to Blackjack!\")\n    deck = Deck()\n    player_hand = Hand()\n    dealer_hand = Hand()\n\n    # Initial dealing\n    for _ in range(2):\n        player_hand.add_card(deck.deal())\n        dealer_hand.add_card(deck.deal())\n\n    while True:\n        print(f\"\\nYour hand: {player_hand} (Value: {player_hand.value()})\")\n        print(f\"Dealer's hand: {dealer_hand.cards[0]} and unknown card\")\n\n        if player_hand.value() == 21:\n            print(\"Blackjack! You win!\")\n            return\n        elif player_hand.value() > 21:\n            print(\"Bust! You lose!\")\n            return\n\n        action = input(\"Do you want to (h)it or (s)tand? \").lower()\n        if action == 'h':\n            player_hand.add_card(deck.deal())\n        elif action == 's':\n            break\n        else:\n            print(\"Invalid input. Please enter 'h' or 's'.\")\n\n    # Dealer's turn\n    while dealer_hand.value() < 17:\n        dealer_hand.add_card(deck.deal())\n\n    print(f\"\\nDealer's hand: {dealer_hand} (Value: {dealer_hand.value()})\")\n\n    # Determine the outcome\n    if dealer_hand.value() > 21:\n        print(\"Dealer busts! You win!\")\n    elif player_hand.value() > dealer_hand.value():\n        print(\"You win!\")\n    elif player_hand.value() < dealer_hand.value():\n        print(\"You lose!\")\n    else:\n        print(\"It's a tie!\")\n\nif __name__ == \"__main__\":\n    play_blackjack()\n```\n\nTo run the game, you just need to copy this code into a Python file (e.g., `blackjack.py`) and execute it in your command line or terminal using `python blackjack.py`. Enjoy playing!",
    "10": "Sure! Below is a simple implementation of the game Hammurabi in Python with a command line interface.\n\n```python\nimport random\n\nclass Hammurabi:\n    def __init__(self):\n        self.year = 1\n        self.population = 100\n        self.bushels = 2800\n        self.land = 100\n        self.plague_years = 0\n        self.famine_years = 0\n        self.harvest = 3\n        self.price_per_bushel = 1\n        self.deaths = 0\n        self.rats = 0\n\n    def print_status(self):\n        print(f\"\\nYear: {self.year}\")\n        print(f\"Population: {self.population}\")\n        print(f\"Bushels of grain: {self.bushels}\")\n        print(f\"Acres of land: {self.land}\")\n        print(f\"Price per bushel: {self.price_per_bushel}\")\n\n    def plant_crops(self, acres):\n        if acres > self.land:\n            print(\"You cannot plant more acres than you own!\")\n            return False\n        if acres * self.price_per_bushel > self.bushels:\n            print(\"You do not have enough bushels to plant that many acres!\")\n            return False\n        self.bushels -= acres * self.price_per_bushel\n        yield_amount = acres * self.harvest\n        self.bushels += yield_amount\n        return True\n\n    def buy_land(self, acres):\n        cost = acres * self.price_per_bushel\n        if cost > self.bushels:\n            print(\"You do not have enough bushels to buy that much land!\")\n            return False\n        self.bushels -= cost\n        self.land += acres\n        return True\n\n    def sell_land(self, acres):\n        if acres > self.land:\n            print(\"You cannot sell more land than you own!\")\n            return False\n        self.land -= acres\n        self.bushels += acres * self.price_per_bushel\n        return True\n\n    def simulate_year(self):\n        self.year += 1\n        if self.year % 4 == 0:\n            self.rats = random.randint(0, 200)\n            self.bushels -= self.rats\n            if self.bushels < 0:\n                self.bushels = 0\n\n        plague = random.randint(0, 100)\n        if plague < 10:\n            self.deaths = int(self.population * 0.5)\n            self.plague_years += 1\n            print(\"A plague has struck! Half the population has died.\")\n        else:\n            self.deaths = 0\n\n        famine = random.randint(0, 100)\n        if famine < 20 and self.bushels < self.population:\n            self.deaths += int(self.population * 0.3)\n            self.famine_years += 1\n            print(\"There was a famine! Many people have died.\")\n        \n        self.population -= self.deaths\n        if self.population < 0:\n            self.population = 0\n\n    def play(self):\n        print(\"Welcome to Hammurabi!\")\n        while self.year <= 10 and self.population > 0:\n            self.print_status()\n            action = input(\"\\nWhat would you like to do? (plant/buy/sell): \").strip().lower()\n            if action == \"plant\":\n                acres = int(input(\"Enter the number of acres to plant: \"))\n                self.plant_crops(acres)\n            elif action == \"buy\":\n                acres = int(input(\"Enter the number of acres to buy: \"))\n                self.buy_land(acres)\n            elif action == \"sell\":\n                acres = int(input(\"Enter the number of acres to sell: \"))\n                self.sell_land(acres)\n            else:\n                print(\"Invalid action. Please",
    "11": "Here's a full implementation of the \"Lights Out\" game with a command line interface in Python:\n\n```python\nimport random\n\nclass LightsOut:\n    def __init__(self, size=5):\n        self.size = size\n        self.board = self.create_board()\n        self.is_game_over = False\n\n    def create_board(self):\n        board = [[random.choice([0, 1]) for _ in range(self.size)] for _ in range(self.size)]\n        return board\n\n    def toggle_light(self, row, col):\n        if 0 <= row < self.size and 0 <= col < self.size:\n            self.board[row][col] ^= 1  # Toggle the light\n            # Toggle adjacent lights\n            if row > 0:\n                self.board[row - 1][col] ^= 1\n            if row < self.size - 1:\n                self.board[row + 1][col] ^= 1\n            if col > 0:\n                self.board[row][col - 1] ^= 1\n            if col < self.size - 1:\n                self.board[row][col + 1] ^= 1\n\n    def print_board(self):\n        for row in self.board:\n            print(' '.join(['O' if light == 1 else 'X' for light in row]))\n        print()\n\n    def check_win(self):\n        return all(light == 0 for row in self.board for light in row)\n\n    def play(self):\n        print(\"Welcome to Lights Out!\")\n        while not self.is_game_over:\n            self.print_board()\n            row = int(input(f\"Enter row (0-{self.size-1}): \"))\n            col = int(input(f\"Enter column (0-{self.size-1}): \"))\n            self.toggle_light(row, col)\n            if self.check_win():\n                self.is_game_over = True\n                print(\"Congratulations! You've turned off all the lights!\")\n        self.print_board()\n\nif __name__ == \"__main__\":\n    game = LightsOut()\n    game.play()\n```\n\nTo run the game, simply save this code to a Python file (e.g., `lights_out.py`) and execute it in the command line using `python lights_out.py`. Enjoy!",
    "12": "Here's a simple implementation of the Pong game using Python with a command line interface. This version uses the `curses` library to handle the terminal graphics.\n\n```python\nimport curses\nimport time\n\n# Constants\nWIN_HEIGHT = 20\nWIN_WIDTH = 40\nPADDLE_HEIGHT = 3\nBALL_SYMBOL = 'O'\nPADDLE_SYMBOL = '|'\n\ndef main(stdscr):\n    # Clear and refresh the screen\n    stdscr.clear()\n    curses.curs_set(0)\n\n    # Create a window\n    win = curses.newwin(WIN_HEIGHT, WIN_WIDTH, 0, 0)\n    win.keypad(1)\n    win.timeout(100)\n\n    # Initial positions\n    left_paddle = (WIN_HEIGHT // 2) - 1\n    right_paddle = (WIN_HEIGHT // 2) - 1\n    ball_x = WIN_WIDTH // 2\n    ball_y = WIN_HEIGHT // 2\n    ball_dx = 1\n    ball_dy = 1\n\n    while True:\n        win.clear()\n\n        # Draw paddles\n        for i in range(PADDLE_HEIGHT):\n            win.addch(left_paddle + i, 1, PADDLE_SYMBOL)\n            win.addch(right_paddle + i, WIN_WIDTH - 2, PADDLE_SYMBOL)\n\n        # Draw ball\n        win.addch(ball_y, ball_x, BALL_SYMBOL)\n\n        # Refresh the window\n        win.refresh()\n\n        # Ball movement\n        ball_x += ball_dx\n        ball_y += ball_dy\n\n        # Ball collision with top and bottom\n        if ball_y <= 0 or ball_y >= WIN_HEIGHT - 1:\n            ball_dy *= -1\n\n        # Ball collision with paddles\n        if ball_x == 2 and left_paddle <= ball_y < left_paddle + PADDLE_HEIGHT:\n            ball_dx *= -1\n        if ball_x == WIN_WIDTH - 3 and right_paddle <= ball_y < right_paddle + PADDLE_HEIGHT:\n            ball_dx *= -1\n\n        # Ball out of bounds\n        if ball_x <= 0 or ball_x >= WIN_WIDTH - 1:\n            ball_x, ball_y = WIN_WIDTH // 2, WIN_HEIGHT // 2  # Reset ball position\n\n        # Paddle movement\n        key = win.getch()\n        if key == curses.KEY_UP and right_paddle > 0:\n            right_paddle -= 1\n        elif key == curses.KEY_DOWN and right_paddle < WIN_HEIGHT - PADDLE_HEIGHT:\n            right_paddle += 1\n        elif key == ord('w') and left_paddle > 0:\n            left_paddle -= 1\n        elif key == ord('s') and left_paddle < WIN_HEIGHT - PADDLE_HEIGHT:\n            left_paddle += 1\n\n        time.sleep(0.05)\n\nif __name__ == \"__main__\":\n    curses.wrapper(main)\n```\n\n### Instructions to Run the Code\n1. Make sure you have Python installed on your system.\n2. Save the code in a file named `pong.py`.\n3. Run the code in your terminal using the command: `python pong.py`.\n4. Use `W` and `S` keys to move the left paddle up and down, and the arrow keys to move the right paddle. \n\n### Note\nThis is a basic implementation of Pong. You can enhance it with features like scoring, sound effects, and additional game mechanics as you learn more!",
    "13": "Here's a simple implementation of Tetris in Python with a command line interface. You can run this code in a terminal that supports ANSI escape sequences for better visuals. Make sure you have the `curses` library available, as it's used for handling the terminal interface.\n\n```python\nimport curses\nimport random\n\n# Define the shapes of the Tetriminos\nSHAPES = [\n    [[1, 1, 1, 1]],  # I\n    [[1, 1, 1], [0, 1, 0]],  # T\n    [[1, 1], [1, 1]],  # O\n    [[0, 1, 1], [1, 1, 0]],  # S\n    [[1, 1, 0], [0, 1, 1]],  # Z\n    [[1, 0, 0], [1, 1, 1]],  # L\n    [[0, 0, 1], [1, 1, 1]],  # J\n]\n\nclass Tetris:\n    def __init__(self, stdscr):\n        self.stdscr = stdscr\n        self.board = [[0] * 10 for _ in range(20)]\n        self.current_piece = None\n        self.current_x = 0\n        self.current_y = 0\n        self.score = 0\n        self.game_over = False\n        self.spawn_piece()\n\n    def spawn_piece(self):\n        self.current_piece = random.choice(SHAPES)\n        self.current_x = 3\n        self.current_y = 0\n        if self.collision():\n            self.game_over = True\n\n    def collision(self):\n        for y, row in enumerate(self.current_piece):\n            for x, cell in enumerate(row):\n                if cell:\n                    if (y + self.current_y >= len(self.board) or\n                            x + self.current_x < 0 or\n                            x + self.current_x >= len(self.board[0]) or\n                            self.board[y + self.current_y][x + self.current_x]):\n                        return True\n        return False\n\n    def freeze(self):\n        for y, row in enumerate(self.current_piece):\n            for x, cell in enumerate(row):\n                if cell:\n                    self.board[y + self.current_y][x + self.current_x] = 1\n        self.clear_lines()\n        self.spawn_piece()\n\n    def clear_lines(self):\n        lines_to_clear = []\n        for i, row in enumerate(self.board):\n            if all(row):\n                lines_to_clear.append(i)\n        for i in lines_to_clear:\n            del self.board[i]\n            self.board.insert(0, [0] * 10)\n            self.score += 100\n\n    def rotate(self):\n        self.current_piece = list(zip(*self.current_piece[::-1]))\n        if self.collision():\n            self.current_piece = list(zip(*self.current_piece))[::-1]\n\n    def move(self, dx):\n        self.current_x += dx\n        if self.collision():\n            self.current_x -= dx\n\n    def drop(self):\n        self.current_y += 1\n        if self.collision():\n            self.current_y -= 1\n            self.freeze()\n\n    def draw(self):\n        self.stdscr.clear()\n        for y in range(len(self.board)):\n            for x in range(len(self.board[0])):\n                if self.board[y][x]:\n                    self.stdscr.addstr(y, x, \"█\")\n        for y, row in enumerate(self.current_piece):\n            for x, cell in enumerate(row):\n                if cell:\n                    self.stdscr.addstr(y + self.current_y, x + self.current_x, \"█\")\n        self.stdscr.addstr(22, 0, f\"Score: {self.score}\")\n        if self.game",
    "14": "Sure! Below is a simple implementation of an Asteroids-like game in Python that runs in the command line. This version uses basic ASCII art and keyboard inputs to simulate the game. To run this code, make sure you have Python installed on your system.\n\n```python\nimport random\nimport os\nimport sys\nimport time\nimport threading\nimport keyboard\n\n# Game constants\nWIDTH = 40\nHEIGHT = 20\nNUM_ASTEROIDS = 5\nSHIP_ICON = '>'\nASTEROID_ICON = '*'\nBULLET_ICON = '|'\nSHIP_START_X = WIDTH // 2\nSHIP_START_Y = HEIGHT - 1\n\nclass Game:\n    def __init__(self):\n        self.ship_x = SHIP_START_X\n        self.ship_y = SHIP_START_Y\n        self.asteroids = self.create_asteroids()\n        self.bullets = []\n        self.score = 0\n        self.game_over = False\n\n    def create_asteroids(self):\n        return [(random.randint(0, WIDTH-1), random.randint(0, HEIGHT-5)) for _ in range(NUM_ASTEROIDS)]\n\n    def draw(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for y in range(HEIGHT):\n            for x in range(WIDTH):\n                if (x, y) == (self.ship_x, self.ship_y):\n                    print(SHIP_ICON, end='')\n                elif (x, y) in self.asteroids:\n                    print(ASTEROID_ICON, end='')\n                elif (x, y) in self.bullets:\n                    print(BULLET_ICON, end='')\n                else:\n                    print(' ', end='')\n            print()\n        print(f'Score: {self.score}')\n\n    def move_ship(self, dx):\n        self.ship_x = max(0, min(WIDTH - 1, self.ship_x + dx))\n\n    def shoot(self):\n        self.bullets.append((self.ship_x, self.ship_y - 1))\n\n    def update_bullets(self):\n        new_bullets = []\n        for bullet in self.bullets:\n            if bullet[1] > 0:\n                new_bullets.append((bullet[0], bullet[1] - 1))\n        self.bullets = new_bullets\n\n    def check_collisions(self):\n        for bullet in self.bullets:\n            if bullet in self.asteroids:\n                self.asteroids.remove(bullet)\n                self.score += 1\n\n    def run(self):\n        while not self.game_over:\n            self.draw()\n            self.update_bullets()\n            self.check_collisions()\n            if not self.asteroids:\n                print(\"You destroyed all the asteroids! You win!\")\n                self.game_over = True\n            time.sleep(0.1)\n\ndef control_thread(game):\n    while not game.game_over:\n        if keyboard.is_pressed('a'):\n            game.move_ship(-1)\n        elif keyboard.is_pressed('d'):\n            game.move_ship(1)\n        elif keyboard.is_pressed('space'):\n            game.shoot()\n        time.sleep(0.1)\n\nif __name__ == '__main__':\n    game = Game()\n    threading.Thread(target=control_thread, args=(game,), daemon=True).start()\n    game.run()\n```\n\n### Instructions to Run the Game:\n1. Make sure you have Python installed on your computer.\n2. Copy the above code into a file named `asteroid_game.py`.\n3. Open a terminal or command prompt, navigate to the directory where the file is located.\n4. Run the game using the command: `python asteroid_game.py`.\n5. Use the `A` key to move left, the `D` key to move right, and the spacebar to shoot.\n\nEnjoy the game!",
    "15": "Here's a full implementation of a simple Boggle game with a command line interface in Python:\n\n```python\nimport random\nimport string\n\nclass Boggle:\n    def __init__(self, size=4):\n        self.size = size\n        self.board = self.generate_board()\n        self.words = set()\n\n    def generate_board(self):\n        letters = string.ascii_uppercase\n        return [[random.choice(letters) for _ in range(self.size)] for _ in range(self.size)]\n\n    def print_board(self):\n        for row in self.board:\n            print(' '.join(row))\n        print()\n\n    def is_valid_word(self, word):\n        return word in self.words\n\n    def add_word(self, word):\n        self.words.add(word.upper())\n\n    def find_words(self, word, visited, x, y):\n        if not (0 <= x < self.size and 0 <= y < self.size):\n            return\n\n        if (x, y) in visited:\n            return\n\n        visited.add((x, y))\n        word += self.board[x][y]\n\n        if len(word) > 2 and self.is_valid_word(word):\n            print(f'Found: {word}')\n        \n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx != 0 or dy != 0:\n                    self.find_words(word, visited.copy(), x + dx, y + dy)\n\n    def search_words(self):\n        for x in range(self.size):\n            for y in range(self.size):\n                self.find_words(\"\", set(), x, y)\n\n    def load_dictionary(self, dictionary_file):\n        with open(dictionary_file, 'r') as f:\n            for line in f:\n                self.add_word(line.strip())\n\ndef main():\n    boggle = Boggle()\n    boggle.load_dictionary('dictionary.txt')  # Ensure you have a dictionary file with words\n    print(\"Boggle Board:\")\n    boggle.print_board()\n    print(\"Searching for words...\")\n    boggle.search_words()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Instructions:\n1. Create a file named `dictionary.txt` in the same directory as your script. This file should contain a list of valid words (one word per line).\n2. Run the script in your command line interface.\n\nThis code creates a simple Boggle game where a 4x4 board of random letters is generated, and it searches for words from a specified dictionary. The game prints the found words directly to the console.",
    "16": "Creating a full implementation of the game Pac-Man in a command line interface is quite an extensive task. Below is a simplified version of the game that captures the basic mechanics. This implementation uses Python for simplicity.\n\n```python\nimport random\nimport os\nimport sys\nimport time\nimport keyboard\n\n# Constants\nWIDTH = 10\nHEIGHT = 10\nNUM_GHOSTS = 3\nNUM_DOTS = 20\n\n# Directions\nUP = (0, -1)\nDOWN = (0, 1)\nLEFT = (-1, 0)\nRIGHT = (1, 0)\nDIRECTIONS = [UP, DOWN, LEFT, RIGHT]\n\nclass Game:\n    def __init__(self):\n        self.pacman_pos = [1, 1]\n        self.dots = self.generate_dots()\n        self.ghosts = self.generate_ghosts()\n        self.score = 0\n        self.is_game_over = False\n\n    def generate_dots(self):\n        dots = set()\n        while len(dots) < NUM_DOTS:\n            pos = (random.randint(0, WIDTH - 1), random.randint(0, HEIGHT - 1))\n            if pos != (1, 1) and pos not in dots:\n                dots.add(pos)\n        return dots\n\n    def generate_ghosts(self):\n        ghosts = set()\n        while len(ghosts) < NUM_GHOSTS:\n            pos = (random.randint(0, WIDTH - 1), random.randint(0, HEIGHT - 1))\n            if pos != (1, 1) and pos not in ghosts:\n                ghosts.add(pos)\n        return ghosts\n\n    def move(self, direction):\n        new_x = self.pacman_pos[0] + direction[0]\n        new_y = self.pacman_pos[1] + direction[1]\n\n        if 0 <= new_x < WIDTH and 0 <= new_y < HEIGHT:\n            self.pacman_pos = [new_x, new_y]\n            self.check_collision()\n\n    def check_collision(self):\n        if tuple(self.pacman_pos) in self.dots:\n            self.dots.remove(tuple(self.pacman_pos))\n            self.score += 1\n        if tuple(self.pacman_pos) in self.ghosts:\n            self.is_game_over = True\n\n    def display(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for y in range(HEIGHT):\n            for x in range(WIDTH):\n                if [x, y] == self.pacman_pos:\n                    print('P', end=' ')\n                elif (x, y) in self.ghosts:\n                    print('G', end=' ')\n                elif (x, y) in self.dots:\n                    print('.', end=' ')\n                else:\n                    print(' ', end=' ')\n            print()\n        print(f\"Score: {self.score}\")\n\n    def play(self):\n        while not self.is_game_over:\n            self.display()\n            time.sleep(0.1)\n            if keyboard.is_pressed('w'):\n                self.move(UP)\n            elif keyboard.is_pressed('s'):\n                self.move(DOWN)\n            elif keyboard.is_pressed('a'):\n                self.move(LEFT)\n            elif keyboard.is_pressed('d'):\n                self.move(RIGHT)\n        print(\"Game Over! Your score was:\", self.score)\n\n\nif __name__ == \"__main__\":\n    game = Game()\n    game.play()\n```\n\n### Instructions to Run:\n1. Make sure you have Python installed on your machine.\n2. Install the `keyboard` library using `pip install keyboard`.\n3. Copy the code into a Python file (e.g., `pacman.py`).\n4. Run the script using `python pacman.py`.\n\n### Controls:\n- Press `W` to move up\n- Press `S` to move down\n",
    "17": "Certainly! Below is a simple implementation of a command-line version of the Dinosaur Runner game in Python. This version uses basic concepts and is designed for beginners.\n\n```python\nimport random\nimport time\nimport os\n\nclass DinosaurRunner:\n    def __init__(self):\n        self.score = 0\n        self.is_running = True\n\n    def clear_screen(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n\n    def display_score(self):\n        print(f\"Score: {self.score}\")\n\n    def jump(self):\n        print(\"Jumping!\")\n        time.sleep(0.5)\n\n    def game_over(self):\n        self.clear_screen()\n        print(\"Game Over!\")\n        print(f\"Final Score: {self.score}\")\n        self.is_running = False\n\n    def check_obstacle(self):\n        # Randomly determine if an obstacle appears\n        return random.choice([True, False])\n\n    def play(self):\n        while self.is_running:\n            self.clear_screen()\n            self.display_score()\n            print(\"Press 'j' to jump or 'q' to quit.\")\n            user_input = input(\"Your action: \")\n\n            if user_input.lower() == 'j':\n                if self.check_obstacle():\n                    print(\"You jumped over an obstacle!\")\n                    self.score += 1\n                else:\n                    print(\"No obstacle to jump over.\")\n                time.sleep(1)\n            elif user_input.lower() == 'q':\n                self.is_running = False\n            else:\n                print(\"Invalid action! Please press 'j' to jump or 'q' to quit.\")\n                time.sleep(1)\n\n            if self.check_obstacle() and random.random() < 0.1:  # 10% chance of hitting an obstacle\n                self.game_over()\n\nif __name__ == \"__main__\":\n    game = DinosaurRunner()\n    game.play()\n```\n\nTo run this code, simply copy and paste it into a Python environment (like an IDE or a text editor) and execute it. The game allows you to jump (by pressing 'j') and will randomly generate obstacles. If you hit an obstacle, the game ends and displays your score. You can quit anytime by pressing 'q'."
}