{
    "0": "```python\ndef print_board(board):\n    \"\"\"Prints the Tic-Tac-Toe board.\"\"\"\n    print(\"-------------\")\n    for i in range(3):\n        print(\"|\", board[i * 3], \"|\", board[i * 3 + 1], \"|\", board[i * 3 + 2], \"|\")\n        print(\"-------------\")\n\n\ndef check_win(board, player):\n    \"\"\"Checks if the player has won the game.\"\"\"\n    # Check rows\n    for i in range(3):\n        if board[i * 3] == board[i * 3 + 1] == board[i * 3 + 2] == player:\n            return True\n\n    # Check columns\n    for i in range(3):\n        if board[i] == board[i + 3] == board[i + 6] == player:\n            return True\n\n    # Check diagonals\n    if board[0] == board[4] == board[8] == player:\n        return True\n    if board[2] == board[4] == board[6] == player:\n        return True\n\n    return False\n\n\ndef check_tie(board):\n    \"\"\"Checks if the game is a tie.\"\"\"\n    return all(cell != \" \" for cell in board)\n\n\ndef get_player_move(board, player):\n    \"\"\"Gets the player's move.\"\"\"\n    while True:\n        try:\n            move = int(input(f\"Player {player}, enter your move (1-9): \")) - 1\n            if 0 <= move <= 8 and board[move] == \" \":\n                return move\n            else:\n                print(\"Invalid move. Try again.\")\n        except ValueError:\n            print(\"Invalid input. Please enter a number between 1 and 9.\")\n\n\ndef play_tic_tac_toe():\n    \"\"\"Plays a game of Tic-Tac-Toe.\"\"\"\n    board = [\" \"] * 9\n    player = \"X\"\n    game_over = False\n\n    while not game_over:\n        print_board(board)\n        move = get_player_move(board, player)\n        board[move] = player\n\n        if check_win(board, player):\n            print_board(board)\n            print(f\"Player {player} wins!\")\n            game_over = True\n        elif check_tie(board):\n            print_board(board)\n            print(\"It's a tie!\")\n            game_over = True\n        else:\n            player = \"O\" if player == \"X\" else \"X\"\n\n\nif __name__ == \"__main__\":\n    print(\"Welcome to Tic-Tac-Toe!\")\n    play_tic_tac_toe()\n```",
    "1": "```python\nimport random\n\ndef choose_word(word_list):\n    \"\"\"Chooses a random word from a list of words.\"\"\"\n    return random.choice(word_list).upper()\n\ndef display_word(word, guessed_letters):\n    \"\"\"Displays the word with correctly guessed letters and underscores for unguessed letters.\"\"\"\n    display = \"\"\n    for letter in word:\n        if letter in guessed_letters:\n            display += letter + \" \"\n        else:\n            display += \"_ \"\n    return display.strip()\n\ndef get_guess(guessed_letters):\n    \"\"\"Gets a valid letter guess from the user.\"\"\"\n    while True:\n        guess = input(\"Guess a letter: \").upper()\n        if len(guess) != 1:\n            print(\"Please enter only one letter.\")\n        elif not guess.isalpha():\n            print(\"Please enter a letter.\")\n        elif guess in guessed_letters:\n            print(\"You already guessed that letter.\")\n        else:\n            return guess\n\ndef play_hangman(word_list):\n    \"\"\"Plays a game of Hangman.\"\"\"\n    word = choose_word(word_list)\n    guessed_letters = set()\n    incorrect_guesses = 0\n    max_incorrect_guesses = 6\n    game_over = False\n\n    print(\"Welcome to Hangman!\")\n    print(display_word(word, guessed_letters))\n\n    while not game_over:\n        guess = get_guess(guessed_letters)\n        guessed_letters.add(guess)\n\n        if guess in word:\n            print(\"Correct!\")\n            display = display_word(word, guessed_letters)\n            print(display)\n\n            if \"_\" not in display:\n                print(\"Congratulations! You guessed the word:\", word)\n                game_over = True\n        else:\n            incorrect_guesses += 1\n            print(\"Incorrect guess.\")\n            print(f\"You have {max_incorrect_guesses - incorrect_guesses} guesses remaining.\")\n\n            if incorrect_guesses >= max_incorrect_guesses:\n                print(\"You ran out of guesses. The word was:\", word)\n                game_over = True\n\n        print()  # Add a newline for better readability\n\n\ndef main():\n    \"\"\"Main function to start the game.\"\"\"\n    word_list = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\", \"fig\", \"grape\", \"honeydew\"]  # Add more words to the list as desired\n\n    while True:\n        play_hangman(word_list)\n\n        play_again = input(\"Play again? (yes/no): \").lower()\n        if play_again != \"yes\":\n            break\n\nif __name__ == \"__main__\":\n    main()\n```",
    "2": "```python\nimport random\n\ndef get_player_choice():\n    \"\"\"Gets the player's choice from the command line.\"\"\"\n    while True:\n        choice = input(\"Choose rock, paper, or scissors: \").lower()\n        if choice in [\"rock\", \"paper\", \"scissors\"]:\n            return choice\n        else:\n            print(\"Invalid choice. Please enter rock, paper, or scissors.\")\n\ndef get_computer_choice():\n    \"\"\"Generates a random choice for the computer.\"\"\"\n    return random.choice([\"rock\", \"paper\", \"scissors\"])\n\ndef determine_winner(player_choice, computer_choice):\n    \"\"\"Determines the winner of the game.\"\"\"\n    print(f\"You chose: {player_choice}\")\n    print(f\"Computer chose: {computer_choice}\")\n\n    if player_choice == computer_choice:\n        return \"It's a tie!\"\n    elif (player_choice == \"rock\" and computer_choice == \"scissors\") or \\\n         (player_choice == \"paper\" and computer_choice == \"rock\") or \\\n         (player_choice == \"scissors\" and computer_choice == \"paper\"):\n        return \"You win!\"\n    else:\n        return \"Computer wins!\"\n\ndef play_again():\n    \"\"\"Asks the player if they want to play again.\"\"\"\n    while True:\n        choice = input(\"Play again? (yes/no): \").lower()\n        if choice in [\"yes\", \"no\"]:\n            return choice == \"yes\"\n        else:\n            print(\"Invalid input. Please enter yes or no.\")\n\ndef main():\n    \"\"\"The main function that runs the game.\"\"\"\n    print(\"Welcome to Rock, Paper, Scissors!\")\n\n    while True:\n        player_choice = get_player_choice()\n        computer_choice = get_computer_choice()\n        result = determine_winner(player_choice, computer_choice)\n        print(result)\n\n        if not play_again():\n            break\n\n    print(\"Thanks for playing!\")\n\nif __name__ == \"__main__\":\n    main()\n```",
    "3": "```python\nimport random\nimport time\nimport os\n\nclass SnakeGame:\n    def __init__(self, width=20, height=10):\n        self.width = width\n        self.height = height\n        self.snake = [(width // 2, height // 2)]  # Initial snake position (as a list of tuples)\n        self.food = self.create_food()\n        self.direction = \"RIGHT\"  # Initial direction\n        self.score = 0\n        self.game_over = False\n\n    def create_food(self):\n        while True:\n            x = random.randint(0, self.width - 1)\n            y = random.randint(0, self.height - 1)\n            if (x, y) not in self.snake:\n                return (x, y)\n\n    def move(self):\n        head_x, head_y = self.snake[0]\n\n        if self.direction == \"UP\":\n            new_head = (head_x, (head_y - 1) % self.height)  # Wrap around\n        elif self.direction == \"DOWN\":\n            new_head = (head_x, (head_y + 1) % self.height)  # Wrap around\n        elif self.direction == \"LEFT\":\n            new_head = ((head_x - 1) % self.width, head_y)  # Wrap around\n        elif self.direction == \"RIGHT\":\n            new_head = ((head_x + 1) % self.width, head_y)  # Wrap around\n\n        if new_head in self.snake:\n            self.game_over = True\n            return\n\n        self.snake.insert(0, new_head)  # Add new head\n\n        if new_head == self.food:\n            self.score += 1\n            self.food = self.create_food()\n        else:\n            self.snake.pop()  # Remove tail if no food eaten\n\n    def change_direction(self, new_direction):\n        if new_direction == \"UP\" and self.direction != \"DOWN\":\n            self.direction = \"UP\"\n        elif new_direction == \"DOWN\" and self.direction != \"UP\":\n            self.direction = \"DOWN\"\n        elif new_direction == \"LEFT\" and self.direction != \"RIGHT\":\n            self.direction = \"LEFT\"\n        elif new_direction == \"RIGHT\" and self.direction != \"LEFT\":\n            self.direction = \"RIGHT\"\n\n    def draw(self):\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the screen\n        print(f\"Score: {self.score}\")\n\n        for y in range(self.height):\n            for x in range(self.width):\n                if (x, y) in self.snake:\n                    print(\"O\", end=\"\")  # Snake body\n                elif (x, y) == self.food:\n                    print(\"F\", end=\"\")  # Food\n                else:\n                    print(\" \", end=\"\")  # Empty space\n            print()\n\n    def play(self):\n        while not self.game_over:\n            self.draw()\n            self.move()\n\n            # Get user input (non-blocking)\n            import select, sys, termios, tty\n            def get_key():\n                fd = sys.stdin.fileno()\n                old_settings = termios.tcgetattr(fd)\n                try:\n",
    "4": "```python\nimport random\n\nclass Minesweeper:\n    def __init__(self, rows, cols, mines):\n        self.rows = rows\n        self.cols = cols\n        self.mines = mines\n        self.board = [[' ' for _ in range(cols)] for _ in range(rows)]\n        self.revealed = [[False for _ in range(cols)] for _ in range(rows)]\n        self.flagged = [[False for _ in range(cols)] for _ in range(rows)]\n        self.mine_positions = self.place_mines()\n        self.calculate_adjacent_mines()\n        self.game_over = False\n        self.won = False\n\n    def place_mines(self):\n        mine_positions = []\n        while len(mine_positions) < self.mines:\n            row = random.randint(0, self.rows - 1)\n            col = random.randint(0, self.cols - 1)\n            if (row, col) not in mine_positions:\n                mine_positions.append((row, col))\n                self.board[row][col] = '*'\n        return mine_positions\n\n    def calculate_adjacent_mines(self):\n        for row in range(self.rows):\n            for col in range(self.cols):\n                if self.board[row][col] != '*':\n                    count = 0\n                    for i in range(max(0, row - 1), min(self.rows, row + 2)):\n                        for j in range(max(0, col - 1), min(self.cols, col + 2)):\n                            if self.board[i][j] == '*':\n                                count += 1\n                    if count > 0:\n                        self.board[row][col] = str(count)\n\n    def print_board(self, show_mines=False):\n        print(\"   \" + \" \".join(str(i) for i in range(self.cols)))\n        print(\"  \" + \"-\" * (2 * self.cols + 1))\n        for row in range(self.rows):\n            row_str = str(row) + \" |\"\n            for col in range(self.cols):\n                if self.flagged[row][col]:\n                    row_str += \"F \"\n                elif self.revealed[row][col]:\n                    row_str += self.board[row][col] + \" \"\n                elif show_mines and self.board[row][col] == '*':\n                    row_str += \"* \"\n                else:\n                    row_str += \". \"\n            print(row_str)\n\n    def reveal(self, row, col):\n        if self.revealed[row][col]:\n            return\n\n        self.revealed[row][col] = True\n\n        if self.board[row][col] == '*':\n            self.game_over = True\n            return\n\n        if self.board[row][col] == ' ':\n            for i in range(max(0, row - 1), min(self.rows, row + 2)):\n                for j in range(max(0, col - 1), min(self.cols, col + 2)):\n                    if not self.revealed[i][j]:\n                        self.reveal(i, j)\n\n    def flag(self, row, col):\n        if self.revealed[row][col]:\n            print(\"Cannot flag a revealed cell.\")\n            return\n        self.flagged[row][col",
    "5": "```python\nimport random\n\ndef generate_secret_code(code_length=4, num_colors=6):\n    \"\"\"Generates a secret code with specified length and number of colors.\"\"\"\n    return [random.randint(1, num_colors) for _ in range(code_length)]\n\ndef get_user_guess(code_length=4, num_colors=6):\n    \"\"\"Gets a valid guess from the user.\"\"\"\n    while True:\n        guess_str = input(f\"Enter your guess (length {code_length}, colors 1-{num_colors}, separated by spaces): \")\n        try:\n            guess = [int(x) for x in guess_str.split()]\n            if len(guess) != code_length:\n                print(f\"Invalid guess length.  Must be {code_length}.\")\n            elif any(x < 1 or x > num_colors for x in guess):\n                print(f\"Invalid color. Colors must be between 1 and {num_colors}.\")\n            else:\n                return guess\n        except ValueError:\n            print(\"Invalid input.  Please enter numbers separated by spaces.\")\n\ndef calculate_feedback(secret_code, guess):\n    \"\"\"Calculates the feedback for a guess.\"\"\"\n    correct_position = 0\n    correct_color = 0\n    temp_secret = secret_code[:]  # Create a copy to avoid modifying the original\n    temp_guess = guess[:]\n\n    # Check for correct positions first\n    for i in range(len(secret_code)):\n        if temp_secret[i] == temp_guess[i]:\n            correct_position += 1\n            temp_secret[i] = None  # Mark as matched\n            temp_guess[i] = None  # Mark as matched\n\n    # Check for correct colors in the wrong positions\n    for i in range(len(secret_code)):\n        if temp_guess[i] is not None:  # Only check unmatched colors\n            if temp_guess[i] in temp_secret:\n                correct_color += 1\n                temp_secret[temp_secret.index(temp_guess[i])] = None  # Mark as matched\n\n    return correct_position, correct_color\n\ndef play_mastermind(code_length=4, num_colors=6, max_attempts=10):\n    \"\"\"Plays a game of Mastermind.\"\"\"\n    secret_code = generate_secret_code(code_length, num_colors)\n    attempts = 0\n\n    print(\"Welcome to Mastermind!\")\n    print(f\"I've generated a secret code with {code_length} colors (1-{num_colors}).\")\n    print(f\"You have {max_attempts} attempts to guess the code.\")\n\n    while attempts < max_attempts:\n        attempts += 1\n        print(f\"\\nAttempt {attempts}:\")\n        guess = get_user_guess(code_length, num_colors)\n        correct_position, correct_color = calculate_feedback(secret_code, guess)\n\n        print(f\"Feedback: {correct_position} correct position(s), {correct_color} correct color(s)\")\n\n        if correct_position == code_length:\n            print(f\"Congratulations! You guessed the code in {attempts} attempts.\")\n            return\n\n    print(f\"\\nYou ran out of attempts. The secret code was: {secret_code}\")\n\nif __name__ == \"__main__\":\n    play_mastermind()\n```",
    "6": "```python\nimport random\n\ndef create_board(size):\n    \"\"\"Creates an empty game board.\"\"\"\n    return [['.' for _ in range(size)] for _ in range(size)]\n\ndef print_board(board, show_ships=False):\n    \"\"\"Prints the game board to the console.\"\"\"\n    size = len(board)\n    print(\"  \" + \" \".join(str(i) for i in range(size)))\n    for i in range(size):\n        row_str = str(i) + \" \"\n        for j in range(size):\n            if board[i][j] == 'S' and not show_ships:\n                row_str += \". \"\n            else:\n                row_str += board[i][j] + \" \"\n        print(row_str)\n\ndef place_ships(board, ships):\n    \"\"\"Places ships randomly on the board.\"\"\"\n    size = len(board)\n    for ship_length in ships:\n        while True:\n            orientation = random.choice(['horizontal', 'vertical'])\n            if orientation == 'horizontal':\n                row = random.randint(0, size - 1)\n                col = random.randint(0, size - ship_length)\n                if all(board[row][col + i] == '.' for i in range(ship_length)):\n                    for i in range(ship_length):\n                        board[row][col + i] = 'S'\n                    break\n            else:  # vertical\n                row = random.randint(0, size - ship_length)\n                col = random.randint(0, size - 1)\n                if all(board[row + i][col] == '.' for i in range(ship_length)):\n                    for i in range(ship_length):\n                        board[row + i][col] = 'S'\n                    break\n\ndef get_player_move(board_size):\n    \"\"\"Gets the player's move from the console.\"\"\"\n    while True:\n        try:\n            move_str = input(\"Enter your move (row, col): \")\n            row, col = map(int, move_str.split(','))\n            if 0 <= row < board_size and 0 <= col < board_size:\n                return row, col\n            else:\n                print(\"Invalid coordinates. Try again.\")\n        except ValueError:\n            print(\"Invalid input.  Enter coordinates as 'row,col'.\")\n\ndef update_board(board, row, col):\n    \"\"\"Updates the board based on the player's move.\"\"\"\n    if board[row][col] == 'S':\n        board[row][col] = 'X'  # Hit\n        return True\n    elif board[row][col] == '.':\n        board[row][col] = 'O'  # Miss\n        return False\n    else:\n        print(\"You already attacked that location. Try again.\")\n        return None\n\ndef check_win(board):\n    \"\"\"Checks if all ships have been sunk.\"\"\"\n    for row in board:\n        if 'S' in row:\n            return False\n    return True\n\ndef play_battleship():\n    \"\"\"Plays the Battleship game.\"\"\"\n    board_size = 8\n    ships = [5, 4, 3, 3, 2]  # Sizes of the ships\n\n    player_board = create_board(board_size)\n    computer_board = create_board(board_size)\n\n    place_ships(computer_board, ships)\n    place_ships(player_",
    "7": "```python\nimport argparse\nimport os\nimport random\nimport time\n\n\nclass GameOfLife:\n    def __init__(self, width, height, initial_state=None, seed=None):\n        self.width = width\n        self.height = height\n        self.grid = self.create_grid(initial_state, seed)\n\n    def create_grid(self, initial_state=None, seed=None):\n        if initial_state:\n            if len(initial_state) != self.height or any(\n                len(row) != self.width for row in initial_state\n            ):\n                raise ValueError(\n                    \"Initial state dimensions do not match specified width and height.\"\n                )\n            return [list(row) for row in initial_state]\n\n        if seed is not None:\n            random.seed(seed)\n\n        return [\n            [random.choice([0, 1]) for _ in range(self.width)]\n            for _ in range(self.height)\n        ]\n\n    def get_neighbors(self, row, col):\n        neighbors = []\n        for i in range(max(0, row - 1), min(self.height, row + 2)):\n            for j in range(max(0, col - 1), min(self.width, col + 2)):\n                if (i, j) != (row, col):\n                    neighbors.append(self.grid[i][j])\n        return neighbors\n\n    def update_cell(self, row, col):\n        neighbors = self.get_neighbors(row, col)\n        live_neighbors = sum(neighbors)\n        cell_state = self.grid[row][col]\n\n        if cell_state == 1:  # Alive\n            if live_neighbors < 2 or live_neighbors > 3:\n                return 0  # Dies\n            else:\n                return 1  # Stays alive\n        else:  # Dead\n            if live_neighbors == 3:\n                return 1  # Becomes alive\n            else:\n                return 0  # Stays dead\n\n    def update_grid(self):\n        new_grid = [\n            [self.update_cell(row, col) for col in range(self.width)]\n            for row in range(self.height)\n        ]\n        self.grid = new_grid\n\n    def display_grid(self, generation, clear_screen=True):\n        if clear_screen:\n            os.system(\"cls\" if os.name == \"nt\" else \"clear\")  # Clear the screen\n        print(f\"Generation: {generation}\")\n        for row in self.grid:\n            print(\"\".join([\"#\" if cell == 1 else \" \" for cell in row]))\n\n    def run_simulation(self, generations, delay=0.1, clear_screen=True):\n        for generation in range(generations):\n            self.display_grid(generation, clear_screen)\n            self.update_grid()\n            time.sleep(delay)\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description=\"Conway's Game of Life simulation.\"\n    )\n    parser.add_argument(\n        \"--width\", type=int, default=60, help=\"Width of the grid (default: 60)\"\n    )\n    parser.add_argument(\n        \"--height\", type=int, default=30, help=\"Height of the grid (default: 30)\"\n    )\n    parser.add_argument",
    "8": "```python\ndef create_board(rows=6, cols=7):\n    \"\"\"Creates an empty Connect Four board.\"\"\"\n    return [[\" \" for _ in range(cols)] for _ in range(rows)]\n\n\ndef print_board(board):\n    \"\"\"Prints the Connect Four board to the console.\"\"\"\n    for row in reversed(board):\n        print(\"|\" + \"|\".join(row) + \"|\")\n    print(\"-\" * (len(board[0]) * 2 + 1))\n    print(\" \" + \" \".join(str(i + 1) for i in range(len(board[0]))))\n\n\ndef is_valid_move(board, col):\n    \"\"\"Checks if a move is valid (column is within bounds and not full).\"\"\"\n    return 0 <= col < len(board[0]) and board[0][col] == \" \"\n\n\ndef drop_piece(board, col, player):\n    \"\"\"Drops a piece into the specified column.\"\"\"\n    for row in range(len(board)):\n        if board[row][col] == \" \":\n            board[row][col] = player\n            return\n\n\ndef check_win(board, player):\n    \"\"\"Checks if the specified player has won.\"\"\"\n    rows = len(board)\n    cols = len(board[0])\n\n    # Check horizontal\n    for row in range(rows):\n        for col in range(cols - 3):\n            if (\n                board[row][col] == player\n                and board[row][col + 1] == player\n                and board[row][col + 2] == player\n                and board[row][col + 3] == player\n            ):\n                return True\n\n    # Check vertical\n    for row in range(rows - 3):\n        for col in range(cols):\n            if (\n                board[row][col] == player\n                and board[row + 1][col] == player\n                and board[row + 2][col] == player\n                and board[row + 3][col] == player\n            ):\n                return True\n\n    # Check positive diagonal\n    for row in range(rows - 3):\n        for col in range(cols - 3):\n            if (\n                board[row][col] == player\n                and board[row + 1][col + 1] == player\n                and board[row + 2][col + 2] == player\n                and board[row + 3][col + 3] == player\n            ):\n                return True\n\n    # Check negative diagonal\n    for row in range(3, rows):\n        for col in range(cols - 3):\n            if (\n                board[row][col] == player\n                and board[row - 1][col + 1] == player\n                and board[row - 2][col + 2] == player\n                and board[row - 3][col + 3] == player\n            ):\n                return True\n\n    return False\n\n\ndef is_board_full(board):\n    \"\"\"Checks if the board is full.\"\"\"\n    for col in range(len(board[0])):\n        if board[len(board) - 1][col] == \" \":\n            return False\n    return True\n\n\ndef play_connect_four():\n    \"\"\"Main function to play the Connect Four game.\"\"\"\n    board = create_board()\n    player1 = \"X\"\n    player2 = \"O\"\n    current_player = player1\n    game_over = False\n\n    print(\"Welcome to",
    "9": "```python\nimport random\n\ndef calculate_hand_value(hand):\n    \"\"\"Calculates the value of a hand in Blackjack.  Aces can be 1 or 11.\"\"\"\n    ace_count = hand.count('A')\n    total = 0\n    for card in hand:\n        if card.isdigit():\n            total += int(card)\n        elif card in ('J', 'Q', 'K'):\n            total += 10\n        elif card == 'A':\n            total += 11  # Initially treat Ace as 11\n    while total > 21 and ace_count > 0:\n        total -= 10\n        ace_count -= 1\n    return total\n\ndef deal_card(deck):\n    \"\"\"Deals a card from the deck.\"\"\"\n    return deck.pop()\n\ndef create_deck():\n    \"\"\"Creates a standard 52-card deck.\"\"\"\n    suits = ['Hearts', 'Diamonds', 'Clubs', 'Spades']\n    ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']\n    deck = [rank for suit in suits for rank in ranks] * 4  # Use 4 decks for better shuffling\n    random.shuffle(deck)\n    return deck\n\ndef display_hand(hand, hidden=False):\n    \"\"\"Displays a hand of cards.\"\"\"\n    if hidden:\n        print(\"[Hidden Card]\", end=\" \")\n        for card in hand[1:]:\n            print(card, end=\" \")\n    else:\n        for card in hand:\n            print(card, end=\" \")\n    print()\n\ndef play_blackjack():\n    \"\"\"Plays a game of Blackjack.\"\"\"\n    deck = create_deck()\n    player_hand = []\n    dealer_hand = []\n\n    # Initial deal\n    for _ in range(2):\n        player_hand.append(deal_card(deck))\n        dealer_hand.append(deal_card(deck))\n\n    print(\"\\n--- Blackjack ---\")\n    print(\"Dealer's hand:\", end=\" \")\n    display_hand(dealer_hand, hidden=True) # Hide dealer's first card\n    print(\"Your hand:\", end=\" \")\n    display_hand(player_hand)\n    player_value = calculate_hand_value(player_hand)\n    dealer_value = calculate_hand_value(dealer_hand)\n    print(\"Your hand value:\", player_value)\n\n    # Player's turn\n    while player_value < 21:\n        action = input(\"Hit or stand? (h/s): \").lower()\n        if action == 'h':\n            player_hand.append(deal_card(deck))\n            print(\"Your hand:\", end=\" \")\n            display_hand(player_hand)\n            player_value = calculate_hand_value(player_hand)\n            print(\"Your hand value:\", player_value)\n            if player_value > 21:\n                print(\"Bust! You lose.\")\n                return\n        elif action == 's':\n            break\n        else:\n            print(\"Invalid input. Please enter 'h' or 's'.\")\n\n    # Dealer's turn\n    if player_value <= 21:\n        print(\"\\nDealer's hand:\", end=\" \")\n        display_hand(dealer_hand)\n        print(\"Dealer's hand value:\", dealer_value)\n        while dealer_value < 17:\n            print",
    "10": "```python\nimport random\n\ndef hammurabi():\n    \"\"\"\n    A text-based implementation of the classic game Hammurabi.\n    \"\"\"\n\n    year = 1\n    population = 100\n    grain_stores = 2800\n    acres_owned = 1000\n    acres_price = 19  # Initial price of land\n    starved = 0\n    immigrants = 0\n    harvest = 0\n\n    print(\"Congratulations, you are the newly appointed ruler of ancient Sumer,\\n\"\n          \"responsible for managing farmland, feeding the population, and making\\n\"\n          \"long-term decisions for the prosperity of your kingdom.\\n\")\n\n    def summary():\n        print(\"\\nO great Hammurabi!\")\n        print(f\"You are in year {year} of your ten-year rule.\")\n        print(f\"  {starved} people starved in the previous year.\")\n        print(f\"  {immigrants} people came to the city.\")\n        print(f\"  The city population is now {population}.\")\n        print(f\"  You own {acres_owned} acres of land.\")\n        print(f\"  You harvested {harvest} bushels of grain per acre.\")\n        print(f\"  You have {grain_stores} bushels in store.\")\n        print(f\"  Land is trading at {acres_price} bushels per acre.\")\n\n    def plague():\n        \"\"\"Simulates a plague that can affect the population.\"\"\"\n        if random.random() < 0.15:  # 15% chance of plague\n            deaths = int(population * random.uniform(0.15, 0.45))\n            population -= deaths\n            print(f\"\\nA horrible plague struck! {deaths} people died.\")\n            return True\n        return False\n\n    def rats():\n        \"\"\"Simulates a rat infestation that eats grain.\"\"\"\n        if random.random() < 0.4:  # 40% chance of rats\n            eaten = int(grain_stores * random.uniform(0.1, 0.3))\n            grain_stores -= eaten\n            print(f\"\\nRats consumed {eaten} bushels of grain!\")\n            return eaten\n        return 0\n\n    def harvest_yield():\n        \"\"\"Calculates the harvest yield per acre, affected by randomness.\"\"\"\n        return random.randint(1, 8)  # Yield varies between 1 and 8 bushels per acre\n\n    def price_of_land():\n        \"\"\"Determines the price of land based on previous harvest.\"\"\"\n        return random.randint(17, 26) # Price between 17 and 26\n\n    def grain_required():\n        \"\"\"Calculates the amount of grain required to feed the population.\"\"\"\n        return population * 20\n\n    for year in range(1, 11):\n        summary()\n\n        # Plague Check\n        if plague():\n            if population <= 0:\n                print(\"\\nYour entire population has died. Your rule is over.\")\n                return\n            continue  # Skip the rest of the year's events\n        \n        # Land Transactions\n        while True:\n            try:\n                buy_sell = input(\"How many acres do you wish to buy/sell? (Enter a negative number to sell): \")\n                acres_to_trade = int(buy_sell)\n                \n                if acres_to_trade > 0:  # Buying land\n                    cost = acres_to_trade * acres_price\n                    if cost > grain_stores:\n                        print(\"O Hamm",
    "11": "```python\nimport random\n\nclass LightsOut:\n    def __init__(self, size=5, initial_state=None):\n        \"\"\"\n        Initializes the Lights Out game.\n\n        Args:\n            size: The size of the board (size x size).  Defaults to 5.\n            initial_state:  Optional. A 2D list of booleans representing the initial state.\n                           If None, a random initial state is generated.\n        \"\"\"\n        self.size = size\n        if initial_state is None:\n            self.board = self.generate_random_board()\n        else:\n            self.board = initial_state\n        self.moves = 0\n\n    def generate_random_board(self):\n        \"\"\"Generates a random initial board state.\"\"\"\n        board = [[random.choice([True, False]) for _ in range(self.size)] for _ in range(self.size)]\n        return board\n\n    def print_board(self):\n        \"\"\"Prints the current state of the board.\"\"\"\n        for row in self.board:\n            print(\" \".join([\"*\" if cell else \".\" for cell in row]))\n        print(f\"Moves: {self.moves}\")\n\n    def toggle_cell(self, row, col):\n        \"\"\"Toggles the state of a cell.\"\"\"\n        if 0 <= row < self.size and 0 <= col < self.size:\n            self.board[row][col] = not self.board[row][col]\n\n    def press_button(self, row, col):\n        \"\"\"Presses a button and toggles the cell and its neighbors.\"\"\"\n        self.toggle_cell(row, col)\n        self.toggle_cell(row - 1, col)  # Up\n        self.toggle_cell(row + 1, col)  # Down\n        self.toggle_cell(row, col - 1)  # Left\n        self.toggle_cell(row, col + 1)  # Right\n        self.moves += 1\n\n    def is_solved(self):\n        \"\"\"Checks if the game is solved (all lights are off).\"\"\"\n        return all(not cell for row in self.board for cell in row)\n\n    def play(self):\n        \"\"\"Plays the game until it is solved.\"\"\"\n        while not self.is_solved():\n            self.print_board()\n            try:\n                row, col = map(int, input(\"Enter row and column (e.g., 0 0): \").split())\n                if not (0 <= row < self.size and 0 <= col < self.size):\n                    print(\"Invalid row or column. Try again.\")\n                    continue\n                self.press_button(row, col)\n            except ValueError:\n                print(\"Invalid input. Please enter two integers separated by a space.\")\n            except KeyboardInterrupt:\n                print(\"\\nGame interrupted.  Exiting.\")\n                return\n\n        self.print_board()\n        print(f\"Congratulations! You solved the puzzle in {self.moves} moves.\")\n\n\n\nif __name__ == \"__main__\":\n    print(\"Welcome to Lights Out!\")\n    size = 5\n    try:\n        size = int(input(\"Enter the size of the board (default is 5): \") or 5)\n        if size <= 0:\n            print(\"Board size must be a positive integer. Using default size 5.\")\n            size = 5\n    except ValueError:\n        print(\"Invalid input. Using default size 5.\")\n        size = 5\n\n    game = LightsOut",
    "12": "```python\nimport time\nimport random\nimport os\n\nclass Pong:\n    def __init__(self, width=60, height=20, paddle_length=3, max_speed=2):\n        self.width = width\n        self.height = height\n        self.paddle_length = paddle_length\n        self.max_speed = max_speed\n        self.paddle1_pos = self.height // 2 - self.paddle_length // 2\n        self.paddle2_pos = self.height // 2 - self.paddle_length // 2\n        self.ball_x = self.width // 2\n        self.ball_y = self.height // 2\n        self.ball_dx = random.choice([-1, 1])\n        self.ball_dy = random.uniform(-0.5, 0.5)\n        self.score1 = 0\n        self.score2 = 0\n        self.running = True\n\n    def update(self):\n        # Move paddles\n        if self.paddle1_move == \"up\":\n            self.paddle1_pos = max(0, self.paddle1_pos - 1)\n        elif self.paddle1_move == \"down\":\n            self.paddle1_pos = min(self.height - self.paddle_length, self.paddle1_pos + 1)\n\n        if self.paddle2_move == \"up\":\n            self.paddle2_pos = max(0, self.paddle2_pos - 1)\n        elif self.paddle2_move == \"down\":\n            self.paddle2_pos = min(self.height - self.paddle_length, self.paddle2_pos + 1)\n\n        # Move ball\n        self.ball_x += self.ball_dx\n        self.ball_y += self.ball_dy\n\n        # Bounce off top and bottom\n        if self.ball_y <= 0 or self.ball_y >= self.height - 1:\n            self.ball_dy *= -1\n\n        # Paddle collisions\n        if self.ball_x <= 1 and self.paddle1_pos <= self.ball_y <= self.paddle1_pos + self.paddle_length - 1:\n            self.ball_dx *= -1\n            self.ball_dx = min(self.max_speed, self.ball_dx * 1.1)  # Increase speed\n            self.ball_dy += random.uniform(-0.3, 0.3) # Add some randomness\n\n        if self.ball_x >= self.width - 2 and self.paddle2_pos <= self.ball_y <= self.paddle2_pos + self.paddle_length - 1:\n            self.ball_dx *= -1\n            self.ball_dx = max(-self.max_speed, self.ball_dx * 1.1) #Increase speed\n            self.ball_dy += random.uniform(-0.3, 0.3) # Add some randomness\n\n        # Scoring\n        if self.ball_x < 0:\n            self.score2 += 1\n            self.reset_ball()\n        elif self.ball_x >= self.width:\n            self.score1 += 1\n            self.reset_ball()\n\n        # Check for game over (optional)\n        if self.score1 >= 10 or self.score2 >= 10:\n            self.running = False\n\n\n    def reset_ball(self):\n        ",
    "13": "```python\nimport random\nimport time\nimport os\n\n# Constants\nGRID_WIDTH = 10\nGRID_HEIGHT = 20\nTETROMINOS = {\n    'I': [[1, 1, 1, 1]],\n    'O': [[1, 1], [1, 1]],\n    'T': [[0, 1, 0], [1, 1, 1]],\n    'S': [[0, 1, 1], [1, 1, 0]],\n    'Z': [[1, 1, 0], [0, 1, 1]],\n    'J': [[1, 0, 0], [1, 1, 1]],\n    'L': [[0, 0, 1], [1, 1, 1]]\n}\nCOLORS = {\n    'I': 96,  # Cyan\n    'O': 93,  # Yellow\n    'T': 95,  # Magenta\n    'S': 92,  # Green\n    'Z': 91,  # Red\n    'J': 94,  # Blue\n    'L': 91  # Orange\n}\n\ndef clear_screen():\n    os.system('cls' if os.name == 'nt' else 'clear')\n\ndef create_grid():\n    return [[0] * GRID_WIDTH for _ in range(GRID_HEIGHT)]\n\ndef print_grid(grid):\n    for row in grid:\n        line = \"\"\n        for cell in row:\n            if cell == 0:\n                line += \". \"\n            else:\n                line += f\"\\033[{COLORS[cell]}m[]\\033[0m\" + \" \"\n        print(line)\n\ndef generate_tetromino():\n    tetromino_type = random.choice(list(TETROMINOS.keys()))\n    tetromino = TETROMINOS[tetromino_type]\n    color = tetromino_type\n    return tetromino, color\n\ndef rotate_tetromino(tetromino):\n    rows = len(tetromino)\n    cols = len(tetromino[0])\n    rotated_tetromino = [[0] * rows for _ in range(cols)]\n    for i in range(rows):\n        for j in range(cols):\n            rotated_tetromino[j][rows - 1 - i] = tetromino[i][j]\n    return rotated_tetromino\n\ndef is_valid_move(grid, tetromino, offset_x, offset_y):\n    rows = len(tetromino)\n    cols = len(tetromino[0])\n\n    for i in range(rows):\n        for j in range(cols):\n            if tetromino[i][j] != 0:\n                grid_x = offset_x + j\n                grid_y = offset_y + i\n\n                if grid_x < 0 or grid_x >= GRID_WIDTH or grid_y >= GRID_HEIGHT:\n                    return False\n                if grid_y >= 0 and grid[grid_y][grid_x] != 0:\n                    return False\n\n    return True\n\ndef place_tetromino(grid, tetromino, offset_x, offset_y, color):\n    rows = len(tetromino)\n    cols = len(tetromino[0])\n\n    for i in range(rows):\n        for j in range(cols):\n            if tetromino[i][j] != 0:\n                grid[offset_y + i][offset_x",
    "14": "```python\nimport math\nimport random\nimport time\n\n\nclass GameObject:\n    def __init__(self, x, y, velocity_x, velocity_y, angle=0):\n        self.x = x\n        self.y = y\n        self.velocity_x = velocity_x\n        self.velocity_y = velocity_y\n        self.angle = angle\n\n    def update(self):\n        self.x += self.velocity_x\n        self.y += self.velocity_y\n\n    def wrap_around(self, width, height):\n        if self.x < 0:\n            self.x = width\n        elif self.x > width:\n            self.x = 0\n        if self.y < 0:\n            self.y = height\n        elif self.y > height:\n            self.y = 0\n\n\nclass Spaceship(GameObject):\n    TURN_SPEED = 5\n    ACCELERATION = 0.2\n\n    def __init__(self, x, y):\n        super().__init__(x, y, 0, 0)\n        self.width = 3\n        self.height = 5\n\n    def accelerate(self):\n        self.velocity_x += math.cos(math.radians(self.angle)) * self.ACCELERATION\n        self.velocity_y += math.sin(math.radians(self.angle)) * self.ACCELERATION\n\n    def turn_left(self):\n        self.angle -= self.TURN_SPEED\n\n    def turn_right(self):\n        self.angle += self.TURN_SPEED\n\n    def fire(self):\n        bullet_x = self.x + math.cos(math.radians(self.angle)) * (self.width + 1)\n        bullet_y = self.y + math.sin(math.radians(self.angle)) * (self.height + 1)\n        bullet_velocity_x = self.velocity_x + math.cos(math.radians(self.angle)) * 5\n        bullet_velocity_y = self.velocity_y + math.sin(math.radians(self.angle)) * 5\n        return Bullet(bullet_x, bullet_y, bullet_velocity_x, bullet_velocity_y, self.angle)\n\n    def draw(self, width, height):\n        points = [\n            (self.x + math.cos(math.radians(self.angle)) * (self.height + 1), self.y + math.sin(math.radians(self.angle)) * (self.height + 1)),\n            (self.x + math.cos(math.radians(self.angle + 120)) * self.height, self.y + math.sin(math.radians(self.angle + 120)) * self.height),\n            (self.x + math.cos(math.radians(self.angle - 120)) * self.height, self.y + math.sin(math.radians(self.angle - 120)) * self.height),\n        ]\n\n        # Simple ASCII representation\n        rows = [[' ' for _ in range(width)] for _ in range(height)]\n        for i in range(len(points)):\n            x1, y1 = int(points[i][0]), int(points[i][1])\n            x2, y2 = int(points[(i + 1) % len(points)][0]), int(points[(i + 1) % len(points)][1])\n",
    "15": "```python\nimport random\nimport time\n\n# Constants\nGRID_SIZE = 4\nMIN_WORD_LENGTH = 3\nTIME_LIMIT = 180  # seconds\n\n# Word list (you can replace this with a more comprehensive dictionary)\nWORD_LIST = set([\n    \"cat\", \"dog\", \"run\", \"sun\", \"sky\", \"eat\", \"sleep\", \"play\", \"jump\", \"sing\",\n    \"dance\", \"swim\", \"read\", \"write\", \"code\", \"game\", \"word\", \"time\", \"life\",\n    \"love\", \"hate\", \"hope\", \"fear\", \"joy\", \"sad\", \"tree\", \"bird\", \"fish\", \"star\",\n    \"moon\", \"rain\", \"snow\", \"wind\", \"fire\", \"earth\", \"water\", \"light\", \"dark\",\n    \"music\", \"art\", \"book\", \"desk\", \"chair\", \"house\", \"road\", \"town\", \"city\",\n    \"world\", \"name\", \"idea\", \"plan\", \"goal\", \"help\", \"stop\", \"start\", \"wait\",\n    \"look\", \"feel\", \"think\", \"know\", \"find\", \"give\", \"take\", \"make\", \"have\",\n    \"want\", \"need\", \"use\", \"see\", \"hear\", \"speak\", \"walk\", \"come\", \"turn\",\n    \"open\", \"close\", \"send\", \"keep\", \"leave\", \"begin\", \"end\", \"show\", \"hide\",\n    \"true\", \"false\", \"right\", \"wrong\", \"good\", \"bad\", \"easy\", \"hard\", \"fast\",\n    \"slow\", \"long\", \"short\", \"high\", \"low\", \"big\", \"small\", \"new\", \"old\",\n    \"near\", \"far\", \"here\", \"there\", \"this\", \"that\", \"some\", \"many\", \"all\",\n    \"none\", \"other\", \"first\", \"last\", \"each\", \"every\", \"one\", \"two\", \"few\",\n    \"more\", \"less\", \"same\", \"than\", \"then\", \"when\", \"where\", \"why\", \"how\",\n    \"who\", \"what\", \"which\", \"whose\", \"they\", \"them\", \"their\", \"ours\", \"hers\",\n    \"mine\", \"yours\", \"him\", \"her\", \"its\", \"our\", \"your\", \"his\", \"the\", \"a\",\n    \"an\", \"and\", \"but\", \"for\", \"nor\", \"or\", \"so\", \"yet\", \"about\", \"above\",\n    \"across\", \"after\", \"again\", \"against\", \"along\", \"among\", \"around\", \"as\",\n    \"at\", \"before\", \"behind\", \"below\", \"beside\", \"between\", \"beyond\", \"by\",\n    \"down\", \"during\", \"except\", \"from\", \"in\", \"inside\", \"into\", \"like\", \"of\",\n    \"off\", \"on\", \"onto\", \"out\", \"outside\", \"over\", \"past\", \"since\", \"through\",\n    \"to\", \"toward\", \"under\", \"until\", \"up\", \"upon\", \"with\", \"within\", \"without\"\n])\n\n# Function to generate a random Boggle board\ndef generate_board():\n    dice = [\n        \"RIFOBX\", \"IFEHEE\", \"LPTTDS\", \"XEEIHN\", \"AFSIRSY\",\n        \"DSOANT\", \"AAAAEE\", \"SOTNDN\", \"OOBJOBA\", \"HIMOQT\",\n        \"ESTIIN\", \"VWRIL",
    "16": "```python\nimport random\nimport time\nimport os\n\nclass PacManGame:\n    def __init__(self, width=20, height=10):\n        self.width = width\n        self.height = height\n        self.pacman_x = width // 2\n        self.pacman_y = height // 2\n        self.ghost_x = random.randint(1, width - 2)\n        self.ghost_y = random.randint(1, height - 2)\n        self.food = set()\n        for x in range(1, width - 1):\n            for y in range(1, height - 1):\n                self.food.add((x, y))\n        self.food.discard((self.pacman_x, self.pacman_y))\n        self.food.discard((self.ghost_x, self.ghost_y))\n        self.score = 0\n        self.game_over = False\n\n    def display(self):\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the screen\n        grid = [['#' for _ in range(self.width)] for _ in range(self.height)]\n\n        for x in range(1, self.width - 1):\n            for y in range(1, self.height - 1):\n                grid[y][x] = ' '\n\n        for x, y in self.food:\n            grid[y][x] = '.'\n\n        grid[self.pacman_y][self.pacman_x] = 'P'\n        grid[self.ghost_y][self.ghost_x] = 'G'\n\n        for row in grid:\n            print(''.join(row))\n\n        print(f\"Score: {self.score}\")\n\n    def move_pacman(self, direction):\n        new_x = self.pacman_x\n        new_y = self.pacman_y\n\n        if direction == 'w':\n            new_y -= 1\n        elif direction == 's':\n            new_y += 1\n        elif direction == 'a':\n            new_x -= 1\n        elif direction == 'd':\n            new_x += 1\n\n        if 0 < new_x < self.width - 1 and 0 < new_y < self.height - 1:\n            self.pacman_x = new_x\n            self.pacman_y = new_y\n\n            if (self.pacman_x, self.pacman_y) in self.food:\n                self.food.remove((self.pacman_x, self.pacman_y))\n                self.score += 1\n\n    def move_ghost(self):\n        possible_moves = []\n        if 0 < self.ghost_x + 1 < self.width - 1:\n            possible_moves.append((self.ghost_x + 1, self.ghost_y))\n        if 0 < self.ghost_x - 1 < self.width - 1:\n            possible_moves.append((self.ghost_x - 1, self.ghost_y))\n        if 0 < self.ghost_y + 1 < self.height - 1:\n            possible_moves.append((self.ghost_x, self.ghost_y + 1))\n        if 0 < self.ghost_y - 1 < self.height - 1:\n            possible_moves.append((",
    "17": "```python\nimport time\nimport random\nimport os\n\nclass DinosaurRunner:\n    def __init__(self):\n        self.dino_position = 0\n        self.obstacle_position = 20\n        self.obstacle_type = self.generate_obstacle_type()\n        self.score = 0\n        self.game_over = False\n        self.speed = 1\n\n    def generate_obstacle_type(self):\n        return random.choice(['cactus', 'bird'])\n\n    def generate_obstacle_position(self):\n        return random.randint(20, 30)\n\n    def update(self):\n        if self.game_over:\n            return\n\n        self.obstacle_position -= self.speed\n        if self.obstacle_position < 0:\n            self.obstacle_position = self.generate_obstacle_position()\n            self.obstacle_type = self.generate_obstacle_type()\n            self.score += 1\n            self.speed = min(5, self.speed + 0.1) # Gradually increase speed\n        \n        if self.check_collision():\n            self.game_over = True\n\n    def check_collision(self):\n        if self.obstacle_type == 'cactus':\n            if self.obstacle_position <= self.dino_position + 2 and self.obstacle_position >= self.dino_position:\n                return True\n        elif self.obstacle_type == 'bird':\n            if self.obstacle_position <= self.dino_position + 2 and self.obstacle_position >= self.dino_position and self.dino_position < 1: # Bird is at a higher position, only collide if dino is not jumping\n                return True\n        return False\n\n    def jump(self):\n        if self.game_over:\n            return\n        self.dino_position = 1 #Dino jumps to position 1\n\n    def duck(self):\n        if self.game_over:\n            return\n        self.dino_position = -1 #Dino ducks to position -1\n\n    def reset_position(self):\n        if self.game_over:\n            self.dino_position = 0 #Resets dino to original position after game over\n            return\n\n    def draw(self):\n        if self.game_over:\n            print(\"Game Over! Score:\", self.score)\n            return\n        \n        # Clear the screen\n        os.system('cls' if os.name == 'nt' else 'clear')\n\n        # Draw the game\n        ground = ['-'] * 30\n        \n        # Draw Dino\n        if self.dino_position == 0:\n            ground[self.dino_position] = 'D'\n            ground[self.dino_position + 1] = '>'\n        elif self.dino_position == 1:\n            ground[self.dino_position] = '^'\n            ground[self.dino_position + 1] = 'D'\n        elif self.dino_position == -1:\n            ground[self.dino_position + 1] = 'd'\n            ground[self.dino_position + 2] = '>'\n\n        # Draw Obstacle\n        if self.obstacle_type == 'cactus':\n            ground[self.obstacle_position] = '|'\n            ground[self.obstacle_position + 1] = '|'\n        elif self.obstacle_type == 'bird':\n            ground[self.obstacle_position"
}