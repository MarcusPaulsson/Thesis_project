{
    "86": "```python\ndef solve():\n  n, k = map(int, input().split())\n\n  if k * (k + 1) // 2 > n:\n    print(\"NO\")\n    return\n\n  a = [i + 1 for i in range(k)]\n  remaining = n - sum(a)\n\n  add = remaining // k\n  rem = remaining % k\n\n  for i in range(k):\n    a[i] += add\n\n  for i in range(k - 1, k - 1 - rem, -1):\n    a[i] += 1\n\n  for i in range(k - 1):\n    if a[i + 1] > 2 * a[i]:\n      diff = a[i + 1] - 2 * a[i]\n      a[i + 1] -= diff\n      a[0] += diff\n      if a[0] >= a[1]:\n          print(\"NO\")\n          return\n      \n  for i in range(k - 1):\n    if a[i + 1] <= a[i]:\n      \n      print(\"NO\")\n      return\n    \n    if a[i+1] > 2 * a[i]:\n        print(\"NO\")\n        return\n\n\n  print(\"YES\")\n  print(*a)\n\nsolve()\n```",
    "87": "```python\ndef solve():\n    n, r = map(int, input().split())\n    projects = []\n    for _ in range(n):\n        projects.append(list(map(int, input().split())))\n\n    positive_projects = []\n    negative_projects = []\n    for a, b in projects:\n        if b >= 0:\n            positive_projects.append((a, b))\n        else:\n            negative_projects.append((a, b))\n\n    positive_projects.sort()\n    \n    count = 0\n    for a, b in positive_projects:\n        if r >= a:\n            r += b\n            count += 1\n\n    negative_projects.sort(key=lambda x: x[0] + x[1], reverse=True)\n\n    def can_complete(subset, initial_rating):\n        rating = initial_rating\n        for a, b in subset:\n            if rating >= a:\n                rating += b\n                if rating < 0:\n                    return False\n            else:\n                return False\n        return True\n    \n    def find_max_subset(remaining_projects, current_subset, current_rating):\n        if not remaining_projects:\n            return len(current_subset)\n        \n        max_size = len(current_subset)\n        \n        for i in range(len(remaining_projects)):\n            next_project = remaining_projects[i]\n            \n            temp_subset = current_subset[:]\n            temp_subset.append(next_project)\n            \n            temp_remaining = remaining_projects[:i] + remaining_projects[i+1:]\n\n            if can_complete(temp_subset, r):\n                max_size = max(max_size, find_max_subset(temp_remaining, temp_subset, r))\n        \n        return max_size\n\n    \n    rating = r\n    negative_count = 0\n    \n    for a, b in negative_projects:\n        if rating >= a:\n            rating += b\n            if rating >= 0:\n                negative_count += 1\n            else:\n                rating -=b\n                \n    rating = r\n    count = 0\n    for a, b in positive_projects:\n        if rating >= a:\n            rating += b\n            count += 1\n\n    rating = r\n    \n    \n    \n    temp_r = r\n    \n    for a,b in positive_projects:\n        if temp_r >=a:\n            temp_r+=b\n        else:\n            break\n    \n    \n    \n    negative_projects.sort(key = lambda x : x[0]+x[1],reverse = True)\n    \n    \n    temp_count = count\n    \n    \n    for a,b in negative_projects:\n        if rating >= a:\n            rating+=b\n            if rating >=0:\n                temp_count+=1\n            else:\n                rating -=b\n                \n    print(temp_count)\nsolve()\n```"
}