{
    "0": "```python\ndef solve():\n    s = input()\n    n = len(s)\n    \n    max_len = -1\n    \n    for i in range(n):\n        if s[i] == '[':\n            for j in range(i + 1, n):\n                if s[j] == ']':\n                    for k in range(i + 1, j):\n                        if s[k] == ':':\n                            for l in range(k + 1, j):\n                                if s[l] == ':':\n                                    \n                                    count = 0\n                                    for m in range(k + 1, l):\n                                        if s[m] == '|':\n                                            count += 1\n                                    \n                                    curr_len = 2 + 2 + count\n                                    \n                                    max_len = max(max_len, curr_len)\n    \n    print(max_len)\n\nsolve()\n```",
    "1": "```python\ndef solve():\n    x = int(input())\n    s = str(x)\n    n = len(s)\n    \n    best_num = x\n    best_sum = sum(int(digit) for digit in s)\n    \n    for i in range(n):\n        if s[i] == '0':\n            continue\n        \n        num_str = s[:i] + str(int(s[i]) - 1) + '9' * (n - i - 1)\n        num = int(num_str)\n        \n        if num <= x:\n            current_sum = sum(int(digit) for digit in num_str)\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_num = num\n            elif current_sum == best_sum and num > best_num:\n                best_num = num\n                \n    print(best_num)\n\nsolve()\n```",
    "2": "```python\ndef solve():\n    n = int(input())\n    s = str(n)\n    l = len(s)\n    \n    first_digit = int(s[0])\n    \n    next_lucky = (first_digit + 1) * (10**(l-1))\n    \n    print(next_lucky - n)\n\nsolve()\n```",
    "6": "```python\ndef solve():\n    n, x = map(int, input().split())\n    blows = []\n    for _ in range(n):\n        blows.append(list(map(int, input().split())))\n\n    max_damage = 0\n    for d, h in blows:\n        max_damage = max(max_damage, d)\n\n    if max_damage >= x:\n        print(1)\n        return\n\n    max_diff = 0\n    for d, h in blows:\n        max_diff = max(max_diff, d - h)\n\n    if max_diff <= 0:\n        print(-1)\n        return\n\n    remaining = x - max_damage\n    \n    ans = 1 + (remaining + max_diff - 1) // max_diff\n    print(ans)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "7": "```python\nn, m = map(int, input().split())\n\nleft = 0\nright = 2 * 10**9\n\nans = right\n\nwhile left <= right:\n  mid = (left + right) // 2\n  \n  total_sparrows = mid * (mid + 1) // 2\n  \n  if n + mid * m >= total_sparrows:\n    ans = mid\n    right = mid - 1\n  else:\n    left = mid + 1\n\nprint(ans)\n```",
    "9": "```python\ndef solve():\n    d = int(input())\n    n, m = map(int, input().split())\n    sofas = []\n    for _ in range(d):\n        sofas.append(list(map(int, input().split())))\n    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\n    def count_sofas(sofa_index):\n        l, r, t, b = 0, 0, 0, 0\n        x1, y1, x2, y2 = sofas[sofa_index]\n        \n        for i in range(d):\n            if i == sofa_index:\n                continue\n            \n            ox1, oy1, ox2, oy2 = sofas[i]\n            \n            # Check left\n            if min(x1, x2) > max(ox1, ox2):\n                l += 1\n            # Check right\n            elif max(x1, x2) < min(ox1, ox2):\n                r += 1\n            # Check top\n            if min(y1, y2) > max(oy1, oy2):\n                t += 1\n            # Check bottom\n            elif max(y1, y2) < min(oy1, oy2):\n                b += 1\n        return l, r, t, b\n\n    for i in range(d):\n        l, r, t, b = count_sofas(i)\n        if l == cnt_l and r == cnt_r and t == cnt_t and b == cnt_b:\n            print(i + 1)\n            return\n\n    print(-1)\n\nsolve()\n```",
    "10": "```python\ndef solve():\n    n = int(input())\n    \n    min_days_off = (n // 7) * 2\n    max_days_off = (n // 7) * 2\n    \n    remaining_days = n % 7\n    \n    if remaining_days == 1:\n        min_days_off += 0\n        max_days_off += 1\n    elif remaining_days == 2:\n        min_days_off += 0\n        max_days_off += 2\n    elif remaining_days == 3:\n        min_days_off += 0\n        max_days_off += 2\n    elif remaining_days == 4:\n        min_days_off += 0\n        max_days_off += 2\n    elif remaining_days == 5:\n        min_days_off += 0\n        max_days_off += 2\n    elif remaining_days == 6:\n        min_days_off += 1\n        max_days_off += 2\n        \n    print(min_days_off, max_days_off)\n\nsolve()\n```",
    "11": "```python\ndef solve():\n  n, a, b, p, q = map(int, input().split())\n\n  red_count = n // a\n  blue_count = n // b\n  \n  lcm = (a * b) // gcd(a, b)\n  \n  both_count = n // lcm\n  \n  red_only = red_count - both_count\n  blue_only = blue_count - both_count\n  \n  total_chocolates = red_only * p + blue_only * q + both_count * max(p, q)\n  \n  print(total_chocolates)\n\ndef gcd(a, b):\n  if b == 0:\n    return a\n  return gcd(b, a % b)\n\nsolve()\n```",
    "14": "```python\ndef solve():\n    n, k = map(int, input().split())\n    p = list(map(int, input().split()))\n\n    used = [False] * (n + 1)\n    for x in p:\n        used[x] = True\n\n    remaining = []\n    for i in range(n, 0, -1):\n        if not used[i]:\n            remaining.append(i)\n\n    p_full = p[:]\n    for x in remaining:\n        p_full.append(x)\n\n    def is_stack_sortable(arr):\n        stack = []\n        b = []\n        a = arr[:]\n        \n        def backtrack():\n            nonlocal a, stack, b\n            \n            if not a and not stack:\n                return all(b[i] <= b[i+1] for i in range(len(b)-1)) if len(b) > 1 else True\n            \n            \n            if a:\n                stack.append(a[0])\n                new_a = a[1:]\n                \n                old_a = a[:]\n                old_stack = stack[:-1]\n                old_b = b[:]\n                \n                a = new_a\n                \n                if backtrack():\n                    return True\n                \n                a = old_a\n                stack = old_stack\n                b = old_b\n            \n            if stack:\n                b.append(stack[-1])\n                new_stack = stack[:-1]\n                \n                old_a = a[:]\n                old_stack = stack[:]\n                old_b = b[:-1]\n                \n                stack = new_stack\n                \n                if backtrack():\n                    return True\n                \n                a = old_a\n                stack = old_stack\n                b = old_b\n            \n            return False\n\n        return backtrack()\n\n    if not is_stack_sortable(p_full):\n        print(-1)\n        return\n\n    remaining = []\n    for i in range(n, 0, -1):\n        if not used[i]:\n            remaining.append(i)\n\n    best_p = None\n    import itertools\n    for perm in itertools.permutations(remaining):\n        candidate_p = p + list(perm)\n        if is_stack_sortable(candidate_p):\n            if best_p is None:\n                best_p = candidate_p\n            else:\n                if candidate_p > best_p:\n                    best_p = candidate_p\n\n    if best_p is None:\n        print(-1)\n    else:\n        print(*best_p)\n\nsolve()\n```",
    "16": "```python\ndef solve():\n  cnt1 = int(input())\n  cnt2 = int(input())\n  cnt3 = int(input())\n  cnt4 = int(input())\n\n  if cnt1 == cnt4 and cnt1 >= 0 and cnt4 >= 0:\n    print(1)\n  else:\n    print(0)\n\nsolve()\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelse:\n    print(k - (t - n))\n```",
    "18": "```python\ndef solve():\n    s = input()\n    n = len(s)\n    t = \"\"\n    u = \"\"\n    \n    suffix_min = [\"\"] * (n + 1)\n    suffix_min[n] = chr(ord('z') + 1) \n    \n    for i in range(n - 1, -1, -1):\n        suffix_min[i] = min(s[i], suffix_min[i+1])\n        \n    \n    while len(s) > 0:\n        if s[0] <= suffix_min[0]:\n            t += s[0]\n            s = s[1:]\n        else:\n            while len(t) > 0 and t[-1] <= suffix_min[0]:\n                u += t[-1]\n                t = t[:-1]\n            t += s[0]\n            s = s[1:]\n            \n    while len(t) > 0:\n        u += t[-1]\n        t = t[:-1]\n        \n    print(u)\n\nsolve()\n```",
    "19": "```python\ndef solve():\n    n = int(input())\n    pairs = []\n    for _ in range(n):\n        pairs.append(list(map(int, input().split())))\n\n    possible = True\n    for i in range(n):\n        if pairs[i][1] > pairs[i][0]:\n            possible = False\n            break\n        if i > 0:\n            if pairs[i][0] < pairs[i-1][0] or pairs[i][1] < pairs[i-1][1]:\n                possible = False\n                break\n            if pairs[i][0] - pairs[i-1][0] < pairs[i][1] - pairs[i-1][1]:\n                possible = False\n                break\n\n    if possible:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "20": "```python\ndef solve():\n    s = input()\n    hh = int(s[:2])\n    mm = int(s[3:])\n    \n    ans = float('inf')\n    \n    for h in range(24):\n        for m in range(60):\n            h_str = str(h).zfill(2)\n            m_str = str(m).zfill(2)\n            \n            if h_str == m_str[::-1]:\n                curr_minutes = hh * 60 + mm\n                target_minutes = h * 60 + m\n                \n                diff = (target_minutes - curr_minutes) % (24 * 60)\n                ans = min(ans, diff)\n                \n    print(ans)\n\nsolve()\n```",
    "22": "```python\ndef solve():\n    s = input()\n    n = len(s)\n    \n    symmetric_chars = {'b': 'd', 'd': 'b', 'p': 'q', 'q': 'p', 'o': 'o', 'x': 'x', 'X': 'X', 'H': 'H', 'I': 'I', 'M': 'M', 'O': 'O', 'T': 'T', 'U': 'U', 'V': 'V', 'v': 'v', 'W': 'W', 'w': 'w', 'Y': 'Y'}\n    \n    for i in range((n + 1) // 2):\n        if s[i] not in symmetric_chars or symmetric_chars.get(s[i]) != s[n - 1 - i]:\n            print(\"NIE\")\n            return\n    \n    print(\"TAK\")\n\nsolve()\n```",
    "23": "```python\nfrom collections import Counter\n\ndef solve():\n    a = input()\n    b = input()\n    \n    a_digits = sorted(list(a), reverse=True)\n    \n    if len(a) < len(b):\n        print(\"\".join(a_digits))\n        return\n    \n    if len(a) > len(b):\n        \n        print(\"\".join(a_digits))\n        return\n\n    \n    def find_max_permutation(index, current_num, remaining_digits):\n        if index == len(a):\n            return current_num\n        \n        best_num = \"\"\n        \n        for digit in sorted(remaining_digits.keys(), reverse=True):\n            if remaining_digits[digit] > 0:\n                \n                temp_remaining_digits = remaining_digits.copy()\n                temp_remaining_digits[digit] -= 1\n                if temp_remaining_digits[digit] == 0:\n                    del temp_remaining_digits[digit]\n                    \n                new_num = current_num + digit\n                \n                if int(new_num) <= int(b[:index+1]):\n                    \n                    if int(new_num) == int(b[:index+1]):\n                        \n                        result = find_max_permutation(index + 1, new_num, temp_remaining_digits)\n                        if result != \"\" and (best_num == \"\" or int(result) > int(best_num)):\n                            best_num = result\n                    else:\n                        \n                        remaining_digits_list = []\n                        for d, count in temp_remaining_digits.items():\n                            remaining_digits_list.extend([d] * count)\n                        remaining_digits_list.sort(reverse=True)\n                        \n                        \n                        full_num = new_num + \"\".join(remaining_digits_list)\n                        if best_num == \"\" or int(full_num) > int(best_num):\n                            best_num = full_num\n        \n        return best_num\n    \n    a_counts = Counter(a)\n    result = find_max_permutation(0, \"\", a_counts)\n    print(result)\n\nsolve()\n```",
    "24": "```python\ndef solve():\n    board = []\n    for _ in range(10):\n        board.append(list(input()))\n\n    def check_win(board):\n        for i in range(10):\n            for j in range(10):\n                if board[i][j] == 'X':\n                    # Check horizontal\n                    if j <= 5:\n                        count = 0\n                        for k in range(5):\n                            if board[i][j+k] == 'X':\n                                count += 1\n                        if count == 5:\n                            return True\n\n                    # Check vertical\n                    if i <= 5:\n                        count = 0\n                        for k in range(5):\n                            if board[i+k][j] == 'X':\n                                count += 1\n                        if count == 5:\n                            return True\n\n                    # Check diagonal (top-left to bottom-right)\n                    if i <= 5 and j <= 5:\n                        count = 0\n                        for k in range(5):\n                            if board[i+k][j+k] == 'X':\n                                count += 1\n                        if count == 5:\n                            return True\n\n                    # Check diagonal (top-right to bottom-left)\n                    if i <= 5 and j >= 4:\n                        count = 0\n                        for k in range(5):\n                            if board[i+k][j-k] == 'X':\n                                count += 1\n                        if count == 5:\n                            return True\n        return False\n\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                board[i][j] = 'X'\n                if check_win(board):\n                    print('YES')\n                    return\n                board[i][j] = '.'\n\n    print('NO')\n\nsolve()\n```",
    "25": "```python\ndef solve():\n    n, k = map(int, input().split())\n    \n    if k > n * n:\n        print(\"-1\")\n        return\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k == 0:\n            break\n        if matrix[i][i] == 0 and k > 0:\n            matrix[i][i] = 1\n            k -= 1\n            \n    for i in range(n):\n        for j in range(i + 1, n):\n            if k >= 2:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n    \n    if k > 0:\n        print(\"-1\")\n        return\n    \n    for row in matrix:\n        print(*row)\n\nsolve()\n```",
    "27": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    \n    ans = n\n    \n    for i in range(1, n // 2 + 1):\n        prefix = s[:i]\n        if s[:2*i].startswith(prefix):\n            ans = min(ans, i + 1 + (n - 2*i))\n            \n    print(ans)\n\nsolve()\n```",
    "28": "```python\ndef solve():\n    n = int(input())\n    files = []\n    for _ in range(n):\n        files.append(input().split())\n    \n    examples = []\n    regular = []\n    for i in range(n):\n        if files[i][1] == '1':\n            examples.append((files[i][0], i))\n        else:\n            regular.append((files[i][0], i))\n    \n    e = len(examples)\n    \n    moves = []\n    \n    # Move examples to 1, 2, ..., e\n    for i in range(e):\n        if examples[i][0] != str(i + 1):\n            \n            # Find a temporary file name\n            temp_name = None\n            for j in range(1, n + 2):\n                temp_name_str = str(j)\n                \n                is_used = False\n                for k in range(n):\n                    if files[k][0] == temp_name_str:\n                        is_used = True\n                        break\n                if not is_used:\n                    temp_name = temp_name_str\n                    break\n            \n            if temp_name is None:\n                print(\"Error: Could not find a temporary file name.\")\n                return\n            \n            # Move the example to the correct position\n            if any(file[0] == str(i + 1) for file in files):\n                moves.append(f\"move {examples[i][0]} {temp_name}\")\n                \n                # Find the file that is currently at the target position\n                target_file = None\n                for k in range(n):\n                    if files[k][0] == str(i + 1):\n                        target_file = files[k][0]\n                        break\n                \n                moves.append(f\"move {target_file} {str(i + 1)}\")\n                moves.append(f\"move {temp_name} {examples[i][0]}\")\n                \n                # Update the files list\n                for k in range(n):\n                    if files[k][0] == examples[i][0]:\n                        files[k][0] = str(i + 1)\n                    elif files[k][0] == target_file:\n                        files[k][0] = examples[i][0]\n                    elif files[k][0] == temp_name:\n                        files[k][0] = target_file\n            else:\n                moves.append(f\"move {examples[i][0]} {str(i + 1)}\")\n                \n                # Update the files list\n                for k in range(n):\n                    if files[k][0] == examples[i][0]:\n                        files[k][0] = str(i + 1)\n                        break\n    \n    # Move regular tests to e + 1, e + 2, ..., n\n    for i in range(len(regular)):\n        if regular[i][0] != str(e + i + 1):\n            \n            # Find a temporary file name\n            temp_name = None\n            for j in range(1, n + 2):\n                temp_name_str = str(j)\n                \n                is_used = False\n                for k in range(n):\n                    if files[k][0] == temp_name_str:\n                        is_used = True\n                        break\n                if not is_used:\n                    temp_name = temp_name_str\n                    break\n            \n            if temp_name is None:\n                print(\"Error: Could not find a temporary file name.\")\n                return\n            \n            # Move the regular test to the correct position\n            if any(file[0] == str(e + i + 1) for file in files):\n                moves.append(f\"move {regular[i][0]} {temp_name}\")\n                \n                # Find the file that is currently at the target position\n                target_file = None\n                for k in range(n):\n                    if files[k][0] == str(e + i + 1):\n                        target_file = files[k][0]\n                        break\n                \n                moves.append(f\"move {target_file} {str(e + i + 1)}\")\n                moves.append(f\"move {temp_name} {regular[i][0]}\")\n                \n                # Update the files list\n                for k in range(n):\n                    if files[k][0] == regular[i][0]:\n                        files[k][0] = str(e + i + 1)\n                    elif files[k][0] == target_file:\n                        files[k][0] = regular[i][0]\n                    elif files[k][0] == temp_name:\n                        files[k][0] = target_file\n            else:\n                moves.append(f\"move {regular[i][0]} {str(e + i + 1)}\")\n                \n                # Update the files list\n                for k in range(n):\n                    if files[k][0] == regular[i][0]:\n                        files[k][0] = str(e + i + 1)\n                        break\n    \n    print(len(moves))\n    for move in moves:\n        print(move)\n\nsolve()\n```",
    "29": "```python\ndef solve():\n    s = input()\n    digits = [int(c) for c in s]\n    \n    ans = 6\n    for i in range(1000):\n        s1 = str(i).zfill(3)\n        sum1 = sum(int(c) for c in s1)\n        \n        for j in range(1000):\n            s2 = str(j).zfill(3)\n            sum2 = sum(int(c) for c in s2)\n            \n            if sum1 == sum2:\n                \n                temp_digits = digits[:]\n                \n                \n                \n                \n                count = 0\n                \n                temp_digits[0] = int(s1[0])\n                temp_digits[1] = int(s1[1])\n                temp_digits[2] = int(s1[2])\n                temp_digits[3] = int(s2[0])\n                temp_digits[4] = int(s2[1])\n                temp_digits[5] = int(s2[2])\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n",
    "30": "```python\ndef solve():\n  m, x = map(int, input().split())\n  print(m - 1)\n\nsolve()\n```",
    "31": "```python\ndef solve():\n    n, k = map(int, input().split())\n    mod = 10**6 + 3\n\n    if n > 63 and k > 1:\n        print(1, 1)\n        return\n\n    if k > 2**n:\n        print(1, 1)\n        return\n\n    num = 1\n    den = 1\n    \n    for i in range(int(k)):\n        num = (num * (pow(2, n, mod) - i)) % mod\n        den = (den * pow(2, n, mod)) % mod\n\n    \n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def mod_inv(a, m):\n        return pow(a, m - 2, m)\n\n    \n    prob_same = (1 - (num * mod_inv(den, mod)) % mod + mod) % mod\n    \n    print(prob_same, 1)\n    \nsolve()\n```",
    "32": "```python\ndef solve():\n    n = int(input())\n    \n    current_pos = 0  # 0 is North Pole, 20000 is South Pole\n    \n    for _ in range(n):\n        t, direction = input().split()\n        t = int(t)\n        \n        if current_pos == 0 and direction != \"South\":\n            print(\"NO\")\n            return\n        \n        if current_pos == 20000 and direction != \"North\":\n            print(\"NO\")\n            return\n        \n        if direction == \"South\":\n            current_pos += t\n        elif direction == \"North\":\n            current_pos -= t\n        \n        if current_pos < 0:\n            current_pos = 0\n        if current_pos > 20000:\n            current_pos = 20000\n            \n    if current_pos == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nsolve()\n```",
    "33": "```python\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef extended_gcd(a, b):\n    if a == 0:\n        return b, 0, 1\n    d, x1, y1 = extended_gcd(b % a, a)\n    x = y1 - (b // a) * x1\n    y = x1\n    return d, x, y\n\ndef solve():\n    a1, b1, a2, b2, L, R = map(int, input().split())\n\n    g = gcd(a1, a2)\n    \n    if (b2 - b1) % g != 0:\n        print(0)\n        return\n\n    d, x, y = extended_gcd(a1, a2)\n    x *= (b2 - b1) // d\n    y *= (b2 - b1) // d\n\n    lcm = (a1 * a2) // g\n\n    x0 = (x * a1 + b1)\n    \n    \n    def find_min_val(a1, b1, a2, b2, L, R):\n        g = gcd(a1, a2)\n        if (b2 - b1) % g != 0:\n            return float('inf')\n\n        d, x, y = extended_gcd(a1, a2)\n        x *= (b2 - b1) // d\n        y *= (b2 - b1) // d\n\n        lcm = (a1 * a2) // g\n        x0 = (x * a1 + b1)\n        \n        k = (L - x0 + lcm - 1) // lcm\n        first = x0 + k * lcm\n        \n        if first > R:\n            return float('inf')\n        return first\n    \n    first = find_min_val(a1, b1, a2, b2, L, R)\n    \n    if first == float('inf'):\n        print(0)\n        return\n    \n    count = (R - first) // lcm + 1\n    print(count)\n\nsolve()\n```",
    "34": "```python\ndef solve():\n    n, a, b = map(int, input().split())\n    \n    ans = 0\n    for i in range(1, n):\n        if i >= 1 and i < n:\n            x = a // i\n            y = b // (n - i)\n            \n            if x > 0 and y > 0:\n                ans = max(ans, min(x, y))\n    print(ans)\n\nsolve()\n```",
    "36": "```python\ndef solve():\n    n = int(input())\n\n    if n == 0:\n        print(0, 0)\n        return\n\n    l, r = 0, 10**9\n    k = 0\n    while l <= r:\n        mid = (l + r) // 2\n        if 3 * mid * (mid + 1) >= n:\n            k = mid\n            r = mid - 1\n        else:\n            l = mid + 1\n\n    n -= 3 * k * (k - 1)\n    \n    x, y = 2 * k, 0\n    \n    if n <= k:\n        x -= 2 * n\n    elif n <= 2 * k:\n        x -= 2 * k\n        x += 2 * (n - k)\n        y += 2 * (n - k)\n    elif n <= 3 * k:\n        x -= 2 * (3 * k - n)\n        y += 2 * k\n    elif n <= 4 * k:\n        x += 2 * (n - 3 * k)\n        y += 2 * k\n        y -= 2 * (n - 3 * k)\n    elif n <= 5 * k:\n        x += 2 * k\n        y -= 2 * (n - 4 * k)\n    else:\n        x += 2 * k\n        x -= 2 * (n - 5 * k)\n        y -= 2 * k\n    \n    print(x, y)\n\nsolve()\n```",
    "38": "```python\ndef solve():\n    n, L = map(int, input().split())\n    kefa = list(map(int, input().split()))\n    sasha = list(map(int, input().split()))\n\n    for shift in range(L):\n        shifted_sasha = [(x + shift) % L for x in sasha]\n        shifted_sasha.sort()\n        if kefa == shifted_sasha:\n            print(\"YES\")\n            return\n\n    print(\"NO\")\n\nsolve()\n```",
    "41": "```python\ndef nearest_zero(arr):\n  \"\"\"\n  Finds the distance to the nearest zero for each element in the array.\n\n  Args:\n    arr: A list of integers.\n\n  Returns:\n    A list of integers representing the distances to the nearest zero.\n  \"\"\"\n\n  n = len(arr)\n  distances = [float('inf')] * n\n\n  # Forward pass: find distances to the nearest zero from the left\n  last_zero = float('-inf')\n  for i in range(n):\n    if arr[i] == 0:\n      last_zero = i\n      distances[i] = 0\n    elif last_zero != float('-inf'):\n      distances[i] = min(distances[i], i - last_zero)\n\n  # Backward pass: find distances to the nearest zero from the right\n  last_zero = float('inf')\n  for i in range(n - 1, -1, -1):\n    if arr[i] == 0:\n      last_zero = i\n      distances[i] = 0\n    elif last_zero != float('inf'):\n      distances[i] = min(distances[i], last_zero - i)\n\n  return distances\n\n\nif __name__ == \"__main__\":\n  n = int(input())\n  arr = list(map(int, input().split()))\n\n  distances = nearest_zero(arr)\n  print(*distances)\n```",
    "42": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    \n    count = 0\n    distinct_strings = set()\n    \n    for i in range(2**n):\n        binary_string = bin(i)[2:].zfill(n)\n        \n        is_substring = False\n        for j in range(n):\n            shifted_string = binary_string[j:] + binary_string[:j]\n            if s in shifted_string:\n                is_substring = True\n                break\n        \n        if is_substring:\n            if binary_string not in distinct_strings:\n                count += 1\n                distinct_strings.add(binary_string)\n                \n    print(count)\n\nsolve()\n```",
    "44": "```python\nd, k, a, b, t = map(int, input().split())\n\nif d <= k:\n  print(d * a)\nelse:\n  if a * k + t >= b * k:\n    print(k * a + (d - k) * b)\n  else:\n    num_breaks = d // k\n    remaining = d % k\n    \n    time = num_breaks * (k * a + t)\n    \n    if remaining > 0:\n      if remaining * a + t < remaining * b:\n        time += remaining * a\n      else:\n        time -= t\n        time += remaining * b\n    else:\n      time -= t\n      \n    print(time)\n```",
    "45": "```python\ndef solve():\n    n, k = map(int, input().split())\n\n    if k * (k + 1) // 2 > n:\n        print(-1)\n        return\n\n    best_gcd = 0\n    best_seq = []\n\n    for gcd in range(int(n**0.5), 0, -1):\n        if n % gcd == 0:\n            \n            q = n // gcd\n            if q >= k * (k + 1) // 2:\n                \n                seq = [i * gcd for i in range(1, k)]\n                seq.append(n - sum(seq))\n                \n                if all(seq[i] < seq[i+1] for i in range(len(seq)-1)) and all(x > 0 for x in seq):\n                    best_gcd = gcd\n                    best_seq = seq\n                    break\n            \n            gcd2 = n // gcd\n            q = n // gcd2\n            if q >= k * (k + 1) // 2:\n                \n                seq = [i * gcd2 for i in range(1, k)]\n                seq.append(n - sum(seq))\n                \n                if all(seq[i] < seq[i+1] for i in range(len(seq)-1)) and all(x > 0 for x in seq):\n                    best_gcd = gcd2\n                    best_seq = seq\n                    break\n\n    if best_gcd == 0:\n        if n == 1 and k == 1:\n            print(1)\n        else:\n            print(-1)\n    else:\n        print(*best_seq)\n\nsolve()\n```",
    "46": "```python\ndef solve():\n    n, m = map(int, input().split())\n    count = 0\n    for x in range(1, n + 1):\n        for y in range(1, m + 1):\n            if (x + y) % 5 == 0:\n                count += 1\n    print(count)\n\nsolve()\n```",
    "49": "```python\nk = int(input())\n\ndigits = 1\ncount = 9\nwhile k > digits * count:\n    k -= digits * count\n    digits += 1\n    count *= 10\n\nnum = 10**(digits - 1) + (k - 1) // digits\nindex = (k - 1) % digits\n\nprint(str(num)[index])\n```",
    "52": "```python\ndef solve():\n    n, m, k = map(int, input().split())\n    a = []\n    for _ in range(n):\n        a.append(list(map(int, input().split())))\n\n    dp = {}\n\n    def get_dp(row_idx, rem):\n        if (row_idx, rem) in dp:\n            return dp[(row_idx, rem)]\n\n        if row_idx == n:\n            if rem == 0:\n                return 0\n            else:\n                return float('-inf')\n\n        max_sum = float('-inf')\n        \n        # Option 1: Don't pick anything from this row\n        max_sum = max(max_sum, get_dp(row_idx + 1, rem))\n\n        # Option 2: Pick some elements from this row\n        row = a[row_idx]\n        max_picks = m // 2\n        \n        for i in range(1 << m):\n            picks = []\n            for j in range(m):\n                if (i >> j) & 1:\n                    picks.append(row[j])\n            \n            if len(picks) <= max_picks:\n                current_sum = sum(picks)\n                new_rem = (rem - (current_sum % k)) % k\n                max_sum = max(max_sum, current_sum + get_dp(row_idx + 1, new_rem))\n\n        dp[(row_idx, rem)] = max_sum\n        return max_sum\n\n    print(get_dp(0, 0))\n\nsolve()\n```",
    "53": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    def find_longest_increasing_subsequence(arr):\n        best_len = 0\n        best_seq = \"\"\n\n        def backtrack(current_seq, current_arr, last_val, moves):\n            nonlocal best_len, best_seq\n\n            if not current_arr:\n                if len(current_seq) > best_len:\n                    best_len = len(current_seq)\n                    best_seq = moves\n                return\n\n            if current_arr[0] > last_val and current_arr[-1] > last_val:\n                if current_arr[0] < current_arr[-1]:\n                    backtrack(current_seq + [current_arr[0]], current_arr[1:], current_arr[0], moves + \"L\")\n                    backtrack(current_seq + [current_arr[-1]], current_arr[:-1], current_arr[-1], moves + \"R\")\n                elif current_arr[0] > current_arr[-1]:\n                    backtrack(current_seq + [current_arr[-1]], current_arr[:-1], current_arr[-1], moves + \"R\")\n                    backtrack(current_seq + [current_arr[0]], current_arr[1:], current_arr[0], moves + \"L\")\n                else:\n                    \n                    temp_arr = current_arr[:]\n                    temp_seq = current_seq[:]\n                    temp_moves = moves[:]\n                    \n                    len_l = 0\n                    i = 0\n                    while i < len(temp_arr) and temp_arr[i] > last_val and temp_arr[i] == temp_arr[0]:\n                        len_l += 1\n                        i += 1\n                    \n                    len_r = 0\n                    j = len(temp_arr) - 1\n                    while j >= 0 and temp_arr[j] > last_val and temp_arr[j] == temp_arr[-1]:\n                        len_r += 1\n                        j -= 1\n                    \n                    if len_l > len_r:\n                        backtrack(current_seq + [current_arr[0]], current_arr[1:], current_arr[0], moves + \"L\")\n                    elif len_r > len_l:\n                        backtrack(current_seq + [current_arr[-1]], current_arr[:-1], current_arr[-1], moves + \"R\")\n                    else:\n                        \n                        \n                        temp_arr_l = current_arr[1:]\n                        temp_seq_l = current_seq + [current_arr[0]]\n                        temp_moves_l = moves + \"L\"\n                        \n                        best_len_l = 0\n                        best_seq_l = \"\"\n                        \n                        def backtrack_l(current_seq, current_arr, last_val, moves):\n                            nonlocal best_len_l, best_seq_l\n                            \n                            if not current_arr:\n                                if len(current_seq) > best_len_l:\n                                    best_len_l = len(current_seq)\n                                    best_seq_l = moves\n                                return\n                            \n                            if current_arr[0] > last_val and current_arr[-1] > last_val:\n                                if current_arr[0] < current_arr[-1]:\n                                    backtrack_l(current_seq + [current_arr[0]], current_arr[1:], current_arr[0], moves + \"L\")\n                                    backtrack_l(current_seq + [current_arr[-1]], current_arr[:-1], current_arr[-1], moves + \"R\")\n                                elif current_arr[0] > current_arr[-1]:\n                                    backtrack_l(current_seq + [current_arr[-1]], current_arr[:-1], current_arr[-1], moves + \"R\")\n                                    backtrack_l(current_seq + [current_arr[0]], current_arr[1:], current_arr[0], moves + \"L\")\n                                else:\n                                    return\n                            elif current_arr[0] > last_val:\n                                backtrack_l(current_seq + [current_arr[0]], current_arr[1:], current_arr[0], moves + \"L\")\n                            elif current_arr[-1] > last_val:\n                                backtrack_l(current_seq + [current_arr[-1]], current_arr[:-1], current_arr[-1], moves + \"R\")\n                            else:\n                                if len(current_seq) > best_len_l:\n                                    best_len_l = len(current_seq)\n                                    best_seq_l = moves\n                                return\n                        \n                        backtrack_l(temp_seq_l, temp_arr_l, temp_seq_l[-1], temp_moves_l)\n                        \n                        \n                        temp_arr_r = current_arr[:-1]\n                        temp_seq_r = current_seq + [current_arr[-1]]\n                        temp_moves_r = moves + \"R\"\n                        \n                        best_len_r = 0\n                        best_seq_r = \"\"\n                        \n                        def backtrack_r(current_seq, current_arr, last_val, moves):\n                            nonlocal best_len_r, best_seq_r\n                            \n                            if not current_arr:\n                                if len(current_seq) > best_len_r:\n                                    best_len_r = len(current_seq)\n                                    best_seq_r = moves\n                                return\n                            \n                            if current_arr[0] > last_val and current_arr[-1] > last_val:\n                                if current_arr[0] < current_arr[-1]:\n                                    backtrack_r(current_seq + [current_arr[0]], current_arr[1:], current_arr[0], moves + \"L\")\n                                    backtrack_r(current_seq + [current_arr[-1]], current_arr[:-1], current_arr[-1], moves + \"R\")\n                                elif current_arr[0] > current_arr[-1]:\n                                    backtrack_r(current_seq + [current_arr[-1]], current_arr[:-1], current_arr[-1], moves + \"R\")\n                                    backtrack_r(current_seq + [current_arr[0]], current_arr[1:], current_arr[0], moves + \"L\")\n                                else:\n                                    return\n                            elif current_arr[0] > last_val:\n                                backtrack_r(current_seq + [current_arr[0]], current_arr[1:], current_arr[0], moves + \"L\")\n                            elif current_arr[-1] > last_val:\n                                backtrack_r(current_seq + [current_arr[-1]], current_arr[:-1], current_arr[-1], moves + \"R\")\n                            else:\n                                if len(current_seq) > best_len_r:\n                                    best_len_r = len(current_seq)\n                                    best_seq_r = moves\n                                return\n                        \n                        backtrack_r(temp_seq_r, temp_arr_r, temp_seq_r[-1], temp_moves_r)\n                        \n                        if best_len_l > best_len_r:\n                            if len(temp_seq_l) + best_len_l - len(temp_seq_l) > best_len:\n                                best_len = len(temp_seq_l) + best_len_l - len(temp_seq_l)\n                                best_seq = temp_moves_l + best_seq_l\n                        elif best_len_r > best_len_l:\n                            if len(temp_seq_r) + best_len_r - len(temp_seq_r) > best_len:\n                                best_len = len(temp_seq_r) + best_len_r - len(temp_seq_r)\n                                best_seq = temp_moves_r + best_seq_r\n                        else:\n                            if len(temp_seq_l) + best_len_l - len(temp_seq_l) > best_len:\n                                best_len = len(temp_seq_l) + best_len_l - len(temp_seq_l)\n                                best_seq = temp_moves_l + best_seq_l\n                            \n                        return\n                            \n            elif current_arr[0] > last_val:\n                backtrack(current_seq + [current_arr[0]], current_arr[1:], current_arr[0], moves + \"L\")\n            elif current_arr[-1] > last_val:\n                backtrack(current_seq + [current_arr[-1]], current_arr[:-1], current_arr[-1], moves + \"R\")\n            else:\n                if len(current_seq) > best_len:\n                    best_len = len(current_seq)\n                    best_seq = moves\n                return\n\n        backtrack([], arr, 0, \"\")\n        return best_len, best_seq\n\n    length, sequence = find_longest_increasing_subsequence(a)\n    print(length)\n    print(sequence)\n\nsolve()\n```",
    "54": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    if n == 1:\n        print(0)\n        return\n\n    unique_values = sorted(list(set(a)))\n\n    if len(unique_values) > 3:\n        print(-1)\n        return\n\n    if len(unique_values) == 1:\n        print(0)\n        return\n\n    if len(unique_values) == 2:\n        val1, val2 = unique_values\n        if (val1 + val2) % 2 == 0:\n            print((val2 - val1) // 2)\n        else:\n            print(val2 - val1)\n        return\n\n    if len(unique_values) == 3:\n        val1, val2, val3 = unique_values\n        if val2 - val1 == val3 - val2:\n            print(val2 - val1)\n        else:\n            print(-1)\n        return\n\nsolve()\n```",
    "55": "```python\ndef solve():\n    x1, y1, x2, y2 = map(int, input().split())\n    x3, y3, x4, y4 = map(int, input().split())\n    x5, y5, x6, y6 = map(int, input().split())\n\n    white_area = (x2 - x1) * (y2 - y1)\n\n    # Intersection of white and black 1\n    x_overlap_1 = max(0, min(x2, x4) - max(x1, x3))\n    y_overlap_1 = max(0, min(y2, y4) - max(y1, y3))\n    intersection_area_1 = x_overlap_1 * y_overlap_1\n\n    # Intersection of white and black 2\n    x_overlap_2 = max(0, min(x2, x6) - max(x1, x5))\n    y_overlap_2 = max(0, min(y2, y6) - max(y1, y5))\n    intersection_area_2 = x_overlap_2 * y_overlap_2\n\n    # Intersection of white, black 1, and black 2\n    x_overlap_12 = max(0, min(x2, x4, x6) - max(x1, x3, x5))\n    y_overlap_12 = max(0, min(y2, y4, y6) - max(y1, y3, y5))\n    intersection_area_12 = x_overlap_12 * y_overlap_12\n\n    # Intersection of black 1 and black 2\n    x_black_overlap = max(0, min(x4, x6) - max(x3, x5))\n    y_black_overlap = max(0, min(y4, y6) - max(y3, y5))\n    black_overlap_area = x_black_overlap * y_black_overlap\n\n    # Area covered by either black sheet\n    covered_area = intersection_area_1 + intersection_area_2 - intersection_area_12\n\n    if white_area > covered_area:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nsolve()\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef solve():\n    n = int(input())\n    reachable = {n}\n    curr = n\n    while True:\n        curr = f(curr)\n        if curr in reachable:\n            break\n        reachable.add(curr)\n    print(len(reachable))\n\nsolve()\n```",
    "57": "```python\ndef solve():\n    n = int(input())\n    f = list(map(int, input().split()))\n\n    assigned = [False] * (n + 1)\n    for i in range(n):\n        if f[i] != 0:\n            assigned[f[i]] = True\n\n    unassigned_givers = []\n    unassigned_receivers = []\n    for i in range(n):\n        if f[i] == 0:\n            unassigned_givers.append(i)\n\n    for i in range(1, n + 1):\n        if not assigned[i]:\n            unassigned_receivers.append(i)\n\n    for i in range(len(unassigned_givers)):\n        f[unassigned_givers[i]] = unassigned_receivers[i]\n\n    \n    for i in range(n):\n        if f[i] == i + 1:\n            for j in range(n):\n                if i != j and f[j] != j + 1 and f[j] != 0:\n                    f[i], f[j] = f[j], f[i]\n                    break\n            else:\n                for j in range(n):\n                    if i != j and f[j] != j + 1:\n                        f[i], f[j] = f[j], f[i]\n                        break\n    \n    for i in range(n):\n        if f[i] == i + 1:\n            for j in range(n):\n                if i != j and f[j] != j + 1:\n                    f[i], f[j] = f[j], f[i]\n                    break\n\n    print(*f)\n\nsolve()\n```",
    "59": "```python\ndef solve():\n    n, x, y = map(int, input().split())\n    s = input()\n    \n    count = 0\n    for i in range(n - x, n):\n        if i == n - 1 - y:\n            if s[i] == '0':\n                count += 1\n        else:\n            if s[i] == '1':\n                count += 1\n    print(count)\n\nsolve()\n```",
    "62": "```python\ndef solve():\n    a, b, c = map(int, input().split())\n    \n    best_cost = float('inf')\n    best_triple = None\n    \n    for A in range(1, 2 * a + 1):\n        for B in range(A, 2 * b + 1, A):\n            for C in range(B, 2 * c + 1, B):\n                cost = abs(a - A) + abs(b - B) + abs(c - C)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_triple = (A, B, C)\n                    \n    print(best_cost)\n    print(*best_triple)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "64": "```python\ndef solve():\n    n, m = map(int, input().split())\n    exams = []\n    for i in range(m):\n        s, d, c = map(int, input().split())\n        exams.append((s, d, c, i + 1))\n    \n    schedule = [0] * n\n    exam_days = {}\n    for s, d, c, i in exams:\n        exam_days[d] = i\n        schedule[d-1] = m + 1\n    \n    preparation_counts = [0] * m\n    \n    for day in range(n):\n        if schedule[day] == 0:\n            best_exam = -1\n            for i in range(m):\n                s, d, c, exam_num = exams[i]\n                if s <= day + 1 < d and preparation_counts[i] < c:\n                    if best_exam == -1:\n                        best_exam = i\n                    else:\n                        s_best, d_best, c_best, exam_num_best = exams[best_exam]\n                        if d < d_best:\n                            best_exam = i\n            \n            if best_exam != -1:\n                schedule[day] = exams[best_exam][3]\n                preparation_counts[best_exam] += 1\n    \n    for i in range(m):\n        if preparation_counts[i] != exams[i][2]:\n            print(\"-1\")\n            return\n    \n    print(*schedule)\n\nsolve()\n```",
    "66": "```python\ndef solve():\n    n, k = map(int, input().split())\n    t = input()\n    \n    if n == 1:\n        print(t * k)\n        return\n    \n    overlap = 0\n    for i in range(1, n):\n        if t[:n-i] == t[i:]:\n            overlap = n - i\n            break\n    \n    result = t + t[overlap:] * (k - 1)\n    print(result)\n\nsolve()\n```",
    "68": "```python\ndef solve():\n    n, k = map(int, input().split())\n    s = input()\n    \n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            dp[i][j] = dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i-1][j-1]\n        \n    counts = [0] * (n + 1)\n    for i in range(n + 1):\n        counts[i] = dp[n][i]\n    \n    \n    total_cost = 0\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ",
    "69": "```python\ndef solve():\n    n, m, d = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n\n    def check_degree(tree_edges):\n        degree = 0\n        for u, v in tree_edges:\n            if u == 1 or v == 1:\n                degree += 1\n        return degree\n\n    def find_spanning_tree(edges, n, d):\n        import itertools\n        for i in range(1 << m):\n            tree_edges = []\n            for j in range(m):\n                if (i >> j) & 1:\n                    tree_edges.append(edges[j])\n\n            if len(tree_edges) != n - 1:\n                continue\n\n            parent = list(range(n + 1))\n\n            def find(i):\n                if parent[i] == i:\n                    return i\n                parent[i] = find(parent[i])\n                return parent[i]\n\n            def union(i, j):\n                root_i = find(i)\n                root_j = find(j)\n                if root_i != root_j:\n                    parent[root_i] = root_j\n                    return True\n                return False\n\n            is_spanning = True\n            num_edges_added = 0\n            for u, v in tree_edges:\n                if union(u, v):\n                    num_edges_added += 1\n\n            if num_edges_added != n - 1:\n                continue\n\n            degree = check_degree(tree_edges)\n            if degree == d:\n                return tree_edges\n        return None\n\n    spanning_tree = find_spanning_tree(edges, n, d)\n\n    if spanning_tree:\n        print(\"YES\")\n        for u, v in spanning_tree:\n            print(u, v)\n    else:\n        print(\"NO\")\n\nsolve()\n```",
    "70": "```python\ndef solve():\n    time1 = input()\n    time2 = input()\n    \n    h1 = int(time1[:2])\n    m1 = int(time1[3:])\n    h2 = int(time2[:2])\n    m2 = int(time2[3:])\n    \n    start_minutes = h1 * 60 + m1\n    end_minutes = h2 * 60 + m2\n    \n    mid_minutes = (start_minutes + end_minutes) // 2\n    \n    h3 = mid_minutes // 60\n    m3 = mid_minutes % 60\n    \n    print(f\"{h3:02}:{m3:02}\")\n\nsolve()\n```",
    "71": "```python\nimport math\n\na = int(input())\nif a == 1:\n    print(1)\nelse:\n    print(math.ceil(math.log(a, 2)))\n```",
    "73": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    stack = []\n    for x in a:\n        if not stack:\n            stack.append(x)\n        elif stack[-1] == x:\n            stack.pop()\n        else:\n            stack.append(x)\n\n    if not stack:\n        print(\"YES\")\n    elif len(stack) == 1:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nsolve()\n```",
    "74": "```python\ndef solve():\n    n, k = map(int, input().split())\n    s = input()\n    \n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            dp[i][j] = dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i-1][j-1]\n            dp[i][j] = min(dp[i][j], k)\n    \n    total_cost = 0\n    \n    for length in range(n, -1, -1):\n        count = dp[n][length]\n        \n        if k > count:\n            total_cost += (n - length) * count\n            k -= count\n        else:\n            total_cost += (n - length) * k\n            k = 0\n            break\n    \n    if k > 0:\n        print(\"-1\")\n    else:\n        print(total_cost)\n\nsolve()\n```",
    "76": "```python\ndef solve():\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        tile = []\n        tile.append(list(map(int, input().split())))\n        tile.append(list(map(int, input().split())))\n        tiles.append(tile)\n\n    if m % 2 != 0:\n        print(\"NO\")\n        return\n\n    found = False\n    for tile in tiles:\n        if tile[0][1] == tile[1][0]:\n            found = True\n            break\n\n    if found:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "77": "```python\nn = int(input())\n\ntotal_sum = n * (n + 1) // 2\n\nif total_sum % 2 == 0:\n  print(0)\nelse:\n  print(1)\n```",
    "78": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    len_s = len(s)\n    mod = 10**9 + 7\n\n    def is_regular(seq):\n        balance = 0\n        for char in seq:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    def count_regular_sequences(n, s):\n        count = 0\n        for i in range(2**(2*n)):\n            seq = \"\"\n            binary = bin(i)[2:].zfill(2*n)\n            for bit in binary:\n                if bit == '0':\n                    seq += '('\n                else:\n                    seq += ')'\n            \n            if is_regular(seq) and s in seq:\n                count = (count + 1) % mod\n        return count\n\n    print(count_regular_sequences(n, s))\n\nsolve()\n```",
    "79": "```python\ndef solve():\n    n = input()\n    n_list = list(n)\n    n_len = len(n)\n    \n    def calculate_moves(arr):\n        moves = 0\n        for i in range(len(arr)):\n            if arr[i] != i:\n                j = arr.index(i)\n                moves += j - i\n                arr = arr[:i] + arr[i:j+1][::-1] + arr[j+1:]\n        return moves\n\n    def check_leading_zeros(s):\n        return len(s) == 1 or s[0] != '0'\n\n    def find_min_moves(digits):\n        min_moves = float('inf')\n        \n        import itertools\n        \n        for p in itertools.permutations(digits):\n            s = \"\".join(p)\n            if check_leading_zeros(s) and int(s) % 25 == 0:\n                \n                arr = list(range(len(digits)))\n                digit_indices = {}\n                for i in range(len(digits)):\n                    if digits[i] not in digit_indices:\n                        digit_indices[digits[i]] = []\n                    digit_indices[digits[i]].append(i)\n                \n                permutation_indices = []\n                for digit in p:\n                    permutation_indices.append(digit_indices[digit].pop(0))\n                \n                moves = calculate_moves(arr)\n                min_moves = min(min_moves, moves)\n        \n        if min_moves == float('inf'):\n            return -1\n        else:\n            return min_moves\n\n    min_moves = float('inf')\n    \n    for i in range(n_len):\n        for j in range(i + 1, n_len):\n            if (int(n_list[i]) * 10 + int(n_list[j])) % 25 == 0:\n                \n                temp_list = n_list[:]\n                \n                moves = 0\n                \n                moves += (n_len - 1) - j\n                temp_list.insert(n_len, temp_list.pop(j))\n                \n                moves += (n_len - 1) - i\n                temp_list.insert(n_len, temp_list.pop(i))\n                \n                first_non_zero = -1\n                for k in range(n_len - 2):\n                    if temp_list[k] != '0':\n                        first_non_zero = k\n                        break\n                \n                if first_non_zero == -1:\n                    if n_len - 2 > 0:\n                        continue\n                else:\n                    moves += first_non_zero\n                    temp_list.insert(0, temp_list.pop(first_non_zero))\n                \n                min_moves = min(min_moves, moves)\n\n    if min_moves == float('inf'):\n        print(\"-1\")\n    else:\n        print(min_moves)\n\nsolve()\n```",
    "80": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    \n    colors = [0] * n\n    \n    def check(num_colors):\n        \n        def is_sortable(coloring):\n            temp_s = list(s)\n            \n            for _ in range(n * (n - 1) // 2):\n                swapped = False\n                for i in range(n - 1):\n                    if temp_s[i] > temp_s[i+1] and coloring[i] != coloring[i+1]:\n                        temp_s[i], temp_s[i+1] = temp_s[i+1], temp_s[i]\n                        swapped = True\n                if not swapped:\n                    break\n            \n            return \"\".join(temp_s) == \"\".join(sorted(s))\n        \n        \n        import itertools\n        \n        for coloring in itertools.product(range(1, num_colors + 1), repeat=n):\n            if is_sortable(coloring):\n                return True, list(coloring)\n        \n        return False, None\n\n    for num_colors in range(1, n + 1):\n        sortable, coloring = check(num_colors)\n        if sortable:\n            print(num_colors)\n            print(*coloring)\n            return\n\nsolve()\n```",
    "81": "```python\ndef solve():\n    n = int(input())\n    strings = []\n    for _ in range(n):\n        strings.append(input())\n\n    strings.sort(key=len)\n\n    for i in range(1, n):\n        found = False\n        for j in range(i):\n            if strings[j] in strings[i]:\n                found = True\n                break\n        if not found:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    for s in strings:\n        print(s)\n\nsolve()\n```",
    "83": "```python\ndef solve():\n    a, b = map(int, input().split())\n    total = a + b\n    \n    best_perimeter = float('inf')\n    \n    for h in range(1, int(total**0.5) + 2):\n        if total % h == 0:\n            w = total // h\n            \n            # Case 1: a forms a rectangle\n            for h_a in range(1, int(a**0.5) + 2):\n                if a % h_a == 0:\n                    w_a = a // h_a\n                    if h_a <= h and w_a <= w:\n                        best_perimeter = min(best_perimeter, 2 * (h + w))\n            \n            # Case 2: b forms a rectangle\n            for h_b in range(1, int(b**0.5) + 2):\n                if b % h_b == 0:\n                    w_b = b // h_b\n                    if h_b <= h and w_b <= w:\n                        best_perimeter = min(best_perimeter, 2 * (h + w))\n    \n    print(best_perimeter)\n\nsolve()\n```",
    "84": "```python\ndef solve():\n    n = int(input())\n    s = input()\n\n    for i in range(1 << n):\n        coloring = \"\"\n        for j in range(n):\n            if (i >> j) & 1:\n                coloring += \"1\"\n            else:\n                coloring += \"0\"\n\n        s0 = \"\"\n        s1 = \"\"\n        for j in range(n):\n            if coloring[j] == '0':\n                s0 += s[j]\n            else:\n                s1 += s[j]\n\n        sorted_s0 = \"\".join(sorted(s0))\n        sorted_s1 = \"\".join(sorted(s1))\n\n        merged = \"\"\n        idx0 = 0\n        idx1 = 0\n        for j in range(n):\n            if coloring[j] == '0':\n                merged += sorted_s0[idx0]\n                idx0 += 1\n            else:\n                merged += sorted_s1[idx1]\n                idx1 += 1\n\n        if \"\".join(sorted(s)) == merged:\n            print(\"YES\")\n            print(coloring)\n            return\n\n    print(\"NO\")\n\nsolve()\n```",
    "86": "```python\ndef solve():\n    n, k = map(int, input().split())\n\n    if k * (k + 1) // 2 > n:\n        print(\"NO\")\n        return\n\n    a = [0] * k\n    for i in range(k):\n        a[i] = i + 1\n\n    remaining = n - k * (k + 1) // 2\n\n    for i in range(k - 1, -1, -1):\n        add = min(remaining, 2 * a[i] - a[i] - 1)\n        a[i] += add\n        remaining -= add\n\n    if remaining > 0:\n        print(\"NO\")\n        return\n    \n    for i in range(k - 1):\n        if a[i+1] <= a[i] or a[i+1] > 2 * a[i]:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(*a)\n\nsolve()\n```",
    "88": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    counts = {}\n    for x in a:\n        counts[x] = counts.get(x, 0) + 1\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    def check():\n        for i in range(n):\n            for j in range(n):\n                if matrix[i][j] != matrix[n-1-i][j] or matrix[i][j] != matrix[i][n-1-j]:\n                    return False\n        return True\n\n    def backtrack(row, col):\n        if row == n:\n            if check():\n                print(\"YES\")\n                for r in matrix:\n                    print(*r)\n                return True\n            else:\n                return False\n        \n        next_row = row\n        next_col = col + 1\n        if next_col == n:\n            next_row += 1\n            next_col = 0\n        \n        for num in list(counts.keys()):\n            if counts[num] > 0:\n                counts[num] -= 1\n                matrix[row][col] = num\n                \n                if backtrack(next_row, next_col):\n                    return True\n                \n                matrix[row][col] = 0\n                counts[num] += 1\n        \n        return False\n\n    if backtrack(0, 0):\n        return\n    else:\n        print(\"NO\")\n\nsolve()\n```",
    "89": "```python\ndef solve():\n    n, r = map(int, input().split())\n    projects = []\n    for _ in range(n):\n        projects.append(list(map(int, input().split())))\n\n    def check(order):\n        current_rating = r\n        for i in order:\n            a, b = projects[i]\n            if current_rating < a:\n                return False\n            current_rating += b\n            if current_rating < 0:\n                return False\n        return True\n\n    import itertools\n    for order in itertools.permutations(range(n)):\n        if check(order):\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nsolve()\n```",
    "90": "```python\ndef solve():\n    n, m, d = map(int, input().split())\n    c = list(map(int, input().split()))\n\n    total_length = sum(c)\n    \n    if d > n + 1:\n        print(\"YES\")\n        result = [0] * n\n        last_index = n - c[0]\n        for i in range(c[0]):\n            result[last_index + i] = 1\n        print(*result)\n        return\n\n    min_empty = (m + 1) * (d - 1)\n    if total_length + min_empty > n:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    result = [0] * n\n    \n    current_pos = 0\n    platform_positions = []\n    \n    for i in range(m):\n        \n        needed_space = d - 1 if i == 0 else d - 1\n        \n        while current_pos + c[i] <= n and current_pos < needed_space:\n            current_pos += 1\n        \n        platform_positions.append(current_pos)\n        \n        for j in range(c[i]):\n            result[current_pos + j] = i + 1\n        \n        current_pos += c[i]\n    \n    print(*result)\n\nsolve()\n```",
    "91": "```python\ndef solve():\n    s = input()\n    t = input()\n    n = len(s)\n    m = len(t)\n    \n    ans = 0\n    for i in range(n + 1):\n        for j in range(i, n + 1):\n            temp_s = \"\"\n            if i > 0:\n                temp_s += s[:i]\n            if j < n:\n                temp_s += s[j:]\n            \n            k = 0\n            l = 0\n            while k < len(temp_s) and l < m:\n                if temp_s[k] == t[l]:\n                    l += 1\n                k += 1\n            \n            if l == m:\n                ans = max(ans, j - i)\n    print(ans)\n\nsolve()\n```",
    "92": "```python\nx = float(input())\n\na = int(x * 10)\nb = int((x * 100) % 10)\n\nprint(a, b)\n```",
    "93": "```python\ndef solve():\n    n, d, k = map(int, input().split())\n\n    if d >= n:\n        print(\"NO\")\n        return\n\n    if d == 1 and n > 2:\n        print(\"NO\")\n        return\n    \n    if k == 1 and n > 2:\n        print(\"NO\")\n        return\n    \n    if d > n - 1:\n        print(\"NO\")\n        return\n\n    edges = []\n    degrees = [0] * (n + 1)\n\n    # Create the diameter path\n    for i in range(d):\n        edges.append((i + 1, i + 2))\n        degrees[i + 1] += 1\n        degrees[i + 2] += 1\n\n    if any(degree > k for degree in degrees[1:]):\n        print(\"NO\")\n        return\n\n    next_node = d + 2\n    for i in range(1, d + 2):\n        while degrees[i] < k and next_node <= n:\n            edges.append((i, next_node))\n            degrees[i] += 1\n            degrees[next_node] += 1\n            next_node += 1\n\n        if next_node > n:\n            break\n\n    if any(degree > k for degree in degrees[1:]):\n        print(\"NO\")\n        return\n\n    if len(edges) != n - 1:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    for u, v in edges:\n        print(u, v)\n\nsolve()\n```",
    "94": "```python\na, b, x = map(int, input().split())\n\nif a > b:\n  start = 0\nelse:\n  start = 1\n\nresult = \"\"\nwhile x > 1:\n  result += str(start)\n  if start == 0:\n    b -= 1\n    start = 1\n  else:\n    a -= 1\n    start = 0\n  x -= 1\n\nif start == 0:\n  result += \"0\" * a + \"1\" * b\nelse:\n  result += \"1\" * b + \"0\" * a\n\nprint(result)\n```",
    "95": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    t = input()\n\n    def check(res, s, t):\n        for i in range(len(res) - 1):\n            sub = res[i:i+2]\n            if sub == s or sub == t:\n                return False\n        return True\n\n    import itertools\n    \n    chars = ['a'] * n + ['b'] * n + ['c'] * n\n    \n    for perm in itertools.permutations(chars):\n        res = \"\".join(perm)\n        if check(res, s, t):\n            print(\"YES\")\n            print(res)\n            return\n    \n    print(\"NO\")\n\nsolve()\n```",
    "96": "```python\ndef solve():\n    n = int(input())\n    q = list(map(int, input().split()))\n\n    for first_element in range(1, n + 1):\n        p = [first_element]\n        valid = True\n        for i in range(n - 1):\n            next_element = p[-1] + q[i]\n            p.append(next_element)\n\n        seen = set()\n        for x in p:\n            if x < 1 or x > n or x in seen:\n                valid = False\n                break\n            seen.add(x)\n\n        if valid and len(seen) == n:\n            print(*p)\n            return\n\n    print(-1)\n\nsolve()\n```",
    "97": "```python\ndef solve():\n    n = int(input())\n    x = list(map(int, input().split()))\n\n    ans = float('inf')\n    for target in range(1, 101):\n        cost = 0\n        for val in x:\n            cost += abs(val - target) % 2\n        ans = min(ans, cost)\n    print(ans)\n\nsolve()\n```",
    "99": "```python\ndef solve():\n    n = int(input())\n    a1, a2, a3 = map(int, input().split())\n    b1, b2, b3 = map(int, input().split())\n\n    min_wins = max(0, a1 - (b1 + b3 - a2 - a3), a2 - (b2 + b1 - a1 - a3), a3 - (b3 + b2 - a1 - a2))\n    \n    max_wins = min(a1, b2) + min(a2, b3) + min(a3, b1)\n\n    print(min_wins, max_wins)\n\nsolve()\n```"
}