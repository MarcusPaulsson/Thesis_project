{
    "0": "```python\ndef solve():\n    s = input()\n    n = len(s)\n    \n    max_len = -1\n    \n    for i in range(n):\n        if s[i] == '[':\n            for j in range(i + 1, n):\n                if s[j] == ']':\n                    for k in range(i + 1, j):\n                        if s[k] == ':':\n                            for l in range(k + 1, j):\n                                if s[l] == ':':\n                                    \n                                    \n                                    vertical_bars_count = 0\n                                    for m in range(k + 1, l):\n                                        if s[m] == '|':\n                                            vertical_bars_count += 1\n                                    \n                                    current_len = 2 + 2 + vertical_bars_count\n                                    max_len = max(max_len, current_len)\n                                    \n    print(max_len)\n\nsolve()\n```",
    "1": "```python\ndef solve():\n    x = int(input())\n    s = str(x)\n    n = len(s)\n    \n    best_num = x\n    best_sum = sum(int(digit) for digit in s)\n    \n    for i in range(n):\n        if s[i] == '0':\n            continue\n        \n        num_str = s[:i] + str(int(s[i]) - 1) + '9' * (n - i - 1)\n        num = int(num_str)\n        \n        if num <= x:\n            current_sum = sum(int(digit) for digit in num_str)\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_num = num\n            elif current_sum == best_sum and num > best_num:\n                best_num = num\n    \n    print(best_num)\n\nsolve()\n```",
    "2": "```python\ndef solve():\n    n = int(input())\n    s = str(n)\n    l = len(s)\n    \n    first_digit = int(s[0])\n    \n    next_lucky = (first_digit + 1) * (10**(l-1))\n    \n    print(next_lucky - n)\n\nsolve()\n```",
    "4": "```python\ndef solve():\n    x = int(input())\n    hh, mm = map(int, input().split())\n    \n    count = 0\n    while True:\n        h_str = str(hh).zfill(2)\n        m_str = str(mm).zfill(2)\n        \n        if '7' in h_str or '7' in m_str:\n            print(count)\n            return\n        \n        minutes = hh * 60 + mm\n        minutes -= x\n        \n        if minutes < 0:\n            minutes += 24 * 60\n            \n        hh = minutes // 60 % 24\n        mm = minutes % 60\n        \n        count += 1\n\nsolve()\n```",
    "6": "```python\ndef solve():\n    n, x = map(int, input().split())\n    blows = []\n    for _ in range(n):\n        blows.append(list(map(int, input().split())))\n\n    max_damage = 0\n    for d, h in blows:\n        max_damage = max(max_damage, d)\n\n    if max_damage >= x:\n        print(1)\n        return\n\n    max_diff = 0\n    for d, h in blows:\n        max_diff = max(max_diff, d - h)\n\n    if max_diff <= 0:\n        print(-1)\n        return\n    \n    remaining = x - max_damage\n    \n    ans = 1 + (remaining + max_diff - 1) // max_diff\n    print(ans)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "7": "```python\nn, m = map(int, input().split())\n\nlow = 0\nhigh = 2 * 10**9\nans = high\n\nwhile low <= high:\n    mid = (low + high) // 2\n    \n    total_sparrows = mid * (mid + 1) // 2\n    \n    grains_eaten = 0\n    \n    if total_sparrows >= n:\n      grains_eaten = n\n    else:\n      grains_eaten = total_sparrows\n      \n    \n    total_added = 0\n    \n    num_cycles = n // m\n    \n    if num_cycles >= mid:\n        total_added = mid * m\n    else:\n        total_added = num_cycles * m\n        \n    \n    \n    \n    current_grains = n + total_added - grains_eaten\n    \n    if current_grains <= 0:\n        ans = mid\n        high = mid - 1\n    else:\n        low = mid + 1\n\nprint(ans)\n```",
    "8": "```python\ndef solve():\n  s = input().split()\n  \n  def check_mentsu(tiles):\n    # Check koutsu\n    counts = {}\n    for tile in tiles:\n      if tile not in counts:\n        counts[tile] = 0\n      counts[tile] += 1\n    \n    for tile in counts:\n      if counts[tile] >= 3:\n        return True\n    \n    # Check shuntsu\n    nums = {'m': [], 'p': [], 's': []}\n    for tile in tiles:\n      nums[tile[1]].append(int(tile[0]))\n    \n    for suit in ['m', 'p', 's']:\n      nums[suit].sort()\n      if len(nums[suit]) >= 3:\n        for i in range(len(nums[suit]) - 2):\n          if nums[suit][i+1] == nums[suit][i] + 1 and nums[suit][i+2] == nums[suit][i] + 2:\n            return True\n    \n    return False\n  \n  if check_mentsu(s):\n    print(0)\n    return\n  \n  # Check if adding one tile can create a mentsu\n  for i in range(1, 10):\n    for suit in ['m', 'p', 's']:\n      new_tile = str(i) + suit\n      temp_tiles = s + [new_tile]\n      if check_mentsu(temp_tiles):\n        print(1)\n        return\n  \n  print(2)\n  \nsolve()\n```",
    "9": "```python\ndef solve():\n    d = int(input())\n    n, m = map(int, input().split())\n    sofas = []\n    for _ in range(d):\n        sofas.append(list(map(int, input().split())))\n    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n    \n    def count_sofas(sofa_index):\n        l, r, t, b = 0, 0, 0, 0\n        x1_s, y1_s, x2_s, y2_s = sofas[sofa_index]\n        \n        for i in range(d):\n            if i == sofa_index:\n                continue\n            x1, y1, x2, y2 = sofas[i]\n            \n            # Check left\n            if min(y1_s, y2_s) > max(y1, y2):\n                l_found = False\n                if x1_s < x1:\n                  l_found = True\n                if x2_s < x1:\n                  l_found = True\n                if x1_s < x2:\n                  l_found = True\n                if x2_s < x2:\n                  l_found = True\n                if l_found:\n                  l += 1\n                  continue\n                  \n            if min(y1_s, y2_s) > max(y2, y1):\n                l_found = False\n                if x1_s < x1:\n                  l_found = True\n                if x2_s < x1:\n                  l_found = True\n                if x1_s < x2:\n                  l_found = True\n                if x2_s < x2:\n                  l_found = True\n                if l_found:\n                  l += 1\n                  continue\n\n            # Check right\n            if min(y1_s, y2_s) < max(y1, y2):\n                r_found = False\n                if x1_s > x1:\n                  r_found = True\n                if x2_s > x1:\n                  r_found = True\n                if x1_s > x2:\n                  r_found = True\n                if x2_s > x2:\n                  r_found = True\n                if r_found:\n                  r += 1\n                  continue\n            \n            if min(y1_s, y2_s) < max(y2, y1):\n                r_found = False\n                if x1_s > x1:\n                  r_found = True\n                if x2_s > x1:\n                  r_found = True\n                if x1_s > x2:\n                  r_found = True\n                if x2_s > x2:\n                  r_found = True\n                if r_found:\n                  r += 1\n                  continue\n\n            # Check top\n            if min(x1_s, x2_s) > max(x1, x2):\n                t_found = False\n                if y1_s < y1:\n                  t_found = True\n                if y2_s < y1:\n                  t_found = True\n                if y1_s < y2:\n                  t_found = True\n                if y2_s < y2:\n                  t_found = True\n                if t_found:\n                  t += 1\n                  continue\n            \n            if min(x1_s, x2_s) > max(x2, x1):\n                t_found = False\n                if y1_s < y1:\n                  t_found = True\n                if y2_s < y1:\n                  t_found = True\n                if y1_s < y2:\n                  t_found = True\n                if y2_s < y2:\n                  t_found = True\n                if t_found:\n                  t += 1\n                  continue\n\n            # Check bottom\n            if min(x1_s, x2_s) < max(x1, x2):\n                b_found = False\n                if y1_s > y1:\n                  b_found = True\n                if y2_s > y1:\n                  b_found = True\n                if y1_s > y2:\n                  b_found = True\n                if y2_s > y2:\n                  b_found = True\n                if b_found:\n                  b += 1\n                  continue\n\n            if min(x1_s, x2_s) < max(x2, x1):\n                b_found = False\n                if y1_s > y1:\n                  b_found = True\n                if y2_s > y1:\n                  b_found = True\n                if y1_s > y2:\n                  b_found = True\n                if y2_s > y2:\n                  b_found = True\n                if b_found:\n                  b += 1\n                  continue\n\n\n        return l, r, t, b\n\n    result = -1\n    for i in range(d):\n        l, r, t, b = count_sofas(i)\n        if l == cnt_l and r == cnt_r and t == cnt_t and b == cnt_b:\n            result = i + 1\n            break\n    \n    print(result)\n\nsolve()\n```",
    "10": "```python\ndef solve():\n  n = int(input())\n  \n  min_days_off = (n // 7) * 2\n  max_days_off = (n // 7) * 2\n  \n  remaining_days = n % 7\n  \n  if remaining_days == 1:\n    min_days_off += 0\n    max_days_off += 1\n  elif remaining_days == 2:\n    min_days_off += 0\n    max_days_off += 2\n  elif remaining_days == 3:\n    min_days_off += 0\n    max_days_off += 2\n  elif remaining_days == 4:\n    min_days_off += 0\n    max_days_off += 2\n  elif remaining_days == 5:\n    min_days_off += 0\n    max_days_off += 2\n  elif remaining_days == 6:\n    min_days_off += 1\n    max_days_off += 2\n    \n  print(min_days_off, max_days_off)\n\nsolve()\n```",
    "11": "```python\ndef solve():\n    n, a, b, p, q = map(int, input().split())\n    \n    red_count = n // a\n    blue_count = n // b\n    \n    lcm = (a * b) // gcd(a, b)\n    \n    common_count = n // lcm\n    \n    red_only = red_count - common_count\n    blue_only = blue_count - common_count\n    \n    total_chocolates = red_only * p + blue_only * q\n    \n    if p > q:\n        total_chocolates += common_count * p\n    else:\n        total_chocolates += common_count * q\n        \n    print(total_chocolates)\n    \ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\nsolve()\n```",
    "13": "```python\nfrom collections import defaultdict, deque\n\ndef solve():\n    n, k = map(int, input().split())\n    main_courses = list(map(int, input().split()))\n    dependencies = []\n    for _ in range(n):\n        dependencies.append(list(map(int, input().split()))[1:])\n\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    for i in range(n):\n        for dep in dependencies[i]:\n            graph[dep].append(i + 1)\n            in_degree[i + 1] += 1\n\n    q = deque()\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            q.append(i)\n\n    result = []\n    count = 0\n    while q:\n        node = q.popleft()\n        result.append(node)\n        count += 1\n\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                q.append(neighbor)\n\n    if count != n:\n        print(\"-1\")\n        return\n\n    required_courses = set(main_courses)\n    visited = [False] * (n + 1)\n    path = []\n\n    def dfs(course):\n        if visited[course]:\n            return\n        visited[course] = True\n        for dep in dependencies[course-1]:\n            if not visited[dep]:\n                dfs(dep)\n                \n        path.append(course)\n\n    for course in main_courses:\n        if not visited[course]:\n            dfs(course)\n\n    path.reverse()\n    \n    final_path = []\n    final_set = set()\n    \n    for course in path:\n        if course not in final_set:\n            final_path.append(course)\n            final_set.add(course)\n    \n    \n    main_courses_present = True\n    for course in main_courses:\n        if course not in final_set:\n            main_courses_present = False\n            break\n            \n    if not main_courses_present:\n        print(\"-1\")\n        return\n\n    print(len(final_path))\n    print(*final_path)\n\nsolve()\n```",
    "14": "```python\ndef solve():\n    n, k = map(int, input().split())\n    p = list(map(int, input().split()))\n\n    used = set(p)\n    remaining = []\n    for i in range(n, 0, -1):\n        if i not in used:\n            remaining.append(i)\n\n    p = p + remaining\n    \n    def is_stack_sortable(arr):\n        stack = []\n        b = []\n        \n        def can_sort(a, s, b):\n            if not a and not s:\n                for i in range(len(b) - 1):\n                    if b[i] > b[i+1]:\n                        return False\n                return True\n            \n            if a:\n                new_s = s + [a[0]]\n                new_a = a[1:]\n                if can_sort(new_a, new_s, b):\n                    return True\n            \n            if s:\n                new_b = b + [s[-1]]\n                new_s = s[:-1]\n                if can_sort(a, new_s, new_b):\n                    return True\n            \n            return False\n        \n        return can_sort(arr, [], [])\n\n    if is_stack_sortable(p):\n        print(*p)\n    else:\n        print(-1)\n\nsolve()\n```",
    "16": "```python\ndef solve():\n  cnt1 = int(input())\n  cnt2 = int(input())\n  cnt3 = int(input())\n  cnt4 = int(input())\n\n  if cnt1 == cnt4 and cnt1 >= 0 and cnt4 >= 0:\n      print(1)\n  else:\n      print(0)\n\nsolve()\n```",
    "17": "```python\ndef solve():\n    n, k, t = map(int, input().split())\n    \n    if t <= k:\n        print(t)\n    elif t <= n:\n        print(k)\n    else:\n        print(k - (t - n))\n\nsolve()\n```",
    "18": "```python\ndef solve():\n  s = input()\n  n = len(s)\n  t = \"\"\n  u = \"\"\n  \n  suffix_min = [0] * (n + 1)\n  suffix_min[n] = 'z'\n  for i in range(n - 1, -1, -1):\n    suffix_min[i] = min(s[i], suffix_min[i+1])\n  \n  i = 0\n  while i < n or len(t) > 0:\n    if len(t) > 0 and t[-1] <= suffix_min[i] :\n      u += t[-1]\n      t = t[:-1]\n    else:\n      if i < n:\n        t += s[i]\n        i += 1\n      else:\n          u += t[-1]\n          t = t[:-1]\n        \n  print(u)\n\nsolve()\n```",
    "19": "```python\ndef solve():\n  n = int(input())\n  pairs = []\n  for _ in range(n):\n    pairs.append(list(map(int, input().split())))\n\n  possible = True\n  for i in range(n):\n    if pairs[i][1] > pairs[i][0]:\n      possible = False\n      break\n\n    if i > 0:\n      if pairs[i][0] < pairs[i-1][0] or pairs[i][1] < pairs[i-1][1]:\n        possible = False\n        break\n\n      if pairs[i][0] - pairs[i-1][0] < pairs[i][1] - pairs[i-1][1]:\n        possible = False\n        break\n\n  if possible:\n    print(\"YES\")\n  else:\n    print(\"NO\")\n\nt = int(input())\nfor _ in range(t):\n  solve()\n```",
    "20": "```python\ndef solve():\n    s = input()\n    hh = int(s[:2])\n    mm = int(s[3:])\n    \n    ans = 0\n    while True:\n        hh_str = str(hh).zfill(2)\n        mm_str = str(mm).zfill(2)\n        \n        if hh_str == mm_str[::-1]:\n            print(ans)\n            return\n        \n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        \n        ans += 1\n\nsolve()\n```",
    "21": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    pos_1 = a.index(1)\n    pos_n = a.index(n)\n\n    ans = 0\n    \n    # Try swapping 1 with the element at the beginning\n    ans = max(ans, abs(0 - pos_n))\n    \n    # Try swapping 1 with the element at the end\n    ans = max(ans, abs(n - 1 - pos_n))\n    \n    # Try swapping n with the element at the beginning\n    ans = max(ans, abs(0- pos_1))\n    \n    # Try swapping n with the element at the end\n    ans = max(ans, abs(n-1- pos_1))\n    \n    print(ans)\n\nsolve()\n```",
    "22": "```python\ndef solve():\n    s = input()\n    n = len(s)\n    mirrors = {\n        'b': 'd',\n        'd': 'b',\n        'o': 'o',\n        'p': 'q',\n        'q': 'p',\n        'v': 'v',\n        'w': 'w',\n        'x': 'x',\n        'A': 'A',\n        'H': 'H',\n        'I': 'I',\n        'M': 'M',\n        'O': 'O',\n        'T': 'T',\n        'U': 'U',\n        'V': 'V',\n        'W': 'W',\n        'X': 'X',\n        'Y': 'Y'\n    }\n    \n    for i in range((n + 1) // 2):\n        if s[i] not in mirrors or mirrors[s[i]] != s[n - 1 - i]:\n            print(\"NIE\")\n            return\n    \n    print(\"TAK\")\n\nsolve()\n```",
    "23": "```python\nfrom collections import Counter\n\ndef solve():\n    a = input()\n    b = input()\n    \n    a_digits = sorted(list(a), reverse=True)\n    \n    def find_max_permutation(digits, target, index, current_num):\n        if index == len(target):\n            return current_num if current_num <= target else \"\"\n\n        available_digits = Counter(digits)\n        \n        for digit in sorted(list(set(digits)), reverse=True):\n            if available_digits[digit] > 0:\n                remaining_digits = list(digits)\n                remaining_digits.remove(digit)\n                \n                new_num = current_num + digit\n                \n                if new_num < target[:index+1]:\n                    remaining_digits.sort(reverse=True)\n                    return new_num + \"\".join(remaining_digits)\n                elif new_num == target[:index+1]:\n                    res = find_max_permutation(remaining_digits, target, index + 1, new_num)\n                    if res:\n                        return res\n                \n        return \"\"\n    \n    if len(a) < len(b):\n        a_digits.sort(reverse=True)\n        print(\"\".join(a_digits))\n    elif len(a) == len(b):\n        res = find_max_permutation(list(a), b, 0, \"\")\n        print(res)\n    \nsolve()\n```",
    "24": "```python\ndef solve():\n    board = []\n    for _ in range(10):\n        board.append(list(input()))\n\n    def check_win(board):\n        # Check rows\n        for i in range(10):\n            for j in range(6):\n                if all(board[i][j + k] == 'X' for k in range(5)):\n                    return True\n\n        # Check columns\n        for j in range(10):\n            for i in range(6):\n                if all(board[i + k][j] == 'X' for k in range(5)):\n                    return True\n\n        # Check diagonals (top-left to bottom-right)\n        for i in range(6):\n            for j in range(6):\n                if all(board[i + k][j + k] == 'X' for k in range(5)):\n                    return True\n\n        # Check diagonals (top-right to bottom-left)\n        for i in range(6):\n            for j in range(4, 10):\n                if all(board[i + k][j - k] == 'X' for k in range(5)):\n                    return True\n\n        return False\n\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                board[i][j] = 'X'\n                if check_win(board):\n                    print('YES')\n                    return\n                board[i][j] = '.'\n\n    print('NO')\n\nsolve()\n```",
    "25": "```python\ndef solve():\n    n, k = map(int, input().split())\n    \n    if k > n * n:\n        print(\"-1\")\n        return\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k == 0:\n            break\n        if matrix[i][i] == 0 and k > 0:\n            matrix[i][i] = 1\n            k -= 1\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if k >= 2:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n    \n    if k > 0:\n        print(\"-1\")\n        return\n    \n    for row in matrix:\n        print(*row)\n\nsolve()\n```",
    "26": "```python\nx, y, z = map(float, input().split())\n\na1 = x**(y**z)\na2 = x**(z**y)\na3 = (x**y)**z\na4 = (x**z)**y\na5 = y**(x**z)\na6 = y**(z**x)\na7 = (y**x)**z\na8 = (y**z)**x\na9 = z**(x**y)\na10 = z**(y**x)\na11 = (z**x)**y\na12 = (z**y)**x\n\nvalues = [a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12]\nexpressions = [\"x^y^z\", \"x^z^y\", \"(x^y)^z\", \"(x^z)^y\", \"y^x^z\", \"y^z^x\", \"(y^x)^z\", \"(y^z)^x\", \"z^x^y\", \"z^y^x\", \"(z^x)^y\", \"(z^y)^x\"]\n\nmax_val = -1\nmax_index = -1\n\nfor i in range(len(values)):\n    if values[i] > max_val:\n        max_val = values[i]\n        max_index = i\n\nprint(expressions[max_index])\n```",
    "27": "```python\ndef solve():\n  n = int(input())\n  s = input()\n  \n  ans = n\n  \n  for i in range(1, n // 2 + 1):\n    prefix = s[:i]\n    if s[:2*i].startswith(prefix):\n      ans = min(ans, i + 1 + (n - 2*i))\n    \n  print(ans)\n\nsolve()\n```",
    "28": "```python\ndef solve():\n    n = int(input())\n    files = []\n    for _ in range(n):\n        files.append(input().split())\n\n    examples = []\n    regular = []\n    for i in range(n):\n        if files[i][1] == '1':\n            examples.append((files[i][0], i))\n        else:\n            regular.append((files[i][0], i))\n\n    moves = []\n    \n    num_examples = len(examples)\n    num_regular = len(regular)\n\n    # Move examples to 1, 2, ..., num_examples\n    for i in range(num_examples):\n        if examples[i][0] != str(i + 1):\n            \n            if any(files[j][0] == str(i+1) for j in range(n)):\n                temp_name = generate_temp_name(files)\n                moves.append(f\"move {str(i+1)} {temp_name}\")\n                \n                # update files\n                for j in range(n):\n                    if files[j][0] == str(i+1):\n                        files[j][0] = temp_name\n                        break\n                \n            moves.append(f\"move {examples[i][0]} {str(i + 1)}\")\n            \n            # update files\n            for j in range(n):\n                if files[j][0] == examples[i][0]:\n                    files[j][0] = str(i+1)\n                    break\n            \n    # Move regular to num_examples + 1, num_examples + 2, ..., n\n    for i in range(num_regular):\n        if regular[i][0] != str(num_examples + i + 1):\n            \n            if any(files[j][0] == str(num_examples + i + 1) for j in range(n)):\n                temp_name = generate_temp_name(files)\n                moves.append(f\"move {str(num_examples + i + 1)} {temp_name}\")\n\n                # update files\n                for j in range(n):\n                    if files[j][0] == str(num_examples + i + 1):\n                        files[j][0] = temp_name\n                        break\n                        \n            moves.append(f\"move {regular[i][0]} {str(num_examples + i + 1)}\")\n            \n            # update files\n            for j in range(n):\n                if files[j][0] == regular[i][0]:\n                    files[j][0] = str(num_examples + i + 1)\n                    break\n            \n    print(len(moves))\n    for move in moves:\n        print(move)\n\ndef generate_temp_name(files):\n    import random\n    import string\n    while True:\n        temp_name = ''.join(random.choices(string.ascii_lowercase + string.digits, k=6))\n        if not any(files[i][0] == temp_name for i in range(len(files))):\n            return temp_name\n\nsolve()\n```",
    "29": "```python\ndef solve():\n    s = input()\n    digits = [int(c) for c in s]\n    \n    ans = 6\n    for i in range(1000):\n        s1 = str(i).zfill(3)\n        sum1 = sum(int(c) for c in s1)\n        \n        for j in range(1000):\n            s2 = str(j).zfill(3)\n            sum2 = sum(int(c) for c in s2)\n            \n            if sum1 == sum2:\n                \n                temp_digits = [int(c) for c in s1 + s2]\n                \n                diff = 0\n                \n                for k in range(6):\n                    if digits[k] != temp_digits[k]:\n                        diff += 1\n                \n                ans = min(ans, diff)\n                \n    print(ans)\n\nsolve()\n```",
    "30": "```python\ndef solve():\n    m, x = map(int, input().split())\n    print(m - 1)\n\nsolve()\n```",
    "31": "```python\ndef solve():\n    n, k = map(int, input().split())\n    mod = 10**6 + 3\n    \n    if n > 63 and k > 1:\n        print(1, 1)\n        return\n\n    if k > (1 << n):\n        print(1, 1)\n        return\n    \n    num = 1\n    den = 1\n    \n    for i in range(int(k)):\n        num = (num * ((1 << n) % mod - i % mod)) % mod\n        den = (den * ((1)% mod)) % mod\n        \n    den = pow((1 << (n * int(k))) % mod, mod - 2, mod)\n    \n    prob_diff = (num * den) % mod\n    prob_same = (1 - prob_diff + mod) % mod\n    \n    g = gcd(prob_same, (1 << (n * int(k))) % mod)\n    \n    \n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n    \n    \n    \n    g = gcd(prob_same, pow(2, n*int(k)))\n    \n    \n    \n    num_gcd = gcd(prob_same, pow(2, n*int(k)))\n    den_gcd = gcd(1, pow(2, n*int(k)))\n    \n    \n    num_gcd = gcd(prob_same, pow(2, int(n*k)))\n    den_gcd = gcd(1, pow(2, int(n*k)))\n\n    \n    \n    \n    num_final = 1\n    den_final = 1\n    \n    \n    \n    \n    \n    num = 1\n    den = 1\n    \n    for i in range(int(k)):\n        num = (num * ((1 << n) - i))\n        den = (den * (1))\n    \n    den = pow(1 << (n * int(k)), 1, mod)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    num = 1\n    den = 1\n    \n    for i in range(int(k)):\n        num = (num * ((1 << n) % mod - i % mod)) % mod\n        den = (den * (1 % mod)) % mod\n    \n    den = pow((1 << (n * int(k))) % mod, mod - 2, mod)\n    \n    prob_diff = (num * den) % mod\n    prob_same = (1 - prob_diff + mod) % mod\n    \n    a = prob_same\n    b = 1\n    \n\n    print(a, 1)\n\nsolve()\n```",
    "32": "```python\ndef solve():\n    n = int(input())\n    \n    current_pos = 0  # 0 is North Pole, 20000 is South Pole\n    \n    for _ in range(n):\n        t, direction = input().split()\n        t = int(t)\n        \n        if current_pos == 0 and direction != \"South\":\n            print(\"NO\")\n            return\n        \n        if current_pos == 20000 and direction != \"North\":\n            print(\"NO\")\n            return\n        \n        if direction == \"South\":\n            current_pos += t\n            if current_pos > 20000:\n                current_pos = 20000\n        elif direction == \"North\":\n            current_pos -= t\n            if current_pos < 0:\n                current_pos = 0\n        \n    if current_pos == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nsolve()\n```",
    "33": "```python\nimport math\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef extended_gcd(a, b):\n    if a == 0:\n        return b, 0, 1\n    d, x1, y1 = extended_gcd(b % a, a)\n    x = y1 - (b // a) * x1\n    y = x1\n    return d, x, y\n\ndef solve():\n    a1, b1, a2, b2, L, R = map(int, input().split())\n\n    g = gcd(a1, a2)\n    \n    if (b2 - b1) % g != 0:\n        print(0)\n        return\n\n    d, x, y = extended_gcd(a1, a2)\n    x *= (b2 - b1) // d\n    y *= (b2 - b1) // d\n\n    lcm = a1 * a2 // g\n\n    x0 = x\n    y0 = y\n\n    t = math.ceil((-x0) / (a2 // g))\n    x0 += (a2 // g) * t\n    y0 -= (a1 // g) * t\n\n    val = a1 * x0 + b1\n    \n    if val < L:\n        t = math.ceil((L - val) / lcm)\n        val += lcm * t\n    \n    if val > R:\n        print(0)\n        return\n\n    count = (R - val) // lcm + 1\n    print(count)\n\nsolve()\n```",
    "34": "```python\ndef solve():\n    n, a, b = map(int, input().split())\n    \n    ans = 0\n    for i in range(1, n):\n        if i >= 1 and i < n:\n            x = a // i\n            y = b // (n - i)\n            if x > 0 and y > 0:\n                ans = max(ans, min(x, y))\n    print(ans)\n\nsolve()\n```",
    "35": "```python\ndef solve():\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n)]\n\n    def check_horizontal(n, m, grid):\n        if n % 3 != 0:\n            return False\n        stripe_height = n // 3\n        colors = []\n        for i in range(3):\n            colors.append(grid[i * stripe_height][0])\n        if len(set(colors)) != 3:\n            return False\n        \n        for i in range(n):\n            expected_color_index = i // stripe_height\n            expected_color = colors[expected_color_index]\n            for j in range(m):\n                if grid[i][j] != expected_color:\n                    return False\n        return True\n\n    def check_vertical(n, m, grid):\n        if m % 3 != 0:\n            return False\n        stripe_width = m // 3\n        colors = []\n        for i in range(3):\n            colors.append(grid[0][i * stripe_width])\n        if len(set(colors)) != 3:\n            return False\n        \n        for j in range(m):\n            expected_color_index = j // stripe_width\n            expected_color = colors[expected_color_index]\n            for i in range(n):\n                if grid[i][j] != expected_color:\n                    return False\n        return True\n\n    if check_horizontal(n, m, grid) or check_vertical(n, m, grid):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nsolve()\n```",
    "36": "```python\ndef solve():\n    n = int(input())\n    \n    if n == 0:\n        print(0, 0)\n        return\n\n    k = 0\n    while True:\n        if 3 * k * (k + 1) >= n:\n            break\n        k += 1\n\n    moves_in_prev_layer = 3 * (k - 1) * k if k > 0 else 0\n    rem = n - moves_in_prev_layer\n    \n    x = 2 * k\n    y = 0\n\n    if rem <= k:\n        x -= 2 * rem\n        print(x, y)\n    elif rem <= 2 * k:\n        x -= 2 * k\n        rem -= k\n        x += rem\n        y += 2 * rem\n        print(x, y)\n    elif rem <= 3 * k:\n        rem -= 2 * k\n        x += k\n        y += 2 * k\n        x -= rem\n        print(x, y)\n    elif rem <= 4 * k:\n        rem -= 3 * k\n        x += k\n        y += 2 * k\n        x -= 2 * rem\n        y -= rem * 2\n        print(x, y)\n    elif rem <= 5 * k:\n        rem -= 4 * k\n        x -= k \n        y -= 2 * k\n        x -= rem\n        y -= 2 * rem\n        print(x, y)\n    else:\n        rem -= 5 * k\n        x -= 2 * k\n        y -= 0\n        x += rem * 1\n        y -= rem * 2\n        print(x, y)\n\nsolve()\n```",
    "37": "```python\ndef solve():\n    a, b, c = map(int, input().split())\n    \n    for i in range(c // a + 1):\n        remaining_damage = c - i * a\n        if remaining_damage >= 0 and remaining_damage % b == 0:\n            print(\"Yes\")\n            return\n    \n    print(\"No\")\n\nsolve()\n```",
    "38": "```python\ndef solve():\n    n, l = map(int, input().split())\n    kefa = list(map(int, input().split()))\n    sasha = list(map(int, input().split()))\n\n    for start_diff in range(l):\n        possible = True\n        shifted_kefa = [(x + start_diff) % l for x in kefa]\n        shifted_kefa.sort()\n        \n        if shifted_kefa == sasha:\n            print(\"YES\")\n            return\n    \n    print(\"NO\")\n\nsolve()\n```",
    "41": "```python\ndef nearest_zero(arr):\n  \"\"\"\n  Finds the distance to the nearest zero for each element in the array.\n\n  Args:\n    arr: A list of integers.\n\n  Returns:\n    A list of integers representing the distances to the nearest zero.\n  \"\"\"\n\n  n = len(arr)\n  distances = [float('inf')] * n\n\n  # Forward pass: find distances to the nearest zero from the left\n  last_zero = float('-inf')\n  for i in range(n):\n    if arr[i] == 0:\n      last_zero = i\n    if last_zero != float('-inf'):\n      distances[i] = min(distances[i], i - last_zero)\n\n  # Backward pass: find distances to the nearest zero from the right\n  last_zero = float('inf')\n  for i in range(n - 1, -1, -1):\n    if arr[i] == 0:\n      last_zero = i\n    if last_zero != float('inf'):\n      distances[i] = min(distances[i], last_zero - i)\n\n  return distances\n\n\nif __name__ == \"__main__\":\n  n = int(input())\n  arr = list(map(int, input().split()))\n  distances = nearest_zero(arr)\n  print(*distances)\n```",
    "42": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    \n    count = 0\n    distinct_strings = set()\n    \n    for i in range(2**n):\n        binary_string = bin(i)[2:].zfill(n)\n        \n        is_substring = False\n        for j in range(n):\n            shifted_string = binary_string[j:] + binary_string[:j]\n            if s in shifted_string:\n                is_substring = True\n                break\n        \n        if is_substring:\n            if binary_string not in distinct_strings:\n                count += 1\n                distinct_strings.add(binary_string)\n    \n    print(count)\n\nsolve()\n```",
    "43": "```python\nimport math\n\ndef solve():\n    n = int(input())\n    vectors = []\n    for i in range(n):\n        x, y = map(int, input().split())\n        vectors.append((x, y))\n    \n    angles = []\n    for x, y in vectors:\n        angle = math.atan2(y, x)\n        angles.append(angle)\n    \n    min_angle_diff = float('inf')\n    best_pair = (-1, -1)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            angle1 = angles[i]\n            angle2 = angles[j]\n            \n            diff = abs(angle1 - angle2)\n            diff = min(diff, 2 * math.pi - diff)\n            \n            if diff < min_angle_diff:\n                min_angle_diff = diff\n                best_pair = (i + 1, j + 1)\n    \n    print(best_pair[0], best_pair[1])\n\nsolve()\n```",
    "44": "```python\nd, k, a, b, t = map(int, input().split())\n\nif d <= k:\n  print(d * a)\nelse:\n  if a * k + t >= b * k:\n    print(k * a + (d - k) * b)\n  else:\n    num_breaks = d // k\n    remainder = d % k\n    \n    time = num_breaks * (k * a + t)\n    \n    if remainder > 0:\n      time += min(remainder * a, remainder * b + t)\n    else:\n      time -= t\n    \n    print(time)\n```",
    "45": "```python\ndef solve():\n    n, k = map(int, input().split())\n\n    if k * (k + 1) // 2 > n:\n        print(-1)\n        return\n\n    best_gcd = 0\n    best_seq = []\n\n    for gcd in range(int(n**0.5), 0, -1):\n        if n % gcd == 0:\n            \n            q = n // gcd\n            if q >= k * (k + 1) // 2:\n                \n                seq = [gcd * i for i in range(1, k)]\n                seq.append(n - sum(seq))\n                \n                if all(seq[i] < seq[i+1] for i in range(len(seq) - 1)):\n                  \n                  print(*seq)\n                  return\n\n            \n            if gcd != q:\n              if gcd >= k * (k + 1) // 2:\n\n                  seq = [q * i for i in range(1, k)]\n                  seq.append(n - sum(seq))\n                  \n                  if all(seq[i] < seq[i+1] for i in range(len(seq) - 1)):\n                    \n                    print(*seq)\n                    return\n    \n    print(-1)\n\nsolve()\n```",
    "46": "```python\nn, m = map(int, input().split())\ncount = 0\nfor x in range(1, n + 1):\n    for y in range(1, m + 1):\n        if (x + y) % 5 == 0:\n            count += 1\nprint(count)\n```",
    "47": "```python\ndef solve():\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    ans = 0\n    for i in range(n + 1):\n        for j in range(i, n + 1):\n            temp_a = a[:]\n            for k in range(i, j):\n                temp_a[k] *= x\n\n            current_max = 0\n            max_so_far = 0\n            for num in temp_a:\n                current_max += num\n                if current_max < 0:\n                    current_max = 0\n                max_so_far = max(max_so_far, current_max)\n            ans = max(ans, max_so_far)\n            \n    print(ans)\n\nsolve()\n```",
    "48": "```python\ndef solve():\n    n, m, k = map(int, input().split())\n\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(m, x // i)\n        return count\n\n    low = 1\n    high = n * m\n    ans = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if count_less_equal(mid) >= k:\n            ans = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    print(ans)\n\nsolve()\n```",
    "49": "```python\nk = int(input())\n\ndigits = 1\ncount = 9\nwhile k > digits * count:\n  k -= digits * count\n  digits += 1\n  count *= 10\n\nnum = 10**(digits - 1) + (k - 1) // digits\nindex = (k - 1) % digits\n\nprint(str(num)[index])\n```",
    "52": "```python\ndef solve():\n    n, m, k = map(int, input().split())\n    a = []\n    for _ in range(n):\n        a.append(list(map(int, input().split())))\n    \n    dp = {}\n\n    def row_max_sum(row, max_elements, current_sum, index, chosen_count, cache):\n        if (index, chosen_count, current_sum % k) in cache:\n            return cache[(index, chosen_count, current_sum % k)]\n        \n        if index == len(row):\n            return current_sum if current_sum % k == 0 else -float('inf')\n\n        if chosen_count == max_elements:\n            return row_max_sum(row, max_elements, current_sum, index + 1, chosen_count, cache)\n\n        \n        take = row_max_sum(row, max_elements, current_sum + row[index], index + 1, chosen_count+1, cache)\n        dont_take = row_max_sum(row, max_elements, current_sum, index + 1, chosen_count, cache)\n\n        cache[(index, chosen_count, current_sum % k)] = max(take, dont_take)\n        return cache[(index, chosen_count, current_sum % k)]\n    \n    \n    overall_dp = {}\n    \n    def overall_max_sum(row_index, current_sum, cache):\n        if row_index == n:\n            return current_sum if current_sum % k == 0 else -float('inf')\n        \n        if (row_index, current_sum % k) in cache:\n            return cache[(row_index, current_sum % k)]\n\n        row = a[row_index]\n        max_elements = m // 2\n        \n        row_cache = {}\n        max_row_sum = row_max_sum(row, max_elements, 0, 0, 0, row_cache)\n        \n        next_sum = overall_max_sum(row_index + 1, current_sum + max_row_sum, cache)\n        \n        \n        cache[(row_index, current_sum % k)] = next_sum\n        \n        return cache[(row_index, current_sum % k)]\n        \n    \n    result = overall_max_sum(0, 0, overall_dp)\n    print(result)\n\n\nsolve()\n```",
    "53": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    def find_longest_increasing_subsequence(arr):\n        q = [(arr, [], -1, \"\")]\n        max_len = 0\n        best_path = \"\"\n\n        while q:\n            curr_arr, curr_seq, last_val, curr_path = q.pop(0)\n\n            if not curr_arr:\n                if len(curr_seq) > max_len:\n                    max_len = len(curr_seq)\n                    best_path = curr_path\n                continue\n\n            left_val = curr_arr[0]\n            right_val = curr_arr[-1]\n\n            if left_val > last_val:\n                q.append((curr_arr[1:], curr_seq + [left_val], left_val, curr_path + \"L\"))\n\n            if len(curr_arr) > 1 and right_val > last_val:\n                q.append((curr_arr[:-1], curr_seq + [right_val], right_val, curr_path + \"R\"))\n            elif len(curr_arr) == 1 and right_val > last_val:\n                if len(curr_seq) + 1 > max_len:\n                     max_len = len(curr_seq) + 1\n                     best_path = curr_path + 'R'\n                     \n        return max_len, best_path\n\n    max_len, best_path = find_longest_increasing_subsequence(a)\n    print(max_len)\n    print(best_path)\n\nsolve()\n```",
    "54": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    if n == 1:\n        print(0)\n        return\n\n    distinct_values = sorted(list(set(a)))\n\n    if len(distinct_values) > 3:\n        print(-1)\n        return\n\n    if len(distinct_values) == 1:\n        print(0)\n        return\n\n    if len(distinct_values) == 2:\n        x, y = distinct_values\n        if (x + y) % 2 == 0:\n            print((y - x) // 2)\n        else:\n            print(y - x)\n        return\n\n    if len(distinct_values) == 3:\n        x, y, z = distinct_values\n        if y - x == z - y:\n            print(y - x)\n        else:\n            print(-1)\n        return\n\nsolve()\n```",
    "55": "```python\ndef solve():\n  x1, y1, x2, y2 = map(int, input().split())\n  x3, y3, x4, y4 = map(int, input().split())\n  x5, y5, x6, y6 = map(int, input().split())\n\n  white_area = (x2 - x1) * (y2 - y1)\n\n  # Calculate intersection with first black sheet\n  x_overlap1 = max(0, min(x2, x4) - max(x1, x3))\n  y_overlap1 = max(0, min(y2, y4) - max(y1, y3))\n  intersection_area1 = x_overlap1 * y_overlap1\n\n  # Calculate intersection with second black sheet\n  x_overlap2 = max(0, min(x2, x6) - max(x1, x5))\n  y_overlap2 = max(0, min(y2, y6) - max(y1, y5))\n  intersection_area2 = x_overlap2 * y_overlap2\n    \n  # Calculate intersection between the two black sheets\n  x_overlap_black = max(0, min(x4, x6) - max(x3, x5))\n  y_overlap_black = max(0, min(y4, y6) - max(y3, y5))\n  black_intersection_area = x_overlap_black * y_overlap_black\n    \n  # Calculate the intersection of all three rectangles\n  x_overlap_all = max(0, min(x2, x4, x6) - max(x1, x3, x5))\n  y_overlap_all = max(0, min(y2, y4, y6) - max(y1, y3, y5))\n  all_intersection_area = x_overlap_all * y_overlap_all\n    \n  # Calculate intersection of white and both black sheets\n  intersection_area12 = 0\n  x_overlap_12 = max(0, min(x2, x4, x6) - max(x1, x3, x5))\n  y_overlap_12 = max(0, min(y2, y4, y6) - max(y1, y3, y5))\n  intersection_area12 = x_overlap_12 * y_overlap_12\n\n  \n  total_covered_area = intersection_area1 + intersection_area2 - all_intersection_area\n  \n  if white_area > total_covered_area:\n    print(\"YES\")\n  else:\n    print(\"NO\")\n\nsolve()\n```",
    "56": "```python\ndef f(x):\n  x += 1\n  while x % 10 == 0:\n    x //= 10\n  return x\n\ndef solve():\n  n = int(input())\n  reachable = {n}\n  curr = n\n  while True:\n    curr = f(curr)\n    if curr in reachable:\n      break\n    reachable.add(curr)\n  print(len(reachable))\n\nsolve()\n```",
    "57": "```python\ndef solve():\n    n = int(input())\n    f = list(map(int, input().split()))\n\n    assigned = [False] * (n + 1)\n    for i in range(n):\n        if f[i] != 0:\n            assigned[f[i]] = True\n\n    unassigned_givers = []\n    unassigned_receivers = []\n    for i in range(n):\n        if f[i] == 0:\n            unassigned_givers.append(i)\n\n    for i in range(1, n + 1):\n        if not assigned[i]:\n            unassigned_receivers.append(i)\n\n    for i in range(len(unassigned_givers)):\n        giver_index = unassigned_givers[i]\n        receiver = unassigned_receivers[i]\n        \n        if giver_index + 1 == receiver:\n            if i + 1 < len(unassigned_givers):\n                unassigned_receivers[i], unassigned_receivers[i+1] = unassigned_receivers[i+1], unassigned_receivers[i]\n                \n            else:\n                for j in range(len(unassigned_givers)):\n                    if unassigned_givers[j] + 1 != unassigned_receivers[i]:\n                         unassigned_receivers[i], unassigned_receivers[j] = unassigned_receivers[j], unassigned_receivers[i]\n                         break\n\n        f[giver_index] = unassigned_receivers[i]\n\n    print(*f)\n\nsolve()\n```",
    "59": "```python\ndef solve():\n    n, x, y = map(int, input().split())\n    s = input()\n    \n    count = 0\n    for i in range(n - x, n):\n        if i == n - 1 - y:\n            if s[i] == '0':\n                count += 1\n        else:\n            if s[i] == '1':\n                count += 1\n    \n    print(count)\n\nsolve()\n```",
    "61": "```python\ndef solve():\n    n = int(input())\n    a = input()\n    f = list(map(int, input().split()))\n    \n    a_list = list(map(int, list(a)))\n    \n    best_a = a\n    \n    for i in range(n):\n        for j in range(i, n):\n            temp_a_list = a_list[:]\n            for k in range(i, j + 1):\n                temp_a_list[k] = f[temp_a_list[k] - 1]\n            \n            temp_a = \"\".join(map(str, temp_a_list))\n            \n            if temp_a > best_a:\n                best_a = temp_a\n                \n    print(best_a)\n\nsolve()\n```",
    "62": "```python\ndef solve():\n    a, b, c = map(int, input().split())\n    \n    best_cost = float('inf')\n    best_triple = None\n    \n    for A in range(1, 2 * a + 1):\n        for B in range(A, 2 * b + 1, A):\n            for C in range(B, 2 * c + 1, B):\n                cost = abs(a - A) + abs(b - B) + abs(c - C)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_triple = (A, B, C)\n                    \n    print(best_cost)\n    print(*best_triple)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "64": "```python\ndef solve():\n    n, m = map(int, input().split())\n    exams = []\n    for i in range(m):\n        s, d, c = map(int, input().split())\n        exams.append((s, d, c, i + 1))\n    \n    schedule = [0] * n\n    exam_days = {}\n    for s, d, c, i in exams:\n        schedule[d-1] = m + 1\n        exam_days[d-1] = i\n        \n    preparation_counts = [0] * m\n    \n    for day in range(n):\n        if schedule[day] == m + 1:\n            continue\n        \n        best_exam = -1\n        for i in range(m):\n            s, d, c, exam_num = exams[i]\n            if s <= day + 1 < d and preparation_counts[i] < c:\n                if best_exam == -1:\n                    best_exam = i\n                else:\n                    s_best, d_best, c_best, _ = exams[best_exam]\n                    if d > d_best:\n                        best_exam = i\n        \n        if best_exam != -1:\n            schedule[day] = exams[best_exam][3]\n            preparation_counts[best_exam] += 1\n            \n    \n    for i in range(m):\n      if exams[i][2] != preparation_counts[i]:\n        print(\"-1\")\n        return\n    \n    print(*schedule)\n\nsolve()\n```",
    "65": "```python\ndef solve():\n    n, m = map(int, input().split())\n    \n    if n == m:\n        print(0)\n        return\n    \n    if m % n != 0:\n        print(-1)\n        return\n    \n    diff = m // n\n    \n    count = 0\n    \n    while diff % 2 == 0:\n        diff //= 2\n        count += 1\n    \n    while diff % 3 == 0:\n        diff //= 3\n        count += 1\n    \n    if diff != 1:\n        print(-1)\n    else:\n        print(count)\n\nsolve()\n```",
    "66": "```python\ndef solve():\n    n, k = map(int, input().split())\n    t = input()\n    \n    if n == 1:\n        print(t * k)\n        return\n    \n    overlap = 0\n    for i in range(1, n):\n        if t[:n-i] == t[i:]:\n            overlap = n - i\n            break\n    \n    if k == 1:\n        print(t)\n    else:\n        print(t + t[overlap:] * (k - 1))\n\nsolve()\n```",
    "68": "```python\ndef solve():\n    n, k = map(int, input().split())\n    s = input()\n\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            dp[i][0] = 1\n            if j > 0:\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n\n        counts = {}\n        for l in range(i - 1, -1, -1):\n            if s[l] not in counts:\n                dp[i][1:] = [dp[i][x] - dp[l][x - 1] for x in range(1, i + 1)]\n                counts[s[l]] = True\n    \n    total_cost = 0\n    for length in range(n, -1, -1):\n        num_subsequences = dp[n][length]\n        \n        if k > num_subsequences:\n            total_cost += (n - length) * num_subsequences\n            k -= num_subsequences\n        else:\n            total_cost += (n - length) * k\n            k = 0\n            break\n    \n    if k > 0:\n        print(-1)\n    else:\n        print(total_cost)\nsolve()\n```",
    "69": "```python\ndef solve():\n    n, m, d = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n\n    def build_spanning_tree(edges, n, d):\n        adj = [[] for _ in range(n + 1)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        def check_degree(tree_edges, d):\n            degree = 0\n            for u, v in tree_edges:\n                if u == 1 or v == 1:\n                    degree += 1\n            return degree == d\n\n        def is_connected(tree_edges, n):\n            if not tree_edges:\n                return False if n > 1 else True\n            \n            adj_list = [[] for _ in range(n + 1)]\n            for u, v in tree_edges:\n                adj_list[u].append(v)\n                adj_list[v].append(u)\n            \n            visited = [False] * (n + 1)\n            \n            def dfs(node):\n                visited[node] = True\n                for neighbor in adj_list[node]:\n                    if not visited[neighbor]:\n                        dfs(neighbor)\n            \n            dfs(1)\n            for i in range(1, n + 1):\n                if not visited[i]:\n                    return False\n            return True\n\n        def find_spanning_tree(index, current_tree_edges):\n            if len(current_tree_edges) == n - 1:\n                if check_degree(current_tree_edges, d) and is_connected(current_tree_edges, n):\n                    return current_tree_edges\n                else:\n                    return None\n            \n            if index == len(edges):\n                return None\n            \n            # Option 1: Include the current edge in the spanning tree\n            new_tree_edges = current_tree_edges + [edges[index]]\n            result = find_spanning_tree(index + 1, new_tree_edges)\n            if result:\n                return result\n            \n            # Option 2: Exclude the current edge from the spanning tree\n            result = find_spanning_tree(index + 1, current_tree_edges)\n            if result:\n                return result\n            \n            return None\n\n        spanning_tree = find_spanning_tree(0, [])\n        return spanning_tree\n\n    spanning_tree = build_spanning_tree(edges, n, d)\n\n    if spanning_tree:\n        print(\"YES\")\n        for u, v in spanning_tree:\n            print(u, v)\n    else:\n        print(\"NO\")\n\nsolve()\n```",
    "71": "```python\nimport math\n\na = int(input())\nif a == 1:\n    print(0)\nelse:\n    print(math.ceil(math.log(a, 2)))\n```",
    "73": "```python\ndef solve():\n  n = int(input())\n  a = list(map(int, input().split()))\n\n  stack = []\n  for x in a:\n    if not stack:\n      stack.append(x)\n    elif stack[-1] == x:\n      stack.pop()\n    else:\n      stack.append(x)\n  \n  if not stack:\n    print(\"YES\")\n  elif len(stack) == 1:\n    print(\"YES\")\n  else:\n    print(\"NO\")\n\nsolve()\n```",
    "74": "```python\ndef solve():\n    n, k = map(int, input().split())\n    s = input()\n\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            dp[i][0] = 1\n            if j > 0:\n                dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n\n    \n    counts = []\n    for i in range(n + 1):\n        counts.append(dp[n][i])\n\n    counts.reverse()\n\n    \n    cost = 0\n    total_subsequences = 0\n    \n    for i in range(len(counts)):\n      \n      if total_subsequences + counts[i] <= k:\n        total_subsequences += counts[i]\n        cost += counts[i] * (n - (len(counts) - 1 - i))\n      else:\n        needed = k - total_subsequences\n        cost += needed * (n - (len(counts) - 1 - i))\n        total_subsequences = k\n        break\n    \n    if total_subsequences < k:\n      print(\"-1\")\n    else:\n      print(cost)\n\nsolve()\n```",
    "75": "```python\ndef solve():\n    a, b, c = map(int, input().split())\n    \n    week = [0, 1, 2, 0, 2, 1, 0] \n    \n    best_days = 0\n    \n    for start_day in range(7):\n        \n        cur_a, cur_b, cur_c = a, b, c\n        cur_days = 0\n        \n        day = start_day\n        \n        while True:\n            food_type = week[day % 7]\n            \n            if food_type == 0:\n                if cur_a > 0:\n                    cur_a -= 1\n                    cur_days += 1\n                else:\n                    break\n            elif food_type == 1:\n                if cur_b > 0:\n                    cur_b -= 1\n                    cur_days += 1\n                else:\n                    break\n            else:\n                if cur_c > 0:\n                    cur_c -= 1\n                    cur_days += 1\n                else:\n                    break\n            \n            day += 1\n        \n        best_days = max(best_days, cur_days)\n        \n    print(best_days)\n\nsolve()\n```",
    "76": "```python\ndef solve():\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append([list(map(int, input().split())) for _ in range(2)])\n\n    if m % 2 != 0:\n        print(\"NO\")\n        return\n\n    found = False\n    for tile in tiles:\n        if tile[0][1] == tile[1][0]:\n            found = True\n            break\n\n    if found:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "77": "```python\nn = int(input())\n\ntotal_sum = n * (n + 1) // 2\n\nif total_sum % 2 == 0:\n    print(0)\nelse:\n    print(1)\n```",
    "78": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    mod = 10**9 + 7\n    len_s = len(s)\n    \n    def is_regular(seq):\n        balance = 0\n        for char in seq:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    def count_regular_sequences(n, s):\n        count = 0\n        for i in range(2**(2*n)):\n            seq = \"\"\n            binary = bin(i)[2:].zfill(2*n)\n            for bit in binary:\n                if bit == '0':\n                    seq += '('\n                else:\n                    seq += ')'\n            \n            if is_regular(seq) and s in seq:\n                count = (count + 1) % mod\n        return count\n\n    print(count_regular_sequences(n, s))\n\nsolve()\n```",
    "79": "```python\ndef solve():\n    n = input()\n    n_len = len(n)\n    \n    def calculate_moves(s, target):\n        moves = 0\n        s_list = list(s)\n        \n        # Find the last occurrence of the first digit of target\n        first_digit_index = -1\n        for i in range(n_len - 1, -1, -1):\n            if s_list[i] == target[0]:\n                first_digit_index = i\n                break\n        \n        if first_digit_index == -1:\n            return float('inf')\n        \n        # Move the first digit to the last position\n        for i in range(first_digit_index, n_len - 1):\n            s_list[i], s_list[i+1] = s_list[i+1], s_list[i]\n            moves += 1\n        \n        # Find the last occurrence of the second digit of target in the remaining digits\n        second_digit_index = -1\n        for i in range(n_len - 2, -1, -1):\n            if s_list[i] == target[1]:\n                second_digit_index = i\n                break\n        \n        if second_digit_index == -1:\n            return float('inf')\n        \n        # Move the second digit to the second to last position\n        for i in range(second_digit_index, n_len - 2):\n            s_list[i], s_list[i+1] = s_list[i+1], s_list[i]\n            moves += 1\n            \n        # Remove leading zeros\n        leading_zeros = 0\n        for i in range(n_len - 2):\n            if s_list[i] == '0':\n                leading_zeros += 1\n            else:\n                break\n\n        \n        return moves + leading_zeros\n    \n    min_moves = float('inf')\n    \n    min_moves = min(min_moves, calculate_moves(n, \"00\"))\n    min_moves = min(min_moves, calculate_moves(n, \"25\"))\n    min_moves = min(min_moves, calculate_moves(n, \"50\"))\n    min_moves = min(min_moves, calculate_moves(n, \"75\"))\n    \n    if min_moves == float('inf'):\n        print(\"-1\")\n    else:\n        print(min_moves)\n        \n\nsolve()\n```",
    "80": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    \n    colors = [0] * n\n    \n    def check(num_colors):\n        for i in range(1 << n):\n            coloring = []\n            for j in range(n):\n                if (i >> j) & 1:\n                    coloring.append(1)\n                else:\n                    coloring.append(2)\n                    \n            if num_colors == 3:\n                for k in range(n):\n                    if colors[k] == 0:\n                        colors[k] = 3\n                        \n            \n            \n            colored_chars = []\n            for k in range(num_colors):\n                colored_chars.append([])\n            \n            for idx in range(n):\n                colored_chars[coloring[idx]-1].append(s[idx])\n\n            \n            def can_sort(arr, coloring):\n                arr_list = list(s)\n                \n                swaps = []\n                \n                for _ in range(n * n):\n                    swapped = False\n                    for i in range(n - 1):\n                        if arr_list[i] > arr_list[i + 1] and coloring[i] != coloring[i + 1]:\n                            arr_list[i], arr_list[i + 1] = arr_list[i + 1], arr_list[i]\n                            \n                            \n                            coloring[i], coloring[i + 1] = coloring[i + 1], coloring[i]\n                            \n                            \n                            swapped = True\n                \n                    if not swapped:\n                        break\n                            \n                return \"\".join(arr_list) == \"\".join(sorted(s))\n            \n            if can_sort(list(s), coloring.copy()):\n                \n                \n                return True, coloring\n        return False, None\n\n    for num_colors in range(1, n + 1):\n        result, coloring = check(num_colors)\n        if result:\n            print(num_colors)\n            print(*coloring)\n            return\n\nsolve()\n```",
    "81": "```python\ndef solve():\n    n = int(input())\n    strings = []\n    for _ in range(n):\n        strings.append(input())\n\n    strings.sort(key=len)\n\n    for i in range(1, n):\n        found = False\n        for j in range(i):\n            if strings[i-1] in strings[i]:\n                found = True\n                break\n        if not found:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    for s in strings:\n        print(s)\n\nsolve()\n```",
    "82": "```python\ndef solve():\n  n, k = map(int, input().split())\n  a = list(map(int, input().split()))\n\n  l = 0\n  r = n - 1\n  count = 0\n\n  while l <= r:\n    if a[l] <= k:\n      count += 1\n      l += 1\n    elif a[r] <= k:\n      count += 1\n      r -= 1\n    else:\n      break\n            \n    if l > r and a[l-1] <=k:\n        break\n\n    if l == r and a[l] <= k:\n        \n        break\n    \n  print(count)\n\nsolve()\n```",
    "83": "```python\ndef solve():\n    a, b = map(int, input().split())\n    total = a + b\n    \n    best_perimeter = float('inf')\n    \n    for h in range(1, int(total**0.5) + 2):\n        if total % h == 0:\n            w = total // h\n            \n            # Case 1: a is a rectangle\n            for h_a in range(1, int(a**0.5) + 2):\n                if a % h_a == 0:\n                    w_a = a // h_a\n                    \n                    if h_a <= h and w_a <= w:\n                        best_perimeter = min(best_perimeter, 2 * (h + w))\n            \n            # Case 2: b is a rectangle\n            for h_b in range(1, int(b**0.5) + 2):\n                if b % h_b == 0:\n                    w_b = b // h_b\n                    \n                    if h_b <= h and w_b <= w:\n                        best_perimeter = min(best_perimeter, 2 * (h + w))\n    \n    print(best_perimeter)\n\nsolve()\n```",
    "84": "```python\ndef solve():\n    n = int(input())\n    s = input()\n\n    for i in range(1 << n):\n        coloring = \"\"\n        for j in range(n):\n            if (i >> j) & 1:\n                coloring += \"1\"\n            else:\n                coloring += \"0\"\n\n        zeros = \"\"\n        ones = \"\"\n        for j in range(n):\n            if coloring[j] == '0':\n                zeros += s[j]\n            else:\n                ones += s[j]\n\n        sorted_s = \"\".join(sorted(s))\n        \n        merged = \"\"\n        zero_idx = 0\n        one_idx = 0\n\n        possible = True\n        for char in sorted_s:\n            if zero_idx < len(zeros) and zeros[zero_idx] == char:\n                merged += zeros[zero_idx]\n                zero_idx += 1\n            elif one_idx < len(ones) and ones[one_idx] == char:\n                merged += ones[one_idx]\n                one_idx += 1\n            else:\n                possible = False\n                break\n\n        if possible:\n            print(\"YES\")\n            print(coloring)\n            return\n\n    print(\"NO\")\n\nsolve()\n```",
    "85": "```python\ndef solve():\n    a, b = map(int, input().split())\n    \n    for price in range(1, 2001):\n        tax8 = int(price * 0.08)\n        tax10 = int(price * 0.10)\n        \n        if tax8 == a and tax10 == b:\n            print(price)\n            return\n    \n    print(\"-1\")\n\nsolve()\n```",
    "86": "```python\ndef solve():\n    n, k = map(int, input().split())\n\n    if k * (k + 1) // 2 > n:\n        print(\"NO\")\n        return\n\n    a = [0] * k\n    remaining = n - k * (k + 1) // 2\n    \n    base = remaining // k\n    rem = remaining % k\n    \n    for i in range(k):\n        a[i] = i + 1 + base\n        \n    for i in range(k - 1, k - 1 - rem, -1):\n        a[i] += 1\n\n    \n    for i in range(k - 1):\n        if not (a[i] < a[i+1] <= 2 * a[i]):\n            \n            \n            found = False\n            for start in range(1, n + 1):\n                temp_a = [0] * k\n                temp_a[0] = start\n                \n                possible = True\n                \n                for i in range(1, k):\n                    found_next = False\n                    for next_val in range(temp_a[i-1] + 1, 2 * temp_a[i-1] + 1 + 1):\n                        temp_a[i] = next_val\n                        \n                        \n                        \n                        \n                        \n                        found_next = True\n                        break\n                    if not found_next:\n                        possible = False\n                        break\n                \n                if possible and sum(temp_a) == n:\n                    print(\"YES\")\n                    print(*temp_a)\n                    return\n            \n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    print(*a)\n\nsolve()\n```",
    "88": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    counts = {}\n    for x in a:\n        counts[x] = counts.get(x, 0) + 1\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    def can_place(row, col, val):\n        if matrix[row][col] != 0:\n            return False\n        return True\n    \n    def fill_matrix():\n        for i in range((n + 1) // 2):\n            for j in range((n + 1) // 2):\n                if matrix[i][j] == 0:\n                    found = False\n                    for val in sorted(counts.keys()):\n                        if counts[val] >= 1 + (i != n - 1 - i) + (j != n - 1 - j) + (i != n - 1 - i and j != n - 1 - j):\n                            matrix[i][j] = val\n                            counts[val] -= 1\n                            \n                            matrix[n - 1 - i][j] = val\n                            counts[val] -= (i != n - 1 - i)\n                            \n                            matrix[i][n - 1 - j] = val\n                            counts[val] -= (j != n - 1 - j)\n                            \n                            matrix[n - 1 - i][n - 1 - j] = val\n                            counts[val] -= (i != n - 1 - i and j != n - 1 - j)\n                            \n                            found = True\n                            break\n                    if not found:\n                        return False\n                        \n        return True\n    \n    if fill_matrix():\n        print(\"YES\")\n        for row in matrix:\n            print(*row)\n    else:\n        print(\"NO\")\n\nsolve()\n```",
    "89": "```python\ndef solve():\n    n, r = map(int, input().split())\n    projects = []\n    for _ in range(n):\n        projects.append(list(map(int, input().split())))\n\n    def check(order):\n        rating = r\n        for i in order:\n            a, b = projects[i]\n            if rating < a:\n                return False\n            rating += b\n            if rating < 0:\n                return False\n        return True\n\n    import itertools\n    for order in itertools.permutations(range(n)):\n        if check(order):\n            print(\"YES\")\n            return\n\n    print(\"NO\")\n\nsolve()\n```",
    "90": "```python\ndef solve():\n    n, m, d = map(int, input().split())\n    c = list(map(int, input().split()))\n\n    total_length = sum(c)\n    \n    if d > n + 1:\n        print(\"YES\")\n        result = [0] * n\n        last = n\n        for i in range(m - 1, -1, -1):\n          for j in range(c[i]):\n            result[last - 1] = i + 1\n            last -= 1\n        print(*result)\n        return\n\n    min_space = (m + 1) * (d - 1)\n    if total_length + min_space > n + d - 1:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    result = [0] * n\n    \n    pos = 0\n    platform_positions = []\n    \n    for i in range(m):\n      platform_positions.append(pos)\n      pos += d - 1\n    \n    remaining_space = n - total_length - sum([x for x in platform_positions])\n    \n    for i in range(m):\n      add = min(remaining_space, d - 1)\n      platform_positions[i] += add\n      remaining_space -= add\n    \n    last = n\n    for i in range(m - 1, -1, -1):\n      \n      start = last - c[i]\n      \n      while start < platform_positions[i]:\n        start += 1\n      \n      for j in range(start, last):\n        result[j] = i + 1\n      \n      last = start\n        \n    print(*result)\n\nsolve()\n```",
    "91": "```python\ndef solve():\n  s = input()\n  t = input()\n  n = len(s)\n  m = len(t)\n  \n  ans = 0\n  for i in range(n + 1):\n    for j in range(i, n + 1):\n      temp_s = \"\"\n      if i > 0:\n        temp_s += s[:i]\n      if j < n:\n        temp_s += s[j:]\n      \n      ti = 0\n      tsi = 0\n      \n      possible = True\n      while ti < m and tsi < len(temp_s):\n        if t[ti] == temp_s[tsi]:\n          ti += 1\n          tsi += 1\n        else:\n          tsi += 1\n      \n      if ti == m:\n        ans = max(ans, j - i)\n        \n  print(ans)\n  \nsolve()\n```",
    "92": "```python\nx = float(input())\n\na = int(x * 10)\nb = int((x * 100) % 10)\n\nprint(a, b)\n```",
    "93": "```python\ndef solve():\n    n, d, k = map(int, input().split())\n\n    if d >= n:\n        print(\"NO\")\n        return\n\n    if d == 1 and n > 2:\n        print(\"NO\")\n        return\n\n    if k == 1 and d > 1:\n        print(\"NO\")\n        return\n    \n    if k == 1 and d == 1 and n > 2:\n        print(\"NO\")\n        return\n\n    edges = []\n    \n    # Create the diameter path\n    for i in range(d):\n        edges.append((i + 1, i + 2))\n\n    degrees = [0] * (n + 1)\n    for u, v in edges:\n        degrees[u] += 1\n        degrees[v] += 1\n\n    next_node = d + 2\n    \n    # Add nodes to the diameter path\n    for i in range(1, d + 2):\n        while degrees[i] < k and next_node <= n:\n            edges.append((i, next_node))\n            degrees[i] += 1\n            degrees[next_node] += 1\n            next_node += 1\n\n    if next_node <= n:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    for u, v in edges:\n        print(u, v)\n\nsolve()\n```",
    "94": "```python\ndef solve():\n  a, b, x = map(int, input().split())\n  \n  if a > b:\n    start = 0\n    a_char = '0'\n    b_char = '1'\n  else:\n    start = 1\n    a_char = '1'\n    b_char = '0'\n    \n  res = \"\"\n  \n  if start == 0:\n    res += a_char\n    a -= 1\n  else:\n    res += b_char\n    b -= 1\n    \n  x -= 1\n  \n  while x > 0:\n    if res[-1] == a_char:\n      res += b_char\n      b -= 1\n    else:\n      res += a_char\n      a -= 1\n    x -= 1\n    \n  if res[-1] == a_char:\n    res += b_char * b\n    res += a_char * a\n  else:\n    res += a_char * a\n    res += b_char * b\n    \n  print(res)\n  \nsolve()\n```",
    "95": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    t = input()\n\n    def check(res, s, t):\n        for i in range(len(res) - 1):\n            sub = res[i:i+2]\n            if sub == s or sub == t:\n                return False\n        return True\n\n    import itertools\n    \n    chars = ['a'] * n + ['b'] * n + ['c'] * n\n    \n    for perm in itertools.permutations(chars):\n        res = \"\".join(perm)\n        if check(res, s, t):\n            print(\"YES\")\n            print(res)\n            return\n    \n    print(\"NO\")\n\nsolve()\n```",
    "96": "```python\ndef solve():\n    n = int(input())\n    q = list(map(int, input().split()))\n\n    for first_element in range(1, n + 1):\n        p = [first_element]\n        valid = True\n        for i in range(n - 1):\n            next_element = p[-1] + q[i]\n            p.append(next_element)\n\n        seen = set()\n        for x in p:\n            if not (1 <= x <= n):\n                valid = False\n                break\n            if x in seen:\n                valid = False\n                break\n            seen.add(x)\n\n        if len(seen) != n:\n            valid = False\n\n        if valid:\n            print(*p)\n            return\n\n    print(-1)\n\nsolve()\n```",
    "97": "```python\ndef solve():\n    n = int(input())\n    x = list(map(int, input().split()))\n    \n    ans = float('inf')\n    for target in set(x):\n        cost = 0\n        for val in x:\n            cost += abs(val - target) % 2\n        ans = min(ans, cost)\n        \n    print(ans)\n\nsolve()\n```",
    "98": "```python\ndef solve():\n    n = int(input())\n    ans = float('inf')\n    for i in range(1, int(n**0.5) + 2):\n        if n % i == 0:\n            j = n // i\n            ans = min(ans, i + j - 2)\n    print(ans)\n\nsolve()\n```",
    "99": "```python\ndef solve():\n  n = int(input())\n  a1, a2, a3 = map(int, input().split())\n  b1, b2, b3 = map(int, input().split())\n\n  min_wins = 0\n  \n  # Calculate minimum wins\n  temp_a1, temp_a2, temp_a3 = a1, a2, a3\n  temp_b1, temp_b2, temp_b3 = b1, b2, b3\n\n  # Minimize wins by maximizing losses\n  \n  # Alice rock vs Bob rock\n  take = min(temp_a1, temp_b1)\n  temp_a1 -= take\n  temp_b1 -= take\n  \n  # Alice rock vs Bob scissors\n  \n  # Alice rock vs Bob paper\n  take = min(temp_a1, temp_b3)\n  temp_a1 -= take\n  temp_b3 -= take\n\n  # Alice scissors vs Bob rock\n  take = min(temp_a2, temp_b1)\n  temp_a2 -= take\n  temp_b1 -= take\n\n  # Alice scissors vs Bob scissors\n  \n  # Alice scissors vs Bob paper\n  take = min(temp_a2, temp_b2)\n  temp_a2 -= take\n  temp_b2 -= take\n  \n\n  # Alice paper vs Bob rock\n  take = min(temp_a3, temp_b1)\n  temp_a3 -= take\n  temp_b1 -= take\n  \n  # Alice paper vs Bob scissors\n  take = min(temp_a3, temp_b2)\n  temp_a3 -= take\n  temp_b2 -= take\n  \n  # Alice paper vs Bob paper\n  take = min(temp_a3, temp_b3)\n  temp_a3 -= take\n  temp_b3 -= take\n  \n  min_wins = max(0, a1 - (n - temp_a1 -temp_a2 - temp_a3))\n  \n  # Calculate maximum wins\n  max_wins = 0\n  \n  # Alice rock vs Bob scissors\n  take = min(a1, b2)\n  max_wins += take\n  a1 -= take\n  b2 -= take\n  \n  # Alice scissors vs Bob paper\n  take = min(a2, b3)\n  max_wins += take\n  a2 -= take\n  b3 -= take\n  \n  # Alice paper vs Bob rock\n  take = min(a3, b1)\n  max_wins += take\n  a3 -= take\n  b1 -= take\n\n  print(min_wins, max_wins)\n\nsolve()\n```"
}