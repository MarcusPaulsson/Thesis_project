{
    "0": "```python\ndef solve():\n    s = input()\n    n = len(s)\n    \n    first_bracket = -1\n    for i in range(n):\n        if s[i] == '[':\n            first_bracket = i\n            break\n    \n    if first_bracket == -1:\n        print(-1)\n        return\n    \n    last_bracket = -1\n    for i in range(n - 1, -1, -1):\n        if s[i] == ']':\n            last_bracket = i\n            break\n    \n    if last_bracket == -1 or last_bracket <= first_bracket:\n        print(-1)\n        return\n    \n    first_colon = -1\n    for i in range(first_bracket + 1, last_bracket):\n        if s[i] == ':':\n            first_colon = i\n            break\n    \n    if first_colon == -1:\n        print(-1)\n        return\n    \n    second_colon = -1\n    for i in range(last_bracket - 1, first_colon, -1):\n        if s[i] == ':':\n            second_colon = i\n            break\n    \n    if second_colon == -1 or second_colon <= first_colon:\n        print(-1)\n        return\n    \n    count = 0\n    for i in range(first_colon + 1, second_colon):\n        if s[i] == '|':\n            count += 1\n            \n    print(4 + count)\n    \nsolve()\n```",
    "1": "```python\ndef solve():\n    x = int(input())\n    s = str(x)\n    n = len(s)\n    \n    best_num = x\n    best_sum = sum(int(digit) for digit in s)\n    \n    for i in range(n):\n        if s[i] == '0':\n            continue\n        \n        num_str = s[:i] + str(int(s[i]) - 1) + '9' * (n - i - 1)\n        num = int(num_str)\n        \n        if num <= x:\n            current_sum = sum(int(digit) for digit in num_str)\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_num = num\n            elif current_sum == best_sum and num > best_num:\n                best_num = num\n                \n    print(best_num)\n\nsolve()\n```",
    "2": "```python\ndef solve():\n  n = int(input())\n  s = str(n)\n  l = len(s)\n  first_digit = int(s[0])\n  \n  next_lucky = (first_digit + 1) * (10**(l-1))\n  \n  print(next_lucky - n)\n\nsolve()\n```",
    "4": "```python\ndef solve():\n    x = int(input())\n    hh, mm = map(int, input().split())\n\n    def is_lucky(h, m):\n        return '7' in str(h) or '7' in str(m)\n\n    count = 0\n    while True:\n        if is_lucky(hh, mm):\n            print(count)\n            return\n\n        mm -= x\n        if mm < 0:\n            mm += 60\n            hh -= 1\n            if hh < 0:\n                hh += 24\n        \n        count += 1\n\nsolve()\n```",
    "5": "```python\ndef solve():\n    n, pos, l, r = map(int, input().split())\n\n    if l == 1 and r == n:\n        print(0)\n        return\n\n    if l == 1:\n        print(abs(pos - r) + 1)\n        return\n\n    if r == n:\n        print(abs(pos - l) + 1)\n        return\n\n    print(min(abs(pos - l) + abs(r - l) + 2, abs(pos - r) + abs(r - l) + 2))\n\n\nsolve()\n```",
    "6": "```python\ndef solve():\n    n, x = map(int, input().split())\n    blows = []\n    for _ in range(n):\n        blows.append(list(map(int, input().split())))\n    \n    max_d = 0\n    for d, h in blows:\n        max_d = max(max_d, d)\n    \n    if max_d >= x:\n        print(1)\n        return\n    \n    max_diff = 0\n    for d, h in blows:\n        max_diff = max(max_diff, d - h)\n    \n    if max_diff <= 0:\n        print(-1)\n        return\n    \n    remaining = x - max_d\n    \n    ans = 1 + (remaining + max_diff - 1) // max_diff\n    print(ans)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "7": "```python\nn, m = map(int, input().split())\n\nlow = 0\nhigh = 2 * 10**9\n\nans = high\n\nwhile low <= high:\n    mid = (low + high) // 2\n    \n    total_sparrows = mid * (mid + 1) // 2\n    \n    if n + mid * m >= total_sparrows:\n        ans = mid\n        high = mid - 1\n    else:\n        low = mid + 1\n\nprint(ans)\n```",
    "9": "```python\ndef solve():\n    d = int(input())\n    n, m = map(int, input().split())\n    sofas = []\n    for _ in range(d):\n        sofas.append(list(map(int, input().split())))\n    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\n    def count_left(sofa, other_sofas):\n        count = 0\n        for other_sofa in other_sofas:\n            if sofa == other_sofa:\n                continue\n            \n            x1_sofa = min(sofa[0], sofa[2])\n            x2_sofa = max(sofa[0], sofa[2])\n            y1_sofa = min(sofa[1], sofa[3])\n            y2_sofa = max(sofa[1], sofa[3])\n\n            x1_other = min(other_sofa[0], other_sofa[2])\n            x2_other = max(other_sofa[0], other_sofa[2])\n            y1_other = min(other_sofa[1], other_sofa[3])\n            y2_other = max(other_sofa[1], other_sofa[3])\n            \n            \n            min_x_sofa = min(sofa[0], sofa[2])\n            min_x_other = min(other_sofa[0], other_sofa[2])\n        \n            if min_x_sofa > x1_other:\n                count += 1\n        return count\n\n    def count_right(sofa, other_sofas):\n        count = 0\n        for other_sofa in other_sofas:\n            if sofa == other_sofa:\n                continue\n\n            \n            x1_sofa = min(sofa[0], sofa[2])\n            x2_sofa = max(sofa[0], sofa[2])\n            y1_sofa = min(sofa[1], sofa[3])\n            y2_sofa = max(sofa[1], sofa[3])\n\n            x1_other = min(other_sofa[0], other_sofa[2])\n            x2_other = max(other_sofa[0], other_sofa[2])\n            y1_other = min(other_sofa[1], other_sofa[3])\n            y2_other = max(other_sofa[1], other_sofa[3])\n            \n            max_x_sofa = max(sofa[0], sofa[2])\n            max_x_other = max(other_sofa[0], other_sofa[2])\n            \n            if max_x_sofa < x2_other:\n                count += 1\n        return count\n\n    def count_top(sofa, other_sofas):\n        count = 0\n        for other_sofa in other_sofas:\n            if sofa == other_sofa:\n                continue\n\n            x1_sofa = min(sofa[0], sofa[2])\n            x2_sofa = max(sofa[0], sofa[2])\n            y1_sofa = min(sofa[1], sofa[3])\n            y2_sofa = max(sofa[1], sofa[3])\n\n            x1_other = min(other_sofa[0], other_sofa[2])\n            x2_other = max(other_sofa[0], other_sofa[2])\n            y1_other = min(other_sofa[1], other_sofa[3])\n            y2_other = max(other_sofa[1], other_sofa[3])\n            \n            min_y_sofa = min(sofa[1], sofa[3])\n            min_y_other = min(other_sofa[1], other_sofa[3])\n            \n            if min_y_sofa > y1_other:\n                count += 1\n        return count\n\n    def count_bottom(sofa, other_sofas):\n        count = 0\n        for other_sofa in other_sofas:\n            if sofa == other_sofa:\n                continue\n            \n            x1_sofa = min(sofa[0], sofa[2])\n            x2_sofa = max(sofa[0], sofa[2])\n            y1_sofa = min(sofa[1], sofa[3])\n            y2_sofa = max(sofa[1], sofa[3])\n\n            x1_other = min(other_sofa[0], other_sofa[2])\n            x2_other = max(other_sofa[0], other_sofa[2])\n            y1_other = min(other_sofa[1], other_sofa[3])\n            y2_other = max(other_sofa[1], other_sofa[3])\n            \n            max_y_sofa = max(sofa[1], sofa[3])\n            max_y_other = max(other_sofa[1], other_sofa[3])\n\n            if max_y_sofa < y2_other:\n                count += 1\n        return count\n\n    for i in range(d):\n        sofa = sofas[i]\n        other_sofas = sofas[:]\n        \n        \n        l = count_left(sofa, other_sofas)\n        r = count_right(sofa, other_sofas)\n        t = count_top(sofa, other_sofas)\n        b = count_bottom(sofa, other_sofas)\n\n        if l == cnt_l and r == cnt_r and t == cnt_t and b == cnt_b:\n            print(i + 1)\n            return\n\n    print(-1)\n\nsolve()\n```",
    "10": "```python\nn = int(input())\nweeks = n // 7\nrem = n % 7\nmin_days_off = weeks * 2\nmax_days_off = weeks * 2\nif rem == 1:\n    min_days_off += 0\n    max_days_off += 1\nelif rem == 2:\n    min_days_off += 0\n    max_days_off += 2\nelif rem == 3:\n    min_days_off += 0\n    max_days_off += 2\nelif rem == 4:\n    min_days_off += 0\n    max_days_off += 2\nelif rem == 5:\n    min_days_off += 0\n    max_days_off += 2\nelif rem == 6:\n    min_days_off += 1\n    max_days_off += 2\n    \nprint(min_days_off, max_days_off)\n```",
    "11": "```python\ndef gcd(a, b):\n  if b == 0:\n    return a\n  return gcd(b, a % b)\n\ndef lcm(a, b):\n  return (a * b) // gcd(a, b)\n\nn, a, b, p, q = map(int, input().split())\n\nred_count = n // a\nblue_count = n // b\ncommon_count = n // lcm(a, b)\n\nred_only = red_count - common_count\nblue_only = blue_count - common_count\n\ntotal_chocolates = 0\n\nif p > q:\n  total_chocolates += red_only * p\n  total_chocolates += common_count * p\n  total_chocolates += blue_only * q\nelse:\n  total_chocolates += blue_only * q\n  total_chocolates += common_count * q\n  total_chocolates += red_only * p\n  \nprint(total_chocolates)\n```",
    "13": "```python\nfrom collections import deque\n\ndef solve():\n    n, k = map(int, input().split())\n    main_courses = list(map(int, input().split()))\n    dependencies = []\n    for _ in range(n):\n        dependencies.append(list(map(int, input().split()))[1:])\n\n    indegree = [0] * (n + 1)\n    adj = [[] for _ in range(n + 1)]\n    for i in range(n):\n        for dep in dependencies[i]:\n            adj[dep].append(i + 1)\n            indegree[i + 1] += 1\n\n    q = deque()\n    for i in range(1, n + 1):\n        if indegree[i] == 0:\n            q.append(i)\n\n    order = []\n    count = 0\n    \n    while q:\n        u = q.popleft()\n        order.append(u)\n        count += 1\n        for v in adj[u]:\n            indegree[v] -= 1\n            if indegree[v] == 0:\n                q.append(v)\n\n    if count != n:\n        print(-1)\n        return\n\n    \n    necessary = set(main_courses)\n    for i in range(1,n+1):\n      for j in main_courses:\n        if j in adj[i]:\n          necessary.add(i)\n\n    \n    \n    \n    \n    result = []\n    visited = [False] * (n+1)\n    \n    def dfs(node):\n        if visited[node]:\n            return\n        visited[node] = True\n        for dep in dependencies[node-1]:\n            if not visited[dep]:\n                dfs(dep)\n        result.append(node)\n\n    for course in main_courses:\n        if not visited[course]:\n          dfs(course)\n    \n    \n    \n    result.reverse()\n    \n    final_result = []\n    seen = set()\n    \n    for course in result:\n      if course not in seen:\n        final_result.append(course)\n        seen.add(course)\n\n    \n    \n    \n    \n    \n    \n    valid = True\n    needed_courses = set(main_courses)\n    \n    temp_seen = set()\n    for course in final_result:\n      temp_seen.add(course)\n    \n    for course in main_courses:\n      if course not in temp_seen:\n        valid = False\n        break\n    \n    for course in final_result:\n      \n      \n      can_take = True\n      \n      for dep in dependencies[course-1]:\n        if dep not in temp_seen:\n          can_take = False\n          break\n      \n      if not can_take:\n        valid = False\n        break\n      \n    if not valid:\n      print(-1)\n      return\n        \n    \n    print(len(final_result))\n    print(*final_result)\n\nsolve()\n```",
    "14": "```python\ndef solve():\n    n, k = map(int, input().split())\n    p = list(map(int, input().split()))\n\n    available = set(range(1, n + 1))\n    for x in p:\n        available.remove(x)\n\n    def is_stack_sortable(arr):\n        stack = []\n        b = []\n        i = 0\n        while i < len(arr) or stack:\n            if i < len(arr):\n                stack.append(arr[i])\n                i += 1\n            else:\n                \n                b.append(stack.pop())\n                continue\n\n            while stack and stack[-1] == min(stack):\n                b.append(stack.pop())\n        \n        return all(b[i] <= b[i+1] for i in range(len(b)-1))\n\n    def find_permutation(current_permutation, remaining_available):\n        if len(current_permutation) == n:\n            if is_stack_sortable(current_permutation):\n                return current_permutation\n            else:\n                return None\n\n        for val in sorted(list(remaining_available), reverse=True):\n            new_permutation = current_permutation + [val]\n            new_available = remaining_available - {val}\n            result = find_permutation(new_permutation, new_available)\n            if result:\n                return result\n\n        return None\n\n    remaining_available = available\n    result = find_permutation(p, remaining_available)\n\n    if result:\n        print(*result)\n    else:\n        print(-1)\n\nsolve()\n```",
    "16": "```python\ndef solve():\n  cnt1 = int(input())\n  cnt2 = int(input())\n  cnt3 = int(input())\n  cnt4 = int(input())\n\n  if cnt1 == cnt4 and cnt1 >= 0:\n    print(1)\n  else:\n    print(0)\n\nsolve()\n```",
    "17": "```python\ndef solve():\n    n, k, t = map(int, input().split())\n    \n    if t <= k:\n        print(t)\n    elif t <= n:\n        print(k)\n    else:\n        print(k - (t - n))\n\nsolve()\n```",
    "18": "```python\ndef solve():\n    s = input()\n    n = len(s)\n    \n    u = \"\"\n    t = \"\"\n    \n    suffix_min = [0] * (n + 1)\n    suffix_min[n] = chr(ord('z') + 1)\n    \n    for i in range(n - 1, -1, -1):\n        suffix_min[i] = min(s[i], suffix_min[i + 1])\n        \n    i = 0\n    while i < n or len(t) > 0:\n        if len(t) > 0 and t[-1] <= suffix_min[i]:\n            u += t[-1]\n            t = t[:-1]\n        else:\n            if i < n :\n                t += s[i]\n                i += 1\n            else:\n                u += t[-1]\n                t = t[:-1]\n                \n    print(u)\n    \nsolve()\n```",
    "19": "```python\ndef solve():\n    n = int(input())\n    pairs = []\n    for _ in range(n):\n        pairs.append(list(map(int, input().split())))\n    \n    possible = True\n    \n    for i in range(n):\n        if pairs[i][1] > pairs[i][0]:\n            possible = False\n            break\n        if i > 0:\n            if pairs[i][0] < pairs[i-1][0] or pairs[i][1] < pairs[i-1][1]:\n                possible = False\n                break\n            if pairs[i][0] - pairs[i-1][0] < pairs[i][1] - pairs[i-1][1]:\n                possible = False\n                break\n    \n    if possible:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "20": "```python\ndef solve():\n    s = input()\n    hh = int(s[:2])\n    mm = int(s[3:])\n    \n    ans = float('inf')\n    \n    for i in range(24 * 60):\n        curr_hh = hh\n        curr_mm = mm\n        \n        time_str = \"{:02d}:{:02d}\".format(curr_hh, curr_mm)\n        \n        if time_str == time_str[::-1]:\n            ans = 0\n            break\n            \n        \n        new_mm = (mm + 1) % 60\n        new_hh = hh + (mm + 1) // 60\n        \n        hh = new_hh % 24\n        mm = new_mm\n        \n    else:\n        hh = int(s[:2])\n        mm = int(s[3:])\n        \n        for i in range(24 * 60):\n            curr_hh = hh\n            curr_mm = mm\n\n            time_str = \"{:02d}:{:02d}\".format(curr_hh, curr_mm)\n\n            if time_str == time_str[::-1]:\n                ans = i\n                break\n\n\n            new_mm = (mm + 1) % 60\n            new_hh = hh + (mm + 1) // 60\n\n            hh = new_hh % 24\n            mm = new_mm\n        \n    print(ans)\n    \n\nsolve()\n```",
    "21": "```python\ndef solve():\n  n = int(input())\n  a = list(map(int, input().split()))\n\n  pos_min = a.index(1)\n  pos_max = a.index(n)\n\n  print(max(pos_max, pos_min, n - 1 - pos_min, n - 1 - pos_max))\n\nsolve()\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror = {\n        'b': 'd', 'd': 'b', 'p': 'q', 'q': 'p',\n        'o': 'o', 'v': 'v', 'w': 'w', 'x': 'x',\n        'A': 'A', 'H': 'H', 'I': 'I', 'M': 'M',\n        'O': 'O', 'T': 'T', 'U': 'U', 'V': 'V',\n        'W': 'W', 'X': 'X', 'Y': 'Y'\n    }\n    n = len(s)\n    for i in range(n // 2):\n        if s[i] not in mirror or s[n - 1 - i] not in mirror or mirror[s[i]] != s[n - 1 - i]:\n            return \"NIE\"\n    if n % 2 == 1:\n        if s[n // 2] not in mirror or mirror[s[n // 2]] != s[n // 2]:\n            return \"NIE\"\n    return \"TAK\"\n\ns = input()\nprint(is_s_palindrome(s))\n```",
    "23": "```python\nfrom collections import Counter\n\ndef solve():\n    a = input()\n    b = input()\n\n    a_digits = sorted(list(a), reverse=True)\n    \n    if len(a) < len(b):\n        print(\"\".join(a_digits))\n        return\n    \n    a_counts = Counter(a)\n    \n    def find_max(idx, current_num, remaining_counts):\n        if idx == len(a):\n            return current_num\n        \n        best_num = \"\"\n        \n        for digit in sorted(remaining_counts.keys(), reverse=True):\n            temp_counts = remaining_counts.copy()\n            \n            if temp_counts[digit] > 0:\n                temp_counts[digit] -= 1\n                if temp_counts[digit] == 0:\n                    del temp_counts[digit]\n                    \n                new_num = current_num + digit\n                \n                if len(new_num) <= len(b):\n                    if len(new_num) < len(b) or new_num <= b:\n                        result = find_max(idx + 1, new_num, temp_counts)\n                        if len(result) > len(best_num):\n                            best_num = result\n                        elif len(result) == len(best_num) and result > best_num:\n                            best_num = result\n        \n        return best_num\n\n    result = find_max(0, \"\", a_counts)\n    print(result)\n\nsolve()\n```",
    "24": "```python\ndef solve():\n  board = [input() for _ in range(10)]\n\n  def check_win(board):\n    for i in range(10):\n      for j in range(10):\n        if board[i][j] == 'X':\n          # Check horizontal\n          if j <= 5 and all(board[i][j + k] == 'X' for k in range(5)):\n            return True\n          # Check vertical\n          if i <= 5 and all(board[i + k][j] == 'X' for k in range(5)):\n            return True\n          # Check diagonal (top-left to bottom-right)\n          if i <= 5 and j <= 5 and all(board[i + k][j + k] == 'X' for k in range(5)):\n            return True\n          # Check diagonal (top-right to bottom-left)\n          if i <= 5 and j >= 4 and all(board[i + k][j - k] == 'X' for k in range(5)):\n            return True\n    return False\n\n  for i in range(10):\n    for j in range(10):\n      if board[i][j] == '.':\n        new_board = [list(row) for row in board]\n        new_board[i][j] = 'X'\n        new_board = [\"\".join(row) for row in new_board]\n        if check_win(new_board):\n          print('YES')\n          return\n\n  print('NO')\n\nsolve()\n```",
    "25": "```python\ndef solve():\n    n, k = map(int, input().split())\n    \n    if k > n * n:\n        print(\"-1\")\n        return\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k == 0:\n            break\n        if matrix[i][i] == 0 and k > 0:\n            matrix[i][i] = 1\n            k -= 1\n            \n        for j in range(i + 1, n):\n            if k >= 2:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n            else:\n                break\n        \n    if k != 0:\n        if k > 0:\n            print(\"-1\")\n            return\n            \n    for row in matrix:\n        print(*row)\n\nsolve()\n```",
    "26": "```python\nx, y, z = map(float, input().split())\n\na1 = x ** (y ** z)\na2 = x ** (z ** y)\na3 = (x ** y) ** z\na4 = (x ** z) ** y\na5 = y ** (x ** z)\na6 = y ** (z ** x)\na7 = (y ** x) ** z\na8 = (y ** z) ** x\na9 = z ** (x ** y)\na10 = z ** (y ** x)\na11 = (z ** x) ** y\na12 = (z ** y) ** x\n\nvalues = [a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12]\nexpressions = [\"x^y^z\", \"x^z^y\", \"(x^y)^z\", \"(x^z)^y\", \"y^x^z\", \"y^z^x\", \"(y^x)^z\", \"(y^z)^x\", \"z^x^y\", \"z^y^x\", \"(z^x)^y\", \"(z^y)^x\"]\n\nmax_value = max(values)\nindex = values.index(max_value)\n\nprint(expressions[index])\n```",
    "27": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    \n    ans = n\n    \n    for i in range(1, n // 2 + 1):\n        prefix = s[:i]\n        if s.startswith(prefix * 2):\n            ans = min(ans, i + 1 + (n - 2 * i))\n        elif s.startswith(prefix) and s[i:].startswith(prefix) and len(s[i:]) >= i:\n            if s[i:].startswith(prefix):\n                ans = min(ans, i+1+len(s) - 2*i)\n            \n    \n    \n    for i in range(1, n):\n        prefix = s[:i]\n        if s.startswith(prefix) and len(prefix) * 2 <= n:\n            if s.startswith(prefix + prefix):\n                ans = min(ans, len(prefix) + 1 + (n - 2*len(prefix)))\n    \n    print(ans)\n\nsolve()\n```",
    "28": "```python\ndef solve():\n    n = int(input())\n    files = []\n    for _ in range(n):\n        files.append(input().split())\n\n    examples = []\n    regular = []\n    for i in range(n):\n        if files[i][1] == '1':\n            examples.append((files[i][0], i))\n        else:\n            regular.append((files[i][0], i))\n\n    moves = []\n    e = len(examples)\n    r = len(regular)\n    \n    temps = []\n    \n    # Move examples to the front\n    for i in range(e):\n        if examples[i][0] != str(i + 1):\n            temp_name = generate_temp_name(files)\n            temps.append(temp_name)\n            moves.append(f\"move {examples[i][0]} {temp_name}\")\n            \n            target_index = -1\n            for j in range(n):\n                if files[j][0] == str(i+1):\n                    target_index = j\n                    break\n                    \n            if target_index != -1:\n                \n                moves.append(f\"move {str(i+1)} {str(e+r+len(temps))}\")\n                temps.append(str(e+r+len(temps)))\n                moves.append(f\"move {temp_name} {str(i+1)}\")\n                \n                \n                \n                files[examples[i][1]][0] = str(i+1)\n                files[target_index][0] = str(e+r+len(temps)-1)\n                \n                \n                \n            else:\n                moves.append(f\"move {temp_name} {str(i+1)}\")\n                files[examples[i][1]][0] = str(i+1)\n                \n    # Move regular tests to the back\n    for i in range(r):\n        if regular[i][0] != str(e + i + 1):\n            \n            temp_name = generate_temp_name(files)\n            temps.append(temp_name)\n            moves.append(f\"move {regular[i][0]} {temp_name}\")\n            \n            target_index = -1\n            for j in range(n):\n                if files[j][0] == str(e+i+1):\n                    target_index = j\n                    break\n            \n            if target_index != -1:\n                moves.append(f\"move {str(e+i+1)} {str(e+r+len(temps))}\")\n                temps.append(str(e+r+len(temps)))\n                moves.append(f\"move {temp_name} {str(e+i+1)}\")\n                \n                files[regular[i][1]][0] = str(e+i+1)\n                files[target_index][0] = str(e+r+len(temps)-1)\n                \n            else:\n                moves.append(f\"move {temp_name} {str(e+i+1)}\")\n                files[regular[i][1]][0] = str(e+i+1)\n\n    print(len(moves))\n    for move in moves:\n        print(move)\n\ndef generate_temp_name(files):\n    i = 1\n    while True:\n        temp_name = \"temp\" + str(i)\n        exists = False\n        for file in files:\n            if file[0] == temp_name:\n                exists = True\n                break\n        if not exists:\n            return temp_name\n        i += 1\n\nsolve()\n```",
    "29": "```python\ndef solve():\n  s = input()\n  digits = [int(c) for c in s]\n  \n  ans = 6\n  for i in range(1000):\n    s1 = str(i).zfill(3)\n    sum1 = sum(int(c) for c in s1)\n    \n    for j in range(1000):\n      s2 = str(j).zfill(3)\n      sum2 = sum(int(c) for c in s2)\n      \n      if sum1 == sum2:\n        \n        temp_digits = digits[:]\n        \n        \n        \n        \n        \n        \n        changes = 0\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        if digits[0] != int(s1[0]):\n          changes += 1\n        if digits[1] != int(s1[1]):\n          changes += 1\n        if digits[2] != int(s1[2]):\n          changes += 1\n          \n        if digits[3] != int(s2[0]):\n          changes += 1\n        if digits[4] != int(s2[1]):\n          changes += 1\n        if digits[5] != int(s2[2]):\n          changes += 1\n        \n        \n        \n        \n        \n        \n        ans = min(ans, changes)\n        \n  print(ans)\n  \nsolve()\n```",
    "30": "```python\ndef solve():\n  m, x = map(int, input().split())\n  print(m - 1)\n\nsolve()\n```",
    "31": "```python\ndef solve():\n    n, k = map(int, input().split())\n    mod = 10**6 + 3\n\n    if n < 63 and k > (1 << n):\n        print(1, 1)\n        return\n    \n    if k > mod:\n        print(0, 1)\n        return\n\n    num = 1\n    den = 1\n    \n    for i in range(int(k)):\n        if i == 0:\n            continue\n        num = (num * ((pow(2, n, mod) - i + mod) % mod)) % mod\n        den = (den * pow(2, n, mod)) % mod\n\n    \n    \n    a = (den - num + mod) % mod if num != den else 0\n    \n    \n    gcd_val = gcd(a,den)\n    \n    print(a // gcd_val, den // gcd_val)\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\nsolve()\n```",
    "32": "```python\ndef solve():\n    n = int(input())\n    \n    current_pos = 0 \n    \n    for _ in range(n):\n        t, direction = input().split()\n        t = int(t)\n        \n        if current_pos == 0:\n            if direction != \"South\":\n                print(\"NO\")\n                return\n            current_pos += t\n        elif current_pos == 20000:\n            if direction != \"North\":\n                print(\"NO\")\n                return\n            current_pos -= t\n        else:\n            if direction == \"South\":\n                current_pos += t\n            elif direction == \"North\":\n                current_pos -= t\n            \n        if current_pos < 0 or current_pos > 20000:\n            print(\"NO\")\n            return\n    \n    if current_pos == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n        \n\nsolve()\n```",
    "33": "```python\nimport math\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef extended_gcd(a, b):\n    if a == 0:\n        return b, 0, 1\n    d, x1, y1 = extended_gcd(b % a, a)\n    x = y1 - (b // a) * x1\n    y = x1\n    return d, x, y\n\ndef solve():\n    a1, b1, a2, b2, L, R = map(int, input().split())\n\n    g = gcd(a1, a2)\n    \n    if (b2 - b1) % g != 0:\n        print(0)\n        return\n\n    d, x, y = extended_gcd(a1, a2)\n    x *= (b2 - b1) // d\n    y *= (b2 - b1) // d\n\n    lcm = (a1 * a2) // g\n\n    x0 = x\n    y0 = y\n    \n    \n    def find_k_range(L, R, a1, b1, a2, b2, lcm, x0, y0):\n      \n        k_min = math.ceil((L - b1 - a1 * x0) / lcm)\n        k_max = math.floor((R - b1 - a1 * x0) / lcm)\n        \n        return k_min, k_max\n        \n    k_min, k_max = find_k_range(L, R, a1, b1, a2, b2, lcm, x0, y0)\n\n    count = 0\n    \n    for k in range(k_min, k_max + 1):\n      val = a1 * (x0 + (lcm // a1) * k) + b1\n      \n      if L <= val <= R:\n        \n        k_prime = (val - b1) / a1\n        l_prime = (val - b2) / a2\n        \n        if k_prime >= 0 and l_prime >= 0:\n            count += 1\n\n    print(count)\n\nsolve()\n```",
    "34": "```python\ndef solve():\n    n, a, b = map(int, input().split())\n    \n    ans = 0\n    for i in range(1, n):\n        if i > a or n - i > b:\n            continue\n        x = a // i\n        y = b // (n - i)\n        ans = max(ans, min(x, y))\n    \n    print(ans)\n\nsolve()\n```",
    "36": "```python\ndef solve():\n  n = int(input())\n  \n  if n == 0:\n    print(0, 0)\n    return\n  \n  l, r = 0, 10**9\n  k = 0\n  while l <= r:\n    mid = (l + r) // 2\n    if 3 * mid * (mid + 1) >= n:\n      k = mid\n      r = mid - 1\n    else:\n      l = mid + 1\n  \n  n -= 3 * k * (k - 1)\n  \n  x, y = 2 * k, 0\n  \n  if n <= k:\n    x -= 2 * n\n    print(x, y)\n  elif n <= 2 * k:\n    x -= 2 * k\n    y += 2 * (n - k)\n    print(x, y)\n  elif n <= 3 * k:\n    x -= 2 * (2 * k - n)\n    y += 2 * k\n    print(x, y)\n  elif n <= 4 * k:\n    x += 2 * (n - 3 * k)\n    y -= 2 * (4 * k - n)\n    print(x, y)\n  elif n <= 5 * k:\n    x += 2 * k\n    y -= 2 * k\n    x += 2 * (5 * k - n)\n    print(x, y)\n  else:\n    x += 2 * (6 * k - n)\n    print(x, y)\n\nsolve()\n```",
    "37": "```python\ndef solve():\n  a, b, c = map(int, input().split())\n  \n  for i in range(c // a + 1):\n    remaining_damage = c - i * a\n    if remaining_damage >= 0 and remaining_damage % b == 0:\n      print(\"Yes\")\n      return\n  \n  print(\"No\")\n\nsolve()\n```",
    "38": "```python\ndef solve():\n    n, L = map(int, input().split())\n    kefa = list(map(int, input().split()))\n    sasha = list(map(int, input().split()))\n\n    for start_diff in range(L):\n        possible = True\n        kefa_shifted = []\n        for dist in kefa:\n            kefa_shifted.append((dist + start_diff) % L)\n        kefa_shifted.sort()\n\n        if kefa_shifted == sasha:\n            print(\"YES\")\n            return\n    \n    print(\"NO\")\n\nsolve()\n```",
    "41": "```python\ndef solve():\n  n = int(input())\n  a = list(map(int, input().split()))\n  \n  distances = []\n  for i in range(n):\n    min_dist = float('inf')\n    for j in range(n):\n      if a[j] == 0:\n        min_dist = min(min_dist, abs(i - j))\n    distances.append(min_dist)\n    \n  print(*distances)\n\nsolve()\n```",
    "42": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    \n    count = 0\n    distinct_strings = set()\n    \n    for i in range(2**n):\n        binary_string = bin(i)[2:].zfill(n)\n        \n        is_substring = False\n        for j in range(n):\n            shifted_string = binary_string[j:] + binary_string[:j]\n            if s in shifted_string:\n                is_substring = True\n                break\n        \n        if is_substring:\n            if binary_string not in distinct_strings:\n                count += 1\n                distinct_strings.add(binary_string)\n    \n    print(count)\n\nsolve()\n```",
    "43": "```python\nimport math\n\ndef solve():\n    n = int(input())\n    vectors = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        vectors.append((x, y))\n\n    def angle(v):\n        return math.atan2(v[1], v[0])\n\n    angles = []\n    for i in range(n):\n        angles.append((angle(vectors[i]), i + 1))\n\n    angles.sort()\n\n    min_diff = float('inf')\n    best_pair = (0, 0)\n\n    for i in range(n - 1):\n        diff = angles[i+1][0] - angles[i][0]\n        if diff < min_diff:\n            min_diff = diff\n            best_pair = (angles[i][1], angles[i+1][1])\n\n    diff = angles[0][0] + (2 * math.pi - angles[-1][0])\n    if diff < min_diff:\n        min_diff = diff\n        best_pair = (angles[-1][1], angles[0][1])\n\n    print(best_pair[0], best_pair[1])\n\nsolve()\n```",
    "44": "```python\nd, k, a, b, t = map(int, input().split())\n\nif d <= k:\n  print(d * a)\nelse:\n  if k * a + t >= k * b:\n    print(k * a + (d - k) * b)\n  else:\n    num_breaks = (d - 1) // k\n    \n    if num_breaks * t + d * a < k * a + (d - k) * b + (num_breaks - 1 )*t:\n        print(num_breaks * t + d * a)\n    else:\n        print(k * a + (d - k) * b + num_breaks * t)\n```",
    "45": "```python\ndef solve():\n    n, k = map(int, input().split())\n\n    if k * (k + 1) // 2 > n:\n        print(\"-1\")\n        return\n\n    best_gcd = 1\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i >= k * (k + 1) // 2:\n                best_gcd = max(best_gcd, i)\n            if i >= k * (k + 1) // 2:\n                best_gcd = max(best_gcd, n // i)\n\n    if best_gcd == 0:\n        print(\"-1\")\n        return\n\n    result = []\n    for i in range(1, k):\n        result.append(best_gcd * i)\n    \n    result.append(n - sum(result))\n\n    if all(result[i] < result[i+1] for i in range(len(result)-1)) and all(x > 0 for x in result):\n       print(*result)\n\n    else:\n      print(\"-1\")\n\n\n\nsolve()\n```",
    "46": "```python\ndef solve():\n  n, m = map(int, input().split())\n  count = 0\n  for x in range(1, n + 1):\n    for y in range(1, m + 1):\n      if (x + y) % 5 == 0:\n        count += 1\n  print(count)\n\nsolve()\n```",
    "47": "```python\ndef solve():\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    ans = 0\n    for i in range(n + 1):\n        for j in range(i, n + 1):\n            temp_a = a[:]\n            for k in range(i, j):\n                temp_a[k] *= x\n            \n            curr_max = 0\n            max_so_far = 0\n            for k in range(n):\n                curr_max += temp_a[k]\n                if curr_max < 0:\n                    curr_max = 0\n                max_so_far = max(max_so_far, curr_max)\n            ans = max(ans, max_so_far)\n\n    print(ans)\n\nsolve()\n```",
    "48": "```python\ndef solve():\n    n, m, k = map(int, input().split())\n\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(m, x // i)\n        return count\n\n    low = 1\n    high = n * m\n    ans = -1\n    while low <= high:\n        mid = (low + high) // 2\n        if count_less_equal(mid) >= k:\n            ans = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    print(ans)\n\nsolve()\n```",
    "49": "```python\nk = int(input())\n\nlength = 1\ncount = 9\nwhile k > length * count:\n    k -= length * count\n    length += 1\n    count *= 10\n\nnumber = 10**(length - 1) + (k - 1) // length\nindex = (k - 1) % length\nprint(str(number)[index])\n```",
    "52": "```python\ndef solve():\n    n, m, k = map(int, input().split())\n    a = []\n    for _ in range(n):\n        a.append(list(map(int, input().split())))\n\n    dp = {}\n\n    def get_max_sum(row_index, current_sum):\n        if row_index == n:\n            if current_sum % k == 0:\n                return current_sum\n            else:\n                return -float('inf')\n\n        if (row_index, current_sum) in dp:\n            return dp[(row_index, current_sum)]\n\n        max_val = -float('inf')\n        \n        \n        num_elements_to_choose = min(m // 2, m) \n        \n        for i in range(1 << m):\n            count = 0\n            subset_sum = 0\n            subset_indices = []\n            for j in range(m):\n                if (i >> j) & 1:\n                    count += 1\n                    subset_sum += a[row_index][j]\n                    subset_indices.append(j)\n\n            if count <= m // 2:\n                max_val = max(max_val, get_max_sum(row_index + 1, current_sum + subset_sum))\n\n        dp[(row_index, current_sum)] = max_val\n        return max_val\n\n    result = get_max_sum(0, 0)\n    print(result)\n\nsolve()\n```",
    "53": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    def find_longest_increasing_sequence(arr):\n        best_len = 0\n        best_moves = \"\"\n\n        def backtrack(current_seq, remaining_arr, moves):\n            nonlocal best_len, best_moves\n\n            if not remaining_arr:\n                if len(current_seq) > best_len:\n                    best_len = len(current_seq)\n                    best_moves = moves\n                return\n\n            if not current_seq:\n                # Choose left\n                backtrack(current_seq + [remaining_arr[0]], remaining_arr[1:], moves + \"L\")\n                # Choose right\n                backtrack(current_seq + [remaining_arr[-1]], remaining_arr[:-1], moves + \"R\")\n            else:\n                last_val = current_seq[-1]\n                # Choose left\n                if remaining_arr[0] > last_val:\n                    backtrack(current_seq + [remaining_arr[0]], remaining_arr[1:], moves + \"L\")\n                # Choose right\n                if remaining_arr[-1] > last_val:\n                    backtrack(current_seq + [remaining_arr[-1]], remaining_arr[:-1], moves + \"R\")\n\n        backtrack([], a, \"\")\n        return best_len, best_moves\n\n    def find_longest_increasing_sequence_dp(arr):\n        n = len(arr)\n        max_len = 0\n        best_moves = \"\"\n\n        for i in range(1 << n):\n            \n            moves = \"\"\n            temp_arr = arr[:]\n            current_seq = []\n            idx = 0\n            possible = True\n\n            for j in range(n):\n                if (i >> j) & 1:\n                    if not temp_arr:\n                        possible = False\n                        break\n                    if not current_seq:\n                        current_seq.append(temp_arr.pop(0))\n                        moves += \"L\"\n                    elif temp_arr[0] > current_seq[-1]:\n                        current_seq.append(temp_arr.pop(0))\n                        moves += \"L\"\n                    else:\n                        possible = False\n                        break\n                else:\n                    if not temp_arr:\n                        possible = False\n                        break\n                    if not current_seq:\n                        current_seq.append(temp_arr.pop())\n                        moves += \"R\"\n                    elif temp_arr[-1] > current_seq[-1]:\n                        current_seq.append(temp_arr.pop())\n                        moves += \"R\"\n                    else:\n                        possible = False\n                        break\n\n            if possible and len(current_seq) > max_len:\n                max_len = len(current_seq)\n                best_moves = moves\n\n        return max_len, best_moves\n\n    def solve_optimized(arr):\n        n = len(arr)\n        \n        def get_max_len(left, right, last_val, moves):\n            if left > right:\n                return len(moves), moves\n\n            len_left = 0\n            moves_left = \"\"\n            \n            if arr[left] > last_val:\n                len_left, moves_left = get_max_len(left + 1, right, arr[left], moves + \"L\")\n\n            len_right = 0\n            moves_right = \"\"\n\n            if arr[right] > last_val:\n                len_right, moves_right = get_max_len(left, right - 1, arr[right], moves + \"R\")\n\n            if len_left >= len_right:\n                return len_left, moves_left\n            else:\n                return len_right, moves_right\n\n        length, moves = get_max_len(0, n - 1, -1, \"\")\n        return length, moves\n\n    length, moves = solve_optimized(a)\n    print(length)\n    print(moves)\n\nsolve()\n```",
    "54": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    if n == 1:\n        print(0)\n        return\n\n    unique_values = sorted(list(set(a)))\n\n    if len(unique_values) > 3:\n        print(-1)\n        return\n    \n    if len(unique_values) == 1:\n        print(0)\n        return\n    \n    if len(unique_values) == 2:\n        val1, val2 = unique_values\n        d = abs(val1 - val2)\n        if d % 2 == 0:\n            print(d // 2)\n        else:\n            print(d // 2 + (d % 2))\n        return\n\n    if len(unique_values) == 3:\n        val1, val2, val3 = unique_values\n        if val2 - val1 == val3 - val2:\n            print(val2 - val1)\n        else:\n            print(-1)\n        return\n\nsolve()\n```",
    "55": "```python\ndef solve():\n    x1, y1, x2, y2 = map(int, input().split())\n    x3, y3, x4, y4 = map(int, input().split())\n    x5, y5, x6, y6 = map(int, input().split())\n\n    white_area = (x2 - x1) * (y2 - y1)\n\n    # Calculate intersection with first black sheet\n    x_overlap1 = max(0, min(x2, x4) - max(x1, x3))\n    y_overlap1 = max(0, min(y2, y4) - max(y1, y3))\n    intersection_area1 = x_overlap1 * y_overlap1\n\n    # Calculate intersection with second black sheet\n    x_overlap2 = max(0, min(x2, x6) - max(x1, x5))\n    y_overlap2 = max(0, min(y2, y6) - max(y1, y5))\n    intersection_area2 = x_overlap2 * y_overlap2\n\n    # Calculate intersection between the two black sheets and the white sheet\n    x_intersect_black = max(0, min(x4, x6) - max(x3, x5))\n    y_intersect_black = max(0, min(y4, y6) - max(y3, y5))\n    black_intersection = x_intersect_black * y_intersect_black\n\n    x_overlap_all = max(0, min(x2, x4, x6) - max(x1, x3, x5))\n    y_overlap_all = max(0, min(y2, y4, y6) - max(y1, y3, y5))\n    intersection_area_all = x_overlap_all * y_overlap_all\n\n    covered_area = intersection_area1 + intersection_area2 - intersection_area_all\n\n    if white_area > covered_area:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nsolve()\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef solve():\n    n = int(input())\n    reachable = {n}\n    curr = n\n    while True:\n        curr = f(curr)\n        if curr in reachable:\n            break\n        reachable.add(curr)\n    print(len(reachable))\n\nsolve()\n```",
    "57": "```python\ndef solve():\n    n = int(input())\n    f = list(map(int, input().split()))\n    \n    givers = [i + 1 for i in range(n)]\n    receivers = [i + 1 for i in range(n)]\n    \n    given = set()\n    for val in f:\n        if val != 0:\n            given.add(val)\n    \n    not_given = []\n    for i in range(1, n + 1):\n        if i not in given:\n            not_given.append(i)\n            \n    zeros = []\n    for i in range(n):\n        if f[i] == 0:\n            zeros.append(i)\n    \n    for i in range(len(zeros)):\n        f[zeros[i]] = not_given[i]\n        \n    \n    \n    \n    \n    \n    \n    \n    conflicts = []\n    for i in range(n):\n        if f[i] == i + 1:\n            conflicts.append(i)\n            \n    if len(conflicts) > 0:\n        if len(conflicts) == 1:\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            for i in range(n):\n                if i != conflicts[0] and f[i] != i + 1 and i+1 != f[conflicts[0]]:\n                    temp = f[conflicts[0]]\n                    f[conflicts[0]] = f[i]\n                    f[i] = temp\n                    \n                    \n                    break\n        elif len(conflicts) > 1:\n            \n            \n            \n            \n            for i in range(0,len(conflicts),2):\n                if i+1 < len(conflicts):\n                    temp = f[conflicts[i]]\n                    f[conflicts[i]] = f[conflicts[i+1]]\n                    f[conflicts[i+1]] = temp\n                else:\n                    \n                    \n                    \n                    for j in range(n):\n                        if j != conflicts[i] and f[j] != j+1 and j+1 != f[conflicts[i]]:\n                            temp = f[conflicts[i]]\n                            f[conflicts[i]] = f[j]\n                            f[j] = temp\n                            \n                            break\n            \n    print(*f)\n\nsolve()\n```",
    "59": "```python\ndef solve():\n    n, x, y = map(int, input().split())\n    s = input()\n    \n    count = 0\n    for i in range(n - x, n):\n        if i == n - 1 - y:\n            if s[i] == '0':\n                count += 1\n        else:\n            if s[i] == '1':\n                count += 1\n                \n    print(count)\n\nsolve()\n```",
    "61": "```python\ndef solve():\n  n = int(input())\n  a = input()\n  f = list(map(int, input().split()))\n\n  best_a = a\n  \n  for i in range(n):\n    for j in range(i, n):\n      temp_a_list = list(a)\n      for k in range(i, j + 1):\n        digit = int(a[k])\n        temp_a_list[k] = str(f[digit - 1])\n      \n      temp_a = \"\".join(temp_a_list)\n      if temp_a > best_a:\n        best_a = temp_a\n        \n  print(best_a)\n\nsolve()\n```",
    "62": "```python\ndef solve():\n    a, b, c = map(int, input().split())\n    \n    best_cost = float('inf')\n    best_triple = None\n    \n    for A in range(1, 2 * a + 1):\n        for B in range(A, 2 * b + 1, A):\n            for C in range(B, 2 * c + 1, B):\n                cost = abs(A - a) + abs(B - b) + abs(C - c)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_triple = (A, B, C)\n    \n    print(best_cost)\n    print(*best_triple)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "64": "```python\ndef solve():\n  n, m = map(int, input().split())\n  exams = []\n  for i in range(m):\n    s, d, c = map(int, input().split())\n    exams.append((s, d, c))\n  \n  schedule = [0] * n\n  exam_days = {}\n  for i in range(m):\n    exam_days[exams[i][1] - 1] = i + 1\n  \n  for day in exam_days:\n    schedule[day] = m + 1\n    \n  prep_counts = [0] * m\n  \n  for day in range(n):\n    if schedule[day] == 0:\n      best_exam = -1\n      for i in range(m):\n        s, d, c = exams[i]\n        if s - 1 <= day < d - 1 and prep_counts[i] < c:\n          if best_exam == -1:\n            best_exam = i\n          else:\n            s_best, _, _ = exams[best_exam]\n            if s > s_best:\n              best_exam = i\n      if best_exam != -1:\n        schedule[day] = best_exam + 1\n        prep_counts[best_exam] += 1\n  \n  for i in range(m):\n    if prep_counts[i] != exams[i][2]:\n      print(\"-1\")\n      return\n  \n  print(*schedule)\n\nsolve()\n```",
    "65": "```python\ndef solve():\n    n, m = map(int, input().split())\n\n    if n == m:\n        print(0)\n        return\n\n    if m % n != 0:\n        print(-1)\n        return\n\n    diff = m // n\n    \n    count = 0\n    while diff % 2 == 0:\n        diff //= 2\n        count += 1\n    while diff % 3 == 0:\n        diff //= 3\n        count += 1\n    \n    if diff != 1:\n        print(-1)\n    else:\n        twos = 0\n        threes = 0\n        temp = m//n\n        while temp % 2 == 0:\n            temp //= 2\n            twos += 1\n        \n        while temp % 3 == 0:\n            temp //= 3\n            threes += 1\n        \n        if temp != 1:\n            print(-1)\n        else:\n            count_t = 0\n            temp_t = m//n\n\n            while temp_t > 1:\n                if temp_t % 2 == 0:\n                    temp_t //= 2\n                    count_t += 1\n                elif temp_t % 3 == 0:\n                    temp_t //= 3\n                    count_t += 1\n                else:\n                    count_t = -1\n                    break\n\n            print(count_t)\n\nsolve()\n```",
    "66": "```python\ndef solve():\n    n, k = map(int, input().split())\n    t = input()\n    \n    if k == 1:\n        print(t)\n        return\n    \n    max_overlap = 0\n    for overlap in range(1, n):\n        if t[:n - overlap] == t[overlap:]:\n            max_overlap = n - overlap\n            break\n    \n    result = t + t[max_overlap:] * (k - 1)\n    print(result)\n\nsolve()\n```",
    "68": "```python\ndef solve():\n  n, k = map(int, input().split())\n  s = input()\n  \n  dp = [[0] * (n + 1) for _ in range(n + 1)]\n  dp[0][0] = 1\n  \n  for i in range(1, n + 1):\n    for j in range(i + 1):\n      dp[i][j] = dp[i-1][j]\n      if j > 0:\n        dp[i][j] += dp[i-1][j-1]\n\n  counts = [0] * (n + 1)\n  for i in range(n + 1):\n    counts[i] = dp[n][i]\n  \n  ans = 0\n  curr_len = n\n  \n  while k > 0 and curr_len >= 0:\n    take = min(k, counts[curr_len])\n    ans += (n - curr_len) * take\n    k -= take\n    curr_len -= 1\n  \n  if k > 0:\n    print(-1)\n  else:\n    print(ans)\n\nsolve()\n```",
    "69": "```python\ndef solve():\n    n, m, d = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n\n    def check_degree(tree_edges):\n        degree = 0\n        for u, v in tree_edges:\n            if u == 1 or v == 1:\n                degree += 1\n        return degree\n\n    import itertools\n    for i in range(1 << m):\n        tree_edges = []\n        for j in range(m):\n            if (i >> j) & 1:\n                tree_edges.append(edges[j])\n\n        if len(tree_edges) != n - 1:\n            continue\n        \n        import collections\n        adj = collections.defaultdict(list)\n        for u, v in tree_edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        \n        def is_connected(tree_edges, n):\n            if not tree_edges:\n                return n == 1\n            \n            visited = set()\n            q = collections.deque([tree_edges[0][0]])\n            visited.add(tree_edges[0][0])\n            \n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if v not in visited:\n                        visited.add(v)\n                        q.append(v)\n            \n            return len(visited) == n\n\n        if is_connected(tree_edges, n) and check_degree(tree_edges) == d:\n            print(\"YES\")\n            for u, v in tree_edges:\n                print(u, v)\n            return\n\n    print(\"NO\")\n\nsolve()\n```",
    "70": "```python\nh1, m1 = map(int, input().replace(':', ' ').split())\nh2, m2 = map(int, input().replace(':', ' ').split())\n\nstart_minutes = h1 * 60 + m1\nend_minutes = h2 * 60 + m2\n\nmid_minutes = (start_minutes + end_minutes) // 2\n\nh3 = mid_minutes // 60\nm3 = mid_minutes % 60\n\nprint(f\"{h3:02d}:{m3:02d}\")\n```",
    "71": "```python\nimport math\n\na = int(input())\nif a == 1:\n  print(1)\nelse:\n  print(math.ceil(math.log(a, 2)))\n```",
    "73": "```python\ndef solve():\n  n = int(input())\n  a = list(map(int, input().split()))\n  \n  stack = []\n  for x in a:\n    if stack and stack[-1] == x:\n      stack.pop()\n    else:\n      stack.append(x)\n      \n  if not stack:\n    print(\"YES\")\n  elif len(stack) == 1:\n    print(\"YES\")\n  else:\n    print(\"NO\")\n\nsolve()\n```",
    "74": "```python\ndef solve():\n    n, k = map(int, input().split())\n    s = input()\n    \n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            dp[i][j] = dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i-1][j-1]\n            dp[i][j] = min(dp[i][j], k)\n    \n    total_subsequences = 0\n    for i in range(n + 1):\n        total_subsequences += dp[n][i]\n    \n    total_subsequences = min(total_subsequences, k)\n    \n    if total_subsequences < k:\n        print(-1)\n        return\n    \n    cost = 0\n    current_len = n\n    \n    while k > 0:\n        if dp[n][current_len] >= k:\n            cost += (n - current_len) * k\n            k = 0\n        else:\n            cost += (n - current_len) * dp[n][current_len]\n            k -= dp[n][current_len]\n        current_len -= 1\n        \n    print(cost)\n\nsolve()\n```",
    "75": "```python\ndef solve():\n    a, b, c = map(int, input().split())\n    \n    week = [0, 1, 2, 0, 2, 1, 0]\n    \n    days_in_week = [0] * 7\n    for i in range(7):\n        if week[i] == 0:\n            days_in_week[i] = a\n        elif week[i] == 1:\n            days_in_week[i] = b\n        else:\n            days_in_week[i] = c\n    \n    min_weeks = min(a // 3, b // 2, c // 2)\n    a -= min_weeks * 3\n    b -= min_weeks * 2\n    c -= min_weeks * 2\n    \n    ans = min_weeks * 7\n    \n    max_days = 0\n    for start_day in range(7):\n        temp_a, temp_b, temp_c = a, b, c\n        days = 0\n        current_day = start_day\n        \n        while True:\n            food = week[current_day % 7]\n            \n            if food == 0:\n                if temp_a > 0:\n                    temp_a -= 1\n                    days += 1\n                else:\n                    break\n            elif food == 1:\n                if temp_b > 0:\n                    temp_b -= 1\n                    days += 1\n                else:\n                    break\n            else:\n                if temp_c > 0:\n                    temp_c -= 1\n                    days += 1\n                else:\n                    break\n            \n            current_day += 1\n        max_days = max(max_days, days)\n    \n    print(ans + max_days)\n\nsolve()\n```",
    "76": "```python\ndef solve():\n  n, m = map(int, input().split())\n  tiles = []\n  for _ in range(n):\n    tiles.append([list(map(int, input().split())) for _ in range(2)])\n\n  if m % 2 != 0:\n    print(\"NO\")\n    return\n  \n  found = False\n  for tile in tiles:\n    if tile[0][1] == tile[1][0]:\n      found = True\n      break\n  \n  if found:\n    print(\"YES\")\n  else:\n    print(\"NO\")\n\nt = int(input())\nfor _ in range(t):\n  solve()\n```",
    "77": "```python\nn = int(input())\nif n % 4 == 0 or n % 4 == 3:\n    print(0)\nelse:\n    print(1)\n```",
    "78": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    mod = 10**9 + 7\n    len_s = len(s)\n\n    def is_regular(seq):\n        balance = 0\n        for char in seq:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    def generate_bracket_sequences(length):\n        if length == 0:\n            return [\"\"]\n        \n        sequences = []\n        for seq in generate_bracket_sequences(length - 1):\n            sequences.append(seq + \"(\")\n            sequences.append(seq + \")\")\n        return sequences\n    \n    all_sequences = generate_bracket_sequences(2 * n)\n    \n    count = 0\n    for seq in all_sequences:\n        if is_regular(seq) and s in seq:\n            count = (count + 1) % mod\n    \n    print(count)\n\nsolve()\n```",
    "79": "```python\ndef solve():\n    n = input()\n    s = list(n)\n    l = len(s)\n    ans = float('inf')\n\n    for suffix in ['00', '25', '50', '75']:\n        temp_s = s[:]\n        moves = 0\n\n        # Find the last digit of the suffix\n        last_digit_index = -1\n        for i in range(l - 1, -1, -1):\n            if temp_s[i] == suffix[1]:\n                last_digit_index = i\n                break\n\n        if last_digit_index == -1:\n            continue\n\n        moves += (l - 1) - last_digit_index\n        del temp_s[last_digit_index]\n\n        # Find the second last digit of the suffix\n        second_last_digit_index = -1\n        for i in range(len(temp_s) - 1, -1, -1):\n            if temp_s[i] == suffix[0]:\n                second_last_digit_index = i\n                break\n\n        if second_last_digit_index == -1:\n            continue\n\n        moves += (len(temp_s) - 1) - second_last_digit_index\n        del temp_s[second_last_digit_index]\n\n        # Remove leading zeros\n        leading_zeros = 0\n        for i in range(len(temp_s)):\n            if temp_s[i] == '0':\n                leading_zeros += 1\n            else:\n                break\n\n        moves += leading_zeros\n        ans = min(ans, moves)\n\n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)\n\nsolve()\n```",
    "80": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    \n    def check(k):\n        colors = [0] * n\n        \n        def backtrack(index):\n            if index == n:\n                return colors\n            \n            for color in range(1, k + 1):\n                colors[index] = color\n                \n                # Check if valid so far\n                valid = True\n                for i in range(index):\n                    if s[i] > s[index] and colors[i] == colors[index]:\n                        valid = False\n                        break\n                \n                if valid:\n                    result = backtrack(index + 1)\n                    if result:\n                        return result\n            \n            colors[index] = 0  # Reset for backtracking\n            return None\n        \n        return backtrack(0)\n    \n    for k in range(1, n + 1):\n        coloring = check(k)\n        if coloring:\n            print(k)\n            print(*coloring)\n            return\n\nsolve()\n```",
    "81": "```python\ndef solve():\n    n = int(input())\n    strings = []\n    for _ in range(n):\n        strings.append(input())\n\n    def is_substring(a, b):\n        return a in b\n\n    def check_order(order):\n        for i in range(1, len(order)):\n            for j in range(i):\n                if not is_substring(order[j], order[i]):\n                    return False\n        return True\n\n    import itertools\n    \n    for permutation in itertools.permutations(strings):\n        if check_order(list(permutation)):\n            print(\"YES\")\n            for s in permutation:\n                print(s)\n            return\n    \n    print(\"NO\")\n\nsolve()\n```",
    "82": "```python\ndef solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    l = 0\n    r = n - 1\n    count = 0\n    \n    while l <= r:\n        if a[l] <= k:\n            count += 1\n            l += 1\n        elif a[r] <= k:\n            count += 1\n            r -= 1\n        else:\n            break\n            \n        if l > r:\n            break\n            \n        \n        if a[l-1] > k and a[r+1] > k and l <= r:\n            break\n            \n        \n    print(count)\n\nsolve()\n```",
    "83": "```python\nimport math\n\ndef solve():\n    a, b = map(int, input().split())\n    total = a + b\n    \n    best_perimeter = float('inf')\n    \n    for height in range(1, int(math.sqrt(total)) + 2):\n        if total % height == 0:\n            width = total // height\n            \n            # Case 1: Red forms a rectangle\n            for red_height in range(1, int(math.sqrt(a)) + 2):\n                if a % red_height == 0:\n                    red_width = a // red_height\n                    if red_height <= height and red_width <= width:\n                        best_perimeter = min(best_perimeter, 2 * (height + width))\n                        \n            # Case 2: Blue forms a rectangle\n            for blue_height in range(1, int(math.sqrt(b)) + 2):\n                if b % blue_height == 0:\n                    blue_width = b // blue_height\n                    if blue_height <= height and blue_width <= width:\n                        best_perimeter = min(best_perimeter, 2 * (height + width))\n                        \n    print(best_perimeter)\n\nsolve()\n```",
    "84": "```python\ndef solve():\n    n = int(input())\n    s = input()\n\n    for i in range(1 << n):\n        coloring = \"\"\n        for j in range(n):\n            if (i >> j) & 1:\n                coloring += \"1\"\n            else:\n                coloring += \"0\"\n\n        s0 = \"\"\n        s1 = \"\"\n        for j in range(n):\n            if coloring[j] == '0':\n                s0 += s[j]\n            else:\n                s1 += s[j]\n\n        s0 = \"\".join(sorted(s0))\n        s1 = \"\".join(sorted(s1))\n\n        merged = \"\"\n        idx0 = 0\n        idx1 = 0\n        for j in range(n):\n            if coloring[j] == '0':\n                merged += s0[idx0]\n                idx0 += 1\n            else:\n                merged += s1[idx1]\n                idx1 += 1\n        \n        if \"\".join(sorted(s)) == merged:\n            print(\"YES\")\n            print(coloring)\n            return\n    \n    print(\"NO\")\n\nsolve()\n```",
    "85": "```python\ndef solve():\n  a, b = map(int, input().split())\n  \n  ans = -1\n  for price in range(1, 10001):\n    tax8 = int(price * 0.08)\n    tax10 = int(price * 0.10)\n    \n    if tax8 == a and tax10 == b:\n      ans = price\n      break\n      \n  print(ans)\n\nsolve()\n```",
    "86": "```python\ndef solve():\n  n, k = map(int, input().split())\n\n  if k * (k + 1) // 2 > n:\n    print(\"NO\")\n    return\n\n  a = [i + 1 for i in range(k)]\n  remaining = n - k * (k + 1) // 2\n\n  add = remaining // k\n  rem = remaining % k\n\n  for i in range(k):\n    a[i] += add\n\n  for i in range(k - 1, k - 1 - rem, -1):\n    a[i] += 1\n\n  for i in range(k - 1):\n    if a[i+1] > 2 * a[i]:\n      diff = a[i+1] - 2 * a[i]\n      a[i+1] -= diff\n      a[k-1] += diff\n      \n      if a[i+1] <= a[i] or a[i+1] > 2 * a[i]:\n        print(\"NO\")\n        return\n  \n  \n  for i in range(k - 1):\n      if a[i+1] <= a[i] or a[i+1] > 2 * a[i]:\n          print(\"NO\")\n          return\n\n  print(\"YES\")\n  print(*a)\n\n\nsolve()\n```",
    "88": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    counts = {}\n    for x in a:\n        counts[x] = counts.get(x, 0) + 1\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    def can_place(r, c, val):\n        if matrix[r][c] != 0:\n            return False\n        return True\n    \n    def place(r, c, val):\n        matrix[r][c] = val\n        matrix[n-1-r][c] = val\n        matrix[r][n-1-c] = val\n        matrix[n-1-r][n-1-c] = val\n        counts[val] -= 4\n        \n    def unplace(r, c, val):\n        matrix[r][c] = 0\n        matrix[n-1-r][c] = 0\n        matrix[r][n-1-c] = 0\n        matrix[n-1-r][n-1-c] = 0\n        counts[val] += 4\n\n    def can_place_2(r, c, val):\n        if matrix[r][c] != 0:\n            return False\n        return True\n    \n    def place_2(r, c, val):\n        matrix[r][c] = val\n        matrix[n-1-r][c] = val\n        counts[val] -= 2\n        \n    def unplace_2(r, c, val):\n        matrix[r][c] = 0\n        matrix[n-1-r][c] = 0\n        counts[val] += 2\n        \n    def can_place_2_2(r, c, val):\n        if matrix[r][c] != 0:\n            return False\n        return True\n    \n    def place_2_2(r, c, val):\n        matrix[r][c] = val\n        matrix[r][n-1-c] = val\n        counts[val] -= 2\n        \n    def unplace_2_2(r, c, val):\n        matrix[r][c] = 0\n        matrix[r][n-1-c] = 0\n        counts[val] += 2\n\n    def can_place_1(r, c, val):\n        if matrix[r][c] != 0:\n            return False\n        return True\n    \n    def place_1(r, c, val):\n        matrix[r][c] = val\n        counts[val] -= 1\n        \n    def unplace_1(r, c, val):\n        matrix[r][c] = 0\n        counts[val] += 1\n\n    def solve_recursive(r, c):\n        if r == (n + 1) // 2:\n            return True\n        \n        next_r = r\n        next_c = c + 1\n        if next_c == (n + 1) // 2:\n            next_r = r + 1\n            next_c = 0\n            \n        for val in sorted(counts.keys()):\n            if counts[val] > 0:\n                if r < n // 2 and c < n // 2:\n                    if counts[val] >= 4 and can_place(r, c, val) :\n                        place(r, c, val)\n                        if solve_recursive(next_r, next_c):\n                            return True\n                        unplace(r, c, val)\n                elif r < n // 2 and c == n // 2 and n % 2 != 0:\n                    if counts[val] >= 2 and can_place_2(r, c, val):\n                        place_2(r, c, val)\n                        if solve_recursive(next_r, next_c):\n                            return True\n                        unplace_2(r, c, val)\n                elif r == n // 2 and c < n // 2 and n % 2 != 0:\n                    if counts[val] >= 2 and can_place_2_2(r, c, val):\n                        place_2_2(r, c, val)\n                        if solve_recursive(next_r, next_c):\n                            return True\n                        unplace_2_2(r, c, val)\n                elif r == n // 2 and c == n // 2 and n % 2 != 0:\n                     if counts[val] >= 1 and can_place_1(r, c, val):\n                        place_1(r, c, val)\n                        if solve_recursive(next_r, next_c):\n                            return True\n                        unplace_1(r, c, val)\n        return False\n    \n    if solve_recursive(0, 0):\n        print(\"YES\")\n        for row in matrix:\n            print(*row)\n    else:\n        print(\"NO\")\n\nsolve()\n```",
    "90": "```python\ndef solve():\n    n, m, d = map(int, input().split())\n    c = list(map(int, input().split()))\n    \n    total_length = sum(c)\n    \n    min_empty = m - 1\n    \n    if n - total_length < min_empty:\n        print(\"NO\")\n        return\n    \n    arr = [0] * n\n    \n    pos = 0\n    for i in range(m):\n        \n        \n        best_start = -1\n        for j in range(pos, min(n - c[i] + 1, pos + d)):\n            \n            best_start = j\n            break\n        \n        if best_start == -1:\n            print(\"NO\")\n            return\n        \n        for k in range(c[i]):\n            arr[best_start + k] = i + 1\n        \n        pos = best_start + c[i]\n    \n    \n    if pos + d <= n:\n       \n        print(\"YES\")\n        print(*arr)\n    else:\n        \n        print(\"YES\")\n        print(*arr)\n\nsolve()\n```",
    "91": "```python\ndef solve():\n    s = input()\n    t = input()\n    n = len(s)\n    m = len(t)\n    ans = 0\n    for i in range(n + 1):\n        for j in range(i, n + 1):\n            temp = \"\"\n            if i > 0:\n                temp += s[:i]\n            if j < n:\n                temp += s[j:]\n            \n            k = 0\n            l = 0\n            possible = True\n            while k < len(temp) and l < m:\n                if temp[k] == t[l]:\n                    l += 1\n                k += 1\n            \n            if l == m:\n                ans = max(ans, j - i)\n    print(ans)\nsolve()\n```",
    "92": "```python\nx = float(input())\n\na = int((x * 10) // 1)\nb = int((x * 10) % 1 * 10 + 1)\nif b > 10:\n  b = 10\nif a == 0:\n  a = 1\n\nprint(a, b)\n```",
    "93": "```python\ndef solve():\n  n, d, k = map(int, input().split())\n\n  if d >= n:\n    print(\"NO\")\n    return\n\n  if d == 1 and n > 2:\n    if k == 1:\n      print(\"NO\")\n      return\n    \n  if d > 1 and k == 1:\n    print(\"NO\")\n    return\n\n  edges = []\n  \n  # Create the diameter path\n  for i in range(d):\n    edges.append((i + 1, i + 2))\n  \n  degree = [0] * (n + 1)\n  for u, v in edges:\n    degree[u] += 1\n    degree[v] += 1\n  \n  next_node = d + 2\n  \n  # Add nodes to the diameter path\n  for i in range(1, d + 2):\n    while degree[i] < k and next_node <= n:\n      edges.append((i, next_node))\n      degree[i] += 1\n      degree[next_node] += 1\n      next_node += 1\n  \n  # Check if we used all nodes\n  if next_node <= n:\n    print(\"NO\")\n    return\n  \n  # Check if the graph is connected\n  if len(edges) != n - 1:\n    print(\"NO\")\n    return\n  \n  # Check if the degree is at most k\n  for i in range(1, n + 1):\n    if degree[i] > k:\n      print(\"NO\")\n      return\n  \n  print(\"YES\")\n  for u, v in edges:\n    print(u, v)\n\nsolve()\n```",
    "94": "```python\na, b, x = map(int, input().split())\n\nif a > b:\n    start = '0'\n    a -= 1\nelse:\n    start = '1'\n    b -= 1\n\nresult = start\n\nfor i in range(x - 1):\n    if start == '0':\n        result += '1'\n        start = '1'\n        b -= 1\n    else:\n        result += '0'\n        start = '0'\n        a -= 1\n\nif start == '0':\n    result += '0' * a\n    result += '1' * b\nelse:\n    result += '1' * b\n    result += '0' * a\n\nprint(result)\n```",
    "95": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    t = input()\n\n    chars = ['a', 'b', 'c']\n\n    import itertools\n    \n    for perm in itertools.permutations(chars):\n        res = \"\"\n        for _ in range(n):\n            res += \"\".join(perm)\n\n        valid = True\n        for i in range(len(res) - 1):\n            if res[i:i+2] == s or res[i:i+2] == t:\n                valid = False\n                break\n        \n        if valid:\n            print(\"YES\")\n            print(res)\n            return\n    \n    \n    res = \"a\"*n + \"b\"*n + \"c\"*n\n    valid = True\n    for i in range(len(res) - 1):\n        if res[i:i+2] == s or res[i:i+2] == t:\n            valid = False\n            break\n\n    if valid:\n        print(\"YES\")\n        print(res)\n        return\n\n    res = \"c\"*n + \"b\"*n + \"a\"*n\n    valid = True\n    for i in range(len(res) - 1):\n        if res[i:i+2] == s or res[i:i+2] == t:\n            valid = False\n            break\n\n    if valid:\n        print(\"YES\")\n        print(res)\n        return\n    \n    \n    if n == 1 and (s == \"ab\" and t == \"cb\"):\n        print(\"YES\")\n        print(\"bac\")\n        return\n\n\n    for perm in itertools.permutations(chars):\n        res = \"\"\n        for i in range(n):\n            res += perm[0]\n            if i + 1 < n:\n                res += perm[1]\n            \n        for i in range(n):\n            res += perm[2]\n            \n\n        valid = True\n        for i in range(len(res) - 1):\n            if res[i:i+2] == s or res[i:i+2] == t:\n                valid = False\n                break\n        \n        if valid and len(res) == 3*n:\n            print(\"YES\")\n            print(res)\n            return\n\n    print(\"NO\")\n\nsolve()\n```",
    "96": "```python\ndef solve():\n    n = int(input())\n    q = list(map(int, input().split()))\n\n    for first_element in range(1, n + 1):\n        p = [first_element]\n        \n        valid = True\n        for i in range(n - 1):\n            next_element = p[-1] + q[i]\n            if 1 <= next_element <= n:\n                p.append(next_element)\n            else:\n                valid = False\n                break\n\n        if valid:\n            if len(set(p)) == n:\n                print(*p)\n                return\n\n    print(-1)\n\nsolve()\n```",
    "97": "```python\ndef solve():\n    n = int(input())\n    x = list(map(int, input().split()))\n\n    odd_count = 0\n    even_count = 0\n    for val in x:\n        if val % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    print(min(odd_count, even_count))\n\nsolve()\n```",
    "98": "```python\ndef solve():\n  n = int(input())\n  \n  best_moves = float('inf')\n  \n  for i in range(1, int(n**0.5) + 2):\n    if n % i == 0:\n      j = n // i\n      moves = (i - 1) + (j - 1)\n      best_moves = min(best_moves, moves)\n      \n  print(best_moves)\n\nsolve()\n```",
    "99": "```python\ndef solve():\n    n = int(input())\n    a1, a2, a3 = map(int, input().split())\n    b1, b2, b3 = map(int, input().split())\n\n    min_wins = max(0, a1 - (b1 + b3 - a2) - b2, a2 - (b2 + b1 - a3) - b3, a3 - (b3 + b2 - a1) - b1)\n    min_wins = max(0, a1 - (n-a1-a2-b2) - b2, a2 - (n-a2-a3-b3) - b3, a3 - (n-a3-a1-b1) -b1)\n    \n    min_wins = 0\n    \n    temp_a1 = a1\n    temp_a2 = a2\n    temp_a3 = a3\n    temp_b1 = b1\n    temp_b2 = b2\n    temp_b3 = b3\n\n    wins = 0\n    wins += max(0, min(a1,b2))\n    min_wins = wins\n    temp_a1 -= min(a1,b2)\n    temp_b2 -= min(a1,b2)\n    wins = 0\n    wins += max(0, min(a2,b3))\n    min_wins = min(min_wins,wins)\n    temp_a2 -= min(a2,b3)\n    temp_b3 -= min(a2,b3)\n    wins = 0\n    wins += max(0, min(a3,b1))\n    min_wins = min(min_wins,wins)\n    temp_a3 -= min(a3,b1)\n    temp_b1 -= min(a3,b1)\n    \n    \n    max_wins = min(a1, b2) + min(a2, b3) + min(a3, b1)\n\n    print(min_wins, max_wins)\n\nsolve()\n```"
}