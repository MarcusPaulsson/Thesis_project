{
    "30": "```python\ndef solve():\n  n = int(input())\n  s = input()\n\n  def calculate_operations(target):\n    count = 0\n    i = 0\n    while i < n:\n      if s[i] != target[i % 2]:\n        count += 1\n        j = i\n        while j < n and s[j] != target[i % 2]:\n          j += 1\n        i = j\n      else:\n        i += 1\n    return count\n\n  print(min(calculate_operations(\"01\"), calculate_operations(\"10\")))\n\nt = int(input())\nfor _ in range(t):\n  solve()\n```",
    "31": "```python\ndef solve():\n  s = input()\n  visited = set()\n  x, y = 0, 0\n  time = 0\n  for move in s:\n    nx, ny = x, y\n    if move == 'N':\n      ny += 1\n    elif move == 'S':\n      ny -= 1\n    elif move == 'W':\n      nx -= 1\n    else:\n      nx += 1\n    \n    segment = tuple(sorted([(x, y), (nx, ny)]))\n    \n    if segment in visited:\n      time += 1\n    else:\n      time += 5\n      visited.add(segment)\n    \n    x, y = nx, ny\n  print(time)\n\nt = int(input())\nfor _ in range(t):\n  solve()\n```",
    "32": "```python\ndef solve():\n    n = int(input())\n    chanek_coins = 0\n    turn = 0\n    while n > 0:\n        if turn == 0:\n            if n % 2 == 0 and n // 2 > 1:\n                chanek_coins += n // 2\n                n -= n // 2\n            else:\n                chanek_coins += 1\n                n -= 1\n        else:\n            if n % 2 == 0 and n // 2 > 1:\n                n -= n // 2\n            else:\n                n -= 1\n        turn = 1 - turn\n    print(chanek_coins)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "33": "```python\ndef solve():\n  n = int(input())\n  \n  current_nums = list(range(1, n + 1))\n  \n  for _ in range(n - 1):\n    a = current_nums[-1]\n    b = current_nums[-2]\n    \n    print(a, b)\n    \n    new_num = (a + b + 1) // 2\n    \n    current_nums = current_nums[:-2]\n    current_nums.append(new_num)\n    \n  print(current_nums[0])\n\nt = int(input())\nfor _ in range(t):\n  solve()\n```",
    "34": "```python\ndef solve():\n  n = int(input())\n  \n  if n % 2 == 0:\n    print(\"1\" * (n // 2))\n  else:\n    print(\"7\" + \"1\" * ((n - 3) // 2))\n\nt = int(input())\nfor _ in range(t):\n  solve()\n```",
    "35": "```python\ndef solve():\n    n = int(input())\n    e = list(map(int, input().split()))\n    e.sort()\n    \n    groups = 0\n    current_group_size = 0\n    \n    for inexperience in e:\n        current_group_size += 1\n        if current_group_size >= inexperience:\n            groups += 1\n            current_group_size = 0\n            \n    print(groups)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "36": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    m = int(input())\n    q = list(map(int, input().split()))\n\n    prefix_sums = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + a[i - 1]\n\n    for query in q:\n        for i in range(1, n + 1):\n            if query <= prefix_sums[i]:\n                print(i)\n                break\n\nsolve()\n```",
    "37": "```python\ndef solve():\n    n, k = map(int, input().split())\n\n    def get_decomposition(p):\n        n = len(p)\n        marked = [False] * n\n        decomposition = []\n\n        for i in range(n):\n            if not marked[i]:\n                reachable = []\n                curr = i\n                while not marked[curr]:\n                    reachable.append(p[curr])\n                    marked[curr] = True\n                    curr = p[curr] - 1\n                \n                max_val = max(reachable)\n                max_index = reachable.index(max_val)\n                \n                shifted_reachable = reachable[max_index:] + reachable[:max_index]\n                decomposition.append(shifted_reachable)\n        \n        return decomposition\n\n    def new_year_transformation(p):\n        decomposition = get_decomposition(p)\n        decomposition.sort(key=lambda x: x[0])\n        \n        result = []\n        for sublist in decomposition:\n            result.extend(sublist)\n        \n        return result\n\n    def is_good(p):\n        return new_year_transformation(p) == p\n\n    def generate_permutations(n):\n        import itertools\n        permutations = []\n        for p in itertools.permutations(range(1, n + 1)):\n            permutations.append(list(p))\n        return permutations\n    \n    good_permutations = []\n    for p in generate_permutations(n):\n        if is_good(p):\n            good_permutations.append(p)\n    \n    good_permutations.sort()\n\n    if len(good_permutations) < k:\n        print(\"-1\")\n    else:\n        print(*good_permutations[k - 1])\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "38": "```python\ndef solve():\n    n, k1, k2 = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    \n    max_a = max(a)\n    max_b = max(b)\n    \n    if max_a > max_b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "39": "```python\ndef solve():\n    a, b, p = map(int, input().split())\n    s = input()\n    n = len(s)\n    \n    cost = 0\n    i = n - 2\n    while i >= 0:\n        j = i\n        while j >= 0 and s[j] == s[i]:\n            j -= 1\n        \n        if s[i] == 'A':\n            cost += a\n        else:\n            cost += b\n            \n        i = j\n        if cost > p:\n            print(i + 2)\n            return\n            \n    print(1)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "40": null,
    "41": "```python\ndef solve():\n    n, k = map(int, input().split())\n    s = list(input())\n\n    def reverse(l, r):\n        s[l-1:r] = s[l-1:r][::-1]\n\n    def is_regular(seq):\n        balance = 0\n        for char in seq:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    def find_operations():\n        operations = []\n        \n        # 1. Create the target string: \"(\"*k + \")\"*(k-1) + \"()\"*(n//2 - k)\n        target = ['('] * k + [')'] * (k - 1) + ['(' , ')'] * (n//2 - k)\n        \n        # 2. Align the string with the target\n        for i in range(n):\n            if s[i] != target[i]:\n                # Find the correct character in the remaining string\n                for j in range(i + 1, n):\n                    if s[j] == target[i]:\n                        operations.append((i + 1, j + 1))\n                        reverse(i + 1, j + 1)\n                        break\n        \n        return operations\n\n    operations = find_operations()\n\n    print(len(operations))\n    for l, r in operations:\n        print(l, r)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "42": "```python\ndef solve():\n    s = input()\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            sub = s[i:j+1]\n            length = j - i + 1\n            try:\n                val = int(sub, 2)\n            except ValueError:\n                val = 0\n            if length == val:\n                count += 1\n    print(count)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "43": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    \n    min_time = float('inf')\n    \n    for i in range(1 << n):\n        delivery_time = 0\n        pickup_time = 0\n        \n        for j in range(n):\n            if (i >> j) & 1:\n                delivery_time = max(delivery_time, a[j])\n            else:\n                pickup_time += b[j]\n        \n        min_time = min(min_time, max(delivery_time, pickup_time))\n    \n    print(min_time)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "44": "```python\ndef solve():\n    n = int(input())\n    result = []\n    start = 2 * 1\n    for i in range(n):\n        result.append(start)\n        start += 2\n    print(*result)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "45": "```python\ndef solve():\n    x = int(input())\n    \n    count = 0\n    total_cells = 0\n    stair_size = 1\n    \n    while True:\n        cells_needed = stair_size * (stair_size + 1) // 2\n        if total_cells + cells_needed <= x:\n            count += 1\n            total_cells += cells_needed\n            stair_size = stair_size * 2 + 1\n        else:\n            break\n            \n    print(count)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "46": "```python\ndef solve():\n    s = input()\n    n = len(s)\n    \n    r_count = s.count('R')\n    s_count = s.count('S')\n    p_count = s.count('P')\n    \n    if r_count >= s_count and r_count >= p_count:\n        print('P' * n)\n    elif s_count >= r_count and s_count >= p_count:\n        print('R' * n)\n    else:\n        print('S' * n)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "47": "```python\ndef solve():\n    n, q = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    def calculate_max_strength(arr):\n        if not arr:\n            return 0\n        \n        max_strength = 0\n        for i in range(1 << len(arr)):\n            subsequence = []\n            for j in range(len(arr)):\n                if (i >> j) & 1:\n                    subsequence.append(arr[j])\n            \n            if not subsequence:\n                continue\n            \n            strength = 0\n            for k in range(len(subsequence)):\n                if (k % 2) == 0:\n                    strength += subsequence[k]\n                else:\n                    strength -= subsequence[k]\n            \n            max_strength = max(max_strength, strength)\n        return max_strength\n\n    print(calculate_max_strength(a))\n\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "48": "```python\ndef solve():\n    x, y, k = map(int, input().split())\n    \n    # Need k coal, so need k * y sticks\n    sticks_needed_for_coal = k * y\n    \n    # Need k sticks for torches\n    total_sticks_needed = sticks_needed_for_coal + k\n    \n    # We start with 1 stick.  How many stick trades do we need?\n    trades_for_sticks = (total_sticks_needed - 1 + (x - 2)) // (x - 1)\n    \n    print(trades_for_sticks + k)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "49": "```python\ndef solve():\n    def count_classy(n):\n        s = str(n)\n        length = len(s)\n        \n        dp = {}\n        \n        def recurse(idx, non_zero_count, is_tight):\n            if idx == length:\n                return 1\n            \n            if (idx, non_zero_count, is_tight) in dp:\n                return dp[(idx, non_zero_count, is_tight)]\n            \n            ans = 0\n            \n            upper_bound = int(s[idx]) if is_tight else 9\n            \n            for digit in range(upper_bound + 1):\n                new_non_zero_count = non_zero_count + (digit != 0)\n                \n                if new_non_zero_count <= 3:\n                    new_is_tight = is_tight and (digit == int(s[idx]))\n                    ans += recurse(idx + 1, new_non_zero_count, new_is_tight)\n            \n            dp[(idx, non_zero_count, is_tight)] = ans\n            return ans\n        \n        return recurse(0, 0, True)\n    \n    t = int(input())\n    for _ in range(t):\n        l, r = map(int, input().split())\n        print(count_classy(r) - count_classy(l - 1))\n\nsolve()\n```",
    "50": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    ans = float('inf')\n    \n    for i in range(2 * n + 1):\n        for j in range(i + 1):\n            left = j\n            right = i - j\n            \n            if left > n or right > n:\n                continue\n            \n            temp_a = a[:]\n            \n            for k in range(left):\n                temp_a[n-1-k] = -1\n            \n            for k in range(right):\n                temp_a[n+k] = -1\n                \n            strawberries = 0\n            blueberries = 0\n            \n            for k in range(2 * n):\n                if temp_a[k] != -1:\n                    if temp_a[k] == 1:\n                        strawberries += 1\n                    else:\n                        blueberries += 1\n            \n            if strawberries == blueberries:\n                ans = min(ans, i)\n    \n    print(ans)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "51": "```python\ndef solve():\n    n, k, d1, d2 = map(int, input().split())\n\n    def check(x, y, z):\n        if x < 0 or y < 0 or z < 0:\n            return False\n        if x + y + z > k:\n            return False\n        \n        mx = max(x, y, z)\n        rem = n // 3 * 3 - k\n\n        if rem < 0:\n            return False\n        \n        if (rem % 3 != 0):\n          return False\n\n        if mx * 3 > n:\n          return False\n          \n        \n        return True\n\n    possible = False\n    for s1 in [-1, 1]:\n        for s2 in [-1, 1]:\n            x = (d1 * s1 + d2 * s1 * s2)\n            if x % 3 != 0:\n                continue\n            x //= 3\n            y = d1 * s1 + x\n            z = d2 * s2 + y\n            \n            if check(x, y, z):\n                possible = True\n                break\n        if possible:\n            break\n    \n    if possible:\n        print(\"yes\")\n    else:\n        print(\"no\")\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "52": null,
    "53": "```python\ndef solve():\n    n, s = input().split()\n    n = int(n)\n\n    def generate_min_lis(n, s):\n        arr = [0] * n\n        curr = 1\n        for i in range(n):\n            if i == 0 or s[i-1] == '>':\n                j = i\n                while j < n - 1 and s[j] == '<':\n                    j += 1\n                for k in range(j, i - 1, -1):\n                    arr[k] = curr\n                    curr += 1\n        return arr\n\n    def generate_max_lis(n, s):\n        arr = [0] * n\n        curr = 1\n        for i in range(n):\n            if i == 0 or s[i-1] == '<':\n                j = i\n                while j < n - 1 and s[j] == '>':\n                    j += 1\n                for k in range(j, i - 1, -1):\n                    arr[k] = curr\n                    curr += 1\n        return arr\n\n    min_arr = generate_min_lis(n, s)\n    max_arr = generate_max_lis(n, s)\n\n    print(*min_arr)\n    print(*max_arr)\n\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "54": "```python\ndef solve():\n    n = int(input())\n    s = list(map(int, input().split()))\n\n    total_sum = 0\n    for x in s:\n        if x <= 2048:\n            total_sum += x\n\n    if total_sum >= 2048:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nq = int(input())\nfor _ in range(q):\n    solve()\n```",
    "55": "```python\ndef solve():\n  n = int(input())\n  print((n + 1) // 2)\n\nt = int(input())\nfor _ in range(t):\n  solve()\n```",
    "56": "```python\ndef solve():\n    n, k = map(int, input().split())\n    \n    grid = [['0'] * n for _ in range(n)]\n    \n    row = 0\n    col = 0\n    \n    for _ in range(k):\n        grid[row][col] = '1'\n        row = (row + 1) % n\n        col = (col + 1) % n\n        if row == 0:\n            col = (col + 1) % n\n\n    rows_sums = [0] * n\n    cols_sums = [0] * n\n    \n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == '1':\n                rows_sums[i] += 1\n                cols_sums[j] += 1\n    \n    f_a = (max(rows_sums) - min(rows_sums))**2 + (max(cols_sums) - min(cols_sums))**2\n    \n    print(f_a)\n    for row in grid:\n        print(\"\".join(row))\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "57": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    def can_reduce(arr):\n        if len(arr) == 1:\n            return True\n        \n        for i in range(len(arr) - 1):\n            if arr[i] < arr[i+1]:\n                # Try removing arr[i]\n                new_arr1 = arr[:i] + arr[i+1:]\n                if can_reduce(new_arr1):\n                    return True\n                \n                # Try removing arr[i+1]\n                new_arr2 = arr[:i+1] + arr[i+2:]\n                if can_reduce(new_arr2):\n                    return True\n        \n        return False\n\n    if can_reduce(a):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "58": "```python\ndef solve():\n    n, m, k = map(int, input().split())\n    \n    dp = {}\n    \n    def calculate_cost(rows, cols, target_squares):\n        if (rows, cols, target_squares) in dp:\n            return dp[(rows, cols, target_squares)]\n        \n        if target_squares == 0:\n            return 0\n        \n        if rows * cols == target_squares:\n            return 0\n            \n        if rows * cols < target_squares:\n            return float('inf')\n        \n        if rows == 0 or cols == 0:\n            return float('inf')\n            \n        if target_squares < 0:\n            return float('inf')\n\n        min_cost = float('inf')\n        \n        # Horizontal cuts\n        for i in range(1, rows):\n            for j in range(target_squares + 1):\n                cost = cols * cols + calculate_cost(i, cols, j) + calculate_cost(rows - i, cols, target_squares - j)\n                min_cost = min(min_cost, cost)\n        \n        # Vertical cuts\n        for i in range(1, cols):\n            for j in range(target_squares + 1):\n                cost = rows * rows + calculate_cost(rows, i, j) + calculate_cost(rows, cols - i, target_squares - j)\n                min_cost = min(min_cost, cost)\n        \n        dp[(rows, cols, target_squares)] = min_cost\n        return min_cost\n    \n    result = calculate_cost(n, m, k)\n    print(result)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "59": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    bounds = []\n    for i in range(n):\n        if a[i] == -1:\n            if i > 0 and a[i-1] != -1:\n                bounds.append(a[i-1])\n            if i < n-1 and a[i+1] != -1:\n                bounds.append(a[i+1])\n    \n    if not bounds:\n        print(0, 0)\n        return\n\n    min_val = min(bounds)\n    max_val = max(bounds)\n    \n    k = (min_val + max_val) // 2\n    \n    \n    def calculate_m(arr, k_val):\n        new_arr = [k_val if x == -1 else x for x in arr]\n        m = 0\n        for i in range(n - 1):\n            m = max(m, abs(new_arr[i] - new_arr[i+1]))\n        return m\n    \n    m = calculate_m(a,k)\n    \n    print(m, k)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "60": "```python\ndef solve():\n    a, b = map(int, input().split())\n    print(a ^ b)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "61": "```python\ndef solve():\n    n = int(input())\n    p = list(map(int, input().split()))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if p[i] < p[j] and p[j] > p[k]:\n                    print(\"YES\")\n                    print(i + 1, j + 1, k + 1)\n                    return\n\n    print(\"NO\")\n\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "62": "```python\ndef solve():\n    s = input()\n    adj = {}\n    for i in range(len(s) - 1):\n        a, b = s[i], s[i+1]\n        if a not in adj:\n            adj[a] = set()\n        if b not in adj:\n            adj[b] = set()\n        adj[a].add(b)\n        adj[b].add(a)\n    \n    for char in adj:\n        if len(adj[char]) > 2:\n            print(\"NO\")\n            return\n    \n    starts = []\n    for char in \"abcdefghijklmnopqrstuvwxyz\":\n        if char in adj and len(adj[char]) <= 1:\n            starts.append(char)\n        elif char not in adj:\n            starts.append(char)\n    \n    if not starts:\n        print(\"NO\")\n        return\n    \n    visited = set()\n    layout = \"\"\n    \n    for start in starts:\n        if start not in visited:\n            curr = start\n            while curr is not None:\n                if curr in visited:\n                    print(\"NO\")\n                    return\n                visited.add(curr)\n                layout += curr\n                \n                next_char = None\n                if curr in adj:\n                    for neighbor in adj[curr]:\n                        if neighbor not in visited:\n                            next_char = neighbor\n                            break\n                curr = next_char\n    \n    if len(layout) != 26:\n        for char in \"abcdefghijklmnopqrstuvwxyz\":\n            if char not in layout:\n                layout += char\n    \n    if len(layout) != 26:\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    print(layout)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "63": "```python\ndef solve():\n  n, k = map(int, input().split())\n  a = list(map(int, input().split()))\n  w = list(map(int, input().split()))\n\n  a.sort()\n  w.sort()\n\n  happiness = 0\n  \n  # Assign largest elements to friends with w_i = 1\n  l = n - 1\n  for i in range(k):\n    if w[i] == 1:\n      happiness += 2 * a[l]\n      l -= 1\n\n  # Assign remaining elements\n  r = 0\n  for i in range(k - 1, -1, -1):\n    if w[i] > 1:\n      happiness += a[l] + a[r]\n      l -= 1\n      r += w[i] - 1\n\n  print(happiness)\n\nt = int(input())\nfor _ in range(t):\n  solve()\n```",
    "64": "```python\ndef solve():\n    n, l = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    flags1 = [0] + a\n    flags2 = a + [l]\n\n    pos1 = 0\n    pos2 = l\n    speed1 = 1\n    speed2 = 1\n    time = 0\n\n    idx1 = 0\n    idx2 = n\n\n    while True:\n        time_to_next_flag1 = float('inf')\n        if idx1 <= n:\n            time_to_next_flag1 = (flags1[idx1] - pos1) / speed1\n        \n        time_to_next_flag2 = float('inf')\n        if idx2 >= 0:\n            time_to_next_flag2 = (pos2 - flags2[idx2]) / speed2\n\n        time_to_meet = (pos2 - pos1) / (speed1 + speed2)\n\n        if time_to_meet <= time_to_next_flag1 and time_to_meet <= time_to_next_flag2:\n            time += time_to_meet\n            print(time)\n            return\n        elif time_to_next_flag1 <= time_to_next_flag2:\n            time += time_to_next_flag1\n            pos1 += time_to_next_flag1 * speed1\n            pos2 -= time_to_next_flag1 * speed2\n            speed1 += 1\n            idx1 += 1\n        else:\n            time += time_to_next_flag2\n            pos1 += time_to_next_flag2 * speed1\n            pos2 -= time_to_next_flag2 * speed2\n            speed2 += 1\n            idx2 -= 1\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "65": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    dp = {}\n    \n    def calculate_min_skips(index, turn):\n        if index == n:\n            return 0\n        \n        if (index, turn) in dp:\n            return dp[(index, turn)]\n        \n        if turn == 0: \n            \n            ans = float('inf')\n            \n            skips1 = a[index]\n            ans = min(ans, skips1 + calculate_min_skips(index + 1, 1))\n            \n            if index + 1 < n:\n                skips2 = a[index] + a[index+1]\n                ans = min(ans, skips2 + calculate_min_skips(index + 2, 1))\n            \n            dp[(index, turn)] = ans\n            return ans\n        else: \n            ans = float('inf')\n            \n            ans = min(ans, calculate_min_skips(index + 1, 0))\n            \n            if index + 1 < n:\n                ans = min(ans, calculate_min_skips(index + 2, 0))\n            \n            dp[(index, turn)] = ans\n            return ans\n        \n    print(calculate_min_skips(0, 0))\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "66": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    print(*a)\n    print(*sorted(b))\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "67": "```python\ndef solve():\n    n = int(input())\n    s = list(input())\n    t = list(input())\n\n    ops = []\n    for _ in range(2 * n):\n        if s == t:\n            break\n\n        found = False\n        for i in range(n):\n            if s[i] != t[i]:\n                for j in range(n):\n                    if s[i] == t[j]:\n                        ops.append((i + 1, j + 1))\n                        s[i], t[j] = t[j], s[i]\n                        found = True\n                        break\n                if found:\n                    break\n                \n                for j in range(n):\n                    if t[i] == s[j]:\n                        ops.append((j + 1, i + 1))\n                        s[j], t[i] = t[i], s[j]\n                        found = True\n                        break\n                if found:\n                    break\n        \n        if not found:\n            break\n    \n    if s == t:\n        print(\"Yes\")\n        print(len(ops))\n        for i, j in ops:\n            print(i, j)\n    else:\n        print(\"No\")\n\nk = int(input())\nfor _ in range(k):\n    solve()\n```",
    "68": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    \n    def calculate_operations(string):\n        operations = 0\n        while string:\n            operations += 1\n            \n            best_string = \"\"\n            \n            for i in range(len(string)):\n                temp_string = list(string)\n                del temp_string[i]\n                temp_string = \"\".join(temp_string)\n                \n                if temp_string:\n                    first_char = temp_string[0]\n                    prefix_length = 0\n                    for j in range(len(temp_string)):\n                        if temp_string[j] == first_char:\n                            prefix_length += 1\n                        else:\n                            break\n                    temp_string = temp_string[prefix_length:]\n                \n                if not best_string or len(temp_string) > len(best_string):\n                    best_string = temp_string\n            \n            string = best_string\n        return operations\n    \n    print(calculate_operations(s))\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "69": "```python\ndef solve():\n    a, b = map(int, input().split())\n    s = input()\n    n = len(s)\n    \n    gaps = []\n    start = -1\n    end = -1\n    \n    first_one = -1\n    last_one = -1\n    \n    for i in range(n):\n        if s[i] == '1':\n            if first_one == -1:\n                first_one = i\n            last_one = i\n    \n    if first_one == -1:\n        print(0)\n        return\n\n    \n    start = first_one\n    end = last_one\n    \n    \n    count = 0\n    \n    i = start\n    while i <= end:\n        if s[i] == '0':\n            j = i\n            while j <= end and s[j] == '0':\n                j += 1\n            gaps.append(j - i)\n            i = j\n        else:\n            i += 1\n    \n    cost = a\n    \n    for gap in gaps:\n        if gap * b < a:\n            cost += gap * b\n        else:\n            cost += a\n            \n    print(cost)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "70": "```python\ndef solve():\n    n, k = map(int, input().split())\n    s = input()\n    \n    ans = 0\n    for i in range(k // 2):\n        counts = {}\n        for j in range(0, n, k):\n            c1 = s[i+j]\n            c2 = s[k - 1 - i + j]\n            counts[c1] = counts.get(c1, 0) + 1\n            counts[c2] = counts.get(c2, 0) + 1\n        \n        max_count = 0\n        total = 0\n        for c in counts:\n            max_count = max(max_count, counts[c])\n            total += counts[c]\n        \n        ans += (total - max_count)\n    \n    if k % 2 == 1:\n        counts = {}\n        for j in range(0, n, k):\n            c = s[k // 2 + j]\n            counts[c] = counts.get(c, 0) + 1\n        \n        max_count = 0\n        total = 0\n        for c in counts:\n            max_count = max(max_count, counts[c])\n            total += counts[c]\n        \n        ans += (total - max_count)\n    \n    print(ans)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "71": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    coins = 0\n    balance = 0\n    for i in range(n):\n        balance += a[i]\n        if balance < 0:\n            coins += abs(balance)\n    print(coins)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "72": "```python\ndef solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    unique_elements = sorted(list(set(a)))\n    \n    if len(unique_elements) > k:\n        print(-1)\n        return\n    \n    while len(unique_elements) < k:\n        unique_elements.append(1)\n    \n    beautiful_array = unique_elements * n\n    \n    print(len(beautiful_array))\n    print(*beautiful_array)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "73": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    ops = []\n    \n    def get_mex(arr):\n        seen = set(arr)\n        for i in range(n + 1):\n            if i not in seen:\n                return i\n        return n + 1 \n    \n    for _ in range(2 * n):\n        \n        is_sorted = all(a[i] <= a[i+1] for i in range(n-1))\n        if is_sorted:\n            break\n        \n        mex = get_mex(a)\n        \n        if mex < n:\n            \n            for i in range(n):\n                if a[i] != i:\n                    a[i] = mex\n                    ops.append(i + 1)\n                    break\n        else:\n            for i in range(n -1, -1, -1):\n                if not all(a[j] <= a[j+1] for j in range(n-1)):\n                    \n                    for k in range(n-1):\n                        if a[k] > a[k+1]:\n                            a[k] = mex\n                            ops.append(k+1)\n                            break\n                    break\n            \n    print(len(ops))\n    print(*ops)\n    \n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "74": "```python\ndef solve():\n    n, k = map(int, input().split())\n    minions = []\n    for _ in range(n):\n        minions.append(list(map(int, input().split())))\n\n    best_actions = []\n    max_power = -1\n\n    def calculate_power(current_minions):\n        total_power = 0\n        for power in current_minions:\n            total_power += power\n        return total_power\n\n    def find_best_actions(available_minions, current_army, actions_taken):\n        nonlocal best_actions, max_power\n\n        current_power = calculate_power(current_army.values())\n\n        if current_power > max_power:\n            max_power = current_power\n            best_actions = actions_taken[:]\n\n        if not available_minions:\n            return\n\n        for i in range(len(available_minions)):\n            minion_index = available_minions[i]\n            a, b = minions[minion_index]\n\n            # Option 1: Summon the minion\n            if len(current_army) < k:\n                new_army = current_army.copy()\n                \n                # Calculate the power of the current minion\n                minion_power = a\n                \n                # Increase the power of existing minions\n                for index in new_army:\n                    new_army[index] += b\n\n                new_army[minion_index] = minion_power\n                \n                \n                new_available_minions = available_minions[:i] + available_minions[i+1:]\n                new_actions_taken = actions_taken + [minion_index + 1]\n                \n                find_best_actions(new_available_minions, new_army, new_actions_taken)\n\n                # Option 2: Summon and then destroy the minion\n                \n                new_army_destroy = current_army.copy()\n                \n                # Calculate the power of the current minion\n                minion_power_destroy = a\n                \n                # Increase the power of existing minions\n                for index in new_army_destroy:\n                    new_army_destroy[index] += b\n\n                \n                \n                \n                if len(new_army_destroy) < k:\n                    new_army_destroy[minion_index] = minion_power_destroy\n                    new_army_destroy.pop(minion_index)\n                else:\n                    \n                    new_army_destroy[minion_index] = minion_power_destroy\n\n                    new_available_minions_destroy = available_minions[:i] + available_minions[i+1:]\n                    new_actions_taken_destroy = actions_taken + [minion_index + 1, -(minion_index + 1)]\n\n                    new_army_destroy.pop(minion_index)\n                \n                \n                    find_best_actions(new_available_minions_destroy, new_army_destroy, new_actions_taken_destroy)\n                else:\n                    new_army_destroy.pop(minion_index, None)\n                    \n                    new_available_minions_destroy = available_minions[:i] + available_minions[i+1:]\n                    new_actions_taken_destroy = actions_taken + [minion_index + 1, -(minion_index + 1)]\n                    \n                    if minion_index in current_army:\n                        find_best_actions(new_available_minions_destroy, current_army, new_actions_taken_destroy)\n                    else:\n                        find_best_actions(new_available_minions_destroy, current_army, new_actions_taken_destroy)\n\n    find_best_actions(list(range(n)), {}, [])\n\n    print(len(best_actions))\n    print(*best_actions)\n\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "75": null,
    "76": "```python\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        if n % 4 == 0:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nsolve()\n```",
    "77": "```python\ndef solve():\n    n = int(input())\n    boards = []\n    for _ in range(n):\n        boards.append(list(map(int, input().split())))\n\n    dp = [[float('inf')] * 3 for _ in range(n)]\n    dp[0][0] = 0\n    dp[0][1] = boards[0][1]\n    dp[0][2] = 2 * boards[0][1]\n\n    for i in range(1, n):\n        for j in range(3):\n            for k in range(3):\n                if boards[i-1][0] + k != boards[i][0] + j:\n                    dp[i][j] = min(dp[i][j], dp[i-1][k] + j * boards[i][1])\n    \n    print(min(dp[n-1]))\n\nq = int(input())\nfor _ in range(q):\n    solve()\n```",
    "78": "```python\ndef solve():\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n)]\n    \n    ans = float('inf')\n    \n    for r in range(n):\n        for c in range(m):\n            cost = 0\n            \n            # Cost to make row r black\n            for j in range(m):\n                if grid[r][j] == '.':\n                    cost += 1\n            \n            # Cost to make col c black\n            for i in range(n):\n                if grid[i][c] == '.':\n                    cost += 1\n            \n            # Subtract 1 if we double-counted the cell (r, c)\n            if grid[r][c] == '*':\n                cost -= 1\n            \n            ans = min(ans, cost)\n            \n    print(ans)\n\nq = int(input())\nfor _ in range(q):\n    solve()\n```",
    "79": "```python\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef solve():\n    n = int(input())\n    divisors = []\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    divisors.append(n)\n    divisors.sort()\n\n    import itertools\n    \n    best_order = None\n    min_moves = float('inf')\n\n    for order in itertools.permutations(divisors):\n        moves = 0\n        is_valid = True\n        for i in range(len(order)):\n            if gcd(order[i], order[(i+1) % len(order)]) == 1:\n                is_valid = False\n                break\n        \n        if is_valid:\n            if moves < min_moves:\n                min_moves = moves\n                best_order = list(order)\n        else:\n            \n            current_order = list(order)\n            current_moves = 0\n            \n            temp_order = current_order[:]\n            \n            while True:\n                is_coprime_found = False\n                new_order = []\n                for i in range(len(temp_order)):\n                    new_order.append(temp_order[i])\n                    if gcd(temp_order[i], temp_order[(i+1) % len(temp_order)]) == 1:\n                        lcm = (temp_order[i] * temp_order[(i+1) % len(temp_order)]) // gcd(temp_order[i], temp_order[(i+1) % len(temp_order)])\n                        new_order.append(lcm)\n                        current_moves += 1\n                        is_coprime_found = True\n                temp_order = new_order[:]\n                if not is_coprime_found:\n                    break\n            \n            \n            is_valid_after_moves = True\n            for i in range(len(temp_order)):\n                if gcd(temp_order[i], temp_order[(i+1) % len(temp_order)]) == 1:\n                    is_valid_after_moves = False\n                    break\n                    \n            if is_valid_after_moves:\n                if current_moves < min_moves:\n                    min_moves = current_moves\n                    best_order = list(order)\n            \n\n    print(*best_order)\n    print(min_moves)\n\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "80": "```python\ndef solve():\n    l, r = map(int, input().split())\n    count = 0\n    \n    range_size = r - l + 1\n    count = range_size * (range_size - 1) // 2\n\n    num_zeros_below_l = l\n\n    for a in range(l, r + 1):\n        if a == 0 :\n            count += 1\n            continue\n        \n        \n        \n        first_zero_greater_equal_l = l\n        if l > 0:\n           first_zero_greater_equal_l = 0\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n            \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n        \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n        \n        \n        if a & (a - 1) == 0:\n            \n            \n            \n            \n            pass\n        else:\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            pass\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n            \n        \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n",
    "81": null,
    "82": "```python\ndef solve():\n  n = int(input())\n  p = list(map(int, input().split()))\n  \n  if n == 2:\n    print(p[1], p[0])\n    return\n  \n  print(*p[::-1])\n\nt = int(input())\nfor _ in range(t):\n  solve()\n```",
    "83": "```python\ndef solve():\n  x, y, a, b = map(int, input().split())\n  \n  if a + b == 0:\n    if x != y:\n      print(\"-1\")\n    else:\n      print(\"0\")\n    return\n  \n  if (y - x) % (a + b) == 0:\n    print((y - x) // (a + b))\n  else:\n    print(\"-1\")\n\nt = int(input())\nfor _ in range(t):\n  solve()\n```",
    "84": null,
    "85": "```python\ndef solve():\n    s = input()\n    x = int(input())\n    n = len(s)\n    w = [''] * n\n    \n    for i in range(n):\n        w[i] = '1'\n    \n    for i in range(n):\n        if s[i] == '0':\n            if i - x >= 0:\n                w[i - x] = '0'\n            if i + x < n:\n                w[i + x] = '0'\n    \n    w_str = \"\".join(w)\n    \n    s_reconstructed = [''] * n\n    for i in range(n):\n        s_reconstructed[i] = '0'\n        if i - x >= 0 and w_str[i - x] == '1':\n            s_reconstructed[i] = '1'\n        if i + x < n and w_str[i + x] == '1':\n            s_reconstructed[i] = '1'\n    \n    s_reconstructed_str = \"\".join(s_reconstructed)\n    \n    if s_reconstructed_str == s:\n        print(w_str)\n    else:\n        print(\"-1\")\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "86": "```python\ndef solve():\n  n = int(input())\n  a = list(map(int, input().split()))\n\n  ones = a.count(1)\n  zeros = a.count(0)\n\n  if ones <= n // 2:\n    print(zeros)\n    print(*([0] * zeros))\n  else:\n    if ones % 2 == 0:\n      print(ones)\n      print(*([1] * ones))\n    else:\n      print(ones - 1)\n      print(*([1] * (ones - 1)))\n\nt = int(input())\nfor _ in range(t):\n  solve()\n```",
    "87": "```python\nimport math\n\ndef gcd(a, b):\n  if b == 0:\n    return a\n  return gcd(b, a % b)\n\ndef solve():\n  m, d, w = map(int, input().split())\n  \n  w = w // gcd(d - 1, w)\n  \n  mn = min(m, d)\n  \n  k = mn // w\n  \n  ans = mn * k - w * (k * (k + 1) // 2)\n  \n  print(ans)\n\nt = int(input())\nfor _ in range(t):\n  solve()\n```",
    "88": "```python\ndef solve():\n    t = int(input())\n    x = list(map(int, input().split()))\n    \n    for target in x:\n        if target >= 14 and (target - 14) % 7 == 0:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nsolve()\n```",
    "89": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    def calculate_height(parents):\n        depth = {}\n        depth[1] = 0\n        for i in range(2, n + 1):\n            depth[i] = -1\n\n        for i in range(2, n + 1):\n            curr = i\n            d = 0\n            while curr != 1:\n                curr = parents[curr]\n                d += 1\n            depth[i] = d\n\n        max_depth = 0\n        for i in range(1, n + 1):\n            max_depth = max(max_depth, depth[i])\n        return max_depth\n\n    def find_min_height():\n        min_height = float('inf')\n        \n        def check_tree(parents):\n            \n            adj = [[] for _ in range(n + 1)]\n            for i in range(2, n + 1):\n                adj[parents[i]].append(i)\n                \n            for i in range(1, n + 1):\n                adj[i].sort()\n                \n            bfs_order = []\n            q = [1]\n            visited = {1}\n            \n            while q:\n                u = q.pop(0)\n                bfs_order.append(u)\n                \n                for v in adj[u]:\n                    if v not in visited:\n                        q.append(v)\n                        visited.add(v)\n            \n            bfs_order_check = [a[i] for i in range(n)]\n           \n            if bfs_order == bfs_order_check:\n                return True\n            else:\n                return False\n\n        def generate_trees():\n            \n            import itertools\n            \n            possible_parents = {}\n            for i in range(2, n + 1):\n                possible_parents[i] = []\n                \n            \n            \n            level_start_indices = [0]\n            curr_level_start = 1\n            \n            while curr_level_start < n:\n                \n                next_level_start = curr_level_start + 1\n                \n                \n                while next_level_start < n and len([x for x in possible_parents.keys() if x == a[next_level_start]]) == 0:\n                   \n                    next_level_start +=1\n                \n                level_start_indices.append(curr_level_start)\n                curr_level_start = next_level_start\n                \n            \n            \n            level_start_indices.append(n)\n            \n            \n            for i in range(1, n + 1):\n                possible_parents[i] = []\n                \n            \n            \n            for i in range(1, len(level_start_indices)):\n                \n                start_index = level_start_indices[i - 1]\n                end_index = level_start_indices[i]\n                \n                for j in range(start_index, end_index):\n                    node = a[j]\n                    \n                    for k in range(level_start_indices[i - 1] -1 , level_start_indices[i-2] -1, -1):\n                        possible_parents[node].append(a[k])\n                \n        \n            \n            \n            \n            possible_parent_lists = [possible_parents[i] for i in range(2, n + 1)]\n            \n            \n            \n            for parent_combination in itertools.product(*possible_parent_lists):\n                \n                parents = {}\n                for i in range(2, n + 1):\n                    parents[i] = parent_combination[i - 2]\n                    \n                if check_tree(parents):\n                    height = calculate_height(parents)\n                    nonlocal min_height\n                    min_height = min(min_height, height)\n            \n        \n        \n        parents = {}\n        for i in range(2, n + 1):\n            parents[i] = 1\n        \n        \n        \n        \n        \n        \n        \n        level_start_indices = [0]\n        curr_level_start = 1\n        \n        while curr_level_start < n:\n            \n            next_level_start = curr_level_start + 1\n                \n            while next_level_start < n and (a[next_level_start] not in [x for x in range(1,n+1)]):\n                next_level_start +=1\n            \n            level_start_indices.append(curr_level_start)\n            curr_level_start = next_level_start\n            \n        level_start_indices.append(n)\n        \n        \n        \n        \n        \n        parents = {}\n        for i in range(2,n+1):\n            parents[a[i]] = 1\n        \n        \n        \n        \n        \n        height_initial = calculate_height(parents)\n        \n        \n        \n        \n        \n        \n        import itertools\n        \n        possible_parents = {}\n        for i in range(2, n + 1):\n            possible_parents[i] = []\n                \n            \n            \n        level_start_indices = [0]\n        curr_level_start = 1\n            \n        while curr_level_start < n:\n            \n            next_level_start = curr_level_start + 1\n                \n            while next_level_start < n and (a[next_level_start] not in [x for x in range(1,n+1)]):\n                next_level_start +=1\n                \n            level_start_indices.append(curr_level_start)\n            curr_level_start = next_level_start\n                \n        \n        level_start_indices.append(n)\n            \n            \n            \n        for i in range(1, n + 1):\n            possible_parents[i] = []\n                \n            \n            \n        for i in range(1, len(level_start_indices)):\n                \n            start_index = level_start_indices[i - 1]\n            end_index = level_start_indices[i]\n                \n            for j in range(start_index, end_index):\n                node = a[j]\n                    \n                \n                for k in range(level_start_indices[i - 1] - 1, level_start_indices[i-2] - 1, -1):\n                    possible_parents[node].append(a[k])\n                \n            \n        \n            \n        \n        possible_parent_lists = [possible_parents[i] for i in range(2, n + 1)]\n            \n        \n            \n        for parent_combination in itertools.product(*possible_parent_lists):\n                \n            parents = {}\n            for i in range(2, n + 1):\n                parents[i] = parent_combination[i - 2]\n                    \n            if check_tree(parents):\n                height = calculate_height(parents)\n                \n                min_height = min(min_height, height)\n        \n        \n        return min_height\n\n    print(find_min_height())\n\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "90": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n\n    unlocked_values = []\n    for i in range(n):\n        if l[i] == 0:\n            unlocked_values.append(a[i])\n\n    unlocked_values.sort()\n\n    unlocked_index = 0\n    result = []\n    for i in range(n):\n        if l[i] == 1:\n            result.append(a[i])\n        else:\n            result.append(unlocked_values[unlocked_index])\n            unlocked_index += 1\n\n    print(*result)\n\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "91": null,
    "92": "```python\ndef solve():\n    s = input()\n    t = input()\n    n = len(s)\n    \n    def can_transform(s, t):\n        if s == t:\n            return True\n        \n        q = [(s, [])]\n        visited = {s}\n        \n        while q:\n            curr_s, path = q.pop(0)\n            \n            if curr_s == t:\n                return True\n            \n            for i in range(n - 1):\n                new_s1 = list(curr_s)\n                new_s1[i+1] = new_s1[i]\n                new_s1 = \"\".join(new_s1)\n                \n                if new_s1 not in visited:\n                    q.append((new_s1, path + [(i, i+1)]))\n                    visited.add(new_s1)\n                    \n                new_s2 = list(curr_s)\n                new_s2[i] = new_s2[i+1]\n                new_s2 = \"\".join(new_s2)\n                \n                if new_s2 not in visited:\n                    q.append((new_s2, path + [(i+1, i)]))\n                    visited.add(new_s2)\n        \n        return False\n\n    \n    s_chars = set(s)\n    t_chars = set(t)\n    \n    if any(c in s_chars for c in t_chars):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nq = int(input())\nfor _ in range(q):\n    solve()\n```",
    "93": null,
    "94": "```python\ndef solve():\n    n, T = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    colors = [0] * n\n    current_color = 0\n    \n    for i in range(n):\n        if a[i] * 2 < T:\n            colors[i] = 0\n        elif a[i] * 2 > T:\n            colors[i] = 1\n        else:\n            colors[i] = current_color\n            current_color = 1 - current_color\n            \n    print(*colors)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "95": "```python\ndef solve():\n  n = int(input())\n  if n == 1:\n    print(\"-1\")\n  else:\n    s = \"\"\n    for _ in range(n):\n      s += \"2\"\n    print(s)\n\nt = int(input())\nfor _ in range(t):\n  solve()\n```",
    "96": "```python\ndef solve():\n    n, T, a, b = map(int, input().split())\n    types = list(map(int, input().split()))\n    times = list(map(int, input().split()))\n    \n    problems = []\n    for i in range(n):\n        problems.append((times[i], types[i]))\n    \n    problems.sort()\n    \n    max_solved = 0\n    \n    for leave_time in range(T + 1):\n        solved_count = 0\n        possible = True\n        \n        solved_indices = []\n        \n        for i in range(n):\n            if problems[i][0] <= leave_time:\n                solved_indices.append(i)\n        \n        \n        \n        for i in range(n):\n            if problems[i][0] <= leave_time:\n                pass\n            else:\n                continue\n            \n        \n        \n        for i in range(1 << n):\n            current_solved_count = 0\n            current_time = 0\n            current_solved_indices = []\n            \n            for j in range(n):\n                if (i >> j) & 1:\n                    current_solved_indices.append(j)\n            \n            valid_solution = True\n            \n            \n            mandatory_solved = True\n            for j in range(n):\n                if problems[j][0] <= leave_time:\n                    if j not in current_solved_indices:\n                         mandatory_solved = False\n                         break\n            \n            \n            if not mandatory_solved:\n                continue\n            \n            \n            \n            \n            \n            current_solved_count = len(current_solved_indices)\n            \n            for j in range(len(current_solved_indices)):\n                problem_index = current_solved_indices[j]\n                \n                if problems[problem_index][1] == 0:\n                    current_time += a\n                else:\n                    current_time += b\n                    \n                if current_time > leave_time:\n                    valid_solution = False\n                    break\n            \n            if valid_solution:\n                max_solved = max(max_solved, current_solved_count)\n\n    print(max_solved)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "97": "```python\ndef solve():\n    s, c = input().split()\n    n = len(s)\n\n    if s < c:\n        print(s)\n        return\n\n    best_s = None\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            temp_s = list(s)\n            temp_s[i], temp_s[j] = temp_s[j], temp_s[i]\n            temp_s = \"\".join(temp_s)\n            \n            if temp_s < c:\n                if best_s is None or temp_s < best_s:\n                    best_s = temp_s\n    \n    if best_s is not None:\n        print(best_s)\n    else:\n        print(\"---\")\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "98": "```python\ndef solve():\n    c, m, x = map(int, input().split())\n    \n    ans = 0\n    \n    low = 0\n    high = min(c, m, x)\n    \n    while low <= high:\n        mid = (low + high) // 2\n        \n        if c - mid >= 0 and m - mid >= 0 and x - mid >= 0:\n            low = mid + 1\n            ans = mid\n        else:\n            high = mid - 1\n            \n    print(ans)\n\nq = int(input())\nfor _ in range(q):\n    solve()\n```",
    "99": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    \n    s_list = list(s)\n    \n    moves = []\n    \n    i = 0\n    while i < len(s_list) - 1:\n        if s_list[i] == '1' and s_list[i+1] == '0':\n            moves.append(i)\n        i += 1\n    \n    while moves:\n        idx = moves.pop(0)\n        \n        \n        temp_s_list1 = s_list[:idx] + s_list[idx+1:]\n        temp_s_list2 = s_list[:idx+1] + s_list[idx+2:]\n                \n        \n        s_list = min(temp_s_list1, temp_s_list2, key=lambda x: (len(x), x))\n        \n        moves = []\n        i = 0\n        while i < len(s_list) - 1:\n            if s_list[i] == '1' and s_list[i+1] == '0':\n                moves.append(i)\n            i += 1\n    \n    print(\"\".join(s_list))\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```"
}