{
    "0": "```python\ndef solve():\n    s = input()\n    n = len(s)\n\n    first_bracket = -1\n    for i in range(n):\n        if s[i] == '[':\n            first_bracket = i\n            break\n\n    if first_bracket == -1:\n        print(-1)\n        return\n\n    last_bracket = -1\n    for i in range(n - 1, -1, -1):\n        if s[i] == ']':\n            last_bracket = i\n            break\n\n    if last_bracket == -1 or last_bracket <= first_bracket:\n        print(-1)\n        return\n\n    first_colon = -1\n    for i in range(first_bracket + 1, last_bracket):\n        if s[i] == ':':\n            first_colon = i\n            break\n\n    if first_colon == -1:\n        print(-1)\n        return\n\n    second_colon = -1\n    for i in range(last_bracket - 1, first_colon, -1):\n        if s[i] == ':':\n            second_colon = i\n            break\n\n    if second_colon == -1 or second_colon <= first_colon:\n        print(-1)\n        return\n\n    count = 0\n    for i in range(first_colon + 1, second_colon):\n        if s[i] == '|':\n            count += 1\n\n    print(4 + count)\n\nsolve()\n```",
    "1": "```python\ndef sum_digits(n):\n    \"\"\"Calculates the sum of the digits of a non-negative integer.\"\"\"\n    s = 0\n    while n:\n        s += n % 10\n        n //= 10\n    return s\n\ndef solve():\n    \"\"\"Finds the integer not exceeding x with the maximum sum of digits.\"\"\"\n    x = int(input())\n    \n    best_num = x\n    best_sum = sum_digits(x)\n    \n    s = str(x)\n    n = len(s)\n    \n    for i in range(n):\n        if s[i] == '0':\n            continue\n        \n        num_str = s[:i] + str(int(s[i]) - 1) + '9' * (n - i - 1)\n        num = int(num_str)\n        \n        if num > 0:\n            current_sum = sum_digits(num)\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_num = num\n            elif current_sum == best_sum and num > best_num:\n                best_num = num\n                \n    print(best_num)\n\nsolve()\n```",
    "2": "```python\ndef solve():\n    n = int(input())\n    s = str(n)\n    l = len(s)\n    first_digit = int(s[0])\n    \n    next_lucky = (first_digit + 1) * (10**(l-1))\n    \n    print(next_lucky - n)\n\nsolve()\n```",
    "6": "```python\ndef solve():\n    n, x = map(int, input().split())\n    blows = []\n    for _ in range(n):\n        blows.append(list(map(int, input().split())))\n\n    max_damage = 0\n    for d, h in blows:\n        max_damage = max(max_damage, d)\n\n    if max_damage >= x:\n        print(1)\n        return\n\n    max_diff = 0\n    for d, h in blows:\n        max_diff = max(max_diff, d - h)\n\n    if max_diff <= 0:\n        print(-1)\n        return\n\n    remaining = x - max_damage\n    \n    blows_needed = (remaining + max_diff - 1) // max_diff\n    \n    print(blows_needed + 1)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "7": "```python\ndef solve():\n    n, m = map(int, input().split())\n\n    low = 0\n    high = 2 * 10**9  # Increased the upper bound for binary search\n    ans = -1\n\n    while low <= high:\n        mid = (low + high) // 2\n        \n        total_sparrows = mid * (mid + 1) // 2\n        \n        barn_content = n + mid * m - total_sparrows\n        \n        if barn_content <= 0:\n            ans = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n\n    print(ans)\n\nsolve()\n```",
    "9": "```python\ndef solve():\n    d = int(input())\n    n, m = map(int, input().split())\n    sofas = []\n    for _ in range(d):\n        x1, y1, x2, y2 = map(int, input().split())\n        sofas.append(((x1, y1), (x2, y2)))\n    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\n    def count_left(sofa_index):\n        count = 0\n        x_coords = [min(sofas[sofa_index][0][0], sofas[sofa_index][1][0])]\n        y_coords = [sofas[sofa_index][0][1], sofas[sofa_index][1][1]]\n        \n        for i in range(d):\n            if i != sofa_index:\n                other_x_max = max(sofas[i][0][0], sofas[i][1][0])\n                other_y_min = min(sofas[i][0][1], sofas[i][1][1])\n                other_y_max = max(sofas[i][0][1], sofas[i][1][1])\n                \n                if min(y_coords) <= other_y_max and max(y_coords) >= other_y_min:\n                    if min(x_coords) > other_x_max:\n                        count += 1\n        return count\n\n    def count_right(sofa_index):\n        count = 0\n        x_coords = [max(sofas[sofa_index][0][0], sofas[sofa_index][1][0])]\n        y_coords = [sofas[sofa_index][0][1], sofas[sofa_index][1][1]]\n        \n        for i in range(d):\n            if i != sofa_index:\n                other_x_min = min(sofas[i][0][0], sofas[i][1][0])\n                other_y_min = min(sofas[i][0][1], sofas[i][1][1])\n                other_y_max = max(sofas[i][0][1], sofas[i][1][1])\n                \n                if min(y_coords) <= other_y_max and max(y_coords) >= other_y_min:\n                    if max(x_coords) < other_x_min:\n                        count += 1\n        return count\n\n    def count_top(sofa_index):\n        count = 0\n        y_coords = [min(sofas[sofa_index][0][1], sofas[sofa_index][1][1])]\n        x_coords = [sofas[sofa_index][0][0], sofas[sofa_index][1][0]]\n        \n        for i in range(d):\n            if i != sofa_index:\n                other_y_max = max(sofas[i][0][1], sofas[i][1][1])\n                other_x_min = min(sofas[i][0][0], sofas[i][1][0])\n                other_x_max = max(sofas[i][0][0], sofas[i][1][0])\n                \n                if min(x_coords) <= other_x_max and max(x_coords) >= other_x_min:\n                    if min(y_coords) > other_y_max:\n                        count += 1\n        return count\n\n    def count_bottom(sofa_index):\n        count = 0\n        y_coords = [max(sofas[sofa_index][0][1], sofas[sofa_index][1][1])]\n        x_coords = [sofas[sofa_index][0][0], sofas[sofa_index][1][0]]\n        \n        for i in range(d):\n            if i != sofa_index:\n                other_y_min = min(sofas[i][0][1], sofas[i][1][1])\n                other_x_min = min(sofas[i][0][0], sofas[i][1][0])\n                other_x_max = max(sofas[i][0][0], sofas[i][1][0])\n                \n                if min(x_coords) <= other_x_max and max(x_coords) >= other_x_min:\n                    if max(y_coords) < other_y_min:\n                        count += 1\n        return count\n\n    result = -1\n    for i in range(d):\n        l = count_left(i)\n        r = count_right(i)\n        t = count_top(i)\n        b = count_bottom(i)\n        if l == cnt_l and r == cnt_r and t == cnt_t and b == cnt_b:\n            result = i + 1\n            break\n\n    print(result)\n\nsolve()\n```",
    "10": "```python\ndef solve():\n    n = int(input())\n    \n    full_weeks = n // 7\n    remaining_days = n % 7\n    \n    min_days_off = full_weeks * 2\n    max_days_off = full_weeks * 2\n    \n    if remaining_days == 6:\n        min_days_off += 1\n    elif remaining_days >= 1:\n        pass\n        \n    max_days_off += min(remaining_days, 2)\n    \n    print(min_days_off, max_days_off)\n\nsolve()\n```",
    "11": "```python\nimport math\n\ndef solve():\n    n, a, b, p, q = map(int, input().split())\n\n    red_count = n // a\n    blue_count = n // b\n    lcm = (a * b) // math.gcd(a, b)\n    both_count = n // lcm\n\n    red_only = red_count - both_count\n    blue_only = blue_count - both_count\n\n    total_chocolates = red_only * p + blue_only * q\n\n    if p > q:\n        total_chocolates += both_count * p\n    else:\n        total_chocolates += both_count * q\n\n    print(total_chocolates)\n\nsolve()\n```",
    "12": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    \n    golds = s.count('G')\n    \n    max_len = 0\n    \n    for i in range(n):\n        if s[i] == 'S':\n            temp_s = list(s)\n            \n            for j in range(n):\n                if s[j] == 'G':\n                    temp_s[i], temp_s[j] = temp_s[j], temp_s[i]\n                    temp_s = \"\".join(temp_s)\n                    \n                    current_len = 0\n                    max_current_len = 0\n                    for k in range(n):\n                        if temp_s[k] == 'G':\n                            current_len += 1\n                        else:\n                            max_current_len = max(max_current_len, current_len)\n                            current_len = 0\n                    max_current_len = max(max_current_len, current_len)\n                    \n                    max_len = max(max_len, max_current_len)\n                    \n                    temp_s = list(s)\n                    break\n    \n    current_len = 0\n    max_current_len = 0\n    for k in range(n):\n        if s[k] == 'G':\n            current_len += 1\n        else:\n            max_current_len = max(max_current_len, current_len)\n            current_len = 0\n    max_current_len = max(max_current_len, current_len)\n    max_len = max(max_len, max_current_len)\n    \n    if golds == 0:\n        print(0)\n    else:\n        print(min(max_len, golds))\n\nsolve()\n```",
    "13": "```python\nfrom collections import deque\n\ndef solve():\n    n, k = map(int, input().split())\n    main_courses = set(map(int, input().split()))\n    dependencies = []\n    for _ in range(n):\n        line = list(map(int, input().split()))\n        dependencies.append(line[1:])\n\n    graph = [[] for _ in range(n + 1)]\n    in_degree = [0] * (n + 1)\n\n    for i in range(n):\n        for dependency in dependencies[i]:\n            graph[dependency].append(i + 1)\n            in_degree[i + 1] += 1\n\n    queue = deque()\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            queue.append(i)\n\n    required_courses = set(main_courses)\n    \n    reachable = [False] * (n + 1)\n    \n    q = deque(main_courses)\n    for course in main_courses:\n        reachable[course] = True\n    \n    while q:\n        u = q.popleft()\n        for i in range(1, n + 1):\n            for dep in dependencies[i-1]:\n                if dep == u and not reachable[i]:\n                    reachable[i] = True\n                    q.append(i)\n                    required_courses.add(i)\n\n    \n    graph = [[] for _ in range(n + 1)]\n    in_degree = [0] * (n + 1)\n\n    for i in range(n):\n        for dependency in dependencies[i]:\n            if (i+1) in required_courses and dependency in required_courses:\n                graph[dependency].append(i + 1)\n                in_degree[i + 1] += 1\n    \n    queue = deque()\n    for i in required_courses:\n        if in_degree[i] == 0:\n            queue.append(i)\n\n    course_order = []\n    visited_count = 0\n\n    while queue:\n        course = queue.popleft()\n        course_order.append(course)\n        visited_count += 1\n\n        for dependent_course in graph[course]:\n            in_degree[dependent_course] -= 1\n            if in_degree[dependent_course] == 0:\n                queue.append(dependent_course)\n\n    if visited_count != len(required_courses):\n        print(\"-1\")\n        return\n\n    print(len(course_order))\n    print(*course_order)\n\nsolve()\n```",
    "14": "```python\ndef is_stack_sortable(arr):\n    stack = []\n    expected = 1\n    for num in arr:\n        stack.append(num)\n        while stack and stack[-1] == expected:\n            stack.pop()\n            expected += 1\n    return not stack\n\ndef solve():\n    n, k = map(int, input().split())\n    p = list(map(int, input().split()))\n\n    used = [False] * (n + 1)\n    for x in p:\n        used[x] = True\n\n    remaining = []\n    for i in range(n, 0, -1):\n        if not used[i]:\n            remaining.append(i)\n\n    p_full = p[:]\n    \n    \n    def find_lexicographically_largest_stack_sortable(prefix, remaining_numbers, n):\n        if not remaining_numbers:\n            if is_stack_sortable(prefix):\n                return prefix\n            else:\n                return None\n\n        \n        for i in range(len(remaining_numbers)):\n            \n            new_prefix = prefix + [remaining_numbers[i]]\n            new_remaining = remaining_numbers[:i] + remaining_numbers[i+1:]\n            \n            result = find_lexicographically_largest_stack_sortable(new_prefix, new_remaining, n)\n            if result:\n                return result\n        \n        return None\n    \n    remaining_nums = []\n    for i in range(1, n + 1):\n        if i not in p:\n            remaining_nums.append(i)\n    \n    remaining_nums.sort(reverse=True)\n    \n    result = find_lexicographically_largest_stack_sortable(p, remaining_nums, n)\n    \n    if result:\n        print(*result)\n    else:\n        print(\"-1\")\n\nsolve()\n```",
    "15": "```python\ndef solve():\n  a, b, c = map(int, input().split())\n\n  if c == 0:\n    if a == b:\n      print(\"YES\")\n    else:\n      print(\"NO\")\n    return\n\n  diff = b - a\n\n  if diff % c == 0 and diff // c >= 0:\n    print(\"YES\")\n  else:\n    print(\"NO\")\n\nsolve()\n```",
    "16": "```python\ndef solve():\n    cnt1 = int(input())\n    cnt2 = int(input())\n    cnt3 = int(input())\n    cnt4 = int(input())\n\n    if cnt1 == cnt4 and cnt1 >= 0 and cnt4 >= 0 and cnt3 > -1:\n        if cnt1 == 0 and cnt3 > 0:\n            print(0)\n        else:\n            print(1)\n    else:\n        print(0)\n\nsolve()\n```",
    "17": "```python\ndef solve():\n    n, k, t = map(int, input().split())\n\n    if t <= k:\n        print(t)\n    elif t <= n:\n        print(k)\n    else:\n        print(k - (t - n))\n\nsolve()\n```",
    "18": "```python\ndef solve():\n    s = input()\n    n = len(s)\n    t = []\n    u = \"\"\n    \n    min_suffix = [0] * (n + 1)\n    min_suffix[n] = 'z'  # Initialize with a large value\n    for i in range(n - 1, -1, -1):\n        min_suffix[i] = min(s[i], min_suffix[i+1])\n    \n    i = 0\n    while i < n:\n        if len(t) > 0 and t[-1] <= min_suffix[i]:\n            u += t[-1]\n            t.pop()\n        else:\n            t.append(s[i])\n            i += 1\n            \n    while len(t) > 0:\n        u += t[-1]\n        t.pop()\n        \n    print(u)\n\nsolve()\n```",
    "19": "```python\ndef solve():\n    n = int(input())\n    pairs = []\n    for _ in range(n):\n        pairs.append(list(map(int, input().split())))\n\n    if n == 0:\n        print(\"YES\")\n        return\n\n    possible = True\n    if pairs[0][1] > pairs[0][0]:\n        possible = False\n    \n    for i in range(1, n):\n        if pairs[i][1] > pairs[i][0]:\n            possible = False\n            break\n        if pairs[i][0] < pairs[i-1][0] or pairs[i][1] < pairs[i-1][1]:\n            possible = False\n            break\n        if pairs[i][0] - pairs[i-1][0] < pairs[i][1] - pairs[i-1][1]:\n            possible = False\n            break\n\n    if possible:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "20": "```python\ndef solve():\n    s = input()\n    hh = int(s[:2])\n    mm = int(s[3:])\n\n    def is_palindrome(h, m):\n        h_str = str(h).zfill(2)\n        m_str = str(m).zfill(2)\n        return h_str == m_str[::-1]\n\n    minutes = 0\n    while True:\n        if is_palindrome(hh, mm):\n            print(minutes)\n            return\n\n        minutes += 1\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n\nsolve()\n```",
    "22": "```python\ndef solve():\n    s = input()\n    n = len(s)\n\n    mirror_chars = {\n        'b': 'd', 'd': 'b',\n        'p': 'q', 'q': 'p',\n        'o': 'o', 'x': 'x',\n        'X': 'X', 'H': 'H',\n        'I': 'I', 'M': 'M',\n        'O': 'O', 'T': 'T',\n        'U': 'U', 'V': 'V',\n        'v': 'v', 'W': 'W',\n        'w': 'w', 'Y': 'Y',\n        'A': 'A', 'm': 'm'\n    }\n\n    for i in range(n // 2):\n        if s[i] not in mirror_chars or mirror_chars[s[i]] != s[n - 1 - i]:\n            print(\"NIE\")\n            return\n\n    if n % 2 == 1:\n        if s[n // 2] not in mirror_chars or mirror_chars[s[n // 2]] != s[n // 2]:\n            print(\"NIE\")\n            return\n\n    print(\"TAK\")\n\n\nsolve()\n```",
    "23": "```python\nfrom collections import Counter\n\ndef solve():\n    a = input()\n    b = input()\n    \n    a_digits = sorted(list(a), reverse=True)\n    \n    if len(a) < len(b):\n        print(\"\".join(a_digits))\n        return\n    \n    a_counts = Counter(a)\n    \n    def find_max_permutation(index, current_num, remaining_counts):\n        if index == len(a):\n            return current_num\n        \n        best_num = None\n        \n        for digit in sorted(remaining_counts.keys(), reverse=True):\n            if remaining_counts[digit] > 0:\n                new_counts = remaining_counts.copy()\n                new_counts[digit] -= 1\n                if new_counts[digit] == 0:\n                    del new_counts[digit]\n                    \n                new_num = current_num + digit\n                \n                if new_num <= b[:index+1]:\n                    if new_num == b[:index+1]:\n                        next_best = find_max_permutation(index + 1, new_num, new_counts)\n                        if next_best is not None:\n                            if best_num is None or next_best > best_num:\n                                best_num = next_best\n                    else:\n                        remaining_digits = []\n                        for d, count in new_counts.items():\n                            remaining_digits.extend([d] * count)\n                        remaining_digits.sort(reverse=True)\n                        \n                        full_num = new_num + \"\".join(remaining_digits)\n                        if best_num is None or full_num > best_num:\n                            best_num = full_num\n        \n        return best_num\n\n    result = find_max_permutation(0, \"\", a_counts)\n    print(result)\n\nsolve()\n```",
    "24": "```python\ndef solve():\n    board = []\n    for _ in range(10):\n        board.append(list(input()))\n\n    def check_win(board):\n        n = 10\n        # Check horizontal\n        for r in range(n):\n            for c in range(n - 4):\n                if all(board[r][c + i] == 'X' for i in range(5)):\n                    return True\n\n        # Check vertical\n        for c in range(n):\n            for r in range(n - 4):\n                if all(board[r + i][c] == 'X' for i in range(5)):\n                    return True\n\n        # Check diagonal (top-left to bottom-right)\n        for r in range(n - 4):\n            for c in range(n - 4):\n                if all(board[r + i][c + i] == 'X' for i in range(5)):\n                    return True\n\n        # Check diagonal (top-right to bottom-left)\n        for r in range(n - 4):\n            for c in range(4, n):\n                if all(board[r + i][c - i] == 'X' for i in range(5)):\n                    return True\n\n        return False\n\n    for r in range(10):\n        for c in range(10):\n            if board[r][c] == '.':\n                board[r][c] = 'X'\n                if check_win(board):\n                    print(\"YES\")\n                    return\n                board[r][c] = '.'\n\n    print(\"NO\")\n\nsolve()\n```",
    "25": "```python\ndef solve():\n    n, k = map(int, input().split())\n\n    if k > n * n:\n        print(\"-1\")\n        return\n\n    matrix = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        if k == 0:\n            break\n        if matrix[i][i] == 0 and k > 0:\n            matrix[i][i] = 1\n            k -= 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if k >= 2:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n\n    if k != 0:\n        print(\"-1\")\n        return\n\n    for row in matrix:\n        print(*row)\n\nsolve()\n```",
    "27": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    \n    ans = n\n    \n    for i in range(1, n // 2 + 1):\n        prefix = s[:i]\n        if s.startswith(prefix * 2):\n            ans = min(ans, n - i)\n        elif s[:2*i].startswith(prefix):\n            if s.startswith(prefix):\n                ans = min(ans, n - i)\n    \n    print(ans)\n\nsolve()\n```",
    "28": "```python\ndef solve():\n    n = int(input())\n    files = []\n    for _ in range(n):\n        files.append(input().split())\n\n    examples = []\n    regular = []\n    for i in range(n):\n        if files[i][1] == '1':\n            examples.append((files[i][0], i))\n        else:\n            regular.append((files[i][0], i))\n\n    moves = []\n    e = len(examples)\n\n    temp_names = []\n    for i in range(n):\n        temp_name = f\"temp{i}\"\n        while temp_name in [f[0] for f in files]:\n            temp_name = f\"temp{i+n}\"\n        temp_names.append(temp_name)\n\n    \n    def find_temp_name(existing_names):\n        i = 0\n        while True:\n            temp_name = f\"temp{i}\"\n            if temp_name not in existing_names:\n                return temp_name\n            i += 1\n\n    \n    existing_names = [f[0] for f in files]\n    \n    \n    for i in range(e):\n        if examples[i][0] != str(i + 1):\n            if str(i + 1) in existing_names:\n                temp_name = find_temp_name(existing_names)\n                moves.append(f\"move {str(i + 1)} {temp_name}\")\n                moves.append(f\"move {examples[i][0]} {i + 1}\")\n                moves.append(f\"move {temp_name} {examples[i][0]}\")\n                existing_names.remove(str(i+1))\n                existing_names.append(str(i+1))\n                existing_names.remove(examples[i][0])\n                existing_names.append(str(i+1))\n                \n            else:\n                moves.append(f\"move {examples[i][0]} {i + 1}\")\n                existing_names.remove(examples[i][0])\n                existing_names.append(str(i+1))\n\n    for i in range(len(regular)):\n        if regular[i][0] != str(e + i + 1):\n            if str(e + i + 1) in existing_names:\n                temp_name = find_temp_name(existing_names)\n                moves.append(f\"move {str(e + i + 1)} {temp_name}\")\n                moves.append(f\"move {regular[i][0]} {e + i + 1}\")\n                moves.append(f\"move {temp_name} {regular[i][0]}\")\n                existing_names.remove(str(e+i+1))\n                existing_names.append(str(e+i+1))\n                existing_names.remove(regular[i][0])\n                existing_names.append(str(e+i+1))\n            else:\n                moves.append(f\"move {regular[i][0]} {e + i + 1}\")\n                existing_names.remove(regular[i][0])\n                existing_names.append(str(e+i+1))\n\n    print(len(moves))\n    for move in moves:\n        print(move)\n\nsolve()\n```",
    "29": "```python\ndef solve():\n    s = input()\n    digits = [int(c) for c in s]\n    \n    ans = 6\n    \n    for sum1 in range(0, 28):\n        for sum2 in range(0, 28):\n            if sum1 == sum2:\n                \n                count = 0\n                \n                for i in range(1000):\n                    s1 = str(i).zfill(3)\n                    if sum(int(c) for c in s1) == sum1:\n                        for j in range(1000):\n                            s2 = str(j).zfill(3)\n                            if sum(int(c) for c in s2) == sum2:\n                                temp_digits = [int(c) for c in s1 + s2]\n                                \n                                diff = 0\n                                for k in range(6):\n                                    if digits[k] != temp_digits[k]:\n                                        diff += 1\n                                ans = min(ans, diff)\n    print(ans)\n\nsolve()\n```",
    "30": "```python\ndef solve():\n    m, x = map(int, input().split())\n    print(m - 1)\n\nsolve()\n```",
    "31": "```python\ndef solve():\n    n, k = map(int, input().split())\n    mod = 10**6 + 3\n\n    if n > 63 and k > 1:\n        print(1, 1)\n        return\n\n    if k > 2**n:\n        print(1, 1)\n        return\n\n    num = 1\n    den = 1\n    twos_num = 0\n    twos_den = 0\n\n    for i in range(k):\n        val = (pow(2, n, mod) - i) % mod\n        num = (num * val) % mod\n        twos_num += count_twos(pow(2, n, 2**60) - i)\n\n    den = pow(pow(2, n, mod), k, mod)\n    twos_den = n * k\n\n    twos_diff = min(twos_num, twos_den)\n\n    num = (num * pow(2, mod - 1 - twos_diff % (mod - 1), mod)) % mod\n    den = (den * pow(2, mod - 1 - twos_diff % (mod - 1), mod)) % mod\n\n    a = (den - num + mod) % mod\n    b = den % mod\n\n    print(a, b)\n\ndef count_twos(n):\n    count = 0\n    while n > 0 and n % 2 == 0:\n        count += 1\n        n //= 2\n    return count\n\nsolve()\n```",
    "32": "```python\ndef solve():\n    n = int(input())\n    \n    current_pos = 0  # 0 is North Pole, 20000 is South Pole\n    \n    for _ in range(n):\n        t, direction = input().split()\n        t = int(t)\n        \n        if current_pos == 0 and direction != \"South\":\n            print(\"NO\")\n            return\n        \n        if current_pos == 20000 and direction != \"North\":\n            print(\"NO\")\n            return\n        \n        if direction == \"North\":\n            current_pos -= t\n            current_pos = max(0, current_pos)\n        elif direction == \"South\":\n            current_pos += t\n            current_pos = min(20000, current_pos)\n        \n    if current_pos == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nsolve()\n```",
    "33": "```python\ndef gcd(a, b):\n    \"\"\"Calculates the greatest common divisor (GCD) of two integers.\"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\ndef extended_gcd(a, b):\n    \"\"\"\n    Calculates the extended GCD of two integers a and b.\n\n    Returns:\n        A tuple (d, x, y) where d is the GCD of a and b, and x and y are\n        integers such that ax + by = d.\n    \"\"\"\n    if a == 0:\n        return b, 0, 1\n    d, x1, y1 = extended_gcd(b % a, a)\n    x = y1 - (b // a) * x1\n    y = x1\n    return d, x, y\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding the number of integers x in the range [L, R]\n    that can be expressed in the form a1*k + b1 and a2*l + b2, where k and l\n    are non-negative integers.\n    \"\"\"\n    a1, b1, a2, b2, L, R = map(int, input().split())\n\n    g = gcd(a1, a2)\n\n    if (b2 - b1) % g != 0:\n        print(0)\n        return\n\n    d, x, y = extended_gcd(a1, a2)\n    x *= (b2 - b1) // d\n    y *= (b2 - b1) // d\n\n    lcm = (a1 * a2) // g\n\n    # x = a1 * k + b1 = a2 * l + b2\n    # k = k0 + (a2 // g) * t\n    # l = l0 + (a1 // g) * t\n    # x = a1 * (k0 + (a2 // g) * t) + b1\n    # x = a1 * k0 + b1 + (a1 * a2 // g) * t\n    # x = a1 * k0 + b1 + lcm * t\n\n    x0 = a1 * x + b1  # Initial value of x\n\n    # Find the range of t such that L <= x0 + lcm * t <= R\n    t_min = (L - x0 + lcm - 1) // lcm\n    t_max = (R - x0) // lcm\n\n    count = 0\n    for t in range(t_min, t_max + 1):\n        k = x + (a2 // g) * t\n        l = y + (a1 // g) * t\n        if k >= 0 and l >= 0:\n            count += 1\n\n    print(count)\n\nsolve()\n```",
    "34": "```python\ndef solve():\n    n, a, b = map(int, input().split())\n    \n    ans = 0\n    for i in range(1, n):\n        \n        x = a // i\n        y = b // (n - i)\n        \n        if x > 0 and y > 0:\n            ans = max(ans, min(x, y))\n        \n    print(ans)\n\nsolve()\n```",
    "36": "```python\ndef solve():\n    n = int(input())\n\n    if n == 0:\n        print(0, 0)\n        return\n\n    layer = 0\n    count = 0\n    while True:\n        if count + 6 * layer <= n:\n            count += 6 * layer\n            layer += 1\n        else:\n            layer -= 1\n            break\n\n    remaining = n - count\n    x, y = 2 * layer, 0\n\n    segment_length = layer\n\n    if remaining == 0:\n        print(x, y)\n        return\n\n    if remaining <= segment_length:\n        x -= remaining\n        y += 2 * remaining\n    elif remaining <= 2 * segment_length:\n        remaining -= segment_length\n        x -= 2 * segment_length\n        y += 2 * segment_length\n        x -= remaining\n        y -= remaining\n    elif remaining <= 3 * segment_length:\n        remaining -= 2 * segment_length\n        x -= 2 * segment_length\n        y += 2 * segment_length\n        x += remaining\n        y -= remaining * 2\n    elif remaining <= 4 * segment_length:\n        remaining -= 3 * segment_length\n        x += remaining\n        y -= 2 * segment_length\n    elif remaining <= 5 * segment_length:\n        remaining -= 4 * segment_length\n        x += 2 * segment_length\n        y -= 2 * segment_length\n        x += remaining\n        y += 2 * remaining\n    else:\n        remaining -= 5 * segment_length\n        x += 2 * segment_length\n        y -= 2 * segment_length\n        x -= remaining\n        y += 2 * remaining\n\n    print(x, y)\n\nsolve()\n```",
    "38": "```python\ndef solve():\n    n, l = map(int, input().split())\n    kefa = list(map(int, input().split()))\n    sasha = list(map(int, input().split()))\n\n    for shift in range(n):\n        shifted_sasha = [(sasha[i] - sasha[0] + l) % l for i in range(n)]\n        shifted_sasha.sort()\n\n        diff = kefa[0]\n        shifted_kefa = [(kefa[i] - diff + l) % l for i in range(n)]\n        shifted_kefa.sort()\n\n        if shifted_kefa == shifted_sasha:\n            print(\"YES\")\n            return\n\n    print(\"NO\")\n\nsolve()\n```",
    "39": "```python\ndef solve():\n    s = input()\n    n = len(s)\n    max_len = 0\n    for i in range(n):\n        for j in range(i, n):\n            sub = s[i:j+1]\n            if sub != sub[::-1]:\n                max_len = max(max_len, len(sub))\n    print(max_len)\n\nsolve()\n```",
    "41": "```python\ndef nearest_zero(arr):\n  \"\"\"\n  Calculates the distance to the nearest zero for each element in the array.\n\n  Args:\n    arr: A list of integers.\n\n  Returns:\n    A list of integers representing the distances to the nearest zero for each element.\n  \"\"\"\n\n  n = len(arr)\n  distances = [float('inf')] * n\n\n  # Forward pass: Find the distance to the nearest zero from the left\n  last_zero = float('-inf')\n  for i in range(n):\n    if arr[i] == 0:\n      last_zero = i\n      distances[i] = 0\n    elif last_zero != float('-inf'):\n      distances[i] = i - last_zero\n\n  # Backward pass: Find the distance to the nearest zero from the right\n  last_zero = float('inf')\n  for i in range(n - 1, -1, -1):\n    if arr[i] == 0:\n      last_zero = i\n      distances[i] = 0\n    elif last_zero != float('inf'):\n      distances[i] = min(distances[i], last_zero - i)\n\n  return distances\n\n\nif __name__ == \"__main__\":\n  n = int(input())\n  arr = list(map(int, input().split()))\n  result = nearest_zero(arr)\n  print(*result)\n```",
    "42": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    len_s = len(s)\n    \n    count = 0\n    \n    for i in range(2**n):\n        binary_string = bin(i)[2:].zfill(n)\n        \n        is_substring = False\n        for j in range(n):\n            shifted_string = binary_string[j:] + binary_string[:j]\n            if s in shifted_string:\n                is_substring = True\n                break\n        \n        if is_substring:\n            count += 1\n                \n    print(count)\n\nsolve()\n```",
    "44": "```python\ndef solve():\n    d, k, a, b, t = map(int, input().split())\n\n    if d <= k:\n        print(d * a)\n        return\n\n    cost_only_driving = k * a + t + (d - k) * a\n    cost_drive_and_walk = k * a + (d - k) * b\n\n    if cost_drive_and_walk < cost_only_driving:\n        print(cost_drive_and_walk)\n        return\n\n    num_breaks = (d - 1) // k\n    total_driving_cost = num_breaks * (k * a + t)\n    remaining_distance_last = d - num_breaks * k\n    total_driving_cost += remaining_distance_last * a\n    \n    cost_with_breaks = total_driving_cost\n    \n    print(cost_with_breaks)\n    \n\nsolve()\n```",
    "45": "```python\ndef solve():\n    n, k = map(int, input().split())\n\n    if k * (k + 1) // 2 > n:\n        print(\"-1\")\n        return\n\n    best_gcd = 0\n    best_seq = []\n\n    for gcd in range(int(n**0.5), 0, -1):\n        if n % gcd == 0:\n            divisors = [gcd, n // gcd]\n            for d in divisors:\n                if d >= k * (k + 1) // 2:\n                    remaining_sum = d - k * (k + 1) // 2\n                    seq = [i + 1 for i in range(k)]\n                    seq[-1] += remaining_sum\n                    seq = [x * (n // d) for x in seq]\n\n                    is_strictly_increasing = all(seq[i] < seq[i+1] for i in range(len(seq)-1))\n                    if is_strictly_increasing:\n                        best_gcd = n // d\n                        best_seq = seq\n                        print(*best_seq)\n                        return\n\n    if n == 1 and k == 1:\n        print(1)\n    else:\n        print(\"-1\")\n\nsolve()\n```",
    "46": "```python\ndef solve():\n    n, m = map(int, input().split())\n    count = 0\n    for i in range(5):\n        count += (n - i + 4) // 5 * ((m - (5 - i) + 4) // 5)\n    print(count)\n\nsolve()\n```",
    "49": "```python\ndef solve():\n    k = int(input())\n    \n    digits = 0\n    count = 0\n    power_of_10 = 1\n    length = 1\n    \n    while True:\n        num_numbers = 9 * power_of_10\n        digits_in_numbers = num_numbers * length\n        \n        if count + digits_in_numbers >= k:\n            break\n        \n        count += digits_in_numbers\n        power_of_10 *= 10\n        length += 1\n    \n    remaining = k - count\n    number_index = (remaining - 1) // length\n    digit_index = (remaining - 1) % length\n    \n    number = power_of_10 + number_index\n    number_str = str(number)\n    \n    print(number_str[digit_index])\n\nsolve()\n```",
    "52": "```python\ndef solve():\n    n, m, k = map(int, input().split())\n    a = []\n    for _ in range(n):\n        a.append(list(map(int, input().split())))\n\n    dp = {}\n\n    def get_dp(row_idx, total_sum_mod_k):\n        if (row_idx, total_sum_mod_k) in dp:\n            return dp[(row_idx, total_sum_mod_k)]\n\n        if row_idx == n:\n            if total_sum_mod_k == 0:\n                return 0\n            else:\n                return float('-inf')\n\n        max_sum = float('-inf')\n        \n        # Option 1: Don't pick any elements from the current row\n        max_sum = max(max_sum, get_dp(row_idx + 1, total_sum_mod_k))\n\n        # Option 2: Pick some elements from the current row\n        row = a[row_idx]\n        max_elements = m // 2\n        \n        for num_elements in range(1, max_elements + 1):\n            for combination in combinations(row, num_elements):\n                current_sum = sum(combination)\n                max_sum = max(max_sum, current_sum + get_dp(row_idx + 1, (total_sum_mod_k + current_sum) % k))\n\n        dp[(row_idx, total_sum_mod_k)] = max_sum\n        return max_sum\n\n    from itertools import combinations\n    print(get_dp(0, 0))\n\nsolve()\n```",
    "53": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    def find_longest_increasing_sequence(arr):\n        max_len = 0\n        best_moves = \"\"\n\n        def backtrack(current_sequence, remaining_arr, moves):\n            nonlocal max_len, best_moves\n\n            if len(current_sequence) > max_len:\n                max_len = len(current_sequence)\n                best_moves = moves\n\n            if not remaining_arr:\n                return\n\n            last_val = current_sequence[-1] if current_sequence else 0  # Initialize to 0 for empty sequence\n\n            if remaining_arr[0] > last_val:\n                backtrack(current_sequence + [remaining_arr[0]], remaining_arr[1:], moves + \"L\")\n\n            if len(remaining_arr) > 1 and remaining_arr[-1] > last_val:\n                backtrack(current_sequence + [remaining_arr[-1]], remaining_arr[:-1], moves + \"R\")\n\n        backtrack([], arr, \"\")\n        return max_len, best_moves\n\n    length, moves = find_longest_increasing_sequence(a)\n    print(length)\n    print(moves)\n\nsolve()\n```",
    "54": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    unique_values = sorted(list(set(a)))\n\n    if len(unique_values) > 3:\n        print(-1)\n        return\n\n    if len(unique_values) <= 1:\n        print(0)\n        return\n\n    if len(unique_values) == 2:\n        val1, val2 = unique_values\n        diff = abs(val1 - val2)\n        if diff % 2 == 0:\n            print(diff // 2)\n        else:\n            print(diff)\n        return\n\n    if len(unique_values) == 3:\n        val1, val2, val3 = unique_values\n        if val2 - val1 == val3 - val2:\n            print(val2 - val1)\n        else:\n            print(-1)\n        return\n\nsolve()\n```",
    "55": "```python\ndef intersection_area(x1, y1, x2, y2, x3, y3, x4, y4):\n    \"\"\"Calculates the area of intersection between two rectangles.\"\"\"\n    x_overlap = max(0, min(x2, x4) - max(x1, x3))\n    y_overlap = max(0, min(y2, y4) - max(y1, y3))\n    return x_overlap * y_overlap\n\n\ndef solve():\n    \"\"\"Reads input, calculates visible area, and prints the result.\"\"\"\n    x1, y1, x2, y2 = map(int, input().split())\n    x3, y3, x4, y4 = map(int, input().split())\n    x5, y5, x6, y6 = map(int, input().split())\n\n    white_area = (x2 - x1) * (y2 - y1)\n    intersection1 = intersection_area(x1, y1, x2, y2, x3, y3, x4, y4)\n    intersection2 = intersection_area(x1, y1, x2, y2, x5, y5, x6, y6)\n\n    # Calculate the intersection of the two black rectangles\n    x_overlap_black = max(0, min(x4, x6) - max(x3, x5))\n    y_overlap_black = max(0, min(y4, y6) - max(y3, y5))\n    intersection_black = x_overlap_black * y_overlap_black\n\n    # Calculate the intersection of the white rectangle with the intersection of the two black rectangles\n    intersection12 = intersection_area(x1, y1, x2, y2, max(x3, x5), max(y3, y5), min(x4, x6), min(y4, y6))\n\n    covered_area = intersection1 + intersection2 - intersection12\n\n    if white_area > covered_area:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nsolve()\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef solve():\n    n = int(input())\n    reachable = set()\n    reachable.add(n)\n    \n    current = n\n    while True:\n        current = f(current)\n        if current in reachable:\n            break\n        reachable.add(current)\n    \n    print(len(reachable))\n\nsolve()\n```",
    "57": "```python\ndef solve():\n    n = int(input())\n    f = list(map(int, input().split()))\n\n    givers = [i + 1 for i in range(n)]\n    receivers = [i + 1 for i in range(n)]\n\n    given = set()\n    for i in range(n):\n        if f[i] != 0:\n            given.add(f[i])\n\n    not_given = []\n    for i in range(1, n + 1):\n        if i not in given:\n            not_given.append(i)\n\n    zeros_indices = []\n    for i in range(n):\n        if f[i] == 0:\n            zeros_indices.append(i)\n\n    for i in range(len(zeros_indices)):\n        f[zeros_indices[i]] = not_given[i]\n\n    for i in range(len(zeros_indices)):\n        if f[zeros_indices[i]] == zeros_indices[i] + 1:\n            if i + 1 < len(zeros_indices):\n                f[zeros_indices[i]], f[zeros_indices[i+1]] = f[zeros_indices[i+1]], f[zeros_indices[i]]\n            else:\n                \n                for j in range(len(zeros_indices)):\n                    if zeros_indices[j] + 1 != f[zeros_indices[i]]:\n                        f[zeros_indices[i]], f[zeros_indices[j]] = f[zeros_indices[j]], f[zeros_indices[i]]\n                        break\n    print(*f)\nsolve()\n```",
    "58": "```python\ndef solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    counts = {}\n    for x in a:\n        counts[x] = counts.get(x, 0) + 1\n\n    for x in counts:\n        if counts[x] > k:\n            print(\"NO\")\n            return\n\n    coloring = [0] * n\n    color_idx = 1\n    \n    assignments = {}\n\n    for i in range(n):\n        num = a[i]\n        if num not in assignments:\n            assignments[num] = []\n        \n        if len(assignments[num]) < k:\n            coloring[i] = color_idx\n            assignments[num].append(color_idx)\n            color_idx = (color_idx % k) + 1\n            if color_idx == 0:\n                color_idx = 1\n\n    color_used = [False] * (k + 1)\n    for color in coloring:\n        color_used[color] = True\n    \n    all_colors_used = all(color_used[1:])\n    \n    if not all_colors_used:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    print(*coloring)\n\nsolve()\n```",
    "59": "```python\ndef solve():\n    n, x, y = map(int, input().split())\n    s = input()\n    \n    count = 0\n    for i in range(n - x, n):\n        if i == n - 1 - y:\n            if s[i] == '0':\n                count += 1\n        else:\n            if s[i] == '1':\n                count += 1\n    print(count)\n\nsolve()\n```",
    "62": "```python\ndef solve():\n    a, b, c = map(int, input().split())\n    \n    best_cost = float('inf')\n    best_triple = None\n    \n    for A in range(1, 2 * a + 1):\n        for B in range(A, 2 * b + 1, A):\n            C1 = (c // B) * B\n            C2 = C1 + B\n            \n            candidates = []\n            if C1 > 0:\n                candidates.append(C1)\n            candidates.append(C2)\n            \n            for C in candidates:\n                cost = abs(A - a) + abs(B - b) + abs(C - c)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_triple = (A, B, C)\n                    \n    print(best_cost)\n    print(*best_triple)\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "64": "```python\ndef solve():\n    n, m = map(int, input().split())\n    exams = []\n    for i in range(m):\n        s, d, c = map(int, input().split())\n        exams.append((s - 1, d - 1, c, i + 1))\n\n    schedule = [0] * n\n    exam_days = {}\n    for s, d, c, i in exams:\n        exam_days[d] = i\n        schedule[d] = m + 1\n\n    preparation_counts = [0] * m\n\n    for day in range(n):\n        if schedule[day] == 0:\n            best_exam = -1\n            for s, d, c, i in exams:\n                exam_index = i - 1\n                if s <= day < d and preparation_counts[exam_index] < c:\n                    if best_exam == -1:\n                        best_exam = i\n                    else:\n                        s_best, d_best, c_best, i_best = exams[best_exam - 1]\n                        if d < d_best:\n                            best_exam = i\n\n            if best_exam != -1:\n                schedule[day] = best_exam\n                preparation_counts[best_exam - 1] += 1\n\n    possible = True\n    for i in range(m):\n        if preparation_counts[i] != exams[i][2]:\n            possible = False\n            break\n\n    if possible:\n        print(*schedule)\n    else:\n        print(-1)\n\nsolve()\n```",
    "66": "```python\ndef solve():\n    n, k = map(int, input().split())\n    t = input()\n\n    overlap = 0\n    for i in range(1, n):\n        if t[:n-i] == t[i:]:\n            overlap = n - i\n            break\n    \n    result = t + t[overlap:] * (k - 1)\n    print(result)\n\nsolve()\n```",
    "68": "```python\ndef solve():\n    n, k = map(int, input().split())\n    s = input()\n\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        dp[i][0] = 1\n        for j in range(1, i + 1):\n            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n\n    total_subsequences = sum(dp[n])\n    \n    if k > total_subsequences:\n        print(\"-1\")\n        return\n\n    cost = 0\n    for length in range(n, -1, -1):\n        num_subsequences = dp[n][length]\n        \n        take = min(k, num_subsequences)\n        cost += (n - length) * take\n        k -= take\n        \n        if k == 0:\n            break\n\n    print(cost)\n\nsolve()\n```",
    "71": "```python\ndef solve():\n    a = int(input())\n\n    if a == 1:\n        print(1)\n        return\n\n    count = 0\n    i = 2\n    while a >= i:\n        a -= i\n        count += 1\n        i += 1\n\n    print(count)\n\nsolve()\n```",
    "73": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    stack = []\n    for x in a:\n        if not stack:\n            stack.append(x)\n        elif stack[-1] == x:\n            stack.pop()\n        else:\n            stack.append(x)\n\n    if not stack:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nsolve()\n```",
    "74": "```python\ndef solve():\n    n, k = map(int, input().split())\n    s = input()\n\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1]\n\n    counts = [dp[n][i] for i in range(n + 1)]\n\n    total_subsequences = sum(counts)\n    if k > total_subsequences:\n        print(-1)\n        return\n\n    cost = 0\n    for length in range(n, -1, -1):\n        if k <= counts[length]:\n            cost += (n - length) * k\n            k = 0\n            break\n        else:\n            cost += (n - length) * counts[length]\n            k -= counts[length]\n\n    print(cost)\n\nsolve()\n```",
    "76": "```python\ndef solve():\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        tile = []\n        tile.append(list(map(int, input().split())))\n        tile.append(list(map(int, input().split())))\n        tiles.append(tile)\n\n    if m % 2 != 0:\n        print(\"NO\")\n        return\n\n    found = False\n    for tile in tiles:\n        if tile[0][1] == tile[1][0]:\n            found = True\n            break\n\n    if found:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nt = int(input())\nfor _ in range(t):\n    solve()\n```",
    "77": "```python\ndef solve():\n    \"\"\"\n    Calculates the minimum possible absolute difference between the sums of two sets\n    formed by dividing the sequence 1, 2, ..., n.\n\n    The problem is equivalent to finding the minimum possible value of |sum(A) - sum(B)|,\n    where A and B are two sets that partition the sequence 1, 2, ..., n.\n    This is equivalent to finding the absolute difference between the total sum and twice the sum of one of the sets.\n    The minimum value is achieved when the sum of one set is as close as possible to half the total sum.\n    If the total sum is even, the minimum difference is 0.\n    If the total sum is odd, the minimum difference is 1.\n\n    The total sum of the sequence 1, 2, ..., n is n * (n + 1) // 2.\n    \"\"\"\n    n = int(input())\n    total_sum = n * (n + 1) // 2\n\n    # If the total sum is even, the minimum difference is 0.\n    # If the total sum is odd, the minimum difference is 1.\n    print(total_sum % 2)\n\nsolve()\n```",
    "78": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    mod = 10**9 + 7\n    len_s = len(s)\n\n    dp = {}\n\n    def count_regular_sequences(length, balance, contains_s):\n        if length == 2 * n:\n            if balance == 0 and contains_s:\n                return 1\n            else:\n                return 0\n\n        if (length, balance, contains_s) in dp:\n            return dp[(length, balance, contains_s)]\n\n        count = 0\n        \n        # Add '('\n        if balance + 1 <= n:\n            new_contains_s = contains_s\n            if not contains_s:\n                new_seq = \"\"\n                if length > 0:\n                    new_seq = current_seq + '('\n                else:\n                    new_seq = '('\n                \n                if len(new_seq) >= len_s and new_seq[len(new_seq) - len_s:] == s:\n                    new_contains_s = True\n            \n            count = (count + count_regular_sequences(length + 1, balance + 1, contains_s or (len(current_seq + '(') >= len_s and (current_seq + '(')[len(current_seq + '(') - len_s:] == s))) % mod\n\n        # Add ')'\n        if balance > 0:\n            new_contains_s = contains_s\n            if not contains_s:\n                new_seq = \"\"\n                if length > 0:\n                    new_seq = current_seq + ')'\n                else:\n                    new_seq = ')'\n                \n                if len(new_seq) >= len_s and new_seq[len(new_seq) - len_s:] == s:\n                    new_contains_s = True\n            \n            count = (count + count_regular_sequences(length + 1, balance - 1, contains_s or (len(current_seq + ')') >= len_s and (current_seq + ')')[len(current_seq + ')') - len_s:] == s))) % mod\n\n        dp[(length, balance, contains_s)] = count\n        return count\n\n    current_seq = \"\"\n    dp = {}\n    result = count_regular_sequences(0, 0, False)\n    print(result)\n\nsolve()\n```",
    "79": "```python\ndef solve():\n    n = input()\n    s = list(n)\n    l = len(s)\n    ans = float('inf')\n\n    for suffix in ['00', '25', '50', '75']:\n        temp_s = s[:]\n        moves = 0\n\n        # Find the last digit of the suffix\n        last_digit_index = -1\n        for i in range(l - 1, -1, -1):\n            if temp_s[i] == suffix[1]:\n                last_digit_index = i\n                break\n\n        if last_digit_index == -1:\n            continue\n\n        moves += l - 1 - last_digit_index\n        temp_s.pop(last_digit_index)\n\n        # Find the first digit of the suffix\n        first_digit_index = -1\n        for i in range(len(temp_s) - 1, -1, -1):\n            if temp_s[i] == suffix[0]:\n                first_digit_index = i\n                break\n\n        if first_digit_index == -1:\n            continue\n\n        moves += len(temp_s) - 1 - first_digit_index\n        temp_s.pop(first_digit_index)\n\n        # Remove leading zeros\n        leading_zeros = 0\n        for i in range(len(temp_s)):\n            if temp_s[i] == '0':\n                leading_zeros += 1\n            else:\n                break\n\n        # If all digits are zero after removing suffix, it's invalid\n        if leading_zeros == len(temp_s):\n            continue\n\n        moves += leading_zeros\n\n        ans = min(ans, moves)\n\n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)\n\nsolve()\n```",
    "80": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    \n    colors = [0] * n\n    \n    def check(num_colors):\n        \n        def is_valid_coloring(color_assignment):\n            \n            b = []\n            for i in range(n):\n                b.append((s[i], color_assignment[i]))\n            \n            \n            def can_be_sorted(arr):\n                arr_copy = arr[:]\n                \n                for _ in range(n * (n - 1) // 2):\n                    swapped = False\n                    for i in range(n - 1):\n                        if arr_copy[i][0] > arr_copy[i+1][0] and arr_copy[i][1] != arr_copy[i+1][1]:\n                            arr_copy[i], arr_copy[i+1] = arr_copy[i+1], arr_copy[i]\n                            swapped = True\n                    if not swapped:\n                        break\n                \n                sorted_arr = sorted(arr, key=lambda x: x[0])\n                \n                \n                chars_only_copy = [x[0] for x in arr_copy]\n                chars_only_sorted = [x[0] for x in sorted_arr]\n                \n                return chars_only_copy == chars_only_sorted\n            \n            return can_be_sorted(b)\n        \n        import itertools\n        \n        for color_assignment in itertools.product(range(1, num_colors + 1), repeat=n):\n            if is_valid_coloring(list(color_assignment)):\n                return True, list(color_assignment)\n        return False, None\n    \n    for num_colors in range(1, n + 1):\n        possible, color_assignment = check(num_colors)\n        if possible:\n            print(num_colors)\n            print(*color_assignment)\n            return\n\nsolve()\n```",
    "81": "```python\ndef solve():\n    n = int(input())\n    strings = [input() for _ in range(n)]\n\n    strings.sort(key=len)\n\n    for i in range(1, n):\n        for j in range(i):\n            if strings[j] not in strings[i]:\n                print(\"NO\")\n                return\n\n    print(\"YES\")\n    for s in strings:\n        print(s)\n\nsolve()\n```",
    "83": "```python\ndef solve():\n    a, b = map(int, input().split())\n    total = a + b\n    \n    best_perimeter = float('inf')\n    \n    for h in range(1, int(total**0.5) + 1):\n        if total % h == 0:\n            w = total // h\n            \n            # Case 1: a forms a rectangle\n            for h_a in range(1, int(a**0.5) + 1):\n                if a % h_a == 0:\n                    w_a = a // h_a\n                    if h_a <= h and w_a <= w:\n                        best_perimeter = min(best_perimeter, 2 * (h + w))\n            \n            # Case 2: b forms a rectangle\n            for h_b in range(1, int(b**0.5) + 1):\n                if b % h_b == 0:\n                    w_b = b // h_b\n                    if h_b <= h and w_b <= w:\n                        best_perimeter = min(best_perimeter, 2 * (h + w))\n    \n    print(best_perimeter)\n\nsolve()\n```",
    "84": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    sorted_s = sorted(s)\n\n    for i in range(2**n):\n        coloring = bin(i)[2:].zfill(n)\n        \n        s0 = []\n        s1 = []\n        \n        for j in range(n):\n            if coloring[j] == '0':\n                s0.append(s[j])\n            else:\n                s1.append(s[j])\n        \n        s0.sort()\n        s1.sort()\n        \n        merged = []\n        idx0 = 0\n        idx1 = 0\n        \n        possible = True\n        \n        for k in range(n):\n            if coloring[k] == '0':\n                if idx0 < len(s0):\n                    merged.append(s0[idx0])\n                    idx0 += 1\n                else:\n                    possible = False\n                    break\n            else:\n                if idx1 < len(s1):\n                    merged.append(s1[idx1])\n                    idx1 += 1\n                else:\n                    possible = False\n                    break\n        \n        if not possible:\n            continue\n        \n        if merged == sorted_s:\n            print(\"YES\")\n            print(coloring)\n            return\n    \n    print(\"NO\")\n\nsolve()\n```",
    "86": "```python\ndef solve():\n    n, k = map(int, input().split())\n\n    if k * (k + 1) // 2 > n:\n        print(\"NO\")\n        return\n\n    a = [0] * k\n    for i in range(k):\n        a[i] = i + 1\n\n    remaining = n - k * (k + 1) // 2\n\n    for i in range(k):\n        a[i] += remaining // k\n\n    remaining %= k\n\n    for i in range(k - 1, k - 1 - remaining, -1):\n        a[i] += 1\n\n    for i in range(k - 1):\n        if a[i + 1] > 2 * a[i]:\n            diff = a[i + 1] - 2 * a[i]\n            a[i + 1] -= diff\n            a[k - 1] += diff\n            if a[i + 1] > 2 * a[i]:\n                print(\"NO\")\n                return\n            \n    for i in range(k - 1):\n        if a[i + 1] <= a[i]:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(*a)\n\nsolve()\n```",
    "88": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    counts = {}\n    for x in a:\n        counts[x] = counts.get(x, 0) + 1\n\n    matrix = [[0] * n for _ in range(n)]\n\n    def can_place(row, col, num):\n        r_sym = n - 1 - row\n        c_sym = n - 1 - col\n\n        if row == r_sym and col == c_sym:\n            return counts[num] >= 1\n        elif row == r_sym or col == c_sym:\n            return counts[num] >= 2\n        else:\n            return counts[num] >= 4\n\n    def place(row, col, num):\n        r_sym = n - 1 - row\n        c_sym = n - 1 - col\n\n        matrix[row][col] = num\n        if row != r_sym or col != c_sym:\n            matrix[r_sym][col] = num\n        if row != r_sym or col != c_sym:\n            matrix[row][c_sym] = num\n        if row != r_sym and col != c_sym:\n            matrix[r_sym][c_sym] = num\n\n        if row == r_sym and col == c_sym:\n            counts[num] -= 1\n        elif row == r_sym or col == c_sym:\n            counts[num] -= 2\n        else:\n            counts[num] -= 4\n\n    def remove(row, col, num):\n        r_sym = n - 1 - row\n        c_sym = n - 1 - col\n\n        matrix[row][col] = 0\n        if row != r_sym or col != c_sym:\n            matrix[r_sym][col] = 0\n        if row != r_sym or col != c_sym:\n            matrix[row][c_sym] = 0\n        if row != r_sym and col != c_sym:\n            matrix[r_sym][c_sym] = 0\n\n        if row == r_sym and col == c_sym:\n            counts[num] += 1\n        elif row == r_sym or col == c_sym:\n            counts[num] += 2\n        else:\n            counts[num] += 4\n\n    def backtrack(row, col):\n        if row == n:\n            return True\n\n        if col == n:\n            return backtrack(row + 1, 0)\n\n        if matrix[row][col] != 0:\n            return backtrack(row, col + 1)\n\n        for num in list(counts.keys()):\n            if counts[num] > 0 and can_place(row, col, num):\n                place(row, col, num)\n                if backtrack(row, col + 1):\n                    return True\n                remove(row, col, num)\n\n        return False\n\n    if backtrack(0, 0):\n        print(\"YES\")\n        for row in matrix:\n            print(*row)\n    else:\n        print(\"NO\")\n\nsolve()\n```",
    "89": "```python\ndef solve():\n    n, r = map(int, input().split())\n    positive_projects = []\n    negative_projects = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        if b >= 0:\n            positive_projects.append((a, b))\n        else:\n            negative_projects.append((a, b))\n\n    positive_projects.sort()\n    negative_projects.sort(key=lambda x: x[0] + x[1], reverse=True)\n\n    def check_projects(projects):\n        nonlocal r\n        initial_r = r\n        for a, b in projects:\n            if r < a:\n                r = initial_r\n                return False\n            r += b\n            if r < 0:\n                r = initial_r\n                return False\n        return True\n\n    if check_projects(positive_projects) and check_projects(negative_projects):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nsolve()\n```",
    "90": "```python\ndef solve():\n    n, m, d = map(int, input().split())\n    c = list(map(int, input().split()))\n\n    total_length = sum(c)\n    min_empty = n - total_length\n\n    arr = [0] * n\n\n    current_pos = 0\n    possible = False\n\n    for i in range(m):\n        current_pos += 1\n        \n        \n        if current_pos + c[i] -1 > n:\n            print(\"NO\")\n            return\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n",
    "91": "```python\ndef solve():\n    s = input()\n    t = input()\n    n = len(s)\n    m = len(t)\n    \n    max_len = 0\n    \n    for i in range(n + 1):\n        for j in range(i, n + 1):\n            temp_s = \"\"\n            if i > 0:\n                temp_s += s[:i]\n            if j < n:\n                temp_s += s[j:]\n            \n            \n            t_idx = 0\n            temp_s_idx = 0\n            \n            possible = True\n            while t_idx < m and temp_s_idx < len(temp_s):\n                if t[t_idx] == temp_s[temp_s_idx]:\n                    t_idx += 1\n                temp_s_idx += 1\n            \n            if t_idx == m:\n                max_len = max(max_len, j - i)\n                \n    print(max_len)\n\nsolve()\n```",
    "92": "```python\ndef solve():\n    x = float(input())\n    \n    for a in range(1, 11):\n        for b in range(1, 11):\n            if abs(a / b - x) < 1e-7:\n                print(a, b)\n                return\n\nsolve()\n```",
    "93": "```python\ndef solve():\n    n, d, k = map(int, input().split())\n\n    if d >= n:\n        print(\"NO\")\n        return\n\n    if k == 1:\n        if d > 1 or n > d + 1:\n            print(\"NO\")\n            return\n        else:\n            print(\"YES\")\n            for i in range(d):\n                print(i + 1, i + 2)\n            return\n\n    if d > n - 1:\n        print(\"NO\")\n        return\n\n    if d == 1 and n > 2 and k < 2:\n        print(\"NO\")\n        return\n    \n    if d == 1 and n > k + 1:\n        print(\"NO\")\n        return\n\n    edges = []\n    degrees = [0] * (n + 1)\n\n    # Create a path of length d\n    for i in range(d):\n        edges.append((i + 1, i + 2))\n        degrees[i + 1] += 1\n        degrees[i + 2] += 1\n\n    next_node = d + 2\n\n    # Add remaining nodes to the path\n    for i in range(1, d + 2):\n        while degrees[i] < k and next_node <= n:\n            edges.append((i, next_node))\n            degrees[i] += 1\n            degrees[next_node] += 1\n            next_node += 1\n\n    if next_node <= n:\n        print(\"NO\")\n        return\n\n    if len(edges) != n - 1:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    for u, v in edges:\n        print(u, v)\n\nsolve()\n```",
    "94": "```python\ndef solve():\n    a, b, x = map(int, input().split())\n\n    s = \"\"\n    \n    if a > b:\n        start = 0\n    else:\n        start = 1\n\n    curr = start\n    \n    for _ in range(x):\n        s += str(curr)\n        if curr == 0:\n            a -= 1\n            curr = 1\n        else:\n            b -= 1\n            curr = 0\n\n    if curr == 0:\n        s += \"0\" * a\n        s += \"1\" * b\n    else:\n        s += \"1\" * b\n        s += \"0\" * a\n\n    print(s)\n\nsolve()\n```",
    "95": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    t = input()\n\n    def check(res, s, t):\n        for i in range(len(res) - 1):\n            sub = res[i:i+2]\n            if sub == s or sub == t:\n                return False\n        return True\n\n    res1 = \"a\" * n + \"b\" * n + \"c\" * n\n    if check(res1, s, t):\n        print(\"YES\")\n        print(res1)\n        return\n\n    res2 = \"a\" * n + \"c\" * n + \"b\" * n\n    if check(res2, s, t):\n        print(\"YES\")\n        print(res2)\n        return\n\n    res3 = \"b\" * n + \"a\" * n + \"c\" * n\n    if check(res3, s, t):\n        print(\"YES\")\n        print(res3)\n        return\n\n    res4 = \"b\" * n + \"c\" * n + \"a\" * n\n    if check(res4, s, t):\n        print(\"YES\")\n        print(res4)\n        return\n\n    res5 = \"c\" * n + \"a\" * n + \"b\" * n\n    if check(res5, s, t):\n        print(\"YES\")\n        print(res5)\n        return\n\n    res6 = \"c\" * n + \"b\" * n + \"a\" * n\n    if check(res6, s, t):\n        print(\"YES\")\n        print(res6)\n        return\n\n    res7 = \"acb\" * n\n    if check(res7, s, t):\n        print(\"YES\")\n        print(res7)\n        return\n\n    res8 = \"bac\" * n\n    if check(res8, s, t):\n        print(\"YES\")\n        print(res8)\n        return\n\n    res9 = \"cba\" * n\n    if check(res9, s, t):\n        print(\"YES\")\n        print(res9)\n        return\n\n    res10 = \"abc\" * n\n    if check(res10, s, t):\n        print(\"YES\")\n        print(res10)\n        return\n    \n    res11 = \"cab\" * n\n    if check(res11, s, t):\n        print(\"YES\")\n        print(res11)\n        return\n\n    res12 = \"bca\" * n\n    if check(res12, s, t):\n        print(\"YES\")\n        print(res12)\n        return\n\n    print(\"NO\")\n\nsolve()\n```",
    "96": "```python\ndef solve():\n    n = int(input())\n    q = list(map(int, input().split()))\n\n    def check_permutation(arr):\n        if len(arr) != n:\n            return False\n        seen = set()\n        for x in arr:\n            if not (1 <= x <= n):\n                return False\n            if x in seen:\n                return False\n            seen.add(x)\n        return True\n\n    def find_permutation():\n        for first_element in range(1, n + 1):\n            p = [first_element]\n            for i in range(n - 1):\n                next_element = p[-1] + q[i]\n                p.append(next_element)\n            \n            if check_permutation(p):\n                return p\n        return None\n\n    result = find_permutation()\n    if result:\n        print(*result)\n    else:\n        print(-1)\n\nsolve()\n```",
    "97": "```python\ndef solve():\n    n = int(input())\n    x = list(map(int, input().split()))\n\n    odd_count = 0\n    even_count = 0\n    for val in x:\n        if val % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    print(min(odd_count, even_count))\n\nsolve()\n```",
    "99": "```python\ndef solve():\n    n = int(input())\n    a1, a2, a3 = map(int, input().split())\n    b1, b2, b3 = map(int, input().split())\n\n    max_wins = min(a1, b2) + min(a2, b3) + min(a3, b1)\n\n    min_wins = max(0, a1 - (b1 + b3)) + max(0, a2 - (b2 + b1)) + max(0, a3 - (b3 + b2))\n    \n    print(min_wins, max_wins)\n\nsolve()\n```"
}