{
    "80": "```python\ndef solve():\n    n = int(input())\n    s = input()\n\n    def check(coloring):\n        temp_s = list(s)\n        \n        for _ in range(n * (n - 1) // 2):\n            swapped = False\n            for i in range(n - 1):\n                if temp_s[i] > temp_s[i+1] and coloring[i] != coloring[i+1]:\n                    temp_s[i], temp_s[i+1] = temp_s[i+1], temp_s[i]\n                    swapped = True\n            if not swapped:\n                break\n        return \"\".join(temp_s) == \"\".join(sorted(s))\n    \n    def find_coloring(num_colors):\n        for i in range(num_colors**n):\n            coloring = []\n            temp = i\n            for _ in range(n):\n                coloring.append(temp % num_colors + 1)\n                temp //= num_colors\n            \n            if check(coloring):\n                return coloring\n        return None\n\n    for num_colors in range(1, n + 1):\n        coloring = find_coloring(num_colors)\n        if coloring:\n            print(num_colors)\n            print(*coloring)\n            return\n\nsolve()\n```",
    "81": "```python\ndef solve():\n    n = int(input())\n    strings = [input() for _ in range(n)]\n\n    strings.sort(key=len)\n\n    def is_substring(a, b):\n        return a in b\n\n    def check_order(order):\n        for i in range(1, len(order)):\n            for j in range(i):\n                if not is_substring(order[j], order[i]):\n                    return False\n        return True\n\n    if check_order(strings):\n        print(\"YES\")\n        for s in strings:\n            print(s)\n    else:\n        print(\"NO\")\n\nsolve()\n```",
    "83": "```python\ndef solve():\n    a, b = map(int, input().split())\n    total = a + b\n    \n    min_perimeter = float('inf')\n    \n    for h in range(1, int(total**0.5) + 1):\n        if total % h == 0:\n            w = total // h\n            \n            # Case 1: Red rectangle\n            for h_a in range(1, int(a**0.5) + 1):\n                if a % h_a == 0:\n                    w_a = a // h_a\n                    if h_a <= h and w_a <= w:\n                        min_perimeter = min(min_perimeter, 2 * (h + w))\n                    if h_a <= w and w_a <= h:\n                        min_perimeter = min(min_perimeter, 2 * (h + w))\n                        \n            # Case 2: Blue rectangle\n            for h_b in range(1, int(b**0.5) + 1):\n                if b % h_b == 0:\n                    w_b = b // h_b\n                    if h_b <= h and w_b <= w:\n                        min_perimeter = min(min_perimeter, 2 * (h + w))\n                    if h_b <= w and w_b <= h:\n                        min_perimeter = min(min_perimeter, 2 * (h + w))\n\n    print(min_perimeter)\n\nsolve()\n```",
    "84": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    sorted_s = sorted(s)\n\n    for i in range(1 << n):\n        coloring = \"\"\n        s0 = \"\"\n        s1 = \"\"\n        \n        for j in range(n):\n            if (i >> j) & 1:\n                coloring += \"1\"\n                s1 += s[j]\n            else:\n                coloring += \"0\"\n                s0 += s[j]\n\n        s0_sorted = \"\".join(sorted(s0))\n        s1_sorted = \"\".join(sorted(s1))\n\n        merged = \"\"\n        idx0 = 0\n        idx1 = 0\n\n        possible = True\n        for j in range(n):\n            if coloring[j] == '0':\n                if idx0 >= len(s0_sorted):\n                    possible = False\n                    break\n                merged += s0_sorted[idx0]\n                idx0 += 1\n            else:\n                if idx1 >= len(s1_sorted):\n                    possible = False\n                    break\n                merged += s1_sorted[idx1]\n                idx1 += 1\n\n        if not possible:\n            continue\n\n        if \"\".join(sorted_s) == merged:\n            print(\"YES\")\n            print(coloring)\n            return\n\n    print(\"NO\")\n\nsolve()\n```",
    "85": "```python\ndef solve():\n    A, B = map(int, input().split())\n\n    ans = -1\n    for price in range(1, 2000):\n        tax_8 = int(price * 0.08)\n        tax_10 = int(price * 0.10)\n\n        if tax_8 == A and tax_10 == B:\n            ans = price\n            break\n\n    print(ans)\n\nsolve()\n```",
    "86": "```python\ndef solve():\n    n, k = map(int, input().split())\n\n    if k * (k + 1) // 2 > n:\n        print(\"NO\")\n        return\n\n    a = [i + 1 for i in range(k)]\n    remaining = n - sum(a)\n\n    add = remaining // k\n    rem = remaining % k\n\n    for i in range(k):\n        a[i] += add\n\n    for i in range(k):\n        if i < rem:\n            a[k - 1 - i] += 1\n\n    for i in range(k - 1):\n        if not (a[i] < a[i+1] <= 2 * a[i]):\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(*a)\n\nsolve()\n```",
    "88": "```python\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    counts = {}\n    for x in a:\n        counts[x] = counts.get(x, 0) + 1\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    def find_solution():\n        \n        def is_valid():\n            for i in range(n):\n                for j in range(n):\n                    if matrix[i][j] != matrix[n-1-i][j] or matrix[i][j] != matrix[i][n-1-j]:\n                        return False\n            return True\n\n        def solve_recursive(row, col):\n            if row == (n + 1) // 2:\n                return is_valid()\n            \n            if col == (n + 1) // 2:\n                return solve_recursive(row + 1, 0)\n            \n            for val in sorted(list(counts.keys())):\n                if counts[val] > 0:\n                    \n                    need = 1\n                    if row != n - 1 - row:\n                        need += 1\n                    if col != n - 1 - col:\n                        need += 1\n                    if row != n - 1 - row and col != n - 1 - col:\n                        need += 1\n                    \n                    if counts[val] >= need:\n                        \n                        matrix[row][col] = val\n                        matrix[n-1-row][col] = val\n                        matrix[row][n-1-col] = val\n                        matrix[n-1-row][n-1-col] = val\n                        \n                        counts[val] -= need\n\n                        if solve_recursive(row, col + 1):\n                            return True\n\n                        counts[val] += need\n                        matrix[row][col] = 0\n                        matrix[n-1-row][col] = 0\n                        matrix[row][n-1-col] = 0\n                        matrix[n-1-row][n-1-col] = 0\n            return False\n\n        return solve_recursive(0, 0)\n\n    if find_solution():\n        print(\"YES\")\n        for row in matrix:\n            print(*row)\n    else:\n        print(\"NO\")\n\nsolve()\n```",
    "90": "```python\ndef solve():\n    n, m, d = map(int, input().split())\n    c = list(map(int, input().split()))\n    \n    total_length = sum(c)\n    arr = [0] * n\n    \n    pos = 0\n    remaining = n\n    \n    for i in range(m):\n        needed = min(remaining - total_length, d - 1)\n        pos += needed\n        remaining -= needed\n        \n        for j in range(c[i]):\n            arr[pos] = i + 1\n            pos += 1\n        remaining -= c[i]\n        total_length -= c[i]\n        \n    if remaining < 0:\n        print(\"NO\")\n        return\n\n    if total_length > 0:\n        print(\"NO\")\n        return\n    \n    \n    \n    \n    reachable = False\n    \n    def check_reachable(arrangement):\n        \n        curr_pos = 0\n        \n        \n        while curr_pos < n:\n            \n            next_pos = -1\n            for i in range(curr_pos + 1, min(curr_pos + d + 1, n + 1)):\n                if i == n:\n                    \n                    return True\n                \n                if arrangement[i-1] != 0:\n                    next_pos = i\n                    \n            if next_pos == -1:\n                return False\n            \n            curr_pos = next_pos\n        \n        return True\n\n    if check_reachable(arr):\n        print(\"YES\")\n        print(*arr)\n    else:\n        print(\"NO\")\n\nsolve()\n```",
    "91": "```python\ndef solve():\n  s = input()\n  t = input()\n  n = len(s)\n  m = len(t)\n  \n  ans = 0\n  for i in range(n + 1):\n    for j in range(i, n + 1):\n      temp_s = \"\"\n      if i > 0:\n        temp_s += s[:i]\n      if j < n:\n        temp_s += s[j:]\n        \n      \n      ti = 0\n      tsi = 0\n      \n      is_subsequence = True\n      while ti < m and tsi < len(temp_s):\n        if t[ti] == temp_s[tsi]:\n          ti += 1\n          tsi += 1\n        else:\n          tsi += 1\n      \n      if ti == m:\n        ans = max(ans, j - i)\n  print(ans)\n  \nsolve()\n```",
    "92": "```python\nx = float(input())\na = int((x * 10) % 10) + 1\nb = int((x * 100) % 10) + 1\nprint(a, b)\n```",
    "93": "```python\ndef solve():\n    n, d, k = map(int, input().split())\n\n    if d >= n:\n        print(\"NO\")\n        return\n\n    if d == 1:\n        if n > 2 and k < 2:\n            print(\"NO\")\n            return\n        if k == 1 and n > 2:\n            print(\"NO\")\n            return\n        if n > k:\n            print(\"NO\")\n            return\n    elif d > n -1 :\n        print(\"NO\")\n        return\n    elif d > 1 and k == 1:\n        print(\"NO\")\n        return\n    \n    if d > 1 and n == 2:\n        print(\"NO\")\n        return\n\n    edges = []\n    \n    # Create the diameter path\n    for i in range(d):\n        edges.append((i + 1, i + 2))\n    \n    degree = [0] * (n + 1)\n    for u, v in edges:\n        degree[u] += 1\n        degree[v] += 1\n\n    next_node = d + 2\n    \n    # Add nodes to the diameter path until we reach n nodes\n    for i in range(1, d + 2):\n        while degree[i] < k and next_node <= n:\n            edges.append((i, next_node))\n            degree[i] += 1\n            degree[next_node] += 1\n            next_node += 1\n    \n    if next_node <= n:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    for u, v in edges:\n        print(u, v)\n\nsolve()\n```",
    "94": "```python\na, b, x = map(int, input().split())\n\nif a > b:\n  start = 0\n  s = ''\n  for i in range(x):\n    if i % 2 == 0:\n      s += '0'\n      a -= 1\n    else:\n      s += '1'\n      b -= 1\n  if x % 2 == 0:\n    s += '0' * a\n    s += '1' * b\n  else:\n    s += '1' * b\n    s += '0' * a\nelse:\n  start = 1\n  s = ''\n  for i in range(x):\n    if i % 2 == 0:\n      s += '1'\n      b -= 1\n    else:\n      s += '0'\n      a -= 1\n  if x % 2 == 0:\n    s += '1' * b\n    s += '0' * a\n  else:\n    s += '0' * a\n    s += '1' * b\n\nprint(s)\n```",
    "95": "```python\ndef solve():\n    n = int(input())\n    s = input()\n    t = input()\n\n    def check(candidate):\n        if s in candidate or t in candidate:\n            return False\n        return True\n\n    base_patterns = [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n\n    for pattern in base_patterns:\n        candidate = pattern * n\n        if check(candidate):\n            print(\"YES\")\n            print(candidate)\n            return\n\n    \n    alt_patterns = [\"acbbac\", \"bacbac\", \"cabcab\", \"abcbca\", \"bcabac\", \"cbacba\", \"acbacb\", \"bacabc\", \"cbacab\", \"abcacb\", \"bcabca\", \"cabacb\", \"acbcba\", \"bacbca\", \"cbacab\", \"abcabc\", \"bcbcba\", \"cacbac\"]\n    \n    if n == 2:\n        for pattern in alt_patterns:\n            if len(pattern) == 6 and check(pattern):\n                print(\"YES\")\n                print(pattern)\n                return\n    \n    if n == 3:\n      alt_patterns_3 = [\"cacbacbab\", \"abcabcabc\", \"acbacbacb\", \"bacbacbac\"]\n      for pattern in alt_patterns_3:\n          if check(pattern):\n              print(\"YES\")\n              print(pattern)\n              return\n    \n    print(\"NO\")\n\nsolve()\n```",
    "96": "```python\ndef solve():\n    n = int(input())\n    q = list(map(int, input().split()))\n\n    for first_element in range(1, n + 1):\n        p = [first_element]\n        \n        for i in range(n - 1):\n            next_element = p[-1] + q[i]\n            p.append(next_element)\n        \n        if all(1 <= x <= n for x in p) and len(set(p)) == n:\n            print(*p)\n            return\n                \n    print(-1)\n\nsolve()\n```",
    "98": "```python\ndef solve():\n    n = int(input())\n    \n    best_moves = float('inf')\n    \n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            j = n // i\n            moves = (i - 1) + (j - 1)\n            best_moves = min(best_moves, moves)\n            \n    print(best_moves)\n\nsolve()\n```",
    "99": "```python\ndef solve():\n    n = int(input())\n    a1, a2, a3 = map(int, input().split())\n    b1, b2, b3 = map(int, input().split())\n\n    min_wins = 0\n    \n    rem_a1 = a1\n    rem_a2 = a2\n    rem_a3 = a3\n    rem_b1 = b1\n    rem_b2 = b2\n    rem_b3 = b3\n\n    min_wins = max(0, a1 - (b1 + b3 - n + a1), a2 - (b2 + b1 - n + a2), a3 - (b3 + b2 - n + a3))\n    min_wins = max(0, a1 - (n - a1 - a2 + a2), a2 - (n - a2 - a3 + a3), a3 - (n - a3 - a1 + a1))\n    min_wins = max(0, a1 - (b1 + b3 - (a1+a2+a3) + a1), a2 - (b2 + b1- (a1+a2+a3) + a2), a3 - (b3 + b2 - (a1+a2+a3) + a3))\n    min_wins = max(0, a1 - (b1 + b3 - (a2+a3)), a2 - (b2 + b1- (a1+a3)), a3 - (b3 + b2 - (a1+a2)))\n\n    max_wins = min(a1, b2) + min(a2, b3) + min(a3, b1)\n\n    print(min_wins, max_wins)\n\nsolve()\n```"
}