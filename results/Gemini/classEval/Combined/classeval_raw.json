{
    "0": "```python\nimport logging\nimport datetime\n\nclass AccessGatewayFilter:\n    \"\"\"\n    This class is a filter used for accessing gateway filtering, primarily for authentication and access log recording.\n    \"\"\"\n\n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n        self.access_level = 3\n\n    def filter(self, request):\n        \"\"\"\n        Filter the incoming request based on certain rules and conditions.\n        :param request: dict, the incoming request details\n        :return: bool, True if the request is allowed, False otherwise\n        \"\"\"\n        path = request.get('path')\n        if self.is_start_with(path):\n            return True\n\n        auth_header = request.get('headers', {}).get('Authorization')\n        if auth_header:\n            user = auth_header.get('user')\n            jwt_token = auth_header.get('jwt')\n\n            if user and jwt_token:\n                jwt_user = self.get_jwt_user(request)\n                if jwt_user:\n                    user_level = user.get('level')\n                    if user_level is not None:\n                        if user_level > self.access_level:\n                            return True\n                        elif user_level == self.access_level:\n                            return True\n                        else:\n                            return None\n                    else:\n                        return True\n                else:\n                    return True\n            else:\n                return True\n        return False\n\n    def is_start_with(self, request_uri):\n        \"\"\"\n        Check if the request URI starts with certain prefixes.\n        Currently, the prefixes being checked are \"/api\" and \"/login\".\n        :param request_uri: str, the URI of the request\n        :return: bool, True if the URI starts with certain prefixes, False otherwise\n        \"\"\"\n        if not request_uri:\n            return False\n        return request_uri.startswith('/api') or request_uri.startswith('/login')\n\n    def get_jwt_user(self, request):\n        \"\"\"\n        Get the user information from the JWT token in the request.\n        :param request: dict, the incoming request details\n        :return: dict or None, the user information if the token is valid, None otherwise\n        \"\"\"\n        auth_header = request.get('headers', {}).get('Authorization')\n        if auth_header:\n            user = auth_header.get('user')\n            jwt_token = auth_header.get('jwt')\n            if user and jwt_token:\n                expected_jwt = user['name'] + str(datetime.date.today())\n                if jwt_token == expected_jwt:\n                    return user\n        return None\n\n    def set_current_user_info_and_log(self, user):\n        \"\"\"\n        Set the current user information and log the access.\n        :param user: dict, the user information\n        :return: None\n        \"\"\"\n        if user:\n            user_name = user.get('name', 'Unknown')\n            user_address = user.get('address', 'Unknown')\n            log_message = f\"User '{user_name}' from address '{user_address}' accessed the gateway.\"\n            self.logger.info(log_message)\n        else:\n            self.logger.warning(\"Attempted to set user info and log with empty user data.\")\n```",
    "1": "```python\nimport math\nclass AreaCalculator:\n    \"\"\"\n    This is a class for calculating the area of different shapes, including circle, sphere, cylinder, sector and annulus.\n    \"\"\"\n\n\n    def __init__(self, radius):\n        \"\"\"\n        Initialize the radius for shapes.\n        :param radius: float\n        \"\"\"\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        \"\"\"\n        calculate the area of circle based on self.radius\n        :return: area of circle, float\n        \"\"\"\n        return math.pi * self.radius**2\n\n    def calculate_sphere_area(self):\n        \"\"\"\n        calculate the area of sphere based on self.radius\n        :return: area of sphere, float\n        \"\"\"\n        return 4 * math.pi * self.radius**2\n\n    def calculate_cylinder_area(self, height):\n        \"\"\"\n        calculate the area of cylinder based on self.radius and height\n        :param height: height of cylinder, float\n        :return: area of cylinder, float\n        \"\"\"\n        return 2 * math.pi * self.radius * height + 2 * math.pi * self.radius**2\n\n    def calculate_sector_area(self, angle):\n        \"\"\"\n        calculate the area of sector based on self.radius and angle\n        :param angle: angle of sector, float\n        :return: area of sector, float\n        \"\"\"\n        return 0.5 * self.radius**2 * angle\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        \"\"\"\n        calculate the area of annulus based on inner_radius and out_radius\n        :param inner_radius: inner radius of sector, float\n        :param outer_radius: outer radius of sector, float\n        :return: area of annulus, float\n        \"\"\"\n        return math.pi * (outer_radius**2 - inner_radius**2)\n```",
    "2": "```python\nclass ArgumentParser:\n    \"\"\"\n    This is a class for parsing command line arguments to a dictionary.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the fields.\n        self.arguments is a dict that stores the args in a command line\n        self.requried is a set that stores the required arguments\n        self.types is a dict that stores type of every arguments.\n        \"\"\"\n        self.arguments = {}\n        self.required = set()\n        self.types = {}\n\n    def parse_arguments(self, command_string):\n        \"\"\"\n        Parses the given command line argument string and stores the parsed result in the arguments dictionary.\n        Checks for missing required arguments, if any, and returns False with the missing argument names, otherwise returns True.\n        :param command_string: str, command line argument string, formatted like \"python script.py --arg1=value1 -arg2 value2 --option1 -option2\"\n        :return tuple: (True, None) if parsing is successful, (False, missing_args) if parsing fails,\n            where missing_args is a set of the missing argument names which are str.\n        \"\"\"\n        args = command_string.split()\n        i = 1\n        while i < len(args):\n            arg = args[i]\n            if arg.startswith(\"--\"):\n                arg_name = arg[2:].split(\"=\")[0]\n                if \"=\" in arg:\n                    arg_value = arg[2:].split(\"=\")[1]\n                    self.arguments[arg_name] = self._convert_type(arg_name, arg_value)\n                else:\n                    self.arguments[arg_name] = True\n            elif arg.startswith(\"-\"):\n                arg_name = arg[1:]\n                if i + 1 < len(args) and not args[i + 1].startswith(\"-\"):\n                    arg_value = args[i + 1]\n                    self.arguments[arg_name] = self._convert_type(arg_name, arg_value)\n                    i += 1\n                else:\n                    self.arguments[arg_name] = True\n            i += 1\n\n        missing_args = self.required - set(self.arguments.keys())\n        if missing_args:\n            return False, missing_args\n        else:\n            return True, None\n\n    def get_argument(self, key):\n        \"\"\"\n        Retrieves the value of the specified argument from the arguments dictionary and returns it.\n        :param key: str, argument name\n        :return: The value of the argument, or None if the argument does not exist.\n        \"\"\"\n        return self.arguments.get(key)\n\n    def add_argument(self, arg, required=False, arg_type=str):\n        \"\"\"\n        Adds an argument to self.types and self.required.\n        Check if it is a required argument and store the argument type.\n        If the argument is set as required, it will be added to the required set.\n        The argument type and name are stored in the types dictionary as key-value pairs.\n        :param arg: str, argument name\n        :param required: bool, whether the argument is required, default is False\n        :param arg_type:str, Argument type, default is str\n        \"\"\"\n        self.types[arg] = arg_type\n        if required:\n            self.required.add(arg)\n\n    def _convert_type(self, arg, value):\n        \"\"\"\n        Try to convert the type of input value by searching in self.types.\n        :param value: str, the input value in command line\n        :return: return corresponding value in self.types if convert successfully, or the input value oherwise\n        \"\"\"\n        arg_type = self.types.get(arg)\n        if arg_type:\n            try:\n                if arg_type == int:\n                    return int(value)\n                elif arg_type == float:\n                    return float(value)\n                elif arg_type == bool:\n                    return value.lower() == 'true' or value == ''\n                else:\n                    return value\n            except ValueError:\n                return value\n        return value\n```",
    "3": "```python\nimport itertools\n\nclass ArrangementCalculator:\n    \"\"\"\n    The Arrangement class provides permutation calculations and selection operations for a given set of data elements.\n    \"\"\"\n\n    def __init__(self, datas):\n        \"\"\"\n        Initializes the ArrangementCalculator object with a list of datas.\n        :param datas: List, the data elements to be used for arrangements.\n        \"\"\"\n        self.datas = datas\n\n    @staticmethod\n    def count(n, m=None):\n        \"\"\"\n        Counts the number of arrangements by choosing m items from n items (permutations).\n        If m is not provided or n equals m, returns factorial(n).\n        :param n: int, the total number of items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: int, the count of arrangements.\n        \"\"\"\n        if m is None or n == m:\n            return ArrangementCalculator.factorial(n)\n        elif m > n:\n            return 0\n        else:\n            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n):\n        \"\"\"\n        Counts the total number of all possible arrangements by choosing at least 1 item and at most n items from n items.\n        :param n: int, the total number of items.\n        :return: int, the count of all arrangements.\n        \"\"\"\n        total_arrangements = 0\n        for i in range(1, n + 1):\n            total_arrangements += ArrangementCalculator.count(n, i)\n        return total_arrangements\n\n\n    def select(self, m=None):\n        \"\"\"\n        Generates a list of arrangements by selecting m items from the internal datas.\n        If m is not provided, selects all items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: List, a list of arrangements.\n        \"\"\"\n        if m is None:\n            m = len(self.datas)\n\n        arrangements = []\n        for permutation in itertools.permutations(self.datas, m):\n            arrangements.append(list(permutation))\n        return arrangements\n\n\n    def select_all(self):\n        \"\"\"\n        Generates a list of all arrangements by selecting at least 1 item and at most the number of internal datas.\n        :return: List, a list of all arrangements.\n        \"\"\"\n        all_arrangements = []\n        for i in range(1, len(self.datas) + 1):\n            for permutation in itertools.permutations(self.datas, i):\n                all_arrangements.append(list(permutation))\n        return all_arrangements\n\n\n    @staticmethod\n    def factorial(n):\n        \"\"\"\n        Calculates the factorial of a given number.\n        :param n: int, the number to calculate the factorial.\n        :return: int, the factorial of the given number.\n        \"\"\"\n        if n == 0:\n            return 1\n        elif n < 0:\n            return 0\n        else:\n            result = 1\n            for i in range(1, n + 1):\n                result *= i\n            return result\n```",
    "4": "```python\nclass AssessmentSystem:\n    \"\"\"\n    This is a class as an student assessment system, which supports add student, add course score, calculate GPA, and other functions for students and courses.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the students dict in assessment system.\n        \"\"\"\n        self.students = {}\n\n    def add_student(self, name, grade, major):\n        \"\"\"\n        Add a new student into self.students dict\n        :param name: str, student name\n        :param grade: int, student grade\n        :param major: str, student major\n        \"\"\"\n        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}\n\n    def add_course_score(self, name, course, score):\n        \"\"\"\n        Add score of specific course for student in self.students\n        :param name: str, student name\n        :param course: str, course name\n        :param score: int, course score\n        \"\"\"\n        if name in self.students:\n            self.students[name]['courses'][course] = score\n\n    def get_gpa(self, name):\n        \"\"\"\n        Get average grade of one student.\n        :param name: str, student name\n        :return: if name is in students and this students have courses grade, return average grade(float)\n                    or None otherwise\n        \"\"\"\n        student_data = self.students.get(name)\n        if student_data and student_data['courses']:\n            total_score = sum(student_data['courses'].values())\n            return float(total_score) / len(student_data['courses'])\n        return None\n\n    def get_all_students_with_fail_course(self):\n        \"\"\"\n        Get all students who have any score blow 60\n        :return: list of str ,student name\n        \"\"\"\n        failed_students = []\n        for name, student_data in self.students.items():\n            for score in student_data['courses'].values():\n                if score < 60:\n                    failed_students.append(name)\n                    break  # Only add the student once if they have multiple failing grades\n        return failed_students\n\n    def get_course_average(self, course):\n        \"\"\"\n        Get the average score of a specific course.\n        :param course: str, course name\n        :return: float, average scores of this course if anyone have score of this course, or None if nobody have records.\n        \"\"\"\n        total_score = 0\n        student_count = 0\n        for student_data in self.students.values():\n            score = student_data['courses'].get(course)\n            if score is not None:\n                total_score += score\n                student_count += 1\n\n        if student_count > 0:\n            return float(total_score) / student_count\n        return None\n\n    def get_top_student(self):\n        \"\"\"\n        Calculate every student's gpa with get_gpa method, and find the student with highest gpa\n        :return: str, name of student whose gpa is highest\n        \"\"\"\n        top_student = None\n        highest_gpa = None\n\n        for name in self.students:\n            gpa = self.get_gpa(name)\n            if gpa is not None:\n                if highest_gpa is None or gpa > highest_gpa:\n                    highest_gpa = gpa\n                    top_student = name\n\n        return top_student\n```",
    "5": "```python\nclass AutomaticGuitarSimulator:\n    def __init__(self, text):\n        \"\"\"\n        Initializes the AutomaticGuitarSimulator with the given text.\n\n        Args:\n            text (str): The text representing the guitar score.\n        \"\"\"\n        self.play_text = text\n\n    def interpret(self, display=False):\n        \"\"\"\n        Interprets the guitar score and returns a list of dictionaries,\n        where each dictionary contains the chord and tune.\n\n        Args:\n            display (bool, optional): Whether to display the interpreted score. Defaults to False.\n\n        Returns:\n            list: A list of dictionaries, where each dictionary has 'Chord' and 'Tune' keys.\n                   Returns an empty list if the input text is empty or contains only whitespace.\n        \"\"\"\n        if not self.play_text or self.play_text.isspace():\n            return []\n\n        play_list = []\n        parts = self.play_text.split()\n\n        for part in parts:\n            chord = ''.join(filter(str.isalpha, part))\n            tune = ''.join(filter(str.isdigit, part))\n            play_list.append({'Chord': chord, 'Tune': tune})\n\n        if display:\n            for item in play_list:\n                print(self.display(item['Chord'], item['Tune']))\n\n        return play_list\n\n    def display(self, key, value):\n        \"\"\"\n        Formats and returns a string representing the chord and tune.\n\n        Args:\n            key (str): The chord.\n            value (str): The tune.\n\n        Returns:\n            str: A formatted string representing the chord and tune.\n        \"\"\"\n        return f\"Normal Guitar Playing -- Chord: {key}, Play Tune: {value}\"\n```",
    "6": "```python\nclass AvgPartition:\n    \"\"\"\n    Partitions a list into approximately equal-sized blocks.\n    \"\"\"\n\n    def __init__(self, lst, limit):\n        \"\"\"\n        Initializes the partitioner.\n\n        Args:\n            lst: The list to partition.\n            limit: The desired number of partitions.\n        \"\"\"\n        if not isinstance(lst, list):\n            raise TypeError(\"lst must be a list\")\n        if not isinstance(limit, int):\n            raise TypeError(\"limit must be an integer\")\n        if limit <= 0:\n            raise ValueError(\"limit must be greater than 0\")\n\n        self.lst = lst\n        self.limit = limit\n\n    def setNum(self):\n        \"\"\"\n        Calculates the base block size and the number of elements in the remainder.\n\n        Returns:\n            A tuple containing the base block size and the remainder.\n        \"\"\"\n        block_size = len(self.lst) // self.limit\n        remainder = len(self.lst) % self.limit\n        return (block_size, remainder)\n\n    def get(self, index):\n        \"\"\"\n        Retrieves a specific partition.\n\n        Args:\n            index: The index of the partition to retrieve (0-based).\n\n        Returns:\n            A list representing the requested partition.\n\n        Raises:\n            IndexError: If the index is out of bounds.\n        \"\"\"\n        if not isinstance(index, int):\n            raise TypeError(\"Index must be an integer\")\n        if index < 0 or index >= self.limit:\n            raise IndexError(\"Index out of bounds\")\n\n        block_size, remainder = self.setNum()\n        start = index * block_size + min(index, remainder)\n        end = (index + 1) * block_size + min(index + 1, remainder)\n        return self.lst[start:end]\n```",
    "7": "```python\nclass BalancedBrackets:\n    \"\"\"\n    This is a class that checks for bracket matching\n    \"\"\"\n\n    def __init__(self, expr):\n        \"\"\"\n        Initializes the class with an expression.\n        :param expr: The expression to check for balanced brackets,str.\n        \"\"\"\n        self.stack = []\n        self.left_brackets = [\"(\", \"{\", \"[\"]\n        self.right_brackets = [\")\", \"}\", \"]\"]\n        self.expr = expr\n\n    def clear_expr(self):\n        \"\"\"\n        Clears the expression of all characters that are not brackets.\n        >>> b = BalancedBrackets(\"a(b)c\")\n        >>> b.clear_expr()\n        >>> b.expr\n        '()'\n\n        \"\"\"\n        self.expr = \"\".join(char for char in self.expr if char in self.left_brackets or char in self.right_brackets)\n\n    def check_balanced_brackets(self):\n        \"\"\"\n        Checks if the expression has balanced brackets.\n        :return: True if the expression has balanced brackets, False otherwise.\n        >>> b = BalancedBrackets(\"a(b)c\")\n        >>> b.check_balanced_brackets()\n        True\n\n        \"\"\"\n        self.clear_expr()\n        stack = []\n        bracket_map = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n        for char in self.expr:\n            if char in self.left_brackets:\n                stack.append(char)\n            elif char in self.right_brackets:\n                if not stack:\n                    return False\n                top = stack.pop()\n                if bracket_map[char] != top:\n                    return False\n        return not stack\n```",
    "8": "```python\nclass BankAccount:\n    \"\"\"\n    This is a class as a bank account system, which supports deposit money, withdraw money, view balance, and transfer money.\n    \"\"\"\n\n    def __init__(self, balance=0):\n        \"\"\"\n        Initializes a bank account object with an attribute balance, default value is 0.\n        \"\"\"\n        self.balance = balance\n\n    def deposit(self, amount):\n        \"\"\"\n        Deposits a certain amount into the account, increasing the account balance, return the current account balance.\n        If amount is negative, raise a ValueError(\"Invalid amount\").\n        :param amount: int\n        \"\"\"\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        self.balance += amount\n        return self.balance\n\n    def withdraw(self, amount):\n        \"\"\"\n        Withdraws a certain amount from the account, decreasing the account balance, return the current account balance.\n        If amount is negative, raise a ValueError(\"Invalid amount\").\n        If the withdrawal amount is greater than the account balance, raise a ValueError(\"Insufficient balance.\").\n        :param amount: int\n        \"\"\"\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        if amount > self.balance:\n            raise ValueError(\"Insufficient balance.\")\n        self.balance -= amount\n        return self.balance\n\n    def view_balance(self):\n        \"\"\"\n        Return the account balance.\n        \"\"\"\n        return self.balance\n\n    def transfer(self, other_account, amount):\n        \"\"\"\n        Transfers a certain amount from the current account to another account.\n        :param other_account: BankAccount\n        :param amount: int\n        \"\"\"\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        if amount > self.balance:\n            raise ValueError(\"Insufficient balance.\")\n        self.withdraw(amount)\n        other_account.deposit(amount)\n```",
    "9": "```python\nclass BigNumCalculator:\n    \"\"\"\n    This is a class that implements big number calculations, including adding, subtracting and multiplying.\n    \"\"\"\n\n    @staticmethod\n    def add(num1, num2):\n        \"\"\"\n        Adds two big numbers.\n        :param num1: The first number to add,str.\n        :param num2: The second number to add,str.\n        :return: The sum of the two numbers,str.\n        \"\"\"\n        num1 = num1.lstrip('0') or '0'\n        num2 = num2.lstrip('0') or '0'\n\n        n1 = len(num1)\n        n2 = len(num2)\n\n        if n1 < n2:\n            num1, num2 = num2, num1\n            n1, n2 = n2, n1\n\n        result = []\n        carry = 0\n\n        for i in range(n1 - 1, -1, -1):\n            digit1 = int(num1[i])\n            digit2 = int(num2[i - (n1 - n2)]) if i >= (n1 - n2) else 0\n\n            digit_sum = digit1 + digit2 + carry\n            result.append(str(digit_sum % 10))\n            carry = digit_sum // 10\n\n        if carry:\n            result.append(str(carry))\n\n        return ''.join(result[::-1])\n\n    @staticmethod\n    def subtract(num1, num2):\n        \"\"\"\n        Subtracts two big numbers.\n        :param num1: The first number to subtract,str.\n        :param num2: The second number to subtract,str.\n        :return: The difference of the two numbers,str.\n        \"\"\"\n        num1 = num1.lstrip('0') or '0'\n        num2 = num2.lstrip('0') or '0'\n\n        sign = \"\"\n        if len(num1) < len(num2) or (len(num1) == len(num2) and num1 < num2):\n            num1, num2 = num2, num1\n            sign = \"-\"\n\n        n1 = len(num1)\n        n2 = len(num2)\n        result = []\n        borrow = 0\n\n        for i in range(n1 - 1, -1, -1):\n            digit1 = int(num1[i])\n            digit2 = int(num2[i - (n1 - n2)]) if i >= (n1 - n2) else 0\n\n            diff = digit1 - digit2 - borrow\n            if diff < 0:\n                diff += 10\n                borrow = 1\n            else:\n                borrow = 0\n            result.append(str(diff))\n\n        res = sign + ''.join(result[::-1]).lstrip('0')\n        return res or '0'\n\n    @staticmethod\n    def multiply(num1, num2):\n        \"\"\"\n        Multiplies two big numbers.\n        :param num1: The first number to multiply,str.\n        :param num2: The second number to multiply,str.\n        :return: The product of the two numbers,str.\n        \"\"\"\n        num1 = num1.lstrip('0')\n        num2 = num2.lstrip('0')\n\n        if not num1 or not num2:\n            return \"0\"\n\n        n1 = len(num1)\n        n2 = len(num2)\n        product = [0] * (n1 + n2)\n\n        for i in range(n1 - 1, -1, -1):\n            carry = 0\n            for j in range(n2 - 1, -1, -1):\n                product[i + j + 1] += int(num1[i]) * int(num2[j]) + carry\n                carry = product[i + j + 1] // 10\n                product[i + j + 1] %= 10\n            product[i] += carry\n\n        result = \"\".join(map(str, product))\n        return result.lstrip('0') or '0'\n```",
    "10": "```python\nclass BinaryDataProcessor:\n    \"\"\"\n    This is a class used to process binary data, which includes functions such as clearing non 0 or 1 characters, counting binary string information, and converting to corresponding strings based on different encoding methods.\n    \"\"\"\n\n    def __init__(self, binary_string):\n        \"\"\"\n        Initialize the class with a binary string and clean it by removing all non 0 or 1 characters.\n        \"\"\"\n        self.binary_string = binary_string\n        self.clean_non_binary_chars()\n\n    def clean_non_binary_chars(self):\n        \"\"\"\n        Clean the binary string by removing all non 0 or 1 characters.\n        >>> bdp = BinaryDataProcessor(\"01101000daf3e4r01100101011011000110110001101111\")\n        >>> bdp.clean_non_binary_chars()\n        >>> bdp.binary_string\n        '0110100001100101011011000110110001101111'\n\n        \"\"\"\n        self.binary_string = ''.join(char for char in self.binary_string if char in '01')\n\n    def calculate_binary_info(self):\n        \"\"\"\n        Calculate the binary string information, including the percentage of 0 and 1, and the total length of the binary string.\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.calculate_binary_info()\n        {'Zeroes': 0.475, 'Ones': 0.525, 'Bit length': 40}\n\n        \"\"\"\n        bit_length = len(self.binary_string)\n        if bit_length == 0:\n            return {'Zeroes': 0, 'Ones': 0, 'Bit length': 0}\n\n        zeroes = self.binary_string.count('0')\n        ones = self.binary_string.count('1')\n        zeroes_percentage = zeroes / bit_length\n        ones_percentage = ones / bit_length\n\n        return {'Zeroes': zeroes_percentage, 'Ones': ones_percentage, 'Bit length': bit_length}\n\n    def convert_to_ascii(self):\n        \"\"\"\n        Convert the binary string to ascii string.\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.convert_to_ascii()\n        'hello'\n\n        \"\"\"\n        ascii_string = \"\"\n        for i in range(0, len(self.binary_string), 8):\n            binary_octet = self.binary_string[i:i + 8]\n            if len(binary_octet) == 8:\n                decimal_value = int(binary_octet, 2)\n                ascii_string += chr(decimal_value)\n        return ascii_string\n\n    def convert_to_utf8(self):\n        \"\"\"\n        Convert the binary string to utf-8 string.\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.convert_to_utf8()\n        'hello'\n\n        \"\"\"\n        utf8_string = \"\"\n        for i in range(0, len(self.binary_string), 8):\n            binary_octet = self.binary_string[i:i + 8]\n            if len(binary_octet) == 8:\n                decimal_value = int(binary_octet, 2)\n                utf8_string += chr(decimal_value)\n        return utf8_string\n```",
    "11": "```python\nclass BitStatusUtil:\n    \"\"\"\n    This is a utility class that provides methods for manipulating and checking status using bitwise operations.\n    \"\"\"\n\n    @staticmethod\n    def add(states, stat):\n        \"\"\"\n        Add a status to the current status.\n\n        :param states: Current status, int.\n        :param stat: Status to be added, int.\n        :return: The status after adding the status, int.\n        \"\"\"\n        return states | stat\n\n    @staticmethod\n    def has(states, stat):\n        \"\"\"\n        Check if the current status contains the specified status.\n\n        :param states: Current status, int.\n        :param stat: Specified status, int.\n        :return: True if the current status contains the specified status, otherwise False, bool.\n        \"\"\"\n        return (states & stat) == stat\n\n    @staticmethod\n    def remove(states, stat):\n        \"\"\"\n        Remove the specified status from the current status.\n\n        :param states: Current status, int.\n        :param stat: Specified status, int.\n        :return: The status after removing the specified status, int.\n        \"\"\"\n        return states & ~stat\n\n    @staticmethod\n    def check(args):\n        \"\"\"\n        Check if the parameters are legal. Args must be greater than or equal to 0 and must be even, if not, raise ValueError.\n\n        :param args: Parameters to be checked, list.\n        :return: None.\n        :raises ValueError: If any argument is negative or odd.\n        \"\"\"\n        for arg in args:\n            if arg < 0:\n                raise ValueError(f\"{arg} must be non-negative\")\n            if arg % 2 != 0:\n                raise ValueError(f\"{arg} must be even\")\n```",
    "12": "```python\nimport random\n\nclass BlackjackGame:\n    \"\"\"\n    This is a class representing a game of blackjack, which includes creating a deck, calculating the value of a hand, and determine the winner based on the hand values of the player and dealer.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Blackjack Game with the attribute deck, player_hand and dealer_hand.\n        While initializing deck attribute, call the create_deck method to generate.\n        The deck stores 52 rondom order poker with the Jokers removed, format is ['AS', '2S', ...].\n        player_hand is a list which stores player's hand cards.\n        dealer_hand is is a list which stores dealer's hand cards.\n        \"\"\"\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n\n    def create_deck(self):\n        \"\"\"\n        Create a deck of 52 cards, which stores 52 rondom order poker with the Jokers removed.\n        :return: a list of 52 rondom order poker with the Jokers removed, format is ['AS', '2S', ...].\n        \"\"\"\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n        deck = [rank + suit for suit in suits for rank in ranks]\n        random.shuffle(deck)\n        return deck\n\n    def calculate_hand_value(self, hand):\n        \"\"\"\n        Calculate the value of the poker cards stored in hand list according to the rules of the Blackjack Game.\n        If the card is a digit, its value is added to the total hand value.\n        Value of J, Q, or K is 10, while Aces are worth 11.\n        If the total hand value exceeds 21 and there are Aces present, one Ace is treated as having a value of 1 instead of 11,\n        until the hand value is less than or equal to 21, or all Aces have been counted as value of 1.\n        :param hand: list\n        :return: the value of the poker cards stored in hand list, a number.\n        \"\"\"\n        value = 0\n        num_aces = 0\n        for card in hand:\n            rank = card[:-1]\n            if rank.isdigit():\n                value += int(rank)\n            elif rank in ['J', 'Q', 'K']:\n                value += 10\n            elif rank == 'A':\n                value += 11\n                num_aces += 1\n\n        while value > 21 and num_aces > 0:\n            value -= 10\n            num_aces -= 1\n\n        return value\n\n    def check_winner(self, player_hand, dealer_hand):\n        \"\"\"\n        Determines the winner of a game by comparing the hand values of the player and dealer.\n        rule:\n        If both players have hand values that are equal to or less than 21, the winner is the one whose hand value is closer to 21.\n        Otherwise, the winner is the one with the lower hand value.\n        :param player_hand: list\n        :param dealer_hand: list\n        :return: the result of the game, only two certain str: 'Dealer wins' or 'Player wins'\n        \"\"\"\n        player_value = self.calculate_hand_value(player_hand)\n        dealer_value = self.calculate_hand_value(dealer_hand)\n\n        if player_value > 21 and dealer_value > 21:\n            if player_value < dealer_value:\n                return 'Player wins'\n            else:\n                return 'Dealer wins'\n        elif player_value > 21:\n            return 'Dealer wins'\n        elif dealer_value > 21:\n            return 'Player wins'\n        else:\n            if player_value > dealer_value:\n                return 'Player wins'\n            elif player_value < dealer_value:\n                return 'Dealer wins'\n            else:\n                return 'Dealer wins'\n```",
    "13": "```python\nclass BookManagement:\n    \"\"\"\n    This is a class as managing books system, which supports to add and remove books from the inventory dict, view the inventory, and check the quantity of a specific book.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the inventory of Book Manager.\n        \"\"\"\n        self.inventory = {}\n\n    def add_book(self, title, quantity=1):\n        \"\"\"\n        Add one or several books to inventory which is sorted by book title.\n        :param title: str, the book title\n        :param quantity: int, default value is 1.\n        \"\"\"\n        if not isinstance(title, str):\n            raise TypeError(\"Title must be a string.\")\n        if not isinstance(quantity, int):\n            raise TypeError(\"Quantity must be an integer.\")\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be positive.\")\n\n        if title in self.inventory:\n            self.inventory[title] += quantity\n        else:\n            self.inventory[title] = quantity\n\n    def remove_book(self, title, quantity):\n        \"\"\"\n        Remove one or several books from inventory which is sorted by book title.\n        Raise false while get invalid input.\n        :param title: str, the book title\n        :param quantity: int\n        \"\"\"\n        if not isinstance(title, str):\n            raise TypeError(\"Title must be a string.\")\n        if not isinstance(quantity, int):\n            raise TypeError(\"Quantity must be an integer.\")\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be positive.\")\n\n        if title not in self.inventory:\n            raise Exception(\"Book not found in inventory.\")\n\n        if self.inventory[title] < quantity:\n            raise Exception(\"Not enough books to remove.\")\n\n        self.inventory[title] -= quantity\n        if self.inventory[title] == 0:\n            del self.inventory[title]\n\n    def view_inventory(self):\n        \"\"\"\n        Get the inventory of the Book Management.\n        :return self.inventory: dictionary, {title(str): quantity(int), ...}\n        \"\"\"\n        return self.inventory\n\n    def view_book_quantity(self, title):\n        \"\"\"\n        Get the quantity of a book.\n        :param title: str, the title of the book.\n        :return quantity: the quantity of this book title. return 0 when the title does not exist in self.invenroty\n        \"\"\"\n        if not isinstance(title, str):\n            raise TypeError(\"Title must be a string.\")\n\n        if title in self.inventory:\n            return self.inventory[title]\n        else:\n            return 0\n```",
    "14": "```python\nimport sqlite3\n\nclass BookManagementDB:\n    \"\"\"\n    This is a database class as a book management system, used to handle the operations of adding, removing, updating, and searching books.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the class by creating a database connection and cursor,\n        and creates the book table if it does not already exist.\n        :param db_name: str, the name of db file\n        \"\"\"\n        self.db_name = db_name\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates the book table in the database if it does not already exist.\n        \"\"\"\n        try:\n            self.cursor.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS books (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    title TEXT NOT NULL,\n                    author TEXT NOT NULL,\n                    available INTEGER NOT NULL DEFAULT 1\n                )\n            \"\"\")\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n\n    def add_book(self, title, author):\n        \"\"\"\n        Adds a book to the database with the specified title and author,\n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        \"\"\"\n        try:\n            self.cursor.execute(\"INSERT INTO books (title, author, available) VALUES (?, ?, 1)\", (title, author))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n\n    def remove_book(self, book_id):\n        \"\"\"\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        try:\n            self.cursor.execute(\"DELETE FROM books WHERE id = ?\", (book_id,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n\n    def borrow_book(self, book_id):\n        \"\"\"\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        try:\n            self.cursor.execute(\"UPDATE books SET available = 0 WHERE id = ?\", (book_id,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n\n    def return_book(self, book_id):\n        \"\"\"\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        try:\n            self.cursor.execute(\"UPDATE books SET available = 1 WHERE id = ?\", (book_id,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n\n    def search_books(self):\n        \"\"\"\n        Retrieves all books from the database and returns their information.\n        :return books: list[tuple], the information of all books in database\n        \"\"\"\n        try:\n            self.cursor.execute(\"SELECT * FROM books\")\n            books = self.cursor.fetchall()\n            return books\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n            return []\n\n    def __del__(self):\n        \"\"\"\n        Closes the database connection when the object is deleted.\n        \"\"\"\n        if hasattr(self, 'connection') and self.connection:\n            self.connection.close()\n```",
    "15": "```python\nclass BoyerMooreSearch:\n    \"\"\"\n    This class implements the Boyer-Moore algorithm for string searching, which is used to find occurrences of a pattern within a given text.\n    \"\"\"\n\n    def __init__(self, text, pattern):\n        \"\"\"\n        Initializes the BoyerMooreSearch class with the given text and pattern.\n        :param text: The text to be searched, str.\n        :param pattern: The pattern to be searched for, str.\n        \"\"\"\n        self.text = text\n        self.pattern = pattern\n        self.textLen = len(text)\n        self.patLen = len(pattern)\n\n    def match_in_pattern(self, char):\n        \"\"\"\n        Finds the rightmost occurrence of a character in the pattern.\n        :param char: The character to be searched for, str.\n        :return: The index of the rightmost occurrence of the character in the pattern, int. Returns -1 if the character is not found.\n        \"\"\"\n        for i in range(self.patLen - 1, -1, -1):\n            if self.pattern[i] == char:\n                return i\n        return -1\n\n    def mismatch_in_text(self, currentPos):\n        \"\"\"\n        Determines the position of the first mismatch between the pattern and the text, starting from currentPos in the text.\n        :param currentPos: The current position in the text, int.\n        :return: The position of the first mismatch between the pattern and the text, int. Returns -1 if there is no mismatch.\n        \"\"\"\n        if not self.pattern:\n            return -1\n\n        for i in range(self.patLen):\n            if currentPos + i >= self.textLen:\n                return currentPos + i\n            if self.pattern[i] != self.text[currentPos + i]:\n                return currentPos + i\n        return -1\n\n    def bad_character_heuristic(self):\n        \"\"\"\n        Finds all occurrences of the pattern in the text using the bad character heuristic.\n        :return: A list of all starting positions of the pattern in the text, list.\n        \"\"\"\n        occurrences = []\n        if not self.pattern:\n            return list(range(self.textLen + 1))\n\n        i = 0\n        while i <= (self.textLen - self.patLen):\n            mismatch_pos = self.mismatch_in_text(i)\n            if mismatch_pos == -1:\n                occurrences.append(i)\n                i += 1\n            else:\n                if mismatch_pos >= self.textLen:\n                    break\n                char = self.text[mismatch_pos]\n                pattern_index = self.match_in_pattern(char)\n                if pattern_index == -1:\n                    i = mismatch_pos + 1\n                else:\n                    shift = mismatch_pos - pattern_index\n                    if shift <= 0:\n                        i += 1\n                    else:\n                        i = shift\n        return occurrences\n```",
    "16": "```python\nclass Calculator:\n    \"\"\"\n    This is a class for a calculator, capable of performing basic arithmetic calculations on numerical expressions using the operators +, -, *, /, and ^ (exponentiation).\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the operations performed by the five operators'+','-','*','/','^'\n        \"\"\"\n        self.operators = {\n            '+': lambda x, y: x + y,\n            '-': lambda x, y: x - y,\n            '*': lambda x, y: x * y,\n            '/': lambda x, y: x / y if y != 0 else None,\n            '^': lambda x, y: x ** y\n        }\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the value of a given expression\n        :param expression: string, given expression\n        :return:If successful, returns the value of the expression; otherwise, returns None\n        \"\"\"\n        if not expression:\n            return None\n\n        operand_stack = []\n        operator_stack = []\n        i = 0\n\n        while i < len(expression):\n            char = expression[i]\n\n            if char.isdigit():\n                num = 0\n                while i < len(expression) and expression[i].isdigit():\n                    num = num * 10 + int(expression[i])\n                    i += 1\n                operand_stack.append(float(num))\n                i -= 1\n\n            elif char in self.operators:\n                while operator_stack and operator_stack[-1] != '(' and self.precedence(char) <= self.precedence(operator_stack[-1]):\n                    result = self.apply_operator(operand_stack, operator_stack)\n                    if result is None:\n                        return None\n\n                operator_stack.append(char)\n\n            elif char == '(':\n                operator_stack.append(char)\n\n            elif char == ')':\n                while operator_stack and operator_stack[-1] != '(':\n                    result = self.apply_operator(operand_stack, operator_stack)\n                    if result is None:\n                        return None\n                if operator_stack:\n                    operator_stack.pop()  # Remove the '('\n                else:\n                    return None #Mismatched parentheses\n\n            i += 1\n\n        while operator_stack:\n            result = self.apply_operator(operand_stack, operator_stack)\n            if result is None:\n                return None\n\n        if operand_stack:\n            return operand_stack[0]\n        else:\n            return None\n\n    def precedence(self, operator):\n        \"\"\"\n        Returns the priority of the specified operator, where the higher the priority, the greater the assignment. The priority of '^' is greater than '/' and '*', and the priority of '/' and '*' is greater than '+' and '-'\n        :param operator: string, given operator\n        :return: int, the priority of the given operator, otherwise return 0\n        \"\"\"\n        if operator == '+' or operator == '-':\n            return 1\n        elif operator == '*' or operator == '/':\n            return 2\n        elif operator == '^':\n            return 3\n        return 0\n\n    def apply_operator(self, operand_stack, operator_stack):\n        \"\"\"\n        Use the operator at the top of the operator stack to perform the operation on the two numbers at the top of the operator stack, and store the results at the top of the operator stack\n        :param operand_stack:list\n        :param operator_stack:list\n        :return: the updated operand_stack and operator_stack\n        \"\"\"\n        if not operator_stack or len(operand_stack) < 2:\n            return None\n\n        operator = operator_stack.pop()\n        operand2 = operand_stack.pop()\n        operand1 = operand_stack.pop()\n\n        if operator not in self.operators:\n            return None\n\n        result = self.operators[operator](operand1, operand2)\n\n        if result is None:\n            return None\n\n        operand_stack.append(result)\n        return result\n```",
    "17": "```python\nfrom datetime import datetime, timedelta\n\nclass CalendarUtil:\n    \"\"\"\n    This is a class as CalendarUtil that provides functionalities to manage calendar events, schedule appointments, and perform conflict checks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the calendar with an empty list of events.\n        \"\"\"\n        self.events = []\n\n    def add_event(self, event):\n        \"\"\"\n        Add an event to the calendar.\n        :param event: The event to be added to the calendar,dict.\n        \"\"\"\n        self.events.append(event)\n\n    def remove_event(self, event):\n        \"\"\"\n        Remove an event from the calendar.\n        :param event: The event to be removed from the calendar,dict.\n        \"\"\"\n        try:\n            self.events.remove(event)\n        except ValueError:\n            pass\n\n    def get_events(self, date):\n        \"\"\"\n        Get all events on a given date.\n        :param date: The date to get events for,datetime.\n        :return: A list of events on the given date,list.\n        \"\"\"\n        return [event for event in self.events if event['date'].date() == date.date()]\n\n    def is_available(self, start_time, end_time):\n        \"\"\"\n        Check if the calendar is available for a given time slot.\n        :param start_time: The start time of the time slot,datetime.\n        :param end_time: The end time of the time slot,datetime.\n        :return: True if the calendar is available for the given time slot, False otherwise,bool.\n        \"\"\"\n        for event in self.events:\n            if event['date'].date() == start_time.date():\n                if (start_time < event['end_time'] and end_time > event['start_time']):\n                    return False\n        return True\n\n    def get_available_slots(self, date):\n        \"\"\"\n        Get all available time slots on a given date.\n        :param date: The date to get available time slots for,datetime.\n        :return: A list of available time slots on the given date,list.\n        \"\"\"\n        available_slots = []\n        current_time = datetime.combine(date.date(), datetime.min.time())\n        end_of_day = datetime.combine(date.date(), datetime.max.time())\n\n        sorted_events_for_date = sorted([event for event in self.events if event['date'].date() == date.date()], key=lambda event: event['start_time'])\n\n        if not sorted_events_for_date:\n            available_slots.append((current_time, end_of_day + timedelta(seconds=1)))\n            return available_slots\n\n        if current_time < sorted_events_for_date[0]['start_time']:\n            available_slots.append((current_time, sorted_events_for_date[0]['start_time']))\n\n        for i in range(len(sorted_events_for_date) - 1):\n            if sorted_events_for_date[i]['end_time'] < sorted_events_for_date[i+1]['start_time']:\n                available_slots.append((sorted_events_for_date[i]['end_time'], sorted_events_for_date[i+1]['start_time']))\n\n        if sorted_events_for_date[-1]['end_time'] < end_of_day + timedelta(seconds=1):\n            available_slots.append((sorted_events_for_date[-1]['end_time'], end_of_day + timedelta(seconds=1)))\n\n        return available_slots\n\n    def get_upcoming_events(self, num_events):\n        \"\"\"\n        Get the next n upcoming events from a given date.\n        :param date: The date to get upcoming events from,datetime.\n        :param n: The number of upcoming events to get,int.\n        :return: A list of the next n upcoming events from the given date,list.\n        \"\"\"\n        now = datetime.now()\n        upcoming_events = sorted([event for event in self.events if event['date'] >= now], key=lambda x: x['date'])\n        return upcoming_events[:num_events]\n```",
    "18": "```python\nclass CamelCaseMap:\n    \"\"\"\n    This is a custom class that allows keys to be in camel case style by converting them from underscore style, which provides dictionary-like functionality.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize data to an empty dictionary\n        \"\"\"\n        self._data = {}\n\n    def __getitem__(self, key):\n        \"\"\"\n        Return the value corresponding to the key\n        :param key:str\n        :return:str,the value corresponding to the key\n        \"\"\"\n        converted_key = self._convert_key(key)\n        return self._data[converted_key]\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Set the value corresponding to the key to the specified value\n        :param key:str\n        :param value:str, the specified value\n        :return:None\n        \"\"\"\n        converted_key = self._convert_key(key)\n        self._data[converted_key] = value\n\n    def __delitem__(self, key):\n        \"\"\"\n        Delete the value corresponding to the key\n        :param key:str\n        :return:None\n        \"\"\"\n        converted_key = self._convert_key(key)\n        del self._data[converted_key]\n\n    def __iter__(self):\n        \"\"\"\n        Returning Iterateable Objects with Own Data\n        :return:Iterator\n        \"\"\"\n        return iter(self._data)\n\n    def __len__(self):\n        \"\"\"\n        Returns the length of the own data\n        :return:int, length of data\n        \"\"\"\n        return len(self._data)\n\n    def _convert_key(self, key):\n        \"\"\"\n        convert key string into camel case\n        :param key:str\n        :return:str, converted key string\n        \"\"\"\n        if isinstance(key, str):\n            return self._to_camel_case(key)\n        return key\n\n    @staticmethod\n    def _to_camel_case(key):\n        \"\"\"\n        convert key string into camel case\n        :param key:str\n        :return:str, converted key string\n        \"\"\"\n        components = key.split('_')\n        return components[0] + ''.join(x.title() for x in components[1:])\n```",
    "19": "```python\nclass ChandrasekharSieve:\n    \"\"\"\n    This is a class that uses the Chandrasekhar's Sieve method to find all prime numbers within the range\n    \"\"\"\n\n    def __init__(self, n):\n        \"\"\"\n        Initialize the ChandrasekharSieve class with the given limit.\n        :param n: int, the upper limit for generating prime numbers\n        \"\"\"\n        self.n = n\n        self.primes = self.generate_primes()\n\n    def generate_primes(self):\n        \"\"\"\n        Generate prime numbers up to the specified limit using the Chandrasekhar sieve algorithm.\n        :return: list, a list of prime numbers\n        \"\"\"\n        if self.n <= 1:\n            return []\n\n        sieve = [True] * (self.n + 1)\n        sieve[0] = sieve[1] = False\n\n        for i in range(2, int(self.n**0.5) + 1):\n            if sieve[i]:\n                for j in range(i*i, self.n + 1, i):\n                    sieve[j] = False\n\n        primes = [i for i in range(2, self.n + 1) if sieve[i]]\n        return primes\n\n    def get_primes(self):\n        \"\"\"\n        Get the list of generated prime numbers.\n        :return: list, a list of prime numbers\n        \"\"\"\n        return self.primes\n```",
    "20": "```python\nfrom datetime import datetime\n\nclass Chat:\n    \"\"\"\n    This is a chat class with the functions of adding users, removing users, sending messages, and obtaining messages.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Chat with an attribute users, which is an empty dictionary.\n        \"\"\"\n        self.users = {}\n\n    def add_user(self, username):\n        \"\"\"\n        Add a new user to the Chat.\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns False, otherwise, returns True.\n        \"\"\"\n        if username in self.users:\n            return False\n        self.users[username] = []\n        return True\n\n    def remove_user(self, username):\n        \"\"\"\n        Remove a user from the Chat.\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns True, otherwise, returns False.\n        \"\"\"\n        if username in self.users:\n            del self.users[username]\n            return True\n        return False\n\n    def send_message(self, sender, receiver, message):\n        \"\"\"\n        Send a message from a user to another user.\n        :param sender: The sender's name, str.\n        :param receiver: The receiver's name, str.\n        :param message: The message, str.\n        :return: If the sender or the receiver is not in the Chat, returns False, otherwise, returns True.\n        \"\"\"\n        if sender not in self.users or receiver not in self.users:\n            return False\n\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        message_data = {'sender': sender, 'receiver': receiver, 'message': message, 'timestamp': timestamp}\n        self.users[sender].append(message_data)\n        self.users[receiver].append(message_data)\n        return True\n\n    def get_messages(self, username):\n        \"\"\"\n        Get all the messages of a user from the Chat.\n        :param username: The user's name, str.\n        :return: A list of messages, each message is a dictionary with keys 'sender', 'receiver', 'message', 'timestamp'.\n        \"\"\"\n        return self.users.get(username, [])\n```",
    "21": "```python\nfrom datetime import datetime\n\nclass Classroom:\n    \"\"\"\n    This is a class representing a classroom, capable of adding and removing courses, checking availability at a given time, and detecting conflicts when scheduling new courses.\n    \"\"\"\n\n    TIME_FORMAT = '%H:%M'\n\n    def __init__(self, id):\n        \"\"\"\n        Initialize the classroom management system.\n        :param id: int, the id of classroom\n        \"\"\"\n        self.id = id\n        self.courses = []\n\n    def add_course(self, course):\n        \"\"\"\n        Add course to self.courses list if the course wasn't in it.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        \"\"\"\n        if course not in self.courses:\n            self.courses.append(course)\n\n    def remove_course(self, course):\n        \"\"\"\n        Remove course from self.courses list if the course was in it.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        \"\"\"\n        if course in self.courses:\n            self.courses.remove(course)\n\n    def is_free_at(self, check_time):\n        \"\"\"\n        Check if the classroom is free at the given time.\n        :param check_time: str, the time to check (format: HH:MM)\n        :return: True if the classroom is free, False otherwise.\n        \"\"\"\n        check_time_dt = datetime.strptime(check_time, self.TIME_FORMAT).time()\n        for course in self.courses:\n            start_time_dt = datetime.strptime(course['start_time'], self.TIME_FORMAT).time()\n            end_time_dt = datetime.strptime(course['end_time'], self.TIME_FORMAT).time()\n            if start_time_dt <= check_time_dt < end_time_dt:\n                return False\n        return True\n\n    def check_course_conflict(self, new_course):\n        \"\"\"\n        Check if the new course conflicts with any existing courses.\n        :param new_course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        :return: True if there is no conflict, False otherwise.\n        \"\"\"\n        new_start_time = datetime.strptime(new_course['start_time'], self.TIME_FORMAT).time()\n        new_end_time = datetime.strptime(new_course['end_time'], self.TIME_FORMAT).time()\n\n        for existing_course in self.courses:\n            existing_start_time = datetime.strptime(existing_course['start_time'], self.TIME_FORMAT).time()\n            existing_end_time = datetime.strptime(existing_course['end_time'], self.TIME_FORMAT).time()\n\n            if not (new_end_time <= existing_start_time or new_start_time >= existing_end_time):\n                return False\n\n        return True\n```",
    "22": "```python\nclass ClassRegistrationSystem:\n    \"\"\"\n    This is a class as a class registration system, allowing to register students, register them for classes, retrieve students by major, get a list of all majors, and determine the most popular class within a specific major.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the registration system with the attribute students and students_registration_class.\n        students is a list of student dictionaries, each student dictionary has the key of name and major.\n        students_registration_class is a dictionaries, key is the student name, value is a list of class names\n        \"\"\"\n        self.students = []\n        self.students_registration_classes = {}\n\n    def register_student(self, student):\n        \"\"\"\n        Registers a student to the system.\n\n        Args:\n            student (dict): A dictionary containing student information, with keys \"name\" and \"major\".\n\n        Returns:\n            int: 1 if the student was successfully registered, 0 if the student is already registered.\n        \"\"\"\n        if any(s[\"name\"] == student[\"name\"] and s[\"major\"] == student[\"major\"] for s in self.students):\n            return 0\n        self.students.append(student)\n        return 1\n\n    def register_class(self, student_name, class_name):\n        \"\"\"\n        Registers a student for a class.\n\n        Args:\n            student_name (str): The name of the student.\n            class_name (str): The name of the class.\n\n        Returns:\n            list: A list of class names that the student has registered for.\n        \"\"\"\n        if student_name not in self.students_registration_classes:\n            self.students_registration_classes[student_name] = []\n        if class_name not in self.students_registration_classes[student_name]:\n            self.students_registration_classes[student_name].append(class_name)\n        return self.students_registration_classes[student_name]\n\n    def get_students_by_major(self, major):\n        \"\"\"\n        Retrieves a list of student names for a given major.\n\n        Args:\n            major (str): The major to search for.\n\n        Returns:\n            list: A list of student names in the specified major.\n        \"\"\"\n        return [student[\"name\"] for student in self.students if student[\"major\"] == major]\n\n    def get_all_major(self):\n        \"\"\"\n        Retrieves a list of all unique majors in the system.\n\n        Returns:\n            list: A list of unique majors.\n        \"\"\"\n        majors = []\n        for student in self.students:\n            if student[\"major\"] not in majors:\n                majors.append(student[\"major\"])\n        return majors\n\n    def get_most_popular_class_in_major(self, major):\n        \"\"\"\n        Retrieves the most popular class within a specific major.\n\n        Args:\n            major (str): The major to search for.\n\n        Returns:\n            str: The name of the most popular class in the major, or None if no classes are found.\n        \"\"\"\n        class_counts = {}\n        for student in self.students:\n            if student[\"major\"] == major:\n                student_name = student[\"name\"]\n                if student_name in self.students_registration_classes:\n                    for class_name in self.students_registration_classes[student_name]:\n                        class_counts[class_name] = class_counts.get(class_name, 0) + 1\n\n        most_popular_class = None\n        max_count = 0\n        for class_name, count in class_counts.items():\n            if count > max_count:\n                most_popular_class = class_name\n                max_count = count\n\n        return most_popular_class\n```",
    "23": "```python\nimport math\nfrom typing import List\n\nclass CombinationCalculator:\n    \"\"\"\n    This is a class that provides methods to calculate the number of combinations for a specific count, calculate all possible combinations, and generate combinations with a specified number of elements.\n    \"\"\"\n\n    def __init__(self, datas: List[str]):\n        \"\"\"\n        Initialize the calculator with a list of data.\n        \"\"\"\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        \"\"\"\n        Calculate the number of combinations for a specific count.\n        :param n: The total number of elements,int.\n        :param m: The number of elements in each combination,int.\n        :return: The number of combinations,int.\n        >>> CombinationCalculator.count(4, 2)\n        6\n        \"\"\"\n        if m < 0 or m > n:\n            return 0\n        if m == 0 or m == n:\n            return 1\n        m = min(m, n - m)\n        result = 1\n        for i in range(m):\n            result = result * (n - i) // (i + 1)\n        return result\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"\n        Calculate the number of all possible combinations.\n        :param n: The total number of elements,int.\n        :return: The number of all possible combinations,int,if the number of combinations is greater than 2^63-1,return float(\"inf\").\n        >>> CombinationCalculator.count_all(4)\n        15\n        \"\"\"\n        if n < 0 or n > 63:\n            return False\n        if n == 63:\n            return float(\"inf\")\n        return (1 << n) - 1 if n > 0 else 0\n\n    def select(self, m: int) -> List[List[str]]:\n        \"\"\"\n        Generate combinations with a specified number of elements.\n        :param m: The number of elements in each combination,int.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select(2)\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"\n        if m < 0 or m > len(self.datas):\n            return []\n\n        result = []\n        self._select(0, [], m, result)\n        return result\n\n    def select_all(self) -> List[List[str]]:\n        \"\"\"\n        Generate all possible combinations of  selecting elements from the given data list,and it uses the select method.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select_all()\n        [['A'], ['B'], ['C'], ['D'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D'], ['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']]\n\n        \"\"\"\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        return result\n\n    def _select(self, dataIndex: int, currentCombination: List[str], remaining: int, result: List[List[str]]):\n        \"\"\"\n        Generate combinations with a specified number of elements by recursion.\n        :param dataIndex: The index of the data to be selected,int.\n        :param currentCombination: The list of elements in the combination,List[str].\n        :param remaining: The number of elements remaining to be selected.\n        :param result: The list of combinations,List[List[str]].\n        :return: None.\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> result = []\n        >>> calc._select(0, [None] * 2, 0, result)\n        >>> result\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"\n        if remaining == 0:\n            result.append(currentCombination.copy())\n            return\n\n        if dataIndex >= len(self.datas):\n            return\n\n        # Include the current element\n        currentCombination.append(self.datas[dataIndex])\n        self._select(dataIndex + 1, currentCombination, remaining - 1, result)\n        currentCombination.pop()  # Backtrack: remove the current element\n\n        # Exclude the current element\n        self._select(dataIndex + 1, currentCombination, remaining, result)\n```",
    "24": "```python\nclass ComplexCalculator:\n    \"\"\"\n    This is a class that implements addition, subtraction, multiplication, and division operations for complex numbers.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the ComplexCalculator class.  No specific initialization is needed.\n        \"\"\"\n        pass\n\n    @staticmethod\n    def add(c1, c2):\n        \"\"\"\n        Adds two complex numbers.\n        :param c1: The first complex number.\n        :param c2: The second complex number.\n        :return: The sum of the two complex numbers.\n        \"\"\"\n        return c1 + c2\n\n    @staticmethod\n    def subtract(c1, c2):\n        \"\"\"\n        Subtracts two complex numbers.\n        :param c1: The first complex number.\n        :param c2: The second complex number.\n        :return: The difference of the two complex numbers.\n        \"\"\"\n        return c1 - c2\n\n    @staticmethod\n    def multiply(c1, c2):\n        \"\"\"\n        Multiplies two complex numbers.\n        :param c1: The first complex number.\n        :param c2: The second complex number.\n        :return: The product of the two complex numbers.\n        \"\"\"\n        return c1 * c2\n\n    @staticmethod\n    def divide(c1, c2):\n        \"\"\"\n        Divides two complex numbers.\n        :param c1: The first complex number.\n        :param c2: The second complex number.\n        :return: The quotient of the two complex numbers.\n        \"\"\"\n        return c1 / c2\n```",
    "25": "```python\nimport json\n\nclass CookiesUtil:\n    \"\"\"\n    This is a class as utility for managing and manipulating Cookies, including methods for retrieving, saving, and setting Cookies data.\n    \"\"\"\n\n    def __init__(self, cookies_file):\n        \"\"\"\n        Initializes the CookiesUtil with the specified cookies file.\n        :param cookies_file: The cookies file to use, str.\n        \"\"\"\n        self.cookies_file = cookies_file\n        self.cookies = {}\n\n    def get_cookies(self, reponse):\n        \"\"\"\n        Gets the cookies from the specified response.\n        :param reponse: The response to get cookies from, dict.\n        \"\"\"\n        if 'cookies' in reponse:\n            self.cookies = reponse['cookies']\n\n    def load_cookies(self):\n        \"\"\"\n        Loads the cookies from the cookies_file.\n        :return: The cookies data, dict.\n        \"\"\"\n        try:\n            with open(self.cookies_file, 'r') as f:\n                self.cookies = json.load(f)\n        except FileNotFoundError:\n            self.cookies = {}\n        except json.JSONDecodeError:\n            self.cookies = {}\n\n        if isinstance(self.cookies, dict):\n            return self.cookies\n        else:\n            return {}\n\n    def _save_cookies(self):\n        \"\"\"\n        Saves the cookies to the cookies_file.\n        :return: True if successful, False otherwise.\n        \"\"\"\n        if not self.cookies_file:\n            return False\n\n        try:\n            with open(self.cookies_file, 'w') as f:\n                json.dump(self.cookies, f)\n            return True\n        except Exception:\n            return False\n\n    def set_cookies(self, request):\n        \"\"\"\n        Sets the cookies to the specified request.\n        :param request: The request to set cookies to, dict.\n        \"\"\"\n        request['cookies'] = \"cookies=\" + str(self.cookies)\n```",
    "26": "```python\nimport csv\n\nclass CSVProcessor:\n    \"\"\"\n    This is a class for processing CSV files, including reading and writing CSV data, as well as processing specific operations and saving as a new CSV file.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_csv(self, file_name):\n        \"\"\"\n        Read the csv file by file_name, get the title and data from it\n        :param file_name: str, name of the csv file\n        :return title, data: (list, list), first row is title, the rest is data\n        \"\"\"\n        try:\n            with open(file_name, 'r', newline='') as file:\n                reader = csv.reader(file)\n                title = next(reader)\n                data = list(reader)\n                return title, data\n        except FileNotFoundError:\n            print(f\"Error: File '{file_name}' not found.\")\n            return [], []\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n            return [], []\n\n    def write_csv(self, data, file_name):\n        \"\"\"\n        Write data into a csv file.\n        :param data: list of lists, the data to write. The first sublist is the header.\n        :param file_name: str, name of the csv file\n        :return: int, if success return 1, or 0 otherwise\n        \"\"\"\n        if not data:\n            return 0\n\n        try:\n            with open(file_name, 'w', newline='') as file:\n                writer = csv.writer(file)\n                writer.writerow(data[0])  # Write the header row\n                for row in data[1:]:\n                    writer.writerow(row)\n            return 1\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n            return 0\n\n    def process_csv_data(self, N, save_file_name):\n        \"\"\"\n        Read a csv file into variable title and data.\n        Only remain the N th (from 0) column data and Capitalize them, store the title and new data into a new csv file.\n        Add '_process' suffix after old file name, as a new file name.\n        :param N: int, the N th column(from 0)\n        :param save_file_name: str, the name of file that needs to be processed.\n        :return: int, if success return 1, or 0 otherwise\n        \"\"\"\n        try:\n            title, data = self.read_csv(save_file_name)\n            if not title or not data:\n                return 0\n\n            processed_data = []\n            for row in data:\n                if 0 <= N < len(row):\n                    processed_data.append([row[N].upper()])\n                else:\n                    print(f\"Error: Column index {N} out of range for row: {row}\")\n                    return 0\n\n            new_file_name = save_file_name.replace(\".csv\", \"_process.csv\")\n            \n            # Prepare data for writing: header + processed data\n            data_to_write = [title] + processed_data\n            return self.write_csv(data_to_write, new_file_name)\n\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n            return 0\n```",
    "27": "```python\nclass CurrencyConverter:\n    \"\"\"\n    This is a class for currency conversion, which supports to convert amounts between different currencies, retrieve supported currencies, add new currency rates, and update existing currency rates.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the exchange rate of the US dollar against various currencies\n        \"\"\"\n        self.rates = {\n            'USD': 1.0,\n            'EUR': 0.85,\n            'GBP': 0.72,\n            'JPY': 110.15,\n            'CAD': 1.23,\n            'AUD': 1.34,\n            'CNY': 6.40,\n        }\n\n    def convert(self, amount, from_currency, to_currency):\n        \"\"\"\n        Convert the value of a given currency to another currency type\n        :param amount: float, The value of a given currency\n        :param from_currency: string, source currency type\n        :param to_currency: string, target currency type\n        :return: float, value converted to another currency type, or False if currencies are not supported.\n        \"\"\"\n        if not isinstance(amount, (int, float)):\n            raise TypeError(\"Amount must be a number.\")\n        if not isinstance(from_currency, str) or not isinstance(to_currency, str):\n            raise TypeError(\"Currencies must be strings.\")\n\n        from_currency = from_currency.upper()\n        to_currency = to_currency.upper()\n\n        if from_currency not in self.rates or to_currency not in self.rates:\n            return False\n\n        from_rate = self.rates[from_currency]\n        to_rate = self.rates[to_currency]\n\n        usd_amount = amount / from_rate\n        converted_amount = usd_amount * to_rate\n\n        return converted_amount\n\n    def get_supported_currencies(self):\n        \"\"\"\n        Returns a list of supported currency types\n        :return:list, All supported currency types\n        \"\"\"\n        return list(self.rates.keys())\n\n    def add_currency_rate(self, currency, rate):\n        \"\"\"\n        Add a new supported currency type, return False if the currency type is already in the support list\n        :param currency:string, currency type to be added\n        :param rate:float, exchange rate for this type of currency\n        :return: True if successful, False otherwise.\n        \"\"\"\n        if not isinstance(currency, str):\n            raise TypeError(\"Currency must be a string.\")\n        if not isinstance(rate, (int, float)):\n            raise TypeError(\"Rate must be a number.\")\n\n        currency = currency.upper()\n\n        if currency in self.rates:\n            return False\n\n        self.rates[currency] = rate\n        return True\n\n    def update_currency_rate(self, currency, new_rate):\n        \"\"\"\n        Update the exchange rate for a certain currency\n        :param currency:string\n        :param new_rate:float\n        :return: True if successful, False otherwise.\n        \"\"\"\n        if not isinstance(currency, str):\n            raise TypeError(\"Currency must be a string.\")\n        if not isinstance(new_rate, (int, float)):\n            raise TypeError(\"New rate must be a number.\")\n\n        currency = currency.upper()\n\n        if currency not in self.rates:\n            return False\n\n        self.rates[currency] = new_rate\n        return True\n```",
    "28": "```python\nimport sqlite3\nimport pandas as pd\n\nclass DatabaseProcessor:\n    \"\"\"\n    This is a class for processing a database, supporting to create tables, insert data into the database, search for data based on name, and delete data from the database.\n    \"\"\"\n\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        self.database_name = database_name\n\n\n    def _execute_query(self, query, params=None):\n        \"\"\"\n        Helper function to execute SQL queries with error handling and connection management.\n        \"\"\"\n        conn = None\n        cursor = None\n        try:\n            conn = sqlite3.connect(self.database_name)\n            cursor = conn.cursor()\n            if params:\n                cursor.execute(query, params)\n            else:\n                cursor.execute(query)\n            conn.commit()\n            return cursor\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n            if conn:\n                conn.rollback()  # Rollback in case of error\n            return None\n        finally:\n            if cursor:\n                cursor.close()\n            if conn:\n                conn.close()\n\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table.\n        :param key2: str, the name of the second column in the table.\n        >>> db.create_table('user', 'name', 'age')\n        \"\"\"\n        query = f\"\"\"\n            CREATE TABLE IF NOT EXISTS {table_name} (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                {key1} TEXT,\n                {key2} INTEGER\n            )\n        \"\"\"\n        self._execute_query(query)\n\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        >>> db.insert_into_database('user', [\n                {'name': 'John', 'age': 25},\n                {'name': 'Alice', 'age': 30}\n            ])\n        \"\"\"\n        for row in data:\n            columns = ', '.join(row.keys())\n            placeholders = ', '.join(['?'] * len(row))\n            values = tuple(row.values())\n\n            query = f\"INSERT INTO {table_name} ({columns}) VALUES ({placeholders})\"\n            self._execute_query(query, values)\n\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list, a list of tuples representing the rows with matching name, if any;\n                    otherwise, returns None.\n        >>> db.search_database('user', 'John')\n        [(1, 'John', 25)]\n        \"\"\"\n        query = f\"SELECT * FROM {table_name} WHERE name=?\"\n        cursor = self._execute_query(query, (name,))\n\n        if cursor:\n            result = cursor.fetchall()\n            return result if result else None\n        else:\n            return None\n\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the name to match for deletion.\n        >>> db.delete_from_database('user', 'John')\n        \"\"\"\n        query = f\"DELETE FROM {table_name} WHERE name=?\"\n        self._execute_query(query, (name,))\n```",
    "29": "```python\nfrom collections import Counter\n\nclass DataStatistics:\n    \"\"\"\n    This is a class for performing data statistics, supporting to calculate the mean, median, and mode of a given data set.\n    \"\"\"\n\n    def mean(self, data):\n        \"\"\"\n        Calculate the average value of a group of data, accurate to two digits after the Decimal separator\n        :param data:list, data list\n        :return:float, the mean value\n        >>> ds = DataStatistics()\n        >>> ds.mean([1, 2, 3, 4, 5])\n        3.00\n        \"\"\"\n        if not data:\n            return 0.00\n        try:\n            mean_value = sum(data) / len(data)\n            return round(mean_value, 2)\n        except TypeError:\n            raise TypeError(\"Data must be a list of numbers.\")\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n            return None\n\n    def median(self, data):\n        \"\"\"\n        Calculate the median of a group of data, accurate to two digits after the Decimal separator\n        :param data:list, data list\n        :return:float, the median value\n        >>> ds = DataStatistics()\n        >>> ds.median([2, 5, 1, 3, 4])\n        3.00\n        \"\"\"\n        if not data:\n            return 0.00\n\n        try:\n            sorted_data = sorted(data)\n            n = len(sorted_data)\n\n            if n % 2 == 0:\n                # Even number of elements\n                mid1 = sorted_data[n // 2 - 1]\n                mid2 = sorted_data[n // 2]\n                median = (mid1 + mid2) / 2\n            else:\n                # Odd number of elements\n                median = sorted_data[n // 2]\n\n            if isinstance(median, float):\n                return round(median, 2)\n            else:\n                return median\n        except TypeError:\n            raise TypeError(\"Data must be a list of numbers.\")\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n            return None\n\n    def mode(self, data):\n        \"\"\"\n        Calculate the mode of a set of data\n        :param data:list, data list\n        :return:float, the mode\n        >>> ds = DataStatistics()\n        >>> ds.mode([2, 2, 3, 3, 4])\n        [2, 3]\n        \"\"\"\n        if not data:\n            return []\n\n        try:\n            count = Counter(data)\n            max_count = max(count.values())\n            modes = [key for key, value in count.items() if value == max_count]\n            modes.sort()\n            return modes\n        except TypeError:\n            raise TypeError(\"Data must be a list of numbers or strings.\")\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n            return None\n```",
    "30": "```python\nimport numpy as np\n\nclass DataStatistics2:\n    \"\"\"\n    This is a class for performing data statistics, supporting to get the sum, minimum, maximum, variance, standard deviation, and correlation of a given dataset.\n    \"\"\"\n\n    def __init__(self, data):\n        \"\"\"\n        Initialize Data List\n        :param data:list\n        \"\"\"\n        self.data = np.array(data)\n\n    def get_sum(self):\n        \"\"\"\n        Calculate the sum of data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_sum()\n        10\n        \"\"\"\n        return float(np.sum(self.data))\n\n    def get_min(self):\n        \"\"\"\n        Calculate the minimum value in the data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_min()\n        1\n        \"\"\"\n        return float(np.min(self.data))\n\n    def get_max(self):\n        \"\"\"\n        Calculate the maximum value in the data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_max()\n        4\n        \"\"\"\n        return float(np.max(self.data))\n\n    def get_variance(self):\n        \"\"\"\n        Calculate variance, accurate to two digits after the Decimal separator\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_variance()\n        1.25\n        \"\"\"\n        variance = np.var(self.data)\n        return round(float(variance), 2)\n\n    def get_std_deviation(self):\n        \"\"\"\n        Calculate standard deviation, accurate to two digits after the Decimal separator\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_std_deviation()\n        1.12\n        \"\"\"\n        std_deviation = np.std(self.data)\n        return round(float(std_deviation), 2)\n\n    def get_correlation(self):\n        \"\"\"\n        Calculate correlation\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_correlation()\n        1.0\n        \"\"\"\n        if len(self.data) <= 1:\n            return 1.0\n        correlation_matrix = np.corrcoef(self.data)\n        return float(round(correlation_matrix[0, 0], 2))\n```",
    "31": "```python\nimport math\n\nclass DataStatistics4:\n    \"\"\"\n    This is a class that performs advanced mathematical calculations and statistics, including correlation coefficient, skewness, kurtosis, and probability density function (PDF) for a normal distribution.\n    \"\"\"\n\n\n    @staticmethod\n    def correlation_coefficient(data1, data2):\n        \"\"\"\n        Calculate the correlation coefficient of two sets of data.\n        :param data1: The first set of data,list.\n        :param data2: The second set of data,list.\n        :return: The correlation coefficient, float.\n        \"\"\"\n        if len(data1) != len(data2):\n            raise ValueError(\"Data sets must have the same length\")\n\n        n = len(data1)\n        if n <= 1:\n            return 0.0\n\n        mean1 = sum(data1) / n\n        mean2 = sum(data2) / n\n\n        numerator = sum((x - mean1) * (y - mean2) for x, y in zip(data1, data2))\n        denominator1 = sum((x - mean1) ** 2 for x in data1)\n        denominator2 = sum((y - mean2) ** 2 for y in data2)\n\n        if denominator1 == 0 or denominator2 == 0:\n            return 0.0  # Handle cases where one or both datasets have zero variance\n\n        correlation = numerator / math.sqrt(denominator1 * denominator2)\n        return correlation\n\n    @staticmethod\n    def skewness(data):\n        \"\"\"\n        Calculate the skewness of a set of data.\n        :param data: The input data list, list.\n        :return: The skewness, float.\n        \"\"\"\n        n = len(data)\n        if n < 3:\n            return 0.0\n\n        mean = sum(data) / n\n        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / (n - 1))\n\n        if std_dev == 0:\n            return 0.0\n\n        skewness = sum((x - mean) ** 3 for x in data) / ((n - 1) * std_dev ** 3)\n        return skewness\n\n    @staticmethod\n    def kurtosis(data):\n        \"\"\"\n        Calculate the kurtosis of a set of data.\n        :param data: The input data list, list.\n        :return: The kurtosis, float.\n        \"\"\"\n        n = len(data)\n        if n < 4:\n            return float('NaN')\n\n        mean = sum(data) / n\n        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / (n - 1))\n\n        if std_dev == 0:\n            return float('NaN')\n\n        kurtosis = sum((x - mean) ** 4 for x in data) / ((n - 1) * std_dev ** 4) - 3\n        return kurtosis\n\n    @staticmethod\n    def pdf(data, mu, sigma):\n        \"\"\"\n        Calculate the probability density function (PDF) of a set of data under a normal distribution.\n        :param data: The input data list, list.\n        :param mu: The mean of the normal distribution, float.\n        :param sigma: The standard deviation of the normal distribution, float.\n        :return: The probability density function (PDF), list.\n        \"\"\"\n        if sigma <= 0:\n            raise ValueError(\"Standard deviation (sigma) must be positive.\")\n\n        pdf_values = []\n        for x in data:\n            exponent = -((x - mu) ** 2) / (2 * sigma ** 2)\n            coefficient = 1 / (sigma * math.sqrt(2 * math.pi))\n            pdf = coefficient * math.exp(exponent)\n            pdf_values.append(pdf)\n        return pdf_values\n```",
    "32": "```python\nclass DecryptionUtils:\n    \"\"\"\n    This is a class that provides methods for decryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the decryption utility with a key.\n        :param key: The key to use for decryption,str.\n        \"\"\"\n        self.key = key\n\n    def caesar_decipher(self, ciphertext, shift):\n        \"\"\"\n        Deciphers the given ciphertext using the Caesar cipher\n        :param ciphertext: The ciphertext to decipher,str.\n        :param shift: The shift to use for decryption,int.\n        :return: The deciphered plaintext,str.\n        \"\"\"\n        plaintext = \"\"\n        for char in ciphertext:\n            if 'a' <= char <= 'z':\n                start = 'a'\n                decrypted_char = chr((ord(char) - ord(start) - shift) % 26 + ord(start))\n            elif 'A' <= char <= 'Z':\n                start = 'A'\n                decrypted_char = chr((ord(char) - ord(start) - shift) % 26 + ord(start))\n            else:\n                decrypted_char = char\n            plaintext += decrypted_char\n        return plaintext\n\n    def vigenere_decipher(self, ciphertext):\n        \"\"\"\n        Deciphers the given ciphertext using the Vigenere cipher\n        :param ciphertext: The ciphertext to decipher,str.\n        :return: The deciphered plaintext,str.\n        \"\"\"\n        plaintext = \"\"\n        key_length = len(self.key)\n        for i, char in enumerate(ciphertext):\n            if 'a' <= char <= 'z':\n                start = 'a'\n                key_char = self.key[i % key_length]\n                key_shift = ord(key_char) - ord('a')\n                decrypted_char = chr((ord(char) - ord(start) - key_shift) % 26 + ord(start))\n            elif 'A' <= char <= 'Z':\n                start = 'A'\n                key_char = self.key[i % key_length]\n                key_shift = ord(key_char.lower()) - ord('a')\n                decrypted_char = chr((ord(char) - ord(start) - key_shift) % 26 + ord(start))\n            else:\n                decrypted_char = char\n            plaintext += decrypted_char\n        return plaintext\n\n    def rail_fence_decipher(self, encrypted_text, rails):\n        \"\"\"\n        Deciphers the given ciphertext using the Rail Fence cipher\n        :param encrypted_text: The ciphertext to decipher,str.\n        :param rails: The number of rails to use for decryption,int.\n        :return: The deciphered plaintext,str.\n        \"\"\"\n        text_length = len(encrypted_text)\n        rail_matrix = [['' for _ in range(text_length)] for _ in range(rails)]\n        direction_down = False\n        row, col = 0, 0\n\n        for i in range(text_length):\n            if row == 0 or row == rails - 1:\n                direction_down = not direction_down\n\n            rail_matrix[row][col] = '*'\n            col += 1\n\n            if direction_down:\n                row += 1\n            else:\n                row -= 1\n\n        index = 0\n        for i in range(rails):\n            for j in range(text_length):\n                if rail_matrix[i][j] == '*':\n                    rail_matrix[i][j] = encrypted_text[index]\n                    index += 1\n\n        result = \"\"\n        row, col = 0, 0\n        direction_down = False\n\n        for i in range(text_length):\n            if row == 0 or row == rails - 1:\n                direction_down = not direction_down\n\n            result += rail_matrix[row][col]\n            col += 1\n\n            if direction_down:\n                row += 1\n            else:\n                row -= 1\n\n        return result\n```",
    "33": "```python\nclass DiscountStrategy:\n    \"\"\"\n    This is a class that allows to use different discount strategy based on shopping credit or shopping cart in supermarket.\n    \"\"\"\n\n    def __init__(self, customer, cart, promotion=None):\n        \"\"\"\n        Initialize the DiscountStrategy with customer information, a cart of items, and an optional promotion.\n        :param customer: dict, customer information\n        :param cart: list of dicts, a cart of items with details\n        :param promotion: function, optional promotion applied to the order\n        \"\"\"\n        self.customer = customer\n        self.cart = cart\n        self.promotion = promotion\n        self._total = self._calculate_total()\n\n    def _calculate_total(self):\n        \"\"\"\n        Calculate the total cost of items in the cart.\n        \"\"\"\n        total = 0.0\n        for item in self.cart:\n            total += item['quantity'] * item['price']\n        return total\n\n    def total(self):\n        \"\"\"\n        Calculate the total cost of items in the cart.\n        :return: float, total cost of items\n        \"\"\"\n        return self._total\n\n    def due(self):\n        \"\"\"\n        Calculate the final amount to be paid after applying the discount.\n        :return: float, final amount to be paid\n        \"\"\"\n        discount = 0.0\n        if self.promotion:\n            discount = self.promotion(self)\n        return self._total - discount\n\n    @staticmethod\n    def FidelityPromo(order):\n        \"\"\"\n        Calculate the discount based on the fidelity points of the customer.Customers with over 1000 points can enjoy a 5% discount on the entire order.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        \"\"\"\n        if order.customer.get('fidelity', 0) >= 1000:\n            return order.total() * 0.05\n        return 0.0\n\n    @staticmethod\n    def BulkItemPromo(order):\n        \"\"\"\n        Calculate the discount based on bulk item quantity in the order.In the same order, if the quantity of a single item reaches 20 or more, each item will enjoy a 10% discount.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        \"\"\"\n        discount = 0.0\n        for item in order.cart:\n            if item['quantity'] >= 20:\n                discount += item['quantity'] * item['price'] * 0.1\n        return discount\n\n    @staticmethod\n    def LargeOrderPromo(order):\n        \"\"\"\n        Calculate the discount based on the number of different products in the order.If the quantity of different products in the order reaches 10 or more, the entire order will enjoy a 7% discount.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        \"\"\"\n        if len(order.cart) >= 10:\n            return order.total() * 0.07\n        return 0.0\n```",
    "34": "```python\nfrom docx import Document\nfrom docx.shared import Pt\nfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENT\n\n\nclass DocFileHandler:\n    \"\"\"\n    This is a class that handles Word documents and provides functionalities for reading, writing, and modifying the content of Word documents.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initializes the DocFileHandler object with the specified file path.\n        :param file_path: str, the path to the Word document file.\n        \"\"\"\n        self.file_path = file_path\n\n    def read_text(self):\n        \"\"\"\n        Reads the content of a Word document and returns it as a string.\n        :return: str, the content of the Word document.\n        \"\"\"\n        try:\n            document = Document(self.file_path)\n            text = '\\n'.join([paragraph.text for paragraph in document.paragraphs])\n            return text\n        except Exception as e:\n            print(f\"Error reading document: {e}\")\n            return \"\"\n\n    def write_text(self, content, font_size=12, alignment='left'):\n        \"\"\"\n        Writes the specified content to a Word document.\n        :param content: str, the text content to write.\n        :param font_size: int, optional, the font size of the text (default is 12).\n        :param alignment: str, optional, the alignment of the text ('left', 'center', or 'right'; default is 'left').\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n        try:\n            document = Document()\n            paragraph = document.add_paragraph(content)\n            paragraph.alignment = self._get_alignment_value(alignment)\n            for run in paragraph.runs:\n                run.font.size = Pt(font_size)\n            document.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error writing to document: {e}\")\n            return False\n\n    def add_heading(self, heading, level=1):\n        \"\"\"\n        Adds a heading to the Word document.\n        :param heading: str, the text of the heading.\n        :param level: int, optional, the level of the heading (1, 2, 3, etc.; default is 1).\n        :return: bool, True if the heading is successfully added, False otherwise.\n        \"\"\"\n        try:\n            document = Document(self.file_path) if self.file_path else Document()\n            document.add_heading(heading, level=level)\n            document.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error adding heading: {e}\")\n            return False\n\n    def add_table(self, data):\n        \"\"\"\n        Adds a table to the Word document with the specified data.\n        :param data: list of lists, the data to populate the table.\n        :return: bool, True if the table is successfully added, False otherwise.\n        \"\"\"\n        try:\n            document = Document(self.file_path) if self.file_path else Document()\n            table = document.add_table(rows=0, cols=len(data[0]) if data else 0)\n\n            for row_data in data:\n                row_cells = table.add_row().cells\n                for i, item in enumerate(row_data):\n                    row_cells[i].text = str(item)\n\n            document.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error adding table: {e}\")\n            return False\n\n    def _get_alignment_value(self, alignment):\n        \"\"\"\n        Returns the alignment value corresponding to the given alignment string.\n        :param alignment: str, the alignment string ('left', 'center', or 'right').\n        :return: int, the alignment value.\n        \"\"\"\n        alignment = alignment.lower()\n        if alignment == 'center':\n            return WD_PARAGRAPH_ALIGNMENT.CENTER\n        elif alignment == 'right':\n            return WD_PARAGRAPH_ALIGNMENT.RIGHT\n        else:\n            return WD_PARAGRAPH_ALIGNMENT.LEFT\n```",
    "35": "```python\nclass EightPuzzle:\n    \"\"\"\n    This class is an implementation of the classic 8-puzzle game, including methods for finding the blank tile, making moves, getting possible moves, and solving the puzzle using a breadth-first search algorithm.\n    \"\"\"\n\n    def __init__(self, initial_state):\n        \"\"\"\n        Initializing the initial state of Eight Puzzle Game, stores in attribute self.initial_state.\n        And set the goal state of this game, stores in self.goal_state. In this case, set the size as 3*3\n        :param initial_state: a 3*3 size list of Integer, stores the initial state\n        \"\"\"\n        self.initial_state = initial_state\n        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n        self.size = 3\n\n    def find_blank(self, state):\n        \"\"\"\n        Find the blank position of current state, which is the 0 element.\n        :param state: a 3*3 size list of Integer, stores the current state.\n        :return i, j: two Integers, represent the coordinate of the blank block.\n        \"\"\"\n        for i in range(self.size):\n            for j in range(self.size):\n                if state[i][j] == 0:\n                    return i, j\n        return None\n\n    def move(self, state, direction):\n        \"\"\"\n        Find the blank block, then makes the board moves forward the given direction.\n        :param state: a 3*3 size list of Integer, stores the state before moving.\n        :param direction: str, only has 4 direction 'up', 'down', 'left', 'right'\n        :return new_state: a 3*3 size list of Integer, stores the state after moving.\n        \"\"\"\n        blank_row, blank_col = self.find_blank(state)\n        new_state = [row[:] for row in state]\n\n        if blank_row is None or blank_col is None:\n            return new_state\n\n        if direction == 'up':\n            if blank_row > 0:\n                new_state[blank_row][blank_col], new_state[blank_row - 1][blank_col] = new_state[blank_row - 1][blank_col], new_state[blank_row][blank_col]\n        elif direction == 'down':\n            if blank_row < self.size - 1:\n                new_state[blank_row][blank_col], new_state[blank_row + 1][blank_col] = new_state[blank_row + 1][blank_col], new_state[blank_row][blank_col]\n        elif direction == 'left':\n            if blank_col > 0:\n                new_state[blank_row][blank_col], new_state[blank_row][blank_col - 1] = new_state[blank_row][blank_col - 1], new_state[blank_row][blank_col]\n        elif direction == 'right':\n            if blank_col < self.size - 1:\n                new_state[blank_row][blank_col], new_state[blank_row][blank_col + 1] = new_state[blank_row][blank_col + 1], new_state[blank_row][blank_col]\n        return new_state\n    \n    def get_possible_moves(self, state):\n        \"\"\"\n        According the current state, find all the possible moving directions. Only has 4 direction 'up', 'down', 'left', 'right'.\n        :param state: a 3*3 size list of Integer, stores the current state.\n        :return moves: a list of str, store all the possible moving directions according to the current state.\n        \"\"\"\n        blank_row, blank_col = self.find_blank(state)\n        moves = []\n\n        if blank_row is None or blank_col is None:\n            return moves\n\n        if blank_row > 0:\n            moves.append('up')\n        if blank_row < self.size - 1:\n            moves.append('down')\n        if blank_col > 0:\n            moves.append('left')\n        if blank_col < self.size - 1:\n            moves.append('right')\n        return moves\n\n    def solve(self):\n        \"\"\"\n        Use BFS algorithm to find the path solution which makes the initial state to the goal method.\n        Maintain a list as a queue, named as open_list, append the initial state.\n        Always visit and pop the 0 index element, invoke get_possible_moves method find all the possible directions.\n        Traversal the possible_moves list and invoke move method to get several new states.Then append them.\n        redo the above steps until the open_list is empty or the state has changed to the goal state.\n        :return path: list of str, the solution to the goal state.\n        \"\"\"\n        initial_state = self.initial_state\n\n        if initial_state == [[0, 0, 0], [0, 0, 0], [0, 0, 0]]:\n            return None\n\n        queue = [(initial_state, [])]  # (state, path)\n        visited = {tuple(map(tuple, initial_state))}\n\n        while queue:\n            current_state, path = queue.pop(0)\n\n            if current_state == self.goal_state:\n                return path\n\n            possible_moves = self.get_possible_moves(current_state)\n\n            for move in possible_moves:\n                new_state = self.move(current_state, move)\n                state_tuple = tuple(map(tuple, new_state))\n\n                if state_tuple not in visited:\n                    visited.add(state_tuple)\n                    new_path = path + [move]\n                    queue.append((new_state, new_path))\n\n        return None\n```",
    "36": "```python\nfrom datetime import datetime\n\nclass EmailClient:\n    \"\"\"\n    This is a class that serves as an email client, implementing functions such as checking emails, determining whether there is sufficient space, and cleaning up space\n    \"\"\"\n\n    def __init__(self, addr, capacity) -> None:\n        \"\"\"\n        Initializes the EmailClient class with the email address and the capacity of the email box.\n        :param addr: The email address, str.\n        :param capacity: The capacity of the email box, float.\n        \"\"\"\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox = []\n\n    def send_to(self, recv, content, size):\n        \"\"\"\n        Sends an email to the given email address.\n        :param recv: The email address of the receiver, str.\n        :param content: The content of the email, str.\n        :param size: The size of the email, float.\n        :return: True if the email is sent successfully, False if the receiver's email box is full.\n        \"\"\"\n        if recv.is_full_with_one_more_email(size):\n            return False\n        else:\n            timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            email = {\n                'sender': self.addr,\n                'receiver': recv.addr,\n                'content': content,\n                'size': size,\n                'time': timestamp,\n                'state': 'unread'\n            }\n            recv.inbox.append(email)\n            return True\n\n    def fetch(self):\n        \"\"\"\n        Retrieves the first unread email in the email box and marks it as read.\n        :return: The first unread email in the email box, dict.\n        \"\"\"\n        for email in self.inbox:\n            if email['state'] == 'unread':\n                email['state'] = 'read'\n                return email\n        return None\n\n    def is_full_with_one_more_email(self, size):\n        \"\"\"\n        Determines whether the email box is full after adding an email of the given size.\n        :param size: The size of the email, float.\n        :return: True if the email box is full, False otherwise.\n        \"\"\"\n        return self.get_occupied_size() + size > self.capacity\n\n    def get_occupied_size(self):\n        \"\"\"\n        Gets the total size of the emails in the email box.\n        :return: The total size of the emails in the email box, float.\n        \"\"\"\n        total_size = 0\n        for email in self.inbox:\n            total_size += email.get('size', 0)\n        return total_size\n\n    def clear_inbox(self, size):\n        \"\"\"\n        Clears the email box by deleting the oldest emails until the email box has enough space to accommodate the given size.\n        :param size: The size of the email, float.\n        \"\"\"\n        \n        if not self.inbox:\n            return\n        \n        emails_to_remove_size = 0\n        emails_to_remove = []\n        \n        inbox_copy = self.inbox[:]\n        \n        inbox_copy.sort(key=lambda x: x.get('time', datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")) if isinstance(x.get('time', datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")), str) else datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"), reverse = False)\n\n        for email in inbox_copy:\n            emails_to_remove_size += email.get('size', 0)\n            emails_to_remove.append(email)\n            if self.get_occupied_size() - emails_to_remove_size + size <= self.capacity:\n                break\n        \n        for email in emails_to_remove:\n            if email in self.inbox:\n                self.inbox.remove(email)\n```",
    "37": "```python\nclass EncryptionUtils:\n    \"\"\"\n    This is a class that provides methods for encryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the class with a key.\n        :param key: The key to use for encryption, str.\n        \"\"\"\n        self.key = key\n\n    def caesar_cipher(self, plaintext, shift):\n        \"\"\"\n        Encrypts the plaintext using the Caesar cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :param shift: The number of characters to shift each character in the plaintext, int.\n        :return: The ciphertext, str.\n        \"\"\"\n        ciphertext = \"\"\n        for char in plaintext:\n            if 'a' <= char <= 'z':\n                shifted_char = chr(((ord(char) - ord('a') + shift) % 26) + ord('a'))\n            elif 'A' <= char <= 'Z':\n                shifted_char = chr(((ord(char) - ord('A') + shift) % 26) + ord('A'))\n            else:\n                shifted_char = char\n            ciphertext += shifted_char\n        return ciphertext\n\n    def vigenere_cipher(self, plaintext):\n        \"\"\"\n        Encrypts the plaintext using the Vigenere cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :return: The ciphertext, str.\n        \"\"\"\n        ciphertext = \"\"\n        key = self.key\n        key_length = len(key)\n        for i, char in enumerate(plaintext):\n            if 'a' <= char <= 'z':\n                key_char = key[i % key_length]\n                shift = ord(key_char) - ord('a')\n                shifted_char = chr(((ord(char) - ord('a') + shift) % 26) + ord('a'))\n            elif 'A' <= char <= 'Z':\n                key_char = key[i % key_length]\n                shift = ord(key_char.lower()) - ord('a')\n                shifted_char = chr(((ord(char) - ord('A') + shift) % 26) + ord('A'))\n            else:\n                shifted_char = char\n            ciphertext += shifted_char\n        return ciphertext\n\n    def rail_fence_cipher(self, plain_text, rails):\n        \"\"\"\n        Encrypts the plaintext using the Rail Fence cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :param rails: The number of rails to use, int.\n        :return: The ciphertext, str.\n        \"\"\"\n        if rails <= 1:\n            return plain_text\n\n        rail = [['' for _ in range(len(plain_text))]\n                for _ in range(rails)]\n\n        dir_down = False\n        row, col = 0, 0\n\n        for i in range(len(plain_text)):\n            if row == 0 or row == rails - 1:\n                dir_down = not dir_down\n\n            rail[row][col] = plain_text[i]\n            col += 1\n\n            if dir_down:\n                row += 1\n            else:\n                row -= 1\n\n        result = \"\"\n        for i in range(rails):\n            for j in range(len(plain_text)):\n                if rail[i][j] != '':\n                    result += rail[i][j]\n        return result\n```",
    "38": "```python\nimport openpyxl\n\n\nclass ExcelProcessor:\n    \"\"\"\n    This is a class for processing excel files, including reading and writing excel data, as well as processing specific operations and saving as a new excel file.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_excel(self, file_name):\n        \"\"\"\n        Reading data from Excel files\n        :param file_name:str, Excel file name to read\n        :return:list of data, Data in Excel\n        \"\"\"\n        try:\n            workbook = openpyxl.load_workbook(file_name)\n            sheet = workbook.active\n            data = []\n            for row in sheet.iter_rows():\n                row_data = tuple(cell.value for cell in row)\n                data.append(row_data)\n            return data\n        except FileNotFoundError:\n            print(f\"Error: File '{file_name}' not found.\")\n            return None\n        except openpyxl.utils.exceptions.InvalidFileException:\n            print(f\"Error: File '{file_name}' is not a valid Excel file.\")\n            return None\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n            return None\n\n    def write_excel(self, data, file_name):\n        \"\"\"\n        Write data to the specified Excel file\n        :param data: list, Data to be written\n        :param file_name: str, Excel file name to write to\n        :return: 1 for successful writing, 0 for failed writing\n        \"\"\"\n        if not file_name:\n            print(\"Error: File name cannot be empty.\")\n            return 0\n\n        try:\n            workbook = openpyxl.Workbook()\n            sheet = workbook.active\n            for row_data in data:\n                sheet.append(row_data)\n            workbook.save(file_name)\n            return 1\n        except Exception as e:\n            print(f\"An error occurred while writing to Excel: {e}\")\n            return 0\n\n    def process_excel_data(self, N, save_file_name):\n        \"\"\"\n        Change the specified column in the Excel file to uppercase\n        :param N: int, The serial number of the column that want to change\n        :param save_file_name: str, source file name\n        :return:(int, str), The former is the return value of write_excel, while the latter is the saved file name of the processed data\n        \"\"\"\n        data = self.read_excel(save_file_name)\n        if data is None:\n            return 0, None\n\n        if not data:\n            print(\"Error: The Excel file is empty.\")\n            return 0, None\n\n        new_data = []\n        for row in data:\n            new_row = list(row)\n            if 0 <= N < len(new_row):\n                original_value = new_row[N]\n                if isinstance(original_value, str):\n                    new_row.append(original_value.upper())\n                else:\n                    new_row.append(original_value)\n            else:\n                print(f\"Error: Column index {N} is out of range.\")\n                return 0, None\n            new_data.append(tuple(new_row))\n\n        output_file_name = \"processed_\" + save_file_name\n        write_result = self.write_excel(new_data, output_file_name)\n        return write_result, output_file_name\n```",
    "39": "```python\nfrom collections import deque\nimport decimal\n\nclass ExpressionCalculator:\n    \"\"\"\n    This is a class in Python that can perform calculations with basic arithmetic operations, including addition, subtraction, multiplication, division, and modulo.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the expression calculator\n        \"\"\"\n        self.postfix_stack = deque()\n        self.operator_stack = deque()\n        self.priority = {'+': 1, '-': 1, '*': 2, '/': 2, '%': 2}\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the result of the given infix expression\n        :param expression: string, the infix expression to be calculated\n        :return: float, the calculated result\n        \"\"\"\n        try:\n            postfix_expression = self.infix_to_postfix(expression)\n            return self.evaluate_postfix(postfix_expression)\n        except Exception as e:\n            raise ValueError(f\"Invalid expression: {e}\")\n\n    def infix_to_postfix(self, expression):\n        \"\"\"\n        Convert an infix expression to postfix notation.\n        :param expression: The infix expression string.\n        :return: A deque representing the postfix expression.\n        \"\"\"\n        self.postfix_stack = deque()\n        self.operator_stack = deque()\n        expression = self.transform(expression)\n\n        for char in expression:\n            if char.isalnum():\n                self.postfix_stack.append(char)\n            elif char == '(':\n                self.operator_stack.append(char)\n            elif char == ')':\n                while self.operator_stack and self.operator_stack[-1] != '(':\n                    self.postfix_stack.append(self.operator_stack.pop())\n                if self.operator_stack:\n                    self.operator_stack.pop()  # Remove the '('\n                else:\n                    raise ValueError(\"Mismatched parentheses\")\n            elif self.is_operator(char):\n                while self.operator_stack and self.operator_stack[-1] != '(' and self.compare(char, self.operator_stack[-1]):\n                    self.postfix_stack.append(self.operator_stack.pop())\n                self.operator_stack.append(char)\n\n        while self.operator_stack:\n            if self.operator_stack[-1] == '(':\n                raise ValueError(\"Mismatched parentheses\")\n            self.postfix_stack.append(self.operator_stack.pop())\n\n        return self.postfix_stack\n\n    def evaluate_postfix(self, postfix_expression):\n        \"\"\"\n        Evaluate a postfix expression.\n        :param postfix_expression: A deque representing the postfix expression.\n        :return: The result of the evaluation as a float.\n        \"\"\"\n        stack = deque()\n        for item in postfix_expression:\n            if not self.is_operator(item):\n                stack.append(item)\n            else:\n                if len(stack) < 2:\n                    raise ValueError(\"Invalid postfix expression\")\n                second_value = stack.pop()\n                first_value = stack.pop()\n                result = self._calculate(first_value, second_value, item)\n                stack.append(str(result))\n\n        if len(stack) != 1:\n            raise ValueError(\"Invalid postfix expression\")\n\n        return float(stack[0])\n\n    def prepare(self, expression):\n        \"\"\"\n        Prepare the infix expression for conversion to postfix notation\n        :param expression: string, the infix expression to be prepared\n        \"\"\"\n        self.infix_to_postfix(expression)\n\n    @staticmethod\n    def is_operator(c):\n        \"\"\"\n        Check if a character is an operator in {'+', '-', '*', '/', '(', ')', '%'}\n        :param c: string, the character to be checked\n        :return: bool, True if the character is an operator, False otherwise\n        \"\"\"\n        return c in {'+', '-', '*', '/', '%'}\n\n    def compare(self, cur, peek):\n        \"\"\"\n        Compare the precedence of two operators\n        :param cur: string, the current operator\n        :param peek: string, the operator at the top of the operator stack\n        :return: bool, True if the current operator has higher or equal precedence, False otherwise\n        \"\"\"\n        return self.priority.get(peek, 0) >= self.priority.get(cur, 0)\n\n    @staticmethod\n    def _calculate(first_value, second_value, current_op):\n        \"\"\"\n        Perform the mathematical calculation based on the given operands and operator\n        :param first_value: string, the first operand\n        :param second_value: string, the second operand\n        :param current_op: string, the operator\n        :return: decimal.Decimal, the calculated result\n        \"\"\"\n        first_value = decimal.Decimal(first_value)\n        second_value = decimal.Decimal(second_value)\n        if current_op == '+':\n            return first_value + second_value\n        elif current_op == '-':\n            return first_value - second_value\n        elif current_op == '*':\n            return first_value * second_value\n        elif current_op == '/':\n            if second_value == 0:\n                raise ZeroDivisionError(\"Division by zero\")\n            return first_value / second_value\n        elif current_op == '%':\n            return first_value % second_value\n        else:\n            raise ValueError(\"Invalid operator\")\n\n    @staticmethod\n    def transform(expression):\n        \"\"\"\n        Transform the infix expression to a format suitable for conversion\n        :param expression: string, the infix expression to be transformed\n        :return: string, the transformed expression\n        \"\"\"\n        expression = expression.replace(\" \", \"\")\n        expression = expression.replace(\"(-\", \"(~\")\n        expression = expression.replace(\"-\", \"~\", 1) if expression.startswith('-') else expression\n        expression = expression.replace(\"~(\", \"0-(\")\n        expression = expression.replace(\"~\", \"0-\")\n        return expression\n```",
    "40": "```python\nclass FitnessTracker:\n    \"\"\"\n    This is a class as fitness tracker that implements to calculate BMI (Body Mass Index) and calorie intake based on the user's height, weight, age, and sex.\n    \"\"\"\n\n    def __init__(self, height, weight, age, sex) -> None:\n        \"\"\"\n        Initialize the class with height, weight, age, and sex, and calculate the BMI standard based on sex, and male is 20-25, female is 19-24.\n        \"\"\"\n        self.height = height\n        self.weight = weight\n        self.age = age\n        self.sex = sex.lower()  # Store sex in lowercase for consistency\n        self.BMI_std = {\n            \"male\": [20, 25],\n            \"female\": [19, 24]\n        }\n\n    def get_BMI(self):\n        \"\"\"\n        Calculate the BMI based on the height and weight.\n        :return: BMI,which is the weight divide by the square of height, float.\n\n        \"\"\"\n        return self.weight / (self.height ** 2)\n\n    def condition_judge(self):\n        \"\"\"\n        Judge the condition of the user based on the BMI standard.\n        :return: 1 if the user is too fat, -1 if the user is too thin, 0 if the user is normal, int.\n\n        \"\"\"\n        bmi = self.get_BMI()\n        bmi_range = self.BMI_std[self.sex]\n        if bmi > bmi_range[1]:\n            return 1\n        elif bmi < bmi_range[0]:\n            return -1\n        else:\n            return 0\n\n    def calculate_calorie_intake(self):\n        \"\"\"\n        Calculate the calorie intake based on the user's condition and BMR (Basal Metabolic Rate),BMR is calculated based on the user's height, weight, age, and sex,male is10 * self.weight + 6.25 * self.height - 5 * self.age + 5,female is 10 * self.weight + 6.25 * self.height - 5 * self.age - 161, and the calorie intake is calculated based on the BMR and the user's condition,if the user is too fat, the calorie intake is BMR * 1.2, if the user is too thin, the calorie intake is BMR * 1.4, if the user is normal, the calorie intake is BMR * 1.4.\n        :return: calorie intake, float.\n\n        \"\"\"\n        if self.sex == \"male\":\n            BMR = 10 * self.weight + 6.25 * self.height * 100 - 5 * self.age + 5\n        else:\n            BMR = 10 * self.weight + 6.25 * self.height * 100 - 5 * self.age - 161\n\n        condition = self.condition_judge()\n\n        if condition == 1:\n            calorie_intake = BMR * 1.2\n        elif condition == -1:\n            calorie_intake = BMR * 1.4\n        else:\n            calorie_intake = BMR * 1.4\n\n        return calorie_intake\n```",
    "41": "```python\nclass GomokuGame:\n    \"\"\"\n    This class is an implementation of a Gomoku game, supporting for making moves, checking for a winner, and checking if there are five consecutive symbols on the game board.\n    \"\"\"\n\n    def __init__(self, board_size):\n        \"\"\"\n        Initializes the game with a given board size.\n        It initializes the board with empty spaces and sets the current player symble as 'X'.\n        \"\"\"\n        self.board_size = board_size\n        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Makes a move at the given row and column.\n        If the move is valid, it places the current player's symbol on the board\n        and changes the current player to the other player (if the current player is 'X', then it becomes 'O' and vice versa).\n        :param row: int, the row index of this move\n        :param col: int, the column index\n        return: True if the move is valid, or False otherwise.\n        \"\"\"\n        if not (0 <= row < self.board_size and 0 <= col < self.board_size):\n            return False\n        if self.board[row][col] != ' ':\n            return False\n\n        self.board[row][col] = self.current_player\n        self.current_player = 'O' if self.current_player == 'X' else 'X'\n        return True\n\n    def check_winner(self):\n        \"\"\"\n        Checks if there is a winner by looking for five in a row in all directions (horizontal, vertical, diagonal).\n        return: the symbol of the winning player (either 'X' or 'O') if there is a winner, or None otherwise.\n        \"\"\"\n        for row in range(self.board_size):\n            for col in range(self.board_size):\n                if self.board[row][col] != ' ':\n                    player = self.board[row][col]\n                    # Check horizontal\n                    if self._check_line(row, col, 0, 1, player):\n                        return player\n                    # Check vertical\n                    if self._check_line(row, col, 1, 0, player):\n                        return player\n                    # Check diagonal (top-left to bottom-right)\n                    if self._check_line(row, col, 1, 1, player):\n                        return player\n                    # Check diagonal (top-right to bottom-left)\n                    if self._check_line(row, col, 1, -1, player):\n                        return player\n        return None\n\n    def _check_line(self, row, col, row_increment, col_increment, player):\n        \"\"\"\n        Checks for five in a row in a specific direction.\n\n        :param row: Starting row.\n        :param col: Starting column.\n        :param row_increment: Increment for row.\n        :param col_increment: Increment for column.\n        :param player: The player to check for.\n        :return: True if five in a row is found, False otherwise.\n        \"\"\"\n        count = 0\n        for i in range(5):\n            new_row = row + i * row_increment\n            new_col = col + i * col_increment\n            if (0 <= new_row < self.board_size and\n                    0 <= new_col < self.board_size and\n                    self.board[new_row][new_col] == player):\n                count += 1\n            else:\n                return False\n        return count == 5\n\n    def _check_five_in_a_row(self, row, col, direction):\n        \"\"\"\n        checks if there are five consecutive symbols of the same player in a row starting from a given cell in a given direction (horizontal, vertical, diagonal).\n        Counts the number of consecutive symbols in that direction starting from the given cell,\n        :param row: int, row of the given cell\n        :param col: int, column of the given cell\n        :param direction: tuple, (int, int), named as (dx, dy). Row and col will plus several dx and dy repectively.\n        :return: True if there are five consecutive symbols of the same player, and False otherwise.\n        \"\"\"\n        player = self.board[row][col]\n        count = 0\n        for i in range(5):\n            new_row = row + i * direction[0]\n            new_col = col + i * direction[1]\n            if 0 <= new_row < self.board_size and 0 <= new_col < self.board_size and self.board[new_row][new_col] == player:\n                count += 1\n            else:\n                return False\n        return count == 5\n```",
    "42": "```python\nclass Hotel:\n    \"\"\"\n    Manages hotel bookings, check-ins, check-outs, and room availability.\n    \"\"\"\n\n    def __init__(self, name, rooms):\n        \"\"\"\n        Initializes the Hotel object.\n\n        Args:\n            name (str): The name of the hotel.\n            rooms (dict): A dictionary representing the available rooms,\n                          where keys are room types (str) and values are\n                          the number of available rooms of that type (int).\n        \"\"\"\n        self.name = name\n        self.available_rooms = rooms.copy()  # Create a copy to avoid modifying the original\n        self.booked_rooms = {}\n\n    def book_room(self, room_type, room_number, name):\n        \"\"\"\n        Books rooms of a specified type for a guest.\n\n        Args:\n            room_type (str): The type of room to book.\n            room_number (int): The number of rooms to book.\n            name (str): The name of the guest making the booking.\n\n        Returns:\n            str: 'Success!' if the booking was successful.\n            int: The number of available rooms of the specified type if the\n                 requested number exceeds availability but some rooms are still available.\n            bool: False if the room type is not available or if there are no\n                  rooms of the specified type available.\n        \"\"\"\n        if room_type not in self.available_rooms:\n            return False\n\n        available = self.available_rooms[room_type]\n\n        if room_number <= available:\n            self.available_rooms[room_type] -= room_number\n\n            if room_type not in self.booked_rooms:\n                self.booked_rooms[room_type] = {}\n\n            if name not in self.booked_rooms[room_type]:\n                self.booked_rooms[room_type][name] = 0\n\n            self.booked_rooms[room_type][name] += room_number\n            return 'Success!'\n        elif available > 0:\n            return available\n        else:\n            return False\n\n    def check_in(self, room_type, room_number, name):\n        \"\"\"\n        Checks a guest into a booked room.\n\n        Args:\n            room_type (str): The type of room being checked into.\n            room_number (int): The number of rooms being checked into.\n            name (str): The name of the guest checking in.\n\n        Returns:\n            bool: True if check-in was successful, False otherwise.\n        \"\"\"\n        if room_type not in self.booked_rooms or name not in self.booked_rooms[room_type] or self.booked_rooms[room_type].get(name, 0) < room_number:\n            return False\n\n        if room_number == self.booked_rooms[room_type][name]:\n            del self.booked_rooms[room_type][name]\n            if not self.booked_rooms[room_type]:\n                del self.booked_rooms[room_type]\n        else:\n            self.booked_rooms[room_type][name] -= room_number\n        return True\n\n    def check_out(self, room_type, room_number):\n        \"\"\"\n        Checks a guest out of a room, making it available again.\n\n        Args:\n            room_type (str): The type of room being checked out.\n            room_number (int): The number of rooms being checked out.\n        \"\"\"\n        self.available_rooms[room_type] = self.available_rooms.get(room_type, 0) + room_number\n\n    def get_available_rooms(self, room_type):\n        \"\"\"\n        Gets the number of available rooms of a specified type.\n\n        Args:\n            room_type (str): The type of room to check availability for.\n\n        Returns:\n            int: The number of available rooms of the specified type.\n        \"\"\"\n        return self.available_rooms.get(room_type, 0)\n```",
    "43": "```python\nclass HRManagementSystem:\n    \"\"\"\n    This is a class as personnel management system that implements functions such as adding, deleting, querying, and updating employees\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the HRManagementSystem with an attribute employees, which is an empty dictionary.\n        \"\"\"\n        self.employees = {}\n\n    def add_employee(self, employee_id, name, position, department, salary):\n        \"\"\"\n        Add a new employee to the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :param name: The employee's name, str.\n        :param position: The employee's position, str.\n        :param department: The employee's department, str.\n        :param salary: The employee's salary, int.\n        :return: If the employee is already in the HRManagementSystem, returns False, otherwise, returns True.\n        \"\"\"\n        if employee_id in self.employees:\n            return False\n        self.employees[employee_id] = {'name': name, 'position': position, 'department': department, 'salary': salary}\n        return True\n\n    def remove_employee(self, employee_id):\n        \"\"\"\n        Remove an employee from the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :return: If the employee is already in the HRManagementSystem, returns True, otherwise, returns False.\n        \"\"\"\n        if employee_id in self.employees:\n            del self.employees[employee_id]\n            return True\n        return False\n\n    def update_employee(self, employee_id: int, employee_info: dict):\n        \"\"\"\n        Update an employee's information in the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :param employee_info: The employee's information, dict.\n        :return: If the employee is already in the HRManagementSystem, returns True, otherwise, returns False.\n        \"\"\"\n        if employee_id not in self.employees:\n            return False\n\n        for key in employee_info:\n            if key not in ['name', 'position', 'department', 'salary']:\n                return False\n\n        self.employees[employee_id].update(employee_info)\n        return True\n\n    def get_employee(self, employee_id):\n        \"\"\"\n        Get an employee's information from the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :return: If the employee is already in the HRManagementSystem, returns the employee's information, otherwise, returns False.\n        \"\"\"\n        if employee_id in self.employees:\n            return self.employees[employee_id]\n        return False\n\n    def list_employees(self):\n        \"\"\"\n        List all employees' information in the HRManagementSystem.\n        :return: A list of all employees' information,dict.\n        \"\"\"\n        employee_list = {}\n        for employee_id, employee_info in self.employees.items():\n            employee_list[employee_id] = {'employee_ID': employee_id, **employee_info}\n        return employee_list\n```",
    "44": "```python\nimport re\nfrom bs4 import BeautifulSoup\n\nclass HtmlUtil:\n    \"\"\"\n    This is a class as util for html, supporting for formatting and extracting code from HTML text, including cleaning up the text and converting certain elements into specific marks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a series of labels\n        \"\"\"\n        self.SPACE_MARK = '-SPACE-'\n        self.JSON_MARK = '-JSON-'\n        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'\n        self.URL_MARK = '-URL-'\n        self.NUMBER_MARK = '-NUMBER-'\n        self.TRACE_MARK = '-TRACE-'\n        self.COMMAND_MARK = '-COMMAND-'\n        self.COMMENT_MARK = '-COMMENT-'\n        self.CODE_MARK = '-CODE-'\n\n    @staticmethod\n    def __format_line_feed(text):\n        \"\"\"\n        Replace consecutive line breaks with a single line break\n        :param text: string with consecutive line breaks\n        :return:string, replaced text with single line break\n        \"\"\"\n        return re.sub(r'\\n+', '\\n', text)\n\n    def format_line_html_text(self, html_text):\n        \"\"\"\n        get the html text without the code, and add the code tag -CODE- where the code is\n        :param html_text:string\n        :return:string\n        \"\"\"\n        soup = BeautifulSoup(html_text, 'html.parser')\n        text = ''\n        for element in soup.recursiveChildGenerator():\n            if isinstance(element, str):\n                stripped_text = element.strip()\n                if stripped_text:  # Avoid adding empty lines\n                    text += stripped_text + '\\n'\n            elif element.name == 'pre':\n                text += self.CODE_MARK + '\\n'\n            elif element.name == 'ul':\n                for item in element.find_all('li'):\n                    text += '[-]'+ item.text + '.' + '\\n'\n            elif element.name == 'div':\n                stripped_text = element.text.strip()\n                if stripped_text:\n                    text += stripped_text + '\\n'\n            elif element.name == 'code':\n                stripped_text = element.text.strip()\n                if stripped_text:\n                    text += stripped_text + '\\n'\n\n        return HtmlUtil.__format_line_feed(text).strip()\n\n    def extract_code_from_html_text(self, html_text):\n        \"\"\"\n        extract codes from the html body\n        :param html_text: string, html text\n        :return: the list of code\n        \"\"\"\n        soup = BeautifulSoup(html_text, 'html.parser')\n        code_list = []\n        for pre in soup.find_all('pre'):\n            code = pre.find('code')\n            if code:\n                code_list.append(code.text)\n            else:\n                code_list.append(pre.text)\n        return code_list\n```",
    "45": "```python\nfrom PIL import Image, ImageEnhance, ImageChops\nimport os\n\nclass ImageProcessor:\n    \"\"\"\n    This is a class to process image, including loading, saving, resizing, rotating, and adjusting the brightness of images.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize self.image\n        \"\"\"\n        self.image = None\n\n    def load_image(self, image_path):\n        \"\"\"\n        Use Image util in PIL to open a image\n        :param image_path: str, path of image that is to be\n        \"\"\"\n        try:\n            self.image = Image.open(image_path)\n        except FileNotFoundError:\n            raise FileNotFoundError(f\"Image file not found at {image_path}\")\n        except Exception as e:\n            raise Exception(f\"Could not open image. {e}\")\n\n    def save_image(self, save_path):\n        \"\"\"\n        Save image to a path if image has opened\n        :param save_path: str, the path that the image will be saved\n        \"\"\"\n        if not self.image:\n            raise ValueError(\"No image loaded to save.\")\n\n        try:\n            self.image.save(save_path)\n        except Exception as e:\n            raise Exception(f\"Could not save image. {e}\")\n\n    def resize_image(self, width, height):\n        \"\"\"\n        Resize the image if image has opened.\n        :param width: int, the target width of image\n        :param height: int, the target height of image\n        \"\"\"\n        if not self.image:\n            raise ValueError(\"No image loaded to resize.\")\n\n        try:\n            self.image = self.image.resize((width, height))\n        except Exception as e:\n            raise Exception(f\"Could not resize image. {e}\")\n\n    def rotate_image(self, degrees):\n        \"\"\"\n        Rotate image if image has opened\n        :param degrees: float, the degrees that the image will be rotated\n        \"\"\"\n        if not self.image:\n            raise ValueError(\"No image loaded to rotate.\")\n\n        try:\n            self.image = self.image.rotate(degrees)\n        except Exception as e:\n            raise Exception(f\"Could not rotate image. {e}\")\n\n    def adjust_brightness(self, factor):\n        \"\"\"\n        Adjust the brightness of image if image has opened.\n        :param factor: float, brightness of an image. A factor of 0.0 gives a black image. A factor of 1.0 gives the original image.\n        \"\"\"\n        if not self.image:\n            raise ValueError(\"No image loaded to adjust brightness.\")\n\n        try:\n            enhancer = ImageEnhance.Brightness(self.image)\n            self.image = enhancer.enhance(factor)\n        except Exception as e:\n            raise Exception(f\"Could not adjust brightness. {e}\")\n```",
    "46": "```python\nclass Interpolation:\n    \"\"\"\n    This is a class that implements the Linear interpolation operation of one-dimensional and two-dimensional data\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        \"\"\"\n        Linear interpolation of one-dimensional data\n        :param x: The x-coordinate of the data point, list.\n        :param y: The y-coordinate of the data point, list.\n        :param x_interp: The x-coordinate of the interpolation point, list.\n        :return: The y-coordinate of the interpolation point, list.\n        \"\"\"\n        if not x or not y or not x_interp:\n            return []\n\n        if len(x) != len(y):\n            raise ValueError(\"x and y must have the same length\")\n\n        if len(x) < 2:\n            if not x:\n                return []\n            return [y[0]] * len(x_interp)\n\n        y_interp = []\n        for x_i in x_interp:\n            if x_i <= x[0]:\n                y_interp.append(y[0] + (x_i - x[0]) * (y[1] - y[0]) / (x[1] - x[0]))\n            elif x_i >= x[-1]:\n                y_interp.append(y[-1] + (x_i - x[-1]) * (y[-1] - y[-2]) / (x[-1] - x[-2]))\n            else:\n                for i in range(len(x) - 1):\n                    if x[i] <= x_i <= x[i + 1]:\n                        y_i = y[i] + (x_i - x[i]) * (y[i + 1] - y[i]) / (x[i + 1] - x[i])\n                        y_interp.append(y_i)\n                        break\n        return y_interp\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        \"\"\"\n        Linear interpolation of two-dimensional data\n        :param x: The x-coordinate of the data point, list.\n        :param y: The y-coordinate of the data point, list.\n        :param z: The z-coordinate of the data point, list.\n        :param x_interp: The x-coordinate of the interpolation point, list.\n        :param y_interp: The y-coordinate of the interpolation point, list.\n        :return: The z-coordinate of the interpolation point, list.\n        \"\"\"\n        z_interp = []\n        for x_i, y_i in zip(x_interp, y_interp):\n            for i in range(len(x) - 1):\n                for j in range(len(y) - 1):\n                    if x[i] <= x_i <= x[i + 1] and y[j] <= y_i <= y[j + 1]:\n                        x1, x2 = x[i], x[i + 1]\n                        y1, y2 = y[j], y[j + 1]\n\n                        z11 = z[i][j]\n                        z12 = z[i][j + 1]\n                        z21 = z[i + 1][j]\n                        z22 = z[i + 1][j + 1]\n\n                        z_interp_val = (z11 * (x2 - x_i) * (y2 - y_i) +\n                                          z21 * (x_i - x1) * (y2 - y_i) +\n                                          z12 * (x2 - x_i) * (y_i - y1) +\n                                          z22 * (x_i - x1) * (y_i - y1)) / ((x2 - x1) * (y2 - y1))\n                        z_interp.append(z_interp_val)\n                        break\n                else:\n                    continue\n                break\n        return z_interp\n```",
    "47": "```python\nclass IPAddress:\n    \"\"\"\n    This is a class to process IP Address, including validating, getting the octets and obtaining the binary representation of a valid IP address.\n    \"\"\"\n\n    def __init__(self, ip_address):\n        \"\"\"\n        Initialize the IP address to the specified address\n        :param ip_address:string\n        \"\"\"\n        self.ip_address = ip_address\n\n\n    def is_valid(self):\n        \"\"\"\n        Judge whether the IP address is valid, that is, whether the IP address is composed of four Decimal digits separated by '.'. Each digit is greater than or equal to 0 and less than or equal to 255\n        :return: bool\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.is_valid()\n        True\n        \"\"\"\n        octets = self.ip_address.split('.')\n        if len(octets) != 4:\n            return False\n\n        for octet in octets:\n            if not octet.isdigit():\n                return False\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return False\n\n        return True\n\n\n    def get_octets(self):\n        \"\"\"\n        If the IP address is valid, the list of four decimal numbers separated by \".\" constituting the IP address is returned; otherwise, an empty list is returned\n        :return: list\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.get_octets()\n        [\"10\", \"10\", \"10\", \"10\"]\n        \"\"\"\n        if not self.is_valid():\n            return []\n        return self.ip_address.split('.')\n\n\n    def get_binary(self):\n        \"\"\"\n        If the IP address is valid, return the binary form of the IP address; otherwise, return ''\n        :return: string\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.get_binary()\n        \"00001010.00001010.00001010.00001010\"\n        \"\"\"\n        if not self.is_valid():\n            return ''\n\n        octets = self.get_octets()\n        binary_octets = [bin(int(octet))[2:].zfill(8) for octet in octets]\n\n        return '.'.join(binary_octets)\n```",
    "48": "```python\nimport socket\nimport ipaddress\n\n\nclass IpUtil:\n    \"\"\"\n    This is a class as tool for ip that can be used to obtain the local IP address, validate its validity, and also provides the functionality to retrieve the corresponding hostname.\n    \"\"\"\n\n    @staticmethod\n    def is_valid_ipv4(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv4 address.\n        :param ip_address: string, the IP address to check\n        :return: bool, True if the IP address is valid, False otherwise\n        \"\"\"\n        try:\n            ipaddress.IPv4Address(ip_address)\n            return True\n        except ipaddress.AddressValueError:\n            return False\n\n    @staticmethod\n    def is_valid_ipv6(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv6 address.\n        :param ip_address: string, the IP address to check\n        :return: bool, True if the IP address is valid, False otherwise\n        \"\"\"\n        try:\n            ipaddress.IPv6Address(ip_address)\n            return True\n        except ipaddress.AddressValueError:\n            return False\n\n    @staticmethod\n    def get_hostname(ip_address):\n        \"\"\"\n        Get the hostname associated with the given IP address.\n        :param ip_address: string, the IP address to get the hostname for\n        :return: string, the hostname associated with the IP address, None if not found.\n        \"\"\"\n        try:\n            hostname, _, _ = socket.gethostbyaddr(ip_address)\n            return hostname\n        except socket.herror:\n            return None\n        except socket.gaierror:\n            return None\n        except OSError:\n            return socket.gethostname()\n```",
    "49": "```python\nclass JobMarketplace:\n    \"\"\"\n    This is a class that provides functionalities to publish positions, remove positions, submit resumes, withdraw resumes, search for positions, and obtain candidate information.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the JobMarketplace with empty lists for job listings and resumes.\n        \"\"\"\n        self.job_listings = []\n        self.resumes = []\n\n    def post_job(self, job_title, company, requirements):\n        \"\"\"\n        Publishes a new job listing.\n\n        :param job_title: The title of the position (str).\n        :param company: The company offering the position (str).\n        :param requirements: A list of required skills or qualifications (list of str).\n        :return: None\n        \"\"\"\n        job = {\n            'job_title': job_title,\n            'company': company,\n            'requirements': requirements\n        }\n        self.job_listings.append(job)\n\n    def remove_job(self, job):\n        \"\"\"\n        Removes a job listing from the marketplace.\n\n        :param job: The job listing to remove (dict).\n        :return: None\n        \"\"\"\n        if job in self.job_listings:\n            self.job_listings.remove(job)\n\n    def submit_resume(self, name, skills, experience):\n        \"\"\"\n        Submits a resume to the marketplace.\n\n        :param name: The name of the applicant (str).\n        :param skills: A list of skills possessed by the applicant (list of str).\n        :param experience: A brief description of the applicant's experience (str).\n        :return: None\n        \"\"\"\n        resume = {\n            'name': name,\n            'skills': skills,\n            'experience': experience\n        }\n        self.resumes.append(resume)\n\n    def withdraw_resume(self, resume):\n        \"\"\"\n        Withdraws a resume from the marketplace.\n\n        :param resume: The resume to withdraw (dict).\n        :return: None\n        \"\"\"\n        if resume in self.resumes:\n            self.resumes.remove(resume)\n\n    def search_jobs(self, criteria):\n        \"\"\"\n        Searches for job listings that match the given criteria.\n\n        :param criteria: The search criteria (str).  Looks for this string within the job requirements.\n        :return: A list of job listings that match the criteria (list of dict).\n        \"\"\"\n        results = []\n        for job in self.job_listings:\n            if criteria in job['requirements']:\n                results.append(job)\n        return results\n\n    def get_job_applicants(self, job):\n        \"\"\"\n        Retrieves a list of applicants whose skills match the job requirements.\n\n        :param job: The job listing to find applicants for (dict).\n        :return: A list of resumes that match the job requirements (list of dict).\n        \"\"\"\n        applicants = []\n        for resume in self.resumes:\n            if self.matches_requirements(resume, job['requirements']):\n                applicants.append(resume)\n        return applicants\n\n    def matches_requirements(self, resume, requirements):\n        \"\"\"\n        Checks if a resume's skills meet all the job requirements.\n\n        :param resume: The resume to check (dict).\n        :param requirements: A list of required skills (list of str).\n        :return: True if the resume meets all requirements, False otherwise (bool).\n        \"\"\"\n        for requirement in requirements:\n            if requirement not in resume['skills']:\n                return False\n        return True\n```",
    "50": "```python\nimport json\nimport os\n\nclass JSONProcessor:\n    \"\"\"\n    This is a class to process JSON file, including reading and writing JSON files, as well as processing JSON data by removing a specified key from the JSON object.\n    \"\"\"\n\n    def read_json(self, file_path):\n        \"\"\"\n        Read a JSON file and return the data.\n        :param file_path: str, the path of the JSON file.\n        :return: dict, the data from the JSON file if read successfully, or None if an error occurs during the reading process,\n                 or None if the file does not exist.\n        \"\"\"\n        if not os.path.exists(file_path):\n            return 0\n\n        try:\n            with open(file_path, 'r') as file:\n                data = json.load(file)\n                return data\n        except json.JSONDecodeError:\n            return -1\n        except Exception:\n            return -1\n\n    def write_json(self, data, file_path):\n        \"\"\"\n        Write data to a JSON file and save it to the given path.\n\n        :param data: dict, the data to be written to the JSON file.\n        :param file_path: str, the path of the JSON file.\n        :return: True if the writing process is successful, False if an error occurs during the writing process.\n        \"\"\"\n        try:\n            with open(file_path, 'w') as file:\n                json.dump(data, file)\n            return 1\n        except Exception:\n            return -1\n\n    def process_json(self, file_path, remove_key):\n        \"\"\"\n        Read a JSON file and process the data by removing a specified key and rewrite the modified data back to the file.\n\n        :param file_path: str, the path of the JSON file.\n        :param remove_key: str, the key to be removed.\n        :return: True if the specified key is successfully removed and the data is written back,\n                 False if the file does not exist or the specified key does not exist in the data.\n        \"\"\"\n        data = self.read_json(file_path)\n\n        if data == 0:\n            return 0\n\n        if data == -1:\n            return 0\n\n        if remove_key in data:\n            del data[remove_key]\n            if self.write_json(data, file_path) == 1:\n                return 1\n            else:\n                return 0\n        else:\n            return 0\n```",
    "51": "```python\nimport numpy as np\n\nclass KappaCalculator:\n    \"\"\"\n    This is a class as KappaCalculator, supporting to calculate Cohen's and Fleiss' kappa coefficient.\n    \"\"\"\n\n    @staticmethod\n    def kappa(testData):\n        \"\"\"\n        Calculate Cohen's kappa coefficient.\n\n        Args:\n            testData: A square matrix representing the confusion matrix.  Rows and columns\n                      represent the categories being rated.\n\n        Returns:\n            float: Cohen's kappa value.\n\n        Raises:\n            ValueError: if the input matrix is not square.\n        \"\"\"\n        matrix = np.array(testData)\n        if matrix.shape[0] != matrix.shape[1]:\n            raise ValueError(\"Input matrix must be square.\")\n\n        n = len(matrix)\n        total_sum = np.sum(matrix)\n        observed_agreement = np.trace(matrix) / total_sum\n\n        row_sums = np.sum(matrix, axis=1)\n        col_sums = np.sum(matrix, axis=0)\n\n        expected_agreement = np.sum(row_sums * col_sums) / (total_sum ** 2)\n\n        kappa = (observed_agreement - expected_agreement) / (1 - expected_agreement)\n        return kappa\n\n    @staticmethod\n    def fleiss_kappa(testData):\n        \"\"\"\n        Calculate Fleiss' kappa coefficient for inter-rater reliability.\n\n        Args:\n            testData: A matrix where rows represent subjects and columns represent categories.\n                      Each cell contains the number of raters who assigned that category to that subject.\n\n        Returns:\n            float: Fleiss' kappa value.\n        \"\"\"\n        data = np.array(testData)\n        N, k = data.shape\n        n = np.sum(data[0, :])  # Assuming all subjects have the same number of ratings\n\n        total_ratings = N * n\n\n        # Calculate the proportion of all assignments which were to the ith category\n        p_i = np.sum(data, axis=0) / total_ratings\n\n        # Calculate the extent to which raters agree for the jth subject\n        P_j = (np.sum(data**2, axis=1) - n) / (n * (n - 1))\n\n        # Calculate the mean extent to which raters agree\n        P_mean = np.mean(P_j)\n\n        # Calculate the extent to which agreement is expected by chance\n        P_e = np.sum(p_i**2)\n\n        # Calculate Fleiss' Kappa\n        kappa = (P_mean - P_e) / (1 - P_e)\n\n        return kappa\n```",
    "52": "```python\nimport nltk\nfrom nltk.stem import WordNetLemmatizer\nfrom nltk import pos_tag, word_tokenize\nimport string\n\n\nnltk.download('averaged_perceptron_tagger')\nnltk.download('punkt')\nnltk.download('wordnet')\n\nclass Lemmatization:\n    \"\"\"\n    This is a class about Lemmatization, which utilizes the nltk library to perform lemmatization and part-of-speech tagging on sentences, as well as remove punctuation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        creates a WordNetLemmatizer object and stores it in the self.lemmatizer member variable.\n        \"\"\"\n        self.lemmatizer = WordNetLemmatizer()\n\n    def lemmatize_sentence(self, sentence):\n        \"\"\"\n        Remove punctuations of the sentence and tokenizes the input sentence, mark the part of speech tag of each word,\n        lemmatizes the words with different parameters based on their parts of speech, and stores in a list.\n        :param sentence: a sentence str\n        :return: a list of words which have been lemmatized.\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.lemmatize_sentence(\"I am running in a race.\")\n        ['I', 'be', 'run', 'in', 'a', 'race']\n\n        \"\"\"\n        sentence = self.remove_punctuation(sentence)\n        tokens = word_tokenize(sentence)\n        pos_tags = self.get_pos_tag(sentence)\n        lemmatized_words = []\n        for i, token in enumerate(tokens):\n            pos_tag_prefix = pos_tags[i][0].upper() if pos_tags[i] else ''\n            if pos_tag_prefix == 'J':\n                lemmatized_word = self.lemmatizer.lemmatize(token, pos='a')\n            elif pos_tag_prefix == 'V':\n                lemmatized_word = self.lemmatizer.lemmatize(token, pos='v')\n            elif pos_tag_prefix == 'N':\n                lemmatized_word = self.lemmatizer.lemmatize(token, pos='n')\n            elif pos_tag_prefix == 'R':\n                lemmatized_word = self.lemmatizer.lemmatize(token, pos='r')\n            else:\n                lemmatized_word = self.lemmatizer.lemmatize(token)\n            lemmatized_words.append(lemmatized_word)\n        return lemmatized_words\n\n    def get_pos_tag(self, sentence):\n        \"\"\"\n        Remove punctuations of the sentence and tokenizes the input sentence, mark the part of speech tag of each word.\n        :param sentence: a sentence str\n        :return: list, part of speech tag of each word in the sentence.\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.get_pos_tag(\"I am running in a race.\")\n        ['PRP', 'VBP', 'VBG', 'IN', 'DT', 'NN']\n\n        \"\"\"\n        sentence = self.remove_punctuation(sentence)\n        tokens = word_tokenize(sentence)\n        pos_tags = pos_tag(tokens)\n        return [tag for word, tag in pos_tags]\n\n    def remove_punctuation(self, sentence):\n        \"\"\"\n        Removes punctuation from the input text.\n        :param sentence: a sentence str\n        :return: str, sentence without any punctuation\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.remove_punctuation(\"I am running in a race.\")\n        'I am running in a race'\n\n        \"\"\"\n        translator = str.maketrans('', '', string.punctuation)\n        return sentence.translate(translator)\n```",
    "53": "```python\nimport re\nimport string\n\nclass LongestWord:\n    \"\"\"\n    This is a class allows to add words to a list and find the longest word in a given sentence by comparing the words with the ones in the word list.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a list of word.\n        \"\"\"\n        self.word_list = []\n\n    def add_word(self, word):\n        \"\"\"\n        Append the input word into self.word_list.\n        :param word: str, input word\n        \"\"\"\n        self.word_list.append(word)\n\n    def find_longest_word(self, sentence):\n        \"\"\"\n        Remove punctuation marks and split a sentence into a list of word. Find the longest splited word that is in the self.word_list.\n        Words are strictly case sensitive.\n        :param sentence: a sentence str\n        :return str: longest splited word that is in the self.word_list. Return '' if self.word_list is empty.\n        \"\"\"\n        if not self.word_list:\n            return ''\n\n        # Remove punctuation marks from the sentence\n        sentence = sentence.translate(str.maketrans('', '', string.punctuation))\n\n        # Split the sentence into words\n        words = sentence.split()\n\n        # Find the longest word that is in the word_list\n        longest_word = ''\n        for word in words:\n            if word in self.word_list:\n                if len(word) > len(longest_word):\n                    longest_word = word\n\n        return longest_word\n```",
    "54": "```python\nimport random\n\nclass MahjongConnect:\n    \"\"\"\n    MahjongConnect is a class representing a game board for Mahjong Connect with features like creating the board, checking valid moves, finding paths, removing icons, and checking if the game is over.\n    \"\"\"\n\n    def __init__(self, BOARD_SIZE, ICONS):\n        \"\"\"\n        initialize the board size and the icon list, create the game board\n        :param BOARD_SIZE: list of two integer numbers, representing the number of rows and columns of the game board\n        :param ICONS: list of string, representing the icons\n        \"\"\"\n        self.BOARD_SIZE = BOARD_SIZE\n        self.ICONS = ICONS\n        self.board = self.create_board()\n\n    def create_board(self):\n        \"\"\"\n        create the game board with the given board size and icons\n        :return: 2-dimensional list, the game board\n        \"\"\"\n        rows, cols = self.BOARD_SIZE\n        board = []\n        icons = self.ICONS * ((rows * cols) // len(self.ICONS))\n        if (rows * cols) % len(self.ICONS) != 0:\n            icons += self.ICONS[:(rows * cols) % len(self.ICONS)]\n        random.shuffle(icons)\n        \n        board_icons = icons[:rows * cols]\n        board = [board_icons[i * cols:(i + 1) * cols] for i in range(rows)]\n        \n        return board\n\n    def is_valid_move(self, pos1, pos2):\n        \"\"\"\n        check if the move of two icons is valid (i.e. positions are within the game board range, the two positions are not the same, the two positions have the same icon, and there is a valid path between the two positions)\n        :param pos1: position tuple(x, y) of the first icon\n        :param pos2: position tuple(x, y) of the second icon\n        :return:True or False ,representing whether the move of two icons is valid\n        \"\"\"\n        if not self.is_valid_position(pos1) or not self.is_valid_position(pos2):\n            return False\n\n        if pos1 == pos2:\n            return False\n\n        if self.board[pos1[0]][pos1[1]] != self.board[pos2[0]][pos2[1]]:\n            return False\n\n        if self.board[pos1[0]][pos1[1]] == ' ':\n            return False\n\n        return self.has_path(pos1, pos2)\n\n    def is_valid_position(self, pos):\n        \"\"\"\n        check if the position is within the game board range\n        :param pos: position tuple(x, y) of the icon\n        :return: True or False, representing whether the position is valid\n        \"\"\"\n        rows, cols = self.BOARD_SIZE\n        r, c = pos\n        return 0 <= r < rows and 0 <= c < cols\n\n    def has_path(self, pos1, pos2):\n        \"\"\"\n        check if there is a path between two icons\n        :param pos1: position tuple(x, y) of the first icon\n        :param pos2: position tuple(x, y) of the second icon\n        :return: True or False ,representing whether there is a path between two icons\n        \"\"\"\n        rows, cols = self.BOARD_SIZE\n\n        def find_path(p1, p2, turns):\n            if turns > 2:\n                return False\n\n            if p1 == p2:\n                return True\n\n            r, c = p1\n            \n            # Move horizontally\n            for nc in range(cols):\n                if nc == c:\n                    continue\n                \n                valid_horizontal = True\n                for k in range(min(c, nc) + 1, max(c, nc)):\n                    if self.board[r][k] != ' ':\n                        valid_horizontal = False\n                        break\n                \n                if valid_horizontal:\n                    if find_path((r, nc), p2, turns + (1 if nc != c else 0)):\n                        return True\n\n            # Move vertically\n            for nr in range(rows):\n                if nr == r:\n                    continue\n                \n                valid_vertical = True\n                for k in range(min(r, nr) + 1, max(r, nr)):\n                    if self.board[k][c] != ' ':\n                        valid_vertical = False\n                        break\n                \n                if valid_vertical:\n                    if find_path((nr, c), p2, turns + (1 if nr != r else 0)):\n                        return True\n\n            return False\n\n        return find_path(pos1, pos2, 0)\n\n    def remove_icons(self, pos1, pos2):\n        \"\"\"\n        remove the connected icons on the game board\n        :param pos1: position tuple(x, y) of the first icon to be removed\n        :param pos2: position tuple(x, y) of the second icon to be removed\n        :return: None\n        \"\"\"\n        self.board[pos1[0]][pos1[1]] = ' '\n        self.board[pos2[0]][pos2[1]] = ' '\n\n    def is_game_over(self):\n        \"\"\"\n        Check if the game is over (i.e., if there are no more icons on the game board)\n        :return: True or False ,representing whether the game is over\n        \"\"\"\n        for row in self.board:\n            for icon in row:\n                if icon != ' ':\n                    return False\n        return True\n```",
    "55": "```python\nclass Manacher:\n    \"\"\"\n    This is a class that implements the Manacher algorithm to find the longest palindromic substring in a given string.\n    \"\"\"\n\n    def __init__(self, input_string: str) -> None:\n        \"\"\"\n        Initializes the Manacher class with the given input_string.\n\n        :param input_string: The input string to be searched, str.\n        \"\"\"\n        self.input_string = input_string\n\n    def palindromic_length(self, center: int, diff: int, string: str) -> int:\n        \"\"\"\n        Calculates the length of the palindromic substring based on a given center and difference.\n        This iterative approach avoids recursion and potential stack overflow issues.\n\n        :param center: The center of the palindromic substring, int.\n        :param diff: The difference between the center and the current position, int.\n        :param string: The string to be searched, str.\n        :return: The length of the palindromic substring, int.\n        \"\"\"\n        left = center - diff\n        right = center + diff\n        length = 0\n\n        while left >= 0 and right < len(string) and string[left] == string[right]:\n            length += 1\n            left -= 1\n            right += 1\n\n        return length\n\n    def palindromic_string(self) -> str:\n        \"\"\"\n        Finds the longest palindromic substring in the given string using the Manacher's algorithm.\n\n        :return: The longest palindromic substring, str.\n        \"\"\"\n        # Preprocess the string to handle even length palindromes\n        processed_string = '#' + '#'.join(self.input_string) + '#'\n        n = len(processed_string)\n        palindrome_radii = [0] * n  # Array to store palindrome radii centered at each index\n        center = 0  # Center of the current rightmost palindrome\n        right = 0  # Right boundary of the current rightmost palindrome\n        max_len = 0  # Length of the longest palindrome found so far\n        max_center = 0  # Center of the longest palindrome found so far\n\n        for i in range(n):\n            # Utilize symmetry to initialize palindrome_radii[i]\n            mirror = 2 * center - i\n            if right > i:\n                palindrome_radii[i] = min(right - i, palindrome_radii[mirror])\n\n            # Expand palindrome centered at i\n            left = i - (1 + palindrome_radii[i])\n            right_bound = i + (1 + palindrome_radii[i])\n            while left >= 0 and right_bound < n and processed_string[left] == processed_string[right_bound]:\n                palindrome_radii[i] += 1\n                left -= 1\n                right_bound += 1\n\n            # Update center and right boundary if palindrome centered at i expands past right\n            if i + palindrome_radii[i] > right:\n                center = i\n                right = i + palindrome_radii[i]\n\n            # Update max_len and max_center\n            if palindrome_radii[i] > max_len:\n                max_len = palindrome_radii[i]\n                max_center = i\n\n        # Extract the longest palindromic substring from the original string\n        start = (max_center - max_len) // 2\n        return self.input_string[start: start + max_len]\n```",
    "56": "```python\nclass MetricsCalculator:\n    \"\"\"\n    The class calculates precision, recall, F1 score, and accuracy based on predicted and true labels.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the number of true positives, false positives, false negatives, and true negatives to 0.\n        \"\"\"\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n    def update(self, predicted_labels, true_labels):\n        \"\"\"\n        Update the counts of true positives, false positives, false negatives, and true negatives\n        based on the predicted and true labels.\n\n        :param predicted_labels: list, predicted results (1 for positive, 0 for negative)\n        :param true_labels: list, true labels (1 for positive, 0 for negative)\n        :raises ValueError: if predicted_labels and true_labels have different lengths.\n        \"\"\"\n        if len(predicted_labels) != len(true_labels):\n            raise ValueError(\"predicted_labels and true_labels must have the same length\")\n\n        for predicted, true in zip(predicted_labels, true_labels):\n            if predicted == 1 and true == 1:\n                self.true_positives += 1\n            elif predicted == 1 and true == 0:\n                self.false_positives += 1\n            elif predicted == 0 and true == 1:\n                self.false_negatives += 1\n            elif predicted == 0 and true == 0:\n                self.true_negatives += 1\n\n    def precision(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate precision.\n\n        :param predicted_labels: list, predicted results (1 for positive, 0 for negative)\n        :param true_labels: list, true labels (1 for positive, 0 for negative)\n        :return: float, precision score. Returns 0.0 if no positive predictions are made.\n        \"\"\"\n        tp = 0\n        fp = 0\n        for predicted, true in zip(predicted_labels, true_labels):\n            if predicted == 1 and true == 1:\n                tp += 1\n            elif predicted == 1 and true == 0:\n                fp += 1\n\n        if tp + fp == 0:\n            return 0.0\n        return tp / (tp + fp)\n\n    def recall(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate recall.\n\n        :param predicted_labels: list, predicted results (1 for positive, 0 for negative)\n        :param true_labels: list, true labels (1 for positive, 0 for negative)\n        :return: float, recall score. Returns 0.0 if no actual positives are present.\n        \"\"\"\n        tp = 0\n        fn = 0\n        for predicted, true in zip(predicted_labels, true_labels):\n            if predicted == 1 and true == 1:\n                tp += 1\n            elif predicted == 0 and true == 1:\n                fn += 1\n\n        if tp + fn == 0:\n            return 0.0\n        return tp / (tp + fn)\n\n    def f1_score(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate F1 score, the harmonic mean of precision and recall.\n\n        :param predicted_labels: list, predicted results (1 for positive, 0 for negative)\n        :param true_labels: list, true labels (1 for positive, 0 for negative)\n        :return: float, F1 score. Returns 0.0 if both precision and recall are 0.\n        \"\"\"\n        precision_value = self.precision(predicted_labels, true_labels)\n        recall_value = self.recall(predicted_labels, true_labels)\n\n        if precision_value + recall_value == 0:\n            return 0.0\n\n        return 2 * (precision_value * recall_value) / (precision_value + recall_value)\n\n    def accuracy(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate accuracy.\n\n        :param predicted_labels: list, predicted results (1 for positive, 0 for negative)\n        :param true_labels: list, true labels (1 for positive, 0 for negative)\n        :return: float, accuracy score. Returns 0.0 if the input lists are empty.\n        \"\"\"\n        correct = 0\n        total = len(predicted_labels)\n        if total == 0:\n            return 0.0\n\n        for predicted, true in zip(predicted_labels, true_labels):\n            if predicted == true:\n                correct += 1\n\n        return correct / total\n```",
    "57": "```python\nimport numpy as np\n\n\nclass MetricsCalculator2:\n    \"\"\"\n    The class provides to calculate Mean Reciprocal Rank (MRR) and Mean Average Precision (MAP) based on input data, where MRR measures the ranking quality and MAP measures the average precision.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def mrr(data):\n        \"\"\"\n        Compute the Mean Reciprocal Rank (MRR) of the input data.\n\n        Args:\n            data: A tuple or list of tuples. Each tuple should be in the format\n                  (results, ground_truth_num), where:\n                  - results is a list of 1s and 0s, representing correct and\n                    incorrect answers, respectively.\n                  - ground_truth_num is the total number of ground truth items.\n\n        Returns:\n            A tuple containing:\n            - The mean reciprocal rank (float).\n            - A list of reciprocal ranks for each input tuple.\n        \"\"\"\n        if not isinstance(data, (list, tuple)):\n            raise TypeError(\"Input data must be a list or tuple.\")\n\n        if isinstance(data, tuple):\n            data = [data]\n\n        if not data:\n            return 0.0, [0.0]\n\n        reciprocal_ranks = []\n        for item in data:\n            if not isinstance(item, tuple) or len(item) != 2:\n                raise ValueError(\n                    \"Each item in the list must be a tuple of (results, ground_truth_num).\"\n                )\n\n            results, ground_truth_num = item\n            if not isinstance(results, list):\n                raise TypeError(\"Results must be a list.\")\n\n            try:\n                rank = next(i + 1 for i, x in enumerate(results) if x == 1)\n                reciprocal_rank = 1.0 / rank\n            except StopIteration:\n                reciprocal_rank = 0.0\n            reciprocal_ranks.append(reciprocal_rank)\n\n        mean_reciprocal_rank = np.mean(reciprocal_ranks) if reciprocal_ranks else 0.0\n        return mean_reciprocal_rank, reciprocal_ranks\n\n    @staticmethod\n    def map(data):\n        \"\"\"\n        Compute the Mean Average Precision (MAP) of the input data.\n\n        Args:\n            data: A tuple or list of tuples. Each tuple should be in the format\n                  (results, ground_truth_num), where:\n                  - results is a list of 1s and 0s, representing correct and\n                    incorrect answers, respectively.\n                  - ground_truth_num is the total number of ground truth items.\n\n        Returns:\n            A tuple containing:\n            - The mean average precision (float).\n            - A list of average precisions for each input tuple.\n        \"\"\"\n        if not isinstance(data, (list, tuple)):\n            raise TypeError(\"Input data must be a list or tuple.\")\n\n        if isinstance(data, tuple):\n            data = [data]\n\n        if not data:\n            return 0.0, [0.0]\n\n        average_precisions = []\n        for item in data:\n            if not isinstance(item, tuple) or len(item) != 2:\n                raise ValueError(\n                    \"Each item in the list must be a tuple of (results, ground_truth_num).\"\n                )\n\n            results, ground_truth_num = item\n            if not isinstance(results, list):\n                raise TypeError(\"Results must be a list.\")\n\n            relevant_count = 0\n            precision_sum = 0.0\n            for i, result in enumerate(results):\n                if result == 1:\n                    relevant_count += 1\n                    precision_sum += float(relevant_count) / (i + 1)\n\n            if ground_truth_num == 0:\n                average_precision = 0.0\n            else:\n                average_precision = precision_sum / ground_truth_num\n\n            average_precisions.append(average_precision)\n\n        mean_average_precision = np.mean(average_precisions) if average_precisions else 0.0\n        return mean_average_precision, average_precisions\n```",
    "58": "```python\nimport random\n\nclass MinesweeperGame:\n    \"\"\"\n    This is a class that implements mine sweeping games including minesweeping and winning judgment.\n    \"\"\"\n\n    def __init__(self, n, k) -> None:\n        \"\"\"\n        Initializes the MinesweeperGame class with the size of the board and the number of mines.\n        :param n: The size of the board, int.\n        :param k: The number of mines, int.\n        \"\"\"\n        self.n = n\n        self.k = k\n        self.minesweeper_map = self.generate_mine_sweeper_map()\n        self.player_map = self.generate_playerMap()\n        self.score = 0\n\n    def generate_mine_sweeper_map(self):\n        \"\"\"\n        Generates a minesweeper map with the given size of the board and the number of mines.\n        'X' represents the mine, other numbers represent the number of mines around the position.\n        :return: The minesweeper map, list of lists.\n        \"\"\"\n        minesweeper_map = [[0 for _ in range(self.n)] for _ in range(self.n)]\n        \n        # Place mines randomly\n        mine_positions = random.sample(range(self.n * self.n), self.k)\n        for mine_position in mine_positions:\n            row = mine_position // self.n\n            col = mine_position % self.n\n            minesweeper_map[row][col] = 'X'\n        \n        # Calculate adjacent mine counts\n        for row in range(self.n):\n            for col in range(self.n):\n                if minesweeper_map[row][col] == 'X':\n                    continue\n                count = 0\n                for i in range(max(0, row - 1), min(self.n, row + 2)):\n                    for j in range(max(0, col - 1), min(self.n, col + 2)):\n                        if minesweeper_map[i][j] == 'X':\n                            count += 1\n                minesweeper_map[row][col] = count\n        return minesweeper_map\n\n    def generate_playerMap(self):\n        \"\"\"\n        Generates a player map with all positions initially unknown ('-').\n        :return: The player map, list of lists.\n        \"\"\"\n        return [['-' for _ in range(self.n)] for _ in range(self.n)]\n\n    def check_won(self, map):\n        \"\"\"\n        Checks whether the player has won the game.\n        The player wins if all non-mine cells are revealed.\n        :return: True if the player has won the game, False otherwise.\n        \"\"\"\n        revealed_count = 0\n        for row in range(self.n):\n            for col in range(self.n):\n                if map[row][col] != '-':\n                    revealed_count += 1\n        return revealed_count == self.n * self.n - self.k\n\n    def sweep(self, x, y):\n        \"\"\"\n        Sweeps the given position.\n        :param x: The x coordinate of the position, int.\n        :param y: The y coordinate of the position, int.\n        :return: False if mine hit, True if won, player_map if game continues.\n        \"\"\"\n        if self.minesweeper_map[x][y] == 'X':\n            return False\n        else:\n            self.player_map[x][y] = self.minesweeper_map[x][y]\n            self.score += 1\n            if self.check_won(self.player_map):\n                return True\n            else:\n                return self.player_map\n```",
    "59": "```python\nfrom datetime import datetime\nimport numpy as np\n\nclass MovieBookingSystem:\n    \"\"\"\n    A movie booking system that allows adding movies, booking tickets,\n    and checking available movies within a given time range.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the movie booking system with an empty list of movies.\n        \"\"\"\n        self.movies = []\n\n    def add_movie(self, name, price, start_time, end_time, n):\n        \"\"\"\n        Adds a new movie to the system.\n\n        Args:\n            name (str): The name of the movie.\n            price (float): The price of a ticket for the movie.\n            start_time (str): The start time of the movie in HH:MM format (e.g., \"17:05\").\n            end_time (str): The end time of the movie in HH:MM format (e.g., \"19:25\").\n            n (int): The size of the square seating arrangement (n x n).\n        \"\"\"\n        try:\n            start_time_dt = datetime.strptime(start_time, '%H:%M')\n            end_time_dt = datetime.strptime(end_time, '%H:%M')\n        except ValueError:\n            raise ValueError(\"Invalid time format. Please use HH:MM format.\")\n\n        if not isinstance(price, (int, float)):\n            raise TypeError(\"Price must be a number.\")\n        if price <= 0:\n            raise ValueError(\"Price must be positive.\")\n\n        if not isinstance(n, int):\n            raise TypeError(\"Seat size must be an integer.\")\n        if n <= 0:\n            raise ValueError(\"Seat size must be positive.\")\n\n        seats = np.zeros((n, n))\n        movie = {\n            'name': name,\n            'price': price,\n            'start_time': start_time_dt,\n            'end_time': end_time_dt,\n            'seats': seats\n        }\n        self.movies.append(movie)\n\n    def book_ticket(self, name, seats_to_book):\n        \"\"\"\n        Books tickets for a movie, marking the selected seats as occupied.\n\n        Args:\n            name (str): The name of the movie to book tickets for.\n            seats_to_book (list of tuples): A list of (row, col) tuples representing the seats to book.\n\n        Returns:\n            str: A message indicating the booking status:\n                - \"Movie not found.\" if the movie is not found.\n                - \"Booking success.\" if the booking is successful.\n                - \"Booking failed.\" if one or more seats are already booked.\n        \"\"\"\n        for movie in self.movies:\n            if movie['name'] == name:\n                seats = movie['seats']\n                for row, col in seats_to_book:\n                    if not (0 <= row < seats.shape[0] and 0 <= col < seats.shape[1]):\n                        return 'Booking failed. Invalid seat selection.'\n\n                all_available = all(seats[row][col] == 0 for row, col in seats_to_book)\n\n                if all_available:\n                    for row, col in seats_to_book:\n                        seats[row][col] = 1\n                    return 'Booking success.'\n                else:\n                    return 'Booking failed.'\n        return 'Movie not found.'\n\n    def available_movies(self, start_time, end_time):\n        \"\"\"\n        Retrieves a list of movies that are playing within the specified time range.\n\n        Args:\n            start_time (str): The start time of the desired time range in HH:MM format (e.g., \"12:00\").\n            end_time (str): The end time of the desired time range in HH:MM format (e.g., \"22:00\").\n\n        Returns:\n            list of str: A list of movie names that are playing within the specified time range.\n        \"\"\"\n        try:\n            start_time_dt = datetime.strptime(start_time, '%H:%M')\n            end_time_dt = datetime.strptime(end_time, '%H:%M')\n        except ValueError:\n            raise ValueError(\"Invalid time format. Please use HH:MM format.\")\n\n        available_movies_list = []\n        for movie in self.movies:\n            if movie['start_time'] <= end_time_dt and movie['end_time'] >= start_time_dt:\n                available_movies_list.append(movie['name'])\n\n        return available_movies_list\n```",
    "60": "```python\nimport sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information, searching for movie information by name, and deleting movie information by name.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.db_name = db_name\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.Fields include ID of type int, movie name of type str, theater name of type str, seat number of type str, and customer name of type str\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS tickets (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    movie_name TEXT NOT NULL,\n                    theater_name TEXT NOT NULL,\n                    seat_number TEXT NOT NULL,\n                    customer_name TEXT NOT NULL\n                )\n            \"\"\")\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute(\"\"\"\n                INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n                VALUES (?, ?, ?, ?)\n            \"\"\", (movie_name, theater_name, seat_number, customer_name))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        >>> ticket_db = MovieTicketDB(\"ticket_database.db\")\n        >>> ticket_db.create_table()\n        >>> ticket_db.insert_ticket(\"Movie A\", \"Theater 1\", \"A1\", \"John Doe\")\n        >>> result = ticket_db.search_tickets_by_customer(\"John Doe\")\n        len(result) = 1\n        \"\"\"\n        try:\n            self.cursor.execute(\"\"\"\n                SELECT * FROM tickets\n                WHERE customer_name = ?\n            \"\"\", (customer_name,))\n            return self.cursor.fetchall()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n            return []\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute(\"\"\"\n                DELETE FROM tickets\n                WHERE id = ?\n            \"\"\", (ticket_id,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n```",
    "61": "```python\nimport random\n\nclass MusicPlayer:\n    \"\"\"\n    This is a class as a music player that provides to play, stop, add songs, remove songs, set volume, shuffle, and switch to the next or previous song.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the music player with an empty playlist, no current song, and a default volume of 50.\n        \"\"\"\n        self.playlist = []\n        self.current_song = None\n        self.volume = 50\n        self.current_song_index = None\n\n    def add_song(self, song):\n        \"\"\"\n        Adds a song to the playlist.\n        :param song: The song to add to the playlist, str.\n        \"\"\"\n        self.playlist.append(song)\n\n    def remove_song(self, song):\n        \"\"\"\n        Removes a song from the playlist.\n        :param song: The song to remove from the playlist, str.\n        \"\"\"\n        if song in self.playlist:\n            self.playlist.remove(song)\n            if self.current_song == song:\n                self.current_song = None\n                self.current_song_index = None\n            elif self.current_song_index is not None:\n                if song in self.playlist:\n                    pass\n                else:\n                    self.current_song_index = None\n                    self.current_song = None\n\n    def play(self):\n        \"\"\"\n        Plays the current song in the playlist.\n        :return: The current song in the playlist, or False if there is no current song.\n        \"\"\"\n        if self.current_song:\n            return self.current_song\n        elif self.playlist:\n            if self.current_song is None:\n                if len(self.playlist) > 0:\n                    return False\n        else:\n            return None\n\n    def stop(self):\n        \"\"\"\n        Stops the current song in the playlist.\n        :return: True if the current song was stopped, False if there was no current song.\n        \"\"\"\n        if self.current_song:\n            self.current_song = None\n            self.current_song_index = None\n            return True\n        else:\n            return False\n\n    def switch_song(self):\n        \"\"\"\n        Switches to the next song in the playlist.\n        :return: True if the next song was switched to, False if there was no next song.\n        \"\"\"\n        if not self.playlist:\n            return False\n\n        if self.current_song is None and self.playlist:\n            return False\n\n        if self.current_song_index is None and self.current_song is not None:\n            try:\n                self.current_song_index = self.playlist.index(self.current_song)\n            except ValueError:\n                return False\n\n        if self.current_song_index is None and self.current_song is None:\n            return False\n\n        if self.current_song_index is not None:\n            if self.current_song_index < len(self.playlist) - 1:\n                self.current_song_index += 1\n                self.current_song = self.playlist[self.current_song_index]\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    def previous_song(self):\n        \"\"\"\n        Switches to the previous song in the playlist.\n        :return: True if the previous song was switched to, False if there was no previous song.\n        \"\"\"\n        if not self.playlist:\n            return False\n\n        if self.current_song is None and self.playlist:\n            return False\n\n        if self.current_song_index is None and self.current_song is not None:\n            try:\n                self.current_song_index = self.playlist.index(self.current_song)\n            except ValueError:\n                return False\n\n        if self.current_song_index is None and self.current_song is None:\n            return False\n\n        if self.current_song_index is not None:\n            if self.current_song_index > 0:\n                self.current_song_index -= 1\n                self.current_song = self.playlist[self.current_song_index]\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    def set_volume(self, volume):\n        \"\"\"\n        Sets the volume of the music player,ifthe volume is between 0 and 100 is valid.\n        :param volume: The volume to set the music player to,int.\n        :return: True if the volume was set, False if the volume was invalid.\n        \"\"\"\n        if 0 <= volume <= 100:\n            self.volume = volume\n        else:\n            return False\n\n    def shuffle(self):\n        \"\"\"\n        Shuffles the playlist.\n        :return: True if the playlist was shuffled, False if the playlist was empty.\n        \"\"\"\n        if self.playlist:\n            random.shuffle(self.playlist)\n            if self.current_song:\n                try:\n                    self.current_song_index = self.playlist.index(self.current_song)\n                except ValueError:\n                    self.current_song = None\n                    self.current_song_index = None\n            return True\n        else:\n            return False\n```",
    "62": "```python\nclass NLPDataProcessor:\n    \"\"\"\n    The class processes NLP data by removing stop words from a list of strings using a pre-defined stop word list.\n    \"\"\"\n\n    def construct_stop_word_list(self):\n        \"\"\"\n        Construct a stop word list including 'a', 'an', 'the'.\n        :return: a list of stop words\n        >>> NLPDataProcessor.construct_stop_word_list()\n        ['a', 'an', 'the']\n        \"\"\"\n        return ['a', 'an', 'the']\n\n    def remove_stop_words(self, string_list, stop_word_list):\n        \"\"\"\n        Remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :param stop_word_list: a list of stop words\n        :return: a list of words without stop words\n        >>> NLPDataProcessor.process(['This is a test.'])\n        [['This', 'is', 'test.']]\n        \"\"\"\n        words_list = []\n        for sentence in string_list:\n            words = sentence.split()\n            filtered_words = [word for word in words if word not in stop_word_list]\n            words_list.append(filtered_words)\n        return words_list\n\n    def process(self, string_list):\n        \"\"\"\n        Construct a stop word list including 'a', 'an', 'the', and remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :return: a list of words without stop words\n        >>> NLPDataProcessor.process(['This is a test.'])\n        [['This', 'is', 'test.']]\n        \"\"\"\n        stop_word_list = self.construct_stop_word_list()\n        return self.remove_stop_words(string_list, stop_word_list)\n```",
    "63": "```python\nimport re\nfrom collections import Counter\n\nclass NLPDataProcessor2:\n    \"\"\"\n    The class processes NLP data by extracting words from a list of strings, calculating the frequency of each word, and returning the top 5 most frequent words.\n    \"\"\"\n\n    def process_data(self, string_list):\n        \"\"\"\n        Keeps only English letters and spaces in the string, then converts the string to lower case, and then splits the string into a list of words.\n        :param string_list: a list of strings\n        :return: words_list: a list of words lists\n        \"\"\"\n        words_list = []\n        for string in string_list:\n            cleaned_string = re.sub(r'[^a-zA-Z\\s]', '', string)\n            lowercased_string = cleaned_string.lower()\n            words = lowercased_string.split()\n            words_list.append(words)\n        return words_list\n\n    def calculate_word_frequency(self, words_list):\n        \"\"\"\n        Calculates the word frequency of each word in the list of words list, and returns the top 5 most frequent words.\n        :param words_list: a list of words lists\n        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency\n        \"\"\"\n        word_counts = Counter()\n        for words in words_list:\n            word_counts.update(words)\n        return dict(word_counts.most_common(5))\n\n    def process(self, string_list):\n        \"\"\"\n        Processes a list of strings to extract the top 5 most frequent words.\n        :param string_list: a list of strings\n        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency\n        \"\"\"\n        words_list = self.process_data(string_list)\n        return self.calculate_word_frequency(words_list)\n```",
    "64": "```python\nclass NumberConverter:\n    \"\"\"\n    The class allows to convert  decimal to binary, octal and hexadecimal repectively and contrarily\n    \"\"\"\n\n    @staticmethod\n    def decimal_to_binary(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to binary format.\n        :param decimal_num: int, decimal number\n        :return: str, the binary representation of an integer.\n        >>> NumberConverter.decimal_to_binary(42423)\n        '1010010110110111'\n        \"\"\"\n        if not isinstance(decimal_num, int):\n            raise TypeError(\"Input must be an integer.\")\n\n        if decimal_num < 0:\n            raise ValueError(\"Input must be a non-negative integer.\")\n        \n        if decimal_num == 0:\n            return '0'\n        \n        binary_num = ''\n        while decimal_num > 0:\n            binary_num = str(decimal_num % 2) + binary_num\n            decimal_num //= 2\n        return binary_num\n\n    @staticmethod\n    def binary_to_decimal(binary_num):\n        \"\"\"\n        Convert a number from binary format to decimal format.\n        :param binary_num: str, binary number\n        :return: int, the decimal representation of binary number str.\n        >>> NumberConverter.binary_to_decimal('1010010110110111')\n        42423\n        \"\"\"\n        if not isinstance(binary_num, str):\n            raise TypeError(\"Input must be a string.\")\n\n        if not all(c in '01' for c in binary_num):\n            raise ValueError(\"Input must be a valid binary string.\")\n\n        decimal_num = 0\n        power = 0\n        for digit in reversed(binary_num):\n            if digit == '1':\n                decimal_num += 2 ** power\n            power += 1\n        return decimal_num\n\n\n    @staticmethod\n    def decimal_to_octal(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to octal format.\n        :param decimal_num: int, decimal number\n        :return: str, the octal representation of an integer.\n        >>> NumberConverter.decimal_to_octal(42423)\n        '122667'\n        \"\"\"\n        if not isinstance(decimal_num, int):\n            raise TypeError(\"Input must be an integer.\")\n\n        if decimal_num < 0:\n            raise ValueError(\"Input must be a non-negative integer.\")\n\n        if decimal_num == 0:\n            return '0'\n        \n        octal_num = ''\n        while decimal_num > 0:\n            octal_num = str(decimal_num % 8) + octal_num\n            decimal_num //= 8\n        return octal_num\n\n    @staticmethod\n    def octal_to_decimal(octal_num):\n        \"\"\"\n        Convert a number from octal format to decimal format.\n        :param octal_num: str, octal num\n        :return: int, the decimal representation of octal number str.\n        >>> NumberConverter.octal_to_decimal('122667')\n        42423\n        \"\"\"\n        if not isinstance(octal_num, str):\n            raise TypeError(\"Input must be a string.\")\n\n        if not all(c in '01234567' for c in octal_num):\n            raise ValueError(\"Input must be a valid octal string.\")\n        \n        decimal_num = 0\n        power = 0\n        for digit in reversed(octal_num):\n            decimal_num += int(digit) * (8 ** power)\n            power += 1\n        return decimal_num\n\n    @staticmethod\n    def decimal_to_hex(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to hex format.\n        :param decimal_num: int, decimal number\n        :return hex_num: str, the hex representation of an integer.\n        >>> NumberConverter.decimal_to_hex(42423)\n        'a5b7'\n        \"\"\"\n        if not isinstance(decimal_num, int):\n            raise TypeError(\"Input must be an integer.\")\n\n        if decimal_num < 0:\n            raise ValueError(\"Input must be a non-negative integer.\")\n\n        if decimal_num == 0:\n            return '0'\n        \n        hex_num = ''\n        hex_digits = \"0123456789abcdef\"\n        while decimal_num > 0:\n            remainder = decimal_num % 16\n            hex_num = hex_digits[remainder] + hex_num\n            decimal_num //= 16\n        return hex_num\n\n    @staticmethod\n    def hex_to_decimal(hex_num):\n        \"\"\"\n        Convert a number from hex format to decimal format.\n        :param hex_num: str, hex num\n        :return: int, the decimal representation of hex number str.\n        >>> NumberConverter.hex_to_decimal('a5b7')\n        42423\n        \"\"\"\n        if not isinstance(hex_num, str):\n            raise TypeError(\"Input must be a string.\")\n\n        hex_num = hex_num.lower()\n        hex_digits = \"0123456789abcdef\"\n        if not all(c in hex_digits for c in hex_num):\n            raise ValueError(\"Input must be a valid hexadecimal string.\")\n        \n        decimal_num = 0\n        power = 0\n        for digit in reversed(hex_num):\n            decimal_num += hex_digits.index(digit) * (16 ** power)\n            power += 1\n        return decimal_num\n```",
    "65": "```python\nclass NumberWordFormatter:\n    \"\"\"\n    Converts numbers into their corresponding English word representation.\n    Handles integer and decimal parts.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the formatter with word lists.\"\"\"\n        self.ONES = [\"\", \"ONE\", \"TWO\", \"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\"]\n        self.TEENS = [\"TEN\", \"ELEVEN\", \"TWELVE\", \"THIRTEEN\", \"FOURTEEN\", \"FIFTEEN\", \"SIXTEEN\", \"SEVENTEEN\",\n                      \"EIGHTEEN\", \"NINETEEN\"]\n        self.TENS = [\"TEN\", \"TWENTY\", \"THIRTY\", \"FORTY\", \"FIFTY\", \"SIXTY\", \"SEVENTY\", \"EIGHTY\", \"NINETY\"]\n        self.MAGNITUDES = [\"\", \"THOUSAND\", \"MILLION\", \"BILLION\"]\n\n    def format(self, number):\n        \"\"\"\n        Converts a number (int or float) to its English word representation.\n\n        Args:\n            number (int or float): The number to convert.\n\n        Returns:\n            str: The number in words, or an empty string if input is None.\n        \"\"\"\n        if number is None:\n            return \"\"\n\n        if isinstance(number, float):\n            integer_part = int(number)\n            decimal_part = round((number - integer_part) * 100)\n            integer_words = self.format(integer_part)\n            decimal_words = self.format(decimal_part)\n\n            if integer_part == 0:\n                return \"CENTS \" + decimal_words + \" ONLY\"\n            return integer_words + \" AND CENTS \" + decimal_words + \" ONLY\"\n\n        if number == 0:\n            return \"ZERO ONLY\"\n\n        return self._format_integer(int(number))\n\n    def format_string(self, number_string):\n        \"\"\"\n        Converts a string representation of a number to words.\n\n        Args:\n            number_string (str): The string to convert.\n\n        Returns:\n            str: The number in words, or an empty string on error.\n        \"\"\"\n        try:\n            number = float(number_string)\n            return self.format(number)\n        except ValueError:\n            return \"\"\n\n    def _format_integer(self, number):\n        \"\"\"\n        Helper function to format an integer into words.\n\n        Args:\n            number (int): The integer to format.\n\n        Returns:\n            str: The integer in words.\n        \"\"\"\n        if number == 0:\n            return \"ZERO ONLY\"\n\n        parts = []\n        magnitude_index = 0\n        while number > 0:\n            # Process the last three digits\n            three_digits = number % 1000\n            if three_digits != 0:\n                parts.insert(0, self._format_less_than_1000(three_digits) + \" \" + self.MAGNITUDES[magnitude_index])\n\n            number //= 1000\n            magnitude_index += 1\n\n        return \" \".join(part for part in parts if part).strip() + \" ONLY\"\n\n    def _format_less_than_1000(self, number):\n        \"\"\"\n        Formats a number less than 1000 into words.\n\n        Args:\n            number (int): The number to format (0-999).\n\n        Returns:\n            str: The number in words.\n        \"\"\"\n        hundreds = number // 100\n        remainder = number % 100\n\n        words = []\n        if hundreds > 0:\n            words.append(self.ONES[hundreds])\n            words.append(\"HUNDRED\")\n\n            if remainder > 0:\n                words.append(\"AND\")\n\n        if remainder > 0:\n            words.append(self._format_less_than_100(remainder))\n\n        return \" \".join(words).strip()\n\n    def _format_less_than_100(self, number):\n        \"\"\"\n        Formats a number less than 100 into words.\n\n        Args:\n            number (int): The number to format (0-99).\n\n        Returns:\n            str: The number in words.\n        \"\"\"\n        if number < 10:\n            return self.ONES[number]\n        elif 10 <= number < 20:\n            return self.TEENS[number - 10]\n        else:\n            tens = number // 10\n            ones = number % 10\n            if ones == 0:\n                return self.TENS[tens - 1]\n            else:\n                return self.TENS[tens - 1] + \" \" + self.ONES[ones]\n\n    def trans_two(self, s):\n        \"\"\"\n        Converts a two-digit number into words format\n        :param s: str, the two-digit number\n        :return: str, the number in words format\n        \"\"\"\n        if len(s) != 2:\n            return \"\"\n\n        if s[0] == '0':\n            if s[1] == '0':\n                return \"\"\n            else:\n                return self.ONES[int(s[1])]\n        elif s[0] == '1':\n            return self.TEENS[int(s[1])]\n        else:\n            if s[1] == '0':\n                return self.TENS[int(s[0]) - 1]\n            else:\n                return self.TENS[int(s[0]) - 1] + \" \" + self.ONES[int(s[1])]\n\n    def trans_three(self, s):\n        \"\"\"\n        Converts a three-digit number into words format\n        :param s: str, the three-digit number\n        :return: str, the number in words format\n        \"\"\"\n        if len(s) != 3:\n            return \"\"\n\n        result = []\n        if s[0] != '0':\n            result.append(self.ONES[int(s[0])])\n            result.append(\"HUNDRED\")\n\n        two_digit = s[1:]\n        two_digit_words = self.trans_two(two_digit)\n\n        if result and two_digit_words:\n            result.append(\"AND\")\n\n        if two_digit_words:\n            result.append(two_digit_words)\n\n        return \" \".join(result).strip()\n\n    def parse_more(self, i):\n        \"\"\"\n        Parses the thousand/million/billion suffix based on the index\n        :param i: int, the index representing the magnitude (thousand, million, billion)\n        :return: str, the corresponding suffix for the magnitude\n        \"\"\"\n        return self.MAGNITUDES[i]\n```",
    "66": "```python\nclass NumericEntityUnescaper:\n    \"\"\"\n    This is a class that provides functionality to replace numeric entities with their corresponding characters in a given string.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def replace(self, string):\n        \"\"\"\n        Replaces numeric character references (HTML entities) in the input string with their corresponding Unicode characters.\n        :param string: str, the input string containing numeric character references.\n        :return: str, the input string with numeric character references replaced with their corresponding Unicode characters.\n        >>> unescaper = NumericEntityUnescaper()\n        >>> unescaper.replace(\"&#65;&#66;&#67;\")\n        'ABC'\n\n        \"\"\"\n        result = \"\"\n        i = 0\n        while i < len(string):\n            if string[i:i + 2] == \"&#\":\n                j = i + 2\n                while j < len(string) and string[j] != ';':\n                    j += 1\n\n                if j < len(string) and string[j] == ';':\n                    entity = string[i + 2:j]\n                    try:\n                        if entity.lower().startswith(\"x\"):\n                            char_code = int(entity[1:], 16)\n                        else:\n                            char_code = int(entity)\n                        result += chr(char_code)\n                        i = j + 1\n                    except ValueError:\n                        result += string[i:j+1]\n                        i = j + 1\n                else:\n                    result += string[i:i+2]\n                    i += 2\n            else:\n                result += string[i]\n                i += 1\n        return result\n\n    @staticmethod\n    def is_hex_char(char):\n        \"\"\"\n        Determines whether a given character is a hexadecimal digit.\n        :param char: str, the character to check.\n        :return: bool, True if the character is a hexadecimal digit, False otherwise.\n        >>> NumericEntityUnescaper.is_hex_char('a')\n        True\n\n        \"\"\"\n        return '0' <= char <= '9' or 'a' <= char.lower() <= 'f'\n```",
    "67": "```python\nclass Order:\n    \"\"\"\n    The class manages restaurant orders by allowing the addition of dishes, calculation of the total cost, and checkout.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the order management system.\n\n        self.menu stores the dishes of restaurant inventory.\n        Format: [{\"dish\": dish name, \"price\": price, \"count\": count}, ...]\n\n        self.selected_dishes stores the dishes selected by customer.\n        Format: [{\"dish\": dish name, \"count\": count, \"price\": price}, ...]\n\n        self.sales stores the sales rate of each dish.\n        Format: {dish name: sales_rate}\n        \"\"\"\n        self.menu = []\n        self.selected_dishes = []\n        self.sales = {}\n\n    def add_dish(self, dish):\n        \"\"\"\n        Adds a dish to the order if it's available in the menu and the requested count is valid.\n\n        :param dish: dict, the information of the dish to add.\n                     Format: {\"dish\": dish name, \"count\": count, \"price\": price}\n        :return: True if the dish was successfully added, False otherwise.\n        \"\"\"\n        if not dish:\n            return True\n\n        dish_name = dish.get(\"dish\")\n        dish_count = dish.get(\"count\")\n        dish_price = dish.get(\"price\")\n\n        if not dish_name or not isinstance(dish_count, int) or dish_count <= 0:\n            return False\n\n        for menu_dish in self.menu:\n            if menu_dish[\"dish\"] == dish_name:\n                if menu_dish[\"count\"] >= dish_count:\n                    menu_dish[\"count\"] -= dish_count\n                    self.selected_dishes.append({\"dish\": dish_name, \"count\": dish_count, \"price\": dish_price})\n                    return True\n                else:\n                    return False\n\n        return False  # Dish not found in menu\n\n    def calculate_total(self):\n        \"\"\"\n        Calculates the total price of the dishes in the order, considering sales rates.\n\n        :return: float, the total price of the order.\n        \"\"\"\n        total = 0.0\n        for selected_dish in self.selected_dishes:\n            dish_name = selected_dish[\"dish\"]\n            dish_count = selected_dish[\"count\"]\n            dish_price = selected_dish[\"price\"]\n            sales_rate = self.sales.get(dish_name, 1.0)  # Default to 1.0 if no sales rate is found\n            total += dish_count * dish_price * sales_rate\n        return total\n\n    def checkout(self):\n        \"\"\"\n        Completes the order, calculates the total, updates the menu, and clears the selected dishes.\n\n        :return: float, the total price of the order if successful, False if no dishes were selected.\n        \"\"\"\n        if not self.selected_dishes:\n            return False\n\n        total = self.calculate_total()\n\n        # Update menu counts after checkout (more robust approach)\n        for selected_dish in self.selected_dishes:\n            dish_name = selected_dish[\"dish\"]\n            dish_count = selected_dish[\"count\"]\n            for menu_dish in self.menu:\n                if menu_dish[\"dish\"] == dish_name:\n                    break # No need to update here, already updated in add_dish\n\n        self.selected_dishes = []  # Clear selected dishes after checkout\n        return total\n```",
    "68": "```python\nclass PageUtil:\n    \"\"\"\n    PageUtil class is a versatile utility for handling pagination and search functionalities in an efficient and convenient manner.\n    \"\"\"\n\n    def __init__(self, data, page_size):\n        \"\"\"\n        Initialize the PageUtil object with the given data and page size.\n        :param data: list, the data to be paginated\n        :param page_size: int, the number of items per page\n        \"\"\"\n        if not isinstance(data, list):\n            raise TypeError(\"Data must be a list.\")\n        if not isinstance(page_size, int) or page_size <= 0:\n            raise ValueError(\"Page size must be a positive integer.\")\n\n        self.data = data\n        self.page_size = page_size\n        self.total_items = len(data)\n        self.total_pages = (self.total_items + page_size - 1) // page_size\n\n    def get_page(self, page_number):\n        \"\"\"\n        Retrieve a specific page of data.\n        :param page_number: int, the page number to fetch\n        :return: list, the data on the specified page\n        \"\"\"\n        if not isinstance(page_number, int):\n            raise TypeError(\"Page number must be an integer.\")\n\n        if page_number <= 0 or page_number > self.total_pages:\n            return []\n\n        start_index = (page_number - 1) * self.page_size\n        end_index = start_index + self.page_size\n        return self.data[start_index:end_index]\n\n    def get_page_info(self, page_number):\n        \"\"\"\n        Retrieve information about a specific page.\n        :param page_number: int, the page number to fetch information about\n        :return: dict, containing page information such as current page number, total pages, etc.\n        \"\"\"\n        if not isinstance(page_number, int):\n            raise TypeError(\"Page number must be an integer.\")\n\n        if page_number <= 0 or page_number > self.total_pages:\n            return {}\n\n        page_data = self.get_page(page_number)\n        has_previous = page_number > 1\n        has_next = page_number < self.total_pages\n\n        page_info = {\n            \"current_page\": page_number,\n            \"per_page\": self.page_size,\n            \"total_pages\": self.total_pages,\n            \"total_items\": self.total_items,\n            \"has_previous\": has_previous,\n            \"has_next\": has_next,\n            \"data\": page_data\n        }\n        return page_info\n\n    def search(self, keyword):\n        \"\"\"\n        Search for items in the data that contain the given keyword.\n        :param keyword: str, the keyword to search for\n        :return: dict, containing search information such as total results and matching items\n        \"\"\"\n        if not isinstance(keyword, str) and not isinstance(keyword, int):\n            raise TypeError(\"Keyword must be a string or integer.\")\n\n        keyword = str(keyword)\n        results = [item for item in self.data if keyword in str(item)]\n        total_results = len(results)\n        total_pages = (total_results + self.page_size - 1) // self.page_size if total_results > 0 else 0\n\n        search_info = {\n            \"keyword\": keyword,\n            \"total_results\": total_results,\n            \"total_pages\": total_pages,\n            \"results\": results\n        }\n        return search_info\n```",
    "69": "```python\nimport PyPDF2\n\nclass PDFHandler:\n    \"\"\"\n    The class allows merging multiple PDF files into one and extracting text from PDFs using PyPDF2 library.\n    \"\"\"\n\n    def __init__(self, filepaths):\n        \"\"\"\n        Initializes the PDFHandler with a list of filepaths.\n\n        Args:\n            filepaths: A list of strings, where each string is a path to a PDF file.\n        \"\"\"\n        self.filepaths = filepaths\n        self.readers = []\n        for fp in self.filepaths:\n            try:\n                reader = PyPDF2.PdfFileReader(fp)\n                self.readers.append(reader)\n            except FileNotFoundError:\n                print(f\"Error: File not found at {fp}\")\n                self.readers.append(None)\n            except PyPDF2.utils.PdfReadError:\n                print(f\"Error: Could not open or read PDF file at {fp}.  It may be encrypted or not a valid PDF.\")\n                self.readers.append(None)\n            except Exception as e:\n                print(f\"Error reading {fp}: {e}\")\n                self.readers.append(None)\n\n    def merge_pdfs(self, output_filepath):\n        \"\"\"\n        Merges multiple PDF files into a single PDF file.\n\n        Args:\n            output_filepath: The path to the output PDF file.\n\n        Returns:\n            A string indicating the success or failure of the merge operation.\n        \"\"\"\n        merger = PyPDF2.PdfFileMerger()\n        for reader in self.readers:\n            if reader:\n                try:\n                    merger.append(reader)\n                except Exception as e:\n                    return f\"Error appending PDF: {e}\"\n\n        try:\n            merger.write(output_filepath)\n            merger.close()\n            return f\"Merged PDFs saved at {output_filepath}\"\n        except Exception as e:\n            return f\"Error writing merged PDF: {e}\"\n\n    def extract_text_from_pdfs(self):\n        \"\"\"\n        Extracts text from multiple PDF files.\n\n        Returns:\n            A list of strings, where each string contains the extracted text from a PDF file.\n            If a PDF file could not be read, an empty string is returned for that file.\n        \"\"\"\n        pdf_texts = []\n        for reader in self.readers:\n            if reader:\n                text = \"\"\n                try:\n                    for page_num in range(reader.numPages):\n                        page = reader.getPage(page_num)\n                        text += page.extractText()\n                except Exception as e:\n                    print(f\"Error extracting text: {e}\")\n                    text = \"\"  # Ensure empty string is appended even if extraction fails\n                pdf_texts.append(text)\n            else:\n                pdf_texts.append(\"\")\n        return pdf_texts\n```",
    "70": "```python\nclass PersonRequest:\n    \"\"\"\n    This class validates input personal information data and sets invalid fields to None based to specific rules.\n    \"\"\"\n\n    def __init__(self, name: str, sex: str, phoneNumber: str):\n        \"\"\"\n        Initialize PersonRequest object with the provided information.\n        :param name: str, the name of the person\n        :param sex: str, the sex of the person\n        :param phoneNumber: str, the phone number of the person\n        \"\"\"\n        self.name = self._validate_name(name)\n        self.sex = self._validate_sex(sex)\n        self.phoneNumber = self._validate_phoneNumber(phoneNumber)\n\n\n    def _validate_name(self, name: str) -> str:\n        \"\"\"\n        Validate the name and return it. If name is empty or exceeds 33 characters in length, set to None.\n        :param name: str, the name to validate\n        :return: str, the validated name or None if invalid\n        \"\"\"\n        if not name or len(name) > 33:\n            return None\n        return name\n\n    def _validate_sex(self, sex: str) -> str:\n        \"\"\"\n        Validate the sex and return it. If sex is not Man, Woman, or UGM, set to None.\n        :param sex: str, the sex to validate\n        :return: str, the validated sex or None if invalid\n        \"\"\"\n        valid_sexes = (\"Man\", \"Woman\", \"UGM\")\n        if sex not in valid_sexes:\n            return None\n        return sex\n\n    def _validate_phoneNumber(self, phoneNumber: str) -> str:\n        \"\"\"\n        Validate the phone number and return it. If phoneNumber is empty or not an 11 digit number, set to None.\n        :param phoneNumber: str, the phone number to validate\n        :return: str, the validated phone number or None if invalid\n        \"\"\"\n        if not phoneNumber or not phoneNumber.isdigit() or len(phoneNumber) != 11:\n            return None\n        return phoneNumber\n```",
    "71": "```python\nclass PushBoxGame:\n    \"\"\"\n    This class implements a functionality of a sokoban game, where the player needs to move boxes to designated targets in order to win.\n    \"\"\"\n\n    def __init__(self, map):\n        \"\"\"\n        Initialize the push box game with the map and various attributes.\n        :param map: list[str], the map of the push box game, represented as a list of strings. \n            Each character on the map represents a different element, including the following:\n            - '#' represents a wall that neither the player nor the box can pass through;\n            - 'O' represents the initial position of the player;\n            - 'G' represents the target position;\n            - 'X' represents the initial position of the box.\n        \"\"\"\n        self.map = map\n        self.player_row = 0\n        self.player_col = 0\n        self.targets = []\n        self.boxes = []\n        self.target_count = 0\n        self.is_game_over = False\n        self._init_game()\n\n    def _init_game(self):\n        \"\"\"\n        Initialize the game by setting the positions of the player, targets, and boxes based on the map.\n        \"\"\"\n        for row in range(len(self.map)):\n            for col in range(len(self.map[row])):\n                cell = self.map[row][col]\n                if cell == 'O':\n                    self.player_row = row\n                    self.player_col = col\n                elif cell == 'G':\n                    self.targets.append((row, col))\n                elif cell == 'X':\n                    self.boxes.append((row, col))\n        self.target_count = len(self.targets)\n\n    def check_win(self):\n        \"\"\"\n        Check if the game is won. The game is won when all the boxes are placed on target positions.\n        :return: True if all the boxes are placed on target positions, or False otherwise.\n        \"\"\"\n        if not self.boxes:\n            return False  # No boxes, can't win\n\n        for box in self.boxes:\n            if box not in self.targets:\n                return False\n        self.is_game_over = True\n        return True\n\n\n    def move(self, direction):\n        \"\"\"\n        Move the player based on the specified direction and check if the game is won.\n        :param direction: str, the direction of the player's movement. \n            It can be 'w', 's', 'a', or 'd' representing up, down, left, or right respectively.\n\n        :return: True if the game is won, False otherwise.\n        \"\"\"\n        dr, dc = 0, 0\n        if direction == 'w':\n            dr, dc = -1, 0\n        elif direction == 's':\n            dr, dc = 1, 0\n        elif direction == 'a':\n            dr, dc = 0, -1\n        elif direction == 'd':\n            dr, dc = 0, 1\n        else:\n            return self.is_game_over\n\n        new_row = self.player_row + dr\n        new_col = self.player_col + dc\n\n        if not (0 <= new_row < len(self.map) and 0 <= new_col < len(self.map[0])):\n            return self.is_game_over\n\n        if self.map[new_row][new_col] == '#':\n            return self.is_game_over\n\n        box_index = self._find_box_index(new_row, new_col)\n\n        if box_index != -1:\n            new_box_row = new_row + dr\n            new_box_col = new_col + dc\n\n            if not (0 <= new_box_row < len(self.map) and 0 <= new_box_col < len(self.map[0])):\n                return self.is_game_over\n\n            if self.map[new_box_row][new_box_col] == '#':\n                return self.is_game_over\n\n            if self._is_occupied_by_another_box(new_box_row, new_box_col):\n                return self.is_game_over\n\n            self.boxes[box_index] = (new_box_row, new_box_col)\n            self.player_row = new_row\n            self.player_col = new_col\n            return self.check_win()\n\n        self.player_row = new_row\n        self.player_col = new_col\n        return self.is_game_over\n\n    def _find_box_index(self, row, col):\n        \"\"\"Helper function to find the index of a box at a given position.\"\"\"\n        for i, box in enumerate(self.boxes):\n            if box[0] == row and box[1] == col:\n                return i\n        return -1\n\n    def _is_occupied_by_another_box(self, row, col):\n        \"\"\"Helper function to check if a position is occupied by another box.\"\"\"\n        for other_box in self.boxes:\n            if other_box[0] == row and other_box[1] == col:\n                return True\n        return False\n```",
    "72": "```python\nimport re\n\nclass RegexUtils:\n    \"\"\"\n    The class provides methods to match, find all occurrences, split, and substitute text using regular expressions.\n    It also includes methods to generate predefined patterns for validating phone numbers and extracting email addresses.\n    \"\"\"\n\n    def match(self, pattern, text):\n        \"\"\"\n        Check if the text matches the regular expression.\n\n        :param pattern: string, Regular expression pattern.\n        :param text: string, Text to match.\n        :return: True or False, representing whether the text matches the regular expression or not.\n        \"\"\"\n        return bool(re.match(pattern, text))\n\n    def findall(self, pattern, text):\n        \"\"\"\n        Find all matching substrings and return a list of all matching substrings.\n\n        :param pattern: string, Regular expression pattern.\n        :param text: string, Text to match.\n        :return: list of string, List of all matching substrings.\n        \"\"\"\n        return re.findall(pattern, text)\n\n    def split(self, pattern, text):\n        \"\"\"\n        Split text based on regular expression patterns and return a list of substrings.\n\n        :param pattern: string, Regular expression pattern.\n        :param text: string, Text to be split.\n        :return: list of string, List of substrings after splitting.\n        \"\"\"\n        return re.split(pattern, text)\n\n    def sub(self, pattern, replacement, text):\n        \"\"\"\n        Replace the substring matched by a regular expression with the specified string.\n\n        :param pattern: string, Regular expression pattern.\n        :param replacement: Text to replace with.\n        :param text: string, Text to be replaced.\n        :return: string, Text after replacement.\n        \"\"\"\n        return re.sub(pattern, replacement, text)\n\n    def generate_email_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match email addresses.\n\n        :return: string, regular expression patterns that match email addresses.\n        \"\"\"\n        return r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n\n    def generate_phone_number_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match phone numbers.\n\n        :return: string, regular expression patterns that match phone numbers.\n        \"\"\"\n        return r'\\b\\d{3}-\\d{3}-\\d{4}\\b'\n\n    def generate_split_sentences_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match the middle characters of two sentences.\n\n        :return: string, regular expression patterns that match the middle characters of two sentences.\n        \"\"\"\n        return r'[.!?][\\s]{1,2}(?=[A-Z])'\n\n    def split_sentences(self, text):\n        \"\"\"\n        Split the text into a list of sentences without Punctuation except the last sentence.\n\n        :param text: Text to be split.\n        :return: Split Text List.\n        \"\"\"\n        pattern = self.generate_split_sentences_pattern()\n        return re.split(pattern, text)\n\n    def validate_phone_number(self, phone_number):\n        \"\"\"\n        Verify if the phone number is valid.\n\n        :param phone_number: Phone number to be verified.\n        :return: True or False, indicating whether the phone number is valid.\n        \"\"\"\n        pattern = self.generate_phone_number_pattern()\n        return bool(re.match(pattern, phone_number))\n\n    def extract_email(self, text):\n        \"\"\"\n        Extract all email addresses from the text.\n\n        :param text: string, input text.\n        :return: list of string, All extracted email addresses.\n        \"\"\"\n        pattern = self.generate_email_pattern()\n        return re.findall(pattern, text)\n```",
    "73": "```python\nclass RPGCharacter:\n    \"\"\"\n    The class represents a role-playing game character, which allows to attack other characters, heal, gain experience, level up, and check if the character is alive.\n    \"\"\"\n\n    MAX_HP = 100\n    LEVEL_UP_THRESHOLD = 100\n    MAX_LEVEL = 100\n    HEAL_AMOUNT = 10\n    LEVEL_UP_HP_INCREASE = 20\n    LEVEL_UP_STAT_INCREASE = 5\n\n    def __init__(self, name, hp, attack_power, defense, level=1):\n        \"\"\"\n        Initialize an RPG character object.\n        :param name: str, the name of the character.\n        :param hp: int, The health points of the character.\n        :param attack_power: int, the attack power of the character.\n        :param defense: int, the defense points of the character.\n        :param level: int, the level of the character. Default is 1.\n        \"\"\"\n        self.name = name\n        self.hp = hp\n        self.attack_power = attack_power\n        self.defense = defense\n        self.level = level\n        self.exp = 0\n\n    def attack(self, other_character):\n        \"\"\"\n        Attack another character. The damage caused needs to offset the defense value.\n        :param other_character: RPGCharacter, The character being attacked.\n        \"\"\"\n        damage = self.attack_power - other_character.defense\n        if damage > 0:\n            other_character.hp -= damage\n\n    def heal(self):\n        \"\"\"\n        Heal the character.\n        :return: int, the current health points after healing.\n        \"\"\"\n        self.hp = min(self.hp + self.HEAL_AMOUNT, self.MAX_HP)\n        return self.hp\n\n    def gain_exp(self, amount):\n        \"\"\"\n        Gain experience points for the character and level_up when the exp has reached the values that is 100 times the current level\n        The experience that overflows should be used to calculate the next leve up untill exhausts\n        :param amount: int, the amount of experience points to gain.\n        \"\"\"\n        self.exp += amount\n        while self.exp >= self.LEVEL_UP_THRESHOLD * self.level:\n            if self.level < self.MAX_LEVEL:\n                self.level_up()\n            else:\n                self.exp = 0\n                break\n\n    def level_up(self):\n        \"\"\"\n        Level up the character and return to zero experience points, increase hp by 20 points, attack power and defense points by 5 points.\n        \"\"\"\n        if self.level < self.MAX_LEVEL:\n            self.level += 1\n            self.hp += self.LEVEL_UP_HP_INCREASE\n            self.attack_power += self.LEVEL_UP_STAT_INCREASE\n            self.defense += self.LEVEL_UP_STAT_INCREASE\n            self.exp = 0\n\n    def is_alive(self):\n        \"\"\"\n        Check if player is alive.\n        :return: True if the hp is larger than 0, or False otherwise.\n        \"\"\"\n        return self.hp > 0\n```",
    "74": "```python\nclass Server:\n    \"\"\"\n    This is a class as a server, which handles a white list, message sending and receiving, and information display.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the whitelist as an empty list, and initialize the sending and receiving information as an empty dictionary\n        \"\"\"\n        self.white_list = []\n        self.send_struct = {}\n        self.receive_struct = {}\n\n    def add_white_list(self, addr):\n        \"\"\"\n        Add an address to the whitelist and do nothing if it already exists\n        :param addr: int, address to be added\n        :return: True if the address was added, False otherwise.\n        \"\"\"\n        if addr in self.white_list:\n            return False\n        else:\n            self.white_list.append(addr)\n            return True\n\n    def del_white_list(self, addr):\n        \"\"\"\n        Remove an address from the whitelist and do nothing if it does not exist\n        :param addr: int, address to be deleted\n        :return: True if the address was deleted, False otherwise.\n        \"\"\"\n        if addr in self.white_list:\n            self.white_list.remove(addr)\n            return True\n        else:\n            return False\n\n    def recv(self, info):\n        \"\"\"\n        Receive information containing address and content. If the address is on the whitelist, receive the content; otherwise, do not receive it\n        :param info: dict, information dictionary containing address and content\n        :return: The content of the information if successfully received, False if the address is not on the whitelist, -1 if the info is invalid.\n        \"\"\"\n        if not isinstance(info, dict) or \"addr\" not in info or \"content\" not in info:\n            return -1\n\n        addr = info[\"addr\"]\n        content = info[\"content\"]\n\n        if addr in self.white_list:\n            self.receive_struct = info\n            return content\n        else:\n            return False\n\n    def send(self, info):\n        \"\"\"\n        Send information containing address and content\n        :param info: dict, information dictionary containing address and content\n        :return: None if successfully sent, an error message string otherwise.\n        \"\"\"\n        if not isinstance(info, dict) or \"addr\" not in info or \"content\" not in info:\n            return \"info structure is not correct\"\n\n        self.send_struct = info\n        return\n\n    def show(self, type):\n        \"\"\"\n        Returns struct of the specified type\n        :param type: string, the type of struct to be returned, which can be 'send' or 'receive'\n        :return: The corresponding struct if type is 'send' or 'receive', False otherwise.\n        \"\"\"\n        if type == \"send\":\n            return self.send_struct\n        elif type == \"receive\":\n            return self.receive_struct\n        else:\n            return False\n```",
    "75": "```python\nclass ShoppingCart:\n    \"\"\"\n    The class manages items, their prices, quantities, and allows to for add, remove, view items, and calculate the total price.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the items representing the shopping list as an empty dictionary\n        \"\"\"\n        self.items = {}\n\n    def add_item(self, item, price, quantity=1):\n        \"\"\"\n        Add item information to the shopping list items, including price and quantity. The default quantity is 1\n        :param item: string, Item to be added\n        :param price: float, The price of the item\n        :param quantity: int, The number of items, defaults to 1\n        :return: None\n        \"\"\"\n        if not isinstance(item, str):\n            raise TypeError(\"Item must be a string\")\n        if not isinstance(price, (int, float)):\n            raise TypeError(\"Price must be a number\")\n        if not isinstance(quantity, int):\n            raise TypeError(\"Quantity must be an integer\")\n        if price <= 0:\n            raise ValueError(\"Price must be positive\")\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be positive\")\n\n        if item in self.items:\n            self.items[item][\"quantity\"] = quantity\n        else:\n            self.items[item] = {\"price\": price, \"quantity\": quantity}\n\n    def remove_item(self, item, quantity=1):\n        \"\"\"\n        Subtract the specified quantity of item from the shopping list items\n        :param item: string, Item to be subtracted in quantity\n        :param quantity: int, Quantity to be subtracted\n        :return: None\n        \"\"\"\n        if not isinstance(item, str):\n            raise TypeError(\"Item must be a string\")\n        if not isinstance(quantity, int):\n            raise TypeError(\"Quantity must be an integer\")\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be positive\")\n\n        if item in self.items:\n            self.items[item][\"quantity\"] -= quantity\n            if self.items[item][\"quantity\"] <= 0:\n                del self.items[item]\n\n    def view_items(self) -> dict:\n        \"\"\"\n        Return the current shopping list items\n        :return: dict, the current shopping list items\n        \"\"\"\n        return self.items\n\n    def total_price(self) -> float:\n        \"\"\"\n        Calculate the total price of all items in the shopping list, which is the quantity of each item multiplied by the price\n        :return: float, the total price of all items in the shopping list\n        \"\"\"\n        total = 0.0\n        for item, details in self.items.items():\n            total += details[\"price\"] * details[\"quantity\"]\n        return total\n```",
    "76": "```python\nclass SignInSystem:\n    \"\"\"\n    This is a class as sigin in system, including adding users, signing in/out, checking sign-in status, and retrieving signed-in/not signed-in users.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the sign-in system.\n        \"\"\"\n        self.users = {}\n\n    def add_user(self, username):\n        \"\"\"\n        Add a user to the sign-in system if the user wasn't in the self.users.\n        And the initial state is False.\n        :param username: str, the username to be added.\n        :return: bool, True if the user is added successfully, False if the user already exists.\n        >>> signInSystem.add_user(\"mike\")\n        True\n        >>> signInSystem.add_user(\"mike\")\n        False\n        \"\"\"\n        if username in self.users:\n            return False\n        self.users[username] = False\n        return True\n\n    def sign_in(self, username):\n        \"\"\"\n        Sign in a user if the user was in the self.users and change the state to True.\n        :param username: str, the username to be signed in.\n        :return: bool, True if the user is signed in successfully, False if the user does not exist.\n        >>> signInSystem.sign_in(\"mike\")\n        True\n        >>> signInSystem.sign_in(\"mik\")\n        False\n        \"\"\"\n        if username not in self.users:\n            return False\n        self.users[username] = True\n        return True\n\n    def check_sign_in(self, username):\n        \"\"\"\n        Check if a user is signed in.\n        :param username: str, the username to be checked.\n        :return: bool, True if the user is signed in, False if the user does not exist or is not signed in.\n        >>> signInSystem.check_sign_in(\"jack\")\n        False\n        >>> signInSystem.add_user(\"jack\")\n        >>> signInSystem.check_sign_in(\"jack\")\n        >>> signInSystem.sign_in(\"jack\")\n        >>> signInSystem.check_sign_in(\"jack\")\n        True\n        \"\"\"\n        if username not in self.users:\n            return False\n        return self.users[username]\n\n    def all_signed_in(self):\n        \"\"\"\n        Check if all users are signed in.\n        :return: bool, True if all users are signed in, False otherwise.\n        >>> signInSystem.add_user(\"jack\")\n        True\n        >>> signInSystem.sign_in(\"jack\")\n        >>> signInSystem.all_signed_in()\n        True\n        \"\"\"\n        if not self.users:\n            return True\n        for username in self.users:\n            if not self.users[username]:\n                return False\n        return True\n\n    def all_not_signed_in(self):\n        \"\"\"\n        Get a list of usernames that are not signed in.\n        :return: list[str], a list of usernames that are not signed in.\n        >>> signInSystem = SignInSystem()\n        >>> signInSystem.add_user(\"a\")\n        True\n        >>> signInSystem.add_user(\"b\")\n        True\n        >>> signInSystem.all_not_signed_in()\n        ['a', 'b']\n        \"\"\"\n        not_signed_in = []\n        for username in self.users:\n            if not self.users[username]:\n                not_signed_in.append(username)\n        return not_signed_in\n```",
    "77": "```python\nimport random\n\nclass Snake:\n    \"\"\"\n    The class is a snake game, with allows snake to move and eat food, and also enables to reset, and generat a random food position.\n    \"\"\"\n\n    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):\n        \"\"\"\n        Initialize the length of the snake, screen width, screen height, block size, snake head position, score, and food position.\n        :param SCREEN_WIDTH: int\n        :param SCREEN_HEIGHT: int\n        :param BLOCK_SIZE: int, Size of moving units\n        :param food_position: tuple, representing the position(x, y) of food.\n        \"\"\"\n        self.length = 1\n        self.SCREEN_WIDTH = SCREEN_WIDTH\n        self.SCREEN_HEIGHT = SCREEN_HEIGHT\n        self.BLOCK_SIZE = BLOCK_SIZE\n        self.positions = [((SCREEN_WIDTH // 2), (SCREEN_HEIGHT // 2))]\n        self.score = 0\n        self.food_position = food_position\n\n\n    def move(self, direction):\n        \"\"\"\n        Move the snake in the specified direction. If the new position of the snake's head is equal to the position of the food, then eat the food; If the position of the snake's head is equal to the position of its body, then start over, otherwise its own length plus one.\n        :param direction: tuple, representing the direction of movement (x, y).\n        :return: None\n        \"\"\"\n        x, y = self.positions[0]\n        new_head = (x + direction[0], y + direction[1])\n\n        if new_head == self.food_position:\n            self.eat_food()\n            self.positions.insert(0, new_head)\n        elif new_head in self.positions[1:]:\n            self.reset()\n        else:\n            self.positions.insert(0, new_head)\n            self.positions.pop()\n\n    def random_food_position(self):\n        \"\"\"\n        Randomly generate a new food position, but don't place it on the snake.\n        :return: None, Change the food position\n        \"\"\"\n        while True:\n            x = random.randint(0, self.SCREEN_WIDTH - 1)\n            y = random.randint(0, self.SCREEN_HEIGHT - 1)\n            if (x, y) not in self.positions:\n                self.food_position = (x, y)\n                break\n\n\n    def reset(self):\n        \"\"\"\n        Reset the snake to its initial state. Set the length to 1, the snake head position to ((SCREEN_WIDTH/2), (SCREEN_HEIGHT/2)), the score to 0, and randomly generate new food position.\n        :return: None\n        \"\"\"\n        self.length = 1\n        self.positions = [((self.SCREEN_WIDTH // 2), (self.SCREEN_HEIGHT // 2))]\n        self.score = 0\n        self.random_food_position()\n\n\n    def eat_food(self):\n        \"\"\"\n        Increase the length of the snake by 1 and increase the score by 100. Randomly generate a new food position, but\n        don't place it on the snake.\n        :return: None\n        \"\"\"\n        self.length += 1\n        self.score += 100\n        self.random_food_position()\n```",
    "78": "```python\nimport re\n\nclass SplitSentence:\n    \"\"\"\n    The class allows to split sentences, count words in a sentence, and process a text file to find the maximum word count.\n    \"\"\"\n\n    def split_sentences(self, sentences_string):\n        \"\"\"\n        Split a string into a list of sentences. Sentences end with . or ? and with a space after that. Please note that Mr. also end with . but are not sentences.\n        :param sentences_string: string, string to split\n        :return:list, split sentence list\n        \"\"\"\n        sentences = re.split(r'(?<!Mr\\.)(?<!Mrs\\.)(?<!Ms\\.)(?<!Dr\\.)(?<![A-Z][a-z]\\.)(?<=[.?!])\\s+', sentences_string)\n        return sentences\n\n    def count_words(self, sentence):\n        \"\"\"\n        Count the number of words in a sentence. Note that words are separated by spaces and that punctuation marks and numbers are not counted as words.\n        :param sentence:string, sentence to be counted, where words are separated by spaces\n        :return:int, number of words in the sentence\n        \"\"\"\n        words = sentence.split()\n        count = 0\n        for word in words:\n            if word.isalpha():\n                count += 1\n        return count\n\n    def process_text_file(self, sentences_string):\n        \"\"\"\n        Given a text, return the number of words in the longest sentence\n        :param sentences_string: string, undivided long sentence\n        :return:int, the number of words in the longest sentence\n        \"\"\"\n        sentences = self.split_sentences(sentences_string)\n        max_words = 0\n        for sentence in sentences:\n            word_count = self.count_words(sentence)\n            if word_count > max_words:\n                max_words = word_count\n        return max_words\n```",
    "79": "```python\nclass SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        fields_str = ', '.join(fields) if fields else '*'\n        sql = f\"SELECT {fields_str} FROM {self.table_name}\"\n        if condition:\n            sql += f\" WHERE {condition}\"\n        sql += \";\"\n        return sql\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        fields = ', '.join(data.keys())\n        values = ', '.join([f\"'{value}'\" for value in data.values()])\n        sql = f\"INSERT INTO {self.table_name} ({fields}) VALUES ({values});\"\n        return sql\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and values are new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        updates = ', '.join([f\"{field} = '{value}'\" for field, value in data.items()])\n        sql = f\"UPDATE {self.table_name} SET {updates} WHERE {condition};\"\n        return sql\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition};\"\n        return sql\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        sql = f\"SELECT * FROM {self.table_name} WHERE age < {age} AND gender = 'female';\"\n        return sql\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        sql = f\"SELECT * FROM {self.table_name} WHERE age BETWEEN {min_age} AND {max_age};\"\n        return sql\n```",
    "80": "```python\nclass SQLQueryBuilder:\n    \"\"\"\n    This class provides methods to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements.\n    \"\"\"\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generates a SELECT SQL statement.\n\n        :param table: str, the name of the table.\n        :param columns: str or list of str, the columns to select.  Defaults to '*' (all columns).\n        :param where: dict, the WHERE clause conditions.\n        :return: str, the generated SQL query.\n        \"\"\"\n        query = \"SELECT \"\n\n        if isinstance(columns, list):\n            query += \", \".join(columns)\n        else:\n            query += str(columns)  # Ensure columns is a string\n\n        query += f\" FROM {table}\"\n\n        if where:\n            conditions = \" AND \".join(f\"{key}='{value}'\" for key, value in where.items())\n            query += f\" WHERE {conditions}\"\n\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generates an INSERT SQL statement.\n\n        :param table: str, the name of the table.\n        :param data: dict, the data to insert (column names and values).\n        :return: str, the generated SQL query.\n        \"\"\"\n        columns = \", \".join(data.keys())\n        values = \", \".join([f\"'{value}'\" for value in data.values()])\n        return f\"INSERT INTO {table} ({columns}) VALUES ({values})\"\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generates a DELETE SQL statement.\n\n        :param table: str, the name of the table.\n        :param where: dict, the WHERE clause conditions.\n        :return: str, the generated SQL query.\n        \"\"\"\n        query = f\"DELETE FROM {table}\"\n\n        if where:\n            conditions = \" AND \".join(f\"{key}='{value}'\" for key, value in where.items())\n            query += f\" WHERE {conditions}\"\n\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generates an UPDATE SQL statement.\n\n        :param table: str, the name of the table.\n        :param data: dict, the data to update (column names and values).\n        :param where: dict, the WHERE clause conditions.\n        :return: str, the generated SQL query.\n        \"\"\"\n        updates = \", \".join(f\"{key}='{value}'\" for key, value in data.items())\n        query = f\"UPDATE {table} SET {updates}\"\n\n        if where:\n            conditions = \" AND \".join(f\"{key}='{value}'\" for key, value in where.items())\n            query += f\" WHERE {conditions}\"\n\n        return query\n```",
    "81": "```python\nimport math\n\nclass Statistics3:\n    \"\"\"\n    This is a class that implements methods for calculating indicators such as median, mode, correlation matrix, and Z-score in statistics.\n    \"\"\"\n\n    @staticmethod\n    def median(data):\n        \"\"\"\n        Calculates the median of the given list.\n\n        Args:\n            data (list): The input list of numerical data.\n\n        Returns:\n            float: The median of the data.\n\n        Raises:\n            TypeError: If the input data is not a list or contains non-numerical data.\n            ValueError: If the input data list is empty.\n        \"\"\"\n        if not isinstance(data, list):\n            raise TypeError(\"Input data must be a list.\")\n        if not data:\n            raise ValueError(\"Input data list cannot be empty.\")\n        if not all(isinstance(x, (int, float)) for x in data):\n            raise TypeError(\"Input data must contain only numerical values.\")\n\n        n = len(data)\n        sorted_data = sorted(data)  # Avoid modifying the original list\n        if n % 2 == 0:\n            mid1 = sorted_data[n // 2 - 1]\n            mid2 = sorted_data[n // 2]\n            median = (mid1 + mid2) / 2\n        else:\n            median = sorted_data[n // 2]\n        return median\n\n    @staticmethod\n    def mode(data):\n        \"\"\"\n        Calculates the mode(s) of the given list.\n\n        Args:\n            data (list): The input list.\n\n        Returns:\n            list: A list containing the mode(s).  If all elements appear only once, returns the original list.\n\n        Raises:\n            TypeError: If the input data is not a list.\n            ValueError: If the input data list is empty.\n        \"\"\"\n        if not isinstance(data, list):\n            raise TypeError(\"Input data must be a list.\")\n        if not data:\n            raise ValueError(\"Input data list cannot be empty.\")\n\n        counts = {}\n        for item in data:\n            counts[item] = counts.get(item, 0) + 1\n\n        max_count = 0\n        modes = []\n        for item, count in counts.items():\n            if count > max_count:\n                modes = [item]\n                max_count = count\n            elif count == max_count:\n                modes.append(item)\n\n        if len(modes) == len(data) and len(set(data)) == len(data):\n            return modes\n        \n        return modes\n\n    @staticmethod\n    def mean(data):\n        \"\"\"\n        Calculates the mean of the given list.\n\n        Args:\n            data (list): The input list of numerical data.\n\n        Returns:\n            float: The mean of the data, or None if the input list is empty.\n\n        Raises:\n            TypeError: If the input data is not a list or contains non-numerical data.\n        \"\"\"\n        if not isinstance(data, list):\n            raise TypeError(\"Input data must be a list.\")\n        if not all(isinstance(x, (int, float)) for x in data):\n            raise TypeError(\"Input data must contain only numerical values.\")\n\n        if not data:\n            return None\n        return sum(data) / len(data)\n\n    @staticmethod\n    def standard_deviation(data):\n        \"\"\"\n        Calculates the standard deviation of the given list.\n\n        Args:\n            data (list): The input list of numerical data.\n\n        Returns:\n            float: The standard deviation of the data, or None if the input list is empty.\n\n        Raises:\n            TypeError: If the input data is not a list or contains non-numerical data.\n        \"\"\"\n        if not isinstance(data, list):\n            raise TypeError(\"Input data must be a list.\")\n        if not all(isinstance(x, (int, float)) for x in data):\n            raise TypeError(\"Input data must contain only numerical values.\")\n\n        n = len(data)\n        if n == 0:\n            return None\n\n        mean = Statistics3.mean(data)\n        if mean is None:\n            return None\n\n        variance = sum([(x - mean) ** 2 for x in data]) / n\n        return math.sqrt(variance)\n\n    @staticmethod\n    def z_score(data):\n        \"\"\"\n        Calculates the z-scores of the given list.\n\n        Args:\n            data (list): The input list of numerical data.\n\n        Returns:\n            list: A list of z-scores, or None if the standard deviation is zero or the input list has fewer than 2 elements.\n\n        Raises:\n            TypeError: If the input data is not a list or contains non-numerical data.\n        \"\"\"\n        if not isinstance(data, list):\n            raise TypeError(\"Input data must be a list.\")\n        if not all(isinstance(x, (int, float)) for x in data):\n            raise TypeError(\"Input data must contain only numerical values.\")\n\n        n = len(data)\n        if n <= 1:\n            return None\n\n        mean = Statistics3.mean(data)\n        std_dev = Statistics3.standard_deviation(data)\n\n        if std_dev == 0:\n            return None\n\n        if mean is None or std_dev is None:\n            return None\n\n        z_scores = [(x - mean) / std_dev for x in data]\n        return z_scores\n\n    @staticmethod\n    def correlation(x, y):\n        \"\"\"\n        Calculates the Pearson correlation coefficient between two lists.\n\n        Args:\n            x (list): The first list of numerical data.\n            y (list): The second list of numerical data.\n\n        Returns:\n            float: The Pearson correlation coefficient, or None if the lists have different lengths or the standard deviation of either list is zero.\n\n        Raises:\n            TypeError: If either input is not a list or contains non-numerical data.\n        \"\"\"\n        if not isinstance(x, list) or not isinstance(y, list):\n            raise TypeError(\"Inputs must be lists.\")\n        if not all(isinstance(val, (int, float)) for val in x) or not all(isinstance(val, (int, float)) for val in y):\n            raise TypeError(\"Inputs must contain only numerical values.\")\n\n        if len(x) != len(y):\n            return None\n\n        n = len(x)\n        if n <= 1:\n            return None\n\n        mean_x = Statistics3.mean(x)\n        mean_y = Statistics3.mean(y)\n\n        if mean_x is None or mean_y is None:\n            return None\n\n        numerator = sum([(x[i] - mean_x) * (y[i] - mean_y) for i in range(n)])\n        denominator_x = sum([(x[i] - mean_x) ** 2 for i in range(n)])\n        denominator_y = sum([(y[i] - mean_y) ** 2 for i in range(n)])\n\n        if denominator_x == 0 or denominator_y == 0:\n            return None\n\n        correlation = numerator / (math.sqrt(denominator_x) * math.sqrt(denominator_y))\n        return correlation\n\n    @staticmethod\n    def correlation_matrix(data):\n        \"\"\"\n        Calculates the correlation matrix for a list of lists.\n\n        Args:\n            data (list): A list of lists, where each inner list represents a variable.\n\n        Returns:\n            list: A correlation matrix (list of lists), where each element (i, j) represents the correlation between variable i and variable j. Returns a matrix filled with None if the input is invalid.\n\n        Raises:\n            TypeError: If the input is not a list of lists or if any inner list contains non-numerical data.\n        \"\"\"\n        if not isinstance(data, list) or not all(isinstance(row, list) for row in data):\n            return [[None] * 3 for _ in range(3)]\n\n        for row in data:\n            if not all(isinstance(val, (int, float)) for val in row):\n                return [[None] * 3 for _ in range(3)]\n\n        num_variables = len(data)\n        if num_variables == 0:\n            return [[None] * 3 for _ in range(3)]\n\n        matrix_width = len(data[0]) if data else 0\n        correlation_matrix = [[None] * matrix_width for _ in range(num_variables)]\n\n        for i in range(num_variables):\n            for j in range(num_variables):\n                correlation = Statistics3.correlation(data[i], data[j])\n                if correlation is not None:\n                    correlation_matrix[i] = [correlation] * matrix_width\n                    break\n                else:\n                    correlation_matrix[i] = [None] * matrix_width\n                    break\n        return correlation_matrix\n```",
    "82": "```python\nclass StockPortfolioTracker:\n    \"\"\"\n    This is a class as StockPortfolioTracker that allows to add stocks, remove stocks, buy stocks, sell stocks, calculate the total value of the portfolio, and obtain a summary of the portfolio.\n    \"\"\"\n\n    def __init__(self, cash_balance):\n        \"\"\"\n        Initialize the StockPortfolioTracker class with a cash balance and an empty portfolio.\n        \"\"\"\n        self.portfolio = []\n        self.cash_balance = cash_balance\n\n    def add_stock(self, stock):\n        \"\"\"\n        Add a stock to the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        \"\"\"\n        stock_name = stock[\"name\"]\n        stock_price = stock[\"price\"]\n        stock_quantity = stock[\"quantity\"]\n\n        for existing_stock in self.portfolio:\n            if existing_stock[\"name\"] == stock_name and existing_stock[\"price\"] == stock_price:\n                existing_stock[\"quantity\"] += stock_quantity\n                return\n\n        self.portfolio.append(stock)\n\n    def remove_stock(self, stock):\n        \"\"\"\n        Remove a stock from the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        \"\"\"\n        stock_name = stock[\"name\"]\n        stock_price = stock[\"price\"]\n        stock_quantity = stock[\"quantity\"]\n\n        for existing_stock in self.portfolio:\n            if existing_stock[\"name\"] == stock_name and existing_stock[\"price\"] == stock_price:\n                if existing_stock[\"quantity\"] >= stock_quantity:\n                    existing_stock[\"quantity\"] -= stock_quantity\n                    if existing_stock[\"quantity\"] == 0:\n                        self.portfolio.remove(existing_stock)\n                    return True\n                else:\n                    return False\n        return False\n\n    def buy_stock(self, stock):\n        \"\"\"\n        Buy a stock and add it to the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        :return: True if the stock was bought successfully, False if the cash balance is not enough.\n        \"\"\"\n        stock_name = stock[\"name\"]\n        stock_price = stock[\"price\"]\n        stock_quantity = stock[\"quantity\"]\n\n        cost = stock_price * stock_quantity\n\n        if self.cash_balance >= cost:\n            self.cash_balance -= cost\n            self.add_stock(stock)\n            return True\n        else:\n            return False\n\n    def sell_stock(self, stock):\n        \"\"\"\n        Sell a stock and remove it from the portfolio and add the cash to the cash balance.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        :return: True if the stock was sold successfully, False if the quantity of the stock is not enough.\n        \"\"\"\n        stock_name = stock[\"name\"]\n        stock_price = stock[\"price\"]\n        stock_quantity = stock[\"quantity\"]\n\n        for existing_stock in self.portfolio:\n            if existing_stock[\"name\"] == stock_name and existing_stock[\"price\"] == stock_price:\n                if existing_stock[\"quantity\"] >= stock_quantity:\n                    self.cash_balance += stock_price * stock_quantity\n                    existing_stock[\"quantity\"] -= stock_quantity\n                    if existing_stock[\"quantity\"] == 0:\n                        self.portfolio.remove(existing_stock)\n                    return True\n                else:\n                    return False\n        return False\n\n    def calculate_portfolio_value(self):\n        \"\"\"\n        Calculate the total value of the portfolio.\n        :return: the total value of the portfolio, float.\n        \"\"\"\n        total_value = self.cash_balance\n        for stock in self.portfolio:\n            total_value += stock[\"price\"] * stock[\"quantity\"]\n        return total_value\n\n    def get_portfolio_summary(self):\n        \"\"\"\n        Get a summary of the portfolio.\n        :return: a tuple of the total value of the portfolio and a list of dictionaries with keys \"name\" and \"value\"\n        \"\"\"\n        total_value = self.calculate_portfolio_value()\n        stock_values = []\n        for stock in self.portfolio:\n            stock_values.append({\"name\": stock[\"name\"], \"value\": stock[\"price\"] * stock[\"quantity\"]})\n        return total_value, stock_values\n\n    def get_stock_value(self, stock):\n        \"\"\"\n        Get the value of a stock.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        :return: the value of the stock, float.\n        \"\"\"\n        return stock[\"price\"] * stock[\"quantity\"]\n```",
    "83": "```python\nimport sqlite3\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This is a class with database operation, including inserting student information, searching for student information by name, and deleting student information by name.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n\n    def _execute_query(self, query, params=None):\n        \"\"\"\n        Executes a SQL query.  Handles connection and cursor management.\n        :param query: str, the SQL query to execute.\n        :param params: tuple, optional parameters for the query.\n        :return: list of tuples, the result of the query (if applicable).\n        \"\"\"\n        conn = None\n        cursor = None\n        try:\n            conn = sqlite3.connect(self.database_name)\n            cursor = conn.cursor()\n            if params:\n                cursor.execute(query, params)\n            else:\n                cursor.execute(query)\n            if query.lower().startswith(\"select\"):\n                result = cursor.fetchall()\n            else:\n                result = None\n            conn.commit()\n            return result\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n            if conn:\n                conn.rollback()\n            return None\n        finally:\n            if cursor:\n                cursor.close()\n            if conn:\n                conn.close()\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.Fields include ID of type int, name of type str, age of type int, gender of type str, and grade of type int\n        :return: None\n        \"\"\"\n        query = \"\"\"\n            CREATE TABLE IF NOT EXISTS students (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                name TEXT NOT NULL,\n                age INTEGER NOT NULL,\n                gender TEXT NOT NULL,\n                grade INTEGER NOT NULL\n            )\n        \"\"\"\n        self._execute_query(query)\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n        :return: None\n        \"\"\"\n        query = \"\"\"\n            INSERT INTO students (name, age, gender, grade)\n            VALUES (?, ?, ?, ?)\n        \"\"\"\n        params = (student_data['name'], student_data['age'], student_data['gender'], student_data['grade'])\n        self._execute_query(query, params)\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n        \"\"\"\n        query = \"SELECT * FROM students WHERE name=?\"\n        result = self._execute_query(query, (name,))\n        return result\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        \"\"\"\n        query = \"DELETE FROM students WHERE name=?\"\n        self._execute_query(query, (name,))\n```",
    "84": "```python\nimport json\nimport re\n\nclass TextFileProcessor:\n    \"\"\"\n    The class handles reading, writing, and processing text files. It can read the file as JSON, read the raw text, write content to the file, and process the file by removing non-alphabetic characters.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initialize the file path.\n        :param file_path: str\n        \"\"\"\n        self.file_path = file_path\n\n    def read_file_as_json(self):\n        \"\"\"\n        Read the self.file_path file as json format.\n        If the file content doesn't obey json format, attempt to parse it as a literal.\n        If both fail, return the content as a string.\n        :return: dict if the file is stored as json format, or str/int/float.. according to the file content otherwise.\n        \"\"\"\n        try:\n            with open(self.file_path, 'r') as f:\n                content = f.read()\n                return json.loads(content)\n        except json.JSONDecodeError:\n            try:\n                with open(self.file_path, 'r') as f:\n                    content = f.read()\n                    return eval(content)\n            except (NameError, SyntaxError, TypeError):\n                with open(self.file_path, 'r') as f:\n                    content = f.read()\n                    return content\n\n    def read_file(self):\n        \"\"\"\n        Read the content of self.file_path file.\n        :return: the content of the file as a string.\n        \"\"\"\n        try:\n            with open(self.file_path, 'r') as f:\n                return f.read()\n        except FileNotFoundError:\n            return None\n\n    def write_file(self, content):\n        \"\"\"\n        Write content into the self.file_path file, and overwrite if the file has already existed.\n        :param content: the content to write to the file.\n        \"\"\"\n        try:\n            with open(self.file_path, 'w') as f:\n                f.write(content)\n        except Exception as e:\n            print(f\"Error writing to file: {e}\")\n\n    def process_file(self):\n        \"\"\"\n        Read the self.file_path file and filter out non-alphabetic characters from the content string.\n        Overwrite the after-processed data into the same self.file_path file.\n        :return: The processed content.\n        \"\"\"\n        content = self.read_file()\n        if content is None:\n            return None\n\n        processed_content = ''.join(re.findall(r'[a-zA-Z]+', content))\n        self.write_file(processed_content)\n        return processed_content\n```",
    "85": "```python\nimport time\n\nclass Thermostat:\n    \"\"\"\n    The class manages temperature control, including setting and retrieving the target temperature, adjusting the mode, and simulating temperature operation.\n    \"\"\"\n\n    VALID_MODES = ['heat', 'cool']\n\n    def __init__(self, current_temperature, target_temperature, mode):\n        \"\"\"\n        Initializes instances of the Thermostat class.\n\n        :param current_temperature: float, the current temperature.\n        :param target_temperature: float, the target temperature.\n        :param mode: str, the operating mode ('heat' or 'cool').\n        :raises ValueError: if mode is not valid.\n        \"\"\"\n        self.current_temperature = current_temperature\n        self.target_temperature = target_temperature\n        if mode not in self.VALID_MODES:\n            self.mode = 'cool'\n        else:\n            self.mode = mode\n\n    def get_target_temperature(self):\n        \"\"\"\n        Gets the target temperature.\n\n        :return: float, the target temperature.\n        \"\"\"\n        return self.target_temperature\n\n    def set_target_temperature(self, temperature):\n        \"\"\"\n        Sets the target temperature.\n\n        :param temperature: float, the target temperature.\n        \"\"\"\n        self.target_temperature = temperature\n\n    def get_mode(self):\n        \"\"\"\n        Gets the current operating mode.\n\n        :return: str, the operating mode ('heat' or 'cool').\n        \"\"\"\n        return self.mode\n\n    def set_mode(self, mode):\n        \"\"\"\n        Sets the operating mode.\n\n        :param mode: str, the operating mode ('heat' or 'cool').\n        :return: bool, True if the mode was set successfully, False otherwise.\n        \"\"\"\n        if mode in self.VALID_MODES:\n            self.mode = mode\n            return True\n        return False\n\n    def auto_set_mode(self):\n        \"\"\"\n        Automatically sets the operating mode based on the current and target temperatures.\n        If the current temperature is lower than the target temperature, the mode is set to 'heat',\n        otherwise it is set to 'cool'.\n        \"\"\"\n        if self.current_temperature < self.target_temperature:\n            self.mode = 'heat'\n        else:\n            self.mode = 'cool'\n\n    def auto_check_conflict(self):\n        \"\"\"\n        Checks for conflicts between the operating mode and the temperature difference.\n        If a conflict exists, the operating mode is adjusted automatically.\n\n        :return: bool, True if no conflict exists, False otherwise.\n        \"\"\"\n        if self.mode == 'heat' and self.current_temperature >= self.target_temperature:\n            self.mode = 'cool'\n            return False\n        elif self.mode == 'cool' and self.current_temperature <= self.target_temperature:\n            self.mode = 'heat'\n            return False\n        else:\n            return True\n\n    def simulate_operation(self):\n        \"\"\"\n        Simulates the operation of the thermostat, adjusting the current temperature\n        until it reaches the target temperature.\n\n        :return: int, the number of iterations it took to reach the target temperature.\n        \"\"\"\n        start_time = 0\n        self.auto_set_mode()\n        tolerance = 0.5\n        while abs(self.current_temperature - self.target_temperature) > tolerance:\n            if self.mode == 'heat':\n                self.current_temperature += 1\n            else:\n                self.current_temperature -= 1\n            start_time += 1\n            if start_time > 100:\n                break\n        self.current_temperature = self.target_temperature\n        return start_time\n```",
    "86": "```python\nclass TicTacToe:\n    \"\"\"\n    The class represents a game of Tic-Tac-Toe and its functions include making a move on the board, checking for a winner, and determining if the board is full.\n    \"\"\"\n\n    def __init__(self, N=3):\n        \"\"\"\n        Initialize a 3x3 game board with all empty spaces and current symble player, default is 'X'.\n        \"\"\"\n        self.board = [[' ' for _ in range(N)] for _ in range(N)]\n        self.current_player = 'X'\n        self.size = N\n\n    def make_move(self, row, col):\n        \"\"\"\n        Place the current player's mark at the specified position on the board and switch the mark.\n        :param row: int, the row index of the position\n        :param col: int, the column index of the position\n        :return: bool, indicating whether the move was successful or not\n        \"\"\"\n        if not (0 <= row < self.size and 0 <= col < self.size):\n            return False\n\n        if self.board[row][col] == ' ':\n            self.board[row][col] = self.current_player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        else:\n            return False\n\n    def check_winner(self):\n        \"\"\"\n        Check if there is a winner on the board in rows, columns and diagonals three directions\n        :return: str or None, the mark of the winner ('X' or 'O'), or None if there is no winner yet\n        \"\"\"\n        # Check rows\n        for row in range(self.size):\n            if self.board[row][0] != ' ' and all(self.board[row][col] == self.board[row][0] for col in range(self.size)):\n                return self.board[row][0]\n\n        # Check columns\n        for col in range(self.size):\n            if self.board[0][col] != ' ' and all(self.board[row][col] == self.board[0][col] for row in range(self.size)):\n                return self.board[0][col]\n\n        # Check main diagonal\n        if self.board[0][0] != ' ' and all(self.board[i][i] == self.board[0][0] for i in range(self.size)):\n            return self.board[0][0]\n\n        # Check secondary diagonal\n        if self.board[0][self.size - 1] != ' ' and all(self.board[i][self.size - 1 - i] == self.board[0][self.size - 1] for i in range(self.size)):\n            return self.board[0][self.size - 1]\n\n        return None\n\n    def is_board_full(self):\n        \"\"\"\n        Check if the game board is completely filled.\n        :return: bool, indicating whether the game board is full or not\n        \"\"\"\n        for row in range(self.size):\n            for col in range(self.size):\n                if self.board[row][col] == ' ':\n                    return False\n        return True\n```",
    "87": "```python\nimport datetime\nimport time\n\nclass TimeUtils:\n    \"\"\"\n    This is a time util class, including getting the current time and date, adding seconds to a datetime, converting between strings and datetime objects, calculating the time difference in minutes, and formatting a datetime object.\n    \"\"\"\n\n\n    def __init__(self):\n        \"\"\"\n        Get the current datetime\n        \"\"\"\n        self.datetime = datetime.datetime.now()\n\n    def get_current_time(self):\n        \"\"\"\n        Return the current time in the format of '%H:%M:%S'\n        :return: string\n        >>> timeutils = TimeUtils()\n        >>> timeutils.get_current_time()\n        \"19:19:22\"\n        \"\"\"\n        return self.datetime.strftime(\"%H:%M:%S\")\n\n    def get_current_date(self):\n        \"\"\"\n        Return the current date in the format of \"%Y-%m-%d\"\n        :return: string\n        >>> timeutils.get_current_date()\n        \"2023-06-14\"\n        \"\"\"\n        return self.datetime.strftime(\"%Y-%m-%d\")\n\n    def add_seconds(self, seconds):\n        \"\"\"\n        Add the specified number of seconds to the current time\n        :param seconds: int, number of seconds to add\n        :return: string, time after adding the specified number of seconds in the format '%H:%M:%S'\n        >>> timeutils.add_seconds(600)\n        \"19:29:22\"\n        \"\"\"\n        new_datetime = self.datetime + datetime.timedelta(seconds=seconds)\n        return new_datetime.strftime(\"%H:%M:%S\")\n\n    def string_to_datetime(self, string):\n        \"\"\"\n        Convert the time string to a datetime instance\n        :param string: string, string before converting format\n        :return: datetime instance\n        >>> timeutils.string_to_datetime(\"2001-7-18 1:1:1\")\n        2001-07-18 01:01:01\n        \"\"\"\n        return datetime.datetime.strptime(string, \"%Y-%m-%d %H:%M:%S\")\n\n    def datetime_to_string(self, datetime_obj):\n        \"\"\"\n        Convert a datetime instance to a string\n        :param datetime: the datetime instance to convert\n        :return: string, converted time string\n        >>> timeutils.datetime_to_string(timeutils.datetime)\n        \"2023-06-14 19:30:03\"\n        \"\"\"\n        return datetime_obj.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    def get_minutes(self, string_time1, string_time2):\n        \"\"\"\n        Calculate how many minutes have passed between two times, and round the results to the nearest\n        :return: int, the number of minutes between two times, rounded off\n        >>> timeutils.get_minutes(\"2001-7-18 1:1:1\", \"2001-7-18 2:1:1\")\n        60\n        \"\"\"\n        datetime1 = datetime.datetime.strptime(string_time1, \"%Y-%m-%d %H:%M:%S\")\n        datetime2 = datetime.datetime.strptime(string_time2, \"%Y-%m-%d %H:%M:%S\")\n        difference = datetime2 - datetime1\n        minutes = round(difference.total_seconds() / 60)\n        return minutes\n\n    def get_format_time(self, year, month, day, hour, minute, second):\n        \"\"\"\n        get format time\n        :param year: int\n        :param month: int\n        :param day: int\n        :param hour: int\n        :param minute: int\n        :param second: int\n        :return: formatted time string\n        >>> timeutils.get_format_time(2001, 7, 18, 1, 1, 1)\n        \"2001-07-18 01:01:01\"\n        \"\"\"\n        return datetime.datetime(year, month, day, hour, minute, second).strftime(\"%Y-%m-%d %H:%M:%S\")\n```",
    "88": "```python\nfrom math import pi, fabs\n\nclass TriCalculator:\n    \"\"\"\n    The class allows to calculate trigonometric values, including cosine, sine, and tangent, using Taylor series approximations.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def cos(self, x):\n        \"\"\"\n        Calculate the cos value of the x-degree angle\n        :param x: float\n        :return: float\n        \"\"\"\n        return self.taylor(x, 50)\n\n    def factorial(self, a):\n        \"\"\"\n        Calculate the factorial of a\n        :param a: int\n        :return: int\n        \"\"\"\n        if not isinstance(a, int):\n            raise TypeError(\"Input must be an integer.\")\n        if a < 0:\n            raise ValueError(\"Input must be a non-negative integer.\")\n        if a == 0:\n            return 1\n        else:\n            result = 1\n            for i in range(1, a + 1):\n                result *= i\n            return result\n\n    def taylor(self, x, n):\n        \"\"\"\n        Finding the n-order Taylor expansion value of cos (x/180 * pi)\n        :param x: int\n        :param n: int\n        :return: float\n        \"\"\"\n        x = x / 180 * pi\n        result = 0\n        for i in range(n):\n            numerator = (-1)**i * x**(2*i)\n            denominator = self.factorial(2*i)\n            result += numerator / denominator\n        return result\n\n    def sin(self, x):\n        \"\"\"\n        Calculate the sin value of the x-degree angle\n        :param x: float\n        :return: float\n        \"\"\"\n        x = x / 180 * pi\n        result = 0\n        n = 50\n        for i in range(n):\n            numerator = (-1)**i * x**(2*i + 1)\n            denominator = self.factorial(2*i + 1)\n            result += numerator / denominator\n        return result\n\n\n    def tan(self, x):\n        \"\"\"\n        Calculate the tan value of the x-degree angle\n        :param x: float\n        :return: float\n        \"\"\"\n        if x % 180 == 90:\n            return False\n        else:\n            return self.sin(x) / self.cos(x)\n```",
    "89": "```python\nimport random\n\nclass TwentyFourPointGame:\n    \"\"\"\n    This is a game of twenty-four points, which provides to generate four numbers and check whether player's expression is equal to 24.\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"\n        Initializes the game with an empty list of numbers.\n        \"\"\"\n        self.nums = []\n\n\n    def _generate_cards(self):\n        \"\"\"\n        Generates four random numbers between 1 and 9 (inclusive) for the cards.\n        \"\"\"\n        self.nums = [random.randint(1, 9) for _ in range(4)]\n\n\n    def get_my_cards(self):\n        \"\"\"\n        Generates and returns a list of four random numbers between 1 and 9, representing the player's cards.\n        :return: list of integers, representing the player's cards\n        \"\"\"\n        self._generate_cards()\n        return self.nums\n\n\n    def answer(self, expression):\n        \"\"\"\n        Checks if a given mathematical expression using the cards can evaluate to 24.\n        :param expression: string, mathematical expression using the cards\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        \"\"\"\n        if not self.nums:\n            return [0, 0, 0, 0]  # Or raise an exception, depending on desired behavior\n\n        return self.evaluate_expression(expression)\n\n\n    def evaluate_expression(self, expression):\n        \"\"\"\n        Evaluates a mathematical expression and checks if the result is 24.\n        :param expression: string, mathematical expression\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        \"\"\"\n        try:\n            result = eval(expression)\n            return abs(result - 24) < 1e-6  # Using a small tolerance for floating-point comparisons\n        except (SyntaxError, NameError, TypeError, ZeroDivisionError):\n            return False\n```",
    "90": "```python\nfrom urllib.parse import urlparse, parse_qs\n\n\nclass URLHandler:\n    \"\"\"\n    The class supports to handle URLs, including extracting the scheme, host, path, query parameters, and fragment.\n    \"\"\"\n\n    def __init__(self, url):\n        \"\"\"\n        Initialize URLHandler's URL\n        \"\"\"\n        self.url = url\n\n    def get_scheme(self):\n        \"\"\"\n        get the scheme of the URL\n        :return: string, If successful, return the scheme of the URL\n        \"\"\"\n        try:\n            parsed_url = urlparse(self.url)\n            return parsed_url.scheme or None\n        except Exception:\n            return None\n\n    def get_host(self):\n        \"\"\"\n        Get the second part of the URL, which is the host domain name\n        :return: string, If successful, return the host domain name of the URL\n        \"\"\"\n        try:\n            parsed_url = urlparse(self.url)\n            return parsed_url.netloc or None\n        except Exception:\n            return None\n\n    def get_path(self):\n        \"\"\"\n        Get the third part of the URL, which is the address of the resource\n        :return: string, If successful, return the address of the resource of the URL\n        \"\"\"\n        try:\n            parsed_url = urlparse(self.url)\n            path = parsed_url.path\n            query = parsed_url.query\n            fragment = parsed_url.fragment\n\n            result = path\n\n            if query:\n                result += \"?\" + query\n            if fragment:\n                result += \"#\" + fragment\n\n            return result or None\n        except Exception:\n            return None\n\n    def get_query_params(self):\n        \"\"\"\n        Get the request parameters for the URL\n        :return: dict, If successful, return the request parameters of the URL\n        \"\"\"\n        try:\n            parsed_url = urlparse(self.url)\n            query_params = parse_qs(parsed_url.query)\n            if not query_params:\n                return None\n            return {k: v[0] for k, v in query_params.items()}\n        except Exception:\n            return None\n\n    def get_fragment(self):\n        \"\"\"\n        Get the fragment after '#' in the URL\n        :return: string, If successful, return the fragment after '#' of the URL\n        \"\"\"\n        try:\n            parsed_url = urlparse(self.url)\n            return parsed_url.fragment or None\n        except Exception:\n            return None\n```",
    "91": "```python\nimport urllib.parse\n\nclass UrlPath:\n    \"\"\"\n    The  class is a utility for encapsulating and manipulating the path component of a URL, including adding nodes, parsing path strings, and building path strings with optional encoding.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the UrlPath object with an empty list of segments and a flag indicating the presence of an end tag.\n        \"\"\"\n        self.segments = []\n        self.with_end_tag = False\n\n    def add(self, segment):\n        \"\"\"\n        Adds a segment to the list of segments in the UrlPath.\n        :param segment: str, the segment to add.\n        \"\"\"\n        self.segments.append(segment)\n\n\n    def parse(self, path, charset):\n        \"\"\"\n        Parses a given path string and populates the list of segments in the UrlPath.\n        :param path: str, the path string to parse.\n        :param charset: str, the character encoding of the path string.\n        \"\"\"\n        path = self.fix_path(path)\n        self.with_end_tag = path.endswith('/')\n        if self.with_end_tag:\n            path = path[:-1]\n\n        if path:\n            self.segments = path.split('/')\n        else:\n            self.segments = []\n\n\n    @staticmethod\n    def fix_path(path):\n        \"\"\"\n        Fixes the given path string by removing leading and trailing slashes.\n        :param path: str, the path string to fix.\n        :return: str, the fixed path string.\n        \"\"\"\n        path = path.strip('/')\n        return path\n```",
    "92": "```python\nimport sqlite3\n\nclass UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information, searching user information, deleting user information, and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.db_name = db_name\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates the 'users' table if it doesn't exist.\n        \"\"\"\n        try:\n            query = \"\"\"\n            CREATE TABLE IF NOT EXISTS users (\n                username TEXT PRIMARY KEY,\n                password TEXT\n            )\n            \"\"\"\n            self.cursor.execute(query)\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        \"\"\"\n        try:\n            query = \"INSERT INTO users (username, password) VALUES (?, ?)\"\n            self.cursor.execute(query, (username, password))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return: tuple, the row from the \"users\" table that matches the search criteria, or None if not found.\n        \"\"\"\n        try:\n            query = \"SELECT username, password FROM users WHERE username = ?\"\n            self.cursor.execute(query, (username,))\n            result = self.cursor.fetchone()\n            return result\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n            return None\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        \"\"\"\n        try:\n            query = \"DELETE FROM users WHERE username = ?\"\n            self.cursor.execute(query, (username,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct\n        :param username:str, the username of the user to validate.\n        :param password:str, the password of the user to validate.\n        :return:bool, representing whether the user can log in correctly\n        \"\"\"\n        user = self.search_user_by_username(username)\n        if user:\n            return user[1] == password\n        return False\n```",
    "93": "```python\nimport numpy as np\nfrom gensim import matutils\nimport math\n\nclass VectorUtil:\n    \"\"\"\n    The class provides vector operations, including calculating similarity, cosine similarities, average similarity, and IDF weights.\n    \"\"\"\n\n    @staticmethod\n    def similarity(vector_1, vector_2):\n        \"\"\"\n        Compute the cosine similarity between one vector and another vector.\n        :param vector_1: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :param vector_2: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :return: float, Cosine similarity between `vector_1` and `vector_2`.\n        >>> vector_1 = np.array([1, 1])\n        >>> vector_2 = np.array([1, 0])\n        >>> VectorUtil.similarity(vector_1, vector_2)\n        0.7071067811865475\n        \"\"\"\n        vector_1 = matutils.unitvec(vector_1)\n        vector_2 = matutils.unitvec(vector_2)\n        return np.dot(vector_1, vector_2)\n\n\n    @staticmethod\n    def cosine_similarities(vector_1, vectors_all):\n        \"\"\"\n        Compute cosine similarities between one vector and a set of other vectors.\n        :param vector_1: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :param vectors_all: list of numpy.ndarray, For each row in vectors_all, distance from vector_1 is computed, expected shape (num_vectors, dim).\n        :return: list, Contains cosine distance between `vector_1` and each row in `vectors_all`, shape (num_vectors,).\n        >>> vector1 = np.array([1, 2, 3])\n        >>> vectors_all = [np.array([4, 5, 6]), np.array([7, 8, 9])]\n        >>> VectorUtil.cosine_similarities(vector1, vectors_all)\n        [0.97463185 0.95941195]\n        \"\"\"\n        unit_vector_1 = matutils.unitvec(vector_1)\n        similarities = [np.dot(unit_vector_1, matutils.unitvec(vector)) for vector in vectors_all]\n        return similarities\n\n\n    @staticmethod\n    def n_similarity(vector_list_1, vector_list_2):\n        \"\"\"\n        Compute cosine similarity between two sets of vectors.\n        :param vector_list_1: list of numpy vector\n        :param vector_list_2: list of numpy vector\n        :return: float, Average cosine similarity between vectors in vector_list_1 and vector_list_2. Returns 0.0 if either list is empty.\n        >>> vector_list1 = [np.array([1, 2, 3]), np.array([4, 5, 6])]\n        >>> vector_list2 = [np.array([7, 8, 9]), np.array([10, 11, 12])]\n        >>> VectorUtil.n_similarity(vector_list1, vector_list_2)\n        0.9897287473881233\n        \"\"\"\n        if not vector_list_1 or not vector_list_2:\n            return 0.0\n\n        unit_vectors_1 = [matutils.unitvec(vector) for vector in vector_list_1]\n        unit_vectors_2 = [matutils.unitvec(vector) for vector in vector_list_2]\n\n        similarity_sum = sum(np.dot(v1, v2) for v1 in unit_vectors_1 for v2 in unit_vectors_2)\n        return similarity_sum / (len(vector_list_1) * len(vector_list_2))\n\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num, number_dict):\n        \"\"\"\n        Calculate log((total_num + 1) / (count + 1)) for each count in number_dict.\n        :param total_num: int, Total number of documents.\n        :param number_dict: dict, Dictionary where keys are terms and values are their document frequencies.\n        :return: dict, Dictionary where keys are terms and values are their IDF weights.\n        >>> num_dict = {'key1':0.1, 'key2':0.5}\n        >>> VectorUtil.compute_idf_weight_dict(2, num_dict)\n        {'key1': 1.0033021088637848, 'key2': 0.6931471805599453}\n        \"\"\"\n        idf_weight_dict = {key: math.log((total_num + 1) / (count + 1)) for key, count in number_dict.items()}\n        return idf_weight_dict\n```",
    "94": "```python\nclass VendingMachine:\n    \"\"\"\n    This is a class to simulate a vending machine, including adding products, inserting coins, purchasing products, viewing balance, replenishing product inventory, and displaying product information.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the vending machine's inventory and balance.\n        \"\"\"\n        self.inventory = {}\n        self.balance = 0.0\n\n    def add_item(self, item_name, price, quantity):\n        \"\"\"\n        Adds a product to the vending machine's inventory.\n        :param item_name: The name of the product to be added, str.\n        :param price: The price of the product to be added, float.\n        :param quantity: The quantity of the product to be added, int.\n        :return: None\n        \"\"\"\n        if not isinstance(item_name, str):\n            raise TypeError(\"item_name must be a string\")\n        if not isinstance(price, (int, float)):\n            raise TypeError(\"price must be a number\")\n        if not isinstance(quantity, int):\n            raise TypeError(\"quantity must be an integer\")\n        if price <= 0:\n            raise ValueError(\"price must be positive\")\n        if quantity <= 0:\n            raise ValueError(\"quantity must be positive\")\n\n        if item_name in self.inventory:\n            self.inventory[item_name]['quantity'] += quantity\n        else:\n            self.inventory[item_name] = {'price': price, 'quantity': quantity}\n\n    def insert_coin(self, amount):\n        \"\"\"\n        Inserts coins into the vending machine.\n        :param amount: The amount of coins to be inserted, float.\n        :return: The balance of the vending machine after the coins are inserted, float.\n        \"\"\"\n        if not isinstance(amount, (int, float)):\n            raise TypeError(\"amount must be a number\")\n        if amount <= 0:\n            raise ValueError(\"amount must be positive\")\n\n        self.balance += amount\n        return round(self.balance, 2)\n\n    def purchase_item(self, item_name):\n        \"\"\"\n        Purchases a product from the vending machine and returns the balance after the purchase and display purchase unsuccessful if the product is out of stock.\n        :param item_name: The name of the product to be purchased, str.\n        :return: If successful, returns the balance of the vending machine after the product is purchased, float,otherwise,returns False.\n        \"\"\"\n        if not isinstance(item_name, str):\n            raise TypeError(\"item_name must be a string\")\n\n        if item_name not in self.inventory:\n            return False\n\n        if self.inventory[item_name]['quantity'] <= 0:\n            return False\n\n        if self.balance < self.inventory[item_name]['price']:\n            return False\n\n        self.balance -= self.inventory[item_name]['price']\n        self.inventory[item_name]['quantity'] -= 1\n        return round(self.balance, 2)\n\n    def restock_item(self, item_name, quantity):\n        \"\"\"\n        Replenishes the inventory of a product already in the vending machine.\n        :param item_name: The name of the product to be replenished, str.\n        :param quantity: The quantity of the product to be replenished, int.\n        :return: If the product is already in the vending machine, returns True, otherwise, returns False.\n        \"\"\"\n        if not isinstance(item_name, str):\n            raise TypeError(\"item_name must be a string\")\n        if not isinstance(quantity, int):\n            raise TypeError(\"quantity must be an integer\")\n        if quantity <= 0:\n            raise ValueError(\"quantity must be positive\")\n\n        if item_name not in self.inventory:\n            return False\n\n        self.inventory[item_name]['quantity'] += quantity\n        return True\n\n    def display_items(self):\n        \"\"\"\n        Displays the products in the vending machine.\n        :return: If the vending machine is empty, returns False, otherwise, returns a list of the products in the vending machine, str.\n        \"\"\"\n        if not self.inventory:\n            return False\n\n        display_string = \"\"\n        items = list(self.inventory.items())\n        for i, (item_name, item_data) in enumerate(items):\n            display_string += f\"{item_name} - ${item_data['price']} [{item_data['quantity']}]\"\n            if i < len(items) - 1:\n                display_string += \"\\n\"\n        return display_string\n```",
    "95": "```python\nclass Warehouse:\n    \"\"\"\n    The class manages inventory and orders, including adding products, updating product quantities, retrieving product quantities, creating orders, changing order statuses, and tracking orders.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize inventory and orders.\n        inventory: {product_id: {'name': product_name, 'quantity': quantity}}\n        orders: {order_id: {'product_id': product_id, 'quantity': quantity, 'status': order_status}}\n        \"\"\"\n        self.inventory = {}\n        self.orders = {}\n\n    def add_product(self, product_id, name, quantity):\n        \"\"\"\n        Adds a product to the inventory or updates the quantity if the product already exists.\n\n        :param product_id: int, the unique identifier for the product\n        :param name: str, the name of the product\n        :param quantity: int, the quantity of the product to add\n        \"\"\"\n        if not isinstance(product_id, int) or not isinstance(quantity, int) or not isinstance(name, str):\n            raise TypeError(\"Invalid input types. Product ID and quantity must be integers, and name must be a string.\")\n\n        if product_id in self.inventory:\n            self.inventory[product_id]['quantity'] += quantity\n        else:\n            self.inventory[product_id] = {'name': name, 'quantity': quantity}\n\n    def update_product_quantity(self, product_id, quantity):\n        \"\"\"\n        Updates the quantity of a product in the inventory.\n\n        :param product_id: int, the unique identifier for the product\n        :param quantity: int, the quantity to add to the existing quantity (can be negative)\n        \"\"\"\n        if not isinstance(product_id, int) or not isinstance(quantity, int):\n            raise TypeError(\"Invalid input types. Product ID and quantity must be integers.\")\n\n        if product_id in self.inventory:\n            self.inventory[product_id]['quantity'] += quantity\n\n    def get_product_quantity(self, product_id):\n        \"\"\"\n        Retrieves the quantity of a product in the inventory.\n\n        :param product_id: int, the unique identifier for the product\n        :return: int, the quantity of the product if it exists in the inventory, or False otherwise\n        \"\"\"\n        if not isinstance(product_id, int):\n            raise TypeError(\"Product ID must be an integer.\")\n\n        if product_id in self.inventory:\n            return self.inventory[product_id]['quantity']\n        else:\n            return False\n\n    def create_order(self, order_id, product_id, quantity):\n        \"\"\"\n        Creates a new order.\n\n        :param order_id: int, the unique identifier for the order\n        :param product_id: int, the unique identifier for the product being ordered\n        :param quantity: int, the quantity of the product being ordered\n        :return: bool, True if the order was created successfully, False otherwise (e.g., insufficient stock)\n        \"\"\"\n        if not isinstance(order_id, int) or not isinstance(product_id, int) or not isinstance(quantity, int):\n            raise TypeError(\"Invalid input types. Order ID, Product ID, and quantity must be integers.\")\n\n        if product_id not in self.inventory:\n            return False\n\n        if self.inventory[product_id]['quantity'] < quantity:\n            return False\n\n        self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}\n        return True\n\n    def change_order_status(self, order_id, status):\n        \"\"\"\n        Changes the status of an existing order.\n\n        :param order_id: int, the unique identifier for the order\n        :param status: str, the new status of the order\n        :return: bool, True if the order status was changed successfully, False otherwise (e.g., order not found)\n        \"\"\"\n        if not isinstance(order_id, int) or not isinstance(status, str):\n            raise TypeError(\"Invalid input types. Order ID must be an integer, and status must be a string.\")\n\n        if order_id not in self.orders:\n            return False\n\n        self.orders[order_id]['status'] = status\n        return True\n\n    def track_order(self, order_id):\n        \"\"\"\n        Retrieves the status of an order.\n\n        :param order_id: int, the unique identifier for the order\n        :return: str, the status of the order if it exists, or False otherwise\n        \"\"\"\n        if not isinstance(order_id, int):\n            raise TypeError(\"Order ID must be an integer.\")\n\n        if order_id not in self.orders:\n            return False\n\n        return self.orders[order_id]['status']\n```",
    "96": "```python\nclass WeatherSystem:\n    \"\"\"\n    This is a class representing a weather system that provides functionality to query weather information for a specific city and convert temperature units between Celsius and Fahrenheit.\n    \"\"\"\n\n    def __init__(self, city):\n        \"\"\"\n        Initialize the weather system with a city name.\n        \"\"\"\n        self.city = city\n        self.temperature = None\n        self.weather = None\n\n    def query(self, weather_data, tmp_units='celsius'):\n        \"\"\"\n        Query the weather system for the weather and temperature of the city, and convert the temperature units based on the input parameter.\n\n        :param weather_data: A dictionary of weather information for different cities.\n        :param tmp_units: The temperature units to convert to ('celsius' or 'fahrenheit').\n        :return: A tuple containing the temperature and weather of the city, or False if the city is not found.\n        \"\"\"\n        if self.city not in weather_data:\n            return False\n\n        city_data = weather_data[self.city]\n        temperature = city_data['temperature']\n        weather = city_data['weather']\n        temperature_units = city_data['temperature units']\n\n        if temperature_units.lower() not in ('celsius', 'fahrenheit'):\n            raise ValueError(\"Invalid temperature units in weather data. Must be 'celsius' or 'fahrenheit'.\")\n\n        if tmp_units.lower() not in ('celsius', 'fahrenheit'):\n            raise ValueError(\"Invalid tmp_units. Must be 'celsius' or 'fahrenheit'.\")\n\n        if temperature_units.lower() != tmp_units.lower():\n            if tmp_units.lower() == 'celsius':\n                temperature = self.fahrenheit_to_celsius_static(temperature)\n            else:  # tmp_units == 'fahrenheit'\n                temperature = self.celsius_to_fahrenheit_static(temperature)\n\n        return temperature, weather\n\n    def set_city(self, city):\n        \"\"\"\n        Set the city of the weather system.\n\n        :param city: The city to set.\n        \"\"\"\n        self.city = city\n\n    def celsius_to_fahrenheit(self):\n        \"\"\"\n        Convert the temperature from Celsius to Fahrenheit.\n\n        :return: The temperature in Fahrenheit.\n        \"\"\"\n        if self.temperature is None:\n            raise ValueError(\"Temperature must be set before conversion.\")\n        return self.celsius_to_fahrenheit_static(self.temperature)\n\n    def fahrenheit_to_celsius(self):\n        \"\"\"\n        Convert the temperature from Fahrenheit to Celsius.\n\n        :return: The temperature in Celsius.\n        \"\"\"\n        if self.temperature is None:\n            raise ValueError(\"Temperature must be set before conversion.\")\n        return self.fahrenheit_to_celsius_static(self.temperature)\n\n    @staticmethod\n    def celsius_to_fahrenheit_static(celsius):\n        \"\"\"\n        Convert Celsius to Fahrenheit.\n        \"\"\"\n        return (celsius * 9 / 5) + 32\n\n    @staticmethod\n    def fahrenheit_to_celsius_static(fahrenheit):\n        \"\"\"\n        Convert Fahrenheit to Celsius.\n        \"\"\"\n        return (fahrenheit - 32) * 5 / 9\n```",
    "97": "```python\nclass Words2Numbers:\n    \"\"\"\n    The class provides a text-to-number conversion utility, allowing conversion of written numbers (in words) to their numerical representation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the word lists and dictionaries required for conversion\n        \"\"\"\n        self.numwords = {}\n        self.units = [\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\n            \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n            \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\",\n        ]\n        self.tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        self.scales = [\"hundred\", \"thousand\", \"million\", \"billion\", \"trillion\"]\n\n        self.numwords[\"and\"] = (1, 0)\n        for idx, word in enumerate(self.units):\n            self.numwords[word] = (1, idx)\n        for idx, word in enumerate(self.tens):\n            self.numwords[word] = (1, idx * 10)\n        for idx, word in enumerate(self.scales):\n            self.numwords[word] = (10 ** (idx * 3 or 2), 0)\n\n        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}\n        self.ordinal_endings = [('ieth', 'y'), ('th', '')]\n\n    def text2int(self, textnum):\n        \"\"\"\n        Convert the word string to the corresponding integer string\n        :param textnum: string, the word string to be converted\n        :return: string, the final converted integer string\n        \"\"\"\n        textnum = textnum.replace('-', ' ')\n        current_number = 0\n        final_number = 0\n        parts = textnum.split()\n\n        for word in parts:\n            word = word.lower()\n            if word in self.numwords:\n                scale, increment = self.numwords[word]\n                current_number = current_number * scale + increment\n                if scale > 100:\n                    final_number += current_number\n                    current_number = 0\n            elif word in self.ordinal_words:\n                final_number += self.ordinal_words[word]\n                current_number = 0\n            else:\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        base_word = word[:-len(ending)] + replacement\n                        if base_word in self.numwords:\n                            scale, increment = self.numwords[base_word]\n                            current_number = current_number * scale + increment\n                            final_number += current_number\n                            current_number = 0\n                            break\n                else:\n                    return \"0\"\n\n        final_number += current_number\n        return str(final_number)\n\n    def is_valid_input(self, textnum):\n        \"\"\"\n        Check if the input text contains only valid words that can be converted into numbers.\n        :param textnum: The input text containing words representing numbers.\n        :return: True if input is valid, False otherwise.\n        \"\"\"\n        textnum = textnum.replace('-', ' ')\n        parts = textnum.split()\n        valid_words = list(self.numwords.keys()) + list(self.ordinal_words.keys())\n        for word in parts:\n            word = word.lower()\n            found = False\n            if word in valid_words:\n                found = True\n            else:\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        base_word = word[:-len(ending)] + replacement\n                        if base_word in self.numwords:\n                            found = True\n                            break\n                if not found:\n                    return False\n        return True\n```",
    "98": "```python\nimport xml.etree.ElementTree as ET\n\n\nclass XMLProcessor:\n    \"\"\"\n    This is a class as XML files handler, including reading, writing, processing as well as finding elements in a XML file.\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize the XMLProcessor object with the given file name.\n        :param file_name:string, the name of the XML file to be processed.\n        \"\"\"\n        self.file_name = file_name\n        self.root = None\n\n    def read_xml(self):\n        \"\"\"\n        Reads the XML file and returns the root element.\n        :return: Element, the root element of the XML file, or None if an error occurs.\n        \"\"\"\n        try:\n            tree = ET.parse(self.file_name)\n            self.root = tree.getroot()\n            return self.root\n        except FileNotFoundError:\n            print(f\"Error: File not found: {self.file_name}\")\n            return None\n        except ET.ParseError:\n            print(f\"Error: XML parsing error in: {self.file_name}\")\n            return None\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n            return None\n\n    def write_xml(self, file_name):\n        \"\"\"\n        Writes the XML data to the specified file.\n        :param file_name: string, the name of the file to write the XML data.\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n        if self.root is None:\n            print(\"Error: No XML data to write.  Ensure XML has been read first.\")\n            return False\n\n        try:\n            tree = ET.ElementTree(self.root)\n            tree.write(file_name)\n            return True\n        except Exception as e:\n            print(f\"Error writing to file {file_name}: {e}\")\n            return False\n\n    def process_xml_data(self, file_name):\n        \"\"\"\n        Modifies the data in XML elements and writes the updated XML data to a new file.\n        Specifically, converts the text of all 'item' elements to uppercase.\n        :param file_name: string, the name of the file to write the modified XML data.\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n        if self.root is None:\n            print(\"Error: No XML data to process. Ensure XML has been read first.\")\n            return False\n\n        try:\n            for element in self.root.findall('.//item'):\n                if element.text is not None:\n                    element.text = element.text.upper()\n\n            tree = ET.ElementTree(self.root)\n            tree.write(file_name)\n            return True\n        except Exception as e:\n            print(f\"Error processing and writing to file {file_name}: {e}\")\n            return False\n\n    def find_element(self, element_name):\n        \"\"\"\n        Finds the XML elements with the specified name.\n        :param element_name: string, the name of the elements to find.\n        :return: list, a list of found elements with the specified name.  Returns an empty list if no elements are found or if an error occurs.\n        \"\"\"\n        if self.root is None:\n            print(\"Error: No XML data to search. Ensure XML has been read first.\")\n            return []\n\n        try:\n            return self.root.findall(element_name)\n        except Exception as e:\n            print(f\"Error finding elements with name {element_name}: {e}\")\n            return []\n```",
    "99": "```python\nimport zipfile\nimport os\n\n\nclass ZipFileProcessor:\n    \"\"\"\n    This is a compressed file processing class that provides the ability to read and decompress compressed files\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize file name\n        :param file_name:string\n        \"\"\"\n        self.file_name = file_name\n\n    def read_zip_file(self):\n        \"\"\"\n        Get open file object\n        :return:If successful, returns the open file object; otherwise, returns None\n        \"\"\"\n        try:\n            zip_file = zipfile.ZipFile(self.file_name, 'r')\n            return zip_file\n        except FileNotFoundError:\n            return None\n        except zipfile.BadZipFile:\n            return None\n        except Exception:\n            return None\n\n    def extract_all(self, output_path):\n        \"\"\"\n        Extract all zip files and place them in the specified path\n        :param output_path: string, The location of the extracted file\n        :return: True or False, representing whether the extraction operation was successful\n        \"\"\"\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                zip_file.extractall(output_path)\n            return True\n        except FileNotFoundError:\n            return False\n        except zipfile.BadZipFile:\n            return False\n        except Exception:\n            return False\n\n    def extract_file(self, file_name, output_path):\n        \"\"\"\n        Extract the file with the specified name from the zip file and place it in the specified path\n        :param file_name:string, The name of the file to be uncompressed\n        :param output_path:string, The location of the extracted file\n        :return: True or False, representing whether the extraction operation was successful\n        \"\"\"\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                zip_file.extract(file_name, output_path)\n            return True\n        except FileNotFoundError:\n            return False\n        except KeyError:\n            return False\n        except zipfile.BadZipFile:\n            return False\n        except Exception:\n            return False\n\n    def create_zip_file(self, files, output_file_name):\n        \"\"\"\n        Compress the specified file list into a zip file and place it in the specified path\n        :param files:list of string, List of files to compress\n        :param output_file_name: string, Specified output path\n        :return:True or False, representing whether the compression operation was successful\n        \"\"\"\n        try:\n            with zipfile.ZipFile(output_file_name, 'w') as zip_file:\n                for file in files:\n                    if os.path.exists(file):\n                        zip_file.write(file, os.path.basename(file))\n                    else:\n                        return False\n            return True\n        except Exception:\n            return False\n```"
}