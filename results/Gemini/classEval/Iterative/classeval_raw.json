{
    "20": "```python\nfrom datetime import datetime\n\nclass Chat:\n    \"\"\"\n    A chat class with the functions of adding/removing users, sending messages, and retrieving messages.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the Chat with an empty dictionary to store users and their messages.\n        \"\"\"\n        self.users = {}\n\n    def add_user(self, username):\n        \"\"\"\n        Adds a new user to the Chat.\n\n        Args:\n            username (str): The user's name.\n\n        Returns:\n            bool: True if the user was added successfully, False if the user already exists.\n        \"\"\"\n        if not isinstance(username, str):\n            raise TypeError(\"Username must be a string.\")\n        if not username:\n            raise ValueError(\"Username cannot be empty.\")\n\n        if username in self.users:\n            return False\n        self.users[username] = []\n        return True\n\n    def remove_user(self, username):\n        \"\"\"\n        Removes a user from the Chat.\n\n        Args:\n            username (str): The user's name.\n\n        Returns:\n            bool: True if the user was removed successfully, False if the user does not exist.\n        \"\"\"\n        if not isinstance(username, str):\n            raise TypeError(\"Username must be a string.\")\n\n        if username in self.users:\n            del self.users[username]\n            return True\n        return False\n\n    def send_message(self, sender, receiver, message):\n        \"\"\"\n        Sends a message from one user to another.\n\n        Args:\n            sender (str): The sender's username.\n            receiver (str): The receiver's username.\n            message (str): The message content.\n\n        Returns:\n            bool: True if the message was sent successfully, False if either the sender or receiver does not exist.\n        \"\"\"\n        if not isinstance(sender, str) or not isinstance(receiver, str) or not isinstance(message, str):\n            raise TypeError(\"Sender, receiver, and message must be strings.\")\n        if not sender or not receiver or not message:\n            raise ValueError(\"Sender, receiver, and message cannot be empty.\")\n\n        if sender not in self.users or receiver not in self.users:\n            return False\n\n        timestamp = datetime.now().isoformat()  # Use ISO format for better compatibility\n        message_data = {\n            'sender': sender,\n            'receiver': receiver,\n            'message': message,\n            'timestamp': timestamp\n        }\n        self.users[receiver].append(message_data)\n        return True\n\n    def get_messages(self, username):\n        \"\"\"\n        Retrieves all messages for a specific user.\n\n        Args:\n            username (str): The user's name.\n\n        Returns:\n            list: A list of message dictionaries, each containing 'sender', 'receiver', 'message', and 'timestamp'.\n                  Returns an empty list if the user does not exist.\n        \"\"\"\n        if not isinstance(username, str):\n            raise TypeError(\"Username must be a string.\")\n\n        if username in self.users:\n            return self.users[username]\n        else:\n            return []\n```",
    "21": "```python\nfrom datetime import datetime, time\n\nclass Classroom:\n    \"\"\"\n    Represents a classroom with scheduling functionalities.\n    \"\"\"\n\n    def __init__(self, classroom_id: int):\n        \"\"\"\n        Initializes a Classroom object.\n\n        Args:\n            classroom_id: The unique identifier for the classroom.\n        \"\"\"\n        if not isinstance(classroom_id, int):\n            raise TypeError(\"classroom_id must be an integer.\")\n        if classroom_id <= 0:\n            raise ValueError(\"classroom_id must be a positive integer.\")\n\n        self.id = classroom_id\n        self.courses = []  # List of courses, each a dictionary\n\n    def add_course(self, course: dict):\n        \"\"\"\n        Adds a course to the classroom schedule.\n\n        Args:\n            course: A dictionary containing course information, including 'name', 'start_time', and 'end_time'.\n                'start_time' and 'end_time' should be strings in 'HH:MM' format.\n\n        Raises:\n            TypeError: If course is not a dictionary or if start/end times are not strings.\n            ValueError: If start/end times are not in the correct format or if the course already exists.\n        \"\"\"\n        if not isinstance(course, dict):\n            raise TypeError(\"course must be a dictionary.\")\n        if not all(key in course for key in ('name', 'start_time', 'end_time')):\n            raise ValueError(\"course dictionary must contain 'name', 'start_time', and 'end_time' keys.\")\n        if not isinstance(course['start_time'], str) or not isinstance(course['end_time'], str):\n            raise TypeError(\"start_time and end_time must be strings.\")\n\n        try:\n            datetime.strptime(course['start_time'], '%H:%M').time()\n            datetime.strptime(course['end_time'], '%H:%M').time()\n        except ValueError:\n            raise ValueError(\"start_time and end_time must be in 'HH:MM' format.\")\n\n        if course in self.courses:\n             raise ValueError(\"Course already exists in the classroom schedule.\")\n\n        self.courses.append(course)\n\n    def remove_course(self, course: dict):\n        \"\"\"\n        Removes a course from the classroom schedule.\n\n        Args:\n            course: A dictionary representing the course to remove. Must match an existing course exactly.\n\n        Raises:\n            TypeError: If course is not a dictionary.\n            ValueError: If the course does not exist in the classroom schedule.\n        \"\"\"\n        if not isinstance(course, dict):\n            raise TypeError(\"course must be a dictionary.\")\n\n        if course not in self.courses:\n            raise ValueError(\"Course not found in the classroom schedule.\")\n\n        self.courses.remove(course)\n\n    def is_free_at(self, check_time: str) -> bool:\n        \"\"\"\n        Checks if the classroom is free at a given time.\n\n        Args:\n            check_time: A string representing the time to check in 'HH:MM' format.\n\n        Returns:\n            True if the classroom is free at the given time, False otherwise.\n\n        Raises:\n            TypeError: If check_time is not a string.\n            ValueError: If check_time is not in the correct format.\n        \"\"\"\n        if not isinstance(check_time, str):\n            raise TypeError(\"check_time must be a string.\")\n\n        try:\n            check_time_obj = datetime.strptime(check_time, '%H:%M').time()\n        except ValueError:\n            raise ValueError(\"check_time must be in 'HH:MM' format.\")\n\n        for course in self.courses:\n            start_time_obj = datetime.strptime(course['start_time'], '%H:%M').time()\n            end_time_obj = datetime.strptime(course['end_time'], '%H:%M').time()\n\n            if start_time_obj <= check_time_obj < end_time_obj:\n                return False  # Classroom is occupied\n\n        return True  # Classroom is free\n\n    def check_course_conflict(self, new_course: dict) -> bool:\n        \"\"\"\n        Checks if a new course conflicts with any existing courses in the classroom.\n\n        Args:\n            new_course: A dictionary representing the new course to check for conflicts. Must contain 'start_time' and 'end_time'.\n\n        Returns:\n            True if the new course does not conflict with any existing courses, False otherwise.\n\n        Raises:\n            TypeError: If new_course is not a dictionary or if start/end times are not strings.\n            ValueError: If start/end times are not in the correct format.\n        \"\"\"\n        if not isinstance(new_course, dict):\n            raise TypeError(\"new_course must be a dictionary.\")\n        if not all(key in new_course for key in ('start_time', 'end_time')):\n            raise ValueError(\"new_course dictionary must contain 'start_time' and 'end_time' keys.\")\n\n        if not isinstance(new_course['start_time'], str) or not isinstance(new_course['end_time'], str):\n            raise TypeError(\"start_time and end_time must be strings.\")\n\n        try:\n            new_start_time_obj = datetime.strptime(new_course['start_time'], '%H:%M').time()\n            new_end_time_obj = datetime.strptime(new_course['end_time'], '%H:%M').time()\n        except ValueError:\n            raise ValueError(\"start_time and end_time must be in 'HH:MM' format.\")\n\n        for course in self.courses:\n            start_time_obj = datetime.strptime(course['start_time'], '%H:%M').time()\n            end_time_obj = datetime.strptime(course['end_time'], '%H:%M').time()\n\n            if not (new_end_time_obj <= start_time_obj or new_start_time_obj >= end_time_obj):\n                return False  # Conflict detected\n\n        return True  # No conflict\n```",
    "22": "```python\nclass ClassRegistrationSystem:\n    \"\"\"\n    A class for managing student registration and class enrollment.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the registration system.\n        - `students`: A dictionary where keys are student names and values are dictionaries containing student information (e.g., major).\n        - `class_rosters`: A dictionary where keys are class names and values are sets of student names enrolled in that class.\n        \"\"\"\n        self.students = {}  # {student_name: {major: str, ...}}\n        self.class_rosters = {}  # {class_name: set(student_names)}\n\n    def register_student(self, student_name, major):\n        \"\"\"\n        Registers a student in the system.\n\n        Args:\n            student_name (str): The name of the student.\n            major (str): The student's major.\n\n        Returns:\n            bool: True if the student was successfully registered, False if the student already exists.\n        \"\"\"\n        if student_name in self.students:\n            return False  # Student already exists\n        self.students[student_name] = {\"major\": major}\n        return True\n\n    def register_class(self, student_name, class_name):\n        \"\"\"\n        Registers a student for a class.\n\n        Args:\n            student_name (str): The name of the student.\n            class_name (str): The name of the class.\n\n        Returns:\n            bool: True if the student was successfully registered for the class, False otherwise (e.g., student doesn't exist).\n        \"\"\"\n        if student_name not in self.students:\n            return False  # Student does not exist\n\n        if class_name not in self.class_rosters:\n            self.class_rosters[class_name] = set()\n\n        self.class_rosters[class_name].add(student_name)\n        return True\n\n    def get_students_by_major(self, major):\n        \"\"\"\n        Retrieves a list of student names for a given major.\n\n        Args:\n            major (str): The major to search for.\n\n        Returns:\n            list: A list of student names belonging to the specified major.\n        \"\"\"\n        return [\n            student_name\n            for student_name, student_info in self.students.items()\n            if student_info[\"major\"] == major\n        ]\n\n    def get_all_majors(self):\n        \"\"\"\n        Retrieves a list of all unique majors in the system.\n\n        Returns:\n            list: A list of unique majors.\n        \"\"\"\n        majors = set()\n        for student_info in self.students.values():\n            majors.add(student_info[\"major\"])\n        return list(majors)\n\n    def get_most_popular_class_in_major(self, major):\n        \"\"\"\n        Finds the most popular class among students of a specific major.\n\n        Args:\n            major (str): The major to consider.\n\n        Returns:\n            str: The name of the most popular class, or None if no students in the major are registered for any classes.\n        \"\"\"\n        class_counts = {}\n        for class_name, student_set in self.class_rosters.items():\n            for student_name in student_set:\n                if (\n                    student_name in self.students\n                    and self.students[student_name][\"major\"] == major\n                ):\n                    class_counts[class_name] = class_counts.get(class_name, 0) + 1\n\n        if not class_counts:\n            return None  # No students in the major are registered for classes\n\n        most_popular_class = max(class_counts, key=class_counts.get)\n        return most_popular_class\n```",
    "23": "```python\nfrom typing import List\nimport math\n\nclass CombinationCalculator:\n    \"\"\"\n    This class provides methods to calculate combinations.\n    \"\"\"\n\n    def __init__(self, data: List[str]):\n        \"\"\"\n        Initializes the CombinationCalculator with a list of data.\n        \"\"\"\n        if not isinstance(data, list):\n            raise TypeError(\"Data must be a list.\")\n        if not all(isinstance(item, str) for item in data):\n            raise TypeError(\"All elements in data must be strings.\")\n        self.data = data\n\n    @staticmethod\n    def count(n: int, k: int) -> int:\n        \"\"\"\n        Calculates the number of combinations (n choose k).\n        \"\"\"\n        if not isinstance(n, int) or not isinstance(k, int):\n            raise TypeError(\"n and k must be integers.\")\n        if n < 0 or k < 0:\n            raise ValueError(\"n and k must be non-negative.\")\n        if k > n:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        if k > n // 2:\n            k = n - k\n\n        result = 1\n        for i in range(k):\n            result = result * (n - i) // (i + 1)\n        return result\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"\n        Calculates the total number of combinations (excluding the empty set).\n        \"\"\"\n        if not isinstance(n, int):\n            raise TypeError(\"n must be an integer.\")\n        if n < 0:\n            raise ValueError(\"n must be non-negative.\")\n\n        if n > 62:\n            return float('inf')\n        return (1 << n) - 1\n\n    def select(self, k: int) -> List[List[str]]:\n        \"\"\"\n        Generates all combinations of k elements from the data.\n        \"\"\"\n        if not isinstance(k, int):\n            raise TypeError(\"k must be an integer.\")\n        if k <= 0 or k > len(self.data):\n            return []\n\n        combinations: List[List[str]] = []\n        self._generate_combinations(0, k, [], combinations)\n        return combinations\n\n    def select_all(self) -> List[List[str]]:\n        \"\"\"\n        Generates all possible combinations (excluding the empty set).\n        \"\"\"\n        all_combinations: List[List[str]] = []\n        for k in range(1, len(self.data) + 1):\n            all_combinations.extend(self.select(k))\n        return all_combinations\n\n    def _generate_combinations(self, start_index: int, k: int, current_combination: List[str], all_combinations: List[List[str]]):\n        \"\"\"\n        Recursive helper function to generate combinations.\n        \"\"\"\n        if len(current_combination) == k:\n            all_combinations.append(current_combination.copy())  # Append a copy\n            return\n\n        for i in range(start_index, len(self.data)):\n            current_combination.append(self.data[i])\n            self._generate_combinations(i + 1, k, current_combination, all_combinations)\n            current_combination.pop()  # Backtrack\n```",
    "24": "```python\nclass ComplexCalculator:\n    \"\"\"\n    This class implements addition, subtraction, multiplication, and division operations for complex numbers.\n    \"\"\"\n\n    def __init__(self):\n        pass  # No instance-specific initialization needed\n\n    @staticmethod\n    def add(c1: complex, c2: complex) -> complex:\n        \"\"\"\n        Adds two complex numbers.\n\n        Args:\n            c1: The first complex number.\n            c2: The second complex number.\n\n        Returns:\n            The sum of the two complex numbers.\n\n        Examples:\n            >>> ComplexCalculator.add(1+2j, 3+4j)\n            (4+6j)\n        \"\"\"\n        return c1 + c2\n\n    @staticmethod\n    def subtract(c1: complex, c2: complex) -> complex:\n        \"\"\"\n        Subtracts two complex numbers.\n\n        Args:\n            c1: The first complex number.\n            c2: The second complex number.\n\n        Returns:\n            The difference of the two complex numbers.\n\n        Examples:\n            >>> ComplexCalculator.subtract(1+2j, 3+4j)\n            (-2-2j)\n        \"\"\"\n        return c1 - c2\n\n    @staticmethod\n    def multiply(c1: complex, c2: complex) -> complex:\n        \"\"\"\n        Multiplies two complex numbers.\n\n        Args:\n            c1: The first complex number.\n            c2: The second complex number.\n\n        Returns:\n            The product of the two complex numbers.\n\n        Examples:\n            >>> ComplexCalculator.multiply(1+2j, 3+4j)\n            (-5+10j)\n        \"\"\"\n        return c1 * c2\n\n    @staticmethod\n    def divide(c1: complex, c2: complex) -> complex:\n        \"\"\"\n        Divides two complex numbers.\n\n        Args:\n            c1: The first complex number.\n            c2: The second complex number.\n\n        Returns:\n            The quotient of the two complex numbers.\n\n        Raises:\n            ZeroDivisionError: If c2 is zero.  For robustness.\n\n        Examples:\n            >>> ComplexCalculator.divide(1+2j, 3+4j)\n            (0.44+0.08j)\n        \"\"\"\n        if c2 == 0:\n            raise ZeroDivisionError(\"Cannot divide by zero\")\n        return c1 / c2\n```",
    "25": "```python\nimport json\nimport os\nfrom typing import Dict, Optional, Union\n\nclass CookiesUtil:\n    \"\"\"\n    Utility class for managing and manipulating cookies, including methods for retrieving, saving, and loading cookie data.\n    \"\"\"\n\n    def __init__(self, cookies_file: str):\n        \"\"\"\n        Initializes the CookiesUtil with the specified cookies file.\n\n        Args:\n            cookies_file: The path to the cookies file (JSON format).\n        \"\"\"\n        self.cookies_file = cookies_file\n        self.cookies: Dict[str, str] = {}  # Initialize cookies as an empty dictionary\n\n    def get_cookies(self, response: Dict[str, Union[str, Dict[str, str]]]) -> None:\n        \"\"\"\n        Extracts cookies from the response and saves them to the cookies file.\n\n        Args:\n            response: The response dictionary, expected to contain a 'cookies' key.\n        \"\"\"\n        if 'cookies' in response and isinstance(response['cookies'], dict):\n            self.cookies = response['cookies']\n            self.save_cookies()  # Changed to public method\n        else:\n            self.cookies = {}\n\n    def load_cookies(self) -> Dict[str, str]:\n        \"\"\"\n        Loads cookies from the cookies file.\n\n        Returns:\n            A dictionary containing the loaded cookies.  Returns an empty dictionary if the file does not exist or contains invalid JSON.\n        \"\"\"\n        try:\n            if not os.path.exists(self.cookies_file):\n                return {}\n\n            with open(self.cookies_file, 'r') as f:\n                self.cookies = json.load(f)\n                if not isinstance(self.cookies, dict):  # Check if loaded data is a dictionary\n                    self.cookies = {}  # Reset if not a dictionary\n        except (FileNotFoundError, json.JSONDecodeError):\n            self.cookies = {}\n        return self.cookies\n\n    def save_cookies(self) -> bool:\n        \"\"\"\n        Saves the current cookies to the cookies file.\n\n        Returns:\n            True if the cookies were saved successfully, False otherwise.\n        \"\"\"\n        try:\n            with open(self.cookies_file, 'w') as f:\n                json.dump(self.cookies, f, indent=4)  # Added indent for readability\n            return True\n        except Exception as e:\n            print(f\"Error saving cookies: {e}\")\n            return False\n\nif __name__ == '__main__':\n    # Example usage\n    cookies_file = 'my_cookies.json'\n    cookies_util = CookiesUtil(cookies_file)\n\n    # Load cookies (if they exist)\n    loaded_cookies = cookies_util.load_cookies()\n    print(f\"Loaded cookies: {loaded_cookies}\")\n\n    # Simulate a response with cookies\n    response_data = {'status': 'success', 'cookies': {'session_id': '12345', 'user_id': 'abcde'}}\n    cookies_util.get_cookies(response_data)\n    print(f\"Current cookies after get_cookies: {cookies_util.cookies}\")\n\n    # Save the cookies\n    if cookies_util.save_cookies():\n        print(\"Cookies saved successfully.\")\n    else:\n        print(\"Failed to save cookies.\")\n\n    # Load cookies again to verify\n    loaded_cookies_again = cookies_util.load_cookies()\n    print(f\"Loaded cookies after saving: {loaded_cookies_again}\")\n\n    # Clean up: Remove the cookies file\n    try:\n        os.remove(cookies_file)\n        print(f\"Removed {cookies_file}\")\n    except FileNotFoundError:\n        pass\n```",
    "26": "```python\nimport csv\n\nclass CSVProcessor:\n    \"\"\"\n    This class processes CSV files, including reading, writing, and specific operations,\n    saving the results to a new CSV file.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_csv(self, file_name):\n        \"\"\"\n        Reads a CSV file and returns the header and data.\n\n        Args:\n            file_name (str): The name of the CSV file.\n\n        Returns:\n            tuple: A tuple containing the header (list) and data (list of lists).\n                   Returns (None, None) if an error occurs.\n        \"\"\"\n        try:\n            with open(file_name, 'r', newline='') as csvfile:\n                reader = csv.reader(csvfile)\n                header = next(reader)\n                data = list(reader)  # Read all rows into a list\n                return header, data\n        except FileNotFoundError:\n            print(f\"Error: File '{file_name}' not found.\")\n            return None, None\n        except Exception as e:\n            print(f\"An error occurred while reading {file_name}: {e}\")\n            return None, None\n\n    def write_csv(self, data, file_name):\n        \"\"\"\n        Writes data to a CSV file.\n\n        Args:\n            data (list of lists): The data to write, including the header.\n            file_name (str): The name of the CSV file to write to.\n\n        Returns:\n            bool: True if the write was successful, False otherwise.\n        \"\"\"\n        try:\n            with open(file_name, 'w', newline='') as csvfile:\n                writer = csv.writer(csvfile)\n                writer.writerows(data)\n            return True\n        except Exception as e:\n            print(f\"An error occurred while writing to {file_name}: {e}\")\n            return False\n\n    def process_csv_data(self, column_index, input_file_name, output_file_name=None):\n        \"\"\"\n        Reads a CSV file, extracts a specific column, capitalizes the data,\n        and writes the processed data to a new CSV file.\n\n        Args:\n            column_index (int): The index of the column to process (0-based).\n            input_file_name (str): The name of the input CSV file.\n            output_file_name (str, optional): The name of the output CSV file.\n                                               If None, defaults to input_file_name_processed.csv\n\n        Returns:\n            bool: True if the processing and writing were successful, False otherwise.\n        \"\"\"\n        header, data = self.read_csv(input_file_name)\n\n        if header is None or data is None:\n            return False\n\n        processed_data = []\n        for row in data:\n            try:\n                processed_data.append([row[column_index].upper()])  # Capitalize the value\n            except IndexError:\n                print(f\"Warning: Column index {column_index} out of bounds for row: {row}\")\n                return False #Or continue if you want to skip the row: continue\n            except Exception as e:\n                print(f\"An error occurred during processing: {e}\")\n                return False\n\n\n        if output_file_name is None:\n            output_file_name = input_file_name.replace(\".csv\", \"_processed.csv\") #more robust filename generation\n\n        # Create the data structure needed for write_csv: header + processed data\n        output_data = [header]\n        for row in processed_data:\n            output_data.append(row)\n\n        # Write header and processed data to the output file\n        if self.write_csv(output_data, output_file_name):\n            return True\n        else:\n            return False\n\nif __name__ == '__main__':\n    # Example usage (create a dummy CSV for testing)\n    test_data = [['a', 'b', 'c', 'd'], ['hElLo', 'YoU', 'ME', 'LoW'], ['another', 'row', 'data', 'here']]\n    csv_processor = CSVProcessor()\n    csv_processor.write_csv(test_data, 'read_test.csv')\n\n    # Test the process_csv_data function\n    if csv_processor.process_csv_data(0, 'read_test.csv'):\n        print(\"Processing successful!\")\n    else:\n        print(\"Processing failed.\")\n\n    # Verify the output\n    title, data = csv_processor.read_csv('read_test_processed.csv')\n    if title and data:\n        print(f\"Title: {title}\")\n        print(f\"Data: {data}\") # Expected output: [['HELLO'], ['ANOTHER']]\n    else:\n        print(\"Could not verify the output due to read error.\")\n\n    # Test write_csv function\n    if csv_processor.write_csv([['a', 'b', 'c', 'd'], ['1', '2', '3', '4']], 'write_test.csv'):\n        print(\"Write successful!\")\n    else:\n        print(\"Write failed.\")\n```",
    "27": "```python\nclass CurrencyConverter:\n    \"\"\"\n    This is a class for currency conversion, which supports to convert amounts between different currencies, retrieve supported currencies, add new currency rates, and update existing currency rates.\n    \"\"\"\n\n    def __init__(self, rates=None):\n        \"\"\"\n        Initialize the exchange rate of the US dollar against various currencies\n        \"\"\"\n        if rates is None:\n            self.rates = {\n                'USD': 1.0,\n                'EUR': 0.85,\n                'GBP': 0.72,\n                'JPY': 110.15,\n                'CAD': 1.23,\n                'AUD': 1.34,\n                'CNY': 6.40,\n            }\n        else:\n            self.rates = rates\n\n    def convert(self, amount, from_currency, to_currency):\n        \"\"\"\n        Convert the value of a given currency to another currency type\n        :param amount: float, The value of a given currency\n        :param from_currency: string, source currency type\n        :param to_currency: string, target currency type\n        :return: float, value converted to another currency type\n        :raises ValueError: if from_currency or to_currency is not supported.\n        \"\"\"\n        if not isinstance(amount, (int, float)):\n            raise TypeError(\"Amount must be a number (int or float)\")\n\n        if not isinstance(from_currency, str) or not isinstance(to_currency, str):\n            raise TypeError(\"Currency codes must be strings\")\n\n        from_currency = from_currency.upper()\n        to_currency = to_currency.upper()\n\n        if from_currency not in self.rates:\n            raise ValueError(f\"Currency '{from_currency}' not supported.\")\n        if to_currency not in self.rates:\n            raise ValueError(f\"Currency '{to_currency}' not supported.\")\n\n        usd_amount = amount / self.rates[from_currency]\n        converted_amount = usd_amount * self.rates[to_currency]\n        return round(converted_amount, 2)\n\n    def get_supported_currencies(self):\n        \"\"\"\n        Returns a list of supported currency types\n        :return: list, All supported currency types\n        \"\"\"\n        return list(self.rates.keys())\n\n    def add_currency_rate(self, currency, rate):\n        \"\"\"\n        Add a new supported currency type\n        :param currency: string, currency type to be added\n        :param rate: float, exchange rate for this type of currency\n        :raises TypeError: if currency is not a string or rate is not a number.\n        :raises ValueError: if currency already exists.\n        \"\"\"\n\n        if not isinstance(currency, str):\n            raise TypeError(\"Currency must be a string.\")\n        if not isinstance(rate, (int, float)):\n            raise TypeError(\"Rate must be a number (int or float).\")\n\n        currency = currency.upper()\n\n        if currency in self.rates:\n            raise ValueError(f\"Currency '{currency}' already exists.\")\n\n        self.rates[currency] = rate\n\n    def update_currency_rate(self, currency, new_rate):\n        \"\"\"\n        Update the exchange rate for a certain currency\n        :param currency: string\n        :param new_rate: float\n        :raises TypeError: if currency is not a string or new_rate is not a number.\n        :raises ValueError: if currency does not exist.\n        \"\"\"\n        if not isinstance(currency, str):\n            raise TypeError(\"Currency must be a string.\")\n        if not isinstance(new_rate, (int, float)):\n            raise TypeError(\"New rate must be a number (int or float).\")\n\n        currency = currency.upper()\n\n        if currency not in self.rates:\n            raise ValueError(f\"Currency '{currency}' not found.\")\n\n        self.rates[currency] = new_rate\n```",
    "28": "```python\nimport sqlite3\nimport pandas as pd\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\nclass DatabaseProcessor:\n    \"\"\"\n    This is a class for processing a database, supporting to create tables, insert data into the database, search for data based on name, and delete data from the database.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        self.database_name = database_name\n        self.connection = None  # Initialize connection attribute\n\n    def _connect(self):\n        \"\"\"\n        Establish a database connection.\n        \"\"\"\n        try:\n            self.connection = sqlite3.connect(self.database_name)\n            return self.connection.cursor()\n        except sqlite3.Error as e:\n            logging.error(f\"Database connection error: {e}\")\n            raise  # Re-raise the exception to be handled by the calling function\n\n    def _close(self):\n        \"\"\"\n        Close the database connection.\n        \"\"\"\n        if self.connection:\n            try:\n                self.connection.close()\n                self.connection = None\n            except sqlite3.Error as e:\n                logging.error(f\"Database closing error: {e}\")\n\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table.\n        :param key2: str, the name of the second column in the table.\n        \"\"\"\n        try:\n            cursor = self._connect()\n            cursor.execute(f'''\n                CREATE TABLE IF NOT EXISTS {table_name} (\n                    id INTEGER PRIMARY KEY,\n                    {key1} TEXT,\n                    {key2} INTEGER\n                )\n            ''')\n            self.connection.commit()\n            logging.info(f\"Table '{table_name}' created successfully.\")\n        except sqlite3.Error as e:\n            logging.error(f\"Error creating table '{table_name}': {e}\")\n            raise\n        finally:\n            self._close()\n\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        \"\"\"\n        try:\n            cursor = self._connect()\n            for row in data:\n                keys = ', '.join(row.keys())\n                placeholders = ', '.join(['?'] * len(row))\n                sql = f'''\n                    INSERT INTO {table_name} ({keys})\n                    VALUES ({placeholders})\n                '''\n                cursor.execute(sql, tuple(row.values()))\n            self.connection.commit()\n            logging.info(f\"Data inserted successfully into table '{table_name}'.\")\n        except sqlite3.Error as e:\n            logging.error(f\"Error inserting data into table '{table_name}': {e}\")\n            raise\n        finally:\n            self._close()\n\n\n    def search_database(self, table_name, search_column, search_value):\n        \"\"\"\n        Search the specified table in the database for rows with a matching value in the specified column.\n        :param table_name: str, the name of the table to search.\n        :param search_column: str, the name of the column to search in.\n        :param search_value: any, the value to search for.\n        :return: list, a list of tuples representing the rows with matching values, if any;\n                    otherwise, returns an empty list.\n        \"\"\"\n        try:\n            cursor = self._connect()\n            sql = f'''\n                SELECT * FROM {table_name} WHERE {search_column} = ?\n            '''\n            cursor.execute(sql, (search_value,))\n            result = cursor.fetchall()\n            logging.info(f\"Search in table '{table_name}' for column '{search_column}' with value '{search_value}' successful.\")\n            return result if result else []  # Return empty list instead of None\n        except sqlite3.Error as e:\n            logging.error(f\"Error searching in table '{table_name}': {e}\")\n            raise\n        finally:\n            self._close()\n\n\n    def delete_from_database(self, table_name, delete_column, delete_value):\n        \"\"\"\n        Delete rows from the specified table in the database where the specified column matches the given value.\n        :param table_name: str, the name of the table to delete rows from.\n        :param delete_column: str, the column to check for the value to delete.\n        :param delete_value: any, the value to match for deletion.\n        \"\"\"\n        try:\n            cursor = self._connect()\n            sql = f'''\n                DELETE FROM {table_name} WHERE {delete_column} = ?\n            '''\n            cursor.execute(sql, (delete_value,))\n            self.connection.commit()\n            logging.info(f\"Rows deleted from table '{table_name}' where column '{delete_column}' equals '{delete_value}'.\")\n        except sqlite3.Error as e:\n            logging.error(f\"Error deleting from table '{table_name}': {e}\")\n            raise\n        finally:\n            self._close()\n\n    def read_table_to_dataframe(self, table_name):\n        \"\"\"\n        Reads the entire table into a Pandas DataFrame.\n\n        Args:\n            table_name (str): The name of the table to read.\n\n        Returns:\n            pandas.DataFrame: A DataFrame containing the table data, or an empty DataFrame if an error occurs.\n        \"\"\"\n        try:\n            conn = sqlite3.connect(self.database_name)\n            df = pd.read_sql_query(f\"SELECT * FROM {table_name}\", conn)\n            conn.close()\n            logging.info(f\"Table '{table_name}' read into DataFrame successfully.\")\n            return df\n        except sqlite3.Error as e:\n            logging.error(f\"Error reading table '{table_name}' into DataFrame: {e}\")\n            return pd.DataFrame()  # Return an empty DataFrame in case of error\n```",
    "29": "```python\nfrom collections import Counter\nfrom typing import List\n\nclass DataStatistics:\n    \"\"\"\n    This is a class for performing data statistics, supporting to calculate the mean, median, and mode of a given data set.\n    \"\"\"\n\n    def mean(self, data: List[float]) -> float:\n        \"\"\"\n        Calculate the average value of a group of data, accurate to two digits after the Decimal separator\n        :param data: list, data list\n        :return: float, the mean value or None if data is empty.\n        >>> ds = DataStatistics()\n        >>> ds.mean([1, 2, 3, 4, 5])\n        3.0\n        \"\"\"\n        if not data:\n            return 0.0\n        return round(sum(data) / len(data), 2)\n\n    def median(self, data: List[float]) -> float:\n        \"\"\"\n        Calculate the median of a group of data, accurate to two digits after the Decimal separator\n        :param data: list, data list\n        :return: float, the median value, or None if data is empty.\n        >>> ds = DataStatistics()\n        >>> ds.median([2, 5, 1, 3, 4])\n        3.0\n        \"\"\"\n        if not data:\n            return 0.0\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        if n % 2 == 0:\n            median = (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2\n        else:\n            median = sorted_data[n // 2]\n        return round(median, 2)\n\n    def mode(self, data: List[float]) -> List[float]:\n        \"\"\"\n        Calculate the mode of a set of data\n        :param data: list, data list\n        :return: list, the mode(s).  Returns an empty list if data is empty.\n        >>> ds = DataStatistics()\n        >>> ds.mode([2, 2, 3, 3, 4])\n        [2, 3]\n        \"\"\"\n        if not data:\n            return []\n\n        counts = Counter(data)\n        max_count = max(counts.values())\n        modes = [key for key, value in counts.items() if value == max_count]\n        modes.sort()\n        return modes\n```",
    "30": "```python\nimport numpy as np\n\nclass DataStatistics2:\n    \"\"\"\n    This is a class for performing data statistics, supporting to get the sum, minimum, maximum, variance, standard deviation, and correlation of a given dataset.\n    \"\"\"\n\n    def __init__(self, data):\n        \"\"\"\n        Initialize Data List\n        :param data:list\n        Raises:\n            TypeError: if data is not a list or numpy array.\n            ValueError: if data is empty.\n        \"\"\"\n        if not isinstance(data, (list, np.ndarray)):\n            raise TypeError(\"Data must be a list or numpy array.\")\n        if not data:\n            raise ValueError(\"Data cannot be empty.\")\n\n        self.data = np.array(data)\n\n    def get_sum(self):\n        \"\"\"\n        Calculate the sum of data\n        :return: float\n        \"\"\"\n        return float(np.sum(self.data))\n\n    def get_min(self):\n        \"\"\"\n        Calculate the minimum value in the data\n        :return: float\n        \"\"\"\n        return float(np.min(self.data))\n\n    def get_max(self):\n        \"\"\"\n        Calculate the maximum value in the data\n        :return: float\n        \"\"\"\n        return float(np.max(self.data))\n\n    def get_variance(self):\n        \"\"\"\n        Calculate variance\n        :return: float\n        \"\"\"\n        return float(np.var(self.data))\n\n    def get_std_deviation(self):\n        \"\"\"\n        Calculate standard deviation\n        :return: float\n        \"\"\"\n        return float(np.std(self.data))\n\n    def get_correlation(self):\n        \"\"\"\n        Calculate correlation.  Returns 1.0 if the data has only one element.\n        :return: float\n        \"\"\"\n        if len(self.data) <= 1:\n            return 1.0\n        return float(np.corrcoef(self.data, self.data)[0, 1])\n```",
    "31": "```python\nimport math\nfrom typing import List, Union\n\nclass DataStatistics4:\n    \"\"\"\n    This is a class that performs advanced mathematical calculations and statistics, including correlation coefficient, skewness, kurtosis, and probability density function (PDF) for a normal distribution.\n    \"\"\"\n\n    @staticmethod\n    def correlation_coefficient(data1: List[Union[int, float]], data2: List[Union[int, float]]) -> float:\n        \"\"\"\n        Calculate the Pearson correlation coefficient of two sets of data.\n\n        Args:\n            data1: The first set of data, a list of numerical values.\n            data2: The second set of data, a list of numerical values.\n\n        Returns:\n            The Pearson correlation coefficient, a float between -1 and 1.  Returns NaN if either input list is empty or if the standard deviation of either list is zero.\n\n        Raises:\n            ValueError: If the data sets do not have the same length.\n\n        Examples:\n            >>> DataStatistics4.correlation_coefficient([1, 2, 3], [4, 5, 6])\n            1.0\n            >>> DataStatistics4.correlation_coefficient([1, 2, 3], [6, 5, 4])\n            -1.0\n            >>> DataStatistics4.correlation_coefficient([1, 2, 3], [1, 2, 3])\n            1.0\n            >>> DataStatistics4.correlation_coefficient([1, 2, 3], [3, 2, 1])\n            -1.0\n        \"\"\"\n        if not data1 or not data2:\n            return float('NaN')\n\n        n = len(data1)\n        if n != len(data2):\n            raise ValueError(\"Data sets must have the same length\")\n\n        mean1 = sum(data1) / n\n        mean2 = sum(data2) / n\n\n        numerator = sum((x - mean1) * (y - mean2) for x, y in zip(data1, data2))\n        std_dev1 = math.sqrt(sum((x - mean1)**2 for x in data1))\n        std_dev2 = math.sqrt(sum((y - mean2)**2 for y in data2))\n\n        if std_dev1 == 0 or std_dev2 == 0:\n            return float('NaN')  # Handle cases where standard deviation is zero\n\n        return numerator / (std_dev1 * std_dev2)\n\n\n    @staticmethod\n    def skewness(data: List[Union[int, float]]) -> float:\n        \"\"\"\n        Calculate the skewness of a set of data.\n\n        Args:\n            data: The input data list, a list of numerical values.\n\n        Returns:\n            The skewness, a float. Returns NaN if the input list is empty or if the standard deviation is zero.\n\n        Examples:\n            >>> DataStatistics4.skewness([1, 2, 5])\n            1.0453591785333538\n            >>> DataStatistics4.skewness([1, 2, 3, 4, 5])\n            0.0\n            >>> DataStatistics4.skewness([1, 1, 1])\n            0.0\n        \"\"\"\n        n = len(data)\n        if not data:\n            return float('NaN')\n\n        mean = sum(data) / n\n        std_dev = math.sqrt(sum((x - mean)**2 for x in data) / (n - 1)) if n > 1 else 0.0\n\n\n        if std_dev == 0:\n            return float('NaN')  # Avoid division by zero\n\n        sum_cubed_deviations = sum((x - mean)**3 for x in data)\n        skewness = sum_cubed_deviations / ((n - 1) * (std_dev**3)) if n > 1 else 0.0\n        return skewness\n\n    @staticmethod\n    def kurtosis(data: List[Union[int, float]]) -> float:\n        \"\"\"\n        Calculate the excess kurtosis of a set of data. Excess kurtosis is kurtosis - 3.\n\n        Args:\n            data: The input data list, a list of numerical values.\n\n        Returns:\n            The excess kurtosis, a float.  Returns NaN if the input list is empty or if the standard deviation is zero.\n\n        Examples:\n            >>> DataStatistics4.kurtosis([1, 20,100])\n            -1.268292682926829\n            >>> DataStatistics4.kurtosis([1, 2, 3, 4, 5])\n            -1.3\n            >>> DataStatistics4.kurtosis([1, 1, 1, 1, 1])\n            -3.0\n        \"\"\"\n        n = len(data)\n        if not data:\n            return float('NaN')\n\n        mean = sum(data) / n\n        std_dev = math.sqrt(sum((x - mean)**2 for x in data) / (n - 1)) if n > 1 else 0.0\n\n\n        if std_dev == 0:\n            return float('NaN')  # Avoid division by zero\n\n        sum_fourth_power_deviations = sum((x - mean)**4 for x in data)\n        kurtosis = sum_fourth_power_deviations / ((n - 1) * (std_dev**4)) - 3 if n > 1 else -3.0\n        return kurtosis\n\n    @staticmethod\n    def pdf(data: List[Union[int, float]], mu: float, sigma: float) -> List[float]:\n        \"\"\"\n        Calculate the probability density function (PDF) of a set of data under a normal distribution.\n\n        Args:\n            data: The input data list, a list of numerical values.\n            mu: The mean of the normal distribution, a float.\n            sigma: The standard deviation of the normal distribution, a float.\n\n        Returns:\n            A list of floats representing the probability density function (PDF) values for each data point.  Returns a list of NaN if sigma is zero.\n\n        Examples:\n            >>> DataStatistics4.pdf([1, 2, 3], 1, 1)\n            [0.3989422804014327, 0.24197072451914337, 0.05399096651318806]\n            >>> DataStatistics4.pdf([1, 2, 3], 0, 1)\n            [0.24197072451914337, 0.05399096651318806, 0.004431848411938007]\n        \"\"\"\n        if sigma == 0:\n            return [float('NaN')] * len(data)\n\n        pdf_values = []\n        for x in data:\n            exponent = -((x - mu)**2) / (2 * sigma**2)\n            coefficient = 1 / (sigma * math.sqrt(2 * math.pi))\n            pdf_values.append(coefficient * math.exp(exponent))\n        return pdf_values\n```",
    "32": "```python\nclass DecryptionUtils:\n    \"\"\"\n    This is a class that provides methods for decryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key=\"default_key\"):\n        \"\"\"\n        Initializes the decryption utility with a key.\n        :param key: The key to use for decryption, str. Defaults to \"default_key\" if None is provided.\n        \"\"\"\n        self.key = key\n\n    def caesar_decipher(self, ciphertext, shift):\n        \"\"\"\n        Deciphers the given ciphertext using the Caesar cipher.\n\n        Handles non-alphabetic characters and maintains case.\n\n        :param ciphertext: The ciphertext to decipher, str.\n        :param shift: The shift to use for decryption, int.\n        :return: The deciphered plaintext, str.\n        \"\"\"\n        if not isinstance(ciphertext, str):\n            raise TypeError(\"Ciphertext must be a string.\")\n        if not isinstance(shift, int):\n            raise TypeError(\"Shift must be an integer.\")\n\n        plaintext = \"\"\n        for char in ciphertext:\n            if 'a' <= char <= 'z':\n                plaintext += chr(((ord(char) - ord('a') - shift) % 26) + ord('a'))\n            elif 'A' <= char <= 'Z':\n                plaintext += chr(((ord(char) - ord('A') - shift) % 26) + ord('A'))\n            else:\n                plaintext += char\n        return plaintext\n\n    def vigenere_decipher(self, ciphertext):\n        \"\"\"\n        Deciphers the given ciphertext using the Vigenere cipher.\n\n        Handles non-alphabetic characters and maintains case.  Key is repeated as needed.\n\n        :param ciphertext: The ciphertext to decipher, str.\n        :return: The deciphered plaintext, str.\n        \"\"\"\n        if not isinstance(ciphertext, str):\n            raise TypeError(\"Ciphertext must be a string.\")\n        if not isinstance(self.key, str):\n            raise TypeError(\"Key must be a string.\")\n\n        plaintext = \"\"\n        key = self.key.lower()  # Ensure key is lowercase for consistency\n        key_length = len(key)\n        key_index = 0\n\n        for char in ciphertext:\n            if 'a' <= char <= 'z':\n                shift = ord(key[key_index % key_length]) - ord('a')\n                plaintext += chr(((ord(char) - ord('a') - shift) % 26) + ord('a'))\n                key_index += 1\n            elif 'A' <= char <= 'Z':\n                shift = ord(key[key_index % key_length]) - ord('a')\n                plaintext += chr(((ord(char) - ord('A') - shift) % 26) + ord('A'))\n                key_index += 1\n            else:\n                plaintext += char\n        return plaintext\n\n    def rail_fence_decipher(self, encrypted_text, rails):\n        \"\"\"\n        Deciphers the given ciphertext using the Rail Fence cipher.\n\n        Handles invalid rail values.\n\n        :param encrypted_text: The ciphertext to decipher, str.\n        :param rails: The number of rails to use for decryption, int.\n        :return: The deciphered plaintext, str.\n        \"\"\"\n        if not isinstance(encrypted_text, str):\n            raise TypeError(\"Encrypted text must be a string.\")\n        if not isinstance(rails, int):\n            raise TypeError(\"Rails must be an integer.\")\n        if rails <= 0:\n            raise ValueError(\"Rails must be a positive integer.\")\n        if rails >= len(encrypted_text):\n            return encrypted_text # If rails >= length, the ciphertext is the plaintext\n\n        rail = [['' for _ in range(len(encrypted_text))] for _ in range(rails)]\n\n        # Mark the positions where characters will be placed\n        row = 0\n        direction = 1  # 1 for down, -1 for up\n        for col in range(len(encrypted_text)):\n            rail[row][col] = '*'\n            row += direction\n\n            if row == rails - 1:\n                direction = -1\n            elif row == 0:\n                direction = 1\n\n        # Fill the rail matrix with the encrypted text\n        index = 0\n        for i in range(rails):\n            for j in range(len(encrypted_text)):\n                if rail[i][j] == '*':\n                    rail[i][j] = encrypted_text[index]\n                    index += 1\n\n        # Read the rail matrix in a zig-zag manner to get the plaintext\n        plaintext = \"\"\n        row = 0\n        direction = 1\n        for col in range(len(encrypted_text)):\n            plaintext += rail[row][col]\n            row += direction\n\n            if row == rails - 1:\n                direction = -1\n            elif row == 0:\n                direction = 1\n\n        return plaintext\n```",
    "33": "```python\nclass DiscountStrategy:\n    \"\"\"\n    This is a class that allows to use different discount strategy based on shopping credit or shopping cart in supermarket.\n    \"\"\"\n\n    def __init__(self, customer, cart, promotion=None):\n        \"\"\"\n        Initialize the DiscountStrategy with customer information, a cart of items, and an optional promotion.\n        :param customer: dict, customer information\n        :param cart: list of dicts, a cart of items with details\n        :param promotion: function, optional promotion applied to the order\n        \"\"\"\n        self.customer = customer\n        self.cart = cart\n        self.promotion = promotion\n        self._total = self.calculate_total()\n\n    def calculate_total(self):\n        \"\"\"\n        Calculate the total cost of items in the cart.\n        :return: float, total cost of items\n        \"\"\"\n        total = sum(item['quantity'] * item['price'] for item in self.cart)\n        return total\n\n    def due(self):\n        \"\"\"\n        Calculate the final amount to be paid after applying the discount.\n        :return: float, final amount to be paid\n        \"\"\"\n        discount = 0\n        if self.promotion:\n            discount = self.promotion(self)\n        return self._total - discount\n\n    @staticmethod\n    def fidelity_promo(order):\n        \"\"\"\n        Calculate the discount based on the fidelity points of the customer.\n        Customers with over 1000 points can enjoy a 5% discount on the entire order.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        \"\"\"\n        if order.customer.get('fidelity', 0) >= 1000:\n            return order._total * 0.05\n        return 0.0\n\n    @staticmethod\n    def bulk_item_promo(order):\n        \"\"\"\n        Calculate the discount based on bulk item quantity in the order.\n        In the same order, if the quantity of a single item reaches 20 or more, each item will enjoy a 10% discount.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        \"\"\"\n        discount = 0\n        for item in order.cart:\n            if item['quantity'] >= 20:\n                discount += item['quantity'] * item['price'] * 0.1\n        return discount\n\n    @staticmethod\n    def large_order_promo(order):\n        \"\"\"\n        Calculate the discount based on the number of different products in the order.\n        If the quantity of different products in the order reaches 10 or more, the entire order will enjoy a 7% discount.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        \"\"\"\n        if len(order.cart) >= 10:\n            return order._total * 0.07\n        return 0.0\n\n\nif __name__ == '__main__':\n    # Example Usage\n    customer = {'name': 'John Doe', 'fidelity': 1200}\n    cart = [{'product': 'product1', 'quantity': 14, 'price': 23.5},\n            {'product': 'product2', 'quantity': 25, 'price': 10.0}]\n\n    # Fidelity Promo\n    order1 = DiscountStrategy(customer, cart, DiscountStrategy.fidelity_promo)\n    print(f\"Total with Fidelity Promo: {order1.due()}\")\n\n    # Bulk Item Promo\n    order2 = DiscountStrategy(customer, cart, DiscountStrategy.bulk_item_promo)\n    print(f\"Total with Bulk Item Promo: {order2.due()}\")\n\n    # Large Order Promo\n    cart_large = [{'product': f'product{i}', 'quantity': 1, 'price': 5} for i in range(10)}]\n    order3 = DiscountStrategy(customer, cart_large, DiscountStrategy.large_order_promo)\n    print(f\"Total with Large Order Promo: {order3.due()}\")\n\n    # No Promo\n    order4 = DiscountStrategy(customer, cart)\n    print(f\"Total with No Promo: {order4.due()}\")\n```",
    "34": "```python\nfrom docx import Document\nfrom docx.shared import Pt\nfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENT\nfrom docx.enum.style import WD_STYLE_TYPE\n\n\nclass DocFileHandler:\n    \"\"\"\n    Handles Word documents, providing functionalities for reading, writing, and modifying content.\n    \"\"\"\n\n    def __init__(self, file_path=None):\n        \"\"\"\n        Initializes the DocFileHandler object with an optional file path.\n        If no file_path is provided, a new document will be created.\n        :param file_path: str, the path to the Word document file (optional).\n        \"\"\"\n        self.file_path = file_path\n        if file_path:\n            try:\n                self.document = Document(file_path)\n            except Exception as e:\n                print(f\"Error opening document: {e}. Creating a new document.\")\n                self.document = Document()\n        else:\n            self.document = Document()\n\n    def read_text(self):\n        \"\"\"\n        Reads the content of the Word document and returns it as a string.\n        :return: str, the content of the document, or None if an error occurs.\n        \"\"\"\n        try:\n            text = \"\\n\".join(paragraph.text for paragraph in self.document.paragraphs)\n            return text\n        except Exception as e:\n            print(f\"Error reading document: {e}\")\n            return None\n\n    def write_text(self, content, font_size=12, alignment='left'):\n        \"\"\"\n        Writes the specified content to the Word document.  Creates a new paragraph.\n        :param content: str, the text content to write.\n        :param font_size: int, optional, the font size of the text (default is 12).\n        :param alignment: str, optional, the alignment of the text ('left', 'center', or 'right'; default is 'left').\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n        try:\n            paragraph = self.document.add_paragraph()\n            paragraph.paragraph_format.alignment = self._get_alignment_value(alignment)\n            run = paragraph.add_run(content)\n            run.font.size = Pt(font_size)\n            self.document.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error writing to document: {e}\")\n            return False\n\n    def add_heading(self, heading, level=1):\n        \"\"\"\n        Adds a heading to the Word document.\n        :param heading: str, the text of the heading.\n        :param level: int, optional, the level of the heading (1, 2, 3, etc.; default is 1).\n        :return: bool, True if the heading is successfully added, False otherwise.\n        \"\"\"\n        try:\n            self.document.add_heading(heading, level=level)\n            self.document.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error adding heading: {e}\")\n            return False\n\n    def add_table(self, data):\n        \"\"\"\n        Adds a table to the Word document with the specified data.\n        :param data: list of lists, the data to populate the table.  Must be rectangular.\n        :return: bool, True if the table is successfully added, False otherwise.\n        \"\"\"\n        try:\n            if not data or not data[0]:\n                print(\"No data provided or empty table structure.\")\n                return False\n\n            table = self.document.add_table(rows=0, cols=len(data[0]))\n\n            for row_data in data:\n                row_cells = table.add_row().cells\n                if len(row_data) != len(data[0]):\n                    print(\"Warning: Row with incorrect number of columns. Skipping.\")\n                    continue  # Skip rows with incorrect column counts\n\n                for i, item in enumerate(row_data):\n                    row_cells[i].text = str(item)\n\n            self.document.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error adding table: {e}\")\n            return False\n\n    def _get_alignment_value(self, alignment):\n        \"\"\"\n        Returns the alignment value corresponding to the given alignment string.\n        :param alignment: str, the alignment string ('left', 'center', or 'right').\n        :return: int, the alignment value.  Defaults to LEFT.\n        \"\"\"\n        alignment = alignment.lower()\n        if alignment == 'left':\n            return WD_PARAGRAPH_ALIGNMENT.LEFT\n        elif alignment == 'center':\n            return WD_PARAGRAPH_ALIGNMENT.CENTER\n        elif alignment == 'right':\n            return WD_PARAGRAPH_ALIGNMENT.RIGHT\n        else:\n            print(f\"Invalid alignment value: {alignment}. Defaulting to left.\")\n            return WD_PARAGRAPH_ALIGNMENT.LEFT  # Default to left alignment\n\n    def save(self, file_path=None):\n        \"\"\"Saves the document.  If file_path is None, saves to the original file path.\n           If no original file path was set, raises a ValueError.\n        \"\"\"\n        if file_path:\n            self.file_path = file_path\n        if not self.file_path:\n            raise ValueError(\"No file path specified for saving.\")\n        try:\n            self.document.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error saving document: {e}\")\n            return False\n\n    def add_page_break(self):\n        \"\"\"Adds a page break to the document.\"\"\"\n        try:\n            self.document.add_page_break()\n            self.document.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error adding page break: {e}\")\n            return False\n```",
    "35": "```python\nclass EightPuzzle:\n    \"\"\"\n    This class is an implementation of the classic 8-puzzle game, including methods for finding the blank tile, making moves, getting possible moves, and solving the puzzle using a breadth-first search algorithm.\n    \"\"\"\n\n    def __init__(self, initial_state):\n        \"\"\"\n        Initializes the Eight Puzzle game with the initial state.\n\n        Args:\n            initial_state (list[list[int]]): A 3x3 list of integers representing the initial state of the puzzle.\n        \"\"\"\n        if not self._is_valid_state(initial_state):\n            raise ValueError(\"Invalid initial state: Must be a 3x3 list of integers 0-8 with no repeats.\")\n\n        self.initial_state = [row[:] for row in initial_state]  # Create a deep copy\n        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n    def _is_valid_state(self, state):\n        \"\"\"\n        Helper function to check if a given state is valid.\n        \"\"\"\n        if not isinstance(state, list) or len(state) != 3:\n            return False\n        for row in state:\n            if not isinstance(row, list) or len(row) != 3:\n                return False\n            for val in row:\n                if not isinstance(val, int) or val < 0 or val > 8:\n                    return False\n\n        # Check for duplicates\n        flattened = [val for row in state for val in row]\n        if len(set(flattened)) != 9:\n            return False\n\n        return True\n\n\n    def find_blank(self, state):\n        \"\"\"\n        Finds the coordinates of the blank tile (represented by 0) in the given state.\n\n        Args:\n            state (list[list[int]]): A 3x3 list of integers representing the puzzle state.\n\n        Returns:\n            tuple[int, int]: A tuple (row, col) representing the coordinates of the blank tile.\n        \"\"\"\n        for i in range(3):\n            for j in range(3):\n                if state[i][j] == 0:\n                    return i, j\n        return None  # Should never happen in a valid state\n\n\n    def move(self, state, direction):\n        \"\"\"\n        Generates a new state by moving the blank tile in the specified direction.\n\n        Args:\n            state (list[list[int]]): A 3x3 list of integers representing the puzzle state.\n            direction (str): The direction to move the blank tile ('up', 'down', 'left', 'right').\n\n        Returns:\n            list[list[int]] or None: A new state after the move, or None if the move is invalid.\n        \"\"\"\n        blank_i, blank_j = self.find_blank(state)\n        new_state = [row[:] for row in state]  # Deep copy\n\n        if direction == 'up' and blank_i > 0:\n            new_state[blank_i][blank_j], new_state[blank_i - 1][blank_j] = new_state[blank_i - 1][blank_j], new_state[blank_i][blank_j]\n            return new_state\n        elif direction == 'down' and blank_i < 2:\n            new_state[blank_i][blank_j], new_state[blank_i + 1][blank_j] = new_state[blank_i + 1][blank_j], new_state[blank_i][blank_j]\n            return new_state\n        elif direction == 'left' and blank_j > 0:\n            new_state[blank_i][blank_j], new_state[blank_i][blank_j - 1] = new_state[blank_i][blank_j - 1], new_state[blank_i][blank_j]\n            return new_state\n        elif direction == 'right' and blank_j < 2:\n            new_state[blank_i][blank_j], new_state[blank_i][blank_j + 1] = new_state[blank_i][blank_j + 1], new_state[blank_i][blank_j]\n            return new_state\n\n        return None  # Invalid move\n\n\n    def get_possible_moves(self, state):\n        \"\"\"\n        Determines the possible moves (directions) from the given state.\n\n        Args:\n            state (list[list[int]]): A 3x3 list of integers representing the puzzle state.\n\n        Returns:\n            list[str]: A list of possible move directions ('up', 'down', 'left', 'right').\n        \"\"\"\n        blank_i, blank_j = self.find_blank(state)\n        moves = []\n        if blank_i > 0:\n            moves.append('up')\n        if blank_i < 2:\n            moves.append('down')\n        if blank_j > 0:\n            moves.append('left')\n        if blank_j < 2:\n            moves.append('right')\n        return moves\n\n\n    def solve(self):\n        \"\"\"\n        Solves the 8-puzzle using Breadth-First Search (BFS).\n\n        Returns:\n            list[str] or None: A list of move directions representing the solution path, or None if no solution is found.\n        \"\"\"\n        initial_state_tuple = tuple(tuple(row) for row in self.initial_state)\n        goal_state_tuple = tuple(tuple(row) for row in self.goal_state)\n\n        if initial_state_tuple == goal_state_tuple:\n            return []  # Already at the goal state\n\n        open_list = [(self.initial_state, [])]  # (state, path)\n        visited = {initial_state_tuple}\n\n        while open_list:\n            current_state, path = open_list.pop(0)\n            current_state_tuple = tuple(tuple(row) for row in current_state)\n\n\n            possible_moves = self.get_possible_moves(current_state)\n            for move in possible_moves:\n                new_state = self.move(current_state, move)\n                if new_state:\n                    new_state_tuple = tuple(tuple(row) for row in new_state)\n\n                    if new_state_tuple == goal_state_tuple:\n                        return path + [move]\n\n                    if new_state_tuple not in visited:\n                        open_list.append((new_state, path + [move]))\n                        visited.add(new_state_tuple)\n\n        return None  # No solution found\n```",
    "36": "```python\nfrom datetime import datetime\n\nclass EmailClient:\n    \"\"\"\n    This is a class that serves as an email client, implementing functions such as checking emails, determining whether there is sufficient space, and cleaning up space\n    \"\"\"\n\n    def __init__(self, addr, capacity):\n        \"\"\"\n        Initializes the EmailClient class with the email address and the capacity of the email box.\n        :param addr: The email address, str.\n        :param capacity: The capacity of the email box, float.\n        \"\"\"\n        if not isinstance(addr, str):\n            raise TypeError(\"Address must be a string.\")\n        if not isinstance(capacity, (int, float)):\n            raise TypeError(\"Capacity must be a number.\")\n        if capacity <= 0:\n            raise ValueError(\"Capacity must be positive.\")\n\n        self.addr = addr\n        self.capacity = float(capacity)  # Ensure capacity is a float\n        self.inbox = []\n\n    def send_to(self, recv, content, size):\n        \"\"\"\n        Sends an email to the given email address.\n        :param recv: The EmailClient object of the receiver.\n        :param content: The content of the email, str.\n        :param size: The size of the email, float.\n        :return: True if the email is sent successfully, False if the receiver's email box is full.\n        \"\"\"\n        if not isinstance(recv, EmailClient):\n            raise TypeError(\"Receiver must be an EmailClient object.\")\n        if not isinstance(content, str):\n            raise TypeError(\"Content must be a string.\")\n        if not isinstance(size, (int, float)):\n            raise TypeError(\"Size must be a number.\")\n        if size <= 0:\n            raise ValueError(\"Size must be positive.\")\n            \n        if recv.is_full_with_one_more_email(size):\n            return False\n        else:\n            now = datetime.now()\n            dt_string = now.strftime(\"%Y-%m-%d %H:%M:%S\")\n            email = {'sender': self.addr, 'receiver': recv.addr, 'content': content, 'size': float(size), 'time': dt_string, 'state': 'unread'}\n            recv.inbox.append(email)\n            return True\n\n    def fetch(self):\n        \"\"\"\n        Retrieves the first unread email in the email box and marks it as read.\n        :return: The first unread email in the email box, dict. Returns None if no unread emails.\n        \"\"\"\n        for email in self.inbox:\n            if email['state'] == 'unread':\n                email['state'] = 'read'\n                return email\n        return None\n\n    def is_full_with_one_more_email(self, size):\n        \"\"\"\n        Determines whether the email box is full after adding an email of the given size.\n        :param size: The size of the email, float.\n        :return: True if the email box is full, False otherwise.\n        \"\"\"\n        if not isinstance(size, (int, float)):\n            raise TypeError(\"Size must be a number.\")\n        if size <= 0:\n            raise ValueError(\"Size must be positive.\")\n        \n        return self.get_occupied_size() + size > self.capacity\n\n    def get_occupied_size(self):\n        \"\"\"\n        Gets the total size of the emails in the email box.\n        :return: The total size of the emails in the email box, float.\n        \"\"\"\n        total_size = 0.0\n        for email in self.inbox:\n            total_size += float(email.get('size', 0))  # Ensure size is treated as a float\n        return total_size\n\n    def clear_inbox(self, size):\n        \"\"\"\n        Clears the email box by deleting the oldest emails until the email box has enough space to accommodate the given size.\n        :param size: The size of the email, float.\n        \"\"\"\n        if not isinstance(size, (int, float)):\n            raise TypeError(\"Size must be a number.\")\n        if size <= 0:\n            raise ValueError(\"Size must be positive.\")\n            \n        while self.is_full_with_one_more_email(size):\n            if not self.inbox:\n                break\n            self.inbox.pop(0)\n```",
    "37": "```python\nclass EncryptionUtils:\n    \"\"\"\n    This class provides methods for encryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the class with a key.\n        :param key: The key to use for encryption, str.  Should be non-empty for Vigenere.\n        :raises ValueError: if key is empty for Vigenere cipher.\n        \"\"\"\n        self.key = key\n        if not self.key and hasattr(self, 'vigenere_cipher'):\n            raise ValueError(\"Key cannot be empty for Vigenere cipher.\")\n\n\n    def caesar_cipher(self, plaintext, shift):\n        \"\"\"\n        Encrypts the plaintext using the Caesar cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :param shift: The number of characters to shift each character in the plaintext, int.\n                      Can be positive or negative.\n        :return: The ciphertext, str.\n        \"\"\"\n        ciphertext = \"\"\n        for char in plaintext:\n            if 'a' <= char <= 'z':\n                shifted_char = chr(((ord(char) - ord('a') + shift) % 26) + ord('a'))\n            elif 'A' <= char <= 'Z':\n                shifted_char = chr(((ord(char) - ord('A') + shift) % 26) + ord('A'))\n            else:\n                shifted_char = char\n            ciphertext += shifted_char\n        return ciphertext\n\n    def vigenere_cipher(self, plaintext):\n        \"\"\"\n        Encrypts the plaintext using the Vigenere cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :return: The ciphertext, str.\n        \"\"\"\n        ciphertext = \"\"\n        key = self.key\n        key_length = len(key)\n        for i, char in enumerate(plaintext):\n            if 'a' <= char <= 'z':\n                key_char = key[i % key_length]\n                key_shift = ord(key_char.lower()) - ord('a')\n                shifted_char = chr(((ord(char) - ord('a') + key_shift) % 26) + ord('a'))\n            elif 'A' <= char <= 'Z':\n                key_char = key[i % key_length]\n                key_shift = ord(key_char.lower()) - ord('a')\n                shifted_char = chr(((ord(char) - ord('A') + key_shift) % 26) + ord('A'))\n            else:\n                shifted_char = char\n            ciphertext += shifted_char\n        return ciphertext\n\n    def rail_fence_cipher(self, plain_text, rails):\n        \"\"\"\n        Encrypts the plaintext using the Rail Fence cipher.\n        :param plain_text: The plaintext to encrypt, str.\n        :param rails: The number of rails to use, int. Must be at least 2.\n        :return: The ciphertext, str.\n        :raises ValueError: if rails is less than 2.\n        \"\"\"\n        if rails < 2:\n            raise ValueError(\"Number of rails must be at least 2.\")\n\n        fence = [[\"\" for _ in range(len(plain_text))] for _ in range(rails)]\n        rail = 0\n        down = True\n\n        for col in range(len(plain_text)):\n            fence[rail][col] = plain_text[col]\n\n            if rail == rails - 1:\n                down = False\n            elif rail == 0:\n                down = True\n\n            rail += 1 if down else -1\n\n        ciphertext = \"\"\n        for row in fence:\n            ciphertext += \"\".join(row)\n\n        ciphertext = ciphertext.replace(\"\",\"\")\n        return ciphertext\n```",
    "38": "```python\nimport openpyxl\nfrom openpyxl.utils.exceptions import InvalidFileException\n\n\nclass ExcelProcessor:\n    \"\"\"\n    A class for processing Excel files, including reading and writing data,\n    performing specific operations, and saving to a new Excel file.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_excel(self, file_name):\n        \"\"\"\n        Reads data from an Excel file.\n\n        Args:\n            file_name (str): The name of the Excel file to read.\n\n        Returns:\n            list: A list of tuples, where each tuple represents a row of data.\n                  Returns None if the file is not found or an error occurs.\n        \"\"\"\n        try:\n            workbook = openpyxl.load_workbook(file_name)\n            sheet = workbook.active\n            data = list(sheet.iter_rows(values_only=True))  # Directly convert to list\n            return data\n        except FileNotFoundError:\n            print(f\"Error: File '{file_name}' not found.\")\n            return None\n        except InvalidFileException:\n            print(f\"Error: File '{file_name}' is not a valid Excel file.\")\n            return None\n        except Exception as e:\n            print(f\"An unexpected error occurred while reading the Excel file: {e}\")\n            return None\n\n    def write_excel(self, data, file_name):\n        \"\"\"\n        Writes data to an Excel file.\n\n        Args:\n            data (list): A list of tuples or lists, where each item represents a row to be written.\n            file_name (str): The name of the Excel file to write to.\n\n        Returns:\n            bool: True if the data was written successfully, False otherwise.\n        \"\"\"\n        try:\n            workbook = openpyxl.Workbook()\n            sheet = workbook.active\n            for row_data in data:\n                sheet.append(row_data)\n            workbook.save(file_name)\n            return True\n        except Exception as e:\n            print(f\"An error occurred while writing to the Excel file: {e}\")\n            return False\n\n    def process_excel_data(self, column_index, file_name):\n        \"\"\"\n        Processes data in an Excel file by converting the specified column to uppercase.\n\n        Args:\n            column_index (int): The index of the column to convert to uppercase (0-based).\n            file_name (str): The name of the Excel file to process.\n\n        Returns:\n            tuple: A tuple containing a boolean indicating success (True/False) and the output file name.\n                   Returns (False, None) if an error occurs.\n        \"\"\"\n        try:\n            data = self.read_excel(file_name)\n            if data is None:\n                return False, None\n\n            new_data = []\n            for row in data:\n                row_list = list(row)  # Convert tuple to list for modification\n                if 0 <= column_index < len(row_list):  # Check if column_index is valid\n                    cell_value = row_list[column_index]\n                    if isinstance(cell_value, (int, float)):\n                        row_list[column_index] = str(cell_value).upper()\n                    elif isinstance(cell_value, str):\n                        row_list[column_index] = cell_value.upper()\n                new_data.append(tuple(row_list))  # Convert back to tuple\n\n            output_file_name = \"processed_\" + file_name\n            success = self.write_excel(new_data, output_file_name)\n            return success, output_file_name\n        except Exception as e:\n            print(f\"An error occurred while processing the Excel data: {e}\")\n            return False, None\n\n\nif __name__ == '__main__':\n    processor = ExcelProcessor()\n\n    # Example Usage for write_excel\n    new_data = [\n        ('Name', 'Age', 'Country'),\n        ('John', 25, 'USA'),\n        ('Alice', 30, 'Canada'),\n        ('Bob', 35, 'Australia'),\n        ('Julia', 28, 'Germany')\n    ]\n    write_status = processor.write_excel(new_data, 'test_data.xlsx')\n    print(f\"Write Status: {write_status}\")\n\n    # Example Usage for process_excel_data\n    success, output_file = processor.process_excel_data(0, 'test_data.xlsx')  # Change the first column to uppercase\n    print(f\"Process Status: {success}, Output File: {output_file}\")\n\n    # Example Usage for read_excel:\n    read_data = processor.read_excel('test_data.xlsx')\n    if read_data:\n        print(\"Read Data:\")\n        for row in read_data:\n            print(row)\n```",
    "39": "```python\nfrom collections import deque\nimport decimal\n\n\nclass ExpressionCalculator:\n    \"\"\"\n    A class to evaluate arithmetic expressions. Supports +, -, *, /, %, and parentheses.\n    \"\"\"\n\n    OPERATORS = {'+': 1, '-': 1, '*': 2, '/': 2, '%': 2}\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculates the result of an arithmetic expression.\n\n        Args:\n            expression (str): The arithmetic expression to evaluate (e.g., \"2 + 3 * 4\").\n\n        Returns:\n            decimal.Decimal: The result of the expression.\n\n        Raises:\n            ValueError: If the expression is invalid (e.g., unbalanced parentheses,\n                        division by zero, invalid operator).\n        \"\"\"\n        try:\n            postfix = self._infix_to_postfix(expression)\n            return self._evaluate_postfix(postfix)\n        except Exception as e:\n            raise ValueError(f\"Invalid expression: {expression}. Reason: {e}\") from e\n\n    def _infix_to_postfix(self, expression):\n        \"\"\"\n        Converts an infix expression to postfix notation.\n\n        Args:\n            expression (str): The infix expression (e.g., \"2 + 3 * 4\").\n\n        Returns:\n            list: The postfix expression as a list of tokens (e.g., ['2', '3', '4', '*', '+']).\n        \"\"\"\n        expression = expression.replace(\" \", \"\")  # Remove spaces\n        output_queue = []\n        operator_stack = deque()\n\n        for token in self._tokenize(expression):\n            if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):  # Handle negative numbers\n                output_queue.append(token)\n            elif token in self.OPERATORS:\n                while operator_stack and operator_stack[-1] in self.OPERATORS and \\\n                        self.OPERATORS[token] <= self.OPERATORS[operator_stack[-1]]:\n                    output_queue.append(operator_stack.pop())\n                operator_stack.append(token)\n            elif token == '(':\n                operator_stack.append(token)\n            elif token == ')':\n                while operator_stack and operator_stack[-1] != '(':\n                    output_queue.append(operator_stack.pop())\n                if not operator_stack:\n                    raise ValueError(\"Unbalanced parentheses\")\n                operator_stack.pop()  # Remove the '('\n            else:\n                raise ValueError(f\"Invalid token: {token}\")\n\n        while operator_stack:\n            if operator_stack[-1] == '(':\n                raise ValueError(\"Unbalanced parentheses\")\n            output_queue.append(operator_stack.pop())\n\n        return output_queue\n\n    def _evaluate_postfix(self, postfix):\n        \"\"\"\n        Evaluates a postfix expression.\n\n        Args:\n            postfix (list): The postfix expression as a list of tokens (e.g., ['2', '3', '4', '*', '+']).\n\n        Returns:\n            decimal.Decimal: The result of the expression.\n        \"\"\"\n        stack = deque()\n        for token in postfix:\n            if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n                stack.append(decimal.Decimal(token))\n            elif token in self.OPERATORS:\n                if len(stack) < 2:\n                    raise ValueError(\"Not enough operands for operator\")\n                operand2 = stack.pop()\n                operand1 = stack.pop()\n                result = self._apply_operator(operand1, operand2, token)\n                stack.append(result)\n            else:\n                raise ValueError(f\"Invalid token in postfix expression: {token}\")\n\n        if len(stack) != 1:\n            raise ValueError(\"Invalid postfix expression\")\n\n        return stack.pop()\n\n    def _apply_operator(self, operand1, operand2, operator):\n        \"\"\"\n        Applies an arithmetic operator to two operands.\n\n        Args:\n            operand1 (decimal.Decimal): The first operand.\n            operand2 (decimal.Decimal): The second operand.\n            operator (str): The operator (+, -, *, /, %).\n\n        Returns:\n            decimal.Decimal: The result of the operation.\n        \"\"\"\n        if operator == '+':\n            return operand1 + operand2\n        elif operator == '-':\n            return operand1 - operand2\n        elif operator == '*':\n            return operand1 * operand2\n        elif operator == '/':\n            if operand2 == 0:\n                raise ZeroDivisionError(\"Division by zero\")\n            return operand1 / operand2\n        elif operator == '%':\n            if operand2 == 0:\n                raise ZeroDivisionError(\"Modulo by zero\")\n            return operand1 % operand2\n        else:\n            raise ValueError(f\"Invalid operator: {operator}\")\n\n    def _tokenize(self, expression):\n        \"\"\"\n        Tokenizes the input expression, handling multi-digit numbers and negative numbers.\n\n        Args:\n            expression (str): The arithmetic expression.\n\n        Returns:\n            list: A list of tokens (numbers and operators).\n        \"\"\"\n        tokens = []\n        current_number = \"\"\n        for char in expression:\n            if char.isdigit():\n                current_number += char\n            elif char in self.OPERATORS or char in \"()\":\n                if current_number:\n                    tokens.append(current_number)\n                    current_number = \"\"\n                tokens.append(char)\n            elif char == '-' and (not tokens or tokens[-1] in self.OPERATORS or tokens[-1] == '('):\n                current_number = \"-\"  # Handle negative numbers\n            else:\n                raise ValueError(f\"Invalid character in expression: {char}\")\n\n        if current_number:\n            tokens.append(current_number)\n        return tokens\n```",
    "40": "```python\nclass FitnessTracker:\n    \"\"\"\n    A class for tracking fitness metrics like BMI and calorie intake.\n    \"\"\"\n\n    BMI_STANDARDS = {\n        \"male\": [20, 25],\n        \"female\": [19, 24]\n    }\n    ACTIVITY_MULTIPLIERS = {\n        1: 1.2,  # Overweight\n        -1: 1.6, # Underweight\n        0: 1.4   # Normal\n    }\n\n    def __init__(self, height, weight, age, sex):\n        \"\"\"\n        Initializes the FitnessTracker with user data.\n\n        Args:\n            height (float): Height in meters.\n            weight (float): Weight in kilograms.\n            age (int): Age in years.\n            sex (str): Sex, either \"male\" or \"female\".\n\n        Raises:\n            ValueError: If sex is not \"male\" or \"female\".\n        \"\"\"\n        self.height = height\n        self.weight = weight\n        self.age = age\n        self.sex = sex.lower()\n\n        if self.sex not in (\"male\", \"female\"):\n            raise ValueError(\"Sex must be 'male' or 'female'.\")\n\n\n    def get_BMI(self):\n        \"\"\"\n        Calculates the Body Mass Index (BMI).\n\n        Returns:\n            float: The calculated BMI.\n        \"\"\"\n        if self.height <= 0:\n            raise ValueError(\"Height must be a positive value.\")\n        return self.weight / (self.height ** 2)\n\n    def condition_judge(self):\n        \"\"\"\n        Determines the user's condition based on BMI.\n\n        Returns:\n            int: 1 if overweight, -1 if underweight, 0 if normal.\n        \"\"\"\n        bmi = self.get_BMI()\n        lower_limit, upper_limit = self.BMI_STANDARDS[self.sex]\n\n        if bmi > upper_limit:\n            return 1\n        elif bmi < lower_limit:\n            return -1\n        else:\n            return 0\n\n    def calculate_calorie_intake(self):\n        \"\"\"\n        Calculates the recommended daily calorie intake based on BMR and activity level.\n\n        Returns:\n            float: The calculated calorie intake.\n        \"\"\"\n        bmr = self._calculate_bmr()\n        condition = self.condition_judge()\n        multiplier = self.ACTIVITY_MULTIPLIERS.get(condition)\n\n        if multiplier is None:\n            raise ValueError(\"Invalid condition value.\")\n\n        return bmr * multiplier\n\n    def _calculate_bmr(self):\n        \"\"\"\n        Calculates the Basal Metabolic Rate (BMR).\n\n        Returns:\n            float: The calculated BMR.\n        \"\"\"\n        if self.sex == \"male\":\n            bmr = 10 * self.weight + 6.25 * self.height * 100 - 5 * self.age + 5\n        else:\n            bmr = 10 * self.weight + 6.25 * self.height * 100 - 5 * self.age - 161\n        return bmr\n```",
    "41": "```python\nclass GomokuGame:\n    \"\"\"\n    This class is an implementation of a Gomoku game, supporting for making moves, checking for a winner, and checking if there are five consecutive symbols on the game board.\n    \"\"\"\n\n    def __init__(self, board_size):\n        \"\"\"\n        Initializes the game with a given board size.\n        It initializes the board with empty spaces and sets the current player symbol as 'X'.\n        \"\"\"\n        if not isinstance(board_size, int) or board_size <= 0:\n            raise ValueError(\"Board size must be a positive integer.\")\n\n        self.board_size = board_size\n        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]\n        self.current_player = 'X'\n        self.other_player = 'O'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Makes a move at the given row and column.\n        If the move is valid, it places the current player's symbol on the board\n        and changes the current player to the other player.\n        :param row: int, the row index of this move\n        :param col: int, the column index\n        :return: True if the move is valid, or False otherwise.\n        \"\"\"\n        if not isinstance(row, int) or not isinstance(col, int):\n            return False\n\n        if not (0 <= row < self.board_size and 0 <= col < self.board_size):\n            return False\n\n        if self.board[row][col] != ' ':\n            return False\n\n        self.board[row][col] = self.current_player\n        self.current_player, self.other_player = self.other_player, self.current_player  # Swap players\n        return True\n\n    def check_winner(self):\n        \"\"\"\n        Checks if there is a winner by looking for five in a row in all directions (horizontal, vertical, diagonal).\n        :return: the symbol of the winning player (either 'X' or 'O') if there is a winner, or None otherwise.\n        \"\"\"\n        for row in range(self.board_size):\n            for col in range(self.board_size):\n                if self.board[row][col] != ' ':\n                    player = self.board[row][col]\n                    if self._check_five_in_a_row(row, col, (0, 1), player):  # Horizontal\n                        return player\n                    if self._check_five_in_a_row(row, col, (1, 0), player):  # Vertical\n                        return player\n                    if self._check_five_in_a_row(row, col, (1, 1), player):  # Diagonal\n                        return player\n                    if self._check_five_in_a_row(row, col, (1, -1), player):  # Anti-Diagonal\n                        return player\n        return None\n\n    def _check_five_in_a_row(self, row, col, direction, player):\n        \"\"\"\n        Checks if there are five consecutive symbols of the same player in a row starting from a given cell in a given direction.\n        :param row: int, row of the given cell\n        :param col: int, column of the given cell\n        :param direction: tuple, (int, int), representing the direction to check (dx, dy).\n        :param player: The player ('X' or 'O') to check for.\n        :return: True if there are five consecutive symbols of the same player, and False otherwise.\n        \"\"\"\n        count = 0\n        for i in range(5):\n            new_row = row + i * direction[0]\n            new_col = col + i * direction[1]\n            if 0 <= new_row < self.board_size and 0 <= new_col < self.board_size and self.board[new_row][new_col] == player:\n                count += 1\n            else:\n                return False\n        return count == 5\n\n    def is_board_full(self):\n        \"\"\"\n        Checks if the board is full.\n        :return: True if the board is full, False otherwise.\n        \"\"\"\n        for row in range(self.board_size):\n            for col in range(self.board_size):\n                if self.board[row][col] == ' ':\n                    return False\n        return True\n\n    def get_board(self):\n        \"\"\"\n        Returns the current state of the board.\n        :return: A 2D list representing the board.\n        \"\"\"\n        return [row[:] for row in self.board]  # Return a copy to prevent modification\n\n    def print_board(self):\n        \"\"\"Prints the board to the console.\"\"\"\n        for row in self.board:\n            print('|' + '|'.join(row) + '|')\n            print('-' * (2 * self.board_size + 1))\n```",
    "42": "```python\nclass Hotel:\n    \"\"\"\n    Manages hotel bookings, check-ins, check-outs, and room availability.\n    \"\"\"\n\n    def __init__(self, name, rooms):\n        \"\"\"\n        Initializes the Hotel object.\n\n        Args:\n            name (str): The name of the hotel.\n            rooms (dict): A dictionary representing the available rooms,\n                          where keys are room types (e.g., 'single', 'double')\n                          and values are the number of available rooms of that type.\n        \"\"\"\n        if not isinstance(name, str):\n            raise TypeError(\"Hotel name must be a string.\")\n        if not isinstance(rooms, dict):\n            raise TypeError(\"Rooms must be a dictionary.\")\n        for room_type, count in rooms.items():\n            if not isinstance(room_type, str):\n                raise TypeError(\"Room type must be a string.\")\n            if not isinstance(count, int) or count < 0:\n                raise ValueError(\"Room count must be a non-negative integer.\")\n\n        self.name = name\n        self.available_rooms = rooms.copy()  # Create a copy to avoid external modification\n        self.booked_rooms = {}  # {room_type: {guest_name: num_rooms}}\n\n    def book_room(self, room_type, room_number, name):\n        \"\"\"\n        Books rooms of a specified type for a guest.\n\n        Args:\n            room_type (str): The type of room to book (e.g., 'single', 'double').\n            room_number (int): The number of rooms to book.\n            name (str): The name of the guest making the booking.\n\n        Returns:\n            str: 'Success!' if the booking was successful.\n            int: The remaining number of available rooms of that type if the\n                 requested number exceeds availability but some rooms are still available.\n            bool: False if the room type is not available or the requested number\n                  exceeds the total number of rooms of that type.\n        Raises:\n            TypeError: if room_type or name is not a string, or room_number is not an integer\n            ValueError: if room_number is not positive.\n        \"\"\"\n        if not isinstance(room_type, str):\n            raise TypeError(\"Room type must be a string.\")\n        if not isinstance(room_number, int):\n            raise TypeError(\"Room number must be an integer.\")\n        if not isinstance(name, str):\n            raise TypeError(\"Guest name must be a string.\")\n        if room_number <= 0:\n            raise ValueError(\"Room number must be positive.\")\n\n        if room_type not in self.available_rooms:\n            return False\n\n        available = self.available_rooms[room_type]\n\n        if available >= room_number:\n            # Update booked_rooms\n            if room_type not in self.booked_rooms:\n                self.booked_rooms[room_type] = {}\n            if name not in self.booked_rooms[room_type]:\n                self.booked_rooms[room_type][name] = 0\n            self.booked_rooms[room_type][name] += room_number\n\n            # Update available_rooms\n            self.available_rooms[room_type] -= room_number\n            return 'Success!'\n        elif available > 0:\n            return available\n        else:\n            return False\n\n    def check_in(self, room_type, room_number, name):\n        \"\"\"\n        Checks a guest into a booked room.\n\n        Args:\n            room_type (str): The type of room being checked into.\n            room_number (int): The number of rooms being checked into.\n            name (str): The name of the guest checking in.\n\n        Returns:\n            None\n\n        Raises:\n            TypeError: if room_type or name is not a string, or room_number is not an integer\n            ValueError: if room_number is not positive.\n            ValueError: If the check-in fails due to incorrect information.\n        \"\"\"\n        if not isinstance(room_type, str):\n            raise TypeError(\"Room type must be a string.\")\n        if not isinstance(room_number, int):\n            raise TypeError(\"Room number must be an integer.\")\n        if not isinstance(name, str):\n            raise TypeError(\"Guest name must be a string.\")\n        if room_number <= 0:\n            raise ValueError(\"Room number must be positive.\")\n\n        if room_type not in self.booked_rooms or name not in self.booked_rooms[room_type]:\n            raise ValueError(\"Check-in failed: No booking found for this room type and guest.\")\n\n        booked_number = self.booked_rooms[room_type].get(name, 0)\n        if booked_number < room_number:\n            raise ValueError(\"Check-in failed: Number of rooms exceeds booked rooms.\")\n\n        self.booked_rooms[room_type][name] -= room_number\n        if self.booked_rooms[room_type][name] == 0:\n            del self.booked_rooms[room_type][name]\n            if not self.booked_rooms[room_type]:\n                del self.booked_rooms[room_type]\n\n    def check_out(self, room_type, room_number):\n        \"\"\"\n        Checks a guest out of a room, making it available again.\n\n        Args:\n            room_type (str): The type of room being checked out.\n            room_number (int): The number of rooms being checked out.\n\n        Raises:\n            TypeError: if room_type is not a string, or room_number is not an integer\n            ValueError: if room_number is not positive.\n        \"\"\"\n        if not isinstance(room_type, str):\n            raise TypeError(\"Room type must be a string.\")\n        if not isinstance(room_number, int):\n            raise TypeError(\"Room number must be an integer.\")\n        if room_number <= 0:\n            raise ValueError(\"Room number must be positive.\")\n\n        if room_type in self.available_rooms:\n            self.available_rooms[room_type] += room_number\n        else:\n            self.available_rooms[room_type] = room_number\n\n    def get_available_rooms(self, room_type):\n        \"\"\"\n        Gets the number of available rooms of a specific type.\n\n        Args:\n            room_type (str): The type of room to query.\n\n        Returns:\n            int: The number of available rooms of the specified type.\n        Raises:\n            TypeError: if room_type is not a string\n        \"\"\"\n        if not isinstance(room_type, str):\n            raise TypeError(\"Room type must be a string.\")\n        return self.available_rooms.get(room_type, 0)\n```",
    "43": "```python\nclass HRManagementSystem:\n    \"\"\"\n    This is a class as personnel management system that implements functions such as adding, deleting, querying, and updating employees\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the HRManagementSystem with an attribute employees, which is an empty dictionary.\n        \"\"\"\n        self.employees = {}\n\n    def add_employee(self, employee_id, name, position, department, salary):\n        \"\"\"\n        Add a new employee to the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :param name: The employee's name, str.\n        :param position: The employee's position, str.\n        :param department: The employee's department, str.\n        :param salary: The employee's salary, int.\n        :return: True if the employee is added successfully, False otherwise.\n        \"\"\"\n        if not isinstance(employee_id, int):\n            raise TypeError(\"Employee ID must be an integer.\")\n        if not isinstance(name, str) or not name:\n            raise ValueError(\"Employee name must be a non-empty string.\")\n        if not isinstance(position, str) or not position:\n            raise ValueError(\"Employee position must be a non-empty string.\")\n        if not isinstance(department, str) or not department:\n            raise ValueError(\"Employee department must be a non-empty string.\")\n        if not isinstance(salary, (int, float)) or salary <= 0:\n            raise ValueError(\"Employee salary must be a positive number.\")\n\n        if employee_id in self.employees:\n            return False\n        else:\n            self.employees[employee_id] = {\n                'name': name,\n                'position': position,\n                'department': department,\n                'salary': salary\n            }\n            return True\n\n    def remove_employee(self, employee_id):\n        \"\"\"\n        Remove an employee from the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :return: True if the employee is removed successfully, False otherwise.\n        \"\"\"\n        if not isinstance(employee_id, int):\n            raise TypeError(\"Employee ID must be an integer.\")\n\n        if employee_id in self.employees:\n            del self.employees[employee_id]\n            return True\n        else:\n            return False\n\n    def update_employee(self, employee_id: int, employee_info: dict):\n        \"\"\"\n        Update an employee's information in the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :param employee_info: A dictionary containing the employee's information to update.\n        :return: True if the employee is updated successfully, False otherwise.\n        \"\"\"\n        if not isinstance(employee_id, int):\n            raise TypeError(\"Employee ID must be an integer.\")\n        if not isinstance(employee_info, dict):\n            raise TypeError(\"Employee info must be a dictionary.\")\n\n        if employee_id in self.employees:\n            # Validate employee_info (example)\n            if 'salary' in employee_info and not isinstance(employee_info['salary'], (int, float)):\n                raise ValueError(\"Salary must be a number.\")\n\n            self.employees[employee_id].update(employee_info)\n            return True\n        else:\n            return False\n\n    def get_employee(self, employee_id):\n        \"\"\"\n        Get an employee's information from the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :return: A dictionary containing the employee's information if found, False otherwise.\n        \"\"\"\n        if not isinstance(employee_id, int):\n            raise TypeError(\"Employee ID must be an integer.\")\n\n        if employee_id in self.employees:\n            return self.employees[employee_id]\n        else:\n            return False\n\n    def list_employees(self):\n        \"\"\"\n        List all employees' information in the HRManagementSystem.\n        :return: A dictionary where keys are employee IDs and values are employee information dictionaries.\n        \"\"\"\n        return self.employees\n```",
    "44": "```python\nimport re\nfrom bs4 import BeautifulSoup\n\nclass HtmlUtil:\n    \"\"\"\n    This is a class as util for html, supporting for formatting and extracting code from HTML text, including cleaning up the text and converting certain elements into specific marks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a series of labels\n        \"\"\"\n        self.SPACE_MARK = '-SPACE-'\n        self.JSON_MARK = '-JSON-'\n        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'\n        self.URL_MARK = '-URL-'\n        self.NUMBER_MARK = '-NUMBER-'\n        self.TRACE_MARK = '-TRACE-'\n        self.COMMAND_MARK = '-COMMAND-'\n        self.COMMENT_MARK = '-COMMENT-'\n        self.CODE_MARK = '-CODE-'\n\n    @staticmethod\n    def __format_line_feed(text):\n        \"\"\"\n        Replace consecutive line breaks with a single line break\n        :param text: string with consecutive line breaks\n        :return:string, replaced text with single line break\n        \"\"\"\n        return re.sub(r'\\n+', '\\n', text)\n\n    def format_line_html_text(self, html_text):\n        \"\"\"\n        get the html text without the code, and add the code tag -CODE- where the code is\n        :param html_text:string\n        :return:string\n        \"\"\"\n        soup = BeautifulSoup(html_text, 'html.parser')\n        text = \"\"\n        if soup.body:\n            for element in soup.body.children:\n                if element.name == 'pre':\n                    text += self.CODE_MARK + '\\n'\n                elif element and element.name:\n                    text += element.text + '\\n'\n        return self.__format_line_feed(text).strip()\n\n    def extract_code_from_html_text(self, html_text):\n        \"\"\"\n        extract codes from the html body\n        :param html_text: string, html text\n        :return: the list of code\n        \"\"\"\n        soup = BeautifulSoup(html_text, 'html.parser')\n        code_list = []\n        for code in soup.find_all('pre'):\n            code_text = code.text\n            code_list.append(code_text)\n        return code_list\n```",
    "45": "```python\nfrom PIL import Image, ImageEnhance\n\n\nclass ImageProcessor:\n    \"\"\"\n    This class processes images, including loading, saving, resizing, rotating, and adjusting brightness.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the ImageProcessor with no image loaded.\n        \"\"\"\n        self.image = None\n\n    def load_image(self, image_path):\n        \"\"\"\n        Loads an image from the specified path using PIL.\n\n        Args:\n            image_path (str): The path to the image file.\n\n        Raises:\n            FileNotFoundError: If the image file is not found.\n            Exception: If there is an error opening the image.\n        \"\"\"\n        try:\n            self.image = Image.open(image_path)\n        except FileNotFoundError:\n            raise FileNotFoundError(f\"Image file not found at {image_path}\")\n        except Exception as e:\n            raise Exception(f\"Could not open image at {image_path}: {e}\")\n\n    def save_image(self, save_path):\n        \"\"\"\n        Saves the currently loaded image to the specified path.\n\n        Args:\n            save_path (str): The path to save the image to.\n\n        Raises:\n            ValueError: If no image is loaded.\n            Exception: If there is an error saving the image.\n        \"\"\"\n        if self.image:\n            try:\n                self.image.save(save_path)\n            except Exception as e:\n                raise Exception(f\"Could not save image to {save_path}: {e}\")\n        else:\n            raise ValueError(\"No image loaded to save.\")\n\n    def resize_image(self, width, height, resample=Image.LANCZOS):\n        \"\"\"\n        Resizes the currently loaded image to the specified width and height.\n\n        Args:\n            width (int): The target width of the image.\n            height (int): The target height of the image.\n            resample: Resampling filter. Defaults to LANCZOS\n\n        Raises:\n            ValueError: If no image is loaded.\n            ValueError: if width or height are not positive integers\n            Exception: If there is an error resizing the image.\n        \"\"\"\n        if not isinstance(width, int) or width <= 0:\n            raise ValueError(\"Width must be a positive integer.\")\n        if not isinstance(height, int) or height <= 0:\n            raise ValueError(\"Height must be a positive integer.\")\n\n        if self.image:\n            try:\n                self.image = self.image.resize((width, height), resample=resample)\n            except Exception as e:\n                raise Exception(f\"Could not resize image: {e}\")\n        else:\n            raise ValueError(\"No image loaded to resize.\")\n\n    def rotate_image(self, degrees, expand=False):\n        \"\"\"\n        Rotates the currently loaded image by the specified number of degrees.\n\n        Args:\n            degrees (float): The number of degrees to rotate the image by (clockwise).\n            expand (bool): Whether the image should be expanded to fit the rotated image.\n\n        Raises:\n            ValueError: If no image is loaded.\n            TypeError: if degrees is not a number\n            Exception: If there is an error rotating the image.\n        \"\"\"\n        if not isinstance(degrees, (int, float)):\n            raise TypeError(\"Degrees must be a number.\")\n\n        if self.image:\n            try:\n                self.image = self.image.rotate(\n                    -degrees, expand=expand\n                )  # PIL rotates counterclockwise, so negating degrees\n            except Exception as e:\n                raise Exception(f\"Could not rotate image: {e}\")\n        else:\n            raise ValueError(\"No image loaded to rotate.\")\n\n    def adjust_brightness(self, factor):\n        \"\"\"\n        Adjusts the brightness of the currently loaded image.\n\n        Args:\n            factor (float): The brightness factor. 1.0 gives the original image.\n\n        Raises:\n            ValueError: If no image is loaded.\n            TypeError: If factor is not a number.\n            ValueError: if factor is negative\n            Exception: If there is an error adjusting the brightness.\n        \"\"\"\n        if not isinstance(factor, (int, float)):\n            raise TypeError(\"Factor must be a number.\")\n\n        if factor < 0:\n            raise ValueError(\"Factor must be non-negative.\")\n\n        if self.image:\n            try:\n                enhancer = ImageEnhance.Brightness(self.image)\n                self.image = enhancer.enhance(factor)\n            except Exception as e:\n                raise Exception(f\"Could not adjust brightness: {e}\")\n        else:\n            raise ValueError(\"No image loaded to adjust brightness.\")\n```",
    "46": "```python\nimport numpy as np\n\nclass Interpolation:\n    \"\"\"\n    This is a class that implements the Linear interpolation operation of one-dimensional and two-dimensional data\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        \"\"\"\n        Linear interpolation of one-dimensional data.  Uses numpy for efficiency and handles edge cases.\n\n        :param x: The x-coordinate of the data points, list or numpy array.  Must be sorted.\n        :param y: The y-coordinate of the data points, list or numpy array.\n        :param x_interp: The x-coordinate of the interpolation points, list or numpy array.\n        :return: The y-coordinate of the interpolation points, numpy array. Returns NaN if x_interp is outside the range of x.\n\n        >>> Interpolation.interpolate_1d([1, 2, 3], [1, 2, 3], [1.5, 2.5])\n        array([1.5, 2.5])\n        >>> Interpolation.interpolate_1d([1, 2, 3], [1, 2, 3], [0.5, 3.5])\n        array([nan, nan])\n        \"\"\"\n        x = np.asarray(x)\n        y = np.asarray(y)\n        x_interp = np.asarray(x_interp)\n\n        if x.ndim != 1 or y.ndim != 1 or x_interp.ndim != 1:\n            raise ValueError(\"x, y, and x_interp must be one-dimensional arrays.\")\n\n        if x.shape != y.shape:\n            raise ValueError(\"x and y must have the same shape.\")\n\n        y_interp = np.interp(x_interp, x, y, left=np.nan, right=np.nan)  # Use numpy's interp for efficiency and edge handling\n        return y_interp\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        \"\"\"\n        Bilinear interpolation of two-dimensional data. Uses numpy for efficiency and readability.\n        Handles out-of-bounds cases by returning NaN.\n\n        :param x: The x-coordinates of the data points, list or numpy array (1D). Must be sorted.\n        :param y: The y-coordinates of the data points, list or numpy array (1D). Must be sorted.\n        :param z: The z-coordinates of the data points, list or numpy array (2D). z[i][j] corresponds to (x[i], y[j]).\n        :param x_interp: The x-coordinates of the interpolation points, list or numpy array (1D).\n        :param y_interp: The y-coordinates of the interpolation points, list or numpy array (1D).\n        :return: The z-coordinates of the interpolation points, numpy array (1D). Returns NaN if interpolation point is out of bounds.\n\n        >>> Interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1.5, 2.5], [1.5, 2.5])\n        array([3., 7.])\n        >>> Interpolation.interpolate_2d([1, 2], [1, 2], [[1, 2], [3, 4]], [0, 3], [0, 3])\n        array([nan, nan])\n        \"\"\"\n        x = np.asarray(x)\n        y = np.asarray(y)\n        z = np.asarray(z)\n        x_interp = np.asarray(x_interp)\n        y_interp = np.asarray(y_interp)\n\n        if x.ndim != 1 or y.ndim != 1 or x_interp.ndim != 1 or y_interp.ndim != 1:\n            raise ValueError(\"x, y, x_interp, and y_interp must be one-dimensional arrays.\")\n\n        if z.ndim != 2:\n            raise ValueError(\"z must be a two-dimensional array.\")\n\n        if z.shape != (len(x), len(y)):\n            raise ValueError(\"z must have shape (len(x), len(y)).\")\n\n        z_interp = np.zeros_like(x_interp, dtype=np.float64)\n        z_interp[:] = np.nan  # Initialize with NaN\n\n        for idx, (xi, yi) in enumerate(zip(x_interp, y_interp)):\n            # Find the grid cell containing the point (xi, yi)\n            i = np.searchsorted(x, xi, side=\"right\") - 1\n            j = np.searchsorted(y, yi, side=\"right\") - 1\n\n            if 0 <= i < len(x) - 1 and 0 <= j < len(y) - 1:\n                # Bilinear interpolation\n                x1, x2 = x[i], x[i + 1]\n                y1, y2 = y[j], y[j + 1]\n\n                Q11 = z[i, j]\n                Q12 = z[i, j + 1]\n                Q21 = z[i + 1, j]\n                Q22 = z[i + 1, j + 1]\n\n                z_interp[idx] = (\n                    (Q11 * (x2 - xi) * (y2 - yi))\n                    + (Q21 * (xi - x1) * (y2 - yi))\n                    + (Q12 * (x2 - xi) * (yi - y1))\n                    + (Q22 * (xi - x1) * (yi - y1))\n                ) / ((x2 - x1) * (y2 - y1))\n\n        return z_interp\n```",
    "47": "```python\nimport ipaddress\n\nclass IPAddress:\n    \"\"\"\n    This is a class to process IP Address, including validating, getting the octets and obtaining the binary representation of a valid IP address.\n    \"\"\"\n\n    def __init__(self, ip_address):\n        \"\"\"\n        Initialize the IP address to the specified address\n        :param ip_address: string\n        \"\"\"\n        self.ip_address = ip_address\n        self._octets = None\n        self._is_valid = None\n\n\n    def is_valid(self):\n        \"\"\"\n        Judge whether the IP address is valid, that is, whether the IP address is composed of four Decimal digits separated by '.'. Each digit is greater than or equal to 0 and less than or equal to 255\n        :return: bool\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.is_valid()\n        True\n        >>> ipaddress = IPAddress(\"256.256.256.256\")\n        >>> ipaddress.is_valid()\n        False\n        \"\"\"\n        if self._is_valid is None:\n            try:\n                ipaddress.ip_address(self.ip_address)\n                self._is_valid = True\n                self._octets = self.ip_address.split('.')\n            except ValueError:\n                self._is_valid = False\n                self._octets = []\n        return self._is_valid\n\n\n    def get_octets(self):\n        \"\"\"\n        If the IP address is valid, the list of four decimal numbers separated by \".\" constituting the IP address is returned; otherwise, an empty list is returned\n        :return: list\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.get_octets()\n        ['10', '10', '10', '10']\n        >>> ipaddress = IPAddress(\"256.256.256.256\")\n        >>> ipaddress.get_octets()\n        []\n        \"\"\"\n        if self.is_valid():\n            return self._octets\n        else:\n            return []\n\n\n    def get_binary(self):\n        \"\"\"\n        If the IP address is valid, return the binary form of the IP address; otherwise, return ''\n        :return: string\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.get_binary()\n        '00001010.00001010.00001010.00001010'\n        >>> ipaddress = IPAddress(\"256.256.256.256\")\n        >>> ipaddress.get_binary()\n        ''\n        \"\"\"\n        if self.is_valid():\n            binary_octets = []\n            for octet in self._octets:\n                binary_octet = bin(int(octet))[2:].zfill(8)\n                binary_octets.append(binary_octet)\n            return '.'.join(binary_octets)\n        else:\n            return ''\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n```",
    "48": "```python\nimport socket\nimport ipaddress\n\n\nclass IpUtil:\n    \"\"\"\n    Utility class for IP address manipulation and validation.\n    \"\"\"\n\n    @staticmethod\n    def is_valid_ipv4(ip_address: str) -> bool:\n        \"\"\"\n        Check if the given IP address is a valid IPv4 address.\n\n        Args:\n            ip_address: The IP address to check.\n\n        Returns:\n            True if the IP address is a valid IPv4 address, False otherwise.\n\n        Examples:\n            >>> IpUtil.is_valid_ipv4('192.168.0.123')\n            True\n            >>> IpUtil.is_valid_ipv4('256.0.0.0')\n            False\n        \"\"\"\n        try:\n            ipaddress.IPv4Address(ip_address)\n            return True\n        except ValueError:\n            return False\n\n    @staticmethod\n    def is_valid_ipv6(ip_address: str) -> bool:\n        \"\"\"\n        Check if the given IP address is a valid IPv6 address.\n\n        Args:\n            ip_address: The IP address to check.\n\n        Returns:\n            True if the IP address is a valid IPv6 address, False otherwise.\n\n        Examples:\n            >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:0000:0000:8a2e:0370:7334')\n            True\n            >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:::8a2e:0370:7334')\n            False\n        \"\"\"\n        try:\n            ipaddress.IPv6Address(ip_address)\n            return True\n        except ValueError:\n            return False\n\n    @staticmethod\n    def get_hostname(ip_address: str) -> str | None:\n        \"\"\"\n        Get the hostname associated with the given IP address.\n\n        Args:\n            ip_address: The IP address to get the hostname for.\n\n        Returns:\n            The hostname associated with the IP address, or None if not found.\n\n        Examples:\n            >>> # doctest: +SKIP\n            >>> IpUtil.get_hostname('110.242.68.3')\n            'www.baidu.com'\n            >>> # doctest: +SKIP\n            >>> IpUtil.get_hostname('10.0.0.1')\n        \"\"\"\n        try:\n            return socket.gethostbyaddr(ip_address)[0]\n        except (socket.herror, socket.gaierror):\n            return None\n        except Exception:\n            return None\n```",
    "49": "```python\nclass JobMarketplace:\n    \"\"\"\n    A class to manage job postings and resumes.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the JobMarketplace with empty job listings and resumes.\n        \"\"\"\n        self.job_listings = []\n        self.resumes = []\n\n    def post_job(self, job_title, company, requirements):\n        \"\"\"\n        Publishes a new job posting.\n\n        Args:\n            job_title (str): The title of the job.\n            company (str): The name of the company.\n            requirements (list): A list of required skills or qualifications.\n\n        Returns:\n            None\n        \"\"\"\n        if not all(isinstance(arg, str) for arg in [job_title, company]) or not isinstance(requirements, list):\n            raise TypeError(\"Invalid input types. job_title and company must be strings, requirements must be a list.\")\n\n        job = {'job_title': job_title, 'company': company, 'requirements': requirements}\n        self.job_listings.append(job)\n\n    def remove_job(self, job):\n        \"\"\"\n        Removes a job posting from the marketplace.\n\n        Args:\n            job (dict): The job posting to remove.\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the job is not found in the job listings.\n        \"\"\"\n        if not isinstance(job, dict):\n            raise TypeError(\"job must be a dictionary.\")\n\n        try:\n            self.job_listings.remove(job)\n        except ValueError:\n            raise ValueError(\"Job not found in job listings.\")\n\n    def submit_resume(self, name, skills, experience):\n        \"\"\"\n        Submits a resume to the marketplace.\n\n        Args:\n            name (str): The name of the applicant.\n            skills (list): A list of skills the applicant possesses.\n            experience (str): A brief description of the applicant's experience.\n\n        Returns:\n            None\n        \"\"\"\n        if not all(isinstance(arg, str) for arg in [name, experience]) or not isinstance(skills, list):\n            raise TypeError(\"Invalid input types. name and experience must be strings, skills must be a list.\")\n\n        resume = {'name': name, 'skills': skills, 'experience': experience}\n        self.resumes.append(resume)\n\n    def withdraw_resume(self, resume):\n        \"\"\"\n        Withdraws a resume from the marketplace.\n\n        Args:\n            resume (dict): The resume to withdraw.\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the resume is not found in the resumes list.\n        \"\"\"\n        if not isinstance(resume, dict):\n            raise TypeError(\"resume must be a dictionary.\")\n\n        try:\n            self.resumes.remove(resume)\n        except ValueError:\n            raise ValueError(\"Resume not found in resumes.\")\n\n    def search_jobs(self, criteria):\n        \"\"\"\n        Searches for job postings that match the given criteria.\n\n        Args:\n            criteria (str): The search criteria (e.g., a skill or keyword).\n\n        Returns:\n            list: A list of job postings that match the criteria.\n        \"\"\"\n        if not isinstance(criteria, str):\n            raise TypeError(\"criteria must be a string.\")\n\n        results = []\n        for job in self.job_listings:\n            if any(criteria.lower() in req.lower() for req in job['requirements']):\n                results.append(job)\n        return results\n\n    def get_job_applicants(self, job):\n        \"\"\"\n        Finds applicants whose skills match the requirements of a given job.\n\n        Args:\n            job (dict): The job posting to find applicants for.\n\n        Returns:\n            list: A list of resumes that match the job requirements.\n        \"\"\"\n        if not isinstance(job, dict):\n            raise TypeError(\"job must be a dictionary.\")\n\n        applicants = []\n        for resume in self.resumes:\n            if self.matches_requirements(resume, job['requirements']):\n                applicants.append(resume)\n        return applicants\n\n    def matches_requirements(self, resume, requirements):\n        \"\"\"\n        Checks if a resume matches the given job requirements.\n\n        Args:\n            resume (dict): The resume to check.\n            requirements (list): A list of required skills.\n\n        Returns:\n            bool: True if the resume meets all requirements, False otherwise.\n        \"\"\"\n        if not isinstance(resume, dict) or not isinstance(requirements, list):\n            raise TypeError(\"resume must be a dictionary and requirements must be a list.\")\n\n        for requirement in requirements:\n            if requirement.lower() not in [skill.lower() for skill in resume['skills']]:\n                return False\n        return True\n```",
    "50": "```python\nimport json\nimport os\n\nclass JSONProcessor:\n    \"\"\"\n    This class processes JSON files, including reading, writing, and modifying data.\n    \"\"\"\n\n    def read_json(self, file_path):\n        \"\"\"\n        Reads a JSON file and returns the data as a dictionary.\n\n        Args:\n            file_path (str): The path to the JSON file.\n\n        Returns:\n            dict: The JSON data as a dictionary.\n            None: If the file does not exist or an error occurs during reading.\n        \"\"\"\n        if not os.path.exists(file_path):\n            print(f\"File not found: {file_path}\")\n            return None\n\n        try:\n            with open(file_path, 'r') as f:\n                data = json.load(f)\n            return data\n        except json.JSONDecodeError as e:\n            print(f\"Error decoding JSON: {e}\")\n            return None\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n            return None\n\n    def write_json(self, data, file_path):\n        \"\"\"\n        Writes data to a JSON file.\n\n        Args:\n            data (dict): The data to write to the JSON file.\n            file_path (str): The path to the JSON file.\n\n        Returns:\n            bool: True if the writing process is successful, False otherwise.\n        \"\"\"\n        try:\n            with open(file_path, 'w') as f:\n                json.dump(data, f, indent=4)\n            return True\n        except Exception as e:\n            print(f\"Error writing JSON to file: {e}\")\n            return False\n\n    def process_json(self, file_path, remove_key):\n        \"\"\"\n        Reads a JSON file, removes a specified key, and writes the modified data back to the file.\n\n        Args:\n            file_path (str): The path to the JSON file.\n            remove_key (str): The key to remove from the JSON data.\n\n        Returns:\n            bool: True if the key was successfully removed and the data was written back, False otherwise.\n        \"\"\"\n        data = self.read_json(file_path)\n\n        if data is None:\n            return False\n\n        if remove_key in data:\n            del data[remove_key]\n            if self.write_json(data, file_path):\n                return True\n            else:\n                return False\n        else:\n            print(f\"Key '{remove_key}' not found in JSON data.\")\n            return False\n```",
    "51": "```python\nimport numpy as np\n\nclass KappaCalculator:\n    \"\"\"\n    This is a class as KappaCalculator, supporting to calculate Cohen's and Fleiss' kappa coefficient.\n    \"\"\"\n\n    @staticmethod\n    def kappa(data):\n        \"\"\"\n        Calculate Cohen's kappa coefficient.\n\n        Args:\n            data (list of lists or numpy.ndarray): A square confusion matrix.\n\n        Returns:\n            float: Cohen's kappa coefficient.  Returns NaN if the denominator is zero.\n\n        Raises:\n            TypeError: if input is not a list or numpy array\n            ValueError: if input is not a square matrix\n\n        >>> KappaCalculator.kappa([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n        0.25\n        >>> KappaCalculator.kappa([[10, 2], [3, 5]])\n        0.38095238095238093\n        \"\"\"\n        if not isinstance(data, (list, np.ndarray)):\n            raise TypeError(\"Input data must be a list or numpy array.\")\n\n        matrix = np.array(data)\n\n        if len(matrix.shape) != 2 or matrix.shape[0] != matrix.shape[1]:\n            raise ValueError(\"Input data must be a square matrix.\")\n\n        n = np.sum(matrix)\n        if n == 0: # Handle the case where the sum of all values is zero\n            return np.nan\n\n        p_o = np.trace(matrix) / n\n\n        row_sums = np.sum(matrix, axis=1)\n        col_sums = np.sum(matrix, axis=0)\n\n        p_e = np.sum(row_sums * col_sums) / (n ** 2)\n\n        kappa = (p_o - p_e) / (1 - p_e) if (1 - p_e) !=0 else np.nan # prevent division by zero\n        return kappa\n\n    @staticmethod\n    def fleiss_kappa(data):\n        \"\"\"\n        Calculate Fleiss' kappa coefficient for inter-rater reliability.\n\n        Args:\n            data (list of lists or numpy.ndarray): A matrix where rows represent subjects and columns represent categories.\n                                                    Each cell contains the number of raters who assigned that category to that subject.\n\n        Returns:\n            float: Fleiss' kappa coefficient. Returns NaN if the denominator is zero or if there are invalid inputs.\n\n        Raises:\n            TypeError: if input is not a list or numpy array\n            ValueError: if input data is invalid or inconsistent\n\n        >>> KappaCalculator.fleiss_kappa([[0, 0, 0, 0, 14],\n        ...                              [0, 2, 6, 4, 2],\n        ...                              [0, 0, 3, 5, 6],\n        ...                              [0, 3, 9, 2, 0],\n        ...                              [2, 2, 8, 1, 1],\n        ...                              [7, 7, 0, 0, 0],\n        ...                              [3, 2, 6, 3, 0],\n        ...                              [2, 5, 3, 2, 2],\n        ...                              [6, 5, 2, 1, 0],\n        ...                              [0, 2, 2, 3, 7]])\n        0.20993070442195522\n        \"\"\"\n        if not isinstance(data, (list, np.ndarray)):\n            raise TypeError(\"Input data must be a list or numpy array.\")\n\n        matrix = np.array(data)\n        N, k = matrix.shape\n\n        n = np.sum(matrix[0, :])\n        # Validate all rows have the same number of raters\n        for i in range(1, N):\n            if np.sum(matrix[i, :]) != n:\n                raise ValueError(\"Number of ratings per subject must be constant.\")\n\n        p_i = np.sum(matrix, axis=0) / (N * n)\n        P_i = (np.sum(matrix ** 2, axis=1) - n) / (n * (n - 1))\n        P = np.sum(P_i) / N\n        P_e = np.sum(p_i ** 2)\n\n        kappa = (P - P_e) / (1 - P_e) if (1 - P_e) != 0 else np.nan # prevent division by zero\n        return kappa\n```",
    "52": "```python\nimport nltk\nfrom nltk.stem import WordNetLemmatizer\nfrom nltk import pos_tag, word_tokenize\nimport string\n\n# Download necessary NLTK data\ntry:\n    nltk.data.find('taggers/averaged_perceptron_tagger')\nexcept LookupError:\n    nltk.download('averaged_perceptron_tagger')\n\ntry:\n    nltk.data.find('tokenizers/punkt')\nexcept LookupError:\n    nltk.download('punkt')\n\ntry:\n    nltk.data.find('corpora/wordnet')\nexcept LookupError:\n    nltk.download('wordnet')\n\n\nclass Lemmatization:\n    \"\"\"\n    A class for performing lemmatization on sentences using NLTK.\n    It includes functionality for removing punctuation, tokenizing,\n    part-of-speech tagging, and lemmatizing words based on their POS tags.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the Lemmatization class with a WordNetLemmatizer.\n        \"\"\"\n        self.lemmatizer = WordNetLemmatizer()\n\n    def remove_punctuation(self, sentence):\n        \"\"\"\n        Removes punctuation from the input sentence.\n\n        Args:\n            sentence (str): The input sentence.\n\n        Returns:\n            str: The sentence with punctuation removed.\n        \"\"\"\n        translator = str.maketrans('', '', string.punctuation)\n        return sentence.translate(translator)\n\n    def get_pos_tag(self, sentence):\n        \"\"\"\n        Tokenizes the input sentence and tags each word with its part of speech.\n\n        Args:\n            sentence (str): The input sentence.\n\n        Returns:\n            list: A list of POS tags corresponding to each word in the sentence.\n        \"\"\"\n        words = word_tokenize(self.remove_punctuation(sentence))\n        pos_tags = pos_tag(words)\n        return [tag for word, tag in pos_tags]\n\n    def lemmatize_sentence(self, sentence):\n        \"\"\"\n        Lemmatizes the words in the input sentence based on their POS tags.\n\n        Args:\n            sentence (str): The input sentence.\n\n        Returns:\n            list: A list of lemmatized words.\n        \"\"\"\n        words = word_tokenize(self.remove_punctuation(sentence))\n        pos_tags = self.get_pos_tag(sentence)\n        lemmatized_words = []\n        for word, tag in zip(words, pos_tags):\n            if tag.startswith('V'):\n                lemmatized_words.append(self.lemmatizer.lemmatize(word, pos='v'))\n            elif tag.startswith('N'):\n                lemmatized_words.append(self.lemmatizer.lemmatize(word, pos='n'))\n            elif tag.startswith('J'):\n                lemmatized_words.append(self.lemmatizer.lemmatize(word, pos='a'))\n            elif tag.startswith('R'):\n                lemmatized_words.append(self.lemmatizer.lemmatize(word, pos='r'))\n            else:\n                lemmatized_words.append(self.lemmatizer.lemmatize(word))\n        return lemmatized_words\n```",
    "53": "```python\nimport re\nimport string\n\nclass LongestWord:\n    \"\"\"\n    This is a class allows to add words to a list and find the longest word in a given sentence by comparing the words with the ones in the word list.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a list of word.\n        \"\"\"\n        self.word_list = set()  # Use a set for faster lookups\n\n    def add_word(self, word):\n        \"\"\"\n        Add the input word to the word list.\n        :param word: str, input word\n        \"\"\"\n        if isinstance(word, str):\n            self.word_list.add(word)\n        else:\n            raise TypeError(\"Word must be a string.\")\n\n\n    def find_longest_word(self, sentence):\n        \"\"\"\n        Remove punctuation marks and split a sentence into a list of word. Find the longest splited word that is in the self.word_list.\n        Words are strictly case sensitive.\n        :param sentence: a sentence str\n        :return str: longest splited word that is in the self.word_list. return '' if no matching word is found.\n        >>> longestWord = LongestWord()\n        >>> longestWord.add_word('A')\n        >>> longestWord.add_word('aM')\n        >>> longestWord.find_longest_word('I am A student.')\n        'A'\n        >>> longestWord.find_longest_word('I am a student.')\n        ''\n        \"\"\"\n        if not self.word_list:\n            return ''\n\n        # Remove punctuation and split into words\n        regex = re.compile('[%s]' % re.escape(string.punctuation))\n        words = regex.sub(' ', sentence).split()\n\n        longest_word = ''\n        for word in words:\n            if word in self.word_list:\n                if len(word) > len(longest_word):\n                    longest_word = word\n\n        return longest_word\n```",
    "54": "```python\nimport random\n\nclass MahjongConnect:\n    \"\"\"\n    MahjongConnect is a class representing a game board for Mahjong Connect with features like creating the board, checking valid moves, finding paths, removing icons, and checking if the game is over.\n    \"\"\"\n\n    def __init__(self, board_size, icons):\n        \"\"\"\n        Initialize the board size and the icon list, create the game board.\n\n        Args:\n            board_size (list): A list of two integers representing the number of rows and columns of the game board.\n            icons (list): A list of strings representing the icons.\n        \"\"\"\n        self.BOARD_SIZE = board_size\n        self.ICONS = icons\n        self.board = self.create_board()\n\n    def create_board(self):\n        \"\"\"\n        Create the game board with the given board size and icons.\n\n        Returns:\n            list: A 2-dimensional list representing the game board.\n        \"\"\"\n        rows, cols = self.BOARD_SIZE\n        num_icons = rows * cols // 2\n        if num_icons * 2 > len(self.ICONS) * (rows * cols // len(self.ICONS)):\n            raise ValueError(\"Not enough icons to fill the board.\")\n\n        icons = self.ICONS * (rows * cols // len(self.ICONS))\n        icons = icons[:num_icons] * 2\n        random.shuffle(icons)\n\n        board = []\n        for i in range(rows):\n            row = []\n            for j in range(cols):\n                row.append(icons[i * cols + j])\n            board.append(row)\n        return board\n\n    def is_valid_move(self, pos1, pos2):\n        \"\"\"\n        Check if the move of two icons is valid.\n\n        Args:\n            pos1 (tuple): A tuple (row, col) representing the position of the first icon.\n            pos2 (tuple): A tuple (row, col) representing the position of the second icon.\n\n        Returns:\n            bool: True if the move is valid, False otherwise.\n        \"\"\"\n        row1, col1 = pos1\n        row2, col2 = pos2\n        rows, cols = self.BOARD_SIZE\n\n        if not (0 <= row1 < rows and 0 <= col1 < cols and 0 <= row2 < rows and 0 <= col2 < cols):\n            return False\n\n        if pos1 == pos2:\n            return False\n\n        if self.board[row1][col1] == ' ' or self.board[row2][col2] == ' ':\n            return False\n\n        if self.board[row1][col1] != self.board[row2][col2]:\n            return False\n\n        return self.has_path(pos1, pos2)\n\n    def has_path(self, pos1, pos2):\n        \"\"\"\n        Check if there is a path between two icons with at most two turns.\n\n        Args:\n            pos1 (tuple): A tuple (row, col) representing the position of the first icon.\n            pos2 (tuple): A tuple (row, col) representing the position of the second icon.\n\n        Returns:\n            bool: True if a path exists, False otherwise.\n        \"\"\"\n        rows, cols = self.BOARD_SIZE\n\n        def is_valid(row, col):\n            return 0 <= row < rows and 0 <= col < cols\n\n        def can_reach(start_row, start_col, end_row, end_col, turns_left, visited):\n            if (start_row, start_col) == (end_row, end_col) and turns_left >= 0:\n                return True\n            if turns_left < 0:\n                return False\n            if (start_row, start_col, turns_left) in visited:\n                return False\n\n            visited.add((start_row, start_col, turns_left))\n\n            # Move horizontally\n            for col in range(start_col + 1, cols):\n                if self.board[start_row][col] != ' ' and (start_row, col) != (end_row, end_col):\n                    break\n                if can_reach(start_row, col, end_row, end_col, turns_left - 1 if (start_row,col) != pos2 and (start_row, col) != pos1 else turns_left, visited):\n                    return True\n            for col in range(start_col - 1, -1, -1):\n                if self.board[start_row][col] != ' ' and (start_row, col) != (end_row, end_col):\n                    break\n                if can_reach(start_row, col, end_row, end_col, turns_left - 1 if (start_row,col) != pos2 and (start_row, col) != pos1 else turns_left, visited):\n                    return True\n\n            # Move vertically\n            for row in range(start_row + 1, rows):\n                if self.board[row][start_col] != ' ' and (row, start_col) != (end_row, end_col):\n                    break\n                if can_reach(row, start_col, end_row, end_col, turns_left - 1 if (row,start_col) != pos2 and (row, start_col) != pos1 else turns_left, visited):\n                    return True\n            for row in range(start_row - 1, -1, -1):\n                if self.board[row][start_col] != ' ' and (row, start_col) != (end_row, end_col):\n                    break\n                if can_reach(row, start_col, end_row, end_col, turns_left - 1 if (row,start_col) != pos2 and (row, start_col) != pos1 else turns_left, visited):\n                    return True\n\n            return False\n\n        visited = set()\n        return can_reach(pos1[0], pos1[1], pos2[0], pos2[1], 2, visited)\n\n    def remove_icons(self, pos1, pos2):\n        \"\"\"\n        Remove the connected icons on the game board.\n\n        Args:\n            pos1 (tuple): A tuple (row, col) representing the position of the first icon to be removed.\n            pos2 (tuple): A tuple (row, col) representing the position of the second icon to be removed.\n        \"\"\"\n        self.board[pos1[0]][pos1[1]] = ' '\n        self.board[pos2[0]][pos2[1]] = ' '\n\n    def is_game_over(self):\n        \"\"\"\n        Check if the game is over (i.e., if there are no more icons on the game board).\n\n        Returns:\n            bool: True if the game is over, False otherwise.\n        \"\"\"\n        for row in self.board:\n            for icon in row:\n                if icon != ' ':\n                    return False\n        return True\n```",
    "55": "```python\nclass Manacher:\n    \"\"\"\n    Finds the Longest Palindromic Substring in a given string using the Manacher's algorithm.\n    \"\"\"\n\n    def __init__(self, input_string: str) -> None:\n        \"\"\"\n        Initializes the Manacher class with the given input_string.\n\n        Args:\n            input_string: The input string to be searched.\n        \"\"\"\n        self.input_string = input_string\n\n    def _preprocess_string(self) -> str:\n        \"\"\"\n        Preprocesses the input string by inserting '|' between characters and at the beginning and end.\n\n        Returns:\n            The preprocessed string.\n        \"\"\"\n        return '^' + '|'.join(list(self.input_string)) + '$'\n\n    def find_longest_palindrome(self) -> str:\n        \"\"\"\n        Finds the longest palindromic substring in the given string using Manacher's algorithm.\n\n        Returns:\n            The longest palindromic substring. Returns an empty string if the input string is empty.\n        \"\"\"\n\n        if not self.input_string:\n            return \"\"\n\n        processed_string = self._preprocess_string()\n        n = len(processed_string)\n        palindrome_radii = [0] * n  # Length of palindrome centered at each index\n        center = 0  # Center of the rightmost palindrome found so far\n        right_boundary = 0  # Right boundary of the rightmost palindrome found so far\n        max_length = 0\n        center_index = 0\n\n        for i in range(1, n - 1):\n            mirror = 2 * center - i  # Mirror index of i with respect to center\n\n            if i < right_boundary:\n                palindrome_radii[i] = min(right_boundary - i, palindrome_radii[mirror])\n\n            # Attempt to expand palindrome centered at i\n            while processed_string[i + (1 + palindrome_radii[i])] == processed_string[i - (1 + palindrome_radii[i])]:\n                palindrome_radii[i] += 1\n\n            # If palindrome centered at i expands past right_boundary, adjust center and right_boundary\n            if i + palindrome_radii[i] > right_boundary:\n                center = i\n                right_boundary = i + palindrome_radii[i]\n\n            # Update maximum palindrome length and its center\n            if palindrome_radii[i] > max_length:\n                max_length = palindrome_radii[i]\n                center_index = i\n\n        start = (center_index - max_length) // 2\n        return self.input_string[start:start + max_length]\n```",
    "56": "```python\nclass MetricsCalculator:\n    \"\"\"\n    The class calculates precision, recall, F1 score, and accuracy based on predicted and true labels.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the counts for true positives, false positives, false negatives, and true negatives.\n        \"\"\"\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n    def update(self, predicted_labels, true_labels):\n        \"\"\"\n        Update the counts of true positives, false positives, false negatives, and true negatives\n        based on the predicted and true labels.\n\n        :param predicted_labels: list, predicted results (0 or 1)\n        :param true_labels: list, true labels (0 or 1)\n        :raises ValueError: if the lengths of predicted_labels and true_labels are not equal.\n        \"\"\"\n        if len(predicted_labels) != len(true_labels):\n            raise ValueError(\"The lengths of predicted_labels and true_labels must be equal.\")\n\n        for predicted, true in zip(predicted_labels, true_labels):\n            if predicted not in (0, 1) or true not in (0, 1):\n                raise ValueError(\"predicted_labels and true_labels must contain only 0 or 1\")\n            if predicted == 1 and true == 1:\n                self.true_positives += 1\n            elif predicted == 1 and true == 0:\n                self.false_positives += 1\n            elif predicted == 0 and true == 1:\n                self.false_negatives += 1\n            else:  # predicted == 0 and true == 0\n                self.true_negatives += 1\n\n    def _calculate_precision(self):\n        \"\"\"\n        Calculate precision based on the stored counts.\n        :return: float, precision\n        \"\"\"\n        tp = self.true_positives\n        fp = self.false_positives\n        if tp + fp == 0:\n            return 0.0\n        return tp / (tp + fp)\n\n    def _calculate_recall(self):\n        \"\"\"\n        Calculate recall based on the stored counts.\n        :return: float, recall\n        \"\"\"\n        tp = self.true_positives\n        fn = self.false_negatives\n        if tp + fn == 0:\n            return 0.0\n        return tp / (tp + fn)\n\n    def _calculate_accuracy(self):\n        \"\"\"\n        Calculate accuracy based on the stored counts.\n        :return: float, accuracy\n        \"\"\"\n        correct = self.true_positives + self.true_negatives\n        total = self.true_positives + self.false_positives + self.false_negatives + self.true_negatives\n        if total == 0:\n            return 0.0\n        return correct / total\n\n    def precision(self):\n        \"\"\"\n        Calculate precision using the accumulated counts.\n        :return: float, precision\n        \"\"\"\n        return self._calculate_precision()\n\n    def recall(self):\n        \"\"\"\n        Calculate recall using the accumulated counts.\n        :return: float, recall\n        \"\"\"\n        return self._calculate_recall()\n\n    def f1_score(self):\n        \"\"\"\n        Calculate F1 score, the harmonic mean of precision and recall, using the accumulated counts.\n        :return: float, F1 score\n        \"\"\"\n        precision_val = self._calculate_precision()\n        recall_val = self._calculate_recall()\n        if precision_val + recall_val == 0:\n            return 0.0\n        return 2 * (precision_val * recall_val) / (precision_val + recall_val)\n\n    def accuracy(self):\n        \"\"\"\n        Calculate accuracy using the accumulated counts.\n        :return: float, accuracy\n        \"\"\"\n        return self._calculate_accuracy()\n```",
    "57": "```python\nimport numpy as np\n\n\nclass MetricsCalculator2:\n    \"\"\"\n    The class provides to calculate Mean Reciprocal Rank (MRR) and Mean Average Precision (MAP) based on input data, where MRR measures the ranking quality and MAP measures the average precision.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def mrr(data):\n        \"\"\"\n        Compute the Mean Reciprocal Rank (MRR) of the input data.\n\n        Args:\n            data: A tuple or list of tuples. Each tuple contains:\n                - result: A list or numpy array of 1s and 0s, where 1 indicates a correct answer and 0 indicates a wrong answer.\n                - ground_truth_num: The total number of relevant items.\n\n        Returns:\n            A tuple containing:\n                - The mean MRR across all input tuples.\n                - A list of MRR values for each input tuple. Returns (0.0, []) if input data is invalid or empty.\n        \"\"\"\n        if not data:\n            return 0.0, []\n\n        if isinstance(data, tuple):\n            data = [data]\n\n        if not isinstance(data, list):\n            print(\"Warning: Input data should be a tuple or a list of tuples.\")\n            return 0.0, []\n\n        rr_list = []\n        for item in data:\n            if not isinstance(item, tuple) or len(item) != 2:\n                print(\"Warning: Each item in the list should be a tuple of (result, ground_truth_num).\")\n                return 0.0, []\n\n            result, ground_truth_num = item\n\n            if not isinstance(result, (list, np.ndarray)):\n                print(\"Warning: Result should be a list or numpy array.\")\n                return 0.0, []\n\n            if not all(r in [0, 1] for r in result):\n                print(\"Warning: Result should contain only 0s and 1s.\")\n                return 0.0, []\n\n            if not isinstance(ground_truth_num, int):\n                print(\"Warning: ground_truth_num should be an integer.\")\n                return 0.0, []\n\n            rr = 0\n            for i, r in enumerate(result):\n                if r == 1:\n                    rr = 1 / (i + 1)\n                    break\n            rr_list.append(rr)\n\n        return np.mean(rr_list) if rr_list else 0.0, rr_list\n\n    @staticmethod\n    def map(data):\n        \"\"\"\n        Compute the Mean Average Precision (MAP) of the input data.\n\n        Args:\n            data: A tuple or list of tuples. Each tuple contains:\n                - result: A list or numpy array of 1s and 0s, where 1 indicates a correct answer and 0 indicates a wrong answer.\n                - ground_truth_num: The total number of relevant items.\n\n        Returns:\n            A tuple containing:\n                - The mean MAP across all input tuples.\n                - A list of MAP values for each input tuple.\n        \"\"\"\n        if not data:\n            return 0.0, []\n\n        if isinstance(data, tuple):\n            data = [data]\n\n        if not isinstance(data, list):\n            print(\"Warning: Input data should be a tuple or a list of tuples.\")\n            return (0.0, [])\n\n        ap_list = []\n        for item in data:\n            if not isinstance(item, tuple) or len(item) != 2:\n                print(\"Warning: Each item in the list should be a tuple of (result, ground_truth_num).\")\n                return (0.0, [])\n\n            result, ground_truth_num = item\n\n            if not isinstance(result, (list, np.ndarray)):\n                print(\"Warning: Result should be a list or numpy array.\")\n                return (0.0, [])\n\n            if not all(r in [0, 1] for r in result):\n                print(\"Warning: Result should contain only 0s and 1s.\")\n                return (0.0, [])\n\n            if not isinstance(ground_truth_num, int):\n                print(\"Warning: ground_truth_num should be an integer.\")\n                return (0.0, [])\n            \n            if ground_truth_num < 0:\n                print(\"Warning: ground_truth_num should be non-negative.\")\n                return (0.0, [])\n\n            precision_sum = 0\n            correct_count = 0\n            for i, r in enumerate(result):\n                if r == 1:\n                    correct_count += 1\n                    precision_sum += correct_count / (i + 1)\n\n            if ground_truth_num > 0:\n                ap = precision_sum / ground_truth_num\n            else:\n                ap = 0.0\n            ap_list.append(ap)\n\n        return np.mean(ap_list) if ap_list else 0.0, ap_list\n```",
    "58": "```python\nimport random\n\nclass MinesweeperGame:\n    \"\"\"\n    Implements a Minesweeper game with mine placement, sweeping, and win condition checking.\n    \"\"\"\n\n    def __init__(self, n, k):\n        \"\"\"\n        Initializes the game board and mine positions.\n\n        Args:\n            n (int): The size of the board (n x n).\n            k (int): The number of mines to place.\n        Raises:\n            ValueError: If k is greater than or equal to n*n\n        \"\"\"\n        if k >= n * n:\n            raise ValueError(\"Number of mines cannot exceed the number of cells.\")\n\n        self.n = n\n        self.k = k\n        self.minesweeper_map = self._generate_mine_sweeper_map()\n        self.player_map = self._generate_player_map()\n        self.score = 0\n        self.game_over = False\n\n    def _generate_mine_sweeper_map(self):\n        \"\"\"\n        Generates the hidden minesweeper map with mines and adjacent mine counts.\n        \"\"\"\n        mine_map = [[0 for _ in range(self.n)] for _ in range(self.n)]\n        mines_placed = 0\n        while mines_placed < self.k:\n            x = random.randint(0, self.n - 1)\n            y = random.randint(0, self.n - 1)\n            if mine_map[x][y] == 0:\n                mine_map[x][y] = 'X'\n                mines_placed += 1\n\n        for i in range(self.n):\n            for j in range(self.n):\n                if mine_map[i][j] == 'X':\n                    continue\n                count = 0\n                for row in range(max(0, i - 1), min(self.n, i + 2)):\n                    for col in range(max(0, j - 1), min(self.n, j + 2)):\n                        if mine_map[row][col] == 'X':\n                            count += 1\n                mine_map[i][j] = count\n        return mine_map\n\n    def _generate_player_map(self):\n        \"\"\"\n        Generates the player's view of the board, initially filled with hidden cells.\n        \"\"\"\n        return [['-' for _ in range(self.n)] for _ in range(self.n)]\n\n    def check_won(self):\n        \"\"\"\n        Checks if the player has won the game.\n        \"\"\"\n        revealed_count = 0\n        for i in range(self.n):\n            for j in range(self.n):\n                if self.player_map[i][j] != '-':\n                    revealed_count += 1\n        return revealed_count == self.n * self.n - self.k\n\n    def sweep(self, x, y):\n        \"\"\"\n        Sweeps a cell on the board.\n\n        Args:\n            x (int): The row index of the cell to sweep.\n            y (int): The column index of the cell to sweep.\n\n        Returns:\n            bool: True if the game is won, False if game is lost (hit a mine), None if the game continues.\n        Raises:\n            IndexError: If x or y are out of bounds.\n            ValueError: If the cell has already been revealed.\n        \"\"\"\n        if not (0 <= x < self.n and 0 <= y < self.n):\n            raise IndexError(\"Coordinates are out of bounds.\")\n\n        if self.player_map[x][y] != '-':\n            raise ValueError(\"Cell already revealed.\")\n\n        if self.minesweeper_map[x][y] == 'X':\n            self.player_map[x][y] = 'X'  # Reveal the mine\n            self.game_over = True\n            return False  # Game over, player hit a mine\n        else:\n            self._reveal_cell(x, y)\n            if self.check_won():\n                return True  # Game won\n            else:\n                return None # Game continues\n\n    def _reveal_cell(self, x, y):\n        \"\"\"\n        Reveals a cell and recursively reveals adjacent empty cells.\n        \"\"\"\n        if not (0 <= x < self.n and 0 <= y < self.n) or self.player_map[x][y] != '-':\n            return  # Base case: out of bounds or already revealed\n\n        self.player_map[x][y] = self.minesweeper_map[x][y]\n\n        if self.minesweeper_map[x][y] == 0:\n            # Recursively reveal adjacent cells\n            for row in range(max(0, x - 1), min(self.n, x + 2)):\n                for col in range(max(0, y - 1), min(self.n, y + 2)):\n                    if row != x or col != y:\n                        self._reveal_cell(row, col)\n\n    def print_board(self, show_mines=False):\n        \"\"\"Prints the current state of the game board.\"\"\"\n        board = self.minesweeper_map if show_mines else self.player_map\n        for row in board:\n            print(' '.join(map(str, row)))\n```",
    "59": "```python\nfrom datetime import datetime\nimport numpy as np\n\nclass MovieBookingSystem:\n    \"\"\"\n    A class representing a movie booking system.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the movie booking system with an empty list of movies.\n        \"\"\"\n        self.movies = []\n\n    def add_movie(self, name, price, start_time, end_time, n):\n        \"\"\"\n        Adds a new movie to the system.\n\n        Args:\n            name (str): The name of the movie.\n            price (float): The price of a movie ticket.\n            start_time (str): The start time of the movie in HH:MM format (e.g., \"17:05\").\n            end_time (str): The end time of the movie in HH:MM format (e.g., \"19:25\").\n            n (int): The size of the square seating arrangement (n x n).\n        \"\"\"\n        try:\n            start_time_dt = datetime.strptime(start_time, '%H:%M').time()\n            end_time_dt = datetime.strptime(end_time, '%H:%M').time()\n        except ValueError:\n            raise ValueError(\"Invalid time format. Please use HH:MM.\")\n\n        # Create datetime objects with a default date (1900-01-01) for time comparisons\n        start_datetime = datetime.combine(datetime(1900, 1, 1), start_time_dt)\n        end_datetime = datetime.combine(datetime(1900, 1, 1), end_time_dt)\n\n        if end_datetime <= start_datetime:\n            raise ValueError(\"End time must be later than start time.\")\n\n        self.movies.append({\n            'name': name,\n            'price': price,\n            'start_time': start_datetime,\n            'end_time': end_datetime,\n            'seats': np.zeros((n, n), dtype=int)  # Use integers for seat representation (0: available, 1: booked)\n        })\n\n    def book_ticket(self, movie_name, seats_to_book):\n        \"\"\"\n        Books tickets for a specified movie.\n\n        Args:\n            movie_name (str): The name of the movie to book tickets for.\n            seats_to_book (list of tuples): A list of (row, col) tuples representing the seats to book.\n\n        Returns:\n            str: A message indicating the booking status (\"Booking success.\", \"Booking failed.\", or \"Movie not found.\").\n        \"\"\"\n        for movie in self.movies:\n            if movie['name'] == movie_name:\n                seats = movie['seats']\n                rows, cols = seats.shape\n                for row, col in seats_to_book:\n                    if not (0 <= row < rows and 0 <= col < cols):\n                        return \"Booking failed. Invalid seat coordinates.\"\n\n                # Check if any of the seats are already booked\n                if any(seats[row, col] == 1 for row, col in seats_to_book):\n                    return \"Booking failed. Some seats are already booked.\"\n\n                # Book the seats\n                for row, col in seats_to_book:\n                    seats[row, col] = 1\n                return \"Booking success.\"\n\n        return \"Movie not found.\"\n\n    def available_movies(self, start_time, end_time):\n        \"\"\"\n        Retrieves a list of movies that are playing within a given time range.\n\n        Args:\n            start_time (str): The start time of the time range in HH:MM format (e.g., \"12:00\").\n            end_time (str): The end time of the time range in HH:MM format (e.g., \"22:00\").\n\n        Returns:\n            list of str: A list of movie names that are playing within the specified time range.\n        \"\"\"\n        try:\n            start_time_dt = datetime.strptime(start_time, '%H:%M').time()\n            end_time_dt = datetime.strptime(end_time, '%H:%M').time()\n        except ValueError:\n            raise ValueError(\"Invalid time format. Please use HH:MM.\")\n\n        start_datetime = datetime.combine(datetime(1900, 1, 1), start_time_dt)\n        end_datetime = datetime.combine(datetime(1900, 1, 1), end_time_dt)\n\n        available_movies_list = []\n        for movie in self.movies:\n            if movie['start_time'] <= end_datetime and movie['end_time'] >= start_datetime:\n                available_movies_list.append(movie['name'])\n        return available_movies_list\n\nif __name__ == '__main__':\n    system = MovieBookingSystem()\n    system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n    print(system.movies)\n    print(system.book_ticket('Batman', [(0, 0), (0, 1)]))\n    print(system.book_ticket('Batman', [(0, 0)]))\n    print(system.book_ticket('batman', [(0, 0)]))\n    print(system.available_movies('12:00', '22:00'))\n```",
    "60": "```python\nimport sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information, searching for movie information by name, and deleting movie information by name.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.db_name = db_name\n        self.connection = None\n        self.cursor = None\n        self.connect()\n        self.create_table()\n\n\n    def connect(self):\n        \"\"\"\n        Establishes a connection to the SQLite database.\n        \"\"\"\n        try:\n            self.connection = sqlite3.connect(self.db_name)\n            self.cursor = self.connection.cursor()\n        except sqlite3.Error as e:\n            print(f\"Database connection error: {e}\")\n            raise\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        if self.connection:\n            self.connection.close()\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.Fields include ID of type int, movie name of type str, theater name of type str, seat number of type str, and customer name of type str\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS tickets (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    movie_name TEXT NOT NULL,\n                    theater_name TEXT NOT NULL,\n                    seat_number TEXT NOT NULL,\n                    customer_name TEXT NOT NULL\n                )\n            \"\"\")\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error during table creation: {e}\")\n            raise\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute(\"\"\"\n                INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n                VALUES (?, ?, ?, ?)\n            \"\"\", (movie_name, theater_name, seat_number, customer_name))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error during ticket insertion: {e}\")\n            raise\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        \"\"\"\n        try:\n            self.cursor.execute(\"\"\"\n                SELECT * FROM tickets\n                WHERE customer_name = ?\n            \"\"\", (customer_name,))\n            return self.cursor.fetchall()\n        except sqlite3.Error as e:\n            print(f\"Database error during ticket search: {e}\")\n            raise\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute(\"\"\"\n                DELETE FROM tickets\n                WHERE id = ?\n            \"\"\", (ticket_id,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error during ticket deletion: {e}\")\n            raise\n\n    def __enter__(self):\n        \"\"\"\n        Context management entry.\n        \"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"\n        Context management exit. Closes the connection.\n        \"\"\"\n        if self.connection:\n            self.close()\n```",
    "61": "```python\nimport random\n\nclass MusicPlayer:\n    \"\"\"\n    A class representing a music player.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the music player with an empty playlist, no current song, and a default volume of 50.\n        \"\"\"\n        self.playlist = []\n        self.current_song = None\n        self.volume = 50\n        self.is_playing = False\n\n    def add_song(self, song):\n        \"\"\"\n        Adds a song to the playlist.\n        :param song: The song to add to the playlist (string).\n        \"\"\"\n        if isinstance(song, str):\n            self.playlist.append(song)\n        else:\n            raise TypeError(\"Song must be a string.\")\n\n    def remove_song(self, song):\n        \"\"\"\n        Removes a song from the playlist.\n        :param song: The song to remove from the playlist (string).\n        \"\"\"\n        try:\n            self.playlist.remove(song)\n            if self.current_song == song:\n                self.stop()\n        except ValueError:\n            print(f\"Song '{song}' not found in playlist.\")\n\n    def play(self, song=None):\n        \"\"\"\n        Plays a specific song or resumes the current song.\n        :param song: The song to play (string, optional). If None, resumes the current song.\n        :return: True if playback started, False otherwise.\n        \"\"\"\n        if song:\n            if song in self.playlist:\n                self.current_song = song\n                self.is_playing = True\n                return True\n            else:\n                print(f\"Song '{song}' not found in playlist.\")\n                return False\n        elif self.current_song:\n            self.is_playing = True\n            return True\n        else:\n            if self.playlist:\n                self.current_song = self.playlist[0]\n                self.is_playing = True\n                return True\n            else:\n                print(\"Playlist is empty.\")\n                return False\n\n    def stop(self):\n        \"\"\"\n        Stops the current song.\n        :return: True if the song was stopped, False otherwise.\n        \"\"\"\n        if self.is_playing:\n            self.is_playing = False\n            return True\n        else:\n            return False\n\n    def switch_song(self):\n        \"\"\"\n        Switches to the next song in the playlist.\n        :return: True if a song was switched to, False otherwise.\n        \"\"\"\n        if not self.playlist:\n            print(\"Playlist is empty.\")\n            return False\n\n        if not self.current_song:\n            return self.play()\n\n        try:\n            current_index = self.playlist.index(self.current_song)\n            next_index = (current_index + 1) % len(self.playlist)\n            self.current_song = self.playlist[next_index]\n            self.is_playing = True\n            return True\n        except ValueError:  # Should not happen if current_song is managed correctly\n            return self.play()\n\n    def previous_song(self):\n        \"\"\"\n        Switches to the previous song in the playlist.\n        :return: True if a song was switched to, False otherwise.\n        \"\"\"\n        if not self.playlist:\n            print(\"Playlist is empty.\")\n            return False\n\n        if not self.current_song:\n            return self.play()\n\n        try:\n            current_index = self.playlist.index(self.current_song)\n            previous_index = (current_index - 1) % len(self.playlist)\n            self.current_song = self.playlist[previous_index]\n            self.is_playing = True\n            return True\n        except ValueError:  # Should not happen if current_song is managed correctly\n            return self.play()\n\n    def set_volume(self, volume):\n        \"\"\"\n        Sets the volume of the music player.\n        :param volume: The volume to set (integer between 0 and 100).\n        :return: True if the volume was set, False otherwise.\n        \"\"\"\n        if isinstance(volume, int) and 0 <= volume <= 100:\n            self.volume = volume\n            return True\n        else:\n            print(\"Invalid volume. Volume must be an integer between 0 and 100.\")\n            return False\n\n    def shuffle(self):\n        \"\"\"\n        Shuffles the playlist.\n        :return: True if the playlist was shuffled, False otherwise.\n        \"\"\"\n        if self.playlist:\n            random.shuffle(self.playlist)\n            return True\n        else:\n            print(\"Playlist is empty.\")\n            return False\n\n    def get_current_song(self):\n        \"\"\"\n        Returns the currently playing song.\n        :return: The current song (string) or None if no song is playing.\n        \"\"\"\n        return self.current_song\n\n    def get_playlist(self):\n        \"\"\"\n        Returns a copy of the current playlist.\n        :return: A list of strings representing the playlist.\n        \"\"\"\n        return self.playlist[:] # Return a copy to prevent external modification\n\n    def is_currently_playing(self):\n        \"\"\"\n        Returns the playing status\n        :return: boolean\n        \"\"\"\n        return self.is_playing\n```",
    "62": "```python\nclass NLPDataProcessor:\n    \"\"\"\n    The class processes NLP data by removing stop words from a list of strings using a pre-defined stop word list.\n    \"\"\"\n\n    def __init__(self, stop_words=None):\n        \"\"\"\n        Initializes the NLPDataProcessor with an optional custom stop word list.\n        If no stop words are provided, the default list ['a', 'an', 'the'] is used.\n        \"\"\"\n        if stop_words is None:\n            self.stop_words = ['a', 'an', 'the']\n        else:\n            self.stop_words = stop_words\n\n    def construct_stop_word_list(self):\n        \"\"\"\n        Returns the stop word list.  This method is now largely redundant,\n        but kept for backwards compatibility, returning the initialized stop words.\n        :return: a list of stop words\n        >>> processor = NLPDataProcessor()\n        >>> processor.construct_stop_word_list()\n        ['a', 'an', 'the']\n        \"\"\"\n        return self.stop_words\n\n    def remove_stop_words(self, string_list):\n        \"\"\"\n        Remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :return: a list of lists of words without stop words\n        >>> processor = NLPDataProcessor()\n        >>> processor.remove_stop_words(['This is a test.'])\n        [['This', 'is', 'test.']]\n        >>> processor.remove_stop_words(['This is a test a an the.'])\n        [['This', 'is', 'test']]\n        \"\"\"\n        result = []\n        for string in string_list:\n            words = string.split()\n            filtered_words = [word for word in words if word.lower() not in self.stop_words]\n            result.append(filtered_words)\n        return result\n\n    def process(self, string_list):\n        \"\"\"\n        Removes stop words from a list of strings using the processor's stop word list.\n        :param string_list: a list of strings\n        :return: a list of lists of words without stop words\n        >>> processor = NLPDataProcessor()\n        >>> processor.process(['This is a test.'])\n        [['This', 'is', 'test.']]\n        >>> processor = NLPDataProcessor(stop_words=['is', 'a'])\n        >>> processor.process(['This is a test.'])\n        [['This', 'test.']]\n        \"\"\"\n        return self.remove_stop_words(string_list)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n```",
    "63": "```python\nimport re\nfrom collections import Counter\nfrom typing import List, Dict\n\nclass NLPDataProcessor2:\n    \"\"\"\n    The class processes NLP data by extracting words from a list of strings,\n    calculating the frequency of each word, and returning the top N most frequent words.\n    \"\"\"\n\n    def __init__(self, top_n: int = 5):\n        \"\"\"\n        Initializes the NLPDataProcessor2 with the desired number of top words to return.\n\n        :param top_n: The number of top frequent words to return. Defaults to 5.\n        \"\"\"\n        self.top_n = top_n\n\n    def process_data(self, string_list: List[str]) -> List[List[str]]:\n        \"\"\"\n        Cleans and tokenizes a list of strings.\n\n        Keeps only English letters and spaces in the string, then converts the string\n        to lower case, and then splits the string into a list of words.\n\n        :param string_list: A list of strings.\n        :return: A list of lists of words.\n        \"\"\"\n        words_list = []\n        for string in string_list:\n            cleaned_string = re.sub(r'[^a-zA-Z\\s]', '', string)\n            cleaned_string = cleaned_string.lower()\n            words = cleaned_string.split()\n            words_list.append(words)\n        return words_list\n\n    def calculate_word_frequency(self, words_list: List[List[str]]) -> Dict[str, int]:\n        \"\"\"\n        Calculates the word frequency of each word in the list of word lists.\n\n        :param words_list: A list of lists of words.\n        :return: A dictionary of word frequencies, where the key is the word and the value is its frequency.\n        \"\"\"\n        word_counts = Counter()\n        for words in words_list:\n            word_counts.update(words)\n        return dict(word_counts)\n\n    def get_top_n_words(self, word_frequency: Dict[str, int]) -> Dict[str, int]:\n        \"\"\"\n        Returns the top N most frequent words from a word frequency dictionary.\n\n        :param word_frequency: A dictionary of word frequencies.\n        :return: A dictionary containing the top N most frequent words and their frequencies.\n        \"\"\"\n        sorted_words = sorted(word_frequency.items(), key=lambda item: item[1], reverse=True)\n        return dict(sorted_words[:self.top_n])\n\n    def process(self, string_list: List[str]) -> Dict[str, int]:\n        \"\"\"\n        Processes a list of strings to extract, clean, and count word frequencies,\n        then returns the top N most frequent words.\n\n        :param string_list: A list of strings to process.\n        :return: A dictionary containing the top N most frequent words and their frequencies.\n        \"\"\"\n        words_list = self.process_data(string_list)\n        word_frequency = self.calculate_word_frequency(words_list)\n        top_words = self.get_top_n_words(word_frequency)\n        return top_words\n```",
    "64": "```python\nclass NumberConverter:\n    \"\"\"\n    The class allows to convert decimal to binary, octal, and hexadecimal respectively, and vice versa.\n    \"\"\"\n\n    @staticmethod\n    def decimal_to_binary(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to binary format.\n        :param decimal_num: int, decimal number\n        :return: str, the binary representation of an integer.\n        :raises TypeError: if input is not an integer.\n        :raises ValueError: if input is a negative integer.\n        >>> NumberConverter.decimal_to_binary(42423)\n        '1010010110110111'\n        \"\"\"\n        if not isinstance(decimal_num, int):\n            raise TypeError(\"Input must be an integer.\")\n        if decimal_num < 0:\n            raise ValueError(\"Input must be a non-negative integer.\")\n\n        return bin(decimal_num)[2:]\n\n    @staticmethod\n    def binary_to_decimal(binary_num):\n        \"\"\"\n        Convert a number from binary format to decimal format.\n        :param binary_num: str, binary number\n        :return: int, the decimal representation of binary number str.\n        :raises TypeError: if input is not a string.\n        :raises ValueError: if input is not a valid binary string.\n        >>> NumberConverter.binary_to_decimal('1010010110110111')\n        42423\n        \"\"\"\n        if not isinstance(binary_num, str):\n            raise TypeError(\"Input must be a string.\")\n        if not all(bit in '01' for bit in binary_num):\n            raise ValueError(\"Input must be a valid binary string.\")\n\n        return int(binary_num, 2)\n\n    @staticmethod\n    def decimal_to_octal(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to octal format.\n        :param decimal_num: int, decimal number\n        :return: str, the octal representation of an integer.\n        :raises TypeError: if input is not an integer.\n        :raises ValueError: if input is a negative integer.\n        >>> NumberConverter.decimal_to_octal(42423)\n        '122667'\n        \"\"\"\n        if not isinstance(decimal_num, int):\n            raise TypeError(\"Input must be an integer.\")\n        if decimal_num < 0:\n            raise ValueError(\"Input must be a non-negative integer.\")\n\n        return oct(decimal_num)[2:]\n\n    @staticmethod\n    def octal_to_decimal(octal_num):\n        \"\"\"\n        Convert a number from octal format to decimal format.\n        :param octal_num: str, octal num\n        :return: int, the decimal representation of octal number str.\n        :raises TypeError: if input is not a string.\n        :raises ValueError: if input is not a valid octal string.\n        >>> NumberConverter.octal_to_decimal('122667')\n        42423\n        \"\"\"\n        if not isinstance(octal_num, str):\n            raise TypeError(\"Input must be a string.\")\n        if not all(digit in '01234567' for digit in octal_num):\n            raise ValueError(\"Input must be a valid octal string.\")\n\n        return int(octal_num, 8)\n\n    @staticmethod\n    def decimal_to_hex(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to hex format.\n        :param decimal_num: int, decimal number\n        :return hex_num: str, the hex representation of an integer.\n        :raises TypeError: if input is not an integer.\n        :raises ValueError: if input is a negative integer.\n        >>> NumberConverter.decimal_to_hex(42423)\n        'a5b7'\n        \"\"\"\n        if not isinstance(decimal_num, int):\n            raise TypeError(\"Input must be an integer.\")\n        if decimal_num < 0:\n            raise ValueError(\"Input must be a non-negative integer.\")\n\n        return hex(decimal_num)[2:]\n\n    @staticmethod\n    def hex_to_decimal(hex_num):\n        \"\"\"\n        Convert a number from hex format to decimal format.\n        :param hex_num: str, hex num\n        :return: int, the decimal representation of hex number str.\n        :raises TypeError: if input is not a string.\n        :raises ValueError: if input is not a valid hexadecimal string.\n        >>> NumberConverter.hex_to_decimal('a5b7')\n        42423\n        \"\"\"\n        if not isinstance(hex_num, str):\n            raise TypeError(\"Input must be a string.\")\n        if not all(digit in '0123456789abcdefABCDEF' for digit in hex_num):\n            raise ValueError(\"Input must be a valid hexadecimal string.\")\n\n        return int(hex_num, 16)\n```",
    "65": "```python\nclass NumberWordFormatter:\n    \"\"\"\n    Converts numbers into their corresponding English word representation.\n    Handles integer parts, and incorporates appropriate connectors and units.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize NumberWordFormatter object.\"\"\"\n        self.NUMBER = [\"\", \"ONE\", \"TWO\", \"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\"]\n        self.NUMBER_TEEN = [\"TEN\", \"ELEVEN\", \"TWELVE\", \"THIRTEEN\", \"FOURTEEN\", \"FIFTEEN\", \"SIXTEEN\", \"SEVENTEEN\",\n                            \"EIGHTEEN\", \"NINETEEN\"]\n        self.NUMBER_TEN = [\"TEN\", \"TWENTY\", \"THIRTY\", \"FORTY\", \"FIFTY\", \"SIXTY\", \"SEVENTY\", \"EIGHTY\", \"NINETY\"]\n        self.NUMBER_MORE = [\"\", \"THOUSAND\", \"MILLION\", \"BILLION\"]  # Up to billions\n        self.AND = \"AND\"\n        self.ONLY = \"ONLY\"\n        self.HUNDRED = \"HUNDRED\"\n        self.ZERO = \"ZERO\"\n\n    def format(self, x):\n        \"\"\"\n        Converts a number into words format.\n\n        Args:\n            x: int or float, the number to be converted into words format.  Only integer part is considered.\n\n        Returns:\n            str, the number in words format. Returns \"Invalid input\" if input is not an integer or float.\n\n        Examples:\n            >>> formatter = NumberWordFormatter()\n            >>> formatter.format(123456)\n            'ONE HUNDRED AND TWENTY THREE THOUSAND FOUR HUNDRED AND FIFTY SIX ONLY'\n            >>> formatter.format(0)\n            'ZERO ONLY'\n            >>> formatter.format(1234567890)\n            'ONE BILLION TWO HUNDRED AND THIRTY FOUR MILLION FIVE HUNDRED AND SIXTY SEVEN THOUSAND EIGHT HUNDRED AND NINETY ONLY'\n        \"\"\"\n        if not isinstance(x, (int, float)):\n            return \"Invalid input\"\n\n        x = int(x)  # Consider only the integer part\n\n        if x == 0:\n            return f\"{self.ZERO} {self.ONLY}\"\n\n        if x < 0:\n            return \"Invalid input: Cannot convert negative numbers\"\n\n        result = []\n        i = 0\n        while x > 0:\n            n = x % 1000\n            if n != 0:\n                words = self._trans_three(n)\n                if i > 0:  # Add magnitude only if the chunk is not zero\n                    words += f\" {self.NUMBER_MORE[i]}\"\n                result.append(words)\n            x //= 1000\n            i += 1\n\n        result.reverse()\n        return \" \".join(result).strip() + f\" {self.ONLY}\"\n\n    def format_string(self, x):\n        \"\"\"\n        Converts a string representation of a number into words format.\n\n        Args:\n            x: str, the string representation of a number\n\n        Returns:\n            str, the number in words format. Returns \"Invalid input\" if the string does not represent a valid integer.\n\n        Examples:\n            >>> formatter = NumberWordFormatter()\n            >>> formatter.format_string(\"123456\")\n            'ONE HUNDRED AND TWENTY THREE THOUSAND FOUR HUNDRED AND FIFTY SIX ONLY'\n            >>> formatter.format_string(\"abc\")\n            'Invalid input: Not a valid number string'\n        \"\"\"\n        try:\n            num = int(x)\n            return self.format(num)\n        except ValueError:\n            return \"Invalid input: Not a valid number string\"\n\n    def _trans_two(self, n):\n        \"\"\"\n        Converts a two-digit number (0-99) into words.  Private helper function.\n\n        Args:\n            n: int, the two-digit number\n\n        Returns:\n            str, the number in words format\n\n        Examples:\n            >>> formatter = NumberWordFormatter()\n            >>> formatter._trans_two(23)\n            'TWENTY THREE'\n            >>> formatter._trans_two(9)\n            'NINE'\n            >>> formatter._trans_two(10)\n            'TEN'\n            >>> formatter._trans_two(19)\n            'NINETEEN'\n        \"\"\"\n        if n < 10:\n            return self.NUMBER[n]\n        elif 10 <= n <= 19:\n            return self.NUMBER_TEEN[n - 10]\n        else:\n            tens = n // 10\n            ones = n % 10\n            if ones == 0:\n                return self.NUMBER_TEN[tens - 1]\n            else:\n                return f\"{self.NUMBER_TEN[tens - 1]} {self.NUMBER[ones]}\"\n\n    def _trans_three(self, n):\n        \"\"\"\n        Converts a three-digit number (0-999) into words. Private helper function.\n\n        Args:\n            n: int, the three-digit number\n\n        Returns:\n            str, the number in words format\n\n        Examples:\n            >>> formatter = NumberWordFormatter()\n            >>> formatter._trans_three(123)\n            'ONE HUNDRED AND TWENTY THREE'\n            >>> formatter._trans_three(100)\n            'ONE HUNDRED'\n            >>> formatter._trans_three(5)\n            'FIVE'\n        \"\"\"\n        hundreds = n // 100\n        remainder = n % 100\n\n        words = []\n        if hundreds > 0:\n            words.append(f\"{self.NUMBER[hundreds]} {self.HUNDRED}\")\n\n        if remainder > 0:\n            if hundreds > 0:\n                words.append(self.AND)\n            words.append(self._trans_two(remainder))\n\n        return \" \".join(words)\n```",
    "66": "```python\nimport re\n\nclass NumericEntityUnescaper:\n    \"\"\"\n    Replaces numeric character references (HTML entities) in a string with their corresponding Unicode characters.\n    \"\"\"\n\n    def replace(self, string):\n        \"\"\"\n        Replaces numeric character references (HTML entities) in the input string with their corresponding Unicode characters.\n\n        Args:\n            string: The input string containing numeric character references.\n\n        Returns:\n            The input string with numeric character references replaced with their corresponding Unicode characters.\n        \"\"\"\n\n        def replace_entity(match):\n            entity = match.group(1)\n            try:\n                if entity.startswith('x'):\n                    cp = int(entity[1:], 16)\n                else:\n                    cp = int(entity, 10)\n\n                # Check for valid Unicode code points\n                if 0 <= cp <= 0x10FFFF:\n                    return chr(cp)\n                else:\n                    return match.group(0)  # Return original entity if invalid\n\n            except ValueError:\n                return match.group(0)  # Return original entity if conversion fails\n\n        return re.sub(r\"&#(x?[0-9a-fA-F]+);\", replace_entity, string)\n\n\n    @staticmethod\n    def is_hex_char(char):\n        \"\"\"\n        Checks if a character is a hexadecimal digit.\n\n        Args:\n            char: The character to check.\n\n        Returns:\n            True if the character is a hexadecimal digit, False otherwise.\n        \"\"\"\n        return '0' <= char <= '9' or 'a' <= char <= 'f' or 'A' <= char <= 'F'\n```",
    "67": "```python\nclass Order:\n    \"\"\"\n    Manages restaurant orders, including adding dishes, calculating the total cost, and checkout.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the order management system.\n\n        - `self.menu`: A list of dictionaries, where each dictionary represents a dish in the restaurant's inventory.\n          Each dish dictionary has the following keys: \"dish\" (dish name), \"price\" (price), and \"count\" (available count).\n          Example: `[{\"dish\": \"dish1\", \"price\": 10, \"count\": 5}, ...]`\n\n        - `self.selected_dishes`: A list of dictionaries, where each dictionary represents a dish selected by the customer.\n          Each selected dish dictionary has the following keys: \"dish\" (dish name), \"count\" (quantity ordered), and \"price\" (price).\n          Example: `[{\"dish\": \"dish1\", \"count\": 2, \"price\": 10}, ...]`\n\n        - `self.sales`: A dictionary storing the sales percentage for each dish.\n          Example: `{\"dish1\": 0.8, \"dish2\": 0.9}` (80% and 90% of original price respectively)\n        \"\"\"\n        self.menu = []\n        self.selected_dishes = []\n        self.sales = {}\n\n    def add_dish(self, dish):\n        \"\"\"\n        Adds a dish to the order if it's available in the menu and the requested quantity is valid.\n\n        Args:\n            dish (dict): A dictionary containing the information about the dish to add.\n                         It should have the following keys: \"dish\" (dish name), \"count\" (quantity to add), and \"price\" (price).\n\n        Returns:\n            bool: True if the dish was successfully added to the order, False otherwise (e.g., not enough stock).\n        \"\"\"\n        dish_name = dish[\"dish\"]\n        dish_count = dish[\"count\"]\n        dish_price = dish[\"price\"]\n\n        for item in self.menu:\n            if item[\"dish\"] == dish_name:\n                if item[\"count\"] >= dish_count:\n                    item[\"count\"] -= dish_count\n                    self.selected_dishes.append({\"dish\": dish_name, \"count\": dish_count, \"price\": dish_price})\n                    return True\n                else:\n                    return False  # Not enough stock\n        return False  # Dish not found in menu\n\n    def calculate_total(self):\n        \"\"\"\n        Calculates the total price of the dishes in the order, taking into account any sales discounts.\n\n        Returns:\n            float: The total price of the order.\n        \"\"\"\n        total = 0.0\n        for dish in self.selected_dishes:\n            dish_name = dish[\"dish\"]\n            price = dish[\"price\"]\n            count = dish[\"count\"]\n\n            sale_percentage = self.sales.get(dish_name, 1.0)  # Default to 1.0 (no discount) if dish not in sales\n\n            total += price * count * sale_percentage\n\n        return total\n\n    def checkout(self):\n        \"\"\"\n        Completes the order and calculates the final total.\n\n        Returns:\n            float or bool: The total price of the order if there are items in the order, False if the order is empty.\n        \"\"\"\n        if not self.selected_dishes:\n            return False  # No items in the order\n        else:\n            return self.calculate_total()\n```",
    "68": "```python\nclass PageUtil:\n    \"\"\"\n    PageUtil class is a utility for handling pagination and search functionalities.\n    \"\"\"\n\n    def __init__(self, data, page_size):\n        \"\"\"\n        Initialize the PageUtil object.\n\n        :param data: list, the data to be paginated\n        :param page_size: int, the number of items per page\n        :raises TypeError: if data is not a list or page_size is not an integer.\n        :raises ValueError: if page_size is not a positive integer.\n        \"\"\"\n        if not isinstance(data, list):\n            raise TypeError(\"Data must be a list.\")\n        if not isinstance(page_size, int):\n            raise TypeError(\"Page size must be an integer.\")\n        if page_size <= 0:\n            raise ValueError(\"Page size must be a positive integer.\")\n\n        self.data = data\n        self.page_size = page_size\n        self.total_items = len(data)\n        self.total_pages = (self.total_items + page_size - 1) // page_size\n\n    def get_page(self, page_number):\n        \"\"\"\n        Retrieve a specific page of data.\n\n        :param page_number: int, the page number to fetch (1-indexed)\n        :return: list, the data on the specified page\n        :raises TypeError: if page_number is not an integer.\n        :raises ValueError: if page_number is not a positive integer or exceeds total pages.\n        \"\"\"\n        if not isinstance(page_number, int):\n            raise TypeError(\"Page number must be an integer.\")\n        if page_number <= 0:\n            raise ValueError(\"Page number must be a positive integer.\")\n        if page_number > self.total_pages and self.total_pages > 0:\n            raise ValueError(\"Page number exceeds total pages.\")\n\n        start_index = (page_number - 1) * self.page_size\n        end_index = min(start_index + self.page_size, self.total_items)\n        return self.data[start_index:end_index]\n\n    def get_page_info(self, page_number):\n        \"\"\"\n        Retrieve information about a specific page.\n\n        :param page_number: int, the page number to fetch information about (1-indexed)\n        :return: dict, containing page information.\n        :raises TypeError: if page_number is not an integer.\n        :raises ValueError: if page_number is not a positive integer or exceeds total pages.\n        \"\"\"\n        if not isinstance(page_number, int):\n            raise TypeError(\"Page number must be an integer.\")\n        if page_number <= 0:\n            raise ValueError(\"Page number must be a positive integer.\")\n        if page_number > self.total_pages and self.total_pages > 0:\n            raise ValueError(\"Page number exceeds total pages.\")\n\n        start_index = (page_number - 1) * self.page_size\n        end_index = min(start_index + self.page_size, self.total_items)\n        data = self.data[start_index:end_index]\n        has_previous = page_number > 1\n        has_next = page_number < self.total_pages\n\n        return {\n            \"current_page\": page_number,\n            \"per_page\": self.page_size,\n            \"total_pages\": self.total_pages,\n            \"total_items\": self.total_items,\n            \"has_previous\": has_previous,\n            \"has_next\": has_next,\n            \"data\": data\n        }\n\n    def search(self, keyword):\n        \"\"\"\n        Search for items in the data that contain the given keyword (case-insensitive).\n\n        :param keyword: str, the keyword to search for\n        :return: dict, containing search information.\n        :raises TypeError: if keyword is not a string.\n        \"\"\"\n        if not isinstance(keyword, str):\n            raise TypeError(\"Keyword must be a string.\")\n\n        results = [item for item in self.data if keyword.lower() in str(item).lower()]\n        total_results = len(results)\n        total_pages = (total_results + self.page_size - 1) // self.page_size if self.page_size > 0 else 0\n\n        search_info = {\n            \"keyword\": keyword,\n            \"total_results\": total_results,\n            \"total_pages\": total_pages,\n            \"results\": results\n        }\n        return search_info\n```",
    "69": "```python\nimport PyPDF2\n\nclass PDFHandler:\n    \"\"\"\n    The class allows merging multiple PDF files into one and extracting text from PDFs using PyPDF2 library.\n    \"\"\"\n\n    def __init__(self, filepaths):\n        \"\"\"\n        Initializes the PDFHandler with a list of filepaths.\n        Opens each PDF file and creates a PdfFileReader object. Handles potential FileNotFoundError and generic Exceptions.\n        \"\"\"\n        self.filepaths = filepaths\n        self.readers = []\n        for fp in filepaths:\n            try:\n                with open(fp, 'rb') as f:  # Open in binary mode\n                    self.readers.append(PyPDF2.PdfFileReader(f))\n            except FileNotFoundError:\n                print(f\"Error: File not found - {fp}\")\n                self.readers.append(None)  # Append None to maintain the list length\n            except Exception as e:\n                print(f\"Error opening {fp}: {e}\")\n                self.readers.append(None)\n\n    def merge_pdfs(self, output_filepath):\n        \"\"\"\n        Merges multiple PDF files into a single PDF file.\n\n        Args:\n            output_filepath (str): The file path for the merged PDF.\n\n        Returns:\n            str: A message indicating the successful merging and the output file path, or None if merging fails.\n        \"\"\"\n        merger = PyPDF2.PdfFileMerger()\n        try:\n            for reader in self.readers:\n                if reader:  # Check if the reader is valid (not None)\n                    merger.append(reader)\n            with open(output_filepath, 'wb') as output_file:\n                merger.write(output_file)\n            return f\"Merged PDFs saved at {output_filepath}\"\n        except Exception as e:\n            print(f\"Error during merge: {e}\")\n            return None\n        finally:\n            merger.close()\n\n    def extract_text_from_pdfs(self):\n        \"\"\"\n        Extracts text from each PDF file.\n\n        Returns:\n            list: A list of strings, where each string contains the extracted text from a PDF file.\n                  Returns an empty string for invalid PDF files.\n        \"\"\"\n        pdf_texts = []\n        for reader in self.readers:\n            if reader:  # Check if the reader is valid (not None)\n                text = \"\"\n                try:\n                    for page_num in range(reader.getNumPages()):\n                        page = reader.getPage(page_num)\n                        text += page.extractText()\n                except Exception as e:\n                    print(f\"Error extracting text: {e}\")\n                    text = \"\"  # Return empty string if extraction fails\n                pdf_texts.append(text)\n            else:\n                pdf_texts.append(\"\")  # Append an empty string for invalid readers\n        return pdf_texts\n\nif __name__ == '__main__':\n    # Create dummy PDF files for testing\n    # Note: These are NOT actual PDF files, but text files. Real PDF files are needed for proper functionality.\n    with open(\"a.pdf\", \"w\") as f:\n        f.write(\"Test a.pdf\")\n    with open(\"b.pdf\", \"w\") as f:\n        f.write(\"Test b.pdf\")\n\n    handler = PDFHandler(['a.pdf', 'b.pdf'])\n    print(handler.extract_text_from_pdfs())\n    print(handler.merge_pdfs('out.pdf'))\n```",
    "70": "```python\nimport re\n\n\nclass PersonRequest:\n    \"\"\"\n    This class validates input personal information data and sets invalid fields to None based to specific rules.\n    \"\"\"\n\n    ALLOWED_SEXES = [\"Man\", \"Woman\", \"UGM\"]\n    PHONE_NUMBER_LENGTH = 11\n    MAX_NAME_LENGTH = 33\n\n    def __init__(self, name: str, sex: str, phone_number: str):\n        \"\"\"\n        Initialize PersonRequest object with the provided information.\n\n        :param name: str, the name of the person\n        :param sex: str, the sex of the person\n        :param phone_number: str, the phone number of the person\n        \"\"\"\n        self.name = self._validate_name(name)\n        self.sex = self._validate_sex(sex)\n        self.phone_number = self._validate_phone_number(phone_number)\n\n    def _validate_name(self, name: str) -> str | None:\n        \"\"\"\n        Validate the name.\n\n        If name is empty or exceeds MAX_NAME_LENGTH characters in length, return None.\n\n        :param name: str, the name to validate\n        :return: str | None, the validated name or None if invalid\n        \"\"\"\n        name = name.strip()\n        if not name or len(name) > self.MAX_NAME_LENGTH:\n            return None\n        return name\n\n    def _validate_sex(self, sex: str) -> str | None:\n        \"\"\"\n        Validate the sex.\n\n        If sex is not in ALLOWED_SEXES, return None. Case-insensitive comparison is performed.\n\n        :param sex: str, the sex to validate\n        :return: str | None, the validated sex or None if invalid\n        \"\"\"\n        if sex.strip() and sex.strip() in self.ALLOWED_SEXES:\n            return sex.strip()\n        return None\n\n    def _validate_phone_number(self, phone_number: str) -> str | None:\n        \"\"\"\n        Validate the phone number.\n\n        If phone_number is empty, not a digit, or not PHONE_NUMBER_LENGTH digits long, return None.\n\n        :param phone_number: str, the phone number to validate\n        :return: str | None, the validated phone number or None if invalid\n        \"\"\"\n        phone_number = phone_number.strip()\n        if not phone_number:\n            return None\n\n        if not re.match(r\"^[0-9]+$\", phone_number) or len(phone_number) != self.PHONE_NUMBER_LENGTH:\n            return None\n\n        return phone_number\n```",
    "71": "```python\nclass PushBoxGame:\n    \"\"\"\n    This class implements a functionality of a sokoban game, where the player needs to move boxes to designated targets in order to win.\n    \"\"\"\n\n    def __init__(self, map):\n        \"\"\"\n        Initialize the push box game with the map and various attributes.\n        :param map: list[str], the map of the push box game, represented as a list of strings. \n            Each character on the map represents a different element, including the following:\n            - '#' represents a wall that neither the player nor the box can pass through;\n            - 'O' represents the initial position of the player;\n            - 'G' represents the target position;\n            - 'X' represents the initial position of the box.\n        \"\"\"\n        self.map = map\n        self.player_row = 0\n        self.player_col = 0\n        self.targets = []\n        self.boxes = []\n        self.target_count = 0\n        self.is_game_over = False\n        self.height = len(map)\n        self.width = len(map[0]) if map else 0  # Handle empty map case\n        self.init_game()\n\n    def init_game(self):\n        \"\"\"\n        Initialize the game by setting the positions of the player, targets, and boxes based on the map.\n        \"\"\"\n        for row in range(self.height):\n            for col in range(self.width):\n                cell = self.map[row][col]\n                if cell == 'O':\n                    self.player_row = row\n                    self.player_col = col\n                elif cell == 'G':\n                    self.targets.append((row, col))\n                elif cell == 'X':\n                    self.boxes.append((row, col))\n        self.target_count = len(self.targets)\n\n    def check_win(self):\n        \"\"\"\n        Check if the game is won. The game is won when all the boxes are placed on target positions.\n        And update the value of self.is_game_over.\n        :return: True if all the boxes are placed on target positions, or False otherwise.\n        \"\"\"\n        if not self.boxes or not self.targets:\n            self.is_game_over = False\n            return self.is_game_over\n\n        boxes_on_targets = 0\n        for box in self.boxes:\n            if box in self.targets:\n                boxes_on_targets += 1\n        self.is_game_over = boxes_on_targets == self.target_count\n        return self.is_game_over\n\n    def move(self, direction):\n        \"\"\"\n        Move the player based on the specified direction and check if the game is won.\n        :param direction: str, the direction of the player's movement. \n            It can be 'w', 's', 'a', or 'd' representing up, down, left, or right respectively.\n\n        :return: True if the game is won, False otherwise.\n        \"\"\"\n        new_row = self.player_row\n        new_col = self.player_col\n\n        if direction == 'w':\n            new_row -= 1\n        elif direction == 's':\n            new_row += 1\n        elif direction == 'a':\n            new_col -= 1\n        elif direction == 'd':\n            new_col += 1\n        else:\n            return False  # Invalid direction\n\n        if not (0 <= new_row < self.height and 0 <= new_col < self.width):\n            return False  # Out of bounds\n\n        if self.map[new_row][new_col] == '#':\n            return False  # Hit a wall\n\n        box_index = -1\n        for i, box in enumerate(self.boxes):\n            if box[0] == new_row and box[1] == new_col:\n                box_index = i\n                break\n\n        if box_index != -1:\n            box_row, box_col = self.boxes[box_index]\n            new_box_row = box_row + (new_row - self.player_row)\n            new_box_col = box_col + (new_col - self.player_col)\n\n            if not (0 <= new_box_row < self.height and 0 <= new_box_col < self.width):\n                return False  # Box out of bounds\n\n            if self.map[new_box_row][new_box_col] == '#':\n                return False  # Box hits a wall\n\n            is_occupied = False\n            for other_box in self.boxes:\n                if other_box != (box_row, box_col) and other_box[0] == new_box_row and other_box[1] == new_box_col:\n                    is_occupied = True\n                    break\n\n            if is_occupied:\n                return False  # Box hits another box\n\n            self.boxes[box_index] = (new_box_row, new_box_col)\n\n        self.player_row = new_row\n        self.player_col = new_col\n\n        return self.check_win()\n\n    def print_map(self):\n        \"\"\"\n        Print the current state of the map.\n        \"\"\"\n        temp_map = [list(row) for row in self.map]\n\n        # Place player\n        temp_map[self.player_row][self.player_col] = 'O'\n\n        # Place boxes\n        for row, col in self.boxes:\n            temp_map[row][col] = 'X'\n\n        # Place targets if not covered by a box\n        for row, col in self.targets:\n            if temp_map[row][col] not in ['X', 'O']:\n                temp_map[row][col] = 'G'\n\n        for row in temp_map:\n            print(''.join(row))\n```",
    "72": "```python\nimport re\n\nclass RegexUtils:\n    \"\"\"\n    Provides utility functions for working with regular expressions, including matching,\n    finding all occurrences, splitting, and substituting text.  Also includes methods for\n    validating phone numbers and extracting email addresses.\n    \"\"\"\n\n    def match(self, pattern, text):\n        \"\"\"\n        Checks if the beginning of the text matches the regular expression.\n\n        Args:\n            pattern (str): The regular expression pattern.\n            text (str): The text to match against.\n\n        Returns:\n            bool: True if the text matches the pattern, False otherwise.\n        \"\"\"\n        if not isinstance(pattern, str):\n            raise TypeError(\"Pattern must be a string.\")\n        if not isinstance(text, str):\n            raise TypeError(\"Text must be a string.\")\n        return bool(re.match(pattern, text))\n\n    def findall(self, pattern, text):\n        \"\"\"\n        Finds all non-overlapping matches of the regular expression in the text.\n\n        Args:\n            pattern (str): The regular expression pattern.\n            text (str): The text to search within.\n\n        Returns:\n            list: A list of strings containing all matching substrings.  Returns an empty list if no matches are found.\n        \"\"\"\n        if not isinstance(pattern, str):\n            raise TypeError(\"Pattern must be a string.\")\n        if not isinstance(text, str):\n            raise TypeError(\"Text must be a string.\")\n        return re.findall(pattern, text)\n\n    def split(self, pattern, text):\n        \"\"\"\n        Splits the text into a list of substrings based on the occurrences of the regular expression pattern.\n\n        Args:\n            pattern (str): The regular expression pattern to split on.\n            text (str): The text to split.\n\n        Returns:\n            list: A list of strings representing the substrings after splitting.\n        \"\"\"\n        if not isinstance(pattern, str):\n            raise TypeError(\"Pattern must be a string.\")\n        if not isinstance(text, str):\n            raise TypeError(\"Text must be a string.\")\n        return re.split(pattern, text)\n\n    def sub(self, pattern, replacement, text):\n        \"\"\"\n        Replaces all occurrences of the regular expression pattern in the text with the given replacement string.\n\n        Args:\n            pattern (str): The regular expression pattern to replace.\n            replacement (str): The string to replace the matched patterns with.\n            text (str): The text to perform the substitution on.\n\n        Returns:\n            str: The text after the substitutions have been made.\n        \"\"\"\n        if not isinstance(pattern, str):\n            raise TypeError(\"Pattern must be a string.\")\n        if not isinstance(replacement, str):\n            raise TypeError(\"Replacement must be a string.\")\n        if not isinstance(text, str):\n            raise TypeError(\"Text must be a string.\")\n        return re.sub(pattern, replacement, text)\n\n    def generate_email_pattern(self):\n        \"\"\"\n        Generates a regular expression pattern for matching email addresses.\n\n        Returns:\n            str: A regular expression pattern that matches email addresses.\n        \"\"\"\n        return r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n\n    def generate_phone_number_pattern(self):\n        \"\"\"\n        Generates a regular expression pattern for matching phone numbers in the format XXX-XXX-XXXX.\n\n        Returns:\n            str: A regular expression pattern that matches phone numbers.\n        \"\"\"\n        return r'\\b\\d{3}-\\d{3}-\\d{4}\\b'\n\n    def generate_split_sentences_pattern(self):\n        \"\"\"\n        Generates a regular expression pattern for splitting sentences based on sentence-ending punctuation.\n\n        Returns:\n            str: A regular expression pattern that matches the whitespace after sentence-ending punctuation.\n        \"\"\"\n        return r'[.!?][\\s]{1,2}(?=[A-Z])'\n\n    def split_sentences(self, text):\n        \"\"\"\n        Splits the text into a list of sentences.\n\n        Args:\n            text (str): The text to split into sentences.\n\n        Returns:\n            list: A list of strings, where each string is a sentence.\n        \"\"\"\n        if not isinstance(text, str):\n            raise TypeError(\"Text must be a string.\")\n\n        pattern = self.generate_split_sentences_pattern()\n        sentences = re.split(pattern, text)\n        return [s.strip() for s in sentences if s.strip()]  # Remove leading/trailing whitespace and empty sentences\n\n    def validate_phone_number(self, phone_number):\n        \"\"\"\n        Validates a phone number against the predefined phone number pattern.\n\n        Args:\n            phone_number (str): The phone number to validate.\n\n        Returns:\n            bool: True if the phone number is valid, False otherwise.\n        \"\"\"\n        if not isinstance(phone_number, str):\n            raise TypeError(\"Phone number must be a string.\")\n\n        pattern = self.generate_phone_number_pattern()\n        return bool(re.match(pattern, phone_number))\n\n    def extract_email(self, text):\n        \"\"\"\n        Extracts all email addresses from the given text.\n\n        Args:\n            text (str): The text to extract email addresses from.\n\n        Returns:\n            list: A list of strings, where each string is an email address found in the text.\n        \"\"\"\n        if not isinstance(text, str):\n            raise TypeError(\"Text must be a string.\")\n\n        pattern = self.generate_email_pattern()\n        return re.findall(pattern, text)\n```",
    "73": "```python\nclass RPGCharacter:\n    \"\"\"\n    Represents a role-playing game character with abilities to attack, heal, gain experience, level up, and check life status.\n    \"\"\"\n\n    MAX_HP = 100\n    MAX_LEVEL = 100\n    EXP_PER_LEVEL = 100\n    HEAL_AMOUNT = 10\n    LEVEL_UP_HP_INCREASE = 20\n    LEVEL_UP_STAT_INCREASE = 5\n\n    def __init__(self, name, hp, attack_power, defense, level=1):\n        \"\"\"\n        Initializes an RPG character.\n\n        Args:\n            name (str): The character's name.\n            hp (int): The character's health points.\n            attack_power (int): The character's attack power.\n            defense (int): The character's defense points.\n            level (int): The character's level (default: 1).\n        \"\"\"\n        if not all(isinstance(arg, int) and arg > 0 for arg in [hp, attack_power, defense, level]):\n            raise ValueError(\"HP, attack_power, defense, and level must be positive integers.\")\n        if not isinstance(name, str):\n            raise TypeError(\"Name must be a string.\")\n\n        self.name = name\n        self.hp = hp\n        self.attack_power = attack_power\n        self.defense = defense\n        self.level = level\n        self.exp = 0\n\n    def attack(self, other_character):\n        \"\"\"\n        Attacks another character, reducing their HP based on the attacker's attack power and the defender's defense.\n\n        Args:\n            other_character (RPGCharacter): The character being attacked.\n        \"\"\"\n        if not isinstance(other_character, RPGCharacter):\n            raise TypeError(\"Target must be an RPGCharacter instance.\")\n\n        damage = max(0, self.attack_power - other_character.defense)  # Ensure damage is not negative\n        other_character.hp = max(0, other_character.hp - damage)  # Ensure HP doesn't go below 0\n\n    def heal(self):\n        \"\"\"\n        Heals the character, increasing their HP up to a maximum value.\n\n        Returns:\n            int: The character's current health points after healing.\n        \"\"\"\n        self.hp = min(RPGCharacter.MAX_HP, self.hp + RPGCharacter.HEAL_AMOUNT)\n        return self.hp\n\n    def gain_exp(self, amount):\n        \"\"\"\n        Gains experience points, potentially leveling up the character.\n\n        Args:\n            amount (int): The amount of experience points gained.\n        \"\"\"\n        if not isinstance(amount, int) or amount < 0:\n            raise ValueError(\"Experience amount must be a non-negative integer.\")\n\n        self.exp += amount\n        while self.exp >= RPGCharacter.EXP_PER_LEVEL * self.level and self.level < RPGCharacter.MAX_LEVEL:\n            self.level_up()\n            self.exp -= RPGCharacter.EXP_PER_LEVEL * self.level\n        #cap experience at 100\n        if self.exp > RPGCharacter.EXP_PER_LEVEL:\n            self.exp = RPGCharacter.EXP_PER_LEVEL\n\n    def level_up(self):\n        \"\"\"\n        Levels up the character, increasing their stats.\n        \"\"\"\n        if self.level < RPGCharacter.MAX_LEVEL:\n            self.level += 1\n            self.hp += RPGCharacter.LEVEL_UP_HP_INCREASE\n            self.attack_power += RPGCharacter.LEVEL_UP_STAT_INCREASE\n            self.defense += RPGCharacter.LEVEL_UP_STAT_INCREASE\n            # Optionally cap HP at MAX_HP after level up\n            self.hp = min(self.hp, RPGCharacter.MAX_HP)\n        return (self.level, self.hp, self.attack_power, self.defense)\n\n    def is_alive(self):\n        \"\"\"\n        Checks if the character is alive.\n\n        Returns:\n            bool: True if the character's HP is greater than 0, False otherwise.\n        \"\"\"\n        return self.hp > 0\n```",
    "74": "```python\nclass Server:\n    \"\"\"\n    A server class that manages a whitelist, sends/receives messages, and displays information.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the server with an empty whitelist and empty dictionaries for sent and received data.\n        \"\"\"\n        self.white_list = set()  # Use a set for efficient membership checking\n        self.send_struct = {}\n        self.receive_struct = {}\n\n    def add_white_list(self, addr):\n        \"\"\"\n        Adds an address to the whitelist if it's not already present.\n\n        Args:\n            addr: The address to add (must be hashable).\n\n        Returns:\n            True if the address was added, False otherwise.\n        \"\"\"\n        if addr not in self.white_list:\n            self.white_list.add(addr)\n            return True\n        return False\n\n    def del_white_list(self, addr):\n        \"\"\"\n        Removes an address from the whitelist if it exists.\n\n        Args:\n            addr: The address to remove.\n\n        Returns:\n            True if the address was removed, False otherwise.\n        \"\"\"\n        if addr in self.white_list:\n            self.white_list.remove(addr)\n            return True\n        return False\n\n    def recv(self, info):\n        \"\"\"\n        Receives information if the sender's address is on the whitelist.\n\n        Args:\n            info: A dictionary containing 'addr' (sender's address) and 'content' (the message).\n\n        Returns:\n            The content of the message if the sender is whitelisted, False otherwise.\n        \"\"\"\n        if not isinstance(info, dict) or 'addr' not in info or 'content' not in info:\n            print(\"Error: Invalid info format. Expected a dictionary with 'addr' and 'content' keys.\")  #Add error handling\n            return False\n\n        addr = info['addr']\n        if addr in self.white_list:\n            self.receive_struct = info.copy() # Store a copy to prevent modification of the original info\n            return info['content']\n        return False\n\n    def send(self, info):\n        \"\"\"\n        Sends information by storing it in the send_struct.\n\n        Args:\n            info: A dictionary containing 'addr' (recipient's address) and 'content' (the message).\n\n        Returns:\n            None.\n        \"\"\"\n        if not isinstance(info, dict) or 'addr' not in info or 'content' not in info:\n            print(\"Error: Invalid info format. Expected a dictionary with 'addr' and 'content' keys.\")  #Add error handling\n            return\n\n        self.send_struct = info.copy() #Again store a copy\n        return\n\n    def show(self, type):\n        \"\"\"\n        Returns the stored send or receive structure.\n\n        Args:\n            type: A string, either 'send' or 'receive', specifying which structure to return.\n\n        Returns:\n            The corresponding structure (send_struct or receive_struct) if the type is valid, False otherwise.\n        \"\"\"\n        if type == \"send\":\n            return self.send_struct.copy() # Return a copy to prevent external modification\n        elif type == \"receive\":\n            return self.receive_struct.copy() #Return a copy\n        else:\n            print(\"Error: Invalid type.  Must be 'send' or 'receive'.\") #Add error handling\n            return False\n```",
    "75": "```python\nclass ShoppingCart:\n    \"\"\"\n    Manages items, prices, and quantities in a shopping cart.\n    Allows adding, removing, viewing items, and calculating the total price.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes an empty shopping cart.\n        \"\"\"\n        self.items = {}\n\n    def add_item(self, item: str, price: float, quantity: int = 1) -> None:\n        \"\"\"\n        Adds an item to the shopping cart or updates the quantity if it already exists.\n\n        Args:\n            item: The name of the item (string).\n            price: The price of the item (float).\n            quantity: The quantity of the item to add (integer, default is 1).\n\n        Raises:\n            TypeError: if price or quantity are not of the correct type\n            ValueError: if price or quantity are invalid (negative or zero)\n        \"\"\"\n        if not isinstance(price, (int, float)):\n            raise TypeError(\"Price must be a number.\")\n        if not isinstance(quantity, int):\n            raise TypeError(\"Quantity must be an integer.\")\n        if price <= 0:\n            raise ValueError(\"Price must be positive.\")\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be positive.\")\n\n        if item in self.items:\n            self.items[item][\"quantity\"] += quantity\n        else:\n            self.items[item] = {\"price\": price, \"quantity\": quantity}\n\n    def remove_item(self, item: str, quantity: int = 1) -> None:\n        \"\"\"\n        Removes items from the shopping cart.  If the quantity to remove\n        is greater or equal to the quantity in the cart, the item is removed.\n\n        Args:\n            item: The name of the item to remove (string).\n            quantity: The quantity of the item to remove (integer, default is 1).\n\n        Raises:\n            ValueError: If the quantity to remove is invalid (negative or zero).\n            KeyError: If the item is not in the cart.\n            TypeError: If quantity is not an integer.\n        \"\"\"\n        if not isinstance(quantity, int):\n            raise TypeError(\"Quantity must be an integer.\")\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be positive.\")\n\n        if item not in self.items:\n            raise KeyError(f\"Item '{item}' not found in cart.\")\n\n        if self.items[item][\"quantity\"] > quantity:\n            self.items[item][\"quantity\"] -= quantity\n        else:\n            del self.items[item]\n\n    def view_items(self) -> dict:\n        \"\"\"\n        Returns a dictionary representing the current items in the shopping cart.\n\n        Returns:\n            A dictionary where keys are item names and values are dictionaries\n            containing the 'price' and 'quantity' of each item.\n        \"\"\"\n        return self.items\n\n    def total_price(self) -> float:\n        \"\"\"\n        Calculates the total price of all items in the shopping cart.\n\n        Returns:\n            The total price (float).\n        \"\"\"\n        total = 0\n        for item, details in self.items.items():\n            total += details[\"price\"] * details[\"quantity\"]\n        return total\n```",
    "76": "```python\nclass SignInSystem:\n    \"\"\"\n    A simple sign-in system.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the sign-in system with an empty dictionary of users.\n        \"\"\"\n        self.users = {}  # key: username (str), value: sign-in status (bool)\n\n    def add_user(self, username):\n        \"\"\"\n        Adds a user to the system.\n\n        Args:\n            username (str): The username to add.\n\n        Returns:\n            bool: True if the user was added, False if the user already exists.\n        \"\"\"\n        if not isinstance(username, str):\n            raise TypeError(\"Username must be a string.\")\n\n        if username in self.users:\n            return False\n        else:\n            self.users[username] = False\n            return True\n\n    def sign_in(self, username):\n        \"\"\"\n        Signs in a user.\n\n        Args:\n            username (str): The username to sign in.\n\n        Returns:\n            bool: True if the user was signed in, False if the user does not exist.\n        \"\"\"\n        if not isinstance(username, str):\n            raise TypeError(\"Username must be a string.\")\n\n        if username in self.users:\n            self.users[username] = True\n            return True\n        else:\n            return False\n\n    def sign_out(self, username):\n        \"\"\"\n        Signs out a user.\n\n        Args:\n            username (str): The username to sign out.\n\n        Returns:\n            bool: True if the user was signed out, False if the user does not exist.\n        \"\"\"\n        if not isinstance(username, str):\n            raise TypeError(\"Username must be a string.\")\n        if username in self.users:\n            self.users[username] = False\n            return True\n        else:\n            return False\n\n    def check_sign_in(self, username):\n        \"\"\"\n        Checks if a user is signed in.\n\n        Args:\n            username (str): The username to check.\n\n        Returns:\n            bool: True if the user is signed in, False if the user does not exist or is not signed in.\n        \"\"\"\n        if not isinstance(username, str):\n            raise TypeError(\"Username must be a string.\")\n\n        if username in self.users:\n            return self.users[username]\n        else:\n            return False\n\n    def all_signed_in(self):\n        \"\"\"\n        Checks if all users are signed in.\n\n        Returns:\n            bool: True if all users are signed in, False otherwise.  Returns True if there are no users.\n        \"\"\"\n        if not self.users:\n            return True  # Handle the case where there are no users\n\n        return all(self.users.values())\n\n    def all_not_signed_in(self):\n        \"\"\"\n        Returns a list of usernames that are not signed in.\n\n        Returns:\n            list: A list of usernames (strings) that are not signed in.\n        \"\"\"\n        return [username for username, signed_in in self.users.items() if not signed_in]\n\n\nif __name__ == '__main__':\n    # Example Usage\n    system = SignInSystem()\n\n    print(\"Adding users:\")\n    print(f\"Adding 'Alice': {system.add_user('Alice')}\")  # Output: True\n    print(f\"Adding 'Bob': {system.add_user('Bob')}\")    # Output: True\n    print(f\"Adding 'Alice' again: {system.add_user('Alice')}\")  # Output: False\n\n    print(\"\\nChecking sign-in status:\")\n    print(f\"Is 'Alice' signed in? {system.check_sign_in('Alice')}\")  # Output: False\n    print(f\"Is 'Bob' signed in? {system.check_sign_in('Bob')}\")    # Output: False\n    print(f\"Is 'Charlie' signed in? {system.check_sign_in('Charlie')}\")  # Output: False\n\n    print(\"\\nSigning in users:\")\n    print(f\"Signing in 'Alice': {system.sign_in('Alice')}\")  # Output: True\n    print(f\"Signing in 'Charlie': {system.sign_in('Charlie')}\")  # Output: False\n\n    print(\"\\nChecking sign-in status again:\")\n    print(f\"Is 'Alice' signed in? {system.check_sign_in('Alice')}\")  # Output: True\n    print(f\"Is 'Bob' signed in? {system.check_sign_in('Bob')}\")    # Output: False\n\n    print(\"\\nList of not signed in users:\")\n    print(f\"Not signed in: {system.all_not_signed_in()}\")  # Output: ['Bob']\n\n    print(\"\\nAre all users signed in?\")\n    print(f\"All signed in? {system.all_signed_in()}\")  # Output: False\n\n    print(\"\\nSigning in Bob\")\n    system.sign_in(\"Bob\")\n    print(f\"All signed in? {system.all_signed_in()}\")\n\n    print(\"\\nSigning out Alice\")\n    system.sign_out(\"Alice\")\n    print(f\"Not signed in: {system.all_not_signed_in()}\")\n\n    print(\"\\nNo users yet\")\n    system2 = SignInSystem()\n    print(f\"All signed in? {system2.all_signed_in()}\")\n```",
    "77": "```python\nimport random\n\nclass Snake:\n    \"\"\"\n    The class is a snake game, with allows snake to move and eat food, and also enables to reset and generate a random food position.\n    \"\"\"\n\n    def __init__(self, screen_width, screen_height, block_size):\n        \"\"\"\n        Initialize the snake.\n\n        :param screen_width: int, The width of the game screen.\n        :param screen_height: int, The height of the game screen.\n        :param block_size: int, Size of moving units.\n        \"\"\"\n        self.screen_width = screen_width\n        self.screen_height = screen_height\n        self.block_size = block_size\n        self.reset()  # Initialize snake's position, length, score, and food\n\n    def reset(self):\n        \"\"\"\n        Reset the snake to its initial state.\n        \"\"\"\n        self.length = 1\n        self.positions = [((self.screen_width // 2), (self.screen_height // 2))]\n        self.score = 0\n        self.direction = (0, 0)  # Initial direction: stationary\n        self.random_food_position()\n\n    def move(self):\n        \"\"\"\n        Move the snake in the current direction.\n        \"\"\"\n        if self.direction == (0, 0):\n            return  # Snake is stationary, don't move\n\n        cur = self.positions[0]\n        x, y = self.direction\n        new = (((cur[0] + (x * self.block_size)) % self.screen_width),\n               (cur[1] + (y * self.block_size)) % self.screen_height)\n\n        if new in self.positions[1:]:\n            self.reset()  # Collision with self, game over\n        else:\n            self.positions.insert(0, new)  # Add new head position\n            if new == self.food_position:\n                self.eat_food()\n            else:\n                self.positions.pop()  # Remove tail if no food eaten\n\n    def set_direction(self, direction):\n        \"\"\"\n        Set the direction of the snake's movement.\n\n        :param direction: tuple, representing the direction of movement (x, y).  Must be one of (0,1), (0,-1), (1,0), (-1,0)\n        \"\"\"\n\n        # Prevent snake from reversing direction immediately\n        if (direction[0] * -1, direction[1] * -1) == self.direction and self.length > 1:\n            return\n        self.direction = direction\n\n    def random_food_position(self):\n        \"\"\"\n        Randomly generate a new food position, but not on the snake's body.\n        \"\"\"\n        while True:\n            x = random.randint(0, (self.screen_width // self.block_size) - 1) * self.block_size\n            y = random.randint(0, (self.screen_height // self.block_size) - 1) * self.block_size\n            if (x, y) not in self.positions:\n                self.food_position = (x, y)\n                return\n\n    def eat_food(self):\n        \"\"\"\n        Increase the length of the snake and the score. Generate new food.\n        \"\"\"\n        self.length += 1\n        self.score += 10\n        self.random_food_position()\n\n\nif __name__ == '__main__':\n    # Example Usage\n    SCREEN_WIDTH = 600\n    SCREEN_HEIGHT = 480\n    BLOCK_SIZE = 20\n\n    snake = Snake(SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE)\n    print(f\"Initial snake positions: {snake.positions}\")\n    print(f\"Initial snake length: {snake.length}\")\n    print(f\"Initial snake score: {snake.score}\")\n    print(f\"Initial food position: {snake.food_position}\")\n\n    snake.set_direction((1, 0))  # Move right\n    snake.move()\n    print(f\"Snake positions after moving right: {snake.positions}\")\n\n    initial_score = snake.score\n    # Simulate eating food by placing food next to the snake's head\n    snake.food_position = (snake.positions[0][0] + BLOCK_SIZE, snake.positions[0][1])\n    snake.move()  # Move again to 'eat' the food\n    print(f\"Snake length after eating food: {snake.length}\")\n    print(f\"Snake score after eating food: {snake.score}\")\n    print(f\"New food position after eating: {snake.food_position}\")\n\n    snake.reset()\n    print(f\"Snake positions after reset: {snake.positions}\")\n    print(f\"Snake length after reset: {snake.length}\")\n    print(f\"Snake score after reset: {snake.score}\")\n    print(f\"New food position after reset: {snake.food_position}\")\n```",
    "78": "```python\nimport re\n\nclass SplitSentence:\n    \"\"\"\n    The class allows to split sentences, count words in a sentence, and process a text file to find the maximum word count.\n    \"\"\"\n\n    def split_sentences(self, sentences_string):\n        \"\"\"\n        Split a string into a list of sentences. Sentences end with . or ? and with a space after that. Please note that Mr. also end with . but are not sentences.\n        :param sentences_string: string, string to split\n        :return:list, split sentence list\n        >>> ss = SplitSentence()\n        >>> ss.split_sentences(\"aaa aaaa. bb bbbb bbb? cccc cccc. dd ddd?\")\n        ['aaa aaaa.', 'bb bbbb bbb?', 'cccc cccc.', 'dd ddd?']\n        \"\"\"\n        sentences = re.split(r'(?<!Mr)(?<!Mrs)(?<!Dr)(?<!Ms)\\.(?=\\s)|(?<=\\?)\\s', sentences_string)\n        sentences = [s.strip() for s in sentences if s.strip()]\n        return sentences\n\n    def count_words(self, sentence):\n        \"\"\"\n        Count the number of words in a sentence. Note that words are separated by spaces and that punctuation marks and numbers are not counted as words.\n        :param sentence:string, sentence to be counted, where words are separated by spaces\n        :return:int, number of words in the sentence\n        >>> ss = SplitSentence()\n        >>> ss.count_words(\"abc def\")\n        2\n        \"\"\"\n        words = re.findall(r'\\b[a-zA-Z]+\\b', sentence)\n        return len(words)\n\n    def process_text_file(self, sentences_string):\n        \"\"\"\n        Given a text, return the number of words in the longest sentence\n        :param sentences_string: string, undivided long sentence\n        :return:int, the number of words in the longest sentence\n        >>> ss = SplitSentence()\n        >>> ss.process_text_file(\"aaa aaaa. bb bbbb bbb? cccc ccccccc cc ccc. dd ddd?\")\n        4\n        \"\"\"\n        sentences = self.split_sentences(sentences_string)\n        if not sentences:\n            return 0\n        max_words = max(self.count_words(sentence) for sentence in sentences)\n        return max_words\n```",
    "79": "```python\nimport re\n\n\nclass SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        if not isinstance(table_name, str):\n            raise TypeError(\"Table name must be a string.\")\n        if not re.match(r\"^[a-zA-Z_][a-zA-Z0-9_]*$\", table_name):\n            raise ValueError(\n                \"Invalid table name. Must start with a letter or underscore and contain only alphanumeric characters and underscores.\"\n            )\n        self.table_name = table_name\n\n    def _sanitize_field(self, field):\n        \"\"\"Sanitizes a field name to prevent SQL injection.\"\"\"\n        if not isinstance(field, str):\n            raise TypeError(\"Field name must be a string.\")\n        if not re.match(r\"^[a-zA-Z_][a-zA-Z0-9_]*$\", field):\n            raise ValueError(\n                \"Invalid field name. Must start with a letter or underscore and contain only alphanumeric characters and underscores.\"\n            )\n        return field\n\n    def _sanitize_value(self, value):\n        \"\"\"Sanitizes a value to prevent SQL injection.\"\"\"\n        if isinstance(value, str):\n            return \"'\" + value.replace(\"'\", \"''\") + \"'\"  # Escape single quotes\n        elif isinstance(value, (int, float)):\n            return str(value)\n        elif value is None:\n            return \"NULL\"\n        else:\n            raise TypeError(f\"Unsupported value type: {type(value)}\")\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        sql = \"SELECT \"\n        if fields:\n            if not isinstance(fields, list):\n                raise TypeError(\"Fields must be a list.\")\n            sanitized_fields = [self._sanitize_field(field) for field in fields]\n            sql += \", \".join(sanitized_fields)\n        else:\n            sql += \"*\"\n        sql += \" FROM \" + self.table_name\n        if condition:\n            if not isinstance(condition, str):\n                raise TypeError(\"Condition must be a string.\")\n            sql += \" WHERE \" + condition\n        sql += \";\"\n        return sql\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        if not isinstance(data, dict):\n            raise TypeError(\"Data must be a dictionary.\")\n\n        if not data:\n            raise ValueError(\"Data dictionary cannot be empty.\")\n\n        fields = [self._sanitize_field(field) for field in data.keys()]\n        values = [self._sanitize_value(value) for value in data.values()]\n\n        sql = (\n            f\"INSERT INTO {self.table_name} ({', '.join(fields)}) VALUES ({', '.join(values)});\"\n        )\n        return sql\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and values are new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        if not isinstance(data, dict):\n            raise TypeError(\"Data must be a dictionary.\")\n\n        if not isinstance(condition, str):\n            raise TypeError(\"Condition must be a string.\")\n\n        updates = []\n        for field, value in data.items():\n            sanitized_field = self._sanitize_field(field)\n            sanitized_value = self._sanitize_value(value)\n            updates.append(f\"{sanitized_field} = {sanitized_value}\")\n\n        if not updates:\n            raise ValueError(\"Data dictionary cannot be empty.\")\n\n        sql = f\"UPDATE {self.table_name} SET {', '.join(updates)} WHERE {condition};\"\n        return sql\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        if not isinstance(condition, str):\n            raise TypeError(\"Condition must be a string.\")\n\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition};\"\n        return sql\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        if not isinstance(age, int):\n            raise TypeError(\"Age must be an integer.\")\n\n        sql = f\"SELECT * FROM {self.table_name} WHERE age < {age} AND gender = 'female';\"\n        return sql\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        if not isinstance(min_age, int) or not isinstance(max_age, int):\n            raise TypeError(\"Min_age and max_age must be integers.\")\n\n        if min_age > max_age:\n            raise ValueError(\"Min_age cannot be greater than max_age.\")\n\n        sql = f\"SELECT * FROM {self.table_name} WHERE age BETWEEN {min_age} AND {max_age};\"\n        return sql\n```",
    "80": "```python\nimport re\nfrom typing import Dict, List, Union\n\n\nclass SQLQueryBuilder:\n    \"\"\"\n    This class provides methods to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements.\n    It includes basic sanitization to prevent SQL injection.\n    \"\"\"\n\n    @staticmethod\n    def _sanitize_value(value: Union[str, int, float]) -> str:\n        \"\"\"\n        Sanitizes a value to prevent SQL injection.\n        \"\"\"\n        if isinstance(value, (int, float)):\n            return str(value)  # Numbers are generally safe\n        if isinstance(value, str):\n            # Escape single quotes by replacing them with two single quotes\n            escaped_value = value.replace(\"'\", \"''\")\n            return f\"'{escaped_value}'\"\n        return \"NULL\"  # Handle other types as NULL or raise an exception\n\n    @staticmethod\n    def select(table: str, columns: Union[str, List[str]] = '*', where: Dict[str, Union[str, int, float]] = None) -> str:\n        \"\"\"\n        Generates a SELECT SQL statement.\n\n        Args:\n            table: The name of the table.\n            columns: A string or a list of strings representing the columns to select.\n                     Defaults to '*' (all columns).\n            where: A dictionary representing the WHERE clause conditions.\n                   Keys are column names, and values are the conditions.\n\n        Returns:\n            A string representing the SELECT SQL statement.\n\n        Raises:\n            ValueError: If the table or column names contain invalid characters.\n\n        Example:\n            >>> SQLQueryBuilder.select('users', columns=['id', 'name'], where={'age': 30, 'city': 'New York'})\n            \"SELECT id, name FROM users WHERE age=30 AND city='New York'\"\n        \"\"\"\n        if not re.match(r\"^[a-zA-Z_][a-zA-Z0-9_]*$\", table):\n            raise ValueError(\"Invalid table name.\")\n\n        if isinstance(columns, list):\n            for col in columns:\n                if not re.match(r\"^[a-zA-Z_][a-zA-Z0-9_]*$\", col):\n                    raise ValueError(\"Invalid column name.\")\n            columns_str = ', '.join(columns)\n        elif columns == '*':\n            columns_str = '*'\n        else:\n            if not re.match(r\"^[a-zA-Z_][a-zA-Z0-9_]*$\", columns):\n                raise ValueError(\"Invalid column name.\")\n            columns_str = columns\n\n        query = f\"SELECT {columns_str} FROM {table}\"\n\n        if where:\n            where_clauses = []\n            for key, value in where.items():\n                if not re.match(r\"^[a-zA-Z_][a-zA-Z0-9_]*$\", key):\n                    raise ValueError(\"Invalid column name in WHERE clause.\")\n                sanitized_value = SQLQueryBuilder._sanitize_value(value)\n                where_clauses.append(f\"{key}={sanitized_value}\")\n            query += \" WHERE \" + \" AND \".join(where_clauses)\n\n        return query\n\n    @staticmethod\n    def insert(table: str, data: Dict[str, Union[str, int, float]]) -> str:\n        \"\"\"\n        Generates an INSERT SQL statement.\n\n        Args:\n            table: The name of the table.\n            data: A dictionary representing the data to insert.\n                  Keys are column names, and values are the data to insert.\n\n        Returns:\n            A string representing the INSERT SQL statement.\n\n        Raises:\n            ValueError: If the table or column names contain invalid characters.\n\n        Example:\n            >>> SQLQueryBuilder.insert('users', {'name': 'Alice', 'age': 25})\n            \"INSERT INTO users (name, age) VALUES ('Alice', 25)\"\n        \"\"\"\n        if not re.match(r\"^[a-zA-Z_][a-zA-Z0-9_]*$\", table):\n            raise ValueError(\"Invalid table name.\")\n\n        columns = []\n        values = []\n        for key, value in data.items():\n            if not re.match(r\"^[a-zA-Z_][a-zA-Z0-9_]*$\", key):\n                raise ValueError(\"Invalid column name in INSERT statement.\")\n            columns.append(key)\n            sanitized_value = SQLQueryBuilder._sanitize_value(value)\n            values.append(sanitized_value)\n\n        columns_str = ', '.join(columns)\n        values_str = ', '.join(values)\n\n        query = f\"INSERT INTO {table} ({columns_str}) VALUES ({values_str})\"\n        return query\n\n    @staticmethod\n    def delete(table: str, where: Dict[str, Union[str, int, float]] = None) -> str:\n        \"\"\"\n        Generates a DELETE SQL statement.\n\n        Args:\n            table: The name of the table.\n            where: A dictionary representing the WHERE clause conditions.\n                   Keys are column names, and values are the conditions.\n\n        Returns:\n            A string representing the DELETE SQL statement.\n\n        Raises:\n            ValueError: If the table or column names contain invalid characters.\n\n        Example:\n            >>> SQLQueryBuilder.delete('users', where={'id': 123})\n            \"DELETE FROM users WHERE id=123\"\n        \"\"\"\n        if not re.match(r\"^[a-zA-Z_][a-zA-Z0-9_]*$\", table):\n            raise ValueError(\"Invalid table name.\")\n\n        query = f\"DELETE FROM {table}\"\n\n        if where:\n            where_clauses = []\n            for key, value in where.items():\n                if not re.match(r\"^[a-zA-Z_][a-zA-Z0-9_]*$\", key):\n                    raise ValueError(\"Invalid column name in WHERE clause.\")\n                sanitized_value = SQLQueryBuilder._sanitize_value(value)\n                where_clauses.append(f\"{key}={sanitized_value}\")\n            query += \" WHERE \" + \" AND \".join(where_clauses)\n\n        return query\n\n    @staticmethod\n    def update(table: str, data: Dict[str, Union[str, int, float]], where: Dict[str, Union[str, int, float]] = None) -> str:\n        \"\"\"\n        Generates an UPDATE SQL statement.\n\n        Args:\n            table: The name of the table.\n            data: A dictionary representing the data to update.\n                  Keys are column names, and values are the new values.\n            where: A dictionary representing the WHERE clause conditions.\n                   Keys are column names, and values are the conditions.\n\n        Returns:\n            A string representing the UPDATE SQL statement.\n\n        Raises:\n            ValueError: If the table or column names contain invalid characters.\n\n        Example:\n            >>> SQLQueryBuilder.update('users', data={'name': 'Bob'}, where={'id': 123})\n            \"UPDATE users SET name='Bob' WHERE id=123\"\n        \"\"\"\n        if not re.match(r\"^[a-zA-Z_][a-zA-Z0-9_]*$\", table):\n            raise ValueError(\"Invalid table name.\")\n\n        set_clauses = []\n        for key, value in data.items():\n            if not re.match(r\"^[a-zA-Z_][a-zA-Z0-9_]*$\", key):\n                raise ValueError(\"Invalid column name in SET clause.\")\n            sanitized_value = SQLQueryBuilder._sanitize_value(value)\n            set_clauses.append(f\"{key}={sanitized_value}\")\n        set_str = ', '.join(set_clauses)\n\n        query = f\"UPDATE {table} SET {set_str}\"\n\n        if where:\n            where_clauses = []\n            for key, value in where.items():\n                if not re.match(r\"^[a-zA-Z_][a-zA-Z0-9_]*$\", key):\n                    raise ValueError(\"Invalid column name in WHERE clause.\")\n                sanitized_value = SQLQueryBuilder._sanitize_value(value)\n                where_clauses.append(f\"{key}={sanitized_value}\")\n            query += \" WHERE \" + \" AND \".join(where_clauses)\n\n        return query\n```",
    "81": "```python\nimport math\nfrom collections import Counter\n\nclass Statistics3:\n    \"\"\"\n    This is a class that implements methods for calculating indicators such as median, mode, correlation matrix, and Z-score in statistics.\n    \"\"\"\n\n    @staticmethod\n    def median(data):\n        \"\"\"\n        Calculates the median of the given list.\n\n        Args:\n            data (list): The input list of numerical data.\n\n        Returns:\n            float: The median of the data.  Returns None if the input list is empty.\n\n        Raises:\n            TypeError: If the input data is not a list or contains non-numerical data.\n        \"\"\"\n        if not isinstance(data, list):\n            raise TypeError(\"Input data must be a list.\")\n        if not data:\n            return None  # Handle empty list case\n        try:\n            data = sorted(data)\n            n = len(data)\n            if n % 2 == 0:\n                mid1 = data[n // 2 - 1]\n                mid2 = data[n // 2]\n                median = (mid1 + mid2) / 2\n            else:\n                median = data[n // 2]\n            return float(median) # Ensure float return type\n        except TypeError:\n            raise TypeError(\"List elements must be numerical.\")\n\n\n    @staticmethod\n    def mode(data):\n        \"\"\"\n        Calculates the mode(s) of the given list.\n\n        Args:\n            data (list): The input list of data.\n\n        Returns:\n            list: A list containing the mode(s) of the data.  Returns an empty list if the input list is empty or if all elements appear only once.\n\n        Raises:\n            TypeError: If the input data is not a list.\n        \"\"\"\n        if not isinstance(data, list):\n            raise TypeError(\"Input data must be a list.\")\n\n        if not data:\n            return []  # Handle empty list case\n\n        counts = Counter(data)\n        max_count = max(counts.values()) if counts else 0\n\n        if max_count == 1 and len(counts) == len(data):  # Check for all unique values\n            return []\n\n        modes = [item for item, count in counts.items() if count == max_count]\n        return modes\n\n\n    @staticmethod\n    def correlation(x, y):\n        \"\"\"\n        Calculates the Pearson correlation coefficient between two lists.\n\n        Args:\n            x (list): The first list of numerical data.\n            y (list): The second list of numerical data.\n\n        Returns:\n            float: The Pearson correlation coefficient between x and y. Returns 0.0 if the denominator is zero.\n\n        Raises:\n            ValueError: If the input lists are not of the same length.\n            TypeError: If the input data is not a list or contains non-numerical data.\n        \"\"\"\n        if not isinstance(x, list) or not isinstance(y, list):\n            raise TypeError(\"Input data must be lists.\")\n\n        if len(x) != len(y):\n            raise ValueError(\"Lists must be of the same length.\")\n\n        n = len(x)\n        if n == 0:\n            return 0.0 # Handle empty list case\n\n        try:\n            mean_x = sum(x) / n\n            mean_y = sum(y) / n\n\n            numerator = sum([(x[i] - mean_x) * (y[i] - mean_y) for i in range(n)])\n            denominator_x = sum([(x[i] - mean_x) ** 2 for i in range(n)])\n            denominator_y = sum([(y[i] - mean_y) ** 2 for i in range(n)])\n            denominator = math.sqrt(denominator_x * denominator_y)\n\n            if denominator == 0:\n                return 0.0\n\n            return numerator / denominator\n        except TypeError:\n            raise TypeError(\"List elements must be numerical.\")\n\n\n\n    @staticmethod\n    def mean(data):\n        \"\"\"\n        Calculates the mean (average) of the given list.\n\n        Args:\n            data (list): The input list of numerical data.\n\n        Returns:\n            float: The mean of the data.  Returns None if the input list is empty.\n\n        Raises:\n            TypeError: If the input data is not a list or contains non-numerical data.\n        \"\"\"\n        if not isinstance(data, list):\n            raise TypeError(\"Input data must be a list.\")\n\n        if not data:\n            return None # Handle empty list case\n\n        try:\n            return float(sum(data) / len(data)) # Ensure float return type\n\n        except TypeError:\n            raise TypeError(\"List elements must be numerical.\")\n\n\n    @staticmethod\n    def correlation_matrix(data):\n        \"\"\"\n        Calculates the correlation matrix of the given list of lists (matrix).\n\n        Args:\n            data (list): A list of lists, where each inner list represents a variable.\n\n        Returns:\n            list: A correlation matrix (list of lists) representing the pairwise correlations between the variables.  Returns an empty list if the input list is empty.\n\n        Raises:\n            TypeError: If the input data is not a list or contains non-numerical data.\n        \"\"\"\n        if not isinstance(data, list):\n            raise TypeError(\"Input data must be a list.\")\n\n        if not data:\n            return [] # Handle empty list case\n\n        num_variables = len(data)\n        correlation_matrix = []\n        for i in range(num_variables):\n            row = []\n            for j in range(num_variables):\n                row.append(Statistics3.correlation(data[i], data[j]))\n            correlation_matrix.append(row)\n        return correlation_matrix\n\n\n    @staticmethod\n    def standard_deviation(data):\n        \"\"\"\n        Calculates the sample standard deviation of the given list.\n\n        Args:\n            data (list): The input list of numerical data.\n\n        Returns:\n            float: The sample standard deviation of the data. Returns 0.0 if the list has fewer than 2 elements. Returns None if the input list is empty.\n\n        Raises:\n            TypeError: If the input data is not a list or contains non-numerical data.\n        \"\"\"\n        if not isinstance(data, list):\n            raise TypeError(\"Input data must be a list.\")\n\n        if not data:\n            return None # Handle empty list case\n        \n        n = len(data)\n        if n < 2:\n            return 0.0 # Cannot compute stdev with fewer than 2 data points\n\n        try:\n            mean = Statistics3.mean(data) # Use the class's mean method\n            variance = sum([(x - mean) ** 2 for x in data]) / (n - 1)  # Sample standard deviation (n-1)\n            return math.sqrt(variance)\n        except TypeError:\n            raise TypeError(\"List elements must be numerical.\")\n\n\n    @staticmethod\n    def z_score(data):\n        \"\"\"\n        Calculates the Z-scores for each data point in the given list.\n\n        Args:\n            data (list): The input list of numerical data.\n\n        Returns:\n            list: A list of Z-scores corresponding to each data point in the input list. Returns a list of 0.0 if the standard deviation is zero. Returns an empty list if the input list is empty.\n\n        Raises:\n            TypeError: If the input data is not a list or contains non-numerical data.\n        \"\"\"\n        if not isinstance(data, list):\n            raise TypeError(\"Input data must be a list.\")\n\n        if not data:\n            return []  # Handle empty list case\n\n        try:\n            mean = Statistics3.mean(data)\n            std_dev = Statistics3.standard_deviation(data)\n\n            if std_dev == 0:\n                return [0.0] * len(data) # Return 0 if standard deviation is zero\n\n            return [(x - mean) / std_dev for x in data]\n        except TypeError:\n            raise TypeError(\"List elements must be numerical.\")\n```",
    "82": "```python\nclass StockPortfolioTracker:\n    \"\"\"\n    This is a class as StockPortfolioTracker that allows to add stocks, remove stocks, buy stocks, sell stocks, calculate the total value of the portfolio, and obtain a summary of the portfolio.\n    \"\"\"\n\n    def __init__(self, cash_balance):\n        \"\"\"\n        Initialize the StockPortfolioTracker class with a cash balance and an empty portfolio.\n        \"\"\"\n        self.portfolio = {}  # Use a dictionary to store stocks, with stock name as key\n        self.cash_balance = cash_balance\n\n    def add_stock(self, stock_name, price, quantity):\n        \"\"\"\n        Add a stock to the portfolio.\n        :param stock_name: The name of the stock (string).\n        :param price: The price of the stock (float).\n        :param quantity: The quantity of the stock (int).\n        \"\"\"\n        if stock_name in self.portfolio:\n            self.portfolio[stock_name]['quantity'] += quantity\n        else:\n            self.portfolio[stock_name] = {'price': price, 'quantity': quantity}\n\n    def remove_stock(self, stock_name, quantity_to_remove):\n        \"\"\"\n        Remove a stock from the portfolio.\n        :param stock_name: The name of the stock to remove (string).\n        :param quantity_to_remove: The quantity of the stock to remove (int).\n        :return: True if the stock was successfully removed, False otherwise.\n        \"\"\"\n        if stock_name not in self.portfolio:\n            return False\n\n        if self.portfolio[stock_name]['quantity'] < quantity_to_remove:\n            return False\n\n        self.portfolio[stock_name]['quantity'] -= quantity_to_remove\n        if self.portfolio[stock_name]['quantity'] == 0:\n            del self.portfolio[stock_name]\n        return True\n\n    def buy_stock(self, stock_name, price, quantity):\n        \"\"\"\n        Buy a stock and add it to the portfolio.\n        :param stock_name: The name of the stock to buy (string).\n        :param price: The price of the stock (float).\n        :param quantity: The quantity of the stock to buy (int).\n        :return: True if the stock was bought successfully, False if the cash balance is not enough.\n        \"\"\"\n        cost = price * quantity\n        if self.cash_balance >= cost:\n            self.add_stock(stock_name, price, quantity)\n            self.cash_balance -= cost\n            return True\n        else:\n            return False\n\n    def sell_stock(self, stock_name, price, quantity):\n        \"\"\"\n        Sell a stock and remove it from the portfolio and add the cash to the cash balance.\n        :param stock_name: The name of the stock to sell (string).\n        :param price: The price of the stock (float).\n        :param quantity: The quantity of the stock to sell (int).\n        :return: True if the stock was sold successfully, False if the quantity of the stock is not enough.\n        \"\"\"\n        if stock_name not in self.portfolio:\n            return False\n\n        if self.portfolio[stock_name]['quantity'] < quantity:\n            return False\n\n        self.remove_stock(stock_name, quantity)  # Remove using the remove_stock method\n        self.cash_balance += price * quantity\n        return True\n\n    def calculate_portfolio_value(self):\n        \"\"\"\n        Calculate the total value of the portfolio.\n        :return: the total value of the portfolio, float.\n        \"\"\"\n        total_value = self.cash_balance\n        for stock_name, stock_data in self.portfolio.items():\n            total_value += stock_data['price'] * stock_data['quantity']\n        return total_value\n\n    def get_portfolio_summary(self):\n        \"\"\"\n        Get a summary of the portfolio.\n        :return: a tuple of the total value of the portfolio and a list of dictionaries with keys \"name\" and \"value\"\n        \"\"\"\n        total_value = self.calculate_portfolio_value()\n        stock_values = []\n        for stock_name, stock_data in self.portfolio.items():\n            stock_values.append({\"name\": stock_name, \"value\": stock_data['price'] * stock_data['quantity']})\n        return total_value, stock_values\n\n    def get_stock_value(self, stock_name):\n        \"\"\"\n        Get the value of a stock.\n        :param stock_name: The name of the stock (string).\n        :return: the value of the stock, float, or None if the stock is not in the portfolio.\n        \"\"\"\n        if stock_name not in self.portfolio:\n            return None\n        stock_data = self.portfolio[stock_name]\n        return stock_data['price'] * stock_data['quantity']\n```",
    "83": "```python\nimport sqlite3\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This is a class with database operation, including inserting student information, searching for student information by name, and deleting student information by name.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n        self.conn = None  # Initialize connection attribute\n\n    def _connect(self):\n        \"\"\"\n        Establishes a database connection.\n        \"\"\"\n        try:\n            self.conn = sqlite3.connect(self.database_name)\n            return self.conn.cursor()\n        except sqlite3.Error as e:\n            print(f\"Database connection error: {e}\")\n            return None\n\n    def _close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        if self.conn:\n            self.conn.close()\n            self.conn = None\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.\n        Fields include ID of type int, name of type str, age of type int, gender of type str, and grade of type int.\n        :return: None\n        \"\"\"\n        cursor = self._connect()\n        if cursor:\n            try:\n                cursor.execute(\"\"\"\n                    CREATE TABLE IF NOT EXISTS students (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        name TEXT NOT NULL,\n                        age INTEGER,\n                        gender TEXT,\n                        grade INTEGER\n                    )\n                \"\"\")\n                self.conn.commit()\n            except sqlite3.Error as e:\n                print(f\"Database error creating table: {e}\")\n            finally:\n                self._close()\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n               Must contain keys 'name', 'age', 'gender', and 'grade'.\n        :return: None\n        :raises ValueError: if student_data is missing required keys.\n        \"\"\"\n        cursor = self._connect()\n        if cursor:\n            try:\n                if not all(key in student_data for key in ('name', 'age', 'gender', 'grade')):\n                    raise ValueError(\"Student data is missing required keys (name, age, gender, grade).\")\n\n                cursor.execute(\"\"\"\n                    INSERT INTO students (name, age, gender, grade)\n                    VALUES (?, ?, ?, ?)\n                \"\"\", (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))\n                self.conn.commit()\n            except sqlite3.Error as e:\n                print(f\"Database error inserting student: {e}\")\n            except ValueError as e:\n                print(f\"Invalid input: {e}\")\n            finally:\n                self._close()\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.  Returns an empty list if no match is found or an error occurs.\n        \"\"\"\n        cursor = self._connect()\n        if cursor:\n            try:\n                cursor.execute(\"\"\"\n                    SELECT * FROM students WHERE name = ?\n                \"\"\", (name,))\n                result = cursor.fetchall()\n                return result\n            except sqlite3.Error as e:\n                print(f\"Database error searching for student: {e}\")\n                return []\n            finally:\n                self._close()\n        else:\n            return []\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        \"\"\"\n        cursor = self._connect()\n        if cursor:\n            try:\n                cursor.execute(\"\"\"\n                    DELETE FROM students WHERE name = ?\n                \"\"\", (name,))\n                self.conn.commit()\n            except sqlite3.Error as e:\n                print(f\"Database error deleting student: {e}\")\n            finally:\n                self._close()\n```",
    "84": "```python\nimport json\nimport re\n\nclass TextFileProcessor:\n    \"\"\"\n    The class handles reading, writing, and processing text files. It can read the file as JSON, read the raw text, write content to the file, and process the file by removing non-alphabetic characters.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initialize the file path.\n        :param file_path: str\n        \"\"\"\n        self.file_path = file_path\n\n    def read_file_as_json(self):\n        \"\"\"\n        Read the file as JSON.  If the file is not valid JSON, return None.\n        \"\"\"\n        try:\n            with open(self.file_path, 'r') as f:\n                return json.load(f)\n        except (json.JSONDecodeError, FileNotFoundError):\n            return None\n\n    def read_file(self):\n        \"\"\"\n        Read the content of the file.\n        \"\"\"\n        try:\n            with open(self.file_path, 'r') as f:\n                return f.read()\n        except FileNotFoundError:\n            return None\n\n    def write_file(self, content):\n        \"\"\"\n        Write content to the file, overwriting existing content.\n        \"\"\"\n        try:\n            with open(self.file_path, 'w') as f:\n                f.write(content)\n            return True  # Indicate success\n        except Exception as e:\n            print(f\"Error writing to file: {e}\")\n            return False #Indicate failure\n\n    def process_file(self):\n        \"\"\"\n        Read the file, remove non-alphabetic characters, and overwrite the file.\n        Returns the processed content. Returns None if there is a file error.\n        \"\"\"\n        try:\n            with open(self.file_path, 'r') as f:\n                content = f.read()\n\n            processed_content = ''.join(re.findall(r'[a-zA-Z]+', content))\n\n            with open(self.file_path, 'w') as f:\n                f.write(processed_content)\n\n            return processed_content\n        except FileNotFoundError:\n            return None\n\nif __name__ == '__main__':\n    # Example Usage (and basic tests)\n    test_file = \"test_example.txt\"\n\n    # Test write_file\n    processor = TextFileProcessor(test_file)\n    if processor.write_file(\"This is a test.\"):\n        print(\"write_file test: Success\")\n    else:\n        print(\"write_file test: Failure\")\n\n    # Test read_file\n    content = processor.read_file()\n    if content == \"This is a test.\":\n        print(\"read_file test: Success\")\n    else:\n        print(f\"read_file test: Failure, got: {content}\")\n\n    # Test process_file\n    processor.write_file(\"Hello, World! 123\")\n    processed_content = processor.process_file()\n    if processed_content == \"HelloWorld\":\n        print(\"process_file test: Success\")\n    else:\n        print(f\"process_file test: Failure, got: {processed_content}\")\n\n    # Test read_file_as_json (valid JSON)\n    processor.write_file('{\"name\": \"John\", \"age\": 30}')\n    json_data = processor.read_file_as_json()\n    if isinstance(json_data, dict) and json_data.get(\"name\") == \"John\":\n        print(\"read_file_as_json (valid) test: Success\")\n    else:\n        print(f\"read_file_as_json (valid) test: Failure, got: {json_data}\")\n\n    # Test read_file_as_json (invalid JSON)\n    processor.write_file(\"This is not JSON\")\n    json_data = processor.read_file_as_json()\n    if json_data is None:\n        print(\"read_file_as_json (invalid) test: Success\")\n    else:\n        print(f\"read_file_as_json (invalid) test: Failure, got: {json_data}\")\n\n    import os\n    try:\n        os.remove(test_file) # Clean up the test file\n    except OSError as e:\n        print(f\"Error deleting test file: {e}\")\n```",
    "85": "```python\nimport time\n\nclass Thermostat:\n    \"\"\"\n    Manages temperature control, including setting and retrieving the target temperature,\n    adjusting the mode, and simulating temperature operation.\n    \"\"\"\n\n    VALID_MODES = ['heat', 'cool']\n\n    def __init__(self, current_temperature, target_temperature, mode):\n        \"\"\"\n        Initializes a Thermostat instance.\n\n        :param current_temperature: The current temperature (float).\n        :param target_temperature: The target temperature (float).\n        :param mode: The operating mode ('heat' or 'cool').\n        :raises ValueError: If the mode is invalid.\n        \"\"\"\n        self.current_temperature = current_temperature\n        self.target_temperature = target_temperature\n        self.mode = self._validate_mode(mode)\n\n    def _validate_mode(self, mode):\n        \"\"\"\n        Validates the operating mode.\n\n        :param mode: The operating mode (string).\n        :return: The validated mode.\n        :raises ValueError: If the mode is invalid.\n        \"\"\"\n        if mode not in self.VALID_MODES:\n            raise ValueError(f\"Invalid mode: {mode}.  Must be one of {self.VALID_MODES}\")\n        return mode\n\n    def get_target_temperature(self):\n        \"\"\"\n        Gets the target temperature.\n\n        :return: The target temperature (float).\n        \"\"\"\n        return self.target_temperature\n\n    def set_target_temperature(self, temperature):\n        \"\"\"\n        Sets the target temperature.\n\n        :param temperature: The target temperature (float).\n        \"\"\"\n        self.target_temperature = temperature\n\n    def get_mode(self):\n        \"\"\"\n        Gets the current operating mode.\n\n        :return: The operating mode (string).\n        \"\"\"\n        return self.mode\n\n    def set_mode(self, mode):\n        \"\"\"\n        Sets the operating mode.\n\n        :param mode: The operating mode ('heat' or 'cool').\n        :raises ValueError: If the mode is invalid.\n        \"\"\"\n        self.mode = self._validate_mode(mode)\n\n    def auto_set_mode(self):\n        \"\"\"\n        Automatically sets the operating mode based on the current and target temperatures.\n        If the current temperature is lower than the target temperature, the mode is set to 'heat',\n        otherwise, it's set to 'cool'.\n        \"\"\"\n        if self.current_temperature < self.target_temperature:\n            self.mode = 'heat'\n        else:\n            self.mode = 'cool'\n\n    def auto_check_conflict(self):\n        \"\"\"\n        Checks for conflicts between the operating mode and the temperature relationship.\n        If a conflict exists, the operating mode is adjusted automatically.\n\n        :return: True if there is no conflict, False otherwise.\n        \"\"\"\n        if self.mode == 'heat' and self.current_temperature >= self.target_temperature:\n            self.mode = 'cool'\n            return False\n        elif self.mode == 'cool' and self.current_temperature <= self.target_temperature:\n            self.mode = 'heat'\n            return False\n        else:\n            return True\n\n    def simulate_operation(self, temperature_change_rate=1.0, check_interval=0.1):\n        \"\"\"\n        Simulates the operation of the thermostat, adjusting the current temperature\n        until it reaches the target temperature.\n\n        :param temperature_change_rate: The amount the temperature changes per interval (default: 1.0).\n        :param check_interval: The time interval between temperature adjustments (default: 0.1).\n        :return: The time it took to complete the simulation (integer seconds).\n        \"\"\"\n        start_time = time.time()\n        self.auto_set_mode()\n\n        while abs(self.current_temperature - self.target_temperature) > 0.1:\n            if self.mode == 'heat':\n                self.current_temperature += temperature_change_rate * check_interval\n            else:\n                self.current_temperature -= temperature_change_rate * check_interval\n\n            self.auto_check_conflict()\n            time.sleep(check_interval)\n\n        end_time = time.time()\n        return int(end_time - start_time)\n```",
    "86": "```python\nclass TicTacToe:\n    \"\"\"\n    The class represents a game of Tic-Tac-Toe and its functions include making a move on the board, checking for a winner, and determining if the board is full.\n    \"\"\"\n\n    def __init__(self, N=3):\n        \"\"\"\n        Initialize a game board with all empty spaces and the starting player.\n        :param N: int, the size of the board (N x N), default is 3\n        \"\"\"\n        self.N = N\n        self.board = [[' ' for _ in range(N)] for _ in range(N)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Place the current player's mark at the specified position on the board and switch the player.\n        :param row: int, the row index of the position (0-indexed)\n        :param col: int, the column index of the position (0-indexed)\n        :return: bool, indicating whether the move was successful or not\n        \"\"\"\n        if not (0 <= row < self.N and 0 <= col < self.N):\n            return False  # Invalid move: out of bounds\n        if self.board[row][col] != ' ':\n            return False  # Invalid move: space already occupied\n\n        self.board[row][col] = self.current_player\n        self.current_player = 'O' if self.current_player == 'X' else 'X'\n        return True\n\n    def check_winner(self):\n        \"\"\"\n        Check if there is a winner on the board.\n        :return: str or None, the mark of the winner ('X' or 'O'), or None if there is no winner yet\n        \"\"\"\n\n        # Check rows\n        for row in range(self.N):\n            if self.board[row][0] == self.board[row][1] == self.board[row][2] != ' ':\n                return self.board[row][0]\n\n        # Check columns\n        for col in range(self.N):\n            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':\n                return self.board[0][col]\n\n        # Check diagonals\n        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':\n            return self.board[0][0]\n        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':\n            return self.board[0][2]\n\n        return None\n\n    def is_board_full(self):\n        \"\"\"\n        Check if the game board is completely filled.\n        :return: bool, indicating whether the game board is full or not\n        \"\"\"\n        for row in range(self.N):\n            for col in range(self.N):\n                if self.board[row][col] == ' ':\n                    return False\n        return True\n\n    def print_board(self):\n        \"\"\"Prints the current state of the board.\"\"\"\n        for row in self.board:\n            print(\"|\" + \"|\".join(row) + \"|\")\n\n\nif __name__ == '__main__':\n    ttt = TicTacToe()\n    moves = [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0)]  # Corrected moves to win for X\n    for move in moves:\n        if ttt.make_move(move[0], move[1]):\n            ttt.print_board()\n        else:\n            print(f\"Invalid move at {move}\")\n            break\n    winner = ttt.check_winner()\n    if winner:\n        print(f\"The winner is {winner}!\")\n    elif ttt.is_board_full():\n        print(\"It's a draw!\")\n    else:\n        print(\"The game is still in progress.\")\n```",
    "87": "```python\nimport datetime\n\nclass TimeUtils:\n    \"\"\"\n    A utility class for time-related operations.\n    \"\"\"\n\n    DEFAULT_DATETIME_FORMAT = \"%Y-%m-%d %H:%M:%S\"\n    DEFAULT_TIME_FORMAT = \"%H:%M:%S\"\n    DEFAULT_DATE_FORMAT = \"%Y-%m-%d\"\n\n    def __init__(self, now=None):\n        \"\"\"\n        Initializes the TimeUtils object.\n\n        Args:\n            now (datetime, optional):  A datetime object to use as the current time.\n                Defaults to None, which uses datetime.datetime.now().  Useful for testing.\n        \"\"\"\n        self.now = now if now else datetime.datetime.now()\n\n\n    def get_current_time(self, fmt=None):\n        \"\"\"\n        Returns the current time in the specified format.  If no format is specified,\n        uses DEFAULT_TIME_FORMAT.\n\n        Args:\n            fmt (str, optional): The format string for the time. Defaults to None.\n\n        Returns:\n            str: The current time as a string.\n\n        Examples:\n            >>> timeutils = TimeUtils(datetime.datetime(2023, 1, 1, 10, 30, 0))\n            >>> timeutils.get_current_time()\n            '10:30:00'\n            >>> timeutils.get_current_time(\"%I:%M %p\")\n            '10:30 AM'\n        \"\"\"\n        fmt = fmt or self.DEFAULT_TIME_FORMAT\n        return self.now.strftime(fmt)\n\n\n    def get_current_date(self, fmt=None):\n        \"\"\"\n        Returns the current date in the specified format.  If no format is specified,\n        uses DEFAULT_DATE_FORMAT.\n\n        Args:\n            fmt (str, optional): The format string for the date. Defaults to None.\n\n        Returns:\n            str: The current date as a string.\n\n        Examples:\n            >>> timeutils = TimeUtils(datetime.datetime(2023, 1, 1, 10, 30, 0))\n            >>> timeutils.get_current_date()\n            '2023-01-01'\n            >>> timeutils.get_current_date(\"%m/%d/%Y\")\n            '01/01/2023'\n        \"\"\"\n        fmt = fmt or self.DEFAULT_DATE_FORMAT\n        return self.now.strftime(fmt)\n\n\n    def add_seconds(self, seconds, fmt=None):\n        \"\"\"\n        Adds the specified number of seconds to the current time and returns the\n        result as a string in the specified format.  If no format is specified,\n        uses DEFAULT_TIME_FORMAT.\n\n        Args:\n            seconds (int): The number of seconds to add.\n            fmt (str, optional): The format string for the time. Defaults to None.\n\n        Returns:\n            str: The time after adding the seconds, as a string.\n\n        Examples:\n            >>> timeutils = TimeUtils(datetime.datetime(2023, 1, 1, 10, 30, 0))\n            >>> timeutils.add_seconds(600)\n            '10:40:00'\n            >>> timeutils.add_seconds(600, \"%I:%M %p\")\n            '10:40 AM'\n        \"\"\"\n        fmt = fmt or self.DEFAULT_TIME_FORMAT\n        new_datetime = self.now + datetime.timedelta(seconds=seconds)\n        return new_datetime.strftime(fmt)\n\n\n    def string_to_datetime(self, string, fmt=None):\n        \"\"\"\n        Converts a time string to a datetime object.  If no format is specified,\n        uses DEFAULT_DATETIME_FORMAT.\n\n        Args:\n            string (str): The time string to convert.\n            fmt (str, optional): The format string for the time. Defaults to None.\n\n        Returns:\n            datetime: A datetime object representing the time string.\n\n        Raises:\n            ValueError: If the string does not match the format.\n\n        Examples:\n            >>> timeutils = TimeUtils()\n            >>> timeutils.string_to_datetime(\"2023-01-01 10:30:00\")\n            datetime.datetime(2023, 1, 1, 10, 30, 0)\n            >>> timeutils.string_to_datetime(\"01/01/2023 10:30:00\", \"%m/%d/%Y %H:%M:%S\")\n            datetime.datetime(2023, 1, 1, 10, 30, 0)\n        \"\"\"\n        fmt = fmt or self.DEFAULT_DATETIME_FORMAT\n        return datetime.datetime.strptime(string, fmt)\n\n\n    def datetime_to_string(self, dt_obj, fmt=None):\n        \"\"\"\n        Converts a datetime object to a string.  If no format is specified,\n        uses DEFAULT_DATETIME_FORMAT.\n\n        Args:\n            dt_obj (datetime): The datetime object to convert.\n            fmt (str, optional): The format string for the time. Defaults to None.\n\n        Returns:\n            str: The datetime object as a string.\n\n        Examples:\n            >>> timeutils = TimeUtils()\n            >>> dt = datetime.datetime(2023, 1, 1, 10, 30, 0)\n            >>> timeutils.datetime_to_string(dt)\n            '2023-01-01 10:30:00'\n            >>> timeutils.datetime_to_string(dt, \"%m/%d/%Y %H:%M:%S\")\n            '01/01/2023 10:30:00'\n        \"\"\"\n        fmt = fmt or self.DEFAULT_DATETIME_FORMAT\n        return dt_obj.strftime(fmt)\n\n\n    def get_minutes_difference(self, string_time1, string_time2, fmt=None):\n        \"\"\"\n        Calculates the difference in minutes between two times represented as strings.\n        Rounds the result to the nearest minute.  If no format is specified, uses\n        DEFAULT_DATETIME_FORMAT.\n\n        Args:\n            string_time1 (str): The first time string.\n            string_time2 (str): The second time string.\n            fmt (str, optional): The format string for the times. Defaults to None.\n\n        Returns:\n            int: The difference in minutes between the two times, rounded to the nearest minute.\n\n        Raises:\n            ValueError: If either time string does not match the format.\n\n        Examples:\n            >>> timeutils = TimeUtils()\n            >>> timeutils.get_minutes_difference(\"2023-01-01 01:01:01\", \"2023-01-01 02:01:01\")\n            60\n            >>> timeutils.get_minutes_difference(\"01/01/2023 01:01:01\", \"01/01/2023 02:01:01\", \"%m/%d/%Y %H:%M:%S\")\n            60\n        \"\"\"\n        fmt = fmt or self.DEFAULT_DATETIME_FORMAT\n        time1 = datetime.datetime.strptime(string_time1, fmt)\n        time2 = datetime.datetime.strptime(string_time2, fmt)\n        difference = time2 - time1\n        minutes = round(difference.total_seconds() / 60)\n        return minutes\n\n\n    def get_formatted_time(self, year, month, day, hour, minute, second, fmt=None):\n        \"\"\"\n        Creates a datetime object from the given components and returns it as a\n        formatted string.  If no format is specified, uses DEFAULT_DATETIME_FORMAT.\n\n        Args:\n            year (int): The year.\n            month (int): The month.\n            day (int): The day.\n            hour (int): The hour.\n            minute (int): The minute.\n            second (int): The second.\n            fmt (str, optional): The format string for the time. Defaults to None.\n\n        Returns:\n            str: The formatted time string.\n\n        Raises:\n            ValueError: If the date components are invalid.\n\n        Examples:\n            >>> timeutils = TimeUtils()\n            >>> timeutils.get_formatted_time(2023, 1, 1, 10, 30, 0)\n            '2023-01-01 10:30:00'\n            >>> timeutils.get_formatted_time(2023, 1, 1, 10, 30, 0, \"%m/%d/%Y %H:%M:%S\")\n            '01/01/2023 10:30:00'\n        \"\"\"\n        fmt = fmt or self.DEFAULT_DATETIME_FORMAT\n        dt = datetime.datetime(year, month, day, hour, minute, second)\n        return dt.strftime(fmt)\n```",
    "88": "```python\nfrom math import pi, fabs\n\nclass TriCalculator:\n    \"\"\"\n    Calculates trigonometric values (cosine, sine, tangent) using Taylor series approximations.\n    \"\"\"\n\n    def __init__(self, taylor_terms=50):\n        \"\"\"\n        Initializes the TriCalculator with the number of Taylor series terms to use.\n\n        Args:\n            taylor_terms (int): The number of terms to use in the Taylor series approximation.\n                                 Higher values provide better accuracy but increase computation time.\n                                 Defaults to 50.\n        \"\"\"\n        self.taylor_terms = taylor_terms\n\n    def _factorial(self, a):\n        \"\"\"\n        Calculates the factorial of a non-negative integer.\n\n        Args:\n            a (int): A non-negative integer.\n\n        Returns:\n            int: The factorial of a.  Returns 1 if a is 0.\n\n        Raises:\n            ValueError: If a is negative.\n        \"\"\"\n        if not isinstance(a, int):\n            raise TypeError(\"Factorial input must be an integer.\")\n        if a < 0:\n            raise ValueError(\"Factorial is not defined for negative numbers.\")\n        if a == 0:\n            return 1\n        result = 1\n        for i in range(1, a + 1):\n            result *= i\n        return result\n\n    def _taylor_cos(self, x_rad, n):\n        \"\"\"\n        Calculates the n-order Taylor series expansion value of cos(x_rad).\n\n        Args:\n            x_rad (float): The angle in radians.\n            n (int): The number of terms to use in the Taylor series.\n\n        Returns:\n            float: The approximate cosine value.\n        \"\"\"\n        cos_approx = 0\n        for i in range(n):\n            numerator = x_rad**(2*i)\n            denominator = self._factorial(2*i)\n            cos_approx += ((-1)**i) * (numerator/denominator)\n        return cos_approx\n\n    def _taylor_sin(self, x_rad, n):\n        \"\"\"\n        Calculates the n-order Taylor series expansion value of sin(x_rad).\n\n        Args:\n            x_rad (float): The angle in radians.\n            n (int): The number of terms to use in the Taylor series.\n\n        Returns:\n            float: The approximate sine value.\n        \"\"\"\n        sin_approx = 0\n        for i in range(n):\n            numerator = x_rad**(2*i+1)\n            denominator = self._factorial(2*i+1)\n            sin_approx += ((-1)**i) * (numerator/denominator)\n        return sin_approx\n\n    def cos(self, x_deg):\n        \"\"\"\n        Calculates the cosine of an angle given in degrees using the Taylor series approximation.\n\n        Args:\n            x_deg (float): The angle in degrees.\n\n        Returns:\n            float: The approximate cosine value.\n        \"\"\"\n        x_rad = (x_deg / 180) * pi\n        return self._taylor_cos(x_rad, self.taylor_terms)\n\n    def sin(self, x_deg):\n        \"\"\"\n        Calculates the sine of an angle given in degrees using the Taylor series approximation.\n\n        Args:\n            x_deg (float): The angle in degrees.\n\n        Returns:\n            float: The approximate sine value.\n        \"\"\"\n        x_rad = (x_deg / 180) * pi\n        return self._taylor_sin(x_rad, self.taylor_terms)\n\n    def tan(self, x_deg):\n        \"\"\"\n        Calculates the tangent of an angle given in degrees using the Taylor series approximation.\n\n        Args:\n            x_deg (float): The angle in degrees.\n\n        Returns:\n            float: The approximate tangent value.  Returns infinity if cosine is close to zero.\n        \"\"\"\n        cos_val = self.cos(x_deg)\n        if fabs(cos_val) < 1e-10:  # Check if cosine is close to zero to avoid division by zero\n            return float('inf')  # Return infinity if cosine is zero\n        return self.sin(x_deg) / cos_val\n```",
    "89": "```python\nimport random\nimport operator\nimport itertools\n\nclass TwentyFourPointGame:\n    \"\"\"\n    A game of twenty-four points, which generates four numbers and checks whether a player's expression evaluates to 24.\n    \"\"\"\n\n    def __init__(self):\n        self.nums = []\n\n    def _generate_cards(self):\n        \"\"\"\n        Generate four random numbers between 1 and 9 for the cards.\n        \"\"\"\n        self.nums = [random.randint(1, 9) for _ in range(4)]\n\n    def get_my_cards(self):\n        \"\"\"\n        Get a list of four random numbers between 1 and 9 representing the player's cards.\n        :return: list of integers, representing the player's cards\n        \"\"\"\n        self._generate_cards()\n        return self.nums\n\n    def is_solvable(self):\n      \"\"\"\n      Check if the current set of cards is solvable.\n      :return: bool, True if solvable, False otherwise\n      \"\"\"\n      if not self.nums:\n        return False\n\n      ops = [operator.add, operator.sub, operator.mul, operator.truediv]\n      for a, b, c, d in itertools.permutations(self.nums):\n          for op1, op2, op3 in itertools.product(ops, ops, ops):\n              try:\n                  if abs(op3(op2(op1(a, b), c), d) - 24) < 1e-6:\n                      return True\n                  if abs(op2(op1(a, b), op3(c, d)) - 24) < 1e-6:\n                      return True\n                  if abs(op1(a, op3(op2(b, c), d)) - 24) < 1e-6:\n                      return True\n                  if abs(op1(a, op2(b, op3(c, d))) - 24) < 1e-6:\n                      return True\n                  if abs(op3(op1(a, op2(b, c)), d) - 24) < 1e-6:\n                      return True\n              except ZeroDivisionError:\n                  continue\n      return False\n\n    def answer(self, expression):\n        \"\"\"\n        Check if a given mathematical expression using the cards can evaluate to 24.\n        :param expression: string, mathematical expression using the cards\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        \"\"\"\n        try:\n            # Validate that the expression only uses allowed characters and the numbers\n            allowed_chars = set(\"0123456789+-*/.() \")\n            allowed_numbers = set(str(num) for num in self.nums)\n            expression_chars = set(expression)\n            is_valid = all(char in allowed_chars for char in expression_chars) and \\\n                       all(number in expression for number in allowed_numbers)\n\n            if not is_valid:\n                return False\n\n            result = eval(expression)\n            return abs(result - 24) < 1e-6  # Use a tolerance for floating-point comparisons\n        except (SyntaxError, NameError, TypeError, ZeroDivisionError):\n            return False\n\n    def evaluate_expression(self, expression):\n        \"\"\"\n        Evaluate a mathematical expression and check if the result is 24.\n        :param expression: string, mathematical expression\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        \"\"\"\n        try:\n            result = eval(expression)\n            return abs(result - 24) < 1e-6  # Use a tolerance for floating-point comparisons\n        except (SyntaxError, NameError, TypeError, ZeroDivisionError):\n            return False\n```",
    "90": "```python\nfrom urllib.parse import urlparse, parse_qs\n\n\nclass URLHandler:\n    \"\"\"\n    The class supports to handle URLs, including extracting the scheme, host, path, query parameters, and fragment.\n    \"\"\"\n\n    def __init__(self, url):\n        \"\"\"\n        Initialize URLHandler's URL\n        \"\"\"\n        self.url = urlparse(url)\n\n    def get_scheme(self):\n        \"\"\"\n        get the scheme of the URL\n        :return: string, If successful, return the scheme of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_scheme()\n        \"https\"\n        \"\"\"\n        return self.url.scheme\n\n    def get_host(self):\n        \"\"\"\n        Get the second part of the URL, which is the host domain name\n        :return: string, If successful, return the host domain name of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_host()\n        \"www.baidu.com\"\n        \"\"\"\n        return self.url.netloc\n\n    def get_path(self):\n        \"\"\"\n        Get the third part of the URL, which is the address of the resource\n        :return: string, If successful, return the address of the resource of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_path()\n        \"/s\"\n        \"\"\"\n        return self.url.path\n\n    def get_query_params(self):\n        \"\"\"\n        Get the request parameters for the URL\n        :return: dict, If successful, return the request parameters of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_query_params()\n        {'wd': ['aaa'], 'rsv_spt': ['1']}\n        \"\"\"\n        return parse_qs(self.url.query)\n\n    def get_fragment(self):\n        \"\"\"\n        Get the fragment after '#' in the URL\n        :return: string, If successful, return the fragment after '#' of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_fragment()\n        \"page\"\n        \"\"\"\n        return self.url.fragment\n```",
    "91": "```python\nimport urllib.parse\n\nclass UrlPath:\n    \"\"\"\n    A utility for encapsulating and manipulating URL paths.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the UrlPath with an empty list of segments.\n        \"\"\"\n        self.segments = []\n\n    def add(self, segment):\n        \"\"\"\n        Adds a segment to the path.\n\n        Args:\n            segment (str): The segment to add.  Should not contain '/'.\n        \"\"\"\n        if not isinstance(segment, str):\n            raise TypeError(\"Segment must be a string.\")\n\n        if '/' in segment:\n            raise ValueError(\"Segment should not contain '/'.\")\n\n        self.segments.append(segment)\n\n    def parse(self, path, charset='utf-8'):\n        \"\"\"\n        Parses a URL path string into segments.\n\n        Args:\n            path (str): The URL path to parse.\n            charset (str): The character encoding of the path. Defaults to 'utf-8'.\n        \"\"\"\n        if not isinstance(path, str):\n            raise TypeError(\"Path must be a string.\")\n\n        if not isinstance(charset, str):\n            raise TypeError(\"Charset must be a string.\")\n\n        path = self._fix_path(path)\n        if path:\n            self.segments = path.split('/')\n        else:\n            self.segments = []\n\n\n    @staticmethod\n    def _fix_path(path):\n        \"\"\"\n        Removes leading and trailing slashes from a path.\n\n        Args:\n            path (str): The path to fix.\n\n        Returns:\n            str: The fixed path.\n        \"\"\"\n        if not isinstance(path, str):\n            raise TypeError(\"Path must be a string.\")\n\n        return path.strip('/')\n\n    def __str__(self):\n        \"\"\"\n        Returns the path as a string.\n\n        Returns:\n            str: The concatenated path segments, separated by '/'.\n        \"\"\"\n        return '/'.join(self.segments)\n\n    def get_encoded_path(self, charset='utf-8'):\n        \"\"\"\n        Returns the encoded path string.\n\n        Args:\n            charset (str): The character encoding to use. Defaults to 'utf-8'.\n\n        Returns:\n            str: The encoded path string.\n        \"\"\"\n        encoded_segments = [urllib.parse.quote(segment, encoding=charset) for segment in self.segments]\n        return '/'.join(encoded_segments)\n```",
    "92": "```python\nimport sqlite3\nimport hashlib\n\nclass UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information, searching user information, deleting user information, and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.db_name = db_name\n        self.connection = None\n        self.cursor = None\n        self.connect()\n        self.create_table()\n\n    def connect(self):\n        \"\"\"Connects to the database.\"\"\"\n        try:\n            self.connection = sqlite3.connect(self.db_name)\n            self.cursor = self.connection.cursor()\n        except sqlite3.Error as e:\n            print(f\"Database connection error: {e}\")\n            raise\n\n    def create_table(self):\n        \"\"\"\n        Creates the \"users\" table if it does not already exist.\n        \"\"\"\n        try:\n            self.cursor.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT PRIMARY KEY,\n                    password TEXT\n                )\n            \"\"\")\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Database table creation error: {e}\")\n            raise\n\n    def _hash_password(self, password):\n        \"\"\"Hashes the password using SHA-256.\"\"\"\n        hashed_password = hashlib.sha256(password.encode('utf-8')).hexdigest()\n        return hashed_password\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        \"\"\"\n        try:\n            hashed_password = self._hash_password(password)\n            self.cursor.execute(\"INSERT INTO users (username, password) VALUES (?, ?)\", (username, hashed_password))\n            self.connection.commit()\n        except sqlite3.IntegrityError:\n            print(f\"Username '{username}' already exists.\")\n            raise\n        except sqlite3.Error as e:\n            print(f\"Database insertion error: {e}\")\n            raise\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return:list of tuples, the rows from the \"users\" table that match the search criteria.\n        \"\"\"\n        try:\n            self.cursor.execute(\"SELECT * FROM users WHERE username = ?\", (username,))\n            return self.cursor.fetchall()\n        except sqlite3.Error as e:\n            print(f\"Database search error: {e}\")\n            raise\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute(\"DELETE FROM users WHERE username = ?\", (username,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Database deletion error: {e}\")\n            raise\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct\n        :param username:str, the username of the user to validate.\n        :param password:str, the password of the user to validate.\n        :return:bool, representing whether the user can log in correctly\n        \"\"\"\n        try:\n            self.cursor.execute(\"SELECT password FROM users WHERE username = ?\", (username,))\n            result = self.cursor.fetchone()\n\n            if result:\n                hashed_password = result[0]\n                return self._hash_password(password) == hashed_password\n            else:\n                return False\n        except sqlite3.Error as e:\n            print(f\"Database validation error: {e}\")\n            raise\n\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        if self.connection:\n            self.connection.close()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()\n\n\nif __name__ == '__main__':\n    # Example Usage (without doctests for brevity)\n    try:\n        with UserLoginDB(\"user_database.db\") as user_db:\n            # Insert a user\n            try:\n                user_db.insert_user('testuser', 'securepassword')\n            except sqlite3.IntegrityError:\n                print(\"User already exists.\")\n\n\n            # Validate login\n            if user_db.validate_user_login('testuser', 'securepassword'):\n                print(\"Login successful!\")\n            else:\n                print(\"Login failed.\")\n\n            # Search for the user\n            user = user_db.search_user_by_username('testuser')\n            print(f\"User found: {user}\")\n\n            # Delete the user\n            user_db.delete_user_by_username('testuser')\n            print(\"User deleted.\")\n\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n```",
    "93": "```python\nimport numpy as np\nfrom gensim import matutils\nfrom numpy import dot\n\nclass VectorUtil:\n    \"\"\"\n    Provides vector operations, including calculating similarity, cosine similarities, average similarity, and IDF weights.\n    \"\"\"\n\n    @staticmethod\n    def similarity(vector_1, vector_2):\n        \"\"\"\n        Compute the cosine similarity between two vectors.\n\n        Args:\n            vector_1 (numpy.ndarray): Vector from which similarities are to be computed, expected shape (dim,).\n            vector_2 (numpy.ndarray): Vector from which similarities are to be computed, expected shape (dim,).\n\n        Returns:\n            float: Cosine similarity between `vector_1` and `vector_2`.  Returns 0 if either vector is all zeros.\n\n        Raises:\n            TypeError: if inputs are not numpy arrays.\n            ValueError: if inputs are not 1D arrays or have different dimensions.\n\n        >>> vector_1 = np.array([1, 1])\n        >>> vector_2 = np.array([1, 0])\n        >>> VectorUtil.similarity(vector_1, vector_2)\n        0.7071067811865475\n        \"\"\"\n        if not isinstance(vector_1, np.ndarray) or not isinstance(vector_2, np.ndarray):\n            raise TypeError(\"Inputs must be numpy arrays.\")\n\n        if vector_1.ndim != 1 or vector_2.ndim != 1:\n            raise ValueError(\"Inputs must be 1D arrays.\")\n\n        if vector_1.shape != vector_2.shape:\n            raise ValueError(\"Vectors must have the same dimension.\")\n\n        vector_1 = matutils.unitvec(vector_1)\n        vector_2 = matutils.unitvec(vector_2)\n\n        return np.dot(vector_1, vector_2)\n\n\n\n    @staticmethod\n    def cosine_similarities(vector_1, vectors_all):\n        \"\"\"\n        Compute cosine similarities between one vector and a set of other vectors.\n\n        Args:\n            vector_1 (numpy.ndarray): Vector from which similarities are to be computed, expected shape (dim,).\n            vectors_all (list of numpy.ndarray or numpy.ndarray): For each row in vectors_all, distance from vector_1 is computed, expected shape (num_vectors, dim) or (dim,).\n\n        Returns:\n            numpy.ndarray: Contains cosine distance between `vector_1` and each row in `vectors_all`, shape (num_vectors,). Returns array of 0s if vector_1 is all zeros\n\n        Raises:\n            TypeError: if vector_1 is not a numpy array or vectors_all is not a list/numpy array.\n            ValueError: if vector_1 is not 1D or vectors in vectors_all do not have the same dimension as vector_1.\n\n        >>> vector1 = np.array([1, 2, 3])\n        >>> vectors_all = [np.array([4, 5, 6]), np.array([7, 8, 9])]\n        >>> VectorUtil.cosine_similarities(vector1, vectors_all)\n        array([0.97463185, 0.95941195])\n        \"\"\"\n        if not isinstance(vector_1, np.ndarray):\n            raise TypeError(\"vector_1 must be a numpy array.\")\n\n        if not isinstance(vectors_all, (list, np.ndarray)):\n            raise TypeError(\"vectors_all must be a list or numpy array.\")\n\n        if vector_1.ndim != 1:\n            raise ValueError(\"vector_1 must be a 1D array.\")\n\n        if isinstance(vectors_all, list):\n            for v in vectors_all:\n                if not isinstance(v, np.ndarray):\n                    raise TypeError(\"All elements in vectors_all must be numpy arrays.\")\n                if v.shape != vector_1.shape:\n                    raise ValueError(\"Vectors in vectors_all must have the same dimension as vector_1.\")\n            vectors_all = np.array(vectors_all)\n        elif isinstance(vectors_all, np.ndarray):\n            if vectors_all.ndim == 1:\n                if vectors_all.shape != vector_1.shape:\n                    raise ValueError(\"Vectors in vectors_all must have the same dimension as vector_1.\")\n                vectors_all = vectors_all[np.newaxis, :] # Reshape to 2D array\n            elif vectors_all.ndim == 2:\n                if vectors_all.shape[1] != vector_1.shape[0]:\n                    raise ValueError(\"Vectors in vectors_all must have the same dimension as vector_1.\")\n            else:\n                raise ValueError(\"vectors_all must be a 1D or 2D array.\")\n        else:\n            raise TypeError(\"vectors_all must be a list or numpy array.\")\n\n\n        vector_1 = matutils.unitvec(vector_1)\n        vectors_all = matutils.unitvec(vectors_all)\n\n\n        if vectors_all.ndim == 1:\n            return np.array([np.dot(vector_1, vectors_all)])  # Ensure it returns a NumPy array\n        else:\n            return np.dot(vectors_all, vector_1)\n\n\n    @staticmethod\n    def n_similarity(vector_list_1, vector_list_2):\n        \"\"\"\n        Compute average cosine similarity between two sets of vectors.\n\n        Args:\n            vector_list_1 (list of numpy.ndarray): List of numpy vectors.\n            vector_list_2 (list of numpy.ndarray): List of numpy vectors.\n\n        Returns:\n            float: Average cosine similarity between vector_list_1 and vector_list_2. Returns 0 if either list is empty.\n\n        Raises:\n            TypeError: if inputs are not lists or elements are not numpy arrays.\n            ValueError: if vectors within a list have inconsistent dimensions.\n\n        >>> vector_list1 = [np.array([1, 2, 3]), np.array([4, 5, 6])]\n        >>> vector_list2 = [np.array([7, 8, 9]), np.array([10, 11, 12])]\n        >>> VectorUtil.n_similarity(vector_list1, vector_list2)\n        0.9897287473881233\n        \"\"\"\n        if not isinstance(vector_list_1, list) or not isinstance(vector_list_2, list):\n            raise TypeError(\"Inputs must be lists.\")\n\n        if not vector_list_1 or not vector_list_2:\n            return 0.0\n\n        for v in vector_list_1 + vector_list_2:\n            if not isinstance(v, np.ndarray):\n                raise TypeError(\"All elements in the lists must be numpy arrays.\")\n            if v.ndim != 1:\n                raise ValueError(\"All vectors must be 1D arrays.\")\n\n        if len(vector_list_1) > 0:\n            dim1 = vector_list_1[0].shape[0]\n            for v in vector_list_1:\n                if v.shape[0] != dim1:\n                    raise ValueError(\"Vectors in vector_list_1 must have the same dimension.\")\n\n        if len(vector_list_2) > 0:\n            dim2 = vector_list_2[0].shape[0]\n            for v in vector_list_2:\n                if v.shape[0] != dim2:\n                    raise ValueError(\"Vectors in vector_list_2 must have the same dimension.\")\n\n\n        vector_list_1 = [matutils.unitvec(v) for v in vector_list_1]\n        vector_list_2 = [matutils.unitvec(v) for v in vector_list_2]\n\n        sum_sim = 0.0\n        for v1 in vector_list_1:\n            for v2 in vector_list_2:\n                sum_sim += np.dot(v1, v2)\n\n        return sum_sim / (len(vector_list_1) * len(vector_list_2))\n\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num, number_dict):\n        \"\"\"\n        Calculate log((total_num + 1) / (count + 1)) for each count in number_dict.\n\n        Args:\n            total_num (int): Total number of documents.\n            number_dict (dict): Dictionary where keys are terms and values are document frequencies.\n\n        Returns:\n            dict: Dictionary with the same keys as number_dict and IDF weights as values.\n\n        Raises:\n            TypeError: if total_num is not an integer or number_dict is not a dictionary.\n            ValueError: if total_num is negative or values in number_dict are not numeric.\n\n\n        >>> num_dict = {'key1':0.1, 'key2':0.5}\n        >>> VectorUtil.compute_idf_weight_dict(2, num_dict)\n        {'key1': 1.0033021088637848, 'key2': 0.6931471805599453}\n        \"\"\"\n        if not isinstance(total_num, int):\n            raise TypeError(\"total_num must be an integer.\")\n\n        if not isinstance(number_dict, dict):\n            raise TypeError(\"number_dict must be a dictionary.\")\n\n        if total_num < 0:\n            raise ValueError(\"total_num cannot be negative.\")\n\n        for key, count in number_dict.items():\n            if not isinstance(count, (int, float)):\n                raise ValueError(\"Values in number_dict must be numeric.\")\n\n        idf_weight = {}\n        for key, count in number_dict.items():\n            idf_weight[key] = np.log((total_num + 1) / (count + 1))\n        return idf_weight\n```",
    "94": "```python\nclass VendingMachine:\n    \"\"\"\n    This is a class to simulate a vending machine, including adding products, inserting coins, purchasing products, viewing balance, replenishing product inventory, and displaying product information.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the vending machine's inventory and balance.\n        \"\"\"\n        self.inventory = {}\n        self.balance = 0\n\n    def add_item(self, item_name, price, quantity):\n        \"\"\"\n        Adds a product to the vending machine's inventory.\n\n        Args:\n            item_name (str): The name of the product to be added.\n            price (float): The price of the product.\n            quantity (int): The quantity of the product.\n\n        Raises:\n            TypeError: If price is not a number or quantity is not an integer.\n            ValueError: If price or quantity is negative.\n        \"\"\"\n        if not isinstance(price, (int, float)):\n            raise TypeError(\"Price must be a number.\")\n        if not isinstance(quantity, int):\n            raise TypeError(\"Quantity must be an integer.\")\n        if price < 0:\n            raise ValueError(\"Price cannot be negative.\")\n        if quantity < 0:\n            raise ValueError(\"Quantity cannot be negative.\")\n\n        self.inventory[item_name] = {'price': price, 'quantity': quantity}\n\n    def insert_coin(self, amount):\n        \"\"\"\n        Inserts coins into the vending machine.\n\n        Args:\n            amount (float): The amount of coins to be inserted.\n\n        Returns:\n            float: The updated balance.\n\n        Raises:\n            TypeError: If amount is not a number.\n            ValueError: If amount is negative.\n        \"\"\"\n        if not isinstance(amount, (int, float)):\n            raise TypeError(\"Amount must be a number.\")\n        if amount <= 0:\n            raise ValueError(\"Amount must be positive.\")\n\n        self.balance += amount\n        return self.balance\n\n    def purchase_item(self, item_name):\n        \"\"\"\n        Purchases an item from the vending machine.\n\n        Args:\n            item_name (str): The name of the item to purchase.\n\n        Returns:\n            float: The updated balance after purchase, or False if the purchase fails.\n\n        Raises:\n            TypeError: if item_name is not a string\n        \"\"\"\n        if not isinstance(item_name, str):\n            raise TypeError(\"Item Name must be a string\")\n\n        if item_name not in self.inventory:\n            return False\n\n        if self.inventory[item_name]['quantity'] <= 0:\n            return False\n\n        if self.balance < self.inventory[item_name]['price']:\n            return False\n\n        self.balance -= self.inventory[item_name]['price']\n        self.inventory[item_name]['quantity'] -= 1\n        return self.balance\n\n    def restock_item(self, item_name, quantity):\n        \"\"\"\n        Restocks an existing item in the vending machine.\n\n        Args:\n            item_name (str): The name of the item to restock.\n            quantity (int): The quantity to add.\n\n        Returns:\n            bool: True if the item was restocked, False otherwise.\n\n        Raises:\n            TypeError: If quantity is not an integer.\n            ValueError: If quantity is negative.\n        \"\"\"\n        if not isinstance(quantity, int):\n            raise TypeError(\"Quantity must be an integer.\")\n        if quantity < 0:\n            raise ValueError(\"Quantity cannot be negative.\")\n\n        if item_name not in self.inventory:\n            return False\n\n        self.inventory[item_name]['quantity'] += quantity\n        return True\n\n    def display_items(self):\n        \"\"\"\n        Displays the available items in the vending machine.\n\n        Returns:\n            str: A formatted string of items or False if the machine is empty.\n        \"\"\"\n        if not self.inventory:\n            return False\n\n        item_strings = []\n        for item_name, details in self.inventory.items():\n            item_strings.append(f\"{item_name} - ${details['price']:.2f} [{details['quantity']}]\")  # Format price to 2 decimal places\n\n        return \", \".join(item_strings)\n```",
    "95": "```python\nclass Product:\n    \"\"\"Represents a product in the warehouse.\"\"\"\n\n    def __init__(self, product_id, name, quantity):\n        \"\"\"\n        Initializes a Product object.\n\n        Args:\n            product_id (int): The unique identifier for the product.\n            name (str): The name of the product.\n            quantity (int): The initial quantity of the product in stock.\n        \"\"\"\n        self.product_id = product_id\n        self.name = name\n        self.quantity = quantity\n\n    def __repr__(self):\n        return f\"Product(id={self.product_id}, name='{self.name}', quantity={self.quantity})\"\n\n\nclass Order:\n    \"\"\"Represents an order placed in the warehouse.\"\"\"\n\n    STATUSES = [\"Pending\", \"Shipped\", \"Delivered\", \"Cancelled\"]  # Valid order statuses\n\n    def __init__(self, order_id, product_id, quantity, status=\"Pending\"):\n        \"\"\"\n        Initializes an Order object.\n\n        Args:\n            order_id (int): The unique identifier for the order.\n            product_id (int): The ID of the product being ordered.\n            quantity (int): The quantity of the product being ordered.\n            status (str): The initial status of the order (default: \"Pending\").\n        \"\"\"\n        self.order_id = order_id\n        self.product_id = product_id\n        self.quantity = quantity\n        if status not in self.STATUSES:\n            raise ValueError(f\"Invalid order status: {status}.  Must be one of {self.STATUSES}\")\n        self.status = status\n\n    def __repr__(self):\n        return f\"Order(id={self.order_id}, product_id={self.product_id}, quantity={self.quantity}, status='{self.status}')\"\n\n\nclass Warehouse:\n    \"\"\"\n    Manages inventory and orders, including adding products, updating product quantities,\n    retrieving product quantities, creating orders, changing order statuses, and tracking orders.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the warehouse with empty inventory and order dictionaries.\n        self.inventory: dict[int, Product] - stores products, key is product_id, value is Product object\n        self.orders: dict[int, Order] - stores orders, key is order_id, value is Order object\n        \"\"\"\n        self.inventory = {}  # Product ID: Product object\n        self.orders = {}  # Order ID: Order object\n\n    def add_product(self, product_id, name, quantity):\n        \"\"\"\n        Adds a new product to the inventory or updates the quantity if the product already exists.\n\n        Args:\n            product_id (int): The unique identifier for the product.\n            name (str): The name of the product.\n            quantity (int): The quantity of the product to add.  Must be non-negative.\n\n        Raises:\n            ValueError: If quantity is negative.\n        \"\"\"\n        if quantity < 0:\n            raise ValueError(\"Quantity must be non-negative.\")\n\n        if product_id in self.inventory:\n            self.inventory[product_id].quantity += quantity\n        else:\n            self.inventory[product_id] = Product(product_id, name, quantity)\n\n    def update_product_quantity(self, product_id, quantity_change):\n        \"\"\"\n        Updates the quantity of an existing product in the inventory.\n\n        Args:\n            product_id (int): The unique identifier for the product.\n            quantity_change (int): The amount to change the quantity by (can be positive or negative).\n\n        Raises:\n            ValueError: If the resulting quantity would be negative.\n            KeyError: If the product_id is not found in inventory.\n        \"\"\"\n        if product_id not in self.inventory:\n            raise KeyError(f\"Product with ID {product_id} not found in inventory.\")\n\n        new_quantity = self.inventory[product_id].quantity + quantity_change\n        if new_quantity < 0:\n            raise ValueError(f\"Cannot reduce quantity below zero for product ID {product_id}.\")\n\n        self.inventory[product_id].quantity = new_quantity\n\n    def get_product_quantity(self, product_id):\n        \"\"\"\n        Retrieves the quantity of a specific product in the inventory.\n\n        Args:\n            product_id (int): The unique identifier for the product.\n\n        Returns:\n            int: The quantity of the product, or 0 if the product is not found.\n        \"\"\"\n        if product_id in self.inventory:\n            return self.inventory[product_id].quantity\n        else:\n            return 0\n\n    def create_order(self, order_id, product_id, quantity):\n        \"\"\"\n        Creates a new order and updates the inventory.\n\n        Args:\n            order_id (int): The unique identifier for the order.\n            product_id (int): The ID of the product being ordered.\n            quantity (int): The quantity of the product to order.\n\n        Returns:\n            bool: True if the order was created successfully, False otherwise (e.g., insufficient stock).\n\n        Raises:\n            ValueError: If quantity is negative.\n            KeyError: If the product_id is not found in inventory.\n        \"\"\"\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be positive.\")\n\n        if product_id not in self.inventory:\n            raise KeyError(f\"Product with ID {product_id} not found in inventory.\")\n\n        if self.inventory[product_id].quantity < quantity:\n            return False  # Insufficient stock\n\n        try:\n            self.update_product_quantity(product_id, -quantity) # Reduce inventory\n        except ValueError:\n            # Should never happen if we check quantity correctly, but good to be safe\n            return False\n\n        self.orders[order_id] = Order(order_id, product_id, quantity)\n        return True\n\n    def change_order_status(self, order_id, status):\n        \"\"\"\n        Changes the status of an existing order.\n\n        Args:\n            order_id (int): The unique identifier for the order.\n            status (str): The new status for the order.  Must be one of Order.STATUSES.\n\n        Returns:\n            bool: True if the order status was changed successfully, False if the order_id is not found.\n\n        Raises:\n            ValueError: If the provided status is invalid.\n        \"\"\"\n        if order_id not in self.orders:\n            return False\n\n        try:\n            self.orders[order_id].status = status\n        except ValueError as e:\n            raise ValueError(str(e))\n        return True\n\n    def track_order(self, order_id):\n        \"\"\"\n        Retrieves the status of a specific order.\n\n        Args:\n            order_id (int): The unique identifier for the order.\n\n        Returns:\n            str: The status of the order, or None if the order is not found.\n        \"\"\"\n        if order_id in self.orders:\n            return self.orders[order_id].status\n        else:\n            return None\n```",
    "96": "```python\nclass WeatherSystem:\n    \"\"\"\n    A class representing a weather system that provides functionality to query weather information for a specific city and convert temperature units between Celsius and Fahrenheit.\n    \"\"\"\n\n    def __init__(self, city):\n        \"\"\"\n        Initializes the weather system with a city name.\n\n        Args:\n            city (str): The name of the city.\n        \"\"\"\n        self.city = city\n        self.weather_data = None  # Store weather data for the city\n\n    def query(self, weather_data, temp_units='celsius'):\n        \"\"\"\n        Queries the weather system for the weather and temperature of the city, and converts the temperature units if necessary.\n\n        Args:\n            weather_data (dict): A dictionary of weather information for different cities.  Each city's data should include 'weather', 'temperature', and 'units' (celsius or fahrenheit).\n            temp_units (str, optional): The desired temperature units ('celsius' or 'fahrenheit'). Defaults to 'celsius'.\n\n        Returns:\n            tuple: A tuple containing the temperature and weather of the city, or None if the city is not found.  The temperature will be in the requested units.\n\n        Raises:\n            ValueError: If temp_units is not 'celsius' or 'fahrenheit'.\n            TypeError: If temperature is not a number.\n        \"\"\"\n        if not isinstance(weather_data, dict):\n            raise TypeError(\"weather_data must be a dictionary\")\n        if temp_units not in ('celsius', 'fahrenheit'):\n            raise ValueError(\"temp_units must be 'celsius' or 'fahrenheit'\")\n\n        if self.city in weather_data:\n            city_data = weather_data[self.city]\n\n            if not isinstance(city_data, dict):\n                raise TypeError(f\"Weather data for {self.city} must be a dictionary\")\n\n            if 'weather' not in city_data or 'temperature' not in city_data or 'units' not in city_data:\n                raise ValueError(f\"Weather data for {self.city} is missing required keys (weather, temperature, units)\")\n\n            weather = city_data['weather']\n            temperature = city_data['temperature']\n            current_units = city_data['units']\n\n            if not isinstance(temperature, (int, float)):\n                raise TypeError(\"Temperature must be a number\")\n\n            if current_units not in ('celsius', 'fahrenheit'):\n                 raise ValueError(f\"Units must be 'celsius' or 'fahrenheit' for {self.city}\")\n\n\n            if current_units != temp_units:\n                if temp_units == 'fahrenheit' and current_units == 'celsius':\n                    temperature = self.celsius_to_fahrenheit(temperature)\n                elif temp_units == 'celsius' and current_units == 'fahrenheit':\n                    temperature = self.fahrenheit_to_celsius(temperature)\n\n            return (temperature, weather)\n        else:\n            return None\n\n    def set_city(self, city):\n        \"\"\"\n        Sets the city of the weather system.\n\n        Args:\n            city (str): The city to set.\n        \"\"\"\n        if not isinstance(city, str):\n            raise TypeError(\"City must be a string\")\n        self.city = city\n\n    def celsius_to_fahrenheit(self, celsius):\n        \"\"\"\n        Converts a temperature from Celsius to Fahrenheit.\n\n        Args:\n            celsius (float): The temperature in Celsius.\n\n        Returns:\n            float: The temperature in Fahrenheit.\n\n        Raises:\n            TypeError: If celsius is not a number.\n        \"\"\"\n        if not isinstance(celsius, (int, float)):\n            raise TypeError(\"Celsius temperature must be a number\")\n        return celsius * 9 / 5 + 32\n\n    def fahrenheit_to_celsius(self, fahrenheit):\n        \"\"\"\n        Converts a temperature from Fahrenheit to Celsius.\n\n        Args:\n            fahrenheit (float): The temperature in Fahrenheit.\n\n        Returns:\n            float: The temperature in Celsius.\n\n        Raises:\n            TypeError: If fahrenheit is not a number.\n        \"\"\"\n        if not isinstance(fahrenheit, (int, float)):\n            raise TypeError(\"Fahrenheit temperature must be a number\")\n        return (fahrenheit - 32) * 5 / 9\n```",
    "97": "```python\nimport re\n\nclass Words2Numbers:\n    \"\"\"\n    The class provides a text-to-number conversion utility, allowing conversion of written numbers (in words) to their numerical representation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the word lists and dictionaries required for conversion.\n        \"\"\"\n        self.numwords = {}\n        self.units = [\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\n            \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n            \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\",\n        ]\n        self.tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        self.scales = [\"hundred\", \"thousand\", \"million\", \"billion\", \"trillion\"]\n\n        self.numwords[\"and\"] = (1, 0)\n        for idx, word in enumerate(self.units):\n            self.numwords[word] = (1, idx)\n        for idx, word in enumerate(self.tens):\n            self.numwords[word] = (1, idx * 10)\n        for idx, word in enumerate(self.scales):\n            self.numwords[word] = (10 ** (idx * 3 if idx else 2), 0) # Handles hundred correctly\n\n        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}\n        self.ordinal_endings = [('ieth', 'y'), ('th', '')]\n\n    def text2int(self, textnum):\n        \"\"\"\n        Convert the word string to the corresponding integer.\n\n        Handles hyphenated numbers and correctly parses complex numbers.\n        :param textnum: string, the word string to be converted\n        :return: int, the converted integer, or None if conversion fails\n        >>> w2n = Words2Numbers()\n        >>> w2n.text2int(\"thirty-two\")\n        32\n        >>> w2n.text2int(\"one hundred and forty-two\")\n        142\n        >>> w2n.text2int(\"two million three hundred forty-five thousand six hundred and seventy-eight\")\n        2345678\n        >>> w2n.text2int(\"invalid input\") is None\n        True\n        \"\"\"\n        textnum = textnum.lower()\n        textnum = re.sub(r'[\\s-]+', ' ', textnum).strip()  # Normalize whitespace and hyphens\n        tokens = textnum.split()\n\n        current = 0\n        result = 0\n\n        for word in tokens:\n            if word not in self.numwords:\n                return None  # Invalid input\n\n            scale, increment = self.numwords[word]\n            current = current * scale + increment\n\n            if scale > 100:\n                result += current\n                current = 0\n\n        result += current\n        return result\n\n    def is_valid_input(self, textnum):\n        \"\"\"\n        Check if the input text contains only valid words that can be converted into numbers.\n\n        Handles hyphenated words in the input.\n        :param textnum: The input text containing words representing numbers.\n        :return: True if input is valid, False otherwise.\n        >>> w2n = Words2Numbers()\n        >>> w2n.is_valid_input(\"thirty-two\")\n        True\n        >>> w2n.is_valid_input(\"thirty-invalid\")\n        False\n        \"\"\"\n        textnum = textnum.lower()\n        textnum = re.sub(r'[\\s-]+', ' ', textnum).strip()  # Normalize whitespace and hyphens\n        tokens = textnum.split()\n\n        for word in tokens:\n            if word not in self.numwords:\n                return False\n        return True\n```",
    "98": "```python\nimport xml.etree.ElementTree as ET\n\n\nclass XMLProcessor:\n    \"\"\"\n    A class for handling XML files, including reading, writing, processing, and finding elements.\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initializes the XMLProcessor object with the given file name.\n\n        Args:\n            file_name (str): The name of the XML file to be processed.\n        \"\"\"\n        self.file_name = file_name\n        self.root = None\n\n    def read_xml(self):\n        \"\"\"\n        Reads the XML file and sets the root element.\n\n        Returns:\n            ET.Element: The root element of the XML file, or None if an error occurred.\n        \"\"\"\n        try:\n            tree = ET.parse(self.file_name)\n            self.root = tree.getroot()\n            return self.root\n        except FileNotFoundError:\n            print(f\"Error: File '{self.file_name}' not found.\")\n            return None\n        except ET.ParseError as e:\n            print(f\"Error: Failed to parse XML file '{self.file_name}': {e}\")\n            return None\n        except Exception as e:\n            print(f\"An unexpected error occurred while reading '{self.file_name}': {e}\")\n            return None\n\n    def write_xml(self, file_name):\n        \"\"\"\n        Writes the XML data to the specified file.\n\n        Args:\n            file_name (str): The name of the file to write the XML data to.\n\n        Returns:\n            bool: True if the write operation is successful, False otherwise.\n        \"\"\"\n        if self.root is None:\n            print(\"Error: No XML data to write.  Call read_xml() first.\")\n            return False\n\n        try:\n            tree = ET.ElementTree(self.root)\n            tree.write(file_name, encoding=\"utf-8\", xml_declaration=True)  # Added encoding and declaration\n            return True\n        except Exception as e:\n            print(f\"Error writing to file '{file_name}': {e}\")\n            return False\n\n    def process_xml_data(self, file_name):\n        \"\"\"\n        Modifies the data in XML elements by converting text to uppercase and writes the updated XML data to a new file.\n\n        Args:\n            file_name (str): The name of the file to write the modified XML data to.\n\n        Returns:\n            bool: True if the write operation is successful, False otherwise.\n        \"\"\"\n        if self.root is None:\n            print(\"Error: XML data not loaded. Call read_xml() first.\")\n            return False\n\n        try:\n            for element in self.root.iter():\n                if element.text:\n                    element.text = element.text.upper()\n            return self.write_xml(file_name)\n        except Exception as e:\n            print(f\"Error processing XML data: {e}\")\n            return False\n\n    def find_element(self, element_name):\n        \"\"\"\n        Finds all XML elements with the specified name.\n\n        Args:\n            element_name (str): The name of the elements to find.\n\n        Returns:\n            list: A list of found elements with the specified name.  Returns an empty list if no elements are found or if the XML is not loaded.\n        \"\"\"\n        if self.root is None:\n            print(\"Error: XML data not loaded. Call read_xml() first.\")\n            return []\n\n        try:\n            return self.root.findall(element_name)\n        except Exception as e:\n            print(f\"Error finding element '{element_name}': {e}\")\n            return []\n```",
    "99": "```python\nimport zipfile\nimport os\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n\nclass ZipFileProcessor:\n    \"\"\"\n    A class for processing zip files, providing functionalities to read, extract, and create zip archives.\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initializes the ZipFileProcessor with the name of the zip file.\n\n        Args:\n            file_name (str): The name of the zip file to be processed.\n        \"\"\"\n        if not isinstance(file_name, str):\n            raise TypeError(\"file_name must be a string\")\n        self.file_name = file_name\n        logging.debug(f\"ZipFileProcessor initialized with file: {file_name}\")\n\n    def read_zip_file(self):\n        \"\"\"\n        Opens the zip file in read mode.\n\n        Returns:\n            zipfile.ZipFile: A ZipFile object if the file is successfully opened, None otherwise.\n        \"\"\"\n        try:\n            zip_file = zipfile.ZipFile(self.file_name, 'r')\n            logging.info(f\"Successfully opened zip file: {self.file_name}\")\n            return zip_file\n        except FileNotFoundError:\n            logging.error(f\"File not found: {self.file_name}\")\n            return None\n        except zipfile.BadZipFile:\n            logging.error(f\"Not a valid zip file: {self.file_name}\")\n            return None\n        except Exception as e:\n            logging.exception(f\"An unexpected error occurred while reading {self.file_name}: {e}\")\n            return None\n\n    def extract_all(self, output_path):\n        \"\"\"\n        Extracts all files from the zip archive to the specified output path.\n\n        Args:\n            output_path (str): The directory where the files will be extracted.\n\n        Returns:\n            bool: True if the extraction was successful, False otherwise.\n        \"\"\"\n        if not isinstance(output_path, str):\n            raise TypeError(\"output_path must be a string\")\n\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                zip_file.extractall(output_path)\n            logging.info(f\"Successfully extracted all files from {self.file_name} to {output_path}\")\n            return True\n        except FileNotFoundError:\n            logging.error(f\"File not found: {self.file_name}\")\n            return False\n        except zipfile.BadZipFile:\n            logging.error(f\"Not a valid zip file: {self.file_name}\")\n            return False\n        except Exception as e:\n            logging.exception(f\"An unexpected error occurred while extracting all from {self.file_name}: {e}\")\n            return False\n\n    def extract_file(self, file_name, output_path):\n        \"\"\"\n        Extracts a specific file from the zip archive to the specified output path.\n\n        Args:\n            file_name (str): The name of the file to extract.\n            output_path (str): The directory where the file will be extracted.\n\n        Returns:\n            bool: True if the extraction was successful, False otherwise.\n        \"\"\"\n        if not isinstance(file_name, str):\n            raise TypeError(\"file_name must be a string\")\n        if not isinstance(output_path, str):\n            raise TypeError(\"output_path must be a string\")\n\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                zip_file.extract(file_name, output_path)\n            logging.info(f\"Successfully extracted {file_name} from {self.file_name} to {output_path}\")\n            return True\n        except FileNotFoundError:\n            logging.error(f\"File not found: {self.file_name}\")\n            return False\n        except zipfile.BadZipFile:\n            logging.error(f\"Not a valid zip file: {self.file_name}\")\n            return False\n        except KeyError:\n            logging.error(f\"File {file_name} not found in the zip archive {self.file_name}\")\n            return False\n        except Exception as e:\n            logging.exception(f\"An unexpected error occurred while extracting {file_name} from {self.file_name}: {e}\")\n            return False\n\n    def create_zip_file(self, files, output_file_name):\n        \"\"\"\n        Creates a zip file containing the specified files.\n\n        Args:\n            files (list of str): A list of file paths to be added to the zip archive.\n            output_file_name (str): The name of the zip file to be created (without the .zip extension).\n\n        Returns:\n            bool: True if the zip file was created successfully, False otherwise.\n        \"\"\"\n        if not isinstance(files, list):\n            raise TypeError(\"files must be a list\")\n        if not isinstance(output_file_name, str):\n            raise TypeError(\"output_file_name must be a string\")\n\n        try:\n            zip_file_path = output_file_name + \".zip\"\n            with zipfile.ZipFile(zip_file_path, 'w') as zip_file:\n                for file in files:\n                    if not isinstance(file, str):\n                        logging.warning(f\"Skipping non-string file name: {file}\")\n                        continue\n\n                    if os.path.exists(file):\n                        zip_file.write(file)\n                        logging.debug(f\"Added {file} to {zip_file_path}\")\n                    else:\n                        logging.warning(f\"File not found, skipping: {file}\")\n            logging.info(f\"Successfully created zip file: {zip_file_path}\")\n            return True\n        except Exception as e:\n            logging.exception(f\"An unexpected error occurred while creating {output_file_name}.zip: {e}\")\n            return False\n\n\nif __name__ == '__main__':\n    # Example usage (create dummy files and then zip them)\n    try:\n        os.makedirs(\"output\", exist_ok=True)  # Create 'output' directory if it doesn't exist\n        os.makedirs(\"result/aaa\", exist_ok=True)  # Create 'result/aaa' directory if it doesn't exist\n\n        with open(\"bbb.txt\", \"w\") as f:\n            f.write(\"This is bbb.txt\")\n        with open(\"ccc.txt\", \"w\") as f:\n            f.write(\"This is ccc.txt\")\n        with open(\"ddd.txt\", \"w\") as f:\n            f.write(\"This is ddd.txt\")\n\n        zfp = ZipFileProcessor(\"aaa.zip\")  # This line is not doing anything useful\n        zfp = ZipFileProcessor(\"test.zip\")\n        zfp.create_zip_file([\"bbb.txt\", \"ccc.txt\", \"ddd.txt\"], \"output/bcd\")\n\n        # Extract all files to result/aaa folder\n        zfp = ZipFileProcessor(\"output/bcd.zip\")\n        zfp.extract_all(\"result/aaa\")\n\n        print(\"Example completed successfully.\")\n\n    except Exception as e:\n        print(f\"An error occurred during the example: {e}\")\n```"
}