{
    "60": "```python\nimport sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information, searching for movie information by name, and deleting movie information by name.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.db_name = db_name\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.Fields include ID of type int, movie name of type str, theater name of type str, seat number of type str, and customer name of type str\n        :return: None\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS tickets (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                movie_name TEXT NOT NULL,\n                theater_name TEXT NOT NULL,\n                seat_number TEXT NOT NULL,\n                customer_name TEXT NOT NULL\n            )\n        \"\"\")\n        self.connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute(\"\"\"\n                INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n                VALUES (?, ?, ?, ?)\n            \"\"\", (movie_name, theater_name, seat_number, customer_name))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n            self.connection.rollback()\n\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        >>> ticket_db = MovieTicketDB(\"ticket_database.db\")\n        >>> ticket_db.create_table()\n        >>> ticket_db.insert_ticket(\"Movie A\", \"Theater 1\", \"A1\", \"John Doe\")\n        >>> result = ticket_db.search_tickets_by_customer(\"John Doe\")\n        len(result) = 1\n        \"\"\"\n        try:\n            self.cursor.execute(\"\"\"\n                SELECT * FROM tickets WHERE customer_name = ?\n            \"\"\", (customer_name,))\n            return self.cursor.fetchall()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n            return []\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"\n        try:\n            self.cursor.execute(\"\"\"\n                DELETE FROM tickets WHERE id = ?\n            \"\"\", (ticket_id,))\n            self.connection.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n            self.connection.rollback()\n```",
    "61": "```python\nimport random\n\nclass MusicPlayer:\n    \"\"\"\n    This is a class as a music player that provides to play, stop, add songs, remove songs, set volume, shuffle, and switch to the next or previous song.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the music player with an empty playlist, no current song, and a default volume of 50.\n        \"\"\"\n        self.playlist = []\n        self.current_song = None\n        self.volume = 50\n        self.current_song_index = -1\n\n    def add_song(self, song):\n        \"\"\"\n        Adds a song to the playlist.\n        :param song: The song to add to the playlist, str.\n        \"\"\"\n        self.playlist.append(song)\n\n    def remove_song(self, song):\n        \"\"\"\n        Removes a song from the playlist.\n        :param song: The song to remove from the playlist, str.\n        \"\"\"\n        if song in self.playlist:\n            self.playlist.remove(song)\n            if self.current_song == song:\n                self.current_song = None\n                self.current_song_index = -1\n            else:\n                try:\n                    self.current_song_index = self.playlist.index(self.current_song)\n                except ValueError:\n                    self.current_song = None\n                    self.current_song_index = -1\n\n    def play(self):\n        \"\"\"\n        Plays the current song in the playlist.\n        :return: The current song in the playlist, or False if there is no current song.\n        \"\"\"\n        if self.current_song:\n            return self.current_song\n        elif self.playlist:\n            if self.current_song is None and self.current_song_index == -1:\n                self.current_song = self.playlist[0]\n                self.current_song_index = 0\n                return False\n        else:\n            return None\n\n    def stop(self):\n        \"\"\"\n        Stops the current song in the playlist.\n        :return: True if the current song was stopped, False if there was no current song.\n        \"\"\"\n        if self.current_song:\n            self.current_song = None\n            self.current_song_index = -1\n            return True\n        else:\n            return False\n\n    def switch_song(self):\n        \"\"\"\n        Switches to the next song in the playlist.\n        :return: True if the next song was switched to, False if there was no next song.\n        \"\"\"\n        if not self.playlist:\n            return False\n\n        if self.current_song is None and self.playlist:\n           return False\n        if self.current_song_index == -1 and self.current_song is None and self.playlist:\n            return False\n\n        if self.current_song_index == -1 and self.current_song is not None:\n            try:\n                self.current_song_index = self.playlist.index(self.current_song)\n            except ValueError:\n                return False\n\n        if self.current_song_index < len(self.playlist) - 1:\n            self.current_song_index += 1\n            self.current_song = self.playlist[self.current_song_index]\n            return True\n        else:\n            return False\n\n    def previous_song(self):\n        \"\"\"\n        Switches to the previous song in the playlist.\n        :return: True if the previous song was switched to, False if there was no previous song.\n        \"\"\"\n        if not self.playlist:\n            return False\n\n        if self.current_song is None and self.playlist:\n           return False\n        if self.current_song_index == -1 and self.current_song is None and self.playlist:\n            return False\n\n        if self.current_song_index == -1 and self.current_song is not None:\n            try:\n                self.current_song_index = self.playlist.index(self.current_song)\n            except ValueError:\n                return False\n\n        if self.current_song_index > 0:\n            self.current_song_index -= 1\n            self.current_song = self.playlist[self.current_song_index]\n            return True\n        else:\n            return False\n\n    def set_volume(self, volume):\n        \"\"\"\n        Sets the volume of the music player,ifthe volume is between 0 and 100 is valid.\n        :param volume: The volume to set the music player to,int.\n        :return: True if the volume was set, False if the volume was invalid.\n        \"\"\"\n        if 0 <= volume <= 100:\n            self.volume = volume\n            return None\n        else:\n            return False\n\n    def shuffle(self):\n        \"\"\"\n        Shuffles the playlist.\n        :return: True if the playlist was shuffled, False if the playlist was empty.\n        \"\"\"\n        if self.playlist:\n            random.shuffle(self.playlist)\n            try:\n                self.current_song_index = self.playlist.index(self.current_song)\n            except ValueError:\n                self.current_song = None\n                self.current_song_index = -1\n            return True\n        else:\n            return False\n```",
    "62": "```python\nclass NLPDataProcessor:\n    \"\"\"\n    The class processes NLP data by removing stop words from a list of strings using a pre-defined stop word list.\n    \"\"\"\n\n    def construct_stop_word_list(self):\n        \"\"\"\n        Construct a stop word list including 'a', 'an', 'the'.\n        :return: a list of stop words\n        >>> NLPDataProcessor.construct_stop_word_list()\n        ['a', 'an', 'the']\n        \"\"\"\n        return ['a', 'an', 'the']\n\n    def remove_stop_words(self, string_list, stop_word_list):\n        \"\"\"\n        Remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :param stop_word_list: a list of stop words\n        :return: a list of words without stop words\n        >>> NLPDataProcessor.process(['This is a test.'])\n        [['This', 'is', 'test.']]\n        \"\"\"\n        words_list = []\n        for string in string_list:\n            words = string.split()\n            words_without_stop_words = [word for word in words if word.lower() not in stop_word_list]\n            words_list.append(words_without_stop_words)\n        return words_list\n\n    def process(self, string_list):\n        \"\"\"\n        Construct a stop word list including 'a', 'an', 'the', and remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :return: a list of words without stop words\n        >>> NLPDataProcessor.process(['This is a test.'])\n        [['This', 'is', 'test.']]\n        \"\"\"\n        stop_word_list = self.construct_stop_word_list()\n        words_list = []\n        for string in string_list:\n            words = string.split()\n            words_without_stop_words = [word for word in words if word.lower() not in stop_word_list]\n            words_list.append(words_without_stop_words)\n        return words_list\n```",
    "63": "```python\nimport re\nfrom collections import Counter\n\nclass NLPDataProcessor2:\n    \"\"\"\n    The class processes NLP data by extracting words from a list of strings, calculating the frequency of each word, and returning the top 5 most frequent words.\n    \"\"\"\n\n\n    def process_data(self, string_list):\n        \"\"\"\n        keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words.\n        :param string_list: a list of strings\n        :return: words_list: a list of words lists\n        >>> NLPDataProcessor.process_data(['This is a test.'])\n        [['this', 'is', 'a', 'test']]\n        \"\"\"\n        words_list = []\n        for string in string_list:\n            string = re.sub(r'[^a-zA-Z\\s]', '', string)\n            string = string.lower()\n            words = string.split()\n            words_list.append(words)\n        return words_list\n\n    def calculate_word_frequency(self, words_list):\n        \"\"\"\n        Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.\n        :param words_list: a list of words lists\n        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency\n        >>> NLPDataProcessor.calculate_word_frequency([['this', 'is', 'a', 'test'], ['this', 'is', 'another', 'test']])\n        {'this': 2, 'is': 2, 'test': 2, 'a': 1, 'another': 1}\n        \"\"\"\n        word_counts = Counter()\n        for words in words_list:\n            word_counts.update(words)\n\n        # Sort the word frequency dictionary by value in descending order\n        sorted_word_counts = dict(sorted(word_counts.items(), key=lambda item: item[1], reverse=True))\n        top_5_word_counts = {}\n        count = 0\n        # for word, frequency in sorted_word_counts.items():\n        #   if count < 5:\n        #     top_5_word_counts[word] = frequency\n        #     count += 1\n        # return top_5_word_counts\n        if not words_list:\n            return {}\n        \n        all_words = []\n        for sublist in words_list:\n            all_words.extend(sublist)\n        \n        word_counts = Counter(all_words)\n        \n        return dict(word_counts.most_common(5))\n\n    def process(self, string_list):\n        \"\"\"\n        keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words. Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.\n        :param string_list: a list of strings\n        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency\n        >>> NLPDataProcessor.process(['This is a test.', 'This is another test.'])\n        {'this': 2, 'is': 2, 'test': 2, 'a': 1, 'another': 1}\n        \"\"\"\n        words_list = self.process_data(string_list)\n        word_frequency = self.calculate_word_frequency(words_list)\n        return word_frequency\n```",
    "64": "```python\nclass NumberConverter:\n    \"\"\"\n    The class allows to convert  decimal to binary, octal and hexadecimal repectively and contrarily\n    \"\"\"\n\n    @staticmethod\n    def decimal_to_binary(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to binary format.\n        :param decimal_num: int, decimal number\n        :return: str, the binary representation of an integer.\n        >>> NumberConverter.decimal_to_binary(42423)\n        '1010010110110111'\n        \"\"\"\n        if not isinstance(decimal_num, int):\n            raise TypeError(\"Input must be an integer.\")\n        if decimal_num < 0:\n            raise ValueError(\"Input must be a non-negative integer.\")\n\n        if decimal_num == 0:\n            return '0'\n        binary_num = ''\n        while decimal_num > 0:\n            binary_num = str(decimal_num % 2) + binary_num\n            decimal_num //= 2\n        return binary_num\n\n    @staticmethod\n    def binary_to_decimal(binary_num):\n        \"\"\"\n        Convert a number from binary format to decimal format.\n        :param binary_num: str, binary number\n        :return: int, the decimal representation of binary number str.\n        >>> NumberConverter.binary_to_decimal('1010010110110111')\n        42423\n        \"\"\"\n        if not isinstance(binary_num, str):\n            raise TypeError(\"Input must be a string.\")\n        if not all(c in '01' for c in binary_num):\n            raise ValueError(\"Input must be a valid binary string.\")\n\n        decimal_num = 0\n        power = 0\n        for digit in reversed(binary_num):\n            if digit == '1':\n                decimal_num += 2 ** power\n            power += 1\n        return decimal_num\n\n\n    @staticmethod\n    def decimal_to_octal(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to octal format.\n        :param decimal_num: int, decimal number\n        :return: str, the octal representation of an integer.\n        >>> NumberConverter.decimal_to_octal(42423)\n        '122667'\n        \"\"\"\n        if not isinstance(decimal_num, int):\n            raise TypeError(\"Input must be an integer.\")\n        if decimal_num < 0:\n            raise ValueError(\"Input must be a non-negative integer.\")\n\n        if decimal_num == 0:\n            return '0'\n        octal_num = ''\n        while decimal_num > 0:\n            octal_num = str(decimal_num % 8) + octal_num\n            decimal_num //= 8\n        return octal_num\n\n    @staticmethod\n    def octal_to_decimal(octal_num):\n        \"\"\"\n        Convert a number from octal format to decimal format.\n        :param octal_num: str, octal num\n        :return: int, the decimal representation of octal number str.\n        >>> NumberConverter.octal_to_decimal('122667')\n        42423\n        \"\"\"\n        if not isinstance(octal_num, str):\n            raise TypeError(\"Input must be a string.\")\n        if not all(c in '01234567' for c in octal_num):\n            raise ValueError(\"Input must be a valid octal string.\")\n        decimal_num = 0\n        power = 0\n        for digit in reversed(octal_num):\n            decimal_num += int(digit) * (8 ** power)\n            power += 1\n        return decimal_num\n\n    @staticmethod\n    def decimal_to_hex(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to hex format.\n        :param decimal_num: int, decimal number\n        :return hex_num: str, the hex representation of an integer.\n        >>> NumberConverter.decimal_to_hex(42423)\n        'a5b7'\n        \"\"\"\n        if not isinstance(decimal_num, int):\n            raise TypeError(\"Input must be an integer.\")\n        if decimal_num < 0:\n            raise ValueError(\"Input must be a non-negative integer.\")\n\n        hex_digits = \"0123456789abcdef\"\n        if decimal_num == 0:\n            return \"0\"\n        hex_num = \"\"\n        while decimal_num > 0:\n            remainder = decimal_num % 16\n            hex_num = hex_digits[remainder] + hex_num\n            decimal_num //= 16\n        return hex_num\n\n    @staticmethod\n    def hex_to_decimal(hex_num):\n        \"\"\"\n        Convert a number from hex format to decimal format.\n        :param hex_num: str, hex num\n        :return: int, the decimal representation of hex number str.\n        >>> NumberConverter.hex_to_decimal('a5b7')\n        42423\n        \"\"\"\n        if not isinstance(hex_num, str):\n            raise TypeError(\"Input must be a string.\")\n        if not all(c in '0123456789abcdefABCDEF' for c in hex_num):\n            raise ValueError(\"Input must be a valid hexadecimal string.\")\n\n        decimal_num = 0\n        power = 0\n        for digit in reversed(hex_num):\n            if '0' <= digit <= '9':\n                decimal_num += int(digit) * (16 ** power)\n            elif 'a' <= digit <= 'f':\n                decimal_num += (ord(digit) - ord('a') + 10) * (16 ** power)\n            elif 'A' <= digit <= 'F':\n                decimal_num += (ord(digit) - ord('A') + 10) * (16 ** power)\n            power += 1\n        return decimal_num\n```",
    "65": "```python\nclass NumberWordFormatter:\n    \"\"\"\n    This is a class that provides to convert numbers into their corresponding English word representation, including handling the conversion of both the integer and decimal parts, and incorporating appropriate connectors and units.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize NumberWordFormatter object.\n        \"\"\"\n        self.NUMBER = [\"\", \"ONE\", \"TWO\", \"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\"]\n        self.NUMBER_TEEN = [\"TEN\", \"ELEVEN\", \"TWELVE\", \"THIRTEEN\", \"FOURTEEN\", \"FIFTEEN\", \"SIXTEEN\", \"SEVENTEEN\",\n                            \"EIGHTEEN\",\n                            \"NINETEEN\"]\n        self.NUMBER_TEN = [\"TEN\", \"TWENTY\", \"THIRTY\", \"FORTY\", \"FIFTY\", \"SIXTY\", \"SEVENTY\", \"EIGHTY\", \"NINETY\"]\n        self.NUMBER_MORE = [\"\", \"THOUSAND\", \"MILLION\", \"BILLION\"]\n        self.NUMBER_SUFFIX = [\"k\", \"w\", \"\", \"m\", \"\", \"\", \"b\", \"\", \"\", \"t\", \"\", \"\", \"p\", \"\", \"\", \"e\"]\n\n    def format(self, x):\n        \"\"\"\n        Converts a number into words format\n        :param x: int or float, the number to be converted into words format\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.format(123456)\n        \"ONE HUNDRED AND TWENTY THREE THOUSAND FOUR HUNDRED AND FIFTY SIX ONLY\"\n        \"\"\"\n        if x is None:\n            return \"\"\n\n        if isinstance(x, float):\n            integer_part = int(x)\n            decimal_part = int(round((x - integer_part) * 100))\n            integer_words = self.format(integer_part)\n            decimal_words = self.trans_two(str(decimal_part).zfill(2))\n            if integer_words == \"ZERO ONLY\":\n                return \"ZERO AND CENTS \" + decimal_words + \" ONLY\"\n            return integer_words.replace(\"ONLY\", \"\").strip() + \" AND CENTS \" + decimal_words + \" ONLY\"\n\n        if x == 0:\n            return \"ZERO ONLY\"\n\n        s = str(int(x))\n        n = len(s)\n        res = []\n        for i in range(n // 3, -1, -1):\n            part = s[max(0, n - 3 * (i + 1)): n - 3 * i]\n            if part:\n                words = self.trans_three(part)\n                if words:\n                    res.append(words + \" \" + self.parse_more(i))\n        return \" \".join(res).strip() + \" ONLY\"\n\n    def format_string(self, x):\n        \"\"\"\n        Converts a string representation of a number into words format\n        :param x: str, the string representation of a number\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.format_string(\"123456\")\n        \"ONE HUNDRED AND TWENTY THREE THOUSAND FOUR HUNDRED AND FIFTY SIX ONLY\"\n        \"\"\"\n        try:\n            num = float(x)\n            return self.format(num)\n        except ValueError:\n            return \"\"\n\n    def trans_two(self, s):\n        \"\"\"\n        Converts a two-digit number into words format\n        :param s: str, the two-digit number\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.trans_two(\"23\")\n        \"TWENTY THREE\"\n        \"\"\"\n        if len(s) != 2:\n            return \"\"\n\n        if s[0] == '0':\n            if s[1] == '0':\n                return \"\"\n            else:\n                return self.NUMBER[int(s[1])]\n\n        if s[0] == '1':\n            return self.NUMBER_TEEN[int(s[1])]\n        else:\n            if s[1] == '0':\n                return self.NUMBER_TEN[int(s[0]) - 1]\n            else:\n                return self.NUMBER_TEN[int(s[0]) - 1] + \" \" + self.NUMBER[int(s[1])]\n\n    def trans_three(self, s):\n        \"\"\"\n        Converts a three-digit number into words format\n        :param s: str, the three-digit number\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.trans_three(\"123\")\n        \"ONE HUNDRED AND TWENTY THREE\"\n        \"\"\"\n        if len(s) != 3:\n            return \"\"\n\n        res = []\n        if s[0] != '0':\n            res.append(self.NUMBER[int(s[0])] + \" HUNDRED\")\n        two = self.trans_two(s[1:])\n        if two:\n            if res:\n                res.append(\"AND \" + two)\n            else:\n                res.append(two)\n        return \" \".join(res)\n\n    def parse_more(self, i):\n        \"\"\"\n        Parses the thousand/million/billion suffix based on the index\n        :param i: int, the index representing the magnitude (thousand, million, billion)\n        :return: str, the corresponding suffix for the magnitude\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.parse_more(1)\n        \"THOUSAND\"\n        \"\"\"\n        return self.NUMBER_MORE[i]\n```",
    "66": "```python\nclass NumericEntityUnescaper:\n    \"\"\"\n    This is a class that provides functionality to replace numeric entities with their corresponding characters in a given string.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def replace(self, string):\n        \"\"\"\n        Replaces numeric character references (HTML entities) in the input string with their corresponding Unicode characters.\n        :param string: str, the input string containing numeric character references.\n        :return: str, the input string with numeric character references replaced with their corresponding Unicode characters.\n        >>> unescaper = NumericEntityUnescaper()\n        >>> unescaper.replace(\"&#65;&#66;&#67;\")\n        'ABC'\n\n        \"\"\"\n        result = \"\"\n        i = 0\n        while i < len(string):\n            if string[i:i+2] == \"&#\":\n                start = i + 2\n                is_hex = False\n                if start < len(string) and string[start:start+1].lower() == 'x':\n                    is_hex = True\n                    start += 1\n                \n                end = string.find(\";\", start)\n                if end != -1:\n                    entity = string[start:end]\n                    try:\n                        if is_hex:\n                            char_code = int(entity, 16)\n                        else:\n                            char_code = int(entity)\n                        result += chr(char_code)\n                        i = end + 1\n                    except ValueError:\n                        result += string[i:end+1]\n                        i = end + 1\n                    except OverflowError:\n                        result += string[i:end+1]\n                        i = end + 1\n                else:\n                    result += string[i:]\n                    i = len(string)\n            else:\n                result += string[i]\n                i += 1\n        return result\n\n\n    @staticmethod\n    def is_hex_char(char):\n        \"\"\"\n        Determines whether a given character is a hexadecimal digit.\n        :param char: str, the character to check.\n        :return: bool, True if the character is a hexadecimal digit, False otherwise.\n        >>> NumericEntityUnescaper.is_hex_char('a')\n        True\n\n        \"\"\"\n        if '0' <= char <= '9' or 'a' <= char.lower() <= 'f':\n            return True\n        return False\n```",
    "67": "```python\nclass Order:\n    \"\"\"\n    The class manages restaurant orders by allowing the addition of dishes, calculation of the total cost, and checkout.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the order management system\n        self.menu stores the dishes of resturant inventory\n        menu = [{\"dish\": dish name, \"price\": price, \"count\": count}, ...]\n        self.selected_dishes stores the dished selected by customer\n        selected_dish = {\"dish\": dish name, \"count\": count, price: price}\n        self.sales stores the sales of each dish\n        sales = {dish name: sales}\n        \"\"\"\n        self.menu = []\n        self.selected_dishes = []\n        self.sales = {}\n\n    def add_dish(self, dish):\n        \"\"\"\n        Check the self.menu and add into self.selected_dish if the dish count is valid.\n        And if the dish has successfully been added, change the count in self.menu.\n        :param dish: dict, the information of dish. dish = {\"dish\": dish name, \"count\": count, price: price}\n        :return: True if successfully added, or False otherwise.\n        >>> order = Order()\n        >>> order.menu.append({\"dish\": \"dish1\", \"price\": 10, \"count\": 5})\n        >>> order.add_dish({\"dish\": \"dish1\", \"price\": 10, \"count\": 3})\n        True\n        \"\"\"\n        if not dish or not dish.get(\"dish\") or not dish.get(\"count\") or not dish.get(\"price\"):\n            return True\n\n        dish_name = dish[\"dish\"]\n        dish_count = dish[\"count\"]\n        dish_price = dish[\"price\"]\n\n        for menu_dish in self.menu:\n            if menu_dish[\"dish\"] == dish_name:\n                if menu_dish[\"count\"] >= dish_count:\n                    menu_dish[\"count\"] -= dish_count\n                    self.selected_dishes.append({\"dish\": dish_name, \"count\": dish_count, \"price\": dish_price})\n                    return True\n                else:\n                    return False\n        return True\n\n    def calculate_total(self):\n        \"\"\"\n        Calculate the total price of dishes that have been ordered. Multiply the count, price and sales.\n        :return total: float, the final total price.\n        >>> order = Order()\n        >>> order.menu.append({\"dish\": \"dish1\", \"price\": 10, \"count\": 5})\n        >>> order.sales = {\"dish1\": 0.8}\n        >>> order.add_dish({\"dish\": \"dish1\", \"price\": 10, \"count\": 4})\n        True\n        >>> order.calculate_total()\n        32.0\n        \"\"\"\n        total = 0.0\n        for selected_dish in self.selected_dishes:\n            dish_name = selected_dish[\"dish\"]\n            dish_count = selected_dish[\"count\"]\n            dish_price = selected_dish[\"price\"]\n            sales = self.sales.get(dish_name, 1.0)  # Default to 1.0 if no sale price\n            total += dish_count * dish_price * sales\n        return round(total, 2)\n\n    def checkout(self):\n        \"\"\"\n        Check out the dished ordered. IF the self.selected_dishes is not empty, invoke the calculate_total\n        method to check out.\n        :return Flase if the self.selected_dishes is empty, or total(return value of calculate_total) otherwise.\n        >>> order = Order()\n        >>> order.menu.append({\"dish\": \"dish1\", \"price\": 10, \"count\": 5})\n        >>> order.sales = {\"dish1\": 0.8}\n        >>> order.add_dish({\"dish\": \"dish1\", \"price\": 10, \"count\": 4})\n        True\n        >>> order.checkout()\n        32.0\n        \"\"\"\n        if not self.selected_dishes:\n            return False\n        else:\n            total = self.calculate_total()\n            self.selected_dishes = []\n            return total\n```",
    "68": "```python\nclass PageUtil:\n    \"\"\"\n    PageUtil class is a versatile utility for handling pagination and search functionalities in an efficient and convenient manner.\n    \"\"\"\n\n    def __init__(self, data, page_size):\n        \"\"\"\n        Initialize the PageUtil object with the given data and page size.\n        :param data: list, the data to be paginated\n        :param page_size: int, the number of items per page\n        \"\"\"\n        self.data = data\n        self.page_size = page_size\n        self.total_items = len(data)\n        self.total_pages = (self.total_items + page_size - 1) // page_size\n\n    def get_page(self, page_number):\n        \"\"\"\n        Retrieve a specific page of data.\n        :param page_number: int, the page number to fetch\n        :return: list, the data on the specified page\n        \"\"\"\n        if page_number <= 0 or page_number > self.total_pages:\n            return []\n        start_index = (page_number - 1) * self.page_size\n        end_index = min(start_index + self.page_size, self.total_items)\n        return self.data[start_index:end_index]\n\n    def get_page_info(self, page_number):\n        \"\"\"\n        Retrieve information about a specific page.\n        :param page_number: int, the page number to fetch information about\n        :return: dict, containing page information such as current page number, total pages, etc.\n        \"\"\"\n        if page_number <= 0 or page_number > self.total_pages:\n            return {}\n        page_data = self.get_page(page_number)\n        has_previous = page_number > 1\n        has_next = page_number < self.total_pages\n        return {\n            \"current_page\": page_number,\n            \"per_page\": self.page_size,\n            \"total_pages\": self.total_pages,\n            \"total_items\": self.total_items,\n            \"has_previous\": has_previous,\n            \"has_next\": has_next,\n            \"data\": page_data\n        }\n\n    def search(self, keyword):\n        \"\"\"\n        Search for items in the data that contain the given keyword.\n        :param keyword: str, the keyword to search for\n        :return: dict, containing search information such as total results and matching items\n        \"\"\"\n        results = [item for item in self.data if str(keyword) in str(item)]\n        total_results = len(results)\n        total_pages = (total_results + self.page_size - 1) // self.page_size if total_results > 0 else 0\n        return {\n            \"keyword\": keyword,\n            \"total_results\": total_results,\n            \"total_pages\": total_pages,\n            \"results\": results\n        }\n```",
    "69": "```python\nimport PyPDF2\n\nclass PDFHandler:\n    \"\"\"\n    The class allows merging multiple PDF files into one and extracting text from PDFs using PyPDF2 library.\n    \"\"\"\n\n    def __init__(self, filepaths):\n        \"\"\"\n        takes a list of file paths filepaths as a parameter.\n        It creates a list named readers using PyPDF2, where each reader opens a file from the given paths.\n        If a file is not found or cannot be read, a None is appended to the readers list.\n        \"\"\"\n        self.filepaths = filepaths\n        self.readers = []\n        for fp in filepaths:\n            try:\n                with open(fp, 'rb') as f:\n                    self.readers.append(PyPDF2.PdfFileReader(f))\n            except FileNotFoundError:\n                print(f\"File not found: {fp}\")\n                self.readers.append(None)\n            except PyPDF2.utils.PdfReadError:\n                print(f\"Could not read PDF: {fp}\")\n                self.readers.append(None)\n            except Exception as e:\n                print(f\"Error opening {fp}: {e}\")\n                self.readers.append(None)\n\n    def merge_pdfs(self, output_filepath):\n        \"\"\"\n        Read files in self.readers which stores handles to multiple PDF files.\n        Merge them to one pdf and update the page number, then save in disk.\n        :param output_filepath: str, ouput file path to save to\n        :return: str, \"Merged PDFs saved at {output_filepath}\" if successfully merged\n        >>> handler = PDFHandler(['a.pdf', 'b.pdf'])\n        >>> handler.merge_pdfs('out.pdf')\n        Merged PDFs saved at out.pdf\n        \"\"\"\n        merger = PyPDF2.PdfFileMerger()\n        for reader in self.readers:\n            if reader:\n                try:\n                    merger.append(reader)\n                except Exception as e:\n                    print(f\"Error appending PDF: {e}\")\n\n        try:\n            with open(output_filepath, 'wb') as output_file:\n                merger.write(output_file)\n            return f\"Merged PDFs saved at {output_filepath}\"\n        except Exception as e:\n            return f\"Error merging PDFs: {e}\"\n        finally:\n            merger.close()\n\n\n    def extract_text_from_pdfs(self):\n        \"\"\"\n        Extract text from pdf files in self.readers\n        :return pdf_texts: list of str, each element is the text of one pdf file\n        >>> handler = PDFHandler(['a.pdf', 'b.pdf'])\n        >>> handler.extract_text_from_pdfs()\n        ['Test a.pdf', 'Test b.pdf']\n        \"\"\"\n        pdf_texts = []\n        for reader in self.readers:\n            if reader:\n                text = \"\"\n                try:\n                    for page_num in range(reader.getNumPages()):\n                        page = reader.getPage(page_num)\n                        text += page.extractText()\n                except Exception as e:\n                    print(f\"Error extracting text: {e}\")\n                    text = \"\" # Ensure an empty string is added even if extraction fails\n                pdf_texts.append(text)\n            else:\n                pdf_texts.append(\"\")\n        return pdf_texts\n```",
    "70": "```python\nclass PersonRequest:\n    \"\"\"\n    This class validates input personal information data and sets invalid fields to None based to specific rules.\n    \"\"\"\n\n    def __init__(self, name: str, sex: str, phoneNumber: str):\n        \"\"\"\n        Initialize PersonRequest object with the provided information.\n        :param name: str, the name of the person\n        :param sex: str, the sex of the person\n        :param phoneNumber: str, the phone number of the person\n        \"\"\"\n        self.name = self._validate_name(name)\n        self.sex = self._validate_sex(sex)\n        self.phoneNumber = self._validate_phoneNumber(phoneNumber)\n\n\n    def _validate_name(self, name: str) -> str:\n        \"\"\"\n        Validate the name and return it. If name is empty or exceeds 33 characters in length, set to None.\n        :param name: str, the name to validate\n        :return: str, the validated name or None if invalid\n        \"\"\"\n        if not name or len(name) > 33:\n            return None\n        return name\n\n    def _validate_sex(self, sex: str) -> str:\n        \"\"\"\n        Validate the sex and return it. If sex is not Man, Woman, or UGM, set to None.\n        :param sex: str, the sex to validate\n        :return: str, the validated sex or None if invalid\n        \"\"\"\n        if sex not in (\"Man\", \"Woman\", \"UGM\"):\n            return None\n        return sex\n\n    def _validate_phoneNumber(self, phoneNumber: str) -> str:\n        \"\"\"\n        Validate the phone number and return it. If phoneNumber is empty or not an 11 digit number, set to None.\n        :param phoneNumber: str, the phone number to validate\n        :return: str, the validated phone number or None if invalid\n        \"\"\"\n        if not phoneNumber or not phoneNumber.isdigit() or len(phoneNumber) != 11:\n            return None\n        return phoneNumber\n```",
    "71": "```python\nclass PushBoxGame:\n    \"\"\"\n    This class implements a functionality of a sokoban game, where the player needs to move boxes to designated targets in order to win.\n    \"\"\"\n\n    def __init__(self, map):\n        \"\"\"\n        Initialize the push box game with the map and various attributes.\n        :param map: list[str], the map of the push box game, represented as a list of strings. \n            Each character on the map represents a different element, including the following:\n            - '#' represents a wall that neither the player nor the box can pass through;\n            - 'O' represents the initial position of the player;\n            - 'G' represents the target position;\n            - 'X' represents the initial position of the box.\n        \"\"\"\n        self.map = map\n        self.player_row = 0\n        self.player_col = 0\n        self.targets = []\n        self.boxes = []\n        self.target_count = 0\n        self.is_game_over = False\n        self.init_game()\n\n    def init_game(self):\n        \"\"\"\n        Initialize the game by setting the positions of the player, targets, and boxes based on the map.\n        \"\"\"\n        for row_index, row in enumerate(self.map):\n            for col_index, cell in enumerate(row):\n                if cell == 'O':\n                    self.player_row = row_index\n                    self.player_col = col_index\n                elif cell == 'G':\n                    self.targets.append((row_index, col_index))\n                    self.target_count += 1\n                elif cell == 'X':\n                    self.boxes.append((row_index, col_index))\n\n    def check_win(self):\n        \"\"\"\n        Check if the game is won. The game is won when all the boxes are placed on target positions.\n        And update the value of self.is_game_over.\n        :return self.is_game_over: True if all the boxes are placed on target positions, or False otherwise.\n        \"\"\"\n        if not self.targets:\n            self.is_game_over = False\n            return self.is_game_over\n        \n        if len(self.boxes) != len(self.targets):\n            self.is_game_over = False\n            return self.is_game_over\n\n        for box in self.boxes:\n            if box not in self.targets:\n                self.is_game_over = False\n                return self.is_game_over\n        self.is_game_over = True\n        return self.is_game_over\n\n\n    def move(self, direction):\n        \"\"\"\n        Move the player based on the specified direction and check if the game is won.\n        :param direction: str, the direction of the player's movement. \n            It can be 'w', 's', 'a', or 'd' representing up, down, left, or right respectively.\n\n        :return: True if the game is won, False otherwise.\n        \"\"\"\n        new_row = self.player_row\n        new_col = self.player_col\n\n        if direction == 'w':\n            new_row -= 1\n        elif direction == 's':\n            new_row += 1\n        elif direction == 'a':\n            new_col -= 1\n        elif direction == 'd':\n            new_col += 1\n        else:\n            return self.check_win()\n\n        if not (0 <= new_row < len(self.map) and 0 <= new_col < len(self.map[0])):\n            return self.check_win()\n\n        if self.map[new_row][new_col] == '#':\n            return self.check_win()\n\n        box_index = -1\n        for i, box in enumerate(self.boxes):\n            if box[0] == new_row and box[1] == new_col:\n                box_index = i\n                break\n\n        if box_index != -1:\n            box_row = self.boxes[box_index][0]\n            box_col = self.boxes[box_index][1]\n            new_box_row = box_row + (new_row - self.player_row)\n            new_box_col = box_col + (new_col - self.player_col)\n\n            if not (0 <= new_box_row < len(self.map) and 0 <= new_box_col < len(self.map[0])):\n                return self.check_win()\n\n            if self.map[new_box_row][new_box_col] == '#':\n                return self.check_win()\n            \n            another_box = False\n            for box2 in self.boxes:\n                if box2[0] == new_box_row and box2[1] == new_box_col:\n                    another_box = True\n                    break\n            if another_box:\n                return self.check_win()\n\n            self.boxes[box_index] = (new_box_row, new_box_col)\n            self.player_row = new_row\n            self.player_col = new_col\n            return self.check_win()\n        else:\n            self.player_row = new_row\n            self.player_col = new_col\n            return self.check_win()\n\n    def print_map(self):\n        \"\"\"\n        Print the current map of the game.\n        \"\"\"\n        for row in self.map:\n            print(' '.join(row))\n```",
    "72": "```python\nimport re\n\nclass RegexUtils:\n    \"\"\"\n    The class provides to match, find all occurrences, split, and substitute text using regular expressions. It also includes predefined patterns, validating phone numbers and extracting email addresses.\n    \"\"\"\n\n    def match(self, pattern, text):\n        \"\"\"\n        Check if the text matches the regular expression\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to match\n        :return: True or False, representing whether the text matches the regular expression or not\n        \"\"\"\n        if not isinstance(pattern, str):\n            raise TypeError(\"Pattern must be a string.\")\n        if not isinstance(text, str):\n            raise TypeError(\"Text must be a string.\")\n        try:\n            return bool(re.match(pattern, text))\n        except re.error as e:\n            raise ValueError(f\"Invalid regex pattern: {e}\")\n\n\n    def findall(self, pattern, text):\n        \"\"\"\n        Find all matching substrings and return a list of all matching substrings\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to match\n        :return: list of string, List of all matching substrings\n        \"\"\"\n        if not isinstance(pattern, str):\n            raise TypeError(\"Pattern must be a string.\")\n        if not isinstance(text, str):\n            raise TypeError(\"Text must be a string.\")\n        try:\n            return re.findall(pattern, text)\n        except re.error as e:\n            raise ValueError(f\"Invalid regex pattern: {e}\")\n\n    def split(self, pattern, text):\n        \"\"\"\n        Split text based on regular expression patterns and return a list of substrings\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to be split\n        :return: list of string, List of substrings after splitting\n        \"\"\"\n        if not isinstance(pattern, str):\n            raise TypeError(\"Pattern must be a string.\")\n        if not isinstance(text, str):\n            raise TypeError(\"Text must be a string.\")\n        try:\n            return re.split(pattern, text)\n        except re.error as e:\n            raise ValueError(f\"Invalid regex pattern: {e}\")\n\n    def sub(self, pattern, replacement, text):\n        \"\"\"\n        Replace the substring matched by a regular expression with the specified string\n        :param pattern: string, Regular expression pattern\n        :param replacement: Text to replace with\n        :param text: string, Text to be replaced\n        :return: string, Text after replacement\n        \"\"\"\n        if not isinstance(pattern, str):\n            raise TypeError(\"Pattern must be a string.\")\n        if not isinstance(replacement, str):\n            raise TypeError(\"Replacement must be a string.\")\n        if not isinstance(text, str):\n            raise TypeError(\"Text must be a string.\")\n        try:\n            return re.sub(pattern, replacement, text)\n        except re.error as e:\n            raise ValueError(f\"Invalid regex pattern: {e}\")\n\n    def generate_email_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match email addresses\n        :return: string, regular expression patterns that match email addresses\n        \"\"\"\n        return r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n\n    def generate_phone_number_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match phone numbers\n        :return: string, regular expression patterns that match phone numbers\n        \"\"\"\n        return r'\\b\\d{3}-\\d{3}-\\d{4}\\b'\n\n    def generate_split_sentences_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match the middle characters of two sentences\n        :return: string, regular expression patterns that match the middle characters of two sentences\n        \"\"\"\n        return r'[.!?][\\s]{1,2}(?=[A-Z])'\n\n    def split_sentences(self, text):\n        \"\"\"\n        Split the text into a list of sentences without Punctuation except the last sentence\n        :param text: Text to be split\n        :return: Split Text List\n        \"\"\"\n        if not isinstance(text, str):\n            raise TypeError(\"Text must be a string.\")\n        pattern = self.generate_split_sentences_pattern()\n        sentences = re.split(pattern, text)\n        return sentences\n\n    def validate_phone_number(self, phone_number):\n        \"\"\"\n        Verify if the phone number is valid\n        :param phone_number: Phone number to be verified\n        :return: True or False, indicating whether the phone number is valid\n        \"\"\"\n        if not isinstance(phone_number, str):\n            raise TypeError(\"Phone number must be a string.\")\n        pattern = self.generate_phone_number_pattern()\n        return bool(re.match(pattern, phone_number))\n\n    def extract_email(self, text):\n        \"\"\"\n        Extract all email addresses from the text\n        :param text: string, input text\n        :return: list of string, All extracted email addresses\n        \"\"\"\n        if not isinstance(text, str):\n            raise TypeError(\"Text must be a string.\")\n        pattern = self.generate_email_pattern()\n        return re.findall(pattern, text)\n```",
    "73": "```python\nclass RPGCharacter:\n    \"\"\"\n    The class represents a role-playing game character, which allows to attack other characters, heal, gain experience, level up, and check if the character is alive.\n    \"\"\"\n\n    def __init__(self, name, hp, attack_power, defense, level=1):\n        \"\"\"\n        Initialize an RPG character object.\n        :param name: strm, the name of the character.\n        :param hp: int, The health points of the character.\n        :param attack_power: int, the attack power of the character.\n        :param defense: int, the defense points of the character.\n        :param level: int, the level of the character. Default is 1.\n        \"\"\"\n        self.name = name\n        self.hp = hp\n        self.attack_power = attack_power\n        self.defense = defense\n        self.level = level\n        self.exp = 0\n\n    def attack(self, other_character):\n        \"\"\"\n        Attack another character. The damage caused needs to offset the defense value.\n        :param other_character: str, The character being attacked.\n        \"\"\"\n        damage = self.attack_power - other_character.defense\n        if damage > 0:\n            other_character.hp -= damage\n\n    def heal(self):\n        \"\"\"\n        Heal the character with 10 hp and the max hp is 100.\n        :return: int, the current health points after healing.\n        \"\"\"\n        self.hp = min(self.hp + 10, 100)\n        return self.hp\n\n    def gain_exp(self, amount):\n        \"\"\"\n        Gain experience points for the character and level_up when the exp has reached the values that is 100 times the current level\n        The experience that overflows should be used to calculate the next leve up untill exhausts\n        :param amount: int, the amount of experience points to gain.\n        \"\"\"\n        self.exp += amount\n        while self.exp >= self.level * 100:\n            self.exp -= self.level * 100\n            self.level_up()\n\n    def level_up(self):\n        \"\"\"\n        Level up the character and return to zero experience points, increase hp by 20 points, attack power and defense points by 5 points.\n        max level is 100\n        :return: tuple[int, int, int, int], the new level, health points, attack power, and defense points after leveling up.\n        \"\"\"\n        if self.level < 100:\n            self.level += 1\n            self.hp += 20\n            self.attack_power += 5\n            self.defense += 5\n\n    def is_alive(self):\n        \"\"\"\n        Check if player is alive.\n        :return: True if the hp is larger than 0, or False otherwise.\n        \"\"\"\n        return self.hp > 0\n```",
    "74": "```python\nclass Server:\n    \"\"\"\n    This is a class as a server, which handles a white list, message sending and receiving, and information display.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the whitelist as an empty list, and initialize the sending and receiving information as an empty dictionary\n        \"\"\"\n        self.white_list = []\n        self.send_struct = {}\n        self.receive_struct = {}\n\n    def add_white_list(self, addr):\n        \"\"\"\n        Add an address to the whitelist and do nothing if it already exists\n        :param addr: int, address to be added\n        :return: new whitelist, return False if the address already exists\n        \"\"\"\n        if addr in self.white_list:\n            return False\n        else:\n            self.white_list.append(addr)\n            return self.white_list\n\n    def del_white_list(self, addr):\n        \"\"\"\n        Remove an address from the whitelist and do nothing if it does not exist\n        :param addr: int, address to be deleted\n        :return: new whitelist, return False if the address does not exist\n        \"\"\"\n        if addr in self.white_list:\n            self.white_list.remove(addr)\n            return self.white_list\n        else:\n            return False\n\n    def recv(self, info):\n        \"\"\"\n        Receive information containing address and content. If the address is on the whitelist, receive the content; otherwise, do not receive it\n        :param info: dict, information dictionary containing address and content\n        :return: if successfully received, return the content of the infomation; otherwise, return False\n        \"\"\"\n        if not isinstance(info, dict) or \"addr\" not in info or \"content\" not in info:\n            return -1\n\n        addr = info[\"addr\"]\n\n        if addr in self.white_list:\n            self.receive_struct = info\n            return info[\"content\"]\n        else:\n            return False\n\n    def send(self, info):\n        \"\"\"\n        Send information containing address and content\n        :param info: dict, information dictionary containing address and content\n        :return: if successfully sent, return nothing; otherwise, return a string indicating an error message\n        \"\"\"\n        if not isinstance(info, dict) or \"addr\" not in info or \"content\" not in info:\n            return \"info structure is not correct\"\n        self.send_struct = info\n        return None\n\n    def show(self, type):\n        \"\"\"\n        Returns struct of the specified type\n        :param type: string, the type of struct to be returned, which can be 'send' or 'receive'\n        :return: if type is equal to 'send' or 'receive', return the corresponding struct; otherwise, return False\n        \"\"\"\n        if type == 'send':\n            return self.send_struct\n        elif type == 'receive':\n            return self.receive_struct\n        else:\n            return False\n```",
    "75": "```python\nclass ShoppingCart:\n    \"\"\"\n    The class manages items, their prices, quantities, and allows to for add, removie, view items, and calculate the total price.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the items representing the shopping list as an empty dictionary\n        \"\"\"\n        self.items = {}\n\n\n    def add_item(self, item, price, quantity=1):\n        \"\"\"\n        Add item information to the shopping list items, including price and quantity. The default quantity is 1\n        :param item: string, Item to be added\n        :param price: float, The price of the item\n        :param quantity:int, The number of items, defaults to 1\n        :return:None\n        \"\"\"\n        if not isinstance(item, str):\n            raise TypeError(\"Item must be a string\")\n        if not isinstance(price, (int, float)):\n            raise TypeError(\"Price must be a number\")\n        if not isinstance(quantity, int):\n            raise TypeError(\"Quantity must be an integer\")\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be positive\")\n\n        if item in self.items:\n            self.items[item][\"quantity\"] += quantity\n        else:\n            self.items[item] = {\"price\": price, \"quantity\": quantity}\n\n\n    def remove_item(self, item, quantity=1):\n        \"\"\"\n        Subtract the specified quantity of item from the shopping list items\n        :param item:string, Item to be subtracted in quantity\n        :param quantity:int, Quantity to be subtracted\n        :return:None\n        \"\"\"\n        if not isinstance(item, str):\n            raise TypeError(\"Item must be a string\")\n        if not isinstance(quantity, int):\n            raise TypeError(\"Quantity must be an integer\")\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be positive\")\n\n        if item in self.items:\n            self.items[item][\"quantity\"] -= quantity\n            if self.items[item][\"quantity\"] <= 0:\n                del self.items[item]\n\n\n    def view_items(self) -> dict:\n        \"\"\"\n        Return the current shopping list items\n        :return:dict, the current shopping list items\n        \"\"\"\n        return self.items\n\n\n    def total_price(self) -> float:\n        \"\"\"\n        Calculate the total price of all items in the shopping list, which is the quantity of each item multiplied by the price\n        :return:float, the total price of all items in the shopping list\n        \"\"\"\n        total = 0\n        for item, details in self.items.items():\n            total += details[\"price\"] * details[\"quantity\"]\n        return float(total)\n```",
    "76": "```python\nclass SignInSystem:\n    \"\"\"\n    This is a class as sigin in system, including adding users, signing in/out, checking sign-in status, and retrieving signed-in/not signed-in users.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the sign-in system.\n        \"\"\"\n        self.users = {}\n\n    def add_user(self, username):\n        \"\"\"\n        Add a user to the sign-in system if the user wasn't in the self.users.\n        And the initial state is False.\n        :param username: str, the username to be added.\n        :return: bool, True if the user is added successfully, False if the user already exists.\n        >>> signInSystem.add_user(\"mike\")\n        True\n        >>> signInSystem.add_user(\"mike\")\n        False\n        \"\"\"\n        if username in self.users:\n            return False\n        self.users[username] = False\n        return True\n\n    def sign_in(self, username):\n        \"\"\"\n        Sign in a user if the user was in the self.users and change the state to True.\n        :param username: str, the username to be signed in.\n        :return: bool, True if the user is signed in successfully, False if the user does not exist.\n        >>> signInSystem.sign_in(\"mike\")\n        True\n        >>> signInSystem.sign_in(\"mik\")\n        False\n        \"\"\"\n        if username in self.users:\n            self.users[username] = True\n            return True\n        return False\n\n    def check_sign_in(self, username):\n        \"\"\"\n        Check if a user is signed in.\n        :param username: str, the username to be checked.\n        :return: bool, True if the user is signed in, False if the user does not exist or is not signed in.\n        >>> signInSystem.check_sign_in(\"jack\")\n        False\n        >>> signInSystem.add_user(\"jack\")\n        >>> signInSystem.check_sign_in(\"jack\")\n        >>> signInSystem.sign_in(\"jack\")\n        >>> signInSystem.check_sign_in(\"jack\")\n        True\n        \"\"\"\n        if username not in self.users:\n            return False\n        return self.users[username]\n\n    def all_signed_in(self):\n        \"\"\"\n        Check if all users are signed in.\n        :return: bool, True if all users are signed in, False otherwise.\n        >>> signInSystem.add_user(\"jack\")\n        True\n        >>> signInSystem.sign_in(\"jack\")\n        >>> signInSystem.all_signed_in()\n        True\n        \"\"\"\n        if not self.users:\n            return True\n        return all(self.users.values())\n\n    def all_not_signed_in(self):\n        \"\"\"\n        Get a list of usernames that are not signed in.\n        :return: list[str], a list of usernames that are not signed in.\n        >>> signInSystem = SignInSystem()\n        >>> signInSystem.add_user(\"a\")\n        True\n        >>> signInSystem.add_user(\"b\")\n        True\n        >>> signInSystem.all_not_signed_in()\n        ['a', 'b']\n        \"\"\"\n        return [user for user, signed_in in self.users.items() if not signed_in]\n```",
    "77": "```python\nimport random\n\nclass Snake:\n    \"\"\"\n    The class is a snake game, with allows snake to move and eat food, and also enables to reset, and generat a random food position.\n    \"\"\"\n\n    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):\n        \"\"\"\n        Initialize the length of the snake, screen width, screen height, block size, snake head position, score, and food position.\n        :param SCREEN_WIDTH: int\n        :param SCREEN_HEIGHT: int\n        :param BLOCK_SIZE: int, Size of moving units\n        :param food_position: tuple, representing the position(x, y) of food.\n        \"\"\"\n        self.length = 1\n        self.SCREEN_WIDTH = SCREEN_WIDTH\n        self.SCREEN_HEIGHT = SCREEN_HEIGHT\n        self.BLOCK_SIZE = BLOCK_SIZE\n        self.positions = [((SCREEN_WIDTH // 2), (SCREEN_HEIGHT // 2))]\n        self.score = 0\n        self.food_position = food_position\n\n\n    def move(self, direction):\n        \"\"\"\n        Move the snake in the specified direction. If the new position of the snake's head is equal to the position of the food, then eat the food; If the position of the snake's head is equal to the position of its body, then start over, otherwise its own length plus one.\n        :param direction: tuple, representing the direction of movement (x, y).\n        :return: None\n        \"\"\"\n        x, y = self.positions[0]\n        new_head = (x + direction[0], y + direction[1])\n\n        if new_head == self.food_position:\n            self.length += 1\n            self.score += 100\n            self.positions.insert(0, new_head)\n            self.food_position = self.random_food_position()\n        elif new_head in self.positions[1:]:\n            self.reset()\n        else:\n            self.positions.insert(0, new_head)\n            self.positions.pop()\n\n    def random_food_position(self):\n        \"\"\"\n        Randomly generate a new food position, but don't place it on the snake.\n        :return: tuple, the new food position\n        \"\"\"\n        while True:\n            x = random.randint(0, self.SCREEN_WIDTH - 1)\n            y = random.randint(0, self.SCREEN_HEIGHT - 1)\n            food_position = (x, y)\n            if food_position not in self.positions:\n                return food_position\n\n\n    def reset(self):\n        \"\"\"\n        Reset the snake to its initial state. Set the length to 1, the snake head position to ((SCREEN_WIDTH/2), (SCREEN_HEIGHT/2)), the score to 0, and randomly generate new food position.\n        :return: None\n        \"\"\"\n        self.length = 1\n        self.positions = [((self.SCREEN_WIDTH // 2), (self.SCREEN_HEIGHT // 2))]\n        self.score = 0\n        self.food_position = self.random_food_position()\n\n\n    def eat_food(self):\n        \"\"\"\n        Increase the length of the snake by 1 and increase the score by 100. Randomly generate a new food position, but\n        don't place it on the snake.\n        :return: None\n        \"\"\"\n        self.length += 1\n        self.score += 100\n        self.food_position = self.random_food_position()\n```",
    "78": "```python\nimport re\n\nclass SplitSentence:\n    \"\"\"\n    The class allows to split sentences, count words in a sentence, and process a text file to find the maximum word count.\n    \"\"\"\n\n\n    def split_sentences(self, sentences_string):\n        \"\"\"\n        Split a string into a list of sentences. Sentences end with . or ? and with a space after that. Please note that Mr. also end with . but are not sentences.\n        :param sentences_string: string, string to split\n        :return:list, split sentence list\n        >>> ss = SplitSentence()\n        >>> ss.split_sentences(\"aaa aaaa. bb bbbb bbb? cccc cccc. dd ddd?\")\n        ['aaa aaaa.', 'bb bbbb bbb?', 'cccc cccc.', 'dd ddd?']\n        \"\"\"\n        sentences = re.split(r'(?<!\\b(?:Mr|Mrs|Ms|A\\.B\\.C)\\b)(?<![A-Z])[\\.\\?]\\s+', sentences_string)\n        sentences = [s.strip() for s in sentences if s.strip()]\n        sentences = [s + ('.' if sentences_string[sum(len(i) + 1 for i in sentences[:index]):].startswith('.') else '?' if sentences_string[sum(len(i) + 1 for i in sentences[:index]):].startswith('?') else '') for index, s in enumerate(sentences)]\n        return sentences\n\n    def count_words(self, sentence):\n        \"\"\"\n        Count the number of words in a sentence. Note that words are separated by spaces and that punctuation marks and numbers are not counted as words.\n        :param sentence:string, sentence to be counted, where words are separated by spaces\n        :return:int, number of words in the sentence\n        >>> ss.count_words(\"abc def\")\n        2\n        \"\"\"\n        words = sentence.split()\n        count = 0\n        for word in words:\n            if not re.match(r'^\\d+$', word):\n                count += 1\n        return count\n\n    def process_text_file(self, sentences_string):\n        \"\"\"\n        Given a text, return the number of words in the longest sentence\n        :param sentences_string: string, undivided long sentence\n        :return:int, the number of words in the longest sentence\n        >>> ss.process_text_file(\"aaa aaaa. bb bbbb bbb? cccc ccccccc cc ccc. dd ddd?\")\n        4\n        \"\"\"\n        sentences = self.split_sentences(sentences_string)\n        max_words = 0\n        for sentence in sentences:\n            word_count = self.count_words(sentence)\n            if word_count > max_words:\n                max_words = word_count\n        return max_words\n```",
    "79": "```python\nclass SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.select(['field1', 'field2'], 'filed3 = value1')\n        'SELECT field1, field2 FROM table1 WHERE filed3 = value1;'\n        \"\"\"\n        sql = f\"SELECT * FROM {self.table_name}\"\n        if fields:\n            if isinstance(fields, list):\n                sql = f\"SELECT {', '.join(fields)} FROM {self.table_name}\"\n            else:\n                 sql = f\"SELECT {str(fields)} FROM {self.table_name}\"\n\n        if condition:\n            sql += f\" WHERE {condition}\"\n        sql += \";\"\n        return sql\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        >>> sql.insert({'key1': 'value1', 'key2': 'value2'})\n        \"INSERT INTO table1 (key1, key2) VALUES ('value1', 'value2');\"\n        \"\"\"\n        fields = ', '.join(data.keys())\n        values = \", \".join([f\"'{str(value)}'\" for value in data.values()])\n        sql = f\"INSERT INTO {self.table_name} ({fields}) VALUES ({values});\"\n        return sql\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and values are new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        >>> sql.update({'field1': 'new_value1', 'field2': 'new_value2'}, \"field3 = value1\")\n        \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2' WHERE field3 = value1;\"\n        \"\"\"\n        updates = \", \".join([f\"{field} = '{str(value)}'\" for field, value in data.items()])\n        sql = f\"UPDATE {self.table_name} SET {updates} WHERE {condition};\"\n        return sql\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        >>> sql.delete(\"field1 = value1\")\n        'DELETE FROM table1 WHERE field1 = value1;'\n        \"\"\"\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition};\"\n        return sql\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        >>> sql.select_female_under_age(30)\n        \"SELECT * FROM table1 WHERE age < 30 AND gender = 'female';\"\n        \"\"\"\n        sql = f\"SELECT * FROM {self.table_name} WHERE age < {age} AND gender = 'female';\"\n        return sql\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        >>> sql.select_by_age_range(20, 30)\n        'SELECT * FROM table1 WHERE age BETWEEN 20 AND 30;'\n        \"\"\"\n        sql = f\"SELECT * FROM {self.table_name} WHERE age BETWEEN {min_age} AND {max_age};\"\n        return sql\n```",
    "80": "```python\nclass SQLQueryBuilder:\n    \"\"\"\n    This class provides to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements. \n    \"\"\"\n\n    @staticmethod\n    def _build_where_clause(where):\n        \"\"\"Helper function to build the WHERE clause.\"\"\"\n        if not where:\n            return \"\"\n        conditions = []\n        for key, value in where.items():\n            conditions.append(f\"{key}='{value}'\")\n        return \" WHERE \" + \" AND \".join(conditions)\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in database.\n        :param columns: list of str, ['col1', 'col2'].\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        return query: str, the SQL query statement.\n        \"\"\"\n        query = \"SELECT \"\n        if isinstance(columns, list):\n            query += \", \".join(columns)\n        else:\n            query += str(columns)  # Ensure columns is converted to string\n        query += \" FROM \" + table\n        query += SQLQueryBuilder._build_where_clause(where)\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to be inserted in database.\n        :param data: dict, the key and value in SQL insert statement\n        :return query: str, the SQL insert statement.\n        \"\"\"\n        columns = \", \".join(data.keys())\n        values = \", \".join([f\"'{str(value)}'\" for value in data.values()])  # Ensure values are converted to string\n        query = f\"INSERT INTO {table} ({columns}) VALUES ({values})\"\n        return query\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with DELETE operation in database\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return query: str, the SQL delete statement.\n        \"\"\"\n        query = f\"DELETE FROM {table}\"\n        query += SQLQueryBuilder._build_where_clause(where)\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with UPDATE operation in database\n        :param data: dict, the key and value in SQL update statement\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        \"\"\"\n        query = f\"UPDATE {table} SET \"\n        updates = []\n        for key, value in data.items():\n            updates.append(f\"{key}='{value}'\")\n        query += \", \".join(updates)\n        query += SQLQueryBuilder._build_where_clause(where)\n        return query\n```",
    "81": "```python\nimport math\n\nclass Statistics3:\n    \"\"\"\n    This is a class that implements methods for calculating indicators such as median, mode, correlation matrix, and Z-score in statistics.\n    \"\"\"\n\n    @staticmethod\n    def median(data):\n        \"\"\"\n        calculates the median of the given list.\n        :param data: the given list, list.\n        :return: the median of the given list, float.\n        \"\"\"\n        if not data:\n            return None\n        data_sorted = sorted(data)\n        n = len(data_sorted)\n        if n % 2 == 0:\n            mid1 = data_sorted[n // 2 - 1]\n            mid2 = data_sorted[n // 2]\n            median = (mid1 + mid2) / 2\n        else:\n            median = data_sorted[n // 2]\n        return median\n\n    @staticmethod\n    def mode(data):\n        \"\"\"\n        calculates the mode of the given list.\n        :param data: the given list, list.\n        :return: the mode of the given list, list.\n        \"\"\"\n        if not data:\n            return []\n\n        counts = {}\n        for item in data:\n            counts[item] = counts.get(item, 0) + 1\n\n        max_count = 0\n        modes = []\n        for item, count in counts.items():\n            if count > max_count:\n                modes = [item]\n                max_count = count\n            elif count == max_count:\n                modes.append(item)\n\n        return modes\n\n    @staticmethod\n    def correlation(x, y):\n        \"\"\"\n        calculates the correlation of the given list.\n        :param x: the given list, list.\n        :param y: the given list, list.\n        :return: the correlation of the given list, float.\n        \"\"\"\n        n = len(x)\n        if n != len(y):\n            raise ValueError(\"The two lists must have the same length\")\n\n        mean_x = Statistics3.mean(x)\n        mean_y = Statistics3.mean(y)\n\n        if mean_x is None or mean_y is None:\n            return None\n\n        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))\n        denominator_x = sum((xi - mean_x)**2 for xi in x)\n        denominator_y = sum((yi - mean_y)**2 for yi in y)\n\n        if denominator_x == 0 or denominator_y == 0:\n            return None\n\n        denominator = math.sqrt(denominator_x * denominator_y)\n\n        return numerator / denominator\n\n    @staticmethod\n    def mean(data):\n        \"\"\"\n        calculates the mean of the given list.\n        :param data: the given list, list.\n        :return: the mean of the given list, float.\n        \"\"\"\n        if not data:\n            return None\n        return sum(data) / len(data)\n\n    @staticmethod\n    def correlation_matrix(data):\n        \"\"\"\n        calculates the correlation matrix of the given list.\n        :param data: the given list, list.\n        :return: the correlation matrix of the given list, list.\n        \"\"\"\n        num_variables = len(data)\n        correlation_matrix = [[None] * num_variables for _ in range(num_variables)]\n\n        for i in range(num_variables):\n            for j in range(num_variables):\n                correlation_matrix[i][j] = Statistics3.correlation(data[i], data[j])\n\n        return correlation_matrix\n\n    @staticmethod\n    def standard_deviation(data):\n        \"\"\"\n        calculates the standard deviation of the given list.\n        :param data: the given list, list.\n        :return: the standard deviation of the given list, float.\n        \"\"\"\n        if not data:\n            return 0.0\n\n        mean = Statistics3.mean(data)\n\n        if mean is None:\n            return 0.0\n\n        variance = sum((x - mean)**2 for x in data) / len(data)\n        return math.sqrt(variance)\n\n    @staticmethod\n    def z_score(data):\n        \"\"\"\n        calculates the z-score of the given list.\n        :param data: the given list, list.\n        :return: the z-score of the given list, list.\n        \"\"\"\n        if not data:\n            return None\n\n        mean = Statistics3.mean(data)\n        std_dev = Statistics3.standard_deviation(data)\n\n        if std_dev == 0:\n            return None\n\n        z_scores = [(x - mean) / std_dev for x in data]\n        return z_scores\n```",
    "82": "```python\nclass StockPortfolioTracker:\n    \"\"\"\n    This is a class as StockPortfolioTracker that allows to add stocks, remove stocks, buy stocks, sell stocks, calculate the total value of the portfolio, and obtain a summary of the portfolio.\n    \"\"\"\n\n    def __init__(self, cash_balance):\n        \"\"\"\n        Initialize the StockPortfolioTracker class with a cash balance and an empty portfolio.\n        \"\"\"\n        self.portfolio = []\n        self.cash_balance = cash_balance\n\n    def add_stock(self, stock):\n        \"\"\"\n        Add a stock to the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        \"\"\"\n        if not all(key in stock for key in (\"name\", \"price\", \"quantity\")):\n            raise ValueError(\"Stock must have 'name', 'price', and 'quantity' keys.\")\n\n        if not isinstance(stock[\"name\"], str):\n            raise TypeError(\"Stock name must be a string.\")\n        if not isinstance(stock[\"price\"], (int, float)):\n            raise TypeError(\"Stock price must be a number.\")\n        if not isinstance(stock[\"quantity\"], int):\n            raise TypeError(\"Stock quantity must be an integer.\")\n        if stock[\"quantity\"] <= 0:\n            raise ValueError(\"Stock quantity must be positive.\")\n\n        found = False\n        for existing_stock in self.portfolio:\n            if existing_stock[\"name\"] == stock[\"name\"] and existing_stock[\"price\"] == stock[\"price\"]:\n                existing_stock[\"quantity\"] += stock[\"quantity\"]\n                found = True\n                break\n        if not found:\n            self.portfolio.append(stock)\n\n    def remove_stock(self, stock):\n        \"\"\"\n        Remove a stock from the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        \"\"\"\n        if not all(key in stock for key in (\"name\", \"price\", \"quantity\")):\n            raise ValueError(\"Stock must have 'name', 'price', and 'quantity' keys.\")\n\n        if not isinstance(stock[\"name\"], str):\n            raise TypeError(\"Stock name must be a string.\")\n        if not isinstance(stock[\"price\"], (int, float)):\n            raise TypeError(\"Stock price must be a number.\")\n        if not isinstance(stock[\"quantity\"], int):\n            raise TypeError(\"Stock quantity must be an integer.\")\n              \n        if stock[\"quantity\"] <= 0:\n            raise ValueError(\"Stock quantity must be positive.\")\n\n        for existing_stock in self.portfolio:\n            if existing_stock[\"name\"] == stock[\"name\"] and existing_stock[\"price\"] == stock[\"price\"]:\n                if existing_stock[\"quantity\"] >= stock[\"quantity\"]:\n                    existing_stock[\"quantity\"] -= stock[\"quantity\"]\n                    if existing_stock[\"quantity\"] == 0:\n                        self.portfolio.remove(existing_stock)\n                    return True\n                else:\n                    return False\n        return False\n\n    def buy_stock(self, stock):\n        \"\"\"\n        Buy a stock and add it to the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        :return: True if the stock was bought successfully, False if the cash balance is not enough.\n        \"\"\"\n        if not all(key in stock for key in (\"name\", \"price\", \"quantity\")):\n            raise ValueError(\"Stock must have 'name', 'price', and 'quantity' keys.\")\n\n        if not isinstance(stock[\"name\"], str):\n            raise TypeError(\"Stock name must be a string.\")\n        if not isinstance(stock[\"price\"], (int, float)):\n            raise TypeError(\"Stock price must be a number.\")\n        if not isinstance(stock[\"quantity\"], int):\n            raise TypeError(\"Stock quantity must be an integer.\")\n\n        if stock[\"quantity\"] <= 0:\n            raise ValueError(\"Stock quantity must be positive.\")\n\n        cost = stock[\"price\"] * stock[\"quantity\"]\n        if self.cash_balance >= cost:\n            self.cash_balance -= cost\n            self.add_stock(stock)\n            return True\n        else:\n            return False\n\n    def sell_stock(self, stock):\n        \"\"\"\n        Sell a stock and remove it from the portfolio and add the cash to the cash balance.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        :return: True if the stock was sold successfully, False if the quantity of the stock is not enough.\n        \"\"\"\n        if not all(key in stock for key in (\"name\", \"price\", \"quantity\")):\n            raise ValueError(\"Stock must have 'name', 'price', and 'quantity' keys.\")\n\n        if not isinstance(stock[\"name\"], str):\n            raise TypeError(\"Stock name must be a string.\")\n        if not isinstance(stock[\"price\"], (int, float)):\n            raise TypeError(\"Stock price must be a number.\")\n        if not isinstance(stock[\"quantity\"], int):\n            raise TypeError(\"Stock quantity must be an integer.\")\n\n        if stock[\"quantity\"] <= 0:\n            raise ValueError(\"Stock quantity must be positive.\")\n\n        for existing_stock in self.portfolio:\n            if existing_stock[\"name\"] == stock[\"name\"] and existing_stock[\"price\"] == stock[\"price\"]:\n                if existing_stock[\"quantity\"] >= stock[\"quantity\"]:\n                    self.cash_balance += stock[\"price\"] * stock[\"quantity\"]\n                    existing_stock[\"quantity\"] -= stock[\"quantity\"]\n                    if existing_stock[\"quantity\"] == 0:\n                        self.portfolio.remove(existing_stock)\n                    return True\n                else:\n                    return False\n        return False\n\n    def calculate_portfolio_value(self):\n        \"\"\"\n        Calculate the total value of the portfolio.\n        :return: the total value of the portfolio, float.\n        \"\"\"\n        total_value = self.cash_balance\n        for stock in self.portfolio:\n            total_value += stock[\"price\"] * stock[\"quantity\"]\n        return total_value\n\n    def get_portfolio_summary(self):\n        \"\"\"\n        Get a summary of the portfolio.\n        :return: a tuple of the total value of the portfolio and a list of dictionaries with keys \"name\" and \"value\"\n        \"\"\"\n        total_value = self.calculate_portfolio_value()\n        stock_values = []\n        for stock in self.portfolio:\n            stock_values.append({\"name\": stock[\"name\"], \"value\": stock[\"price\"] * stock[\"quantity\"]})\n        return total_value, stock_values\n\n    def get_stock_value(self, stock):\n        \"\"\"\n        Get the value of a stock.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        :return: the value of the stock, float.\n        \"\"\"\n        if not all(key in stock for key in (\"name\", \"price\", \"quantity\")):\n            raise ValueError(\"Stock must have 'name', 'price', and 'quantity' keys.\")\n            \n        if not isinstance(stock[\"name\"], str):\n            raise TypeError(\"Stock name must be a string.\")\n        if not isinstance(stock[\"price\"], (int, float)):\n            raise TypeError(\"Stock price must be a number.\")\n        if not isinstance(stock[\"quantity\"], int):\n            raise TypeError(\"Stock quantity must be an integer.\")\n        \n        return stock[\"price\"] * stock[\"quantity\"]\n```",
    "83": "```python\nimport sqlite3\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This is a class with database operation, including inserting student information, searching for student information by name, and deleting student information by name.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.Fields include ID of type int, name of type str, age of type int, gender of type str, and grade of type int\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        \"\"\"\n        try:\n            conn = sqlite3.connect(self.database_name)\n            cursor = conn.cursor()\n            cursor.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS students (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    name TEXT NOT NULL,\n                    age INTEGER NOT NULL,\n                    gender TEXT NOT NULL,\n                    grade INTEGER NOT NULL\n                )\n            \"\"\")\n            conn.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n        finally:\n            if conn:\n                conn.close()\n\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        \"\"\"\n        try:\n            conn = sqlite3.connect(self.database_name)\n            cursor = conn.cursor()\n            cursor.execute(\"\"\"\n                INSERT INTO students (name, age, gender, grade)\n                VALUES (?, ?, ?, ?)\n            \"\"\", (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))\n            conn.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n        finally:\n            if conn:\n                conn.close()\n\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> result = processor.search_student_by_name(\"John\")\n        \"\"\"\n        try:\n            conn = sqlite3.connect(self.database_name)\n            cursor = conn.cursor()\n            cursor.execute(\"SELECT * FROM students WHERE name=?\", (name,))\n            result = cursor.fetchall()\n            return result\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n            return []\n        finally:\n            if conn:\n                conn.close()\n\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        >>> processor.delete_student_by_name(\"John\")\n        \"\"\"\n        try:\n            conn = sqlite3.connect(self.database_name)\n            cursor = conn.cursor()\n            cursor.execute(\"DELETE FROM students WHERE name=?\", (name,))\n            conn.commit()\n        except sqlite3.Error as e:\n            print(f\"Database error: {e}\")\n        finally:\n            if conn:\n                conn.close()\n```",
    "84": "```python\nimport json\nimport re\n\nclass TextFileProcessor:\n    \"\"\"\n    The class handles reading, writing, and processing text files. It can read the file as JSON, read the raw text, write content to the file, and process the file by removing non-alphabetic characters.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initialize the file path.\n        :param file_path: str\n        \"\"\"\n        self.file_path = file_path\n\n    def read_file_as_json(self):\n        \"\"\"\n        Read the self.file_path file as json format.\n        if the file content doesn't obey json format, the code will raise error.\n        :return data: dict if the file is stored as json format, or str/int/float.. according to the file content otherwise.\n        \"\"\"\n        with open(self.file_path, 'r') as f:\n            content = f.read()\n            try:\n                data = json.loads(content)\n            except json.JSONDecodeError:\n                try:\n                    data = int(content)\n                except ValueError:\n                    try:\n                        data = float(content)\n                    except ValueError:\n                        data = content.strip('\"')\n            return data\n\n    def read_file(self):\n        \"\"\"\n        Read the return the content of self.file_path file.\n        :return: the same return as the read() method\n        \"\"\"\n        with open(self.file_path, 'r') as f:\n            return f.read()\n\n    def write_file(self, content):\n        \"\"\"\n        Write content into the self.file_path file, and overwrite if the file has already existed.\n        :param content: any content\n        \"\"\"\n        with open(self.file_path, 'w') as f:\n            f.write(str(content))\n\n    def process_file(self):\n        \"\"\"\n        Read the self.file_path file and filter out non-alphabetic characters from the content string.\n        Overwrite the after-processed data into the same self.file_path file.\n        \"\"\"\n        content = self.read_file()\n        processed_content = ''.join(re.findall(r'[a-zA-Z]', content))\n        self.write_file(processed_content)\n        return processed_content\n```",
    "85": "```python\nimport time\n\nclass Thermostat:\n    \"\"\"\n    The class manages temperature control, including setting and retrieving the target temperature, adjusting the mode, and simulating temperature operation.\n    \"\"\"\n\n    def __init__(self, current_temperature, target_temperature, mode):\n        \"\"\"\n        initialize instances of the Thermostat class, including the current temperature, target temperature, and operating mode.\n        :param current_temperature: float\n        :param target_temperature: float\n        :param mode: str, the work mode\n        \"\"\"\n        self.current_temperature = current_temperature\n        self.target_temperature = target_temperature\n        self.mode = mode\n\n    def get_target_temperature(self):\n        \"\"\"\n        Get the target temperature of an instance of the Thermostat class.\n        :return self.target_temperature: float\n        \"\"\"\n        return self.target_temperature\n\n    def set_target_temperature(self, temperature):\n        \"\"\"\n        Set the target temperature\n        :param temperature: float, the target temperature\n        \"\"\"\n        self.target_temperature = temperature\n\n    def get_mode(self):\n        \"\"\"\n        Get the current work mode\n        :return mode: str, working mode.\n        \"\"\"\n        return self.mode\n\n    def set_mode(self, mode):\n        \"\"\"\n        Set the current work mode\n        :param mode: str, working mode. only ['heat', 'cool']\n        \"\"\"\n        if mode in ['heat', 'cool']:\n            self.mode = mode\n            return True\n        return False\n\n    def auto_set_mode(self):\n        \"\"\"\n        Automatically set the operating mode by comparing with the current temperature and target temperature. If the current temperature is lower than the target temperature, the operating mode is set to 'heat', otherwise it is set to 'cool'.\n        \"\"\"\n        if self.current_temperature < self.target_temperature:\n            self.mode = 'heat'\n        else:\n            self.mode = 'cool'\n\n    def auto_check_conflict(self):\n        \"\"\"\n        Check if there is a conflict between the operating mode and the relationship between the current temperature and the target temperature.\n        If there is a conflict, the operating mode will be adjusted automatically.\n        :return: True if mode isn't conflict with the relationship between the current temperature and the target temperature, or False otherwise.\n        \"\"\"\n        if self.mode == 'heat' and self.current_temperature >= self.target_temperature:\n            self.mode = 'cool'\n            return False\n        elif self.mode == 'cool' and self.current_temperature <= self.target_temperature:\n            self.mode = 'heat'\n            return False\n        else:\n            return True\n\n    def simulate_operation(self):\n        \"\"\"\n        simulate the operation of Thermostat. It will automatically start the auto_set_mode method to set the operating mode,\n        and then automatically adjust the current temperature according to the operating mode until the target temperature is reached.\n        :return time: int, the time it took to complete the simulation.\n        \"\"\"\n        start_time = 0\n        self.auto_set_mode()\n        while abs(self.current_temperature - self.target_temperature) > 0.3:\n            if self.mode == 'heat':\n                self.current_temperature += 1\n            else:\n                self.current_temperature -= 1\n            start_time += 1\n            if start_time > 100:\n                break\n\n        # Ensure the final temperature is exactly the target temperature\n        self.current_temperature = self.target_temperature\n        return start_time\n```",
    "86": "```python\nclass TicTacToe:\n    \"\"\"\n    The class represents a game of Tic-Tac-Toe and its functions include making a move on the board, checking for a winner, and determining if the board is full.\n    \"\"\"\n\n    def __init__(self, N=3):\n        \"\"\"\n        Initialize a 3x3 game board with all empty spaces and current symbol player, default is 'X'.\n        \"\"\"\n        self.N = N\n        self.board = [[' ' for _ in range(N)] for _ in range(N)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Place the current player's mark at the specified position on the board and switch the mark.\n        :param row: int, the row index of the position\n        :param col: int, the column index of the position\n        :return: bool, indicating whether the move was successful or not\n        \"\"\"\n        if not (0 <= row < self.N and 0 <= col < self.N):\n            return False\n        if self.board[row][col] == ' ':\n            self.board[row][col] = self.current_player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        else:\n            return False\n\n    def check_winner(self):\n        \"\"\"\n        Check if there is a winner on the board in rows, columns and diagonals three directions\n        :return: str or None, the mark of the winner ('X' or 'O'), or None if there is no winner yet\n        \"\"\"\n        # Check rows\n        for row in range(self.N):\n            if self.board[row][0] != ' ' and all(self.board[row][col] == self.board[row][0] for col in range(self.N)):\n                return self.board[row][0]\n\n        # Check columns\n        for col in range(self.N):\n            if self.board[0][col] != ' ' and all(self.board[row][col] == self.board[0][col] for row in range(self.N)):\n                return self.board[0][col]\n\n        # Check diagonals\n        if self.board[0][0] != ' ' and all(self.board[i][i] == self.board[0][0] for i in range(self.N)):\n            return self.board[0][0]\n\n        if self.board[0][self.N - 1] != ' ' and all(self.board[i][self.N - 1 - i] == self.board[0][self.N - 1] for i in range(self.N)):\n            return self.board[0][self.N - 1]\n\n        return None\n\n    def is_board_full(self):\n        \"\"\"\n        Check if the game board is completely filled.\n        :return: bool, indicating whether the game board is full or not\n        \"\"\"\n        return all(self.board[row][col] != ' ' for row in range(self.N) for col in range(self.N))\n```",
    "87": "```python\nimport datetime\nimport time\n\nclass TimeUtils:\n    \"\"\"\n    This is a time util class, including getting the current time and date, adding seconds to a datetime, converting between strings and datetime objects, calculating the time difference in minutes, and formatting a datetime object.\n    \"\"\"\n\n\n    def __init__(self):\n        \"\"\"\n        Get the current datetime\n        \"\"\"\n        self.datetime = datetime.datetime.now()\n\n    def get_current_time(self):\n        \"\"\"\n        Return the current time in the format of '%H:%M:%S'\n        :return: string\n        >>> timeutils = TimeUtils()\n        >>> timeutils.get_current_time()\n        \"19:19:22\"\n        \"\"\"\n        return self.datetime.strftime(\"%H:%M:%S\")\n\n    def get_current_date(self):\n        \"\"\"\n        Return the current date in the format of \"%Y-%m-%d\"\n        :return: string\n        >>> timeutils.get_current_date()\n        \"2023-06-14\"\n        \"\"\"\n        return self.datetime.strftime(\"%Y-%m-%d\")\n\n    def add_seconds(self, seconds):\n        \"\"\"\n        Add the specified number of seconds to the current time\n        :param seconds: int, number of seconds to add\n        :return: string, time after adding the specified number of seconds in the format '%H:%M:%S'\n        >>> timeutils.add_seconds(600)\n        \"19:29:22\"\n        \"\"\"\n        return (self.datetime + datetime.timedelta(seconds=seconds)).strftime(\"%H:%M:%S\")\n\n    def string_to_datetime(self, string):\n        \"\"\"\n        Convert the time string to a datetime instance\n        :param string: string, string before converting format\n        :return: datetime instance\n        >>> timeutils.string_to_datetime(\"2001-7-18 1:1:1\")\n        2001-07-18 01:01:01\n        \"\"\"\n        return datetime.datetime.strptime(string, \"%Y-%m-%d %H:%M:%S\")\n\n    def datetime_to_string(self, datetime_obj):\n        \"\"\"\n        Convert a datetime instance to a string\n        :param datetime: the datetime instance to convert\n        :return: string, converted time string\n        >>> timeutils.datetime_to_string(timeutils.datetime)\n        \"2023-06-14 19:30:03\"\n        \"\"\"\n        return datetime_obj.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    def get_minutes(self, string_time1, string_time2):\n        \"\"\"\n        Calculate how many minutes have passed between two times, and round the results to the nearest\n        :return: int, the number of minutes between two times, rounded off\n        >>> timeutils.get_minutes(\"2001-7-18 1:1:1\", \"2001-7-18 2:1:1\")\n        60\n        \"\"\"\n        time1 = datetime.datetime.strptime(string_time1, \"%Y-%m-%d %H:%M:%S\")\n        time2 = datetime.datetime.strptime(string_time2, \"%Y-%m-%d %H:%M:%S\")\n        return round((time2 - time1).total_seconds() / 60)\n\n    def get_format_time(self, year, month, day, hour, minute, second):\n        \"\"\"\n        get format time\n        :param year: int\n        :param month: int\n        :param day: int\n        :param hour: int\n        :param minute: int\n        :param second: int\n        :return: formatted time string\n        >>> timeutils.get_format_time(2001, 7, 18, 1, 1, 1)\n        \"2001-07-18 01:01:01\"\n        \"\"\"\n        return datetime.datetime(year, month, day, hour, minute, second).strftime(\"%Y-%m-%d %H:%M:%S\")\n```",
    "88": "```python\nfrom math import pi, fabs\n\nclass TriCalculator:\n    \"\"\"\n    The class allows to calculate trigonometric values, including cosine, sine, and tangent, using Taylor series approximations.\n    \"\"\"\n\n\n    def __init__(self):\n        pass\n\n    def cos(self, x):\n        \"\"\"\n        Calculate the cos value of the x-degree angle\n        :param x:float\n        :return:float\n        \"\"\"\n        x = x % 360\n        radians = x * pi / 180\n        result = self.taylor(x, 50)\n        return result\n\n    def factorial(self, a):\n        \"\"\"\n        Calculate the factorial of a\n        :param a: int\n        :return: int\n        \"\"\"\n        if a == 0:\n            return 1\n        else:\n            fact = 1\n            for i in range(1, a + 1):\n                fact = fact * i\n            return fact\n\n    def taylor(self, x, n):\n        \"\"\"\n        Finding the n-order Taylor expansion value of cos (x/180 * pi)\n        :param x: int\n        :param n: int\n        :return: float\n        \"\"\"\n        x = x % 360\n        x = x * pi / 180\n        cos_approx = 0\n        for i in range(n):\n            numerator = (-1)**i * x**(2*i)\n            denominator = self.factorial(2*i)\n            cos_approx += numerator / denominator\n        return cos_approx\n\n    def sin(self, x):\n        \"\"\"\n        Calculate the sin value of the x-degree angle\n        :param x: float\n        :return: float\n        \"\"\"\n        x = x % 360\n        radians = x * pi / 180\n        sin_approx = 0\n        n = 50\n        for i in range(n):\n            numerator = (-1)**i * (radians)**(2*i + 1)\n            denominator = self.factorial(2*i + 1)\n            sin_approx += numerator / denominator\n        return sin_approx\n\n\n    def tan(self, x):\n        \"\"\"\n        Calculate the tan value of the x-degree angle\n        :param x: float\n        :return: float\n        \"\"\"\n        if x % 180 == 90:\n            return False\n        else:\n          cos_val = self.cos(x)\n          if cos_val == 0:\n            return False\n          return self.sin(x) / cos_val\n```",
    "89": "```python\nimport random\n\nclass TwentyFourPointGame:\n    \"\"\"\n    This is a game of twenty-four points, which provides to generate four numbers and check whether player's expression is equal to 24.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.nums = []\n\n\n    def _generate_cards(self):\n        \"\"\"\n        Generate random numbers between 1 and 9 for the cards.\n        \"\"\"\n        self.nums = [random.randint(1, 9) for _ in range(4)]\n\n\n    def get_my_cards(self):\n        \"\"\"\n        Get a list of four random numbers between 1 and 9 representing the player's cards.\n        :return: list of integers, representing the player's cards\n        \"\"\"\n        self._generate_cards()\n        return self.nums\n\n\n    def answer(self, expression):\n        \"\"\"\n        Check if a given mathematical expression using the cards can evaluate to 24.\n        :param expression: string, mathematical expression using the cards\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        \"\"\"\n        if not self.nums:\n            return [1, 1, 1, 1]\n        try:\n            result = eval(expression)\n            return abs(result - 24.0) < 1e-6\n        except (SyntaxError, NameError, TypeError, ZeroDivisionError):\n            return False\n        except Exception:\n            return False\n\n\n    def evaluate_expression(self, expression):\n        \"\"\"\n        Evaluate a mathematical expression and check if the result is 24.\n        :param expression: string, mathematical expression\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        \"\"\"\n        try:\n            result = eval(expression)\n            return abs(result - 24.0) < 1e-6\n        except (SyntaxError, NameError, TypeError, ZeroDivisionError):\n            return False\n        except Exception:\n            return False\n```",
    "90": "```python\nfrom urllib.parse import urlparse, parse_qs\n\n\nclass URLHandler:\n    \"\"\"\n    The class supports to handle URLs, including extracting the scheme, host, path, query parameters, and fragment.\n    \"\"\"\n\n    def __init__(self, url):\n        \"\"\"\n        Initialize URLHandler's URL\n        \"\"\"\n        self.url = url\n\n    def get_scheme(self):\n        \"\"\"\n        get the scheme of the URL\n        :return: string, If successful, return the scheme of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_scheme()\n        \"https\"\n        \"\"\"\n        try:\n            parsed_url = urlparse(self.url)\n            return parsed_url.scheme or None\n        except Exception:\n            return None\n\n    def get_host(self):\n        \"\"\"\n        Get the second part of the URL, which is the host domain name\n        :return: string, If successful, return the host domain name of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_host()\n        \"www.baidu.com\"\n        \"\"\"\n        try:\n            parsed_url = urlparse(self.url)\n            return parsed_url.netloc or None\n        except Exception:\n            return None\n\n    def get_path(self):\n        \"\"\"\n        Get the third part of the URL, which is the address of the resource\n        :return: string, If successful, return the address of the resource of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_path()\n        \"/s?wd=aaa&rsv_spt=1#page\"\n        \"\"\"\n        try:\n            parsed_url = urlparse(self.url)\n            path = parsed_url.path\n            query = parsed_url.query\n            fragment = parsed_url.fragment\n\n            full_path = path\n            if query:\n                full_path += '?' + query\n            if fragment:\n                full_path += '#' + fragment\n\n            return full_path or None\n        except Exception:\n            return None\n\n    def get_query_params(self):\n        \"\"\"\n        Get the request parameters for the URL\n        :return: dict, If successful, return the request parameters of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_query_params()\n        {\"wd\": \"aaa\", \"rsv_spt\": \"1\"}\n        \"\"\"\n        try:\n            parsed_url = urlparse(self.url)\n            query_params = parse_qs(parsed_url.query)\n\n            if not query_params and parsed_url.query:\n                return {}\n\n            if query_params:\n                result = {}\n                for key, value in query_params.items():\n                    result[key] = value[0]\n                return result\n            else:\n                return None\n        except Exception:\n            return None\n\n    def get_fragment(self):\n        \"\"\"\n        Get the fragment after '#' in the URL\n        :return: string, If successful, return the fragment after '#' of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_fragment()\n        \"page\"\n        \"\"\"\n        try:\n            parsed_url = urlparse(self.url)\n            return parsed_url.fragment or None\n        except Exception:\n            return None\n```",
    "91": "```python\nimport urllib.parse\n\nclass UrlPath:\n    \"\"\"\n    The  class is a utility for encapsulating and manipulating the path component of a URL, including adding nodes, parsing path strings, and building path strings with optional encoding.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the UrlPath object with an empty list of segments and a flag indicating the presence of an end tag.\n        \"\"\"\n        self.segments = []\n        self.with_end_tag = False\n\n    def add(self, segment):\n        \"\"\"\n        Adds a segment to the list of segments in the UrlPath.\n        :param segment: str, the segment to add.\n        \"\"\"\n        self.segments.append(segment)\n\n    def parse(self, path, charset):\n        \"\"\"\n        Parses a given path string and populates the list of segments in the UrlPath.\n        :param path: str, the path string to parse.\n        :param charset: str, the character encoding of the path string.\n        \"\"\"\n        fixed_path = self.fix_path(path)\n        if fixed_path:\n            self.segments = fixed_path.split('/')\n        else:\n            self.segments = []\n\n        self.with_end_tag = path.endswith('/') if path else False\n\n\n    @staticmethod\n    def fix_path(path):\n        \"\"\"\n        Fixes the given path string by removing leading and trailing slashes.\n        :param path: str, the path string to fix.\n        :return: str, the fixed path string.\n        \"\"\"\n        if not path:\n            return \"\"\n\n        start = 0\n        end = len(path)\n\n        while start < end and path[start] == '/':\n            start += 1\n        while end > start and path[end-1] == '/':\n            end -= 1\n\n        return path[start:end]\n```",
    "92": "```python\nimport sqlite3\n\nclass UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information, searching user information, deleting user information, and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.db_name = db_name\n        self.connection = sqlite3.connect(self.db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates the 'users' table if it doesn't exist.\n        \"\"\"\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS users (\n            username TEXT PRIMARY KEY,\n            password TEXT\n        )\n        \"\"\"\n        self.cursor.execute(create_table_query)\n        self.connection.commit()\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        \"\"\"\n        insert_query = \"INSERT OR REPLACE INTO users (username, password) VALUES (?, ?)\"\n        self.cursor.execute(insert_query, (username, password))\n        self.connection.commit()\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return:list of tuples, the rows from the \"users\" table that match the search criteria.\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> result = user_db.search_user_by_username('user1')\n        len(result) = 1\n        \"\"\"\n        search_query = \"SELECT username, password FROM users WHERE username = ?\"\n        self.cursor.execute(search_query, (username,))\n        result = self.cursor.fetchone()\n        return result\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.delete_user_by_username('user1')\n        \"\"\"\n        delete_query = \"DELETE FROM users WHERE username = ?\"\n        self.cursor.execute(delete_query, (username,))\n        self.connection.commit()\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct\n        :param username:str, the username of the user to validate.\n        :param password:str, the password of the user to validate.\n        :return:bool, representing whether the user can log in correctly\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.validate_user_login('user1', 'pass1')\n        True\n        \"\"\"\n        user = self.search_user_by_username(username)\n        if user:\n            return user[1] == password\n        else:\n            return False\n\n    def close(self):\n        \"\"\"Closes the database connection.\"\"\"\n        self.connection.close()\n```",
    "93": "```python\nimport numpy as np\nfrom numpy import dot\nfrom numpy.linalg import norm\n\n\nclass VectorUtil:\n    \"\"\"\n    The class provides vector operations, including calculating similarity, cosine similarities, average similarity, and IDF weights.\n    \"\"\"\n\n    @staticmethod\n    def similarity(vector_1, vector_2):\n        \"\"\"\n        Compute the cosine similarity between one vector and another vector.\n        :param vector_1: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :param vector_2: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :return: numpy.ndarray, Contains cosine distance between `vector_1` and `vector_2`\n        \"\"\"\n        norm_v1 = norm(vector_1)\n        norm_v2 = norm(vector_2)\n\n        if norm_v1 == 0 or norm_v2 == 0:\n            return 0.0\n\n        return dot(vector_1, vector_2) / (norm_v1 * norm_v2)\n\n    @staticmethod\n    def cosine_similarities(vector_1, vectors_all):\n        \"\"\"\n        Compute cosine similarities between one vector and a set of other vectors.\n        :param vector_1: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :param vectors_all: list of numpy.ndarray, For each row in vectors_all, distance from vector_1 is computed, expected shape (num_vectors, dim).\n        :return: numpy.ndarray, Contains cosine distance between `vector_1` and each row in `vectors_all`, shape (num_vectors,).\n        \"\"\"\n        similarities = []\n        norm_v1 = norm(vector_1)\n\n        if norm_v1 == 0:\n            return [0.0] * len(vectors_all)\n\n        for vector in vectors_all:\n            norm_v2 = norm(vector)\n            if norm_v2 == 0:\n                similarities.append(0.0)\n            else:\n                similarities.append(dot(vector_1, vector) / (norm_v1 * norm_v2))\n        return similarities\n\n    @staticmethod\n    def n_similarity(vector_list_1, vector_list_2):\n        \"\"\"\n        Compute cosine similarity between two sets of vectors.\n        :param vector_list_1: list of numpy vector\n        :param vector_list_2: list of numpy vector\n        :return: numpy.ndarray, Similarities between vector_list_1 and vector_list_2.\n        \"\"\"\n        if not vector_list_1 or not vector_list_2:\n            return 0.0\n\n        sum_sim = 0.0\n        count = 0\n        for v1 in vector_list_1:\n            norm_v1 = norm(v1)\n            if norm_v1 == 0:\n                continue\n            for v2 in vector_list_2:\n                norm_v2 = norm(v2)\n                if norm_v2 == 0:\n                    continue\n                sim = dot(v1, v2) / (norm_v1 * norm_v2)\n                sum_sim += sim\n                count += 1\n\n        return sum_sim / count if count > 0 else 0.0\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num, number_dict):\n        \"\"\"\n        Calculate log(total_num+1/count+1) for each count in number_dict\n        :param total_num: int\n        :param number_dict: dict\n        :return: dict\n        \"\"\"\n        idf_weight_dict = {}\n        for key, count in number_dict.items():\n            idf_weight_dict[key] = np.log((total_num + 1) / (count + 1))\n        return idf_weight_dict\n```",
    "94": "```python\nclass VendingMachine:\n    \"\"\"\n    This is a class to simulate a vending machine, including adding products, inserting coins, purchasing products, viewing balance, replenishing product inventory, and displaying product information.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the vending machine's inventory and balance.\n        \"\"\"\n        self.inventory = {}\n        self.balance = 0\n\n    def add_item(self, item_name, price, quantity):\n        \"\"\"\n        Adds a product to the vending machine's inventory.\n        :param item_name: The name of the product to be added, str.\n        :param price: The price of the product to be added, float.\n        :param quantity: The quantity of the product to be added, int.\n        :return: None\n        >>> vendingMachine = VendingMachine()\n        >>> vendingMachine.add_item('Coke', 1.25, 10)\n        >>> vendingMachine.inventory\n        {'Coke': {'price': 1.25, 'quantity': 10}}\n\n        \"\"\"\n        if not isinstance(item_name, str):\n            raise TypeError(\"item_name must be a string\")\n        if not isinstance(price, (int, float)):\n            raise TypeError(\"price must be a number\")\n        if not isinstance(quantity, int):\n            raise TypeError(\"quantity must be an integer\")\n        if quantity < 0:\n            raise ValueError(\"quantity must be non-negative\")\n\n        if item_name in self.inventory:\n            self.inventory[item_name]['quantity'] += quantity\n        else:\n            self.inventory[item_name] = {'price': price, 'quantity': quantity}\n\n    def insert_coin(self, amount):\n        \"\"\"\n        Inserts coins into the vending machine.\n        :param amount: The amount of coins to be inserted, float.\n        :return: The balance of the vending machine after the coins are inserted, float.\n        >>> vendingMachine = VendingMachine()\n        >>> vendingMachine.insert_coin(1.25)\n        1.25\n\n        \"\"\"\n        if not isinstance(amount, (int, float)):\n            raise TypeError(\"amount must be a number\")\n        if amount <= 0:\n            raise ValueError(\"amount must be positive\")\n\n        self.balance += amount\n        return self.balance\n\n    def purchase_item(self, item_name):\n        \"\"\"\n        Purchases a product from the vending machine and returns the balance after the purchase and display purchase unsuccessful if the product is out of stock.\n        :param item_name: The name of the product to be purchased, str.\n        :return: If successful, returns the balance of the vending machine after the product is purchased, float,otherwise,returns False.\n        >>> vendingMachine = VendingMachine()\n        >>> vendingMachine.inventory = {'Coke': {'price': 1.25, 'quantity': 10}}\n        >>> vendingMachine.balance = 1.25\n        >>> vendingMachine.purchase_item('Coke')\n        0.0\n        >>> vendingMachine.purchase_item('Pizza')\n        False\n\n        \"\"\"\n        if not isinstance(item_name, str):\n            raise TypeError(\"item_name must be a string\")\n\n        if item_name in self.inventory:\n            if self.inventory[item_name]['quantity'] > 0:\n                if self.balance >= self.inventory[item_name]['price']:\n                    self.inventory[item_name]['quantity'] -= 1\n                    self.balance -= self.inventory[item_name]['price']\n                    return self.balance\n                else:\n                    return False\n            else:\n                return False\n        else:\n            return False\n\n    def restock_item(self, item_name, quantity):\n        \"\"\"\n        Replenishes the inventory of a product already in the vending machine.\n        :param item_name: The name of the product to be replenished, str.\n        :param quantity: The quantity of the product to be replenished, int.\n        :return: If the product is already in the vending machine, returns True, otherwise, returns False.\n        >>> vendingMachine = VendingMachine()\n        >>> vendingMachine.inventory = {'Coke': {'price': 1.25, 'quantity': 10}}\n        >>> vendingMachine.restock_item('Coke', 10)\n        True\n        >>> vendingMachine.restock_item('Pizza', 10)\n        False\n\n        \"\"\"\n        if not isinstance(item_name, str):\n            raise TypeError(\"item_name must be a string\")\n        if not isinstance(quantity, int):\n            raise TypeError(\"quantity must be an integer\")\n        if quantity < 0:\n            raise ValueError(\"quantity must be non-negative\")\n\n        if item_name in self.inventory:\n            self.inventory[item_name]['quantity'] += quantity\n            return True\n        else:\n            return False\n\n    def display_items(self):\n        \"\"\"\n        Displays the products in the vending machine.\n        :return: If the vending machine is empty, returns False, otherwise, returns a list of the products in the vending machine, str.\n        >>> vendingMachine = VendingMachine()\n        >>> vendingMachine.display_items()\n        False\n        >>> vendingMachine.inventory = {'Coke': {'price': 1.25, 'quantity': 10} }\n        >>> vendingMachine.display_items()\n        'Coke - $1.25 [10]'\n\n        \"\"\"\n        if not self.inventory:\n            return False\n        else:\n            result = \"\"\n            for item_name, details in self.inventory.items():\n                result += f\"{item_name} - ${details['price']} [{details['quantity']}]\"\n                if item_name != list(self.inventory.keys())[-1]:\n                    result += \"\\n\"\n            return result\n```",
    "95": "```python\nclass Warehouse:\n    \"\"\"\n    The class manages inventory and orders, including adding products, updating product quantities, retrieving product quantities, creating orders, changing order statuses, and tracking orders.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize two fields.\n        self.inventory is a dict that stores the products.\n        self.inventory = {Product ID: Product}\n        self.orders is a dict that stores the products in a order.\n        self.orders = {Order ID: Order}\n        \"\"\"\n        self.inventory = {}  # Product ID: Product\n        self.orders = {}  # Order ID: Order\n\n    def add_product(self, product_id, name, quantity):\n        \"\"\"\n        Add product to inventory and plus the quantity if it has existed in inventory.\n        Or just add new product to dict otherwise.\n        :param product_id: int\n        :param name: str, product name\n        :param quantity: int, product quantity\n        \"\"\"\n        if product_id in self.inventory:\n            self.inventory[product_id]['quantity'] += quantity\n        else:\n            self.inventory[product_id] = {'name': name, 'quantity': quantity}\n\n    def update_product_quantity(self, product_id, quantity):\n        \"\"\"\n        According to product_id, add the quantity to the corresponding product in inventory.\n        \"\"\"\n        if product_id in self.inventory:\n            self.inventory[product_id]['quantity'] += quantity\n\n    def get_product_quantity(self, product_id):\n        \"\"\"\n        Get the quantity of specific product by product_id.\n        :param product_id, int\n        :return: if the product_id is in inventory then return the corresponding quantity,\n                or False otherwise.\n        \"\"\"\n        if product_id in self.inventory:\n            return self.inventory[product_id]['quantity']\n        else:\n            return False\n\n    def create_order(self, order_id, product_id, quantity):\n        \"\"\"\n        Create a order which includes the infomation of product, like id and quantity.\n        And put the new order into self.orders.\n        The default value of status is 'Shipped'.\n        :param order_id: int\n        :param product_id: int\n        :param quantity: the quantity of product that be selected.\n        :return False: only if product_id is not in inventory or the quantity is not adequate\n        \"\"\"\n        if product_id not in self.inventory:\n            return False\n        if self.inventory[product_id]['quantity'] < quantity:\n            return False\n\n        self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}\n        return True\n\n    def change_order_status(self, order_id, status):\n        \"\"\"\n        Change the status of order if the input order_id is in self.orders.\n        :param order_id: int\n        :param status: str, the state that is going to change to\n        :return False: only if the order_id is not in self.orders\n        \"\"\"\n        if order_id not in self.orders:\n            return False\n        self.orders[order_id]['status'] = status\n        return True\n\n    def track_order(self, order_id):\n        \"\"\"\n        Get the status of specific order.\n        :param order_id: int\n        :return False: only if the order_id is not in self.orders.\n        \"\"\"\n        if order_id not in self.orders:\n            return False\n        return self.orders[order_id]['status']\n```",
    "96": "```python\nclass WeatherSystem:\n    \"\"\"\n    This is a class representing a weather system that provides functionality to query weather information for a specific city and convert temperature units between Celsius and Fahrenheit.\n    \"\"\"\n\n    def __init__(self, city) -> None:\n        \"\"\"\n        Initialize the weather system with a city name.\n        \"\"\"\n        self.temperature = None\n        self.weather = None\n        self.city = city\n        self.weather_list = {}\n\n    def query(self, weather_list, tmp_units = 'celsius'):\n        \"\"\"\n        Query the weather system for the weather and temperature of the city,and convert the temperature units based on the input parameter.\n        :param weather_list: a dictionary of weather information for different cities,dict.\n        :param tmp_units: the temperature units to convert to, str.\n        :return: the temperature and weather of the city, tuple.\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weather_list = {'New York': {'weather': 'sunny','temperature': 27,'temperature units': 'celsius'},'Beijing': {'weather': 'cloudy','temperature': 23,'temperature units': 'celsius'}}\n        >>> weatherSystem.query(weather_list)\n        (27, 'sunny')\n\n        \"\"\"\n        if self.city in weather_list:\n            weather_info = weather_list[self.city]\n            temperature = weather_info['temperature']\n            weather = weather_info['weather']\n            temperature_units = weather_info['temperature units']\n\n            if tmp_units == 'fahrenheit' and temperature_units == 'celsius':\n                temperature = self.celsius_to_fahrenheit_static(temperature)\n            elif tmp_units == 'celsius' and temperature_units == 'fahrenheit':\n                temperature = self.fahrenheit_to_celsius_static(temperature)\n\n            return (temperature, weather)\n        else:\n            return False\n\n    def set_city(self, city):\n        \"\"\"\n        Set the city of the weather system.\n        :param city: the city to set, str.\n        :return: None\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weatherSystem.set_city('Beijing')\n        >>> weatherSystem.city\n        'Beijing'\n\n        \"\"\"\n        self.city = city\n\n    def celsius_to_fahrenheit(self):\n        \"\"\"\n        Convert the temperature from Celsius to Fahrenheit.\n        :return: the temperature in Fahrenheit, float.\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weatherSystem.temperature = 27\n        >>> weatherSystem.celsius_to_fahrenheit()\n        80.6\n\n        \"\"\"\n        return (self.temperature * 9/5) + 32\n\n    def fahrenheit_to_celsius(self):\n        \"\"\"\n        Convert the temperature from Fahrenheit to Celsius.\n        :return: the temperature in Celsius, float.\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weatherSystem.temperature = 80.6\n        >>> weatherSystem.fahrenheit_to_celsius()\n        26.999999999999996\n\n        \"\"\"\n        return (self.temperature - 32) * 5/9\n\n    @staticmethod\n    def celsius_to_fahrenheit_static(celsius):\n        return (celsius * 9/5) + 32\n\n    @staticmethod\n    def fahrenheit_to_celsius_static(fahrenheit):\n        return (fahrenheit - 32) * 5/9\n```",
    "97": "```python\nclass Words2Numbers:\n    \"\"\"\n    The class provides a text-to-number conversion utility, allowing conversion of written numbers (in words) to their numerical representation.\n    \"\"\"\n\n\n    def __init__(self):\n        \"\"\"\n        Initialize the word lists and dictionaries required for conversion\n        \"\"\"\n        self.numwords = {}\n        self.units = [\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\n            \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n            \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\",\n        ]\n        self.tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        self.scales = [\"hundred\", \"thousand\", \"million\", \"billion\", \"trillion\"]\n\n        self.numwords[\"and\"] = (1, 0)\n        for idx, word in enumerate(self.units):\n            self.numwords[word] = (1, idx)\n        for idx, word in enumerate(self.tens):\n            self.numwords[word] = (1, idx * 10)\n        for idx, word in enumerate(self.scales):\n            self.numwords[word] = (10 ** (idx * 3 or 2), 0)\n\n        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}\n        self.ordinal_endings = [('ieth', 'y'), ('th', '')]\n\n\n    def text2int(self, textnum):\n        \"\"\"\n        Convert the word string to the corresponding integer string\n        :param textnum: string, the word string to be converted\n        :return: string, the final converted integer string\n        >>> w2n = Words2Numbers()\n        >>> w2n.text2int(\"thirty-two\")\n        \"32\"\n        \"\"\"\n        textnum = textnum.replace('-', ' ')\n        current = result = 0\n        for word in textnum.split():\n            word = word.lower()\n            if word in self.numwords:\n                scale, increment = self.numwords[word]\n                current = current * scale + increment\n                if scale > 100:\n                    result += current\n                    current = 0\n            elif word in self.ordinal_words:\n                result = self.ordinal_words[word]\n                current = 0 # Reset current after ordinal\n            else:\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        base_word = word[:-len(ending)] + replacement\n                        if base_word in self.numwords:\n                            scale, increment = self.numwords[base_word]\n                            result += increment\n                            current = 0 # Reset current after ordinal\n                            break\n                else:\n                    raise ValueError(\"Illegal word: \" + word)\n\n        return str(result + current)\n\n    def is_valid_input(self, textnum):\n        \"\"\"\n        Check if the input text contains only valid words that can be converted into numbers.\n        :param textnum: The input text containing words representing numbers.\n        :return: True if input is valid, False otherwise.\n        >>> w2n = Words2Numbers()\n        >>> w2n.is_valid_input(\"thirty-two\")\n        False\n        \"\"\"\n        textnum = textnum.replace('-', ' ')\n        for word in textnum.split():\n            word = word.lower()\n            found = False\n            if word in self.numwords or word in self.ordinal_words:\n                found = True\n            else:\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        base_word = word[:-len(ending)] + replacement\n                        if base_word in self.numwords:\n                            found = True\n                            break\n            if not found:\n                return False\n        return True\n```",
    "98": "```python\nimport xml.etree.ElementTree as ET\n\n\nclass XMLProcessor:\n    \"\"\"\n    This is a class as XML files handler, including reading, writing, processing as well as finding elements in a XML file.\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize the XMLProcessor object with the given file name.\n        :param file_name:string, the name of the XML file to be processed.\n        \"\"\"\n        self.file_name = file_name\n        self.root = None\n\n    def read_xml(self):\n        \"\"\"\n        Reads the XML file and returns the root element.\n        :return: Element, the root element of the XML file.\n        \"\"\"\n        try:\n            tree = ET.parse(self.file_name)\n            self.root = tree.getroot()\n            return self.root\n        except FileNotFoundError:\n            return None\n        except ET.ParseError:\n            return None\n        except Exception:\n            return None\n\n    def write_xml(self, file_name):\n        \"\"\"\n        Writes the XML data to the specified file.\n        :param file_name: string, the name of the file to write the XML data.\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n        if self.root is None:\n            return False\n        try:\n            tree = ET.ElementTree(self.root)\n            tree.write(file_name)\n            return True\n        except FileNotFoundError:\n            return False\n        except Exception:\n            return False\n\n    def process_xml_data(self, file_name):\n        \"\"\"\n        Modifies the data in XML elements and writes the updated XML data to a new file.\n        :param file_name: string, the name of the file to write the modified XML data.\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n        if self.root is None:\n            return False\n        try:\n            for item in self.root.findall('item'):\n                if item.text:\n                    item.text = item.text.upper()\n            tree = ET.ElementTree(self.root)\n            tree.write(file_name)\n            return True\n        except FileNotFoundError:\n            return False\n        except Exception:\n            return False\n\n    def find_element(self, element_name):\n        \"\"\"\n        Finds the XML elements with the specified name.\n        :param element_name: string, the name of the elements to find.\n        :return: list, a list of found elements with the specified name.\n        \"\"\"\n        if self.root is None:\n            return []\n        return self.root.findall(element_name)\n```",
    "99": "```python\nimport zipfile\nimport os\n\n\nclass ZipFileProcessor:\n    \"\"\"\n    This is a compressed file processing class that provides the ability to read and decompress compressed files\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize file name\n        :param file_name:string\n        \"\"\"\n        self.file_name = file_name\n\n    def read_zip_file(self):\n        \"\"\"\n        Get open file object\n        :return:If successful, returns the open file object; otherwise, returns None\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> file = zfp.read_zip_file()\n        \"\"\"\n        try:\n            zip_file = zipfile.ZipFile(self.file_name, 'r')\n            return zip_file\n        except Exception:\n            return None\n\n    def extract_all(self, output_path):\n        \"\"\"\n        Extract all zip files and place them in the specified path\n        :param output_path: string, The location of the extracted file\n        :return: True or False, representing whether the extraction operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.extract_all(\"result/aaa\")\n        \"\"\"\n        try:\n            os.makedirs(output_path, exist_ok=True)\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                zip_file.extractall(output_path)\n            return True\n        except Exception:\n            return False\n\n    def extract_file(self, file_name, output_path):\n        \"\"\"\n        Extract the file with the specified name from the zip file and place it in the specified path\n        :param file_name:string, The name of the file to be uncompressed\n        :param output_path:string, The location of the extracted file\n        :return: True or False, representing whether the extraction operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.extract_file(\"bbb.txt\", \"result/aaa\")\n        \"\"\"\n        try:\n            os.makedirs(output_path, exist_ok=True)\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                zip_file.extract(file_name, output_path)\n            return True\n        except Exception:\n            return False\n\n    def create_zip_file(self, files, output_file_name):\n        \"\"\"\n        Compress the specified file list into a zip file and place it in the specified path\n        :param files:list of string, List of files to compress\n        :param output_file_name: string, Specified output path\n        :return:True or False, representing whether the compression operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.create_zip_file([\"bbb.txt\", \"ccc,txt\", \"ddd.txt\"], \"output/bcd\")\n        \"\"\"\n        try:\n            os.makedirs(os.path.dirname(output_file_name), exist_ok=True)\n            with zipfile.ZipFile(output_file_name, 'w') as zip_file:\n                for file in files:\n                    if os.path.exists(file):\n                        zip_file.write(file, os.path.basename(file))\n            return True\n        except Exception:\n            return False\n```"
}