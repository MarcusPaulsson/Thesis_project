{
    "0": "```python\ndef print_board(board):\n    \"\"\"Prints the Tic-Tac-Toe board to the console.\"\"\"\n    print(\"-------------\")\n    for i in range(3):\n        print(\"|\", board[i][0], \"|\", board[i][1], \"|\", board[i][2], \"|\")\n        print(\"-------------\")\n\n\ndef check_win(board, player):\n    \"\"\"Checks if the given player has won the game.\"\"\"\n    # Check rows\n    for row in board:\n        if all(cell == player for cell in row):\n            return True\n\n    # Check columns\n    for col in range(3):\n        if all(board[row][col] == player for row in range(3)):\n            return True\n\n    # Check diagonals\n    if all(board[i][i] == player for i in range(3)):\n        return True\n    if all(board[i][2 - i] == player for i in range(3)):\n        return True\n\n    return False\n\n\ndef check_draw(board):\n    \"\"\"Checks if the game is a draw.\"\"\"\n    return all(cell != \" \" for row in board for cell in row)\n\n\ndef get_player_move(board, player):\n    \"\"\"Gets the player's move from the console.\"\"\"\n    while True:\n        try:\n            row = int(input(f\"Player {player}, enter row (0-2): \"))\n            col = int(input(f\"Player {player}, enter column (0-2): \"))\n\n            if not (0 <= row <= 2 and 0 <= col <= 2):\n                print(\"Invalid input. Row and column must be between 0 and 2.\")\n                continue\n\n            if board[row][col] != \" \":\n                print(\"That cell is already occupied. Try again.\")\n                continue\n\n            return row, col\n\n        except ValueError:\n            print(\"Invalid input. Please enter numbers.\")\n\n\ndef tic_tac_toe():\n    \"\"\"Main function to run the Tic-Tac-Toe game.\"\"\"\n    board = [[\" \" for _ in range(3)] for _ in range(3)]\n    current_player = \"X\"\n\n    print(\"Welcome to Tic-Tac-Toe!\")\n    print_board(board)\n\n    while True:\n        row, col = get_player_move(board, current_player)\n        board[row][col] = current_player\n        print_board(board)\n\n        if check_win(board, current_player):\n            print(f\"Player {current_player} wins!\")\n            break\n\n        if check_draw(board):\n            print(\"It's a draw!\")\n            break\n\n        current_player = \"O\" if current_player == \"X\" else \"X\"\n\n\nif __name__ == \"__main__\":\n    tic_tac_toe()\n```",
    "1": "```python\nimport random\n\ndef choose_word():\n    \"\"\"Chooses a random word from a predefined list.\"\"\"\n    words = [\"python\", \"hangman\", \"programming\", \"computer\", \"algorithm\", \"developer\", \"software\", \"interface\", \"keyboard\", \"monitor\"]\n    return random.choice(words)\n\ndef display_word(word, guessed_letters):\n    \"\"\"Displays the word with correctly guessed letters and underscores for unguessed letters.\"\"\"\n    displayed_word = \"\"\n    for letter in word:\n        if letter in guessed_letters:\n            displayed_word += letter + \" \"\n        else:\n            displayed_word += \"_ \"\n    return displayed_word.strip()\n\ndef hangman():\n    \"\"\"Implements the Hangman game logic.\"\"\"\n\n    word_to_guess = choose_word()\n    guessed_letters = set()\n    incorrect_guesses = 0\n    max_incorrect_guesses = 6  # Number of incorrect guesses allowed\n    game_over = False\n\n    print(\"Welcome to Hangman!\")\n    print(display_word(word_to_guess, guessed_letters))\n    print(f\"You have {max_incorrect_guesses} incorrect guesses remaining.\")\n\n    while not game_over:\n        guess = input(\"Guess a letter: \").lower()\n\n        if not guess.isalpha() or len(guess) != 1:\n            print(\"Invalid input. Please enter a single letter.\")\n            continue\n\n        if guess in guessed_letters:\n            print(\"You already guessed that letter.\")\n            continue\n\n        guessed_letters.add(guess)\n\n        if guess in word_to_guess:\n            print(\"Correct guess!\")\n            displayed_word = display_word(word_to_guess, guessed_letters)\n            print(displayed_word)\n\n            if \"_\" not in displayed_word:\n                print(\"Congratulations! You guessed the word:\", word_to_guess)\n                game_over = True\n        else:\n            incorrect_guesses += 1\n            print(\"Incorrect guess.\")\n            print(f\"You have {max_incorrect_guesses - incorrect_guesses} incorrect guesses remaining.\")\n\n            # Simple hangman drawing based on incorrect guesses\n            if incorrect_guesses == 1:\n                print(\"  O  \")\n            elif incorrect_guesses == 2:\n                print(\"  O  \")\n                print(\"  |  \")\n            elif incorrect_guesses == 3:\n                print(\"  O  \")\n                print(\" /|  \")\n            elif incorrect_guesses == 4:\n                print(\"  O  \")\n                print(\" /|\\ \")\n            elif incorrect_guesses == 5:\n                print(\"  O  \")\n                print(\" /|\\ \")\n                print(\" /   \")\n            elif incorrect_guesses == 6:\n                print(\"  O  \")\n                print(\" /|\\ \")\n                print(\" / \\ \")\n                print(\"You ran out of guesses. The word was:\", word_to_guess)\n                game_over = True\n\n        if incorrect_guesses >= max_incorrect_guesses:\n            game_over = True\n\nif __name__ == \"__main__\":\n    hangman()\n```\n",
    "2": "```python\nimport random\n\ndef get_player_choice():\n    \"\"\"Gets the player's choice (rock, paper, or scissors) from input.\"\"\"\n    while True:\n        choice = input(\"Choose rock, paper, or scissors: \").lower()\n        if choice in [\"rock\", \"paper\", \"scissors\"]:\n            return choice\n        else:\n            print(\"Invalid choice. Please choose rock, paper, or scissors.\")\n\ndef get_computer_choice():\n    \"\"\"Generates a random choice for the computer.\"\"\"\n    return random.choice([\"rock\", \"paper\", \"scissors\"])\n\ndef determine_winner(player_choice, computer_choice):\n    \"\"\"Determines the winner of the game.\"\"\"\n    print(f\"You chose: {player_choice}\")\n    print(f\"Computer chose: {computer_choice}\")\n\n    if player_choice == computer_choice:\n        return \"It's a tie!\"\n    elif (player_choice == \"rock\" and computer_choice == \"scissors\") or \\\n         (player_choice == \"paper\" and computer_choice == \"rock\") or \\\n         (player_choice == \"scissors\" and computer_choice == \"paper\"):\n        return \"You win!\"\n    else:\n        return \"Computer wins!\"\n\ndef play_again():\n    \"\"\"Asks the player if they want to play again.\"\"\"\n    while True:\n        answer = input(\"Play again? (yes/no): \").lower()\n        if answer in [\"yes\", \"no\"]:\n            return answer == \"yes\"\n        else:\n            print(\"Invalid input. Please enter 'yes' or 'no'.\")\n\ndef main():\n    \"\"\"Main function to run the Rock-Paper-Scissors game.\"\"\"\n    print(\"Welcome to Rock-Paper-Scissors!\")\n\n    while True:\n        player_choice = get_player_choice()\n        computer_choice = get_computer_choice()\n        result = determine_winner(player_choice, computer_choice)\n        print(result)\n\n        if not play_again():\n            print(\"Thanks for playing!\")\n            break\n\nif __name__ == \"__main__\":\n    main()\n```",
    "3": "```python\nimport random\nimport time\nimport sys\nimport select\nimport tty\nimport termios\n\nclass SnakeGame:\n    def __init__(self, width=20, height=10):\n        self.width = width\n        self.height = height\n        self.snake = [(width // 2, height // 2)]  # Initial snake position\n        self.food = self.create_food()\n        self.direction = \"right\"\n        self.game_over = False\n        self.score = 0\n        self.delay = 0.2  # Initial delay between moves\n        self.original_settings = termios.tcgetattr(sys.stdin) # Save terminal settings\n\n    def create_food(self):\n        while True:\n            food = (random.randint(0, self.width - 1), random.randint(0, self.height - 1))\n            if food not in self.snake:\n                return food\n\n    def get_next_head(self):\n        head_x, head_y = self.snake[0]\n        if self.direction == \"right\":\n            next_head = (head_x + 1, head_y)\n        elif self.direction == \"left\":\n            next_head = (head_x - 1, head_y)\n        elif self.direction == \"up\":\n            next_head = (head_x, head_y - 1)\n        elif self.direction == \"down\":\n            next_head = (head_x, head_y + 1)\n        return next_head\n\n    def move(self):\n        next_head = self.get_next_head()\n\n        # Check for game over conditions\n        if (\n            next_head[0] < 0\n            or next_head[0] >= self.width\n            or next_head[1] < 0\n            or next_head[1] >= self.height\n            or next_head in self.snake\n        ):\n            self.game_over = True\n            return\n\n        self.snake.insert(0, next_head)\n\n        if next_head == self.food:\n            self.score += 1\n            self.food = self.create_food()\n            self.delay *= 0.95 # Increase speed\n        else:\n            self.snake.pop() # Remove tail if no food eaten\n\n\n    def is_data_available(self):\n        return select.select([sys.stdin], [], [], 0) == ([sys.stdin], [], [])\n\n    def get_input(self):\n        if self.is_data_available():\n            return sys.stdin.read(1)\n        else:\n            return None\n\n\n    def change_direction(self, key):\n        if key == \"w\" and self.direction != \"down\":\n            self.direction = \"up\"\n        elif key == \"s\" and self.direction != \"up\":\n            self.direction = \"down\"\n        elif key == \"a\" and self.direction != \"right\":\n            self.direction = \"left\"\n        elif key == \"d\" and self.direction != \"left\":\n            self.direction = \"right\"\n        elif key == \"\\x1b[A\" and self.direction != \"down\": #Up Arrow\n            self.direction = \"up\"\n        elif key == \"\\x1b[B\" and self.direction != \"up\": #Down Arrow\n            self.direction = \"down\"\n        elif key ==",
    "4": "```python\nimport random\nimport sys\n\nclass Minesweeper:\n    def __init__(self, rows, cols, mines):\n        self.rows = rows\n        self.cols = cols\n        self.mines = mines\n        self.board = [[' ' for _ in range(cols)] for _ in range(rows)]\n        self.revealed = [[False for _ in range(cols)] for _ in range(rows)]\n        self.flags = [[False for _ in range(cols)] for _ in range(rows)]\n        self.game_over = False\n        self.first_click = True\n\n    def print_board(self):\n        \"\"\"Prints the current state of the board.\"\"\"\n        print(\"   \" + \"  \".join(str(i) for i in range(self.cols)))\n        print(\"  \" + \"-\" * (self.cols * 3))\n        for i in range(self.rows):\n            row_str = str(i) + \"| \"\n            for j in range(self.cols):\n                if self.flags[i][j]:\n                    row_str += \"F \"\n                elif self.revealed[i][j]:\n                    row_str += str(self.board[i][j]) + \" \"\n                else:\n                    row_str += \". \"\n            print(row_str)\n\n    def place_mines(self, row, col):\n      \"\"\"Places mines randomly on the board, avoiding the initial click.\"\"\"\n      mines_placed = 0\n      while mines_placed < self.mines:\n          mine_row = random.randint(0, self.rows - 1)\n          mine_col = random.randint(0, self.cols - 1)\n          if self.board[mine_row][mine_col] != '*' and (mine_row, mine_col) != (row, col):\n              self.board[mine_row][mine_col] = '*'\n              mines_placed += 1\n\n    def calculate_neighbor_counts(self):\n        \"\"\"Calculates the number of neighboring mines for each cell.\"\"\"\n        for i in range(self.rows):\n            for j in range(self.cols):\n                if self.board[i][j] != '*':\n                    count = 0\n                    for x in range(max(0, i - 1), min(self.rows, i + 2)):\n                        for y in range(max(0, j - 1), min(self.cols, j + 2)):\n                            if self.board[x][y] == '*':\n                                count += 1\n                    self.board[i][j] = count if count > 0 else ' '\n\n    def reveal(self, row, col):\n        \"\"\"Reveals a cell and recursively reveals neighbors if the cell is empty.\"\"\"\n        if row < 0 or row >= self.rows or col < 0 or col >= self.cols or self.revealed[row][col] or self.flags[row][col]:\n            return\n\n        self.revealed[row][col] = True\n\n        if self.board[row][col] == '*':\n            self.game_over = True\n            return\n\n        if self.board[row][col] == ' ':\n            for x in range(max(0, row - 1), min(self.rows, row + 2)):\n                for y in range(max(0, col - 1), min(self.cols, col + 2)):\n                    self.reveal(x, y)\n\n    def flag(self,",
    "5": "```python\nimport random\n\nclass Mastermind:\n    def __init__(self, code_length=4, colors=('R', 'G', 'B', 'Y', 'O', 'P'), max_guesses=10):\n        \"\"\"\n        Initializes the Mastermind game.\n\n        Args:\n            code_length (int): The length of the secret code.\n            colors (tuple): The available colors for the code.\n            max_guesses (int): The maximum number of guesses allowed.\n        \"\"\"\n        self.code_length = code_length\n        self.colors = colors\n        self.max_guesses = max_guesses\n        self.secret_code = self._generate_secret_code()\n        self.guesses = []\n        self.feedback = []\n        self.game_over = False\n        self.won = False\n\n    def _generate_secret_code(self):\n        \"\"\"Generates a random secret code.\"\"\"\n        return [random.choice(self.colors) for _ in range(self.code_length)]\n\n    def guess(self, attempt):\n        \"\"\"\n        Processes a player's guess.\n\n        Args:\n            attempt (str): The player's guess as a string of colors.\n\n        Returns:\n            tuple: A tuple containing the feedback (black and white pegs) and a boolean indicating if the guess was valid.\n            Returns None if the game is already over.\n        \"\"\"\n\n        if self.game_over:\n            return None\n\n        if not self._is_valid_guess(attempt):\n            return None, False  # Invalid guess\n\n        attempt_list = list(attempt.upper())  # Convert to uppercase list for consistency\n        self.guesses.append(attempt_list)\n\n        black_pegs = 0\n        white_pegs = 0\n        temp_secret_code = self.secret_code[:]  # Create a copy to avoid modifying the original\n        temp_attempt = attempt_list[:]  # Create a copy to avoid modifying the original\n\n        # First, count black pegs (correct color and position)\n        for i in range(self.code_length):\n            if temp_attempt[i] == temp_secret_code[i]:\n                black_pegs += 1\n                temp_attempt[i] = None  # Mark as matched\n                temp_secret_code[i] = None # Mark as matched\n\n\n        # Then, count white pegs (correct color, wrong position)\n        for i in range(self.code_length):\n            if temp_attempt[i] is not None:\n                if temp_attempt[i] in temp_secret_code:\n                    white_pegs += 1\n                    # Remove the first occurrence of the color from the secret code copy\n                    temp_secret_code[temp_secret_code.index(temp_attempt[i])] = None\n\n\n        feedback = (black_pegs, white_pegs)\n        self.feedback.append(feedback)\n\n        if black_pegs == self.code_length:\n            self.game_over = True\n            self.won = True\n        elif len(self.guesses) >= self.max_guesses:\n            self.game_over = True\n            self.won = False\n\n        return feedback, True\n\n    def _is_valid_guess(self, attempt):\n        \"\"\"\n        Checks if a guess is valid.\n\n        Args:\n            attempt (str): The player's guess.\n\n        Returns:\n            bool: True if the guess is valid, False otherwise.\n        \"\"\"\n        if not isinstance(",
    "6": "```python\nimport random\n\nclass Battleship:\n    def __init__(self, size=10, num_ships=5):\n        self.size = size\n        self.num_ships = num_ships\n        self.player_board = self.create_board()\n        self.computer_board = self.create_board()\n        self.player_ships = self.place_ships(self.player_board)\n        self.computer_ships = self.place_ships(self.computer_board)\n        self.player_guesses = set()\n        self.computer_guesses = set()\n\n    def create_board(self):\n        \"\"\"Creates an empty game board.\"\"\"\n        return [[' ' for _ in range(self.size)] for _ in range(self.size)]\n\n    def place_ships(self, board):\n        \"\"\"Randomly places ships on the board.\"\"\"\n        ships = []\n        for _ in range(self.num_ships):\n            while True:\n                x = random.randint(0, self.size - 1)\n                y = random.randint(0, self.size - 1)\n                orientation = random.choice(['horizontal', 'vertical'])\n                ship_length = random.randint(2, min(4, self.size // 2)) # Ship length between 2 and 4, capped\n\n                if self.is_valid_placement(board, x, y, orientation, ship_length):\n                    ship_coordinates = []\n                    if orientation == 'horizontal':\n                        for i in range(ship_length):\n                            board[x][y+i] = 'S'\n                            ship_coordinates.append((x, y+i))\n                    else:  # vertical\n                        for i in range(ship_length):\n                            board[x+i][y] = 'S'\n                            ship_coordinates.append((x+i, y))\n                    ships.append(ship_coordinates)\n                    break  # Ship placed successfully, move to the next ship\n        return ships\n\n    def is_valid_placement(self, board, x, y, orientation, length):\n        \"\"\"Checks if a ship placement is valid (doesn't overlap or go out of bounds).\"\"\"\n        if orientation == 'horizontal':\n            if y + length > self.size:\n                return False\n            for i in range(length):\n                if board[x][y + i] == 'S':\n                    return False\n        else:  # vertical\n            if x + length > self.size:\n                return False\n            for i in range(length):\n                if board[x + i][y] == 'S':\n                    return False\n        return True\n\n    def print_board(self, board, hide_ships=True):\n        \"\"\"Prints the board to the console.\"\"\"\n        print(\"  \" + \" \".join([chr(65 + i) for i in range(self.size)]))  # A B C ...\n        for i in range(self.size):\n            row_str = str(i + 1).rjust(2) + \" \"  # 1  2  3 ...\n            for j in range(self.size):\n                if hide_ships and board[i][j] == 'S':\n                    row_str += ' ' + \" \"  # Hide ships by displaying empty spaces\n                else:\n                    row_str += board[i][j] + \" \"\n            print(row_str)\n\n    def get_player_guess(self):\n        \"\"\"Gets the player's guess from the console.\"\"\"",
    "7": "```python\nimport argparse\nimport time\nimport random\nimport os\n\nclass GameOfLife:\n    \"\"\"\n    Implementation of Conway's Game of Life.\n    \"\"\"\n\n    def __init__(self, width, height, initial_state=None, random_fill_prob=0.5):\n        \"\"\"\n        Initializes the Game of Life grid.\n\n        Args:\n            width (int): Width of the grid.\n            height (int): Height of the grid.\n            initial_state (list[list[int]], optional): Initial state of the grid. \n                                                        Defaults to None (random initialization).\n            random_fill_prob (float, optional): Probability of a cell being alive during random initialization.\n                                                Defaults to 0.5.\n        \"\"\"\n        self.width = width\n        self.height = height\n        if initial_state:\n            self.grid = initial_state\n        else:\n            self.grid = self.random_grid(random_fill_prob)\n\n    def random_grid(self, fill_prob):\n        \"\"\"\n        Generates a random grid with cells alive based on the fill probability.\n\n        Args:\n            fill_prob (float): Probability of a cell being alive.\n\n        Returns:\n            list[list[int]]: A randomly initialized grid.\n        \"\"\"\n        return [[1 if random.random() < fill_prob else 0 for _ in range(self.width)] for _ in range(self.height)]\n\n    def get_neighbors(self, x, y):\n        \"\"\"\n        Gets the neighboring cells (including diagonals) of a given cell.\n\n        Args:\n            x (int): X-coordinate of the cell.\n            y (int): Y-coordinate of the cell.\n\n        Returns:\n            list[int]: A list of the states (0 or 1) of the neighboring cells.\n        \"\"\"\n        neighbors = []\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                if i == 0 and j == 0:\n                    continue\n                nx = x + i\n                ny = y + j\n                if 0 <= nx < self.height and 0 <= ny < self.width:\n                    neighbors.append(self.grid[nx][ny])\n        return neighbors\n\n    def next_generation(self):\n        \"\"\"\n        Calculates the next generation of the Game of Life.\n        \"\"\"\n        new_grid = [[0 for _ in range(self.width)] for _ in range(self.height)]\n        for x in range(self.height):\n            for y in range(self.width):\n                neighbors = self.get_neighbors(x, y)\n                alive_neighbors = sum(neighbors)\n                if self.grid[x][y] == 1:  # Alive cell\n                    if alive_neighbors < 2 or alive_neighbors > 3:\n                        new_grid[x][y] = 0  # Dies\n                    else:\n                        new_grid[x][y] = 1  # Stays alive\n                else:  # Dead cell\n                    if alive_neighbors == 3:\n                        new_grid[x][y] = 1  # Becomes alive\n                    else:\n                        new_grid[x][y] = 0  # Stays dead\n        self.grid = new_grid\n\n    def print_grid(self):\n        \"\"\"\n        Prints the current state of the grid to the console.\n        \"\"\"\n        os.system('cls' if os.name == 'nt",
    "8": "```python\ndef create_board(rows=6, cols=7):\n    \"\"\"Creates an empty Connect Four board.\"\"\"\n    return [[' ' for _ in range(cols)] for _ in range(rows)]\n\ndef print_board(board):\n    \"\"\"Prints the Connect Four board to the console.\"\"\"\n    for row in reversed(board):  # Print rows in reverse order for visual clarity\n        print('|' + '|'.join(row) + '|')\n    print('+' + '+'.join(str(i) for i in range(len(board[0]))) + '+')  # Column numbers\n\ndef drop_piece(board, col, piece):\n    \"\"\"Drops a piece into the specified column.\"\"\"\n    for row in range(len(board)):\n        if board[row][col] == ' ':\n            board[row][col] = piece\n            return True  # Successfully dropped the piece\n    return False  # Column is full\n\ndef is_valid_location(board, col):\n    \"\"\"Checks if the specified column is a valid location to drop a piece.\"\"\"\n    return 0 <= col < len(board[0]) and board[len(board) - 1][col] == ' '\n\ndef winning_move(board, piece):\n    \"\"\"Checks if the last move resulted in a win for the given piece.\"\"\"\n    rows = len(board)\n    cols = len(board[0])\n\n    # Check horizontal\n    for row in range(rows):\n        for col in range(cols - 3):\n            if (board[row][col] == piece and\n                board[row][col+1] == piece and\n                board[row][col+2] == piece and\n                board[row][col+3] == piece):\n                return True\n\n    # Check vertical\n    for row in range(rows - 3):\n        for col in range(cols):\n            if (board[row][col] == piece and\n                board[row+1][col] == piece and\n                board[row+2][col] == piece and\n                board[row+3][col] == piece):\n                return True\n\n    # Check positively sloped diagonals\n    for row in range(rows - 3):\n        for col in range(cols - 3):\n            if (board[row][col] == piece and\n                board[row+1][col+1] == piece and\n                board[row+2][col+2] == piece and\n                board[row+3][col+3] == piece):\n                return True\n\n    # Check negatively sloped diagonals\n    for row in range(3, rows):\n        for col in range(cols - 3):\n            if (board[row][col] == piece and\n                board[row-1][col+1] == piece and\n                board[row-2][col+2] == piece and\n                board[row-3][col+3] == piece):\n                return True\n\n    return False\n\ndef is_board_full(board):\n    \"\"\"Checks if the board is full.\"\"\"\n    for col in range(len(board[0])):\n        if board[len(board) - 1][col] == ' ':\n            return False\n    return True\n\ndef get_player_move(board, player_number):\n    \"\"\"Gets the player's move from the console.\"\"\"\n    while True:\n        try:\n            col = int(input(f\"Player {player_number}, enter column (0-{len(board[0])-1}): \"))\n            if is_valid_location(board,",
    "9": "```python\nimport random\n\ndef calculate_hand_value(hand):\n    \"\"\"Calculates the value of a hand in Blackjack.\n\n    Args:\n        hand: A list of strings representing the cards in the hand (e.g., ['A', '10', 'K']).\n\n    Returns:\n        The total value of the hand.  Aces can be 1 or 11.\n    \"\"\"\n    ace_count = hand.count('A')\n    total = 0\n    for card in hand:\n        if card in ('K', 'Q', 'J'):\n            total += 10\n        elif card == 'A':\n            total += 11  # Initially treat Ace as 11\n        else:\n            try:\n                total += int(card)\n            except ValueError:\n                return 0 # Handle invalid card\n    while total > 21 and ace_count > 0:\n        total -= 10\n        ace_count -= 1\n    return total\n\n\ndef deal_card(deck):\n    \"\"\"Deals a card from the deck.\n\n    Args:\n        deck: A list of strings representing the deck of cards.\n\n    Returns:\n        A tuple containing the dealt card and the updated deck.  Returns (None, deck) if the deck is empty.\n    \"\"\"\n    if not deck:\n        return None, deck  # Handle empty deck\n    card = deck.pop()\n    return card, deck\n\n\ndef create_deck():\n    \"\"\"Creates a standard 52-card deck.\n\n    Returns:\n        A list of strings representing the deck of cards.\n    \"\"\"\n    suits = ['Hearts', 'Diamonds', 'Clubs', 'Spades']  # Not used, but could be for more features\n    ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']\n    deck = [rank for rank in ranks for suit in suits] # No suit needed\n    random.shuffle(deck)\n    return deck\n\n\ndef display_hand(hand, is_dealer=False, hide_first_card=False):\n    \"\"\"Displays a hand of cards.\n\n    Args:\n        hand: A list of strings representing the hand.\n        is_dealer: True if the hand is the dealer's hand, False otherwise.\n        hide_first_card: True if the dealer's first card should be hidden (only for the initial deal).\n    \"\"\"\n    if is_dealer and hide_first_card:\n        print(\"[Hidden Card]\", end=\" \")\n        for card in hand[1:]:\n            print(card, end=\" \")\n    else:\n        for card in hand:\n            print(card, end=\" \")\n    print()\n\n\ndef play_blackjack():\n    \"\"\"Plays a game of Blackjack.\"\"\"\n\n    deck = create_deck()\n    player_hand = []\n    dealer_hand = []\n\n    # Initial deal\n    for _ in range(2):\n        card, deck = deal_card(deck)\n        player_hand.append(card)\n        card, deck = deal_card(deck)\n        dealer_hand.append(card)\n\n    print(\"Your hand:\", end=\" \")\n    display_hand(player_hand)\n    print(\"Dealer's hand:\", end=\" \")\n    display_hand(dealer_hand, is_dealer=True, hide_first_card=True)\n\n    # Player's turn\n    while True:\n        player_value = calculate_hand",
    "10": "```python\nimport random\n\ndef print_intro():\n    print(\"\"\"\nCongratulations, you are the newest ruler of ancient Sumer,\nelected for a ten year term of office.  Your duties are to\ndispense food, direct farming, and buy and sell land as needed\nto support your people.  Watch out for rat infestations and\nplagues!  Grain is the general currency, measure, and store of wealth.\n\nGood luck, Hammurabi!\n\"\"\")\n\ndef summarize_year(year, deaths, population, acres_owned, crop_yield, grain_eaten, grain_in_storage, price_of_land):\n    print(f\"\"\"\nYear {year} summary:\n\n{deaths} people starved to death.\n{population} people are now in your kingdom.\nYou own {acres_owned} acres of land.\nYou harvested {crop_yield} bushels per acre.\nRats ate {grain_eaten} bushels.\nYou now have {grain_in_storage} bushels of grain in storage.\nLand is trading at {price_of_land} bushels per acre.\n\"\"\")\n\ndef get_user_input(population, grain_in_storage, acres_owned):\n    while True:\n        try:\n            acres_to_buy = int(input(\"How many acres do you wish to buy? \"))\n            if acres_to_buy < 0:\n                print(\"Please enter a non-negative number of acres.\")\n                continue\n            price_of_land = random.randint(17, 27)\n            if acres_to_buy * price_of_land > grain_in_storage:\n                print(\"O great Hammurabi, you do not have enough grain to buy that much land.\")\n                continue\n            break\n        except ValueError:\n            print(\"Please enter a valid integer number of acres.\")\n\n    while True:\n        try:\n            acres_to_sell = int(input(\"How many acres do you wish to sell? \"))\n            if acres_to_sell < 0:\n                print(\"Please enter a non-negative number of acres.\")\n                continue\n            if acres_to_sell > acres_owned:\n                print(\"O great Hammurabi, you do not have enough land to sell.\")\n                continue\n            break\n        except ValueError:\n            print(\"Please enter a valid integer number of acres.\")\n\n    while True:\n        try:\n            grain_to_feed = int(input(\"How many bushels do you wish to feed your people? \"))\n            if grain_to_feed < 0:\n                print(\"Please enter a non-negative number of bushels.\")\n                continue\n            if grain_to_feed > grain_in_storage:\n                print(\"O great Hammurabi, you do not have that much grain to feed your people.\")\n                continue\n            break\n        except ValueError:\n            print(\"Please enter a valid integer number of bushels.\")\n\n    while True:\n        try:\n            acres_to_plant = int(input(\"How many acres do you wish to plant with seed? \"))\n            if acres_to_plant < 0:\n                print(\"Please enter a non-negative number of acres.\")\n                continue\n            if acres_to_plant > acres_owned:\n                print(\"O great Hammurabi, you do not have that much land to plant.\")\n                continue\n            if acres_to_plant > grain_in_storage:\n                print(\"O great Hammurabi, you do not have that much grain to plant.\")\n                continue\n            if acres_to_plant > population * 10:\n                print(\"O",
    "11": "```python\nimport random\n\nclass LightsOut:\n    def __init__(self, size=5, initial_state=None):\n        \"\"\"\n        Initializes the Lights Out game.\n\n        Args:\n            size (int): The size of the board (size x size). Defaults to 5.\n            initial_state (list): A list of lists representing the initial state of the board.\n                                   If None, a random initial state is generated.\n        \"\"\"\n        self.size = size\n        if initial_state is None:\n            self.board = self.generate_random_board()\n        else:\n            self.board = initial_state\n        self.moves = 0\n\n    def generate_random_board(self):\n        \"\"\"\n        Generates a random initial state for the board.\n        \"\"\"\n        board = [[random.randint(0, 1) for _ in range(self.size)] for _ in range(self.size)]\n        return board\n\n    def print_board(self):\n        \"\"\"\n        Prints the current state of the board to the console.\n        \"\"\"\n        print(\"-\" * (self.size * 2 + 1))\n        for row in self.board:\n            print(\"|\" + \"\".join([\"*\" if cell else \" \" for cell in row]) + \"|\")\n        print(\"-\" * (self.size * 2 + 1))\n        print(f\"Moves: {self.moves}\")\n\n    def toggle_cell(self, row, col):\n        \"\"\"\n        Toggles the state of a cell (0 becomes 1, and 1 becomes 0).\n        \"\"\"\n        if 0 <= row < self.size and 0 <= col < self.size:\n            self.board[row][col] = 1 - self.board[row][col]\n\n    def make_move(self, row, col):\n        \"\"\"\n        Makes a move by toggling the selected cell and its adjacent cells.\n\n        Args:\n            row (int): The row of the selected cell.\n            col (int): The column of the selected cell.\n        \"\"\"\n        self.toggle_cell(row, col)\n        self.toggle_cell(row - 1, col)\n        self.toggle_cell(row + 1, col)\n        self.toggle_cell(row, col - 1)\n        self.toggle_cell(row, col + 1)\n        self.moves += 1\n\n    def is_solved(self):\n        \"\"\"\n        Checks if the game is solved (all cells are 0).\n        \"\"\"\n        return all(all(cell == 0 for cell in row) for row in self.board)\n\n    def play(self):\n        \"\"\"\n        Starts the game loop, handling user input and updating the board.\n        \"\"\"\n        print(\"Welcome to Lights Out!\")\n        self.print_board()\n\n        while not self.is_solved():\n            try:\n                move = input(\"Enter row and column (e.g., 1,2) or 'q' to quit: \")\n                if move.lower() == 'q':\n                    print(\"Quitting the game.\")\n                    return\n\n                row, col = map(int, move.split(','))\n                if not (1 <= row <= self.size and 1 <= col <= self.size):\n                    print(f\"Invalid input. Row and column must be between 1 and {self.size}.\")\n                    continue\n\n                self.make_move(row - 1, col - 1)  # Adjust for",
    "12": "```python\nimport time\nimport random\nimport os\n\nclass Pong:\n    \"\"\"\n    A simple command-line Pong game.\n    \"\"\"\n\n    def __init__(self, width=60, height=20, paddle_length=3):\n        \"\"\"\n        Initializes the Pong game.\n\n        Args:\n            width (int): The width of the game board.\n            height (int): The height of the game board.\n            paddle_length (int): The length of the paddles.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.paddle_length = paddle_length\n        self.paddle1_pos = height // 2 - paddle_length // 2\n        self.paddle2_pos = height // 2 - paddle_length // 2\n        self.ball_x = width // 2\n        self.ball_y = height // 2\n        self.ball_dx = random.choice([-1, 1])  # Ball direction x\n        self.ball_dy = random.choice([-1, 1])  # Ball direction y\n        self.score1 = 0\n        self.score2 = 0\n        self.running = True\n        self.delay = 0.05  # Delay between frames (adjust for speed)\n\n    def _clear_screen(self):\n        \"\"\"Clears the console screen.\"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')\n\n    def _draw_board(self):\n        \"\"\"Draws the game board.\"\"\"\n        board = []\n        for i in range(self.height):\n            row = [' '] * self.width\n            board.append(row)\n\n        # Draw paddles\n        for i in range(self.paddle_length):\n            board[self.paddle1_pos + i][1] = '#'  # Player 1 paddle\n            board[self.paddle2_pos + i][self.width - 2] = '#'  # Player 2 paddle\n\n        # Draw ball\n        board[self.ball_y][self.ball_x] = 'O'\n\n        # Draw top and bottom borders\n        top_bottom = ['-'] * self.width\n        board.insert(0, top_bottom)\n        board.append(top_bottom)\n\n        # Print the board\n        self._clear_screen()\n        print(f\"Player 1: {self.score1}  |  Player 2: {self.score2}\")\n        for row in board:\n            print(''.join(row))\n\n    def _move_ball(self):\n        \"\"\"Moves the ball and handles collisions.\"\"\"\n        self.ball_x += self.ball_dx\n        self.ball_y += self.ball_dy\n\n        # Bounce off top and bottom\n        if self.ball_y <= 0 or self.ball_y >= self.height - 1:\n            self.ball_dy *= -1\n\n        # Bounce off paddles\n        if self.ball_x <= 2 and self.paddle1_pos <= self.ball_y <= self.paddle1_pos + self.paddle_length - 1:\n            self.ball_dx *= -1\n            # Add a little randomness to the ball's vertical direction\n            self.ball_dy += random.choice([-1, 0, 1])\n            self.ball_dy = max(-1, min(1, self.ball_dy)) # Clamp dy to -1, 0, 1\n\n        if self.ball",
    "13": "```python\nimport random\nimport time\nimport os\n\nclass Tetris:\n    \"\"\"\n    A command-line Tetris game.\n    \"\"\"\n\n    def __init__(self, width=10, height=20):\n        \"\"\"\n        Initializes the Tetris game.\n\n        Args:\n            width (int): The width of the game board.\n            height (int): The height of the game board.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.board = [[' ' for _ in range(width)] for _ in range(height)]\n        self.current_piece = None\n        self.next_piece = self.get_new_piece()\n        self.piece_x = 0\n        self.piece_y = 0\n        self.game_over = False\n        self.score = 0\n        self.level = 1\n        self.lines_cleared = 0\n        self.delay = 0.5  # Initial delay in seconds\n\n        self.shapes = [\n            [[1, 1, 1, 1]],  # I\n            [[1, 1], [1, 1]],  # O\n            [[0, 1, 1], [1, 1, 0]],  # Z\n            [[1, 1, 0], [0, 1, 1]],  # S\n            [[1, 0, 0], [1, 1, 1]],  # L\n            [[0, 0, 1], [1, 1, 1]],  # J\n            [[0, 1, 0], [1, 1, 1]]   # T\n        ]\n        self.colors = ['cyan', 'yellow', 'red', 'green', 'orange', 'blue', 'purple']  # Corresponding colors for each shape\n        self.piece_color = None\n\n    def get_new_piece(self):\n        \"\"\"\n        Generates a new random piece.\n\n        Returns:\n            list: A 2D list representing the shape of the piece.\n        \"\"\"\n        shape_index = random.randint(0, len(self.shapes) - 1)\n        self.piece_color = self.colors[shape_index]\n        return self.shapes[shape_index]\n\n    def spawn_piece(self):\n        \"\"\"\n        Spawns a new piece at the top of the board.\n        \"\"\"\n        self.current_piece = self.next_piece\n        self.next_piece = self.get_new_piece()\n        self.piece_x = self.width // 2 - len(self.current_piece[0]) // 2\n        self.piece_y = 0\n        if not self.is_valid_position(self.current_piece, self.piece_x, self.piece_y):\n            self.game_over = True\n\n    def rotate_piece(self):\n        \"\"\"\n        Rotates the current piece clockwise.\n        \"\"\"\n        rotated_piece = list(zip(*self.current_piece[::-1]))\n        if self.is_valid_position(rotated_piece, self.piece_x, self.piece_y):\n            self.current_piece = rotated_piece\n\n    def is_valid_position(self, piece, x, y):\n        \"\"\"\n        Checks if a piece can be placed at a given position without collision.\n\n        Args:\n            piece (list): A 2D list representing the shape of the piece.\n",
    "14": "```python\nimport random\nimport math\nimport time\nimport sys\nimport os\n\nclass GameObject:\n    def __init__(self, x, y, radius, dx=0, dy=0, color='white'):\n        self.x = x\n        self.y = y\n        self.radius = radius\n        self.dx = dx\n        self.dy = dy\n        self.color = color\n\n    def move(self, width, height):\n        self.x += self.dx\n        self.y += self.dy\n\n        # Wrap around the screen\n        if self.x < 0:\n            self.x = width\n        elif self.x > width:\n            self.x = 0\n        if self.y < 0:\n            self.y = height\n        elif self.y > height:\n            self.y = 0\n\n    def draw(self):\n        # Placeholder, overridden in subclasses for actual drawing\n        pass\n\n    def collides_with(self, other):\n        distance = math.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)\n        return distance < (self.radius + other.radius)\n\n\nclass Asteroid(GameObject):\n    def __init__(self, x, y, radius, dx, dy):\n        super().__init__(x, y, radius, dx, dy, color='yellow')\n\n    def draw(self):\n        return f\"A({int(self.x)},{int(self.y)},{self.radius})\"  # Asteroid representation\n\n\nclass Ship(GameObject):\n    def __init__(self, x, y):\n        super().__init__(x, y, radius=10, color='green')\n        self.rotation = 0 # in degrees\n        self.thrust = 0\n\n    def rotate(self, angle):\n        self.rotation += angle\n\n    def apply_thrust(self, thrust):\n       self.thrust = thrust  # -1 for backwards, 1 for forward\n\n    def move(self, width, height):\n        # Calculate acceleration based on thrust and rotation\n        angle_radians = math.radians(self.rotation)\n        acceleration_x = self.thrust * math.cos(angle_radians) * 0.1\n        acceleration_y = self.thrust * math.sin(angle_radians) * 0.1\n\n        # Apply acceleration to velocity\n        self.dx += acceleration_x\n        self.dy += acceleration_y\n\n        # Limit speed\n        max_speed = 5\n        speed = math.sqrt(self.dx**2 + self.dy**2)\n        if speed > max_speed:\n            self.dx = (self.dx / speed) * max_speed\n            self.dy = (self.dy / speed) * max_speed\n\n        super().move(width, height)  # Call parent's move method for wrapping\n\n\n    def draw(self):\n        return f\"S({int(self.x)},{int(self.y)},{self.rotation:.1f})\"  # Ship representation\n\n\nclass Bullet(GameObject):\n    def __init__(self, x, y, angle):\n        super().__init__(x, y, radius=3, color='red')\n        angle_radians = math.radians(angle)\n        self.dx = math.cos(angle_radians) * 10\n        self.dy = math.sin(angle_radians) * 10\n        self.lifespan = 60 # Frames before bullet disappears\n\n    def move(",
    "15": "```python\nimport random\nimport time\n\nclass Boggle:\n    def __init__(self, size=4, time_limit=180):\n        self.size = size\n        self.time_limit = time_limit\n        self.board = self.generate_board()\n        self.words = set()\n        self.score = 0\n        self.start_time = None\n        self.end_time = None\n        self.dictionary = self.load_dictionary(\"dictionary.txt\")  # Replace with your dictionary file\n\n    def generate_board(self):\n        dice = [\n            \"RIFOBX\", \"IFEHIE\", \"TETWOO\", \"ASSPFF\",\n            \"LRYTTU\", \"TOOTEM\", \"ASCIIN\", \"AFPKFS\",\n            \"XLDERI\", \"HCPSOA\", \"NIDEZR\", \"ENSUII\",\n            \"MNOTYU\", \"QBZJAA\", \"DLREAI\", \"NOTDHW\"\n        ]\n        random.shuffle(dice)\n        board = []\n        for i in range(self.size):\n            row = []\n            for j in range(self.size):\n                row.append(random.choice(dice[i * self.size + j]))\n            board.append(row)\n        return board\n\n    def load_dictionary(self, filename):\n        try:\n            with open(filename, \"r\") as f:\n                return set(word.strip().upper() for word in f)\n        except FileNotFoundError:\n            print(f\"Error: Dictionary file '{filename}' not found.  Please create and populate 'dictionary.txt' with one word per line.\")\n            exit()\n\n    def display_board(self):\n        print(\"Boggle Board:\")\n        for row in self.board:\n            print(\" \".join(row))\n\n    def is_valid_word(self, word):\n        return (\n            3 <= len(word) <= 8 and\n            word.upper() in self.dictionary and\n            word.upper() not in self.words\n        )\n\n    def find_word_on_board(self, word):\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.board[i][j].upper() == word[0].upper():\n                    if self._search_word(word.upper(), i, j, [(i, j)]):\n                        return True\n        return False\n\n    def _search_word(self, word, row, col, path):\n        if not word:\n            return True\n\n        for i in range(max(0, row - 1), min(self.size, row + 2)):\n            for j in range(max(0, col - 1), min(self.size, col + 2)):\n                if (i, j) not in path and self.board[i][j].upper() == word[0].upper():\n                    if self._search_word(word[1:], i, j, path + [(i, j)]):\n                        return True\n        return False\n\n    def calculate_score(self, word):\n        length = len(word)\n        if length == 3 or length == 4:\n            return 1\n        elif length == 5:\n            return 2\n        elif length == 6:\n            return 3\n        elif length == 7:\n            return 5\n        elif length == 8:\n            return 11\n        ",
    "16": "```python\nimport random\nimport time\nimport sys\nimport os\n\nclass PacMan:\n    def __init__(self, width=20, height=10):\n        self.width = width\n        self.height = height\n        self.grid = [[' ' for _ in range(width)] for _ in range(height)]\n        self.pacman_x = width // 2\n        self.pacman_y = height // 2\n        self.ghost_x = random.randint(0, width - 1)\n        self.ghost_y = random.randint(0, height - 1)\n        while (self.ghost_x, self.ghost_y) == (self.pacman_x, self.pacman_y):\n            self.ghost_x = random.randint(0, width - 1)\n            self.ghost_y = random.randint(0, height - 1)\n\n        self.food = set()\n        for y in range(height):\n            for x in range(width):\n                if (x, y) != (self.pacman_x, self.pacman_y) and (x, y) != (self.ghost_x, self.ghost_y):\n                    self.food.add((x, y))\n\n        self.score = 0\n        self.game_over = False\n        self.won = False\n        self.lives = 3  # Add lives\n\n        self.update_grid()\n\n    def update_grid(self):\n        # Clear the grid\n        self.grid = [[' ' for _ in range(self.width)] for _ in range(self.height)]\n\n        # Add walls (optional - for a more structured game)\n        # Example: add a border\n        for x in range(self.width):\n            self.grid[0][x] = '#'\n            self.grid[self.height - 1][x] = '#'\n        for y in range(self.height):\n            self.grid[y][0] = '#'\n            self.grid[y][self.width - 1] = '#'\n\n\n        # Add food\n        for x, y in self.food:\n            self.grid[y][x] = '.'\n\n        # Add Pac-Man\n        self.grid[self.pacman_y][self.pacman_x] = 'P'\n\n        # Add Ghost\n        self.grid[self.ghost_y][self.ghost_x] = 'G'\n\n    def print_grid(self):\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear screen\n        print(\"-\" * (self.width + 2))\n        for row in self.grid:\n            print(\"|\" + \"\".join(row) + \"|\")\n        print(\"-\" * (self.width + 2))\n        print(f\"Score: {self.score}, Lives: {self.lives}\")\n\n\n    def move_pacman(self, direction):\n        new_x, new_y = self.pacman_x, self.pacman_y\n\n        if direction == 'w':  # Up\n            new_y -= 1\n        elif direction == 's':  # Down\n            new_y += 1\n        elif direction == 'a':  # Left\n            new_x -= 1\n        elif direction == 'd':  # Right\n            new_x += 1\n        else:\n            return  # Invalid input\n\n        # Boundary check\n        if 0 <= new_x",
    "17": "```python\nimport time\nimport random\nimport os\n\nclass DinosaurRunner:\n    \"\"\"\n    A command-line implementation of the Dinosaur Runner game.\n    \"\"\"\n\n    def __init__(self, width=80, height=15, initial_speed=1.0, speed_increase=0.1, jump_height=5):\n        \"\"\"\n        Initializes the game.\n\n        Args:\n            width (int): The width of the game screen.\n            height (int): The height of the game screen.\n            initial_speed (float): The initial speed of the game.\n            speed_increase (float): The amount to increase the speed by each tick.\n            jump_height (int): The height of the dinosaur's jump.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.dino_x = 5\n        self.dino_y = height - 2  # Dino starts on the ground\n        self.dino_height = 2\n        self.is_jumping = False\n        self.jump_velocity = 0\n        self.initial_jump_velocity = jump_height * 2 #Adjusted initial jump velocity\n        self.gravity = 1 #Simplified gravity\n        self.obstacles = []\n        self.score = 0\n        self.game_over = False\n        self.speed = initial_speed\n        self.speed_increase = speed_increase\n        self.last_obstacle_time = time.time()\n        self.obstacle_spawn_interval = 2  # Seconds between obstacle spawns\n        self.obstacle_width = 3\n        self.debug = False #Set to true to enable debug messages\n\n    def clear_screen(self):\n        \"\"\"Clears the console screen.\"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')\n\n    def create_screen(self):\n        \"\"\"Creates the game screen as a list of strings.\"\"\"\n        screen = [[' ' for _ in range(self.width)] for _ in range(self.height)]\n\n        # Draw ground\n        for i in range(self.width):\n            screen[self.height - 1][i] = '_'\n\n        # Draw dinosaur\n        for i in range(self.dino_height):\n            y = self.dino_y - i\n            if 0 <= y < self.height:\n                if i == 0:\n                    screen[y][self.dino_x] = 'D' #Head\n                    screen[y][self.dino_x+1] = '>' #Head\n                else:\n                    screen[y][self.dino_x] = '|' #Body\n                    screen[y][self.dino_x+1] = '|' #Body\n                    screen[y][self.dino_x+2] = '^' #Leg\n\n        # Draw obstacles\n        for obstacle in self.obstacles:\n            for i in range(self.obstacle_width):\n                if 0 <= obstacle['x'] + i < self.width:\n                    screen[self.height - 2][obstacle['x'] + i] = '#'\n                    screen[self.height - 1][obstacle['x'] + i] = '#'\n\n        return screen\n\n    def print_screen(self, screen):\n        \"\"\"Prints the game screen to the console.\"\"\"\n        for row in screen:\n            print(''.join(row))\n        print(f\"Score: {self.score}\")\n        print(f\"Speed: {self.speed:.2f}\")\n\n"
}