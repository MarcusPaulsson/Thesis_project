{
    "0": "```python\ndef print_board(board):\n    \"\"\"Prints the Tic-Tac-Toe board.\"\"\"\n    print(\"-------------\")\n    for i in range(3):\n        print(\"|\", board[i * 3], \"|\", board[i * 3 + 1], \"|\", board[i * 3 + 2], \"|\")\n        print(\"-------------\")\n\n\ndef check_win(board, player):\n    \"\"\"Checks if the given player has won.\"\"\"\n    # Check rows\n    for i in range(3):\n        if board[i * 3] == board[i * 3 + 1] == board[i * 3 + 2] == player:\n            return True\n\n    # Check columns\n    for i in range(3):\n        if board[i] == board[i + 3] == board[i + 6] == player:\n            return True\n\n    # Check diagonals\n    if board[0] == board[4] == board[8] == player:\n        return True\n    if board[2] == board[4] == board[6] == player:\n        return True\n\n    return False\n\n\ndef check_tie(board):\n    \"\"\"Checks if the game is a tie.\"\"\"\n    return all(board[i] != \" \" for i in range(9))\n\n\ndef get_player_move(board, player):\n    \"\"\"Gets a valid move from the player.\"\"\"\n    while True:\n        try:\n            move = int(input(f\"Player {player}, enter your move (1-9): \")) - 1\n            if 0 <= move <= 8 and board[move] == \" \":\n                return move\n            else:\n                print(\"Invalid move. Try again.\")\n        except ValueError:\n            print(\"Invalid input. Enter a number between 1 and 9.\")\n\n\ndef play_tic_tac_toe():\n    \"\"\"Plays a game of Tic-Tac-Toe.\"\"\"\n    board = [\" \"] * 9\n    player = \"X\"\n    game_over = False\n\n    print(\"Welcome to Tic-Tac-Toe!\")\n    print_board(board)\n\n    while not game_over:\n        move = get_player_move(board, player)\n        board[move] = player\n        print_board(board)\n\n        if check_win(board, player):\n            print(f\"Player {player} wins!\")\n            game_over = True\n        elif check_tie(board):\n            print(\"It's a tie!\")\n            game_over = True\n        else:\n            player = \"O\" if player == \"X\" else \"X\"\n\n\nif __name__ == \"__main__\":\n    play_tic_tac_toe()\n```\n",
    "1": "```python\nimport random\n\ndef choose_word(word_list):\n    \"\"\"Chooses a random word from a list of words.\"\"\"\n    return random.choice(word_list).upper()\n\ndef display_word(word, guessed_letters):\n    \"\"\"Displays the word with correctly guessed letters and underscores for unguessed letters.\"\"\"\n    display = \"\"\n    for letter in word:\n        if letter in guessed_letters:\n            display += letter + \" \"\n        else:\n            display += \"_ \"\n    return display.strip()\n\ndef get_guess(guessed_letters):\n    \"\"\"Gets a valid letter guess from the user.\"\"\"\n    while True:\n        guess = input(\"Guess a letter: \").upper()\n        if not guess.isalpha():\n            print(\"Invalid input. Please enter a letter.\")\n        elif len(guess) != 1:\n            print(\"Please enter only one letter at a time.\")\n        elif guess in guessed_letters:\n            print(\"You already guessed that letter. Try again.\")\n        else:\n            return guess\n\ndef play_hangman(word_list):\n    \"\"\"Plays a game of Hangman.\"\"\"\n    word = choose_word(word_list)\n    guessed_letters = set()\n    incorrect_guesses = 0\n    max_guesses = 6  # You can adjust the number of allowed incorrect guesses.\n\n    print(\"Welcome to Hangman!\")\n    print(display_word(word, guessed_letters))\n    print(f\"You have {max_guesses} guesses.\")\n\n    while incorrect_guesses < max_guesses:\n        guess = get_guess(guessed_letters)\n        guessed_letters.add(guess)\n\n        if guess in word:\n            print(\"Correct guess!\")\n            display = display_word(word, guessed_letters)\n            print(display)\n\n            if \"_\" not in display:\n                print(\"Congratulations! You guessed the word:\", word)\n                return\n\n        else:\n            incorrect_guesses += 1\n            print(\"Incorrect guess.\")\n            print(f\"You have {max_guesses - incorrect_guesses} guesses remaining.\")\n            print(display_word(word, guessed_letters)) # Show progress even after incorrect guess\n\n        if incorrect_guesses == max_guesses:\n            print(\"You ran out of guesses. The word was:\", word)\n            return\n\ndef main():\n    \"\"\"Main function to start the game.\"\"\"\n    word_list = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\", \"fig\", \"grape\", \"honeydew\"] # Add more words!\n    play_hangman(word_list)\n\nif __name__ == \"__main__\":\n    main()\n```\n",
    "2": "```python\nimport random\n\ndef get_player_choice():\n    \"\"\"Gets the player's choice (rock, paper, or scissors).\"\"\"\n    while True:\n        choice = input(\"Choose rock, paper, or scissors: \").lower()\n        if choice in [\"rock\", \"paper\", \"scissors\"]:\n            return choice\n        else:\n            print(\"Invalid choice. Please choose rock, paper, or scissors.\")\n\ndef get_computer_choice():\n    \"\"\"Generates a random choice for the computer.\"\"\"\n    return random.choice([\"rock\", \"paper\", \"scissors\"])\n\ndef determine_winner(player_choice, computer_choice):\n    \"\"\"Determines the winner of the game.\"\"\"\n    print(f\"You chose: {player_choice}\")\n    print(f\"The computer chose: {computer_choice}\")\n\n    if player_choice == computer_choice:\n        return \"It's a tie!\"\n    elif (player_choice == \"rock\" and computer_choice == \"scissors\") or \\\n         (player_choice == \"paper\" and computer_choice == \"rock\") or \\\n         (player_choice == \"scissors\" and computer_choice == \"paper\"):\n        return \"You win!\"\n    else:\n        return \"You lose!\"\n\ndef play_game():\n    \"\"\"Plays a single round of Rock-Paper-Scissors.\"\"\"\n    player_choice = get_player_choice()\n    computer_choice = get_computer_choice()\n    result = determine_winner(player_choice, computer_choice)\n    print(result)\n\ndef main():\n    \"\"\"Main function to run the game.\"\"\"\n    while True:\n        play_game()\n        play_again = input(\"Play again? (yes/no): \").lower()\n        if play_again != \"yes\":\n            break\n    print(\"Thanks for playing!\")\n\nif __name__ == \"__main__\":\n    main()\n```",
    "3": "```python\nimport random\nimport time\nimport os\n\nclass SnakeGame:\n    def __init__(self, width=20, height=15, delay=0.1):\n        self.width = width\n        self.height = height\n        self.snake = [(width // 2, height // 2)]\n        self.food = self.create_food()\n        self.direction = \"right\"\n        self.game_over = False\n        self.score = 0\n        self.delay = delay\n\n    def create_food(self):\n        while True:\n            food = (random.randint(0, self.width - 1), random.randint(0, self.height - 1))\n            if food not in self.snake:\n                return food\n\n    def move(self):\n        head_x, head_y = self.snake[0]\n\n        if self.direction == \"right\":\n            new_head = (head_x + 1, head_y)\n        elif self.direction == \"left\":\n            new_head = (head_x - 1, head_y)\n        elif self.direction == \"up\":\n            new_head = (head_x, head_y - 1)\n        elif self.direction == \"down\":\n            new_head = (head_x, head_y + 1)\n\n        if (\n            new_head[0] < 0\n            or new_head[0] >= self.width\n            or new_head[1] < 0\n            or new_head[1] >= self.height\n            or new_head in self.snake\n        ):\n            self.game_over = True\n            return\n\n        self.snake.insert(0, new_head)\n\n        if new_head == self.food:\n            self.score += 1\n            self.food = self.create_food()\n        else:\n            self.snake.pop()\n\n    def change_direction(self, new_direction):\n        if new_direction == \"right\" and self.direction != \"left\":\n            self.direction = \"right\"\n        elif new_direction == \"left\" and self.direction != \"right\":\n            self.direction = \"left\"\n        elif new_direction == \"up\" and self.direction != \"down\":\n            self.direction = \"up\"\n        elif new_direction == \"down\" and self.direction != \"up\":\n            self.direction = \"down\"\n\n    def draw(self):\n        os.system(\"cls\" if os.name == \"nt\" else \"clear\")  # Clear the console\n\n        for y in range(self.height):\n            for x in range(self.width):\n                if (x, y) == self.food:\n                    print(\"F\", end=\"\")\n                elif (x, y) in self.snake:\n                    if (x,y) == self.snake[0]:\n                        print(\"H\", end=\"\")\n                    else:\n                        print(\"S\", end=\"\")\n                else:\n                    print(\" \", end=\"\")\n            print()\n\n        print(f\"Score: {self.score}\")\n        print(\"Use 'w', 'a', 's', 'd' to move. Press 'q' to quit.\")\n\n    def play(self):\n        while not self.game_over:\n            self.draw()\n            time.sleep(self.delay)\n\n            direction = input(\"Enter move (w/a/s/d/q): \").lower()\n            if direction == \"q\":\n                self.game_over = True\n                break\n            elif direction in (\"w\", \"a\", \"s\", \"d\"):\n                if direction == \"w\":\n                    self.change_direction(\"up\")\n                elif direction == \"a\":\n                    self.change_direction(\"left\")\n                elif direction == \"s\":\n                    self.change_direction(\"down\")\n                elif direction == \"d\":\n                    self.change_direction(\"right\")\n\n            self.move()\n\n        print(\"Game Over!\")\n        print(f\"Final Score: {self.score}\")\n\n\nif __name__ == \"__main__\":\n    game = SnakeGame()\n    game.play()\n```",
    "4": "```python\nimport random\n\nclass Minesweeper:\n    def __init__(self, rows, cols, mines):\n        self.rows = rows\n        self.cols = cols\n        self.mines = mines\n        self.board = [[' ' for _ in range(cols)] for _ in range(rows)]\n        self.hidden_board = [[' ' for _ in range(cols)] for _ in range(rows)]\n        self.mines_positions = []\n        self.game_over = False\n        self.game_won = False\n        self.first_move = True\n\n    def print_board(self):\n        \"\"\"Prints the current state of the board.\"\"\"\n        print(\"   \" + \"  \".join(str(i) for i in range(self.cols)))\n        print(\"  \" + \"-\" * (self.cols * 3))\n        for i in range(self.rows):\n            print(f\"{i} | {'  '.join(self.board[i])} |\")\n        print(\"  \" + \"-\" * (self.cols * 3))\n\n    def generate_mines(self, first_row, first_col):\n        \"\"\"Generates mine positions, avoiding the first move.\"\"\"\n        self.mines_positions = []\n        while len(self.mines_positions) < self.mines:\n            row = random.randint(0, self.rows - 1)\n            col = random.randint(0, self.cols - 1)\n            if (row, col) not in self.mines_positions and (row, col) != (first_row, first_col):\n                self.mines_positions.append((row, col))\n                self.hidden_board[row][col] = '*'\n\n    def calculate_adjacent_mines(self):\n        \"\"\"Calculates the number of mines adjacent to each cell.\"\"\"\n        for row in range(self.rows):\n            for col in range(self.cols):\n                if self.hidden_board[row][col] != '*':\n                    count = 0\n                    for i in range(max(0, row - 1), min(self.rows, row + 2)):\n                        for j in range(max(0, col - 1), min(self.cols, col + 2)):\n                            if self.hidden_board[i][j] == '*':\n                                count += 1\n                    if count > 0:\n                        self.hidden_board[row][col] = str(count)\n                    else:\n                        self.hidden_board[row][col] = '0'\n\n    def reveal_cell(self, row, col):\n        \"\"\"Reveals a cell and recursively reveals adjacent empty cells.\"\"\"\n        if self.board[row][col] != ' ':\n            return  # Cell already revealed\n\n        self.board[row][col] = self.hidden_board[row][col]\n\n        if self.hidden_board[row][col] == '0':\n            for i in range(max(0, row - 1), min(self.rows, row + 2)):\n                for j in range(max(0, col - 1), min(self.cols, col + 2)):\n                    if self.board[i][j] == ' ':\n                        self.reveal_cell(i, j)\n\n    def flag_cell(self, row, col):\n        \"\"\"Flags or unflags a cell.\"\"\"\n        if self.board[row][col] == ' ':\n            self.board[row][col] = 'F'\n        elif self.board[row][col] == 'F':\n            self.board[row][col] = ' '\n\n    def check_win(self):\n        \"\"\"Checks if the player has won the game.\"\"\"\n        revealed_cells = 0\n        for row in range(self.rows):\n            for col in range(self.cols):\n                if self.board[row][col] != ' ':\n                    revealed_cells += 1\n        if revealed_cells == self.rows * self.cols - self.mines:\n            self.game_won = True\n\n    def play(self):\n        \"\"\"Main game loop.\"\"\"\n        while not self.game_over and not self.game_won:\n            self.print_board()\n\n            try:\n                action, row, col = input(\"Enter action (reveal/flag), row, and column (e.g., reveal 0 0): \").split()\n                row = int(row)\n                col = int(col)\n            except ValueError:\n                print(\"Invalid input. Please enter action, row, and column separated by spaces.\")\n                continue\n\n            if not (0 <= row < self.rows and 0 <= col < self.cols):\n                print(\"Invalid row or column. Please enter values within the board dimensions.\")\n                continue\n\n            if self.first_move:\n                self.generate_mines(row, col)\n                self.calculate_adjacent_mines()\n                self.first_move = False\n\n            if action.lower() == 'reveal':\n                if self.hidden_board[row][col] == '*':\n                    self.game_over = True\n                    self.board = [row[:] for row in self.hidden_board]\n                    self.print_board()\n                    print(\"Game Over! You hit a mine.\")\n                else:\n                    self.reveal_cell(row, col)\n                    self.check_win()\n            elif action.lower() == 'flag':\n                self.flag_cell(row, col)\n            else:\n                print(\"Invalid action. Please enter 'reveal' or 'flag'.\")\n\n        if self.game_won:\n            self.print_board()\n            print(\"Congratulations! You won the game!\")\n\n\nif __name__ == \"__main__\":\n    rows = 10\n    cols = 10\n    mines = 15\n    game = Minesweeper(rows, cols, mines)\n    game.play()\n```",
    "5": "```python\nimport random\n\nclass Mastermind:\n    def __init__(self, code_length=4, color_range=6, max_guesses=10):\n        \"\"\"\n        Initializes the Mastermind game.\n\n        Args:\n            code_length (int): The length of the code to guess. Default is 4.\n            color_range (int): The number of possible colors (1 to color_range). Default is 6.\n            max_guesses (int): The maximum number of guesses allowed. Default is 10.\n        \"\"\"\n        self.code_length = code_length\n        self.color_range = color_range\n        self.max_guesses = max_guesses\n        self.secret_code = self.generate_secret_code()\n        self.guesses_remaining = max_guesses\n        self.history = []  # List to store guesses and feedback\n\n    def generate_secret_code(self):\n        \"\"\"\n        Generates a random secret code.\n\n        Returns:\n            list: A list of integers representing the secret code.\n        \"\"\"\n        return [random.randint(1, self.color_range) for _ in range(self.code_length)]\n\n    def get_guess(self):\n        \"\"\"\n        Prompts the user for a guess and validates the input.\n\n        Returns:\n            list: A list of integers representing the user's guess, or None if input is invalid.\n        \"\"\"\n        while True:\n            try:\n                guess_str = input(f\"Enter your guess ({self.code_length} numbers, 1-{self.color_range}, separated by spaces): \")\n                guess = [int(x) for x in guess_str.split()]\n\n                if len(guess) != self.code_length:\n                    print(f\"Invalid guess: Must be {self.code_length} numbers long.\")\n                    continue\n\n                if any(not (1 <= x <= self.color_range) for x in guess):\n                    print(f\"Invalid guess: Numbers must be between 1 and {self.color_range}.\")\n                    continue\n\n                return guess\n            except ValueError:\n                print(\"Invalid input: Please enter numbers separated by spaces.\")\n\n    def check_guess(self, guess):\n        \"\"\"\n        Checks the user's guess against the secret code and provides feedback.\n\n        Args:\n            guess (list): A list of integers representing the user's guess.\n\n        Returns:\n            tuple: A tuple containing the number of \"exact\" matches (correct color and position) and\n                   the number of \"partial\" matches (correct color, wrong position).\n        \"\"\"\n        exact_matches = 0\n        partial_matches = 0\n        temp_secret_code = self.secret_code[:]  # Create a copy to avoid modifying the original\n        temp_guess = guess[:]\n\n        # First, check for exact matches\n        for i in range(self.code_length):\n            if temp_guess[i] == temp_secret_code[i]:\n                exact_matches += 1\n                temp_guess[i] = None  # Mark as matched to avoid double-counting\n                temp_secret_code[i] = None\n\n        # Then, check for partial matches\n        for i in range(self.code_length):\n            if temp_guess[i] is not None:\n                if temp_guess[i] in temp_secret_code:\n                    partial_matches += 1\n                    # Remove the first occurrence of the matching color from the secret code\n                    temp_secret_code[temp_secret_code.index(temp_guess[i])] = None\n\n        return exact_matches, partial_matches\n\n    def play_round(self):\n        \"\"\"\n        Plays a single round of the game.\n\n        Returns:\n            bool: True if the user guessed the code correctly, False otherwise.\n        \"\"\"\n        guess = self.get_guess()\n        if guess is None:\n            return False  # Invalid guess, but continue the game\n\n        exact_matches, partial_matches = self.check_guess(guess)\n        self.history.append((guess, exact_matches, partial_matches))\n        self.guesses_remaining -= 1\n\n        print(f\"Feedback: Exact matches: {exact_matches}, Partial matches: {partial_matches}\")\n\n        return exact_matches == self.code_length\n\n    def print_history(self):\n        \"\"\"\n        Prints the history of guesses and feedback.\n        \"\"\"\n        print(\"\\n--- Guess History ---\")\n        for guess, exact, partial in self.history:\n            print(f\"Guess: {guess}, Exact: {exact}, Partial: {partial}\")\n        print(\"---------------------\")\n\n    def play_game(self):\n        \"\"\"\n        Plays the entire Mastermind game.\n        \"\"\"\n        print(\"Welcome to Mastermind!\")\n        print(f\"I have generated a secret code of length {self.code_length} with numbers from 1 to {self.color_range}.\")\n        print(f\"You have {self.max_guesses} guesses to crack the code.\")\n\n        while self.guesses_remaining > 0:\n            print(f\"\\nGuesses remaining: {self.guesses_remaining}\")\n            if self.play_round():\n                print(\"Congratulations! You cracked the code!\")\n                self.print_history()\n                return\n\n        print(\"\\nYou ran out of guesses.\")\n        print(f\"The secret code was: {self.secret_code}\")\n        self.print_history()\n\n\nif __name__ == \"__main__\":\n    game = Mastermind()  # You can customize code_length, color_range, and max_guesses\n    game.play_game()\n```",
    "6": "```python\nimport random\n\nclass Battleship:\n    def __init__(self, size=10):\n        self.size = size\n        self.player_board = self.create_board()\n        self.computer_board = self.create_board()\n        self.player_ships = []\n        self.computer_ships = []\n        self.ship_lengths = [5, 4, 3, 3, 2]  # Carrier, Battleship, Cruiser, Submarine, Destroyer\n        self.player_guesses = set()\n        self.computer_guesses = set()\n\n    def create_board(self):\n        return [['~' for _ in range(self.size)] for _ in range(self.size)]\n\n    def print_board(self, board, hide_ships=True):\n        header = \"   \" + \" \".join([chr(65 + i) for i in range(self.size)])\n        print(header)\n        for i, row in enumerate(board):\n            row_str = f\"{i+1:2} \" + \" \".join(['~' if hide_ships and cell == 'S' else cell for cell in row])\n            print(row_str)\n\n    def place_ships(self, board, ships, is_player=True):\n        for length in self.ship_lengths:\n            while True:\n                if is_player:\n                    print(f\"\\nPlacing ship of length {length}.\")\n                    orientation = input(\"Enter orientation (H for horizontal, V for vertical): \").upper()\n                    while orientation not in ('H', 'V'):\n                        orientation = input(\"Invalid orientation. Enter H or V: \").upper()\n                    try:\n                        row = int(input(\"Enter starting row (1-{}): \".format(self.size))) - 1\n                        col = ord(input(\"Enter starting column (A-{}): \".format(chr(64+self.size))).upper()) - 65\n                        if not (0 <= row < self.size and 0 <= col < self.size):\n                            print(\"Invalid coordinates. Try again.\")\n                            continue\n                    except ValueError:\n                        print(\"Invalid input. Please enter a number for the row and a letter for the column.\")\n                        continue\n\n                else:\n                    orientation = random.choice(['H', 'V'])\n                    row = random.randint(0, self.size - 1)\n                    col = random.randint(0, self.size - 1)\n\n                if self.is_valid_placement(board, row, col, orientation, length):\n                    self.place_ship(board, row, col, orientation, length)\n                    if is_player:\n                        ships.append((row, col, orientation, length))\n                    else:\n                        ships.append((row, col, orientation, length))\n                    break\n                else:\n                    if is_player:\n                        print(\"Invalid placement. Ship overlaps or goes out of bounds. Try again.\")\n\n    def is_valid_placement(self, board, row, col, orientation, length):\n        if orientation == 'H':\n            if col + length > self.size:\n                return False\n            for i in range(length):\n                if board[row][col + i] == 'S':\n                    return False\n        else:  # orientation == 'V'\n            if row + length > self.size:\n                return False\n            for i in range(length):\n                if board[row + i][col] == 'S':\n                    return False\n        return True\n\n    def place_ship(self, board, row, col, orientation, length):\n        if orientation == 'H':\n            for i in range(length):\n                board[row][col + i] = 'S'\n        else:  # orientation == 'V'\n            for i in range(length):\n                board[row + i][col] = 'S'\n\n    def get_player_guess(self):\n        while True:\n            try:\n                row = int(input(\"Enter row to strike (1-{}): \".format(self.size))) - 1\n                col = ord(input(\"Enter column to strike (A-{}): \".format(chr(64+self.size))).upper()) - 65\n                if not (0 <= row < self.size and 0 <= col < self.size):\n                    print(\"Invalid coordinates. Try again.\")\n                    continue\n                if (row, col) in self.player_guesses:\n                    print(\"You've already guessed that location. Try again.\")\n                    continue\n                return row, col\n            except ValueError:\n                print(\"Invalid input. Please enter a number for the row and a letter for the column.\")\n\n    def computer_guess(self):\n        while True:\n            row = random.randint(0, self.size - 1)\n            col = random.randint(0, self.size - 1)\n            if (row, col) not in self.computer_guesses:\n                return row, col\n\n    def check_hit(self, board, row, col):\n        if board[row][col] == 'S':\n            board[row][col] = 'X'  # Mark as hit\n            return True\n        elif board[row][col] == '~':\n            board[row][col] = 'O'  # Mark as miss\n            return False\n        else:\n            return False  # Already hit or missed\n\n    def is_sunk(self, board, ships, row, col):\n        for ship_row, ship_col, orientation, length in ships:\n            if orientation == 'H':\n                if ship_row == row and ship_col <= col < ship_col + length:\n                    # Check if all parts of the ship are hit\n                    sunk = all(board[ship_row][ship_col + i] == 'X' for i in range(length))\n                    return sunk\n            else:  # orientation == 'V'\n                if ship_col == col and ship_row <= row < ship_row + length:\n                    # Check if all parts of the ship are hit\n                    sunk = all(board[ship_row + i][ship_col] == 'X' for i in range(length))\n                    return sunk\n        return False\n\n    def all_ships_sunk(self, board):\n        for row in board:\n            if 'S' in row:\n                return False\n        return True\n\n    def play(self):\n        print(\"Welcome to Battleship!\")\n\n        # Player setup\n        print(\"\\nPlayer, place your ships:\")\n        self.place_ships(self.player_board, self.player_ships, is_player=True)\n\n        # Computer setup\n        print(\"\\nComputer placing ships...\")\n        self.place_ships(self.computer_board, self.computer_ships, is_player=False)\n\n        turn = 0\n        while True:\n            turn += 1\n            print(f\"\\n--- Turn {turn} ---\")\n\n            # Player's turn\n            print(\"\\nYour board:\")\n            self.print_board(self.player_board)\n            print(\"\\nComputer's board (your guesses):\")\n            self.print_board(self.computer_board, hide_ships=True)\n\n            print(\"\\nYour turn to strike!\")\n            row, col = self.get_player_guess()\n            self.player_guesses.add((row, col))\n\n            hit = self.check_hit(self.computer_board, row, col)\n            if hit:\n                print(\"Hit!\")\n                if self.is_sunk(self.computer_board, self.computer_ships, row, col):\n                    print(\"You sunk a ship!\")\n                if self.all_ships_sunk(self.computer_board):\n                    print(\"\\nCongratulations! You sunk all the computer's ships!\")\n                    break\n            else:\n                print(\"Miss!\")\n\n            # Computer's turn\n            print(\"\\nComputer's turn to strike...\")\n            row, col = self.computer_guess()\n            self.computer_guesses.add((row, col))\n            hit = self.check_hit(self.player_board, row, col)\n            if hit:\n                print(\"Computer hit your ship at {}, {}!\".format(chr(col + 65), row + 1))\n                if self.is_sunk(self.player_board, self.player_ships, row, col):\n                    print(\"Computer sunk one of your ships!\")\n                if self.all_ships_sunk(self.player_board):\n                    print(\"\\nComputer sunk all your ships! You lose!\")\n                    break\n            else:\n                print(\"Computer missed at {}, {}!\".format(chr(col + 65), row + 1))\n\n\nif __name__ == \"__main__\":\n    game = Battleship()\n    game.play()\n```",
    "7": "```python\nimport argparse\nimport time\nimport os\nimport random\n\ndef create_grid(rows, cols, random_fill=False, density=0.5):\n    \"\"\"Creates a grid for the Game of Life.\n\n    Args:\n        rows: Number of rows in the grid.\n        cols: Number of columns in the grid.\n        random_fill: If True, fills the grid randomly.\n        density: Probability of a cell being alive if random_fill is True.\n\n    Returns:\n        A 2D list representing the grid.  Alive cells are 1, dead cells are 0.\n    \"\"\"\n    grid = [[0 for _ in range(cols)] for _ in range(rows)]\n    if random_fill:\n        for i in range(rows):\n            for j in range(cols):\n                if random.random() < density:\n                    grid[i][j] = 1\n    return grid\n\ndef print_grid(grid):\n    \"\"\"Prints the grid to the console.\n\n    Args:\n        grid: The grid to print.\n    \"\"\"\n    os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n    for row in grid:\n        print(''.join(['#' if cell else ' ' for cell in row]))\n\n\ndef get_neighbors(grid, row, col):\n    \"\"\"Gets the number of live neighbors for a given cell.\n\n    Args:\n        grid: The grid.\n        row: The row of the cell.\n        col: The column of the cell.\n\n    Returns:\n        The number of live neighbors.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    neighbors = 0\n    for i in range(max(0, row - 1), min(rows, row + 2)):\n        for j in range(max(0, col - 1), min(cols, col + 2)):\n            if (i, j) != (row, col):\n                neighbors += grid[i][j]\n    return neighbors\n\n\ndef next_generation(grid):\n    \"\"\"Calculates the next generation of the grid.\n\n    Args:\n        grid: The current grid.\n\n    Returns:\n        The next generation grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    new_grid = [[0 for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            neighbors = get_neighbors(grid, i, j)\n            if grid[i][j] == 1:  # Alive cell\n                if neighbors < 2 or neighbors > 3:\n                    new_grid[i][j] = 0  # Dies\n                else:\n                    new_grid[i][j] = 1  # Survives\n            else:  # Dead cell\n                if neighbors == 3:\n                    new_grid[i][j] = 1  # Becomes alive\n    return new_grid\n\n\ndef game_of_life(rows, cols, generations, delay, random_fill, density):\n    \"\"\"Runs the Game of Life simulation.\n\n    Args:\n        rows: Number of rows in the grid.\n        cols: Number of columns in the grid.\n        generations: Number of generations to simulate.\n        delay: Delay between generations in seconds.\n        random_fill: If True, fills the grid randomly.\n        density: Probability of a cell being alive if random_fill is True.\n    \"\"\"\n    grid = create_grid(rows, cols, random_fill, density)\n    for _ in range(generations):\n        print_grid(grid)\n        time.sleep(delay)\n        grid = next_generation(grid)\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Conway's Game of Life\")\n    parser.add_argument(\"-r\", \"--rows\", type=int, default=20, help=\"Number of rows\")\n    parser.add_argument(\"-c\", \"--cols\", type=int, default=40, help=\"Number of columns\")\n    parser.add_argument(\"-g\", \"--generations\", type=int, default=100, help=\"Number of generations\")\n    parser.add_argument(\"-d\", \"--delay\", type=float, default=0.1, help=\"Delay between generations (seconds)\")\n    parser.add_argument(\"-rand\", \"--random\", action=\"store_true\", help=\"Fill grid randomly\")\n    parser.add_argument(\"--density\", type=float, default=0.5, help=\"Density of live cells for random fill\")\n\n    args = parser.parse_args()\n\n    game_of_life(args.rows, args.cols, args.generations, args.delay, args.random, args.density)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
    "8": "```python\ndef create_board(rows=6, cols=7):\n    \"\"\"Creates an empty Connect Four board.\"\"\"\n    return [[' ' for _ in range(cols)] for _ in range(rows)]\n\n\ndef print_board(board):\n    \"\"\"Prints the Connect Four board to the console.\"\"\"\n    cols = len(board[0])\n    print('  ' + '  '.join(str(i + 1) for i in range(cols)))  # Column numbers\n    for row in board:\n        print('| ' + ' | '.join(row) + ' |')\n    print('+' + '---+' * cols)  # Bottom border\n\n\ndef drop_piece(board, col, piece):\n    \"\"\"Drops a piece into the specified column.\"\"\"\n    rows = len(board)\n    for row in range(rows - 1, -1, -1):\n        if board[row][col] == ' ':\n            board[row][col] = piece\n            return row  # Return the row where the piece landed\n    return None  # Column is full\n\n\ndef is_valid_location(board, col):\n    \"\"\"Checks if a column is a valid location to drop a piece.\"\"\"\n    rows = len(board)\n    return board[0][col] == ' ' and 0 <= col < len(board[0])\n\n\ndef winning_move(board, piece):\n    \"\"\"Checks if the last move resulted in a win.\"\"\"\n    rows = len(board)\n    cols = len(board[0])\n\n    # Check horizontal\n    for row in range(rows):\n        for col in range(cols - 3):\n            if (board[row][col] == piece and\n                    board[row][col + 1] == piece and\n                    board[row][col + 2] == piece and\n                    board[row][col + 3] == piece):\n                return True\n\n    # Check vertical\n    for row in range(rows - 3):\n        for col in range(cols):\n            if (board[row][col] == piece and\n                    board[row + 1][col] == piece and\n                    board[row + 2][col] == piece and\n                    board[row + 3][col] == piece):\n                return True\n\n    # Check positive diagonal\n    for row in range(rows - 3):\n        for col in range(cols - 3):\n            if (board[row][col] == piece and\n                    board[row + 1][col + 1] == piece and\n                    board[row + 2][col + 2] == piece and\n                    board[row + 3][col + 3] == piece):\n                return True\n\n    # Check negative diagonal\n    for row in range(3, rows):\n        for col in range(cols - 3):\n            if (board[row][col] == piece and\n                    board[row - 1][col + 1] == piece and\n                    board[row - 2][col + 2] == piece and\n                    board[row - 3][col + 3] == piece):\n                return True\n\n    return False\n\n\ndef is_board_full(board):\n    \"\"\"Checks if the board is full.\"\"\"\n    for row in board:\n        if ' ' in row:\n            return False\n    return True\n\n\ndef get_player_move(board, player_number):\n    \"\"\"Gets a valid column choice from the player.\"\"\"\n    while True:\n        try:\n            col = int(input(f\"Player {player_number}, choose a column (1-{len(board[0])}): \")) - 1\n            if is_valid_location(board, col):\n                return col\n            else:\n                print(\"Invalid column.  It's either full or out of bounds.\")\n        except ValueError:\n            print(\"Invalid input. Please enter a number.\")\n        except IndexError:\n            print(\"Invalid input. Column number out of range.\")\n\n\n\ndef play_connect_four():\n    \"\"\"Plays a game of Connect Four.\"\"\"\n    board = create_board()\n    print_board(board)\n    game_over = False\n    turn = 0\n\n    while not game_over:\n        # Player turn\n        if turn % 2 == 0:\n            player = 1\n            piece = 'X'\n        else:\n            player = 2\n            piece = 'O'\n\n        col = get_player_move(board, player)\n\n        if drop_piece(board, col, piece) is not None:\n            print_board(board)\n\n            if winning_move(board, piece):\n                print(f\"Player {player} wins!\")\n                game_over = True\n            elif is_board_full(board):\n                print(\"It's a draw!\")\n                game_over = True\n            else:\n                turn += 1\n        else:\n            print(\"That column is full. Try again.\")  # Should not happen due to input validation\n\n\nif __name__ == \"__main__\":\n    play_connect_four()\n```",
    "9": "```python\nimport random\n\ndef calculate_hand_value(hand):\n    \"\"\"Calculates the value of a hand in Blackjack. Aces can be 1 or 11.\"\"\"\n    ace_count = hand.count('A')\n    total = 0\n    for card in hand:\n        if card.isdigit():\n            total += int(card)\n        elif card in ('J', 'Q', 'K'):\n            total += 10\n        elif card == 'A':\n            total += 11\n    while total > 21 and ace_count > 0:\n        total -= 10\n        ace_count -= 1\n    return total\n\ndef deal_card(deck):\n    \"\"\"Deals a card from the deck.\"\"\"\n    return deck.pop()\n\ndef create_deck():\n    \"\"\"Creates a standard 52-card deck.\"\"\"\n    suits = ['Hearts', 'Diamonds', 'Clubs', 'Spades']\n    ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']\n    deck = [rank for suit in suits for rank in ranks] * 4 # Use 4 decks\n    random.shuffle(deck)\n    return deck\n\ndef display_hand(hand, hidden=False):\n    \"\"\"Displays a hand of cards.\"\"\"\n    if hidden:\n        print(\"[Hidden Card]\", end=\" \")\n        for card in hand[1:]:\n            print(card, end=\" \")\n    else:\n        for card in hand:\n            print(card, end=\" \")\n    print()\n\ndef play_blackjack():\n    \"\"\"Plays a game of Blackjack.\"\"\"\n    deck = create_deck()\n    player_hand = []\n    dealer_hand = []\n\n    # Deal initial hands\n    for _ in range(2):\n        player_hand.append(deal_card(deck))\n        dealer_hand.append(deal_card(deck))\n\n    print(\"Dealer's hand:\")\n    display_hand(dealer_hand, hidden=True)\n    print(\"Your hand:\")\n    display_hand(player_hand)\n    player_value = calculate_hand_value(player_hand)\n    print(f\"Your hand value: {player_value}\")\n\n    # Player's turn\n    while player_value < 21:\n        action = input(\"Hit or stand? (h/s): \").lower()\n        if action == 'h':\n            player_hand.append(deal_card(deck))\n            print(\"Your hand:\")\n            display_hand(player_hand)\n            player_value = calculate_hand_value(player_hand)\n            print(f\"Your hand value: {player_value}\")\n            if player_value > 21:\n                print(\"You bust!\")\n                return \"dealer\"\n        elif action == 's':\n            break\n        else:\n            print(\"Invalid action. Please enter 'h' or 's'.\")\n\n    # Dealer's turn\n    print(\"\\nDealer's hand:\")\n    display_hand(dealer_hand)\n    dealer_value = calculate_hand_value(dealer_hand)\n    print(f\"Dealer's hand value: {dealer_value}\")\n\n    if player_value > 21:\n        return \"dealer\"\n\n    while dealer_value < 17:  # Dealer hits on 16 or less\n        print(\"Dealer hits.\")\n        dealer_hand.append(deal_card(deck))\n        display_hand(dealer_hand)\n        dealer_value = calculate_hand_value(dealer_hand)\n        print(f\"Dealer's hand value: {dealer_value}\")\n        if dealer_value > 21:\n            print(\"Dealer busts!\")\n            return \"player\"\n\n    # Determine the winner\n    print(\"\\nFinal hands:\")\n    print(\"Your hand:\", end=\" \")\n    display_hand(player_hand)\n    print(\"Dealer's hand:\", end=\" \")\n    display_hand(dealer_hand)\n\n    if dealer_value > 21:\n        return \"player\"\n    elif player_value > dealer_value or dealer_value > 21:\n        return \"player\"\n    elif player_value == dealer_value:\n        return \"push\"\n    else:\n        return \"dealer\"\n\nif __name__ == \"__main__\":\n    while True:\n        print(\"\\nLet's play Blackjack!\")\n        winner = play_blackjack()\n\n        if winner == \"player\":\n            print(\"You win!\")\n        elif winner == \"dealer\":\n            print(\"Dealer wins!\")\n        else:\n            print(\"It's a push (tie)!\")\n\n        play_again = input(\"Play again? (y/n): \").lower()\n        if play_again != 'y':\n            break\n    print(\"Thanks for playing!\")\n```",
    "10": "```python\nimport random\n\ndef play_hammurabi():\n    \"\"\"Plays the game Hammurabi.\"\"\"\n\n    year = 1\n    population = 100\n    grain_stores = 2800\n    acres_owned = 1000\n    bushels_per_acre = 3\n    deaths_from_starvation = 0\n\n    print(\"Congratulations, you are the newly appointed ruler of ancient Sumeria!\")\n    print(\"Your reign begins in a time of plenty.  However, you face challenges:\")\n    print(\" - People will starve if you do not provide enough grain.\")\n    print(\" - Rats will eat your grain if you store too much.\")\n    print(\" - The price of land will vary from year to year.\")\n    print(\" - The amount of grain harvested per acre will also vary.\")\n    print(\"You must rule wisely, or you will be deposed!\")\n\n    while year <= 10:\n        print(\"\\nYear\", year)\n        print(\"Population is\", population)\n        print(\"Grain stores are\", grain_stores, \"bushels\")\n        print(\"You own\", acres_owned, \"acres of land\")\n        print(\"Harvest was\", bushels_per_acre, \"bushels per acre\")\n        print(\"Deaths from starvation last year:\", deaths_from_starvation)\n\n        # Land Price\n        land_price = random.randint(17, 23)\n        print(\"Land is selling for\", land_price, \"bushels per acre\")\n\n        # Buy/Sell Land\n        while True:\n            try:\n                land_to_buy = int(input(\"How many acres do you wish to buy? \"))\n                if land_to_buy < 0:\n                    print(\"You can't buy a negative number of acres.\")\n                    continue\n                if land_to_buy * land_price > grain_stores:\n                    print(\"You do not have enough grain to buy that much land.\")\n                    continue\n                break\n            except ValueError:\n                print(\"Please enter a valid number.\")\n\n        grain_stores -= land_to_buy * land_price\n        acres_owned += land_to_buy\n\n        while True:\n            try:\n                land_to_sell = int(input(\"How many acres do you wish to sell? \"))\n                if land_to_sell < 0:\n                    print(\"You can't sell a negative number of acres.\")\n                    continue\n                if land_to_sell > acres_owned:\n                    print(\"You do not own that much land.\")\n                    continue\n                break\n            except ValueError:\n                print(\"Please enter a valid number.\")\n\n        grain_stores += land_to_sell * land_price\n        acres_owned -= land_to_sell\n\n        # Feed People\n        while True:\n            try:\n                grain_to_feed = int(input(\"How many bushels do you wish to feed your people? \"))\n                if grain_to_feed < 0:\n                    print(\"You can't feed them a negative amount of grain.\")\n                    continue\n                if grain_to_feed > grain_stores:\n                    print(\"You do not have enough grain to feed them that much.\")\n                    continue\n                break\n            except ValueError:\n                print(\"Please enter a valid number.\")\n\n        grain_stores -= grain_to_feed\n\n        # Planting\n        while True:\n            try:\n                acres_to_plant = int(input(\"How many acres do you wish to plant with grain? \"))\n                if acres_to_plant < 0:\n                    print(\"You can't plant a negative number of acres.\")\n                    continue\n                if acres_to_plant > acres_owned:\n                    print(\"You do not own that much land.\")\n                    continue\n                if acres_to_plant > population * 10:\n                    print(\"You do not have enough people to plant that many acres.\")\n                    continue\n                if acres_to_plant > grain_stores:\n                    print(\"You do not have enough grain to plant that many acres.\")\n                    continue\n\n                break\n            except ValueError:\n                print(\"Please enter a valid number.\")\n\n        grain_stores -= acres_to_plant\n\n        # Harvest\n        bushels_per_acre = random.randint(1, 6)\n        harvested_grain = acres_to_plant * bushels_per_acre\n        grain_stores += harvested_grain\n\n        # Rats\n        rat_infestation = random.randint(0, 100)\n        if rat_infestation < 40:\n            rat_loss = int(grain_stores * random.uniform(0.1, 0.3))\n            grain_stores -= rat_loss\n            print(\"Rats ate\", rat_loss, \"bushels of grain!\")\n        else:\n            rat_loss = 0\n\n        # Starvation\n        people_fed = grain_to_feed // 20  # Each person needs 20 bushels\n        deaths_from_starvation = population - people_fed\n        if deaths_from_starvation < 0:\n            deaths_from_starvation = 0\n\n        population -= deaths_from_starvation\n\n        # Immigration\n        immigration = int(random.uniform(0.05, 0.15) * (100 - deaths_from_starvation))\n        if immigration < 0:\n            immigration = 0 # avoid negative populations\n        population += immigration\n\n        if population <= 0:\n            print(\"\\nYour entire population has died.  Your reign is over.\")\n            break\n\n        # Check for Deposition\n        if deaths_from_starvation > population * 0.45:\n            print(\"\\nToo many people starved! You are deposed by the angry mob!\")\n            break\n        \n        year += 1\n\n    # End Game\n    if year > 10:\n        print(\"\\nYour reign has ended after 10 years.\")\n        print(\"You ruled\", acres_owned, \"acres of land with a population of\", population, \"people.\")\n\n\nif __name__ == \"__main__\":\n    play_hammurabi()\n```\n",
    "11": "```python\nimport random\n\nclass LightsOut:\n    def __init__(self, size=5, initial_state=None):\n        \"\"\"\n        Initializes the Lights Out game.\n\n        Args:\n            size (int): The size of the grid (size x size). Default is 5.\n            initial_state (list of lists, optional): An initial grid state. If None, a random state is generated.\n        \"\"\"\n        self.size = size\n        if initial_state is None:\n            self.grid = self.generate_random_grid()\n        else:\n            if len(initial_state) != size or any(len(row) != size for row in initial_state):\n                raise ValueError(\"Initial state must be a square grid of the specified size.\")\n            self.grid = [list(row) for row in initial_state]  # Create a copy to avoid modifying the original\n        self.moves = 0\n\n    def generate_random_grid(self):\n        \"\"\"\n        Generates a random grid for the game.\n\n        Returns:\n            list of lists: A random grid of 0s and 1s.\n        \"\"\"\n        return [[random.randint(0, 1) for _ in range(self.size)] for _ in range(self.size)]\n\n    def __str__(self):\n        \"\"\"\n        Returns a string representation of the game grid.\n\n        Returns:\n            str: A string representation of the grid.\n        \"\"\"\n        grid_str = \"\"\n        for row in self.grid:\n            grid_str += \" \".join(map(str, row)) + \"\\n\"\n        return grid_str\n\n    def toggle(self, row, col):\n        \"\"\"\n        Toggles the state of a cell (0 to 1, or 1 to 0).\n\n        Args:\n            row (int): The row index of the cell.\n            col (int): The column index of the cell.\n        \"\"\"\n        if 0 <= row < self.size and 0 <= col < self.size:\n            self.grid[row][col] = 1 - self.grid[row][col]\n\n    def press_button(self, row, col):\n        \"\"\"\n        Presses a button at the given coordinates, toggling the cell and its neighbors.\n\n        Args:\n            row (int): The row index of the button.\n            col (int): The column index of the button.\n        \"\"\"\n        self.toggle(row, col)\n        self.toggle(row - 1, col)  # Toggle above\n        self.toggle(row + 1, col)  # Toggle below\n        self.toggle(row, col - 1)  # Toggle left\n        self.toggle(row, col + 1)  # Toggle right\n        self.moves += 1\n\n    def is_solved(self):\n        \"\"\"\n        Checks if the game is solved (all cells are 0).\n\n        Returns:\n            bool: True if the game is solved, False otherwise.\n        \"\"\"\n        return all(cell == 0 for row in self.grid for cell in row)\n\n    def solve(self):\n        \"\"\"\n        Solves the game using Gaussian elimination (advanced).  This is optional, but useful for generating solvable puzzles.\n        \"\"\"\n        # Create a matrix representing the game's equations.\n        matrix = []\n        for i in range(self.size):\n            for j in range(self.size):\n                row = [0] * (self.size * self.size)\n                row[i * self.size + j] = 1  # The cell itself\n\n                # Neighbors\n                if i > 0:\n                    row[(i - 1) * self.size + j] = 1\n                if i < self.size - 1:\n                    row[(i + 1) * self.size + j] = 1\n                if j > 0:\n                    row[i * self.size + (j - 1)] = 1\n                if j < self.size - 1:\n                    row[i * self.size + (j + 1)] = 1\n\n                matrix.append(row)\n\n        # Augment the matrix with the initial state.\n        b = [self.grid[i // self.size][i % self.size] for i in range(self.size * self.size)]\n        augmented_matrix = [row + [b[i]] for i, row in enumerate(matrix)]\n\n        # Gaussian elimination (mod 2).\n        for i in range(self.size * self.size):\n            # Find pivot\n            pivot_row = i\n            for k in range(i + 1, self.size * self.size):\n                if augmented_matrix[k][i] == 1:\n                    pivot_row = k\n                    break\n\n            if augmented_matrix[pivot_row][i] == 0:\n                continue  # No pivot in this column\n\n            # Swap rows if necessary\n            if pivot_row != i:\n                augmented_matrix[i], augmented_matrix[pivot_row] = augmented_matrix[pivot_row], augmented_matrix[i]\n\n            # Eliminate other rows\n            for k in range(self.size * self.size):\n                if k != i and augmented_matrix[k][i] == 1:\n                    for j in range(i, self.size * self.size + 1):\n                        augmented_matrix[k][j] = (augmented_matrix[k][j] - augmented_matrix[i][j]) % 2\n\n        # Back substitution\n        solution = [0] * (self.size * self.size)\n        for i in range(self.size * self.size - 1, -1, -1):\n            if augmented_matrix[i][i] == 1:\n                solution[i] = augmented_matrix[i][-1]\n\n        # Apply the solution to the grid\n        for i in range(self.size):\n            for j in range(self.size):\n                if solution[i * self.size + j] == 1:\n                    self.press_button(i, j)\n\ndef play_game():\n    \"\"\"\n    Plays the Lights Out game in the command line.\n    \"\"\"\n    size = 5\n    while True:\n        try:\n            size = int(input(\"Enter the size of the grid (default is 5): \") or 5)\n            if size < 2:\n                print(\"Grid size must be at least 2.\")\n            else:\n                break\n        except ValueError:\n            print(\"Invalid input. Please enter an integer.\")\n\n    game = LightsOut(size)\n    print(\"Initial grid:\")\n    print(game)\n\n    while not game.is_solved():\n        try:\n            row, col = map(int, input(\"Enter the row and column to press (e.g., 0 0), or 'q' to quit: \").split())\n            game.press_button(row, col)\n            print(game)\n            print(f\"Moves: {game.moves}\")\n        except ValueError:\n            user_input = input(\"Enter the row and column to press (e.g., 0 0), or 'q' to quit: \")\n            if user_input.lower() == 'q':\n                print(\"Quitting the game.\")\n                return\n            else:\n                print(\"Invalid input. Please enter two integers separated by a space or 'q'.\")\n        except IndexError:\n            print(\"Invalid input. Please enter two integers separated by a space.\")\n\n\n    print(\"Congratulations! You solved the puzzle.\")\n    print(f\"Total moves: {game.moves}\")\n\n\nif __name__ == \"__main__\":\n    play_game()\n```\n",
    "12": "```python\nimport time\nimport random\nimport os\n\nclass Pong:\n    def __init__(self, width=60, height=20):\n        self.width = width\n        self.height = height\n        self.ball_x = width // 2\n        self.ball_y = height // 2\n        self.ball_dx = random.choice([-1, 1])\n        self.ball_dy = random.choice([-1, 1])\n        self.paddle1_y = height // 2 - 2\n        self.paddle2_y = height // 2 - 2\n        self.paddle_length = 4\n        self.score1 = 0\n        self.score2 = 0\n        self.running = True\n        self.delay = 0.05 # Adjust for game speed\n\n    def clear_screen(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n\n    def draw(self):\n        self.clear_screen()\n        # Create the game board\n        board = [[' ' for _ in range(self.width)] for _ in range(self.height)]\n\n        # Draw paddles\n        for i in range(self.paddle_length):\n            board[self.paddle1_y + i][0] = '|'\n            board[self.paddle2_y + i][self.width - 1] = '|'\n\n        # Draw ball\n        board[self.ball_y][self.ball_x] = 'O'\n\n        # Print the board\n        for row in board:\n            print(''.join(row))\n\n        # Print the score\n        print(f\"Player 1: {self.score1}  Player 2: {self.score2}\")\n\n    def update(self):\n        # Ball movement\n        self.ball_x += self.ball_dx\n        self.ball_y += self.ball_dy\n\n        # Bounce off top and bottom\n        if self.ball_y <= 0 or self.ball_y >= self.height - 1:\n            self.ball_dy *= -1\n\n        # Paddle collision\n        if self.ball_x == 1 and self.paddle1_y <= self.ball_y <= self.paddle1_y + self.paddle_length - 1:\n            self.ball_dx *= -1\n        elif self.ball_x == self.width - 2 and self.paddle2_y <= self.ball_y <= self.paddle2_y + self.paddle_length - 1:\n            self.ball_dx *= -1\n\n        # Score and reset\n        if self.ball_x <= 0:\n            self.score2 += 1\n            self.reset_ball()\n        elif self.ball_x >= self.width - 1:\n            self.score1 += 1\n            self.reset_ball()\n\n    def reset_ball(self):\n        self.ball_x = self.width // 2\n        self.ball_y = self.height // 2\n        self.ball_dx = random.choice([-1, 1])\n        self.ball_dy = random.choice([-1, 1])\n\n\n    def move_paddle1(self, direction):\n        if direction == \"up\" and self.paddle1_y > 0:\n            self.paddle1_y -= 1\n        elif direction == \"down\" and self.paddle1_y < self.height - self.paddle_length:\n            self.paddle1_y += 1\n\n    def move_paddle2(self, direction):\n        if direction == \"up\" and self.paddle2_y > 0:\n            self.paddle2_y -= 1\n        elif direction == \"down\" and self.paddle2_y < self.height - self.paddle_length:\n            self.paddle2_y += 1\n\n\n    def play(self):\n        while self.running:\n            self.draw()\n            self.update()\n\n            # Get input (non-blocking)\n            import select\n            import sys\n            if select.select([sys.stdin,], [], [], 0.0)[0]: # Check if stdin is ready to read\n                action = sys.stdin.readline().strip() # Read input without blocking\n                if action == \"q\":\n                    self.running = False\n                    break\n                elif action == \"w\":\n                    self.move_paddle1(\"up\")\n                elif action == \"s\":\n                    self.move_paddle1(\"down\")\n                elif action == \"o\":\n                    self.move_paddle2(\"up\")\n                elif action == \"l\":\n                    self.move_paddle2(\"down\")\n\n            time.sleep(self.delay)\n\n        print(\"Game Over!\")\n        print(f\"Final Score: Player 1: {self.score1}  Player 2: {self.score2}\")\n\n\nif __name__ == \"__main__\":\n    game = Pong()\n    print(\"Welcome to Pong!\")\n    print(\"Controls:\")\n    print(\"Player 1: w (up), s (down)\")\n    print(\"Player 2: o (up), l (down)\")\n    print(\"Press q to quit\")\n    game.play()\n```",
    "13": "```python\nimport random\nimport os\nimport time\n\nclass Tetris:\n    \"\"\"\n    A command-line Tetris game.\n    \"\"\"\n\n    GRID_WIDTH = 10\n    GRID_HEIGHT = 20\n    SHAPES = [\n        [[1, 1, 1, 1]],  # I\n        [[1, 1], [1, 1]],  # O\n        [[0, 1, 1], [1, 1, 0]],  # S\n        [[1, 1, 0], [0, 1, 1]],  # Z\n        [[1, 1, 1], [0, 0, 1]],  # J\n        [[1, 1, 1], [1, 0, 0]],  # L\n        [[1, 1, 1], [0, 1, 0]]   # T\n    ]\n    COLORS = [\"\\033[0m\", \"\\033[31m\", \"\\033[32m\", \"\\033[33m\", \"\\033[34m\", \"\\033[35m\", \"\\033[36m\", \"\\033[37m\"]  # ANSI color codes\n\n    def __init__(self):\n        self.grid = [[0] * self.GRID_WIDTH for _ in range(self.GRID_HEIGHT)]\n        self.current_shape = None\n        self.current_x = 0\n        self.current_y = 0\n        self.score = 0\n        self.game_over = False\n        self.next_shape = self.get_random_shape()\n        self.level = 1\n        self.drop_interval = 0.8  # Initial drop interval in seconds\n\n    def get_random_shape(self):\n        \"\"\"Returns a random shape from the SHAPES list.\"\"\"\n        shape_index = random.randint(0, len(self.SHAPES) - 1)\n        return (self.SHAPES[shape_index], shape_index + 1)  # Return shape and color index\n\n    def spawn_shape(self):\n        \"\"\"Spawns a new shape at the top of the grid.\"\"\"\n        self.current_shape, self.current_color = self.next_shape\n        self.next_shape = self.get_random_shape()\n        self.current_x = self.GRID_WIDTH // 2 - len(self.current_shape[0]) // 2\n        self.current_y = 0\n        if not self.is_valid_position(self.current_shape, self.current_x, self.current_y):\n            self.game_over = True\n            return False\n        return True\n\n    def rotate_shape(self):\n        \"\"\"Rotates the current shape 90 degrees clockwise.\"\"\"\n        rotated_shape = list(zip(*self.current_shape[::-1]))\n        if self.is_valid_position(rotated_shape, self.current_x, self.current_y):\n            self.current_shape = rotated_shape\n\n    def move_shape(self, dx):\n        \"\"\"Moves the current shape horizontally.\"\"\"\n        new_x = self.current_x + dx\n        if self.is_valid_position(self.current_shape, new_x, self.current_y):\n            self.current_x = new_x\n\n    def drop_shape(self):\n        \"\"\"Drops the current shape down one row.\"\"\"\n        new_y = self.current_y + 1\n        if self.is_valid_position(self.current_shape, self.current_x, new_y):\n            self.current_y = new_y\n        else:\n            self.lock_shape()\n            self.clear_lines()\n            if not self.spawn_shape():\n                self.game_over = True\n            return False\n        return True\n\n    def is_valid_position(self, shape, x, y):\n        \"\"\"Checks if the given shape can be placed at the given position.\"\"\"\n        for row_index, row in enumerate(shape):\n            for col_index, cell in enumerate(row):\n                if cell:\n                    grid_x = x + col_index\n                    grid_y = y + row_index\n\n                    if grid_x < 0 or grid_x >= self.GRID_WIDTH or grid_y >= self.GRID_HEIGHT:\n                        return False\n                    if grid_y >= 0 and self.grid[grid_y][grid_x] != 0:\n                        return False\n        return True\n\n    def lock_shape(self):\n        \"\"\"Locks the current shape into the grid.\"\"\"\n        for row_index, row in enumerate(self.current_shape):\n            for col_index, cell in enumerate(row):\n                if cell:\n                    self.grid[self.current_y + row_index][self.current_x + col_index] = self.current_color\n\n    def clear_lines(self):\n        \"\"\"Clears any full lines from the grid.\"\"\"\n        lines_cleared = 0\n        for row_index in range(self.GRID_HEIGHT):\n            if all(self.grid[row_index]):\n                del self.grid[row_index]\n                self.grid.insert(0, [0] * self.GRID_WIDTH)\n                lines_cleared += 1\n\n        if lines_cleared > 0:\n            self.score += self.level * (lines_cleared ** 2) * 100\n            self.update_level(lines_cleared)\n\n    def update_level(self, lines_cleared):\n        \"\"\"Updates the game level and drop interval based on lines cleared.\"\"\"\n        if self.score >= self.level * 1000:\n            self.level += 1\n            self.drop_interval *= 0.9  # Increase speed by decreasing interval\n            print(f\"Level Up!  Current Level: {self.level}\")\n            time.sleep(1)  # Wait for a second to display the level up message\n\n    def draw_grid(self):\n        \"\"\"Draws the grid with the current shape.\"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n\n        # Print score and level information\n        print(f\"Score: {self.score}   Level: {self.level}\")\n\n        # Print the next shape\n        print(\"Next Shape:\")\n        for row in self.next_shape[0]:\n            print(\"\".join(self.COLORS[self.next_shape[1]] + \"[]\" + self.COLORS[0] if cell else \"  \" for cell in row))\n        print()\n\n        # Create a copy of the grid to draw the current shape on\n        display_grid = [row[:] for row in self.grid]\n\n        # Draw the current shape\n        if self.current_shape:\n            for row_index, row in enumerate(self.current_shape):\n                for col_index, cell in enumerate(row):\n                    if cell:\n                        grid_x = self.current_x + col_index\n                        grid_y = self.current_y + row_index\n                        if 0 <= grid_x < self.GRID_WIDTH and 0 <= grid_y < self.GRID_HEIGHT:\n                            display_grid[grid_y][grid_x] = self.current_color\n\n        # Print the grid with colors\n        print(\"-\" * (self.GRID_WIDTH * 2 + 2))  # Top border\n        for row in display_grid:\n            print(\"|\" + \"\".join(self.COLORS[cell] + \"[]\" + self.COLORS[0] if cell else \"  \" for cell in row) + \"|\")\n        print(\"-\" * (self.GRID_WIDTH * 2 + 2))  # Bottom border\n\n    def run(self):\n        \"\"\"Runs the main game loop.\"\"\"\n        if not self.spawn_shape():\n            self.game_over = True\n\n        last_drop_time = time.time()\n\n        while not self.game_over:\n            self.draw_grid()\n\n            # Handle user input\n            user_input = input(\"Enter command (a=left, d=right, s=down, w=rotate, q=quit): \").lower()\n\n            if user_input == 'a':\n                self.move_shape(-1)\n            elif user_input == 'd':\n                self.move_shape(1)\n            elif user_input == 's':\n                self.drop_shape()\n                last_drop_time = time.time() #Reset timer after manual drop\n            elif user_input == 'w':\n                self.rotate_shape()\n            elif user_input == 'q':\n                self.game_over = True\n                break\n\n            # Automatic drop\n            current_time = time.time()\n            if current_time - last_drop_time >= self.drop_interval:\n                if not self.drop_shape():\n                    if self.game_over:\n                        break\n                last_drop_time = current_time\n\n        # Game over message\n        self.draw_grid()\n        print(\"Game Over! Your score:\", self.score)\n\n\nif __name__ == \"__main__\":\n    game = Tetris()\n    game.run()\n```",
    "14": "```python\nimport math\nimport random\nimport time\nimport sys\n\nclass GameObject:\n    def __init__(self, x, y, velocity_x, velocity_y, size, symbol):\n        self.x = x\n        self.y = y\n        self.velocity_x = velocity_x\n        self.velocity_y = velocity_y\n        self.size = size\n        self.symbol = symbol\n\n    def move(self, width, height):\n        self.x += self.velocity_x\n        self.y += self.velocity_y\n\n        # Wrap around the screen\n        if self.x < 0:\n            self.x = width\n        elif self.x > width:\n            self.x = 0\n        if self.y < 0:\n            self.y = height\n        elif self.y > height:\n            self.y = 0\n\n    def draw(self, screen):\n        x = int(round(self.x))\n        y = int(round(self.y))\n        screen[y][x] = self.symbol\n\n    def check_collision(self, other):\n        distance = math.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)\n        return distance < (self.size + other.size)\n\nclass Asteroid(GameObject):\n    def __init__(self, x, y, velocity_x, velocity_y, size):\n        super().__init__(x, y, velocity_x, velocity_y, size, '*')\n\nclass Ship(GameObject):\n    def __init__(self, x, y):\n        super().__init__(x, y, 0, 0, 1, '^') # '^' for ship pointing upwards\n        self.rotation = 0  # Angle in radians\n\n    def rotate_left(self):\n        self.rotation -= 0.1\n\n    def rotate_right(self):\n        self.rotation += 0.1\n\n    def accelerate(self):\n        self.velocity_x += 0.2 * math.sin(self.rotation)\n        self.velocity_y -= 0.2 * math.cos(self.rotation)  # Y-axis is inverted\n\n    def draw(self, screen):\n        x = int(round(self.x))\n        y = int(round(self.y))\n\n        # Convert rotation to a \"pointing\" symbol\n        if abs(self.rotation) < 0.2:\n            symbol = '^'\n        elif abs(self.rotation - math.pi/2) < 0.2:\n            symbol = '>'\n        elif abs(self.rotation - math.pi) < 0.2 or abs(self.rotation + math.pi) < 0.2:\n            symbol = 'v'\n        elif abs(self.rotation + math.pi/2) < 0.2:\n            symbol = '<'\n        else:\n             symbol = 'X' #Generic symbol if the angle doesn't match known angles\n\n        screen[y][x] = symbol\n\n\nclass Bullet(GameObject):\n    def __init__(self, x, y, velocity_x, velocity_y):\n        super().__init__(x, y, velocity_x, velocity_y, 0, '.')\n\nclass AsteroidsGame:\n    def __init__(self, width=80, height=24):\n        self.width = width\n        self.height = height\n        self.ship = Ship(width // 2, height // 2)\n        self.asteroids = [Asteroid(random.randint(0, width), random.randint(0, height),\n                                   random.uniform(-0.5, 0.5), random.uniform(-0.5, 0.5),\n                                   random.randint(1, 3)) for _ in range(5)]\n        self.bullets = []\n        self.game_over = False\n        self.score = 0\n\n    def create_screen(self):\n        return [[' ' for _ in range(self.width)] for _ in range(self.height)]\n\n    def draw_objects(self, screen):\n        self.ship.draw(screen)\n        for asteroid in self.asteroids:\n            asteroid.draw(screen)\n        for bullet in self.bullets:\n            bullet.draw(screen)\n\n    def move_objects(self):\n        self.ship.move(self.width, self.height)\n        for asteroid in self.asteroids:\n            asteroid.move(self.width, self.height)\n        for bullet in self.bullets:\n            bullet.move(self.width, self.height)\n\n        # Remove bullets that are out of bounds\n        self.bullets = [bullet for bullet in self.bullets if 0 <= bullet.x < self.width and 0 <= bullet.y < self.height]\n\n    def handle_collisions(self):\n        # Ship - Asteroid collisions\n        for asteroid in self.asteroids:\n            if self.ship.check_collision(asteroid):\n                self.game_over = True\n                return\n\n        # Bullet - Asteroid collisions\n        for bullet in self.bullets[:]: #Iterate over a copy\n            for asteroid in self.asteroids[:]: #Iterate over a copy\n                if bullet.check_collision(asteroid):\n                    self.bullets.remove(bullet)\n                    self.asteroids.remove(asteroid)\n                    self.score += 10\n                    # Create new asteroids if the asteroid was large enough\n                    if asteroid.size > 1:\n                        new_asteroids = self.split_asteroid(asteroid)\n                        self.asteroids.extend(new_asteroids)\n                    break # Important: Break inner loop after removing asteroid\n\n\n    def split_asteroid(self, asteroid):\n        new_asteroids = []\n        for _ in range(2): # Split into two smaller asteroids\n            new_size = asteroid.size - 1\n            if new_size > 0:\n                new_asteroids.append(Asteroid(asteroid.x, asteroid.y,\n                                              random.uniform(-0.5, 0.5), random.uniform(-0.5, 0.5),\n                                              new_size))\n        return new_asteroids\n\n\n    def handle_input(self, key):\n        if key == 'a':\n            self.ship.rotate_left()\n        elif key == 'd':\n            self.ship.rotate_right()\n        elif key == 'w':\n            self.ship.accelerate()\n        elif key == ' ':\n            # Fire a bullet.  Velocity is based on ship's rotation.\n            bullet_speed = 2\n            bullet_velocity_x = bullet_speed * math.sin(self.ship.rotation)\n            bullet_velocity_y = -bullet_speed * math.cos(self.ship.rotation)\n            self.bullets.append(Bullet(self.ship.x, self.ship.y, bullet_velocity_x, bullet_velocity_y))\n\n\n    def display_screen(self, screen):\n        # Clear the screen (OS specific)\n        if sys.platform in ['linux', 'darwin']:  # Linux or MacOS\n            print(\"\\033[2J\\033[H\", end=\"\")\n        elif sys.platform in ['win32', 'cygwin']:\n            import os\n            os.system('cls')\n        else: # Fallback - just print newlines\n            print('\\n' * self.height)\n\n        print(\"\\n\".join(\"\".join(row) for row in screen))\n        print(f\"Score: {self.score}\")\n        print(\"Controls: W (Accelerate), A (Rotate Left), D (Rotate Right), Space (Fire)\")\n\n    def run(self):\n        while not self.game_over:\n            screen = self.create_screen()\n            self.move_objects()\n            self.handle_collisions()\n            self.draw_objects(screen)\n            self.display_screen(screen)\n\n            # Get user input (non-blocking)\n            key = get_input()  # Use the get_input function defined below\n            if key:\n                self.handle_input(key)\n\n            time.sleep(0.05)\n        print(\"Game Over! Final Score:\", self.score)\n\n\n# Non-blocking input (platform specific)\nimport select\nimport tty\nimport termios\n\ndef get_input():\n    if select.select([sys.stdin], [], [], 0) == ([sys.stdin], [], []):\n        old_settings = termios.tcgetattr(sys.stdin)\n        try:\n            tty.setcbreak(sys.stdin.fileno())\n            char = sys.stdin.read(1)\n        finally:\n            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)\n        return char\n    return None\n\nif __name__ == \"__main__\":\n    game = AsteroidsGame()\n    game.run()\n```",
    "15": "```python\nimport random\nimport time\nimport sys\n\nclass Boggle:\n    def __init__(self, size=4, time_limit=180):\n        self.size = size\n        self.time_limit = time_limit\n        self.board = self.generate_board()\n        self.words = self.load_words(\"wordlist.txt\")  # Replace with your wordlist file\n        self.found_words = set()\n        self.start_time = 0\n\n    def generate_board(self):\n        dice = [\n            \"RIFOBX\", \"IFEHSE\", \"OBJOBA\", \"HMQUMNI\",\n            \"WEDSLG\", \"ITAEOL\", \"HRIUOB\", \"ENSIEU\",\n            \"ATCIWO\", \"TLAEWR\", \"GONHES\", \"SMRZOI\",\n            \"TOEISS\", \"ANEDVZ\", \"ANDELA\", \"SFPCAP\"\n        ]\n        board = []\n        for _ in range(self.size):\n            row = []\n            for _ in range(self.size):\n                die = random.choice(dice)\n                row.append(random.choice(die))\n            board.append(row)\n        return board\n\n    def load_words(self, filename):\n        try:\n            with open(filename, \"r\") as f:\n                words = set(word.strip().upper() for word in f)\n            return words\n        except FileNotFoundError:\n            print(f\"Error: Wordlist file '{filename}' not found.\")\n            sys.exit(1)\n\n    def print_board(self):\n        for row in self.board:\n            print(\" \".join(row))\n\n    def is_valid_word(self, word):\n        return word in self.words and word not in self.found_words and len(word) >= 3\n\n    def find_word(self, word):\n        for row in range(self.size):\n            for col in range(self.size):\n                if self.board[row][col] == word[0]:\n                    if self._search_recursive(word, row, col, 0, set()):\n                        return True\n        return False\n\n    def _search_recursive(self, word, row, col, index, visited):\n        if index == len(word):\n            return True\n\n        if (row < 0 or row >= self.size or\n            col < 0 or col >= self.size or\n            self.board[row][col] != word[index] or\n            (row, col) in visited):\n            return False\n\n        visited.add((row, col))\n        \n        # Explore adjacent cells\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue  # Skip the current cell\n                new_row = row + dr\n                new_col = col + dc\n                if self._search_recursive(word, new_row, new_col, index + 1, visited.copy()):\n                    return True\n        \n        return False\n\n    def play(self):\n        self.start_time = time.time()\n        print(\"Welcome to Boggle!\")\n        self.print_board()\n        print(f\"You have {self.time_limit} seconds to find as many words as possible.\")\n\n        while time.time() - self.start_time < self.time_limit:\n            remaining_time = self.time_limit - (time.time() - self.start_time)\n            print(f\"\\nTime remaining: {int(remaining_time)} seconds\")\n            word = input(\"Enter a word (or type 'quit' to end): \").strip().upper()\n\n            if word == \"QUIT\":\n                break\n\n            if self.is_valid_word(word) and self.find_word(word):\n                self.found_words.add(word)\n                print(\"Word found!\")\n            else:\n                print(\"Invalid word or already found.\")\n\n        self.end_game()\n\n    def end_game(self):\n        print(\"\\nTime's up!\")\n        print(\"Words found:\")\n        for word in sorted(self.found_words):\n            print(word)\n\n        score = self.calculate_score()\n        print(f\"Your score: {score}\")\n\n    def calculate_score(self):\n        score = 0\n        for word in self.found_words:\n            length = len(word)\n            if length == 3 or length == 4:\n                score += 1\n            elif length == 5:\n                score += 2\n            elif length == 6:\n                score += 3\n            elif length == 7:\n                score += 5\n            else:  # 8 or more\n                score += 11\n        return score\n\n\nif __name__ == \"__main__\":\n    boggle = Boggle()\n    boggle.play()\n```\nTo run this code:\n\n1.  **Save the code:** Save the code as a `.py` file (e.g., `boggle.py`).\n2.  **Create a wordlist file:** Create a text file named `wordlist.txt` (or whatever name you use in the `load_words` function).  Each word should be on a new line in all uppercase.  A sample wordlist can be found online.  A simple example:\n\n    ```\n    CAT\n    DOG\n    BIRD\n    HOUSE\n    TREE\n    CAR\n    ```\n3.  **Run the game:** Open a terminal or command prompt, navigate to the directory where you saved the files, and run the command `python boggle.py`.\n\n",
    "16": "```python\nimport random\nimport time\nimport os\n\nclass PacManGame:\n    def __init__(self, width=15, height=10):\n        self.width = width\n        self.height = height\n        self.board = [[' ' for _ in range(width)] for _ in range(height)]\n        self.pacman_x = width // 2\n        self.pacman_y = height // 2\n        self.ghost_x = 1\n        self.ghost_y = 1\n        self.food_count = 0\n        self.game_over = False\n        self.score = 0\n\n        # Initialize food\n        for y in range(height):\n            for x in range(width):\n                if random.random() < 0.8 and (x != self.pacman_x or y != self.pacman_y) and (x != self.ghost_x or y != self.ghost_y):\n                    self.board[y][x] = '.'\n                    self.food_count += 1\n\n        # Place Pac-Man and Ghost\n        self.board[self.pacman_y][self.pacman_x] = 'P'\n        self.board[self.ghost_y][self.ghost_x] = 'G'\n\n    def print_board(self):\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the screen\n        print(\"-\" * (self.width + 2))\n        for row in self.board:\n            print(\"|\" + \"\".join(row) + \"|\")\n        print(\"-\" * (self.width + 2))\n        print(f\"Score: {self.score}, Food Remaining: {self.food_count}\")\n        \n\n    def move_pacman(self, direction):\n        new_x = self.pacman_x\n        new_y = self.pacman_y\n\n        if direction == 'w':  # Up\n            new_y -= 1\n        elif direction == 's':  # Down\n            new_y += 1\n        elif direction == 'a':  # Left\n            new_x -= 1\n        elif direction == 'd':  # Right\n            new_x += 1\n        else:\n            print(\"Invalid direction. Use w, a, s, d.\")\n            return\n\n        if 0 <= new_x < self.width and 0 <= new_y < self.height:\n            if self.board[new_y][new_x] == '.':\n                self.score += 10\n                self.food_count -= 1\n            elif self.board[new_y][new_x] == 'G':\n                self.game_over = True\n                return\n\n            self.board[self.pacman_y][self.pacman_x] = ' '\n            self.pacman_x = new_x\n            self.pacman_y = new_y\n            self.board[self.pacman_y][self.pacman_x] = 'P'\n\n    def move_ghost(self):\n        possible_moves = []\n        if self.ghost_x > 0:\n            possible_moves.append('a')\n        if self.ghost_x < self.width - 1:\n            possible_moves.append('d')\n        if self.ghost_y > 0:\n            possible_moves.append('w')\n        if self.ghost_y < self.height - 1:\n            possible_moves.append('s')\n\n        if not possible_moves:\n            return # Ghost is trapped\n\n        direction = random.choice(possible_moves)\n        new_x = self.ghost_x\n        new_y = self.ghost_y\n\n        if direction == 'w':\n            new_y -= 1\n        elif direction == 's':\n            new_y += 1\n        elif direction == 'a':\n            new_x -= 1\n        elif direction == 'd':\n            new_x += 1\n\n        if self.board[new_y][new_x] == 'P':\n            self.game_over = True\n            return\n\n        self.board[self.ghost_y][self.ghost_x] = ' '\n        self.ghost_x = new_x\n        self.ghost_y = new_y\n        self.board[self.ghost_y][self.ghost_x] = 'G'\n\n\n    def play(self):\n        while not self.game_over and self.food_count > 0:\n            self.print_board()\n            direction = input(\"Enter direction (w/a/s/d): \").lower()\n            self.move_pacman(direction)\n            if not self.game_over:\n                self.move_ghost()\n            time.sleep(0.2)  # Add a small delay to make it playable\n\n        self.print_board()\n        if self.game_over:\n            print(\"Game Over! Ghost caught Pac-Man.\")\n        else:\n            print(\"Congratulations! You ate all the food!\")\n        print(f\"Final Score: {self.score}\")\n\n\nif __name__ == \"__main__\":\n    game = PacManGame()\n    game.play()\n```",
    "17": "```python\nimport time\nimport random\nimport os\n\nclass DinosaurRunner:\n    def __init__(self):\n        self.dino_position = 0\n        self.obstacle_position = 20\n        self.score = 0\n        self.game_over = False\n        self.obstacle_type = self.choose_obstacle() # 0: cactus, 1: bird\n        self.jump_height = 3\n\n    def choose_obstacle(self):\n        return random.randint(0, 1)\n\n    def generate_obstacle(self):\n       if self.obstacle_type == 0:\n            return \"\"\n       else:\n            return \"\"\n\n    def print_screen(self):\n        \"\"\"Prints the game screen.\"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the screen\n        screen = \"\"\n\n        # Ground\n        ground = \"_\" * 40 + \"\\n\"\n        screen += ground\n\n        # Dino\n        dino = \"\"\n        dino_position_str = \" \" * self.dino_position + dino\n\n        # Obstacle\n        obstacle = self.generate_obstacle()\n        obstacle_position_str = \" \" * self.obstacle_position + obstacle\n\n        # Combine dino and obstacle, handling potential overlap\n        if self.dino_position < self.obstacle_position:\n          screen += dino_position_str + obstacle_position_str[len(dino_position_str):] + \"\\n\"\n        else:\n          screen += obstacle_position_str + dino_position_str[len(obstacle_position_str):] + \"\\n\"\n\n\n        screen += ground\n        screen += f\"Score: {self.score}\\n\"\n        print(screen)\n\n\n    def update(self, action):\n        \"\"\"Updates the game state based on the player's action.\"\"\"\n\n        # Handle jumping\n        if action == \"jump\":\n            self.dino_position = self.jump_height  # Dino jumps\n        else:\n            self.dino_position = 0 # Dino on the ground\n\n\n        # Move the obstacle\n        self.obstacle_position -= 1\n\n        # Check for collision\n        if self.dino_position == 0 and self.obstacle_position <= 1:\n            self.game_over = True\n            return\n\n        # Generate new obstacle\n        if self.obstacle_position < 0:\n            self.obstacle_position = 39\n            self.score += 1\n            self.obstacle_type = self.choose_obstacle()\n\n    def play(self):\n        \"\"\"Main game loop.\"\"\"\n        while not self.game_over:\n            self.print_screen()\n            action = input(\"Type 'jump' to jump, or press Enter to continue: \").lower()\n            self.update(action)\n            time.sleep(0.1)\n\n        print(\"Game Over!\")\n        print(f\"Final Score: {self.score}\")\n\n\nif __name__ == \"__main__\":\n    game = DinosaurRunner()\n    game.play()\n```\n"
}