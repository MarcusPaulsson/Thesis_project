{
    "0": "```python\ndef print_board(board):\n    \"\"\"Prints the Tic-Tac-Toe board.\"\"\"\n    print(\"-------------\")\n    for i in range(3):\n        print(\"|\", board[i][0], \"|\", board[i][1], \"|\", board[i][2], \"|\")\n        print(\"-------------\")\n\n\ndef check_win(board, player):\n    \"\"\"Checks if the given player has won the game.\"\"\"\n    # Check rows\n    for i in range(3):\n        if board[i][0] == board[i][1] == board[i][2] == player:\n            return True\n\n    # Check columns\n    for j in range(3):\n        if board[0][j] == board[1][j] == board[2][j] == player:\n            return True\n\n    # Check diagonals\n    if board[0][0] == board[1][1] == board[2][2] == player:\n        return True\n    if board[0][2] == board[1][1] == board[2][0] == player:\n        return True\n\n    return False\n\n\ndef check_draw(board):\n    \"\"\"Checks if the board is full (draw).\"\"\"\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == \" \":\n                return False  # There's still an empty space\n\n    return True\n\n\ndef get_player_move(board, player):\n    \"\"\"Gets a valid move from the player.\"\"\"\n    while True:\n        try:\n            row = int(input(f\"Player {player}, enter row (0-2): \"))\n            col = int(input(f\"Player {player}, enter column (0-2): \"))\n\n            if not (0 <= row <= 2 and 0 <= col <= 2):\n                print(\"Invalid row or column.  Must be between 0 and 2.\")\n                continue\n\n            if board[row][col] != \" \":\n                print(\"That space is already taken. Try again.\")\n                continue\n\n            return row, col\n\n        except ValueError:\n            print(\"Invalid input. Please enter numbers between 0 and 2.\")\n        except KeyboardInterrupt:\n            print(\"\\nGame interrupted. Exiting.\")\n            exit()\n\n\n\ndef play_tic_tac_toe():\n    \"\"\"Main function to play the Tic-Tac-Toe game.\"\"\"\n    board = [[\" \" for _ in range(3)] for _ in range(3)]  # Initialize the board\n    current_player = \"X\"\n\n    print(\"Welcome to Tic-Tac-Toe!\")\n    print_board(board)\n\n    while True:\n        row, col = get_player_move(board, current_player)\n\n        board[row][col] = current_player  # Make the move\n        print_board(board)\n\n        if check_win(board, current_player):\n            print(f\"Player {current_player} wins!\")\n            break\n\n        if check_draw(board):\n            print(\"It's a draw!\")\n            break\n\n        # Switch players\n        current_player = \"O\" if current_player == \"X\" else \"X\"\n\n\nif __name__ == \"__main__\":\n    play_tic_tac_toe()\n```",
    "1": "```python\nimport random\n\ndef choose_word(word_list):\n    \"\"\"Chooses a random word from a list of words.\"\"\"\n    return random.choice(word_list).upper()\n\ndef display_word(word, guessed_letters):\n    \"\"\"Displays the word with correctly guessed letters and underscores for unguessed letters.\"\"\"\n    displayed_word = \"\"\n    for letter in word:\n        if letter in guessed_letters:\n            displayed_word += letter + \" \"\n        else:\n            displayed_word += \"_ \"\n    return displayed_word.strip()\n\ndef get_guess(guessed_letters):\n    \"\"\"Gets a valid letter guess from the player.\"\"\"\n    while True:\n        guess = input(\"Guess a letter: \").upper()\n        if not guess.isalpha():\n            print(\"Invalid input. Please enter a letter.\")\n        elif len(guess) != 1:\n            print(\"Please guess only one letter at a time.\")\n        elif guess in guessed_letters:\n            print(\"You already guessed that letter.\")\n        else:\n            return guess\n\ndef play_hangman(word_list):\n    \"\"\"Plays a game of Hangman.\"\"\"\n    word = choose_word(word_list)\n    guessed_letters = set()\n    incorrect_guesses = 0\n    max_incorrect_guesses = 6  # You can adjust this\n    game_over = False\n\n    print(\"Welcome to Hangman!\")\n    print(f\"The word has {len(word)} letters.\")\n    print(display_word(word, guessed_letters))\n\n    while not game_over:\n        guess = get_guess(guessed_letters)\n        guessed_letters.add(guess)\n\n        if guess in word:\n            print(\"Correct guess!\")\n            displayed = display_word(word, guessed_letters)\n            print(displayed)\n\n            if \"_\" not in displayed:\n                print(\"Congratulations! You guessed the word:\", word)\n                game_over = True\n        else:\n            incorrect_guesses += 1\n            print(f\"Incorrect guess. You have {max_incorrect_guesses - incorrect_guesses} guesses remaining.\")\n            print(display_word(word, guessed_letters))\n\n            if incorrect_guesses >= max_incorrect_guesses:\n                print(\"You ran out of guesses. The word was:\", word)\n                game_over = True\n\ndef main():\n    \"\"\"Main function to start the Hangman game.\"\"\"\n    word_list = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\", \"fig\", \"grape\"]\n    play_again = True\n\n    while play_again:\n        play_hangman(word_list)\n        response = input(\"Play again? (yes/no): \").lower()\n        if response != \"yes\":\n            play_again = False\n            print(\"Thanks for playing!\")\n\nif __name__ == \"__main__\":\n    main()\n```",
    "2": "```python\nimport random\n\ndef get_player_choice():\n    \"\"\"Gets the player's choice (rock, paper, or scissors) from the command line.\"\"\"\n    while True:\n        choice = input(\"Choose rock, paper, or scissors: \").lower()\n        if choice in [\"rock\", \"paper\", \"scissors\"]:\n            return choice\n        else:\n            print(\"Invalid choice. Please enter rock, paper, or scissors.\")\n\ndef get_computer_choice():\n    \"\"\"Randomly selects the computer's choice (rock, paper, or scissors).\"\"\"\n    return random.choice([\"rock\", \"paper\", \"scissors\"])\n\ndef determine_winner(player_choice, computer_choice):\n    \"\"\"Determines the winner of the game.\"\"\"\n    print(f\"You chose: {player_choice}\")\n    print(f\"The computer chose: {computer_choice}\")\n\n    if player_choice == computer_choice:\n        return \"It's a tie!\"\n    elif (player_choice == \"rock\" and computer_choice == \"scissors\") or \\\n         (player_choice == \"paper\" and computer_choice == \"rock\") or \\\n         (player_choice == \"scissors\" and computer_choice == \"paper\"):\n        return \"You win!\"\n    else:\n        return \"You lose!\"\n\ndef play_again():\n    \"\"\"Asks the player if they want to play again.\"\"\"\n    while True:\n        answer = input(\"Play again? (yes/no): \").lower()\n        if answer in [\"yes\", \"no\"]:\n            return answer == \"yes\"\n        else:\n            print(\"Invalid input. Please enter yes or no.\")\n\ndef play_game():\n    \"\"\"Main function to play the Rock-Paper-Scissors game.\"\"\"\n    print(\"Welcome to Rock-Paper-Scissors!\")\n\n    while True:\n        player_choice = get_player_choice()\n        computer_choice = get_computer_choice()\n        result = determine_winner(player_choice, computer_choice)\n        print(result)\n\n        if not play_again():\n            print(\"Thanks for playing!\")\n            break\n\nif __name__ == \"__main__\":\n    play_game()\n```",
    "3": "```python\nimport random\nimport time\nimport curses\n\nclass SnakeGame:\n    def __init__(self, width=20, height=10):\n        self.width = width\n        self.height = height\n        self.snake = [(width // 2, height // 2)]  # Snake starts in the middle\n        self.food = self.create_food()\n        self.direction = curses.KEY_RIGHT  # Initial direction\n        self.score = 0\n        self.game_over = False\n\n    def create_food(self):\n        \"\"\"Creates food at a random empty location.\"\"\"\n        while True:\n            food = (random.randint(1, self.width - 2), random.randint(1, self.height - 2))\n            if food not in self.snake:\n                return food\n\n    def move_snake(self):\n        \"\"\"Moves the snake based on the current direction.\"\"\"\n        head_x, head_y = self.snake[0]\n\n        if self.direction == curses.KEY_RIGHT:\n            new_head = (head_x + 1, head_y)\n        elif self.direction == curses.KEY_LEFT:\n            new_head = (head_x - 1, head_y)\n        elif self.direction == curses.KEY_UP:\n            new_head = (head_x, head_y - 1)\n        elif self.direction == curses.KEY_DOWN:\n            new_head = (head_x, head_y + 1)\n        else:\n            return  # Invalid direction\n\n        self.snake.insert(0, new_head)  # Add new head\n\n        # Check if snake ate food\n        if new_head == self.food:\n            self.score += 1\n            self.food = self.create_food()  # Create new food\n        else:\n            self.snake.pop()  # Remove tail if no food eaten\n\n    def check_collision(self):\n        \"\"\"Checks for collisions with walls or itself.\"\"\"\n        head_x, head_y = self.snake[0]\n\n        if (\n            head_x <= 0\n            or head_x >= self.width - 1\n            or head_y <= 0\n            or head_y >= self.height - 1\n            or self.snake[0] in self.snake[1:]  # Check self-collision\n        ):\n            self.game_over = True\n\n    def update(self):\n        \"\"\"Updates the game state.\"\"\"\n        self.move_snake()\n        self.check_collision()\n\n    def draw(self, screen):\n        \"\"\"Draws the game on the screen.\"\"\"\n        screen.clear()\n\n        # Draw border\n        for i in range(self.width):\n            screen.addch(0, i, '#')\n            screen.addch(self.height - 1, i, '#')\n        for i in range(self.height):\n            screen.addch(i, 0, '#')\n            screen.addch(i, self.width - 1, '#')\n\n\n        # Draw snake\n        for x, y in self.snake:\n            screen.addch(y, x, 'O')\n\n        # Draw food\n        screen.addch(self.food[1], self.food[0], '*')\n\n        # Draw score\n        screen.addstr(self.height, 0, f\"Score: {self.score}\")\n\n        screen.refresh()\n\n\n\ndef main(screen):\n    \"\"\"Main game loop.\"\"\"\n    curses.curs_set(0)  # Hide cursor\n    screen.nodelay(1)  # Non-blocking getch\n    screen.timeout(100)  # Refresh every 100 ms\n\n    game = SnakeGame(width=40, height=20)\n\n    while not game.game_over:\n        game.draw(screen)\n        key = screen.getch()\n\n        # Handle input\n        if key == curses.KEY_EXIT or key == ord('q'):\n            break\n        elif key in [curses.KEY_LEFT, curses.KEY_RIGHT, curses.KEY_UP, curses.KEY_DOWN]:\n            # Prevent snake from going directly backwards\n            if (key == curses.KEY_LEFT and game.direction != curses.KEY_RIGHT) or \\\n               (key == curses.KEY_RIGHT and game.direction != curses.KEY_LEFT) or \\\n               (key == curses.KEY_UP and game.direction != curses.KEY_DOWN) or \\\n               (key == curses.KEY_DOWN and game.direction != curses.KEY_UP):\n                game.direction = key\n\n        game.update()\n\n    # Game over message\n    screen.clear()\n    screen.addstr(game.height // 2, game.width // 2 - 5, \"Game Over!\")\n    screen.addstr(game.height // 2 + 1, game.width // 2 - 7, f\"Final Score: {game.score}\")\n    screen.refresh()\n    time.sleep(2)\n\n\n\nif __name__ == '__main__':\n    curses.wrapper(main)\n```",
    "4": "```python\nimport random\nimport sys\n\nclass Minesweeper:\n    \"\"\"\n    A Minesweeper game implemented in Python with a command-line interface.\n    \"\"\"\n\n    def __init__(self, rows, cols, mines):\n        \"\"\"\n        Initializes the Minesweeper game.\n\n        Args:\n            rows (int): The number of rows in the grid.\n            cols (int): The number of columns in the grid.\n            mines (int): The number of mines to place.\n        \"\"\"\n        self.rows = rows\n        self.cols = cols\n        self.mines = mines\n        self.grid = [[0 for _ in range(cols)] for _ in range(rows)]\n        self.revealed = [[False for _ in range(cols)] for _ in range(rows)]\n        self.flagged = [[False for _ in range(cols)] for _ in range(rows)]\n        self.game_over = False\n        self.first_move = True  # Flag to indicate the first move\n\n    def print_grid(self):\n        \"\"\"\n        Prints the current state of the Minesweeper grid to the console.\n        Revealed cells show their value, unrevealed cells are hidden.\n        \"\"\"\n        print(\"   \" + \" \".join(str(i) for i in range(self.cols)))\n        print(\"  \" + \"-\" * (2 * self.cols + 1))\n        for row in range(self.rows):\n            print(f\"{row}| \", end=\"\")\n            for col in range(self.cols):\n                if self.flagged[row][col]:\n                    print(\"F \", end=\"\")\n                elif self.revealed[row][col]:\n                    if self.grid[row][col] == -1:\n                        print(\"X \", end=\"\")  # Mine\n                    elif self.grid[row][col] == 0:\n                        print(\". \", end=\"\")  # Empty revealed cell\n                    else:\n                        print(f\"{self.grid[row][col]} \", end=\"\")  # Number of adjacent mines\n                else:\n                    print(\"# \", end=\"\")  # Hidden cell\n            print(\"|\")\n        print(\"  \" + \"-\" * (2 * self.cols + 1))\n\n    def place_mines(self, safe_row, safe_col):\n        \"\"\"\n        Places the mines randomly on the grid, ensuring the first click is safe.\n\n        Args:\n            safe_row (int): The row of the first click.\n            safe_col (int): The column of the first click.\n        \"\"\"\n        mines_placed = 0\n        while mines_placed < self.mines:\n            row = random.randint(0, self.rows - 1)\n            col = random.randint(0, self.cols - 1)\n            if self.grid[row][col] == 0 and (row, col) != (safe_row, safe_col):\n                self.grid[row][col] = -1  # -1 represents a mine\n                mines_placed += 1\n\n        self.calculate_adjacent_mines()\n\n    def calculate_adjacent_mines(self):\n        \"\"\"\n        Calculates and sets the number of adjacent mines for each cell in the grid.\n        \"\"\"\n        for row in range(self.rows):\n            for col in range(self.cols):\n                if self.grid[row][col] != -1:\n                    count = 0\n                    for i in range(max(0, row - 1), min(self.rows, row + 2)):\n                        for j in range(max(0, col - 1), min(self.cols, col + 2)):\n                            if self.grid[i][j] == -1:\n                                count += 1\n                    self.grid[row][col] = count\n\n    def reveal_cell(self, row, col):\n        \"\"\"\n        Reveals a cell and its adjacent empty cells recursively if the cell is empty.\n\n        Args:\n            row (int): The row of the cell to reveal.\n            col (int): The column of the cell to reveal.\n        \"\"\"\n        if row < 0 or row >= self.rows or col < 0 or col >= self.cols or self.revealed[row][col]:\n            return\n\n        self.revealed[row][col] = True\n\n        if self.grid[row][col] == -1:\n            self.game_over = True\n            return\n\n        if self.grid[row][col] == 0:\n            for i in range(max(0, row - 1), min(self.rows, row + 2)):\n                for j in range(max(0, col - 1), min(self.cols, col + 2)):\n                    if not self.revealed[i][j]:\n                        self.reveal_cell(i, j)\n\n    def flag_cell(self, row, col):\n        \"\"\"\n        Flags or unflags a cell.\n\n        Args:\n            row (int): The row of the cell to flag/unflag.\n            col (int): The column of the cell to flag/unflag.\n        \"\"\"\n        if not self.revealed[row][col]:\n            self.flagged[row][col] = not self.flagged[row][col]\n\n    def check_win(self):\n        \"\"\"\n        Checks if the player has won the game.  The player wins if all non-mine\n        cells have been revealed.\n        \"\"\"\n        for row in range(self.rows):\n            for col in range(self.cols):\n                if self.grid[row][col] != -1 and not self.revealed[row][col]:\n                    return False\n        return True\n\n    def play(self):\n        \"\"\"\n        The main game loop.  Handles user input and updates the game state.\n        \"\"\"\n        while not self.game_over:\n            self.print_grid()\n            try:\n                action, row, col = input(\"Enter action (reveal/flag), row, and column (e.g., reveal 0 0): \").split()\n                row = int(row)\n                col = int(",
    "5": "```python\nimport random\n\nclass Mastermind:\n    \"\"\"\n    A class to represent the Mastermind game.\n    \"\"\"\n\n    def __init__(self, code_length=4, colors=('R', 'G', 'B', 'Y', 'O', 'P'), max_guesses=10):\n        \"\"\"\n        Initializes a new Mastermind game.\n\n        Args:\n            code_length (int): The length of the secret code.\n            colors (tuple): The possible colors to choose from.\n            max_guesses (int): The maximum number of guesses allowed.\n        \"\"\"\n        self.code_length = code_length\n        self.colors = colors\n        self.max_guesses = max_guesses\n        self.secret_code = self._generate_secret_code()\n        self.guesses = []\n        self.results = []\n        self.game_over = False\n        self.won = False\n\n    def _generate_secret_code(self):\n        \"\"\"\n        Generates a random secret code.\n\n        Returns:\n            str: The secret code.\n        \"\"\"\n        return ''.join(random.choice(self.colors) for _ in range(self.code_length))\n\n    def guess(self, guess):\n        \"\"\"\n        Makes a guess and evaluates it.\n\n        Args:\n            guess (str): The player's guess.\n\n        Returns:\n            tuple: A tuple containing the number of correct positions and correct colors.\n        \"\"\"\n        if self.game_over:\n            return None  # Game is already over\n\n        if len(guess) != self.code_length:\n            raise ValueError(f\"Guess must be {self.code_length} characters long.\")\n\n        for char in guess:\n            if char not in self.colors:\n                raise ValueError(f\"Invalid color: {char}.  Allowed colors are: {self.colors}\")\n\n\n        correct_position = 0\n        correct_color = 0\n        temp_secret = list(self.secret_code)  # Create a mutable copy of the secret code\n        temp_guess = list(guess)  # Create a mutable copy of the guess\n        \n        # First, check for correct positions\n        for i in range(self.code_length):\n            if temp_guess[i] == temp_secret[i]:\n                correct_position += 1\n                temp_guess[i] = None  # Mark as used\n                temp_secret[i] = None  # Mark as used\n\n        # Then, check for correct colors in the remaining positions\n        for i in range(self.code_length):\n            if temp_guess[i] is not None:\n                if temp_guess[i] in temp_secret:\n                    correct_color += 1\n                    temp_secret[temp_secret.index(temp_guess[i])] = None #Mark as used\n                    \n        self.guesses.append(guess)\n        self.results.append((correct_position, correct_color))\n\n        if correct_position == self.code_length:\n            self.game_over = True\n            self.won = True\n        elif len(self.guesses) >= self.max_guesses:\n            self.game_over = True\n            self.won = False\n\n        return (correct_position, correct_color)\n\n    def is_game_over(self):\n        \"\"\"\n        Checks if the game is over.\n\n        Returns:\n            bool: True if the game is over, False otherwise.\n        \"\"\"\n        return self.game_over\n\n    def has_won(self):\n        \"\"\"\n        Checks if the player has won.\n\n        Returns:\n            bool: True if the player has won, False otherwise.\n        \"\"\"\n        return self.won\n\n    def get_guesses(self):\n        \"\"\"\n        Returns the list of guesses made by the player.\n\n        Returns:\n            list: The list of guesses.\n        \"\"\"\n        return self.guesses\n\n    def get_results(self):\n        \"\"\"\n        Returns the list of results for each guess.\n\n        Returns:\n            list: The list of results.\n        \"\"\"\n        return self.results\n\n    def get_secret_code(self):\n        \"\"\"\n        Returns the secret code.  Only use this after game over.\n\n        Returns:\n            str: The secret code.\n        \"\"\"\n        return self.secret_code\n\n\ndef play_mastermind():\n    \"\"\"\n    Plays a game of Mastermind through the command line.\n    \"\"\"\n    code_length = 4\n    colors = ('R', 'G', 'B', 'Y', 'O', 'P')\n    max_guesses = 10\n\n    game = Mastermind(code_length, colors, max_guesses)\n\n    print(\"Welcome to Mastermind!\")\n    print(f\"I've generated a secret code with {code_length} colors.\")\n    print(f\"The possible colors are: {', '.join(colors)}\")\n    print(f\"You have {max_guesses} guesses to crack the code.\")\n\n    while not game.is_game_over():\n        print(\"\\nGuesses so far:\")\n        for i, guess in enumerate(game.get_guesses()):\n            pos, color = game.get_results()[i]\n            print(f\"  {guess}: {pos} correct position(s), {color} correct color(s)\")\n\n        while True:\n            try:\n                guess = input(\"Enter your guess: \").upper()\n                result = game.guess(guess)\n                break # Exit the inner loop if the guess is valid\n            except ValueError as e:\n                print(f\"Invalid guess: {e}\")\n\n    if game.has_won():\n        print(\"\\nCongratulations! You cracked the code!\")\n    else:\n        print(\"\\nYou ran out of guesses.\")\n\n    print(f\"The secret code was: {game.get_secret_code()}\")\n\n\nif __name__ == \"__main__\":\n    play_mastermind()\n```\n",
    "6": "```python\nimport random\n\nclass Battleship:\n    def __init__(self, size=10, num_ships=5):\n        self.size = size\n        self.num_ships = num_ships\n        self.player_board = [['O'] * size for _ in range(size)]\n        self.computer_board = [['O'] * size for _ in range(size)]\n        self.computer_ships = []\n        self.player_ships_placed = False\n        self.player_ship_lengths = [5, 4, 3, 3, 2]  # Example ship lengths, can be customized\n        self.computer_ship_lengths = [5, 4, 3, 3, 2]\n        self.player_hits = 0\n        self.computer_hits = 0\n        self.game_over = False\n\n    def print_board(self, board, show_ships=False):\n        \"\"\"Prints the game board.\"\"\"\n        header = \"   \" + \" \".join(chr(65 + i) for i in range(self.size))\n        print(header)\n        for i, row in enumerate(board):\n            row_str = str(i).rjust(2) + \" \"\n            for cell in row:\n                if show_ships and cell == 'S':\n                    row_str += 'S '  # Show ships for debugging/testing\n                else:\n                    row_str += cell + ' '\n            print(row_str)\n\n    def place_ship(self, board, ship_length, is_player=True):\n        \"\"\"Places a ship on the board.\"\"\"\n        while True:\n            if is_player:\n                try:\n                    start_row = int(input(f\"Enter starting row (0-{self.size - 1}): \"))\n                    start_col = input(f\"Enter starting column (A-{chr(65 + self.size - 1)}): \").upper()\n                    start_col = ord(start_col) - 65\n                    orientation = input(\"Enter orientation (H for horizontal, V for vertical): \").upper()\n                    if not (0 <= start_row < self.size and 0 <= start_col < self.size and orientation in ('H', 'V')):\n                        print(\"Invalid input. Try again.\")\n                        continue\n                except ValueError:\n                    print(\"Invalid input. Row must be a number.\")\n                    continue\n                except IndexError:\n                    print(\"Invalid input. Column must be a letter within range.\")\n                    continue\n            else:\n                start_row = random.randint(0, self.size - 1)\n                start_col = random.randint(0, self.size - 1)\n                orientation = random.choice(['H', 'V'])\n\n            valid_placement = True\n\n            if orientation == 'H':\n                if start_col + ship_length > self.size:\n                    valid_placement = False\n                else:\n                    for i in range(ship_length):\n                        if board[start_row][start_col + i] == 'S':\n                            valid_placement = False\n                            break\n            else:  # Vertical\n                if start_row + ship_length > self.size:\n                    valid_placement = False\n                else:\n                    for i in range(ship_length):\n                        if board[start_row + i][start_col] == 'S':\n                            valid_placement = False\n                            break\n\n            if valid_placement:\n                if orientation == 'H':\n                    for i in range(ship_length):\n                        board[start_row][start_col + i] = 'S'\n                else:\n                    for i in range(ship_length):\n                        board[start_row + i][start_col] = 'S'\n                return True\n            else:\n                if is_player:\n                    print(\"Invalid placement. Try again.\")\n\n    def player_place_ships(self):\n        \"\"\"Allows the player to place their ships.\"\"\"\n        print(\"Place your ships:\")\n        for length in self.player_ship_lengths:\n            print(f\"\\nPlacing ship of length {length}:\")\n            self.print_board(self.player_board)\n            while not self.place_ship(self.player_board, length, is_player=True):\n                pass\n        self.player_ships_placed = True\n        print(\"All your ships have been placed!\")\n        self.print_board(self.player_board)\n\n\n    def computer_place_ships(self):\n        \"\"\"Places the computer's ships randomly.\"\"\"\n        for length in self.computer_ship_lengths:\n            while not self.place_ship(self.computer_board, length, is_player=False):\n                pass\n\n        # Store computer ship locations for hit tracking (optional, but good practice)\n        self.computer_ships = []\n        for row in range(self.size):\n            for col in range(self.size):\n                if self.computer_board[row][col] == 'S':\n                    self.computer_ships.append((row, col))\n\n\n    def take_turn(self, attacker_board, defender_board, attacker_name, defender_name):\n        \"\"\"Handles a single turn for either the player or the computer.\"\"\"\n        while True:\n            if attacker_name == \"Player\":\n                try:\n                    row = int(input(f\"{attacker_name}, enter row to attack (0-{self.size - 1}): \"))\n                    col = input(f\"Enter column to attack (A-{chr(65 + self.size - 1)}): \").upper()\n                    col = ord(col) - 65\n\n                    if not (0 <= row < self.size and 0 <= col < self.size):\n                        print(\"Invalid coordinates. Try again.\")\n                        continue\n                except ValueError:\n                    print(\"Invalid input. Row must be a number.\")\n                    continue\n                except IndexError:\n                    print(\"Invalid input. Column must be a letter within range.\")\n                    continue\n\n            else:  # Computer's turn\n                row = random.randint(0, self.size - 1)\n                col",
    "7": "```python\nimport argparse\nimport time\nimport random\nimport os\n\n\nclass GameOfLife:\n    \"\"\"\n    Implements Conway's Game of Life.\n    \"\"\"\n\n    def __init__(self, width, height, initial_state=None, density=0.5):\n        \"\"\"\n        Initializes the game board.\n\n        Args:\n            width (int): The width of the board.\n            height (int): The height of the board.\n            initial_state (list[list[int]], optional): A pre-defined initial state. Defaults to None.\n            density (float, optional): The density of live cells when generating a random initial state. Defaults to 0.5.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.density = density\n\n        if initial_state:\n            self.board = initial_state\n            self.height = len(initial_state)\n            self.width = len(initial_state[0]) if self.height > 0 else 0\n        else:\n            self.board = self.create_random_board()\n\n    def create_random_board(self):\n        \"\"\"\n        Creates a random board with the specified density of live cells.\n\n        Returns:\n            list[list[int]]: A 2D list representing the game board.\n        \"\"\"\n        board = []\n        for _ in range(self.height):\n            row = [1 if random.random() < self.density else 0 for _ in range(self.width)]\n            board.append(row)\n        return board\n\n    def get_neighbors(self, row, col):\n        \"\"\"\n        Gets the neighboring cells of a given cell.\n\n        Args:\n            row (int): The row index of the cell.\n            col (int): The column index of the cell.\n\n        Returns:\n            list[int]: A list of the neighbor cell states (0 or 1).\n        \"\"\"\n        neighbors = []\n        for i in range(max(0, row - 1), min(self.height, row + 2)):\n            for j in range(max(0, col - 1), min(self.width, col + 2)):\n                if i != row or j != col:\n                    neighbors.append(self.board[i][j])\n        return neighbors\n\n    def get_next_state(self, row, col):\n        \"\"\"\n        Determines the next state of a cell based on Conway's rules.\n\n        Args:\n            row (int): The row index of the cell.\n            col (int): The column index of the cell.\n\n        Returns:\n            int: The next state of the cell (0 or 1).\n        \"\"\"\n        neighbors = self.get_neighbors(row, col)\n        alive_neighbors = sum(neighbors)\n        if self.board[row][col] == 1:  # Alive cell\n            if alive_neighbors < 2 or alive_neighbors > 3:\n                return 0  # Dies due to underpopulation or overpopulation\n            else:\n                return 1  # Survives\n        else:  # Dead cell\n            if alive_neighbors == 3:\n                return 1  # Becomes alive due to reproduction\n            else:\n                return 0  # Remains dead\n\n    def update_board(self):\n        \"\"\"\n        Updates the game board to the next generation.\n        \"\"\"\n        next_board = []\n        for row in range(self.height):\n            next_row = [self.get_next_state(row, col) for col in range(self.width)]\n            next_board.append(next_row)\n        self.board = next_board\n\n    def print_board(self):\n        \"\"\"\n        Prints the current state of the game board to the console.\n        \"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n        for row in self.board:\n            print(\"\".join(['#' if cell == 1 else ' ' for cell in row]))\n\n    def run(self, generations, delay):\n        \"\"\"\n        Runs the Game of Life for a specified number of generations.\n\n        Args:\n            generations (int): The number of generations to run.\n            delay (float): The delay between each generation (in seconds).\n        \"\"\"\n        for _ in range(generations):\n            self.print_board()\n            self.update_board()\n            time.sleep(delay)\n\n\ndef main():\n    \"\"\"\n    Main function to parse command-line arguments and run the Game of Life.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=\"Conway's Game of Life\")\n    parser.add_argument(\"--width\", type=int, default=60, help=\"Width of the board\")\n    parser.add_argument(\"--height\", type=int, default=30, help=\"Height of the board\")\n    parser.add_argument(\"--generations\", type=int, default=100, help=\"Number of generations to run\")\n    parser.add_argument(\"--delay\", type=float, default=0.1, help=\"Delay between generations (seconds)\")\n    parser.add_argument(\"--density\", type=float, default=0.5, help=\"Initial density of live cells\")\n    parser.add_argument(\"--initial_state\", type=str, default=None, help=\"Path to a file containing an initial state. Should be a text file with 0 and 1 representing dead and alive cells, respectively.\")\n\n    args = parser.parse_args()\n\n    initial_state = None\n    if args.initial_state:\n        try:\n            with open(args.initial_state, 'r') as f:\n                initial_state = []\n                for line in f:\n                    row = [int(cell) for cell in line.strip()]\n                    initial_state.append(row)\n        except FileNotFoundError:\n            print(f\"Error: File not found: {args.initial_state}\")\n            return\n        except ValueError:\n            print(f\"Error: Invalid initial state file.  Must contain only 0s and 1s.\")\n            return",
    "8": "```python\nimport numpy as np\n\nclass ConnectFour:\n    \"\"\"\n    A class to represent the Connect Four game.\n    \"\"\"\n\n    def __init__(self, rows=6, cols=7):\n        \"\"\"\n        Initializes the Connect Four board.\n\n        Args:\n            rows (int): The number of rows on the board.\n            cols (int): The number of columns on the board.\n        \"\"\"\n        self.rows = rows\n        self.cols = cols\n        self.board = np.zeros((rows, cols), dtype=int)  # 0: empty, 1: player 1, 2: player 2\n        self.player = 1  # Player 1 starts\n        self.game_over = False\n\n    def print_board(self):\n        \"\"\"\n        Prints the current state of the board to the console.\n        \"\"\"\n        for row in range(self.rows):\n            print(\"|\", end=\"\")\n            for col in range(self.cols):\n                if self.board[row][col] == 0:\n                    print(\"  \", end=\"|\")\n                elif self.board[row][col] == 1:\n                    print(\"X \", end=\"|\")\n                else:\n                    print(\"O \", end=\"|\")\n            print()\n        print(\"-\" * (self.cols * 3 + 1))\n        print(\" \", end=\"\")\n        for col in range(self.cols):\n            print(col + 1, end=\"  \")  # Numbering columns for user input\n        print()\n\n\n    def is_valid_move(self, col):\n        \"\"\"\n        Checks if a move (column) is valid.\n\n        Args:\n            col (int): The column number to check.\n\n        Returns:\n            bool: True if the move is valid, False otherwise.\n        \"\"\"\n        return 0 <= col < self.cols and self.board[0][col] == 0\n\n    def drop_piece(self, col):\n        \"\"\"\n        Drops a piece into the specified column.\n\n        Args:\n            col (int): The column number to drop the piece into.\n\n        Returns:\n            bool: True if the piece was dropped successfully, False otherwise.\n        \"\"\"\n        if not self.is_valid_move(col):\n            return False\n\n        for row in range(self.rows - 1, -1, -1):\n            if self.board[row][col] == 0:\n                self.board[row][col] = self.player\n                return True\n        return False  # Should not happen if is_valid_move is used correctly.\n\n\n    def check_win(self):\n        \"\"\"\n        Checks if the current player has won the game.\n\n        Returns:\n            bool: True if the current player has won, False otherwise.\n        \"\"\"\n        # Check horizontal\n        for row in range(self.rows):\n            for col in range(self.cols - 3):\n                if (self.board[row][col] == self.player and\n                        self.board[row][col + 1] == self.player and\n                        self.board[row][col + 2] == self.player and\n                        self.board[row][col + 3] == self.player):\n                    return True\n\n        # Check vertical\n        for row in range(self.rows - 3):\n            for col in range(self.cols):\n                if (self.board[row][col] == self.player and\n                        self.board[row + 1][col] == self.player and\n                        self.board[row + 2][col] == self.player and\n                        self.board[row + 3][col] == self.player):\n                    return True\n\n        # Check positive diagonal\n        for row in range(self.rows - 3):\n            for col in range(self.cols - 3):\n                if (self.board[row][col] == self.player and\n                        self.board[row + 1][col + 1] == self.player and\n                        self.board[row + 2][col + 2] == self.player and\n                        self.board[row + 3][col + 3] == self.player):\n                    return True\n\n        # Check negative diagonal\n        for row in range(3, self.rows):\n            for col in range(self.cols - 3):\n                if (self.board[row][col] == self.player and\n                        self.board[row - 1][col + 1] == self.player and\n                        self.board[row - 2][col + 2] == self.player and\n                        self.board[row - 3][col + 3] == self.player):\n                    return True\n\n        return False\n\n\n    def check_draw(self):\n        \"\"\"\n        Checks if the game is a draw (board is full).\n\n        Returns:\n            bool: True if the game is a draw, False otherwise.\n        \"\"\"\n        return np.all(self.board != 0)\n\n\n    def switch_player(self):\n        \"\"\"\n        Switches the current player.\n        \"\"\"\n        self.player = 3 - self.player  # Switches between 1 and 2\n\n\n    def play_game(self):\n        \"\"\"\n        The main game loop.\n        \"\"\"\n        while not self.game_over:\n            self.print_board()\n            print(f\"Player {self.player}, it's your turn.\")\n\n            try:\n                col = int(input(f\"Enter column (1-{self.cols}): \")) - 1  # Adjust for 0-based indexing\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n                continue\n\n            if not self.is_valid_move(col):\n                print(\"Invalid move. Please try again.\")\n                continue\n\n            self.drop_piece(col)\n\n            if self.check_win():\n                self.print_board()\n                print(f\"Player {self.player} wins!\")\n                self.game_over = True\n            elif self.check_draw():\n                self.print_board",
    "9": "```python\nimport random\n\ndef calculate_hand_value(hand):\n    \"\"\"Calculates the value of a hand in Blackjack.\n\n    Args:\n        hand: A list of strings representing the cards in the hand.\n              Each string is the card's rank (e.g., 'A', 'K', '10', '2').\n\n    Returns:\n        The integer value of the hand.  Handles Aces correctly.\n    \"\"\"\n    ace_count = hand.count('A')\n    total = 0\n    for card in hand:\n        if card.isdigit():\n            total += int(card)\n        elif card in ('J', 'Q', 'K'):\n            total += 10\n        elif card == 'A':\n            total += 11\n    while total > 21 and ace_count > 0:\n        total -= 10\n        ace_count -= 1\n    return total\n\n\ndef deal_card(deck):\n    \"\"\"Deals a card from the deck.\n\n    Args:\n        deck: A list of strings representing the deck of cards.\n\n    Returns:\n        A tuple containing:\n            - The card dealt (string).\n            - The updated deck (list).\n    \"\"\"\n    card = deck.pop()\n    return card, deck\n\n\ndef create_deck():\n    \"\"\"Creates a standard 52-card deck.\n\n    Returns:\n        A list of strings representing the deck of cards, shuffled.\n    \"\"\"\n    suits = ['Hearts', 'Diamonds', 'Clubs', 'Spades']\n    ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']\n    deck = [rank for rank in ranks for suit in suits]\n    random.shuffle(deck)\n    return deck\n\n\ndef display_hand(hand, is_dealer=False, hide_first_card=False):\n    \"\"\"Displays a hand of cards.\n\n    Args:\n        hand: A list of strings representing the cards in the hand.\n        is_dealer: Boolean, True if the hand is the dealer's.\n        hide_first_card: Boolean, True if the dealer's first card should be hidden.\n    \"\"\"\n    if is_dealer and hide_first_card:\n        print(\"Dealer's Hand: [Hidden],\", ', '.join(hand[1:]))\n    else:\n        print(\"Dealer's Hand:\" if is_dealer else \"Your Hand:\", ', '.join(hand))\n\ndef play_blackjack():\n    \"\"\"Plays a game of Blackjack.\"\"\"\n\n    deck = create_deck()\n    player_hand = []\n    dealer_hand = []\n\n    # Deal initial hands\n    for _ in range(2):\n        card, deck = deal_card(deck)\n        player_hand.append(card)\n        card, deck = deal_card(deck)\n        dealer_hand.append(card)\n\n    player_value = calculate_hand_value(player_hand)\n    dealer_value = calculate_hand_value(dealer_hand)\n\n    print(\"\\nWelcome to Blackjack!\")\n    display_hand(player_hand)\n    display_hand(dealer_hand, is_dealer=True, hide_first_card=True)\n    print(f\"Your hand value: {player_value}\")\n\n\n    # Player's turn\n    while player_value < 21:\n        action = input(\"Hit or Stand? (h/s): \").lower()\n        if action == 'h':\n            card, deck = deal_card(deck)\n            player_hand.append(card)\n            player_value = calculate_hand_value(player_hand)\n            display_hand(player_hand)\n            print(f\"Your hand value: {player_value}\")\n            if player_value > 21:\n                print(\"Bust! You lose.\")\n                return\n        elif action == 's':\n            break\n        else:\n            print(\"Invalid input. Please enter 'h' or 's'.\")\n\n    # Dealer's turn\n    if player_value <= 21:\n        print(\"\\nDealer's turn...\")\n        display_hand(dealer_hand, is_dealer=True)\n        print(f\"Dealer's hand value: {dealer_value}\")\n\n        while dealer_value < 17:\n            print(\"Dealer hits.\")\n            card, deck = deal_card(deck)\n            dealer_hand.append(card)\n            dealer_value = calculate_hand_value(dealer_hand)\n            display_hand(dealer_hand, is_dealer=True)\n            print(f\"Dealer's hand value: {dealer_value}\")\n            if dealer_value > 21:\n                print(\"Dealer busts! You win!\")\n                return\n\n        # Determine the winner\n        print(\"\\nFinal Results:\")\n        display_hand(player_hand)\n        print(f\"Your hand value: {player_value}\")\n        display_hand(dealer_hand, is_dealer=True)\n        print(f\"Dealer's hand value: {dealer_value}\")\n\n        if dealer_value > player_value:\n            print(\"Dealer wins!\")\n        elif dealer_value == player_value:\n            print(\"Push! (Tie)\")\n        else:\n            print(\"You win!\")\n\n\nif __name__ == \"__main__\":\n    play_blackjack()\n```",
    "10": "```python\nimport random\n\ndef play_hammurabi():\n    \"\"\"Plays the game Hammurabi.\"\"\"\n\n    years_passed = 0\n    population = 100\n    grain_stores = 2800\n    acres_owned = 1000\n    bushels_per_acre = 3  # Initial yield\n\n    print(\"Congratulations, you are the new ruler of Sumeria!\\n\")\n\n    while years_passed < 10:\n        years_passed += 1\n        print(f\"Year {years_passed}, O great Hammurabi!\\n\")\n        print(f\"You are in control of {population} people.\")\n        print(f\"You have {grain_stores} bushels of grain in storage.\")\n        print(f\"You own {acres_owned} acres of land.\")\n        print(f\"Land yields {bushels_per_acre} bushels per acre.\\n\")\n\n        # Ask the user how much land to buy/sell\n        while True:\n            try:\n                acres_to_buy_sell = int(input(\"How many acres do you wish to buy/sell? \"))\n                if acres_to_buy_sell < 0:  # Selling\n                    if abs(acres_to_buy_sell) > acres_owned:\n                        print(\"You do not have that many acres to sell.\")\n                        continue\n                elif acres_to_buy_sell > 0:  # Buying\n                    cost_per_acre = random.randint(17, 27)\n                    cost = acres_to_buy_sell * cost_per_acre\n                    if cost > grain_stores:\n                        print(\"You do not have enough grain to buy that much land.\")\n                        continue\n                break  # Valid input\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n        # Perform the land transaction\n        if acres_to_buy_sell > 0:  # Buying\n            cost_per_acre = random.randint(17, 27)\n            cost = acres_to_buy_sell * cost_per_acre\n            acres_owned += acres_to_buy_sell\n            grain_stores -= cost\n            print(f\"You bought {acres_to_buy_sell} acres for {cost} bushels.\")\n        elif acres_to_buy_sell < 0:  # Selling\n            sale_price_per_acre = random.randint(17, 27)\n            revenue = abs(acres_to_buy_sell) * sale_price_per_acre\n            acres_owned += acres_to_buy_sell\n            grain_stores += revenue\n            print(f\"You sold {abs(acres_to_buy_sell)} acres for {revenue} bushels.\")\n\n\n        # Ask how much grain to feed the people\n        while True:\n            try:\n                grain_to_feed = int(input(\"How many bushels do you wish to feed your people? \"))\n                if grain_to_feed > grain_stores:\n                    print(\"You do not have that much grain.\")\n                    continue\n                break\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n        # Feed the people\n        grain_stores -= grain_to_feed\n        bushels_per_person = grain_to_feed / population\n\n        if bushels_per_person < 0.2:\n            starved = int(population * (1 - bushels_per_person / 0.2))\n            print(f\"{starved} people starved!\")\n            population -= starved\n            if population <= 0:\n                print(\"You starved all your people! Your reign is over!\")\n                return\n            if starved > 0.45 * population:  # 45% died\n                print(\"Your people have overthrown you in a revolt!\")\n                return\n        else:\n            starved = 0\n            print(\"Your people are well fed.\")\n\n        # Ask how much land to plant\n        while True:\n            try:\n                acres_to_plant = int(input(\"How many acres do you wish to plant with grain? \"))\n                if acres_to_plant > acres_owned:\n                    print(\"You do not have that much land.\")\n                    continue\n                if acres_to_plant * 2 > grain_stores:  # Need 2 bushels per acre\n                    print(\"You do not have enough grain to plant that much land.\")\n                    continue\n                break\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n        # Plant the grain\n        grain_stores -= acres_to_plant * 2\n\n        # Harvest\n        bushels_per_acre = random.randint(1, 8)  # Variable yield\n        harvest = acres_to_plant * bushels_per_acre\n        grain_stores += harvest\n        print(f\"You harvested {harvest} bushels of grain.\")\n\n        # Plague\n        if random.random() < 0.15:  # 15% chance of plague\n            deaths = int(population / 2)\n            population -= deaths\n            print(\"A horrible plague struck! Half your people died.\")\n            if population <= 0:\n                print(\"All your people died! Your reign is over!\")\n                return\n\n        # Rats\n        rat_infestation = random.uniform(0.1, 0.3)  # 10-30% of grain eaten\n        eaten_by_rats = int(grain_stores * rat_infestation)\n        grain_stores -= eaten_by_rats\n        print(f\"Rats ate {eaten_by_rats} bushels of grain.\")\n\n        # Immigration\n        immigrants = int(0.1 * (5 * acres_owned + grain_stores) / population)\n        population += immigrants\n        print(f\"{immigrants} people came to the city.\")\n\n    # End of game\n    print(\"\\nYour reign has ended.\")\n    print(f\"You ruled for {years_passed} years.\")\n    print(f\"At the end of your reign, you had {population} people.\")\n    print(f\"You had {acres_owned} acres of land.\")\n    print(f\"You had {",
    "11": "```python\nimport random\n\nclass LightsOut:\n    \"\"\"\n    A class to represent the Lights Out game.\n    \"\"\"\n\n    def __init__(self, size=5, initial_state=None):\n        \"\"\"\n        Initializes the game with a given size and optional initial state.\n\n        Args:\n            size (int): The size of the game board (size x size). Defaults to 5.\n            initial_state (list): A list of lists representing the initial state of the board.\n                                  If None, a random initial state is generated.\n        \"\"\"\n        self.size = size\n        if initial_state:\n            if len(initial_state) != size or any(len(row) != size for row in initial_state):\n                raise ValueError(\"Initial state must be a {0}x{0} matrix\".format(size))\n            self.board = [list(row) for row in initial_state] # Create a deep copy\n        else:\n            self.board = self._generate_random_board()\n\n    def _generate_random_board(self):\n        \"\"\"\n        Generates a random initial state for the board.\n\n        Returns:\n            list: A list of lists representing the randomly generated board.\n        \"\"\"\n        board = [[random.choice([0, 1]) for _ in range(self.size)] for _ in range(self.size)]\n        return board\n\n    def print_board(self):\n        \"\"\"\n        Prints the current state of the board to the console.\n        \"\"\"\n        for row in self.board:\n            print(\" \".join(map(str, row)))\n\n    def toggle(self, row, col):\n        \"\"\"\n        Toggles the state of a cell at the given row and column.\n\n        Args:\n            row (int): The row index of the cell to toggle.\n            col (int): The column index of the cell to toggle.\n        \"\"\"\n        if 0 <= row < self.size and 0 <= col < self.size:\n            self.board[row][col] = 1 - self.board[row][col]\n\n    def make_move(self, row, col):\n        \"\"\"\n        Makes a move by toggling the state of the cell at (row, col) and its neighbors.\n\n        Args:\n            row (int): The row index of the cell to click.\n            col (int): The column index of the cell to click.\n        \"\"\"\n        self.toggle(row, col)       # Toggle the cell itself\n        self.toggle(row - 1, col)   # Toggle the cell above\n        self.toggle(row + 1, col)   # Toggle the cell below\n        self.toggle(row, col - 1)   # Toggle the cell to the left\n        self.toggle(row, col + 1)   # Toggle the cell to the right\n\n    def is_solved(self):\n        \"\"\"\n        Checks if the game is solved (all lights are off).\n\n        Returns:\n            bool: True if the game is solved, False otherwise.\n        \"\"\"\n        return all(all(cell == 0 for cell in row) for row in self.board)\n\n    def play(self):\n        \"\"\"\n        Plays the game with the user via command line interface.\n        \"\"\"\n        print(\"Welcome to Lights Out!\")\n        self.print_board()\n\n        while not self.is_solved():\n            try:\n                move = input(\"Enter your move (row, col) or 'q' to quit: \").lower()\n                if move == 'q':\n                    print(\"Quitting the game.\")\n                    return\n\n                row, col = map(int, move.split(','))\n\n                if not (0 <= row < self.size and 0 <= col < self.size):\n                    print(\"Invalid move. Row and column must be between 0 and {}.\".format(self.size - 1))\n                    continue\n\n                self.make_move(row, col)\n                self.print_board()\n\n            except ValueError:\n                print(\"Invalid input. Please enter row and column separated by a comma (e.g., 0,1).\")\n            except Exception as e:\n                print(f\"An error occurred: {e}\")\n\n        print(\"Congratulations! You solved the puzzle!\")\n\n\nif __name__ == \"__main__\":\n    game = LightsOut()  # You can specify the size: LightsOut(size=7)\n    game.play()\n```",
    "12": "```python\nimport time\nimport random\nimport os\n\nclass Pong:\n    def __init__(self, width=80, height=20, paddle_length=3, ball_speed=1, paddle_speed=1):\n        self.width = width\n        self.height = height\n        self.paddle_length = paddle_length\n        self.ball_speed = ball_speed\n        self.paddle_speed = paddle_speed\n\n        self.paddle1_pos = height // 2 - paddle_length // 2\n        self.paddle2_pos = height // 2 - paddle_length // 2\n        self.ball_x = width // 2\n        self.ball_y = height // 2\n        self.ball_dx = random.choice([-1, 1]) * self.ball_speed\n        self.ball_dy = random.choice([-1, 1]) * self.ball_speed\n        self.score1 = 0\n        self.score2 = 0\n        self.running = True\n\n    def update(self):\n        \"\"\"Updates the game state.\"\"\"\n\n        # Ball movement\n        self.ball_x += self.ball_dx\n        self.ball_y += self.ball_dy\n\n        # Wall collision\n        if self.ball_y <= 0 or self.ball_y >= self.height - 1:\n            self.ball_dy *= -1\n\n        # Paddle collision\n        if self.ball_x <= 1:\n            if self.paddle1_pos <= self.ball_y <= self.paddle1_pos + self.paddle_length - 1:\n                self.ball_dx *= -1\n                # Add some randomness to the ball's vertical direction after hitting the paddle\n                self.ball_dy += random.uniform(-0.5, 0.5)\n                # Limit the vertical speed to prevent extreme angles\n                self.ball_dy = max(min(self.ball_dy, 1.5), -1.5)  # Limit to +/- 1.5\n            else:\n                self.score2 += 1\n                self.reset_ball()\n        elif self.ball_x >= self.width - 2:\n            if self.paddle2_pos <= self.ball_y <= self.paddle2_pos + self.paddle_length - 1:\n                self.ball_dx *= -1\n                # Add some randomness to the ball's vertical direction after hitting the paddle\n                self.ball_dy += random.uniform(-0.5, 0.5)\n                # Limit the vertical speed to prevent extreme angles\n                self.ball_dy = max(min(self.ball_dy, 1.5), -1.5) # Limit to +/- 1.5\n            else:\n                self.score1 += 1\n                self.reset_ball()\n\n        # Check for game over\n        if self.score1 >= 10 or self.score2 >= 10:\n            self.running = False\n\n    def move_paddle1(self, direction):\n        \"\"\"Moves paddle 1 up or down.\"\"\"\n        if direction == \"up\":\n            self.paddle1_pos = max(0, self.paddle1_pos - self.paddle_speed)\n        elif direction == \"down\":\n            self.paddle1_pos = min(self.height - self.paddle_length, self.paddle1_pos + self.paddle_speed)\n\n    def move_paddle2(self, direction):\n        \"\"\"Moves paddle 2 up or down.\"\"\"\n        if direction == \"up\":\n            self.paddle2_pos = max(0, self.paddle2_pos - self.paddle_speed)\n        elif direction == \"down\":\n            self.paddle2_pos = min(self.height - self.paddle_length, self.paddle2_pos + self.paddle_speed)\n\n    def reset_ball(self):\n        \"\"\"Resets the ball to the center after a point.\"\"\"\n        self.ball_x = self.width // 2\n        self.ball_y = self.height // 2\n        self.ball_dx = random.choice([-1, 1]) * self.ball_speed\n        self.ball_dy = random.choice([-1, 1]) * self.ball_speed\n\n    def draw(self):\n        \"\"\"Draws the game state to the console.\"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n\n        # Create the playing field\n        field = [[' ' for _ in range(self.width)] for _ in range(self.height)]\n\n        # Draw paddles\n        for i in range(self.paddle_length):\n            if 0 <= self.paddle1_pos + i < self.height:\n                field[self.paddle1_pos + i][0] = '█'\n            if 0 <= self.paddle2_pos + i < self.height:\n                field[self.paddle2_pos + i][self.width - 1] = '█'\n\n\n        # Draw ball\n        if 0 <= self.ball_y < self.height and 0 <= self.ball_x < self.width:\n            field[int(self.ball_y)][int(self.ball_x)] = 'O'\n\n        # Print the field\n        print(\"-\" * self.width)  # Top border\n        for row in field:\n            print(\"|\" + \"\".join(row[1:-1]) + \"|\") # Side borders\n        print(\"-\" * self.width)  # Bottom border\n\n        # Print the score\n        print(f\"Score: Player 1: {self.score1}  Player 2: {self.score2}\")\n\n    def play(self):\n        \"\"\"Main game loop.\"\"\"\n        while self.running:\n            self.draw()\n            self.update()\n\n            # Get input for paddle 1\n            p1_move = input(\"Player 1 (w/s): \").lower()\n            if p1_move == \"w\":\n                self.move_paddle1(\"up\")\n            elif p1_move == \"s",
    "13": "```python\nimport random\nimport os\nimport sys\n\nclass Tetris:\n    \"\"\"\n    A command-line Tetris game.\n    \"\"\"\n\n    WIDTH = 10\n    HEIGHT = 20\n    PIECES = {\n        'I': [[(0, 0), (0, 1), (0, 2), (0, 3)], [(0, 0), (1, 0), (2, 0), (3, 0)]],\n        'O': [[(0, 0), (0, 1), (1, 0), (1, 1)]],\n        'T': [[(0, 0), (1, 0), (2, 0), (1, 1)], [(0, 0), (0, 1), (0, 2), (1, 1)],\n              [(1, 0), (0, 1), (1, 1), (2, 1)], [(1, 0), (1, 1), (1, 2), (0, 1)]],\n        'S': [[(1, 0), (2, 0), (0, 1), (1, 1)], [(0, 0), (0, 1), (1, 1), (1, 2)]],\n        'Z': [[(0, 0), (1, 0), (1, 1), (2, 1)], [(1, 0), (0, 1), (1, 1), (0, 2)]],\n        'L': [[(0, 0), (0, 1), (0, 2), (1, 2)], [(0, 0), (1, 0), (2, 0), (0, 1)],\n              [(0, 0), (1, 0), (1, 1), (1, 2)], [(2, 0), (0, 1), (1, 1), (2, 1)]],\n        'J': [[(1, 0), (1, 1), (1, 2), (0, 2)], [(0, 0), (1, 0), (2, 0), (2, 1)],\n              [(0, 0), (0, 1), (0, 2), (1, 0)], [(0, 0), (0, 1), (1, 1), (2, 1)]]\n    }\n    EMPTY = '.'\n    FILLED = '#'\n\n    def __init__(self):\n        self.board = [[self.EMPTY for _ in range(self.WIDTH)] for _ in range(self.HEIGHT)]\n        self.current_piece = None\n        self.current_x = 0\n        self.current_y = 0\n        self.current_rotation = 0\n        self.game_over = False\n        self.score = 0\n        self.level = 1\n        self.lines_cleared = 0\n        self.next_piece_type = random.choice(list(self.PIECES.keys()))\n        self.new_piece()\n\n    def new_piece(self):\n        \"\"\"\n        Generates a new piece at the top of the board.\n        \"\"\"\n        self.current_piece_type = self.next_piece_type\n        self.next_piece_type = random.choice(list(self.PIECES.keys()))\n        self.current_piece = self.PIECES[self.current_piece_type]\n        self.current_rotation = 0\n        self.current_x = self.WIDTH // 2 - 2  # Center the piece\n        self.current_y = 0\n\n        if self.check_collision(self.current_piece[self.current_rotation], self.current_x, self.current_y):\n            self.game_over = True\n\n    def rotate(self):\n        \"\"\"\n        Rotates the current piece clockwise.\n        \"\"\"\n        new_rotation = (self.current_rotation + 1) % len(self.current_piece)\n        if not self.check_collision(self.current_piece[new_rotation], self.current_x, self.current_y):\n            self.current_rotation = new_rotation\n\n    def move(self, dx):\n        \"\"\"\n        Moves the current piece horizontally.\n        \"\"\"\n        new_x = self.current_x + dx\n        if not self.check_collision(self.current_piece[self.current_rotation], new_x, self.current_y):\n            self.current_x = new_x\n\n    def drop(self):\n        \"\"\"\n        Moves the current piece down one row. If it collides, lock it in place\n        and generate a new piece.\n        \"\"\"\n        new_y = self.current_y + 1\n        if not self.check_collision(self.current_piece[self.current_rotation], self.current_x, new_y):\n            self.current_y = new_y\n            return False  # Piece moved down\n        else:\n            self.lock_piece()\n            self.clear_lines()\n            self.new_piece()\n            return True  # Piece locked\n\n    def check_collision(self, piece_shape, x, y):\n        \"\"\"\n        Checks if the given piece shape collides with the board at the given\n        position.\n        \"\"\"\n        for px, py in piece_shape:\n            board_x = x + px\n            board_y = y + py\n\n            if board_x < 0 or board_x >= self.WIDTH or board_y >= self.HEIGHT:\n                return True  # Out of bounds\n            if board_y >= 0 and self.board[board_y][board_x] != self.EMPTY:\n                return True  # Collision with existing block\n        return False\n\n    def lock_piece(self):\n        \"\"\"\n        Locks the current piece into the board.\n        \"\"\"\n        for px, py in self.current_piece[self.current_rotation]:",
    "14": "```python\nimport math\nimport random\nimport time\nimport sys\n\nclass GameObject:\n    def __init__(self, x, y, velocity_x, velocity_y, radius=0):\n        self.x = x\n        self.y = y\n        self.velocity_x = velocity_x\n        self.velocity_y = velocity_y\n        self.radius = radius\n\n    def update(self, width, height):\n        self.x += self.velocity_x\n        self.y += self.velocity_y\n\n        # Wrap around the screen\n        if self.x < 0:\n            self.x = width\n        elif self.x > width:\n            self.x = 0\n        if self.y < 0:\n            self.y = height\n        elif self.y > height:\n            self.y = 0\n\n    def distance_to(self, other):\n        return math.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)\n\nclass Asteroid(GameObject):\n    def __init__(self, x, y, velocity_x, velocity_y, size):\n        super().__init__(x, y, velocity_x, velocity_y, radius=size * 5)\n        self.size = size  # 1 (large), 2 (medium), 3 (small)\n\n    def split(self):\n        if self.size > 1:\n            # Create two smaller asteroids\n            new_size = self.size - 1\n            angle1 = random.uniform(0, 2 * math.pi)\n            angle2 = random.uniform(0, 2 * math.pi)\n            speed = 1.5 * math.sqrt(self.velocity_x**2 + self.velocity_y**2) #Increase speed\n\n            new_asteroid1 = Asteroid(self.x, self.y, speed * math.cos(angle1), speed * math.sin(angle1), new_size)\n            new_asteroid2 = Asteroid(self.x, self.y, speed * math.cos(angle2), speed * math.sin(angle2), new_size)\n            return [new_asteroid1, new_asteroid2]\n        else:\n            return []\n\nclass Ship(GameObject):\n    def __init__(self, x, y):\n        super().__init__(x, y, 0, 0, radius=5)\n        self.rotation = 0  # Radians\n        self.acceleration = 0.2\n        self.rotation_speed = 0.1\n        self.is_accelerating = False\n        self.is_rotating_left = False\n        self.is_rotating_right = False\n        self.alive = True\n\n    def update(self, width, height):\n        if self.is_accelerating:\n            self.velocity_x += self.acceleration * math.cos(self.rotation)\n            self.velocity_y += self.acceleration * math.sin(self.rotation)\n\n            # Limit speed\n            speed = math.sqrt(self.velocity_x**2 + self.velocity_y**2)\n            max_speed = 5\n            if speed > max_speed:\n                self.velocity_x = (self.velocity_x / speed) * max_speed\n                self.velocity_y = (self.velocity_y / speed) * max_speed\n\n        # Apply friction\n        self.velocity_x *= 0.99\n        self.velocity_y *= 0.99\n\n        if self.is_rotating_left:\n            self.rotation -= self.rotation_speed\n        if self.is_rotating_right:\n            self.rotation += self.rotation_speed\n\n        super().update(width, height)\n\n    def shoot(self):\n        # Create a bullet\n        bullet_speed = 10\n        bullet_x = self.x + self.radius * math.cos(self.rotation)\n        bullet_y = self.y + self.radius * math.sin(self.rotation)\n        bullet_velocity_x = self.velocity_x + bullet_speed * math.cos(self.rotation)\n        bullet_velocity_y = self.velocity_y + bullet_speed * math.sin(self.rotation)\n        return Bullet(bullet_x, bullet_y, bullet_velocity_x, bullet_velocity_y)\n\nclass Bullet(GameObject):\n    def __init__(self, x, y, velocity_x, velocity_y):\n        super().__init__(x, y, velocity_x, velocity_y, radius=2)\n        self.lifetime = 60 # Frames before bullet disappears\n\n    def update(self, width, height):\n        super().update(width, height)\n        self.lifetime -= 1\n\n        # Bullet disappears if lifetime is over\n        if self.lifetime <= 0 :\n            self.x = -1000 # Place bullet far off screen so it doesn't interfere\n\nclass Game:\n    def __init__(self, width=80, height=24):\n        self.width = width\n        self.height = height\n        self.ship = Ship(width // 2, height // 2)\n        self.asteroids = []\n        self.bullets = []\n        self.score = 0\n        self.game_over = False\n        self.lives = 3\n        self.level = 1\n        self.last_asteroid_spawn = 0\n        self.min_asteroid_spawn_interval = 5\n\n    def start_new_game(self):\n        self.ship = Ship(self.width // 2, self.height // 2)\n        self.asteroids = []\n        self.bullets = []\n        self.score = 0\n        self.game_over = False\n        self.lives = 3\n        self.level = 1\n        self.last_asteroid_spawn = 0\n        self.min_asteroid_spawn_interval = 5\n        self.spawn_asteroids(self.level + 3) # Start with a few asteroids\n\n    def spawn_aster",
    "15": "```python\nimport random\nimport time\n\nclass Boggle:\n    def __init__(self, size=4, duration=180):\n        self.size = size\n        self.duration = duration\n        self.board = self.generate_board()\n        self.words = set()\n        self.dictionary = self.load_dictionary(\"dictionary.txt\")  # Replace with your dictionary file\n        self.score = 0\n        self.start_time = None\n        self.game_over = False\n\n    def generate_board(self):\n        dice = [\n            \"RIFOBX\", \"IFEHIE\", \"DENOWS\", \"UTOKNG\",\n            \"HMRSAO\", \"LUPETS\", \"ACITOA\", \"YLGKUE\",\n            \"QBMJOA\", \"EHISPN\", \"VETIGN\", \"ASREIL\",\n            \"PPCSEA\", \"TSIOET\", \"SCTIEP\", \"NDTHRO\"\n        ]\n        board = []\n        for i in range(self.size):\n            row = []\n            for j in range(self.size):\n                die = random.choice(dice)\n                row.append(random.choice(die))\n            board.append(row)\n        return board\n\n    def load_dictionary(self, filename):\n        try:\n            with open(filename, \"r\") as f:\n                return set(word.strip().upper() for word in f)\n        except FileNotFoundError:\n            print(f\"Error: Dictionary file '{filename}' not found. Please create or provide a valid dictionary file.\")\n            exit()\n\n    def print_board(self):\n        for row in self.board:\n            print(\" \".join(row))\n\n    def is_valid_word(self, word):\n        return (\n            len(word) >= 3\n            and word.upper() in self.dictionary\n            and word not in self.words\n            and self.find_word_on_board(word)\n        )\n\n    def find_word_on_board(self, word):\n        word = word.upper()\n        for row in range(self.size):\n            for col in range(self.size):\n                if self.board[row][col] == word[0] and self.search_recursive(word, row, col, 0, set()):\n                    return True\n        return False\n\n    def search_recursive(self, word, row, col, index, visited):\n        if index == len(word):\n            return True\n\n        if (\n            row < 0\n            or row >= self.size\n            or col < 0\n            or col >= self.size\n            or self.board[row][col] != word[index]\n            or (row, col) in visited\n        ):\n            return False\n\n        visited.add((row, col))\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                new_row = row + dr\n                new_col = col + dc\n                if self.search_recursive(word, new_row, new_col, index + 1, visited.copy()):\n                    return True\n\n        return False\n\n    def play(self):\n        self.start_time = time.time()\n        print(\"Welcome to Boggle!\")\n        self.print_board()\n\n        while not self.game_over:\n            elapsed_time = time.time() - self.start_time\n            remaining_time = max(0, self.duration - int(elapsed_time))\n            print(f\"\\nTime remaining: {remaining_time} seconds\")\n\n            if remaining_time == 0:\n                self.game_over = True\n                break\n\n            word = input(\"Enter a word (or 'quit' to end): \").strip()\n            if word.lower() == \"quit\":\n                self.game_over = True\n                break\n\n            if self.is_valid_word(word):\n                self.words.add(word.upper())\n                self.score += len(word) - 2  # Scoring: 3-letter word = 1 point, 4 = 2, etc.\n                print(f\"Valid word! Score: {self.score}\")\n            else:\n                print(\"Invalid word. Try again.\")\n\n        print(\"\\nGame Over!\")\n        print(f\"Final Score: {self.score}\")\n        print(\"Words found:\")\n        for word in sorted(self.words):\n            print(word)\n\n\nif __name__ == \"__main__\":\n    # Create a simple dictionary file for testing (dictionary.txt)\n    # with one word per line, all uppercase\n    # Example:\n    # CAT\n    # DOG\n    # CODE\n    # PYTHON\n    # etc.\n\n    game = Boggle()\n    game.play()\n```",
    "16": "```python\nimport random\nimport time\nimport os\n\nclass PacManGame:\n    def __init__(self, width=20, height=10):\n        self.width = width\n        self.height = height\n        self.pacman_x = width // 2\n        self.pacman_y = height // 2\n        self.ghost_x = random.randint(1, width - 2)\n        self.ghost_y = random.randint(1, height - 2)\n        self.food = set()\n        for x in range(1, width - 1):\n            for y in range(1, height - 1):\n                self.food.add((x, y))\n        self.food.remove((self.pacman_x, self.pacman_y))\n        self.score = 0\n        self.game_over = False\n        self.last_move = None\n\n    def display(self):\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear screen\n        grid = [[' ' for _ in range(self.width)] for _ in range(self.height)]\n\n        # Draw walls\n        for x in range(self.width):\n            grid[0][x] = '#'\n            grid[self.height - 1][x] = '#'\n        for y in range(self.height):\n            grid[y][0] = '#'\n            grid[y][self.width - 1] = '#'\n\n        # Draw food\n        for x, y in self.food:\n            grid[y][x] = '.'\n\n        # Draw Pac-Man\n        grid[self.pacman_y][self.pacman_x] = 'P'\n\n        # Draw Ghost\n        grid[self.ghost_y][self.ghost_x] = 'G'\n\n        # Print the grid\n        for row in grid:\n            print(''.join(row))\n\n        print(f\"Score: {self.score}\")\n\n    def move_pacman(self, direction):\n        new_x, new_y = self.pacman_x, self.pacman_y\n\n        if direction == 'w':  # Up\n            new_y -= 1\n        elif direction == 's':  # Down\n            new_y += 1\n        elif direction == 'a':  # Left\n            new_x -= 1\n        elif direction == 'd':  # Right\n            new_x += 1\n        else:\n            return  # Invalid move\n\n        if 0 < new_x < self.width - 1 and 0 < new_y < self.height - 1:\n            self.pacman_x = new_x\n            self.pacman_y = new_y\n            self.last_move = direction\n\n            if (self.pacman_x, self.pacman_y) in self.food:\n                self.food.remove((self.pacman_x, self.pacman_y))\n                self.score += 10\n\n            if self.pacman_x == self.ghost_x and self.pacman_y == self.ghost_y:\n                self.game_over = True\n\n\n    def move_ghost(self):\n        possible_moves = []\n        if self.ghost_x > 1 and (self.ghost_x - 1, self.ghost_y) != (self.pacman_x, self.pacman_y):\n            possible_moves.append('a')\n        if self.ghost_x < self.width - 2 and (self.ghost_x + 1, self.ghost_y) != (self.pacman_x, self.pacman_y):\n            possible_moves.append('d')\n        if self.ghost_y > 1 and (self.ghost_x, self.ghost_y - 1) != (self.pacman_x, self.pacman_y):\n            possible_moves.append('w')\n        if self.ghost_y < self.height - 2 and (self.ghost_x, self.ghost_y + 1) != (self.pacman_x, self.pacman_y):\n            possible_moves.append('s')\n\n        if possible_moves:\n            move = random.choice(possible_moves)\n\n            new_x, new_y = self.ghost_x, self.ghost_y\n\n            if move == 'w':\n                new_y -= 1\n            elif move == 's':\n                new_y += 1\n            elif move == 'a':\n                new_x -= 1\n            elif move == 'd':\n                new_x += 1\n\n            self.ghost_x = new_x\n            self.ghost_y = new_y\n            if self.pacman_x == self.ghost_x and self.pacman_y == self.ghost_y:\n                self.game_over = True\n\n    def run(self):\n        while not self.game_over and self.food:\n            self.display()\n            move = input(\"Enter move (w/a/s/d): \").lower()\n            self.move_pacman(move)\n            self.move_ghost()\n            time.sleep(0.2)\n\n        self.display()\n        if self.game_over:\n            print(\"Game Over! Ghost caught you.\")\n        else:\n            print(\"Congratulations! You ate all the food!\")\n        print(f\"Final Score: {self.score}\")\n\nif __name__ == \"__main__\":\n    game = PacManGame()\n    game.run()\n```",
    "17": "```python\nimport random\nimport time\nimport os\n\nclass Dinosaur:\n    def __init__(self, height=3, position=0):\n        self.height = height\n        self.position = position  # 0 for ground, 1 for jumping\n        self.symbol = [\"  O  \", \" /|\\\\ \", \" / \\\\ \"]\n        self.ground_level = 0\n\n    def jump(self):\n        if self.position == self.ground_level:\n            self.position = 1\n\n    def move_down(self):\n        if self.position > self.ground_level:\n            self.position -= 1\n\n    def draw(self):\n        if self.position == 0:\n            return self.symbol\n        else:\n            empty = \"     \"\n            return [empty for _ in self.symbol]\n    def get_hitbox(self):\n        return [(0, 0), (0, 1), (0, 2)] #relative to dino coordinate\n\nclass Cactus:\n    def __init__(self, position, height=2):\n        self.position = position\n        self.height = height\n        self.symbol = [\" || \", \" || \"]\n        self.hitbox = [(0,0), (0,1)] #relative to cactus coordinate\n\n    def move(self, speed):\n        self.position -= speed\n\n    def draw(self):\n        return self.symbol\n\n    def get_hitbox(self):\n        return self.hitbox\n    \nclass Game:\n    def __init__(self, width=60, dino_start_pos=5, initial_speed=1, speed_increment=0.1, jump_height=2):\n        self.width = width\n        self.dino = Dinosaur()\n        self.cactus = []\n        self.dino_start_pos = dino_start_pos\n        self.speed = initial_speed\n        self.speed_increment = speed_increment\n        self.score = 0\n        self.game_over = False\n        self.jump_height = jump_height\n        self.last_cactus_spawn_time = time.time()\n        self.cactus_spawn_interval = 2  # seconds\n\n    def spawn_cactus(self):\n        now = time.time()\n        if now - self.last_cactus_spawn_time >= self.cactus_spawn_interval:\n            self.cactus.append(Cactus(self.width - 1))\n            self.last_cactus_spawn_time = now\n\n    def move_cactus(self):\n        for c in self.cactus:\n            c.move(self.speed)\n        self.cactus = [c for c in self.cactus if c.position > 0]\n\n    def update(self):\n        self.spawn_cactus()\n        self.move_cactus()\n        self.score += self.speed\n        self.speed += self.speed_increment\n        if self.dino.position > self.dino.ground_level:\n            self.dino.move_down()\n        self.check_collision()\n\n    def check_collision(self):\n      dino_hitbox = self.dino.get_hitbox()\n      dino_x = self.dino_start_pos\n      dino_y = self.dino.position\n\n      for cactus in self.cactus:\n        cactus_hitbox = cactus.get_hitbox()\n        cactus_x = cactus.position\n        cactus_y = 0 #cactus is always on y=0\n\n        for dx, dy in dino_hitbox:\n          dino_hitbox_world_x = dino_x + dx\n          dino_hitbox_world_y = dino_y + dy\n\n          for cx, cy in cactus_hitbox:\n            cactus_hitbox_world_x = cactus_x + cx\n            cactus_hitbox_world_y = cactus_y + cy\n\n            if dino_hitbox_world_x == cactus_hitbox_world_x and dino_hitbox_world_y == cactus_hitbox_world_y:\n              self.game_over = True\n              return\n\n    def draw(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        lines = [\"\"] * 3\n\n        # Draw Dino\n        dino_drawing = self.dino.draw()\n        for i in range(len(lines)):\n            lines[i] += \" \" * self.dino_start_pos + dino_drawing[i]\n\n        # Draw Cactus\n        for cactus in self.cactus:\n            cactus_drawing = cactus.draw()\n            for i in range(len(cactus_drawing)):\n                position = int(cactus.position)\n                if position < self.width and position >= 0:  # Prevent index out of bounds\n                    lines[i+3 - len(cactus_drawing)] = lines[i+3 - len(cactus_drawing)][:position] + cactus_drawing[i] + lines[i+3 - len(cactus_drawing)][position + len(cactus_drawing[i]):]\n\n        # Draw Ground\n        lines.append(\"-\" * self.width)\n\n        # Print Everything\n        for line in lines:\n            print(line[:self.width])\n\n        print(f\"Score: {int(self.score)}\")\n\n    def run(self):\n        while not self.game_over:\n            self.draw()\n            self.update()\n            time.sleep(0.1)\n\n            # Input Handling (Non-blocking)\n            import select, sys\n\n            timeout = 0.001  # Small timeout for non-blocking input\n            rlist, _, _ = select.select([sys.stdin], [], [], timeout)\n\n            if rlist:\n                action = sys.stdin.readline().strip()\n                if action.lower() == \"jump\":\n                    self.dino.jump()\n                elif action.lower() == \"quit\":\n                    self.game_over = True\n                    break\n                else:\n                    pass #ignore other input\n\n        print(\"Game Over!\")\n        print(f"
}