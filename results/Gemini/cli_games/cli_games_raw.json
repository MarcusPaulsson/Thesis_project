{
    "0": "```python\nclass TicTacToe:\n    def __init__(self):\n        self.board = [\" \" for _ in range(9)]\n        self.current_player = \"X\"\n\n    def print_board(self):\n        \"\"\"Prints the current state of the board.\"\"\"\n        for i in range(0, 9, 3):\n            print(f\" {self.board[i]} | {self.board[i+1]} | {self.board[i+2]} \")\n            if i < 6:\n                print(\"---+---+---\")\n\n    def is_valid_move(self, position):\n        \"\"\"Checks if the given position is a valid move.\"\"\"\n        if not isinstance(position, int):\n            return False\n        if not (0 <= position <= 8):\n            return False\n        if self.board[position] != \" \":\n            return False\n        return True\n\n    def make_move(self, position):\n        \"\"\"Makes a move at the given position.\"\"\"\n        if self.is_valid_move(position):\n            self.board[position] = self.current_player\n            return True\n        else:\n            return False\n\n    def check_winner(self):\n        \"\"\"Checks if there is a winner.\"\"\"\n        # Check rows\n        for i in range(0, 9, 3):\n            if self.board[i] == self.board[i+1] == self.board[i+2] != \" \":\n                return self.board[i]\n\n        # Check columns\n        for i in range(3):\n            if self.board[i] == self.board[i+3] == self.board[i+6] != \" \":\n                return self.board[i]\n\n        # Check diagonals\n        if self.board[0] == self.board[4] == self.board[8] != \" \":\n            return self.board[0]\n        if self.board[2] == self.board[4] == self.board[6] != \" \":\n            return self.board[2]\n\n        return None\n\n    def is_board_full(self):\n        \"\"\"Checks if the board is full.\"\"\"\n        return \" \" not in self.board\n\n    def switch_player(self):\n        \"\"\"Switches the current player.\"\"\"\n        self.current_player = \"O\" if self.current_player == \"X\" else \"X\"\n\n    def play(self):\n        \"\"\"Main game loop.\"\"\"\n        print(\"Welcome to Tic-Tac-Toe!\")\n        self.print_board()\n\n        while True:\n            print(f\"Player {self.current_player}, it's your turn.\")\n            try:\n                position = int(input(\"Enter the position (0-8): \"))\n            except ValueError:\n                print(\"Invalid input. Please enter a number between 0 and 8.\")\n                continue\n\n            if self.make_move(position):\n                self.print_board()\n                winner = self.check_winner()\n\n                if winner:\n                    print(f\"Player {winner} wins!\")\n                    break\n                elif self.is_board_full():\n                    print(\"It's a draw!\")\n                    break\n                else:\n                    self.switch_player()\n            else:\n                print(\"Invalid move. Please try again.\")\n\n\nif __name__ == \"__main__\":\n    game = TicTacToe()\n    game.play()\n```",
    "1": "```python\nimport random\n\nclass Hangman:\n    def __init__(self, word_list, max_attempts=6):\n        \"\"\"\n        Initializes the Hangman game.\n\n        Args:\n            word_list (list): A list of strings representing possible words to guess.\n            max_attempts (int): The maximum number of incorrect guesses allowed.\n        \"\"\"\n        self.word_list = word_list\n        self.word_to_guess = random.choice(word_list).upper()\n        self.guessed_letters = set()\n        self.attempts_left = max_attempts\n        self.word_display = ['_'] * len(self.word_to_guess)\n        self.game_over = False\n        self.max_attempts = max_attempts\n\n    def display_game_state(self):\n        \"\"\"\n        Prints the current state of the game to the console.\n        \"\"\"\n        print(\"\\n\" + \"=\" * 30)\n        print(\"Word:\", \" \".join(self.word_display))\n        print(\"Guessed letters:\", \", \".join(sorted(self.guessed_letters)))\n        print(\"Attempts left:\", self.attempts_left)\n        print(\"=\" * 30)\n\n    def get_player_guess(self):\n        \"\"\"\n        Prompts the player to enter a guess and validates the input.\n\n        Returns:\n            str: The player's guess (single uppercase letter).  Returns None if input is invalid.\n        \"\"\"\n        while True:\n            guess = input(\"Guess a letter: \").upper()\n            if len(guess) != 1:\n                print(\"Please enter only one letter.\")\n            elif not guess.isalpha():\n                print(\"Please enter a letter (A-Z).\")\n            elif guess in self.guessed_letters:\n                print(\"You already guessed that letter.\")\n            else:\n                return guess\n            \n            if self.attempts_left <=0 and not self.game_over:\n                self.game_over = True\n                print(\"You lost!\")\n                return None\n\n    def update_game_state(self, guess):\n        \"\"\"\n        Updates the game state based on the player's guess.\n\n        Args:\n            guess (str): The player's guess (single uppercase letter).\n        \"\"\"\n        self.guessed_letters.add(guess)\n\n        if guess in self.word_to_guess:\n            for i, letter in enumerate(self.word_to_guess):\n                if letter == guess:\n                    self.word_display[i] = guess\n        else:\n            self.attempts_left -= 1\n            print(\"Incorrect guess.\")\n\n    def check_game_over(self):\n        \"\"\"\n        Checks if the game is over (either won or lost).\n        \"\"\"\n        if \"_\" not in self.word_display:\n            self.game_over = True\n            print(\"Congratulations! You guessed the word:\", self.word_to_guess)\n        elif self.attempts_left <= 0:\n            self.game_over = True\n            print(\"You ran out of attempts. The word was:\", self.word_to_guess)\n\n    def play(self):\n        \"\"\"\n        Plays the Hangman game.\n        \"\"\"\n        print(\"Welcome to Hangman!\")\n        self.display_game_state()\n\n        while not self.game_over:\n            guess = self.get_player_guess()\n            if guess is None:\n                break #handle if the player lost on a previous turn before guessing\n            self.update_game_state(guess)\n            self.display_game_state()\n            self.check_game_over()\n\n\nif __name__ == \"__main__\":\n    word_list = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\", \"fig\", \"grape\"]\n    game = Hangman(word_list)\n    game.play()\n```",
    "2": "```python\nimport random\n\nclass RockPaperScissors:\n    \"\"\"\n    A class to represent the Rock-Paper-Scissors game.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the game.\n        \"\"\"\n        self.choices = [\"rock\", \"paper\", \"scissors\"]\n        self.player_score = 0\n        self.computer_score = 0\n        self.rounds = 0\n\n    def get_player_choice(self):\n        \"\"\"\n        Gets the player's choice from the command line.\n        \"\"\"\n        while True:\n            choice = input(\"Choose rock, paper, or scissors: \").lower()\n            if choice in self.choices:\n                return choice\n            else:\n                print(\"Invalid choice. Please choose rock, paper, or scissors.\")\n\n    def get_computer_choice(self):\n        \"\"\"\n        Generates a random choice for the computer.\n        \"\"\"\n        return random.choice(self.choices)\n\n    def determine_winner(self, player_choice, computer_choice):\n        \"\"\"\n        Determines the winner of a round.\n        \"\"\"\n        print(f\"You chose: {player_choice}\")\n        print(f\"Computer chose: {computer_choice}\")\n\n        if player_choice == computer_choice:\n            print(\"It's a tie!\")\n            return \"tie\"\n        elif (player_choice == \"rock\" and computer_choice == \"scissors\") or \\\n             (player_choice == \"paper\" and computer_choice == \"rock\") or \\\n             (player_choice == \"scissors\" and computer_choice == \"paper\"):\n            print(\"You win!\")\n            return \"player\"\n        else:\n            print(\"Computer wins!\")\n            return \"computer\"\n\n    def play_round(self):\n        \"\"\"\n        Plays a single round of the game.\n        \"\"\"\n        self.rounds += 1\n        print(f\"\\nRound {self.rounds}:\")\n        player_choice = self.get_player_choice()\n        computer_choice = self.get_computer_choice()\n        winner = self.determine_winner(player_choice, computer_choice)\n\n        if winner == \"player\":\n            self.player_score += 1\n        elif winner == \"computer\":\n            self.computer_score += 1\n\n    def display_score(self):\n        \"\"\"\n        Displays the current score.\n        \"\"\"\n        print(\"\\n--- Score ---\")\n        print(f\"You: {self.player_score}\")\n        print(f\"Computer: {self.computer_score}\")\n\n    def play_game(self):\n        \"\"\"\n        Plays the entire game.\n        \"\"\"\n        print(\"Welcome to Rock-Paper-Scissors!\")\n        while True:\n            self.play_round()\n            self.display_score()\n\n            play_again = input(\"Play again? (yes/no): \").lower()\n            if play_again != \"yes\":\n                break\n\n        print(\"\\nThanks for playing!\")\n\nif __name__ == \"__main__\":\n    game = RockPaperScissors()\n    game.play_game()\n```",
    "3": "```python\nimport random\nimport time\nimport os\n\nclass SnakeGame:\n    \"\"\"\n    A command-line implementation of the classic Snake game.\n    \"\"\"\n\n    def __init__(self, width=20, height=15, initial_length=3):\n        \"\"\"\n        Initializes the Snake game.\n\n        Args:\n            width (int): The width of the game board.\n            height (int): The height of the game board.\n            initial_length (int): The initial length of the snake.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.initial_length = initial_length\n        self.snake = []\n        self.food = None\n        self.direction = \"RIGHT\"\n        self.game_over = False\n        self.score = 0\n        self.delay = 0.1  # Initial delay between moves\n        self.setup_game()\n\n    def setup_game(self):\n        \"\"\"\n        Sets up the initial game state.\n        \"\"\"\n        self.snake = [(self.width // 2 - i, self.height // 2) for i in range(self.initial_length)]\n        self.generate_food()\n\n    def generate_food(self):\n        \"\"\"\n        Generates food at a random location that is not occupied by the snake.\n        \"\"\"\n        while True:\n            x = random.randint(0, self.width - 1)\n            y = random.randint(0, self.height - 1)\n            if (x, y) not in self.snake:\n                self.food = (x, y)\n                break\n\n    def move(self):\n        \"\"\"\n        Moves the snake based on the current direction.\n        \"\"\"\n        head_x, head_y = self.snake[0]\n        if self.direction == \"UP\":\n            new_head = (head_x, (head_y - 1) % self.height) #Wrap around\n        elif self.direction == \"DOWN\":\n            new_head = (head_x, (head_y + 1) % self.height) #Wrap around\n        elif self.direction == \"LEFT\":\n            new_head = ((head_x - 1) % self.width, head_y) #Wrap around\n        elif self.direction == \"RIGHT\":\n            new_head = ((head_x + 1) % self.width, head_y) #Wrap around\n\n        if new_head in self.snake:\n            self.game_over = True\n            return\n\n        self.snake.insert(0, new_head)\n\n        if new_head == self.food:\n            self.score += 1\n            self.generate_food()\n            self.delay *= 0.95  # Increase speed\n        else:\n            self.snake.pop()\n\n    def change_direction(self, new_direction):\n        \"\"\"\n        Changes the direction of the snake, preventing immediate reversals.\n        \"\"\"\n        if new_direction == \"UP\" and self.direction != \"DOWN\":\n            self.direction = \"UP\"\n        elif new_direction == \"DOWN\" and self.direction != \"UP\":\n            self.direction = \"DOWN\"\n        elif new_direction == \"LEFT\" and self.direction != \"RIGHT\":\n            self.direction = \"LEFT\"\n        elif new_direction == \"RIGHT\" and self.direction != \"LEFT\":\n            self.direction = \"RIGHT\"\n\n    def draw_board(self):\n        \"\"\"\n        Draws the game board in the console.\n        \"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n        print(\"Score:\", self.score)\n        print(\"-\" * (self.width + 2))\n        for y in range(self.height):\n            print(\"|\", end=\"\")\n            for x in range(self.width):\n                if (x, y) in self.snake:\n                    print(\"O\", end=\"\")\n                elif (x, y) == self.food:\n                    print(\"F\", end=\"\")\n                else:\n                    print(\" \", end=\"\")\n            print(\"|\")\n        print(\"-\" * (self.width + 2))\n\n    def play(self):\n        \"\"\"\n        Runs the main game loop.\n        \"\"\"\n        while not self.game_over:\n            self.draw_board()\n            self.move()\n            time.sleep(self.delay)\n\n            # Get user input (non-blocking)\n            # This requires a library like `msvcrt` on Windows or `select` on Linux/macOS\n            # For simplicity, we'll just poll for input every frame.  This is not ideal\n            #  but works for a basic example.  A proper implementation would use threads or async.\n            import sys\n            import select\n\n            timeout = 0.001 # Small timeout for non-blocking read\n            rlist, _, _ = select.select([sys.stdin], [], [], timeout)\n            if rlist:\n                key = sys.stdin.readline().strip().upper()  # Read a line\n                if key == \"W\":\n                    self.change_direction(\"UP\")\n                elif key == \"S\":\n                    self.change_direction(\"DOWN\")\n                elif key == \"A\":\n                    self.change_direction(\"LEFT\")\n                elif key == \"D\":\n                    self.change_direction(\"RIGHT\")\n                elif key == \"Q\": #Quit\n                    self.game_over = True\n\n\n        self.draw_board()\n        print(\"Game Over! Final Score:\", self.score)\n\n\nif __name__ == \"__main__\":\n    game = SnakeGame()\n    game.play()\n```\n",
    "4": "```python\nimport random\nimport sys\n\nclass Minesweeper:\n    def __init__(self, rows, cols, mines):\n        self.rows = rows\n        self.cols = cols\n        self.mines = mines\n        self.board = [[' ' for _ in range(cols)] for _ in range(rows)]\n        self.revealed = [[False for _ in range(cols)] for _ in range(rows)]\n        self.flags = [[False for _ in range(cols)] for _ in range(rows)]\n        self.game_over = False\n        self.first_move = True\n        self.mine_locations = []\n\n    def print_board(self):\n        \"\"\"Prints the current state of the board.\"\"\"\n        print(\"   \" + \"  \".join(str(i) for i in range(self.cols)))\n        print(\"  \" + \"-\" * (self.cols * 3))\n        for i in range(self.rows):\n            row_str = str(i) + \" |\"\n            for j in range(self.cols):\n                if self.flags[i][j]:\n                    row_str += \" F \"\n                elif self.revealed[i][j]:\n                    row_str += \" \" + self.board[i][j] + \" \"\n                else:\n                    row_str += \" . \"\n            row_str += \"|\"\n            print(row_str)\n        print(\"  \" + \"-\" * (self.cols * 3))\n        print(f\"Mines: {self.mines}\")\n\n\n    def place_mines(self, start_row, start_col):\n        \"\"\"Places mines randomly on the board, avoiding the starting cell.\"\"\"\n        mines_placed = 0\n        while mines_placed < self.mines:\n            row = random.randint(0, self.rows - 1)\n            col = random.randint(0, self.cols - 1)\n            if (row, col) != (start_row, start_col) and (row, col) not in self.mine_locations:\n                self.mine_locations.append((row, col))\n                self.board[row][col] = '*'\n                mines_placed += 1\n\n    def calculate_neighboring_mines(self):\n        \"\"\"Calculates the number of neighboring mines for each cell.\"\"\"\n        for row in range(self.rows):\n            for col in range(self.cols):\n                if self.board[row][col] != '*':\n                    count = 0\n                    for i in range(max(0, row - 1), min(self.rows, row + 2)):\n                        for j in range(max(0, col - 1), min(self.cols, col + 2)):\n                            if self.board[i][j] == '*':\n                                count += 1\n                    self.board[row][col] = str(count) if count > 0 else ' '\n\n    def reveal(self, row, col):\n        \"\"\"Reveals a cell and recursively reveals neighboring cells if they are empty.\"\"\"\n\n        if row < 0 or row >= self.rows or col < 0 or col >= self.cols or self.revealed[row][col]:\n            return\n\n        self.revealed[row][col] = True\n\n        if self.board[row][col] == '*':\n            self.game_over = True\n            return\n\n        if self.board[row][col] == ' ':\n            for i in range(max(0, row - 1), min(self.rows, row + 2)):\n                for j in range(max(0, col - 1), min(self.cols, col + 2)):\n                    self.reveal(i, j)\n\n\n    def flag(self, row, col):\n         \"\"\"Flags or unflags a cell.\"\"\"\n         if self.revealed[row][col]:\n             print(\"Cannot flag a revealed cell.\")\n             return\n\n         self.flags[row][col] = not self.flags[row][col]\n\n    def check_win(self):\n        \"\"\"Checks if the player has won the game.\"\"\"\n        revealed_count = 0\n        for row in range(self.rows):\n            for col in range(self.cols):\n                if self.revealed[row][col]:\n                    revealed_count += 1\n\n        return revealed_count == self.rows * self.cols - self.mines\n\n    def play(self):\n        \"\"\"Main game loop.\"\"\"\n        while not self.game_over:\n            self.print_board()\n            action = input(\"Enter action (reveal r, flag f, quit q), row, col (e.g., r 0 0): \").split()\n\n            if not action:\n                print(\"Invalid input. Please try again.\")\n                continue\n\n            if action[0].lower() == 'q':\n                print(\"Quitting the game.\")\n                sys.exit()\n\n            try:\n                operation = action[0].lower()\n                row = int(action[1])\n                col = int(action[2])\n\n                if row < 0 or row >= self.rows or col < 0 or col >= self.cols:\n                    print(\"Invalid row or column. Please try again.\")\n                    continue\n\n            except (IndexError, ValueError):\n                print(\"Invalid input. Please try again.\")\n                continue\n\n            if operation == 'r':\n                if self.first_move:\n                    self.place_mines(row, col)\n                    self.calculate_neighboring_mines()\n                    self.first_move = False\n\n                self.reveal(row, col)\n\n                if self.game_over:\n                    self.print_board()\n                    print(\"Game Over! You hit a mine.\")\n                    return\n\n                if self.check_win():\n                    self.print_board()\n                    print(\"Congratulations! You won!\")\n                    return\n\n            elif operation == 'f':\n                self.flag(row, col)\n            else:\n                print(\"Invalid action. Please enter 'reveal' or 'flag'.\")\n\n        print(\"Game Over!\")\n\n\nif __name__ == \"__main__\":\n    rows = 10\n    cols = 10\n    mines = 15\n    game = Minesweeper(rows, cols, mines)\n    game.play()\n```\n",
    "5": "```python\nimport random\n\nclass Mastermind:\n    \"\"\"\n    A class to represent the Mastermind game.\n    \"\"\"\n\n    def __init__(self, code_length=4, colors=6, max_guesses=10):\n        \"\"\"\n        Initializes the Mastermind game.\n\n        Args:\n            code_length (int): The length of the code to guess.\n            colors (int): The number of possible colors (represented by integers).\n            max_guesses (int): The maximum number of guesses allowed.\n        \"\"\"\n        self.code_length = code_length\n        self.colors = colors\n        self.max_guesses = max_guesses\n        self.secret_code = self._generate_code()\n        self.guesses = []\n        self.feedback = []\n        self.game_over = False\n        self.won = False\n\n    def _generate_code(self):\n        \"\"\"\n        Generates a random secret code.\n\n        Returns:\n            list: A list of integers representing the secret code.\n        \"\"\"\n        return [random.randint(1, self.colors) for _ in range(self.code_length)]\n\n    def guess(self, guess):\n        \"\"\"\n        Takes a guess from the player and provides feedback.\n\n        Args:\n            guess (list): A list of integers representing the player's guess.\n\n        Returns:\n            tuple: A tuple containing:\n                - bool: True if the guess is valid, False otherwise.\n                - str: A message indicating the validity of the guess.\n        \"\"\"\n        if len(guess) != self.code_length:\n            return False, f\"Invalid guess: Must be {self.code_length} digits long.\"\n        if not all(1 <= digit <= self.colors for digit in guess):\n            return False, f\"Invalid guess: Digits must be between 1 and {self.colors}.\"\n\n        self.guesses.append(guess)\n        feedback = self._evaluate_guess(guess)\n        self.feedback.append(feedback)\n\n        if guess == self.secret_code:\n            self.game_over = True\n            self.won = True\n            return True, \"Congratulations! You cracked the code!\"\n\n        if len(self.guesses) >= self.max_guesses:\n            self.game_over = True\n            return True, f\"You ran out of guesses. The code was {self.secret_code}\"\n\n        return True, self._feedback_to_string(feedback)\n\n    def _evaluate_guess(self, guess):\n        \"\"\"\n        Evaluates a guess against the secret code.\n\n        Args:\n            guess (list): The player's guess.\n\n        Returns:\n            list: A list of strings representing the feedback.  \"B\" for black (correct position),\n                   \"W\" for white (correct color, wrong position), \"\" for incorrect.\n        \"\"\"\n        feedback = []\n        temp_secret = self.secret_code[:]  # Create a copy to avoid modifying the original\n        temp_guess = guess[:]\n\n        # First, check for correct positions (black pegs)\n        for i in range(self.code_length):\n            if temp_guess[i] == temp_secret[i]:\n                feedback.append(\"B\")\n                temp_secret[i] = None  # Mark as used\n                temp_guess[i] = None  # Mark as used\n\n        # Then, check for correct colors in wrong positions (white pegs)\n        for i in range(self.code_length):\n            if temp_guess[i] is not None:\n                try:\n                    j = temp_secret.index(temp_guess[i])\n                    feedback.append(\"W\")\n                    temp_secret[j] = None  # Mark as used\n                except ValueError:\n                    pass  # Color not found in secret code\n\n        # Sort the feedback to have black pegs first\n        feedback.sort(reverse=True)\n        return feedback\n\n    def _feedback_to_string(self, feedback):\n        \"\"\"\n        Converts the feedback list to a string.\n\n        Args:\n            feedback (list): The feedback list.\n\n        Returns:\n            str: A string representation of the feedback.\n        \"\"\"\n        return \"\".join(feedback)\n\n    def display_guesses(self):\n        \"\"\"\n        Displays the previous guesses and their feedback.\n        \"\"\"\n        print(\"\\nPrevious Guesses:\")\n        for i in range(len(self.guesses)):\n            print(f\"Guess {i+1}: {self.guesses[i]} - Feedback: {self._feedback_to_string(self.feedback[i])}\")\n\n    def play(self):\n        \"\"\"\n        Plays the Mastermind game through the command line.\n        \"\"\"\n        print(\"Welcome to Mastermind!\")\n        print(f\"I've generated a secret code with {self.code_length} digits, each between 1 and {self.colors}.\")\n        print(f\"You have {self.max_guesses} guesses to crack the code.\")\n\n        while not self.game_over:\n            try:\n                guess_str = input(f\"Enter your guess (separated by spaces, e.g., {' '.join(['1'] * self.code_length)}): \")\n                guess = [int(x) for x in guess_str.split()]\n            except ValueError:\n                print(\"Invalid input. Please enter numbers separated by spaces.\")\n                continue\n\n            valid, message = self.guess(guess)\n            if not valid:\n                print(message)\n            else:\n                print(message)\n                self.display_guesses()\n\n        if self.won:\n            print(\"You won!\")\n        else:\n            print(f\"You lost! The secret code was {self.secret_code}\")\n\n\nif __name__ == \"__main__\":\n    game = Mastermind()  # You can customize the game by passing arguments to the constructor\n    game.play()\n```",
    "6": "```python\nimport random\n\nclass Battleship:\n    def __init__(self, board_size=10, num_ships=5):\n        \"\"\"\n        Initializes the Battleship game.\n\n        Args:\n            board_size (int): The size of the game board (e.g., 10 for a 10x10 grid).\n            num_ships (int): The number of ships each player has.\n        \"\"\"\n        self.board_size = board_size\n        self.num_ships = num_ships\n        self.player_board = self._create_board()\n        self.computer_board = self._create_board()\n        self.player_ships = self._place_ships(self.player_board)\n        self.computer_ships = self._place_ships(self.computer_board)\n        self.player_guesses = set()  # Track player's guesses\n        self.computer_guesses = set() # Track computer's guesses\n        self.player_ship_locations = set() # Track player ship locations\n        self.computer_ship_locations = set() # Track computer ship locations\n        for ship in self.player_ships:\n            self.player_ship_locations.update(ship)\n        for ship in self.computer_ships:\n            self.computer_ship_locations.update(ship)\n\n\n    def _create_board(self):\n        \"\"\"Creates an empty game board.\"\"\"\n        return [['.' for _ in range(self.board_size)] for _ in range(self.board_size)]\n\n    def _place_ships(self, board):\n        \"\"\"Randomly places ships on the board.\"\"\"\n        ships = []\n        for _ in range(self.num_ships):\n            while True:\n                ship_length = random.randint(2, 4)  # Ships of length 2, 3, or 4\n                orientation = random.choice(['horizontal', 'vertical'])\n                if orientation == 'horizontal':\n                    row = random.randint(0, self.board_size - 1)\n                    col = random.randint(0, self.board_size - ship_length)\n                    positions = [(row, col + i) for i in range(ship_length)]\n                else:  # vertical\n                    row = random.randint(0, self.board_size - ship_length)\n                    col = random.randint(0, self.board_size - 1)\n                    positions = [(row + i, col) for i in range(ship_length)]\n\n                # Check for overlap\n                valid_placement = True\n                for r, c in positions:\n                    if board[r][c] == 'S':\n                        valid_placement = False\n                        break\n\n                if valid_placement:\n                    for r, c in positions:\n                        board[r][c] = 'S'\n                    ships.append(set(positions)) # Store ships as sets of coordinates\n                    break\n        return ships\n\n    def print_board(self, board, hide_ships=True):\n        \"\"\"Prints the game board.\"\"\"\n        print(\"  \" + \" \".join([chr(65 + i) for i in range(self.board_size)]))  # A B C ...\n        for i, row in enumerate(board):\n            print(str(i).rjust(2) + \" \" + \" \".join(['~' if cell == 'S' and hide_ships else cell for cell in row]))\n\n    def get_player_guess(self):\n        \"\"\"Gets a valid guess from the player.\"\"\"\n        while True:\n            try:\n                guess = input(\"Enter your guess (e.g., A0): \").upper()\n                if len(guess) < 2:\n                    print(\"Invalid input. Please enter a coordinate like A0 or B5.\")\n                    continue\n\n                col = ord(guess[0]) - ord('A')\n                row = int(guess[1:])\n\n                if not (0 <= row < self.board_size and 0 <= col < self.board_size):\n                    print(\"Invalid coordinates. Please enter valid row and column values.\")\n                    continue\n\n                if (row, col) in self.player_guesses:\n                    print(\"You already guessed that location. Try again.\")\n                    continue\n\n                return row, col\n\n            except (ValueError, IndexError):\n                print(\"Invalid input. Please enter a coordinate like A0 or B5.\")\n\n\n    def process_player_guess(self, row, col):\n        \"\"\"Processes the player's guess and updates the computer's board.\"\"\"\n        self.player_guesses.add((row, col))\n        if self.computer_board[row][col] == 'S':\n            print(\"Hit!\")\n            self.computer_board[row][col] = 'X'  # Mark as hit\n            for ship in self.computer_ships:\n                if (row, col) in ship:\n                    ship.remove((row, col))\n                    if not ship:\n                        print(\"You sunk a battleship!\")\n            return True\n        else:\n            print(\"Miss!\")\n            self.computer_board[row][col] = 'O'  # Mark as miss\n            return False\n\n    def get_computer_guess(self):\n        \"\"\"Generates a random guess for the computer.\"\"\"\n        while True:\n            row = random.randint(0, self.board_size - 1)\n            col = random.randint(0, self.board_size - 1)\n            if (row, col) not in self.computer_guesses:\n                return row, col\n\n    def process_computer_guess(self, row, col):\n        \"\"\"Processes the computer's guess and updates the player's board.\"\"\"\n        self.computer_guesses.add((row, col))\n        if self.player_board[row][col] == 'S':\n            print(\"Computer hit your ship at\", chr(col + ord('A')) + str(row))\n            self.player_board[row][col] = 'X'  # Mark as hit\n            for ship in self.player_ships:\n                if (row, col) in ship:\n                    ship.remove((row, col))\n                    if not ship:\n                        print(\"Computer sunk your battleship!\")\n            return True\n        else:\n            print(\"Computer missed at\", chr(col + ord('A')) + str(row))\n            self.player_board[row][col] = 'O'  # Mark as miss\n            return False\n\n    def check_win(self):\n        \"\"\"Checks if either player has won the game.\"\"\"\n        player_ships_sunk = all(not ship for ship in self.player_ships)\n        computer_ships_sunk = all(not ship for ship in self.computer_ships)\n\n        if player_ships_sunk:\n            print(\"Computer wins! All your battleships have been sunk.\")\n            return \"computer\"\n        elif computer_ships_sunk:\n            print(\"You win! All computer's battleships have been sunk.\")\n            return \"player\"\n        else:\n            return None\n\n    def play_game(self):\n        \"\"\"Plays the Battleship game.\"\"\"\n        print(\"Welcome to Battleship!\")\n        print(\"Your board:\")\n        self.print_board(self.player_board)\n        print(\"\\nComputer's board:\")\n        self.print_board(self.computer_board, hide_ships=True)  # Hide computer's ships initially\n\n        while True:\n            # Player's turn\n            print(\"\\nYour turn:\")\n            row, col = self.get_player_guess()\n            self.process_player_guess(row, col)\n            print(\"\\nComputer's board:\")\n            self.print_board(self.computer_board, hide_ships=True)\n\n            winner = self.check_win()\n            if winner:\n                break\n\n            # Computer's turn\n            print(\"\\nComputer's turn:\")\n            row, col = self.get_computer_guess()\n            self.process_computer_guess(row, col)\n            print(\"\\nYour board:\")\n            self.print_board(self.player_board)\n\n            winner = self.check_win()\n            if winner:\n                break\n\n\n\nif __name__ == '__main__':\n    game = Battleship()\n    game.play_game()\n```",
    "7": "```python\nimport argparse\nimport time\nimport os\nimport random\n\n\nclass GameOfLife:\n    \"\"\"\n    Implementation of Conway's Game of Life.\n    \"\"\"\n\n    def __init__(self, width, height, initial_density=0.3):\n        \"\"\"\n        Initializes the Game of Life grid.\n\n        Args:\n            width (int): Width of the grid.\n            height (int): Height of the grid.\n            initial_density (float): Probability of a cell being alive initially (0 to 1).\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.grid = [[(random.random() < initial_density) for _ in range(width)] for _ in range(height)]\n\n    def __str__(self):\n        \"\"\"\n        Returns a string representation of the grid.\n        \"\"\"\n        output = \"\"\n        for row in self.grid:\n            output += \"\".join([\"#\" if cell else \" \" for cell in row]) + \"\\n\"\n        return output\n\n    def clear_screen(self):\n        \"\"\"\n        Clears the console screen.\n        \"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')\n\n    def get_neighbors(self, row, col):\n        \"\"\"\n        Gets the number of alive neighbors for a given cell.\n\n        Args:\n            row (int): Row index of the cell.\n            col (int): Column index of the cell.\n\n        Returns:\n            int: Number of alive neighbors.\n        \"\"\"\n        neighbors = 0\n        for i in range(max(0, row - 1), min(self.height, row + 2)):\n            for j in range(max(0, col - 1), min(self.width, col + 2)):\n                if (i, j) != (row, col) and self.grid[i][j]:\n                    neighbors += 1\n        return neighbors\n\n    def update(self):\n        \"\"\"\n        Updates the grid to the next generation.\n        \"\"\"\n        new_grid = [[False for _ in range(self.width)] for _ in range(self.height)]\n\n        for row in range(self.height):\n            for col in range(self.width):\n                neighbors = self.get_neighbors(row, col)\n                if self.grid[row][col]:  # Alive cell\n                    if neighbors == 2 or neighbors == 3:\n                        new_grid[row][col] = True\n                else:  # Dead cell\n                    if neighbors == 3:\n                        new_grid[row][col] = True\n\n        self.grid = new_grid\n\n    def run(self, generations, delay=0.1):\n        \"\"\"\n        Runs the Game of Life for a specified number of generations.\n\n        Args:\n            generations (int): Number of generations to run.\n            delay (float): Delay in seconds between each generation.\n        \"\"\"\n        for _ in range(generations):\n            self.clear_screen()\n            print(self)\n            self.update()\n            time.sleep(delay)\n\n\ndef main():\n    \"\"\"\n    Main function to parse command-line arguments and run the Game of Life.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=\"Conway's Game of Life in Python\")\n    parser.add_argument(\"--width\", type=int, default=60, help=\"Width of the grid (default: 60)\")\n    parser.add_argument(\"--height\", type=int, default=30, help=\"Height of the grid (default: 30)\")\n    parser.add_argument(\"--generations\", type=int, default=100, help=\"Number of generations to run (default: 100)\")\n    parser.add_argument(\"--delay\", type=float, default=0.1, help=\"Delay between generations in seconds (default: 0.1)\")\n    parser.add_argument(\"--density\", type=float, default=0.3, help=\"Initial density of alive cells (default: 0.3)\")\n\n    args = parser.parse_args()\n\n    game = GameOfLife(args.width, args.height, args.density)\n    game.run(args.generations, args.delay)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
    "8": "```python\nclass ConnectFour:\n    def __init__(self, rows=6, cols=7):\n        \"\"\"\n        Initializes the Connect Four game board.\n\n        Args:\n            rows (int): The number of rows in the board (default: 6).\n            cols (int): The number of columns in the board (default: 7).\n        \"\"\"\n        self.rows = rows\n        self.cols = cols\n        self.board = [[' ' for _ in range(cols)] for _ in range(rows)]\n        self.current_player = 'X'  # Player X starts\n        self.game_over = False\n\n    def print_board(self):\n        \"\"\"\n        Prints the current state of the game board to the console.\n        \"\"\"\n        for row in range(self.rows):\n            print('|', end='')\n            for col in range(self.cols):\n                print(self.board[row][col], end='|')\n            print()\n        print('-' * (2 * self.cols + 1))  # Separator line\n        print(' ', end='')\n        for col in range(self.cols):\n            print(col + 1, end=' ') # Column numbers\n        print()\n\n    def is_valid_move(self, col):\n        \"\"\"\n        Checks if a move (dropping a piece into a column) is valid.\n\n        Args:\n            col (int): The column to check (1-indexed).\n\n        Returns:\n            bool: True if the move is valid, False otherwise.\n        \"\"\"\n        if col < 1 or col > self.cols:\n            return False\n        return self.board[0][col - 1] == ' '  # Check if top row is empty\n\n    def drop_piece(self, col):\n        \"\"\"\n        Drops a piece of the current player into the specified column.\n\n        Args:\n            col (int): The column to drop the piece into (1-indexed).\n        \"\"\"\n        for row in range(self.rows - 1, -1, -1):\n            if self.board[row][col - 1] == ' ':\n                self.board[row][col - 1] = self.current_player\n                return row  # Return the row where the piece landed\n\n    def check_win(self, row, col):\n        \"\"\"\n        Checks if the current move resulted in a win for the current player.\n\n        Args:\n            row (int): The row where the piece was dropped.\n            col (int): The column where the piece was dropped (1-indexed).\n\n        Returns:\n            bool: True if the current player has won, False otherwise.\n        \"\"\"\n        player = self.current_player\n\n        # Check horizontal\n        count = 0\n        for c in range(self.cols):\n            if self.board[row][c] == player:\n                count += 1\n                if count == 4:\n                    return True\n            else:\n                count = 0\n\n        # Check vertical\n        count = 0\n        for r in range(self.rows):\n            if self.board[r][col - 1] == player:\n                count += 1\n                if count == 4:\n                    return True\n            else:\n                count = 0\n\n        # Check positive diagonal\n        count = 0\n        for i in range(-3, 4):\n            r = row + i\n            c = col - 1 + i\n            if 0 <= r < self.rows and 0 <= c < self.cols:\n                if self.board[r][c] == player:\n                    count += 1\n                    if count == 4:\n                        return True\n                else:\n                    count = 0\n\n        # Check negative diagonal\n        count = 0\n        for i in range(-3, 4):\n            r = row - i\n            c = col - 1 + i\n            if 0 <= r < self.rows and 0 <= c < self.cols:\n                if self.board[r][c] == player:\n                    count += 1\n                    if count == 4:\n                        return True\n                else:\n                    count = 0\n\n        return False\n\n    def check_draw(self):\n        \"\"\"\n        Checks if the game is a draw (board is full).\n\n        Returns:\n            bool: True if the game is a draw, False otherwise.\n        \"\"\"\n        for col in range(self.cols):\n            if self.board[0][col] == ' ':\n                return False  # At least one empty space\n        return True\n\n    def switch_player(self):\n        \"\"\"\n        Switches the current player to the other player.\n        \"\"\"\n        self.current_player = 'O' if self.current_player == 'X' else 'X'\n\n    def play_game(self):\n        \"\"\"\n        Starts and runs the Connect Four game loop.\n        \"\"\"\n        while not self.game_over:\n            self.print_board()\n            print(f\"Player {self.current_player}, it's your turn.\")\n            try:\n                col = int(input(f\"Enter the column to drop your piece (1-{self.cols}): \"))\n                if self.is_valid_move(col):\n                    row = self.drop_piece(col)\n                    if self.check_win(row, col):\n                        self.print_board()\n                        print(f\"Player {self.current_player} wins!\")\n                        self.game_over = True\n                    elif self.check_draw():\n                        self.print_board()\n                        print(\"It's a draw!\")\n                        self.game_over = True\n                    else:\n                        self.switch_player()\n                else:\n                    print(\"Invalid move. Try again.\")\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n\nif __name__ == \"__main__\":\n    game = ConnectFour()\n    game.play_game()\n```",
    "9": "```python\nimport random\n\nclass Blackjack:\n    def __init__(self):\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n        self.player_score = 0\n        self.dealer_score = 0\n        self.game_over = False\n\n    def create_deck(self):\n        suits = [\"Hearts\", \"Diamonds\", \"Clubs\", \"Spades\"]\n        ranks = [\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\", \"Ace\"]\n        deck = []\n        for suit in suits:\n            for rank in ranks:\n                deck.append((rank, suit))\n        random.shuffle(deck)\n        return deck\n\n    def deal_card(self, hand):\n        card = self.deck.pop()\n        hand.append(card)\n        return card\n\n    def calculate_hand_score(self, hand):\n        score = 0\n        ace_count = 0\n        for card in hand:\n            rank = card[0]\n            if rank.isdigit():\n                score += int(rank)\n            elif rank in [\"Jack\", \"Queen\", \"King\"]:\n                score += 10\n            elif rank == \"Ace\":\n                score += 1\n                ace_count += 1\n\n        while score + 10 <= 21 and ace_count > 0:\n            score += 10\n            ace_count -= 1\n\n        return score\n\n    def display_hand(self, hand, is_dealer=False, hide_first_card=False):\n        if is_dealer:\n            print(\"Dealer's hand:\")\n            if hide_first_card:\n                print(\"[Hidden Card]\")\n                for card in hand[1:]:\n                    print(f\"{card[0]} of {card[1]}\")\n\n            else:\n                for card in hand:\n                    print(f\"{card[0]} of {card[1]}\")\n        else:\n            print(\"Your hand:\")\n            for card in hand:\n                print(f\"{card[0]} of {card[1]}\")\n\n    def play_round(self):\n        # Deal initial hands\n        self.deal_card(self.player_hand)\n        self.deal_card(self.dealer_hand)\n        self.deal_card(self.player_hand)\n        self.deal_card(self.dealer_hand)\n\n        self.player_score = self.calculate_hand_score(self.player_hand)\n        self.dealer_score = self.calculate_hand_score(self.dealer_hand)\n\n        # Player's turn\n        self.display_hand(self.player_hand)\n        self.display_hand(self.dealer_hand, is_dealer=True, hide_first_card=True)\n        print(f\"Your score: {self.player_score}\")\n\n        while self.player_score < 21:\n            action = input(\"Hit or Stand? (h/s): \").lower()\n            if action == \"h\":\n                card = self.deal_card(self.player_hand)\n                self.player_score = self.calculate_hand_score(self.player_hand)\n                print(f\"You drew {card[0]} of {card[1]}\")\n                self.display_hand(self.player_hand)\n                print(f\"Your score: {self.player_score}\")\n                if self.player_score > 21:\n                    print(\"Bust!\")\n                    self.game_over = True\n                    break\n            elif action == \"s\":\n                break\n            else:\n                print(\"Invalid input. Please enter 'h' or 's'.\")\n\n        if not self.game_over:\n            # Dealer's turn\n            print(\"\\nDealer's turn:\")\n            self.display_hand(self.dealer_hand, is_dealer=True)\n            print(f\"Dealer's score: {self.dealer_score}\")\n\n            while self.dealer_score < 17:\n                card = self.deal_card(self.dealer_hand)\n                self.dealer_score = self.calculate_hand_score(self.dealer_hand)\n                print(f\"Dealer drew {card[0]} of {card[1]}\")\n                self.display_hand(self.dealer_hand, is_dealer=True)\n                print(f\"Dealer's score: {self.dealer_score}\")\n                if self.dealer_score > 21:\n                    print(\"Dealer busts!\")\n                    break\n\n            # Determine the winner\n            if self.player_score > 21:\n                print(\"You lose!\")\n            elif self.dealer_score > 21:\n                print(\"You win!\")\n            elif self.player_score > self.dealer_score:\n                print(\"You win!\")\n            elif self.player_score < self.dealer_score:\n                print(\"You lose!\")\n            else:\n                print(\"It's a tie!\")\n\n        self.game_over = True\n\n    def reset_game(self):\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n        self.player_score = 0\n        self.dealer_score = 0\n        self.game_over = False\n\n    def play_game(self):\n        while True:\n            self.reset_game()\n            self.play_round()\n\n            play_again = input(\"Play again? (y/n): \").lower()\n            if play_again != \"y\":\n                break\n\nif __name__ == \"__main__\":\n    game = Blackjack()\n    game.play_game()\n```",
    "10": "```python\nimport random\n\nclass Hammurabi:\n    \"\"\"\n    A class to represent the game Hammurabi.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the game with default values.\n        \"\"\"\n        self.year = 1\n        self.population = 100\n        self.grain = 2800\n        self.acres = 3000\n        self.price_land = 19  # Initial price of land (randomized later)\n        self.deaths = 0\n        self.starved = 0\n        self.harvest = 3\n        self.rats_ate = 200\n        self.immigrants = 5\n\n    def play_year(self):\n        \"\"\"\n        Plays one year of the game.\n        \"\"\"\n        print(f\"\\nYear {self.year}\")\n        print(f\"You are in year {self.year} of your ten-year rule.\")\n        print(f\"In the previous year {self.deaths} people starved to death.\")\n        print(f\"The population is now {self.population}.\")\n        print(f\"You harvested {self.harvest} bushels per acre.\")\n        print(f\"Rats ate {self.rats_ate} bushels.\")\n        print(f\"You now have {self.grain} bushels of grain in storage.\")\n        print(f\"The city owns {self.acres} acres of land.\")\n        print(f\"Land is trading at {self.price_land} bushels per acre.\")\n\n        self.ask_actions()\n        self.calculate_year_end()\n\n    def ask_actions(self):\n        \"\"\"\n        Asks the player for actions to take.\n        \"\"\"\n        while True:\n            try:\n                self.buy_sell = int(input(\"How many acres do you wish to buy/sell? \"))\n                if self.buy_sell < 0:  # Selling land\n                    if abs(self.buy_sell) > self.acres:\n                        print(\"Hammurabi: Think again. You only own\", self.acres, \"acres.\")\n                        continue\n                elif self.buy_sell > 0:  # Buying land\n                    if self.buy_sell * self.price_land > self.grain:\n                        print(\"Hammurabi: Think again. You only have\", self.grain, \"bushels of grain.\")\n                        continue\n                break\n            except ValueError:\n                print(\"Invalid input. Please enter an integer.\")\n\n        while True:\n            try:\n                self.feed = int(input(\"How many bushels do you wish to feed your people? \"))\n                if self.feed > self.grain:\n                    print(\"Hammurabi: Think again. You only have\", self.grain, \"bushels of grain.\")\n                    continue\n                break\n            except ValueError:\n                print(\"Invalid input. Please enter an integer.\")\n\n        while True:\n            try:\n                self.plant = int(input(\"How many acres do you wish to plant with grain? \"))\n                if self.plant > self.acres:\n                    print(\"Hammurabi: Think again. You only have\", self.acres, \"acres.\")\n                    continue\n                if self.plant > self.grain:\n                    print(\"Hammurabi: Think again. You only have\", self.grain, \"bushels of grain.\")\n                    continue\n                if self.plant > self.population * 10:\n                    print(\"Hammurabi: Think again. You only have\", self.population, \"people to tend the fields.\")\n                    continue\n                break\n            except ValueError:\n                print(\"Invalid input. Please enter an integer.\")\n\n    def calculate_year_end(self):\n        \"\"\"\n        Calculates the results of the year.\n        \"\"\"\n\n        # Buy/Sell Land\n        self.acres += self.buy_sell  # Acres owned are updated\n        self.grain -= self.buy_sell * self.price_land # Grain is updated\n\n        # Calculate starvation\n        self.starved = 0\n        if self.feed < self.population * 20:\n            self.starved = int((self.population * 20 - self.feed) / 20)\n            if self.starved > self.population:\n                self.starved = self.population\n            self.population -= self.starved\n\n        # Calculate immigration\n        self.immigrants = 0\n        if self.starved == 0:\n            self.immigrants = int(random.randint(0, 5) * (20 * self.acres + self.grain) / self.population / 100)\n        self.population += self.immigrants\n\n        # Calculate harvest\n        self.harvest = random.randint(1, 6)  # Random harvest yield\n        self.grain += self.plant * self.harvest\n        \n        # Rats attack\n        self.rats_ate = 0\n        if random.randint(0, 1) == 0:\n            self.rats_ate = int(self.grain * random.uniform(0.1, 0.3))\n            self.grain -= self.rats_ate\n\n        # Calculate new grain amount\n        self.grain -= self.feed\n        self.grain -= self.plant\n\n        # Plague\n        self.deaths = 0\n        if random.randint(0, 15) == 0:\n            self.deaths = int(self.population / 2)\n            self.population -= self.deaths\n            print(\"A horrible plague struck! Half the people died.\")\n\n        # Calculate new land price\n        self.price_land = random.randint(17, 23)\n\n    def is_game_over(self):\n        \"\"\"\n        Checks if the game is over.\n        \"\"\"\n        if self.year > 10:\n            return True\n        if self.population <= 0:\n            print(\"Due to your poor leadership, everyone has died.  The game is over.\")\n            return True\n        if self.starved > (0.45 * self.population):\n            print(\"You starved more than 45% of the population! You are immediately deposed by force!\")\n            return True\n        return False\n\n    def calculate_score(self):\n        \"\"\"\n        Calculates the player's score.\n        \"\"\"\n        acres_per_person = self.acres / self.population\n        print(\"\\nFinal Report:\")\n        print(f\"You ruled for {self.year - 1} years.\")\n        print(f\"You ended with {self.population} people.\")\n        print(f\"You owned {self.acres} acres of land.\")\n        print(f\"Acres per person: {acres_per_person:.2f}\")\n\n        if acres_per_person > 10:\n            print(\"A fantastic performance!  Well done!\")\n        elif acres_per_person > 7:\n            print(\"Your performance could have been better.\")\n        elif acres_per_person > 5:\n            print(\"Your performance was adequate.\")\n        else:\n            print(\"Your performance was poor.  You are banished from the kingdom.\")\n\n    def play_game(self):\n        \"\"\"\n        Plays the entire game.\n        \"\"\"\n        print(\"Welcome to the ancient Sumerian city state game of Hammurabi!\\n\")\n        print(\"Try your hand at governing a city state for ten years.\")\n\n        while not self.is_game_over():\n            self.play_year()\n            self.year += 1\n\n        if self.year > 10:\n            self.calculate_score()\n\nif __name__ == \"__main__\":\n    game = Hammurabi()\n    game.play_game()\n```\n",
    "11": "```python\nimport random\n\nclass LightsOut:\n    \"\"\"\n    A class representing the Lights Out game.\n    \"\"\"\n\n    def __init__(self, size=5, initial_state=None):\n        \"\"\"\n        Initializes the game board.\n\n        Args:\n            size (int): The size of the board (size x size).  Defaults to 5.\n            initial_state (list of lists):  An optional initial state for the board.\n                                          If None, generates a random initial state.\n        \"\"\"\n        self.size = size\n        if initial_state is None:\n            self.board = self.generate_random_board()\n        else:\n            if len(initial_state) != size or any(len(row) != size for row in initial_state):\n                raise ValueError(\"Initial state must be a square matrix of the specified size.\")\n            self.board = initial_state\n\n    def generate_random_board(self):\n        \"\"\"\n        Generates a random board state.\n\n        Returns:\n            list of lists: A 2D list representing the board.\n        \"\"\"\n        board = [[random.randint(0, 1) for _ in range(self.size)] for _ in range(self.size)]\n        return board\n\n    def print_board(self):\n        \"\"\"\n        Prints the current state of the board to the console.\n        \"\"\"\n        for row in self.board:\n            print(\" \".join(map(str, row)))\n\n    def toggle_light(self, row, col):\n        \"\"\"\n        Toggles the light at the given row and column.\n\n        Args:\n            row (int): The row of the light to toggle.\n            col (int): The column of the light to toggle.\n        \"\"\"\n        if 0 <= row < self.size and 0 <= col < self.size:\n            self.board[row][col] = 1 - self.board[row][col]  # Flip 0 to 1 and 1 to 0\n\n    def make_move(self, row, col):\n        \"\"\"\n        Makes a move by toggling the selected light and its neighbors.\n\n        Args:\n            row (int): The row of the light to toggle.\n            col (int): The column of the light to toggle.\n        \"\"\"\n        self.toggle_light(row, col)  # Toggle the selected light\n        self.toggle_light(row - 1, col)  # Toggle the light above\n        self.toggle_light(row + 1, col)  # Toggle the light below\n        self.toggle_light(row, col - 1)  # Toggle the light to the left\n        self.toggle_light(row, col + 1)  # Toggle the light to the right\n\n    def is_solved(self):\n        \"\"\"\n        Checks if the game is solved (all lights are off).\n\n        Returns:\n            bool: True if the game is solved, False otherwise.\n        \"\"\"\n        return all(all(light == 0 for light in row) for row in self.board)\n\n    def play(self):\n        \"\"\"\n        Plays the game through the command line.\n        \"\"\"\n        print(\"Welcome to Lights Out!\")\n        self.print_board()\n\n        while not self.is_solved():\n            try:\n                move = input(f\"Enter your move (row, col) [0-{self.size-1}]: \").split(\",\")\n                row = int(move[0].strip())\n                col = int(move[1].strip())\n\n                if 0 <= row < self.size and 0 <= col < self.size:\n                    self.make_move(row, col)\n                    self.print_board()\n                else:\n                    print(\"Invalid move. Row and column must be within the board boundaries.\")\n            except (ValueError, IndexError):\n                print(\"Invalid input.  Please enter row and column as integers separated by a comma.\")\n\n        print(\"Congratulations! You solved the puzzle!\")\n\n\nif __name__ == \"__main__\":\n    game = LightsOut(size=5)  # You can change the size of the board here\n    game.play()\n```",
    "12": "```python\nimport time\nimport random\nimport os\n\nclass Pong:\n    \"\"\"\n    A command-line Pong game.\n    \"\"\"\n\n    def __init__(self, width=60, height=20, paddle_length=4, ball_speed=1, ai_speed=1):\n        \"\"\"\n        Initializes the Pong game.\n\n        Args:\n            width (int): Width of the game board.\n            height (int): Height of the game board.\n            paddle_length (int): Length of the paddles.\n            ball_speed (int): Initial speed of the ball.\n            ai_speed (int): Initial speed of the AI paddle.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.paddle_length = paddle_length\n        self.ball_speed = ball_speed\n        self.ai_speed = ai_speed\n\n        self.player_paddle_x = 1\n        self.player_paddle_y = height // 2 - paddle_length // 2\n        self.ai_paddle_x = width - 2\n        self.ai_paddle_y = height // 2 - paddle_length // 2\n\n        self.ball_x = width // 2\n        self.ball_y = height // 2\n        self.ball_dx = random.choice([-1, 1]) * ball_speed\n        self.ball_dy = random.choice([-1, 1]) * ball_speed\n\n        self.player_score = 0\n        self.ai_score = 0\n        self.game_over = False\n\n    def _clear_screen(self):\n        \"\"\"Clears the console screen.\"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')\n\n    def _draw_board(self):\n        \"\"\"Draws the game board with paddles and ball.\"\"\"\n\n        board = [[' ' for _ in range(self.width)] for _ in range(self.height)]\n\n        # Draw paddles\n        for i in range(self.paddle_length):\n            if 0 <= self.player_paddle_y + i < self.height:\n                board[self.player_paddle_y + i][self.player_paddle_x] = '|'\n            if 0 <= self.ai_paddle_y + i < self.height:\n                board[self.ai_paddle_y + i][self.ai_paddle_x] = '|'\n\n        # Draw ball\n        if 0 <= self.ball_y < self.height and 0 <= self.ball_x < self.width:\n            board[self.ball_y][self.ball_x] = 'O'\n\n        # Draw score\n        score_str = f\"Player: {self.player_score}  AI: {self.ai_score}\"\n        score_x = (self.width - len(score_str)) // 2\n        for i, char in enumerate(score_str):\n            if 0 <= score_x + i < self.width:\n                board[0][score_x + i] = char\n\n\n        self._clear_screen()\n        for row in board:\n            print(\"\".join(row))\n        print(f\"Controls: W (Up), S (Down), Q (Quit)  - Ball Speed: {abs(self.ball_dx)}, AI Speed: {self.ai_speed}\") #Added speed info\n\n\n    def _update_ball(self):\n        \"\"\"Updates the ball's position and handles collisions.\"\"\"\n        self.ball_x += self.ball_dx\n        self.ball_y += self.ball_dy\n\n        # Bounce off top and bottom walls\n        if self.ball_y <= 0 or self.ball_y >= self.height - 1:\n            self.ball_dy *= -1\n\n        # Bounce off paddles\n        if (self.ball_x <= self.player_paddle_x + 1 and\n            self.player_paddle_y <= self.ball_y < self.player_paddle_y + self.paddle_length):\n            self.ball_dx *= -1\n            self.ball_dx = max(self.ball_dx * 1.1, -5) if self.ball_dx < 0 else min(self.ball_dx * 1.1, 5) # Increase ball speed after paddle hit.\n\n        if (self.ball_x >= self.ai_paddle_x - 1 and\n            self.ai_paddle_y <= self.ball_y < self.ai_paddle_y + self.paddle_length):\n            self.ball_dx *= -1\n            self.ball_dx = max(self.ball_dx * 1.1, -5) if self.ball_dx < 0 else min(self.ball_dx * 1.1, 5) # Increase ball speed after paddle hit.\n        # Score\n        if self.ball_x <= 0:\n            self.ai_score += 1\n            self._reset_ball()\n        elif self.ball_x >= self.width - 1:\n            self.player_score += 1\n            self._reset_ball()\n\n        #Check for Game Over\n        if self.player_score >= 10 or self.ai_score >= 10:\n            self.game_over = True\n\n    def _reset_ball(self):\n        \"\"\"Resets the ball to the center of the board with random direction.\"\"\"\n        self.ball_x = self.width // 2\n        self.ball_y = self.height // 2\n        self.ball_dx = random.choice([-1, 1]) * self.ball_speed\n        self.ball_dy = random.choice([-1, 1]) * self.ball_speed\n\n    def _update_ai(self):\n        \"\"\"Updates the AI paddle's position.\"\"\"\n        if self.ai_paddle_y + self.paddle_length // 2 < self.ball_y and self.ai_paddle_y < self.height - self.paddle_length:\n            self.ai_paddle_y += self.ai_speed\n        elif self.ai_paddle_y + self.paddle_length // 2 > self.ball_y and self.ai_paddle_y > 0:\n            self.ai_paddle_y -= self.ai_speed\n\n\n    def _handle_input(self, key):\n        \"\"\"Handles player input.\"\"\"\n        if key.lower() == 'w':\n            self.player_paddle_y = max(0, self.player_paddle_y - 1)\n        elif key.lower() == 's':\n            self.player_paddle_y = min(self.height - self.paddle_length, self.player_paddle_y + 1)\n        elif key.lower() == 'q':\n            self.game_over = True\n        elif key.lower() == 'a': #Increase AI speed\n            self.ai_speed = min(self.ai_speed + 1, 5) #Limit to 5\n        elif key.lower() == 'd': #Decrease AI speed\n            self.ai_speed = max(self.ai_speed - 1, 1) #Limit to 1\n\n\n\n    def play(self):\n        \"\"\"Starts the Pong game loop.\"\"\"\n        while not self.game_over:\n            self._draw_board()\n            self._update_ball()\n            self._update_ai()\n\n            key = input()  # Get player input\n            self._handle_input(key)\n\n            time.sleep(0.05)  # Adjust for game speed\n\n        self._draw_board() #Final Draw\n        if self.player_score > self.ai_score:\n            print(\"Player wins!\")\n        else:\n            print(\"AI wins!\")\n\n\nif __name__ == \"__main__\":\n    game = Pong(width=70, height=25, paddle_length=5, ball_speed=1, ai_speed=2)\n    game.play()\n```",
    "13": "```python\nimport random\nimport os\n\nclass Tetris:\n    \"\"\"\n    A command-line Tetris game.\n    \"\"\"\n\n    WIDTH = 10\n    HEIGHT = 20\n    PIECES = [\n        [[1, 1, 1, 1]],  # I\n        [[1, 1], [1, 1]],  # O\n        [[0, 1, 1], [1, 1, 0]],  # S\n        [[1, 1, 0], [0, 1, 1]],  # Z\n        [[1, 0, 0], [1, 1, 1]],  # L\n        [[0, 0, 1], [1, 1, 1]],  # J\n        [[0, 1, 0], [1, 1, 1]]   # T\n    ]\n    COLORS = ['cyan', 'yellow', 'green', 'red', 'orange', 'blue', 'purple']\n\n    def __init__(self):\n        self.grid = [[0] * self.WIDTH for _ in range(self.HEIGHT)]\n        self.current_piece = None\n        self.current_x = 0\n        self.current_y = 0\n        self.next_piece = None\n        self.game_over = False\n        self.score = 0\n        self.level = 1\n        self.lines_cleared = 0\n        self.new_piece()\n        self.next_piece = self.random_piece()  # Initialize the next piece\n\n    def random_piece(self):\n        \"\"\"\n        Returns a random piece and its corresponding color.\n        \"\"\"\n        index = random.randint(0, len(self.PIECES) - 1)\n        return self.PIECES[index], self.COLORS[index]\n\n    def new_piece(self):\n        \"\"\"\n        Generates a new piece at the top of the grid.\n        \"\"\"\n        self.current_piece, self.current_color = self.next_piece # Use the next piece\n        self.next_piece = self.random_piece() # Get a new next piece\n        self.current_x = self.WIDTH // 2 - len(self.current_piece[0]) // 2\n        self.current_y = 0\n\n        if not self.is_valid_position(self.current_piece, self.current_x, self.current_y):\n            self.game_over = True\n\n    def rotate_piece(self):\n        \"\"\"\n        Rotates the current piece clockwise.\n        \"\"\"\n        rotated_piece = list(zip(*self.current_piece[::-1]))\n        if self.is_valid_position(rotated_piece, self.current_x, self.current_y):\n            self.current_piece = rotated_piece\n\n    def move(self, dx):\n        \"\"\"\n        Moves the current piece horizontally.\n        \"\"\"\n        new_x = self.current_x + dx\n        if self.is_valid_position(self.current_piece, new_x, self.current_y):\n            self.current_x = new_x\n\n    def drop(self):\n        \"\"\"\n        Moves the current piece down one row.\n        \"\"\"\n        new_y = self.current_y + 1\n        if self.is_valid_position(self.current_piece, self.current_x, new_y):\n            self.current_y = new_y\n        else:\n            self.lock_piece()\n\n    def hard_drop(self):\n        \"\"\"\n        Drops the piece to the lowest possible position.\n        \"\"\"\n        while not self.game_over:\n            new_y = self.current_y + 1\n            if self.is_valid_position(self.current_piece, self.current_x, new_y):\n                self.current_y = new_y\n            else:\n                self.lock_piece()\n                break\n\n    def is_valid_position(self, piece, x, y):\n        \"\"\"\n        Checks if the given piece can be placed at the given position.\n        \"\"\"\n        for i in range(len(piece)):\n            for j in range(len(piece[0])):\n                if piece[i][j]:\n                    grid_x = x + j\n                    grid_y = y + i\n\n                    if grid_x < 0 or grid_x >= self.WIDTH or grid_y >= self.HEIGHT:\n                        return False\n                    if grid_y >= 0 and self.grid[grid_y][grid_x] != 0:\n                        return False\n        return True\n\n    def lock_piece(self):\n        \"\"\"\n        Locks the current piece into the grid.\n        \"\"\"\n        for i in range(len(self.current_piece)):\n            for j in range(len(self.current_piece[0])):\n                if self.current_piece[i][j]:\n                    self.grid[self.current_y + i][self.current_x + j] = self.current_color\n\n        self.clear_lines()\n        self.new_piece()\n\n    def clear_lines(self):\n        \"\"\"\n        Clears any full lines from the grid.\n        \"\"\"\n        lines_to_clear = []\n        for i in range(self.HEIGHT):\n            if all(self.grid[i]):\n                lines_to_clear.append(i)\n\n        for line in lines_to_clear:\n            del self.grid[line]\n            self.grid.insert(0, [0] * self.WIDTH)\n\n        num_lines = len(lines_to_clear)\n        if num_lines > 0:\n            self.lines_cleared += num_lines\n            self.score += self.level * (num_lines ** 2) * 100\n            if self.lines_cleared >= self.level * 10:\n                self.level += 1\n\n    def display(self):\n        \"\"\"\n        Displays the game grid in the console.\n        \"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n        print(\"Tetris\")\n        print(f\"Score: {self.score}, Level: {self.level}, Lines: {self.lines_cleared}\")\n        print(\"Next piece:\")\n        self.display_piece(self.next_piece[0])\n\n        for i in range(self.HEIGHT):\n            row = \"\"\n            for j in range(self.WIDTH):\n                cell = self.grid[i][j]\n                if cell:\n                    row += self.color_to_symbol(cell)\n                else:\n                    # Check if current piece is occupying this cell\n                    occupied = False\n                    for piece_row in range(len(self.current_piece)):\n                        for piece_col in range(len(self.current_piece[0])):\n                            if self.current_piece[piece_row][piece_col]:\n                                grid_x = self.current_x + piece_col\n                                grid_y = self.current_y + piece_row\n                                if grid_x == j and grid_y == i:\n                                    row += self.color_to_symbol(self.current_color)\n                                    occupied = True\n                                    break\n                        if occupied:\n                            break\n                    if not occupied:\n                        row += \".\"\n            print(row)\n        print(\"Controls: A - Left, D - Right, S - Down, W - Rotate, Space - Hard Drop, Q - Quit\")\n\n\n    def display_piece(self, piece):\n        \"\"\"\n        Displays a piece in the console.\n        \"\"\"\n        for row in piece:\n            line = \"\"\n            for cell in row:\n                if cell:\n                    line += \"#\"\n                else:\n                    line += \" \"\n            print(line)\n\n\n    def color_to_symbol(self, color):\n        \"\"\"\n        Converts a color name to a symbol for display.\n        \"\"\"\n        if color == 'cyan':\n            return 'C'\n        elif color == 'yellow':\n            return 'Y'\n        elif color == 'green':\n            return 'G'\n        elif color == 'red':\n            return 'R'\n        elif color == 'orange':\n            return 'O'\n        elif color == 'blue':\n            return 'B'\n        elif color == 'purple':\n            return 'P'\n        else:\n            return '?'  # Unknown color\n\n    def play(self):\n        \"\"\"\n        Runs the main game loop.\n        \"\"\"\n        while not self.game_over:\n            self.display()\n            action = input(\"Enter action (A - Left, D - Right, S - Down, W - Rotate, Space - Hard Drop, Q - Quit): \").upper()\n\n            if action == 'A':\n                self.move(-1)\n            elif action == 'D':\n                self.move(1)\n            elif action == 'S':\n                self.drop()\n            elif action == 'W':\n                self.rotate_piece()\n            elif action == ' ':\n                self.hard_drop()\n            elif action == 'Q':\n                self.game_over = True\n            else:\n                print(\"Invalid input.\")\n\n            if self.game_over:\n                self.display()\n                print(\"Game Over!  Final Score:\", self.score)\n\nif __name__ == \"__main__\":\n    game = Tetris()\n    game.play()\n```",
    "14": "```python\nimport math\nimport random\nimport time\n\nclass Asteroid:\n    def __init__(self, x, y, size, dx, dy):\n        self.x = x\n        self.y = y\n        self.size = size\n        self.dx = dx\n        self.dy = dy\n\n    def move(self, width, height):\n        self.x += self.dx\n        self.y += self.dy\n\n        if self.x < 0:\n            self.x = width\n        elif self.x > width:\n            self.x = 0\n        if self.y < 0:\n            self.y = height\n        elif self.y > height:\n            self.y = 0\n\n    def draw(self):\n        print(f\"Asteroid at ({self.x:.1f}, {self.y:.1f}), size: {self.size:.1f}\")\n\n\nclass Bullet:\n    def __init__(self, x, y, angle, speed):\n        self.x = x\n        self.y = y\n        self.angle = angle\n        self.speed = speed\n        self.dx = math.cos(self.angle) * self.speed\n        self.dy = math.sin(self.angle) * self.speed\n\n    def move(self, width, height):\n        self.x += self.dx\n        self.y += self.dy\n\n        if self.x < 0 or self.x > width or self.y < 0 or self.y > height:\n            return True  # Indicate out of bounds\n\n        return False\n\n    def draw(self):\n        print(f\"Bullet at ({self.x:.1f}, {self.y:.1f})\")\n\n\nclass Spaceship:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.angle = 0  # Radians\n        self.thrust = 0\n        self.dx = 0\n        self.dy = 0\n\n    def rotate_left(self, amount):\n        self.angle -= amount\n\n    def rotate_right(self, amount):\n        self.angle += amount\n\n    def apply_thrust(self, amount):\n        self.thrust = amount\n\n    def move(self, width, height):\n        # Update velocity based on thrust\n        self.dx += math.cos(self.angle) * self.thrust\n        self.dy += math.sin(self.angle) * self.thrust\n\n        # Apply friction (damping)\n        self.dx *= 0.98\n        self.dy *= 0.98\n\n        self.x += self.dx\n        self.y += self.dy\n\n        # Keep within bounds (wrap around)\n        if self.x < 0:\n            self.x = width\n        elif self.x > width:\n            self.x = 0\n        if self.y < 0:\n            self.y = height\n        elif self.y > height:\n            self.y = 0\n\n    def draw(self):\n        print(f\"Spaceship at ({self.x:.1f}, {self.y:.1f}), angle: {math.degrees(self.angle):.1f}\")\n\n    def shoot(self, bullet_speed):\n        return Bullet(self.x, self.y, self.angle, bullet_speed)\n\n\nclass AsteroidsGame:\n    def __init__(self, width=80, height=24, num_asteroids=5, bullet_speed=5):\n        self.width = width\n        self.height = height\n        self.spaceship = Spaceship(width // 2, height // 2)\n        self.asteroids = []\n        self.bullets = []\n        self.score = 0\n        self.game_over = False\n        self.bullet_speed = bullet_speed\n\n        for _ in range(num_asteroids):\n            x = random.uniform(0, width)\n            y = random.uniform(0, height)\n            size = random.uniform(2, 5)\n            dx = random.uniform(-1, 1)\n            dy = random.uniform(-1, 1)\n            self.asteroids.append(Asteroid(x, y, size, dx, dy))\n\n    def handle_input(self, action):\n        if action == \"left\":\n            self.spaceship.rotate_left(0.2)\n        elif action == \"right\":\n            self.spaceship.rotate_right(0.2)\n        elif action == \"thrust\":\n            self.spaceship.apply_thrust(0.1)\n        elif action == \"shoot\":\n            self.bullets.append(self.spaceship.shoot(self.bullet_speed))\n        elif action == \"quit\":\n            self.game_over = True\n\n    def update(self):\n        if self.game_over:\n            return\n\n        self.spaceship.move(self.width, self.height)\n\n        for asteroid in self.asteroids:\n            asteroid.move(self.width, self.height)\n\n        # Move bullets and remove out-of-bounds bullets\n        new_bullets = []\n        for bullet in self.bullets:\n            if not bullet.move(self.width, self.height):\n                new_bullets.append(bullet)\n        self.bullets = new_bullets\n\n\n        # Collision detection (Asteroids and Bullets)\n        for bullet in self.bullets[:]: # Iterate over a copy\n            for asteroid in self.asteroids[:]: # Iterate over a copy\n                distance = math.sqrt((bullet.x - asteroid.x)**2 + (bullet.y - asteroid.y)**2)\n                if distance < asteroid.size:\n                    self.asteroids.remove(asteroid)\n                    self.bullets.remove(bullet)\n                    self.score += int(asteroid.size * 10)  # Score based on asteroid size\n                    break  # Only one asteroid can be hit by a bullet at a time\n\n        # Collision detection (Asteroids and Spaceship)\n        for asteroid in self.asteroids:\n            distance = math.sqrt((self.spaceship.x - asteroid.x)**2 + (self.spaceship.y - asteroid.y)**2)\n            if distance < asteroid.size:\n                self.game_over = True\n                print(\"Game Over! Ship hit by asteroid.\")\n                break\n\n\n    def draw(self):\n        print(\"\\n\" * 5)  # Clear screen (crude)\n        print(\"-\" * self.width)\n        print(f\"Score: {self.score}\")\n        self.spaceship.draw()\n        for asteroid in self.asteroids:\n            asteroid.draw()\n        for bullet in self.bullets:\n            bullet.draw()\n        print(\"-\" * self.width)\n\n        if self.game_over:\n            print(\"GAME OVER!\")\n\n    def play(self):\n        while not self.game_over:\n            self.draw()\n            action = input(\"Enter action (left, right, thrust, shoot, quit): \").lower()\n            self.handle_input(action)\n            self.update()\n            time.sleep(0.1)  # Control game speed\n\n        print(f\"Final Score: {self.score}\")\n\n\nif __name__ == \"__main__\":\n    game = AsteroidsGame()\n    game.play()\n```",
    "15": "```python\nimport random\nimport time\n\nclass Boggle:\n    \"\"\"\n    A class to represent the Boggle game.\n    \"\"\"\n\n    def __init__(self, size=4, time_limit=180, dictionary_file=\"words.txt\"):\n        \"\"\"\n        Initializes the Boggle game.\n\n        Args:\n            size (int): The size of the Boggle board (default: 4).\n            time_limit (int): The time limit for the game in seconds (default: 180).\n            dictionary_file (str): The path to the dictionary file (default: \"words.txt\").\n        \"\"\"\n        self.size = size\n        self.time_limit = time_limit\n        self.dictionary = self.load_dictionary(dictionary_file)\n        self.board = self.generate_board()\n        self.found_words = set()\n        self.start_time = None\n        self.game_over = False\n\n    def load_dictionary(self, dictionary_file):\n        \"\"\"\n        Loads the dictionary from a file.\n\n        Args:\n            dictionary_file (str): The path to the dictionary file.\n\n        Returns:\n            set: A set of words from the dictionary.\n        \"\"\"\n        try:\n            with open(dictionary_file, \"r\") as f:\n                words = set(word.strip().upper() for word in f)\n            return words\n        except FileNotFoundError:\n            print(f\"Error: Dictionary file '{dictionary_file}' not found.\")\n            exit()\n\n    def generate_board(self):\n        \"\"\"\n        Generates the Boggle board.\n\n        Returns:\n            list: A 2D list representing the Boggle board.\n        \"\"\"\n        dice = [\n            \"AAEEGN\", \"ELRTTY\", \"AOOTTW\", \"ABBJOO\",\n            \"EHRTVW\", \"CIMOTU\", \"DISTTY\", \"EIOSST\",\n            \"DELRVY\", \"ACHOPS\", \"HIMNQU\", \"EEINSV\",\n            \"EEGHNW\", \"AFFKPS\", \"HLNNRZ\", \"DEILRX\"\n        ]\n        board = []\n        random.shuffle(dice)\n        for i in range(self.size):\n            row = []\n            for j in range(self.size):\n                row.append(random.choice(dice[i * self.size + j]))\n            board.append(row)\n        return board\n\n    def display_board(self):\n        \"\"\"\n        Displays the Boggle board in the console.\n        \"\"\"\n        print(\"Boggle Board:\")\n        for row in self.board:\n            print(\" \".join(row))\n        print()\n\n    def is_valid_word(self, word):\n        \"\"\"\n        Checks if a word is valid.\n\n        Args:\n            word (str): The word to check.\n\n        Returns:\n            bool: True if the word is valid, False otherwise.\n        \"\"\"\n        word = word.upper()\n        if len(word) < 3:\n            return False\n        if word in self.found_words:\n            return False\n        if word not in self.dictionary:\n            return False\n        return True\n\n    def find_word_on_board(self, word):\n        \"\"\"\n        Checks if a word can be found on the Boggle board.\n\n        Args:\n            word (str): The word to find.\n\n        Returns:\n            bool: True if the word can be found, False otherwise.\n        \"\"\"\n        word = word.upper()\n        for row in range(self.size):\n            for col in range(self.size):\n                if self.board[row][col] == word[0]:\n                    if self.search_word(word, row, col, 0, set()):\n                        return True\n        return False\n\n    def search_word(self, word, row, col, index, visited):\n        \"\"\"\n        Recursively searches for the word on the board.\n\n        Args:\n            word (str): The word to search for.\n            row (int): The current row.\n            col (int): The current column.\n            index (int): The current index in the word.\n            visited (set): A set of visited coordinates.\n\n        Returns:\n            bool: True if the word is found, False otherwise.\n        \"\"\"\n        if index == len(word):\n            return True\n\n        if row < 0 or row >= self.size or col < 0 or col >= self.size:\n            return False\n\n        if (row, col) in visited:\n            return False\n\n        if self.board[row][col] != word[index]:\n            return False\n\n        visited.add((row, col))\n\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                new_row = row + dr\n                new_col = col + dc\n                if self.search_word(word, new_row, new_col, index + 1, visited.copy()):\n                    return True\n\n        return False\n\n    def play(self):\n        \"\"\"\n        Runs the Boggle game.\n        \"\"\"\n        self.start_time = time.time()\n        self.display_board()\n\n        while not self.game_over:\n            elapsed_time = time.time() - self.start_time\n            remaining_time = self.time_limit - elapsed_time\n\n            if remaining_time <= 0:\n                self.game_over = True\n                print(\"Time's up!\")\n                break\n\n            print(f\"Time remaining: {int(remaining_time)} seconds\")\n            word = input(\"Enter a word (or type 'quit' to end): \").strip()\n\n            if word.lower() == \"quit\":\n                self.game_over = True\n                break\n\n            if self.is_valid_word(word) and self.find_word_on_board(word):\n                self.found_words.add(word.upper())\n                print(\"Valid word!\")\n            else:\n                print(\"Invalid word.\")\n\n        self.end_game()\n\n    def end_game(self):\n        \"\"\"\n        Ends the game and displays the results.\n        \"\"\"\n        print(\"\\nGame Over!\")\n        print(\"Words you found:\")\n        for word in sorted(self.found_words):\n            print(word)\n        print(f\"\\nTotal score: {len(self.found_words)}\")\n\n\nif __name__ == \"__main__\":\n    game = Boggle()\n    game.play()\n```",
    "16": "```python\nimport random\nimport time\nimport os\n\nclass PacmanGame:\n    \"\"\"\n    A command-line Pac-Man game implementation.\n    \"\"\"\n\n    def __init__(self, width=15, height=10, num_ghosts=2):\n        \"\"\"\n        Initializes the game board, Pac-Man, ghosts, and food.\n\n        Args:\n            width (int): The width of the game board.\n            height (int): The height of the game board.\n            num_ghosts (int): The number of ghosts in the game.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.num_ghosts = num_ghosts\n        self.board = [[' ' for _ in range(width)] for _ in range(height)]\n        self.pacman_x = width // 2\n        self.pacman_y = height // 2\n        self.board[self.pacman_y][self.pacman_x] = 'P'\n        self.ghosts = []\n        for _ in range(num_ghosts):\n            self.ghosts.append(self.create_ghost())\n        self.food_count = 0\n        self.place_food()\n        self.score = 0\n        self.game_over = False\n        self.won = False\n\n    def create_ghost(self):\n        \"\"\"\n        Creates a ghost at a random location on the board, avoiding Pac-Man's starting position.\n\n        Returns:\n            tuple: The (x, y) coordinates of the new ghost.\n        \"\"\"\n        while True:\n            x = random.randint(0, self.width - 1)\n            y = random.randint(0, self.height - 1)\n            if (x, y) != (self.pacman_x, self.pacman_y) and self.board[y][x] != 'G':\n                return (x, y)\n\n    def place_food(self):\n        \"\"\"\n        Places food ('o') on the board at empty locations.\n        \"\"\"\n        for y in range(self.height):\n            for x in range(self.width):\n                if self.board[y][x] == ' ':\n                    self.board[y][x] = 'o'\n                    self.food_count += 1\n\n    def print_board(self):\n        \"\"\"\n        Prints the current state of the game board to the console.\n        \"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n        print(\"-\" * (self.width + 2))\n        for row in self.board:\n            print(\"|\" + \"\".join(row) + \"|\")\n        print(\"-\" * (self.width + 2))\n        print(f\"Score: {self.score}\")\n        print(\"Use WASD to move. Press Q to quit.\")\n\n    def move_pacman(self, direction):\n        \"\"\"\n        Moves Pac-Man based on the given direction (W, A, S, D).\n\n        Args:\n            direction (str): The direction to move Pac-Man ('W', 'A', 'S', 'D').\n        \"\"\"\n        new_x = self.pacman_x\n        new_y = self.pacman_y\n\n        if direction == 'W':\n            new_y -= 1\n        elif direction == 'S':\n            new_y += 1\n        elif direction == 'A':\n            new_x -= 1\n        elif direction == 'D':\n            new_x += 1\n\n        if 0 <= new_x < self.width and 0 <= new_y < self.height:\n            if self.board[new_y][new_x] == 'o':\n                self.score += 10\n                self.food_count -= 1\n            elif self.board[new_y][new_x] == 'G':\n                self.game_over = True\n                return\n\n            self.board[self.pacman_y][self.pacman_x] = ' '\n            self.pacman_x = new_x\n            self.pacman_y = new_y\n            self.board[self.pacman_y][self.pacman_x] = 'P'\n\n            if self.food_count == 0:\n                self.won = True\n                self.game_over = True\n\n    def move_ghosts(self):\n        \"\"\"\n        Moves each ghost randomly to an adjacent empty location.\n        \"\"\"\n        for i in range(len(self.ghosts)):\n            x, y = self.ghosts[i]\n            possible_moves = []\n            if x > 0 and self.board[y][x - 1] != 'G' and self.board[y][x - 1] != 'P':\n                possible_moves.append((x - 1, y))\n            if x < self.width - 1 and self.board[y][x + 1] != 'G' and self.board[y][x + 1] != 'P':\n                possible_moves.append((x + 1, y))\n            if y > 0 and self.board[y - 1][x] != 'G' and self.board[y - 1][x] != 'P':\n                possible_moves.append((x, y - 1))\n            if y < self.height - 1 and self.board[y + 1][x] != 'G' and self.board[y + 1][x] != 'P':\n                possible_moves.append((x, y + 1))\n\n            if possible_moves:\n                new_x, new_y = random.choice(possible_moves)\n                self.board[y][x] = ' '  # Clear the ghost's previous position\n\n                if (new_x, new_y) == (self.pacman_x, self.pacman_y):\n                    self.game_over = True\n                    return\n\n                self.ghosts[i] = (new_x, new_y)\n                self.board[new_y][new_x] = 'G'\n\n    def run(self):\n        \"\"\"\n        Runs the main game loop.\n        \"\"\"\n        while not self.game_over:\n            self.print_board()\n            move = input(\"Enter move (W/A/S/D) or Q to quit: \").upper()\n\n            if move == 'Q':\n                self.game_over = True\n                break\n\n            self.move_pacman(move)\n            if self.game_over:\n                break\n            self.move_ghosts()\n            if self.game_over:\n                break\n            time.sleep(0.2)\n\n        self.print_board()\n        if self.won:\n            print(\"Congratulations! You won!\")\n        elif self.game_over:\n            print(\"Game Over! You were caught by a ghost.\")\n        print(f\"Final Score: {self.score}\")\n\n\nif __name__ == \"__main__\":\n    game = PacmanGame()\n    game.run()\n```",
    "17": "```python\nimport random\nimport time\nimport os\n\nclass DinosaurRunner:\n    def __init__(self, width=80, height=15):\n        self.width = width\n        self.height = height\n        self.dino = 2  # Dino's vertical position\n        self.cactus_position = self.width - 5  # Cactus initial position\n        self.score = 0\n        self.game_over = False\n        self.cactus_speed = 1  # Cactus movement speed\n        self.jump_height = 4\n        self.is_jumping = False\n        self.jump_peak = 0\n        self.jump_direction = 1 # 1 for up, -1 for down\n\n    def clear_screen(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n\n    def draw_screen(self):\n        \"\"\"Draws the game screen in the console.\"\"\"\n        screen = [[' ' for _ in range(self.width)] for _ in range(self.height)]\n\n        # Draw ground\n        for i in range(self.width):\n            screen[self.height - 1][i] = '_'\n\n        # Draw dino\n        if self.is_jumping:\n            dino_height = self.dino - (self.jump_peak - abs(self.jump_peak - self.jump_height))\n            screen[int(dino_height)][2] = 'D'\n        else:\n            screen[self.dino][2] = 'D'\n\n        # Draw cactus\n        screen[self.height - 2][self.cactus_position] = '#'\n        screen[self.height - 3][self.cactus_position] = '#'\n\n        # Print the screen\n        self.clear_screen()\n        for row in screen:\n            print(''.join(row))\n\n        print(f\"Score: {self.score}\")\n\n    def update_game(self):\n        \"\"\"Updates the game state - moves cactus, checks for collisions, etc.\"\"\"\n\n        # Move cactus\n        self.cactus_position -= self.cactus_speed\n        if self.cactus_position < 0:\n            self.cactus_position = self.width - 1\n            self.score += 1\n            self.cactus_speed = min(1 + self.score // 10, 5)  # Increase speed\n\n        # Jumping logic\n        if self.is_jumping:\n            self.jump_peak += self.jump_direction\n            if self.jump_peak == self.jump_height :\n                self.jump_direction = -1\n            elif self.jump_peak == 0:\n                self.is_jumping = False\n                self.jump_direction = 1\n\n        # Collision detection (simplified)\n        if 1 <= self.cactus_position <= 3:\n            if not self.is_jumping:\n                self.game_over = True\n                print(\"Game Over!\")\n\n    def handle_input(self, input_char):\n        \"\"\"Handles user input.  'j' for jump.\"\"\"\n        if input_char == 'j' and not self.is_jumping:\n            self.is_jumping = True\n            self.jump_peak = 0\n            self.jump_direction = 1 # Start going up\n\n    def play(self):\n        \"\"\"Main game loop.\"\"\"\n        while not self.game_over:\n            self.draw_screen()\n            self.update_game()\n\n            # Get input (non-blocking)\n            input_char = None\n            try:\n                import termios, sys, tty\n                def getch():\n                    fd = sys.stdin.fileno()\n                    old_settings = termios.tcgetattr(fd)\n                    try:\n                        tty.setraw(sys.stdin.fileno())\n                        ch = sys.stdin.read(1)\n                    finally:\n                        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n                    return ch\n                input_char = getch()\n            except ImportError: # For Windows (no termios)\n                import msvcrt\n                if msvcrt.kbhit():\n                    input_char = msvcrt.getch().decode('utf-8')\n\n            if input_char:\n                self.handle_input(input_char)\n\n            time.sleep(0.1)  # Adjust for desired game speed\n\n        print(f\"Final Score: {self.score}\")\n        input(\"Press Enter to exit.\")\n\n\nif __name__ == '__main__':\n    game = DinosaurRunner()\n    game.play()\n```"
}