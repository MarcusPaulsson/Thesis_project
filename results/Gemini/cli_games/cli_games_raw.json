{
    "0": "```python\nclass TicTacToe:\n    def __init__(self):\n        self.board = [\" \" for _ in range(9)]  # Represents the board as a list\n        self.current_player = \"X\"\n        self.winner = None\n        self.game_over = False\n\n    def print_board(self):\n        \"\"\"Prints the current state of the board.\"\"\"\n        print(\"-------------\")\n        for i in range(3):\n            print(f\"| {self.board[i * 3]} | {self.board[i * 3 + 1]} | {self.board[i * 3 + 2]} |\")\n            print(\"-------------\")\n\n    def is_valid_move(self, move):\n        \"\"\"Checks if a move is valid (within range and the cell is empty).\"\"\"\n        if not move.isdigit():\n            return False\n        move = int(move)\n        if 0 <= move <= 8 and self.board[move] == \" \":\n            return True\n        return False\n\n    def make_move(self, move):\n        \"\"\"Makes a move on the board.\"\"\"\n        move = int(move)\n        self.board[move] = self.current_player\n        self.check_winner()\n        self.check_draw()\n        self.switch_player()\n\n    def switch_player(self):\n        \"\"\"Switches the current player.\"\"\"\n        self.current_player = \"O\" if self.current_player == \"X\" else \"X\"\n\n    def check_winner(self):\n        \"\"\"Checks if there is a winner.\"\"\"\n        winning_combinations = [\n            [0, 1, 2], [3, 4, 5], [6, 7, 8],  # Rows\n            [0, 3, 6], [1, 4, 7], [2, 5, 8],  # Columns\n            [0, 4, 8], [2, 4, 6]               # Diagonals\n        ]\n\n        for combo in winning_combinations:\n            if (self.board[combo[0]] == self.board[combo[1]] == self.board[combo[2]]\n                    and self.board[combo[0]] != \" \"):\n                self.winner = self.current_player\n                self.game_over = True\n                return\n\n    def check_draw(self):\n        \"\"\"Checks if the game is a draw.\"\"\"\n        if \" \" not in self.board and not self.winner:\n            self.game_over = True\n\n    def play(self):\n        \"\"\"Main game loop.\"\"\"\n        while not self.game_over:\n            self.print_board()\n            move = input(f\"Player {self.current_player}, enter your move (0-8): \")\n\n            if self.is_valid_move(move):\n                self.make_move(move)\n            else:\n                print(\"Invalid move. Try again.\")\n\n        self.print_board()  # Print the final board\n\n        if self.winner:\n            print(f\"Player {self.winner} wins!\")\n        else:\n            print(\"It's a draw!\")\n\n\nif __name__ == \"__main__\":\n    game = TicTacToe()\n    game.play()\n```",
    "1": "```python\nimport random\n\nclass Hangman:\n    def __init__(self, word_list, max_attempts=6):\n        \"\"\"\n        Initializes the Hangman game.\n\n        Args:\n            word_list (list): A list of words to choose from.\n            max_attempts (int): The maximum number of incorrect guesses allowed.\n        \"\"\"\n        self.word_list = word_list\n        self.word = random.choice(word_list).upper()\n        self.guessed_letters = set()\n        self.attempts_left = max_attempts\n        self.word_completion = [\"_\" for _ in self.word]\n        self.game_over = False\n\n    def display_word(self):\n        \"\"\"\n        Returns the current state of the word with guessed letters revealed.\n        \"\"\"\n        return \" \".join(self.word_completion)\n\n    def display_status(self):\n        \"\"\"\n        Displays the current game status to the user.\n        \"\"\"\n        print(f\"\\nWord: {self.display_word()}\")\n        print(f\"Attempts left: {self.attempts_left}\")\n        print(f\"Guessed letters: {', '.join(sorted(self.guessed_letters))}\")\n\n    def get_guess(self):\n        \"\"\"\n        Prompts the user for a letter guess and validates the input.\n\n        Returns:\n            str: The valid letter guess (uppercase).\n        \"\"\"\n        while True:\n            guess = input(\"Guess a letter: \").upper()\n\n            if not guess.isalpha():\n                print(\"Invalid input. Please enter a letter.\")\n            elif len(guess) != 1:\n                print(\"Please guess only one letter at a time.\")\n            elif guess in self.guessed_letters:\n                print(\"You already guessed that letter.\")\n            else:\n                return guess\n\n    def process_guess(self, guess):\n        \"\"\"\n        Processes the user's guess, updating the game state.\n\n        Args:\n            guess (str): The letter guessed by the user.\n        \"\"\"\n        self.guessed_letters.add(guess)\n\n        if guess in self.word:\n            for i, letter in enumerate(self.word):\n                if letter == guess:\n                    self.word_completion[i] = guess\n            if \"_\" not in self.word_completion:\n                self.game_over = True\n                print(\"Congratulations! You guessed the word!\")\n        else:\n            self.attempts_left -= 1\n            print(\"Incorrect guess.\")\n            if self.attempts_left == 0:\n                self.game_over = True\n                print(f\"You ran out of attempts. The word was {self.word}.\")\n\n    def play(self):\n        \"\"\"\n        Runs the main game loop.\n        \"\"\"\n        print(\"Welcome to Hangman!\")\n\n        while not self.game_over:\n            self.display_status()\n            guess = self.get_guess()\n            self.process_guess(guess)\n\n        # Display the final word if the game ended without winning.\n        if \"_\" in self.word_completion:\n            print(f\"The word was: {self.word}\")\n\n\nif __name__ == \"__main__\":\n    word_list = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\", \"fig\", \"grape\"]\n    game = Hangman(word_list)\n    game.play()\n```",
    "2": "```python\nimport random\n\nclass RockPaperScissors:\n    \"\"\"\n    A class to represent the Rock-Paper-Scissors game.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the game with player and computer scores set to 0.\n        \"\"\"\n        self.player_score = 0\n        self.computer_score = 0\n        self.choices = [\"rock\", \"paper\", \"scissors\"]\n\n    def get_player_choice(self):\n        \"\"\"\n        Gets the player's choice from the command line.\n        Validates the input to ensure it's a valid choice.\n\n        Returns:\n            str: The player's choice (rock, paper, or scissors).\n        \"\"\"\n        while True:\n            choice = input(\"Choose rock, paper, or scissors: \").lower()\n            if choice in self.choices:\n                return choice\n            else:\n                print(\"Invalid choice. Please choose rock, paper, or scissors.\")\n\n    def get_computer_choice(self):\n        \"\"\"\n        Generates a random choice for the computer.\n\n        Returns:\n            str: The computer's choice (rock, paper, or scissors).\n        \"\"\"\n        return random.choice(self.choices)\n\n    def determine_winner(self, player_choice, computer_choice):\n        \"\"\"\n        Determines the winner of the round based on player and computer choices.\n\n        Args:\n            player_choice (str): The player's choice.\n            computer_choice (str): The computer's choice.\n\n        Returns:\n            str: A message indicating the winner of the round.\n        \"\"\"\n        print(f\"You chose: {player_choice}\")\n        print(f\"Computer chose: {computer_choice}\")\n\n        if player_choice == computer_choice:\n            return \"It's a tie!\"\n        elif (player_choice == \"rock\" and computer_choice == \"scissors\") or \\\n             (player_choice == \"paper\" and computer_choice == \"rock\") or \\\n             (player_choice == \"scissors\" and computer_choice == \"paper\"):\n            self.player_score += 1\n            return \"You win!\"\n        else:\n            self.computer_score += 1\n            return \"Computer wins!\"\n\n    def play_round(self):\n        \"\"\"\n        Plays a single round of the game.\n        \"\"\"\n        player_choice = self.get_player_choice()\n        computer_choice = self.get_computer_choice()\n        result = self.determine_winner(player_choice, computer_choice)\n        print(result)\n        print(f\"Score - You: {self.player_score}, Computer: {self.computer_score}\")\n\n    def play_game(self, num_rounds=3):\n        \"\"\"\n        Plays the entire game for a specified number of rounds.\n\n        Args:\n            num_rounds (int): The number of rounds to play (default is 3).\n        \"\"\"\n        print(\"Welcome to Rock-Paper-Scissors!\")\n        for i in range(num_rounds):\n            print(f\"\\nRound {i+1}:\")\n            self.play_round()\n\n        print(\"\\nGame Over!\")\n        if self.player_score > self.computer_score:\n            print(\"You are the ultimate Rock-Paper-Scissors champion!\")\n        elif self.player_score < self.computer_score:\n            print(\"The computer reigns supreme!\")\n        else:\n            print(\"It's a draw! A true test of skill.\")\n\nif __name__ == \"__main__\":\n    game = RockPaperScissors()\n    game.play_game()\n```",
    "3": "```python\nimport random\nimport time\nimport os\n\nclass SnakeGame:\n    \"\"\"\n    A command-line Snake game implementation.\n    \"\"\"\n\n    def __init__(self, width=20, height=10, initial_length=3):\n        \"\"\"\n        Initializes the game.\n\n        Args:\n            width (int): The width of the game board.\n            height (int): The height of the game board.\n            initial_length (int): The initial length of the snake.\n        \"\"\"\n\n        self.width = width\n        self.height = height\n        self.snake = [(width // 2, height // 2 - i) for i in range(initial_length)]  # Start in the middle, going up\n        self.food = self.create_food()\n        self.direction = \"down\"  # Initial direction\n        self.game_over = False\n        self.score = 0\n        self.delay = 0.2 # Delay between moves (seconds)\n\n    def create_food(self):\n        \"\"\"\n        Creates food at a random location that is not occupied by the snake.\n\n        Returns:\n            tuple: The coordinates (x, y) of the food.\n        \"\"\"\n\n        while True:\n            x = random.randint(0, self.width - 1)\n            y = random.randint(0, self.height - 1)\n            if (x, y) not in self.snake:\n                return (x, y)\n\n    def move(self):\n        \"\"\"\n        Moves the snake one step in the current direction.\n        \"\"\"\n\n        head_x, head_y = self.snake[0]\n\n        if self.direction == \"up\":\n            new_head = (head_x, head_y - 1)\n        elif self.direction == \"down\":\n            new_head = (head_x, head_y + 1)\n        elif self.direction == \"left\":\n            new_head = (head_x - 1, head_y)\n        elif self.direction == \"right\":\n            new_head = (head_x + 1, head_y)\n        else:\n            raise ValueError(\"Invalid direction\")\n\n        # Check for game over conditions (collision with wall or self)\n        if (\n            new_head[0] < 0\n            or new_head[0] >= self.width\n            or new_head[1] < 0\n            or new_head[1] >= self.height\n            or new_head in self.snake\n        ):\n            self.game_over = True\n            return\n\n        self.snake.insert(0, new_head)  # Add new head\n\n        # Check if food was eaten\n        if new_head == self.food:\n            self.score += 1\n            self.food = self.create_food()\n            self.delay *= 0.95 # Speed up slightly\n        else:\n            self.snake.pop()  # Remove tail if no food eaten\n\n    def change_direction(self, new_direction):\n        \"\"\"\n        Changes the direction of the snake, preventing immediate reversal.\n\n        Args:\n            new_direction (str): The new direction (\"up\", \"down\", \"left\", \"right\").\n        \"\"\"\n\n        if new_direction == \"up\" and self.direction != \"down\":\n            self.direction = \"up\"\n        elif new_direction == \"down\" and self.direction != \"up\":\n            self.direction = \"down\"\n        elif new_direction == \"left\" and self.direction != \"right\":\n            self.direction = \"left\"\n        elif new_direction == \"right\" and self.direction != \"left\":\n            self.direction = \"right\"\n\n    def draw_board(self):\n        \"\"\"\n        Draws the game board in the console.\n        \"\"\"\n\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n        print(f\"Score: {self.score}\")\n\n        for y in range(self.height):\n            for x in range(self.width):\n                if (x, y) == self.food:\n                    print(\"F\", end=\"\")\n                elif (x, y) in self.snake:\n                    if (x,y) == self.snake[0]:\n                        print(\"H\", end=\"\") # Head\n                    else:\n                        print(\"S\", end=\"\")\n                else:\n                    print(\" \", end=\"\")\n            print()  # Newline at the end of each row\n\n    def play(self):\n        \"\"\"\n        Plays the game.\n        \"\"\"\n\n        while not self.game_over:\n            self.draw_board()\n            self.move()\n            time.sleep(self.delay)\n\n            # Get user input (non-blocking)\n            import select\n            import sys\n\n            if select.select([sys.stdin], [], [], 0)[0]:\n                key = sys.stdin.read(1)\n\n                if key == \"w\":\n                    self.change_direction(\"up\")\n                elif key == \"s\":\n                    self.change_direction(\"down\")\n                elif key == \"a\":\n                    self.change_direction(\"left\")\n                elif key == \"d\":\n                    self.change_direction(\"right\")\n                elif key == \"q\":\n                    self.game_over = True # Quit\n\n        print(\"Game Over!\")\n        print(f\"Final Score: {self.score}\")\n\n\nif __name__ == \"__main__\":\n    game = SnakeGame()\n    game.play()\n```",
    "4": "```python\nimport random\n\nclass Minesweeper:\n    def __init__(self, rows, cols, mines):\n        self.rows = rows\n        self.cols = cols\n        self.mines = mines\n        self.board = [[' ' for _ in range(cols)] for _ in range(rows)]\n        self.revealed = [[False for _ in range(cols)] for _ in range(rows)]\n        self.flags = [[False for _ in range(cols)] for _ in range(rows)]\n        self.game_over = False\n        self.won = False\n        self.mine_locations = []\n        self.place_mines()\n        self.calculate_neighboring_mines()\n\n    def place_mines(self):\n        \"\"\"Places mines randomly on the board.\"\"\"\n        mine_count = 0\n        while mine_count < self.mines:\n            row = random.randint(0, self.rows - 1)\n            col = random.randint(0, self.cols - 1)\n            if (row, col) not in self.mine_locations:\n                self.mine_locations.append((row, col))\n                mine_count += 1\n\n    def calculate_neighboring_mines(self):\n        \"\"\"Calculates the number of mines adjacent to each cell.\"\"\"\n        for row in range(self.rows):\n            for col in range(self.cols):\n                if (row, col) not in self.mine_locations:\n                    count = 0\n                    for i in range(max(0, row - 1), min(self.rows, row + 2)):\n                        for j in range(max(0, col - 1), min(self.cols, col + 2)):\n                            if (i, j) in self.mine_locations:\n                                count += 1\n                    self.board[row][col] = str(count) if count > 0 else ' '\n\n    def print_board(self, reveal_all=False):\n        \"\"\"Prints the board to the console.\"\"\"\n        header = \"   \" + \" \".join(str(i) for i in range(self.cols))\n        print(header)\n        print(\"  \" + \"-\" * (2 * self.cols + 1))\n        for i in range(self.rows):\n            row_str = str(i) + \"| \"\n            for j in range(self.cols):\n                if reveal_all:\n                    if (i, j) in self.mine_locations:\n                        row_str += \"* \"\n                    else:\n                        row_str += self.board[i][j] + \" \"\n                else:\n                    if self.revealed[i][j]:\n                        row_str += self.board[i][j] + \" \"\n                    elif self.flags[i][j]:\n                        row_str += \"F \"\n                    else:\n                        row_str += \". \"\n            print(row_str)\n\n    def reveal_cell(self, row, col):\n        \"\"\"Reveals a cell and its adjacent cells if it's empty.\"\"\"\n        if not (0 <= row < self.rows and 0 <= col < self.cols):\n            return\n\n        if self.revealed[row][col] or self.flags[row][col]:\n            return\n\n        self.revealed[row][col] = True\n\n        if (row, col) in self.mine_locations:\n            self.game_over = True\n            return\n\n        if self.board[row][col] == ' ':\n            for i in range(max(0, row - 1), min(self.rows, row + 2)):\n                for j in range(max(0, col - 1), min(self.cols, col + 2)):\n                    self.reveal_cell(i, j)\n\n    def flag_cell(self, row, col):\n        \"\"\"Flags a cell as a mine.\"\"\"\n        if not (0 <= row < self.rows and 0 <= col < self.cols):\n            return\n\n        if self.revealed[row][col]:\n            return\n\n        self.flags[row][col] = not self.flags[row][col]\n\n    def check_win(self):\n        \"\"\"Checks if the player has won the game.\"\"\"\n        revealed_count = 0\n        for row in range(self.rows):\n            for col in range(self.cols):\n                if self.revealed[row][col]:\n                    revealed_count += 1\n\n        if revealed_count == self.rows * self.cols - self.mines:\n            self.won = True\n            self.game_over = True\n\n    def play(self):\n        \"\"\"Plays the game.\"\"\"\n        while not self.game_over:\n            self.print_board()\n            action = input(\"Enter action (reveal r, flag f, quit q) and coordinates (row col): \").split()\n\n            if not action:\n                print(\"Invalid input.\")\n                continue\n\n            if action[0].lower() == 'q':\n                print(\"Quitting the game.\")\n                self.game_over = True\n                break\n\n            if len(action) != 3:\n                print(\"Invalid input.  Please provide action, row, and column.\")\n                continue\n\n            try:\n                row = int(action[1])\n                col = int(action[2])\n            except ValueError:\n                print(\"Invalid row or column.  Please enter numbers.\")\n                continue\n\n            if not (0 <= row < self.rows and 0 <= col < self.cols):\n                print(\"Invalid row or column.  Out of bounds.\")\n                continue\n\n            if action[0].lower() == 'r':\n                self.reveal_cell(row, col)\n            elif action[0].lower() == 'f':\n                self.flag_cell(row, col)\n            else:\n                print(\"Invalid action.  Use 'r' to reveal, 'f' to flag, or 'q' to quit.\")\n                continue\n\n            self.check_win()\n\n            if self.game_over:\n                self.print_board(reveal_all=True)\n                if self.won:\n                    print(\"Congratulations! You won!\")\n                else:\n                    print(\"Game over! You hit a mine.\")\n\n\nif __name__ == \"__main__\":\n    rows = 10\n    cols = 10\n    mines = 12\n    game = Minesweeper(rows, cols, mines)\n    game.play()\n```",
    "5": "```python\nimport random\n\nclass Mastermind:\n    def __init__(self, code_length=4, colors=6, max_guesses=10):\n        \"\"\"\n        Initializes a Mastermind game.\n\n        Args:\n            code_length (int): The length of the code to be guessed.\n            colors (int): The number of different colors available.\n            max_guesses (int): The maximum number of guesses allowed.\n        \"\"\"\n        self.code_length = code_length\n        self.colors = colors\n        self.max_guesses = max_guesses\n        self.secret_code = self._generate_secret_code()\n        self.guesses_remaining = max_guesses\n        self.history = []  # Store guesses and feedback\n        self.game_over = False\n\n    def _generate_secret_code(self):\n        \"\"\"\n        Generates a random secret code.\n\n        Returns:\n            list: A list representing the secret code.\n        \"\"\"\n        return [random.randint(1, self.colors) for _ in range(self.code_length)]\n\n    def _get_feedback(self, guess):\n        \"\"\"\n        Provides feedback on a guess.\n\n        Args:\n            guess (list): The player's guess.\n\n        Returns:\n            tuple: A tuple containing the number of exact matches and partial matches.\n        \"\"\"\n        exact_matches = 0\n        partial_matches = 0\n        temp_secret = self.secret_code[:]  # Create a copy to avoid modifying the original\n        temp_guess = guess[:]\n\n        # Count exact matches first\n        for i in range(self.code_length):\n            if temp_guess[i] == temp_secret[i]:\n                exact_matches += 1\n                temp_secret[i] = None  # Mark as matched\n                temp_guess[i] = None\n\n        # Count partial matches\n        for i in range(self.code_length):\n            if temp_guess[i] is not None:\n                try:\n                    index = temp_secret.index(temp_guess[i])\n                    partial_matches += 1\n                    temp_secret[index] = None  # Mark as matched\n                except ValueError:\n                    pass  # Color not found in the secret code\n\n        return exact_matches, partial_matches\n\n    def make_guess(self, guess):\n        \"\"\"\n        Processes a player's guess.\n\n        Args:\n            guess (list): The player's guess.\n\n        Returns:\n            tuple: A tuple containing the number of exact matches and partial matches,\n                   or None if the game is over or the guess is invalid.\n        \"\"\"\n        if self.game_over:\n            print(\"Game is over. You can't make more guesses.\")\n            return None\n\n        if len(guess) != self.code_length:\n            print(f\"Invalid guess length.  Must be {self.code_length} digits.\")\n            return None\n\n        for color in guess:\n            if not isinstance(color, int) or color < 1 or color > self.colors:\n                print(f\"Invalid color. Colors must be integers between 1 and {self.colors}.\")\n                return None\n\n        self.guesses_remaining -= 1\n        exact_matches, partial_matches = self._get_feedback(guess)\n        self.history.append((guess, exact_matches, partial_matches))\n\n        if exact_matches == self.code_length:\n            print(\"Congratulations! You cracked the code.\")\n            self.game_over = True\n        elif self.guesses_remaining == 0:\n            print(\"You ran out of guesses. Game over.\")\n            print(f\"The secret code was: {self.secret_code}\")\n            self.game_over = True\n        else:\n            print(f\"Exact matches: {exact_matches}, Partial matches: {partial_matches}\")\n            print(f\"Guesses remaining: {self.guesses_remaining}\")\n\n        return exact_matches, partial_matches\n\n    def display_history(self):\n        \"\"\"\n        Displays the guess history.\n        \"\"\"\n        print(\"\\nGuess History:\")\n        for guess, exact, partial in self.history:\n            print(f\"Guess: {guess}, Exact: {exact}, Partial: {partial}\")\n\n    def play(self):\n        \"\"\"\n        Plays the Mastermind game.\n        \"\"\"\n        print(f\"Welcome to Mastermind!\")\n        print(f\"I have generated a secret code of length {self.code_length} using colors 1 to {self.colors}.\")\n        print(f\"You have {self.max_guesses} guesses to crack the code.\")\n\n        while not self.game_over:\n            try:\n                guess_str = input(f\"Enter your guess (separated by spaces, e.g., '1 2 3 4'): \")\n                guess = [int(x) for x in guess_str.split()]\n            except ValueError:\n                print(\"Invalid input. Please enter numbers separated by spaces.\")\n                continue\n\n            self.make_guess(guess)\n            self.display_history()\n\n\nif __name__ == \"__main__\":\n    game = Mastermind()  # You can customize the game by passing arguments\n    game.play()\n```",
    "6": "```python\nimport random\n\nclass Battleship:\n    def __init__(self, board_size=10, num_ships=5):\n        \"\"\"\n        Initializes the Battleship game.\n\n        Args:\n            board_size (int): The size of the game board (e.g., 10 for a 10x10 board).\n            num_ships (int): The number of ships each player will have.\n        \"\"\"\n        self.board_size = board_size\n        self.num_ships = num_ships\n        self.player_board = self.create_board()\n        self.computer_board = self.create_board()\n        self.player_ships = self.place_ships(self.player_board)\n        self.computer_ships = self.place_ships(self.computer_board)\n        self.computer_guesses = set()  # To avoid redundant guesses\n        self.player_ships_sunk = 0\n        self.computer_ships_sunk = 0\n\n    def create_board(self):\n        \"\"\"\n        Creates an empty game board represented as a 2D list.\n\n        Returns:\n            list: A 2D list representing the game board.\n        \"\"\"\n        return [[' ' for _ in range(self.board_size)] for _ in range(self.board_size)]\n\n    def place_ships(self, board):\n        \"\"\"\n        Randomly places ships on the given board.\n\n        Args:\n            board (list): The game board to place ships on.\n\n        Returns:\n            list: A list of ship coordinates (tuples) representing the ships placed.\n        \"\"\"\n        ships = []\n        for _ in range(self.num_ships):\n            while True:\n                orientation = random.choice(['horizontal', 'vertical'])\n                if orientation == 'horizontal':\n                    row = random.randint(0, self.board_size - 1)\n                    col = random.randint(0, self.board_size - 2) # At least 2 spaces for a ship of size 2\n                    if all(board[row][col + i] == ' ' for i in range(2)):\n                        for i in range(2):\n                            board[row][col + i] = 'S'\n                            ships.append((row, col + i))\n                        break\n                else:  # Vertical\n                    row = random.randint(0, self.board_size - 2) # At least 2 spaces for a ship of size 2\n                    col = random.randint(0, self.board_size - 1)\n                    if all(board[row + i][col] == ' ' for i in range(2)):\n                        for i in range(2):\n                            board[row + i][col] = 'S'\n                            ships.append((row + i, col))\n                        break\n        return ships\n\n    def print_board(self, board, hide_ships=False):\n        \"\"\"\n        Prints the game board to the console.\n\n        Args:\n            board (list): The game board to print.\n            hide_ships (bool): Whether to hide the ships ('S') on the board.\n                                 Defaults to False (ships are shown).\n        \"\"\"\n        print(\"  \" + \" \".join([chr(65 + i) for i in range(self.board_size)])) # A, B, C...\n        for i in range(self.board_size):\n            row_str = str(i + 1).rjust(2) + \" \"  # Row numbers, right-aligned\n            for j in range(self.board_size):\n                if hide_ships and board[i][j] == 'S':\n                    row_str += ' ' + \" \"\n                else:\n                    row_str += board[i][j] + \" \"\n            print(row_str)\n\n    def get_player_guess(self):\n        \"\"\"\n        Gets the player's guess for a coordinate.\n\n        Returns:\n            tuple: The (row, col) coordinates of the player's guess, or None if invalid.\n        \"\"\"\n        while True:\n            try:\n                guess = input(\"Enter your guess (e.g., A1): \").upper()\n                if len(guess) < 2:\n                    print(\"Invalid guess.  Try again (e.g., A1).\")\n                    continue\n                col = ord(guess[0]) - 65  # Convert letter to column index (A=0, B=1, ...)\n                row = int(guess[1:]) - 1    # Convert number to row index (1=0, 2=1, ...)\n\n                if 0 <= row < self.board_size and 0 <= col < self.board_size:\n                    return (row, col)\n                else:\n                    print(\"Invalid guess. Coordinates out of bounds.\")\n            except ValueError:\n                print(\"Invalid guess.  Try again (e.g., A1).\")\n            except IndexError:\n                print(\"Invalid guess.  Try again (e.g., A1).\")\n\n    def computer_make_guess(self):\n        \"\"\"\n        Generates a random guess for the computer.\n\n        Returns:\n            tuple: The (row, col) coordinates of the computer's guess.\n        \"\"\"\n        while True:\n            row = random.randint(0, self.board_size - 1)\n            col = random.randint(0, self.board_size - 1)\n            if (row, col) not in self.computer_guesses:\n                self.computer_guesses.add((row, col))\n                return (row, col)\n\n    def check_hit(self, board, row, col):\n        \"\"\"\n        Checks if a guess hits a ship on the board.\n\n        Args:\n            board (list): The game board.\n            row (int): The row coordinate of the guess.\n            col (int): The column coordinate of the guess.\n\n        Returns:\n            bool: True if the guess hits a ship, False otherwise.\n        \"\"\"\n        if board[row][col] == 'S':\n            board[row][col] = 'X'  # Mark as hit\n            return True\n        elif board[row][col] == ' ':\n            board[row][col] = 'O'  # Mark as miss\n            return False\n        else:  # Already hit or missed\n            return False\n\n    def play_round(self):\n        \"\"\"\n        Plays a single round of the game.\n        \"\"\"\n        # Player's turn\n        print(\"\\nYour board:\")\n        self.print_board(self.player_board)\n        print(\"\\nComputer's board:\")\n        self.print_board(self.computer_board, hide_ships=True)  # Hide computer's ships\n\n        player_guess = self.get_player_guess()\n        if player_guess:\n            row, col = player_guess\n            if self.check_hit(self.computer_board, row, col):\n                print(\"Hit!\")\n                self.computer_ships = [(r, c) for r, c in self.computer_ships if (r, c) != (row, col)]\n                if (row, col) in self.computer_ships:\n                    self.computer_ships.remove((row, col))\n                if self.computer_board[row][col] == 'X':\n                    self.computer_ships_sunk += 1\n                if self.computer_ships_sunk == self.num_ships * 2:\n                    return \"player_wins\"\n            else:\n                print(\"Miss!\")\n\n\n        # Computer's turn\n        print(\"\\nComputer's turn...\")\n        computer_guess = self.computer_make_guess()\n        row, col = computer_guess\n        if self.check_hit(self.player_board, row, col):\n            print(\"Computer hit your ship at\", chr(col + 65), row + 1, \"!\")\n            self.player_ships = [(r, c) for r, c in self.player_ships if (r, c) != (row, col)]\n            if (row, col) in self.player_ships:\n                self.player_ships.remove((row, col))\n\n            if self.player_board[row][col] == 'X':\n                self.player_ships_sunk += 1\n            if self.player_ships_sunk == self.num_ships * 2:\n                return \"computer_wins\"\n\n        else:\n            print(\"Computer missed at\", chr(col + 65), row + 1, \".\")\n\n        return None  # No winner yet\n\n    def play_game(self):\n        \"\"\"\n        Starts and runs the main game loop.\n        \"\"\"\n        print(\"Welcome to Battleship!\")\n        print(f\"Board size: {self.board_size}x{self.board_size}, Number of ships: {self.num_ships}\")\n\n        while True:\n            winner = self.play_round()\n            if winner:\n                if winner == \"player_wins\":\n                    print(\"\\nCongratulations! You sunk all the computer's ships!\")\n                elif winner == \"computer_wins\":\n                    print(\"\\nOh no! The computer sunk all your ships!\")\n                break\n\n\nif __name__ == \"__main__\":\n    game = Battleship()\n    game.play_game()\n```\n",
    "7": "```python\nimport argparse\nimport time\nimport random\nimport os\n\n\nclass GameOfLife:\n    def __init__(self, width, height, density=0.5):\n        \"\"\"\n        Initializes the Game of Life grid.\n\n        Args:\n            width (int): The width of the grid.\n            height (int): The height of the grid.\n            density (float): The initial density of live cells (0.0 to 1.0).\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.grid = self.create_grid(density)\n\n    def create_grid(self, density):\n        \"\"\"\n        Creates a grid with a specified density of live cells.\n\n        Args:\n            density (float): The density of live cells (0.0 to 1.0).\n\n        Returns:\n            list[list[int]]: A 2D list representing the grid.\n        \"\"\"\n        grid = []\n        for _ in range(self.height):\n            row = [1 if random.random() < density else 0 for _ in range(self.width)]\n            grid.append(row)\n        return grid\n\n    def get_neighbors(self, row, col):\n        \"\"\"\n        Gets the number of live neighbors for a given cell.\n\n        Args:\n            row (int): The row of the cell.\n            col (int): The column of the cell.\n\n        Returns:\n            int: The number of live neighbors.\n        \"\"\"\n        neighbors = 0\n        for i in range(max(0, row - 1), min(self.height, row + 2)):\n            for j in range(max(0, col - 1), min(self.width, col + 2)):\n                if (i, j) != (row, col):\n                    neighbors += self.grid[i][j]\n        return neighbors\n\n    def next_generation(self):\n        \"\"\"\n        Calculates the next generation of the grid.\n        \"\"\"\n        new_grid = []\n        for row in range(self.height):\n            new_row = []\n            for col in range(self.width):\n                neighbors = self.get_neighbors(row, col)\n                if self.grid[row][col] == 1:  # Live cell\n                    if neighbors < 2 or neighbors > 3:\n                        new_row.append(0)  # Dies\n                    else:\n                        new_row.append(1)  # Lives\n                else:  # Dead cell\n                    if neighbors == 3:\n                        new_row.append(1)  # Becomes alive\n                    else:\n                        new_row.append(0)  # Stays dead\n            new_grid.append(new_row)\n        self.grid = new_grid\n\n    def print_grid(self):\n        \"\"\"\n        Prints the current state of the grid to the console.\n        \"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n        for row in self.grid:\n            print(''.join(['*' if cell == 1 else ' ' for cell in row]))\n\n    def run(self, generations, delay=0.1):\n        \"\"\"\n        Runs the Game of Life for a specified number of generations.\n\n        Args:\n            generations (int): The number of generations to run.\n            delay (float): The delay between generations in seconds.\n        \"\"\"\n        for i in range(generations):\n            self.print_grid()\n            self.next_generation()\n            time.sleep(delay)\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='Conway\\'s Game of Life')\n    parser.add_argument('--width', type=int, default=60, help='Width of the grid')\n    parser.add_argument('--height', type=int, default=30, help='Height of the grid')\n    parser.add_argument('--generations', type=int, default=100, help='Number of generations to simulate')\n    parser.add_argument('--delay', type=float, default=0.1, help='Delay between generations (seconds)')\n    parser.add_argument('--density', type=float, default=0.3, help='Initial density of live cells (0.0 to 1.0)')\n\n    args = parser.parse_args()\n\n    game = GameOfLife(args.width, args.height, args.density)\n    game.run(args.generations, args.delay)\n```",
    "8": "```python\nclass ConnectFour:\n    def __init__(self, rows=6, cols=7):\n        self.rows = rows\n        self.cols = cols\n        self.board = [[' ' for _ in range(cols)] for _ in range(rows)]\n        self.current_player = 'X'\n        self.game_over = False\n\n    def print_board(self):\n        for row in self.board:\n            print('|' + '|'.join(row) + '|')\n        print('+' + '+'.join(['-'] * self.cols) + '+')\n        print(' ' + ' '.join(map(str, range(1, self.cols + 1))))\n\n    def is_valid_move(self, col):\n        return 0 <= col < self.cols and self.board[0][col] == ' '\n\n    def drop_piece(self, col):\n        for row in range(self.rows - 1, -1, -1):\n            if self.board[row][col] == ' ':\n                self.board[row][col] = self.current_player\n                return row\n\n    def check_win(self, row, col):\n        # Check horizontal\n        count = 0\n        for c in range(max(0, col - 3), min(self.cols, col + 4)):\n            if self.board[row][c] == self.current_player:\n                count += 1\n                if count == 4:\n                    return True\n            else:\n                count = 0\n\n        # Check vertical\n        count = 0\n        for r in range(max(0, row - 3), min(self.rows, row + 4)):\n            if self.board[r][col] == self.current_player:\n                count += 1\n                if count == 4:\n                    return True\n            else:\n                count = 0\n\n        # Check positive diagonal\n        count = 0\n        for i in range(-3, 4):\n            r = row + i\n            c = col + i\n            if 0 <= r < self.rows and 0 <= c < self.cols:\n                if self.board[r][c] == self.current_player:\n                    count += 1\n                    if count == 4:\n                        return True\n                else:\n                    count = 0\n\n        # Check negative diagonal\n        count = 0\n        for i in range(-3, 4):\n            r = row + i\n            c = col - i\n            if 0 <= r < self.rows and 0 <= c < self.cols:\n                if self.board[r][c] == self.current_player:\n                    count += 1\n                    if count == 4:\n                        return True\n                else:\n                    count = 0\n\n        return False\n\n    def check_draw(self):\n        for col in range(self.cols):\n            if self.board[0][col] == ' ':\n                return False\n        return True\n\n    def switch_player(self):\n        self.current_player = 'O' if self.current_player == 'X' else 'X'\n\n    def play_game(self):\n        while not self.game_over:\n            self.print_board()\n            print(f\"Player {self.current_player}, it's your turn.\")\n\n            try:\n                col = int(input(f\"Enter a column (1-{self.cols}): \")) - 1\n                if not self.is_valid_move(col):\n                    print(\"Invalid move. Try again.\")\n                    continue\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n                continue\n\n            row = self.drop_piece(col)\n\n            if self.check_win(row, col):\n                self.print_board()\n                print(f\"Player {self.current_player} wins!\")\n                self.game_over = True\n            elif self.check_draw():\n                self.print_board()\n                print(\"It's a draw!\")\n                self.game_over = True\n            else:\n                self.switch_player()\n\nif __name__ == \"__main__\":\n    game = ConnectFour()\n    game.play_game()\n```",
    "9": "```python\nimport random\n\nclass Blackjack:\n    def __init__(self):\n        self.suits = [\"Hearts\", \"Diamonds\", \"Clubs\", \"Spades\"]\n        self.ranks = [\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\", \"Ace\"]\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n        self.player_score = 0\n        self.dealer_score = 0\n\n    def create_deck(self):\n        deck = []\n        for suit in self.suits:\n            for rank in self.ranks:\n                deck.append((rank, suit))\n        random.shuffle(deck)\n        return deck\n\n    def deal_card(self, hand):\n        card = self.deck.pop()\n        hand.append(card)\n        return card\n\n    def calculate_hand_score(self, hand):\n        score = 0\n        aces = 0\n        for card in hand:\n            rank = card[0]\n            if rank.isdigit():\n                score += int(rank)\n            elif rank in [\"Jack\", \"Queen\", \"King\"]:\n                score += 10\n            elif rank == \"Ace\":\n                score += 11\n                aces += 1\n        while score > 21 and aces > 0:\n            score -= 10\n            aces -= 1\n        return score\n\n    def display_hand(self, hand, is_dealer=False, hide_first_card=False):\n        if is_dealer:\n            print(\"Dealer's hand:\")\n            if hide_first_card:\n                print(\"[Hidden Card]\")\n                for card in hand[1:]:\n                    print(f\" {card[0]} of {card[1]}\")\n            else:\n                for card in hand:\n                    print(f\" {card[0]} of {card[1]}\")\n            print(f\"Dealer's score: {self.dealer_score if not hide_first_card else '?'}\")\n        else:\n            print(\"Your hand:\")\n            for card in hand:\n                print(f\" {card[0]} of {card[1]}\")\n            print(f\"Your score: {self.player_score}\")\n        print()\n\n    def play_round(self):\n        # Deal initial hands\n        self.deal_card(self.player_hand)\n        self.deal_card(self.dealer_hand)\n        self.deal_card(self.player_hand)\n        self.deal_card(self.dealer_hand)\n\n        self.player_score = self.calculate_hand_score(self.player_hand)\n        self.dealer_score = self.calculate_hand_score(self.dealer_hand)\n\n        # Player's turn\n        self.display_hand(self.player_hand)\n        self.display_hand(self.dealer_hand, is_dealer=True, hide_first_card=True)\n\n        while self.player_score < 21:\n            action = input(\"Hit or stand? (h/s): \").lower()\n            if action == \"h\":\n                card = self.deal_card(self.player_hand)\n                self.player_score = self.calculate_hand_score(self.player_hand)\n                print(f\"You drew: {card[0]} of {card[1]}\")\n                self.display_hand(self.player_hand)\n\n                if self.player_score > 21:\n                    print(\"Bust! You lose.\")\n                    return\n            elif action == \"s\":\n                break\n            else:\n                print(\"Invalid action. Please enter 'h' or 's'.\")\n\n        # Dealer's turn\n        self.display_hand(self.dealer_hand, is_dealer=True)\n\n        if self.player_score <= 21:\n            while self.dealer_score < 17:\n                card = self.deal_card(self.dealer_hand)\n                self.dealer_score = self.calculate_hand_score(self.dealer_hand)\n                print(f\"Dealer drew: {card[0]} of {card[1]}\")\n                self.display_hand(self.dealer_hand, is_dealer=True)\n\n                if self.dealer_score > 21:\n                    print(\"Dealer busts! You win.\")\n                    return\n\n        # Determine the winner\n        if self.player_score > 21:\n            print(\"You lose.\")\n        elif self.dealer_score > 21:\n            print(\"You win!\")\n        elif self.player_score > self.dealer_score:\n            print(\"You win!\")\n        elif self.player_score < self.dealer_score:\n            print(\"You lose.\")\n        else:\n            print(\"It's a tie!\")\n\n    def reset_round(self):\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n        self.player_score = 0\n        self.dealer_score = 0\n\n    def play_game(self):\n        while True:\n            self.reset_round()\n            self.play_round()\n\n            play_again = input(\"Play again? (y/n): \").lower()\n            if play_again != \"y\":\n                break\n\nif __name__ == \"__main__\":\n    game = Blackjack()\n    game.play_game()\n```\n",
    "10": "```python\nimport random\n\nclass Hammurabi:\n    \"\"\"\n    A class representing the Hammurabi game.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the game state.\n        \"\"\"\n        self.year = 1\n        self.population = 100\n        self.grain = 2800\n        self.land = 1000\n        self.price_of_land = 19  # Initial price per acre\n        self.deaths = 0\n        self.starved = 0\n        self.harvest = 3  # Initial average harvest yield per acre\n        self.rats_ate = 0\n\n\n    def play_year(self):\n        \"\"\"\n        Plays one year of the game.\n        \"\"\"\n\n        print(f\"\\nYear {self.year}\")\n        print(f\"You are in year {self.year} of your ten-year rule.\")\n        print(f\"Population is now {self.population}\")\n        print(f\"You own {self.land} acres of land.\")\n        print(f\"You have {self.grain} bushels of grain in storage.\")\n        print(f\"Land is trading at {self.price_of_land} bushels per acre.\")\n\n        # Ask the player for their decisions\n        acres_to_buy = self.ask_to_buy_land()\n        acres_to_sell = self.ask_to_sell_land()\n        grain_to_feed = self.ask_to_feed_people()\n        acres_to_plant = self.ask_to_plant_land()\n\n        # Handle the consequences of the decisions\n        self.handle_land_transactions(acres_to_buy, acres_to_sell)\n        self.handle_feeding(grain_to_feed)\n        self.handle_planting(acres_to_plant)\n        self.handle_harvest()\n        self.handle_rats()\n        self.handle_starvation()\n        self.handle_population_growth()\n        self.handle_new_price_of_land()\n\n        # Update the year\n        self.year += 1\n\n\n    def ask_to_buy_land(self):\n        \"\"\"\n        Asks the player how many acres of land they want to buy.\n        \"\"\"\n        while True:\n            try:\n                acres = int(input(\"How many acres do you wish to buy? \"))\n                if acres < 0:\n                    print(\"Please enter a non-negative number.\")\n                elif acres * self.price_of_land > self.grain:\n                    print(\"You do not have enough grain to buy that much land.\")\n                else:\n                    return acres\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n    def ask_to_sell_land(self):\n        \"\"\"\n        Asks the player how many acres of land they want to sell.\n        \"\"\"\n        while True:\n            try:\n                acres = int(input(\"How many acres do you wish to sell? \"))\n                if acres < 0:\n                    print(\"Please enter a non-negative number.\")\n                elif acres > self.land:\n                    print(\"You do not have that much land to sell.\")\n                else:\n                    return acres\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n    def ask_to_feed_people(self):\n        \"\"\"\n        Asks the player how much grain they want to use to feed their people.\n        \"\"\"\n        while True:\n            try:\n                grain = int(input(\"How many bushels do you wish to feed your people? \"))\n                if grain < 0:\n                    print(\"Please enter a non-negative number.\")\n                elif grain > self.grain:\n                    print(\"You do not have that much grain.\")\n                else:\n                    return grain\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n    def ask_to_plant_land(self):\n        \"\"\"\n        Asks the player how many acres of land they want to plant.\n        \"\"\"\n        while True:\n            try:\n                acres = int(input(\"How many acres do you wish to plant with grain? \"))\n                if acres < 0:\n                    print(\"Please enter a non-negative number.\")\n                elif acres > self.land:\n                    print(\"You do not have that much land.\")\n                elif acres * 2 > self.grain:\n                    print(\"You do not have enough grain to plant that much land (2 bushels per acre required).\")\n                elif acres > self.population * 10:\n                    print(\"You do not have enough people to plant that much land (each person can plant 10 acres).\")\n                else:\n                    return acres\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n\n    def handle_land_transactions(self, acres_to_buy, acres_to_sell):\n        \"\"\"\n        Handles the buying and selling of land.\n        \"\"\"\n        self.grain -= acres_to_buy * self.price_of_land\n        self.grain += acres_to_sell * self.price_of_land\n        self.land += acres_to_buy - acres_to_sell\n\n\n    def handle_feeding(self, grain_to_feed):\n        \"\"\"\n        Handles the feeding of the population.\n        \"\"\"\n        self.grain -= grain_to_feed\n\n\n    def handle_planting(self, acres_to_plant):\n        \"\"\"\n        Handles the planting of land.\n        \"\"\"\n        self.planted_acres = acres_to_plant\n\n\n    def handle_harvest(self):\n        \"\"\"\n        Handles the harvest.\n        \"\"\"\n        self.harvest = random.randint(1, 6)  # Random harvest yield\n        grain_harvested = self.planted_acres * self.harvest\n        self.grain += grain_harvested\n        print(f\"Harvest was {self.harvest} bushels per acre.  You harvested {grain_harvested} bushels.\")\n\n\n    def handle_rats(self):\n        \"\"\"\n        Handles the rat infestation.\n        \"\"\"\n        rat_infestation = random.randint(0, 100)\n        if rat_infestation <= 40:  # 40% chance of rat infestation\n            self.rats_ate = int(self.grain * random.uniform(0.1, 0.3))  # Rats eat 10-30% of the grain\n            self.grain -= self.rats_ate\n            print(f\"Rats ate {self.rats_ate} bushels of grain!\")\n        else:\n            self.rats_ate = 0\n\n\n    def handle_starvation(self):\n        \"\"\"\n        Handles starvation and its consequences.\n        \"\"\"\n        grain_needed = self.population * 20 # 20 bushels of grain per person\n        if self.grain < grain_needed:\n            starved = self.population - int(self.grain / 20)\n            if starved < 0 : starved = 0\n            self.starved = starved\n            self.population -= starved\n            print(f\"{starved} people starved this year.\")\n\n            if self.population <= 0:\n                print(\"You have starved all your people! Game Over.\")\n                self.game_over = True\n                return\n\n            if starved > self.population * 0.5:\n                print(\"Due to your poor management, the people have revolted! Game Over.\")\n                self.game_over = True\n                return\n        else:\n            self.starved = 0\n            print(\"No one starved this year.\")\n\n\n    def handle_population_growth(self):\n        \"\"\"\n        Handles population growth.\n        \"\"\"\n        if self.starved == 0:\n            growth = int(self.population * random.uniform(0.0, 0.15))  # 0-15% growth\n            self.population += growth\n            print(f\"The population grew by {growth} people.\")\n        else:\n            print(\"The population did not grow this year due to starvation.\")\n\n\n    def handle_new_price_of_land(self):\n        \"\"\"\n        Handles the change in the price of land.\n        \"\"\"\n        self.price_of_land = random.randint(17, 25)\n\n\n    def is_game_over(self):\n        \"\"\"\n        Checks if the game is over.\n        \"\"\"\n        if self.year > 10 or self.game_over:\n            return True\n        else:\n            return False\n\n    def print_final_score(self):\n        \"\"\"\n        Prints the final score based on performance.\n        \"\"\"\n        acres_per_person = self.land / self.population\n        print(\"\\nFinal Report:\")\n        print(f\"You ruled for 10 years.\")\n        print(f\"At the end of your rule, you had {self.population} people.\")\n        print(f\"You owned {self.land} acres of land.\")\n        print(f\"That's {acres_per_person:.2f} acres per person.\")\n\n        if acres_per_person > 10:\n            print(\"A fantastic performance! Well done, Hammurabi!\")\n        elif acres_per_person > 7:\n            print(\"A good performance. You could have done better.\")\n        elif acres_per_person > 4:\n            print(\"An average performance. Not great, not terrible.\")\n        else:\n            print(\"A poor performance. You were a terrible ruler!\")\n\n    def play_game(self):\n        \"\"\"\n        Plays the entire game.\n        \"\"\"\n        self.game_over = False\n        print(\"Welcome to Hammurabi!\")\n\n        while not self.is_game_over():\n            self.play_year()\n\n        if self.game_over and self.population > 0 :\n            print(\"Game Over.\")\n        elif self.year > 10:\n            self.print_final_score()\n\n\n\n\n# Create an instance of the game and play it\nif __name__ == \"__main__\":\n    game = Hammurabi()\n    game.play_game()\n```",
    "11": "```python\nimport random\n\nclass LightsOut:\n    \"\"\"\n    A class representing the Lights Out game.\n    \"\"\"\n\n    def __init__(self, size=5, initial_state=None):\n        \"\"\"\n        Initializes the game board.\n\n        Args:\n            size (int): The size of the board (size x size). Default is 5.\n            initial_state (list[list[bool]]): An optional initial state for the board.\n                                               If None, a random initial state is generated.\n        \"\"\"\n        self.size = size\n        if initial_state:\n            if len(initial_state) != size or any(len(row) != size for row in initial_state):\n                raise ValueError(\"Initial state must be a size x size grid.\")\n            self.board = [row[:] for row in initial_state]  # Deep copy\n        else:\n            self.board = self.generate_random_board()\n\n    def generate_random_board(self):\n        \"\"\"\n        Generates a random initial board state.\n\n        Returns:\n            list[list[bool]]: A randomly generated board.\n        \"\"\"\n        board = [[random.choice([True, False]) for _ in range(self.size)] for _ in range(self.size)]\n        return board\n\n    def print_board(self):\n        \"\"\"\n        Prints the current state of the board to the console.\n        \"\"\"\n        for row in self.board:\n            print(\" \".join([\"X\" if cell else \"O\" for cell in row]))\n\n    def toggle_cell(self, row, col):\n        \"\"\"\n        Toggles the state of a cell on the board.\n\n        Args:\n            row (int): The row index of the cell.\n            col (int): The column index of the cell.\n        \"\"\"\n        if 0 <= row < self.size and 0 <= col < self.size:\n            self.board[row][col] = not self.board[row][col]\n\n    def make_move(self, row, col):\n        \"\"\"\n        Makes a move by toggling the selected cell and its neighbors.\n\n        Args:\n            row (int): The row index of the selected cell.\n            col (int): The column index of the selected cell.\n        \"\"\"\n        self.toggle_cell(row, col)  # Toggle the selected cell\n        self.toggle_cell(row - 1, col)  # Toggle the cell above\n        self.toggle_cell(row + 1, col)  # Toggle the cell below\n        self.toggle_cell(row, col - 1)  # Toggle the cell to the left\n        self.toggle_cell(row, col + 1)  # Toggle the cell to the right\n\n    def is_solved(self):\n        \"\"\"\n        Checks if the game is solved (all lights are off).\n\n        Returns:\n            bool: True if the game is solved, False otherwise.\n        \"\"\"\n        return all(not cell for row in self.board for cell in row)\n\n    def play_game(self):\n        \"\"\"\n        Plays the Lights Out game with a command-line interface.\n        \"\"\"\n        print(\"Welcome to Lights Out!\")\n        self.print_board()\n\n        while not self.is_solved():\n            try:\n                move = input(\"Enter your move (row,col): \").split(\",\")\n                row = int(move[0].strip())\n                col = int(move[1].strip())\n\n                if not (0 <= row < self.size and 0 <= col < self.size):\n                    print(\"Invalid move. Row and column must be between 0 and\", self.size - 1)\n                    continue\n\n                self.make_move(row, col)\n                self.print_board()\n\n            except (ValueError, IndexError):\n                print(\"Invalid input. Please enter row and column separated by a comma (e.g., 1,2).\")\n\n        print(\"Congratulations! You solved the puzzle.\")\n\n\nif __name__ == \"__main__\":\n    game = LightsOut(size=5)  # You can change the size here\n    game.play_game()\n```",
    "12": "```python\nimport time\nimport random\nimport os\n\nclass Pong:\n    \"\"\"\n    A command-line implementation of the classic Pong game.\n    \"\"\"\n\n    def __init__(self, width=60, height=20, paddle_length=5, ball_speed=1):\n        \"\"\"\n        Initializes the Pong game.\n\n        Args:\n            width (int): The width of the game board.\n            height (int): The height of the game board.\n            paddle_length (int): The length of the paddles.\n            ball_speed (int): The speed of the ball (number of steps per update).\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.paddle_length = paddle_length\n        self.ball_speed = ball_speed\n\n        self.player1_pos = height // 2 - paddle_length // 2\n        self.player2_pos = height // 2 - paddle_length // 2\n        self.ball_x = width // 2\n        self.ball_y = height // 2\n        self.ball_dx = random.choice([-1, 1])  # Ball direction in x-axis\n        self.ball_dy = random.choice([-1, 1])  # Ball direction in y-axis\n        self.player1_score = 0\n        self.player2_score = 0\n        self.game_over = False\n        self.max_score = 10\n\n\n    def draw_board(self):\n        \"\"\"\n        Draws the game board with paddles and the ball.\n        \"\"\"\n\n        os.system('cls' if os.name == 'nt' else 'clear')\n\n        board = [[' ' for _ in range(self.width)] for _ in range(self.height)]\n\n        # Draw paddles\n        for i in range(self.paddle_length):\n            if 0 <= self.player1_pos + i < self.height:\n                board[self.player1_pos + i][0] = '|'\n            if 0 <= self.player2_pos + i < self.height:\n                board[self.player2_pos + i][self.width - 1] = '|'\n\n        # Draw ball\n        board[self.ball_y][self.ball_x] = 'O'\n\n        # Print board\n        print(\"-\" * self.width)\n        for row in board:\n            print(\"\".join(row))\n        print(\"-\" * self.width)\n        print(f\"Player 1: {self.player1_score}  Player 2: {self.player2_score}\")\n\n\n    def update_ball(self):\n        \"\"\"\n        Updates the ball's position and handles collisions.\n        \"\"\"\n        for _ in range(self.ball_speed):\n            new_ball_x = self.ball_x + self.ball_dx\n            new_ball_y = self.ball_y + self.ball_dy\n\n            # Check for collisions with top/bottom walls\n            if new_ball_y <= 0 or new_ball_y >= self.height - 1:\n                self.ball_dy *= -1\n                new_ball_y = self.ball_y + self.ball_dy  # Recalculate after bounce\n\n            # Check for collisions with paddles\n            if new_ball_x <= 0:\n                if self.player1_pos <= new_ball_y <= self.player1_pos + self.paddle_length - 1:\n                    self.ball_dx *= -1\n                    new_ball_x = self.ball_x + self.ball_dx  # Recalculate after bounce\n                else:\n                    self.player2_score += 1\n                    self.reset_ball()\n                    return\n\n            if new_ball_x >= self.width - 1:\n                if self.player2_pos <= new_ball_y <= self.player2_pos + self.paddle_length - 1:\n                    self.ball_dx *= -1\n                    new_ball_x = self.ball_x + self.ball_dx  # Recalculate after bounce\n                else:\n                    self.player1_score += 1\n                    self.reset_ball()\n                    return\n\n            self.ball_x = new_ball_x\n            self.ball_y = new_ball_y\n\n    def reset_ball(self):\n         \"\"\"Resets the ball to the center after a point is scored.\"\"\"\n         self.ball_x = self.width // 2\n         self.ball_y = self.height // 2\n         self.ball_dx = random.choice([-1, 1])\n         self.ball_dy = random.choice([-1, 1])\n\n\n    def move_player1(self, direction):\n        \"\"\"\n        Moves player 1's paddle.\n\n        Args:\n            direction (str): \"up\" or \"down\".\n        \"\"\"\n        if direction == \"up\" and self.player1_pos > 0:\n            self.player1_pos -= 1\n        elif direction == \"down\" and self.player1_pos + self.paddle_length < self.height:\n            self.player1_pos += 1\n\n\n    def move_player2(self, direction):\n        \"\"\"\n        Moves player 2's paddle.\n\n        Args:\n            direction (str): \"up\" or \"down\".\n        \"\"\"\n        if direction == \"up\" and self.player2_pos > 0:\n            self.player2_pos -= 1\n        elif direction == \"down\" and self.player2_pos + self.paddle_length < self.height:\n            self.player2_pos += 1\n\n\n    def check_game_over(self):\n        \"\"\"Checks if the game is over.\"\"\"\n        if self.player1_score >= self.max_score or self.player2_score >= self.max_score:\n            self.game_over = True\n            return True\n        return False\n\n    def play(self):\n        \"\"\"\n        Starts and runs the game loop.\n        \"\"\"\n        while not self.game_over:\n            self.draw_board()\n\n            # Get player input (non-blocking)\n            player1_move = input(\"Player 1 (w/s): \").lower()\n            player2_move = input(\"Player 2 (o/l): \").lower()\n\n            # Move players\n            if player1_move == \"w\":\n                self.move_player1(\"up\")\n            elif player1_move == \"s\":\n                self.move_player1(\"down\")\n\n            if player2_move == \"o\":\n                self.move_player2(\"up\")\n            elif player2_move == \"l\":\n                self.move_player2(\"down\")\n\n            self.update_ball()\n\n            if self.check_game_over():\n                self.draw_board()\n                if self.player1_score >= self.max_score:\n                    print(\"Player 1 wins!\")\n                else:\n                    print(\"Player 2 wins!\")\n                break\n\n            time.sleep(0.05)\n\n\nif __name__ == \"__main__\":\n    game = Pong()\n    game.play()\n```",
    "13": "```python\nimport random\nimport os\n\nclass Tetris:\n    \"\"\"\n    A command-line Tetris game.\n    \"\"\"\n\n    WIDTH = 10\n    HEIGHT = 20\n    TETROMINOS = {\n        'I': [(0, 0), (0, 1), (0, 2), (0, 3)],\n        'O': [(0, 0), (0, 1), (1, 0), (1, 1)],\n        'T': [(0, 0), (1, 0), (2, 0), (1, 1)],\n        'S': [(0, 1), (1, 1), (1, 0), (2, 0)],\n        'Z': [(0, 0), (1, 0), (1, 1), (2, 1)],\n        'J': [(0, 0), (1, 0), (2, 0), (2, 1)],\n        'L': [(0, 0), (1, 0), (2, 0), (0, 1)],\n    }\n    COLORS = {\n        'I': 'cyan',\n        'O': 'yellow',\n        'T': 'purple',\n        'S': 'green',\n        'Z': 'red',\n        'J': 'blue',\n        'L': 'orange',\n    }\n\n    def __init__(self):\n        self.board = [[' ' for _ in range(self.WIDTH)] for _ in range(self.HEIGHT)]\n        self.current_piece = self.new_piece()\n        self.current_x = self.WIDTH // 2 - 1\n        self.current_y = 0\n        self.game_over = False\n        self.score = 0\n        self.level = 1\n        self.lines_cleared = 0\n\n    def new_piece(self):\n        \"\"\"\n        Generates a new random Tetromino piece.\n        \"\"\"\n        piece_type = random.choice(list(self.TETROMINOS.keys()))\n        return {'shape': self.TETROMINOS[piece_type], 'color': self.COLORS[piece_type], 'type': piece_type}\n\n    def rotate_piece(self):\n      \"\"\"Rotates current piece clockwise\"\"\"\n      original_piece = self.current_piece['shape']\n      rotated_piece = []\n      for x, y in original_piece:\n          rotated_piece.append((y * -1, x))\n\n      # Check boundaries after rotation\n      min_x = min(x for x, y in rotated_piece) + self.current_x\n      max_x = max(x for x, y in rotated_piece) + self.current_x\n      min_y = min(y for x, y in rotated_piece) + self.current_y\n      max_y = max(y for x, y in rotated_piece) + self.current_y\n      if min_x < 0 or max_x >= self.WIDTH or min_y < 0 or max_y >= self.HEIGHT:\n          return  # Don't rotate\n\n      # Check for collisions after rotation\n      for x, y in rotated_piece:\n          board_x = x + self.current_x\n          board_y = y + self.current_y\n          if self.board[board_y][board_x] != ' ':\n              return  # Don't rotate\n      self.current_piece['shape'] = rotated_piece\n\n\n    def valid_move(self, x_offset, y_offset):\n        \"\"\"\n        Checks if moving the current piece by the given offsets is a valid move.\n        \"\"\"\n        for x, y in self.current_piece['shape']:\n            board_x = x + self.current_x + x_offset\n            board_y = y + self.current_y + y_offset\n\n            if board_x < 0 or board_x >= self.WIDTH or board_y >= self.HEIGHT:\n                return False\n\n            if board_y >= 0 and self.board[board_y][board_x] != ' ':\n                return False\n\n        return True\n\n    def move_piece(self, x_offset, y_offset):\n        \"\"\"\n        Moves the current piece by the given offsets if the move is valid.\n        \"\"\"\n        if self.valid_move(x_offset, y_offset):\n            self.current_x += x_offset\n            self.current_y += y_offset\n            return True\n        else:\n            return False\n\n    def place_piece(self):\n        \"\"\"\n        Places the current piece on the board.\n        \"\"\"\n        for x, y in self.current_piece['shape']:\n            board_x = x + self.current_x\n            board_y = y + self.current_y\n            self.board[board_y][board_x] = self.current_piece['color'][0].upper()  # Use first letter of color\n\n    def clear_lines(self):\n        \"\"\"\n        Clears any full lines from the board and updates the score.\n        \"\"\"\n        lines_to_clear = []\n        for i in range(self.HEIGHT):\n            if all(cell != ' ' for cell in self.board[i]):\n                lines_to_clear.append(i)\n\n        for line_index in lines_to_clear:\n            del self.board[line_index]\n            self.board.insert(0, [' ' for _ in range(self.WIDTH)])\n            self.score += 100 * self.level  # Increase score based on level\n            self.lines_cleared += 1\n            if self.lines_cleared % 10 == 0:\n                self.level += 1\n                print(f\"Level Up! Current level: {self.level}\")\n\n    def drop_piece(self):\n        \"\"\"\n        Drops the current piece down one row. If it can't move down, place it and generate a new piece.\n        \"\"\"\n        if not self.move_piece(0, 1):\n            self.place_piece()\n            self.clear_lines()\n            self.current_piece = self.new_piece()\n            self.current_x = self.WIDTH // 2 - 1\n            self.current_y = 0\n\n            if not self.valid_move(0, 0):\n                self.game_over = True\n\n    def draw_board(self):\n        \"\"\"\n        Draws the current state of the Tetris board to the console.\n        \"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n        print(f\"Score: {self.score}  Level: {self.level}\")\n        print(\"+\" + \"-\" * (self.WIDTH * 2) + \"+\")  # Top border\n        for i in range(self.HEIGHT):\n            row_str = \"|\"\n            for j in range(self.WIDTH):\n                cell = self.board[i][j]\n                row_str += f\"{cell} \"  # Add space for better readability\n            row_str += \"|\"\n            print(row_str)\n        print(\"+\" + \"-\" * (self.WIDTH * 2) + \"+\")  # Bottom border\n\n        # Draw current piece on the board (but not permanently)\n        temp_board = [row[:] for row in self.board]  # Create a copy\n        for x, y in self.current_piece['shape']:\n            board_x = x + self.current_x\n            board_y = y + self.current_y\n            if 0 <= board_x < self.WIDTH and 0 <= board_y < self.HEIGHT:  # Check for valid indices\n                temp_board[board_y][board_x] = self.current_piece['color'][0].upper()\n        print (\"\\nPreview:\")\n        print(\"+\" + \"-\" * (self.WIDTH * 2) + \"+\")  # Top border\n        for i in range(self.HEIGHT):\n            row_str = \"|\"\n            for j in range(self.WIDTH):\n                cell = temp_board[i][j]\n                row_str += f\"{cell} \"  # Add space for better readability\n            row_str += \"|\"\n            print(row_str)\n        print(\"+\" + \"-\" * (self.WIDTH * 2) + \"+\")  # Bottom border\n\n\n    def run(self):\n        \"\"\"\n        Runs the main game loop.\n        \"\"\"\n        while not self.game_over:\n            self.draw_board()\n            action = input(\"Enter action (a=left, d=right, s=down, w=rotate, q=quit): \").lower()\n\n            if action == 'a':\n                self.move_piece(-1, 0)\n            elif action == 'd':\n                self.move_piece(1, 0)\n            elif action == 's':\n                self.drop_piece()\n            elif action == 'w':\n                self.rotate_piece()\n            elif action == 'q':\n                break\n            else:\n                print(\"Invalid action.\")\n\n            self.drop_piece()\n\n        self.draw_board()\n        print(\"Game Over! Final Score:\", self.score)\n\n\nif __name__ == \"__main__\":\n    game = Tetris()\n    game.run()\n```",
    "14": "```python\nimport math\nimport random\nimport time\n\nclass AsteroidGame:\n    \"\"\"\n    A command-line implementation of the Asteroids game.\n    \"\"\"\n\n    def __init__(self, width=80, height=20, asteroid_count=5):\n        \"\"\"\n        Initializes the game.\n\n        Args:\n            width: The width of the game board (in characters).\n            height: The height of the game board (in characters).\n            asteroid_count: The initial number of asteroids.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.asteroid_count = asteroid_count\n        self.ship = Ship(width // 2, height // 2)\n        self.asteroids = []\n        self.bullets = []\n        self.score = 0\n        self.game_over = False\n        self.last_update_time = time.time()\n        self.difficulty_multiplier = 1.0  # Increase over time\n\n        self.initialize_asteroids()\n\n    def initialize_asteroids(self):\n        \"\"\"\n        Creates the initial set of asteroids.\n        \"\"\"\n        self.asteroids = []\n        for _ in range(self.asteroid_count):\n            x = random.randint(0, self.width - 1)\n            y = random.randint(0, self.height - 1)\n            # Avoid spawning asteroids too close to the ship\n            while (x - self.ship.x)**2 + (y - self.ship.y)**2 < (self.width // 5)**2:\n                x = random.randint(0, self.width - 1)\n                y = random.randint(0, self.height - 1)\n\n            size = random.choice([1, 2, 3])  # Small, Medium, Large\n            angle = random.uniform(0, 2 * math.pi)\n            speed = random.uniform(0.5, 1.5) * self.difficulty_multiplier\n            self.asteroids.append(Asteroid(x, y, size, angle, speed))\n\n    def update(self):\n        \"\"\"\n        Updates the game state.  Moves the ship, asteroids, and bullets.\n        Handles collisions and scoring.\n        \"\"\"\n        if self.game_over:\n            return\n\n        current_time = time.time()\n        delta_time = current_time - self.last_update_time\n        self.last_update_time = current_time\n\n        # Update ship position\n        self.ship.update(self.width, self.height, delta_time)\n\n        # Update asteroid positions\n        for asteroid in self.asteroids:\n            asteroid.update(self.width, self.height, delta_time)\n\n        # Update bullet positions\n        for bullet in self.bullets:\n            bullet.update(self.width, self.height, delta_time)\n\n        # Handle collisions\n        self.handle_collisions()\n\n        # Remove off-screen bullets\n        self.bullets = [bullet for bullet in self.bullets if bullet.is_on_screen(self.width, self.height)]\n\n        # Check for game over (ship collision with asteroid)\n        for asteroid in self.asteroids:\n            if self.ship.collides_with(asteroid):\n                self.game_over = True\n                break\n\n        # Spawn new asteroids if necessary\n        if len(self.asteroids) < self.asteroid_count:\n            self.spawn_asteroid()\n\n        # Increase difficulty over time\n        self.difficulty_multiplier += 0.001 * delta_time\n\n    def handle_collisions(self):\n        \"\"\"\n        Checks for and handles collisions between bullets and asteroids.\n        \"\"\"\n        bullets_to_remove = set()\n        asteroids_to_remove = set()\n\n        for i, bullet in enumerate(self.bullets):\n            for j, asteroid in enumerate(self.asteroids):\n                if bullet.collides_with(asteroid):\n                    bullets_to_remove.add(i)\n                    asteroids_to_remove.add(j)\n                    self.score += asteroid.size * 10\n                    self.split_asteroid(asteroid)  # Split the asteroid on hit\n                    break  # Bullet can only hit one asteroid\n\n        # Remove collided bullets and asteroids\n        self.bullets = [bullet for i, bullet in enumerate(self.bullets) if i not in bullets_to_remove]\n        temp_asteroids = []\n        for i, asteroid in enumerate(self.asteroids):\n            if i not in asteroids_to_remove:\n                temp_asteroids.append(asteroid)\n        self.asteroids = temp_asteroids\n\n    def split_asteroid(self, asteroid):\n        \"\"\"\n        Splits an asteroid into smaller asteroids or removes it if it's too small.\n\n        Args:\n            asteroid: The Asteroid object to split.\n        \"\"\"\n        if asteroid.size > 1:  # Can be split\n            new_size = asteroid.size - 1\n            angle1 = asteroid.angle + math.pi / 4\n            angle2 = asteroid.angle - math.pi / 4\n            speed = asteroid.speed * 1.2  # Slightly faster\n            self.asteroids.append(Asteroid(asteroid.x, asteroid.y, new_size, angle1, speed))\n            self.asteroids.append(Asteroid(asteroid.x, asteroid.y, new_size, angle2, speed))\n\n    def spawn_asteroid(self):\n        \"\"\"\n        Spawns a new asteroid at a random location.\n        \"\"\"\n        x = random.choice([0, self.width - 1])\n        y = random.randint(0, self.height - 1)\n        size = random.choice([1, 2, 3])\n        angle = random.uniform(0, 2 * math.pi)\n        speed = random.uniform(0.5, 1.5) * self.difficulty_multiplier\n        self.asteroids.append(Asteroid(x, y, size, angle, speed))\n\n    def fire_bullet(self):\n        \"\"\"\n        Fires a bullet from the ship's current position and direction.\n        \"\"\"\n        bullet = Bullet(self.ship.x, self.ship.y, self.ship.angle, 5)  # Speed of 5\n        self.bullets.append(bullet)\n\n    def draw(self):\n        \"\"\"\n        Draws the game board to the console.\n        \"\"\"\n        board = [[' ' for _ in range(self.width)] for _ in range(self.height)]\n\n        # Draw asteroids\n        for asteroid in self.asteroids:\n            x = int(round(asteroid.x))\n            y = int(round(asteroid.y))\n            if 0 <= x < self.width and 0 <= y < self.height:\n                board[y][x] = '*'\n\n        # Draw bullets\n        for bullet in self.bullets:\n            x = int(round(bullet.x))\n            y = int(round(bullet.y))\n            if 0 <= x < self.width and 0 <= y < self.height:\n                board[y][x] = '.'\n\n        # Draw ship\n        x = int(round(self.ship.x))\n        y = int(round(self.ship.y))\n        if 0 <= x < self.width and 0 <= y < self.height:\n            board[y][x] = '^'  # Simple ship representation\n\n        # Print the board\n        print(\"\\033[H\\033[J\", end=\"\")  # Clear the screen\n        for row in board:\n            print(\"\".join(row))\n\n        # Print score and instructions\n        print(f\"Score: {self.score}\")\n        print(\"Controls: A=Left, D=Right, W=Forward, Space=Fire, Q=Quit\")\n\n        if self.game_over:\n            print(\"Game Over! Press Q to quit.\")\n\n    def run(self):\n        \"\"\"\n        Runs the main game loop.\n        \"\"\"\n        while not self.game_over:\n            self.draw()\n            self.update()\n            action = input(\"Action (A/D/W/Space/Q): \").upper()\n\n            if action == 'A':\n                self.ship.rotate(-0.1)\n            elif action == 'D':\n                self.ship.rotate(0.1)\n            elif action == 'W':\n                self.ship.accelerate(0.5)\n            elif action == ' ':\n                self.fire_bullet()\n            elif action == 'Q':\n                self.game_over = True\n            time.sleep(0.05) # Adjust for desired game speed\n\n        print(\"Final Score:\", self.score)\n\n\nclass GameObject:\n    \"\"\"\n    Base class for game objects (ship, asteroid, bullet).\n    \"\"\"\n    def __init__(self, x, y):\n        \"\"\"\n        Initializes a game object.\n\n        Args:\n            x: The x-coordinate of the object.\n            y: The y-coordinate of the object.\n        \"\"\"\n        self.x = x\n        self.y = y\n\n    def update(self, width, height, delta_time):\n        \"\"\"\n        Updates the object's position.  To be overridden by subclasses.\n\n        Args:\n            width: The width of the game board.\n            height: The height of the game board.\n            delta_time: Time since last update.\n        \"\"\"\n        pass  # Default implementation does nothing\n\n    def collides_with(self, other):\n        \"\"\"\n        Checks if this object collides with another object.\n\n        Args:\n            other: The other GameObject.\n\n        Returns:\n            True if the objects collide, False otherwise.\n        \"\"\"\n        distance = math.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)\n        #Simple collision detection using a combined \"radius\"\n        return distance < 1.0\n\nclass Ship(GameObject):\n    \"\"\"\n    Represents the player's ship.\n    \"\"\"\n    def __init__(self, x, y):\n        \"\"\"\n        Initializes the ship.\n\n        Args:\n            x: The initial x-coordinate of the ship.\n            y: The initial y-coordinate of the ship.\n        \"\"\"\n        super().__init__(x, y)\n        self.angle = 0  # Radians\n        self.speed = 0\n        self.acceleration = 0.0\n\n    def rotate(self, angle_change):\n        \"\"\"\n        Rotates the ship.\n\n        Args:\n            angle_change: The amount to change the angle (in radians).\n        \"\"\"\n        self.angle += angle_change\n\n    def accelerate(self, amount):\n        \"\"\"\n        Applies acceleration to the ship.\n\n        Args:\n            amount: The amount of acceleration to apply.\n        \"\"\"\n        self.acceleration = amount\n\n    def update(self, width, height, delta_time):\n        \"\"\"\n        Updates the ship's position and speed.\n\n        Args:\n            width: The width of the game board.\n            height: The height of the game board.\n            delta_time: The time since the last update.\n        \"\"\"\n        # Apply acceleration\n        self.speed += self.acceleration * delta_time\n        self.speed = max(0, min(self.speed, 5)) #Limit speed\n\n        # Update position based on angle and speed\n        self.x += math.cos(self.angle) * self.speed * delta_time\n        self.y += math.sin(self.angle) * self.speed * delta_time\n\n        # Wrap around the screen\n        self.x %= width\n        self.y %= height\n\n        self.acceleration = 0 # Reset acceleration each frame\n\nclass Asteroid(GameObject):\n    \"\"\"\n    Represents an asteroid.\n    \"\"\"\n    def __init__(self, x, y, size, angle, speed):\n        \"\"\"\n        Initializes an asteroid.\n\n        Args:\n            x: The initial x-coordinate of the asteroid.\n            y: The initial y-coordinate of the asteroid.\n            size: The size of the asteroid (1-3).\n            angle: The angle of the asteroid's movement (in radians).\n            speed: The speed of the asteroid.\n        \"\"\"\n        super().__init__(x, y)\n        self.size = size\n        self.angle = angle\n        self.speed = speed\n\n    def update(self, width, height, delta_time):\n        \"\"\"\n        Updates the asteroid's position.\n\n        Args:\n            width: The width of the game board.\n            height: The height of the game board.\n            delta_time: The time since the last update.\n        \"\"\"\n        self.x += math.cos(self.angle) * self.speed * delta_time\n        self.y += math.sin(self.angle) * self.speed * delta_time\n\n        # Wrap around the screen\n        self.x %= width\n        self.y %= height\n\n    def",
    "15": "```python\nimport random\nimport time\n\nclass Boggle:\n    \"\"\"\n    A class to represent and play the Boggle game.\n    \"\"\"\n\n    def __init__(self, size=4, dictionary_file=\"words.txt\"):\n        \"\"\"\n        Initializes the Boggle game.\n\n        Args:\n            size (int): The size of the Boggle board (default is 4).\n            dictionary_file (str): The path to the dictionary file (default is \"words.txt\").\n        \"\"\"\n        self.size = size\n        self.board = [['' for _ in range(size)] for _ in range(size)]\n        self.dictionary = self.load_dictionary(dictionary_file)\n        self.words_found = set()\n        self.game_over = False\n        self.start_time = None\n        self.time_limit = 180  # 3 minutes\n\n    def load_dictionary(self, dictionary_file):\n        \"\"\"\n        Loads the dictionary from the given file.\n\n        Args:\n            dictionary_file (str): The path to the dictionary file.\n\n        Returns:\n            set: A set of words from the dictionary.\n        \"\"\"\n        try:\n            with open(dictionary_file, \"r\") as f:\n                return set(word.strip().upper() for word in f)\n        except FileNotFoundError:\n            print(f\"Error: Dictionary file '{dictionary_file}' not found.\")\n            exit(1)\n\n    def generate_board(self):\n        \"\"\"\n        Generates a random Boggle board. Uses standard Boggle dice for letter distribution.\n        \"\"\"\n        dice = [\n            \"RIFOBX\", \"IFEHEE\", \"ENSIEU\", \"UTDNIO\",\n            \"HMQUOB\", \"LNWODJ\", \"AREVLD\", \"HOSPNI\",\n            \"TLESRA\", \"ATOOET\", \"HLNRZD\", \"NNIAEE\",\n            \"DGNOTU\", \"AACIOT\", \"AIOEFR\", \"EEIHNS\"\n        ]\n\n        if self.size != 4:  # Generalization for different sizes would require appropriate dice\n            print(\"Warning: Using standard dice for non-4x4 board. Letter distribution may be inaccurate.\")\n\n        for i in range(self.size):\n            for j in range(self.size):\n                die = random.choice(dice)\n                self.board[i][j] = random.choice(die)\n\n    def print_board(self):\n        \"\"\"\n        Prints the current Boggle board to the console.\n        \"\"\"\n        print(\"Boggle Board:\")\n        for row in self.board:\n            print(\" \".join(row))\n        print()\n\n    def is_valid_word(self, word):\n        \"\"\"\n        Checks if a word is valid according to Boggle rules and the dictionary.\n\n        Args:\n            word (str): The word to check.\n\n        Returns:\n            bool: True if the word is valid, False otherwise.\n        \"\"\"\n        if len(word) < 3:\n            return False\n        if word not in self.dictionary:\n            return False\n        if word in self.words_found:\n            return False\n        return True\n\n    def find_word_on_board(self, word):\n        \"\"\"\n        Checks if a word can be found on the Boggle board using adjacent letters.\n\n        Args:\n            word (str): The word to search for.\n\n        Returns:\n            bool: True if the word can be found, False otherwise.\n        \"\"\"\n\n        def search(row, col, word_index, path):\n            \"\"\"\n            Recursive helper function to search for the word.\n            \"\"\"\n            if word_index == len(word):\n                return True\n\n            if row < 0 or row >= self.size or col < 0 or col >= self.size:\n                return False\n\n            if self.board[row][col] != word[word_index]:\n                return False\n\n            if (row, col) in path:\n                return False  # Prevent cycles\n\n            new_path = path + [(row, col)]\n\n            # Explore adjacent cells\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue #Skip current cell\n\n                    if search(row + dr, col + dc, word_index + 1, new_path):\n                        return True\n\n            return False\n\n        for row in range(self.size):\n            for col in range(self.size):\n                if search(row, col, 0, []):\n                    return True\n\n        return False\n\n    def add_word(self, word):\n          \"\"\"\n          Adds a word to the list of found words if it's valid and on the board.\n          \"\"\"\n          word = word.upper()\n          if self.is_valid_word(word) and self.find_word_on_board(word):\n              self.words_found.add(word)\n              print(f\"Word '{word}' found!\")\n          else:\n              print(f\"Word '{word}' is not valid or cannot be found on the board.\")\n\n    def calculate_score(self):\n        \"\"\"\n        Calculates the player's score based on the length of the words found.\n        \"\"\"\n        score = 0\n        for word in self.words_found:\n            length = len(word)\n            if length == 3 or length == 4:\n                score += 1\n            elif length == 5:\n                score += 2\n            elif length == 6:\n                score += 3\n            elif length == 7:\n                score += 5\n            elif length >= 8:\n                score += 11\n        return score\n\n    def play_game(self):\n        \"\"\"\n        The main game loop.\n        \"\"\"\n        self.generate_board()\n        self.print_board()\n        self.words_found = set()\n        print(\"Game started! You have 3 minutes to find words.\")\n        self.start_time = time.time()\n\n        while not self.game_over:\n            elapsed_time = time.time() - self.start_time\n            remaining_time = self.time_limit - elapsed_time\n\n            if remaining_time <= 0:\n                self.game_over = True\n                print(\"Time's up!\")\n                break\n\n            print(f\"Time remaining: {int(remaining_time)} seconds\")\n            word = input(\"Enter a word (or type 'quit' to end): \").strip()\n\n            if word.lower() == \"quit\":\n                self.game_over = True\n                break\n\n            self.add_word(word)\n\n        score = self.calculate_score()\n        print(\"\\nGame Over!\")\n        print(\"Words found:\", \", \".join(sorted(self.words_found)))\n        print(\"Your score:\", score)\n\nif __name__ == \"__main__\":\n    game = Boggle()\n    game.play_game()\n```",
    "16": "```python\nimport random\nimport time\nimport os\n\n\nclass PacmanGame:\n    \"\"\"\n    A simple command-line Pac-Man game.\n    \"\"\"\n\n    def __init__(self, width=15, height=10):\n        \"\"\"\n        Initializes the Pac-Man game.\n\n        Args:\n            width (int): The width of the game grid.\n            height (int): The height of the game grid.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.pacman_x = width // 2\n        self.pacman_y = height // 2\n        self.ghost_x = 1\n        self.ghost_y = 1\n        self.food = set()\n        self.score = 0\n        self.game_over = False\n        self.level = 1\n        self.ghost_speed = 0.5  # Ghost movement frequency (lower = faster)\n\n        # Initialize food pellets\n        for x in range(width):\n            for y in range(height):\n                if (x, y) != (self.pacman_x, self.pacman_y) and (x, y) != (self.ghost_x, self.ghost_y):\n                    self.food.add((x, y))\n\n    def display(self):\n        \"\"\"\n        Displays the game grid in the console.\n        \"\"\"\n\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the screen\n\n        # Display game information\n        print(f\"Level: {self.level}  Score: {self.score}\")\n\n        # Create the grid\n        grid = [[' ' for _ in range(self.width)] for _ in range(self.height)]\n\n        # Place food pellets\n        for x, y in self.food:\n            grid[y][x] = '.'\n\n        # Place Pac-Man\n        grid[self.pacman_y][self.pacman_x] = 'P'\n\n        # Place the ghost\n        grid[self.ghost_y][self.ghost_x] = 'G'\n\n        # Draw the grid\n        for row in grid:\n            print(''.join(row))\n\n    def move_pacman(self, direction):\n        \"\"\"\n        Moves Pac-Man based on the given direction.\n\n        Args:\n            direction (str): The direction to move (up, down, left, right).\n        \"\"\"\n        new_x, new_y = self.pacman_x, self.pacman_y\n\n        if direction == 'up':\n            new_y -= 1\n        elif direction == 'down':\n            new_y += 1\n        elif direction == 'left':\n            new_x -= 1\n        elif direction == 'right':\n            new_x += 1\n\n        # Check for boundaries\n        if 0 <= new_x < self.width and 0 <= new_y < self.height:\n            self.pacman_x = new_x\n            self.pacman_y = new_y\n\n            # Check if Pac-Man eats food\n            if (self.pacman_x, self.pacman_y) in self.food:\n                self.food.remove((self.pacman_x, self.pacman_y))\n                self.score += 10\n\n            # Check if Pac-Man collides with the ghost\n            if self.pacman_x == self.ghost_x and self.pacman_y == self.ghost_y:\n                self.game_over = True\n\n            # Check if the level is complete\n            if not self.food:\n                self.level_complete()\n\n    def move_ghost(self):\n        \"\"\"\n        Moves the ghost randomly.\n        \"\"\"\n        possible_moves = []\n        if self.ghost_x > 0:\n            possible_moves.append('left')\n        if self.ghost_x < self.width - 1:\n            possible_moves.append('right')\n        if self.ghost_y > 0:\n            possible_moves.append('up')\n        if self.ghost_y < self.height - 1:\n            possible_moves.append('down')\n\n        direction = random.choice(possible_moves)\n        new_x, new_y = self.ghost_x, self.ghost_y\n\n        if direction == 'up':\n            new_y -= 1\n        elif direction == 'down':\n            new_y += 1\n        elif direction == 'left':\n            new_x -= 1\n        elif direction == 'right':\n            new_x += 1\n\n        self.ghost_x = new_x\n        self.ghost_y = new_y\n\n        # Check for collision with pacman\n        if self.pacman_x == self.ghost_x and self.pacman_y == self.ghost_y:\n            self.game_over = True\n\n    def level_complete(self):\n        \"\"\"\n        Advances the game to the next level.\n        \"\"\"\n        self.level += 1\n        print(\"Level Complete!\")\n        time.sleep(1)  # Pause briefly\n\n        # Reset Pac-Man and Ghost positions\n        self.pacman_x = self.width // 2\n        self.pacman_y = self.height // 2\n        self.ghost_x = 1\n        self.ghost_y = 1\n\n        # Refill the food\n        self.food = set()\n        for x in range(self.width):\n            for y in range(self.height):\n                if (x, y) != (self.pacman_x, self.pacman_y) and (x, y) != (self.ghost_x, self.ghost_y):\n                    self.food.add((x, y))\n\n        # Optionally increase ghost speed each level\n        self.ghost_speed = max(0.1, self.ghost_speed - 0.05)\n\n    def play(self):\n        \"\"\"\n        Starts the main game loop.\n        \"\"\"\n        last_ghost_move = time.time()\n\n        while not self.game_over:\n            self.display()\n\n            # Get player input\n            direction = input(\"Enter move (up, down, left, right, quit): \").lower()\n\n            if direction == 'quit':\n                break\n\n            # Move Pac-Man\n            self.move_pacman(direction)\n\n            # Move ghost based on the timer\n            current_time = time.time()\n            if current_time - last_ghost_move > self.ghost_speed:\n                self.move_ghost()\n                last_ghost_move = current_time\n\n            time.sleep(0.1)  # Control game speed\n\n        if self.game_over:\n            self.display()\n            print(\"Game Over! Final Score:\", self.score)\n        else:\n            print(\"Game quit. Final Score:\", self.score)\n\n\nif __name__ == \"__main__\":\n    game = PacmanGame()\n    game.play()\n```",
    "17": "```python\nimport random\nimport time\nimport os\n\nclass DinosaurRunner:\n    \"\"\"\n    A command-line implementation of the Dinosaur Runner game.\n    \"\"\"\n\n    def __init__(self, width=80, initial_speed=1, speed_increment=0.1, obstacle_density=0.05, jump_height=5):\n        \"\"\"\n        Initializes the game.\n\n        Args:\n            width (int): The width of the game screen.\n            initial_speed (float): The initial speed of the game.\n            speed_increment (float): The amount the speed increases each frame.\n            obstacle_density (float): The probability of an obstacle appearing on a given line.\n            jump_height (int): The maximum height of the dinosaur's jump.\n        \"\"\"\n        self.width = width\n        self.dinosaur_position = 5  # Vertical position of the dinosaur (0 is the ground)\n        self.dinosaur_velocity = 0  # Vertical velocity of the dinosaur\n        self.gravity = -1  # Simulates gravity\n        self.initial_speed = initial_speed\n        self.speed = initial_speed\n        self.speed_increment = speed_increment\n        self.obstacle_density = obstacle_density\n        self.jump_height = jump_height\n        self.obstacles = []  # List of obstacle positions (x-coordinates)\n        self.score = 0\n        self.game_over = False\n        self.frame_delay = 0.1  # Initial delay between frames\n\n    def clear_screen(self):\n      \"\"\"Clears the terminal screen.\"\"\"\n      os.system('cls' if os.name == 'nt' else 'clear')\n\n\n    def generate_obstacle(self):\n        \"\"\"\n        Generates a new obstacle at the right edge of the screen with a probability\n        determined by the obstacle density.\n        \"\"\"\n        if random.random() < self.obstacle_density:\n            self.obstacles.append(self.width - 1)  # Add obstacle at the right edge\n\n    def update_obstacles(self):\n        \"\"\"\n        Updates the position of the obstacles, removing those that have moved off-screen.\n        \"\"\"\n        new_obstacles = []\n        for obstacle in self.obstacles:\n            obstacle -= self.speed  # Move obstacle to the left\n            if obstacle >= 0:\n                new_obstacles.append(obstacle)\n        self.obstacles = new_obstacles\n\n    def update_dinosaur(self):\n        \"\"\"\n        Updates the dinosaur's position based on its velocity and gravity.\n        \"\"\"\n        self.dinosaur_position += self.dinosaur_velocity\n        self.dinosaur_velocity += self.gravity\n\n        # Keep the dinosaur within the ground limits\n        if self.dinosaur_position < 0:\n            self.dinosaur_position = 0\n            self.dinosaur_velocity = 0  # Stop downward movement on the ground\n\n    def check_collision(self):\n        \"\"\"\n        Checks for a collision between the dinosaur and any obstacles.\n        \"\"\"\n        for obstacle in self.obstacles:\n            if (obstacle < 10 and obstacle > 3) and self.dinosaur_position < 2: # Collision detection range\n                return True\n        return False\n\n    def jump(self):\n        \"\"\"\n        Initiates a jump if the dinosaur is on the ground.\n        \"\"\"\n        if self.dinosaur_position == 0:  # Only jump if on the ground\n            self.dinosaur_velocity = self.jump_height\n\n    def draw_screen(self):\n        \"\"\"\n        Draws the current state of the game on the screen.\n        \"\"\"\n        self.clear_screen()  # Clear the previous frame\n        screen = [\" \" for _ in range(self.width * 6)] # 6 represents height of the screen\n\n        # Draw the ground\n        for i in range(self.width):\n            screen[i] = \"_\"\n\n        # Draw the dinosaur\n        dinosaur_height = 2\n        dinosaur_width = 3\n        dinosaur_start_index = (self.dinosaur_position + 1) * self.width + 3\n\n        if self.dinosaur_position <1: #standing dinosaur\n            dino =  \"\"\"\n            O\n           /|\\\\\n           / \\\\\n           \"\"\"\n        else:\n            dino =  \"\"\"\n            O\n           /|\\\\\n           / \\\\\n           \"\"\"\n\n        dino_lines = dino.splitlines()\n\n        for i, line in enumerate(dino_lines):\n          if line:\n            for j, char in enumerate(line):\n              screen[dinosaur_start_index - (len(dino_lines) -1 -i) * self.width + j] = char\n\n\n\n        # Draw the obstacles\n        obstacle_height = 2\n        obstacle_width = 2\n        for obstacle_x in self.obstacles:\n            for i in range(obstacle_height):\n                for j in range(obstacle_width):\n                  if (obstacle_x + j) < self.width:\n                    screen[(i) * self.width + int(obstacle_x +j)] = \"#\"\n\n        # Print the screen\n        for i in range(6): #Screen Height\n            print(\"\".join(screen[i*self.width:(i+1)*self.width]))\n\n        # Print score\n        print(f\"Score: {self.score}\")\n\n    def update_score(self):\n      \"\"\"Updates the score based on the distance traveled.\"\"\"\n      self.score += self.speed # the faster we go, the faster we score\n\n    def run(self):\n        \"\"\"\n        Runs the main game loop.\n        \"\"\"\n        while not self.game_over:\n            # Get user input\n            user_input = input(\"Press 'j' to jump, or any other key to continue (or 'q' to quit): \").lower()\n            if user_input == 'j':\n                self.jump()\n            elif user_input == 'q':\n                break\n\n            # Update game state\n            self.generate_obstacle()\n            self.update_obstacles()\n            self.update_dinosaur()\n            self.update_score()\n\n            if self.check_collision():\n                self.game_over = True\n\n            self.draw_screen()\n\n            # Increase speed\n            self.speed += self.speed_increment\n            self.frame_delay = max(0.02, 0.1 - (self.speed * 0.005)) #Adjust frame delay to increase speed smoothly\n\n            time.sleep(self.frame_delay)\n\n        if self.game_over:\n            print(\"Game Over!\")\n            print(f\"Final Score: {self.score}\")\n        else:\n            print(\"Game quit.\")\n            print(f\"Final Score: {self.score}\")\n\nif __name__ == \"__main__\":\n    game = DinosaurRunner()\n    game.run()\n```"
}