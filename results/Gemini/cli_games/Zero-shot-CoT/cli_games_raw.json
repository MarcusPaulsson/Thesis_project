{
    "0": "```python\nclass TicTacToe:\n    def __init__(self):\n        self.board = [\" \"] * 9\n        self.current_player = \"X\"\n        self.winner = None\n        self.game_over = False\n\n    def print_board(self):\n        \"\"\"Prints the current board state.\"\"\"\n        print(\"-------------\")\n        for i in range(3):\n            print(f\"| {self.board[i*3]} | {self.board[i*3+1]} | {self.board[i*3+2]} |\")\n            print(\"-------------\")\n\n    def is_valid_move(self, position):\n        \"\"\"Checks if the given position is a valid move.\"\"\"\n        if not isinstance(position, int):\n            return False\n        if not (0 <= position <= 8):\n            return False\n        if self.board[position] != \" \":\n            return False\n        return True\n\n    def make_move(self, position):\n        \"\"\"Makes a move on the board.\"\"\"\n        if self.is_valid_move(position):\n            self.board[position] = self.current_player\n            self.check_winner()\n            self.check_draw()\n            self.switch_player()\n        else:\n            print(\"Invalid move. Try again.\")\n\n    def switch_player(self):\n        \"\"\"Switches the current player.\"\"\"\n        self.current_player = \"O\" if self.current_player == \"X\" else \"X\"\n\n    def check_winner(self):\n        \"\"\"Checks if there is a winner.\"\"\"\n        winning_combinations = [\n            [0, 1, 2], [3, 4, 5], [6, 7, 8],  # Rows\n            [0, 3, 6], [1, 4, 7], [2, 5, 8],  # Columns\n            [0, 4, 8], [2, 4, 6]               # Diagonals\n        ]\n\n        for combo in winning_combinations:\n            a, b, c = combo\n            if self.board[a] == self.board[b] == self.board[c] != \" \":\n                self.winner = self.board[a]\n                self.game_over = True\n                return\n\n    def check_draw(self):\n        \"\"\"Checks if the game is a draw.\"\"\"\n        if \" \" not in self.board and not self.winner:\n            self.game_over = True\n\n    def play(self):\n        \"\"\"Main game loop.\"\"\"\n        while not self.game_over:\n            self.print_board()\n            try:\n                position = int(input(f\"Player {self.current_player}, enter your move (0-8): \"))\n                self.make_move(position)\n            except ValueError:\n                print(\"Invalid input. Please enter a number between 0 and 8.\")\n\n        self.print_board()\n        if self.winner:\n            print(f\"Player {self.winner} wins!\")\n        else:\n            print(\"It's a draw!\")\n\nif __name__ == \"__main__\":\n    game = TicTacToe()\n    game.play()\n```",
    "1": "```python\nimport random\n\nclass Hangman:\n    def __init__(self, word_list, max_attempts=6):\n        \"\"\"\n        Initializes the Hangman game.\n\n        Args:\n            word_list (list): A list of words to choose from.\n            max_attempts (int): The maximum number of incorrect guesses allowed.\n        \"\"\"\n        self.word_list = word_list\n        self.word_to_guess = random.choice(word_list).upper()\n        self.guessed_letters = set()\n        self.attempts_left = max_attempts\n        self.word_progress = ['_'] * len(self.word_to_guess)\n        self.game_over = False\n\n    def display_game_state(self):\n        \"\"\"\n        Displays the current state of the game to the player.\n        \"\"\"\n        print(\"\\n\" + \"=\" * 20)\n        print(\"Word:\", \" \".join(self.word_progress))\n        print(\"Guessed letters:\", \", \".join(sorted(self.guessed_letters)))\n        print(\"Attempts left:\", self.attempts_left)\n        print(\"=\" * 20 + \"\\n\")\n\n    def get_player_guess(self):\n        \"\"\"\n        Gets a letter guess from the player.\n\n        Returns:\n            str: The player's guess (a single uppercase letter).\n        \"\"\"\n        while True:\n            guess = input(\"Guess a letter: \").upper()\n            if not guess.isalpha():\n                print(\"Invalid input. Please enter a letter.\")\n            elif len(guess) != 1:\n                print(\"Please guess only one letter at a time.\")\n            elif guess in self.guessed_letters:\n                print(\"You already guessed that letter.\")\n            else:\n                return guess\n\n    def update_game_state(self, guess):\n        \"\"\"\n        Updates the game state based on the player's guess.\n\n        Args:\n            guess (str): The player's guess.\n        \"\"\"\n        self.guessed_letters.add(guess)\n        if guess in self.word_to_guess:\n            for i, letter in enumerate(self.word_to_guess):\n                if letter == guess:\n                    self.word_progress[i] = guess\n            if \"\".join(self.word_progress) == self.word_to_guess:\n                self.game_over = True\n                print(\"Congratulations! You guessed the word:\", self.word_to_guess)\n        else:\n            self.attempts_left -= 1\n            print(\"Incorrect guess.\")\n            if self.attempts_left == 0:\n                self.game_over = True\n                print(\"You ran out of attempts. The word was:\", self.word_to_guess)\n\n    def play_game(self):\n        \"\"\"\n        Plays the Hangman game.\n        \"\"\"\n        print(\"Welcome to Hangman!\")\n\n        while not self.game_over:\n            self.display_game_state()\n            guess = self.get_player_guess()\n            self.update_game_state(guess)\n\n        print(\"Game over!\")\n\n\nif __name__ == \"__main__\":\n    word_list = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\", \"fig\", \"grape\"]\n    game = Hangman(word_list)\n    game.play_game()\n```",
    "2": "```python\nimport random\n\nclass RockPaperScissors:\n    \"\"\"\n    A class to represent a Rock-Paper-Scissors game.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the game with the available choices and initial scores.\n        \"\"\"\n        self.choices = [\"rock\", \"paper\", \"scissors\"]\n        self.player_score = 0\n        self.computer_score = 0\n\n    def get_player_choice(self):\n        \"\"\"\n        Gets the player's choice from the command line.\n        Handles invalid inputs.\n        \"\"\"\n        while True:\n            choice = input(\"Choose rock, paper, or scissors: \").lower()\n            if choice in self.choices:\n                return choice\n            else:\n                print(\"Invalid choice. Please try again.\")\n\n    def get_computer_choice(self):\n        \"\"\"\n        Generates a random choice for the computer.\n        \"\"\"\n        return random.choice(self.choices)\n\n    def determine_winner(self, player_choice, computer_choice):\n        \"\"\"\n        Determines the winner of a round based on the player's and computer's choices.\n        \"\"\"\n        print(f\"You chose: {player_choice}\")\n        print(f\"Computer chose: {computer_choice}\")\n\n        if player_choice == computer_choice:\n            print(\"It's a tie!\")\n            return \"tie\"\n        elif (player_choice == \"rock\" and computer_choice == \"scissors\") or \\\n             (player_choice == \"paper\" and computer_choice == \"rock\") or \\\n             (player_choice == \"scissors\" and computer_choice == \"paper\"):\n            print(\"You win this round!\")\n            return \"player\"\n        else:\n            print(\"Computer wins this round!\")\n            return \"computer\"\n\n    def update_score(self, winner):\n        \"\"\"\n        Updates the score based on the winner of the round.\n        \"\"\"\n        if winner == \"player\":\n            self.player_score += 1\n        elif winner == \"computer\":\n            self.computer_score += 1\n\n    def display_score(self):\n        \"\"\"\n        Displays the current score.\n        \"\"\"\n        print(f\"Score: Player - {self.player_score}, Computer - {self.computer_score}\")\n\n    def play_round(self):\n        \"\"\"\n        Plays a single round of the game.\n        \"\"\"\n        player_choice = self.get_player_choice()\n        computer_choice = self.get_computer_choice()\n        winner = self.determine_winner(player_choice, computer_choice)\n        self.update_score(winner)\n        self.display_score()\n\n    def play_game(self):\n        \"\"\"\n        Plays the entire game until the player chooses to quit.\n        \"\"\"\n        print(\"Welcome to Rock-Paper-Scissors!\")\n        while True:\n            self.play_round()\n            play_again = input(\"Play again? (yes/no): \").lower()\n            if play_again != \"yes\":\n                print(\"Thanks for playing!\")\n                break\n\n\nif __name__ == \"__main__\":\n    game = RockPaperScissors()\n    game.play_game()\n```",
    "3": "```python\nimport random\nimport time\nimport os\n\nclass SnakeGame:\n    def __init__(self, width=20, height=15):\n        self.width = width\n        self.height = height\n        self.snake = [(width // 2, height // 2)]  # Snake starts in the middle\n        self.food = self.create_food()\n        self.direction = 'right'  # Initial direction\n        self.game_over = False\n        self.score = 0\n\n    def create_food(self):\n        while True:\n            x = random.randint(0, self.width - 1)\n            y = random.randint(0, self.height - 1)\n            if (x, y) not in self.snake:\n                return (x, y)\n\n    def move(self):\n        head_x, head_y = self.snake[0]\n\n        if self.direction == 'up':\n            new_head = (head_x, (head_y - 1) % self.height)\n        elif self.direction == 'down':\n            new_head = (head_x, (head_y + 1) % self.height)\n        elif self.direction == 'left':\n            new_head = ((head_x - 1) % self.width, head_y)\n        elif self.direction == 'right':\n            new_head = ((head_x + 1) % self.width, head_y)\n\n        if new_head in self.snake:\n            self.game_over = True\n            return\n\n        self.snake.insert(0, new_head)\n\n        if new_head == self.food:\n            self.score += 1\n            self.food = self.create_food()\n        else:\n            self.snake.pop()\n\n    def change_direction(self, new_direction):\n        if new_direction == 'up' and self.direction != 'down':\n            self.direction = 'up'\n        elif new_direction == 'down' and self.direction != 'up':\n            self.direction = 'down'\n        elif new_direction == 'left' and self.direction != 'right':\n            self.direction = 'left'\n        elif new_direction == 'right' and self.direction != 'left':\n            self.direction = 'right'\n\n    def draw(self):\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the screen\n        print(f\"Score: {self.score}\")\n\n        for y in range(self.height):\n            for x in range(self.width):\n                if (x, y) in self.snake:\n                    print(\"O\", end=\"\")\n                elif (x, y) == self.food:\n                    print(\"F\", end=\"\")\n                else:\n                    print(\".\", end=\"\")\n            print()  # Newline at the end of each row\n\n    def play(self):\n        while not self.game_over:\n            self.draw()\n            self.move()\n\n            if self.game_over:\n                break\n\n            time.sleep(0.1)  # Adjust speed here\n\n            # Get input from the user (non-blocking)\n            import select, sys\n            timeout = 0.001 #Small timeout for non-blocking input\n            rlist, _, _ = select.select([sys.stdin], [], [], timeout)\n\n            if rlist: #If there's input\n                key = sys.stdin.readline().strip().lower()\n\n                if key == 'w':\n                    self.change_direction('up')\n                elif key == 's':\n                    self.change_direction('down')\n                elif key == 'a':\n                    self.change_direction('left')\n                elif key == 'd':\n                    self.change_direction('right')\n                elif key == 'q':\n                    self.game_over = True #Quit\n\n        print(\"Game Over!\")\n        print(f\"Final Score: {self.score}\")\n\nif __name__ == '__main__':\n    game = SnakeGame()\n    game.play()\n```",
    "4": "```python\nimport random\n\nclass Minesweeper:\n    def __init__(self, rows, cols, mines):\n        self.rows = rows\n        self.cols = cols\n        self.mines = mines\n        self.board = [[' ' for _ in range(cols)] for _ in range(rows)]\n        self.revealed = [[False for _ in range(cols)] for _ in range(rows)]\n        self.flags = [[False for _ in range(cols)] for _ in range(rows)]\n        self.game_over = False\n        self.first_move = True\n        self.mine_positions = [] # Keep track of mine positions\n\n    def print_board(self, show_mines=False):\n        \"\"\"Prints the current state of the board.\"\"\"\n        col_labels = \"   \" + \" \".join([str(i % 10) for i in range(self.cols)])  # Handles columns > 9\n        print(col_labels)\n        print(\"  \" + \"-\" * (2 * self.cols + 1))\n        for i in range(self.rows):\n            row_str = str(i % 10) + \"| \" # Handles rows > 9\n            for j in range(self.cols):\n                if self.flags[i][j]:\n                    row_str += \"F \"\n                elif self.revealed[i][j]:\n                    row_str += str(self.board[i][j]) + \" \"\n                elif show_mines and (i,j) in self.mine_positions:\n                    row_str += \"* \"\n                else:\n                    row_str += \". \"\n            print(row_str + \"|\" + str(i % 10))\n        print(\"  \" + \"-\" * (2 * self.cols + 1))\n        print(col_labels)\n\n    def place_mines(self, safe_row, safe_col):\n        \"\"\"Places mines randomly on the board, avoiding the initial click.\"\"\"\n        possible_positions = [(r, c) for r in range(self.rows) for c in range(self.cols) if (r, c) != (safe_row, safe_col)]\n        self.mine_positions = random.sample(possible_positions, self.mines)\n\n        for r, c in self.mine_positions:\n            self.board[r][c] = '*'\n\n    def calculate_neighbor_counts(self):\n        \"\"\"Calculates the number of neighboring mines for each cell.\"\"\"\n        for r in range(self.rows):\n            for c in range(self.cols):\n                if self.board[r][c] != '*':\n                    count = 0\n                    for i in range(max(0, r - 1), min(self.rows, r + 2)):\n                        for j in range(max(0, c - 1), min(self.cols, c + 2)):\n                            if self.board[i][j] == '*':\n                                count += 1\n                    self.board[r][c] = count if count > 0 else ' '\n\n    def reveal(self, row, col):\n        \"\"\"Reveals a cell and recursively reveals neighboring empty cells.\"\"\"\n        if row < 0 or row >= self.rows or col < 0 or col >= self.cols or self.revealed[row][col]:\n            return\n\n        self.revealed[row][col] = True\n\n        if self.board[row][col] == '*':\n            self.game_over = True\n            return\n\n        if self.board[row][col] == ' ':\n            for i in range(max(0, row - 1), min(self.rows, row + 2)):\n                for j in range(max(0, col - 1), min(self.cols, col + 2)):\n                    self.reveal(i, j)\n\n    def toggle_flag(self, row, col):\n        \"\"\"Toggles a flag on a cell.\"\"\"\n        if self.revealed[row][col]:\n            print(\"Cannot flag a revealed cell.\")\n            return\n\n        self.flags[row][col] = not self.flags[row][col]\n\n    def check_win(self):\n        \"\"\"Checks if the player has won the game.\"\"\"\n        revealed_count = 0\n        for r in range(self.rows):\n            for c in range(self.cols):\n                if self.revealed[r][c]:\n                    revealed_count += 1\n\n        return revealed_count == self.rows * self.cols - self.mines\n\n    def play(self):\n        \"\"\"Main game loop.\"\"\"\n        while not self.game_over:\n            self.print_board()\n            action = input(\"Enter action (r=reveal, f=flag, q=quit) and coordinates (e.g., r 0 0): \").split()\n\n            if not action:\n                print(\"Invalid input. Please enter an action and coordinates.\")\n                continue\n\n            if action[0].lower() == 'q':\n                print(\"Quitting game.\")\n                return\n\n            try:\n                row = int(action[1])\n                col = int(action[2])\n            except (IndexError, ValueError):\n                print(\"Invalid coordinates. Please enter row and column numbers.\")\n                continue\n\n            if row < 0 or row >= self.rows or col < 0 or col >= self.cols:\n                print(\"Coordinates are out of bounds.\")\n                continue\n\n            if action[0].lower() == 'r':\n                if self.first_move:\n                    self.place_mines(row, col)\n                    self.calculate_neighbor_counts()\n                    self.first_move = False\n                self.reveal(row, col)\n                if self.game_over:\n                    self.print_board(show_mines=True)\n                    print(\"Game Over! You hit a mine.\")\n                    return\n            elif action[0].lower() == 'f':\n                self.toggle_flag(row, col)\n            else:\n                print(\"Invalid action. Use 'r' to reveal, 'f' to flag, or 'q' to quit.\")\n\n            if self.check_win():\n                self.print_board()\n                print(\"Congratulations! You won!\")\n                return\n\nif __name__ == '__main__':\n    rows = 10\n    cols = 10\n    mines = 15\n    game = Minesweeper(rows, cols, mines)\n    game.play()\n```",
    "5": "```python\nimport random\n\nclass Mastermind:\n    \"\"\"\n    A class to represent the Mastermind game.\n    \"\"\"\n\n    def __init__(self, code_length=4, colors=6, max_guesses=10):\n        \"\"\"\n        Initializes the Mastermind game.\n\n        Args:\n            code_length (int): The length of the secret code.\n            colors (int): The number of different colors to choose from (1 to colors).\n            max_guesses (int): The maximum number of guesses allowed.\n        \"\"\"\n        self.code_length = code_length\n        self.colors = colors\n        self.max_guesses = max_guesses\n        self.secret_code = self.generate_secret_code()\n        self.guesses = []\n        self.feedback = []\n        self.game_over = False\n        self.won = False\n\n    def generate_secret_code(self):\n        \"\"\"\n        Generates a random secret code.\n\n        Returns:\n            list: A list of integers representing the secret code.\n        \"\"\"\n        return [random.randint(1, self.colors) for _ in range(self.code_length)]\n\n    def get_guess(self):\n        \"\"\"\n        Gets a guess from the player through the command line.\n\n        Returns:\n            list: A list of integers representing the player's guess, or None if the input is invalid.\n        \"\"\"\n        while True:\n            try:\n                guess_str = input(f\"Enter your guess (separated by spaces, {self.code_length} numbers from 1 to {self.colors}): \")\n                guess = [int(x) for x in guess_str.split()]\n                if len(guess) != self.code_length:\n                    print(f\"Invalid guess: You must enter {self.code_length} numbers.\")\n                elif any(x < 1 or x > self.colors for x in guess):\n                    print(f\"Invalid guess: Numbers must be between 1 and {self.colors}.\")\n                else:\n                    return guess\n            except ValueError:\n                print(\"Invalid input: Please enter numbers separated by spaces.\")\n\n    def check_guess(self, guess):\n        \"\"\"\n        Checks the player's guess against the secret code and provides feedback.\n\n        Args:\n            guess (list): A list of integers representing the player's guess.\n\n        Returns:\n            tuple: A tuple containing the number of correct positions and the number of correct colors.\n        \"\"\"\n        correct_position = 0\n        correct_color = 0\n        temp_secret = self.secret_code[:]  # Create a copy to avoid modifying the original\n        temp_guess = guess[:]  # Create a copy to avoid modifying the original\n\n        # Check for correct positions first\n        for i in range(self.code_length):\n            if temp_guess[i] == temp_secret[i]:\n                correct_position += 1\n                temp_guess[i] = None  # Mark as matched\n                temp_secret[i] = None  # Mark as matched\n\n        # Check for correct colors\n        for i in range(self.code_length):\n            if temp_guess[i] is not None:\n                try:\n                    index = temp_secret.index(temp_guess[i])\n                    correct_color += 1\n                    temp_secret[index] = None  # Mark as matched\n                except ValueError:\n                    pass  # Color not found in secret code\n\n        return correct_position, correct_color\n\n    def play_round(self):\n        \"\"\"\n        Plays a single round of the game.\n        \"\"\"\n        guess = self.get_guess()\n        if guess is None:\n            return  # Invalid guess, don't proceed\n\n        self.guesses.append(guess)\n        correct_position, correct_color = self.check_guess(guess)\n        self.feedback.append((correct_position, correct_color))\n\n        print(f\"Feedback: Correct Position: {correct_position}, Correct Color: {correct_color}\")\n\n        if correct_position == self.code_length:\n            self.game_over = True\n            self.won = True\n            print(\"Congratulations! You cracked the code!\")\n        elif len(self.guesses) >= self.max_guesses:\n            self.game_over = True\n            print(f\"You ran out of guesses. The secret code was: {self.secret_code}\")\n\n    def play_game(self):\n        \"\"\"\n        Plays the entire Mastermind game.\n        \"\"\"\n        print(\"Welcome to Mastermind!\")\n        print(f\"I've generated a secret code with {self.code_length} numbers, each from 1 to {self.colors}.\")\n        print(f\"You have {self.max_guesses} guesses to crack the code.\")\n\n        while not self.game_over:\n            self.play_round()\n\n\nif __name__ == \"__main__\":\n    game = Mastermind()\n    game.play_game()\n```",
    "6": "```python\nimport random\n\nclass Battleship:\n    def __init__(self, grid_size=10, num_ships=5, ship_lengths=[2, 3, 3, 4, 5]):\n        self.grid_size = grid_size\n        self.num_ships = num_ships\n        self.ship_lengths = ship_lengths\n        self.player_grid = [['.' for _ in range(grid_size)] for _ in range(grid_size)]\n        self.computer_grid = [['.' for _ in range(grid_size)] for _ in range(grid_size)]\n        self.computer_ships = []\n        self.player_ships = []\n        self.player_guesses = set()\n        self.computer_guesses = set()\n        self.ship_symbols = ['S' for _ in range(num_ships)]  # Use 'S' for ship representation\n        self.player_ships_placed = False\n\n    def print_grid(self, grid):\n        \"\"\"Prints the given grid to the console.\"\"\"\n        header = \"   \" + \" \".join([chr(65 + i) for i in range(self.grid_size)])\n        print(header)\n        for i, row in enumerate(grid):\n            print(f\"{i+1:2} {' '.join(row)}\")\n\n    def place_ship(self, grid, ship_length, ship_symbol, is_computer=False):\n        \"\"\"Places a ship of given length on the grid.\"\"\"\n        while True:\n            if is_computer:\n                orientation = random.choice(['horizontal', 'vertical'])\n                row = random.randint(0, self.grid_size - 1)\n                col = random.randint(0, self.grid_size - 1)\n            else:\n                orientation = input(\"Enter orientation (horizontal or vertical): \").lower()\n                row = int(input(\"Enter starting row (1-{}): \".format(self.grid_size))) - 1\n                col = ord(input(\"Enter starting column (A-{}): \".format(chr(65 + self.grid_size - 1))).upper()) - 65\n\n            if orientation not in ['horizontal', 'vertical']:\n                print(\"Invalid orientation. Please enter 'horizontal' or 'vertical'.\")\n                continue\n\n            if row < 0 or row >= self.grid_size or col < 0 or col >= self.grid_size:\n                print(\"Invalid coordinates.  Please enter valid coordinates within the grid.\")\n                continue\n\n            if (orientation == 'horizontal' and col + ship_length > self.grid_size) or \\\n               (orientation == 'vertical' and row + ship_length > self.grid_size):\n                print(\"Ship placement exceeds grid boundaries.\")\n                continue\n\n            # Check for collisions\n            valid_placement = True\n            if orientation == 'horizontal':\n                for i in range(ship_length):\n                    if grid[row][col + i] != '.':\n                        valid_placement = False\n                        break\n            else:  # vertical\n                for i in range(ship_length):\n                    if grid[row + i][col] != '.':\n                        valid_placement = False\n                        break\n\n            if not valid_placement:\n                print(\"Ship overlaps with another ship.  Try again.\")\n                continue\n\n            # Place the ship\n            if orientation == 'horizontal':\n                for i in range(ship_length):\n                    grid[row][col + i] = ship_symbol\n            else:  # vertical\n                for i in range(ship_length):\n                    grid[row + i][col] = ship_symbol\n\n            # Store ship coordinates\n            ship_coordinates = []\n            if orientation == 'horizontal':\n                for i in range(ship_length):\n                    ship_coordinates.append((row, col + i))\n            else:\n                for i in range(ship_length):\n                    ship_coordinates.append((row + i, col))\n\n            return ship_coordinates\n\n    def place_computer_ships(self):\n        \"\"\"Places the computer's ships randomly on the grid.\"\"\"\n        for i, length in enumerate(self.ship_lengths):\n            ship_coordinates = self.place_ship(self.computer_grid, length, self.ship_symbols[i], is_computer=True)\n            self.computer_ships.append(ship_coordinates)\n\n    def place_player_ships(self):\n        \"\"\"Places the player's ships based on user input.\"\"\"\n        print(\"Place your ships:\")\n        for i, length in enumerate(self.ship_lengths):\n            print(f\"Placing ship of length {length}:\")\n            self.print_grid(self.player_grid)\n            ship_coordinates = self.place_ship(self.player_grid, length, self.ship_symbols[i])\n            self.player_ships.append(ship_coordinates)\n        self.player_ships_placed = True\n        print(\"Your ships have been placed:\")\n        self.print_grid(self.player_grid)\n\n    def get_player_guess(self):\n        \"\"\"Gets the player's guess from the console.\"\"\"\n        while True:\n            try:\n                guess_str = input(\"Enter your guess (e.g., A1): \").upper()\n                col = ord(guess_str[0]) - 65\n                row = int(guess_str[1:]) - 1\n                if row < 0 or row >= self.grid_size or col < 0 or col >= self.grid_size:\n                    print(\"Invalid coordinates.  Please enter valid coordinates within the grid.\")\n                    continue\n                if (row, col) in self.player_guesses:\n                    print(\"You already guessed that location. Try again.\")\n                    continue\n                return row, col\n            except (ValueError, IndexError):\n                print(\"Invalid input. Please enter a guess in the format A1, B2, etc.\")\n\n    def handle_player_turn(self):\n        \"\"\"Handles the player's turn.\"\"\"\n        row, col = self.get_player_guess()\n        self.player_guesses.add((row, col))\n\n        if self.computer_grid[row][col] != '.':\n            print(\"Hit!\")\n            self.computer_grid[row][col] = 'X'  # Mark hit on the computer's grid\n            # Check if ship is sunk\n            for ship in self.computer_ships:\n                if (row, col) in ship:\n                    ship.remove((row, col))\n                    if not ship:\n                        print(\"You sunk a computer's ship!\")\n                        self.computer_ships.remove(ship)\n                    break\n\n        else:\n            print(\"Miss!\")\n            self.computer_grid[row][col] = 'O'  # Mark miss on the computer's grid\n\n    def computer_make_guess(self):\n        \"\"\"The computer makes a guess.\"\"\"\n        while True:\n            row = random.randint(0, self.grid_size - 1)\n            col = random.randint(0, self.grid_size - 1)\n            if (row, col) not in self.computer_guesses:\n                self.computer_guesses.add((row, col))\n                return row, col\n\n    def handle_computer_turn(self):\n        \"\"\"Handles the computer's turn.\"\"\"\n        row, col = self.computer_make_guess()\n        print(f\"Computer guesses {chr(col + 65)}{row + 1}\")\n\n        if self.player_grid[row][col] != '.':\n            print(\"Computer hit your ship!\")\n            self.player_grid[row][col] = 'X'  # Mark hit on the player's grid\n\n            # Check if ship is sunk\n            for ship in self.player_ships:\n                if (row, col) in ship:\n                    ship.remove((row, col))\n                    if not ship:\n                        print(\"Computer sunk one of your ships!\")\n                        self.player_ships.remove(ship)\n                    break\n\n        else:\n            print(\"Computer missed!\")\n            self.player_grid[row][col] = 'O'  # Mark miss on the player's grid\n\n    def check_game_over(self):\n        \"\"\"Checks if the game is over.\"\"\"\n        if not self.computer_ships:\n            print(\"Congratulations! You sunk all the computer's ships!\")\n            return True\n        if not self.player_ships:\n            print(\"Game over! The computer sunk all your ships!\")\n            return True\n        return False\n\n    def play_game(self):\n        \"\"\"Main game loop.\"\"\"\n        print(\"Welcome to Battleship!\")\n        self.place_computer_ships()\n        self.place_player_ships()\n\n        while True:\n            print(\"\\nYour turn:\")\n            print(\"Your Grid:\")\n            self.print_grid(self.player_grid)\n            print(\"Computer's Grid:\")\n            self.print_grid(self.computer_grid)\n            self.handle_player_turn()\n\n            if self.check_game_over():\n                break\n\n            print(\"\\nComputer's turn:\")\n            self.handle_computer_turn()\n\n            if self.check_game_over():\n                break\n\nif __name__ == \"__main__\":\n    game = Battleship()\n    game.play_game()\n```",
    "7": "```python\nimport argparse\nimport time\nimport os\nimport random\n\n\nclass GameOfLife:\n    \"\"\"\n    A class representing the Game of Life.\n    \"\"\"\n\n    def __init__(self, width, height, density=0.3, initial_state=None):\n        \"\"\"\n        Initializes the Game of Life.\n\n        Args:\n            width (int): The width of the grid.\n            height (int): The height of the grid.\n            density (float): The initial density of live cells (0 to 1).\n            initial_state (list[list[int]]): An optional initial state.  Must be a 2D list of 0s and 1s.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.grid = self.create_grid(density, initial_state)\n\n    def create_grid(self, density, initial_state):\n        \"\"\"\n        Creates the initial grid with a random distribution of live cells.\n\n        Returns:\n            list[list[int]]: The grid representing the game state.\n        \"\"\"\n        if initial_state:\n            if len(initial_state) != self.height or any(len(row) != self.width for row in initial_state):\n                raise ValueError(\"Initial state dimensions do not match specified width and height.\")\n            return [row[:] for row in initial_state]  # Create a copy to avoid modifying the original\n\n        grid = []\n        for _ in range(self.height):\n            row = [1 if random.random() < density else 0 for _ in range(self.width)]\n            grid.append(row)\n        return grid\n\n    def get_neighbors(self, row, col):\n        \"\"\"\n        Gets the number of live neighbors for a given cell.\n\n        Args:\n            row (int): The row index of the cell.\n            col (int): The column index of the cell.\n\n        Returns:\n            int: The number of live neighbors.\n        \"\"\"\n        neighbors = 0\n        for i in range(max(0, row - 1), min(self.height, row + 2)):\n            for j in range(max(0, col - 1), min(self.width, col + 2)):\n                if (i, j) != (row, col):\n                    neighbors += self.grid[i][j]\n        return neighbors\n\n    def update_grid(self):\n        \"\"\"\n        Updates the grid to the next generation based on the Game of Life rules.\n        \"\"\"\n        new_grid = []\n        for row in range(self.height):\n            new_row = []\n            for col in range(self.width):\n                neighbors = self.get_neighbors(row, col)\n                if self.grid[row][col] == 1:  # Live cell\n                    if neighbors < 2 or neighbors > 3:\n                        new_row.append(0)  # Dies\n                    else:\n                        new_row.append(1)  # Stays alive\n                else:  # Dead cell\n                    if neighbors == 3:\n                        new_row.append(1)  # Becomes alive\n                    else:\n                        new_row.append(0)  # Stays dead\n            new_grid.append(new_row)\n        self.grid = new_grid\n\n    def display_grid(self):\n        \"\"\"\n        Displays the grid in the console.\n        \"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n        for row in self.grid:\n            print(\"\".join(['#' if cell == 1 else ' ' for cell in row]))\n\n    def run_simulation(self, generations, delay=0.1):\n        \"\"\"\n        Runs the Game of Life simulation for a specified number of generations.\n\n        Args:\n            generations (int): The number of generations to simulate.\n            delay (float): The delay between generations in seconds.\n        \"\"\"\n        for _ in range(generations):\n            self.display_grid()\n            self.update_grid()\n            time.sleep(delay)\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='Conway\\'s Game of Life')\n    parser.add_argument('--width', type=int, default=60, help='Width of the grid')\n    parser.add_argument('--height', type=int, default=30, help='Height of the grid')\n    parser.add_argument('--generations', type=int, default=100, help='Number of generations to simulate')\n    parser.add_argument('--delay', type=float, default=0.1, help='Delay between generations (seconds)')\n    parser.add_argument('--density', type=float, default=0.3, help='Initial density of live cells (0 to 1)')\n\n    args = parser.parse_args()\n\n    game = GameOfLife(args.width, args.height, args.density)\n    game.run_simulation(args.generations, args.delay)\n```",
    "8": "```python\nclass ConnectFour:\n    def __init__(self, rows=6, cols=7):\n        self.rows = rows\n        self.cols = cols\n        self.board = [[' ' for _ in range(cols)] for _ in range(rows)]\n        self.current_player = 'X'  # Start with player X\n        self.game_over = False\n\n    def print_board(self):\n        \"\"\"Prints the Connect Four board to the console.\"\"\"\n        for row in range(self.rows):\n            print('|' + '|'.join(self.board[row]) + '|')\n        print('+' + '+'.join(str(i + 1) for i in range(self.cols)) + '+') # Column numbers\n\n\n    def is_valid_move(self, col):\n        \"\"\"Checks if a move (column) is valid.\"\"\"\n        if not (0 <= col < self.cols):\n            return False  # Column out of bounds\n        return self.board[0][col] == ' '  # Column not full\n\n    def drop_piece(self, col):\n        \"\"\"Drops a piece into the specified column.\"\"\"\n        if not self.is_valid_move(col):\n            return False  # Invalid move\n\n        for row in range(self.rows - 1, -1, -1):\n            if self.board[row][col] == ' ':\n                self.board[row][col] = self.current_player\n                return True  # Piece dropped successfully\n\n        return False  # Should not reach here if move is valid\n\n    def check_win(self):\n        \"\"\"Checks for a win in horizontal, vertical, and diagonal directions.\"\"\"\n\n        # Horizontal\n        for row in range(self.rows):\n            for col in range(self.cols - 3):\n                if (self.board[row][col] == self.current_player and\n                        self.board[row][col + 1] == self.current_player and\n                        self.board[row][col + 2] == self.current_player and\n                        self.board[row][col + 3] == self.current_player):\n                    return True\n\n        # Vertical\n        for row in range(self.rows - 3):\n            for col in range(self.cols):\n                if (self.board[row][col] == self.current_player and\n                        self.board[row + 1][col] == self.current_player and\n                        self.board[row + 2][col] == self.current_player and\n                        self.board[row + 3][col] == self.current_player):\n                    return True\n\n        # Positive Diagonal\n        for row in range(self.rows - 3):\n            for col in range(self.cols - 3):\n                if (self.board[row][col] == self.current_player and\n                        self.board[row + 1][col + 1] == self.current_player and\n                        self.board[row + 2][col + 2] == self.current_player and\n                        self.board[row + 3][col + 3] == self.current_player):\n                    return True\n\n        # Negative Diagonal\n        for row in range(3, self.rows):\n            for col in range(self.cols - 3):\n                if (self.board[row][col] == self.current_player and\n                        self.board[row - 1][col + 1] == self.current_player and\n                        self.board[row - 2][col + 2] == self.current_player and\n                        self.board[row - 3][col + 3] == self.current_player):\n                    return True\n\n        return False\n\n\n    def check_draw(self):\n        \"\"\"Checks if the board is full (draw).\"\"\"\n        for col in range(self.cols):\n            if self.board[0][col] == ' ':\n                return False  # Not a draw, there's an empty space\n        return True  # It's a draw\n\n    def switch_player(self):\n        \"\"\"Switches the current player.\"\"\"\n        self.current_player = 'O' if self.current_player == 'X' else 'X'\n\n    def play_turn(self, col):\n        \"\"\"Plays a single turn for the current player.\"\"\"\n        if self.game_over:\n            return False\n\n        if self.drop_piece(col):\n            if self.check_win():\n                self.print_board()\n                print(f\"Player {self.current_player} wins!\")\n                self.game_over = True\n                return True\n\n            if self.check_draw():\n                self.print_board()\n                print(\"It's a draw!\")\n                self.game_over = True\n                return True\n\n            self.switch_player()\n            return True\n        else:\n            print(\"Invalid move. Try again.\")\n            return False #Invalid move\n\n\n    def play_game(self):\n        \"\"\"Main game loop.\"\"\"\n        while not self.game_over:\n            self.print_board()\n            try:\n                col = int(input(f\"Player {self.current_player}, enter column (1-{self.cols}): \")) - 1\n                if not self.play_turn(col):\n                    continue #Invalid move, ask again\n            except ValueError:\n                print(\"Invalid input. Enter a number between 1 and\", self.cols)\n                continue #Invalid input, ask again\n            except KeyboardInterrupt:\n                print(\"\\nGame interrupted.\")\n                self.game_over = True #End the game gracefully\n\nif __name__ == \"__main__\":\n    game = ConnectFour()\n    game.play_game()\n```",
    "9": "```python\nimport random\n\nclass Blackjack:\n    \"\"\"\n    A class to represent a Blackjack game.\n    \"\"\"\n\n    SUITS = ('Hearts', 'Diamonds', 'Clubs', 'Spades')\n    RANKS = ('Two', 'Three', 'Four', 'Five', 'Six', 'Seven',\n             'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace')\n    VALUES = {'Two': 2, 'Three': 3, 'Four': 4, 'Five': 5, 'Six': 6,\n              'Seven': 7, 'Eight': 8, 'Nine': 9, 'Ten': 10, 'Jack': 10,\n              'Queen': 10, 'King': 10, 'Ace': 11}\n\n    def __init__(self):\n        \"\"\"\n        Initializes a new Blackjack game.\n        \"\"\"\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n        self.player_total = 0\n        self.dealer_total = 0\n        self.player_aces = 0\n        self.dealer_aces = 0\n        self.game_over = False\n\n    def create_deck(self):\n        \"\"\"\n        Creates a standard 52-card deck.\n        \"\"\"\n        deck = []\n        for suit in self.SUITS:\n            for rank in self.RANKS:\n                deck.append((suit, rank))\n        random.shuffle(deck)\n        return deck\n\n    def deal_card(self, hand):\n        \"\"\"\n        Deals a card from the deck to the specified hand.\n        \"\"\"\n        suit, rank = self.deck.pop()\n        hand.append((suit, rank))\n        return suit, rank\n\n    def calculate_hand_value(self, hand):\n        \"\"\"\n        Calculates the total value of a hand.\n        \"\"\"\n        total = 0\n        aces = 0\n        for suit, rank in hand:\n            value = self.VALUES[rank]\n            total += value\n            if rank == 'Ace':\n                aces += 1\n\n        while total > 21 and aces > 0:\n            total -= 10\n            aces -= 1\n\n        return total, aces\n\n    def deal_initial_hands(self):\n        \"\"\"\n        Deals the initial hands to the player and the dealer.\n        \"\"\"\n        for _ in range(2):\n            suit, rank = self.deal_card(self.player_hand)\n            self.player_total, self.player_aces = self.calculate_hand_value(self.player_hand)\n            suit, rank = self.deal_card(self.dealer_hand)\n            self.dealer_total, self.dealer_aces = self.calculate_hand_value(self.dealer_hand)\n\n    def hit(self):\n        \"\"\"\n        Deals a card to the player's hand and updates the player's total.\n        \"\"\"\n        suit, rank = self.deal_card(self.player_hand)\n        self.player_total, self.player_aces = self.calculate_hand_value(self.player_hand)\n        if self.player_total > 21:\n            print(\"Bust! Player loses.\")\n            self.game_over = True\n\n    def dealer_play(self):\n        \"\"\"\n        The dealer's turn to play.\n        \"\"\"\n        while self.dealer_total < 17:\n            suit, rank = self.deal_card(self.dealer_hand)\n            self.dealer_total, self.dealer_aces = self.calculate_hand_value(self.dealer_hand)\n            print(f\"Dealer hits. Dealer's hand: {self.dealer_hand}, Total: {self.dealer_total}\")\n            if self.dealer_total > 21:\n                print(\"Dealer busts! Player wins.\")\n                self.game_over = True\n                return\n\n    def determine_winner(self):\n        \"\"\"\n        Determines the winner of the game.\n        \"\"\"\n        if self.player_total > self.dealer_total or self.dealer_total > 21:\n            print(\"Player wins!\")\n        elif self.player_total == self.dealer_total:\n            print(\"It's a push!\")\n        else:\n            print(\"Dealer wins!\")\n\n    def print_hands(self, show_dealer_full=False):\n        \"\"\"\n        Prints the player's and dealer's hands.\n        \"\"\"\n        print(f\"Player's hand: {self.player_hand}, Total: {self.player_total}\")\n        if show_dealer_full:\n            print(f\"Dealer's hand: {self.dealer_hand}, Total: {self.dealer_total}\")\n        else:\n            print(f\"Dealer's hand: [Hidden card, {self.dealer_hand[1]}], Total: ?\")\n\n    def play_game(self):\n        \"\"\"\n        The main game loop.\n        \"\"\"\n        self.deal_initial_hands()\n        print(\"Welcome to Blackjack!\")\n        self.print_hands()\n\n        while not self.game_over:\n            action = input(\"Hit or Stand? (h/s): \").lower()\n            if action == 'h':\n                self.hit()\n                self.print_hands()\n                if self.game_over:\n                    break\n            elif action == 's':\n                print(\"Player stands.\")\n                self.dealer_play()\n                if not self.game_over:\n                    self.print_hands(show_dealer_full=True)\n                    self.determine_winner()\n                self.game_over = True\n            else:\n                print(\"Invalid action. Please enter 'h' or 's'.\")\n\n        print(\"Game over!\")\n\n\nif __name__ == \"__main__\":\n    game = Blackjack()\n    game.play_game()\n```",
    "10": "```python\nimport random\n\nclass Hammurabi:\n    \"\"\"\n    A class to represent the game Hammurabi.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the game state.\n        \"\"\"\n        self.year = 1\n        self.population = 100\n        self.grain_stores = 2800\n        self.acres_owned = 1000\n        self.bushels_per_acre = 3\n        self.deaths_from_starvation = 0\n        self.immigrants = 0\n\n    def summarize_year(self):\n        \"\"\"\n        Prints a summary of the year's events.\n        \"\"\"\n        print(f\"\\nYear {self.year} Summary:\")\n        print(f\"Population: {self.population}\")\n        print(f\"Acres owned: {self.acres_owned}\")\n        print(f\"Grain stores: {self.grain_stores}\")\n        print(f\"Harvest: {self.bushels_per_acre} bushels per acre\")\n        print(f\"Deaths from starvation: {self.deaths_from_starvation}\")\n        print(f\"Immigrants: {self.immigrants}\")\n\n    def ask_how_much_to_buy(self):\n        \"\"\"\n        Asks the player how much grain to buy.\n\n        Returns:\n            The number of bushels to buy, or None if input is invalid.\n        \"\"\"\n        while True:\n            try:\n                bushels_to_buy = int(input(\"How many bushels of grain do you wish to buy? \"))\n                if bushels_to_buy < 0:\n                    print(\"Please enter a non-negative number.\")\n                elif bushels_to_buy * self.current_price > self.grain_stores:\n                    print(\"You do not have enough grain to pay for that.\")\n                else:\n                    return bushels_to_buy\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n    def ask_how_much_to_sell(self):\n        \"\"\"\n        Asks the player how much grain to sell.\n\n        Returns:\n            The number of bushels to sell, or None if input is invalid.\n        \"\"\"\n        while True:\n            try:\n                bushels_to_sell = int(input(\"How many bushels of grain do you wish to sell? \"))\n                if bushels_to_sell < 0:\n                    print(\"Please enter a non-negative number.\")\n                elif bushels_to_sell > self.grain_stores:\n                    print(\"You do not have that much grain to sell.\")\n                else:\n                    return bushels_to_sell\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n    def ask_how_much_to_feed(self):\n        \"\"\"\n        Asks the player how much grain to feed the people.\n\n        Returns:\n            The amount of grain to feed, or None if input is invalid.\n        \"\"\"\n        while True:\n            try:\n                grain_to_feed = int(input(\"How many bushels of grain do you wish to feed your people? \"))\n                if grain_to_feed < 0:\n                    print(\"Please enter a non-negative number.\")\n                elif grain_to_feed > self.grain_stores:\n                    print(\"You do not have that much grain.\")\n                else:\n                    return grain_to_feed\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n    def ask_how_much_to_plant(self):\n        \"\"\"\n        Asks the player how many acres to plant with grain.\n\n        Returns:\n            The number of acres to plant, or None if input is invalid.\n        \"\"\"\n        while True:\n            try:\n                acres_to_plant = int(input(\"How many acres do you wish to plant with grain? \"))\n                if acres_to_plant < 0:\n                    print(\"Please enter a non-negative number.\")\n                elif acres_to_plant > self.acres_owned:\n                    print(\"You do not own that much land.\")\n                elif acres_to_plant > self.grain_stores:\n                    print(\"You do not have enough grain to plant that much.\")\n                elif acres_to_plant > self.population * 10:\n                    print(\"You do not have enough people to plant that much land.\")\n                else:\n                    return acres_to_plant\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n    def play_year(self):\n        \"\"\"\n        Plays one year of the game.\n        \"\"\"\n\n        self.current_price = random.randint(17, 23)\n\n        print(f\"\\nYear {self.year}\")\n        print(f\"The current price of land is {self.current_price} bushels per acre.\")\n\n        # Buy/Sell Land (Not Implemented)\n\n        # Buy/Sell Grain\n        buy_sell_choice = input(\"Do you want to buy or sell grain? (buy/sell/no): \").lower()\n        if buy_sell_choice == \"buy\":\n            bushels_to_buy = self.ask_how_much_to_buy()\n            if bushels_to_buy is not None:\n                self.grain_stores -= bushels_to_buy * self.current_price\n                self.acres_owned += bushels_to_buy\n                print(f\"You bought {bushels_to_buy} acres of land.\")\n        elif buy_sell_choice == \"sell\":\n            bushels_to_sell = self.ask_how_much_to_sell()\n            if bushels_to_sell is not None:\n                self.grain_stores += bushels_to_sell * self.current_price\n                self.acres_owned -= bushels_to_sell\n                print(f\"You sold {bushels_to_sell} acres of land.\")\n\n        # Feed the people\n        grain_to_feed = self.ask_how_much_to_feed()\n        if grain_to_feed is not None:\n            self.grain_stores -= grain_to_feed\n\n        # Plant the grain\n        acres_to_plant = self.ask_how_much_to_plant()\n        if acres_to_plant is not None:\n            self.grain_stores -= acres_to_plant\n            \n        # Harvest\n        self.bushels_per_acre = random.randint(1, 6)\n        harvested_grain = acres_to_plant * self.bushels_per_acre\n        self.grain_stores += harvested_grain\n\n        # Rats\n        rat_infestation = random.randint(0, 1)\n        if rat_infestation == 1:\n            rat_loss = int(self.grain_stores * random.uniform(0.1, 0.3))\n            self.grain_stores -= rat_loss\n            print(f\"Rats ate {rat_loss} bushels of grain!\")\n        else:\n            print(\"No rats this year!\")\n\n        # Starvation and Immigration\n        food_needed = self.population * 20\n        if grain_to_feed < food_needed:\n            starved = (food_needed - grain_to_feed) // 20\n            if starved < 0:\n                starved = 0\n            self.deaths_from_starvation = starved\n            self.population -= self.deaths_from_starvation\n            if self.population <= 0:\n                print(\"Your entire population has died. Game over.\")\n                return False\n            print(f\"{self.deaths_from_starvation} people starved this year.\")\n        else:\n            self.deaths_from_starvation = 0\n            \n        immigrants = int(0.1 * (self.population - self.deaths_from_starvation))  # 10% increase\n        self.immigrants = immigrants\n        self.population += immigrants\n\n        # Plague (chance of plague killing half the population)\n        plague = random.randint(0, 9)  # 1 in 10 chance\n        if plague == 0:\n            plague_deaths = self.population // 2\n            self.population -= plague_deaths\n            print(f\"A terrible plague has struck! {plague_deaths} people died.\")\n\n        self.summarize_year()\n        self.year += 1\n        return True\n\n    def play_game(self):\n        \"\"\"\n        Plays the entire game.\n        \"\"\"\n        print(\"Welcome to Hammurabi!\")\n        while self.year <= 10:\n            if not self.play_year():\n                break\n\n        if self.year > 10:\n            print(\"\\nCongratulations! You have ruled for 10 years.\")\n            print(\"Let's see how well you did:\")\n            print(f\"You ended with {self.population} people.\")\n            print(f\"You ended with {self.acres_owned} acres of land.\")\n            # Add a more detailed evaluation based on factors like population growth, land ownership, etc.\n            land_per_person = self.acres_owned / self.population\n            print(f\"You have {land_per_person:.2f} acres of land per person.\")\n            if land_per_person > 12:\n                print(\"A magnificent performance! Well done, mighty ruler!\")\n            elif land_per_person > 8:\n                print(\"A good performance. You could have done better.\")\n            else:\n                print(\"Your performance was poor. The people will remember your reign with disdain.\")\n\n\nif __name__ == '__main__':\n    game = Hammurabi()\n    game.play_game()\n```",
    "11": "```python\nimport random\n\nclass LightsOut:\n    \"\"\"\n    A class representing the Lights Out game.\n    \"\"\"\n\n    def __init__(self, size=5, board=None):\n        \"\"\"\n        Initializes the Lights Out game.\n\n        Args:\n            size (int): The size of the board (size x size). Default is 5.\n            board (list of lists): An optional initial board state. If None, a random board is generated.\n        \"\"\"\n        self.size = size\n        if board is None:\n            self.board = self.generate_random_board()\n        else:\n            self.board = board\n\n    def generate_random_board(self):\n        \"\"\"\n        Generates a random board for the game.\n\n        Returns:\n            list of lists: A 2D list representing the board, with each cell being either 0 (off) or 1 (on).\n        \"\"\"\n        board = [[random.randint(0, 1) for _ in range(self.size)] for _ in range(self.size)]\n        return board\n\n    def print_board(self):\n        \"\"\"\n        Prints the current state of the board to the console.\n        \"\"\"\n        for row in self.board:\n            print(\" \".join(map(str, row)))\n        print()\n\n    def toggle_cell(self, row, col):\n        \"\"\"\n        Toggles the state of a cell (0 to 1 or 1 to 0).\n\n        Args:\n            row (int): The row index of the cell.\n            col (int): The column index of the cell.\n        \"\"\"\n        if 0 <= row < self.size and 0 <= col < self.size:\n            self.board[row][col] = 1 - self.board[row][col]\n\n    def make_move(self, row, col):\n        \"\"\"\n        Makes a move by toggling the selected cell and its adjacent cells.\n\n        Args:\n            row (int): The row index of the selected cell.\n            col (int): The column index of the selected cell.\n        \"\"\"\n        self.toggle_cell(row, col)\n        self.toggle_cell(row - 1, col)  # Up\n        self.toggle_cell(row + 1, col)  # Down\n        self.toggle_cell(row, col - 1)  # Left\n        self.toggle_cell(row, col + 1)  # Right\n\n    def is_solved(self):\n        \"\"\"\n        Checks if the game is solved (all cells are off).\n\n        Returns:\n            bool: True if the game is solved, False otherwise.\n        \"\"\"\n        for row in self.board:\n            if any(row):  # Check if any cell in the row is on (1)\n                return False\n        return True\n\n    def play(self):\n        \"\"\"\n        Plays the game in a command-line interface.\n        \"\"\"\n        print(\"Welcome to Lights Out!\")\n        self.print_board()\n\n        while not self.is_solved():\n            try:\n                row, col = map(int, input(\"Enter row and column (e.g., 0 0): \").split())\n                if 0 <= row < self.size and 0 <= col < self.size:\n                    self.make_move(row, col)\n                    self.print_board()\n                else:\n                    print(\"Invalid row or column. Try again.\")\n            except ValueError:\n                print(\"Invalid input. Please enter two integers separated by a space.\")\n\n        print(\"Congratulations! You solved the puzzle!\")\n\n\nif __name__ == \"__main__\":\n    game = LightsOut(5)  # You can change the size here (e.g., LightsOut(7))\n    game.play()\n```",
    "12": "```python\nimport time\nimport random\nimport os\n\nclass Pong:\n    \"\"\"\n    A simple Pong game implemented in the command line.\n    \"\"\"\n\n    def __init__(self, width=60, height=20, paddle_length=3, ball_speed_x=1, ball_speed_y=1):\n        \"\"\"\n        Initializes the Pong game.\n\n        Args:\n            width (int): The width of the game board.\n            height (int): The height of the game board.\n            paddle_length (int): The length of the paddles.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.paddle_length = paddle_length\n        self.ball_speed_x = ball_speed_x\n        self.ball_speed_y = ball_speed_y\n\n        self.paddle1_pos = height // 2 - paddle_length // 2\n        self.paddle2_pos = height // 2 - paddle_length // 2\n        self.ball_x = width // 2\n        self.ball_y = height // 2\n        self.ball_dx = self.ball_speed_x * random.choice([-1, 1])  # Ball direction x (+1 or -1)\n        self.ball_dy = self.ball_speed_y * random.choice([-1, 1])  # Ball direction y (+1 or -1)\n\n        self.score1 = 0\n        self.score2 = 0\n        self.game_over = False\n\n    def _clear_screen(self):\n        \"\"\"Clears the console screen.\"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')\n\n    def _draw_board(self):\n        \"\"\"\n        Draws the game board in the console.\n        \"\"\"\n        self._clear_screen()\n        board = []\n        for i in range(self.height):\n            board.append([' '] * self.width)\n\n        # Draw paddles\n        for i in range(self.paddle_length):\n            board[self.paddle1_pos + i][1] = '|'\n            board[self.paddle2_pos + i][self.width - 2] = '|'\n\n        # Draw ball\n        board[self.ball_y][self.ball_x] = 'O'\n\n        # Draw score\n        score_str = f\"Player 1: {self.score1}  Player 2: {self.score2}\"\n        print(score_str.center(self.width))\n\n        # Draw board\n        for row in board:\n            print(''.join(row))\n\n\n    def _update_ball(self):\n        \"\"\"\n        Updates the ball's position.\n        \"\"\"\n        self.ball_x += self.ball_dx\n        self.ball_y += self.ball_dy\n\n        # Bounce off top and bottom walls\n        if self.ball_y <= 0 or self.ball_y >= self.height - 1:\n            self.ball_dy *= -1\n\n        # Bounce off paddles\n        if self.ball_x <= 2 and self.paddle1_pos <= self.ball_y <= self.paddle1_pos + self.paddle_length - 1:\n            self.ball_dx *= -1\n        elif self.ball_x >= self.width - 3 and self.paddle2_pos <= self.ball_y <= self.paddle2_pos + self.paddle_length - 1:\n            self.ball_dx *= -1\n\n        # Score and reset ball position\n        if self.ball_x <= 0:\n            self.score2 += 1\n            self.ball_x = self.width // 2\n            self.ball_y = self.height // 2\n            self.ball_dx = self.ball_speed_x * random.choice([-1, 1])\n            self.ball_dy = self.ball_speed_y * random.choice([-1, 1])\n        elif self.ball_x >= self.width - 1:\n            self.score1 += 1\n            self.ball_x = self.width // 2\n            self.ball_y = self.height // 2\n            self.ball_dx = self.ball_speed_x * random.choice([-1, 1])\n            self.ball_dy = self.ball_speed_y * random.choice([-1, 1])\n\n    def _update_paddles(self, player1_move, player2_move):\n        \"\"\"\n        Updates the paddle positions based on player input.\n\n        Args:\n            player1_move (str): 'up' or 'down' for player 1.\n            player2_move (str): 'up' or 'down' for player 2.\n        \"\"\"\n        if player1_move == 'up' and self.paddle1_pos > 0:\n            self.paddle1_pos -= 1\n        elif player1_move == 'down' and self.paddle1_pos < self.height - self.paddle_length - 1:\n            self.paddle1_pos += 1\n\n        if player2_move == 'up' and self.paddle2_pos > 0:\n            self.paddle2_pos -= 1\n        elif player2_move == 'down' and self.paddle2_pos < self.height - self.paddle_length - 1:\n            self.paddle2_pos += 1\n\n    def play(self):\n        \"\"\"\n        Runs the main game loop.\n        \"\"\"\n        while not self.game_over:\n            self._draw_board()\n\n            # Get player input\n            player1_move = input(\"Player 1 (w/s): \").lower()\n            player2_move = input(\"Player 2 (up/down): \").lower()\n\n            # Validate player input\n            if player1_move not in ('w', 's', ''):\n                player1_move = ''  # Ignore invalid input\n            if player2_move not in ('up', 'down', ''):\n                player2_move = ''  # Ignore invalid input\n\n            # Convert player 1 input to 'up' and 'down'\n            if player1_move == 'w':\n                player1_move = 'up'\n            elif player1_move == 's':\n                player1_move = 'down'\n\n            self._update_paddles(player1_move, player2_move)\n            self._update_ball()\n\n            # Check for game over (optional)\n            if self.score1 >= 10 or self.score2 >= 10:\n                self.game_over = True\n\n            time.sleep(0.05)  # Control game speed\n\n        self._draw_board()\n        print(\"Game Over!\")\n        if self.score1 > self.score2:\n            print(\"Player 1 wins!\")\n        else:\n            print(\"Player 2 wins!\")\n\n\nif __name__ == '__main__':\n    game = Pong()\n    game.play()\n```",
    "13": "```python\nimport random\nimport os\nimport time\n\nclass Tetris:\n    \"\"\"\n    A command-line implementation of the Tetris game.\n    \"\"\"\n\n    WIDTH = 10\n    HEIGHT = 20\n    SHAPES = [\n        [[1, 1, 1, 1]],  # I\n        [[1, 1], [1, 1]],  # O\n        [[0, 1, 1], [1, 1, 0]],  # S\n        [[1, 1, 0], [0, 1, 1]],  # Z\n        [[1, 1, 1], [0, 0, 1]],  # J\n        [[1, 1, 1], [1, 0, 0]],  # L\n        [[1, 1, 1], [0, 1, 0]]  # T\n    ]\n    SHAPE_COLORS = ['cyan', 'yellow', 'green', 'red', 'blue', 'orange', 'purple']\n\n    def __init__(self):\n        self.board = [[' ' for _ in range(self.WIDTH)] for _ in range(self.HEIGHT)]\n        self.current_piece = None\n        self.current_piece_x = 0\n        self.current_piece_y = 0\n        self.current_piece_shape = None\n        self.current_piece_color = None\n        self.game_over = False\n        self.score = 0\n        self.level = 1\n        self.lines_cleared = 0\n        self.delay = 0.5  # Initial delay between piece drops\n        self.next_piece = self.new_piece()  # Generate the next piece\n\n    def new_piece(self):\n        \"\"\"\n        Generates a new random piece.\n        \"\"\"\n        shape_index = random.randint(0, len(self.SHAPES) - 1)\n        shape = self.SHAPES[shape_index]\n        color = self.SHAPE_COLORS[shape_index]\n        return shape, color\n\n    def spawn_piece(self):\n        \"\"\"\n        Spawns a new piece at the top of the board.\n        \"\"\"\n        self.current_piece_shape, self.current_piece_color = self.next_piece\n        self.next_piece = self.new_piece()  # Generate the next piece\n        self.current_piece = self.current_piece_shape  # Assign shape\n        self.current_piece_x = self.WIDTH // 2 - len(self.current_piece[0]) // 2\n        self.current_piece_y = 0\n        if self.check_collision(self.current_piece, self.current_piece_x, self.current_piece_y):\n            self.game_over = True\n            return False\n        return True\n\n    def rotate_piece(self):\n        \"\"\"\n        Rotates the current piece clockwise.\n        \"\"\"\n        rotated_piece = list(zip(*self.current_piece[::-1]))\n        if not self.check_collision(rotated_piece, self.current_piece_x, self.current_piece_y):\n            self.current_piece = rotated_piece\n\n    def move_piece(self, dx):\n        \"\"\"\n        Moves the current piece horizontally.\n        \"\"\"\n        new_x = self.current_piece_x + dx\n        if not self.check_collision(self.current_piece, new_x, self.current_piece_y):\n            self.current_piece_x = new_x\n\n    def drop_piece(self):\n        \"\"\"\n        Moves the current piece down one row.\n        \"\"\"\n        new_y = self.current_piece_y + 1\n        if not self.check_collision(self.current_piece, self.current_piece_x, new_y):\n            self.current_piece_y = new_y\n            return True\n        else:\n            self.lock_piece()\n            return False\n\n    def check_collision(self, piece, x, y):\n        \"\"\"\n        Checks if the given piece collides with the board or the boundaries.\n        \"\"\"\n        for row_index, row in enumerate(piece):\n            for col_index, cell in enumerate(row):\n                if cell:\n                    board_x = x + col_index\n                    board_y = y + row_index\n                    if board_x < 0 or board_x >= self.WIDTH or board_y >= self.HEIGHT or (board_y >= 0 and self.board[board_y][board_x] != ' '):\n                        return True\n        return False\n\n    def lock_piece(self):\n        \"\"\"\n        Locks the current piece on the board.\n        \"\"\"\n        for row_index, row in enumerate(self.current_piece):\n            for col_index, cell in enumerate(row):\n                if cell:\n                    self.board[self.current_piece_y + row_index][self.current_piece_x + col_index] = self.current_piece_color[0].upper()\n\n        self.clear_lines()\n        if not self.spawn_piece():\n            self.game_over = True\n\n    def clear_lines(self):\n        \"\"\"\n        Clears any completed lines on the board.\n        \"\"\"\n        lines_to_clear = []\n        for row_index, row in enumerate(self.board):\n            if all(cell != ' ' for cell in row):\n                lines_to_clear.append(row_index)\n\n        for row_index in lines_to_clear:\n            del self.board[row_index]\n            self.board.insert(0, [' ' for _ in range(self.WIDTH)])\n\n        num_lines_cleared = len(lines_to_clear)\n        self.lines_cleared += num_lines_cleared\n        self.score += self.calculate_score(num_lines_cleared)\n        self.update_level()\n\n    def calculate_score(self, num_lines):\n        \"\"\"\n        Calculates the score based on the number of lines cleared.\n        \"\"\"\n        if num_lines == 1:\n            return 40 * self.level\n        elif num_lines == 2:\n            return 100 * self.level\n        elif num_lines == 3:\n            return 300 * self.level\n        elif num_lines == 4:\n            return 1200 * self.level\n        else:\n            return 0\n\n    def update_level(self):\n        \"\"\"\n        Updates the game level based on the number of lines cleared.\n        \"\"\"\n        self.level = self.lines_cleared // 10 + 1\n        self.delay = max(0.1, 0.5 - (self.level - 1) * 0.05)  # Decrease delay\n\n    def print_board(self):\n        \"\"\"\n        Prints the game board to the console.\n        \"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the screen\n        print(\"Tetris\")\n        print(f\"Score: {self.score}  Level: {self.level}  Lines: {self.lines_cleared}\")\n        print(\"Next Piece:\")\n        self.print_piece(self.next_piece[0], self.next_piece[1])\n\n        # Create a temporary board with the current piece\n        temp_board = [row[:] for row in self.board]\n        for row_index, row in enumerate(self.current_piece):\n            for col_index, cell in enumerate(row):\n                if cell:\n                    try:\n                        temp_board[self.current_piece_y + row_index][self.current_piece_x + col_index] = self.current_piece_color[0].upper()\n                    except IndexError:\n                        pass\n\n        # Print the board with borders\n        print(\"-\" * (self.WIDTH + 2))\n        for row in temp_board:\n            print(\"|\" + \"\".join(row) + \"|\")\n        print(\"-\" * (self.WIDTH + 2))\n\n    def print_piece(self, piece, color):\n        \"\"\"\n        Prints a piece to the console.\n        \"\"\"\n        for row in piece:\n            print(\"\".join([color[0].upper() if cell else ' ' for cell in row]))\n\n    def run(self):\n        \"\"\"\n        Runs the main game loop.\n        \"\"\"\n        self.spawn_piece()\n        while not self.game_over:\n            self.print_board()\n            start_time = time.time()\n            command = input(\"Enter command (a=left, d=right, s=down, w=rotate, q=quit): \").lower()\n            elapsed_time = time.time() - start_time\n\n            if command == 'a':\n                self.move_piece(-1)\n            elif command == 'd':\n                self.move_piece(1)\n            elif command == 's':\n                self.drop_piece()\n            elif command == 'w':\n                self.rotate_piece()\n            elif command == 'q':\n                self.game_over = True\n                break\n\n            if not self.game_over:\n                time_to_sleep = max(0, self.delay - elapsed_time)\n                time.sleep(time_to_sleep)\n\n                if not self.drop_piece():\n                    self.lock_piece()\n\n        print(\"Game Over!\")\n        print(f\"Final Score: {self.score}\")\n\n\nif __name__ == '__main__':\n    game = Tetris()\n    game.run()\n```",
    "14": "```python\nimport math\nimport random\nimport sys\nimport time\n\n\nclass AsteroidGame:\n    \"\"\"\n    A command-line Asteroids game.\n    \"\"\"\n\n    def __init__(self, width=80, height=20, asteroid_count=5, max_speed=1.0, turn_speed=0.1):\n        \"\"\"\n        Initializes the game.\n\n        Args:\n            width (int): The width of the game board.\n            height (int): The height of the game board.\n            asteroid_count (int): The initial number of asteroids.\n            max_speed (float): The maximum speed of the spaceship and asteroids.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.asteroid_count = asteroid_count\n        self.max_speed = max_speed\n        self.turn_speed = turn_speed\n        self.spaceship = Spaceship(self.width // 2, self.height // 2, 0.0, max_speed=self.max_speed)\n        self.asteroids = []\n        self.bullets = []\n        self.score = 0\n        self.game_over = False\n\n        for _ in range(self.asteroid_count):\n            self.asteroids.append(self._create_asteroid())\n\n    def _create_asteroid(self):\n        \"\"\"\n        Creates a new asteroid at a random location, avoiding the spaceship's initial position.\n\n        Returns:\n            Asteroid: The newly created asteroid.\n        \"\"\"\n        while True:\n            x = random.randint(0, self.width - 1)\n            y = random.randint(0, self.height - 1)\n            if abs(x - self.spaceship.x) > self.width // 4 or abs(y - self.spaceship.y) > self.height // 4:\n                break\n        angle = random.uniform(0, 2 * math.pi)\n        return Asteroid(x, y, angle, size=3, max_speed=self.max_speed)\n\n    def run(self):\n        \"\"\"\n        Runs the main game loop.\n        \"\"\"\n        while not self.game_over:\n            self.print_board()\n            self.process_input()\n            self.update_game_state()\n            time.sleep(0.1)  # Adjust for game speed\n        self.print_game_over()\n\n    def print_board(self):\n        \"\"\"\n        Prints the game board to the console.\n        \"\"\"\n        board = [[' ' for _ in range(self.width)] for _ in range(self.height)]\n\n        # Draw spaceship\n        spaceship_x = int(round(self.spaceship.x)) % self.width\n        spaceship_y = int(round(self.spaceship.y)) % self.height\n\n        if 0 <= spaceship_x < self.width and 0 <= spaceship_y < self.height:\n            board[spaceship_y][spaceship_x] = '^'\n\n        # Draw asteroids\n        for asteroid in self.asteroids:\n            asteroid_x = int(round(asteroid.x)) % self.width\n            asteroid_y = int(round(asteroid.y)) % self.height\n            if 0 <= asteroid_x < self.width and 0 <= asteroid_y < self.height:\n                board[asteroid_y][asteroid_x] = 'O'\n\n        # Draw bullets\n        for bullet in self.bullets:\n            bullet_x = int(round(bullet.x)) % self.width\n            bullet_y = int(round(bullet.y)) % self.height\n            if 0 <= bullet_x < self.width and 0 <= bullet_y < self.height:\n                board[bullet_y][bullet_x] = '.'\n\n        # Print the board\n        print(\"\\033c\", end=\"\")  # Clear the screen (works in most terminals)\n        for row in board:\n            print(\"\".join(row))\n        print(f\"Score: {self.score}\")\n\n    def process_input(self):\n        \"\"\"\n        Processes user input to control the spaceship.\n        \"\"\"\n        action = input(\"Action (a=left, d=right, w=forward, s=shoot, q=quit): \").lower()\n        if action == 'a':\n            self.spaceship.turn_left(self.turn_speed)\n        elif action == 'd':\n            self.spaceship.turn_right(self.turn_speed)\n        elif action == 'w':\n            self.spaceship.accelerate()\n        elif action == 's':\n            self.bullets.append(self.spaceship.shoot())\n        elif action == 'q':\n            self.game_over = True\n\n    def update_game_state(self):\n        \"\"\"\n        Updates the positions of all game objects, checks for collisions, and removes destroyed objects.\n        \"\"\"\n        # Update spaceship position\n        self.spaceship.update(self.width, self.height)\n\n        # Update asteroid positions\n        for asteroid in self.asteroids:\n            asteroid.update(self.width, self.height)\n\n        # Update bullet positions\n        for bullet in self.bullets:\n            bullet.update(self.width, self.height)\n\n        # Check for collisions between bullets and asteroids\n        bullets_to_remove = []\n        asteroids_to_remove = []\n        for bullet in self.bullets:\n            for asteroid in self.asteroids:\n                if self._check_collision(bullet, asteroid):\n                    bullets_to_remove.append(bullet)\n                    asteroids_to_remove.append(asteroid)\n                    self.score += 10\n                    break  # Only one asteroid can be hit per bullet\n        for bullet in bullets_to_remove:\n            if bullet in self.bullets:\n                self.bullets.remove(bullet)\n        for asteroid in asteroids_to_remove:\n            if asteroid in self.asteroids:\n                self.asteroids.remove(asteroid)\n\n        # Check for collisions between spaceship and asteroids\n        for asteroid in self.asteroids:\n            if self._check_collision(self.spaceship, asteroid):\n                self.game_over = True\n                break\n\n        # Remove bullets that are out of bounds\n        self.bullets = [\n            bullet for bullet in self.bullets if 0 <= bullet.x < self.width and 0 <= bullet.y < self.height\n        ]\n\n        # Spawn new asteroids if necessary\n        while len(self.asteroids) < self.asteroid_count:\n            self.asteroids.append(self._create_asteroid())\n\n    def _check_collision(self, obj1, obj2):\n        \"\"\"\n        Checks for collision between two game objects.  Simple distance check.\n\n        Args:\n            obj1: The first game object (must have x and y attributes).\n            obj2: The second game object (must have x and y attributes).\n\n        Returns:\n            bool: True if the objects are colliding, False otherwise.\n        \"\"\"\n        distance = math.sqrt((obj1.x - obj2.x) ** 2 + (obj1.y - obj2.y) ** 2)\n        return distance < 2  # Simple collision detection radius\n\n    def print_game_over(self):\n        \"\"\"\n        Prints the game over message and final score.\n        \"\"\"\n        print(\"Game Over!\")\n        print(f\"Final Score: {self.score}\")\n\n\nclass GameObject:\n    \"\"\"\n    Base class for game objects (spaceship, asteroids, bullets).\n    \"\"\"\n\n    def __init__(self, x, y, angle, speed=0.0, max_speed=1.0):\n        \"\"\"\n        Initializes a game object.\n\n        Args:\n            x (float): The x-coordinate of the object.\n            y (float): The y-coordinate of the object.\n            angle (float): The angle of the object in radians.\n            speed (float): The speed of the object.\n            max_speed (float): The maximum speed of the object.\n        \"\"\"\n        self.x = x\n        self.y = y\n        self.angle = angle\n        self.speed = speed\n        self.max_speed = max_speed\n\n    def update(self, width, height):\n        \"\"\"\n        Updates the position of the object.\n\n        Args:\n            width (int): The width of the game board.\n            height (int): The height of the game board.\n        \"\"\"\n        self.x += self.speed * math.cos(self.angle)\n        self.y += self.speed * math.sin(self.angle)\n\n        # Wrap around the edges of the screen\n        self.x %= width\n        self.y %= height\n\n\nclass Spaceship(GameObject):\n    \"\"\"\n    Represents the player's spaceship.\n    \"\"\"\n\n    def __init__(self, x, y, angle, max_speed=1.0):\n        \"\"\"\n        Initializes the spaceship.\n\n        Args:\n            x (float): The x-coordinate of the spaceship.\n            y (float): The y-coordinate of the spaceship.\n            angle (float): The angle of the spaceship in radians.\n            max_speed (float): The maximum speed of the spaceship.\n        \"\"\"\n        super().__init__(x, y, angle, max_speed=max_speed)\n        self.acceleration = 0.05\n        self.bullet_speed = self.max_speed * 2\n\n    def accelerate(self):\n        \"\"\"\n        Increases the spaceship's speed.\n        \"\"\"\n        self.speed = min(self.speed + self.acceleration, self.max_speed)\n\n    def turn_left(self, turn_speed):\n        \"\"\"\n        Turns the spaceship left.\n\n        Args:\n            turn_speed (float): The amount to turn the spaceship in radians.\n        \"\"\"\n        self.angle -= turn_speed\n\n    def turn_right(self, turn_speed):\n        \"\"\"\n        Turns the spaceship right.\n\n        Args:\n            turn_speed (float): The amount to turn the spaceship in radians.\n        \"\"\"\n        self.angle += turn_speed\n\n    def shoot(self):\n        \"\"\"\n        Fires a bullet from the spaceship.\n\n        Returns:\n            Bullet: The newly created bullet.\n        \"\"\"\n        return Bullet(self.x, self.y, self.angle, speed=self.bullet_speed)\n\n\nclass Asteroid(GameObject):\n    \"\"\"\n    Represents an asteroid.\n    \"\"\"\n\n    def __init__(self, x, y, angle, size=3, max_speed=1.0):\n        \"\"\"\n        Initializes an asteroid.\n\n        Args:\n            x (float): The x-coordinate of the asteroid.\n            y (float): The y-coordinate of the asteroid.\n            angle (float): The angle of the asteroid in radians.\n            size (int): The size of the asteroid (not currently used, but could be used for splitting).\n            max_speed (float): The maximum speed of the asteroid.\n        \"\"\"\n        super().__init__(x, y, angle, speed=random.uniform(0.1, max_speed), max_speed=max_speed)\n        self.size = size\n\n\nclass Bullet(GameObject):\n    \"\"\"\n    Represents a bullet fired by the spaceship.\n    \"\"\"\n\n    def __init__(self, x, y, angle, speed):\n        \"\"\"\n        Initializes a bullet.\n\n        Args:\n            x (float): The x-coordinate of the bullet.\n            y (float): The y-coordinate of the bullet.\n            angle (float): The angle of the bullet in radians.\n            speed (float): The speed of the bullet.\n        \"\"\"\n        super().__init__(x, y, angle, speed=speed)\n\n\nif __name__ == \"__main__\":\n    game = AsteroidGame()\n    game.run()\n```",
    "15": "```python\nimport random\nimport time\n\nclass Boggle:\n    \"\"\"\n    A class to represent a Boggle game.\n    \"\"\"\n\n    def __init__(self, size=4, time_limit=180):\n        \"\"\"\n        Initializes a Boggle game.\n\n        Args:\n            size (int): The size of the Boggle board (default: 4).\n            time_limit (int): The time limit for the game in seconds (default: 180).\n        \"\"\"\n\n        self.size = size\n        self.time_limit = time_limit\n        self.board = self.generate_board()\n        self.dictionary = self.load_dictionary(\"words.txt\")  # Ensure words.txt exists in the same directory\n        self.words_found = set()\n        self.start_time = None\n        self.game_over = False\n\n    def generate_board(self):\n        \"\"\"\n        Generates a random Boggle board.\n\n        Returns:\n            list: A list of lists representing the Boggle board.\n        \"\"\"\n\n        dice = [\n            \"RIFOBX\", \"IFEHEE\", \"ENSIEU\", \"LUPETD\", \"AYOBKR\",\n            \"TDOENS\", \"IMTOCC\", \"GNWHGE\", \"LRYTTK\", \"EOAHIS\",\n            \"XLDERI\", \"SAPNZI\", \"UOTOWN\", \"HSAOFW\", \"MTOICU\", \"ETNIAS\"\n        ]\n        random.shuffle(dice)\n        board = []\n        for i in range(self.size):\n            row = []\n            for j in range(self.size):\n                row.append(random.choice(dice[i * self.size + j]))\n            board.append(row)\n        return board\n\n    def load_dictionary(self, filename=\"words.txt\"):\n        \"\"\"\n        Loads a dictionary of valid words from a file.\n\n        Args:\n            filename (str): The name of the file containing the dictionary (default: \"words.txt\").\n\n        Returns:\n            set: A set of valid words.\n        \"\"\"\n        try:\n            with open(filename, \"r\") as f:\n                words = set(word.strip().upper() for word in f)\n            return words\n        except FileNotFoundError:\n            print(f\"Error: The dictionary file '{filename}' was not found.\")\n            print(\"Please ensure 'words.txt' exists in the same directory as the script.\")\n            exit()\n\n\n    def print_board(self):\n        \"\"\"\n        Prints the Boggle board to the console.\n        \"\"\"\n\n        for row in self.board:\n            print(\" \".join(row))\n\n    def is_valid_word(self, word):\n        \"\"\"\n        Checks if a word is valid according to Boggle rules.\n\n        Args:\n            word (str): The word to check.\n\n        Returns:\n            bool: True if the word is valid, False otherwise.\n        \"\"\"\n\n        word = word.upper()\n        if len(word) < 3:\n            return False\n        if word in self.words_found:\n            return False\n        if word not in self.dictionary:\n            return False\n        return True\n\n    def find_word_on_board(self, word):\n        \"\"\"\n        Checks if a word can be found on the Boggle board.\n\n        Args:\n            word (str): The word to search for.\n\n        Returns:\n            bool: True if the word can be found, False otherwise.\n        \"\"\"\n\n        word = word.upper()\n\n        def search(row, col, index, path):\n            if index == len(word):\n                return True\n\n            if row < 0 or row >= self.size or col < 0 or col >= self.size:\n                return False\n\n            if (row, col) in path:\n                return False\n\n            if self.board[row][col] != word[index]:\n                return False\n\n            path.add((row, col))\n            found = (\n                search(row - 1, col - 1, index + 1, path.copy()) or\n                search(row - 1, col, index + 1, path.copy()) or\n                search(row - 1, col + 1, index + 1, path.copy()) or\n                search(row, col - 1, index + 1, path.copy()) or\n                search(row, col + 1, index + 1, path.copy()) or\n                search(row + 1, col - 1, index + 1, path.copy()) or\n                search(row + 1, col, index + 1, path.copy()) or\n                search(row + 1, col + 1, index + 1, path.copy())\n            )\n            path.remove((row, col)) # Backtrack\n            return found\n\n        for row in range(self.size):\n            for col in range(self.size):\n                if self.board[row][col] == word[0]:\n                    if search(row, col, 0, set()):\n                        return True\n        return False\n\n    def play_turn(self):\n        \"\"\"\n        Plays a single turn of the game.\n        \"\"\"\n\n        elapsed_time = time.time() - self.start_time\n        remaining_time = self.time_limit - elapsed_time\n\n        if remaining_time <= 0:\n            print(\"Time's up!\")\n            self.game_over = True\n            return\n\n        print(f\"Time remaining: {int(remaining_time)} seconds\")\n        word = input(\"Enter a word: \").strip()\n\n        if not word:\n            return\n\n        if self.is_valid_word(word) and self.find_word_on_board(word):\n            self.words_found.add(word.upper())\n            print(\"Valid word!\")\n        else:\n            print(\"Invalid word.\")\n\n    def calculate_score(self):\n        \"\"\"\n        Calculates the player's score based on the words found.\n\n        Returns:\n            int: The player's score.\n        \"\"\"\n\n        score = 0\n        for word in self.words_found:\n            length = len(word)\n            if length == 3 or length == 4:\n                score += 1\n            elif length == 5:\n                score += 2\n            elif length == 6:\n                score += 3\n            elif length == 7:\n                score += 5\n            else:\n                score += 11\n        return score\n\n    def play_game(self):\n        \"\"\"\n        Plays the Boggle game.\n        \"\"\"\n\n        print(\"Welcome to Boggle!\")\n        self.print_board()\n        self.start_time = time.time()\n\n        while not self.game_over:\n            self.play_turn()\n            if time.time() - self.start_time >= self.time_limit:\n                self.game_over = True\n\n        score = self.calculate_score()\n        print(\"Game over!\")\n        print(f\"Your score: {score}\")\n        print(\"Words found:\")\n        for word in sorted(self.words_found):\n            print(word)\n\n\nif __name__ == \"__main__\":\n    # Create a dummy words.txt file for testing\n    with open(\"words.txt\", \"w\") as f:\n        f.write(\"CAT\\n\")\n        f.write(\"DOG\\n\")\n        f.write(\"TEA\\n\")\n        f.write(\"EAT\\n\")\n        f.write(\"RAIN\\n\")\n        f.write(\"TRAIN\\n\")\n        f.write(\"ELEPHANT\\n\")\n        f.write(\"COMPUTER\\n\")\n\n\n    game = Boggle()\n    game.play_game()\n```",
    "16": "```python\nimport random\nimport os\n\nclass PacManGame:\n    def __init__(self, width=10, height=10, num_ghosts=1, num_food=10):\n        self.width = width\n        self.height = height\n        self.num_ghosts = num_ghosts\n        self.num_food = num_food\n        self.board = [[' ' for _ in range(width)] for _ in range(height)]\n        self.pacman_x = width // 2\n        self.pacman_y = height // 2\n        self.ghosts = []\n        self.food_positions = set()\n        self.score = 0\n        self.game_over = False\n        self.won = False\n\n        self.initialize_game()\n\n    def initialize_game(self):\n        self.board[self.pacman_y][self.pacman_x] = 'P'\n\n        # Place ghosts\n        for _ in range(self.num_ghosts):\n            while True:\n                x = random.randint(0, self.width - 1)\n                y = random.randint(0, self.height - 1)\n                if self.board[y][x] == ' ':\n                    self.ghosts.append((x, y))\n                    self.board[y][x] = 'G'\n                    break\n\n        # Place food\n        while len(self.food_positions) < self.num_food:\n            x = random.randint(0, self.width - 1)\n            y = random.randint(0, self.height - 1)\n            if self.board[y][x] == ' ':\n                self.food_positions.add((x, y))\n                self.board[y][x] = '.'\n\n\n    def print_board(self):\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the screen\n        print(\"-\" * (self.width + 2))\n        for row in self.board:\n            print(\"|\" + \"\".join(row) + \"|\")\n        print(\"-\" * (self.width + 2))\n        print(f\"Score: {self.score}\")\n\n\n    def move_pacman(self, direction):\n        new_x, new_y = self.pacman_x, self.pacman_y\n\n        if direction == 'w':  # Up\n            new_y -= 1\n        elif direction == 's':  # Down\n            new_y += 1\n        elif direction == 'a':  # Left\n            new_x -= 1\n        elif direction == 'd':  # Right\n            new_x += 1\n        else:\n            print(\"Invalid direction. Use w, a, s, d.\")\n            return\n\n        if 0 <= new_x < self.width and 0 <= new_y < self.height:\n            # Clear Pac-Man's previous position\n            self.board[self.pacman_y][self.pacman_x] = ' '\n\n            self.pacman_x, self.pacman_y = new_x, new_y\n\n            # Check for food\n            if (self.pacman_x, self.pacman_y) in self.food_positions:\n                self.score += 1\n                self.food_positions.remove((self.pacman_x, self.pacman_y))\n\n            # Check for ghost collision\n            if self.board[self.pacman_y][self.pacman_x] == 'G':\n                self.game_over = True\n                return\n\n            # Update Pac-Man's position on the board\n            self.board[self.pacman_y][self.pacman_x] = 'P'\n        else:\n            print(\"Invalid move: Moving out of bounds.\")\n\n\n    def move_ghosts(self):\n        for i, (x, y) in enumerate(self.ghosts):\n            self.board[y][x] = ' '  # Clear the ghost's previous position\n            possible_moves = []\n            if x > 0 and self.board[y][x-1] != 'G':\n                possible_moves.append((x-1, y))\n            if x < self.width - 1 and self.board[y][x+1] != 'G':\n                possible_moves.append((x+1, y))\n            if y > 0 and self.board[y-1][x] != 'G':\n                possible_moves.append((x, y-1))\n            if y < self.height - 1 and self.board[y+1][x] != 'G':\n                possible_moves.append((x, y+1))\n           \n            if possible_moves:\n                new_x, new_y = random.choice(possible_moves)\n\n\n                #Check if the new position is food\n                is_food = (new_x, new_y) in self.food_positions\n                if is_food:\n                    self.food_positions.remove((new_x, new_y))\n                    self.food_positions.add((x,y)) #add back to old location\n\n                self.ghosts[i] = (new_x, new_y)\n                if self.board[new_y][new_x] == 'P':\n                    self.game_over = True\n                    return\n                self.board[new_y][new_x] = 'G'\n            else:\n                self.board[y][x] = 'G' #Ghost stays in place\n\n    def check_win_condition(self):\n        if not self.food_positions:\n            self.won = True\n            self.game_over = True\n\n\n\n    def play(self):\n        while not self.game_over:\n            self.print_board()\n            direction = input(\"Enter direction (w/a/s/d): \").lower()\n            self.move_pacman(direction)\n            if self.game_over:\n                break\n            self.move_ghosts()\n            self.check_win_condition()\n\n        self.print_board()\n        if self.won:\n            print(\"Congratulations! You won!\")\n        else:\n            print(\"Game Over! You were caught by a ghost.\")\n\n\nif __name__ == \"__main__\":\n    game = PacManGame(width=15, height=10, num_ghosts=2, num_food=15)\n    game.play()\n```",
    "17": "```python\nimport random\nimport time\nimport os\n\nclass DinosaurRunner:\n    \"\"\"\n    A command-line Dinosaur Runner game.\n    \"\"\"\n\n    def __init__(self, width=60, initial_speed=1, speed_increment=0.2, obstacle_density=0.1):\n        \"\"\"\n        Initializes the game.\n\n        Args:\n            width (int): The width of the game screen.\n            initial_speed (float): The initial speed of the game.\n            speed_increment (float): The amount the speed increases each round.\n            obstacle_density (float): The probability of an obstacle appearing in a column.\n        \"\"\"\n        self.width = width\n        self.dinosaur_position = 5  # Fixed dinosaur position\n        self.obstacles = []\n        self.score = 0\n        self.speed = initial_speed\n        self.initial_speed = initial_speed\n        self.speed_increment = speed_increment\n        self.obstacle_density = obstacle_density\n        self.game_over = False\n\n    def reset(self):\n        \"\"\"Resets the game to the initial state.\"\"\"\n        self.obstacles = []\n        self.score = 0\n        self.speed = self.initial_speed\n        self.game_over = False\n\n    def generate_obstacle(self):\n        \"\"\"Generates a new obstacle at the right edge of the screen.\"\"\"\n        if random.random() < self.obstacle_density:\n            self.obstacles.append(self.width - 1)  # Obstacle starts at the right edge\n\n    def move_obstacles(self):\n        \"\"\"Moves existing obstacles one step to the left.\"\"\"\n        self.obstacles = [obstacle - 1 for obstacle in self.obstacles if obstacle > 0]\n\n    def check_collision(self):\n        \"\"\"Checks if the dinosaur has collided with an obstacle.\"\"\"\n        for obstacle in self.obstacles:\n            if obstacle == self.dinosaur_position:\n                return True\n        return False\n\n    def update_game(self):\n        \"\"\"Updates the game state.\"\"\"\n        self.generate_obstacle()\n        self.move_obstacles()\n        if self.check_collision():\n            self.game_over = True\n        else:\n            self.score += 1\n            self.speed += self.speed_increment\n\n    def render(self):\n        \"\"\"Renders the game screen.\"\"\"\n        screen = [' '] * self.width\n        screen[self.dinosaur_position] = 'D'  # Dinosaur\n\n        for obstacle in self.obstacles:\n            screen[obstacle] = '#'  # Obstacle\n\n        print(''.join(screen))\n        print(f\"Score: {self.score}\")\n\n    def play(self):\n        \"\"\"Plays the game.\"\"\"\n        while not self.game_over:\n            os.system('cls' if os.name == 'nt' else 'clear')  # Clear the screen\n            self.render()\n            self.update_game()\n            time.sleep(0.1 / self.speed)\n\n        print(\"Game Over!\")\n        print(f\"Final Score: {self.score}\")\n\ndef main():\n    \"\"\"Main function to start the game.\"\"\"\n    game = DinosaurRunner()\n    while True:\n        game.play()\n        play_again = input(\"Play again? (y/n): \")\n        if play_again.lower() != 'y':\n            break\n        game.reset()\n\nif __name__ == \"__main__\":\n    main()\n```"
}