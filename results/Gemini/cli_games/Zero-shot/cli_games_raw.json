{
    "0": "```python\nclass TicTacToe:\n    def __init__(self):\n        self.board = [' ' for _ in range(9)]  # Represents the 3x3 board as a list\n        self.current_player = 'X'  # Start with player X\n        self.winner = None\n        self.game_over = False\n\n    def print_board(self):\n        \"\"\"Prints the current state of the board to the console.\"\"\"\n        print(\"-------------\")\n        for i in range(3):\n            print(f\"| {self.board[i*3]} | {self.board[i*3 + 1]} | {self.board[i*3 + 2]} |\")\n            print(\"-------------\")\n\n    def is_valid_move(self, position):\n        \"\"\"Checks if the given position is a valid move (within range and empty).\"\"\"\n        return 0 <= position < 9 and self.board[position] == ' '\n\n    def make_move(self, position):\n        \"\"\"Places the current player's mark on the board at the given position.\"\"\"\n        if self.is_valid_move(position):\n            self.board[position] = self.current_player\n            self.check_winner()\n            self.switch_player()\n            return True\n        else:\n            return False\n\n    def check_winner(self):\n        \"\"\"Checks if there is a winner after the last move.\"\"\"\n        winning_combinations = [\n            [0, 1, 2], [3, 4, 5], [6, 7, 8],  # Rows\n            [0, 3, 6], [1, 4, 7], [2, 5, 8],  # Columns\n            [0, 4, 8], [2, 4, 6]               # Diagonals\n        ]\n\n        for combo in winning_combinations:\n            if self.board[combo[0]] == self.board[combo[1]] == self.board[combo[2]] != ' ':\n                self.winner = self.current_player\n                self.game_over = True\n                return\n\n        if ' ' not in self.board:  # Check for a tie\n            self.game_over = True\n            self.winner = None  # No winner, it's a tie\n\n    def switch_player(self):\n        \"\"\"Switches the current player to the other player.\"\"\"\n        self.current_player = 'O' if self.current_player == 'X' else 'X'\n\n    def play_game(self):\n        \"\"\"Main game loop.\"\"\"\n        print(\"Welcome to Tic-Tac-Toe!\")\n        self.print_board()\n\n        while not self.game_over:\n            try:\n                position = int(input(f\"Player {self.current_player}, enter your move (0-8): \"))\n                if self.make_move(position):\n                    self.print_board()\n                else:\n                    print(\"Invalid move. Try again.\")\n            except ValueError:\n                print(\"Invalid input. Please enter a number between 0 and 8.\")\n\n        if self.winner:\n            print(f\"Player {self.winner} wins!\")\n        else:\n            print(\"It's a tie!\")\n\n\nif __name__ == \"__main__\":\n    game = TicTacToe()\n    game.play_game()\n```",
    "1": "```python\nimport random\n\nclass Hangman:\n    def __init__(self, word_list, max_attempts=6):\n        self.word_list = word_list\n        self.word_to_guess = random.choice(self.word_list).upper()\n        self.guessed_letters = set()\n        self.attempts_left = max_attempts\n        self.word_display = ['_' for _ in self.word_to_guess]\n        self.game_over = False\n        self.won = False\n\n    def display(self):\n        print(\"\\n\" + \" \".join(self.word_display))\n        print(f\"Attempts left: {self.attempts_left}\")\n        print(f\"Guessed letters: {', '.join(sorted(self.guessed_letters))}\")\n\n    def guess_letter(self, letter):\n        letter = letter.upper()\n\n        if len(letter) != 1 or not letter.isalpha():\n            print(\"Invalid input. Please enter a single letter.\")\n            return\n\n        if letter in self.guessed_letters:\n            print(\"You already guessed that letter.\")\n            return\n\n        self.guessed_letters.add(letter)\n\n        if letter in self.word_to_guess:\n            for i, char in enumerate(self.word_to_guess):\n                if char == letter:\n                    self.word_display[i] = letter\n            if ''.join(self.word_display) == self.word_to_guess:\n                self.won = True\n                self.game_over = True\n        else:\n            self.attempts_left -= 1\n            if self.attempts_left == 0:\n                self.game_over = True\n\n    def play(self):\n        print(\"Welcome to Hangman!\")\n        while not self.game_over:\n            self.display()\n            guess = input(\"Guess a letter: \")\n            self.guess_letter(guess)\n\n        if self.won:\n            print(f\"Congratulations! You guessed the word: {self.word_to_guess}\")\n        else:\n            print(f\"You ran out of attempts. The word was: {self.word_to_guess}\")\n\nif __name__ == \"__main__\":\n    word_list = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\", \"fig\", \"grape\", \"honeydew\"]\n    game = Hangman(word_list)\n    game.play()\n```\n",
    "2": "```python\nimport random\n\nclass RockPaperScissors:\n    \"\"\"\n    A class to represent the Rock-Paper-Scissors game.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the game with possible choices and scores.\n        \"\"\"\n        self.choices = [\"rock\", \"paper\", \"scissors\"]\n        self.player_score = 0\n        self.computer_score = 0\n\n    def get_computer_choice(self):\n        \"\"\"\n        Generates a random choice for the computer.\n\n        Returns:\n            str: The computer's choice (rock, paper, or scissors).\n        \"\"\"\n        return random.choice(self.choices)\n\n    def get_player_choice(self):\n        \"\"\"\n        Prompts the player to enter their choice and validates the input.\n\n        Returns:\n            str: The player's choice (rock, paper, or scissors), or None if the input is invalid.\n        \"\"\"\n        while True:\n            choice = input(\"Enter your choice (rock, paper, or scissors): \").lower()\n            if choice in self.choices:\n                return choice\n            else:\n                print(\"Invalid choice. Please enter rock, paper, or scissors.\")\n\n    def determine_winner(self, player_choice, computer_choice):\n        \"\"\"\n        Determines the winner of the round based on the player and computer choices.\n\n        Args:\n            player_choice (str): The player's choice.\n            computer_choice (str): The computer's choice.\n\n        Returns:\n            str: \"player\", \"computer\", or \"tie\" indicating the winner of the round.\n        \"\"\"\n        print(f\"You chose: {player_choice}\")\n        print(f\"Computer chose: {computer_choice}\")\n\n        if player_choice == computer_choice:\n            return \"tie\"\n        elif (player_choice == \"rock\" and computer_choice == \"scissors\") or \\\n             (player_choice == \"paper\" and computer_choice == \"rock\") or \\\n             (player_choice == \"scissors\" and computer_choice == \"paper\"):\n            return \"player\"\n        else:\n            return \"computer\"\n\n    def update_score(self, winner):\n        \"\"\"\n        Updates the scores based on the winner of the round.\n\n        Args:\n            winner (str): \"player\", \"computer\", or \"tie\".\n        \"\"\"\n        if winner == \"player\":\n            self.player_score += 1\n            print(\"You win this round!\")\n        elif winner == \"computer\":\n            self.computer_score += 1\n            print(\"Computer wins this round!\")\n        else:\n            print(\"It's a tie!\")\n\n    def display_score(self):\n        \"\"\"\n        Displays the current score.\n        \"\"\"\n        print(f\"Score: Player - {self.player_score}, Computer - {self.computer_score}\")\n\n    def play_round(self):\n        \"\"\"\n        Plays a single round of the game.\n        \"\"\"\n        player_choice = self.get_player_choice()\n        computer_choice = self.get_computer_choice()\n        winner = self.determine_winner(player_choice, computer_choice)\n        self.update_score(winner)\n        self.display_score()\n\n    def play_game(self, num_rounds=3):\n        \"\"\"\n        Plays the game for a specified number of rounds.\n\n        Args:\n            num_rounds (int): The number of rounds to play.\n        \"\"\"\n        print(\"Welcome to Rock-Paper-Scissors!\")\n        for round_num in range(1, num_rounds + 1):\n            print(f\"\\nRound {round_num}:\")\n            self.play_round()\n\n        print(\"\\nGame Over!\")\n        if self.player_score > self.computer_score:\n            print(\"You win the game!\")\n        elif self.player_score < self.computer_score:\n            print(\"Computer wins the game!\")\n        else:\n            print(\"The game is a tie!\")\n\nif __name__ == \"__main__\":\n    game = RockPaperScissors()\n    game.play_game()\n```",
    "3": "```python\nimport random\nimport time\nimport sys\nimport os\n\n\nclass SnakeGame:\n    \"\"\"\n    A command-line Snake game implementation.\n    \"\"\"\n\n    def __init__(self, width=20, height=10, delay=0.1):\n        \"\"\"\n        Initializes the Snake game.\n\n        Args:\n            width (int): Width of the game board.\n            height (int): Height of the game board.\n            delay (float): Delay between game updates in seconds.\n        \"\"\"\n\n        self.width = width\n        self.height = height\n        self.delay = delay\n        self.snake = [(width // 2, height // 2)]  # Snake starts in the middle\n        self.direction = \"right\"\n        self.food = self.create_food()\n        self.score = 0\n        self.game_over = False\n\n    def create_food(self):\n        \"\"\"\n        Creates food at a random location that is not occupied by the snake.\n\n        Returns:\n            tuple: Coordinates (x, y) of the food.\n        \"\"\"\n        while True:\n            x = random.randint(0, self.width - 1)\n            y = random.randint(0, self.height - 1)\n            if (x, y) not in self.snake:\n                return (x, y)\n\n    def move(self):\n        \"\"\"\n        Moves the snake in the current direction.\n        \"\"\"\n\n        head_x, head_y = self.snake[0]\n\n        if self.direction == \"right\":\n            new_head = (head_x + 1, head_y)\n        elif self.direction == \"left\":\n            new_head = (head_x - 1, head_y)\n        elif self.direction == \"up\":\n            new_head = (head_x, head_y - 1)\n        elif self.direction == \"down\":\n            new_head = (head_x, head_y + 1)\n        else:\n            new_head = (head_x, head_y) # Invalid direction, don't move.\n\n        # Check for game over conditions\n        if (\n            new_head[0] < 0\n            or new_head[0] >= self.width\n            or new_head[1] < 0\n            or new_head[1] >= self.height\n            or new_head in self.snake\n        ):\n            self.game_over = True\n            return\n\n        self.snake.insert(0, new_head)  # Add new head\n\n        if new_head == self.food:\n            self.score += 1\n            self.food = self.create_food()\n        else:\n            self.snake.pop()  # Remove tail if no food eaten\n\n    def change_direction(self, new_direction):\n        \"\"\"\n        Changes the direction of the snake, preventing immediate reversals.\n\n        Args:\n            new_direction (str): The new direction (\"up\", \"down\", \"left\", \"right\").\n        \"\"\"\n        if new_direction == \"right\" and self.direction != \"left\":\n            self.direction = \"right\"\n        elif new_direction == \"left\" and self.direction != \"right\":\n            self.direction = \"left\"\n        elif new_direction == \"up\" and self.direction != \"down\":\n            self.direction = \"up\"\n        elif new_direction == \"down\" and self.direction != \"up\":\n            self.direction = \"down\"\n\n    def draw(self):\n        \"\"\"\n        Draws the game board in the console.\n        \"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the screen\n\n        for y in range(self.height):\n            for x in range(self.width):\n                if (x, y) in self.snake:\n                    print(\"O\", end=\"\")  # Snake body\n                elif (x, y) == self.food:\n                    print(\"X\", end=\"\")  # Food\n                else:\n                    print(\" \", end=\"\")  # Empty space\n            print()\n        print(f\"Score: {self.score}\")\n        print(\"Use 'w', 'a', 's', 'd' to move. 'q' to quit.\")\n\n    def run(self):\n        \"\"\"\n        Runs the main game loop.\n        \"\"\"\n        while not self.game_over:\n            self.draw()\n            self.move()\n            time.sleep(self.delay)\n\n            # Get input (non-blocking)\n            user_input = None\n            if sys.stdin in select.select([sys.stdin], [], [], 0)[0]: #Check if input is available immediately\n                user_input = sys.stdin.readline().strip().lower()\n\n\n            if user_input == \"w\":\n                self.change_direction(\"up\")\n            elif user_input == \"s\":\n                self.change_direction(\"down\")\n            elif user_input == \"a\":\n                self.change_direction(\"left\")\n            elif user_input == \"d\":\n                self.change_direction(\"right\")\n            elif user_input == \"q\":\n                self.game_over = True\n\n        print(\"Game Over! Final Score:\", self.score)\n\n\nif __name__ == \"__main__\":\n    import select\n    game = SnakeGame()\n    game.run()\n```",
    "4": "```python\nimport random\n\nclass Minesweeper:\n    def __init__(self, rows, cols, mines):\n        self.rows = rows\n        self.cols = cols\n        self.mines = mines\n        self.board = [[' ' for _ in range(cols)] for _ in range(rows)]\n        self.revealed = [[False for _ in range(cols)] for _ in range(rows)]\n        self.flags = [[False for _ in range(cols)] for _ in range(rows)]\n        self.game_over = False\n        self.mine_positions = self.place_mines()\n        self.calculate_neighbors()\n\n    def place_mines(self):\n        mine_positions = []\n        count = 0\n        while count < self.mines:\n            row = random.randint(0, self.rows - 1)\n            col = random.randint(0, self.cols - 1)\n            if (row, col) not in mine_positions:\n                mine_positions.append((row, col))\n                count += 1\n        return mine_positions\n\n    def calculate_neighbors(self):\n        for row in range(self.rows):\n            for col in range(self.cols):\n                if (row, col) not in self.mine_positions:\n                    count = 0\n                    for i in range(max(0, row - 1), min(self.rows, row + 2)):\n                        for j in range(max(0, col - 1), min(self.cols, col + 2)):\n                            if (i, j) in self.mine_positions:\n                                count += 1\n                    if count > 0:\n                        self.board[row][col] = str(count)\n\n    def print_board(self):\n        print(\"   \" + \" \".join(str(i) for i in range(self.cols)))\n        print(\"  \" + \"-\" * (2 * self.cols + 1))\n        for i in range(self.rows):\n            row_str = str(i) + \" |\"\n            for j in range(self.cols):\n                if self.flags[i][j]:\n                    row_str += \"F \"\n                elif self.revealed[i][j]:\n                    row_str += self.board[i][j] + \" \"\n                else:\n                    row_str += \". \"\n            print(row_str)\n\n    def reveal(self, row, col):\n        if not (0 <= row < self.rows and 0 <= col < self.cols):\n            return\n\n        if self.revealed[row][col]:\n            return\n\n        self.revealed[row][col] = True\n\n        if (row, col) in self.mine_positions:\n            self.game_over = True\n            return\n\n        if self.board[row][col] == ' ':\n            for i in range(max(0, row - 1), min(self.rows, row + 2)):\n                for j in range(max(0, col - 1), min(self.cols, col + 2)):\n                    self.reveal(i, j)\n\n    def flag(self, row, col):\n        if not self.revealed[row][col]:\n            self.flags[row][col] = not self.flags[row][col]\n\n    def check_win(self):\n        revealed_count = 0\n        for i in range(self.rows):\n            for j in range(self.cols):\n                if self.revealed[i][j]:\n                    revealed_count += 1\n        return revealed_count == self.rows * self.cols - self.mines\n\n    def play(self):\n        while not self.game_over:\n            self.print_board()\n            action = input(\"Enter action (reveal/flag), row, col (e.g., reveal 0 0): \").split()\n            if len(action) != 3:\n                print(\"Invalid input. Please enter: reveal/flag, row, col\")\n                continue\n\n            try:\n                act, row, col = action[0].lower(), int(action[1]), int(action[2])\n            except ValueError:\n                print(\"Invalid input. Row and col must be integers.\")\n                continue\n\n            if not (0 <= row < self.rows and 0 <= col < self.cols):\n                print(\"Invalid row or column.  Must be between 0 and {}\".format(max(self.rows, self.cols) -1))\n                continue\n\n            if act == \"reveal\":\n                self.reveal(row, col)\n                if self.game_over:\n                    print(\"Game Over! You hit a mine.\")\n                    for r, c in self.mine_positions:\n                        self.revealed[r][c] = True\n                    self.print_board()\n                    break\n                if self.check_win():\n                    print(\"Congratulations! You won!\")\n                    self.print_board()\n                    self.game_over = True\n                    break\n\n            elif act == \"flag\":\n                self.flag(row, col)\n            else:\n                print(\"Invalid action.  Choose 'reveal' or 'flag'.\")\n\nif __name__ == \"__main__\":\n    rows = int(input(\"Enter the number of rows: \"))\n    cols = int(input(\"Enter the number of columns: \"))\n    mines = int(input(\"Enter the number of mines: \"))\n\n    game = Minesweeper(rows, cols, mines)\n    game.play()\n```",
    "5": "```python\nimport random\n\nclass Mastermind:\n    \"\"\"\n    A class representing the Mastermind game.\n    \"\"\"\n\n    def __init__(self, code_length=4, colors=6, max_guesses=10):\n        \"\"\"\n        Initializes a new Mastermind game.\n\n        Args:\n            code_length (int): The length of the secret code.\n            colors (int): The number of different colors to choose from (1 to colors).\n            max_guesses (int): The maximum number of guesses allowed.\n        \"\"\"\n        self.code_length = code_length\n        self.colors = colors\n        self.max_guesses = max_guesses\n        self.secret_code = self._generate_secret_code()\n        self.guesses = []\n        self.feedback = []\n        self.game_over = False\n        self.won = False\n\n    def _generate_secret_code(self):\n        \"\"\"\n        Generates a random secret code.\n\n        Returns:\n            list: A list of integers representing the secret code.\n        \"\"\"\n        return [random.randint(1, self.colors) for _ in range(self.code_length)]\n\n    def guess(self, guess):\n        \"\"\"\n        Processes a player's guess.\n\n        Args:\n            guess (list): A list of integers representing the player's guess.\n\n        Returns:\n            tuple: A tuple containing the feedback (list of strings) and a boolean indicating if the guess was correct.\n        \"\"\"\n        if self.game_over:\n            return None, False\n\n        if len(guess) != self.code_length:\n            raise ValueError(f\"Guess must be of length {self.code_length}\")\n\n        for color in guess:\n            if not (1 <= color <= self.colors):\n                raise ValueError(f\"Colors must be between 1 and {self.colors}\")\n\n        self.guesses.append(guess)\n        feedback = self._get_feedback(guess)\n        self.feedback.append(feedback)\n\n        if guess == self.secret_code:\n            self.game_over = True\n            self.won = True\n            return feedback, True\n\n        if len(self.guesses) >= self.max_guesses:\n            self.game_over = True\n            self.won = False\n            return feedback, False\n\n        return feedback, False\n\n    def _get_feedback(self, guess):\n        \"\"\"\n        Calculates the feedback for a given guess.\n\n        Args:\n            guess (list): A list of integers representing the player's guess.\n\n        Returns:\n            list: A list of strings representing the feedback.  \"black\" for correct color and position, \"white\" for correct color but wrong position.\n        \"\"\"\n        feedback = []\n        temp_secret_code = self.secret_code[:]\n        temp_guess = guess[:]\n\n        # Check for black pegs (correct color and position)\n        for i in range(self.code_length):\n            if temp_guess[i] == temp_secret_code[i]:\n                feedback.append(\"black\")\n                temp_guess[i] = None  # Mark as used\n                temp_secret_code[i] = None  # Mark as used\n\n        # Check for white pegs (correct color, wrong position)\n        for i in range(self.code_length):\n            if temp_guess[i] is not None:\n                for j in range(self.code_length):\n                    if temp_secret_code[j] is not None and temp_guess[i] == temp_secret_code[j]:\n                        feedback.append(\"white\")\n                        temp_guess[i] = None  # Mark as used\n                        temp_secret_code[j] = None  # Mark as used\n                        break\n\n        return feedback\n\n    def print_board(self):\n        \"\"\"\n        Prints the current state of the game board.\n        \"\"\"\n        print(\"\\n--- Game Board ---\")\n        for i in range(len(self.guesses)):\n            print(f\"Guess {i + 1}: {self.guesses[i]}  Feedback: {self.feedback[i]}\")\n        print(\"------------------\\n\")\n\n    def play(self):\n        \"\"\"\n        Plays the Mastermind game in the command line.\n        \"\"\"\n        print(f\"Welcome to Mastermind!\\n\")\n        print(f\"I have generated a secret code of length {self.code_length} using colors 1 to {self.colors}.\")\n        print(f\"You have {self.max_guesses} guesses to crack the code.\")\n\n        while not self.game_over:\n            self.print_board()\n            try:\n                guess_str = input(f\"Enter your guess (separated by spaces, e.g., '1 2 3 4'): \")\n                guess = [int(x) for x in guess_str.split()]\n                feedback, correct = self.guess(guess)\n\n                if correct:\n                    self.print_board()\n                    print(\"Congratulations! You cracked the code!\")\n                elif self.game_over:\n                    self.print_board()\n                    print(f\"You ran out of guesses. The secret code was: {self.secret_code}\")\n                else:\n                    print(f\"Feedback: {feedback}\")\n\n            except ValueError as e:\n                print(f\"Invalid input: {e}\")\n            except Exception as e:\n                print(f\"An unexpected error occurred: {e}\")\n\nif __name__ == \"__main__\":\n    game = Mastermind()  # You can customize the parameters here\n    game.play()\n```",
    "6": "```python\nimport random\n\nclass Battleship:\n    def __init__(self, board_size=10, num_ships=5):\n        self.board_size = board_size\n        self.num_ships = num_ships\n        self.player_board = self.create_board()\n        self.computer_board = self.create_board()\n        self.player_ships = self.place_ships(self.player_board)\n        self.computer_ships = self.place_ships(self.computer_board)\n        self.player_guesses = set()\n        self.computer_guesses = set()\n\n    def create_board(self):\n        \"\"\"Creates an empty game board.\"\"\"\n        return [['.' for _ in range(self.board_size)] for _ in range(self.board_size)]\n\n    def place_ships(self, board):\n        \"\"\"Randomly places ships on the board.\"\"\"\n        ships = []\n        for _ in range(self.num_ships):\n            while True:\n                row = random.randint(0, self.board_size - 1)\n                col = random.randint(0, self.board_size - 1)\n                orientation = random.choice(['horizontal', 'vertical'])\n                ship_length = random.randint(2, 4)  # Ships can be 2-4 units long\n\n                if self.is_valid_placement(board, row, col, orientation, ship_length):\n                    ship = []\n                    if orientation == 'horizontal':\n                        for i in range(ship_length):\n                            board[row][col + i] = 'S'\n                            ship.append((row, col + i))\n                    else:\n                        for i in range(ship_length):\n                            board[row + i][col] = 'S'\n                            ship.append((row + i, col))\n                    ships.append(ship)\n                    break\n        return ships\n\n    def is_valid_placement(self, board, row, col, orientation, ship_length):\n        \"\"\"Checks if a ship placement is valid.\"\"\"\n        if orientation == 'horizontal':\n            if col + ship_length > self.board_size:\n                return False\n            for i in range(ship_length):\n                if board[row][col + i] != '.':\n                    return False\n        else:\n            if row + ship_length > self.board_size:\n                return False\n            for i in range(ship_length):\n                if board[row + i][col] != '.':\n                    return False\n        return True\n\n    def print_board(self, board, hide_ships=True):\n        \"\"\"Prints the board to the console.\"\"\"\n        print(\"  \" + \" \".join([chr(65 + i) for i in range(self.board_size)]))  # Print column letters\n        for i, row in enumerate(board):\n            row_str = str(i).rjust(2) + \" \"  # Row number, right-aligned\n            for cell in row:\n                if hide_ships and cell == 'S':\n                    row_str += '. '\n                else:\n                    row_str += cell + \" \"\n            print(row_str)\n\n    def get_player_guess(self):\n        \"\"\"Gets a valid guess from the player.\"\"\"\n        while True:\n            try:\n                guess = input(\"Enter your guess (e.g., A3): \").upper()\n                if len(guess) < 2 or len(guess) > 3:\n                    raise ValueError\n                col = ord(guess[0]) - ord('A')\n                row = int(guess[1:])\n                if not (0 <= row < self.board_size and 0 <= col < self.board_size):\n                    raise ValueError\n                if (row, col) in self.player_guesses:\n                    print(\"You already guessed that location.\")\n                    continue\n                return row, col\n            except ValueError:\n                print(\"Invalid guess.  Enter a coordinate like A3 or B7.\")\n            except IndexError:\n                print(\"Invalid guess. Enter a valid coordinate. \")\n\n    def computer_guess(self):\n        \"\"\"Generates a random guess for the computer.\"\"\"\n        while True:\n            row = random.randint(0, self.board_size - 1)\n            col = random.randint(0, self.board_size - 1)\n            if (row, col) not in self.computer_guesses:\n                return row, col\n\n    def check_hit(self, board, ships, row, col):\n        \"\"\"Checks if a guess is a hit.\"\"\"\n        for ship in ships:\n            if (row, col) in ship:\n                return True\n        return False\n\n    def update_board(self, board, row, col, hit):\n        \"\"\"Updates the board with a hit or miss.\"\"\"\n        if hit:\n            board[row][col] = 'X'\n        else:\n            board[row][col] = 'O'\n\n    def sink_ship(self, ships, row, col):\n        \"\"\"Checks if a ship has been sunk.\"\"\"\n        for ship in ships:\n            if (row, col) in ship:\n                ship.remove((row, col))\n                if not ship:\n                    return True\n                break\n        return False\n\n    def all_ships_sunk(self, ships):\n        \"\"\"Checks if all ships have been sunk.\"\"\"\n        return all(not ship for ship in ships)\n\n    def play_game(self):\n        \"\"\"Main game loop.\"\"\"\n        print(\"Welcome to Battleship!\")\n        print(\"Board size:\", self.board_size)\n        print(\"Number of ships:\", self.num_ships)\n        print(\"Ships are of length 2-4\")\n        print(\"Try to sink all of the computer's ships.\")\n\n        while True:\n            # Player's turn\n            print(\"\\nYour Board:\")\n            self.print_board(self.player_board)\n            print(\"\\nComputer's Board:\")\n            self.print_board(self.computer_board, hide_ships=True)\n\n            print(\"\\nYour Turn:\")\n            row, col = self.get_player_guess()\n            self.player_guesses.add((row, col))\n\n            hit = self.check_hit(self.computer_board, self.computer_ships, row, col)\n            self.update_board(self.computer_board, row, col, hit)\n\n            if hit:\n                print(\"Hit!\")\n                if self.sink_ship(self.computer_ships, row, col):\n                    print(\"You sunk a ship!\")\n                if self.all_ships_sunk(self.computer_ships):\n                    print(\"\\nCongratulations! You sunk all the computer's ships!\")\n                    break\n            else:\n                print(\"Miss!\")\n\n            # Computer's turn\n            print(\"\\nComputer's Turn:\")\n            row, col = self.computer_guess()\n            self.computer_guesses.add((row, col))\n\n            hit = self.check_hit(self.player_board, self.player_ships, row, col)\n            self.update_board(self.player_board, row, col, hit)\n\n            if hit:\n                print(\"Computer hit your ship!\")\n                if self.sink_ship(self.player_ships, row, col):\n                    print(\"Computer sunk one of your ships!\")\n                if self.all_ships_sunk(self.player_ships):\n                    print(\"\\nComputer sunk all of your ships! You lose!\")\n                    break\n            else:\n                print(\"Computer missed!\")\n\n\nif __name__ == \"__main__\":\n    game = Battleship()\n    game.play_game()\n```\n",
    "7": "```python\nimport argparse\nimport time\nimport random\nimport os\n\nclass GameOfLife:\n    \"\"\"\n    Implementation of Conway's Game of Life.\n    \"\"\"\n\n    def __init__(self, width, height, initial_state=None, seed=None):\n        \"\"\"\n        Initializes the Game of Life.\n\n        Args:\n            width (int): Width of the grid.\n            height (int): Height of the grid.\n            initial_state (list, optional): Initial state of the grid. \n                                            Defaults to None (random).\n            seed (int, optional): Seed for random number generation. Defaults to None.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.grid = [[0 for _ in range(width)] for _ in range(height)]\n\n        if seed is not None:\n            random.seed(seed)\n\n        if initial_state is None:\n            self.randomize_grid()\n        else:\n            self.grid = initial_state\n\n    def randomize_grid(self):\n        \"\"\"\n        Randomly populates the grid with live cells (1) and dead cells (0).\n        \"\"\"\n        for i in range(self.height):\n            for j in range(self.width):\n                self.grid[i][j] = random.randint(0, 1)\n\n    def clear_grid(self):\n        \"\"\"\n        Clears the grid, setting all cells to dead.\n        \"\"\"\n        for i in range(self.height):\n            for j in range(self.width):\n                self.grid[i][j] = 0\n\n    def get_cell(self, row, col):\n        \"\"\"\n        Gets the state of a cell at the given row and column.\n        Handles wrapping around the edges of the grid.\n\n        Args:\n            row (int): Row index.\n            col (int): Column index.\n\n        Returns:\n            int: 1 if the cell is alive, 0 if dead.\n        \"\"\"\n        row = row % self.height\n        col = col % self.width\n        return self.grid[row][col]\n\n    def count_neighbors(self, row, col):\n        \"\"\"\n        Counts the number of live neighbors for a given cell.\n\n        Args:\n            row (int): Row index of the cell.\n            col (int): Column index of the cell.\n\n        Returns:\n            int: Number of live neighbors.\n        \"\"\"\n        count = 0\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                if i == 0 and j == 0:\n                    continue\n                count += self.get_cell(row + i, col + j)\n        return count\n\n    def next_generation(self):\n        \"\"\"\n        Calculates the next generation of the Game of Life based on the current state.\n        \"\"\"\n        next_grid = [[0 for _ in range(self.width)] for _ in range(self.height)]\n\n        for i in range(self.height):\n            for j in range(self.width):\n                alive_neighbors = self.count_neighbors(i, j)\n                if self.grid[i][j] == 1:  # Alive cell\n                    if alive_neighbors < 2 or alive_neighbors > 3:\n                        next_grid[i][j] = 0  # Dies\n                    else:\n                        next_grid[i][j] = 1  # Survives\n                else:  # Dead cell\n                    if alive_neighbors == 3:\n                        next_grid[i][j] = 1  # Becomes alive\n\n        self.grid = next_grid\n\n    def print_grid(self):\n        \"\"\"\n        Prints the current state of the grid to the console.\n        \"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n        for row in self.grid:\n            print(''.join(['#' if cell else ' ' for cell in row])) # Use # for live, space for dead\n\n    def run(self, generations, delay=0.1):\n        \"\"\"\n        Runs the Game of Life for a specified number of generations.\n\n        Args:\n            generations (int): Number of generations to run.\n            delay (float): Delay (in seconds) between each generation.\n        \"\"\"\n        for _ in range(generations):\n            self.print_grid()\n            time.sleep(delay)\n            self.next_generation()\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description=\"Conway's Game of Life\")\n    parser.add_argument('--width', type=int, default=60, help='Width of the grid')\n    parser.add_argument('--height', type=int, default=30, help='Height of the grid')\n    parser.add_argument('--generations', type=int, default=100, help='Number of generations to run')\n    parser.add_argument('--delay', type=float, default=0.1, help='Delay between generations (in seconds)')\n    parser.add_argument('--seed', type=int, help='Seed for random number generation')\n    parser.add_argument('--initial', type=str, help='Path to initial state file')\n\n\n    args = parser.parse_args()\n\n    initial_state = None\n    if args.initial:\n        try:\n            with open(args.initial, 'r') as f:\n                initial_state = []\n                for line in f:\n                    row = [1 if char == '#' else 0 for char in line.strip()]\n                    initial_state.append(row)\n\n                # Validate initial state dimensions\n                if len(initial_state) != args.height or any(len(row) != args.width for row in initial_state):\n                    raise ValueError(\"Initial state dimensions do not match specified width and height.\")\n\n        except FileNotFoundError:\n            print(f\"Error: Initial state file not found: {args.initial}\")\n            exit(1)\n        except ValueError as e:\n            print(f\"Error: Invalid initial state: {e}\")\n            exit(1)\n        except Exception as e:\n            print(f\"Error reading initial state file: {e}\")\n            exit(1)\n\n    game = GameOfLife(args.width, args.height, initial_state=initial_state, seed=args.seed)\n    game.run(args.generations, args.delay)\n```",
    "8": "```python\nclass ConnectFour:\n    def __init__(self, rows=6, cols=7):\n        self.rows = rows\n        self.cols = cols\n        self.board = [[' ' for _ in range(cols)] for _ in range(rows)]\n        self.current_player = 'X'  # Player X starts\n        self.game_over = False\n\n    def print_board(self):\n        \"\"\"Prints the current state of the board.\"\"\"\n        for row in range(self.rows):\n            print('|', end='')\n            for col in range(self.cols):\n                print(self.board[row][col], end='|')\n            print()\n        print('+' + '-+' * self.cols)\n        print(' ', end='')\n        for col in range(self.cols):\n            print(col + 1, end=' ')\n        print()\n\n    def drop_piece(self, col):\n        \"\"\"Drops a piece into the specified column.\"\"\"\n        col -= 1  # Adjust to 0-based indexing\n\n        if not (0 <= col < self.cols):\n            print(\"Invalid column.  Please choose a column between 1 and\", self.cols)\n            return False\n\n        for row in range(self.rows - 1, -1, -1):\n            if self.board[row][col] == ' ':\n                self.board[row][col] = self.current_player\n                return True  # Piece successfully dropped\n        print(\"Column is full.  Please choose another column.\")\n        return False  # Column is full\n\n    def check_win(self):\n        \"\"\"Checks if the current player has won.\"\"\"\n\n        # Check horizontal\n        for row in range(self.rows):\n            for col in range(self.cols - 3):\n                if (self.board[row][col] == self.current_player and\n                        self.board[row][col + 1] == self.current_player and\n                        self.board[row][col + 2] == self.current_player and\n                        self.board[row][col + 3] == self.current_player):\n                    return True\n\n        # Check vertical\n        for row in range(self.rows - 3):\n            for col in range(self.cols):\n                if (self.board[row][col] == self.current_player and\n                        self.board[row + 1][col] == self.current_player and\n                        self.board[row + 2][col] == self.current_player and\n                        self.board[row + 3][col] == self.current_player):\n                    return True\n\n        # Check positive diagonal\n        for row in range(self.rows - 3):\n            for col in range(self.cols - 3):\n                if (self.board[row][col] == self.current_player and\n                        self.board[row + 1][col + 1] == self.current_player and\n                        self.board[row + 2][col + 2] == self.current_player and\n                        self.board[row + 3][col + 3] == self.current_player):\n                    return True\n\n        # Check negative diagonal\n        for row in range(3, self.rows):\n            for col in range(self.cols - 3):\n                if (self.board[row][col] == self.current_player and\n                        self.board[row - 1][col + 1] == self.current_player and\n                        self.board[row - 2][col + 2] == self.current_player and\n                        self.board[row - 3][col + 3] == self.current_player):\n                    return True\n\n        return False\n\n    def check_draw(self):\n        \"\"\"Checks if the board is full (a draw).\"\"\"\n        for row in range(self.rows):\n            for col in range(self.cols):\n                if self.board[row][col] == ' ':\n                    return False  # Found an empty space, not a draw\n        return True  # No empty spaces, it's a draw\n\n    def switch_player(self):\n        \"\"\"Switches the current player.\"\"\"\n        self.current_player = 'O' if self.current_player == 'X' else 'X'\n\n    def play_game(self):\n        \"\"\"Main game loop.\"\"\"\n        while not self.game_over:\n            self.print_board()\n            print(f\"Player {self.current_player}, it's your turn.\")\n\n            try:\n                col = int(input(f\"Enter the column number (1-{self.cols}) to drop your piece: \"))\n                if self.drop_piece(col):\n                    if self.check_win():\n                        self.print_board()\n                        print(f\"Player {self.current_player} wins!\")\n                        self.game_over = True\n                    elif self.check_draw():\n                        self.print_board()\n                        print(\"It's a draw!\")\n                        self.game_over = True\n                    else:\n                        self.switch_player()\n                else:\n                    continue # Try again if drop_piece failed\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n            except KeyboardInterrupt:\n                print(\"\\nGame interrupted. Exiting...\")\n                self.game_over = True\n\n\n\nif __name__ == \"__main__\":\n    game = ConnectFour()\n    game.play_game()\n```",
    "9": "```python\nimport random\n\nclass Blackjack:\n    def __init__(self):\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n        self.player_score = 0\n        self.dealer_score = 0\n        self.game_over = False\n\n    def create_deck(self):\n        suits = [\"Hearts\", \"Diamonds\", \"Clubs\", \"Spades\"]\n        ranks = [\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\", \"Ace\"]\n        deck = []\n        for suit in suits:\n            for rank in ranks:\n                deck.append((rank, suit))\n        random.shuffle(deck)\n        return deck\n\n    def deal_card(self, hand):\n        card = self.deck.pop()\n        hand.append(card)\n        return card\n\n    def calculate_hand_score(self, hand):\n        score = 0\n        ace_count = 0\n        for card in hand:\n            rank = card[0]\n            if rank in [\"Jack\", \"Queen\", \"King\"]:\n                score += 10\n            elif rank == \"Ace\":\n                score += 11\n                ace_count += 1\n            else:\n                score += int(rank)\n\n        while score > 21 and ace_count > 0:\n            score -= 10\n            ace_count -= 1\n\n        return score\n\n    def display_hand(self, hand, is_dealer=False, hide_first_card=False):\n        if is_dealer:\n            print(\"Dealer's hand:\")\n            if hide_first_card:\n                print(\"[Hidden Card]\")\n                for card in hand[1:]:\n                    print(f\" {card[0]} of {card[1]}\")\n            else:\n                for card in hand:\n                    print(f\" {card[0]} of {card[1]}\")\n            if not hide_first_card:\n                print(f\"Dealer's score: {self.dealer_score}\")\n        else:\n            print(\"Your hand:\")\n            for card in hand:\n                print(f\" {card[0]} of {card[1]}\")\n            print(f\"Your score: {self.player_score}\")\n\n    def play_round(self):\n        # Deal initial hands\n        for _ in range(2):\n            self.deal_card(self.player_hand)\n            self.deal_card(self.dealer_hand)\n\n        self.player_score = self.calculate_hand_score(self.player_hand)\n        self.dealer_score = self.calculate_hand_score(self.dealer_hand)\n\n        # Player's turn\n        self.display_hand(self.player_hand)\n        self.display_hand(self.dealer_hand, is_dealer=True, hide_first_card=True)\n\n\n        while self.player_score < 21:\n            action = input(\"Hit or Stand? (h/s): \").lower()\n            if action == 'h':\n                self.deal_card(self.player_hand)\n                self.player_score = self.calculate_hand_score(self.player_hand)\n                self.display_hand(self.player_hand)\n\n                if self.player_score > 21:\n                    print(\"Bust!\")\n                    self.game_over = True\n                    return\n            elif action == 's':\n                break\n            else:\n                print(\"Invalid input. Please enter 'h' or 's'.\")\n\n        # Dealer's turn\n        if not self.game_over:\n            print(\"\\nDealer's turn:\")\n            self.display_hand(self.dealer_hand, is_dealer=True)\n\n            while self.dealer_score < 17:\n                self.deal_card(self.dealer_hand)\n                self.dealer_score = self.calculate_hand_score(self.dealer_hand)\n                print(\"Dealer hits.\")\n                self.display_hand(self.dealer_hand, is_dealer=True)\n                if self.dealer_score > 21:\n                    print(\"Dealer busts!\")\n                    break\n\n        # Determine the winner\n        self.determine_winner()\n\n    def determine_winner(self):\n        print(\"\\n--- Final Results ---\")\n        self.display_hand(self.player_hand)\n        self.display_hand(self.dealer_hand, is_dealer=True)\n\n        if self.player_score > 21:\n            print(\"You lose!\")\n        elif self.dealer_score > 21:\n            print(\"You win!\")\n        elif self.player_score > self.dealer_score:\n            print(\"You win!\")\n        elif self.dealer_score > self.player_score:\n            print(\"You lose!\")\n        else:\n            print(\"It's a tie!\")\n\n    def play_again(self):\n        while True:\n            answer = input(\"Play again? (y/n): \").lower()\n            if answer == 'y':\n                self.__init__()  # Reset the game\n                return True\n            elif answer == 'n':\n                return False\n            else:\n                print(\"Invalid input. Please enter 'y' or 'n'.\")\n\n    def start_game(self):\n        print(\"Welcome to Blackjack!\")\n        while True:\n            self.play_round()\n            if not self.play_again():\n                print(\"Thanks for playing!\")\n                break\n\n\nif __name__ == \"__main__\":\n    game = Blackjack()\n    game.start_game()\n```",
    "10": "```python\nimport random\n\nclass Hammurabi:\n    \"\"\"\n    A class to represent the game Hammurabi.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the game state.\n        \"\"\"\n        self.year = 1\n        self.population = 100\n        self.grain = 2800\n        self.acres = 1000\n        self.harvest = 3  # Initial harvest rate\n        self.rats_ate = 0\n        self.people_starved = 0\n        self.new_arrivals = 0\n        self.price_of_land = 19 + random.randint(-5, 5)  # Initial price of land\n\n    def play_year(self):\n        \"\"\"\n        Plays one year of the game.\n        \"\"\"\n        print(f\"\\nYear {self.year}\")\n        print(f\"You are in year {self.year} of your ten-year rule.\")\n        print(f\"Population is now {self.population}\")\n        print(f\"You harvested {self.harvest} bushels per acre.\")\n        print(f\"Rats ate {self.rats_ate} bushels.\")\n        print(f\"You now have {self.grain} bushels in store.\")\n        print(f\"Land is selling for {self.price_of_land} bushels per acre.\")\n\n        self.ask_questions()\n        self.do_plague()\n        self.do_harvest()\n        self.do_rats()\n        self.do_starvation()\n        self.do_migration()\n        self.update_land_price()\n\n        self.year += 1\n\n    def ask_questions(self):\n        \"\"\"\n        Asks the player for decisions on land, planting, and feeding.\n        \"\"\"\n        while True:\n            try:\n                self.buy_sell = int(input(\"How many acres do you wish to buy or sell (+/- acres)? \"))\n                if self.grain < -self.buy_sell * self.price_of_land:\n                    print(\"O great Hammurabi, we do not have enough grain.\")\n                else:\n                    break\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n        while True:\n            try:\n                self.grain_to_feed = int(input(\"How many bushels do you wish to feed your people? \"))\n                if self.grain_to_feed > self.grain:\n                    print(\"O great Hammurabi, we do not have enough grain.\")\n                else:\n                    break\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n        while True:\n            try:\n                self.acres_to_plant = int(input(\"How many acres do you wish to plant with seed? \"))\n                if self.acres_to_plant > self.acres:\n                    print(\"O great Hammurabi, we do not have enough land.\")\n                elif self.acres_to_plant > self.grain:\n                    print(\"O great Hammurabi, we do not have enough grain.\")\n                elif self.acres_to_plant > self.population * 10:\n                    print(\"O great Hammurabi, we do not have enough people to tend the fields.\")\n                else:\n                    break\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n    def do_plague(self):\n        \"\"\"\n        Simulates a plague that might kill a portion of the population.\n        \"\"\"\n        if random.randint(1, 100) <= 15:\n            deaths = int(self.population / 2)\n            self.population -= deaths\n            print(f\"A horrible plague struck! Half the people died. {deaths} died.\")\n\n    def do_harvest(self):\n        \"\"\"\n        Calculates the harvest for the year.\n        \"\"\"\n        self.acres += self.buy_sell\n        self.grain += -self.buy_sell * self.price_of_land\n\n        self.grain += -self.grain_to_feed\n\n        self.grain += -self.acres_to_plant\n\n        self.harvest = random.randint(1, 8)\n        self.grain += self.acres_to_plant * self.harvest\n\n    def do_rats(self):\n        \"\"\"\n        Simulates rats eating a portion of the grain.\n        \"\"\"\n        self.rats_ate = 0\n        if random.randint(1, 100) <= 40:\n            self.rats_ate = int(self.grain * random.uniform(0.1, 0.3))\n            self.grain -= self.rats_ate\n            print(f\"Rats ate {self.rats_ate} bushels of grain.\")\n\n    def do_starvation(self):\n        \"\"\"\n        Calculates starvation and its effects on the population.\n        \"\"\"\n        self.people_starved = 0\n        if self.grain_to_feed / self.population < 20:\n            self.people_starved = int(self.population - (self.grain_to_feed / 20))\n            if self.people_starved < 0:\n                self.people_starved = 0\n            self.population -= self.people_starved\n            print(f\"{self.people_starved} people starved.\")\n\n            if self.population <= 0:\n                print(\"O great Hammurabi, you have killed everyone!\")\n                return False\n        return True\n\n    def do_migration(self):\n        \"\"\"\n        Calculates immigration based on the state of the kingdom.\n        \"\"\"\n        self.new_arrivals = int((10 * self.acres + self.grain) / self.population / 20 + 1)\n        self.population += self.new_arrivals\n        print(f\"{self.new_arrivals} people came to the city.\")\n\n    def update_land_price(self):\n        \"\"\"\n        Updates the price of land for the next year.\n        \"\"\"\n        self.price_of_land = 19 + random.randint(-5, 5)\n\n    def game_over(self):\n        \"\"\"\n        Checks if the game is over and displays the final stats.\n        \"\"\"\n        if self.year > 10:\n            print(\"\\nYour reign has ended.\")\n            print(f\"Final population: {self.population}\")\n            print(f\"Acres of land owned: {self.acres}\")\n            print(f\"Grain in store: {self.grain}\")\n            starved_percentage = (sum(year.people_starved for year in self.years_history) / sum(year.population for year in self.years_history)) * 100 if self.years_history else 0.0\n            print(f\"Starved percentage: {starved_percentage:.2f}%\")\n            if starved_percentage > 10:\n                print(\"Due to this extreme mismanagement, you have not only been impeached but have also been declared National Fool!!\")\n            else:\n                print(\"A generally positive outcome, you may be able to rule again.\")\n            return True\n        return False\n\n    def play(self):\n        \"\"\"\n        Plays the game for ten years.\n        \"\"\"\n        self.years_history = []\n        print(\"Welcome to Hammurabi!\")\n        while not self.game_over():\n            year_data = Hammurabi()\n            year_data.year = self.year\n            year_data.population = self.population\n            year_data.grain = self.grain\n            year_data.acres = self.acres\n            year_data.harvest = self.harvest\n            year_data.rats_ate = self.rats_ate\n            year_data.people_starved = self.people_starved\n            year_data.new_arrivals = self.new_arrivals\n            year_data.price_of_land = self.price_of_land\n            \n            if not self.play_year():\n                return\n            \n            self.years_history.append(year_data)\n\n\nif __name__ == \"__main__\":\n    game = Hammurabi()\n    game.play()\n```",
    "11": "```python\nimport random\n\nclass LightsOut:\n    \"\"\"\n    A class representing the Lights Out game.\n    \"\"\"\n\n    def __init__(self, size=5, initial_state=None):\n        \"\"\"\n        Initializes the Lights Out game.\n\n        Args:\n            size (int): The size of the board (size x size). Default is 5.\n            initial_state (list): A list of lists representing the initial state of the board.\n                                  If None, a random initial state is generated.\n        \"\"\"\n        self.size = size\n        if initial_state is None:\n            self.board = self.generate_random_board()\n        else:\n            if len(initial_state) != size or any(len(row) != size for row in initial_state):\n                raise ValueError(\"Initial state must be a size x size matrix.\")\n            self.board = initial_state\n\n    def generate_random_board(self):\n        \"\"\"\n        Generates a random initial board state.\n\n        Returns:\n            list: A list of lists representing the board.\n        \"\"\"\n        board = []\n        for _ in range(self.size):\n            row = [random.randint(0, 1) for _ in range(self.size)]\n            board.append(row)\n        return board\n\n    def print_board(self):\n        \"\"\"\n        Prints the current state of the board to the console.\n        \"\"\"\n        for row in self.board:\n            print(\" \".join(map(str, row)))\n\n    def toggle_light(self, row, col):\n        \"\"\"\n        Toggles the light at the given row and column.\n\n        Args:\n            row (int): The row index (0-based).\n            col (int): The column index (0-based).\n        \"\"\"\n        if 0 <= row < self.size and 0 <= col < self.size:\n            self.board[row][col] = 1 - self.board[row][col]  # Flip 0 to 1 and 1 to 0\n\n    def press_button(self, row, col):\n        \"\"\"\n        Simulates pressing the button at the given row and column, toggling the light\n        and its adjacent lights (up, down, left, right).\n\n        Args:\n            row (int): The row index (0-based).\n            col (int): The column index (0-based).\n        \"\"\"\n        self.toggle_light(row, col)  # Toggle the button itself\n        self.toggle_light(row - 1, col)  # Toggle the light above\n        self.toggle_light(row + 1, col)  # Toggle the light below\n        self.toggle_light(row, col - 1)  # Toggle the light to the left\n        self.toggle_light(row, col + 1)  # Toggle the light to the right\n\n    def is_solved(self):\n        \"\"\"\n        Checks if the game is solved (all lights are off).\n\n        Returns:\n            bool: True if the game is solved, False otherwise.\n        \"\"\"\n        return all(all(light == 0 for light in row) for row in self.board)\n\n    def play(self):\n        \"\"\"\n        Plays the Lights Out game through the command line interface.\n        \"\"\"\n        print(\"Welcome to Lights Out!\")\n        print(\"The goal is to turn off all the lights.\")\n        print(\"Enter the row and column of the button you want to press (e.g., '0 0').\")\n        print(\"Enter 'q' to quit.\")\n\n        while True:\n            self.print_board()\n            if self.is_solved():\n                print(\"Congratulations! You solved the puzzle!\")\n                break\n\n            move = input(\"Enter your move (row col): \").strip().lower()\n\n            if move == 'q':\n                print(\"Quitting the game.\")\n                break\n\n            try:\n                row, col = map(int, move.split())\n                if 0 <= row < self.size and 0 <= col < self.size:\n                    self.press_button(row, col)\n                else:\n                    print(\"Invalid move. Row and column must be between 0 and\", self.size - 1)\n            except ValueError:\n                print(\"Invalid input. Please enter two integers separated by a space.\")\n\nif __name__ == '__main__':\n    game = LightsOut(size=5)  # You can change the size here\n    game.play()\n```",
    "12": "```python\nimport time\nimport random\nimport os\n\n\nclass Pong:\n    \"\"\"\n    A simple command-line Pong game.\n    \"\"\"\n\n    def __init__(self, width=60, height=20, paddle_length=4):\n        \"\"\"\n        Initializes the Pong game.\n\n        Args:\n            width (int): Width of the game board.\n            height (int): Height of the game board.\n            paddle_length (int): Length of the paddles.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.paddle_length = paddle_length\n        self.ball_x = width // 2\n        self.ball_y = height // 2\n        self.ball_dx = random.choice([-1, 1])  # Ball direction in x-axis\n        self.ball_dy = random.choice([-1, 1])  # Ball direction in y-axis\n        self.paddle1_y = height // 2 - paddle_length // 2\n        self.paddle2_y = height // 2 - paddle_length // 2\n        self.score1 = 0\n        self.score2 = 0\n        self.max_score = 5  # Game ends when a player reaches this score\n        self.game_over = False\n\n    def _clear_screen(self):\n        \"\"\"Clears the terminal screen.\"\"\"\n        os.system(\"cls\" if os.name == \"nt\" else \"clear\")\n\n    def _draw_board(self):\n        \"\"\"Draws the game board in the console.\"\"\"\n        board = []\n        for i in range(self.height):\n            board.append([\" \"] * self.width)\n\n        # Draw paddles\n        for i in range(self.paddle_length):\n            board[self.paddle1_y + i][1] = \"|\"  # Paddle 1\n            board[self.paddle2_y + i][self.width - 2] = \"|\"  # Paddle 2\n\n        # Draw ball\n        board[self.ball_y][self.ball_x] = \"O\"\n\n        # Print the board\n        self._clear_screen()\n        print(\"-\" * self.width)\n        for row in board:\n            print(\"\".join(row))\n        print(\"-\" * self.width)\n        print(f\"Player 1: {self.score1}  |  Player 2: {self.score2}\")\n\n    def _move_ball(self):\n        \"\"\"Moves the ball and handles collisions.\"\"\"\n        self.ball_x += self.ball_dx\n        self.ball_y += self.ball_dy\n\n        # Bounce off top and bottom walls\n        if self.ball_y <= 0 or self.ball_y >= self.height - 1:\n            self.ball_dy *= -1\n\n        # Bounce off paddles\n        if self.ball_x <= 2 and self.paddle1_y <= self.ball_y <= self.paddle1_y + self.paddle_length - 1:\n            self.ball_dx *= -1\n            # Add some randomness to the vertical direction\n            self.ball_dy += random.choice([-1, 0, 1])\n            self.ball_dy = max(min(self.ball_dy, 1), -1)  # Limit dy to -1,0,1\n\n        if self.ball_x >= self.width - 3 and self.paddle2_y <= self.ball_y <= self.paddle2_y + self.paddle_length - 1:\n            self.ball_dx *= -1\n            # Add some randomness to the vertical direction\n            self.ball_dy += random.choice([-1, 0, 1])\n            self.ball_dy = max(min(self.ball_dy, 1), -1)  # Limit dy to -1,0,1\n        # Score and reset if ball goes out of bounds\n        if self.ball_x <= 0:\n            self.score2 += 1\n            self._reset_ball()\n        elif self.ball_x >= self.width - 1:\n            self.score1 += 1\n            self._reset_ball()\n\n        # Check for game over\n        if self.score1 >= self.max_score or self.score2 >= self.max_score:\n            self.game_over = True\n\n    def _reset_ball(self):\n        \"\"\"Resets the ball to the center after a score.\"\"\"\n        self.ball_x = self.width // 2\n        self.ball_y = self.height // 2\n        self.ball_dx = random.choice([-1, 1])\n        self.ball_dy = random.choice([-1, 1])\n\n    def _move_paddle1(self, direction):\n        \"\"\"Moves paddle 1 up or down.\"\"\"\n        if direction == \"up\":\n            if self.paddle1_y > 0:\n                self.paddle1_y -= 1\n        elif direction == \"down\":\n            if self.paddle1_y + self.paddle_length < self.height:\n                self.paddle1_y += 1\n\n    def _move_paddle2(self, direction):\n        \"\"\"Moves paddle 2 up or down.\"\"\"\n        if direction == \"up\":\n            if self.paddle2_y > 0:\n                self.paddle2_y -= 1\n        elif direction == \"down\":\n            if self.paddle2_y + self.paddle_length < self.height:\n                self.paddle2_y += 1\n\n    def play(self):\n        \"\"\"Starts the Pong game loop.\"\"\"\n        while not self.game_over:\n            self._draw_board()\n            # Get input for paddle movements\n            p1_move = input(\"Player 1 (w/s): \").lower()\n            p2_move = input(\"Player 2 (up/down): \").lower()\n\n            # Process paddle movements\n            if \"w\" in p1_move:\n                self._move_paddle1(\"up\")\n            if \"s\" in p1_move:\n                self._move_paddle1(\"down\")\n            if \"up\" in p2_move:\n                self._move_paddle2(\"up\")\n            if \"down\" in p2_move:\n                self._move_paddle2(\"down\")\n\n            self._move_ball()\n            time.sleep(0.1)  # Control game speed\n\n        # Game over message\n        self._draw_board()\n        if self.score1 > self.score2:\n            print(\"Player 1 wins!\")\n        else:\n            print(\"Player 2 wins!\")\n\n\nif __name__ == \"__main__\":\n    game = Pong()\n    game.play()\n```",
    "13": "```python\nimport random\nimport os\n\nclass Tetris:\n    \"\"\"\n    Implements the Tetris game with a command-line interface.\n    \"\"\"\n\n    WIDTH = 10\n    HEIGHT = 20\n    PIECES = [\n        [[1, 1, 1, 1]],  # I\n        [[1, 1], [1, 1]],  # O\n        [[0, 1, 1], [1, 1, 0]],  # S\n        [[1, 1, 0], [0, 1, 1]],  # Z\n        [[1, 1, 1], [0, 0, 1]],  # L\n        [[1, 1, 1], [1, 0, 0]],  # J\n        [[1, 1, 1], [0, 1, 0]]   # T\n    ]\n\n    def __init__(self):\n        \"\"\"\n        Initializes the Tetris game.\n        \"\"\"\n        self.board = [[0] * self.WIDTH for _ in range(self.HEIGHT)]\n        self.current_piece = None\n        self.current_x = 0\n        self.current_y = 0\n        self.game_over = False\n        self.score = 0\n        self.next_piece = self.new_piece()  # Store the next piece\n        self.level = 1  # Initial level\n        self.lines_cleared = 0  # Total lines cleared\n        self.speed = 500  # Initial speed (milliseconds)\n        self.delay = self.speed  # Current delay (milliseconds)\n\n    def new_piece(self):\n        \"\"\"\n        Generates a new random piece.\n        \"\"\"\n        return random.choice(self.PIECES)\n\n    def spawn_piece(self):\n        \"\"\"\n        Spawns a new piece at the top of the board.\n        \"\"\"\n        self.current_piece = self.next_piece\n        self.next_piece = self.new_piece()\n        self.current_x = self.WIDTH // 2 - len(self.current_piece[0]) // 2\n        self.current_y = 0\n\n        if self.check_collision(self.current_piece, self.current_x, self.current_y):\n            self.game_over = True\n\n    def rotate_piece(self):\n        \"\"\"\n        Rotates the current piece clockwise.\n        \"\"\"\n        rotated_piece = list(zip(*self.current_piece[::-1]))\n        if not self.check_collision(rotated_piece, self.current_x, self.current_y):\n            self.current_piece = rotated_piece\n\n    def check_collision(self, piece, x, y):\n        \"\"\"\n        Checks if the given piece collides with the board at the given position.\n        \"\"\"\n        for i, row in enumerate(piece):\n            for j, cell in enumerate(row):\n                if cell:\n                    board_x = x + j\n                    board_y = y + i\n\n                    if board_x < 0 or board_x >= self.WIDTH or board_y >= self.HEIGHT or \\\n                       (board_y >= 0 and self.board[board_y][board_x]):\n                        return True\n        return False\n\n    def move_piece(self, dx):\n        \"\"\"\n        Moves the current piece horizontally.\n        \"\"\"\n        new_x = self.current_x + dx\n        if not self.check_collision(self.current_piece, new_x, self.current_y):\n            self.current_x = new_x\n\n    def drop_piece(self):\n        \"\"\"\n        Moves the current piece down one row.\n        \"\"\"\n        new_y = self.current_y + 1\n        if not self.check_collision(self.current_piece, self.current_x, new_y):\n            self.current_y = new_y\n            return True\n        else:\n            return False\n\n    def hard_drop(self):\n        \"\"\"\n        Drops the piece to the lowest possible position.\n        \"\"\"\n        while not self.check_collision(self.current_piece, self.current_x, self.current_y + 1):\n            self.current_y += 1\n        self.fix_piece()\n\n    def fix_piece(self):\n        \"\"\"\n        Fixes the current piece to the board.\n        \"\"\"\n        for i, row in enumerate(self.current_piece):\n            for j, cell in enumerate(row):\n                if cell:\n                    self.board[self.current_y + i][self.current_x + j] = cell\n        self.clear_lines()\n        self.spawn_piece()\n\n    def clear_lines(self):\n        \"\"\"\n        Clears any full lines from the board.\n        \"\"\"\n        lines_cleared = 0\n        new_board = []\n        for row in self.board:\n            if all(row):\n                lines_cleared += 1\n            else:\n                new_board.append(row)\n\n        for _ in range(lines_cleared):\n            new_board.insert(0, [0] * self.WIDTH)\n\n        self.board = new_board\n        self.lines_cleared += lines_cleared\n\n        if lines_cleared > 0:\n            self.score += self.calculate_score(lines_cleared, self.level)\n\n        # Update level every 10 lines\n        if self.lines_cleared >= self.level * 10:\n            self.level += 1\n            self.speed = max(100, 500 - (self.level - 1) * 20)  # Increase speed, minimum 100\n            print(f\"Level Up! New level: {self.level}, Speed: {self.speed}ms\")\n\n    def calculate_score(self, lines, level):\n        \"\"\"\n        Calculates the score based on the number of lines cleared and the level.\n        \"\"\"\n        if lines == 1:\n            return 40 * level\n        elif lines == 2:\n            return 100 * level\n        elif lines == 3:\n            return 300 * level\n        elif lines == 4:\n            return 1200 * level\n        else:\n            return 0\n\n    def draw_board(self):\n        \"\"\"\n        Draws the Tetris board to the console.\n        \"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n        print(\"Tetris\")\n        print(f\"Score: {self.score}  Level: {self.level}  Lines: {self.lines_cleared}\")\n        print(\"Next Piece:\")\n        for row in self.next_piece:\n            print(''.join(['#' if cell else ' ' for cell in row]))\n\n        for i in range(self.HEIGHT):\n            row_str = ''\n            for j in range(self.WIDTH):\n                cell = self.board[i][j]\n                # Check if the current cell is occupied by the current piece\n                is_piece = False\n                if self.current_piece:\n                    piece_height = len(self.current_piece)\n                    piece_width = len(self.current_piece[0])\n                    if (self.current_y <= i < self.current_y + piece_height and\n                            self.current_x <= j < self.current_x + piece_width and\n                            self.current_piece[i - self.current_y][j - self.current_x]):\n                        is_piece = True\n\n                row_str += '#' if cell or is_piece else '.'\n            print(row_str)\n\n        print(\"Controls: A - Left, D - Right, S - Down, W - Rotate, Space - Hard Drop, Q - Quit\")\n\n    def run(self):\n        \"\"\"\n        Runs the Tetris game loop.\n        \"\"\"\n        self.spawn_piece()\n        import time\n        last_time = time.time()\n\n        while not self.game_over:\n            current_time = time.time()\n            elapsed_time = (current_time - last_time) * 1000  # Convert to milliseconds\n\n            self.draw_board()\n\n            import select\n            if select.select([sys.stdin, ], [], [], self.delay / 1000.0)[0]:\n                action = sys.stdin.read(1).upper()  # Read a single character\n                if action == 'A':\n                    self.move_piece(-1)\n                elif action == 'D':\n                    self.move_piece(1)\n                elif action == 'S':\n                    self.drop_piece()\n                elif action == 'W':\n                    self.rotate_piece()\n                elif action == ' ':\n                    self.hard_drop()\n                elif action == 'Q':\n                    self.game_over = True\n                    break\n\n            if elapsed_time >= self.delay:\n                if not self.drop_piece():\n                    self.fix_piece()\n                last_time = time.time()\n            else:\n                time.sleep(0.01) # Small delay to prevent busy-waiting\n\n        self.draw_board()\n        print(\"Game Over! Final Score:\", self.score)\n\nif __name__ == \"__main__\":\n    import sys\n    import tty\n    import termios\n\n    # Store the original terminal settings\n    fd = sys.stdin.fileno()\n    old_settings = termios.tcgetattr(fd)\n\n    try:\n        # Set terminal to raw mode for character-by-character input\n        tty.setraw(sys.stdin.fileno())\n        game = Tetris()\n        game.run()\n    finally:\n        # Restore the original terminal settings\n        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n```",
    "14": "```python\nimport math\nimport random\nimport time\n\nclass Asteroid:\n    def __init__(self, x, y, size, dx, dy):\n        self.x = x\n        self.y = y\n        self.size = size\n        self.dx = dx\n        self.dy = dy\n\n    def move(self, width, height):\n        self.x += self.dx\n        self.y += self.dy\n\n        if self.x < 0:\n            self.x = width\n        elif self.x > width:\n            self.x = 0\n        if self.y < 0:\n            self.y = height\n        elif self.y > height:\n            self.y = 0\n\n    def __repr__(self):\n        return f\"Asteroid(x={self.x}, y={self.y}, size={self.size})\"\n\n\n\nclass Ship:\n    def __init__(self, x, y, angle):\n        self.x = x\n        self.y = y\n        self.angle = angle\n        self.thrust = 0\n        self.lives = 3\n        self.invulnerable_timer = 0\n\n    def move(self, width, height):\n        self.x += self.thrust * math.cos(self.angle)\n        self.y += self.thrust * math.sin(self.angle)\n\n        if self.x < 0:\n            self.x = width\n        elif self.x > width:\n            self.x = 0\n        if self.y < 0:\n            self.y = height\n        elif self.y > height:\n            self.y = 0\n\n        self.thrust *= 0.95  # Gradual deceleration\n        if self.invulnerable_timer > 0:\n            self.invulnerable_timer -= 1\n\n\n    def rotate_left(self):\n        self.angle -= 0.1\n\n    def rotate_right(self):\n        self.angle += 0.1\n\n    def accelerate(self):\n        self.thrust += 0.2\n\n    def is_colliding(self, asteroid):\n        distance = math.sqrt((self.x - asteroid.x)**2 + (self.y - asteroid.y)**2)\n        return distance < asteroid.size + 10  # Approximation for ship size\n\n    def hit(self):\n        if self.invulnerable_timer == 0:\n            self.lives -= 1\n            self.invulnerable_timer = 100 # Invulnerable for a short time\n            return True\n        return False\n    \n    def __repr__(self):\n        return f\"Ship(x={self.x}, y={self.y}, angle={self.angle}, lives={self.lives})\"\n\nclass AsteroidsGame:\n    def __init__(self, width=80, height=24, num_asteroids=5):\n        self.width = width\n        self.height = height\n        self.ship = Ship(width // 2, height // 2, 0)\n        self.asteroids = []\n        self.num_asteroids = num_asteroids\n        self.game_over = False\n        self.score = 0\n        self.create_asteroids()\n\n    def create_asteroids(self):\n        self.asteroids = []\n        for _ in range(self.num_asteroids):\n            size = random.randint(1, 3)\n            x = random.randint(0, self.width)\n            y = random.randint(0, self.height)\n            dx = random.uniform(-0.5, 0.5)\n            dy = random.uniform(-0.5, 0.5)\n            self.asteroids.append(Asteroid(x, y, size, dx, dy))\n\n    def update(self, action=None):\n        if self.game_over:\n            return\n\n        if action == \"left\":\n            self.ship.rotate_left()\n        elif action == \"right\":\n            self.ship.rotate_right()\n        elif action == \"up\":\n            self.ship.accelerate()\n\n        self.ship.move(self.width, self.height)\n\n        for asteroid in self.asteroids:\n            asteroid.move(self.width, self.height)\n\n        self.check_collisions()\n\n    def check_collisions(self):\n        for i in range(len(self.asteroids)):\n            if self.ship.is_colliding(self.asteroids[i]):\n                if self.ship.hit():\n                    print(\"Ship hit!\")\n                    if self.ship.lives <= 0:\n                        self.game_over = True\n                        print(\"Game Over!\")\n                del self.asteroids[i]\n                self.score += 10\n                return # Only one collision per frame\n    def draw(self):\n        screen = [[' ' for _ in range(self.width)] for _ in range(self.height)]\n\n        # Draw asteroids\n        for asteroid in self.asteroids:\n            x = int(asteroid.x)\n            y = int(asteroid.y)\n            if 0 <= x < self.width and 0 <= y < self.height:\n                screen[y][x] = '*'\n\n        # Draw ship\n        ship_x = int(self.ship.x)\n        ship_y = int(self.ship.y)\n        if 0 <= ship_x < self.width and 0 <= ship_y < self.height:\n            screen[ship_y][ship_x] = 'A'\n\n        # Draw lives and score\n        lives_str = f\"Lives: {self.ship.lives}\"\n        score_str = f\"Score: {self.score}\"\n\n        for i, char in enumerate(lives_str):\n            if i < self.width:\n                screen[0][i] = char\n\n        for i, char in enumerate(score_str):\n            if i < self.width:\n                screen[1][i] = char\n\n        # Draw invulnerability indicator\n        if self.ship.invulnerable_timer > 0:\n            invulnerable_str = \"Invulnerable!\"\n            invulnerable_start_x = self.width - len(invulnerable_str)\n            for i, char in enumerate(invulnerable_str):\n                if invulnerable_start_x + i < self.width:\n                    screen[0][invulnerable_start_x + i] = char\n\n\n        # Print screen\n        for row in screen:\n            print(\"\".join(row))\n\n    def play(self):\n        while not self.game_over:\n            self.draw()\n            print(\"Controls: left (a), right (d), up (w), quit (q)\")\n            action = input(\"Enter action: \").lower()\n\n            if action == \"q\":\n                self.game_over = True\n                break\n\n            self.update(action)\n            time.sleep(0.1)  # Control game speed\n\n        print(\"Final Score:\", self.score)\n\nif __name__ == \"__main__\":\n    game = AsteroidsGame()\n    game.play()\n```",
    "15": "```python\nimport random\nimport time\n\nclass Boggle:\n    \"\"\"\n    A class to represent the Boggle game.\n    \"\"\"\n\n    def __init__(self, size=4, time_limit=180, dictionary_file=\"words.txt\"):\n        \"\"\"\n        Initializes the Boggle game.\n\n        Args:\n            size (int): The size of the Boggle board (default: 4).\n            time_limit (int): The time limit for the game in seconds (default: 180).\n            dictionary_file (str): The path to the dictionary file (default: \"words.txt\").\n        \"\"\"\n        self.size = size\n        self.time_limit = time_limit\n        self.dictionary = self.load_dictionary(dictionary_file)\n        self.board = self.generate_board()\n        self.words_found = set()\n        self.start_time = None\n\n    def load_dictionary(self, dictionary_file):\n        \"\"\"\n        Loads the dictionary from a file.\n\n        Args:\n            dictionary_file (str): The path to the dictionary file.\n\n        Returns:\n            set: A set containing all words in the dictionary.\n        \"\"\"\n        try:\n            with open(dictionary_file, \"r\") as f:\n                words = set(word.strip().upper() for word in f)\n            return words\n        except FileNotFoundError:\n            print(f\"Error: Dictionary file '{dictionary_file}' not found.\")\n            exit(1)\n\n    def generate_board(self):\n        \"\"\"\n        Generates a random Boggle board.\n\n        Returns:\n            list: A 2D list representing the Boggle board.\n        \"\"\"\n        dice = [\n            \"RIFOBX\", \"IFEHSE\", \"DIENPS\", \"UMNNNH\",\n            \"ETGLRU\", \"ACDJOV\", \"ACULMN\", \"DGILNU\",\n            \"AHIMOR\", \"EEGHNW\", \"AFFKPS\", \"HLNNRZ\",\n            \"DEILRX\", \"DELRVY\", \"AISTYB\", \"CEILPT\"\n        ]\n        board = []\n        for _ in range(self.size):\n            row = []\n            for _ in range(self.size):\n                die = random.choice(dice)\n                row.append(random.choice(die))\n            board.append(row)\n        return board\n\n    def print_board(self):\n        \"\"\"\n        Prints the Boggle board to the console.\n        \"\"\"\n        print(\"Boggle Board:\")\n        for row in self.board:\n            print(\" \".join(row))\n        print()\n\n    def is_valid_word(self, word):\n        \"\"\"\n        Checks if a word is valid (in the dictionary and not already found).\n\n        Args:\n            word (str): The word to check.\n\n        Returns:\n            bool: True if the word is valid, False otherwise.\n        \"\"\"\n        return (word in self.dictionary and\n                word not in self.words_found and\n                len(word) >= 3)\n\n    def find_words_recursive(self, row, col, word, visited):\n        \"\"\"\n        Recursively finds words on the board starting from a given cell.\n\n        Args:\n            row (int): The row of the current cell.\n            col (int): The column of the current cell.\n            word (str): The current word being formed.\n            visited (set): A set of visited cells (row, col).\n\n        \"\"\"\n        if row < 0 or row >= self.size or col < 0 or col >= self.size:\n            return\n\n        if (row, col) in visited:\n            return\n\n        letter = self.board[row][col]\n        new_word = word + letter\n\n        if not any(w.startswith(new_word) for w in self.dictionary):\n            return  # Prune search if no word starts with the current prefix\n\n        if self.is_valid_word(new_word):\n            self.words_found.add(new_word)\n\n        visited.add((row, col))\n\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                if i == 0 and j == 0:\n                    continue\n                self.find_words_recursive(row + i, col + j, new_word, visited.copy())\n                #visited.remove((row+i, col+j)) #backtrack\n\n    def solve_board(self):\n        \"\"\"\n        Finds all possible words on the board.\n        \"\"\"\n        for row in range(self.size):\n            for col in range(self.size):\n                self.find_words_recursive(row, col, \"\", set())\n\n    def play(self):\n        \"\"\"\n        Starts and runs the Boggle game.\n        \"\"\"\n        self.print_board()\n        self.start_time = time.time()\n        print(f\"You have {self.time_limit} seconds to find words.  Good luck!\")\n        print(\"Enter words (or 'quit' to end):\")\n\n        while time.time() - self.start_time < self.time_limit:\n            remaining_time = int(self.time_limit - (time.time() - self.start_time))\n            print(f\"Time remaining: {remaining_time} seconds\", end='\\r')\n            word = input().strip().upper()\n\n            if word == \"QUIT\":\n                break\n\n            if self.is_valid_word(word):\n                self.words_found.add(word)\n                print(\"Good!\")\n            else:\n                print(\"Invalid word. Try again.\")\n\n        print(\"\\nTime's up!\")\n        self.end_game()\n\n    def calculate_score(self):\n        \"\"\"\n        Calculates the player's score based on the length of the words found.\n\n        Returns:\n            int: The player's score.\n        \"\"\"\n        score = 0\n        for word in self.words_found:\n            length = len(word)\n            if length == 3 or length == 4:\n                score += 1\n            elif length == 5:\n                score += 2\n            elif length == 6:\n                score += 3\n            elif length == 7:\n                score += 5\n            elif length >= 8:\n                score += 11\n        return score\n\n    def end_game(self):\n        \"\"\"\n        Ends the game, displays the results, and calculates the score.\n        \"\"\"\n        print(\"Your words:\", \", \".join(sorted(self.words_found)))\n        score = self.calculate_score()\n        print(\"Your score:\", score)\n\n        self.solve_board()\n        print(\"\\nPossible words:\", \", \".join(sorted(self.words_found)))\n\n        #Find all words that the player didn't find\n        missed_words = [word for word in self.words_found if word not in self.words_found]\n        print(\"\\nMissed words:\", \", \".join(sorted(missed_words)))\n\nif __name__ == \"__main__\":\n    game = Boggle()\n    game.play()\n```",
    "16": "```python\nimport random\nimport time\nimport os\n\nclass PacManGame:\n    \"\"\"\n    A command-line Pac-Man game implementation.\n    \"\"\"\n\n    def __init__(self, width=15, height=10, num_ghosts=2, initial_food_percentage=0.2):\n        \"\"\"\n        Initializes the Pac-Man game.\n\n        Args:\n            width (int): The width of the game board.\n            height (int): The height of the game board.\n            num_ghosts (int): The number of ghosts in the game.\n            initial_food_percentage (float): The initial percentage of the board filled with food.\n        \"\"\"\n\n        self.width = width\n        self.height = height\n        self.num_ghosts = num_ghosts\n        self.initial_food_percentage = initial_food_percentage\n        self.board = [[' ' for _ in range(width)] for _ in range(height)]\n        self.pacman_x = width // 2\n        self.pacman_y = height // 2\n        self.ghosts = []\n        self.food_count = 0\n        self.score = 0\n        self.game_over = False\n        self.won = False\n\n        self.directions = {'w': (-1, 0), 's': (1, 0), 'a': (0, -1), 'd': (0, 1)}  # row, col\n        self.ghost_directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # row, col\n\n        self.initialize_board()\n\n    def initialize_board(self):\n        \"\"\"\n        Initializes the game board with walls, food, Pac-Man, and ghosts.\n        \"\"\"\n\n        # Create walls around the board\n        for i in range(self.width):\n            self.board[0][i] = '#'\n            self.board[self.height - 1][i] = '#'\n        for i in range(self.height):\n            self.board[i][0] = '#'\n            self.board[i][self.width - 1] = '#'\n\n        # Place food randomly\n        for i in range(1, self.height - 1):\n            for j in range(1, self.width - 1):\n                if random.random() < self.initial_food_percentage:\n                    self.board[i][j] = '.'\n                    self.food_count += 1\n\n        # Place Pac-Man in the center\n        self.board[self.pacman_y][self.pacman_x] = 'P'\n\n        # Place ghosts randomly\n        for _ in range(self.num_ghosts):\n            while True:\n                x = random.randint(1, self.width - 2)\n                y = random.randint(1, self.height - 2)\n                if self.board[y][x] == ' ':  # Or '.' if you want ghosts on food\n                    self.ghosts.append((y, x))\n                    self.board[y][x] = 'G'\n                    break\n\n    def print_board(self):\n        \"\"\"\n        Prints the current state of the game board to the console.\n        \"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear') # Clear the console\n        print(\"-\" * (self.width + 2))\n        for row in self.board:\n            print(\"|\" + \"\".join(row) + \"|\")\n        print(\"-\" * (self.width + 2))\n        print(f\"Score: {self.score}  Food Remaining: {self.food_count}\")\n        print(\"Use 'w' (up), 's' (down), 'a' (left), 'd' (right) to move.  'q' to quit.\")\n\n\n    def move_pacman(self, direction):\n        \"\"\"\n        Moves Pac-Man in the specified direction.\n\n        Args:\n            direction (str): The direction to move ('w', 'a', 's', 'd').\n        \"\"\"\n\n        dy, dx = self.directions.get(direction, (0, 0))  # Default to no movement\n        new_x = self.pacman_x + dx\n        new_y = self.pacman_y + dy\n\n        if 0 < new_x < self.width - 1 and 0 < new_y < self.height - 1 and self.board[new_y][new_x] != '#':\n            # Clear Pac-Man's previous position\n            self.board[self.pacman_y][self.pacman_x] = ' '\n\n            # Update Pac-Man's position\n            self.pacman_x = new_x\n            self.pacman_y = new_y\n\n            # Check for food\n            if self.board[self.pacman_y][self.pacman_x] == '.':\n                self.score += 10\n                self.food_count -= 1\n\n            # Check for ghosts (game over)\n            if self.board[self.pacman_y][self.pacman_x] == 'G':\n                self.game_over = True\n                return\n\n            # Place Pac-Man on the board\n            self.board[self.pacman_y][self.pacman_x] = 'P'\n\n\n    def move_ghosts(self):\n        \"\"\"\n        Moves the ghosts randomly.\n        \"\"\"\n\n        for i in range(len(self.ghosts)):\n            y, x = self.ghosts[i]\n            self.board[y][x] = ' '  # Clear the ghost's previous position\n\n            while True:\n                dy, dx = random.choice(self.ghost_directions)\n                new_x = x + dx\n                new_y = y + dy\n\n                if 0 < new_x < self.width - 1 and 0 < new_y < self.height - 1 and self.board[new_y][new_x] != '#':\n                    # Update ghost's position\n                    self.ghosts[i] = (new_y, new_x)\n\n                    # Check for collision with Pac-Man\n                    if new_x == self.pacman_x and new_y == self.pacman_y:\n                        self.game_over = True\n                        return\n\n                    self.board[new_y][new_x] = 'G'\n                    break\n\n    def check_win(self):\n        \"\"\"\n        Checks if the player has won the game.\n        \"\"\"\n        if self.food_count == 0:\n            self.won = True\n            self.game_over = True\n\n\n    def play(self):\n        \"\"\"\n        Starts and runs the Pac-Man game loop.\n        \"\"\"\n        while not self.game_over:\n            self.print_board()\n            direction = input(\"Enter direction (w/a/s/d) or q to quit: \").lower()\n\n            if direction == 'q':\n                print(\"Quitting the game.\")\n                self.game_over = True\n                break\n\n            self.move_pacman(direction)\n            if self.game_over:\n                break  # Game over because Pac-Man hit a ghost\n\n            self.move_ghosts()\n            if self.game_over:\n                break  # Game over because a ghost hit Pac-Man\n\n\n            self.check_win()\n            time.sleep(0.2)  # Add a short delay to control game speed\n\n        self.print_board() # Print the final board state\n\n        if self.won:\n            print(\"Congratulations! You won!\")\n        elif self.game_over:\n            print(\"Game Over! You were caught by a ghost.\")\n        else:\n            print(\"Game ended.\")\n        print(f\"Final Score: {self.score}\")\n\n\nif __name__ == \"__main__\":\n    game = PacManGame(width=20, height=12, num_ghosts=3, initial_food_percentage=0.15)\n    game.play()\n```",
    "17": "```python\nimport random\nimport time\nimport os\n\nclass DinosaurRunner:\n    \"\"\"\n    Implementation of the Dinosaur Runner game in a command line interface.\n    \"\"\"\n\n    def __init__(self, width=80, height=10):\n        \"\"\"\n        Initializes the game.\n\n        Args:\n            width (int): The width of the game screen.\n            height (int): The height of the game screen.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.dino_position = self.height - 2  # Dino starts near the bottom\n        self.obstacle_position = self.width - 5 # Obstacle starts far right\n        self.obstacle_height = 1 # Obstacle height\n        self.score = 0\n        self.game_over = False\n        self.ground = [\"=\"] * self.width\n        self.dino = [\"^\", \"|\", \"\\\\\", \"|\"] # Dino representation (simplified)\n        self.obstacle = [\"#\"]  # Obstacle representation (simplified)\n        self.obstacle_speed = 1 # Obstacle speed\n        self.jump_height = 3 # Height of the dino jump\n        self.is_jumping = False # Flag to indicate if the Dino is jumping\n        self.jump_counter = 0  # Counter for the jump duration\n        self.difficulty = 1  # Game difficulty multiplier\n        self.high_score = 0 # Store the current high score\n\n        self.load_high_score()\n\n    def load_high_score(self):\n        \"\"\"Loads the high score from a file.\"\"\"\n        try:\n            with open(\"highscore.txt\", \"r\") as f:\n                self.high_score = int(f.read())\n        except FileNotFoundError:\n            self.high_score = 0\n        except ValueError:\n            self.high_score = 0 # Handle cases where the file is corrupted\n\n    def save_high_score(self):\n        \"\"\"Saves the high score to a file.\"\"\"\n        with open(\"highscore.txt\", \"w\") as f:\n            f.write(str(self.high_score))\n\n    def clear_screen(self):\n        \"\"\"Clears the terminal screen.\"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')\n\n    def generate_obstacle(self):\n        \"\"\"Generates a new obstacle.\"\"\"\n        self.obstacle_position = self.width - 5\n        self.obstacle_height = random.randint(1, 2) # Vary obstacle height\n\n    def update(self):\n        \"\"\"Updates the game state.\"\"\"\n        if self.game_over:\n            return\n\n        # Update obstacle position\n        self.obstacle_position -= self.obstacle_speed * self.difficulty\n\n        # Generate new obstacle if it goes off screen\n        if self.obstacle_position < 0:\n            self.generate_obstacle()\n            self.score += 1\n\n        # Update jump\n        if self.is_jumping:\n            self.jump_counter += 1\n            if self.jump_counter <= self.jump_height:  # Ascending\n                self.dino_position -= 1\n            else:  # Descending\n                self.dino_position += 1\n            if self.dino_position >= self.height - 2:  # Back on the ground\n                self.dino_position = self.height - 2\n                self.is_jumping = False\n                self.jump_counter = 0\n\n        # Collision detection (simplified)\n        if (self.obstacle_position < 4 and self.obstacle_position > 0 and\n            self.dino_position >= self.height - 1 - self.obstacle_height):\n            self.game_over = True\n            if self.score > self.high_score:\n                self.high_score = self.score\n                self.save_high_score()\n\n        # Increase difficulty over time\n        if self.score > 0 and self.score % 10 == 0:\n            self.difficulty += 0.1\n\n    def draw(self):\n        \"\"\"Draws the game on the screen.\"\"\"\n        self.clear_screen()\n\n        screen = [[\" \"] * self.width for _ in range(self.height)]\n\n        # Draw ground\n        for i in range(self.width):\n            screen[self.height - 1][i] = \"=\"\n\n        # Draw Dino\n        for i, part in enumerate(self.dino):\n            if self.dino_position + i < self.height: # Avoid drawing outside screen\n                screen[self.dino_position + i][2] = part\n\n        # Draw obstacle\n        for i in range(self.obstacle_height):\n             screen[self.height - 1 - i][self.obstacle_position] = \"#\"\n\n        # Print the screen\n        for row in screen:\n            print(\"\".join(row))\n\n        # Print score and instructions\n        print(f\"Score: {self.score:.0f}  High Score: {self.high_score}\")\n        print(\"Press 'space' to jump. Press 'q' to quit.\")\n\n\n    def handle_input(self, key):\n        \"\"\"Handles user input.\"\"\"\n        if key == \" \":\n            if not self.is_jumping:\n                self.is_jumping = True\n        elif key == \"q\":\n            self.game_over = True\n\n    def play(self):\n        \"\"\"Runs the main game loop.\"\"\"\n        self.generate_obstacle()\n\n        while not self.game_over:\n            start_time = time.time()\n            self.draw()\n            time.sleep(0.05)\n\n            # Get user input (non-blocking)\n            key = None\n            try:\n                import termios, sys, tty\n                fd = sys.stdin.fileno()\n                old_settings = termios.tcgetattr(fd)\n                try:\n                    tty.setcbreak(sys.stdin.fileno())\n                    if sys.stdin in select.select([sys.stdin], [], [], 0)[0]:  # Check if input is available\n                        key = sys.stdin.read(1)\n                finally:\n                    termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n            except ImportError:\n                # Fallback for Windows (requires installation of 'msvcrt')\n                import msvcrt\n                if msvcrt.kbhit():\n                    key = msvcrt.getch().decode(\"utf-8\")\n            except Exception as e:\n                print(f\"Error getting input: {e}\")\n                key = None\n\n            if key:\n                self.handle_input(key)\n\n            self.update()\n\n            elapsed_time = time.time() - start_time\n            delay = max(0.01, 0.05 - elapsed_time) # Adjust delay to maintain consistent speed\n            time.sleep(delay)\n\n        self.draw() # Final draw before game over\n        print(\"Game Over!\")\n        print(f\"Final Score: {self.score:.0f}\")\n\n\n\nif __name__ == \"__main__\":\n    import select\n\n    game = DinosaurRunner()\n    game.play()\n```"
}