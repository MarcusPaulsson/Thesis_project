{
    "0": "```python\nclass TicTacToe:\n    \"\"\"\n    Represents a Tic-Tac-Toe game.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the game board and sets the current player to 'X'.\n        \"\"\"\n        self.board = [\" \" for _ in range(9)]  # Represents the 3x3 board\n        self.current_player = \"X\"\n        self.game_over = False\n\n    def print_board(self):\n        \"\"\"\n        Prints the current state of the game board to the console.\n        \"\"\"\n        print(\"-------------\")\n        for i in range(3):\n            print(f\"| {self.board[i*3]} | {self.board[i*3 + 1]} | {self.board[i*3 + 2]} |\")\n            print(\"-------------\")\n\n    def is_valid_move(self, position):\n        \"\"\"\n        Checks if the given position is a valid move.\n\n        Args:\n            position (int): The position to check (1-9).\n\n        Returns:\n            bool: True if the position is valid, False otherwise.\n        \"\"\"\n        return 1 <= position <= 9 and self.board[position - 1] == \" \"\n\n    def make_move(self, position):\n        \"\"\"\n        Makes a move on the board for the current player.\n\n        Args:\n            position (int): The position to make the move (1-9).\n        \"\"\"\n        self.board[position - 1] = self.current_player\n\n    def check_win(self):\n        \"\"\"\n        Checks if the current player has won the game.\n\n        Returns:\n            bool: True if the current player has won, False otherwise.\n        \"\"\"\n        # Check rows\n        for i in range(3):\n            if self.board[i*3] == self.board[i*3 + 1] == self.board[i*3 + 2] != \" \":\n                return True\n\n        # Check columns\n        for i in range(3):\n            if self.board[i] == self.board[i + 3] == self.board[i + 6] != \" \":\n                return True\n\n        # Check diagonals\n        if self.board[0] == self.board[4] == self.board[8] != \" \":\n            return True\n        if self.board[2] == self.board[4] == self.board[6] != \" \":\n            return True\n\n        return False\n\n    def check_draw(self):\n        \"\"\"\n        Checks if the game is a draw.\n\n        Returns:\n            bool: True if the game is a draw, False otherwise.\n        \"\"\"\n        return \" \" not in self.board\n\n    def switch_player(self):\n        \"\"\"\n        Switches the current player to the other player.\n        \"\"\"\n        self.current_player = \"O\" if self.current_player == \"X\" else \"X\"\n\n    def play(self):\n        \"\"\"\n        Plays the Tic-Tac-Toe game.\n        \"\"\"\n        while not self.game_over:\n            self.print_board()\n            print(f\"Player {self.current_player}, it's your turn.\")\n\n            try:\n                position = int(input(\"Enter a position (1-9): \"))\n                if self.is_valid_move(position):\n                    self.make_move(position)\n                    if self.check_win():\n                        self.print_board()\n                        print(f\"Player {self.current_player} wins!\")\n                        self.game_over = True\n                    elif self.check_draw():\n                        self.print_board()\n                        print(\"It's a draw!\")\n                        self.game_over = True\n                    else:\n                        self.switch_player()\n                else:\n                    print(\"Invalid move. Please try again.\")\n            except ValueError:\n                print(\"Invalid input. Please enter a number between 1 and 9.\")\n\nif __name__ == \"__main__\":\n    game = TicTacToe()\n    game.play()\n```\n",
    "1": "```python\nimport random\n\nclass Hangman:\n    \"\"\"\n    A class to represent the Hangman game.\n    \"\"\"\n\n    def __init__(self, word_list, max_attempts=6):\n        \"\"\"\n        Initializes the Hangman game.\n\n        Args:\n            word_list (list): A list of words to choose from.\n            max_attempts (int): The maximum number of incorrect guesses allowed.\n        \"\"\"\n        self.word_list = word_list\n        self.secret_word = random.choice(self.word_list).upper()\n        self.guessed_letters = set()\n        self.attempts_left = max_attempts\n        self.word_mask = ['_' for _ in self.secret_word]\n        self.game_over = False\n\n    def display_board(self):\n        \"\"\"\n        Displays the current state of the game to the console.\n        \"\"\"\n        print(\"\\n\" + \"=\" * 20)\n        print(\"Word:\", \" \".join(self.word_mask))\n        print(\"Guessed letters:\", \", \".join(sorted(self.guessed_letters)))\n        print(\"Attempts left:\", self.attempts_left)\n        print(\"=\" * 20 + \"\\n\")\n\n    def get_guess(self):\n        \"\"\"\n        Prompts the user to enter a guess and validates the input.\n\n        Returns:\n            str: The user's guess (a single uppercase letter).\n        \"\"\"\n        while True:\n            guess = input(\"Guess a letter: \").upper()\n            if not guess.isalpha():\n                print(\"Invalid input. Please enter a letter.\")\n            elif len(guess) != 1:\n                print(\"Please guess only one letter at a time.\")\n            elif guess in self.guessed_letters:\n                print(\"You already guessed that letter.\")\n            else:\n                return guess\n\n    def update_game_state(self, guess):\n        \"\"\"\n        Updates the game state based on the user's guess.\n\n        Args:\n            guess (str): The user's guess.\n        \"\"\"\n        self.guessed_letters.add(guess)\n        if guess in self.secret_word:\n            for i, letter in enumerate(self.secret_word):\n                if letter == guess:\n                    self.word_mask[i] = guess\n            if \"_\" not in self.word_mask:\n                self.game_over = True\n                print(\"Congratulations! You guessed the word:\", self.secret_word)\n        else:\n            self.attempts_left -= 1\n            print(\"Incorrect guess.\")\n            if self.attempts_left == 0:\n                self.game_over = True\n                print(\"You ran out of attempts. The word was:\", self.secret_word)\n\n    def play(self):\n        \"\"\"\n        Runs the main game loop.\n        \"\"\"\n        print(\"Welcome to Hangman!\")\n        while not self.game_over:\n            self.display_board()\n            guess = self.get_guess()\n            self.update_game_state(guess)\n        print(\"Game Over.\")\n\n\nif __name__ == \"__main__\":\n    word_list = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\", \"fig\", \"grape\", \"honeydew\"]\n    game = Hangman(word_list)\n    game.play()\n```",
    "2": "```python\nimport random\n\nclass RockPaperScissors:\n    \"\"\"\n    A class to represent the Rock-Paper-Scissors game.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the game with a list of possible choices and scores.\n        \"\"\"\n        self.choices = [\"rock\", \"paper\", \"scissors\"]\n        self.player_score = 0\n        self.computer_score = 0\n\n    def get_player_choice(self):\n        \"\"\"\n        Gets the player's choice from the command line.\n        Ensures the input is valid.\n\n        Returns:\n            str: The player's choice (rock, paper, or scissors).\n        \"\"\"\n        while True:\n            choice = input(\"Enter your choice (rock, paper, or scissors): \").lower()\n            if choice in self.choices:\n                return choice\n            else:\n                print(\"Invalid choice. Please enter rock, paper, or scissors.\")\n\n    def get_computer_choice(self):\n        \"\"\"\n        Generates a random choice for the computer.\n\n        Returns:\n            str: The computer's choice (rock, paper, or scissors).\n        \"\"\"\n        return random.choice(self.choices)\n\n    def determine_winner(self, player_choice, computer_choice):\n        \"\"\"\n        Determines the winner of the round based on the choices.\n\n        Args:\n            player_choice (str): The player's choice.\n            computer_choice (str): The computer's choice.\n\n        Returns:\n            str: A message indicating the outcome of the round.\n        \"\"\"\n        print(f\"You chose: {player_choice}\")\n        print(f\"Computer chose: {computer_choice}\")\n\n        if player_choice == computer_choice:\n            return \"It's a tie!\"\n        elif (player_choice == \"rock\" and computer_choice == \"scissors\") or \\\n             (player_choice == \"paper\" and computer_choice == \"rock\") or \\\n             (player_choice == \"scissors\" and computer_choice == \"paper\"):\n            self.player_score += 1\n            return \"You win!\"\n        else:\n            self.computer_score += 1\n            return \"Computer wins!\"\n\n    def display_score(self):\n         \"\"\"\n         Displays the current score.\n         \"\"\"\n         print(f\"Score: You - {self.player_score}, Computer - {self.computer_score}\")\n\n\n    def play_round(self):\n        \"\"\"\n        Plays a single round of the game.\n        \"\"\"\n        player_choice = self.get_player_choice()\n        computer_choice = self.get_computer_choice()\n        result = self.determine_winner(player_choice, computer_choice)\n        print(result)\n        self.display_score()\n\n\n    def play_game(self):\n        \"\"\"\n        Plays the game until the player chooses to quit.\n        \"\"\"\n        print(\"Welcome to Rock-Paper-Scissors!\")\n        while True:\n            self.play_round()\n            play_again = input(\"Play again? (y/n): \").lower()\n            if play_again != \"y\":\n                print(\"Thanks for playing!\")\n                break\n\n\nif __name__ == \"__main__\":\n    game = RockPaperScissors()\n    game.play_game()\n```\n",
    "3": "```python\nimport random\nimport time\nimport os\n\nclass SnakeGame:\n    \"\"\"\n    A command-line implementation of the classic Snake game.\n    \"\"\"\n\n    def __init__(self, width=20, height=10, initial_length=3):\n        \"\"\"\n        Initializes the game.\n\n        Args:\n            width (int): The width of the game board.\n            height (int): The height of the game board.\n            initial_length (int): The initial length of the snake.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.snake = [(width // 2, height // 2 - i) for i in range(initial_length)]  # Snake starts in the middle\n        self.food = self.create_food()\n        self.direction = \"right\"  # Initial direction\n        self.game_over = False\n        self.score = 0\n        self.delay = 0.1 # Initial delay\n        self.initial_length = initial_length\n\n    def create_food(self):\n        \"\"\"\n        Creates food at a random location on the board, ensuring it's not on the snake.\n\n        Returns:\n            tuple: The coordinates (x, y) of the food.\n        \"\"\"\n        while True:\n            x = random.randint(0, self.width - 1)\n            y = random.randint(0, self.height - 1)\n            if (x, y) not in self.snake:\n                return (x, y)\n\n    def move(self):\n        \"\"\"\n        Moves the snake one step in the current direction.\n        \"\"\"\n        head_x, head_y = self.snake[0]\n\n        if self.direction == \"up\":\n            new_head = (head_x, head_y - 1)\n        elif self.direction == \"down\":\n            new_head = (head_x, head_y + 1)\n        elif self.direction == \"left\":\n            new_head = (head_x - 1, head_y)\n        elif self.direction == \"right\":\n            new_head = (head_x + 1, head_y)\n\n        # Check for collision with walls or itself\n        if (\n            new_head[0] < 0\n            or new_head[0] >= self.width\n            or new_head[1] < 0\n            or new_head[1] >= self.height\n            or new_head in self.snake\n        ):\n            self.game_over = True\n            return\n\n        self.snake.insert(0, new_head)  # Add the new head\n\n        # Check if the snake ate the food\n        if new_head == self.food:\n            self.score += 1\n            self.food = self.create_food()\n            self.delay *= 0.95  # Increase speed as the snake grows\n        else:\n            self.snake.pop()  # Remove the tail if it didn't eat\n\n    def change_direction(self, new_direction):\n        \"\"\"\n        Changes the direction of the snake, preventing immediate 180-degree turns.\n\n        Args:\n            new_direction (str): The new direction (\"up\", \"down\", \"left\", \"right\").\n        \"\"\"\n        if new_direction == \"up\" and self.direction != \"down\":\n            self.direction = \"up\"\n        elif new_direction == \"down\" and self.direction != \"up\":\n            self.direction = \"down\"\n        elif new_direction == \"left\" and self.direction != \"right\":\n            self.direction = \"left\"\n        elif new_direction == \"right\" and self.direction != \"left\":\n            self.direction = \"right\"\n\n    def draw(self):\n        \"\"\"\n        Draws the game board in the console.\n        \"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n        print(f\"Score: {self.score}\")\n\n        for y in range(self.height):\n            for x in range(self.width):\n                if (x, y) == self.food:\n                    print(\"F\", end=\"\")  # Food\n                elif (x, y) in self.snake:\n                    if (x, y) == self.snake[0]:\n                        print(\"H\", end=\"\") # Head\n                    else:\n                        print(\"S\", end=\"\")  # Snake body\n                else:\n                    print(\".\", end=\"\")  # Empty space\n            print()  # New line at the end of each row\n\n    def play(self):\n        \"\"\"\n        The main game loop.\n        \"\"\"\n        while not self.game_over:\n            self.draw()\n            self.move()\n            time.sleep(self.delay)\n\n            # Get user input (non-blocking)\n            # This is platform-dependent and requires additional libraries like 'msvcrt' on Windows or 'select' on Linux/macOS\n            # For simplicity, we'll use a simple keyboard input method that requires pressing Enter after each move.\n            # A better implementation would use non-blocking input.\n            direction = input(\"Enter direction (up, down, left, right, or q to quit): \").lower()\n            if direction == 'q':\n                self.game_over = True\n                break\n            if direction in (\"up\", \"down\", \"left\", \"right\"):\n                self.change_direction(direction)\n\n        print(\"Game Over!\")\n        print(f\"Final Score: {self.score}\")\n\n    def reset(self):\n        \"\"\"Resets the game to its initial state.\"\"\"\n        self.snake = [(self.width // 2, self.height // 2 - i) for i in range(self.initial_length)]\n        self.food = self.create_food()\n        self.direction = \"right\"\n        self.game_over = False\n        self.score = 0\n        self.delay = 0.1\n\nif __name__ == \"__main__\":\n    game = SnakeGame()\n    game.play()\n```\n",
    "4": "```python\nimport random\n\nclass Minesweeper:\n    def __init__(self, rows, cols, mines):\n        self.rows = rows\n        self.cols = cols\n        self.mines = mines\n        self.board = [[' ' for _ in range(cols)] for _ in range(rows)]\n        self.revealed = [[False for _ in range(cols)] for _range(rows)]\n        self.flags = [[False for _ in range(cols)] for _ in range(rows)]\n        self.game_over = False\n        self.game_won = False\n        self.mine_positions = []\n        self.first_move = True  # Track if it's the first move\n\n    def print_board(self):\n        \"\"\"Prints the current state of the board.\"\"\"\n        print(\"   \" + \" \".join(str(i) for i in range(self.cols)))\n        print(\"  \" + \"-\" * (2 * self.cols + 1))\n        for i in range(self.rows):\n            row_str = str(i) + \"| \"\n            for j in range(self.cols):\n                if self.flags[i][j]:\n                    row_str += \"F \"  # Flag\n                elif self.revealed[i][j]:\n                    row_str += str(self.board[i][j]) + \" \"\n                else:\n                    row_str += \". \"  # Hidden\n            print(row_str)\n\n    def place_mines(self, safe_row, safe_col):\n        \"\"\"Places mines randomly on the board, excluding the safe cell.\"\"\"\n        count = 0\n        while count < self.mines:\n            row = random.randint(0, self.rows - 1)\n            col = random.randint(0, self.cols - 1)\n            if (row, col) != (safe_row, safe_col) and (row, col) not in self.mine_positions:\n                self.board[row][col] = '*'  # Mark as mine\n                self.mine_positions.append((row, col))\n                count += 1\n\n    def calculate_neighboring_mines(self):\n        \"\"\"Calculates the number of mines adjacent to each cell.\"\"\"\n        for row in range(self.rows):\n            for col in range(self.cols):\n                if self.board[row][col] != '*':\n                    count = 0\n                    for i in range(max(0, row - 1), min(self.rows, row + 2)):\n                        for j in range(max(0, col - 1), min(self.cols, col + 2)):\n                            if self.board[i][j] == '*':\n                                count += 1\n                    self.board[row][col] = count if count > 0 else ' ' # ' ' for empty cells\n\n    def reveal(self, row, col):\n        \"\"\"Reveals a cell and recursively reveals adjacent empty cells.\"\"\"\n        if self.revealed[row][col]:\n            return\n\n        self.revealed[row][col] = True\n\n        if self.board[row][col] == '*':\n            self.game_over = True\n            return\n\n        if self.board[row][col] == ' ':\n            for i in range(max(0, row - 1), min(self.rows, row + 2)):\n                for j in range(max(0, col - 1), min(self.cols, col + 2)):\n                    self.reveal(i, j)\n\n    def flag(self, row, col):\n        \"\"\"Toggles a flag on a cell.\"\"\"\n        if self.revealed[row][col]:\n            print(\"Cannot flag a revealed cell.\")\n            return\n        self.flags[row][col] = not self.flags[row][col]\n\n    def check_win(self):\n        \"\"\"Checks if the player has won the game.\"\"\"\n        revealed_count = 0\n        for row in range(self.rows):\n            for col in range(self.cols):\n                if self.revealed[row][col]:\n                    revealed_count += 1\n\n        if revealed_count == self.rows * self.cols - self.mines:\n            self.game_won = True\n\n    def play(self):\n        \"\"\"Main game loop.\"\"\"\n        while not self.game_over and not self.game_won:\n            self.print_board()\n            print(\"\\nOptions: (r)ow (c)ol (a)ction (reveal/flag). Example: 0 0 r\")\n            user_input = input(\"Enter your move: \").split()\n\n            if len(user_input) != 3:\n                print(\"Invalid input. Please enter row, column, and action.\")\n                continue\n\n            try:\n                row = int(user_input[0])\n                col = int(user_input[1])\n                action = user_input[2].lower()\n            except ValueError:\n                print(\"Invalid input. Row and column must be integers.\")\n                continue\n\n            if not (0 <= row < self.rows and 0 <= col < self.cols):\n                print(\"Invalid input. Row and column must be within the board's bounds.\")\n                continue\n\n            if self.first_move:\n                self.place_mines(row, col)\n                self.calculate_neighboring_mines()\n                self.first_move = False\n\n            if action == 'r':\n                self.reveal(row, col)\n            elif action == 'f':\n                self.flag(row, col)\n            else:\n                print(\"Invalid action. Use 'r' to reveal or 'f' to flag.\")\n                continue\n\n            self.check_win()\n\n        if self.game_over:\n            print(\"\\nGame Over! You hit a mine.\")\n            # Reveal the whole board\n            for row in range(self.rows):\n                for col in range(self.cols):\n                    self.revealed[row][col] = True\n            self.print_board()\n        elif self.game_won:\n            print(\"\\nCongratulations! You won!\")\n            # Reveal the whole board\n            for row in range(self.rows):\n                for col in range(self.cols):\n                    self.revealed[row][col] = True\n            self.print_board()\n\n# Example usage:\nif __name__ == \"__main__\":\n    rows = 8\n    cols = 8\n    mines = 10\n    game = Minesweeper(rows, cols, mines)\n    game.play()\n```",
    "5": "```python\nimport random\n\nclass Mastermind:\n    \"\"\"\n    A class representing the Mastermind game.\n    \"\"\"\n\n    def __init__(self, code_length=4, colors=('R', 'G', 'B', 'Y', 'O', 'P'), max_guesses=10):\n        \"\"\"\n        Initializes the Mastermind game.\n\n        Args:\n            code_length (int): The length of the code (default: 4).\n            colors (tuple): The possible colors (default: ('R', 'G', 'B', 'Y', 'O', 'P')).\n            max_guesses (int): The maximum number of guesses allowed (default: 10).\n        \"\"\"\n        self.code_length = code_length\n        self.colors = colors\n        self.max_guesses = max_guesses\n        self.secret_code = self._generate_secret_code()\n        self.guesses_remaining = max_guesses\n        self.game_over = False\n        self.won = False\n\n    def _generate_secret_code(self):\n        \"\"\"\n        Generates a random secret code.\n\n        Returns:\n            str: The secret code.\n        \"\"\"\n        return ''.join(random.choices(self.colors, k=self.code_length))\n\n    def _evaluate_guess(self, guess):\n        \"\"\"\n        Evaluates a guess and returns feedback.\n\n        Args:\n            guess (str): The player's guess.\n\n        Returns:\n            tuple: A tuple containing the number of exact matches and partial matches.\n        \"\"\"\n        exact_matches = 0\n        partial_matches = 0\n        temp_secret_code = list(self.secret_code)\n        temp_guess = list(guess)\n\n        # Find exact matches\n        for i in range(self.code_length):\n            if temp_guess[i] == temp_secret_code[i]:\n                exact_matches += 1\n                temp_secret_code[i] = None  # Mark as matched\n                temp_guess[i] = None        # Mark as matched\n\n        # Find partial matches\n        for i in range(self.code_length):\n            if temp_guess[i] is not None:\n                for j in range(self.code_length):\n                    if temp_guess[i] == temp_secret_code[j]:\n                        partial_matches += 1\n                        temp_secret_code[j] = None  # Mark as matched\n                        break\n\n        return exact_matches, partial_matches\n\n    def play_round(self, guess):\n        \"\"\"\n        Plays a single round of the game.\n\n        Args:\n            guess (str): The player's guess.\n\n        Returns:\n            tuple: A tuple containing the number of exact matches, partial matches,\n                   and a boolean indicating if the game is over.\n        \"\"\"\n        if self.game_over:\n            return None, None, True\n\n        self.guesses_remaining -= 1\n\n        exact_matches, partial_matches = self._evaluate_guess(guess)\n\n        if exact_matches == self.code_length:\n            self.game_over = True\n            self.won = True\n        elif self.guesses_remaining == 0:\n            self.game_over = True\n\n        return exact_matches, partial_matches, self.game_over\n\n    def print_game_state(self):\n        \"\"\"\n        Prints the current game state (guesses remaining).\n        \"\"\"\n        print(f\"Guesses remaining: {self.guesses_remaining}\")\n\n    def get_secret_code(self):\n        \"\"\"\n        Returns the secret code (used for revealing at the end of the game).\n\n        Returns:\n            str: The secret code.\n        \"\"\"\n        return self.secret_code\n\n    def is_valid_guess(self, guess):\n        \"\"\"\n        Checks if a guess is valid.\n\n        Args:\n            guess (str): The player's guess.\n\n        Returns:\n            bool: True if the guess is valid, False otherwise.\n        \"\"\"\n        if len(guess) != self.code_length:\n            return False\n        for char in guess:\n            if char not in self.colors:\n                return False\n        return True\n\n\ndef play_mastermind():\n    \"\"\"\n    Plays a game of Mastermind through the command line.\n    \"\"\"\n    code_length = 4\n    colors = ('R', 'G', 'B', 'Y', 'O', 'P')\n    max_guesses = 10\n\n    print(\"Welcome to Mastermind!\")\n    print(f\"Code length: {code_length}\")\n    print(f\"Available colors: {', '.join(colors)}\")\n    print(f\"You have {max_guesses} guesses.\")\n\n    game = Mastermind(code_length, colors, max_guesses)\n\n    while not game.game_over:\n        game.print_game_state()\n        guess = input(\"Enter your guess (e.g., RGBY): \").upper()\n\n        if not game.is_valid_guess(guess):\n            print(\"Invalid guess. Please enter a guess with the correct length and using only the available colors.\")\n            continue\n\n        exact_matches, partial_matches, game_over = game.play_round(guess)\n\n        print(f\"Exact matches: {exact_matches}\")\n        print(f\"Partial matches: {partial_matches}\")\n\n    if game.won:\n        print(\"Congratulations! You cracked the code!\")\n    else:\n        print(\"You ran out of guesses.  The secret code was:\", game.get_secret_code())\n\nif __name__ == \"__main__\":\n    play_mastermind()\n```",
    "6": "```python\nimport random\n\nclass Battleship:\n    def __init__(self, board_size=10):\n        self.board_size = board_size\n        self.player_board = [['.' for _ in range(board_size)] for _ in range(board_size)]\n        self.computer_board = [['.' for _ in range(board_size)] for _ in range(board_size)]\n        self.player_ships = []\n        self.computer_ships = []\n        self.ship_lengths = [5, 4, 3, 3, 2]  #lengths of ships: Aircraft Carrier, Battleship, Cruiser, Submarine, Destroyer\n\n    def print_board(self, board, hidden=True):\n        \"\"\"Prints the board with row and column labels.\"\"\"\n        print(\"  \" + \" \".join([chr(65 + i) for i in range(self.board_size)])) #A,B,C..\n        for i in range(self.board_size):\n            row_str = str(i + 1).rjust(2) + \" \"  # Number rows starting from 1\n            for j in range(self.board_size):\n                if hidden and board[i][j] == 'S':\n                    row_str += '. '\n                else:\n                    row_str += board[i][j] + \" \"\n            print(row_str)\n\n    def place_ship(self, board, ship_length, player):\n        \"\"\"Places a ship on the board.\"\"\"\n        while True:\n            if player == \"player\":\n                orientation = input(f\"Enter orientation for ship of length {ship_length} (H/V): \").upper()\n                start_row = input(f\"Enter starting row (1-{self.board_size}): \")\n                start_col = input(f\"Enter starting column (A-{chr(64+self.board_size)}): \").upper()\n                try:\n                    start_row = int(start_row) - 1  # Adjust to 0-based index\n                    start_col = ord(start_col) - ord('A')\n                    if not (0 <= start_row < self.board_size and 0 <= start_col < self.board_size):\n                        print(\"Invalid coordinates. Try again.\")\n                        continue\n                except (ValueError, TypeError):\n                    print(\"Invalid input. Try again.\")\n                    continue\n            else:  # Computer placement\n                orientation = random.choice(['H', 'V'])\n                start_row = random.randint(0, self.board_size - 1)\n                start_col = random.randint(0, self.board_size - 1)\n\n            if orientation not in ['H', 'V']:\n                if player == \"player\":\n                    print(\"Invalid orientation. Use 'H' or 'V'.\")\n                continue\n\n            if orientation == 'H':\n                if start_col + ship_length > self.board_size:\n                    if player == \"player\":\n                        print(\"Ship goes off the board. Try again.\")\n                    continue\n                valid = True\n                for i in range(ship_length):\n                    if board[start_row][start_col + i] == 'S':\n                        valid = False\n                        break\n                if not valid:\n                    if player == \"player\":\n                        print(\"Ships are overlapping. Try again.\")\n                    continue\n\n                for i in range(ship_length):\n                    board[start_row][start_col + i] = 'S'\n                return True  # Ship placed successfully\n\n            else:  # orientation == 'V'\n                if start_row + ship_length > self.board_size:\n                    if player == \"player\":\n                        print(\"Ship goes off the board. Try again.\")\n                    continue\n                valid = True\n                for i in range(ship_length):\n                    if board[start_row + i][start_col] == 'S':\n                        valid = False\n                        break\n                if not valid:\n                    if player == \"player\":\n                        print(\"Ships are overlapping. Try again.\")\n                    continue\n                for i in range(ship_length):\n                    board[start_row + i][start_col] = 'S'\n                return True  # Ship placed successfully\n\n    def setup_boards(self):\n        \"\"\"Sets up the player and computer boards with ships.\"\"\"\n        print(\"Player, place your ships:\")\n        for length in self.ship_lengths:\n            while not self.place_ship(self.player_board, length, \"player\"):\n                pass\n            self.print_board(self.player_board)\n\n        print(\"\\nComputer is placing ships...\")\n        for length in self.ship_lengths:\n            while not self.place_ship(self.computer_board, length, \"computer\"):\n                pass\n        print(\"Computer's ships placed.\")\n\n    def take_turn(self, board, player):\n        \"\"\"Takes a turn for the given player.\"\"\"\n        while True:\n            if player == \"player\":\n                target_row = input(f\"Player, enter row to strike (1-{self.board_size}): \")\n                target_col = input(f\"Player, enter column to strike (A-{chr(64+self.board_size)}): \").upper()\n                try:\n                    target_row = int(target_row) - 1\n                    target_col = ord(target_col) - ord('A')\n                    if not (0 <= target_row < self.board_size and 0 <= target_col < self.board_size):\n                        print(\"Invalid coordinates. Try again.\")\n                        continue\n                except (ValueError, TypeError):\n                    print(\"Invalid input. Try again.\")\n                    continue\n            else:\n                target_row = random.randint(0, self.board_size - 1)\n                target_col = random.randint(0, self.board_size - 1)\n                print(f\"Computer attacks {chr(target_col + ord('A'))}{target_row+1}\")\n\n            if board[target_row][target_col] == 'X' or board[target_row][target_col] == 'O':\n                if player == \"player\":\n                    print(\"You already attacked that location. Try again.\")\n                else:\n                    print(\"Computer already attacked that location.\")\n                continue\n\n            if board[target_row][target_col] == 'S':\n                print(\"Hit!\")\n                board[target_row][target_col] = 'X'  # Mark as hit\n                return True  # Hit\n            else:\n                print(\"Miss!\")\n                board[target_row][target_col] = 'O'  # Mark as miss\n                return False  # Miss\n\n    def check_win(self, board):\n        \"\"\"Checks if all ships have been sunk on the given board.\"\"\"\n        for row in board:\n            if 'S' in row:\n                return False  # Ships still present\n        return True  # All ships sunk\n\n    def play_game(self):\n        \"\"\"Main game loop.\"\"\"\n        self.setup_boards()\n\n        while True:\n            print(\"\\nPlayer's Board:\")\n            self.print_board(self.player_board)\n            print(\"\\nComputer's Board:\")\n            self.print_board(self.computer_board, hidden=True)\n\n            print(\"\\nPlayer's Turn:\")\n            self.take_turn(self.computer_board, \"player\")\n            if self.check_win(self.computer_board):\n                print(\"\\nPlayer wins!\")\n                print(\"Final Computer's Board:\")\n                self.print_board(self.computer_board, hidden=False)\n                break\n\n            print(\"\\nComputer's Turn:\")\n            self.take_turn(self.player_board, \"computer\")\n            if self.check_win(self.player_board):\n                print(\"\\nComputer wins!\")\n                print(\"Final Player's Board:\")\n                self.print_board(self.player_board)\n                break\n\nif __name__ == \"__main__\":\n    game = Battleship()\n    game.play_game()\n```",
    "7": "```python\nimport argparse\nimport time\nimport random\nimport os\n\n\nclass GameOfLife:\n    \"\"\"\n    Implements Conway's Game of Life.\n    \"\"\"\n\n    def __init__(self, width, height, initial_density=0.3):\n        \"\"\"\n        Initializes the game board.\n\n        Args:\n            width (int): The width of the board.\n            height (int): The height of the board.\n            initial_density (float): The probability of a cell being alive at the start (0.0 to 1.0).\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.board = self.create_initial_board(initial_density)\n\n    def create_initial_board(self, initial_density):\n        \"\"\"\n        Creates the initial game board with a random distribution of live cells.\n\n        Args:\n            initial_density (float): The probability of a cell being alive.\n\n        Returns:\n            list[list[int]]: A 2D list representing the game board.\n        \"\"\"\n        board = []\n        for _ in range(self.height):\n            row = [1 if random.random() < initial_density else 0 for _ in range(self.width)]\n            board.append(row)\n        return board\n\n    def get_neighbors(self, row, col):\n        \"\"\"\n        Gets the number of live neighbors for a given cell.\n\n        Args:\n            row (int): The row index of the cell.\n            col (int): The column index of the cell.\n\n        Returns:\n            int: The number of live neighbors.\n        \"\"\"\n        neighbors = 0\n        for i in range(max(0, row - 1), min(self.height, row + 2)):\n            for j in range(max(0, col - 1), min(self.width, col + 2)):\n                if (i, j) != (row, col):\n                    neighbors += self.board[i][j]\n        return neighbors\n\n    def update_board(self):\n        \"\"\"\n        Updates the game board to the next generation based on the rules of the Game of Life.\n        \"\"\"\n        new_board = []\n        for row in range(self.height):\n            new_row = []\n            for col in range(self.width):\n                neighbors = self.get_neighbors(row, col)\n                if self.board[row][col] == 1:  # Alive cell\n                    if neighbors < 2 or neighbors > 3:\n                        new_row.append(0)  # Dies\n                    else:\n                        new_row.append(1)  # Stays alive\n                else:  # Dead cell\n                    if neighbors == 3:\n                        new_row.append(1)  # Becomes alive\n                    else:\n                        new_row.append(0)  # Stays dead\n            new_board.append(new_row)\n        self.board = new_board\n\n    def display_board(self):\n        \"\"\"\n        Displays the game board in the console.\n        \"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n        for row in self.board:\n            print(''.join(['#' if cell == 1 else ' ' for cell in row]))\n\n    def run_simulation(self, num_generations, delay=0.1):\n        \"\"\"\n        Runs the simulation for a specified number of generations.\n\n        Args:\n            num_generations (int): The number of generations to simulate.\n            delay (float): The delay between generations in seconds.\n        \"\"\"\n        for _ in range(num_generations):\n            self.display_board()\n            self.update_board()\n            time.sleep(delay)\n\n\ndef main():\n    \"\"\"\n    Main function to parse command-line arguments and run the Game of Life simulation.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=\"Conway's Game of Life\")\n    parser.add_argument(\"--width\", type=int, default=60, help=\"Width of the board\")\n    parser.add_argument(\"--height\", type=int, default=30, help=\"Height of the board\")\n    parser.add_argument(\"--generations\", type=int, default=100, help=\"Number of generations to simulate\")\n    parser.add_argument(\"--density\", type=float, default=0.3, help=\"Initial density of live cells (0.0 to 1.0)\")\n    parser.add_argument(\"--delay\", type=float, default=0.1, help=\"Delay between generations in seconds\")\n\n    args = parser.parse_args()\n\n    game = GameOfLife(args.width, args.height, args.density)\n    game.run_simulation(args.generations, args.delay)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
    "8": "```python\nclass ConnectFour:\n    def __init__(self, rows=6, cols=7):\n        \"\"\"\n        Initializes the Connect Four game board.\n\n        Args:\n            rows (int): The number of rows in the board (default: 6).\n            cols (int): The number of columns in the board (default: 7).\n        \"\"\"\n        self.rows = rows\n        self.cols = cols\n        self.board = [[' ' for _ in range(cols)] for _ in range(rows)]\n        self.current_player = 'X'  # 'X' or 'O'\n        self.game_over = False\n\n    def print_board(self):\n        \"\"\"Prints the current state of the board to the console.\"\"\"\n        for row in self.board:\n            print('|' + '|'.join(row) + '|')\n        print('+' + '+'.join(['-'] * self.cols) + '+')\n        print(' ' + ' '.join(map(str, range(1, self.cols + 1))))\n\n    def is_valid_move(self, col):\n        \"\"\"\n        Checks if a move (column) is valid.\n\n        Args:\n            col (int): The column number (1-indexed).\n\n        Returns:\n            bool: True if the move is valid, False otherwise.\n        \"\"\"\n        if not (1 <= col <= self.cols):\n            return False\n        return self.board[0][col - 1] == ' '  # Check if the top row is empty\n\n    def drop_piece(self, col):\n        \"\"\"\n        Drops a piece into the specified column.\n\n        Args:\n            col (int): The column number (1-indexed).\n\n        Returns:\n            bool: True if the piece was successfully dropped, False otherwise (invalid move).\n        \"\"\"\n        if not self.is_valid_move(col):\n            return False\n\n        for row in range(self.rows - 1, -1, -1):\n            if self.board[row][col - 1] == ' ':\n                self.board[row][col - 1] = self.current_player\n                return True\n        return False  # Should not reach here if is_valid_move is used correctly.\n\n    def check_win(self):\n        \"\"\"\n        Checks if the current player has won the game.\n\n        Returns:\n            bool: True if the current player has won, False otherwise.\n        \"\"\"\n        # Check horizontal\n        for row in range(self.rows):\n            for col in range(self.cols - 3):\n                if (self.board[row][col] == self.current_player and\n                        self.board[row][col + 1] == self.current_player and\n                        self.board[row][col + 2] == self.current_player and\n                        self.board[row][col + 3] == self.current_player):\n                    return True\n\n        # Check vertical\n        for row in range(self.rows - 3):\n            for col in range(self.cols):\n                if (self.board[row][col] == self.current_player and\n                        self.board[row + 1][col] == self.current_player and\n                        self.board[row + 2][col] == self.current_player and\n                        self.board[row + 3][col] == self.current_player):\n                    return True\n\n        # Check positive diagonal\n        for row in range(self.rows - 3):\n            for col in range(self.cols - 3):\n                if (self.board[row][col] == self.current_player and\n                        self.board[row + 1][col + 1] == self.current_player and\n                        self.board[row + 2][col + 2] == self.current_player and\n                        self.board[row + 3][col + 3] == self.current_player):\n                    return True\n\n        # Check negative diagonal\n        for row in range(3, self.rows):\n            for col in range(self.cols - 3):\n                if (self.board[row][col] == self.current_player and\n                        self.board[row - 1][col + 1] == self.current_player and\n                        self.board[row - 2][col + 2] == self.current_player and\n                        self.board[row - 3][col + 3] == self.current_player):\n                    return True\n\n        return False\n\n    def check_draw(self):\n        \"\"\"\n        Checks if the board is full (draw).\n\n        Returns:\n            bool: True if the board is full, False otherwise.\n        \"\"\"\n        for col in range(self.cols):\n            if self.board[0][col] == ' ':\n                return False\n        return True\n\n    def switch_player(self):\n        \"\"\"Switches the current player to the other player.\"\"\"\n        self.current_player = 'O' if self.current_player == 'X' else 'X'\n\n    def play_turn(self):\n        \"\"\"Plays a single turn of the game.\"\"\"\n        self.print_board()\n        print(f\"Player {self.current_player}, it's your turn.\")\n\n        while True:\n            try:\n                col = int(input(f\"Enter a column (1-{self.cols}): \"))\n                if self.drop_piece(col):\n                    break\n                else:\n                    print(\"Invalid move. Try again.\")\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n        if self.check_win():\n            self.print_board()\n            print(f\"Player {self.current_player} wins!\")\n            self.game_over = True\n        elif self.check_draw():\n            self.print_board()\n            print(\"It's a draw!\")\n            self.game_over = True\n        else:\n            self.switch_player()\n\n    def play_game(self):\n        \"\"\"Starts and runs the Connect Four game until it's over.\"\"\"\n        print(\"Welcome to Connect Four!\")\n        while not self.game_over:\n            self.play_turn()\n        print(\"Game over.\")\n\n\nif __name__ == \"__main__\":\n    game = ConnectFour()\n    game.play_game()\n```",
    "9": "```python\nimport random\n\nclass Blackjack:\n    def __init__(self):\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n        self.player_score = 0\n        self.dealer_score = 0\n\n    def create_deck(self):\n        suits = [\"Hearts\", \"Diamonds\", \"Clubs\", \"Spades\"]\n        ranks = [\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\", \"Ace\"]\n        deck = []\n        for suit in suits:\n            for rank in ranks:\n                deck.append((rank, suit))\n        random.shuffle(deck)\n        return deck\n\n    def deal_card(self, hand):\n        card = self.deck.pop()\n        hand.append(card)\n        return card\n\n    def calculate_hand_value(self, hand):\n        value = 0\n        ace_count = 0\n        for card in hand:\n            rank = card[0]\n            if rank.isdigit():\n                value += int(rank)\n            elif rank in [\"Jack\", \"Queen\", \"King\"]:\n                value += 10\n            else:  # Ace\n                value += 11\n                ace_count += 1\n\n        while value > 21 and ace_count > 0:\n            value -= 10\n            ace_count -= 1\n\n        return value\n\n    def display_hand(self, hand, is_dealer=False, hide_first=False):\n        if is_dealer:\n            print(\"Dealer's hand:\")\n            if hide_first:\n                print(\"[Hidden Card]\", end=\" \")\n                for i in range(1, len(hand)):\n                    print(f\"{hand[i][0]} of {hand[i][1]}\", end=\" \")\n            else:\n                for card in hand:\n                    print(f\"{card[0]} of {card[1]}\", end=\" \")\n        else:\n            print(\"Your hand:\")\n            for card in hand:\n                print(f\"{card[0]} of {card[1]}\", end=\" \")\n        print()\n\n    def play_round(self):\n        # Deal initial hands\n        self.deal_card(self.player_hand)\n        self.deal_card(self.dealer_hand)\n        self.deal_card(self.player_hand)\n        self.deal_card(self.dealer_hand)\n\n        self.player_score = self.calculate_hand_value(self.player_hand)\n        self.dealer_score = self.calculate_hand_value(self.dealer_hand)\n\n        # Player's turn\n        self.display_hand(self.player_hand)\n        self.display_hand(self.dealer_hand, is_dealer=True, hide_first=True)\n\n        while self.player_score < 21:\n            action = input(\"Hit or Stand? (h/s): \").lower()\n            if action == 'h':\n                card = self.deal_card(self.player_hand)\n                self.player_score = self.calculate_hand_value(self.player_hand)\n                print(f\"You drew: {card[0]} of {card[1]}\")\n                self.display_hand(self.player_hand)\n                if self.player_score > 21:\n                    print(\"Bust!\")\n                    return \"dealer\" # Dealer wins\n            elif action == 's':\n                break  # Player stands\n            else:\n                print(\"Invalid action. Please enter 'h' or 's'.\")\n\n        # Dealer's turn\n        if self.player_score <= 21:\n            print(\"\\nDealer's turn:\")\n            self.display_hand(self.dealer_hand, is_dealer=True)\n            while self.dealer_score < 17:\n                card = self.deal_card(self.dealer_hand)\n                self.dealer_score = self.calculate_hand_value(self.dealer_hand)\n                print(f\"Dealer drew: {card[0]} of {card[1]}\")\n                self.display_hand(self.dealer_hand, is_dealer=True)\n                if self.dealer_score > 21:\n                    print(\"Dealer busts!\")\n                    return \"player\"  # Player wins\n\n        # Determine the winner\n        print(\"\\nFinal scores:\")\n        print(f\"Your score: {self.player_score}\")\n        print(f\"Dealer's score: {self.dealer_score}\")\n\n        if self.player_score > 21:\n            return \"dealer\"\n        elif self.dealer_score > 21:\n            return \"player\"\n        elif self.player_score > self.dealer_score:\n            return \"player\"\n        elif self.dealer_score > self.player_score:\n            return \"dealer\"\n        else:\n            return \"tie\"\n\n    def play_game(self):\n        while True:\n            self.deck = self.create_deck()  # Reset the deck\n            self.player_hand = []\n            self.dealer_hand = []\n            self.player_score = 0\n            self.dealer_score = 0\n\n            result = self.play_round()\n\n            if result == \"player\":\n                print(\"You win!\")\n            elif result == \"dealer\":\n                print(\"Dealer wins!\")\n            else:\n                print(\"It's a tie!\")\n\n            play_again = input(\"Play again? (y/n): \").lower()\n            if play_again != 'y':\n                break\n\nif __name__ == \"__main__\":\n    game = Blackjack()\n    game.play_game()\n```\n",
    "10": "```python\nimport random\n\nclass Hammurabi:\n    \"\"\"\n    A class representing the Hammurabi game.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the game state.\n        \"\"\"\n        self.year = 1\n        self.population = 100\n        self.grain_stores = 2800\n        self.acres_owned = 1000\n        self.bushels_per_acre = 3  # Initial yield\n        self.deaths = 0\n        self.starved = 0\n        self.immigrants = 0\n        self.plague = False\n\n    def play_year(self):\n        \"\"\"\n        Plays one year of the game.\n        \"\"\"\n        self.print_status()\n\n        # Plague check\n        if random.randint(1, 15) == 1:\n            self.plague = True\n            print(\"\\nA terrible plague has struck the city!\")\n            death_toll = int(self.population / 2)\n            self.population -= death_toll\n            self.deaths += death_toll\n            print(f\"{death_toll} people have died from the plague.\")\n        else:\n            self.plague = False\n\n        # Ask the player how many acres to buy/sell\n        acres_to_buy = self.get_acres_to_buy()\n        if acres_to_buy is None:\n            return False  # Player quit\n\n        # Ask the player how much grain to feed the people\n        grain_to_feed = self.get_grain_to_feed()\n        if grain_to_feed is None:\n            return False  # Player quit\n\n        # Ask the player how many acres to plant\n        acres_to_plant = self.get_acres_to_plant()\n        if acres_to_plant is None:\n            return False  # Player quit\n\n        # Calculate the outcome of the year\n        self.calculate_outcome(acres_to_buy, grain_to_feed, acres_to_plant)\n        return True\n\n    def print_status(self):\n        \"\"\"\n        Prints the current status of the game.\n        \"\"\"\n        print(f\"\\nYear {self.year}\")\n        print(f\"You are in year {self.year} of your ten-year rule.\")\n        print(f\"In the previous year {self.deaths} people starved to death.\")\n        print(f\"{self.immigrants} people entered the city.\")\n        print(f\"The population is now {self.population}.\")\n        print(f\"You own {self.acres_owned} acres of land.\")\n        print(f\"You harvested {self.bushels_per_acre} bushels per acre.\")\n        print(f\"Rats ate {self.calculate_rat_damage()} bushels of grain.\")\n        print(f\"Grain stores are {self.grain_stores} bushels.\")\n        print(f\"Land is trading at {self.calculate_land_price()} bushels per acre.\")\n\n    def get_acres_to_buy(self):\n        \"\"\"\n        Asks the player how many acres to buy or sell.\n        \"\"\"\n        while True:\n            try:\n                acres_to_buy = input(\"How many acres do you wish to buy/sell (enter a negative number to sell)? \")\n                if acres_to_buy.lower() == 'quit':\n                    return None\n                acres_to_buy = int(acres_to_buy)\n\n                if acres_to_buy > 0:  # Buying\n                    if acres_to_buy * self.calculate_land_price() > self.grain_stores:\n                        print(\"O Great Hammurabi, you do not have enough grain to buy that much land.\")\n                    else:\n                        return acres_to_buy\n                elif acres_to_buy < 0:  # Selling\n                    if abs(acres_to_buy) > self.acres_owned:\n                        print(\"O Great Hammurabi, you do not have that much land to sell.\")\n                    else:\n                        return acres_to_buy\n                else:\n                    return 0\n            except ValueError:\n                print(\"Invalid input. Please enter a number or 'quit'.\")\n\n    def get_grain_to_feed(self):\n        \"\"\"\n        Asks the player how much grain to feed the people.\n        \"\"\"\n        while True:\n            try:\n                grain_to_feed = input(\"How much grain do you wish to feed your people? \")\n                if grain_to_feed.lower() == 'quit':\n                    return None\n                grain_to_feed = int(grain_to_feed)\n\n                if grain_to_feed > self.grain_stores:\n                    print(\"O Great Hammurabi, you do not have that much grain.\")\n                elif grain_to_feed < 0:\n                    print(\"O Great Hammurabi, you cannot feed a negative amount of grain.\")\n                else:\n                    return grain_to_feed\n            except ValueError:\n                print(\"Invalid input. Please enter a number or 'quit'.\")\n\n    def get_acres_to_plant(self):\n        \"\"\"\n        Asks the player how many acres to plant.\n        \"\"\"\n        while True:\n            try:\n                acres_to_plant = input(\"How many acres do you wish to plant with grain? \")\n                if acres_to_plant.lower() == 'quit':\n                    return None\n                acres_to_plant = int(acres_to_plant)\n\n                if acres_to_plant > self.acres_owned:\n                    print(\"O Great Hammurabi, you do not have that much land.\")\n                elif acres_to_plant * 2 > self.grain_stores:\n                    print(\"O Great Hammurabi, you do not have enough grain to plant that much land.\")\n                elif acres_to_plant < 0:\n                    print(\"O Great Hammurabi, you cannot plant a negative amount of land.\")\n                else:\n                    return acres_to_plant\n            except ValueError:\n                print(\"Invalid input. Please enter a number or 'quit'.\")\n\n    def calculate_outcome(self, acres_to_buy, grain_to_feed, acres_to_plant):\n        \"\"\"\n        Calculates the outcome of the year based on the player's decisions.\n        \"\"\"\n        # Buy/Sell Land\n        land_price = self.calculate_land_price()\n        self.acres_owned += acres_to_buy\n        self.grain_stores -= acres_to_buy * land_price\n\n        # Feed the people\n        self.grain_stores -= grain_to_feed\n\n        # Calculate starvation\n        food_needed = self.population * 20  # Each person needs 20 bushels\n        if grain_to_feed < food_needed:\n            starved = (food_needed - grain_to_feed) // 20\n            if starved > self.population:\n                starved = self.population\n            self.starved = starved\n            self.deaths = starved\n            self.population -= starved\n            print(f\"{starved} people starved this year.\")\n        else:\n            self.starved = 0\n            self.deaths = 0\n\n        # Calculate immigration\n        self.immigrants = int((10 * (2 * acres_to_plant / self.population) + (50 * grain_to_feed / self.population) - self.deaths / 2))\n        if self.immigrants < 0:\n            self.immigrants = 0\n        self.population += self.immigrants\n\n        # Plant the crops\n        self.grain_stores -= acres_to_plant * 2  # Each acre requires 2 bushels to plant\n\n        # Harvest the crops\n        self.bushels_per_acre = random.randint(1, 6)\n        harvested = acres_to_plant * self.bushels_per_acre\n        self.grain_stores += harvested\n\n        # Rats eat grain\n        rat_damage = self.calculate_rat_damage()\n        self.grain_stores -= rat_damage\n        if self.grain_stores < 0:\n            self.grain_stores = 0 # Make sure grain doesn't go negative\n\n        # Check for rebellion\n        if self.starved > 0.45 * self.population:\n             print(\"O Great Hammurabi, you have been overthrown by the people due to your poor leadership!\")\n             exit()\n\n        self.year += 1\n\n    def calculate_land_price(self):\n        \"\"\"\n        Calculates the price of land.\n        \"\"\"\n        return random.randint(17, 23)\n\n    def calculate_rat_damage(self):\n        \"\"\"\n        Calculates the amount of grain eaten by rats.\n        \"\"\"\n        if random.randint(1, 10) <= 3:\n            rat_damage = int(self.grain_stores * random.uniform(0.1, 0.3))\n            print(f\"Rats ate {rat_damage} bushels of grain!\")\n            return rat_damage\n        else:\n            return 0\n\n    def is_game_over(self):\n        \"\"\"\n        Checks if the game is over.\n        \"\"\"\n        if self.year > 10:\n            return True\n        else:\n            return False\n\n    def calculate_final_score(self):\n        \"\"\"\n        Calculates the player's final score.\n        \"\"\"\n        acres_per_person = self.acres_owned / self.population\n        print(\"\\nO Great Hammurabi, your rule has come to an end.\")\n        print(f\"You ended with {self.population} people, {self.acres_owned} acres of land, and {self.grain_stores} bushels of grain.\")\n        print(f\"You owned {acres_per_person:.2f} acres per person.\")\n\n        if acres_per_person > 10:\n            print(\"A fantastic performance! Well done!\")\n        elif acres_per_person > 7:\n            print(\"Your performance could have been better, but adequate.\")\n        elif acres_per_person > 5:\n            print(\"Your performance was barely adequate.\")\n        else:\n            print(\"Due to this extreme mismanagement, you have not only been impeached and thrown out of office, but you have also been declared 'National Fink'.\")\n\n\ndef main():\n    \"\"\"\n    Main function to run the game.\n    \"\"\"\n    game = Hammurabi()\n\n    print(\"Welcome to Hammurabi!\")\n    print(\"You are the new ruler of the city-state of Sumer.\")\n    print(\"You will rule for 10 years.  Make wise decisions, lest you be overthrown.\")\n    print(\"You start with 100 people, 2800 bushels of grain, and 1000 acres of land.\")\n\n    while not game.is_game_over():\n        if not game.play_year():\n            print(\"Game Over.\")\n            return\n\n    game.calculate_final_score()\n\n\nif __name__ == \"__main__\":\n    main()\n```\n",
    "11": "```python\nimport random\n\nclass LightsOut:\n    \"\"\"\n    A class representing the Lights Out game.\n    \"\"\"\n\n    def __init__(self, size=5, initial_state=None):\n        \"\"\"\n        Initializes the Lights Out game.\n\n        Args:\n            size (int): The size of the grid (size x size). Default is 5.\n            initial_state (list): A 2D list representing the initial state of the board.\n                                  If None, a random initial state is generated.\n        \"\"\"\n        self.size = size\n        if initial_state is None:\n            self.board = self.generate_random_board()\n        else:\n            self.board = [row[:] for row in initial_state]  # Create a copy to avoid modifying the original\n            self.size = len(self.board) # Adjust size if initial state provided\n        self.moves = 0\n\n    def generate_random_board(self):\n        \"\"\"\n        Generates a random initial state for the board.\n        \"\"\"\n        board = [[random.randint(0, 1) for _ in range(self.size)] for _ in range(self.size)]\n        return board\n\n\n    def print_board(self):\n        \"\"\"\n        Prints the current state of the board to the console.\n        \"\"\"\n        for row in self.board:\n            print(\" \".join(['*' if cell else '.' for cell in row]))  # Use * for 'on' and . for 'off'\n\n    def toggle_cell(self, row, col):\n        \"\"\"\n        Toggles the state of a cell (0 -> 1 or 1 -> 0).\n        \"\"\"\n        if 0 <= row < self.size and 0 <= col < self.size:\n            self.board[row][col] = 1 - self.board[row][col]\n\n    def press_button(self, row, col):\n        \"\"\"\n        Simulates pressing a button at the given row and column, toggling the cell and its neighbors.\n        \"\"\"\n        self.toggle_cell(row, col)  # Toggle the cell itself\n        self.toggle_cell(row - 1, col)  # Toggle the cell above\n        self.toggle_cell(row + 1, col)  # Toggle the cell below\n        self.toggle_cell(row, col - 1)  # Toggle the cell to the left\n        self.toggle_cell(row, col + 1)  # Toggle the cell to the right\n        self.moves += 1\n\n    def is_solved(self):\n        \"\"\"\n        Checks if the game is solved (all cells are off).\n        \"\"\"\n        for row in self.board:\n            for cell in row:\n                if cell == 1:  # If any cell is on, the game is not solved\n                    return False\n        return True\n\n    def play(self):\n        \"\"\"\n        Plays the Lights Out game in the command line.\n        \"\"\"\n        print(\"Welcome to Lights Out!\")\n        self.print_board()\n\n        while not self.is_solved():\n            try:\n                row = int(input(\"Enter the row to press (0 to {}): \".format(self.size - 1)))\n                col = int(input(\"Enter the column to press (0 to {}): \".format(self.size - 1)))\n\n                if 0 <= row < self.size and 0 <= col < self.size:\n                    self.press_button(row, col)\n                    self.print_board()\n                    print(f\"Moves: {self.moves}\")\n                else:\n                    print(\"Invalid row or column. Please try again.\")\n            except ValueError:\n                print(\"Invalid input. Please enter integers.\")\n\n        print(\"Congratulations! You solved the puzzle in {} moves.\".format(self.moves))\n\n\nif __name__ == \"__main__\":\n    game = LightsOut()\n    game.play()\n```\n",
    "12": "```python\nimport time\nimport random\nimport os\n\nclass Pong:\n    \"\"\"\n    A command-line Pong game.\n    \"\"\"\n\n    def __init__(self, width=60, height=20, paddle_length=3, max_score=5):\n        \"\"\"\n        Initializes the Pong game.\n\n        Args:\n            width (int): The width of the game board.\n            height (int): The height of the game board.\n            paddle_length (int): The length of the paddles.\n            max_score (int): The maximum score to win the game.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.paddle_length = paddle_length\n        self.max_score = max_score\n\n        # Initialize game state\n        self.ball_x = width // 2\n        self.ball_y = height // 2\n        self.ball_dx = random.choice([-1, 1])  # Ball direction x\n        self.ball_dy = random.choice([-1, 1])  # Ball direction y\n\n        self.paddle1_y = height // 2 - paddle_length // 2  # Player 1 (left)\n        self.paddle2_y = height // 2 - paddle_length // 2  # Player 2 (right)\n\n        self.score1 = 0\n        self.score2 = 0\n\n        self.game_over = False\n\n    def _draw_board(self):\n        \"\"\"\n        Draws the game board in the console.\n        \"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n\n        # Create the board as a list of strings\n        board = []\n        for _ in range(self.height):\n            board.append([' '] * self.width)\n\n        # Draw paddles\n        for i in range(self.paddle_length):\n            board[self.paddle1_y + i][0] = '|'\n            board[self.paddle2_y + i][self.width - 1] = '|'\n\n        # Draw ball\n        board[self.ball_y][self.ball_x] = 'O'\n\n        # Print the board\n        print(\"-\" * self.width)\n        for row in board:\n            print(\"\".join(row))\n        print(\"-\" * self.width)\n\n        # Print scores\n        print(f\"Player 1: {self.score1}  |  Player 2: {self.score2}\")\n\n\n    def _move_ball(self):\n        \"\"\"\n        Moves the ball and handles collisions.\n        \"\"\"\n        self.ball_x += self.ball_dx\n        self.ball_y += self.ball_dy\n\n        # Bounce off top and bottom walls\n        if self.ball_y <= 0 or self.ball_y >= self.height - 1:\n            self.ball_dy *= -1\n\n        # Bounce off paddles\n        if self.ball_x == 1 and self.paddle1_y <= self.ball_y < self.paddle1_y + self.paddle_length:\n            self.ball_dx *= -1\n        elif self.ball_x == self.width - 2 and self.paddle2_y <= self.ball_y < self.paddle2_y + self.paddle_length:\n            self.ball_dx *= -1\n\n        # Score points\n        if self.ball_x <= 0:\n            self.score2 += 1\n            self._reset_ball()\n        elif self.ball_x >= self.width - 1:\n            self.score1 += 1\n            self._reset_ball()\n\n        # Check for game over\n        if self.score1 >= self.max_score or self.score2 >= self.max_score:\n            self.game_over = True\n\n\n    def _reset_ball(self):\n        \"\"\"\n        Resets the ball to the center of the board.\n        \"\"\"\n        self.ball_x = self.width // 2\n        self.ball_y = self.height // 2\n        self.ball_dx = random.choice([-1, 1])\n        self.ball_dy = random.choice([-1, 1])\n\n\n    def _move_paddle1(self, direction):\n        \"\"\"\n        Moves paddle 1 up or down.\n\n        Args:\n            direction (str): \"up\" or \"down\".\n        \"\"\"\n        if direction == \"up\" and self.paddle1_y > 0:\n            self.paddle1_y -= 1\n        elif direction == \"down\" and self.paddle1_y + self.paddle_length < self.height:\n            self.paddle1_y += 1\n\n\n    def _move_paddle2(self, direction):\n        \"\"\"\n        Moves paddle 2 up or down.\n\n        Args:\n            direction (str): \"up\" or \"down\".\n        \"\"\"\n        if direction == \"up\" and self.paddle2_y > 0:\n            self.paddle2_y -= 1\n        elif direction == \"down\" and self.paddle2_y + self.paddle_length < self.height:\n            self.paddle2_y += 1\n\n\n    def play(self):\n        \"\"\"\n        Starts and runs the Pong game.\n        \"\"\"\n        print(\"Welcome to Pong!\")\n        print(\"Player 1 (left): 'w' to move up, 's' to move down\")\n        print(\"Player 2 (right): 'o' to move up, 'l' to move down\")\n        print(\"Press 'q' to quit.\")\n\n        while not self.game_over:\n            self._draw_board()\n            self._move_ball()\n\n            # Get player input\n            player1_move = input(\"Player 1 (w/s): \").lower()\n            player2_move = input(\"Player 2 (o/l): \").lower()\n\n            # Handle player input\n            if player1_move == \"w\":\n                self._move_paddle1(\"up\")\n            elif player1_move == \"s\":\n                self._move_paddle1(\"down\")\n            if player2_move == \"o\":\n                self._move_paddle2(\"up\")\n            elif player2_move == \"l\":\n                self._move_paddle2(\"down\")\n            elif player1_move == \"q\" or player2_move == \"q\":\n                print(\"Quitting the game.\")\n                self.game_over = True\n                break\n\n            time.sleep(0.1)  # Control game speed\n\n        self._draw_board()  # Draw final board\n        if self.score1 > self.score2:\n            print(\"Player 1 wins!\")\n        else:\n            print(\"Player 2 wins!\")\n\n\nif __name__ == \"__main__\":\n    game = Pong()\n    game.play()\n```",
    "13": "```python\nimport random\nimport os\n\nclass Tetris:\n    \"\"\"\n    A command-line Tetris game.\n    \"\"\"\n\n    WIDTH = 10\n    HEIGHT = 20\n    PIECES = [\n        [[1, 1, 1, 1]],  # I\n        [[1, 1], [1, 1]],  # O\n        [[0, 1, 1], [1, 1, 0]],  # Z\n        [[1, 1, 0], [0, 1, 1]],  # S\n        [[1, 0, 0], [1, 1, 1]],  # L\n        [[0, 0, 1], [1, 1, 1]],  # J\n        [[0, 1, 0], [1, 1, 1]]   # T\n    ]\n    COLORS = [\n        0,  # Empty\n        1,  # I - Cyan\n        2,  # O - Yellow\n        3,  # Z - Red\n        4,  # S - Green\n        5,  # L - Orange\n        6,  # J - Blue\n        7   # T - Purple\n    ]\n\n    def __init__(self):\n        self.board = [[0] * self.WIDTH for _ in range(self.HEIGHT)]\n        self.current_piece = None\n        self.current_x = 0\n        self.current_y = 0\n        self.game_over = False\n        self.score = 0\n        self.level = 1\n        self.lines_cleared = 0\n        self.next_piece = random.choice(self.PIECES)\n        self.new_piece()\n\n    def new_piece(self):\n        \"\"\"\n        Generates a new piece at the top of the board.\n        \"\"\"\n        self.current_piece = self.next_piece\n        self.next_piece = random.choice(self.PIECES)\n        self.current_x = self.WIDTH // 2 - len(self.current_piece[0]) // 2\n        self.current_y = 0\n        if not self.is_valid_position(self.current_piece, self.current_x, self.current_y):\n            self.game_over = True\n\n    def rotate(self):\n        \"\"\"\n        Rotates the current piece clockwise.\n        \"\"\"\n        rotated_piece = list(zip(*self.current_piece[::-1]))\n        if self.is_valid_position(rotated_piece, self.current_x, self.current_y):\n            self.current_piece = rotated_piece\n\n    def move(self, dx):\n        \"\"\"\n        Moves the current piece horizontally.\n        \"\"\"\n        new_x = self.current_x + dx\n        if self.is_valid_position(self.current_piece, new_x, self.current_y):\n            self.current_x = new_x\n\n    def drop(self):\n        \"\"\"\n        Moves the current piece down one row.\n        \"\"\"\n        new_y = self.current_y + 1\n        if self.is_valid_position(self.current_piece, self.current_x, new_y):\n            self.current_y = new_y\n        else:\n            self.freeze()\n            self.clear_lines()\n            if not self.game_over:\n                self.new_piece()\n\n    def hard_drop(self):\n        \"\"\"\n        Drops the piece to the lowest possible position.\n        \"\"\"\n        while not self.game_over:\n            new_y = self.current_y + 1\n            if self.is_valid_position(self.current_piece, self.current_x, new_y):\n                self.current_y = new_y\n            else:\n                self.freeze()\n                self.clear_lines()\n                if not self.game_over:\n                    self.new_piece()\n                break\n\n    def is_valid_position(self, piece, x, y):\n        \"\"\"\n        Checks if a piece can be placed at the given position.\n        \"\"\"\n        for i, row in enumerate(piece):\n            for j, cell in enumerate(row):\n                if cell:\n                    board_x = x + j\n                    board_y = y + i\n                    if board_x < 0 or board_x >= self.WIDTH or board_y >= self.HEIGHT:\n                        return False\n                    if board_y >= 0 and self.board[board_y][board_x] != 0:\n                        return False\n        return True\n\n    def freeze(self):\n        \"\"\"\n        Places the current piece on the board.\n        \"\"\"\n        for i, row in enumerate(self.current_piece):\n            for j, cell in enumerate(row):\n                if cell:\n                    self.board[self.current_y + i][self.current_x + j] = self.COLORS[self.PIECES.index(self.current_piece) + 1] # Assign color based on piece index\n\n    def clear_lines(self):\n        \"\"\"\n        Clears any full lines on the board.\n        \"\"\"\n        lines_cleared = 0\n        new_board = []\n        for row in self.board:\n            if all(cell != 0 for cell in row):\n                lines_cleared += 1\n            else:\n                new_board.append(row)\n\n        for _ in range(lines_cleared):\n            new_board.insert(0, [0] * self.WIDTH)\n\n        self.board = new_board\n        self.lines_cleared += lines_cleared\n        self.update_score(lines_cleared)\n        self.update_level()\n\n    def update_score(self, lines_cleared):\n        \"\"\"\n        Updates the score based on the number of lines cleared.\n        \"\"\"\n        if lines_cleared == 1:\n            self.score += 40 * self.level\n        elif lines_cleared == 2:\n            self.score += 100 * self.level\n        elif lines_cleared == 3:\n            self.score += 300 * self.level\n        elif lines_cleared == 4:\n            self.score += 1200 * self.level\n\n    def update_level(self):\n        \"\"\"\n        Updates the level based on the number of lines cleared.\n        \"\"\"\n        self.level = (self.lines_cleared // 10) + 1\n\n    def draw(self):\n        \"\"\"\n        Draws the current state of the game.\n        \"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the screen\n        print(\"Tetris\")\n        print(f\"Score: {self.score}  Level: {self.level}  Lines: {self.lines_cleared}\")\n\n        # Draw the board\n        for i in range(self.HEIGHT):\n            row_str = \"|\"\n            for j in range(self.WIDTH):\n                cell = self.board[i][j]\n                if cell == 0:\n                    row_str += \"  \"\n                else:\n                    row_str += str(cell) + \" \"\n            row_str += \"|\"\n            print(row_str)\n\n        # Draw the bottom border\n        print(\"-\" * (self.WIDTH * 2 + 2))\n\n        # Draw the next piece\n        print(\"\\nNext Piece:\")\n        for row in self.next_piece:\n            row_str = \"\"\n            for cell in row:\n                if cell == 0:\n                    row_str += \"  \"\n                else:\n                    row_str += str(self.COLORS[self.PIECES.index(self.next_piece) + 1]) + \" \"\n            print(row_str)\n\n    def run(self):\n        \"\"\"\n        Runs the main game loop.\n        \"\"\"\n        while not self.game_over:\n            self.draw()\n            action = input(\"Action (a=left, d=right, s=down, w=rotate, space=hard drop, q=quit): \").lower()\n\n            if action == 'a':\n                self.move(-1)\n            elif action == 'd':\n                self.move(1)\n            elif action == 's':\n                self.drop()\n            elif action == 'w':\n                self.rotate()\n            elif action == ' ':\n                self.hard_drop()\n            elif action == 'q':\n                self.game_over = True\n            else:\n                print(\"Invalid action.\")\n\n            if not self.game_over:\n                self.drop()  # Automatically drop the piece\n\n        self.draw()\n        print(\"Game Over! Final Score:\", self.score)\n\n\nif __name__ == '__main__':\n    game = Tetris()\n    game.run()\n```",
    "14": "```python\nimport random\nimport time\nimport math\nimport sys\n\nclass AsteroidGame:\n    \"\"\"\n    A simple Asteroid game implemented in the command line.\n    \"\"\"\n\n    def __init__(self, width=80, height=20, asteroid_count=5, max_shots=3):\n        \"\"\"\n        Initializes the game.\n\n        Args:\n            width (int): The width of the game board.\n            height (int): The height of the game board.\n            asteroid_count (int): The number of asteroids in the game.\n            max_shots (int): The maximum number of simultaneous shots allowed.\n        \"\"\"\n\n        self.width = width\n        self.height = height\n        self.asteroid_count = asteroid_count\n        self.max_shots = max_shots\n\n        self.ship_x = width // 2\n        self.ship_y = height // 2\n        self.ship_char = \"^\"  # Ship represented by a caret\n\n        self.asteroids = []\n        self.shots = []\n\n        self.game_over = False\n        self.score = 0\n\n        self._initialize_asteroids()\n\n    def _initialize_asteroids(self):\n        \"\"\"\n        Creates the initial set of asteroids at random positions.\n        \"\"\"\n        for _ in range(self.asteroid_count):\n            x = random.randint(0, self.width - 1)\n            y = random.randint(0, self.height - 1)\n            # Ensure asteroids aren't too close to the ship initially\n            while abs(x - self.ship_x) < self.width // 4 and abs(y - self.ship_y) < self.height // 4:\n                 x = random.randint(0, self.width - 1)\n                 y = random.randint(0, self.height - 1)\n\n            self.asteroids.append({\n                'x': x,\n                'y': y,\n                'char': 'O',  # Asteroids represented by 'O'\n                'x_velocity': random.choice([-1, 1]),\n                'y_velocity': random.choice([-1, 1])\n            })\n\n    def _draw_board(self):\n        \"\"\"\n        Draws the game board in the console.\n        \"\"\"\n        board = [[' ' for _ in range(self.width)] for _ in range(self.height)]\n\n        # Draw asteroids\n        for asteroid in self.asteroids:\n            board[asteroid['y']][asteroid['x']] = asteroid['char']\n\n        # Draw shots\n        for shot in self.shots:\n            board[shot['y']][shot['x']] = '*'  # Shots represented by '*'\n\n        # Draw ship\n        board[self.ship_y][self.ship_x] = self.ship_char\n\n        # Print the board\n        for row in board:\n            print(\"\".join(row))\n\n        # Print score and instructions\n        print(f\"Score: {self.score}\")\n        print(\"Controls: A (Left), D (Right), W (Shoot), Q (Quit)\")\n\n    def _move_ship(self, direction):\n        \"\"\"\n        Moves the ship left or right.\n\n        Args:\n            direction (str): 'left' or 'right'.\n        \"\"\"\n        if direction == 'left':\n            self.ship_x = max(0, self.ship_x - 1)\n        elif direction == 'right':\n            self.ship_x = min(self.width - 1, self.ship_x + 1)\n\n    def _move_asteroids(self):\n        \"\"\"\n        Moves the asteroids based on their velocity.\n        Wraps around the edges of the screen.\n        \"\"\"\n        for asteroid in self.asteroids:\n            asteroid['x'] += asteroid['x_velocity']\n            asteroid['y'] += asteroid['y_velocity']\n\n            # Wrap around the edges\n            if asteroid['x'] < 0:\n                asteroid['x'] = self.width - 1\n            elif asteroid['x'] >= self.width:\n                asteroid['x'] = 0\n            if asteroid['y'] < 0:\n                asteroid['y'] = self.height - 1\n            elif asteroid['y'] >= self.height:\n                asteroid['y'] = 0\n\n    def _move_shots(self):\n        \"\"\"\n        Moves the shots upwards. Removes shots that go off-screen.\n        \"\"\"\n        for shot in self.shots:\n            shot['y'] -= 1  # Move upwards\n        self.shots = [shot for shot in self.shots if shot['y'] >= 0] # Remove off-screen shots\n\n    def _shoot(self):\n        \"\"\"\n        Fires a shot from the ship's position.\n        \"\"\"\n        if len(self.shots) < self.max_shots:\n            self.shots.append({'x': self.ship_x, 'y': self.ship_y - 1})\n\n    def _check_collisions(self):\n        \"\"\"\n        Checks for collisions between shots and asteroids, and between the ship and asteroids.\n        \"\"\"\n        # Shot-Asteroid collisions\n        for shot in list(self.shots): # Iterate over a *copy* of the list\n            for asteroid in list(self.asteroids): #Iterate over a *copy* of the list\n                if abs(shot['x'] - asteroid['x']) <= 0 and abs(shot['y'] - asteroid['y']) <= 0:\n                    self.asteroids.remove(asteroid)\n                    self.shots.remove(shot)\n                    self.score += 10\n                    break # Avoid double-counting collisions\n\n        # Ship-Asteroid collisions\n        for asteroid in self.asteroids:\n            if abs(self.ship_x - asteroid['x']) <= 0 and abs(self.ship_y - asteroid['y']) <= 0:\n                self.game_over = True\n                break\n\n        #Handle game winning condition\n        if not self.asteroids:\n            print(\"You Win!\")\n            self.game_over = True\n\n    def play(self):\n        \"\"\"\n        The main game loop.\n        \"\"\"\n        while not self.game_over:\n            self._draw_board()\n\n            # Get player input\n            action = input(\"Enter action (A=Left, D=Right, W=Shoot, Q=Quit): \").upper()\n\n            # Process input\n            if action == 'A':\n                self._move_ship('left')\n            elif action == 'D':\n                self._move_ship('right')\n            elif action == 'W':\n                self._shoot()\n            elif action == 'Q':\n                self.game_over = True\n            else:\n                print(\"Invalid input.\")\n\n            # Update game state\n            self._move_asteroids()\n            self._move_shots()\n            self._check_collisions()\n\n            # Add a small delay for better visibility\n            time.sleep(0.1)\n\n        print(\"Game Over! Final Score:\", self.score)\n\n\nif __name__ == '__main__':\n    game = AsteroidGame()\n    game.play()\n```",
    "15": "```python\nimport random\nimport time\n\nclass Boggle:\n    \"\"\"\n    Represents a Boggle game.\n    \"\"\"\n\n    def __init__(self, size=4, time_limit=180):\n        \"\"\"\n        Initializes a Boggle game.\n\n        Args:\n            size (int): The size of the Boggle board (e.g., 4 for a 4x4 board).\n            time_limit (int): The time limit for the game in seconds.\n        \"\"\"\n        self.size = size\n        self.time_limit = time_limit\n        self.board = self.generate_board()\n        self.words = set()  # Store valid words found by the player\n        self.start_time = None\n        self.end_time = None\n        self.dictionary = self.load_dictionary(\"words.txt\") # Load a dictionary file\n\n    def load_dictionary(self, filepath):\n      \"\"\"Loads a dictionary from a text file.\n\n      Args:\n          filepath (str): The path to the dictionary file (one word per line).\n\n      Returns:\n          set: A set containing all words from the dictionary.\n      \"\"\"\n      try:\n          with open(filepath, 'r') as f:\n              words = set(word.strip().upper() for word in f)\n          return words\n      except FileNotFoundError:\n          print(f\"Error: Dictionary file '{filepath}' not found.\")\n          return set()\n\n    def generate_board(self):\n        \"\"\"\n        Generates a random Boggle board.\n\n        Returns:\n            list[list[str]]: A 2D list representing the Boggle board.\n        \"\"\"\n        dice = [\n            \"RIFOBX\", \"IFEHES\", \"DISEAS\", \"UIHMNU\", \"MHLRNO\", \"DLINOR\",\n            \"HZLNOR\", \"AFSIRSY\", \"PORSEU\", \"TLAEPY\", \"GNILRU\", \"WABPDQ\",\n            \"LNSEDT\", \"XLDERA\", \"QUMBMI\", \"AAEEGN\"\n        ]\n        board = []\n        random.shuffle(dice)\n        for i in range(self.size):\n            row = []\n            for j in range(self.size):\n                row.append(random.choice(dice[i * self.size + j]))\n            board.append(row)\n        return board\n\n    def print_board(self):\n        \"\"\"\n        Prints the Boggle board to the console.\n        \"\"\"\n        for row in self.board:\n            print(\" \".join(row))\n\n    def is_valid_word(self, word):\n        \"\"\"\n        Checks if a word is a valid word in the dictionary.\n\n        Args:\n            word (str): The word to check.\n\n        Returns:\n            bool: True if the word is valid, False otherwise.\n        \"\"\"\n        return word.upper() in self.dictionary and len(word) >= 3\n\n    def find_word(self, word):\n      \"\"\"\n      Checks if a word can be found on the Boggle board using adjacency rules (no reusing letters).\n\n      Args:\n          word (str): The word to search for.\n\n      Returns:\n          bool: True if the word is found, False otherwise.\n      \"\"\"\n\n      def solve(row, col, word_index, path):\n          if word_index == len(word):\n              return True  # Found the entire word\n\n          if row < 0 or row >= self.size or col < 0 or col >= self.size or (row, col) in path or self.board[row][col].upper() != word[word_index].upper():\n              return False  # Invalid move\n\n          # Explore neighbors\n          neighbors = [\n              (row - 1, col - 1), (row - 1, col), (row - 1, col + 1),\n              (row, col - 1), (row, col + 1),\n              (row + 1, col - 1), (row + 1, col), (row + 1, col + 1)\n          ]\n\n          for nr, nc in neighbors:\n              if solve(nr, nc, word_index + 1, path + [(row, col)]):\n                  return True\n\n          return False  # No path found from this cell\n\n      # Check all cells on the board as starting points\n      for row in range(self.size):\n          for col in range(self.size):\n              if solve(row, col, 0, []):\n                  return True\n\n      return False\n\n    def play(self):\n        \"\"\"\n        Plays the Boggle game.\n        \"\"\"\n        print(\"Welcome to Boggle!\")\n        self.print_board()\n        self.start_time = time.time()\n        self.end_time = self.start_time + self.time_limit\n\n        while time.time() < self.end_time:\n            remaining_time = int(self.end_time - time.time())\n            print(f\"Time remaining: {remaining_time} seconds\")\n            word = input(\"Enter a word (or type 'quit' to end): \").strip()\n\n            if word.lower() == \"quit\":\n                break\n\n            if self.is_valid_word(word) and self.find_word(word):\n                if word.upper() not in self.words:\n                    self.words.add(word.upper())\n                    print(\"Valid word!\")\n                else:\n                    print(\"You already found that word.\")\n            else:\n                print(\"Invalid word.\")\n\n        print(\"Time's up!\")\n        self.end_game()\n\n    def end_game(self):\n        \"\"\"\n        Ends the Boggle game and displays the results.\n        \"\"\"\n        print(\"Game Over!\")\n        print(\"Words you found:\")\n        for word in sorted(self.words):\n            print(word)\n\n        score = self.calculate_score()\n        print(f\"Your score: {score}\")\n\n    def calculate_score(self):\n        \"\"\"\n        Calculates the player's score based on the words they found.\n\n        Returns:\n            int: The player's score.\n        \"\"\"\n        score = 0\n        for word in self.words:\n            word_length = len(word)\n            if word_length == 3 or word_length == 4:\n                score += 1\n            elif word_length == 5:\n                score += 2\n            elif word_length == 6:\n                score += 3\n            elif word_length == 7:\n                score += 5\n            elif word_length >= 8:\n                score += 11\n        return score\n\n\nif __name__ == \"__main__\":\n    # Create a dummy words.txt file if it doesn't exist.\n    try:\n        with open(\"words.txt\", \"r\") as f:\n            pass  # File exists, do nothing\n    except FileNotFoundError:\n        with open(\"words.txt\", \"w\") as f:\n            f.write(\"CAT\\n\")\n            f.write(\"DOG\\n\")\n            f.write(\"TEA\\n\")\n            f.write(\"EAT\\n\")\n            f.write(\"RAIN\\n\")\n            f.write(\"TRAIN\\n\")\n            f.write(\"EXAMPLE\\n\")\n            f.write(\"ANOTHER\\n\")\n            f.write(\"DICTIONARY\\n\")\n\n    game = Boggle(size=4, time_limit=60)  # Adjust size and time limit as needed\n    game.play()\n```",
    "16": "```python\nimport random\nimport time\nimport os\n\nclass PacMan:\n    def __init__(self, width=15, height=10, num_ghosts=2):\n        self.width = width\n        self.height = height\n        self.num_ghosts = num_ghosts\n        self.grid = [['.' for _ in range(width)] for _ in range(height)]\n        self.pacman_x = width // 2\n        self.pacman_y = height // 2\n        self.grid[self.pacman_y][self.pacman_x] = 'P'\n        self.ghosts = []\n        self.food = width * height - 1 # Initial food count (excluding Pac-Man's starting position)\n        self.score = 0\n        self.game_over = False\n        self.won = False\n        self.ghost_chars = ['G', 'H', 'I', 'J'] # Allow for up to 4 ghosts, expand if needed\n\n        # Initial ghost placement (avoiding Pac-Man)\n        for i in range(num_ghosts):\n            while True:\n                x = random.randint(0, width - 1)\n                y = random.randint(0, height - 1)\n                if (x, y) != (self.pacman_x, self.pacman_y):\n                    self.ghosts.append({'x': x, 'y': y, 'char': self.ghost_chars[i % len(self.ghost_chars)]})\n                    self.grid[y][x] = self.ghosts[-1]['char']\n                    break\n        self.display_delay = 0.2  # Delay between moves for better viewing\n\n    def display(self):\n        os.system('cls' if os.name == 'nt' else 'clear') # Clear the screen\n        print(\"-\" * (self.width + 2)) # Top border\n        for row in self.grid:\n            print(\"|\" + \"\".join(row) + \"|\") # Side borders\n        print(\"-\" * (self.width + 2)) # Bottom border\n        print(f\"Score: {self.score}, Food remaining: {self.food}\")\n\n\n    def move_pacman(self, direction):\n        new_x = self.pacman_x\n        new_y = self.pacman_y\n\n        if direction == 'w':\n            new_y -= 1\n        elif direction == 's':\n            new_y += 1\n        elif direction == 'a':\n            new_x -= 1\n        elif direction == 'd':\n            new_x += 1\n        else:\n            return  # Invalid move\n\n        if 0 <= new_x < self.width and 0 <= new_y < self.height:\n            # Clear Pac-Man's old position\n            self.grid[self.pacman_y][self.pacman_x] = '.'\n\n            # Check for collision with a ghost\n            for ghost in self.ghosts:\n                if new_x == ghost['x'] and new_y == ghost['y']:\n                    self.game_over = True\n                    return\n\n            # Update Pac-Man's position\n            self.pacman_x = new_x\n            self.pacman_y = new_y\n\n            # Check if Pac-Man eats food\n            if self.grid[self.pacman_y][self.pacman_x] == '.':\n                self.score += 10\n                self.food -= 1\n\n            # Place Pac-Man in the new position\n            self.grid[self.pacman_y][self.pacman_x] = 'P'\n\n            if self.food == 0:\n                self.won = True\n                self.game_over = True\n\n    def move_ghosts(self):\n        for ghost in self.ghosts:\n            old_x = ghost['x']\n            old_y = ghost['y']\n            self.grid[old_y][old_x] = '.'\n\n            possible_moves = []\n            if old_x > 0:\n                possible_moves.append(('a', old_x - 1, old_y))\n            if old_x < self.width - 1:\n                possible_moves.append(('d', old_x + 1, old_y))\n            if old_y > 0:\n                possible_moves.append(('w', old_x, old_y - 1))\n            if old_y < self.height - 1:\n                possible_moves.append(('s', old_x, old_y + 1))\n\n            # Prioritize moving towards Pac-Man\n            best_move = None\n            min_distance = float('inf')\n            for move, new_x, new_y in possible_moves:\n                distance = abs(new_x - self.pacman_x) + abs(new_y - self.pacman_y)\n                if distance < min_distance:\n                    min_distance = distance\n                    best_move = (move, new_x, new_y)\n\n            if best_move:\n                _, new_x, new_y = best_move\n            else: #If no valid moves, stay put\n                new_x = old_x\n                new_y = old_y\n\n            # Check for collision with Pac-Man\n            if new_x == self.pacman_x and new_y == self.pacman_y:\n                self.game_over = True\n                return\n\n            # Check for collision with other ghosts\n            for other_ghost in self.ghosts:\n                if ghost != other_ghost and new_x == other_ghost['x'] and new_y == other_ghost['y']:\n                    new_x = old_x  # Stay put if collision with other ghost\n                    new_y = old_y\n                    break\n\n            ghost['x'] = new_x\n            ghost['y'] = new_y\n            self.grid[new_y][new_x] = ghost['char']\n\n\n    def play(self):\n        while not self.game_over:\n            self.display()\n            direction = input(\"Enter move (w/a/s/d): \").lower()\n            self.move_pacman(direction)\n            if self.game_over:\n                break  # Exit loop immediately if Pac-Man dies during move_pacman\n            self.move_ghosts()\n            time.sleep(self.display_delay)\n\n\n\n        self.display() # Display final state\n        if self.won:\n            print(\"You win!\")\n        else:\n            print(\"Game over!\")\n        print(f\"Final Score: {self.score}\")\n\n\nif __name__ == '__main__':\n    game = PacMan()\n    game.play()\n```",
    "17": "```python\nimport random\nimport time\nimport os\n\nclass DinosaurRunner:\n    \"\"\"\n    A command-line Dinosaur Runner game.\n    \"\"\"\n\n    def __init__(self, width=80, initial_speed=1):\n        \"\"\"\n        Initializes the game.\n\n        Args:\n            width (int): The width of the game screen.\n            initial_speed (float): The initial speed of the game (obstacles moving towards the dinosaur).\n        \"\"\"\n        self.width = width\n        self.dinosaur_position = 5  # Fixed position of the dinosaur from the left\n        self.obstacle_position = width - 5  # Starting position of the obstacle from the right\n        self.obstacle_height = random.choice([1, 2])  # 1 for low, 2 for high\n        self.score = 0\n        self.game_over = False\n        self.speed = initial_speed\n        self.ground = \"_\" * width\n        self.dinosaur = \"D\"\n        self.space = \" \"\n        self.obstacle_char = \"X\"\n        self.jump_height = 3\n        self.is_jumping = False\n        self.jump_counter = 0\n        self.clear_screen = lambda: os.system('cls' if os.name == 'nt' else 'clear')\n\n    def update(self):\n        \"\"\"\n        Updates the game state.\n        \"\"\"\n        if self.game_over:\n            return\n\n        # Move the obstacle\n        self.obstacle_position -= self.speed\n        if self.obstacle_position < 0:\n            self.obstacle_position = self.width - 1\n            self.obstacle_height = random.choice([1, 2])\n            self.score += 1\n            self.speed += 0.01  # Increase speed gradually\n\n\n        # Handle jumping\n        if self.is_jumping:\n            self.jump_counter += 1\n            if self.jump_counter > self.jump_height:\n                self.is_jumping = False\n                self.jump_counter = 0\n\n        # Check for collision\n        if self.obstacle_position <= self.dinosaur_position + 1 and self.obstacle_position >= self.dinosaur_position -1:\n            if not self.is_jumping and self.obstacle_height == 2:\n                self.game_over = True\n            if self.is_jumping and self.obstacle_height == 1:\n                self.game_over = True\n\n\n    def render(self):\n        \"\"\"\n        Renders the game screen.\n        \"\"\"\n        self.clear_screen()\n        screen = list(self.ground)\n\n        # Draw the dinosaur\n        dinosaur_height = self.jump_counter if self.is_jumping else 0\n        dinosaur_row = len(self.ground.splitlines()) - 1 - dinosaur_height\n        screen[self.dinosaur_position] = self.dinosaur\n\n        # Draw the obstacle\n        obstacle_row = len(self.ground.splitlines()) - 1\n        if self.obstacle_height == 2:  # High obstacle, need to skip a row\n            obstacle_row -= 1\n        screen[int(self.obstacle_position)] = self.obstacle_char\n\n        # Print the screen\n        print(\"\".join(screen))\n        print(f\"Score: {self.score}\")\n\n        if self.game_over:\n            print(\"Game Over!\")\n\n    def jump(self):\n        \"\"\"\n        Initiates a jump if the dinosaur is not already jumping.\n        \"\"\"\n        if not self.is_jumping:\n            self.is_jumping = True\n            self.jump_counter = 0\n\n    def play(self):\n        \"\"\"\n        Starts the game loop.\n        \"\"\"\n        while not self.game_over:\n            start_time = time.time()\n            self.update()\n            self.render()\n\n            # Control the game speed (frame rate)\n            elapsed_time = time.time() - start_time\n            sleep_time = max(0, 0.1 - elapsed_time)  # Target frame rate: 10 FPS\n            time.sleep(sleep_time)\n\n        input(\"Press Enter to exit.\") # Keep the game over screen until Enter is pressed\n\n\nif __name__ == '__main__':\n    game = DinosaurRunner()\n\n    # Simple input handling for jumping (press 'j' to jump)\n    import threading\n    import sys\n\n    def input_thread(game):\n        while not game.game_over:\n            user_input = input()\n            if user_input.lower() == 'j':\n                game.jump()\n            elif user_input.lower() == 'q':\n                game.game_over = True # Quit the game\n                break\n\n    input_thread = threading.Thread(target=input_thread, args=(game,), daemon=True) # Daemonize to exit with main thread\n    input_thread.start()\n\n    game.play()\n```"
}