{
    "0": "```python\nclass TicTacToe:\n    \"\"\"\n    A class representing a Tic-Tac-Toe game.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the game board and sets the initial player.\n        \"\"\"\n        self.board = [\" \" for _ in range(9)]  # Represents the 3x3 board\n        self.current_player = \"X\"  # X starts the game\n\n    def print_board(self):\n        \"\"\"\n        Prints the current state of the Tic-Tac-Toe board to the console.\n        \"\"\"\n        for i in range(0, 9, 3):\n            print(f\" {self.board[i]} | {self.board[i+1]} | {self.board[i+2]} \")\n            if i < 6:\n                print(\"---+---+---\")\n\n    def is_valid_move(self, position):\n        \"\"\"\n        Checks if a move to the given position is valid.\n\n        Args:\n            position (int): The position to check (1-9).\n\n        Returns:\n            bool: True if the move is valid, False otherwise.\n        \"\"\"\n        return 1 <= position <= 9 and self.board[position - 1] == \" \"\n\n    def make_move(self, position):\n        \"\"\"\n        Makes a move for the current player at the given position.\n\n        Args:\n            position (int): The position to make the move (1-9).\n        \"\"\"\n        if self.is_valid_move(position):\n            self.board[position - 1] = self.current_player\n            return True\n        else:\n            return False\n\n    def check_winner(self):\n        \"\"\"\n        Checks if there is a winner.\n\n        Returns:\n            str: The winning player (\"X\" or \"O\") or None if no winner.\n        \"\"\"\n        winning_combinations = [\n            [0, 1, 2], [3, 4, 5], [6, 7, 8],  # Rows\n            [0, 3, 6], [1, 4, 7], [2, 5, 8],  # Columns\n            [0, 4, 8], [2, 4, 6]               # Diagonals\n        ]\n\n        for combo in winning_combinations:\n            if self.board[combo[0]] == self.board[combo[1]] == self.board[combo[2]] != \" \":\n                return self.board[combo[0]]\n\n        return None\n\n    def is_board_full(self):\n        \"\"\"\n        Checks if the board is full (no more moves possible).\n\n        Returns:\n            bool: True if the board is full, False otherwise.\n        \"\"\"\n        return \" \" not in self.board\n\n    def switch_player(self):\n        \"\"\"\n        Switches the current player to the other player.\n        \"\"\"\n        self.current_player = \"O\" if self.current_player == \"X\" else \"X\"\n\n    def play_game(self):\n        \"\"\"\n        The main game loop.\n        \"\"\"\n        print(\"Welcome to Tic-Tac-Toe!\")\n        self.print_board()\n\n        while True:\n            print(f\"Player {self.current_player}, it's your turn.\")\n            try:\n                position = int(input(\"Enter a position (1-9): \"))\n            except ValueError:\n                print(\"Invalid input. Please enter a number between 1 and 9.\")\n                continue\n\n            if self.make_move(position):\n                self.print_board()\n                winner = self.check_winner()\n\n                if winner:\n                    print(f\"Player {winner} wins!\")\n                    break\n                elif self.is_board_full():\n                    print(\"It's a draw!\")\n                    break\n                else:\n                    self.switch_player()\n            else:\n                print(\"Invalid move. Please try again.\")\n\n\nif __name__ == \"__main__\":\n    game = TicTacToe()\n    game.play_game()\n```",
    "1": "```python\nimport random\n\nclass Hangman:\n    \"\"\"\n    A class to represent the Hangman game.\n    \"\"\"\n\n    def __init__(self, word_list, max_attempts=6):\n        \"\"\"\n        Initializes the Hangman game.\n\n        Args:\n            word_list (list): A list of words to choose from.\n            max_attempts (int): The maximum number of incorrect guesses allowed.\n        \"\"\"\n        self.word_list = word_list\n        self.word_to_guess = random.choice(self.word_list).upper()\n        self.guessed_letters = set()\n        self.attempts_remaining = max_attempts\n        self.game_over = False\n        self.word_display = ['_'] * len(self.word_to_guess) # Initialize with underscores\n\n    def display_game_state(self):\n        \"\"\"\n        Displays the current state of the game to the user.\n        \"\"\"\n        print(\"\\n\" + \"=\" * 30)\n        print(\"Word:\", \" \".join(self.word_display))\n        print(\"Guessed letters:\", \", \".join(sorted(self.guessed_letters)))\n        print(\"Attempts remaining:\", self.attempts_remaining)\n        print(\"=\" * 30)\n\n    def get_user_guess(self):\n        \"\"\"\n        Gets a letter guess from the user.\n\n        Returns:\n            str: The user's guess (a single uppercase letter).\n        \"\"\"\n        while True:\n            guess = input(\"Guess a letter: \").upper()\n            if not guess.isalpha() or len(guess) != 1:\n                print(\"Invalid input. Please enter a single letter.\")\n            elif guess in self.guessed_letters:\n                print(\"You already guessed that letter.\")\n            else:\n                return guess\n\n    def update_game_state(self, guess):\n        \"\"\"\n        Updates the game state based on the user's guess.\n\n        Args:\n            guess (str): The letter guessed by the user.\n        \"\"\"\n        self.guessed_letters.add(guess)\n\n        if guess in self.word_to_guess:\n            for i, letter in enumerate(self.word_to_guess):\n                if letter == guess:\n                    self.word_display[i] = guess\n        else:\n            self.attempts_remaining -= 1\n            print(\"Incorrect guess.\")\n\n        if self.attempts_remaining == 0:\n            self.game_over = True\n            print(\"You ran out of attempts!\")\n            print(\"The word was:\", self.word_to_guess)\n        elif \"_\" not in self.word_display:\n            self.game_over = True\n            print(\"Congratulations! You guessed the word:\", self.word_to_guess)\n\n    def play_game(self):\n        \"\"\"\n        Runs the main game loop.\n        \"\"\"\n        print(\"Welcome to Hangman!\")\n\n        while not self.game_over:\n            self.display_game_state()\n            guess = self.get_user_guess()\n            self.update_game_state(guess)\n\n        print(\"Game over.\")\n\n\nif __name__ == \"__main__\":\n    word_list = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\", \"fig\"]\n    game = Hangman(word_list)\n    game.play_game()\n```",
    "2": "```python\nimport random\n\nclass RockPaperScissors:\n    \"\"\"\n    A class representing the Rock-Paper-Scissors game.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the game with the possible choices and sets the scores to zero.\n        \"\"\"\n        self.choices = [\"rock\", \"paper\", \"scissors\"]\n        self.player_score = 0\n        self.computer_score = 0\n\n    def get_player_choice(self):\n        \"\"\"\n        Prompts the player for their choice and validates the input.\n\n        Returns:\n            str: The player's choice (rock, paper, or scissors).\n        \"\"\"\n        while True:\n            choice = input(\"Choose rock, paper, or scissors: \").lower()\n            if choice in self.choices:\n                return choice\n            else:\n                print(\"Invalid choice. Please choose rock, paper, or scissors.\")\n\n    def get_computer_choice(self):\n        \"\"\"\n        Generates a random choice for the computer.\n\n        Returns:\n            str: The computer's choice (rock, paper, or scissors).\n        \"\"\"\n        return random.choice(self.choices)\n\n    def determine_winner(self, player_choice, computer_choice):\n        \"\"\"\n        Determines the winner of a round based on the player's and computer's choices.\n\n        Args:\n            player_choice (str): The player's choice.\n            computer_choice (str): The computer's choice.\n\n        Returns:\n            str: A message indicating the result of the round (win, lose, or tie).\n        \"\"\"\n        if player_choice == computer_choice:\n            return \"It's a tie!\"\n        elif (\n            (player_choice == \"rock\" and computer_choice == \"scissors\")\n            or (player_choice == \"paper\" and computer_choice == \"rock\")\n            or (player_choice == \"scissors\" and computer_choice == \"paper\")\n        ):\n            self.player_score += 1\n            return \"You win!\"\n        else:\n            self.computer_score += 1\n            return \"You lose!\"\n\n    def display_scores(self):\n        \"\"\"\n        Displays the current scores of the player and the computer.\n        \"\"\"\n        print(f\"Player: {self.player_score}, Computer: {self.computer_score}\")\n\n    def play_round(self):\n        \"\"\"\n        Plays a single round of the game.\n        \"\"\"\n        player_choice = self.get_player_choice()\n        computer_choice = self.get_computer_choice()\n\n        print(f\"You chose: {player_choice}\")\n        print(f\"Computer chose: {computer_choice}\")\n\n        result = self.determine_winner(player_choice, computer_choice)\n        print(result)\n\n        self.display_scores()\n\n    def play_game(self):\n        \"\"\"\n        Plays the entire game until the player chooses to quit.\n        \"\"\"\n        print(\"Welcome to Rock-Paper-Scissors!\")\n\n        while True:\n            self.play_round()\n\n            play_again = input(\"Play again? (yes/no): \").lower()\n            if play_again != \"yes\":\n                print(\"Thanks for playing!\")\n                break\n\n\nif __name__ == \"__main__\":\n    game = RockPaperScissors()\n    game.play_game()\n```",
    "3": "```python\nimport random\nimport time\nimport os\n\nclass SnakeGame:\n    \"\"\"\n    A command-line implementation of the Snake game.\n    \"\"\"\n\n    def __init__(self, width=20, height=10, initial_length=3, initial_speed=0.3):\n        \"\"\"\n        Initializes the game.\n\n        Args:\n            width (int): The width of the game board.\n            height (int): The height of the game board.\n            initial_length (int): The initial length of the snake.\n            initial_speed (float): The initial speed of the game (seconds between moves).\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.snake = [(width // 2, height // 2 - i) for i in range(initial_length)]\n        self.food = self.create_food()\n        self.direction = \"right\"\n        self.game_over = False\n        self.score = 0\n        self.speed = initial_speed\n        self.paused = False\n        self.last_move_time = time.time()\n\n    def create_food(self):\n        \"\"\"\n        Creates a new food item at a random location on the board, ensuring it's not on the snake.\n\n        Returns:\n            tuple: The coordinates (x, y) of the new food item.\n        \"\"\"\n        while True:\n            food = (random.randint(0, self.width - 1), random.randint(0, self.height - 1))\n            if food not in self.snake:\n                return food\n\n    def move(self):\n        \"\"\"\n        Moves the snake one step in the current direction.\n        \"\"\"\n        if self.paused:\n            return\n\n        current_time = time.time()\n        if current_time - self.last_move_time < self.speed:\n            return  # Don't move if it's too soon\n\n        self.last_move_time = current_time\n\n        head_x, head_y = self.snake[0]\n        if self.direction == \"right\":\n            new_head = (head_x + 1, head_y)\n        elif self.direction == \"left\":\n            new_head = (head_x - 1, head_y)\n        elif self.direction == \"up\":\n            new_head = (head_x, head_y - 1)\n        elif self.direction == \"down\":\n            new_head = (head_x, head_y + 1)\n\n        # Check for game over conditions\n        if (\n            new_head[0] < 0\n            or new_head[0] >= self.width\n            or new_head[1] < 0\n            or new_head[1] >= self.height\n            or new_head in self.snake\n        ):\n            self.game_over = True\n            return\n\n        self.snake.insert(0, new_head)\n\n        # Check if the snake ate the food\n        if new_head == self.food:\n            self.score += 1\n            self.food = self.create_food()\n            self.speed *= 0.95  # Increase speed slightly\n        else:\n            self.snake.pop()  # Remove the tail\n\n    def change_direction(self, new_direction):\n        \"\"\"\n        Changes the direction of the snake, preventing immediate 180-degree turns.\n\n        Args:\n            new_direction (str): The new direction (\"up\", \"down\", \"left\", \"right\").\n        \"\"\"\n        if new_direction == \"right\" and self.direction != \"left\":\n            self.direction = \"right\"\n        elif new_direction == \"left\" and self.direction != \"right\":\n            self.direction = \"left\"\n        elif new_direction == \"up\" and self.direction != \"down\":\n            self.direction = \"up\"\n        elif new_direction == \"down\" and self.direction != \"up\":\n            self.direction = \"down\"\n\n    def draw_board(self):\n        \"\"\"\n        Draws the game board in the console.\n        \"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the screen\n        print(f\"Score: {self.score}\")\n        print(\"-\" * (self.width + 2))  # Top border\n\n        for y in range(self.height):\n            row = \"|\"  # Left border\n            for x in range(self.width):\n                if (x, y) in self.snake:\n                    row += \"O\"  # Snake body\n                elif (x, y) == self.food:\n                    row += \"X\"  # Food\n                else:\n                    row += \" \"  # Empty space\n            row += \"|\"  # Right border\n            print(row)\n\n        print(\"-\" * (self.width + 2))  # Bottom border\n        print(\"Controls: Use arrow keys to move. 'p' to pause/unpause. 'q' to quit.\")\n\n    def run(self):\n        \"\"\"\n        Runs the main game loop.\n        \"\"\"\n        import sys\n        import select\n        import tty\n        import termios\n\n        def is_data():\n            return select.select([sys.stdin], [], [], 0) == ([sys.stdin], [], [])\n\n        old_settings = termios.tcgetattr(sys.stdin)\n        try:\n            tty.setcbreak(sys.stdin.fileno())\n            while not self.game_over:\n                self.draw_board()\n                self.move()\n\n                if is_data():\n                    c = sys.stdin.read(1)\n                    if c == '\\x1b[A':  # Up arrow\n                        self.change_direction(\"up\")\n                    elif c == '\\x1b[B':  # Down arrow\n                        self.change_direction(\"down\")\n                    elif c == '\\x1b[C':  # Right arrow\n                        self.change_direction(\"right\")\n                    elif c == '\\x1b[D':  # Left arrow\n                        self.change_direction(\"left\")\n                    elif c == 'p':\n                        self.paused = not self.paused\n                    elif c == 'q':\n                        self.game_over = True\n                else:\n                    time.sleep(0.01) # Reduce CPU usage\n\n            self.draw_board()\n            print(\"Game Over! Final Score:\", self.score)\n\n        finally:\n            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)\n\n\n\nif __name__ == \"__main__\":\n    game = SnakeGame()\n    game.run()\n```",
    "4": "```python\nimport random\n\nclass Minesweeper:\n    \"\"\"\n    A command-line Minesweeper game.\n    \"\"\"\n\n    def __init__(self, rows, cols, mines):\n        \"\"\"\n        Initializes a new Minesweeper game.\n\n        Args:\n            rows (int): The number of rows in the grid.\n            cols (int): The number of columns in the grid.\n            mines (int): The number of mines to place.\n        \"\"\"\n        self.rows = rows\n        self.cols = cols\n        self.mines = mines\n        self.grid = [[' ' for _ in range(cols)] for _ in range(rows)]  # Hidden grid\n        self.visible_grid = [['-' for _ in range(cols)] for _ in range(rows)]  # User view\n        self.mine_positions = set()\n        self.game_over = False\n        self.flags_placed = 0\n        self.first_move = True # Flag to ensure first move is never a mine\n\n        if mines >= rows * cols:\n            raise ValueError(\"Too many mines for the given grid size.\")\n\n        self.place_mines()\n        self.calculate_neighboring_mines()\n\n    def place_mines(self):\n        \"\"\"\n        Randomly places mines on the grid.  Ensures the number of mines is correct.\n        \"\"\"\n        while len(self.mine_positions) < self.mines:\n            row = random.randint(0, self.rows - 1)\n            col = random.randint(0, self.cols - 1)\n            self.mine_positions.add((row, col))\n\n\n    def calculate_neighboring_mines(self):\n        \"\"\"\n        Calculates the number of neighboring mines for each cell.\n        \"\"\"\n        for row in range(self.rows):\n            for col in range(self.cols):\n                if (row, col) not in self.mine_positions:\n                    count = 0\n                    for r in range(max(0, row - 1), min(self.rows, row + 2)):\n                        for c in range(max(0, col - 1), min(self.cols, col + 2)):\n                            if (r, c) in self.mine_positions:\n                                count += 1\n                    self.grid[row][col] = str(count) if count > 0 else '0'\n\n    def print_grid(self):\n        \"\"\"\n        Prints the visible grid to the console.\n        \"\"\"\n        print(\"   \" + \" \".join(str(i) for i in range(self.cols)))\n        print(\"  \" + \"-\" * (2 * self.cols + 1))\n        for i, row in enumerate(self.visible_grid):\n            print(f\"{i}| {' '.join(row)} |\")\n        print(\"  \" + \"-\" * (2 * self.cols + 1))\n        print(f\"Mines: {self.mines}, Flags placed: {self.flags_placed}\")\n\n    def is_valid_move(self, row, col):\n        \"\"\"\n        Checks if a move is valid (within the grid boundaries).\n\n        Args:\n            row (int): The row index.\n            col (int): The column index.\n\n        Returns:\n            bool: True if the move is valid, False otherwise.\n        \"\"\"\n        return 0 <= row < self.rows and 0 <= col < self.cols\n\n    def reveal_cell(self, row, col):\n        \"\"\"\n        Reveals a cell and its neighboring empty cells recursively.\n\n        Args:\n            row (int): The row index.\n            col (int): The column index.\n        \"\"\"\n\n        if not self.is_valid_move(row, col) or self.visible_grid[row][col] != '-':\n            return\n\n        if self.first_move:\n            # Ensure first move is not a mine by moving the mine if necessary\n            if (row, col) in self.mine_positions:\n                self.move_mine(row, col)\n            self.first_move = False\n            self.calculate_neighboring_mines() # Recalculate neighbor counts after moving mine.\n\n\n        if (row, col) in self.mine_positions:\n            self.visible_grid[row][col] = 'X'\n            self.game_over = True\n            return\n\n        self.visible_grid[row][col] = self.grid[row][col]\n\n        if self.grid[row][col] == '0':\n            for r in range(max(0, row - 1), min(self.rows, row + 2)):\n                for c in range(max(0, col - 1), min(self.cols, col + 2)):\n                    self.reveal_cell(r, c)\n\n    def move_mine(self, row, col):\n        \"\"\"Moves a mine from the given location to a new random location.\n\n        Args:\n            row (int): The row index of the mine to move.\n            col (int): The column index of the mine to move.\n        \"\"\"\n        self.mine_positions.remove((row, col))\n        while True:\n            new_row = random.randint(0, self.rows - 1)\n            new_col = random.randint(0, self.cols - 1)\n            if (new_row, new_col) not in self.mine_positions and (new_row, new_col) != (row, col):\n                self.mine_positions.add((new_row, new_col))\n                break\n\n\n    def place_flag(self, row, col):\n        \"\"\"\n        Places a flag on a cell.\n\n        Args:\n            row (int): The row index.\n            col (int): The column index.\n        \"\"\"\n        if not self.is_valid_move(row, col):\n            print(\"Invalid move.\")\n            return\n\n        if self.visible_grid[row][col] == '-':\n            self.visible_grid[row][col] = 'F'\n            self.flags_placed += 1\n        elif self.visible_grid[row][col] == 'F':\n            self.visible_grid[row][col] = '-'\n            self.flags_placed -= 1\n        else:\n            print(\"Cannot place a flag on a revealed cell.\")\n\n    def check_win(self):\n        \"\"\"\n        Checks if the player has won the game.\n\n        Returns:\n            bool: True if the player has won, False otherwise.\n        \"\"\"\n        revealed_cells = 0\n        for row in range(self.rows):\n            for col in range(self.cols):\n                if self.visible_grid[row][col] != '-':\n                    revealed_cells += 1\n\n        return revealed_cells == self.rows * self.cols - self.mines\n\n    def play_turn(self):\n        \"\"\"\n        Plays a single turn of the game.\n        \"\"\"\n        self.print_grid()\n\n        while True:\n            action = input(\"Enter your move (r = reveal, f = flag, q = quit), followed by row and column (e.g., r 0 0): \").split()\n            if len(action) != 3:\n                print(\"Invalid input. Please enter action, row, and column.\")\n                continue\n\n            try:\n                move, row, col = action[0].lower(), int(action[1]), int(action[2])\n            except ValueError:\n                print(\"Invalid input. Row and column must be integers.\")\n                continue\n\n            if move == 'q':\n                self.game_over = True\n                return\n\n            if not self.is_valid_move(row, col):\n                print(\"Invalid move. Row and column must be within the grid boundaries.\")\n                continue\n\n            if move == 'r':\n                self.reveal_cell(row, col)\n                break  # Exit the loop after a valid reveal\n            elif move == 'f':\n                self.place_flag(row, col)\n                break  # Exit the loop after a valid flag\n            else:\n                print(\"Invalid action. Use 'r' to reveal or 'f' to flag.\")\n\n    def play(self):\n        \"\"\"\n        Starts the Minesweeper game.\n        \"\"\"\n        print(\"Welcome to Minesweeper!\")\n        while not self.game_over:\n            self.play_turn()\n            if self.game_over:\n                self.print_grid()\n                print(\"Game Over! You hit a mine.\")\n                break\n            if self.check_win():\n                self.print_grid()\n                print(\"Congratulations! You win!\")\n                self.game_over = True\n\n\nif __name__ == '__main__':\n    try:\n        rows = int(input(\"Enter the number of rows: \"))\n        cols = int(input(\"Enter the number of columns: \"))\n        mines = int(input(\"Enter the number of mines: \"))\n        game = Minesweeper(rows, cols, mines)\n        game.play()\n    except ValueError as e:\n        print(f\"Invalid input: {e}\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n```",
    "5": "```python\nimport random\n\nclass Mastermind:\n    \"\"\"\n    A class to represent the Mastermind game.\n    \"\"\"\n\n    def __init__(self, code_length=4, color_range=6, max_guesses=10):\n        \"\"\"\n        Initializes the Mastermind game.\n\n        Args:\n            code_length (int): The length of the secret code.\n            color_range (int): The number of possible colors (1 to color_range).\n            max_guesses (int): The maximum number of guesses allowed.\n        \"\"\"\n        self.code_length = code_length\n        self.color_range = color_range\n        self.max_guesses = max_guesses\n        self.secret_code = self._generate_secret_code()\n        self.guesses_remaining = max_guesses\n        self.history = []  # Store guesses and feedback\n        self.game_over = False\n\n    def _generate_secret_code(self):\n        \"\"\"\n        Generates a random secret code.\n\n        Returns:\n            list: A list of integers representing the secret code.\n        \"\"\"\n        return [random.randint(1, self.color_range) for _ in range(self.code_length)]\n\n    def _get_feedback(self, guess):\n        \"\"\"\n        Provides feedback for a given guess.\n\n        Args:\n            guess (list): A list of integers representing the player's guess.\n\n        Returns:\n            tuple: A tuple containing the number of correct positions and correct colors.\n        \"\"\"\n        correct_position = 0\n        correct_color = 0\n        temp_secret = self.secret_code[:]  # Create a copy to avoid modifying the original\n        temp_guess = guess[:]\n\n        # Check for correct positions first\n        for i in range(self.code_length):\n            if temp_guess[i] == temp_secret[i]:\n                correct_position += 1\n                temp_guess[i] = None  # Mark as matched\n                temp_secret[i] = None  # Mark as matched\n\n        # Check for correct colors in incorrect positions\n        for i in range(self.code_length):\n            if temp_guess[i] is not None:\n                for j in range(self.code_length):\n                    if temp_secret[j] is not None and temp_guess[i] == temp_secret[j]:\n                        correct_color += 1\n                        temp_secret[j] = None  # Mark as matched\n                        break\n\n        return correct_position, correct_color\n\n    def make_guess(self, guess):\n        \"\"\"\n        Processes a player's guess.\n\n        Args:\n            guess (list): A list of integers representing the player's guess.\n\n        Returns:\n            tuple: A tuple containing a boolean indicating if the guess was correct,\n                   a tuple with the feedback (correct_position, correct_color),\n                   and a boolean indicating if the game is over.\n        \"\"\"\n        if self.game_over:\n            return False, (0, 0), True\n\n        if len(guess) != self.code_length:\n            raise ValueError(f\"Guess must be {self.code_length} digits long.\")\n\n        for digit in guess:\n            if not 1 <= digit <= self.color_range:\n                raise ValueError(f\"Digits must be between 1 and {self.color_range}.\")\n\n        self.guesses_remaining -= 1\n        correct_position, correct_color = self._get_feedback(guess)\n        self.history.append((guess, (correct_position, correct_color)))\n\n        if correct_position == self.code_length:\n            self.game_over = True\n            return True, (correct_position, correct_color), True\n\n        if self.guesses_remaining == 0:\n            self.game_over = True\n            return False, (correct_position, correct_color), True\n\n        return False, (correct_position, correct_color), False\n\n    def display_history(self):\n        \"\"\"\n        Displays the game history to the player.\n        \"\"\"\n        print(\"\\n--- Game History ---\")\n        for guess, feedback in self.history:\n            print(f\"Guess: {guess}, Feedback: {feedback}\")\n        print(\"--------------------\")\n\n    def play(self):\n        \"\"\"\n        Plays the Mastermind game.\n        \"\"\"\n        print(f\"Welcome to Mastermind!\")\n        print(f\"I've generated a secret code with {self.code_length} digits, each between 1 and {self.color_range}.\")\n        print(f\"You have {self.max_guesses} guesses to crack the code.\")\n\n        while not self.game_over:\n            try:\n                guess_str = input(f\"\\nGuess ({self.guesses_remaining} remaining): \")\n                guess = [int(digit) for digit in guess_str]\n\n                is_correct, feedback, game_over = self.make_guess(guess)\n\n                print(f\"Feedback: {feedback[0]} correct position(s), {feedback[1]} correct color(s).\")\n\n                if is_correct:\n                    print(\"\\nCongratulations! You cracked the code!\")\n                    self.display_history()\n                elif game_over:\n                    print(\"\\nYou ran out of guesses. Game over!\")\n                    print(f\"The secret code was: {self.secret_code}\")\n                    self.display_history()\n\n            except ValueError as e:\n                print(f\"Invalid input: {e}\")\n            except Exception as e:\n                print(f\"An unexpected error occurred: {e}\")\n\nif __name__ == \"__main__\":\n    game = Mastermind()\n    game.play()\n```",
    "6": "```python\nimport random\n\nclass Battleship:\n    \"\"\"\n    A command-line Battleship game.\n    \"\"\"\n\n    def __init__(self, grid_size=10, num_ships=5):\n        \"\"\"\n        Initializes the game.\n\n        Args:\n            grid_size (int): The size of the game board (grid_size x grid_size).\n            num_ships (int): The number of ships each player has.\n        \"\"\"\n        self.grid_size = grid_size\n        self.num_ships = num_ships\n        self.player_grid = self._create_grid()\n        self.computer_grid = self._create_grid()\n        self.player_ships = self._place_ships(self.player_grid)\n        self.computer_ships = self._place_ships(self.computer_grid)\n        self.player_guesses = set()\n        self.computer_guesses = set()\n\n    def _create_grid(self):\n        \"\"\"\n        Creates an empty grid for the game.\n\n        Returns:\n            list[list[str]]: A 2D list representing the grid.\n        \"\"\"\n        return [['.' for _ in range(self.grid_size)] for _ in range(self.grid_size)]\n\n    def _place_ships(self, grid):\n        \"\"\"\n        Randomly places ships on the grid.\n\n        Args:\n            grid (list[list[str]]): The grid to place the ships on.\n\n        Returns:\n            list[tuple[int, int]]: A list of ship coordinates (row, col).\n        \"\"\"\n        ships = []\n        for _ in range(self.num_ships):\n            while True:\n                row = random.randint(0, self.grid_size - 1)\n                col = random.randint(0, self.grid_size - 1)\n                if (row, col) not in ships:\n                    ships.append((row, col))\n                    break\n            grid[row][col] = 'S'  # Mark ship location on the grid (for debugging)\n        return ships\n\n    def print_grid(self, grid, hide_ships=True):\n        \"\"\"\n        Prints the grid to the console.\n\n        Args:\n            grid (list[list[str]]): The grid to print.\n            hide_ships (bool): Whether to hide the ships or show them.\n        \"\"\"\n        header = \"   \" + \" \".join([chr(65 + i) for i in range(self.grid_size)])\n        print(header)\n        for i, row in enumerate(grid):\n            row_str = str(i).rjust(2) + \" \"\n            for cell in row:\n                if hide_ships and cell == 'S':\n                    row_str += '. '  # Hide ships from the player\n                else:\n                    row_str += cell + ' '\n            print(row_str)\n\n    def get_player_guess(self):\n        \"\"\"\n        Gets a valid guess from the player.\n\n        Returns:\n            tuple[int, int]: The player's guess (row, col).\n        \"\"\"\n        while True:\n            try:\n                guess = input(f\"Enter your guess (e.g., A0): \").upper()\n                if len(guess) < 2 or len(guess) > 3:\n                    raise ValueError\n                col = ord(guess[0]) - 65\n                row = int(guess[1:])\n\n                if not (0 <= row < self.grid_size and 0 <= col < self.grid_size):\n                    raise ValueError\n\n                if (row, col) in self.player_guesses:\n                    print(\"You already guessed that location. Try again.\")\n                    continue\n\n                return row, col\n\n            except ValueError:\n                print(\"Invalid input. Please enter a valid guess (e.g., A0).\")\n\n    def computer_turn(self):\n        \"\"\"\n        The computer's turn to guess.\n\n        Returns:\n            tuple[int, int]: The computer's guess (row, col).\n        \"\"\"\n        while True:\n            row = random.randint(0, self.grid_size - 1)\n            col = random.randint(0, self.grid_size - 1)\n            if (row, col) not in self.computer_guesses:\n                self.computer_guesses.add((row, col))\n                return row, col\n\n    def play_round(self):\n        \"\"\"\n        Plays a single round of the game.\n        \"\"\"\n        # Player's turn\n        print(\"\\nYour Turn:\")\n        self.print_grid(self.computer_grid)  # Print computer's grid (hidden ships)\n        row, col = self.get_player_guess()\n        self.player_guesses.add((row, col))\n\n        if (row, col) in self.computer_ships:\n            print(\"Hit!\")\n            self.computer_grid[row][col] = 'X'  # Mark hit on the computer's grid\n            self.computer_ships.remove((row, col))\n        else:\n            print(\"Miss!\")\n            self.computer_grid[row][col] = 'O'  # Mark miss on the computer's grid\n\n        # Computer's turn\n        print(\"\\nComputer's Turn:\")\n        row, col = self.computer_turn()\n        print(f\"Computer guessed {chr(col + 65)}{row}\")\n\n        if (row, col) in self.player_ships:\n            print(\"Computer hit your ship!\")\n            self.player_grid[row][col] = 'X'  # Mark hit on the player's grid\n            self.player_ships.remove((row, col))\n        else:\n            print(\"Computer missed!\")\n            self.player_grid[row][col] = 'O'  # Mark miss on the player's grid\n\n        self.print_grid(self.player_grid, hide_ships=False) #show player their own board\n\n    def check_winner(self):\n        \"\"\"\n        Checks if there is a winner.\n\n        Returns:\n            str: 'player' if the player won, 'computer' if the computer won, None if no winner.\n        \"\"\"\n        if not self.computer_ships:\n            return 'player'\n        if not self.player_ships:\n            return 'computer'\n        return None\n\n    def play_game(self):\n        \"\"\"\n        The main game loop.\n        \"\"\"\n        print(\"Welcome to Battleship!\")\n        print(f\"Grid size: {self.grid_size}x{self.grid_size}, Number of ships: {self.num_ships}\")\n\n        while True:\n            self.play_round()\n            winner = self.check_winner()\n\n            if winner:\n                print(f\"\\n{winner.capitalize()} wins!\")\n                if winner == 'player':\n                    print(\"Computer's Board:\")\n                    self.print_grid(self.computer_grid, hide_ships=False) # Show computer's board\n                else:\n                    print(\"Your Board:\")\n                    self.print_grid(self.player_grid, hide_ships=False) #Show player their own board\n                break\n\n\nif __name__ == '__main__':\n    game = Battleship()\n    game.play_game()\n```",
    "7": "```python\nimport argparse\nimport time\nimport os\nimport random\nfrom typing import List\n\n\nclass GameOfLife:\n    \"\"\"\n    Implements Conway's Game of Life.\n    \"\"\"\n\n    ALIVE = '#'\n    DEAD = ' '\n\n    def __init__(self, width: int, height: int, initial_state: List[List[int]] = None,\n                 random_fill_probability: float = 0.3):\n        \"\"\"\n        Initializes the Game of Life.\n\n        Args:\n            width: The width of the grid.\n            height: The height of the grid.\n            initial_state: An optional initial state for the grid.  If None, the grid is initialized randomly.\n            random_fill_probability: The probability that a cell is alive when initialized randomly (default 0.3).\n        \"\"\"\n        self.width = width\n        self.height = height\n\n        if initial_state:\n            self.grid = initial_state\n            self.height = len(initial_state)\n            self.width = len(initial_state[0]) if initial_state else 0  # Handle empty initial state\n        else:\n            self.grid = self._create_random_grid(random_fill_probability)\n\n    def _create_random_grid(self, fill_probability: float) -> List[List[int]]:\n        \"\"\"\n        Creates a random grid with alive cells based on the fill probability.\n\n        Args:\n            fill_probability: The probability that a cell is alive.\n\n        Returns:\n            A 2D list representing the grid.\n        \"\"\"\n        return [[(1 if random.random() < fill_probability else 0) for _ in range(self.width)] for _ in range(self.height)]\n\n    def _get_neighbors(self, row: int, col: int) -> List[int]:\n        \"\"\"\n        Gets the neighbors of a cell. Handles edge cases by wrapping around.\n\n        Args:\n            row: The row index of the cell.\n            col: The column index of the cell.\n\n        Returns:\n            A list of the cell's neighbors (0 or 1).\n        \"\"\"\n        neighbors = []\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                if i == 0 and j == 0:  # Skip the cell itself\n                    continue\n                neighbor_row = (row + i) % self.height\n                neighbor_col = (col + j) % self.width\n                neighbors.append(self.grid[neighbor_row][neighbor_col])\n        return neighbors\n\n    def _get_next_state(self, row: int, col: int) -> int:\n        \"\"\"\n        Determines the next state of a cell based on Conway's rules.\n\n        Args:\n            row: The row index of the cell.\n            col: The column index of the cell.\n\n        Returns:\n            The next state of the cell (0 or 1).\n        \"\"\"\n        alive_neighbors = sum(self._get_neighbors(row, col))\n        if self.grid[row][col] == 1:  # Alive cell\n            if alive_neighbors < 2 or alive_neighbors > 3:\n                return 0  # Dies of underpopulation or overpopulation\n            else:\n                return 1  # Survives\n        else:  # Dead cell\n            if alive_neighbors == 3:\n                return 1  # Becomes alive through reproduction\n            else:\n                return 0  # Remains dead\n\n    def update(self) -> None:\n        \"\"\"\n        Updates the grid to the next generation.\n        \"\"\"\n        next_grid = [[self._get_next_state(row, col) for col in range(self.width)] for row in range(self.height)]\n        self.grid = next_grid\n\n    def display(self) -> None:\n        \"\"\"\n        Displays the current state of the grid in the console.\n        \"\"\"\n        for row in self.grid:\n            print(''.join([self.ALIVE if cell == 1 else self.DEAD for cell in row]))\n\n    def run(self, generations: int, delay: float = 0.1) -> None:\n        \"\"\"\n        Runs the Game of Life for a specified number of generations.\n\n        Args:\n            generations: The number of generations to run.\n            delay: The delay between generations in seconds.\n        \"\"\"\n        try:\n            for _ in range(generations):\n                os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n                self.display()\n                self.update()\n                time.sleep(delay)\n        except KeyboardInterrupt:\n            print(\"\\nGame interrupted by user.\")\n\n\ndef main():\n    \"\"\"\n    Main function to parse arguments and run the Game of Life.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=\"Conway's Game of Life\")\n    parser.add_argument('--width', type=int, default=60, help='Width of the grid')\n    parser.add_argument('--height', type=int, default=30, help='Height of the grid')\n    parser.add_argument('--generations', type=int, default=100, help='Number of generations to run')\n    parser.add_argument('--delay', type=float, default=0.1, help='Delay between generations in seconds')\n    parser.add_argument('--fill_probability', type=float, default=0.3, help='Probability of a cell being alive at start')\n    parser.add_argument('--initial_state_file', type=str, help='Path to a file containing the initial state')\n\n    args = parser.parse_args()\n\n    initial_state = None\n    if args.initial_state_file:\n        try:\n            with open(args.initial_state_file, 'r') as f:\n                initial_state = []\n                for line in f:\n                    row = [1 if char == '#' else 0 for char in line.strip()]\n                    initial_state.append(row)\n        except FileNotFoundError:\n            print(f\"Error: Initial state file not found: {args.initial_state_file}\")\n            return\n        except Exception as e:\n            print(f\"Error reading initial state file: {e}\")\n            return\n\n\n    game = GameOfLife(args.width, args.height, initial_state=initial_state, random_fill_probability=args.fill_probability)\n    game.run(args.generations, args.delay)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
    "8": "```python\nclass ConnectFour:\n    \"\"\"\n    A class to represent the Connect Four game.\n    \"\"\"\n\n    def __init__(self, rows=6, cols=7):\n        \"\"\"\n        Initializes the Connect Four game board.\n\n        Args:\n            rows (int): The number of rows in the board (default: 6).\n            cols (int): The number of columns in the board (default: 7).\n        \"\"\"\n        self.rows = rows\n        self.cols = cols\n        self.board = [[' ' for _ in range(cols)] for _ in range(rows)]\n        self.current_player = 'X'  # Player X starts\n        self.game_over = False\n        self.winner = None\n\n    def print_board(self):\n        \"\"\"\n        Prints the current state of the Connect Four board to the console.\n        \"\"\"\n        for row in range(self.rows):\n            print('|' + '|'.join(self.board[row]) + '|')\n        print('+' + '+'.join(['-'] * self.cols) + '+')\n        print(' ' + ' '.join(str(i + 1) for i in range(self.cols)))  # Column numbers\n\n    def drop_piece(self, col):\n        \"\"\"\n        Drops a piece into the specified column.\n\n        Args:\n            col (int): The column to drop the piece into (0-indexed).\n\n        Returns:\n            bool: True if the piece was successfully dropped, False otherwise\n                  (e.g., column is full).\n        \"\"\"\n        if col < 0 or col >= self.cols:\n            print(\"Invalid column. Please choose a column between 1 and\", self.cols)\n            return False\n\n        for row in range(self.rows - 1, -1, -1):\n            if self.board[row][col] == ' ':\n                self.board[row][col] = self.current_player\n                return True  # Piece successfully dropped\n\n        print(\"Column\", col + 1, \"is full.  Choose a different column.\")\n        return False  # Column is full\n\n    def check_win(self):\n        \"\"\"\n        Checks if the current player has won the game.\n\n        Returns:\n            bool: True if the current player has won, False otherwise.\n        \"\"\"\n        # Check horizontal\n        for row in range(self.rows):\n            for col in range(self.cols - 3):\n                if (self.board[row][col] == self.current_player and\n                        self.board[row][col + 1] == self.current_player and\n                        self.board[row][col + 2] == self.current_player and\n                        self.board[row][col + 3] == self.current_player):\n                    return True\n\n        # Check vertical\n        for row in range(self.rows - 3):\n            for col in range(self.cols):\n                if (self.board[row][col] == self.current_player and\n                        self.board[row + 1][col] == self.current_player and\n                        self.board[row + 2][col] == self.current_player and\n                        self.board[row + 3][col] == self.current_player):\n                    return True\n\n        # Check positive diagonal\n        for row in range(self.rows - 3):\n            for col in range(self.cols - 3):\n                if (self.board[row][col] == self.current_player and\n                        self.board[row + 1][col + 1] == self.current_player and\n                        self.board[row + 2][col + 2] == self.current_player and\n                        self.board[row + 3][col + 3] == self.current_player):\n                    return True\n\n        # Check negative diagonal\n        for row in range(3, self.rows):\n            for col in range(self.cols - 3):\n                if (self.board[row][col] == self.current_player and\n                        self.board[row - 1][col + 1] == self.current_player and\n                        self.board[row - 2][col + 2] == self.current_player and\n                        self.board[row - 3][col + 3] == self.current_player):\n                    return True\n\n        return False\n\n    def check_draw(self):\n        \"\"\"\n        Checks if the game is a draw (i.e., the board is full).\n\n        Returns:\n            bool: True if the game is a draw, False otherwise.\n        \"\"\"\n        for row in range(self.rows):\n            for col in range(self.cols):\n                if self.board[row][col] == ' ':\n                    return False  # There are still empty spaces\n        return True  # Board is full\n\n    def switch_player(self):\n        \"\"\"\n        Switches the current player to the other player.\n        \"\"\"\n        self.current_player = 'O' if self.current_player == 'X' else 'X'\n\n    def play_turn(self):\n        \"\"\"\n        Plays a single turn of the game, prompting the current player for input\n        and updating the board.\n        \"\"\"\n        self.print_board()\n        while True:\n            try:\n                col = int(input(f\"Player {self.current_player}, enter column (1-{self.cols}): \")) - 1\n                if self.drop_piece(col):\n                    break  # Valid move, exit the loop\n            except ValueError:\n                print(\"Invalid input. Please enter a number between 1 and\", self.cols)\n            except Exception as e:\n                print(\"An error occurred:\", e)\n\n        if self.check_win():\n            self.game_over = True\n            self.winner = self.current_player\n            self.print_board()\n            print(f\"Player {self.current_player} wins!\")\n        elif self.check_draw():\n            self.game_over = True\n            self.print_board()\n            print(\"It's a draw!\")\n        else:\n            self.switch_player()\n\n    def play_game(self):\n        \"\"\"\n        Starts and runs the Connect Four game until it is over.\n        \"\"\"\n        print(\"Welcome to Connect Four!\")\n        while not self.game_over:\n            self.play_turn()\n        print(\"Game Over.\")\n\n\nif __name__ == '__main__':\n    game = ConnectFour()\n    game.play_game()\n```",
    "9": "```python\nimport random\n\nclass Blackjack:\n    \"\"\"\n    A class to represent a Blackjack game.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the Blackjack game.\n        \"\"\"\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n        self.player_score = 0\n        self.dealer_score = 0\n        self.game_over = False\n\n    def create_deck(self):\n        \"\"\"\n        Creates a standard 52-card deck.\n        \"\"\"\n        suits = [\"Hearts\", \"Diamonds\", \"Clubs\", \"Spades\"]\n        ranks = [\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\", \"Ace\"]\n        deck = [(rank, suit) for suit in suits for rank in ranks]\n        random.shuffle(deck)\n        return deck\n\n    def deal_card(self, hand):\n        \"\"\"\n        Deals a card from the deck to the given hand.\n        \"\"\"\n        card = self.deck.pop()\n        hand.append(card)\n        return card\n\n    def calculate_hand_value(self, hand):\n        \"\"\"\n        Calculates the value of a hand, treating Aces as 1 or 11.\n        \"\"\"\n        value = 0\n        ace_count = 0\n        for card in hand:\n            rank = card[0]\n            if rank.isdigit():\n                value += int(rank)\n            elif rank in [\"Jack\", \"Queen\", \"King\"]:\n                value += 10\n            elif rank == \"Ace\":\n                value += 11\n                ace_count += 1\n\n        while value > 21 and ace_count > 0:\n            value -= 10\n            ace_count -= 1\n\n        return value\n\n    def display_hand(self, hand, is_dealer=False, hide_first_card=False):\n        \"\"\"\n        Displays a hand of cards.\n        \"\"\"\n        if is_dealer and hide_first_card:\n            print(\"Dealer's Hand: [Hidden Card]\", end=\" \")\n            for card in hand[1:]:\n                print(f\"[{card[0]} of {card[1]}]\", end=\" \")\n            print()\n        else:\n            if is_dealer:\n                print(\"Dealer's Hand:\", end=\" \")\n            else:\n                print(\"Your Hand:\", end=\" \")\n            for card in hand:\n                print(f\"[{card[0]} of {card[1]}]\", end=\" \")\n            print()\n\n    def player_turn(self):\n        \"\"\"\n        Handles the player's turn.\n        \"\"\"\n        while True:\n            self.display_hand(self.player_hand)\n            self.player_score = self.calculate_hand_value(self.player_hand)\n            print(f\"Your Score: {self.player_score}\")\n\n            if self.player_score > 21:\n                print(\"You busted!\")\n                self.game_over = True\n                return\n\n            action = input(\"Hit or Stand? (h/s): \").lower()\n            if action == \"h\":\n                self.deal_card(self.player_hand)\n            elif action == \"s\":\n                break\n            else:\n                print(\"Invalid input. Please enter 'h' or 's'.\")\n\n    def dealer_turn(self):\n        \"\"\"\n        Handles the dealer's turn.\n        \"\"\"\n        print(\"\\nDealer's Turn:\")\n        while self.dealer_score < 17:\n            self.deal_card(self.dealer_hand)\n            self.dealer_score = self.calculate_hand_value(self.dealer_hand)\n            self.display_hand(self.dealer_hand, is_dealer=True)\n            print(f\"Dealer's Score: {self.dealer_score}\")\n            if self.dealer_score > 21:\n                print(\"Dealer busted!\")\n                return\n\n    def determine_winner(self):\n        \"\"\"\n        Determines the winner of the game.\n        \"\"\"\n        print(\"\\n--- Game Over ---\")\n        self.display_hand(self.player_hand)\n        print(f\"Your Score: {self.player_score}\")\n        self.display_hand(self.dealer_hand, is_dealer=True)\n        print(f\"Dealer's Score: {self.dealer_score}\")\n\n        if self.player_score > 21:\n            print(\"Dealer wins!\")\n        elif self.dealer_score > 21:\n            print(\"You win!\")\n        elif self.player_score > self.dealer_score:\n            print(\"You win!\")\n        elif self.dealer_score > self.player_score:\n            print(\"Dealer wins!\")\n        else:\n            print(\"It's a tie!\")\n\n    def play_again(self):\n        \"\"\"\n        Asks if the player wants to play again.\n        \"\"\"\n        while True:\n            play_again = input(\"Play again? (y/n): \").lower()\n            if play_again == \"y\":\n                self.__init__()  # Reset the game\n                self.start_game()\n                break\n            elif play_again == \"n\":\n                print(\"Thanks for playing!\")\n                break\n            else:\n                print(\"Invalid input. Please enter 'y' or 'n'.\")\n\n    def start_game(self):\n        \"\"\"\n        Starts the Blackjack game.\n        \"\"\"\n        print(\"Welcome to Blackjack!\")\n\n        # Deal initial hands\n        self.deal_card(self.player_hand)\n        self.deal_card(self.dealer_hand)\n        self.deal_card(self.player_hand)\n        self.deal_card(self.dealer_hand)\n\n        # Display initial hands (dealer's first card hidden)\n        self.display_hand(self.player_hand)\n        self.display_hand(self.dealer_hand, is_dealer=True, hide_first_card=True)\n\n        # Player's turn\n        self.player_turn()\n\n        # Dealer's turn (if player didn't bust)\n        if not self.game_over:\n            self.dealer_score = self.calculate_hand_value(self.dealer_hand)\n            self.dealer_turn()\n\n        # Determine the winner\n        if not self.game_over:\n             self.player_score = self.calculate_hand_value(self.player_hand) #recalculate in case player has ace\n             self.determine_winner()\n\n        # Ask to play again\n        self.play_again()\n\n\nif __name__ == \"__main__\":\n    game = Blackjack()\n    game.start_game()\n```",
    "10": "```python\nimport random\n\nclass Hammurabi:\n    \"\"\"\n    A class representing the Hammurabi game.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the game state.\n        \"\"\"\n        self.year = 1\n        self.population = 100\n        self.grain_stores = 2800\n        self.acres_owned = 1000\n        self.price_per_acre = 19  #initial price\n        self.starved = 0\n        self.plague_deaths = 0\n\n    def play_year(self):\n        \"\"\"\n        Plays one year of the game.\n        \"\"\"\n        print(f\"\\nYear {self.year}\")\n        print(f\"You are in year {self.year} of your ten-year rule.\")\n        print(f\"In the previous year {self.starved} people starved to death.\")\n        if self.plague_deaths > 0:\n            print(f\"The plague killed {self.plague_deaths} people.\")\n        print(f\"The population is now {self.population}.\")\n        print(f\"You own {self.acres_owned} acres of land.\")\n        print(f\"You harvested {self.grain_stores} bushels of grain.\")\n        print(f\"Land is trading at {self.price_per_acre} bushels per acre.\")\n\n        self.handle_trading()\n        self.handle_feeding()\n        self.handle_planting()\n        self.handle_harvest()\n        self.handle_plague()\n        self.handle_population()\n        self.handle_rats()\n        self.handle_land_price()\n\n        self.year += 1\n\n    def handle_trading(self):\n        \"\"\"\n        Handles buying and selling land.\n        \"\"\"\n        while True:\n            try:\n                acres_to_buy = int(input(\"How many acres do you wish to buy? \"))\n                if acres_to_buy < 0:\n                    print(\"You cannot buy a negative number of acres.\")\n                    continue\n                if acres_to_buy * self.price_per_acre > self.grain_stores:\n                    print(\"O Hammurabi, we have not enough grain!\")\n                    continue\n                break\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n        while True:\n            try:\n                acres_to_sell = int(input(\"How many acres do you wish to sell? \"))\n                if acres_to_sell < 0:\n                    print(\"You cannot sell a negative number of acres.\")\n                    continue\n                if acres_to_sell > self.acres_owned:\n                    print(\"O Hammurabi, you do not own that much land!\")\n                    continue\n                break\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n        self.acres_owned += acres_to_buy - acres_to_sell\n        self.grain_stores -= acres_to_buy * self.price_per_acre\n        self.grain_stores += acres_to_sell * self.price_per_acre\n\n    def handle_feeding(self):\n        \"\"\"\n        Handles feeding the population.\n        \"\"\"\n        while True:\n            try:\n                grain_to_feed = int(input(\"How many bushels do you wish to feed your people? \"))\n                if grain_to_feed < 0:\n                    print(\"You cannot feed a negative amount of grain.\")\n                    continue\n                if grain_to_feed > self.grain_stores:\n                    print(\"O Hammurabi, we have not enough grain!\")\n                    continue\n                break\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n        self.grain_stores -= grain_to_feed\n        grain_per_person = grain_to_feed / self.population\n\n        if grain_per_person < 20:\n            starved = int(self.population * (20 - grain_per_person) / 20)\n            self.starved = starved\n            self.population -= starved\n            print(f\"{starved} people have starved.\")\n            if self.population <= 0:\n                print(\"O Hammurabi, you have starved all your people. Your rule is over!\")\n                exit()\n        else:\n            self.starved = 0\n\n    def handle_planting(self):\n        \"\"\"\n        Handles planting grain.\n        \"\"\"\n        while True:\n            try:\n                acres_to_plant = int(input(\"How many acres do you wish to plant with grain? \"))\n                if acres_to_plant < 0:\n                    print(\"You cannot plant a negative number of acres.\")\n                    continue\n                if acres_to_plant > self.acres_owned:\n                    print(\"O Hammurabi, you do not own that much land!\")\n                    continue\n                if acres_to_plant > self.grain_stores / 1:  # 1 bushel per acre\n                    print(\"O Hammurabi, we have not enough grain!\")\n                    continue\n                if acres_to_plant > self.population * 10: #10 acres per person\n                    print(\"O Hammurabi, we do not have enough people to tend that land!\")\n                    continue\n                break\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n        self.grain_stores -= acres_to_plant\n        self.acres_planted = acres_to_plant\n\n    def handle_harvest(self):\n        \"\"\"\n        Handles the harvest.\n        \"\"\"\n        harvest = int(random.randint(1, 5) * self.acres_planted)\n        self.grain_stores += harvest\n        print(f\"You harvested {harvest} bushels of grain.\")\n\n    def handle_plague(self):\n        \"\"\"\n        Handles the possibility of plague.\n        \"\"\"\n        if random.randint(1, 10) == 1:\n            self.plague_deaths = int(self.population / 2)\n            self.population -= self.plague_deaths\n            print(\"A horrible plague has struck! Half the people have died.\")\n        else:\n            self.plague_deaths = 0\n\n    def handle_population(self):\n        \"\"\"\n        Handles population growth.\n        \"\"\"\n        self.population += int(self.population * (random.randint(5, 15) / 100))\n        if self.population < 0:\n            self.population = 0\n\n    def handle_rats(self):\n        \"\"\"\n        Handles rat infestations.\n        \"\"\"\n        if random.randint(1, 10) <= 3:\n            rats_ate = int(self.grain_stores * random.randint(10, 30) / 100)\n            self.grain_stores -= rats_ate\n            print(f\"Rats ate {rats_ate} bushels of grain!\")\n\n    def handle_land_price(self):\n        \"\"\"\n        Handles the fluctuation of land prices.\n        \"\"\"\n        self.price_per_acre = random.randint(17, 23)\n\n    def game_over(self):\n        \"\"\"\n        Checks if the game is over.\n        \"\"\"\n        if self.year > 10:\n            print(\"\\nYour reign is over!\")\n            print(f\"In your ten-year rule, you starved {self.starved} people on average per year.\")\n            acres_per_person = self.acres_owned / self.population\n            print(f\"You ended with {acres_per_person} acres per person.\")\n\n            if self.starved > (0.45 * self.population):\n                print(\"Due to this extreme negligence, you have not only been impeached and thrown out of office but have also been declared 'National Fickle Head'!\")\n            elif acres_per_person < 7:\n                print(\"Your heavy handed taxation and poor management have left everyone destitute. You have been impeached and thrown out of office!\")\n            elif acres_per_person < 9:\n                print(\"Your performance could have been better. Many people have fled to other kingdoms.\")\n            elif acres_per_person < 10:\n                print(\"Your performance was adequate, but not great.\")\n            else:\n                print(\"A fantastic job! You are known throughout the land as a wise and benevolent ruler!\")\n            return True\n        return False\n\n    def play_game(self):\n        \"\"\"\n        Plays the entire game.\n        \"\"\"\n        print(\"Welcome to Hammurabi!\")\n        while not self.game_over():\n            self.play_year()\n\nif __name__ == \"__main__\":\n    game = Hammurabi()\n    game.play_game()\n```",
    "11": "```python\nimport random\n\nclass LightsOut:\n    \"\"\"\n    A class to represent the Lights Out game.\n    \"\"\"\n\n    def __init__(self, size=5, initial_state=None):\n        \"\"\"\n        Initializes the Lights Out game.\n\n        Args:\n            size (int): The size of the grid (size x size).  Defaults to 5.\n            initial_state (list of lists): The initial state of the grid.\n                If None, the grid is initialized randomly.\n        \"\"\"\n        self.size = size\n        if initial_state is None:\n            self.grid = self.random_grid()\n        else:\n            self.grid = initial_state\n            self.size = len(initial_state) # ensure consistency\n            # Check if the initial state is valid\n            if not all(len(row) == self.size for row in self.grid):\n                raise ValueError(\"Invalid initial state: Grid must be square.\")\n            if not all(all(cell in [0, 1] for cell in row) for row in self.grid):\n                raise ValueError(\"Invalid initial state: Grid must contain only 0s and 1s.\")\n\n\n    def random_grid(self):\n        \"\"\"\n        Generates a random grid for the game.\n\n        Returns:\n            list of lists: A 2D list representing the grid.\n        \"\"\"\n        return [[random.randint(0, 1) for _ in range(self.size)] for _ in range(self.size)]\n\n    def print_grid(self):\n        \"\"\"\n        Prints the current state of the grid to the console.\n        \"\"\"\n        for row in self.grid:\n            print(\" \".join(map(str, row)))\n\n    def toggle(self, row, col):\n        \"\"\"\n        Toggles the state of a cell (0 to 1 or 1 to 0).\n\n        Args:\n            row (int): The row index of the cell.\n            col (int): The column index of the cell.\n        \"\"\"\n        if 0 <= row < self.size and 0 <= col < self.size:\n            self.grid[row][col] = 1 - self.grid[row][col]\n\n    def press_button(self, row, col):\n        \"\"\"\n        Simulates pressing a button at the given row and column.\n        This toggles the state of the button and its neighbors.\n\n        Args:\n            row (int): The row index of the button.\n            col (int): The column index of the button.\n        \"\"\"\n        self.toggle(row, col)\n        self.toggle(row - 1, col)\n        self.toggle(row + 1, col)\n        self.toggle(row, col - 1)\n        self.toggle(row, col + 1)\n\n    def is_solved(self):\n        \"\"\"\n        Checks if the game is solved (all lights are off).\n\n        Returns:\n            bool: True if the game is solved, False otherwise.\n        \"\"\"\n        return all(all(cell == 0 for cell in row) for row in self.grid)\n\n    def solve(self, initial_grid = None):\n        \"\"\"\n        Solves the Lights Out puzzle using brute force (for small grids).\n\n        Returns:\n            list of tuples: A list of (row, col) tuples representing the moves to solve the puzzle,\n                            or None if the puzzle is unsolvable.\n        \"\"\"\n\n        if initial_grid is None:\n            initial_grid = [row[:] for row in self.grid]  # Make a copy to restore later\n\n        n = self.size\n        max_moves = 1 << n  # Maximum number of possible moves in the first row\n\n        for i in range(max_moves):\n            # Reset the grid to the initial state for each attempt\n            self.grid = [row[:] for row in initial_grid]\n\n            moves = []\n            # Apply moves to the first row based on the binary representation of i\n            for j in range(n):\n                if (i >> j) & 1:\n                    self.press_button(0, j)\n                    moves.append((0, j))\n\n            # Apply moves to the remaining rows to turn off all lights in the previous row\n            for row in range(1, n):\n                for col in range(n):\n                    if self.grid[row - 1][col] == 1:\n                        self.press_button(row, col)\n                        moves.append((row, col))\n\n            # Check if the puzzle is solved\n            if self.is_solved():\n                return moves\n\n        return None  # Puzzle is unsolvable\n\ndef main():\n    \"\"\"\n    Main function to run the Lights Out game in the command line.\n    \"\"\"\n    size = 5  # Default grid size\n    game = LightsOut(size)\n\n    print(\"Welcome to Lights Out!\")\n    print(\"Initial grid:\")\n    game.print_grid()\n\n    while not game.is_solved():\n        try:\n            row = int(input(\"Enter row (0-{}): \".format(size - 1)))\n            col = int(input(\"Enter column (0-{}): \".format(size - 1)))\n\n            if 0 <= row < size and 0 <= col < size:\n                game.press_button(row, col)\n                print(\"Grid after move:\")\n                game.print_grid()\n            else:\n                print(\"Invalid row or column. Try again.\")\n        except ValueError:\n            print(\"Invalid input. Please enter integers.\")\n\n    print(\"Congratulations! You solved the puzzle.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
    "12": "```python\nimport time\nimport random\nimport os\n\n\nclass Pong:\n    \"\"\"\n    A command-line Pong game implementation.\n    \"\"\"\n\n    def __init__(self, width=60, height=20, paddle_length=3, max_score=10):\n        \"\"\"\n        Initializes the Pong game.\n\n        Args:\n            width (int): The width of the game board.\n            height (int): The height of the game board.\n            paddle_length (int): The length of the paddles.\n            max_score (int): The maximum score to win the game.\n        \"\"\"\n\n        self.width = width\n        self.height = height\n        self.paddle_length = paddle_length\n        self.max_score = max_score\n\n        # Paddle positions (centered vertically)\n        self.paddle_left_y = height // 2 - paddle_length // 2\n        self.paddle_right_y = height // 2 - paddle_length // 2\n\n        # Ball position and direction\n        self.ball_x = width // 2\n        self.ball_y = height // 2\n        self.ball_dx = random.choice([-1, 1])  # Initial horizontal direction\n        self.ball_dy = random.choice([-1, 1])  # Initial vertical direction\n\n        # Scores\n        self.score_left = 0\n        self.score_right = 0\n\n        self.running = True\n        self.last_update = time.time()\n        self.frame_rate = 0.1  # seconds between frames (adjust for speed)\n\n    def _clear_screen(self):\n        \"\"\"Clears the terminal screen.\"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')\n\n    def _draw_board(self):\n        \"\"\"Draws the game board with paddles, ball, and scores.\"\"\"\n        board = [[' ' for _ in range(self.width)] for _ in range(self.height)]\n\n        # Draw paddles\n        for i in range(self.paddle_length):\n            board[self.paddle_left_y + i][0] = '|'\n            board[self.paddle_right_y + i][self.width - 1] = '|'\n\n        # Draw ball\n        board[self.ball_y][self.ball_x] = 'O'\n\n        # Prepare the output string\n        output = \"\"\n\n        # Draw top border\n        output += \"+\" + (\"-\" * (self.width - 2)) + \"+\\n\"\n\n        # Draw the board content\n        for row in board:\n            output += \"|\" + \"\".join(row[1:-1]) + \"|\\n\"\n\n        # Draw bottom border\n        output += \"+\" + (\"-\" * (self.width - 2)) + \"+\\n\"\n\n        # Draw scores\n        output += f\"Score: Left {self.score_left} - Right {self.score_right}\\n\"\n        return output\n\n    def _update_ball(self):\n        \"\"\"Updates the ball's position and handles collisions.\"\"\"\n        self.ball_x += self.ball_dx\n        self.ball_y += self.ball_dy\n\n        # Bounce off top and bottom walls\n        if self.ball_y <= 0 or self.ball_y >= self.height - 1:\n            self.ball_dy *= -1\n\n        # Bounce off paddles\n        if self.ball_x <= 1 and self.paddle_left_y <= self.ball_y <= self.paddle_left_y + self.paddle_length - 1:\n            self.ball_dx *= -1\n        elif self.ball_x >= self.width - 2 and self.paddle_right_y <= self.ball_y <= self.paddle_right_y + self.paddle_length - 1:\n            self.ball_dx *= -1\n\n        # Handle scoring and reset ball position\n        if self.ball_x <= 0:\n            self.score_right += 1\n            self._reset_ball()\n        elif self.ball_x >= self.width - 1:\n            self.score_left += 1\n            self._reset_ball()\n\n    def _reset_ball(self):\n        \"\"\"Resets the ball to the center with a random direction.\"\"\"\n        self.ball_x = self.width // 2\n        self.ball_y = self.height // 2\n        self.ball_dx = random.choice([-1, 1])\n        self.ball_dy = random.choice([-1, 1])\n\n    def _move_paddle_left(self, direction):\n        \"\"\"Moves the left paddle up or down.\"\"\"\n        if direction == \"up\":\n            if self.paddle_left_y > 0:\n                self.paddle_left_y -= 1\n        elif direction == \"down\":\n            if self.paddle_left_y + self.paddle_length < self.height:\n                self.paddle_left_y += 1\n\n    def _move_paddle_right(self, direction):\n        \"\"\"Moves the right paddle up or down.\"\"\"\n        if direction == \"up\":\n            if self.paddle_right_y > 0:\n                self.paddle_right_y -= 1\n        elif direction == \"down\":\n            if self.paddle_right_y + self.paddle_length < self.height:\n                self.paddle_right_y += 1\n\n    def _get_input(self):\n        \"\"\"\n        Gets player input for paddle movement.\n        Non-blocking input is tricky in a cross-platform way in the terminal.\n        This implementation uses simple polling with a timeout.  It is not ideal,\n        but it avoids the need for external libraries.\n\n        Returns:\n            str: A string representing the player input (\"q\", \"a\", \"z\", \"k\", \"m\", or None).\n        \"\"\"\n        import select\n        import sys\n        import tty\n        import termios\n\n        fd = sys.stdin.fileno()\n        old_settings = termios.tcgetattr(fd)\n\n        try:\n            tty.setraw(sys.stdin.fileno())\n            [rlist, _, _] = select.select([sys.stdin], [], [], 0.01) # Non-blocking read with timeout\n            if rlist:\n                key = sys.stdin.read(1)\n                return key\n        finally:\n            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n        return None\n\n    def run(self):\n        \"\"\"Runs the main game loop.\"\"\"\n        print(\"Welcome to Pong!\")\n        print(\"Left paddle: 'a' (up), 'z' (down)\")\n        print(\"Right paddle: 'k' (up), 'm' (down)\")\n        print(\"Press 'q' to quit.\")\n\n        while self.running:\n            current_time = time.time()\n            if current_time - self.last_update >= self.frame_rate:\n                self._clear_screen()\n                board_str = self._draw_board()\n                print(board_str)\n\n                self._update_ball()\n\n                # Handle player input\n                user_input = self._get_input()\n                if user_input == 'q':\n                    self.running = False\n                elif user_input == 'a':\n                    self._move_paddle_left(\"up\")\n                elif user_input == 'z':\n                    self._move_paddle_left(\"down\")\n                elif user_input == 'k':\n                    self._move_paddle_right(\"up\")\n                elif user_input == 'm':\n                    self._move_paddle_right(\"down\")\n\n                self.last_update = current_time\n\n                # Check for a winner\n                if self.score_left >= self.max_score:\n                    print(\"Left player wins!\")\n                    self.running = False\n                elif self.score_right >= self.max_score:\n                    print(\"Right player wins!\")\n                    self.running = False\n        print(\"Game Over.\")\n\n\nif __name__ == \"__main__\":\n    game = Pong()\n    game.run()\n```",
    "13": "```python\nimport random\nimport os\nimport time\n\nclass Tetris:\n    \"\"\"\n    A command-line Tetris game implementation.\n    \"\"\"\n\n    WIDTH = 10\n    HEIGHT = 20\n    PIECES = {\n        'I': [[(0, 0), (0, 1), (0, 2), (0, 3)], [(0, 0), (1, 0), (2, 0), (3, 0)]],\n        'O': [[(0, 0), (0, 1), (1, 0), (1, 1)]],\n        'T': [[(0, 0), (1, 0), (2, 0), (1, 1)], [(1, 0), (1, 1), (1, 2), (0, 1)],\n              [(0, 1), (1, 1), (2, 1), (1, 0)], [(0, 1), (0, 0), (0, 2), (1, 1)]],\n        'L': [[(0, 0), (0, 1), (0, 2), (1, 2)], [(0, 0), (1, 0), (2, 0), (0, 1)],\n              [(0, 0), (1, 0), (1, 1), (1, 2)], [(2, 0), (0, 1), (1, 1), (2, 1)]],\n        'J': [[(1, 0), (1, 1), (1, 2), (0, 2)], [(0, 0), (0, 1), (1, 1), (2, 1)],\n              [(0, 0), (0, 1), (0, 2), (1, 0)], [(0, 0), (1, 0), (2, 0), (2, 1)]],\n        'S': [[(1, 0), (2, 0), (0, 1), (1, 1)], [(0, 0), (0, 1), (1, 1), (1, 2)]],\n        'Z': [[(0, 0), (1, 0), (1, 1), (2, 1)], [(1, 0), (0, 1), (1, 1), (0, 2)]]\n    }\n    COLORS = {\n        'I': 'cyan',\n        'O': 'yellow',\n        'T': 'purple',\n        'L': 'orange',\n        'J': 'blue',\n        'S': 'green',\n        'Z': 'red'\n    }\n    CLEAR_LINE_SCORE = 100\n    TETRIS_SCORE = 800\n    \n    def __init__(self, width=WIDTH, height=HEIGHT):\n        \"\"\"\n        Initializes the Tetris game.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.board = [[' ' for _ in range(width)] for _ in range(height)]\n        self.current_piece = None\n        self.current_x = 0\n        self.current_y = 0\n        self.current_rotation = 0\n        self.next_piece = None\n        self.game_over = False\n        self.score = 0\n        self.level = 1\n        self.lines_cleared = 0\n        self.delay = 0.5  # Initial delay in seconds\n        self.piece_bag = self.create_piece_bag()\n\n    def create_piece_bag(self):\n        \"\"\"Creates a bag containing all piece types.\"\"\"\n        bag = list(self.PIECES.keys())\n        random.shuffle(bag)\n        return bag\n    \n    def get_next_piece_from_bag(self):\n        \"\"\"Gets the next piece from the bag, refilling if empty.\"\"\"\n        if not self.piece_bag:\n            self.piece_bag = self.create_piece_bag()\n        return self.piece_bag.pop()\n\n    def new_piece(self):\n        \"\"\"\n        Generates a new piece at the top of the board.\n        \"\"\"\n        if self.next_piece:\n            self.current_piece = self.next_piece\n        else:\n            self.current_piece = self.get_next_piece_from_bag()\n\n        self.next_piece = self.get_next_piece_from_bag()\n        self.current_rotation = 0\n        self.current_x = self.width // 2 - 2 if self.current_piece == 'I' else self.width // 2 - 1\n        self.current_y = 0\n\n        if not self.is_valid_position():\n            self.game_over = True\n            return\n\n    def rotate_piece(self):\n        \"\"\"\n        Rotates the current piece clockwise.\n        \"\"\"\n        original_rotation = self.current_rotation\n        self.current_rotation = (self.current_rotation + 1) % len(self.PIECES[self.current_piece])\n        if not self.is_valid_position():\n            self.current_rotation = original_rotation\n\n    def move(self, dx):\n        \"\"\"\n        Moves the current piece horizontally.\n        \"\"\"\n        self.current_x += dx\n        if not self.is_valid_position():\n            self.current_x -= dx\n\n    def drop(self):\n        \"\"\"\n        Moves the current piece down one row.\n        \"\"\"\n        self.current_y += 1\n        if not self.is_valid_position():\n            self.current_y -= 1\n            self.lock_piece()\n\n    def hard_drop(self):\n        \"\"\"\n        Drops the piece to the lowest possible position.\n        \"\"\"\n        while not self.game_over:\n            self.current_y += 1\n            if not self.is_valid_position():\n                self.current_y -= 1\n                self.lock_piece()\n                return\n\n    def is_valid_position(self):\n        \"\"\"\n        Checks if the current piece's position is valid.\n        \"\"\"\n        piece_shape = self.PIECES[self.current_piece][self.current_rotation]\n        for x, y in piece_shape:\n            board_x = self.current_x + x\n            board_y = self.current_y + y\n\n            if board_x < 0 or board_x >= self.width or board_y >= self.height:\n                return False\n            if board_y >= 0 and self.board[board_y][board_x] != ' ':\n                return False\n        return True\n\n    def lock_piece(self):\n        \"\"\"\n        Locks the current piece into the board and checks for cleared lines.\n        \"\"\"\n        piece_shape = self.PIECES[self.current_piece][self.current_rotation]\n        for x, y in piece_shape:\n            self.board[self.current_y + y][self.current_x + x] = self.current_piece\n\n        self.clear_lines()\n        self.new_piece()\n\n    def clear_lines(self):\n        \"\"\"\n        Clears any full lines from the board and updates the score.\n        \"\"\"\n        lines_to_clear = []\n        for i in range(self.height):\n            if all(self.board[i][j] != ' ' for j in range(self.width)):\n                lines_to_clear.append(i)\n\n        num_lines_cleared = len(lines_to_clear)\n        if num_lines_cleared > 0:\n            for line_index in lines_to_clear:\n                del self.board[line_index]\n                self.board.insert(0, [' ' for _ in range(self.width)])\n\n            if num_lines_cleared == 4:\n                self.score += self.TETRIS_SCORE * self.level\n            else:\n                self.score += self.CLEAR_LINE_SCORE * num_lines_cleared * self.level\n\n            self.lines_cleared += num_lines_cleared\n            self.level = self.lines_cleared // 10 + 1\n            self.delay = max(0.1, 0.5 - (self.level - 1) * 0.05)\n\n    def draw_board(self):\n        \"\"\"\n        Draws the current game board and score.\n        \"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n\n        # Print score and level information\n        print(f\"Score: {self.score}, Level: {self.level}, Lines: {self.lines_cleared}\")\n\n        # Print next piece\n        print(\"Next Piece:\")\n        next_piece_shape = self.PIECES[self.next_piece][0]\n        next_piece_grid = [[' ' for _ in range(4)] for _ in range(4)]\n        for x, y in next_piece_shape:\n            next_piece_grid[y][x] = self.next_piece\n        for row in next_piece_grid:\n            print(''.join(row))\n\n        # Print the board\n        for i in range(self.height):\n            row_str = '|' + ''.join([self.board[i][j] if self.board[i][j] != ' ' else '.' for j in range(self.width)]) + '|'\n            print(row_str)\n        print(\"-\" * (self.width + 2))\n\n    def update(self):\n        \"\"\"\n        Updates the game state.\n        \"\"\"\n        self.drop()\n\n    def run(self):\n        \"\"\"\n        Runs the main game loop.\n        \"\"\"\n        self.new_piece()\n        self.next_piece = self.get_next_piece_from_bag()\n\n        while not self.game_over:\n            self.draw_board()\n            start_time = time.time()\n            \n            # Get user input (non-blocking)\n            user_input = self.get_user_input(self.delay)\n\n            if user_input == 'q':\n                break\n\n            if user_input == 'a':\n                self.move(-1)\n            elif user_input == 'd':\n                self.move(1)\n            elif user_input == 's':\n                self.drop()\n            elif user_input == 'w':\n                self.rotate_piece()\n            elif user_input == ' ':\n                self.hard_drop()\n\n            time_elapsed = time.time() - start_time\n            sleep_time = max(0, self.delay - time_elapsed)\n            time.sleep(sleep_time)  # Control game speed\n            self.update()\n\n        self.draw_board()\n        print(\"Game Over!\")\n        print(f\"Final Score: {self.score}\")\n\n    def get_user_input(self, timeout):\n        \"\"\"\n        Gets user input with a timeout.\n        \"\"\"\n        import select, sys\n\n        rlist, _, _ = select.select([sys.stdin], [], [], timeout)\n        if rlist:\n            return sys.stdin.readline().strip().lower()\n        else:\n            return ''\n\n    def place_piece_on_board(self):\n        \"\"\"Places the current piece on the board for rendering.\"\"\"\n        piece_shape = self.PIECES[self.current_piece][self.current_rotation]\n        temp_board = [row[:] for row in self.board]  # Create a copy of the board\n\n        for x, y in piece_shape:\n            board_x = self.current_x + x\n            board_y = self.current_y + y\n\n            if 0 <= board_x < self.width and 0 <= board_y < self.height:\n                temp_board[board_y][board_x] = self.current_piece\n        return temp_board\n\n\nif __name__ == '__main__':\n    game = Tetris()\n    game.run()\n```",
    "14": "```python\nimport math\nimport random\nimport time\n\nclass AsteroidGame:\n    \"\"\"\n    A command-line Asteroid game.\n    \"\"\"\n\n    def __init__(self, width=80, height=20, asteroid_count=5, max_speed=1.0):\n        \"\"\"\n        Initializes the game.\n\n        Args:\n            width (int): Width of the game board.\n            height (int): Height of the game board.\n            asteroid_count (int): Number of asteroids at the start.\n            max_speed (float): Maximum speed of asteroids.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.asteroid_count = asteroid_count\n        self.max_speed = max_speed\n        self.player_x = width // 2\n        self.player_y = height // 2\n        self.player_angle = 0  # Radians\n        self.player_speed = 0\n        self.asteroids = []\n        self.bullets = []\n        self.game_over = False\n        self.score = 0\n        self.lives = 3\n        self.last_shot_time = 0  # To limit firing rate\n        self.bullet_cooldown = 0.2  # Seconds between shots\n\n        self.initialize_asteroids()\n\n    def initialize_asteroids(self):\n        \"\"\"\n        Creates the initial asteroids.\n        \"\"\"\n        self.asteroids = []\n        for _ in range(self.asteroid_count):\n            x = random.randint(0, self.width - 1)\n            y = random.randint(0, self.height - 1)\n            angle = random.uniform(0, 2 * math.pi)\n            speed = random.uniform(0.1, self.max_speed)\n            self.asteroids.append({\n                'x': x,\n                'y': y,\n                'angle': angle,\n                'speed': speed,\n                'size': 2  # Small size for now\n            })\n\n    def update(self, action):\n        \"\"\"\n        Updates the game state based on player action.\n\n        Args:\n            action (str): Player action ('left', 'right', 'forward', 'fire', 'none').\n        \"\"\"\n        if self.game_over:\n            return\n\n        # Player movement\n        if action == 'left':\n            self.player_angle -= 0.2\n        elif action == 'right':\n            self.player_angle += 0.2\n        elif action == 'forward':\n            self.player_speed = min(5, self.player_speed + 0.5) # Speed Limit\n\n        # Decelerate\n        self.player_speed = max(0, self.player_speed - 0.1)\n\n        dx = self.player_speed * math.cos(self.player_angle)\n        dy = self.player_speed * math.sin(self.player_angle)\n        self.player_x = (self.player_x + dx) % self.width\n        self.player_y = (self.player_y + dy) % self.height\n\n        # Shooting\n        current_time = time.time()\n        if action == 'fire' and current_time - self.last_shot_time > self.bullet_cooldown:\n            self.fire_bullet()\n            self.last_shot_time = current_time\n        \n        # Update bullets\n        self.update_bullets()\n\n        # Update asteroids\n        self.update_asteroids()\n\n        # Check for collisions\n        self.check_collisions()\n\n    def fire_bullet(self):\n        \"\"\"\n        Fires a bullet from the player's position.\n        \"\"\"\n        bullet_speed = 8  # Bullet speed\n        bullet_x = self.player_x\n        bullet_y = self.player_y\n        bullet_angle = self.player_angle\n        self.bullets.append({\n            'x': bullet_x,\n            'y': bullet_y,\n            'angle': bullet_angle,\n            'speed': bullet_speed\n        })\n\n    def update_bullets(self):\n        \"\"\"\n        Updates the position of all bullets and removes those that are out of bounds.\n        \"\"\"\n        new_bullets = []\n        for bullet in self.bullets:\n            dx = bullet['speed'] * math.cos(bullet['angle'])\n            dy = bullet['speed'] * math.sin(bullet['angle'])\n            bullet['x'] = (bullet['x'] + dx) % self.width\n            bullet['y'] = (bullet['y'] + dy) % self.height\n\n            # Keep bullets if within bounds\n            if 0 <= bullet['x'] < self.width and 0 <= bullet['y'] < self.height:\n                new_bullets.append(bullet)\n\n        self.bullets = new_bullets\n\n    def update_asteroids(self):\n        \"\"\"\n        Updates the position of all asteroids.\n        \"\"\"\n        for asteroid in self.asteroids:\n            dx = asteroid['speed'] * math.cos(asteroid['angle'])\n            dy = asteroid['speed'] * math.sin(asteroid['angle'])\n            asteroid['x'] = (asteroid['x'] + dx) % self.width\n            asteroid['y'] = (asteroid['y'] + dy) % self.height\n\n    def check_collisions(self):\n        \"\"\"\n        Checks for collisions between player, asteroids, and bullets.\n        \"\"\"\n        # Player-Asteroid collision\n        for asteroid in self.asteroids:\n            distance = math.sqrt((self.player_x - asteroid['x'])**2 + (self.player_y - asteroid['y'])**2)\n            if distance < asteroid['size'] + 1:  # Collision radius\n                self.lives -= 1\n                self.player_x = self.width // 2\n                self.player_y = self.height // 2\n                self.player_speed = 0\n                self.initialize_asteroids()  # Reset Asteroids\n                if self.lives <= 0:\n                    self.game_over = True\n                return  # Only lose one life per frame\n\n        # Bullet-Asteroid collision\n        new_asteroids = []\n        new_bullets = []\n        for asteroid in self.asteroids:\n            hit = False\n            for bullet in self.bullets:\n                distance = math.sqrt((bullet['x'] - asteroid['x'])**2 + (bullet['y'] - asteroid['y'])**2)\n                if distance < asteroid['size']:\n                    self.score += 10\n                    hit = True\n                    break  # One bullet can only hit one asteroid\n            if not hit:\n                new_asteroids.append(asteroid)\n            else:\n                # Split asteroid (simple version - just remove)\n                pass\n\n            if not hit:\n                new_asteroids.append(asteroid)\n\n        for bullet in self.bullets:\n            hit = False\n            for asteroid in self.asteroids:\n                distance = math.sqrt((bullet['x'] - asteroid['x'])**2 + (bullet['y'] - asteroid['y'])**2)\n                if distance < asteroid['size']:\n                    hit = True\n                    break\n            if not hit:\n                new_bullets.append(bullet)\n\n        self.asteroids = new_asteroids\n        self.bullets = new_bullets\n\n        if not self.asteroids:\n            self.asteroid_count += 2 # Increased Difficulty\n            self.initialize_asteroids()\n\n    def draw(self):\n        \"\"\"\n        Draws the game state to the console.\n\n        Returns:\n            str: A string representation of the game board.\n        \"\"\"\n        board = [[' ' for _ in range(self.width)] for _ in range(self.height)]\n\n        # Draw player (triangle for simplicity)\n        player_x = int(round(self.player_x))\n        player_y = int(round(self.player_y))\n        if 0 <= player_x < self.width and 0 <= player_y < self.height:\n           board[player_y][player_x] = '^'\n\n        # Draw asteroids\n        for asteroid in self.asteroids:\n            x = int(round(asteroid['x']))\n            y = int(round(asteroid['y']))\n            if 0 <= x < self.width and 0 <= y < self.height:\n                board[y][x] = 'O'\n\n        # Draw bullets\n        for bullet in self.bullets:\n            x = int(round(bullet['x']))\n            y = int(round(bullet['y']))\n            if 0 <= x < self.width and 0 <= y < self.height:\n                board[y][x] = '.'\n\n        # Convert board to string\n        output = \"\"\n        for row in board:\n            output += ''.join(row) + '\\n'\n\n        # Add score and lives\n        output += f\"Score: {self.score}  Lives: {self.lives}\\n\"\n\n        if self.game_over:\n            output = \"Game Over!\\n\" + output\n\n        return output\n\n    def play(self):\n        \"\"\"\n        Runs the main game loop.\n        \"\"\"\n        while not self.game_over:\n            print(self.draw())\n            action = input(\"Action (left, right, forward, fire, none): \").lower()\n            self.update(action)\n            time.sleep(0.05)  # Control game speed\n\n        print(self.draw())\n        print(\"Final Score:\", self.score)\n\nif __name__ == '__main__':\n    game = AsteroidGame()\n    game.play()\n```",
    "15": "```python\nimport random\nimport time\nimport sys\n\nclass Boggle:\n    \"\"\"\n    A class to represent a Boggle game.\n    \"\"\"\n\n    def __init__(self, size=4, time_limit=180):\n        \"\"\"\n        Initializes a new Boggle game.\n\n        Args:\n            size (int): The size of the Boggle board (size x size). Defaults to 4.\n            time_limit (int): The time limit for the game in seconds. Defaults to 180.\n        \"\"\"\n        self.size = size\n        self.time_limit = time_limit\n        self.board = self.generate_board()\n        self.dictionary = self.load_dictionary(\"dictionary.txt\")  # Ensure dictionary.txt exists\n        self.found_words = set()\n        self.start_time = 0\n        self.game_over = False\n\n    def generate_board(self):\n        \"\"\"\n        Generates a random Boggle board.\n\n        Returns:\n            list[list[str]]: A 2D list representing the Boggle board.\n        \"\"\"\n        dice = [\n            \"RIFOBX\", \"IFEHEE\", \"PTDHIS\", \"LNNZNH\", \"TOEUIS\", \"SIAETI\",\n            \"UMQOJI\", \"EHIFSE\", \"ELRTTY\", \"ACHOPS\", \"SPHDEE\", \"VCLPTU\",\n            \"AENNNG\", \"LETSAS\", \"BGLRYY\", \"AAEEGN\"\n        ]\n        if self.size > 4:\n            dice = dice + [\n                \"RIFOBX\", \"IFEHEE\", \"PTDHIS\", \"LNNZNH\", \"TOEUIS\", \"SIAETI\",\n                \"UMQOJI\", \"EHIFSE\", \"ELRTTY\", \"ACHOPS\", \"SPHDEE\", \"VCLPTU\",\n                \"AENNNG\", \"LETSAS\", \"BGLRYY\", \"AAEEGN\"\n            ][: self.size * self.size - 16]\n\n        random.shuffle(dice)\n        board = []\n        for i in range(self.size):\n            row = []\n            for j in range(self.size):\n                die = dice[i * self.size + j]\n                row.append(random.choice(die))\n            board.append(row)\n        return board\n\n    def load_dictionary(self, filename=\"dictionary.txt\"):\n        \"\"\"\n        Loads a dictionary of valid words from a file.\n\n        Args:\n            filename (str): The name of the dictionary file. Defaults to \"dictionary.txt\".\n\n        Returns:\n            set[str]: A set of valid words.\n        \"\"\"\n        try:\n            with open(filename, \"r\") as file:\n                words = {word.strip().upper() for word in file}\n            return words\n        except FileNotFoundError:\n            print(f\"Error: Dictionary file '{filename}' not found.\")\n            sys.exit(1)\n\n    def print_board(self):\n        \"\"\"\n        Prints the Boggle board to the console.\n        \"\"\"\n        print(\"Boggle Board:\")\n        for row in self.board:\n            print(\" \".join(row))\n        print()\n\n    def is_valid_word(self, word):\n        \"\"\"\n        Checks if a word is a valid word in the dictionary and has not been found yet.\n\n        Args:\n            word (str): The word to check.\n\n        Returns:\n            bool: True if the word is valid, False otherwise.\n        \"\"\"\n        word = word.upper()\n        return (\n            word in self.dictionary\n            and word not in self.found_words\n            and len(word) >= 3  # Minimum word length\n        )\n\n    def find_word_on_board(self, word):\n        \"\"\"\n        Checks if a word can be found on the Boggle board using a depth-first search.\n\n        Args:\n            word (str): The word to find.\n\n        Returns:\n            bool: True if the word is found, False otherwise.\n        \"\"\"\n        word = word.upper()\n        for row in range(self.size):\n            for col in range(self.size):\n                if self._find_word_recursive(word, row, col, 0, set()):\n                    return True\n        return False\n\n    def _find_word_recursive(self, word, row, col, index, visited):\n        \"\"\"\n        Recursive helper function for find_word_on_board.\n\n        Args:\n            word (str): The word to find.\n            row (int): The current row index.\n            col (int): The current column index.\n            index (int): The current index in the word.\n            visited (set[tuple[int, int]]): A set of visited cells.\n\n        Returns:\n            bool: True if the word is found, False otherwise.\n        \"\"\"\n        if index == len(word):\n            return True\n\n        if (\n            row < 0\n            or row >= self.size\n            or col < 0\n            or col >= self.size\n            or (row, col) in visited\n            or self.board[row][col] != word[index]\n        ):\n            return False\n\n        visited.add((row, col))\n\n        # Explore neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                if self._find_word_recursive(word, row + dr, col + dc, index + 1, visited.copy()):\n                    return True\n\n        return False\n\n    def start_game(self):\n        \"\"\"\n        Starts the Boggle game.\n        \"\"\"\n        self.found_words = set()\n        self.start_time = time.time()\n        self.game_over = False\n\n        print(\"Welcome to Boggle!\")\n        self.print_board()\n        print(f\"You have {self.time_limit} seconds to find words.\")\n\n        while not self.game_over:\n            elapsed_time = time.time() - self.start_time\n            remaining_time = max(0, self.time_limit - elapsed_time)\n            print(f\"Time remaining: {int(remaining_time)} seconds\")\n\n            if remaining_time == 0:\n                self.end_game()\n                break\n\n            word = input(\"Enter a word (or 'quit' to end): \").strip()\n\n            if word.lower() == \"quit\":\n                self.end_game()\n                break\n\n            if self.is_valid_word(word) and self.find_word_on_board(word):\n                self.found_words.add(word.upper())\n                print(\"Valid word!\")\n            else:\n                print(\"Invalid word.\")\n\n    def calculate_score(self):\n        \"\"\"\n        Calculates the player's score based on the found words.\n\n        Returns:\n            int: The player's score.\n        \"\"\"\n        score = 0\n        for word in self.found_words:\n            length = len(word)\n            if length == 3 or length == 4:\n                score += 1\n            elif length == 5:\n                score += 2\n            elif length == 6:\n                score += 3\n            elif length == 7:\n                score += 5\n            elif length >= 8:\n                score += 11\n        return score\n\n    def end_game(self):\n        \"\"\"\n        Ends the Boggle game and displays the results.\n        \"\"\"\n        self.game_over = True\n        print(\"\\nTime's up!\")\n        print(\"Words you found:\")\n        for word in sorted(self.found_words):\n            print(word)\n\n        score = self.calculate_score()\n        print(f\"\\nYour score: {score}\")\n\n        # Find words the player missed (optional)\n        missed_words = self.find_all_words() - self.found_words\n\n        if missed_words:\n            print(\"\\nPossible words you missed:\")\n            for word in sorted(missed_words):\n                print(word)\n\n\n    def find_all_words(self):\n        \"\"\"\n        Finds all possible words on the board using the dictionary.  This is very slow and\n        should only be called at the end of the game.\n\n        Returns:\n            set[str]: A set of all possible words.\n        \"\"\"\n        all_words = set()\n        for word in self.dictionary:\n            if self.find_word_on_board(word):\n                all_words.add(word)\n        return all_words\n\n\nif __name__ == \"__main__\":\n    # Example usage:\n    game = Boggle(size=4, time_limit=60)  # You can adjust size and time limit\n    game.start_game()\n```",
    "16": "```python\nimport random\nimport sys\n\nclass PacMan:\n    \"\"\"\n    A command-line Pac-Man game.\n    \"\"\"\n\n    def __init__(self, width=15, height=10, num_ghosts=2, initial_lives=3):\n        \"\"\"\n        Initializes the game board and game state.\n\n        Args:\n            width (int): The width of the game board.\n            height (int): The height of the game board.\n            num_ghosts (int): The number of ghosts in the game.\n            initial_lives (int): The number of lives Pac-Man starts with.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.num_ghosts = num_ghosts\n        self.initial_lives = initial_lives\n        self.board = [['.' for _ in range(width)] for _ in range(height)]\n        self.pacman_x = width // 2\n        self.pacman_y = height // 2\n        self.board[self.pacman_y][self.pacman_x] = 'P'\n        self.ghosts = []\n        for _ in range(num_ghosts):\n            self.add_ghost()\n        self.score = 0\n        self.lives = initial_lives\n        self.game_over = False\n        self.total_dots = width * height - num_ghosts - 1 # - Pacman and Ghosts\n        self.dots_eaten = 0\n\n\n    def add_ghost(self):\n        \"\"\"\n        Adds a new ghost to the game board at a random available location.\n        \"\"\"\n        while True:\n            x = random.randint(0, self.width - 1)\n            y = random.randint(0, self.height - 1)\n            if self.board[y][x] == '.':\n                self.ghosts.append((x, y))\n                self.board[y][x] = 'G'\n                break\n\n    def print_board(self):\n        \"\"\"\n        Prints the current game board to the console.\n        \"\"\"\n        for row in self.board:\n            print(''.join(row))\n        print(f\"Score: {self.score}, Lives: {self.lives}\")\n\n    def move_pacman(self, direction):\n        \"\"\"\n        Moves Pac-Man in the specified direction.\n\n        Args:\n            direction (str): The direction to move ('up', 'down', 'left', 'right').\n        \"\"\"\n        new_x = self.pacman_x\n        new_y = self.pacman_y\n\n        if direction == 'up':\n            new_y -= 1\n        elif direction == 'down':\n            new_y += 1\n        elif direction == 'left':\n            new_x -= 1\n        elif direction == 'right':\n            new_x += 1\n        else:\n            print(\"Invalid direction.\")\n            return\n\n        if 0 <= new_x < self.width and 0 <= new_y < self.height:\n            if self.board[new_y][new_x] == '.':\n                self.score += 1\n                self.dots_eaten += 1\n            elif self.board[new_y][new_x] == 'G':\n                self.lose_life()\n                return\n\n\n            self.board[self.pacman_y][self.pacman_x] = ' ' # Clear old Pac-Man position\n            self.pacman_x = new_x\n            self.pacman_y = new_y\n            self.board[self.pacman_y][self.pacman_x] = 'P'\n            self.move_ghosts()\n\n    def move_ghosts(self):\n        \"\"\"\n        Moves each ghost randomly.\n        \"\"\"\n        for i in range(len(self.ghosts)):\n            old_x, old_y = self.ghosts[i]\n            self.board[old_y][old_x] = ' '  # Clear old ghost position\n\n            while True:\n                dx = random.choice([-1, 0, 1])\n                dy = random.choice([-1, 0, 1])\n                if abs(dx) + abs(dy) != 1:\n                    continue\n\n                new_x = old_x + dx\n                new_y = old_y + dy\n\n                if 0 <= new_x < self.width and 0 <= new_y < self.height and self.board[new_y][new_x] != 'G' and self.board[new_y][new_x] != 'P':\n                    break\n\n            self.ghosts[i] = (new_x, new_y)\n            if self.board[new_y][new_x] == 'P':\n                self.lose_life()\n                return\n\n\n            self.board[new_y][new_x] = 'G'\n\n    def lose_life(self):\n        \"\"\"\n        Handles the event when Pac-Man loses a life.\n        \"\"\"\n        self.lives -= 1\n        if self.lives <= 0:\n            self.game_over = True\n            print(\"Game Over!\")\n        else:\n            print(\"You lost a life!\")\n            self.reset_pacman_position()\n            self.reset_ghost_positions()\n\n\n    def reset_pacman_position(self):\n         \"\"\"Resets Pac-Man's position to the center of the board.\"\"\"\n         self.board[self.pacman_y][self.pacman_x] = ' '\n         self.pacman_x = self.width // 2\n         self.pacman_y = self.height // 2\n         self.board[self.pacman_y][self.pacman_x] = 'P'\n\n    def reset_ghost_positions(self):\n        \"\"\"Resets the ghost positions, placing them randomly on the board.\"\"\"\n        for x, y in self.ghosts:\n            self.board[y][x] = ' '\n        self.ghosts = []\n        for _ in range(self.num_ghosts):\n            self.add_ghost()\n\n\n    def is_win(self):\n        \"\"\"\n        Checks if the player has won the game.\n        \"\"\"\n        return self.dots_eaten == self.total_dots\n\n    def play(self):\n        \"\"\"\n        Main game loop.\n        \"\"\"\n        while not self.game_over:\n            self.print_board()\n            if self.is_win():\n                print(\"You Win!\")\n                break\n\n\n            direction = input(\"Enter move (up, down, left, right, quit): \").lower()\n\n            if direction == 'quit':\n                print(\"Quitting the game.\")\n                break\n\n            self.move_pacman(direction)\n\n        if self.game_over:\n             self.print_board()\n             print(\"Final Score:\", self.score)\n\n\n\nif __name__ == \"__main__\":\n    game = PacMan()\n    game.play()\n```",
    "17": "```python\nimport random\nimport time\nimport os\n\nclass DinosaurRunner:\n    \"\"\"\n    A command-line implementation of the Dinosaur Runner game.\n    \"\"\"\n\n    def __init__(self, width=60, initial_speed=1):\n        \"\"\"\n        Initializes the game.\n\n        Args:\n            width (int): The width of the game screen.\n            initial_speed (float): The initial speed of the game.\n        \"\"\"\n        self.width = width\n        self.initial_speed = initial_speed\n        self.speed = initial_speed\n        self.dino_position = 5\n        self.obstacle_position = width - 5\n        self.obstacle_height = 1\n        self.score = 0\n        self.game_over = False\n        self.last_obstacle_time = time.time()\n        self.obstacle_interval = 2  # Initial obstacle generation interval (seconds)\n        self.level = 1\n\n    def clear_screen(self):\n        \"\"\"\n        Clears the console screen. Works cross-platform.\n        \"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')\n\n    def generate_obstacle(self):\n        \"\"\"\n        Generates a new obstacle.  Obstacle height is randomly 1 or 2.\n        \"\"\"\n        self.obstacle_position = self.width - 5\n        self.obstacle_height = random.choice([1, 2])  # Introduce varying obstacle height\n        self.last_obstacle_time = time.time()\n\n    def update(self):\n        \"\"\"\n        Updates the game state.\n        \"\"\"\n        if self.game_over:\n            return\n\n        # Move the obstacle\n        self.obstacle_position -= self.speed\n        if self.obstacle_position < 0:\n            self.generate_obstacle()\n            self.score += 1\n            self.obstacle_interval = max(0.5, self.obstacle_interval - 0.01) #difficulty increase\n\n        # Check for collision\n        if self.dino_position < self.obstacle_position < self.dino_position + 3:\n            if self.obstacle_height == 2 and self.dino_position < 3:\n                self.game_over = True\n            elif self.obstacle_height == 1:\n                self.game_over = True\n\n        # Increase speed gradually\n        self.speed = self.initial_speed + (self.score / 20)\n        # Update level\n        self.level = int(self.score / 5) + 1\n\n    def render(self):\n        \"\"\"\n        Renders the game screen.\n        \"\"\"\n        screen = [' '] * self.width\n        # Draw dinosaur\n        screen[self.dino_position] = 'D'\n        screen[self.dino_position + 1] = 'i'\n        screen[self.dino_position + 2] = 'n'\n\n        # Draw obstacle\n        if self.obstacle_position < self.width:\n            if self.obstacle_height == 1:\n                screen[int(self.obstacle_position)] = '#'\n            else:  # obstacle_height == 2\n                screen[int(self.obstacle_position)] = 'H'\n                if int(self.obstacle_position) + 1 < self.width:\n                    screen[int(self.obstacle_position) + 1] = 'H'\n\n        # Display score and level\n        score_display = f\"Score: {self.score}  Level: {self.level}\"\n        screen_str = ''.join(screen)\n        print(f\"{score_display:^{self.width}}\")  # Center-align score\n        print(\"-\" * self.width)\n        print(screen_str)\n        print(\"-\" * self.width)\n\n        if self.game_over:\n            print(\"Game Over!\")\n\n\n    def jump(self):\n        \"\"\"\n        Makes the dinosaur jump (moves it up).\n        \"\"\"\n        if self.dino_position == 5:\n            self.dino_position = 2\n\n    def duck(self):\n        \"\"\"\n        Makes the dinosaur duck (moves it down).\n        \"\"\"\n        if self.dino_position == 2:\n            self.dino_position = 5\n\n    def run(self):\n        \"\"\"\n        Runs the main game loop.\n        \"\"\"\n        while not self.game_over:\n            start_time = time.time()\n\n            # Get user input (non-blocking)\n            # This part is difficult in pure command-line Python without external libraries.\n            # For simplicity, we'll skip real-time input and rely on a fixed update rate.\n\n            self.update()\n            self.clear_screen()\n            self.render()\n\n            # Control game speed\n            elapsed_time = time.time() - start_time\n            sleep_time = max(0, 0.1 - elapsed_time)  # Target update rate: 10 FPS\n            time.sleep(sleep_time)\n\n        print(\"Final Score:\", self.score)\n\n\nif __name__ == \"__main__\":\n    game = DinosaurRunner()\n\n    # Simple input handling (replace with proper input if possible)\n    print(\"Dinosaur Runner - Command Line Edition\")\n    print(\"Press Enter to jump, any other key to duck.  Ctrl+C to quit.\")\n\n    import threading\n\n    def input_thread(game_instance):\n        \"\"\"Handles user input in a separate thread.\"\"\"\n        while not game_instance.game_over:\n            try:\n                user_input = input()  # This blocks, hence the thread\n                if user_input == \"\":\n                    game_instance.jump()\n                    time.sleep(0.2)\n                    game_instance.duck() #duck after jump\n                else:\n                    game_instance.duck()\n                    time.sleep(0.2)\n                    game_instance.jump()#jump after duck\n            except EOFError:  # Handle Ctrl+C gracefully\n                game_instance.game_over = True\n                break\n            except KeyboardInterrupt:\n                game_instance.game_over = True\n                break\n\n\n    input_thread_obj = threading.Thread(target=input_thread, args=(game,))\n    input_thread_obj.daemon = True  # Allow the main thread to exit\n    input_thread_obj.start()\n\n    game.run()\n```"
}