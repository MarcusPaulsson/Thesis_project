{
    "10": "```python\nclass BinaryDataProcessor:\n    \"\"\"\n    This is a class used to process binary data, which includes functions such as clearing non 0 or 1 characters, counting binary string information, and converting to corresponding strings based on different encoding methods.\n    \"\"\"\n\n    def __init__(self, binary_string):\n        \"\"\"\n        Initialize the class with a binary string and clean it by removing all non 0 or 1 characters.\n        \"\"\"\n        self.binary_string = binary_string\n        self.clean_non_binary_chars()\n\n    def clean_non_binary_chars(self):\n        \"\"\"\n        Clean the binary string by removing all non 0 or 1 characters.\n        \"\"\"\n        self.binary_string = ''.join(char for char in self.binary_string if char in '01')\n\n    def calculate_binary_info(self):\n        \"\"\"\n        Calculate the binary string information, including the percentage of 0 and 1, and the total length of the binary string.\n        \"\"\"\n        bit_length = len(self.binary_string)\n        if bit_length == 0:\n            return {'Bit length': 0, 'Ones': 0, 'Zeroes': 0}\n\n        zeroes = self.binary_string.count('0')\n        ones = self.binary_string.count('1')\n        zeroes_percentage = zeroes / bit_length\n        ones_percentage = ones / bit_length\n\n        return {'Zeroes': zeroes_percentage, 'Ones': ones_percentage, 'Bit length': bit_length}\n\n    def convert_to_ascii(self):\n        \"\"\"\n        Convert the binary string to ascii string.\n        \"\"\"\n        ascii_string = ''\n        for i in range(0, len(self.binary_string), 8):\n            byte = self.binary_string[i:i+8]\n            if len(byte) == 8:\n                try:\n                    decimal_value = int(byte, 2)\n                    ascii_string += chr(decimal_value)\n                except ValueError:\n                    # Handle cases where the byte is not a valid binary representation\n                    pass\n        return ascii_string\n\n    def convert_to_utf8(self):\n        \"\"\"\n        Convert the binary string to utf-8 string.\n        \"\"\"\n        return self.convert_to_ascii()\n```",
    "11": "```python\nclass BitStatusUtil:\n    \"\"\"\n    This is a utility class that provides methods for manipulating and checking status using bitwise operations.\n    \"\"\"\n\n    @staticmethod\n    def add(states, stat):\n        \"\"\"\n        Add a status to the current status.\n\n        :param states: Current status, int.\n        :param stat: Status to be added, int.\n        :return: The status after adding the status, int.\n        :raises TypeError: if inputs are not integers.\n        :raises ValueError: if inputs are negative or odd.\n        \"\"\"\n        if not isinstance(states, int) or not isinstance(stat, int):\n            raise TypeError(\"Inputs must be integers.\")\n        if states < 0 or stat < 0:\n            raise ValueError(\"Inputs must be non-negative.\")\n        if states % 2 != 0 or stat % 2 != 0:\n            raise ValueError(\"Inputs must be even.\")\n        return states | stat\n\n    @staticmethod\n    def has(states, stat):\n        \"\"\"\n        Check if the current status contains the specified status.\n\n        :param states: Current status, int.\n        :param stat: Specified status, int.\n        :return: True if the current status contains the specified status, otherwise False.\n        :raises TypeError: if inputs are not integers.\n        :raises ValueError: if inputs are negative or odd.\n        \"\"\"\n        if not isinstance(states, int) or not isinstance(stat, int):\n            raise TypeError(\"Inputs must be integers.\")\n        if states < 0 or stat < 0:\n            raise ValueError(\"Inputs must be non-negative.\")\n        if states % 2 != 0 or stat % 2 != 0:\n            raise ValueError(\"Inputs must be even.\")\n        return (states & stat) == stat\n\n    @staticmethod\n    def remove(states, stat):\n        \"\"\"\n        Remove the specified status from the current status.\n\n        :param states: Current status, int.\n        :param stat: Specified status, int.\n        :return: The status after removing the specified status, int.\n        :raises TypeError: if inputs are not integers.\n        :raises ValueError: if inputs are negative or odd.\n        \"\"\"\n        if not isinstance(states, int) or not isinstance(stat, int):\n            raise TypeError(\"Inputs must be integers.\")\n        if states < 0 or stat < 0:\n            raise ValueError(\"Inputs must be non-negative.\")\n        if states % 2 != 0 or stat % 2 != 0:\n            raise ValueError(\"Inputs must be even.\")\n        return states & ~stat\n\n    @staticmethod\n    def check(args):\n        \"\"\"\n        Check if the parameters are legal.\n\n        :param args: Parameters to be checked, list.\n        :raises TypeError: if any input is not an integer.\n        :raises ValueError: if any input is negative or odd.\n        \"\"\"\n        for arg in args:\n            if not isinstance(arg, int):\n                raise TypeError(\"Inputs must be integers.\")\n            if arg < 0:\n                raise ValueError(\"Inputs must be non-negative.\")\n            if arg % 2 != 0:\n                raise ValueError(f\"{arg} not even\")\n```",
    "12": "```python\nimport random\nclass BlackjackGame:\n    \"\"\"\n    This is a class representing a game of blackjack, which includes creating a deck, calculating the value of a hand, and determine the winner based on the hand values of the player and dealer.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Blackjack Game with the attribute deck, player_hand and dealer_hand.\n        While initializing deck attribute, call the create_deck method to generate.\n        The deck stores 52 rondom order poker with the Jokers removed, format is ['AS', '2S', ...].\n        player_hand is a list which stores player's hand cards.\n        dealer_hand is is a list which stores dealer's hand cards.\n        \"\"\"\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n\n    def create_deck(self):\n        \"\"\"\n        Create a deck of 52 cards, which stores 52 rondom order poker with the Jokers removed.\n        :return: a list of 52 rondom order poker with the Jokers removed, format is ['AS', '2S', ...].\n        \"\"\"\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n        deck = [rank + suit for suit in suits for rank in ranks]\n        random.shuffle(deck)\n        return deck\n\n    def calculate_hand_value(self, hand):\n        \"\"\"\n        Calculate the value of the poker cards stored in hand list according to the rules of the Blackjack Game.\n        If the card is a digit, its value is added to the total hand value.\n        Value of J, Q, or K is 10, while Aces are worth 11.\n        If the total hand value exceeds 21 and there are Aces present, one Ace is treated as having a value of 1 instead of 11,\n        until the hand value is less than or equal to 21, or all Aces have been counted as value of 1.\n        :param hand: list\n        :return: the value of the poker cards stored in hand list, a number.\n        \"\"\"\n        value = 0\n        ace_count = 0\n        for card in hand:\n            rank = card[:-1]\n            if rank.isdigit():\n                value += int(rank)\n            elif rank in ['J', 'Q', 'K']:\n                value += 10\n            elif rank == 'A':\n                value += 11\n                ace_count += 1\n\n        while value > 21 and ace_count > 0:\n            value -= 10\n            ace_count -= 1\n\n        return value\n\n    def check_winner(self, player_hand, dealer_hand):\n        \"\"\"\n        Determines the winner of a game by comparing the hand values of the player and dealer.\n        rule:\n        If both players have hand values that are equal to or less than 21, the winner is the one whose hand value is closer to 21.\n        Otherwise, the winner is the one with the lower hand value.\n        :param player_hand: list\n        :param dealer_hand: list\n        :return: the result of the game, only two certain str: 'Dealer wins' or 'Player wins'\n        \"\"\"\n        player_value = self.calculate_hand_value(player_hand)\n        dealer_value = self.calculate_hand_value(dealer_hand)\n\n        if player_value > 21:\n            return 'Dealer wins'\n        elif dealer_value > 21:\n            return 'Player wins'\n        elif player_value > dealer_value:\n            return 'Player wins'\n        else:\n            return 'Dealer wins'\n```",
    "13": "```python\nclass BookManagement:\n    \"\"\"\n    This is a class for managing books, supporting adding, removing, viewing inventory,\n    and checking the quantity of a specific book.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the book inventory as an empty dictionary.\n        \"\"\"\n        self.inventory = {}\n\n    def add_book(self, title, quantity=1):\n        \"\"\"\n        Adds a book to the inventory or increases its quantity if it already exists.\n\n        :param title: The title of the book (string).\n        :param quantity: The quantity to add (integer, default is 1).\n        \"\"\"\n        if title in self.inventory:\n            self.inventory[title] += quantity\n        else:\n            self.inventory[title] = quantity\n\n    def remove_book(self, title, quantity):\n        \"\"\"\n        Removes books from the inventory.\n\n        :param title: The title of the book to remove (string).\n        :param quantity: The quantity to remove (integer).\n        :raises Exception: If the book is not found, the quantity is invalid,\n                          or the quantity to remove exceeds the available quantity.\n        \"\"\"\n        if title not in self.inventory:\n            raise Exception(\"Book not found in inventory.\")\n        if quantity <= 0:\n            raise Exception(\"Quantity must be positive.\")\n        if quantity > self.inventory[title]:\n            raise Exception(\"Quantity to remove exceeds available quantity.\")\n\n        self.inventory[title] -= quantity\n        if self.inventory[title] == 0:\n            del self.inventory[title]\n\n    def view_inventory(self):\n        \"\"\"\n        Returns the current inventory.\n\n        :return: A dictionary representing the inventory, where keys are book titles\n                 and values are their quantities.\n        \"\"\"\n        return self.inventory\n\n    def view_book_quantity(self, title):\n        \"\"\"\n        Returns the quantity of a specific book in the inventory.\n\n        :param title: The title of the book (string).\n        :return: The quantity of the book (integer). Returns 0 if the book is not found.\n        \"\"\"\n        return self.inventory.get(title, 0)\n```",
    "14": "```python\nimport sqlite3\n\nclass BookManagementDB:\n    \"\"\"\n    This is a database class as a book management system, used to handle the operations of adding, removing, updating, and searching books.\n    \"\"\"\n\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the class by creating a database connection and cursor, \n        and creates the book table if it does not already exist\n        :param db_name: str, the name of db file\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates the book table in the database if it does not already exist.\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS books (\n                id INTEGER PRIMARY KEY,\n                title TEXT NOT NULL,\n                author TEXT NOT NULL,\n                available INTEGER DEFAULT 1\n            )\n        \"\"\")\n        self.connection.commit()\n\n    def add_book(self, title, author):\n        \"\"\"\n        Adds a book to the database with the specified title and author, \n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        \"\"\"\n        self.cursor.execute(\"INSERT INTO books (title, author) VALUES (?, ?)\", (title, author))\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        \"\"\"\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute(\"DELETE FROM books WHERE id = ?\", (book_id,))\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        \"\"\"\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute(\"UPDATE books SET available = 0 WHERE id = ?\", (book_id,))\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        \"\"\"\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute(\"UPDATE books SET available = 1 WHERE id = ?\", (book_id,))\n        self.connection.commit()\n\n    def search_books(self):\n        \"\"\"\n        Retrieves all books from the database and returns their information.\n        :return books: list[tuple], the information of all books in database\n        \"\"\"\n        self.cursor.execute(\"SELECT * FROM books\")\n        books = self.cursor.fetchall()\n        return books\n```",
    "15": "```python\nclass BoyerMooreSearch:\n    \"\"\"\n    This is a class that implements the Boyer-Moore algorithm for string searching, which is used to find occurrences of a pattern within a given text.\n    \"\"\"\n\n    def __init__(self, text, pattern):\n        \"\"\"\n        Initializes the BoyerMooreSearch class with the given text and pattern.\n        :param text: The text to be searched, str.\n        :param pattern: The pattern to be searched for, str.\n        \"\"\"\n        self.text, self.pattern = text, pattern\n        self.textLen, self.patLen = len(text), len(pattern)\n\n    def match_in_pattern(self, char):\n        \"\"\"\n        Finds the rightmost occurrence of a character in the pattern.\n        :param char: The character to be searched for, str.\n        :return: The index of the rightmost occurrence of the character in the pattern, int.\n        \"\"\"\n        for i in range(self.patLen - 1, -1, -1):\n            if self.pattern[i] == char:\n                return i\n        return -1\n\n    def mismatch_in_text(self, currentPos):\n        \"\"\"\n        Determines the position of the first dismatch between the pattern and the text.\n        :param currentPos: The current position in the text, int.\n        :return: The position of the first dismatch between the pattern and the text, int,otherwise -1.\n        \"\"\"\n        for i in range(self.patLen):\n            if currentPos + i >= self.textLen:\n                return i\n            if self.text[currentPos + i] != self.pattern[i]:\n                return i\n        return -1\n\n    def bad_character_heuristic(self):\n        \"\"\"\n        Finds all occurrences of the pattern in the text.\n        :return: A list of all positions of the pattern in the text, list.\n        \"\"\"\n        occurrences = []\n        for i in range(self.textLen - self.patLen + 1):\n            mismatch_pos = self.mismatch_in_text(i)\n            if mismatch_pos == -1:\n                occurrences.append(i)\n        return occurrences\n```",
    "16": "```python\nclass Calculator:\n    \"\"\"\n    This is a class for a calculator, capable of performing basic arithmetic calculations on numerical expressions using the operators +, -, *, /, and ^ (exponentiation).\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the operations performed by the five operators'+','-','*','/','^'\n        \"\"\"\n        self.operators = {\n            '+': lambda x, y: x + y,\n            '-': lambda x, y: x - y,\n            '*': lambda x, y: x * y,\n            '/': lambda x, y: x / y,\n            '^': lambda x, y: x ** y\n        }\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the value of a given expression\n        :param expression: string, given expression\n        :return:If successful, returns the value of the expression; otherwise, returns None\n        \"\"\"\n        if not expression:\n            return None\n\n        operand_stack = []\n        operator_stack = []\n        i = 0\n        try:\n            while i < len(expression):\n                if expression[i].isdigit():\n                    num = 0\n                    while i < len(expression) and expression[i].isdigit():\n                        num = num * 10 + int(expression[i])\n                        i += 1\n                    operand_stack.append(float(num))\n                    i -= 1\n                elif expression[i] in self.operators:\n                    while operator_stack and self.precedence(operator_stack[-1]) >= self.precedence(expression[i]):\n                        self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.append(expression[i])\n                elif expression[i] == '(':\n                    operator_stack.append(expression[i])\n                elif expression[i] == ')':\n                    while operator_stack and operator_stack[-1] != '(':\n                        self.apply_operator(operand_stack, operator_stack)\n                    if operator_stack and operator_stack[-1] == '(':\n                        operator_stack.pop()  # Pop the '('\n                    else:\n                        return None  # Unmatched parenthesis\n                i += 1\n\n            while operator_stack:\n                self.apply_operator(operand_stack, operator_stack)\n\n            if len(operand_stack) == 1:\n                return operand_stack[0]\n            else:\n                return None\n        except (TypeError, ValueError, ZeroDivisionError):\n            return None\n\n    def precedence(self, operator):\n        \"\"\"\n        Returns the priority of the specified operator, where the higher the priority, the greater the assignment. The priority of '^' is greater than '/' and '*', and the priority of '/' and '*' is greater than '+' and '-'\n        :param operator: string, given operator\n        :return: int, the priority of the given operator, otherwise return 0\n        \"\"\"\n        if operator == '+' or operator == '-':\n            return 1\n        elif operator == '*' or operator == '/':\n            return 2\n        elif operator == '^':\n            return 3\n        else:\n            return 0\n\n    def apply_operator(self, operand_stack, operator_stack):\n        \"\"\"\n        Use the operator at the top of the operator stack to perform the operation on the two numbers at the top of the operator stack, and store the results at the top of the operator stack\n        :param operand_stack:list\n        :param operator_stack:list\n        :return: the updated operand_stack and operator_stack\n        \"\"\"\n        if len(operand_stack) < 2 or not operator_stack:\n            return\n\n        operator = operator_stack.pop()\n        operand2 = operand_stack.pop()\n        operand1 = operand_stack.pop()\n\n        try:\n            result = self.operators[operator](operand1, operand2)\n            operand_stack.append(result)\n        except (TypeError, ValueError, ZeroDivisionError):\n            return\n```",
    "17": "```python\nfrom datetime import datetime, timedelta\n\nclass CalendarUtil:\n    \"\"\"\n    This is a class as CalendarUtil that provides functionalities to manage calendar events, schedule appointments, and perform conflict checks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the calendar with an empty list of events.\n        \"\"\"\n        self.events = []\n\n    def add_event(self, event):\n        \"\"\"\n        Add an event to the calendar.\n        :param event: The event to be added to the calendar, dict.\n        \"\"\"\n        self.events.append(event)\n\n    def remove_event(self, event):\n        \"\"\"\n        Remove an event from the calendar.\n        :param event: The event to be removed from the calendar, dict.\n        \"\"\"\n        self.events = [e for e in self.events if e != event]\n\n    def get_events(self, date):\n        \"\"\"\n        Get all events on a given date.\n        :param date: The date to get events for, datetime.\n        :return: A list of events on the given date, list.\n        \"\"\"\n        return [event for event in self.events if event['date'].date() == date.date()]\n\n    def is_available(self, start_time, end_time):\n        \"\"\"\n        Check if the calendar is available for a given time slot.\n        :param start_time: The start time of the time slot, datetime.\n        :param end_time: The end time of the time slot, datetime.\n        :return: True if the calendar is available for the given time slot, False otherwise, bool.\n        \"\"\"\n        for event in self.events:\n            if (start_time < event['end_time'] and end_time > event['start_time']):\n                return False\n        return True\n\n    def get_available_slots(self, date):\n        \"\"\"\n        Get all available time slots on a given date.\n        :param date: The date to get available time slots for, datetime.\n        :return: A list of available time slots on the given date, list.\n        \"\"\"\n        events_on_date = sorted([event for event in self.events if event['date'].date() == date.date()],\n                                key=lambda x: x['start_time'])\n\n        available_slots = []\n        start_of_day = datetime(date.year, date.month, date.day, 0, 0)\n        end_of_day = datetime(date.year, date.month, date.day, 23, 59)\n\n        current_time = start_of_day\n\n        for event in events_on_date:\n            if event['start_time'] > current_time:\n                available_slots.append((current_time, event['start_time']))\n            current_time = event['end_time']\n\n        if current_time < end_of_day:\n            available_slots.append((current_time, end_of_day))\n\n        return available_slots\n\n    def get_upcoming_events(self, date, num_events):\n        \"\"\"\n        Get the next n upcoming events from a given date.\n        :param date: The date to get upcoming events from, datetime.\n        :param num_events: The number of upcoming events to get, int.\n        :return: A list of the next n upcoming events from the given date, list.\n        \"\"\"\n        upcoming_events = sorted([event for event in self.events if event['start_time'] > date],\n                                 key=lambda x: x['start_time'])\n        return upcoming_events[:num_events]\n```",
    "18": "```python\nclass CamelCaseMap:\n    \"\"\"\n    This is a custom class that allows keys to be in camel case style by converting them from underscore style, which provides dictionary-like functionality.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize data to an empty dictionary\n        \"\"\"\n        self._data = {}\n\n    def __getitem__(self, key):\n        \"\"\"\n        Return the value corresponding to the key\n        :param key:str\n        :return:str,the value corresponding to the key\n        \"\"\"\n        return self._data[self._convert_key(key)]\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Set the value corresponding to the key to the specified value\n        :param key:str\n        :param value:str, the specified value\n        :return:None\n        \"\"\"\n        self._data[self._convert_key(key)] = value\n\n    def __delitem__(self, key):\n        \"\"\"\n        Delete the value corresponding to the key\n        :param key:str\n        :return:None\n        \"\"\"\n        del self._data[self._convert_key(key)]\n\n    def __iter__(self):\n        \"\"\"\n        Returning Iterateable Objects with Own Data\n        :return:Iterator\n        \"\"\"\n        return iter(self._data)\n\n    def __len__(self):\n        \"\"\"\n        Returns the length of the own data\n        :return:int, length of data\n        \"\"\"\n        return len(self._data)\n\n    def _convert_key(self, key):\n        \"\"\"\n        convert key string into camel case\n        :param key:str\n        :return:str, converted key string\n        \"\"\"\n        if isinstance(key, str):\n            return self._to_camel_case(key)\n        return key\n\n    @staticmethod\n    def _to_camel_case(key):\n        \"\"\"\n        convert key string into camel case\n        :param key:str\n        :return:str, converted key string\n        \"\"\"\n        components = key.split('_')\n        return components[0] + ''.join(x.title() for x in components[1:])\n```",
    "19": "```python\nclass ChandrasekharSieve:\n    \"\"\"\n    This is a class that uses the Sieve of Eratosthenes method to find all prime numbers within the range\n    \"\"\"\n\n    def __init__(self, n):\n        \"\"\"\n        Initialize the ChandrasekharSieve class with the given limit.\n        :param n: int, the upper limit for generating prime numbers\n        \"\"\"\n        self.n = n\n        self.primes = self.generate_primes()\n\n    def generate_primes(self):\n        \"\"\"\n        Generate prime numbers up to the specified limit using the Sieve of Eratosthenes algorithm.\n        :return: list, a list of prime numbers\n        \"\"\"\n        if self.n < 2:\n            return []\n\n        limit = self.n + 1\n        is_prime = [True] * limit\n        is_prime[0] = is_prime[1] = False\n\n        for i in range(2, int(limit**0.5) + 1):\n            if is_prime[i]:\n                for j in range(i * i, limit, i):\n                    is_prime[j] = False\n\n        primes = [i for i in range(2, limit) if is_prime[i]]\n        return primes\n\n    def get_primes(self):\n        \"\"\"\n        Get the list of generated prime numbers.\n        :return: list, a list of prime numbers\n        \"\"\"\n        return self.primes\n```"
}