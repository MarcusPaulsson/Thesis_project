{
    "0": "```python\nclass TicTacToe:\n    def __init__(self):\n        self.board = [' ' for _ in range(9)]  # A list to hold the board state\n        self.current_player = 'X'  # Start with player X\n        self.winner = None\n\n    def print_board(self):\n        print(f\"{self.board[0]} | {self.board[1]} | {self.board[2]}\")\n        print(\"--+---+--\")\n        print(f\"{self.board[3]} | {self.board[4]} | {self.board[5]}\")\n        print(\"--+---+--\")\n        print(f\"{self.board[6]} | {self.board[7]} | {self.board[8]}\")\n\n    def make_move(self, position):\n        if self.board[position] == ' ' and self.winner is None:\n            self.board[position] = self.current_player\n            self.check_winner()\n            self.switch_player()\n        else:\n            print(\"Invalid move. Try again.\")\n\n    def switch_player(self):\n        self.current_player = 'O' if self.current_player == 'X' else 'X'\n\n    def check_winner(self):\n        winning_combinations = [\n            (0, 1, 2), (3, 4, 5), (6, 7, 8),  # Horizontal\n            (0, 3, 6), (1, 4, 7), (2, 5, 8),  # Vertical\n            (0, 4, 8), (2, 4, 6)               # Diagonal\n        ]\n        for a, b, c in winning_combinations:\n            if self.board[a] == self.board[b] == self.board[c] != ' ':\n                self.winner = self.board[a]\n                print(f\"Player {self.winner} wins!\")\n                return\n        if ' ' not in self.board:\n            print(\"It's a draw!\")\n            self.winner = 'Draw'\n\n    def play(self):\n        while self.winner is None:\n            self.print_board()\n            try:\n                move = int(input(f\"Player {self.current_player}, enter your move (0-8): \"))\n                if move < 0 or move > 8:\n                    print(\"Invalid input. Please enter a number between 0 and 8.\")\n                    continue\n                self.make_move(move)\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\nif __name__ == \"__main__\":\n    game = TicTacToe()\n    game.play()\n```",
    "1": "```python\nimport random\n\nclass Hangman:\n    def __init__(self, word_list):\n        self.word_list = word_list\n        self.word = random.choice(self.word_list).upper()\n        self.guessed_letters = set()\n        self.max_attempts = 6\n        self.attempts = 0\n\n    def display_word(self):\n        displayed_word = ''.join(letter if letter in self.guessed_letters else '_' for letter in self.word)\n        return displayed_word\n\n    def guess_letter(self, letter):\n        if letter in self.guessed_letters:\n            return False\n        self.guessed_letters.add(letter)\n        if letter not in self.word:\n            self.attempts += 1\n        return True\n\n    def is_word_guessed(self):\n        return all(letter in self.guessed_letters for letter in self.word)\n\n    def is_game_over(self):\n        return self.attempts >= self.max_attempts or self.is_word_guessed()\n\n    def get_remaining_attempts(self):\n        return self.max_attempts - self.attempts\n\n    def play(self):\n        print(\"Welcome to Hangman!\")\n        while not self.is_game_over():\n            print(f\"Word: {self.display_word()}\")\n            print(f\"Attempts remaining: {self.get_remaining_attempts()}\")\n            guess = input(\"Guess a letter: \").upper()\n            if len(guess) != 1 or not guess.isalpha():\n                print(\"Please enter a single letter.\")\n                continue\n            if not self.guess_letter(guess):\n                print(\"You've already guessed that letter.\")\n        \n        if self.is_word_guessed():\n            print(f\"Congratulations! You've guessed the word: {self.word}\")\n        else:\n            print(f\"Game over! The word was: {self.word}\")\n\nif __name__ == \"__main__\":\n    word_list = ['PYTHON', 'JAVA', 'HANGMAN', 'DEVELOPER', 'COMPUTER']\n    game = Hangman(word_list)\n    game.play()\n```",
    "2": "```python\nimport random\n\nclass RockPaperScissors:\n    def __init__(self):\n        self.choices = ['rock', 'paper', 'scissors']\n    \n    def get_user_choice(self):\n        user_input = input(\"Enter rock, paper, or scissors (or 'quit' to exit): \").lower()\n        while user_input not in self.choices and user_input != 'quit':\n            print(\"Invalid choice. Please try again.\")\n            user_input = input(\"Enter rock, paper, or scissors (or 'quit' to exit): \").lower()\n        return user_input\n    \n    def get_computer_choice(self):\n        return random.choice(self.choices)\n    \n    def determine_winner(self, user_choice, computer_choice):\n        if user_choice == computer_choice:\n            return \"It's a tie!\"\n        elif (user_choice == 'rock' and computer_choice == 'scissors') or \\\n             (user_choice == 'paper' and computer_choice == 'rock') or \\\n             (user_choice == 'scissors' and computer_choice == 'paper'):\n            return \"You win!\"\n        else:\n            return \"You lose!\"\n    \n    def play(self):\n        print(\"Welcome to Rock-Paper-Scissors!\")\n        while True:\n            user_choice = self.get_user_choice()\n            if user_choice == 'quit':\n                print(\"Thanks for playing!\")\n                break\n            computer_choice = self.get_computer_choice()\n            print(f\"You chose: {user_choice}\")\n            print(f\"Computer chose: {computer_choice}\")\n            result = self.determine_winner(user_choice, computer_choice)\n            print(result)\n\nif __name__ == \"__main__\":\n    game = RockPaperScissors()\n    game.play()\n```",
    "3": "```python\nimport random\nimport curses\n\nclass SnakeGame:\n    def __init__(self, height=20, width=60):\n        self.height = height\n        self.width = width\n        self.window = curses.initscr()\n        curses.curs_set(0)\n        self.window.timeout(100)\n        self.window.keypad(1)\n        self.snake = [(height // 2, width // 2)]\n        self.snake_direction = curses.KEY_RIGHT\n        self.food = self.place_food()\n        self.score = 0\n\n    def place_food(self):\n        while True:\n            food = (random.randint(1, self.height - 1), random.randint(1, self.width - 1))\n            if food not in self.snake:\n                return food\n\n    def run(self):\n        while True:\n            next_key = self.window.getch()\n            self.snake_direction = next_key if next_key in [curses.KEY_RIGHT, curses.KEY_LEFT, curses.KEY_UP, curses.KEY_DOWN] else self.snake_direction\n            self.move_snake()\n            self.draw()\n            if self.is_game_over():\n                break\n\n        self.window.addstr(self.height // 2, self.width // 2 - len(\"Game Over!\") // 2, \"Game Over!\")\n        self.window.addstr(self.height // 2 + 1, self.width // 2 - len(f\"Score: {self.score}\") // 2, f\"Score: {self.score}\")\n        self.window.refresh()\n        self.window.getch()\n        curses.endwin()\n\n    def move_snake(self):\n        head_y, head_x = self.snake[0]\n        if self.snake_direction == curses.KEY_DOWN:\n            head_y += 1\n        elif self.snake_direction == curses.KEY_UP:\n            head_y -= 1\n        elif self.snake_direction == curses.KEY_LEFT:\n            head_x -= 1\n        elif self.snake_direction == curses.KEY_RIGHT:\n            head_x += 1\n        \n        new_head = (head_y, head_x)\n        self.snake.insert(0, new_head)\n\n        if new_head == self.food:\n            self.score += 1\n            self.food = self.place_food()\n        else:\n            self.snake.pop()\n\n    def draw(self):\n        self.window.clear()\n        self.window.border(0)\n        self.window.addstr(0, 2, f'Score: {self.score}')    \n        self.window.addch(self.food[0], self.food[1], curses.ACS_PI)\n        for segment in self.snake:\n            self.window.addch(segment[0], segment[1], curses.ACS_CKBOARD)\n        self.window.refresh()\n\n    def is_game_over(self):\n        head = self.snake[0]\n        return (\n            head[0] in [0, self.height] or\n            head[1] in [0, self.width] or\n            head in self.snake[1:]\n        )\n\nif __name__ == \"__main__\":\n    game = SnakeGame()\n    game.run()\n```",
    "4": "```python\nimport random\n\nclass Minesweeper:\n    def __init__(self, width, height, mines):\n        self.width = width\n        self.height = height\n        self.mines = mines\n        self.board = [[' ' for _ in range(width)] for _ in range(height)]\n        self.visible = [[' ' for _ in range(width)] for _ in range(height)]\n        self.game_over = False\n        self.populate_mines()\n        self.calculate_numbers()\n\n    def populate_mines(self):\n        placed_mines = 0\n        while placed_mines < self.mines:\n            x = random.randint(0, self.width - 1)\n            y = random.randint(0, self.height - 1)\n            if self.board[y][x] != '*':\n                self.board[y][x] = '*'\n                placed_mines += 1\n\n    def calculate_numbers(self):\n        for y in range(self.height):\n            for x in range(self.width):\n                if self.board[y][x] == '*':\n                    continue\n                self.board[y][x] = str(self.count_adjacent_mines(x, y))\n\n    def count_adjacent_mines(self, x, y):\n        count = 0\n        for dy in range(-1, 2):\n            for dx in range(-1, 2):\n                if dy == 0 and dx == 0:\n                    continue\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < self.width and 0 <= ny < self.height and self.board[ny][nx] == '*':\n                    count += 1\n        return count\n\n    def reveal(self, x, y):\n        if self.game_over or self.visible[y][x] != ' ':\n            return\n        self.visible[y][x] = self.board[y][x]\n        if self.board[y][x] == '*':\n            self.game_over = True\n            return\n        if self.board[y][x] == '0':\n            for dy in range(-1, 2):\n                for dx in range(-1, 2):\n                    if 0 <= x + dx < self.width and 0 <= y + dy < self.height:\n                        self.reveal(x + dx, y + dy)\n\n    def display(self):\n        print(\"Current Board:\")\n        for y in range(self.height):\n            for x in range(self.width):\n                print(self.visible[y][x], end=' ')\n            print()\n        print()\n\n    def play(self):\n        while not self.game_over:\n            self.display()\n            try:\n                x, y = map(int, input(\"Enter coordinates to reveal (x y): \").split())\n                if 0 <= x < self.width and 0 <= y < self.height:\n                    self.reveal(x, y)\n                else:\n                    print(\"Coordinates out of bounds. Try again.\")\n            except ValueError:\n                print(\"Invalid input. Please enter two integers separated by a space.\")\n        print(\"Game Over! You hit a mine.\")\n        self.display()\n\nif __name__ == \"__main__\":\n    width = int(input(\"Enter board width: \"))\n    height = int(input(\"Enter board height: \"))\n    mines = int(input(\"Enter number of mines: \"))\n    game = Minesweeper(width, height, mines)\n    game.play()\n```",
    "5": "```python\nimport random\n\nclass Mastermind:\n    def __init__(self, code_length=4, num_colors=6, max_attempts=10):\n        self.code_length = code_length\n        self.num_colors = num_colors\n        self.max_attempts = max_attempts\n        self.secret_code = self.generate_code()\n        self.attempts = 0\n\n    def generate_code(self):\n        return [random.randint(1, self.num_colors) for _ in range(self.code_length)]\n\n    def get_feedback(self, guess):\n        correct_positions = sum(1 for i in range(self.code_length) if guess[i] == self.secret_code[i])\n        correct_colors = sum(min(guess.count(c), self.secret_code.count(c)) for c in set(guess))\n        correct_colors -= correct_positions\n        return correct_positions, correct_colors\n\n    def play(self):\n        print(\"Welcome to Mastermind!\")\n        print(f\"Guess the {self.code_length}-digit code using numbers 1 to {self.num_colors}.\")\n        print(f\"You have {self.max_attempts} attempts to guess the code.\")\n\n        while self.attempts < self.max_attempts:\n            guess = input(f\"Attempt {self.attempts + 1}: Enter your guess: \")\n            if not self.is_valid_guess(guess):\n                print(\"Invalid guess. Please enter a sequence of numbers separated by spaces.\")\n                continue\n\n            guess = list(map(int, guess.split()))\n            self.attempts += 1\n            correct_positions, correct_colors = self.get_feedback(guess)\n\n            if correct_positions == self.code_length:\n                print(f\"Congratulations! You've guessed the code: {self.secret_code}\")\n                return\n\n            print(f\"Feedback: {correct_positions} correct positions, {correct_colors} correct colors.\")\n\n        print(f\"Sorry, you've run out of attempts! The secret code was: {self.secret_code}\")\n\n    def is_valid_guess(self, guess):\n        parts = guess.split()\n        if len(parts) != self.code_length:\n            return False\n        return all(part.isdigit() and 1 <= int(part) <= self.num_colors for part in parts)\n\nif __name__ == \"__main__\":\n    game = Mastermind()\n    game.play()\n```",
    "6": "```python\nimport random\n\nclass Battleship:\n    def __init__(self):\n        self.board_size = 5\n        self.board = [[' ' for _ in range(self.board_size)] for _ in range(self.board_size)]\n        self.ship_position = self.place_ship()\n        self.guesses = 0\n        self.max_guesses = 10\n        self.game_over = False\n\n    def place_ship(self):\n        x = random.randint(0, self.board_size - 1)\n        y = random.randint(0, self.board_size - 1)\n        return (x, y)\n\n    def print_board(self):\n        print(\"  \" + \" \".join(str(i) for i in range(self.board_size)))\n        for idx, row in enumerate(self.board):\n            print(idx, \" \".join(row))\n\n    def make_guess(self, x, y):\n        if self.game_over:\n            print(\"Game over! Start a new game.\")\n            return\n\n        if x < 0 or x >= self.board_size or y < 0 or y >= self.board_size:\n            print(\"Invalid coordinates! Try again.\")\n            return\n\n        self.guesses += 1\n\n        if (x, y) == self.ship_position:\n            print(\"Congratulations! You've sunk the battleship!\")\n            self.board[x][y] = 'X'\n            self.game_over = True\n        else:\n            print(\"Miss!\")\n            self.board[x][y] = 'O'\n\n        if self.guesses >= self.max_guesses:\n            print(\"Game over! You've run out of guesses.\")\n            self.game_over = True\n\n        self.print_board()\n\n    def reset_game(self):\n        self.board = [[' ' for _ in range(self.board_size)] for _ in range(self.board_size)]\n        self.ship_position = self.place_ship()\n        self.guesses = 0\n        self.game_over = False\n        print(\"Game reset! Start guessing again.\")\n\ndef main():\n    game = Battleship()\n    game.print_board()\n\n    while not game.game_over:\n        try:\n            guess = input(\"Enter your guess (row and column, e.g., 2 3): \")\n            if guess.lower() == 'reset':\n                game.reset_game()\n                continue\n            x, y = map(int, guess.split())\n            game.make_guess(x, y)\n        except ValueError:\n            print(\"Invalid input! Please enter row and column as numbers.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
    "7": "```python\nimport numpy as np\nimport os\nimport time\n\nclass GameOfLife:\n    def __init__(self, width=10, height=10):\n        self.width = width\n        self.height = height\n        self.board = np.zeros((height, width), dtype=int)\n\n    def randomize(self):\n        self.board = np.random.choice([0, 1], size=(self.height, self.width))\n\n    def update(self):\n        new_board = self.board.copy()\n        for i in range(self.height):\n            for j in range(self.width):\n                alive_neighbors = self.count_alive_neighbors(i, j)\n                if self.board[i, j] == 1:  # Cell is alive\n                    if alive_neighbors < 2 or alive_neighbors > 3:\n                        new_board[i, j] = 0  # Cell dies\n                else:  # Cell is dead\n                    if alive_neighbors == 3:\n                        new_board[i, j] = 1  # Cell becomes alive\n        self.board = new_board\n\n    def count_alive_neighbors(self, x, y):\n        neighbors = [\n            (x-1, y-1), (x-1, y), (x-1, y+1),\n            (x, y-1),           (x, y+1),\n            (x+1, y-1), (x+1, y), (x+1, y+1)\n        ]\n        count = 0\n        for nx, ny in neighbors:\n            if 0 <= nx < self.height and 0 <= ny < self.width:\n                count += self.board[nx, ny]\n        return count\n\n    def display(self):\n        os.system('clear' if os.name == 'posix' else 'cls')\n        print(self.board)\n\n    def run(self, generations=10, delay=1):\n        for _ in range(generations):\n            self.display()\n            self.update()\n            time.sleep(delay)\n\nif __name__ == \"__main__\":\n    game = GameOfLife(width=20, height=20)\n    game.randomize()\n    game.run(generations=50, delay=0.5)\n```\n",
    "8": "```python\nclass ConnectFour:\n    def __init__(self):\n        self.rows = 6\n        self.columns = 7\n        self.board = [[' ' for _ in range(self.columns)] for _ in range(self.rows)]\n        self.current_player = 'X'\n\n    def print_board(self):\n        print(\"\\n\".join(['|'.join(row) for row in self.board]))\n        print('-' * (self.columns * 2 - 1))\n\n    def drop_piece(self, column):\n        for row in reversed(range(self.rows)):\n            if self.board[row][column] == ' ':\n                self.board[row][column] = self.current_player\n                return True\n        return False\n\n    def is_winner(self):\n        for row in range(self.rows):\n            for col in range(self.columns):\n                if self.check_win(row, col):\n                    return True\n        return False\n\n    def check_win(self, row, col):\n        if self.board[row][col] != self.current_player:\n            return False\n        # Check horizontal\n        if col + 3 < self.columns and all(self.board[row][col + i] == self.current_player for i in range(4)):\n            return True\n        # Check vertical\n        if row + 3 < self.rows and all(self.board[row + i][col] == self.current_player for i in range(4)):\n            return True\n        # Check diagonal /\n        if row + 3 < self.rows and col - 3 >= 0 and all(self.board[row + i][col - i] == self.current_player for i in range(4)):\n            return True\n        # Check diagonal \\\n        if row + 3 < self.rows and col + 3 < self.columns and all(self.board[row + i][col + i] == self.current_player for i in range(4)):\n            return True\n        return False\n\n    def switch_player(self):\n        self.current_player = 'O' if self.current_player == 'X' else 'X'\n\n    def play(self):\n        while True:\n            self.print_board()\n            column = int(input(f\"Player {self.current_player}, choose a column (0-{self.columns-1}): \"))\n            if 0 <= column < self.columns and self.drop_piece(column):\n                if self.is_winner():\n                    self.print_board()\n                    print(f\"Player {self.current_player} wins!\")\n                    break\n                self.switch_player()\n            else:\n                print(\"Column full or invalid. Try again.\")\n\nif __name__ == \"__main__\":\n    game = ConnectFour()\n    game.play()\n```",
    "9": "```python\nimport random\n\nclass Card:\n    \"\"\"Represents a single playing card.\"\"\"\n    def __init__(self, suit, rank):\n        self.suit = suit\n        self.rank = rank\n\n    def value(self):\n        \"\"\"Returns the value of the card.\"\"\"\n        if self.rank in ['J', 'Q', 'K']:\n            return 10\n        elif self.rank == 'A':\n            return 11\n        else:\n            return int(self.rank)\n\n    def __str__(self):\n        return f\"{self.rank} of {self.suit}\"\n\n\nclass Deck:\n    \"\"\"Represents a deck of 52 playing cards.\"\"\"\n    def __init__(self):\n        self.cards = [Card(suit, rank) for suit in ['Hearts', 'Diamonds', 'Clubs', 'Spades']\n                      for rank in ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']]\n        random.shuffle(self.cards)\n\n    def deal_card(self):\n        \"\"\"Deals a card from the deck.\"\"\"\n        return self.cards.pop() if self.cards else None\n\n\nclass Hand:\n    \"\"\"Represents a player's hand of cards.\"\"\"\n    def __init__(self):\n        self.cards = []\n\n    def add_card(self, card):\n        \"\"\"Adds a card to the hand.\"\"\"\n        self.cards.append(card)\n\n    def value(self):\n        \"\"\"Calculates the total value of the hand.\"\"\"\n        total = sum(card.value() for card in self.cards)\n        aces = sum(1 for card in self.cards if card.rank == 'A')\n        \n        while total > 21 and aces:\n            total -= 10\n            aces -= 1\n            \n        return total\n\n    def __str__(self):\n        return ', '.join(str(card) for card in self.cards)\n\n\nclass Blackjack:\n    \"\"\"Implements the Blackjack game logic.\"\"\"\n    def __init__(self):\n        self.deck = Deck()\n        self.player_hand = Hand()\n        self.dealer_hand = Hand()\n\n    def deal_initial_cards(self):\n        \"\"\"Deals initial cards to player and dealer.\"\"\"\n        for _ in range(2):\n            self.player_hand.add_card(self.deck.deal_card())\n            self.dealer_hand.add_card(self.deck.deal_card())\n\n    def player_turn(self):\n        \"\"\"Handles the player's turn.\"\"\"\n        while True:\n            print(f\"Your hand: {self.player_hand} (Value: {self.player_hand.value()})\")\n            if self.player_hand.value() > 21:\n                print(\"Bust! You lose.\")\n                return False\n            \n            action = input(\"Do you want to (h)it or (s)tand? \").lower()\n            if action == 'h':\n                self.player_hand.add_card(self.deck.deal_card())\n            elif action == 's':\n                break\n            else:\n                print(\"Invalid input. Please enter 'h' or 's'.\")\n        return True\n\n    def dealer_turn(self):\n        \"\"\"Handles the dealer's turn.\"\"\"\n        while self.dealer_hand.value() < 17:\n            self.dealer_hand.add_card(self.deck.deal_card())\n\n    def determine_winner(self):\n        \"\"\"Determines the winner of the game.\"\"\"\n        player_value = self.player_hand.value()\n        dealer_value = self.dealer_hand.value()\n\n        print(f\"Dealer's hand: {self.dealer_hand} (Value: {dealer_value})\")\n        if dealer_value > 21 or player_value > dealer_value:\n            print(\"You win!\")\n        elif player_value < dealer_value:\n            print(\"You lose!\")\n        else:\n            print(\"It's a tie!\")\n\n    def play(self):\n        \"\"\"Starts the game of Blackjack.\"\"\"\n        self.deal_initial_cards()\n        if self.player_turn():\n            self.dealer_turn()\n            self.determine_winner()\n\n\nif __name__ == \"__main__\":\n    game = Blackjack()\n    game.play()\n```",
    "10": "```python\nimport random\n\nclass Hammurabi:\n    def __init__(self):\n        self.year = 1\n        self.population = 100\n        self.grain = 2800\n        self.land = 100\n        self.plague_years = 0\n        self.harvest_yield = 3\n        self.deaths = 0\n\n    def print_status(self):\n        print(f\"Year: {self.year}\")\n        print(f\"Population: {self.population}\")\n        print(f\"Grain: {self.grain} bushels\")\n        print(f\"Land: {self.land} acres\")\n        print(f\"Plague Years: {self.plague_years}\")\n\n    def get_input(self, prompt, valid_options=None):\n        while True:\n            response = input(prompt).strip()\n            if valid_options and response not in valid_options:\n                print(f\"Invalid input. Please choose from {valid_options}.\")\n            else:\n                return response\n\n    def harvest(self):\n        yield_bushels = self.land * self.harvest_yield\n        self.grain += yield_bushels\n        print(f\"You harvested {yield_bushels} bushels of grain.\")\n\n    def manage_population(self):\n        if self.plague_years > 0:\n            deaths = random.randint(0, self.population // 2)\n            self.deaths += deaths\n            self.population -= deaths\n            self.plague_years -= 1\n            print(f\"The plague has taken {deaths} people.\")\n        else:\n            births = self.population // 10\n            self.population += births\n            print(f\"{births} people were born.\")\n\n    def trade_grain(self):\n        while True:\n            bushels = int(self.get_input(\"How many bushels of grain will you trade? \"))\n            if bushels < 0 or bushels > self.grain:\n                print(\"You cannot trade more grain than you have.\")\n            else:\n                self.grain -= bushels\n                self.grain += bushels * 2  # Assume a 2 for 1 trade ratio\n                print(f\"You traded {bushels} bushels and now have {self.grain} bushels.\")\n                break\n\n    def plant_crops(self):\n        while True:\n            acres = int(self.get_input(\"How many acres will you plant? \"))\n            if acres < 0 or acres > self.land:\n                print(\"You cannot plant more acres than you own.\")\n            else:\n                self.land -= acres\n                self.grain -= acres  # Assume 1 bushel per acre to plant\n                print(f\"You planted crops on {acres} acres.\")\n                break\n\n    def next_year(self):\n        self.year += 1\n        self.harvest()\n        self.manage_population()\n        if random.random() < 0.1:  # 10% chance of plague\n            self.plague_years = random.randint(1, 3)\n            print(\"A plague has struck the city!\")\n\n    def play(self):\n        while self.year <= 10 and self.population > 0:\n            self.print_status()\n            self.plant_crops()\n            self.trade_grain()\n            self.next_year()\n\n        if self.population <= 0:\n            print(\"Your civilization has collapsed!\")\n        else:\n            print(\"You have survived for 10 years!\")\n\nif __name__ == \"__main__\":\n    game = Hammurabi()\n    game.play()\n```",
    "11": "```python\nimport random\n\nclass LightsOut:\n    def __init__(self, size=5):\n        self.size = size\n        self.board = self.generate_board()\n        self.is_solved = False\n\n    def generate_board(self):\n        return [[random.choice([0, 1]) for _ in range(self.size)] for _ in range(self.size)]\n\n    def display_board(self):\n        for row in self.board:\n            print(' '.join(['O' if col == 1 else '.' for col in row]))\n        print()\n\n    def toggle(self, row, col):\n        if 0 <= row < self.size and 0 <= col < self.size:\n            self.board[row][col] ^= 1  # Toggle the light\n            if row > 0:  # Toggle the light above\n                self.board[row - 1][col] ^= 1\n            if row < self.size - 1:  # Toggle the light below\n                self.board[row + 1][col] ^= 1\n            if col > 0:  # Toggle the light to the left\n                self.board[row][col - 1] ^= 1\n            if col < self.size - 1:  # Toggle the light to the right\n                self.board[row][col + 1] ^= 1\n\n    def check_solved(self):\n        self.is_solved = all(col == 0 for row in self.board for col in row)\n\n    def play(self):\n        print(\"Welcome to Lights Out!\")\n        while not self.is_solved:\n            self.display_board()\n            try:\n                move = input(\"Enter your move as 'row col' (or 'quit' to exit): \")\n                if move.lower() == 'quit':\n                    print(\"Thanks for playing!\")\n                    break\n                row, col = map(int, move.split())\n                self.toggle(row, col)\n                self.check_solved()\n                if self.is_solved:\n                    self.display_board()\n                    print(\"Congratulations! You've solved the puzzle!\")\n            except (ValueError, IndexError):\n                print(\"Invalid input. Please enter a valid row and column.\")\n\nif __name__ == \"__main__\":\n    game = LightsOut()\n    game.play()\n```",
    "12": "```python\nimport os\nimport time\nimport random\nimport sys\nimport threading\n\nclass Pong:\n    def __init__(self, width=40, height=20):\n        self.width = width\n        self.height = height\n        self.ball_x = width // 2\n        self.ball_y = height // 2\n        self.ball_dx = random.choice([-1, 1])\n        self.ball_dy = random.choice([-1, 1])\n        self.paddle_left_y = height // 2\n        self.paddle_right_y = height // 2\n        self.running = True\n\n    def draw(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for y in range(self.height):\n            for x in range(self.width):\n                if x == 0 and y in range(self.paddle_left_y - 1, self.paddle_left_y + 2):\n                    print('|', end='')\n                elif x == self.width - 1 and y in range(self.paddle_right_y - 1, self.paddle_right_y + 2):\n                    print('|', end='')\n                elif x == self.ball_x and y == self.ball_y:\n                    print('O', end='')\n                else:\n                    print(' ', end='')\n            print()\n        print(\"Use 'w' and 's' to move left paddle, 'o' and 'l' to move right paddle. Press 'q' to quit.\")\n\n    def update_ball(self):\n        self.ball_x += self.ball_dx\n        self.ball_y += self.ball_dy\n\n        if self.ball_y <= 0 or self.ball_y >= self.height - 1:\n            self.ball_dy *= -1\n\n        if self.ball_x <= 1 and self.paddle_left_y - 1 <= self.ball_y <= self.paddle_left_y + 1:\n            self.ball_dx *= -1\n        elif self.ball_x >= self.width - 2 and self.paddle_right_y - 1 <= self.ball_y <= self.paddle_right_y + 1:\n            self.ball_dx *= -1\n        elif self.ball_x < 0 or self.ball_x >= self.width:\n            self.ball_x, self.ball_y = self.width // 2, self.height // 2\n\n    def move_left_paddle(self, direction):\n        if direction == 'up' and self.paddle_left_y > 1:\n            self.paddle_left_y -= 1\n        elif direction == 'down' and self.paddle_left_y < self.height - 2:\n            self.paddle_left_y += 1\n\n    def move_right_paddle(self, direction):\n        if direction == 'up' and self.paddle_right_y > 1:\n            self.paddle_right_y -= 1\n        elif direction == 'down' and self.paddle_right_y < self.height - 2:\n            self.paddle_right_y += 1\n\n    def input_thread(self):\n        while self.running:\n            key = input()\n            if key == 'w':\n                self.move_left_paddle('up')\n            elif key == 's':\n                self.move_left_paddle('down')\n            elif key == 'o':\n                self.move_right_paddle('up')\n            elif key == 'l':\n                self.move_right_paddle('down')\n            elif key == 'q':\n                self.running = False\n\n    def play(self):\n        threading.Thread(target=self.input_thread, daemon=True).start()\n        while self.running:\n            self.update_ball()\n            self.draw()\n            time.sleep(0.1)\n\nif __name__ == \"__main__\":\n    game = Pong()\n    game.play()\n```",
    "13": "```python\nimport random\nimport os\nimport sys\nimport time\nimport threading\n\nclass Tetris:\n    # Define shapes of the Tetriminos\n    shapes = [\n        [['.....',\n          '.....',\n          '..00.',\n          '..00.',\n          '.....'],\n         'O'],\n        \n        [['.....',\n          '.....',\n          '..0..',\n          '..000',\n          '.....'],\n         'T'],\n        \n        [['.....',\n          '.....',\n          '.0...',\n          '.000.',\n          '.....'],\n         'L'],\n        \n        [['.....',\n          '.....',\n          '...0.',\n          '.000.',\n          '.....'],\n         'J'],\n        \n        [['.....',\n          '.....',\n          '..0..',\n          '.00..',\n          '.0...'],\n         'S'],\n        \n        [['.....',\n          '.....',\n          '.0...',\n          '..00.',\n          '..0..'],\n         'Z'],\n        \n        [['.....',\n          '.....',\n          '..0..',\n          '..0..',\n          '..00.'],\n         'I']\n    ]\n\n    def __init__(self):\n        self.board = [['.' for _ in range(10)] for _ in range(20)]\n        self.current_piece = None\n        self.current_x = 0\n        self.current_y = 0\n        self.score = 0\n        self.game_over = False\n        self.game_thread = threading.Thread(target=self.run)\n        self.game_thread.start()\n\n    def new_piece(self):\n        self.current_piece = random.choice(self.shapes)\n        self.current_x = 3\n        self.current_y = 0\n\n    def rotate_piece(self):\n        self.current_piece[0] = [''.join(row) for row in zip(*self.current_piece[0][::-1])]\n\n    def valid_move(self, dx, dy):\n        for y, row in enumerate(self.current_piece[0]):\n            for x, cell in enumerate(row):\n                if cell == '0':\n                    new_x = self.current_x + x + dx\n                    new_y = self.current_y + y + dy\n                    if new_x < 0 or new_x >= len(self.board[0]) or new_y >= len(self.board):\n                        return False\n                    if new_y >= 0 and self.board[new_y][new_x] != '.':\n                        return False\n        return True\n\n    def lock_piece(self):\n        for y, row in enumerate(self.current_piece[0]):\n            for x, cell in enumerate(row):\n                if cell == '0':\n                    self.board[self.current_y + y][self.current_x + x] = '0'\n        self.clear_lines()\n        self.new_piece()\n        if not self.valid_move(0, 0):\n            self.game_over = True\n\n    def clear_lines(self):\n        new_board = [row for row in self.board if any(cell == '.' for cell in row)]\n        cleared_lines = len(self.board) - len(new_board)\n        self.score += cleared_lines\n        self.board = [['.' for _ in range(10)] for _ in range(cleared_lines)] + new_board\n\n    def drop(self):\n        if self.valid_move(0, 1):\n            self.current_y += 1\n        else:\n            self.lock_piece()\n\n    def run(self):\n        self.new_piece()\n        while not self.game_over:\n            os.system('cls' if os.name == 'nt' else 'clear')\n            self.draw_board()\n            self.drop()\n            time.sleep(0.5)\n\n    def draw_board(self):\n        for y in range(len(self.board)):\n            line = ''\n            for x in range(len(self.board[y])):\n                if self.current_y <= y < self.current_y + len(self.current_piece[0]) and \\\n                        self.current_x <= x < self.current_x + len(self.current_piece[0][0]) and \\\n                        self.current_piece[0][y - self.current_y][x - self.current_x] == '0':\n                    line += '0'\n                else:\n                    line += self.board[y][x]\n            print(line)\n        print(f'Score: {self.score}')\n        if self.game_over:\n            print(\"Game Over!\")\n\n    def move_left(self):\n        if self.valid_move(-1, 0):\n            self.current_x -= 1\n\n    def move_right(self):\n        if self.valid_move(1, 0):\n            self.current_x += 1\n\n    def move_down(self):\n        self.drop()\n\n    def rotate(self):\n        self.rotate_piece()\n        if not self.valid_move(0, 0):\n            self.rotate_piece()  # Rotate back if not valid\n\ndef main():\n    game = Tetris()\n    \n    while not game.game_over:\n        command = input(\"Enter command (l=left, r=right, d=down, t=rotate, q=quit): \")\n        if command == 'l':\n            game.move_left()\n        elif command == 'r':\n            game.move_right()\n        elif command == 'd':\n            game.move_down()\n        elif command == 't':\n            game.rotate()\n        elif command == 'q':\n            game.game_over = True\n\nif __name__ == \"__main__\":\n    main()\n```",
    "14": "```python\nimport random\nimport sys\nimport os\nimport time\nimport math\n\nclass AsteroidGame:\n    def __init__(self, width=40, height=20, num_asteroids=5):\n        self.width = width\n        self.height = height\n        self.player_pos = [width // 2, height // 2]\n        self.asteroids = self._create_asteroids(num_asteroids)\n        self.score = 0\n        self.game_over = False\n\n    def _create_asteroids(self, num_asteroids):\n        return [[random.randint(0, self.width - 1), random.randint(0, self.height - 1)] for _ in range(num_asteroids)]\n\n    def _draw(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for y in range(self.height):\n            for x in range(self.width):\n                if [x, y] == self.player_pos:\n                    print(\"P\", end=\"\")\n                elif [x, y] in self.asteroids:\n                    print(\"A\", end=\"\")\n                else:\n                    print(\" \", end=\"\")\n            print()\n        print(f\"Score: {self.score}\")\n\n    def _move_asteroids(self):\n        for asteroid in self.asteroids:\n            asteroid[1] += 1\n            if asteroid[1] >= self.height:\n                asteroid[0] = random.randint(0, self.width - 1)\n                asteroid[1] = 0\n                self.score += 1\n\n    def _check_collision(self):\n        if self.player_pos in self.asteroids:\n            self.game_over = True\n\n    def _get_input(self):\n        if os.name == 'nt':\n            import msvcrt\n            if msvcrt.kbhit():\n                return msvcrt.getch().decode()\n        else:\n            import select\n            import sys\n            if select.select([sys.stdin], [], [], 0)[0]:\n                return sys.stdin.read(1)\n        return None\n\n    def run(self):\n        while not self.game_over:\n            self._draw()\n            self._move_asteroids()\n            self._check_collision()\n            user_input = self._get_input()\n            if user_input:\n                if user_input == 'a' and self.player_pos[0] > 0:\n                    self.player_pos[0] -= 1\n                elif user_input == 'd' and self.player_pos[0] < self.width - 1:\n                    self.player_pos[0] += 1\n            time.sleep(0.1)\n\n        print(\"Game Over! Your score was:\", self.score)\n\nif __name__ == \"__main__\":\n    game = AsteroidGame()\n    game.run()\n```",
    "15": "```python\nimport random\nimport string\n\nclass Boggle:\n    def __init__(self, size=4):\n        self.size = size\n        self.board = self.generate_board()\n        self.words_found = set()\n        self.dictionary = self.load_dictionary()\n\n    def generate_board(self):\n        letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        return [[random.choice(letters) for _ in range(self.size)] for _ in range(self.size)]\n\n    def load_dictionary(self):\n        # Load a basic English words list, for demonstration purposes.\n        # In practice, this could be a more extensive dictionary.\n        return set(word.strip().upper() for word in open('dictionary.txt'))\n\n    def display_board(self):\n        for row in self.board:\n            print(' '.join(row))\n\n    def is_valid_word(self, word):\n        return word in self.dictionary\n\n    def find_words(self, word, visited, x, y):\n        if not self.is_valid_word(word):\n            return False\n        if word in self.words_found:\n            return True\n\n        self.words_found.add(word)\n        return True\n\n    def search(self, word, x, y, visited):\n        if not (0 <= x < self.size and 0 <= y < self.size):\n            return\n        if (x, y) in visited:\n            return\n\n        visited.add((x, y))\n        word += self.board[x][y]\n\n        if self.is_valid_word(word):\n            self.words_found.add(word)\n\n        for dx in (-1, 0, 1):\n            for dy in (-1, 0, 1):\n                if dx == 0 and dy == 0:\n                    continue\n                self.search(word, x + dx, y + dy, visited)\n\n        visited.remove((x, y))\n\n    def play(self):\n        print(\"Welcome to Boggle!\")\n        self.display_board()\n\n        while True:\n            command = input(\"Enter a word (or 'exit' to quit): \").strip().upper()\n            if command == 'EXIT':\n                break\n            if self.is_valid_word(command):\n                self.words_found.add(command)\n                print(f\"'{command}' is a valid word!\")\n            else:\n                print(f\"'{command}' is not a valid word.\")\n        \n        print(f\"You found {len(self.words_found)} words: {', '.join(sorted(self.words_found))}\")\n\nif __name__ == \"__main__\":\n    game = Boggle()\n    game.play()\n```",
    "16": "```python\nimport random\nimport os\nimport time\n\nclass PacMan:\n    def __init__(self, width=10, height=10):\n        self.width = width\n        self.height = height\n        self.pacman_position = [0, 0]\n        self.ghost_position = [random.randint(0, height-1), random.randint(0, width-1)]\n        self.dots = [[random.randint(0, height-1), random.randint(0, width-1)] for _ in range(5)]\n        self.score = 0\n        self.game_over = False\n\n    def draw(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for y in range(self.height):\n            for x in range(self.width):\n                if [y, x] == self.pacman_position:\n                    print('P', end=' ')\n                elif [y, x] == self.ghost_position:\n                    print('G', end=' ')\n                elif [y, x] in self.dots:\n                    print('.', end=' ')\n                else:\n                    print(' ', end=' ')\n            print()\n        print(f'Score: {self.score}')\n\n    def move_pacman(self, direction):\n        if direction == 'w' and self.pacman_position[0] > 0:\n            self.pacman_position[0] -= 1\n        elif direction == 's' and self.pacman_position[0] < self.height - 1:\n            self.pacman_position[0] += 1\n        elif direction == 'a' and self.pacman_position[1] > 0:\n            self.pacman_position[1] -= 1\n        elif direction == 'd' and self.pacman_position[1] < self.width - 1:\n            self.pacman_position[1] += 1\n\n        self.check_collision()\n\n    def check_collision(self):\n        if self.pacman_position == self.ghost_position:\n            self.game_over = True\n            print(\"Game Over! You were caught by the ghost.\")\n        elif self.pacman_position in self.dots:\n            self.score += 1\n            self.dots.remove(self.pacman_position)\n\n    def move_ghost(self):\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        move = random.choice(directions)\n        new_ghost_position = [self.ghost_position[0] + move[0], self.ghost_position[1] + move[1]]\n        if 0 <= new_ghost_position[0] < self.height and 0 <= new_ghost_position[1] < self.width:\n            self.ghost_position = new_ghost_position\n\n    def play(self):\n        while not self.game_over:\n            self.draw()\n            direction = input(\"Move (w/a/s/d): \")\n            self.move_pacman(direction)\n            self.move_ghost()\n            time.sleep(0.5)\n        self.draw()\n\nif __name__ == \"__main__\":\n    game = PacMan()\n    game.play()\n```",
    "17": "```python\nimport random\nimport time\nimport os\nimport sys\n\nclass DinosaurRunner:\n    def __init__(self):\n        self.score = 0\n        self.is_running = True\n        self.obstacle_distance = 50\n        self.obstacles = ['Cactus', 'Bird']\n        self.obstacle = None\n\n    def clear_screen(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n\n    def generate_obstacle(self):\n        self.obstacle = random.choice(self.obstacles)\n        self.obstacle_distance = 50\n\n    def jump(self):\n        if self.obstacle_distance <= 10:\n            if self.obstacle == 'Cactus':\n                print(\"Jumped over the Cactus!\")\n                self.score += 1\n            elif self.obstacle == 'Bird':\n                print(\"Jumped over the Bird!\")\n                self.score += 1\n            self.obstacle = None\n            self.obstacle_distance = 50\n\n    def run(self):\n        print(\"Welcome to Dinosaur Runner!\")\n        print(\"Press 'j' to jump. Type 'exit' to quit.\")\n        while self.is_running:\n            if self.obstacle is None:\n                self.generate_obstacle()\n            self.obstacle_distance -= 1\n            print(f\"Obstacle: {self.obstacle} | Distance: {self.obstacle_distance} | Score: {self.score}\")\n            user_input = input(\"Your action: \").strip().lower()\n\n            if user_input == 'exit':\n                self.is_running = False\n                print(\"Thanks for playing! Your final score is:\", self.score)\n                break\n            elif user_input == 'j':\n                self.jump()\n            else:\n                print(\"Invalid input. Press 'j' to jump or 'exit' to quit.\")\n\n            if self.obstacle_distance <= 0:\n                print(f\"Game Over! You hit the {self.obstacle}. Final score: {self.score}\")\n                self.is_running = False\n\n            time.sleep(1)\n            self.clear_screen()\n\nif __name__ == \"__main__\":\n    game = DinosaurRunner()\n    game.run()\n```"
}