{
    "0": "```python\nclass TicTacToe:\n    def __init__(self):\n        self.board = [' ' for _ in range(9)]  # A list to hold the board state\n        self.current_player = 'X'\n\n    def print_board(self):\n        print(f\"{self.board[0]} | {self.board[1]} | {self.board[2]}\")\n        print(\"---------\")\n        print(f\"{self.board[3]} | {self.board[4]} | {self.board[5]}\")\n        print(\"---------\")\n        print(f\"{self.board[6]} | {self.board[7]} | {self.board[8]}\")\n\n    def make_move(self, position):\n        if self.board[position] == ' ':\n            self.board[position] = self.current_player\n            return True\n        return False\n\n    def check_winner(self):\n        winning_combinations = [\n            (0, 1, 2), (3, 4, 5), (6, 7, 8),  # horizontal\n            (0, 3, 6), (1, 4, 7), (2, 5, 8),  # vertical\n            (0, 4, 8), (2, 4, 6)               # diagonal\n        ]\n        for a, b, c in winning_combinations:\n            if self.board[a] == self.board[b] == self.board[c] != ' ':\n                return self.board[a]\n        return None\n\n    def is_full(self):\n        return ' ' not in self.board\n\n    def switch_player(self):\n        self.current_player = 'O' if self.current_player == 'X' else 'X'\n\n    def play(self):\n        while True:\n            self.print_board()\n            try:\n                position = int(input(f\"Player {self.current_player}, enter your move (0-8): \"))\n                if position < 0 or position > 8:\n                    print(\"Invalid position. Please try again.\")\n                    continue\n                if not self.make_move(position):\n                    print(\"Position already taken. Please try again.\")\n                    continue\n            except ValueError:\n                print(\"Invalid input. Please enter a number between 0 and 8.\")\n                continue\n\n            winner = self.check_winner()\n            if winner:\n                self.print_board()\n                print(f\"Player {winner} wins!\")\n                break\n            if self.is_full():\n                self.print_board()\n                print(\"It's a draw!\")\n                break\n\n            self.switch_player()\n\n\nif __name__ == \"__main__\":\n    game = TicTacToe()\n    game.play()\n```",
    "1": "```python\nimport random\n\nclass Hangman:\n    def __init__(self, words):\n        self.words = words\n        self.word_to_guess = random.choice(self.words).upper()\n        self.guessed_letters = set()\n        self.attempts_remaining = 6\n        self.word_guessed = False\n\n    def display_hangman(self):\n        stages = [\n            \"\"\"\n               ------\n               |    |\n               |    O\n               |   /|\\\\\n               |   / \\\\\n               |\n            \"\"\",\n            \"\"\"\n               ------\n               |    |\n               |    O\n               |   /|\\\\\n               |   /\n               |\n            \"\"\",\n            \"\"\"\n               ------\n               |    |\n               |    O\n               |   /|\n               |\n               |\n            \"\"\",\n            \"\"\"\n               ------\n               |    |\n               |    O\n               |    \n               |\n               |\n            \"\"\",\n            \"\"\"\n               ------\n               |    |\n               |    \n               |    \n               |\n               |\n            \"\"\",\n            \"\"\"\n               ------\n               |    \n               |    \n               |    \n               |\n               |\n            \"\"\",\n        ]\n        return stages[self.attempts_remaining]\n\n    def display_word(self):\n        displayed_word = ''.join(letter if letter in self.guessed_letters else '_' for letter in self.word_to_guess)\n        return displayed_word\n\n    def guess_letter(self, letter):\n        letter = letter.upper()\n        if letter in self.guessed_letters:\n            return False, \"You already guessed that letter.\"\n        \n        self.guessed_letters.add(letter)\n\n        if letter in self.word_to_guess:\n            if all(l in self.guessed_letters for l in self.word_to_guess):\n                self.word_guessed = True\n            return True, \"Good guess!\"\n        else:\n            self.attempts_remaining -= 1\n            return False, \"Wrong guess!\"\n\n    def play(self):\n        print(\"Welcome to Hangman!\")\n        while self.attempts_remaining > 0 and not self.word_guessed:\n            print(self.display_hangman())\n            print(f\"Word: {self.display_word()}\")\n            print(f\"Guessed letters: {' '.join(sorted(self.guessed_letters))}\")\n            print(f\"Attempts remaining: {self.attempts_remaining}\")\n            \n            guess = input(\"Guess a letter: \").strip()\n            if len(guess) != 1 or not guess.isalpha():\n                print(\"Please enter a single letter.\")\n                continue\n            \n            correct, message = self.guess_letter(guess)\n            print(message)\n        \n        if self.word_guessed:\n            print(f\"Congratulations! You've guessed the word: {self.word_to_guess}\")\n        else:\n            print(self.display_hangman())\n            print(f\"Sorry, you've run out of attempts. The word was: {self.word_to_guess}\")\n\nif __name__ == \"__main__\":\n    word_list = ['python', 'java', 'hangman', 'programming', 'developer']\n    game = Hangman(word_list)\n    game.play()\n```",
    "2": "```python\nimport random\n\nclass RockPaperScissors:\n    def __init__(self):\n        self.choices = ['rock', 'paper', 'scissors']\n\n    def get_user_choice(self):\n        user_input = input(\"Enter rock, paper, or scissors (or 'quit' to exit): \").lower()\n        if user_input in self.choices:\n            return user_input\n        elif user_input == 'quit':\n            return None\n        else:\n            print(\"Invalid choice. Please try again.\")\n            return self.get_user_choice()\n\n    def get_computer_choice(self):\n        return random.choice(self.choices)\n\n    def determine_winner(self, user_choice, computer_choice):\n        if user_choice == computer_choice:\n            return \"It's a tie!\"\n        elif (user_choice == 'rock' and computer_choice == 'scissors') or \\\n             (user_choice == 'paper' and computer_choice == 'rock') or \\\n             (user_choice == 'scissors' and computer_choice == 'paper'):\n            return \"You win!\"\n        else:\n            return \"You lose!\"\n\n    def play(self):\n        while True:\n            user_choice = self.get_user_choice()\n            if user_choice is None:\n                print(\"Thanks for playing!\")\n                break\n            computer_choice = self.get_computer_choice()\n            print(f\"Computer chose: {computer_choice}\")\n            result = self.determine_winner(user_choice, computer_choice)\n            print(result)\n\nif __name__ == \"__main__\":\n    game = RockPaperScissors()\n    game.play()\n```",
    "3": "```python\nimport random\nimport curses\n\nclass SnakeGame:\n    def __init__(self):\n        self.screen = curses.initscr()\n        self.height, self.width = self.screen.getmaxyx()\n        self.window = curses.newwin(self.height, self.width, 0, 0)\n        self.window.keypad(1)\n        self.window.timeout(100)\n        \n        self.snake = [(self.height // 2, self.width // 4)]\n        self.snake_direction = curses.KEY_RIGHT\n        self.food = self.place_food()\n        self.score = 0\n\n    def place_food(self):\n        while True:\n            food = (random.randint(1, self.height - 1), random.randint(1, self.width - 1))\n            if food not in self.snake:\n                return food\n\n    def game_over(self):\n        self.window.addstr(self.height // 2, self.width // 2 - 5, \"Game Over\")\n        self.window.refresh()\n        self.window.getch()\n        curses.endwin()\n        exit()\n\n    def run(self):\n        while True:\n            next_key = self.window.getch()\n            self.snake_direction = next_key if next_key in [curses.KEY_RIGHT, curses.KEY_LEFT, curses.KEY_UP, curses.KEY_DOWN] else self.snake_direction\n            \n            head_y, head_x = self.snake[0]\n            if self.snake_direction == curses.KEY_DOWN:\n                head_y += 1\n            elif self.snake_direction == curses.KEY_UP:\n                head_y -= 1\n            elif self.snake_direction == curses.KEY_LEFT:\n                head_x -= 1\n            elif self.snake_direction == curses.KEY_RIGHT:\n                head_x += 1\n\n            new_head = (head_y, head_x)\n\n            if (new_head in self.snake or\n                    head_y in [0, self.height] or\n                    head_x in [0, self.width]):\n                self.game_over()\n\n            self.snake.insert(0, new_head)\n            if new_head == self.food:\n                self.score += 1\n                self.food = self.place_food()\n            else:\n                self.snake.pop()\n\n            self.window.clear()\n            self.window.border(0)\n            self.window.addstr(0, 2, f'Score: {self.score} ')\n            self.window.addch(self.food[0], self.food[1], curses.ACS_PI)\n            for y, x in self.snake:\n                self.window.addch(y, x, curses.ACS_CKBOARD)\n\nif __name__ == \"__main__\":\n    game = SnakeGame()\n    try:\n        game.run()\n    finally:\n        curses.endwin()\n```\n",
    "4": "```python\nimport random\n\nclass Minesweeper:\n    def __init__(self, width, height, mines):\n        self.width = width\n        self.height = height\n        self.mines = mines\n        self.board = [[' ' for _ in range(width)] for _ in range(height)]\n        self.visible = [[' ' for _ in range(width)] for _ in range(height)]\n        self.game_over = False\n        self.revealed_count = 0\n        self._place_mines()\n        self._calculate_adjacent_mines()\n\n    def _place_mines(self):\n        positions = random.sample(range(self.width * self.height), self.mines)\n        for pos in positions:\n            row = pos // self.width\n            col = pos % self.width\n            self.board[row][col] = '*'\n\n    def _calculate_adjacent_mines(self):\n        for row in range(self.height):\n            for col in range(self.width):\n                if self.board[row][col] == '*':\n                    continue\n                mine_count = self._count_adjacent_mines(row, col)\n                if mine_count > 0:\n                    self.board[row][col] = str(mine_count)\n\n    def _count_adjacent_mines(self, row, col):\n        count = 0\n        for r in range(max(0, row - 1), min(self.height, row + 2)):\n            for c in range(max(0, col - 1), min(self.width, col + 2)):\n                if self.board[r][c] == '*':\n                    count += 1\n        return count\n\n    def reveal(self, row, col):\n        if self.board[row][col] == '*':\n            self.game_over = True\n            return\n        if self.visible[row][col] == ' ':\n            self.visible[row][col] = self.board[row][col]\n            self.revealed_count += 1\n            if self.board[row][col] == '0':\n                for r in range(max(0, row - 1), min(self.height, row + 2)):\n                    for c in range(max(0, col - 1), min(self.width, col + 2)):\n                        if (r, c) != (row, col):\n                            self.reveal(r, c)\n\n    def print_board(self):\n        print(\"   \" + \" \".join(str(i) for i in range(self.width)))\n        for r in range(self.height):\n            print(f\"{r} | \" + \" \".join(self.visible[r]))\n\n    def play(self):\n        while not self.game_over and self.revealed_count < self.width * self.height - self.mines:\n            self.print_board()\n            try:\n                row, col = map(int, input(\"Enter row and column to reveal (e.g., '1 2'): \").strip().split())\n                if 0 <= row < self.height and 0 <= col < self.width:\n                    self.reveal(row, col)\n                else:\n                    print(\"Invalid coordinates. Please try again.\")\n            except ValueError:\n                print(\"Invalid input. Please enter two integers separated by a space.\")\n\n        if self.game_over:\n            print(\"Game Over! You hit a mine.\")\n            self.reveal_all()\n            self.print_board()\n        else:\n            print(\"Congratulations! You've cleared the minefield.\")\n            self.print_board()\n\n    def reveal_all(self):\n        for r in range(self.height):\n            for c in range(self.width):\n                if self.board[r][c] == '*':\n                    self.visible[r][c] = '*'\n                elif self.visible[r][c] == ' ':\n                    self.visible[r][c] = self.board[r][c]\n\nif __name__ == \"__main__\":\n    game = Minesweeper(width=10, height=10, mines=10)\n    game.play()\n```",
    "5": "```python\nimport random\n\nclass Mastermind:\n    def __init__(self, code_length=4, max_attempts=10, colors=['R', 'G', 'B', 'Y', 'O', 'P']):\n        self.code_length = code_length\n        self.max_attempts = max_attempts\n        self.colors = colors\n        self.secret_code = self.generate_code()\n\n    def generate_code(self):\n        return [random.choice(self.colors) for _ in range(self.code_length)]\n\n    def get_feedback(self, guess):\n        correct_positions = sum(g == s for g, s in zip(guess, self.secret_code))\n        correct_colors = sum(min(guess.count(color), self.secret_code.count(color)) for color in set(guess))\n        correct_colors -= correct_positions\n        return correct_positions, correct_colors\n\n    def play(self):\n        print(\"Welcome to Mastermind!\")\n        print(f\"Guess the secret code of length {self.code_length} using the colors: {', '.join(self.colors)}.\")\n        print(f\"You have {self.max_attempts} attempts.\")\n        \n        for attempt in range(1, self.max_attempts + 1):\n            guess = input(f\"Attempt {attempt}: Enter your guess: \").upper().strip().split()\n            \n            if len(guess) != self.code_length or not all(color in self.colors for color in guess):\n                print(\"Invalid guess. Please enter a valid combination of colors.\")\n                continue\n            \n            correct_positions, correct_colors = self.get_feedback(guess)\n            print(f\"Feedback: {correct_positions} correct positions, {correct_colors} correct colors.\")\n            \n            if correct_positions == self.code_length:\n                print(\"Congratulations! You've cracked the code!\")\n                break\n        else:\n            print(f\"Sorry! You've used all attempts. The secret code was: {''.join(self.secret_code)}.\")\n\nif __name__ == \"__main__\":\n    game = Mastermind()\n    game.play()\n```",
    "6": "```python\nimport random\n\nclass Battleship:\n    def __init__(self, size=5, ships=3):\n        self.size = size\n        self.ships = ships\n        self.board = [['~'] * size for _ in range(size)]\n        self.ship_positions = set()\n        self.hits = 0\n        self.place_ships()\n\n    def place_ships(self):\n        while len(self.ship_positions) < self.ships:\n            x = random.randint(0, self.size - 1)\n            y = random.randint(0, self.size - 1)\n            self.ship_positions.add((x, y))\n\n    def print_board(self):\n        print(\"  \" + \" \".join(str(i) for i in range(self.size)))\n        for idx, row in enumerate(self.board):\n            print(idx, \" \".join(row))\n\n    def make_guess(self, x, y):\n        if (x, y) in self.ship_positions:\n            self.board[x][y] = 'X'\n            self.ship_positions.remove((x, y))\n            self.hits += 1\n            print(\"Hit!\")\n        else:\n            self.board[x][y] = 'O'\n            print(\"Miss!\")\n\n    def is_game_over(self):\n        return self.hits == self.ships\n\n    def play(self):\n        print(\"Welcome to Battleship!\")\n        while not self.is_game_over():\n            self.print_board()\n            try:\n                guess = input(\"Enter your guess (row col): \")\n                x, y = map(int, guess.split())\n                if 0 <= x < self.size and 0 <= y < self.size:\n                    self.make_guess(x, y)\n                else:\n                    print(\"Please enter valid coordinates.\")\n            except (ValueError, IndexError):\n                print(\"Invalid input. Please enter row and column numbers.\")\n\n        print(\"Congratulations! You've sunk all the ships!\")\n\nif __name__ == \"__main__\":\n    game = Battleship()\n    game.play()\n```",
    "7": "```python\nimport os\nimport time\nfrom typing import List\n\nclass GameOfLife:\n    def __init__(self, width: int, height: int):\n        self.width = width\n        self.height = height\n        self.board = self.create_empty_board()\n\n    def create_empty_board(self) -> List[List[int]]:\n        return [[0 for _ in range(self.width)] for _ in range(self.height)]\n\n    def print_board(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for row in self.board:\n            print(' '.join('█' if cell else ' ' for cell in row))\n        print(\"\\n\")\n\n    def set_initial_state(self, initial_state: List[tuple]):\n        for x, y in initial_state:\n            self.board[y][x] = 1\n\n    def get_neighbors_count(self, x: int, y: int) -> int:\n        neighbors = [\n            (-1, -1), (-1, 0), (-1, 1),\n            (0, -1),          (0, 1),\n            (1, -1), (1, 0), (1, 1)\n        ]\n        count = 0\n        for dx, dy in neighbors:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < self.width and 0 <= ny < self.height:\n                count += self.board[ny][nx]\n        return count\n\n    def update_board(self):\n        new_board = self.create_empty_board()\n        for y in range(self.height):\n            for x in range(self.width):\n                neighbors_count = self.get_neighbors_count(x, y)\n                if self.board[y][x] == 1:\n                    if neighbors_count in (2, 3):\n                        new_board[y][x] = 1\n                else:\n                    if neighbors_count == 3:\n                        new_board[y][x] = 1\n        self.board = new_board\n\n    def run(self, iterations: int = 10, delay: float = 0.5):\n        for _ in range(iterations):\n            self.print_board()\n            self.update_board()\n            time.sleep(delay)\n\nif __name__ == \"__main__\":\n    game = GameOfLife(width=10, height=10)\n    initial_state = [(1, 1), (1, 2), (1, 3), (2, 2), (3, 1), (3, 2), (3, 3)]\n    game.set_initial_state(initial_state)\n    game.run(iterations=50, delay=0.2)\n```",
    "8": "```python\nclass ConnectFour:\n    def __init__(self):\n        self.rows = 6\n        self.cols = 7\n        self.board = [[' ' for _ in range(self.cols)] for _ in range(self.rows)]\n        self.current_player = 'X'\n    \n    def print_board(self):\n        for row in self.board:\n            print('|'.join(row))\n            print('-' * (self.cols * 2 - 1))\n        print(' '.join(str(i) for i in range(self.cols)))\n\n    def drop_piece(self, col):\n        if col < 0 or col >= self.cols:\n            print(\"Invalid column. Choose a column between 0 and 6.\")\n            return False\n        for row in reversed(range(self.rows)):\n            if self.board[row][col] == ' ':\n                self.board[row][col] = self.current_player\n                return True\n        print(\"Column is full. Choose another column.\")\n        return False\n\n    def check_win(self):\n        # Check horizontal, vertical, and diagonal for win\n        for r in range(self.rows):\n            for c in range(self.cols - 3):\n                if self.board[r][c] == self.current_player and all(self.board[r][c + i] == self.current_player for i in range(4)):\n                    return True\n        \n        for c in range(self.cols):\n            for r in range(self.rows - 3):\n                if self.board[r][c] == self.current_player and all(self.board[r + i][c] == self.current_player for i in range(4)):\n                    return True\n        \n        for r in range(self.rows - 3):\n            for c in range(self.cols - 3):\n                if self.board[r][c] == self.current_player and all(self.board[r + i][c + i] == self.current_player for i in range(4)):\n                    return True\n        \n        for r in range(3, self.rows):\n            for c in range(self.cols - 3):\n                if self.board[r][c] == self.current_player and all(self.board[r - i][c + i] == self.current_player for i in range(4)):\n                    return True\n        \n        return False\n\n    def switch_player(self):\n        self.current_player = 'O' if self.current_player == 'X' else 'X'\n\n    def play(self):\n        while True:\n            self.print_board()\n            col = int(input(f\"Player {self.current_player}, choose a column (0-6): \"))\n            if self.drop_piece(col):\n                if self.check_win():\n                    self.print_board()\n                    print(f\"Player {self.current_player} wins!\")\n                    break\n                self.switch_player()\n\nif __name__ == \"__main__\":\n    game = ConnectFour()\n    game.play()\n```",
    "9": "```python\nimport random\n\nclass Card:\n    SUITS = ('Hearts', 'Diamonds', 'Clubs', 'Spades')\n    RANKS = ('2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace')\n    VALUES = {rank: min(value, 10) for value, rank in enumerate(RANKS, start=2)}\n    VALUES['Ace'] = 11  # Ace can be 1 or 11, handled in hand value calculation.\n\n    def __init__(self, suit, rank):\n        self.suit = suit\n        self.rank = rank\n\n    def __str__(self):\n        return f\"{self.rank} of {self.suit}\"\n\nclass Deck:\n    def __init__(self):\n        self.cards = [Card(suit, rank) for suit in Card.SUITS for rank in Card.RANKS]\n        random.shuffle(self.cards)\n\n    def deal_card(self):\n        return self.cards.pop() if self.cards else None\n\nclass Hand:\n    def __init__(self):\n        self.cards = []\n\n    def add_card(self, card):\n        self.cards.append(card)\n\n    def calculate_value(self):\n        value = sum(Card.VALUES[card.rank] for card in self.cards)\n        # Adjust for Aces\n        aces = sum(1 for card in self.cards if card.rank == 'Ace')\n        while value > 21 and aces:\n            value -= 10\n            aces -= 1\n        return value\n\n    def __str__(self):\n        return ', '.join(str(card) for card in self.cards)\n\nclass Blackjack:\n    def __init__(self):\n        self.deck = Deck()\n        self.player_hand = Hand()\n        self.dealer_hand = Hand()\n\n    def initial_deal(self):\n        for _ in range(2):\n            self.player_hand.add_card(self.deck.deal_card())\n            self.dealer_hand.add_card(self.deck.deal_card())\n\n    def display_hands(self, reveal_dealer=False):\n        print(f\"Player's Hand: {self.player_hand} (Value: {self.player_hand.calculate_value()})\")\n        if reveal_dealer:\n            print(f\"Dealer's Hand: {self.dealer_hand} (Value: {self.dealer_hand.calculate_value()})\")\n        else:\n            print(f\"Dealer's Hand: {self.dealer_hand.cards[0]}, Hidden Card\")\n\n    def player_turn(self):\n        while True:\n            self.display_hands()\n            action = input(\"Do you want to (h)it or (s)tand? \").lower()\n            if action == 'h':\n                self.player_hand.add_card(self.deck.deal_card())\n                if self.player_hand.calculate_value() > 21:\n                    print(\"You busted!\")\n                    return False\n            elif action == 's':\n                break\n        return True\n\n    def dealer_turn(self):\n        while self.dealer_hand.calculate_value() < 17:\n            self.dealer_hand.add_card(self.deck.deal_card())\n\n    def determine_winner(self):\n        player_value = self.player_hand.calculate_value()\n        dealer_value = self.dealer_hand.calculate_value()\n        print(f\"Final Player's Hand: {self.player_hand} (Value: {player_value})\")\n        print(f\"Final Dealer's Hand: {self.dealer_hand} (Value: {dealer_value})\")\n\n        if player_value > 21:\n            return \"Dealer wins!\"\n        elif dealer_value > 21 or player_value > dealer_value:\n            return \"Player wins!\"\n        elif player_value < dealer_value:\n            return \"Dealer wins!\"\n        else:\n            return \"It's a tie!\"\n\n    def play(self):\n        print(\"Welcome to Blackjack!\")\n        self.initial_deal()\n        if self.player_turn():\n            self.dealer_turn()\n        print(self.determine_winner())\n\nif __name__ == \"__main__\":\n    game = Blackjack()\n    game.play()\n```\n",
    "10": "```python\nimport random\n\nclass Hammurabi:\n    def __init__(self):\n        self.year = 1\n        self.population = 100\n        self.land = 1000\n        self.bushels = 2800\n        self.harvest = 3\n        self.plague = False\n        self.starving = False\n        self.land_price = 20\n        self.max_years = 10\n\n    def print_status(self):\n        print(f\"\\nYear: {self.year}\")\n        print(f\"Population: {self.population}\")\n        print(f\"Land: {self.land} acres\")\n        print(f\"Bushels of grain: {self.bushels}\")\n        print(f\"Harvest per acre: {self.harvest} bushels\")\n        print(f\"Plague: {'Yes' if self.plague else 'No'}\")\n        print(f\"Starving: {'Yes' if self.starving else 'No'}\")\n\n    def calculate_harvest(self):\n        return self.land * self.harvest\n\n    def next_year(self):\n        self.year += 1\n        self.harvest = random.randint(1, 6)\n        self.bushels += self.calculate_harvest()\n        self.handle_plague()\n        self.handle_starvation()\n        self.check_end_game()\n\n    def handle_plague(self):\n        if random.random() < 0.2:\n            self.plague = True\n            lost_population = int(self.population * 0.5)\n            self.population -= lost_population\n            print(f\"A plague has struck! You lost {lost_population} people.\")\n\n    def handle_starvation(self):\n        if self.bushels < self.population:\n            self.starving = True\n            lost_population = self.population - self.bushels\n            self.population -= lost_population\n            self.bushels = 0\n            print(f\"Starvation has occurred! You lost {lost_population} people.\")\n\n    def check_end_game(self):\n        if self.population <= 0 or self.year > self.max_years:\n            self.end_game()\n\n    def end_game(self):\n        print(\"\\nGame Over!\")\n        if self.population <= 0:\n            print(\"Your population has died out.\")\n        else:\n            print(\"You have ruled for 10 years.\")\n        exit()\n\n    def buy_land(self, acres):\n        cost = acres * self.land_price\n        if cost > self.bushels:\n            print(\"You do not have enough bushels to buy that much land.\")\n            return\n        self.land += acres\n        self.bushels -= cost\n        print(f\"You bought {acres} acres of land.\")\n\n    def sell_land(self, acres):\n        if acres > self.land:\n            print(\"You do not own that much land.\")\n            return\n        self.land -= acres\n        self.bushels += acres * self.land_price\n        print(f\"You sold {acres} acres of land.\")\n\n    def feed_population(self, bushels):\n        if bushels > self.bushels:\n            print(\"You do not have enough bushels to feed that many people.\")\n            return\n        self.bushels -= bushels\n        self.starving = False\n        print(f\"You fed the population {bushels} bushels of grain.\")\n\n    def play(self):\n        while True:\n            self.print_status()\n            print(\"\\nOptions:\")\n            print(\"1. Buy land\")\n            print(\"2. Sell land\")\n            print(\"3. Feed population\")\n            print(\"4. End year\")\n\n            choice = input(\"Choose an option (1-4): \")\n\n            if choice == '1':\n                acres = int(input(\"How many acres do you want to buy? \"))\n                self.buy_land(acres)\n            elif choice == '2':\n                acres = int(input(\"How many acres do you want to sell? \"))\n                self.sell_land(acres)\n            elif choice == '3':\n                bushels = int(input(\"How many bushels do you want to feed the population? \"))\n                self.feed_population(bushels)\n            elif choice == '4':\n                self.next_year()\n            else:\n                print(\"Invalid choice. Please choose again.\")\n\nif __name__ == \"__main__\":\n    game = Hammurabi()\n    game.play()\n```",
    "11": "```python\nimport random\n\nclass LightsOut:\n    def __init__(self, size=5):\n        self.size = size\n        self.board = [[random.choice([True, False]) for _ in range(size)] for _ in range(size)]\n        self.is_solved = False\n\n    def display_board(self):\n        for row in self.board:\n            print(\" \".join(['O' if cell else 'X' for cell in row]))\n        print()\n\n    def toggle(self, row, col):\n        if 0 <= row < self.size and 0 <= col < self.size:\n            self.board[row][col] = not self.board[row][col]\n            if row > 0: self.board[row - 1][col] = not self.board[row - 1][col]\n            if row < self.size - 1: self.board[row + 1][col] = not self.board[row + 1][col]\n            if col > 0: self.board[row][col - 1] = not self.board[row][col - 1]\n            if col < self.size - 1: self.board[row][col + 1] = not self.board[row][col + 1]\n\n    def check_solved(self):\n        self.is_solved = all(not cell for row in self.board for cell in row)\n\n    def play(self):\n        while not self.is_solved:\n            self.display_board()\n            try:\n                move = input(f\"Enter your move (row col) or 'quit' to exit: \")\n                if move.lower() == 'quit':\n                    print(\"Thanks for playing!\")\n                    break\n                row, col = map(int, move.split())\n                self.toggle(row, col)\n                self.check_solved()\n            except (ValueError, IndexError):\n                print(\"Invalid move. Please enter valid row and column numbers.\")\n\n        if self.is_solved:\n            print(\"Congratulations! You've turned off all the lights!\")\n\nif __name__ == \"__main__\":\n    game = LightsOut()\n    game.play()\n```\n",
    "12": "```python\nimport os\nimport time\nimport sys\nimport random\nimport keyboard\n\nclass Pong:\n    def __init__(self):\n        self.width = 40\n        self.height = 20\n        self.ball_x = self.width // 2\n        self.ball_y = self.height // 2\n        self.ball_dx = random.choice([-1, 1])\n        self.ball_dy = random.choice([-1, 1])\n        self.paddle1_y = self.height // 2\n        self.paddle2_y = self.height // 2\n        self.paddle_height = 4\n        self.score1 = 0\n        self.score2 = 0\n        self.running = True\n\n    def draw(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for y in range(self.height):\n            for x in range(self.width):\n                if x == 0:\n                    print('|', end='')\n                elif x == self.width - 1:\n                    print('|', end='')\n                elif (x == self.ball_x and y == self.ball_y):\n                    print('O', end='')\n                elif (x == 1 and self.paddle1_y <= y < self.paddle1_y + self.paddle_height):\n                    print('#', end='')\n                elif (x == self.width - 2 and self.paddle2_y <= y < self.paddle2_y + self.paddle_height):\n                    print('#', end='')\n                else:\n                    print(' ', end='')\n            print()\n        print(f'Score: Player 1: {self.score1} | Player 2: {self.score2}')\n\n    def update(self):\n        self.ball_x += self.ball_dx\n        self.ball_y += self.ball_dy\n\n        if self.ball_y <= 0 or self.ball_y >= self.height - 1:\n            self.ball_dy *= -1\n        \n        if self.ball_x == 1 and self.paddle1_y <= self.ball_y < self.paddle1_y + self.paddle_height:\n            self.ball_dx *= -1\n        elif self.ball_x == self.width - 2 and self.paddle2_y <= self.ball_y < self.paddle2_y + self.paddle_height:\n            self.ball_dx *= -1\n        elif self.ball_x <= 0:\n            self.score2 += 1\n            self.reset_ball()\n        elif self.ball_x >= self.width - 1:\n            self.score1 += 1\n            self.reset_ball()\n\n    def reset_ball(self):\n        self.ball_x = self.width // 2\n        self.ball_y = self.height // 2\n        self.ball_dx = random.choice([-1, 1])\n        self.ball_dy = random.choice([-1, 1])\n\n    def move_paddle(self, paddle, direction):\n        if paddle == 1 and self.paddle1_y > 0 and direction == 'up':\n            self.paddle1_y -= 1\n        elif paddle == 1 and self.paddle1_y < self.height - self.paddle_height and direction == 'down':\n            self.paddle1_y += 1\n        elif paddle == 2 and self.paddle2_y > 0 and direction == 'up':\n            self.paddle2_y -= 1\n        elif paddle == 2 and self.paddle2_y < self.height - self.paddle_height and direction == 'down':\n            self.paddle2_y += 1\n\n    def run(self):\n        print(\"Controls: Player 1 (W/S), Player 2 (I/K)\")\n        while self.running:\n            if keyboard.is_pressed('w'):\n                self.move_paddle(1, 'up')\n            if keyboard.is_pressed('s'):\n                self.move_paddle(1, 'down')\n            if keyboard.is_pressed('i'):\n                self.move_paddle(2, 'up')\n            if keyboard.is_pressed('k'):\n                self.move_paddle(2, 'down')\n\n            self.update()\n            self.draw()\n            time.sleep(0.1)\n\nif __name__ == \"__main__\":\n    pong_game = Pong()\n    try:\n        pong_game.run()\n    except KeyboardInterrupt:\n        print(\"Game exited.\")\n        sys.exit()\n```",
    "13": "```python\nimport random\nimport os\nimport sys\nimport time\nimport keyboard\n\nclass Tetris:\n    def __init__(self, width=10, height=20):\n        self.width = width\n        self.height = height\n        self.board = [[' ' for _ in range(width)] for _ in range(height)]\n        self.shapes = [\n            [['#', '#', '#', '#']],  # I\n            [['#', '#', '#'], [' ', '#', ' ']],  # T\n            [['#', '#'], ['#', '#']],  # O\n            [[' ', ' ', '#'], ['#', '#', '#']],  # L\n            [['#', ' ', ' '], ['#', '#', '#']],  # J\n            [['#', '#', ' '], [' ', '#', '#']],  # S\n            [[' ', '#', '#'], ['#', '#', ' ']]   # Z\n        ]\n        self.current_shape = None\n        self.current_position = (0, 0)\n        self.game_over = False\n\n    def new_shape(self):\n        self.current_shape = random.choice(self.shapes)\n        self.current_position = (0, self.width // 2 - len(self.current_shape[0]) // 2)\n\n    def rotate_shape(self):\n        self.current_shape = [list(row) for row in zip(*self.current_shape[::-1])]\n\n    def can_move(self, offset_x, offset_y):\n        for r, row in enumerate(self.current_shape):\n            for c, cell in enumerate(row):\n                if cell == '#':\n                    x = self.current_position[0] + r + offset_y\n                    y = self.current_position[1] + c + offset_x\n                    if x < 0 or x >= self.height or y < 0 or y >= self.width or self.board[x][y] == '#':\n                        return False\n        return True\n\n    def merge_shape(self):\n        for r, row in enumerate(self.current_shape):\n            for c, cell in enumerate(row):\n                if cell == '#':\n                    self.board[self.current_position[0] + r][self.current_position[1] + c] = '#'\n\n    def clear_lines(self):\n        self.board = [row for row in self.board if any(cell == ' ' for cell in row)]\n        while len(self.board) < self.height:\n            self.board.insert(0, [' ' for _ in range(self.width)])\n\n    def draw_board(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for row in self.board:\n            print('|' + ''.join(row) + '|')\n        print('+' + '-' * self.width + '+')\n\n    def drop_shape(self):\n        if self.can_move(0, 1):\n            self.current_position = (self.current_position[0] + 1, self.current_position[1])\n        else:\n            self.merge_shape()\n            self.clear_lines()\n            if self.current_position[0] == 0:\n                self.game_over = True\n            self.new_shape()\n\n    def move_shape(self, direction):\n        if self.can_move(direction, 0):\n            self.current_position = (self.current_position[0], self.current_position[1] + direction)\n\n    def play(self):\n        self.new_shape()\n        while not self.game_over:\n            self.draw_board()\n            time.sleep(0.5)\n            self.drop_shape()\n            if keyboard.is_pressed('left'):\n                self.move_shape(-1)\n            if keyboard.is_pressed('right'):\n                self.move_shape(1)\n            if keyboard.is_pressed('down'):\n                self.drop_shape()\n            if keyboard.is_pressed('up'):\n                self.rotate_shape()\n\n        print(\"Game Over\")\n\nif __name__ == \"__main__\":\n    game = Tetris()\n    game.play()\n```\n",
    "14": "Here's a simple implementation of the Asteroids game with a command-line interface in Python:\n\n```python\nimport random\nimport os\nimport time\nimport math\nimport sys\nimport keyboard\n\nclass AsteroidsGame:\n    def __init__(self, width=40, height=20):\n        self.width = width\n        self.height = height\n        self.player_pos = [width // 2, height // 2]\n        self.player_angle = 0\n        self.asteroids = []\n        self.score = 0\n        self.running = True\n        self.generate_asteroids()\n\n    def generate_asteroids(self):\n        for _ in range(5):\n            x = random.randint(0, self.width - 1)\n            y = random.randint(0, self.height - 1)\n            self.asteroids.append([x, y])\n\n    def draw(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for y in range(self.height):\n            for x in range(self.width):\n                if [x, y] == self.player_pos:\n                    print('^', end='')\n                elif [x, y] in self.asteroids:\n                    print('*', end='')\n                else:\n                    print(' ', end='')\n            print()\n        print(f\"Score: {self.score}\")\n\n    def move_player(self, direction):\n        if direction == 'left':\n            self.player_angle -= 5\n        elif direction == 'right':\n            self.player_angle += 5\n\n    def update(self):\n        for asteroid in self.asteroids:\n            if asteroid[0] < 0 or asteroid[0] >= self.width or asteroid[1] < 0 or asteroid[1] >= self.height:\n                asteroid[0] = random.randint(0, self.width - 1)\n                asteroid[1] = random.randint(0, self.height - 1)\n            else:\n                asteroid[0] += random.choice([-1, 0, 1])\n                asteroid[1] += random.choice([-1, 0, 1])\n\n            if asteroid == self.player_pos:\n                self.running = False\n\n    def play(self):\n        print(\"Controls: Arrow Left / Arrow Right to rotate, Q to quit\")\n        while self.running:\n            self.draw()\n            if keyboard.is_pressed('left'):\n                self.move_player('left')\n            if keyboard.is_pressed('right'):\n                self.move_player('right')\n            if keyboard.is_pressed('q'):\n                self.running = False\n            self.update()\n            time.sleep(0.1)\n        print(\"Game Over!\")\n\nif __name__ == \"__main__\":\n    game = AsteroidsGame()\n    game.play()\n```\n\nThis code represents a basic command-line version of the Asteroids game. It includes player rotation and asteroid movement, although collision detection and shooting mechanics are simplified for clarity. The game runs in a loop until the player quits or collides with an asteroid. Make sure to run this code in an environment where you can capture keyboard events, such as a local terminal.",
    "15": "```python\nimport random\nimport string\n\nclass Boggle:\n    def __init__(self, size=4):\n        self.size = size\n        self.board = self.generate_board()\n        self.dictionary = set()\n\n    def generate_board(self):\n        letters = [random.choice(string.ascii_uppercase) for _ in range(self.size * self.size)]\n        return [letters[i * self.size:(i + 1) * self.size] for i in range(self.size)]\n\n    def load_dictionary(self, words):\n        self.dictionary = set(words)\n\n    def display_board(self):\n        for row in self.board:\n            print(\" \".join(row))\n        print()\n\n    def is_valid_word(self, word):\n        return word in self.dictionary\n\n    def find_words(self, word, x, y, visited, found_words):\n        if not (0 <= x < self.size and 0 <= y < self.size) or (x, y) in visited:\n            return\n        \n        visited.add((x, y))\n        word += self.board[x][y]\n\n        if self.is_valid_word(word):\n            found_words.add(word)\n\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                self.find_words(word, x + dx, y + dy, visited, found_words)\n\n        visited.remove((x, y))\n\n    def play(self):\n        print(\"Welcome to Boggle!\")\n        self.display_board()\n\n        found_words = set()\n        for x in range(self.size):\n            for y in range(self.size):\n                self.find_words(\"\", x, y, set(), found_words)\n\n        print(\"You found the following words:\")\n        for word in sorted(found_words):\n            print(word)\n\n# Example usage\nif __name__ == \"__main__\":\n    boggle_game = Boggle()\n    boggle_game.load_dictionary([\"CAT\", \"CART\", \"BAT\", \"BAR\", \"RAT\", \"ART\", \"TAB\", \"TAR\", \"AT\", \"A\", \"BATMAN\"])\n    boggle_game.play()\n```\n",
    "16": "```python\nimport random\nimport os\nimport time\n\nclass PacManGame:\n    def __init__(self, width=10, height=10):\n        self.width = width\n        self.height = height\n        self.pacman_pos = [1, 1]\n        self.food_positions = self.generate_food(5)\n        self.score = 0\n        self.is_running = True\n        self.directions = {'w': (-1, 0), 's': (1, 0), 'a': (0, -1), 'd': (0, 1)}\n\n    def generate_food(self, count):\n        food_positions = []\n        while len(food_positions) < count:\n            pos = [random.randint(0, self.height - 1), random.randint(0, self.width - 1)]\n            if pos not in food_positions and pos != self.pacman_pos:\n                food_positions.append(pos)\n        return food_positions\n\n    def display(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for i in range(self.height):\n            for j in range(self.width):\n                if [i, j] == self.pacman_pos:\n                    print(\"P\", end=' ')\n                elif [i, j] in self.food_positions:\n                    print(\"F\", end=' ')\n                else:\n                    print(\".\", end=' ')\n            print()\n        print(f\"Score: {self.score}\")\n\n    def move(self, direction):\n        if direction in self.directions:\n            new_pos = [\n                self.pacman_pos[0] + self.directions[direction][0],\n                self.pacman_pos[1] + self.directions[direction][1]\n            ]\n            if 0 <= new_pos[0] < self.height and 0 <= new_pos[1] < self.width:\n                self.pacman_pos = new_pos\n                self.check_food()\n\n    def check_food(self):\n        if self.pacman_pos in self.food_positions:\n            self.food_positions.remove(self.pacman_pos)\n            self.score += 1           \n\n    def run(self):\n        while self.is_running:\n            self.display()\n            move = input(\"Move (w/a/s/d) or 'q' to quit: \")\n            if move == 'q':\n                self.is_running = False\n            else:\n                self.move(move)\n\nif __name__ == \"__main__\":\n    game = PacManGame()\n    game.run()\n```\n",
    "17": "```python\nimport random\nimport time\nimport threading\nimport os\nimport sys\n\nclass DinosaurRunner:\n    def __init__(self):\n        self.score = 0\n        self.is_running = True\n        self.dino_pos = 5\n        self.obstacle_pos = 20\n        self.obstacle_char = 'O'\n        self.dino_char = 'D'\n        self.width = 30\n        self.height = 10\n\n    def clear_screen(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n\n    def draw_game(self):\n        self.clear_screen()\n        for i in range(self.height):\n            if i == self.height - 1:\n                print('Score: {}'.format(self.score))\n            else:\n                line = [' '] * self.width\n                if self.obstacle_pos < self.width:\n                    line[self.obstacle_pos] = self.obstacle_char\n                line[self.dino_pos] = self.dino_char\n                print(''.join(line))\n\n    def move_obstacle(self):\n        while self.is_running:\n            time.sleep(0.1)\n            self.obstacle_pos -= 1\n            if self.obstacle_pos < 0:\n                self.obstacle_pos = self.width - 1\n                self.score += 1\n\n    def jump(self):\n        original_pos = self.dino_pos\n        self.dino_pos -= 1\n        self.draw_game()\n        time.sleep(0.3)\n        self.dino_pos = original_pos\n\n    def check_collision(self):\n        return self.dino_pos == self.obstacle_pos\n\n    def run(self):\n        threading.Thread(target=self.move_obstacle, daemon=True).start()\n        while self.is_running:\n            self.draw_game()\n            action = input(\"Press 'j' to jump: \")\n            if action.lower() == 'j':\n                self.jump()\n            if self.check_collision():\n                self.is_running = False\n                print(\"Game Over! Final Score: {}\".format(self.score))\n\nif __name__ == \"__main__\":\n    game = DinosaurRunner()\n    game.run()\n```\n"
}