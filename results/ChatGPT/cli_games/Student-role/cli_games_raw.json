{
    "0": "```python\nclass TicTacToe:\n    def __init__(self):\n        self.board = [' ' for _ in range(9)]  # A list to hold the board state\n        self.current_player = 'X'\n\n    def print_board(self):\n        print(f\"{self.board[0]} | {self.board[1]} | {self.board[2]}\")\n        print(\"--+---+--\")\n        print(f\"{self.board[3]} | {self.board[4]} | {self.board[5]}\")\n        print(\"--+---+--\")\n        print(f\"{self.board[6]} | {self.board[7]} | {self.board[8]}\")\n\n    def check_winner(self):\n        winning_combinations = [\n            (0, 1, 2), (3, 4, 5), (6, 7, 8),  # horizontal\n            (0, 3, 6), (1, 4, 7), (2, 5, 8),  # vertical\n            (0, 4, 8), (2, 4, 6)               # diagonal\n        ]\n        for combo in winning_combinations:\n            if self.board[combo[0]] == self.board[combo[1]] == self.board[combo[2]] != ' ':\n                return self.board[combo[0]]\n        if ' ' not in self.board:\n            return 'Draw'\n        return None\n\n    def make_move(self, position):\n        if self.board[position] == ' ':\n            self.board[position] = self.current_player\n            winner = self.check_winner()\n            if winner:\n                self.print_board()\n                if winner == 'Draw':\n                    print(\"It's a draw!\")\n                else:\n                    print(f\"Player {winner} wins!\")\n                return True\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return False\n        else:\n            print(\"Invalid move. Try again.\")\n            return False\n\n    def play_game(self):\n        while True:\n            self.print_board()\n            try:\n                move = int(input(f\"Player {self.current_player}, enter your move (1-9): \")) - 1\n                if move < 0 or move > 8:\n                    print(\"Invalid move. Enter a number between 1 and 9.\")\n                    continue\n                if self.make_move(move):\n                    break\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\nif __name__ == \"__main__\":\n    game = TicTacToe()\n    game.play_game()\n```",
    "1": "```python\nimport random\n\nclass Hangman:\n    def __init__(self, word_list):\n        self.word_list = word_list\n        self.word = random.choice(self.word_list).upper()\n        self.guesses = []\n        self.max_attempts = 6\n        self.attempts = 0\n\n    def display_word(self):\n        displayed = ''.join([letter if letter in self.guesses else '_' for letter in self.word])\n        return displayed\n\n    def guess(self, letter):\n        letter = letter.upper()\n        if letter in self.guesses:\n            print(\"You've already guessed that letter.\")\n            return False\n\n        self.guesses.append(letter)\n        if letter not in self.word:\n            self.attempts += 1\n            print(f\"Wrong guess! Attempts left: {self.max_attempts - self.attempts}\")\n        return True\n\n    def is_won(self):\n        return all(letter in self.guesses for letter in self.word)\n\n    def is_lost(self):\n        return self.attempts >= self.max_attempts\n\n    def play(self):\n        print(\"Welcome to Hangman!\")\n        while not self.is_won() and not self.is_lost():\n            print(f\"Current word: {self.display_word()}\")\n            print(f\"Guessed letters: {', '.join(self.guesses)}\")\n            guess = input(\"Guess a letter: \")\n            if len(guess) == 1 and guess.isalpha():\n                self.guess(guess)\n            else:\n                print(\"Please enter a single alphabetical character.\")\n\n        if self.is_won():\n            print(f\"Congratulations! You've guessed the word: {self.word}\")\n        else:\n            print(f\"Sorry, you've lost. The word was: {self.word}\")\n\nif __name__ == \"__main__\":\n    word_list = ['PYTHON', 'HANGMAN', 'DEVELOPER', 'COMPUTER', 'PROGRAMMING']\n    game = Hangman(word_list)\n    game.play()\n```",
    "2": "```python\nimport random\n\nclass RockPaperScissors:\n    def __init__(self):\n        self.choices = ['rock', 'paper', 'scissors']\n        self.wins = 0\n        self.losses = 0\n        self.ties = 0\n\n    def play_round(self, user_choice):\n        if user_choice not in self.choices:\n            return \"Invalid choice! Please choose rock, paper, or scissors.\"\n\n        computer_choice = random.choice(self.choices)\n        result = self.determine_winner(user_choice, computer_choice)\n        return f\"You chose {user_choice}, Computer chose {computer_choice}. {result}\"\n\n    def determine_winner(self, user_choice, computer_choice):\n        if user_choice == computer_choice:\n            self.ties += 1\n            return \"It's a tie!\"\n        elif (user_choice == 'rock' and computer_choice == 'scissors') or \\\n             (user_choice == 'paper' and computer_choice == 'rock') or \\\n             (user_choice == 'scissors' and computer_choice == 'paper'):\n            self.wins += 1\n            return \"You win!\"\n        else:\n            self.losses += 1\n            return \"You lose!\"\n\n    def get_score(self):\n        return f\"Wins: {self.wins}, Losses: {self.losses}, Ties: {self.ties}\"\n\ndef main():\n    game = RockPaperScissors()\n    while True:\n        user_input = input(\"Enter rock, paper, or scissors (or 'quit' to exit): \").lower()\n        if user_input == 'quit':\n            print(\"Thanks for playing!\")\n            break\n        result = game.play_round(user_input)\n        print(result)\n        print(game.get_score())\n\nif __name__ == \"__main__\":\n    main()\n```",
    "3": "```python\nimport random\nimport curses\n\nclass SnakeGame:\n    def __init__(self, height=20, width=60):\n        self.height = height\n        self.width = width\n        self.window = curses.initscr()\n        self.window.keypad(1)\n        curses.noecho()\n        curses.cbreak()\n        self.window.border(0)\n        self.window.timeout(100)\n        self.snake = [(height // 2, width // 4)]\n        self.snake_dir = (0, 1)  # Start moving right\n        self.food = self.place_food()\n        self.score = 0\n\n    def place_food(self):\n        while True:\n            food = (random.randint(1, self.height - 2), random.randint(1, self.width - 2))\n            if food not in self.snake:\n                return food\n\n    def change_direction(self, key):\n        if key == curses.KEY_UP and self.snake_dir != (1, 0):\n            self.snake_dir = (-1, 0)\n        elif key == curses.KEY_DOWN and self.snake_dir != (-1, 0):\n            self.snake_dir = (1, 0)\n        elif key == curses.KEY_LEFT and self.snake_dir != (0, 1):\n            self.snake_dir = (0, -1)\n        elif key == curses.KEY_RIGHT and self.snake_dir != (0, -1):\n            self.snake_dir = (0, 1)\n\n    def update(self):\n        head_y, head_x = self.snake[0]\n        new_head = (head_y + self.snake_dir[0], head_x + self.snake_dir[1])\n\n        if (new_head[0] in [0, self.height - 1] or\n                new_head[1] in [0, self.width - 1] or\n                new_head in self.snake):\n            return False  # Game over\n\n        self.snake.insert(0, new_head)\n\n        if new_head == self.food:\n            self.score += 1\n            self.food = self.place_food()\n        else:\n            self.snake.pop()\n\n        return True\n\n    def draw(self):\n        self.window.clear()\n        self.window.border(0)\n        self.window.addstr(0, 2, f'Score: {self.score} ')\n        self.window.addstr(self.food[0], self.food[1], 'üçè')\n        for y, x in self.snake:\n            self.window.addstr(y, x, 'üêç')\n        self.window.refresh()\n\n    def run(self):\n        while True:\n            self.draw()\n            key = self.window.getch()\n            self.change_direction(key)\n            if not self.update():\n                break\n        curses.endwin()\n        print(f'Game Over! Your score was {self.score}.')\n\nif __name__ == '__main__':\n    game = SnakeGame()\n    game.run()\n```\n",
    "4": "```python\nimport random\n\nclass Minesweeper:\n    def __init__(self, width, height, mines):\n        self.width = width\n        self.height = height\n        self.mines = mines\n        self.board = [[' ' for _ in range(width)] for _ in range(height)]\n        self.visible = [[' ' for _ in range(width)] for _ in range(height)]\n        self.game_over = False\n        self.populate_mines()\n\n    def populate_mines(self):\n        mine_positions = random.sample(range(self.width * self.height), self.mines)\n        for pos in mine_positions:\n            x = pos % self.width\n            y = pos // self.width\n            self.board[y][x] = '*'\n            self.update_numbers(x, y)\n\n    def update_numbers(self, x, y):\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                if 0 <= x + i < self.width and 0 <= y + j < self.height and self.board[y + j][x + i] != '*':\n                    if self.board[y + j][x + i] == ' ':\n                        self.board[y + j][x + i] = 1\n                    else:\n                        self.board[y + j][x + i] += 1\n\n    def reveal(self, x, y):\n        if self.board[y][x] == '*':\n            self.game_over = True\n            return\n        \n        if self.visible[y][x] == ' ':\n            self.visible[y][x] = self.board[y][x]\n            if self.board[y][x] == 0:\n                for i in range(-1, 2):\n                    for j in range(-1, 2):\n                        if 0 <= x + i < self.width and 0 <= y + j < self.height:\n                            self.reveal(x + i, y + j)\n\n    def display(self):\n        print(\"Current Board:\")\n        for row in self.visible:\n            print(' '.join(str(cell) for cell in row))\n        if self.game_over:\n            print(\"Game Over! You hit a mine.\")\n\n    def play(self):\n        while not self.game_over:\n            self.display()\n            try:\n                x, y = map(int, input(\"Enter coordinates (x y): \").split())\n                if 0 <= x < self.width and 0 <= y < self.height:\n                    self.reveal(x, y)\n                else:\n                    print(\"Coordinates out of bounds.\")\n            except ValueError:\n                print(\"Invalid input. Please enter two integers.\")\n\nif __name__ == \"__main__\":\n    width = 10\n    height = 10\n    mines = 10\n    game = Minesweeper(width, height, mines)\n    game.play()\n```",
    "5": "```python\nimport random\n\nclass Mastermind:\n    def __init__(self, code_length=4, possible_colors=6, max_attempts=10):\n        self.code_length = code_length\n        self.possible_colors = possible_colors\n        self.max_attempts = max_attempts\n        self.secret_code = self.generate_code()\n        self.attempts = 0\n\n    def generate_code(self):\n        return [random.randint(1, self.possible_colors) for _ in range(self.code_length)]\n\n    def get_feedback(self, guess):\n        correct_position = sum([1 for i in range(self.code_length) if guess[i] == self.secret_code[i]])\n        correct_color = sum(min(guess.count(color), self.secret_code.count(color)) for color in set(guess))\n        return correct_position, correct_color - correct_position\n\n    def play(self):\n        print(\"Welcome to Mastermind!\")\n        print(f\"Guess the secret code of length {self.code_length} using {self.possible_colors} colors.\")\n        print(\"You have a maximum of 10 attempts.\")\n\n        while self.attempts < self.max_attempts:\n            guess = input(f\"Attempt {self.attempts + 1}: Enter your guess (space-separated numbers 1-{self.possible_colors}): \")\n            guess = list(map(int, guess.split()))\n\n            if len(guess) != self.code_length:\n                print(f\"Please enter exactly {self.code_length} numbers.\")\n                continue\n\n            self.attempts += 1\n            correct_position, correct_color = self.get_feedback(guess)\n\n            if correct_position == self.code_length:\n                print(f\"Congratulations! You've guessed the code: {self.secret_code}\")\n                break\n            else:\n                print(f\"Correct position: {correct_position}, Correct color (wrong position): {correct_color}\")\n\n        if self.attempts == self.max_attempts:\n            print(f\"Sorry, you've used all attempts. The secret code was: {self.secret_code}\")\n\nif __name__ == \"__main__\":\n    game = Mastermind()\n    game.play()\n```",
    "6": "```python\nimport random\n\nclass Battleship:\n    def __init__(self, size=5, ships=3):\n        self.size = size\n        self.ships = ships\n        self.board = [['~' for _ in range(size)] for _ in range(size)]\n        self.ship_positions = set()\n        self.hits = 0\n        self.place_ships()\n\n    def place_ships(self):\n        while len(self.ship_positions) < self.ships:\n            x, y = random.randint(0, self.size - 1), random.randint(0, self.size - 1)\n            self.ship_positions.add((x, y))\n\n    def print_board(self):\n        print(\"  \" + \" \".join(str(i) for i in range(self.size)))\n        for idx, row in enumerate(self.board):\n            print(str(idx) + \" \" + \" \".join(row))\n\n    def take_turn(self, x, y):\n        if (x, y) in self.ship_positions:\n            self.board[x][y] = 'X'\n            self.ship_positions.remove((x, y))\n            self.hits += 1\n            print(\"Hit!\")\n        else:\n            self.board[x][y] = 'O'\n            print(\"Miss!\")\n\n    def is_game_over(self):\n        return self.hits == self.ships\n\n    def play(self):\n        print(\"Welcome to Battleship!\")\n        while not self.is_game_over():\n            self.print_board()\n            try:\n                x, y = map(int, input(\"Enter coordinates (row and column) to attack: \").split())\n                if 0 <= x < self.size and 0 <= y < self.size:\n                    self.take_turn(x, y)\n                else:\n                    print(\"Coordinates out of bounds. Try again.\")\n            except ValueError:\n                print(\"Invalid input. Please enter two numbers separated by a space.\")\n        print(\"Congratulations! You've sunk all the ships.\")\n\nif __name__ == \"__main__\":\n    game = Battleship(size=5, ships=3)\n    game.play()\n```",
    "7": "```python\nimport numpy as np\nimport os\nimport time\n\nclass GameOfLife:\n    def __init__(self, width=20, height=20):\n        self.width = width\n        self.height = height\n        self.board = np.zeros((height, width), dtype=int)\n\n    def initialize(self, live_cells):\n        for cell in live_cells:\n            self.board[cell[0], cell[1]] = 1\n\n    def display(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for row in self.board:\n            print(' '.join(['#' if cell else '.' for cell in row]))\n        print(\"\\n\")\n\n    def update(self):\n        new_board = self.board.copy()\n        for y in range(self.height):\n            for x in range(self.width):\n                live_neighbors = self.count_live_neighbors(x, y)\n                if self.board[y, x] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_board[y, x] = 0\n                else:\n                    if live_neighbors == 3:\n                        new_board[y, x] = 1\n        self.board = new_board\n\n    def count_live_neighbors(self, x, y):\n        neighbors = [\n            (-1, -1), (-1, 0), (-1, 1),\n            (0, -1),          (0, 1),\n            (1, -1), (1, 0), (1, 1)\n        ]\n        count = 0\n        for dx, dy in neighbors:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < self.width and 0 <= ny < self.height:\n                count += self.board[ny, nx]\n        return count\n\n    def run(self, generations=10, delay=0.5):\n        for _ in range(generations):\n            self.display()\n            self.update()\n            time.sleep(delay)\n\nif __name__ == \"__main__\":\n    game = GameOfLife(20, 20)\n    initial_live_cells = [(1, 1), (1, 2), (1, 3), (2, 1), (3, 2)]\n    game.initialize(initial_live_cells)\n    game.run(generations=50, delay=0.5)\n```",
    "8": "```python\nclass ConnectFour:\n    def __init__(self):\n        self.rows = 6\n        self.columns = 7\n        self.board = [[' ' for _ in range(self.columns)] for _ in range(self.rows)]\n        self.current_player = 'X'\n\n    def print_board(self):\n        for row in self.board:\n            print('|' + '|'.join(row) + '|')\n        print(' ' + '-'.join(['-' for _ in range(self.columns)]))\n\n    def drop_piece(self, column):\n        for row in reversed(range(self.rows)):\n            if self.board[row][column] == ' ':\n                self.board[row][column] = self.current_player\n                return row\n        return -1\n\n    def check_winner(self, row, column):\n        # Check horizontal\n        for c in range(max(0, column - 3), min(self.columns, column + 4)):\n            if all(self.board[row][c + i] == self.current_player for i in range(4) if 0 <= c + i < self.columns):\n                return True\n\n        # Check vertical\n        if row <= self.rows - 4:\n            if all(self.board[row + i][column] == self.current_player for i in range(4)):\n                return True\n\n        # Check diagonal (bottom-left to top-right)\n        for d in range(-3, 1):\n            if 0 <= row + d < self.rows and 0 <= column + d < self.columns and \\\n               all(self.board[row + d + i][column + d + i] == self.current_player for i in range(4) if 0 <= row + d + i < self.rows and 0 <= column + d + i < self.columns):\n                return True\n\n        # Check diagonal (top-left to bottom-right)\n        for d in range(-3, 1):\n            if 0 <= row - d < self.rows and 0 <= column + d < self.columns and \\\n               all(self.board[row - d + i][column + d + i] == self.current_player for i in range(4) if 0 <= row - d + i < self.rows and 0 <= column + d + i < self.columns):\n                return True\n\n        return False\n\n    def play(self):\n        while True:\n            self.print_board()\n            try:\n                column = int(input(f\"Player {self.current_player}, choose a column (0-{self.columns - 1}): \"))\n                if column < 0 or column >= self.columns:\n                    print(\"Invalid column. Try again.\")\n                    continue\n                \n                row = self.drop_piece(column)\n                if row == -1:\n                    print(\"Column is full. Try again.\")\n                    continue\n                \n                if self.check_winner(row, column):\n                    self.print_board()\n                    print(f\"Player {self.current_player} wins!\")\n                    break\n                \n                self.current_player = 'O' if self.current_player == 'X' else 'X'\n\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\nif __name__ == \"__main__\":\n    game = ConnectFour()\n    game.play()\n```",
    "9": "```python\nimport random\n\nclass Card:\n    def __init__(self, suit, rank):\n        self.suit = suit\n        self.rank = rank\n\n    def value(self):\n        if self.rank in ['Jack', 'Queen', 'King']:\n            return 10\n        elif self.rank == 'Ace':\n            return 11\n        else:\n            return int(self.rank)\n\n    def __str__(self):\n        return f\"{self.rank} of {self.suit}\"\n\nclass Deck:\n    def __init__(self):\n        self.cards = [Card(suit, rank) for suit in ['Hearts', 'Diamonds', 'Clubs', 'Spades']\n                      for rank in ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace']]\n        random.shuffle(self.cards)\n\n    def deal(self):\n        return self.cards.pop()\n\nclass Hand:\n    def __init__(self):\n        self.cards = []\n\n    def add_card(self, card):\n        self.cards.append(card)\n\n    def value(self):\n        total = sum(card.value() for card in self.cards)\n        aces = sum(1 for card in self.cards if card.rank == 'Ace')\n        while total > 21 and aces:\n            total -= 10\n            aces -= 1\n        return total\n\n    def __str__(self):\n        return ', '.join(str(card) for card in self.cards)\n\nclass BlackjackGame:\n    def __init__(self):\n        self.deck = Deck()\n        self.player_hand = Hand()\n        self.dealer_hand = Hand()\n\n    def start_game(self):\n        print(\"Welcome to Blackjack!\")\n        self.player_hand.add_card(self.deck.deal())\n        self.player_hand.add_card(self.deck.deal())\n        self.dealer_hand.add_card(self.deck.deal())\n        self.dealer_hand.add_card(self.deck.deal())\n        self.player_turn()\n\n    def player_turn(self):\n        while True:\n            print(f\"\\nYour hand: {self.player_hand} (Value: {self.player_hand.value()})\")\n            print(f\"Dealer's hand: {self.dealer_hand.cards[0]} and [Hidden]\")\n            if self.player_hand.value() > 21:\n                print(\"You bust! Dealer wins.\")\n                return\n            action = input(\"Would you like to (H)it or (S)tand? \").strip().lower()\n            if action == 'h':\n                self.player_hand.add_card(self.deck.deal())\n            elif action == 's':\n                break\n\n        self.dealer_turn()\n\n    def dealer_turn(self):\n        print(f\"\\nDealer's hand: {self.dealer_hand} (Value: {self.dealer_hand.value()})\")\n        while self.dealer_hand.value() < 17:\n            self.dealer_hand.add_card(self.deck.deal())\n            print(f\"Dealer hits: {self.dealer_hand} (Value: {self.dealer_hand.value()})\")\n        \n        self.determine_winner()\n\n    def determine_winner(self):\n        player_value = self.player_hand.value()\n        dealer_value = self.dealer_hand.value()\n        print(f\"\\nFinal Player Hand: {self.player_hand} (Value: {player_value})\")\n        print(f\"Final Dealer Hand: {self.dealer_hand} (Value: {dealer_value})\")\n        \n        if dealer_value > 21 or player_value > dealer_value:\n            print(\"You win!\")\n        elif player_value < dealer_value:\n            print(\"Dealer wins!\")\n        else:\n            print(\"It's a tie!\")\n\nif __name__ == \"__main__\":\n    game = BlackjackGame()\n    game.start_game()\n```",
    "10": "```python\nimport random\n\nclass Hammurabi:\n    def __init__(self):\n        self.year = 1\n        self.population = 100\n        self.bushels = 2800\n        self.land = 100\n        self.plague = False\n        self.famine = False\n\n    def display_status(self):\n        print(f\"Year: {self.year}\")\n        print(f\"Population: {self.population}\")\n        print(f\"Bushels: {self.bushels}\")\n        print(f\"Land: {self.land} acres\")\n        print()\n\n    def simulate_year(self):\n        self.year += 1\n        self.check_events()\n        self.harvest()\n        self.check_population()\n\n    def check_events(self):\n        event = random.choice(['none', 'plague', 'famine'])\n        if event == 'plague':\n            self.plague = True\n            self.population -= self.population // 2\n            print(\"A plague has struck! Half of the population has died.\")\n        elif event == 'famine':\n            self.famine = True\n            print(\"There is a famine this year!\")\n\n    def harvest(self):\n        if self.famine:\n            self.bushels -= self.population // 2\n            self.famine = False\n        bushels_per_acre = random.randint(1, 6)  # Random yield between 1 and 6\n        self.bushels += bushels_per_acre * self.land\n        print(f\"Harvested {bushels_per_acre * self.land} bushels.\")\n\n    def check_population(self):\n        if self.bushels < self.population:\n            print(\"Not enough food! The population is starving!\")\n            self.population -= self.population // 4\n\n    def buy_land(self, acres):\n        if self.bushels >= acres * 20:\n            self.land += acres\n            self.bushels -= acres * 20\n            print(f\"Bought {acres} acres of land.\")\n        else:\n            print(\"Not enough bushels to buy land.\")\n\n    def sell_land(self, acres):\n        if self.land >= acres:\n            self.land -= acres\n            self.bushels += acres * 10\n            print(f\"Sold {acres} acres of land.\")\n        else:\n            print(\"Not enough land to sell.\")\n\n    def feed_people(self, bushels):\n        if self.bushels >= bushels:\n            self.bushels -= bushels\n            print(f\"Fed the people {bushels} bushels.\")\n        else:\n            print(\"Not enough bushels to feed the people.\")\n\n    def main(self):\n        while self.year <= 10 and self.population > 0:\n            self.display_status()\n            print(\"Choose an action:\")\n            print(\"1. Buy land\")\n            print(\"2. Sell land\")\n            print(\"3. Feed people\")\n            action = input(\"Enter action number: \")\n\n            if action == '1':\n                acres = int(input(\"Enter acres to buy: \"))\n                self.buy_land(acres)\n            elif action == '2':\n                acres = int(input(\"Enter acres to sell: \"))\n                self.sell_land(acres)\n            elif action == '3':\n                bushels = int(input(\"Enter bushels to feed the people: \"))\n                self.feed_people(bushels)\n            else:\n                print(\"Invalid action.\")\n\n            self.simulate_year()\n\n        print(\"Game over!\")\n        print(f\"You survived for {self.year - 1} years.\")\n\nif __name__ == \"__main__\":\n    game = Hammurabi()\n    game.main()\n```",
    "11": "```python\nimport random\n\nclass LightsOut:\n    def __init__(self, size=5):\n        self.size = size\n        self.grid = [[random.choice([0, 1]) for _ in range(size)] for _ in range(size)]\n\n    def display(self):\n        for row in self.grid:\n            print(' '.join(['*' if cell else ' ' for cell in row]))\n        print()\n\n    def toggle(self, x, y):\n        self.grid[x][y] ^= 1  # Toggle the selected light\n        # Toggle adjacent lights\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < self.size and 0 <= ny < self.size:\n                self.grid[nx][ny] ^= 1\n\n    def is_solved(self):\n        return all(cell == 0 for row in self.grid for cell in row)\n\n    def play(self):\n        print(\"Welcome to Lights Out!\")\n        while not self.is_solved():\n            self.display()\n            try:\n                x, y = map(int, input(\"Enter coordinates to toggle (row col): \").split())\n                if 0 <= x < self.size and 0 <= y < self.size:\n                    self.toggle(x, y)\n                else:\n                    print(\"Coordinates out of bounds. Try again.\")\n            except ValueError:\n                print(\"Invalid input. Please enter row and column as two integers.\")\n\n        print(\"Congratulations! You've turned off all the lights!\")\n\nif __name__ == \"__main__\":\n    game = LightsOut()\n    game.play()\n```",
    "12": "```python\nimport os\nimport sys\nimport time\nimport random\nimport threading\n\nclass Pong:\n    def __init__(self, width=40, height=20):\n        self.width = width\n        self.height = height\n        self.ball_x = width // 2\n        self.ball_y = height // 2\n        self.ball_dx = random.choice([-1, 1])\n        self.ball_dy = random.choice([-1, 1])\n        self.paddle_left_y = height // 2\n        self.paddle_right_y = height // 2\n        self.score_left = 0\n        self.score_right = 0\n        self.running = True\n\n    def draw(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for y in range(self.height):\n            for x in range(self.width):\n                if x == 0 and y in range(self.paddle_left_y - 1, self.paddle_left_y + 2):\n                    print('|', end='')\n                elif x == self.width - 1 and y in range(self.paddle_right_y - 1, self.paddle_right_y + 2):\n                    print('|', end='')\n                elif x == self.ball_x and y == self.ball_y:\n                    print('O', end='')\n                else:\n                    print(' ', end='')\n            print()\n        print(f'Score: Left {self.score_left} - Right {self.score_right}')\n\n    def update_ball(self):\n        if self.ball_x <= 1:\n            self.score_right += 1\n            self.reset_ball()\n        elif self.ball_x >= self.width - 2:\n            self.score_left += 1\n            self.reset_ball()\n        elif self.ball_y <= 0 or self.ball_y >= self.height - 1:\n            self.ball_dy *= -1\n\n        if self.ball_x == 1 and self.paddle_left_y - 1 <= self.ball_y <= self.paddle_left_y + 1:\n            self.ball_dx *= -1\n        elif self.ball_x == self.width - 2 and self.paddle_right_y - 1 <= self.ball_y <= self.paddle_right_y + 1:\n            self.ball_dx *= -1\n\n        self.ball_x += self.ball_dx\n        self.ball_y += self.ball_dy\n\n    def reset_ball(self):\n        self.ball_x = self.width // 2\n        self.ball_y = self.height // 2\n        self.ball_dx = random.choice([-1, 1])\n        self.ball_dy = random.choice([-1, 1])\n\n    def move_paddle(self, direction, side):\n        if side == 'left':\n            if direction == 'up' and self.paddle_left_y > 1:\n                self.paddle_left_y -= 1\n            elif direction == 'down' and self.paddle_left_y < self.height - 2:\n                self.paddle_left_y += 1\n        elif side == 'right':\n            if direction == 'up' and self.paddle_right_y > 1:\n                self.paddle_right_y -= 1\n            elif direction == 'down' and self.paddle_right_y < self.height - 2:\n                self.paddle_right_y += 1\n\n    def play(self):\n        def input_thread():\n            while self.running:\n                command = input()\n                if command == 'w':\n                    self.move_paddle('up', 'left')\n                elif command == 's':\n                    self.move_paddle('down', 'left')\n                elif command == 'i':\n                    self.move_paddle('up', 'right')\n                elif command == 'k':\n                    self.move_paddle('down', 'right')\n\n        threading.Thread(target=input_thread, daemon=True).start()\n\n        while self.running:\n            self.update_ball()\n            self.draw()\n            time.sleep(0.1)\n\nif __name__ == \"__main__\":\n    game = Pong()\n    game.play()\n```",
    "13": "```python\nimport random\nimport os\nimport sys\nimport time\nimport keyboard\n\nclass Tetris:\n    def __init__(self, width=10, height=20):\n        self.width = width\n        self.height = height\n        self.board = [[' ' for _ in range(width)] for _ in range(height)]\n        self.shapes = [\n            [['#', '#', '#', '#']],  # I\n            [['#', '#', '#'], [' ', '#', ' ']],  # T\n            [['#', '#', ' '], [' ', '#', '#']],  # Z\n            [[' ', '#', '#'], ['#', '#', ' ']],  # S\n            [['#', '#'], ['#', '#']],  # O\n            [['#', '#', '#'], ['#', ' ', ' ']],  # L\n            [['#', '#', '#'], [' ', ' ', '#']],  # J\n        ]\n        self.current_shape = None\n        self.current_position = (0, 0)\n        self.score = 0\n        self.game_over = False\n\n    def new_shape(self):\n        self.current_shape = random.choice(self.shapes)\n        self.current_position = (0, self.width // 2 - len(self.current_shape[0]) // 2)\n\n    def rotate_shape(self):\n        self.current_shape = [list(row) for row in zip(*self.current_shape[::-1])]\n\n    def check_collision(self, offset_x=0, offset_y=0):\n        for i, row in enumerate(self.current_shape):\n            for j, cell in enumerate(row):\n                if cell != ' ':\n                    x = self.current_position[0] + i + offset_x\n                    y = self.current_position[1] + j + offset_y\n                    if x < 0 or x >= self.height or y < 0 or y >= self.width or (x >= 0 and self.board[x][y] != ' '):\n                        return True\n        return False\n\n    def place_shape(self):\n        for i, row in enumerate(self.current_shape):\n            for j, cell in enumerate(row):\n                if cell != ' ':\n                    x = self.current_position[0] + i\n                    y = self.current_position[1] + j\n                    if x >= 0:\n                        self.board[x][y] = '#'\n        self.clear_lines()\n\n    def clear_lines(self):\n        new_board = [row for row in self.board if any(cell == ' ' for cell in row)]\n        cleared_lines = self.height - len(new_board)\n        self.score += cleared_lines\n        new_board = [[' ' for _ in range(self.width)] for _ in range(cleared_lines)] + new_board\n        self.board = new_board\n\n    def drop_shape(self):\n        if not self.check_collision(offset_x=1):\n            self.current_position = (self.current_position[0] + 1, self.current_position[1])\n        else:\n            self.place_shape()\n            if self.current_position[0] < 0:\n                self.game_over = True\n            self.new_shape()\n\n    def move_shape(self, dx):\n        if not self.check_collision(offset_y=dx):\n            self.current_position = (self.current_position[0], self.current_position[1] + dx)\n\n    def print_board(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for row in self.board:\n            print('|' + ''.join(row) + '|')\n        print('-' * (self.width + 2))\n        print(f'Score: {self.score}')\n\n    def play(self):\n        self.new_shape()\n        while not self.game_over:\n            self.print_board()\n            self.drop_shape()\n            time.sleep(0.5)\n            if keyboard.is_pressed('left'):\n                self.move_shape(-1)\n            elif keyboard.is_pressed('right'):\n                self.move_shape(1)\n            elif keyboard.is_pressed('down'):\n                self.drop_shape()\n            elif keyboard.is_pressed('up'):\n                self.rotate_shape()\n\n        print(\"Game Over! Final Score:\", self.score)\n\nif __name__ == \"__main__\":\n    game = Tetris()\n    game.play()\n```\n",
    "14": "```python\nimport random\nimport os\nimport sys\nimport time\nimport threading\n\nclass AsteroidGame:\n    def __init__(self, width=40, height=20, num_asteroids=5):\n        self.width = width\n        self.height = height\n        self.num_asteroids = num_asteroids\n        self.player_pos = [self.width // 2, self.height - 1]\n        self.asteroids = self.generate_asteroids()\n        self.score = 0\n        self.game_over = False\n\n    def generate_asteroids(self):\n        return [[random.randint(0, self.width - 1), 0] for _ in range(self.num_asteroids)]\n\n    def display(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for y in range(self.height):\n            for x in range(self.width):\n                if [x, y] == self.player_pos:\n                    print('^', end='')\n                elif [x, y] in self.asteroids:\n                    print('O', end='')\n                else:\n                    print(' ', end='')\n            print()\n        print(f'Score: {self.score}')\n\n    def move_player(self, direction):\n        if direction == 'left' and self.player_pos[0] > 0:\n            self.player_pos[0] -= 1\n        elif direction == 'right' and self.player_pos[0] < self.width - 1:\n            self.player_pos[0] += 1\n\n    def update_asteroids(self):\n        new_asteroids = []\n        for asteroid in self.asteroids:\n            asteroid[1] += 1\n            if asteroid[1] < self.height:\n                new_asteroids.append(asteroid)\n            else:\n                self.score += 1  # Player dodged an asteroid\n        self.asteroids = new_asteroids\n        if any(asteroid == self.player_pos for asteroid in self.asteroids):\n            self.game_over = True\n\n    def run(self):\n        def input_thread():\n            while not self.game_over:\n                command = input()\n                if command == 'a':\n                    self.move_player('left')\n                elif command == 'd':\n                    self.move_player('right')\n\n        threading.Thread(target=input_thread, daemon=True).start()\n\n        while not self.game_over:\n            self.display()\n            self.update_asteroids()\n            time.sleep(0.2)\n\n        print(\"Game Over! Your score was:\", self.score)\n\nif __name__ == \"__main__\":\n    game = AsteroidGame()\n    game.run()\n```\n\n### Instructions to Run:\n1. Save the code in a file named `asteroid_game.py`.\n2. Run the script using Python 3: `python asteroid_game.py`.\n3. Control the player using 'a' (left) and 'd' (right) keys.",
    "15": "```python\nimport random\nimport string\n\nclass Boggle:\n    def __init__(self, size=4, word_list=None):\n        self.size = size\n        self.board = self.generate_board()\n        self.word_list = word_list if word_list else set()\n        self.found_words = set()\n\n    def generate_board(self):\n        letters = string.ascii_uppercase\n        return [[random.choice(letters) for _ in range(self.size)] for _ in range(self.size)]\n\n    def display_board(self):\n        for row in self.board:\n            print(\" \".join(row))\n        print()\n\n    def load_words(self, file_path):\n        with open(file_path, 'r') as file:\n            self.word_list = set(word.strip().upper() for word in file)\n\n    def is_valid_word(self, word):\n        return word in self.word_list\n\n    def search_word(self, word):\n        visited = [[False] * self.size for _ in range(self.size)]\n        for i in range(self.size):\n            for j in range(self.size):\n                if self._search_recursive(word, i, j, 0, visited):\n                    return True\n        return False\n\n    def _search_recursive(self, word, x, y, index, visited):\n        if index == len(word):\n            return True\n        if x < 0 or y < 0 or x >= self.size or y >= self.size or visited[x][y]:\n            return False\n        if self.board[x][y] != word[index]:\n            return False\n\n        visited[x][y] = True\n        found = (self._search_recursive(word, x-1, y, index+1, visited) or\n                 self._search_recursive(word, x+1, y, index+1, visited) or\n                 self._search_recursive(word, x, y-1, index+1, visited) or\n                 self._search_recursive(word, x, y+1, index+1, visited) or\n                 self._search_recursive(word, x-1, y-1, index+1, visited) or\n                 self._search_recursive(word, x-1, y+1, index+1, visited) or\n                 self._search_recursive(word, x+1, y-1, index+1, visited) or\n                 self._search_recursive(word, x+1, y+1, index+1, visited))\n\n        visited[x][y] = False\n        return found\n\n    def play(self):\n        print(\"Welcome to Boggle!\")\n        self.display_board()\n        print(\"Enter words you find (type 'exit' to finish):\")\n\n        while True:\n            word = input(\"> \").strip().upper()\n            if word == 'EXIT':\n                break\n            if self.is_valid_word(word):\n                if word not in self.found_words and self.search_word(word):\n                    self.found_words.add(word)\n                    print(f\"Good job! '{word}' is a valid word!\")\n                else:\n                    print(f\"'{word}' is not found on the board or already used.\")\n            else:\n                print(f\"'{word}' is not a valid word.\")\n\n        print(\"Game Over! You found the following words:\")\n        print(\", \".join(sorted(self.found_words)))\n\n\nif __name__ == \"__main__\":\n    game = Boggle()\n    game.load_words(\"words.txt\")  # Provide a path to a file with valid words\n    game.play()\n```\n\nMake sure to create a `words.txt` file containing a list of valid words, one per line, in the same directory as this script for the game to function correctly.",
    "16": "```python\nimport random\nimport os\nimport time\nimport keyboard\n\nclass PacManGame:\n    def __init__(self, width=10, height=10):\n        self.width = width\n        self.height = height\n        self.pacman_pos = [1, 1]\n        self.food_pos = [random.randint(0, height - 1), random.randint(0, width - 1)]\n        self.score = 0\n        self.game_over = False\n        self.direction = 'RIGHT'\n        self.board = self.create_board()\n\n    def create_board(self):\n        return [[' ' for _ in range(self.width)] for _ in range(self.height)]\n\n    def update_board(self):\n        self.board = self.create_board()\n        self.board[self.pacman_pos[0]][self.pacman_pos[1]] = 'P'\n        self.board[self.food_pos[0]][self.food_pos[1]] = 'F'\n\n    def display_board(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for row in self.board:\n            print('|' + ''.join(row) + '|')\n        print(f'Score: {self.score}')\n\n    def move(self):\n        if self.direction == 'UP':\n            self.pacman_pos[0] -= 1\n        elif self.direction == 'DOWN':\n            self.pacman_pos[0] += 1\n        elif self.direction == 'LEFT':\n            self.pacman_pos[1] -= 1\n        elif self.direction == 'RIGHT':\n            self.pacman_pos[1] += 1\n\n        # Check for boundaries\n        self.pacman_pos[0] = max(0, min(self.height - 1, self.pacman_pos[0]))\n        self.pacman_pos[1] = max(0, min(self.width - 1, self.pacman_pos[1]))\n\n        # Check for food\n        if self.pacman_pos == self.food_pos:\n            self.score += 1\n            self.food_pos = [random.randint(0, self.height - 1), random.randint(0, self.width - 1)]\n\n    def change_direction(self, new_direction):\n        self.direction = new_direction\n\n    def run(self):\n        print(\"Control Pac-Man with WASD (W=Up, A=Left, S=Down, D=Right). Press Q to quit.\")\n        while not self.game_over:\n            self.update_board()\n            self.display_board()\n            self.move()\n            if keyboard.is_pressed('w'):\n                self.change_direction('UP')\n            elif keyboard.is_pressed('s'):\n                self.change_direction('DOWN')\n            elif keyboard.is_pressed('a'):\n                self.change_direction('LEFT')\n            elif keyboard.is_pressed('d'):\n                self.change_direction('RIGHT')\n            elif keyboard.is_pressed('q'):\n                self.game_over = True\n\n            time.sleep(0.1)\n\nif __name__ == \"__main__\":\n    game = PacManGame()\n    game.run()\n```\n",
    "17": "```python\nimport random\nimport time\nimport sys\nimport threading\n\nclass DinosaurRunner:\n    def __init__(self):\n        self.game_over = False\n        self.score = 0\n        self.dino_pos = 0\n        self.obstacles = []\n        self.is_jumping = False\n        self.jump_height = 3\n        self.gravity = 1\n        self.jump_count = 0\n        self.obstacle_timer = threading.Timer(1, self.spawn_obstacle)\n\n    def spawn_obstacle(self):\n        if not self.game_over:\n            self.obstacles.append(random.randint(5, 10))  # Random height for the obstacle\n            self.obstacle_timer = threading.Timer(1, self.spawn_obstacle)\n            self.obstacle_timer.start()\n\n    def jump(self):\n        if not self.is_jumping:\n            self.is_jumping = True\n            self.jump_count = self.jump_height\n            print(\"Jump!\")\n\n    def update(self):\n        if self.is_jumping:\n            if self.jump_count >= 0:\n                print(f\"Dino at height: {self.jump_count}\")\n                self.jump_count -= self.gravity\n            else:\n                self.is_jumping = False\n                print(\"Dino falls back down.\")\n\n        for obstacle in self.obstacles:\n            if obstacle <= self.dino_pos:\n                print(f\"Obstacle at height {obstacle}!\")\n                if self.is_jumping and self.jump_height > obstacle:\n                    print(\"Jumped over the obstacle!\")\n                    self.score += 1\n                else:\n                    self.game_over = True\n                    print(\"Game Over!\")\n                    self.obstacle_timer.cancel()\n\n    def play(self):\n        print(\"Starting Dinosaur Runner... Press 'j' to jump.\")\n        self.spawn_obstacle()\n        while not self.game_over:\n            command = input()\n            if command == 'j':\n                self.jump()\n            self.update()\n            time.sleep(0.5)\n        print(f\"Final Score: {self.score}\")\n\nif __name__ == \"__main__\":\n    game = DinosaurRunner()\n    game.play()\n```"
}