{
    "0": "```python\nclass TicTacToe:\n    def __init__(self):\n        self.board = [' ' for _ in range(9)]  # A list to hold the board state\n        self.current_player = 'X'  # Starting player\n\n    def display_board(self):\n        print(\"Current board:\")\n        for i in range(3):\n            print(f\"{self.board[i * 3]} | {self.board[i * 3 + 1]} | {self.board[i * 3 + 2]}\")\n            if i < 2:\n                print(\"---------\")\n\n    def player_move(self):\n        valid_move = False\n        while not valid_move:\n            try:\n                move = int(input(f\"Player {self.current_player}, enter your move (1-9): \")) - 1\n                if 0 <= move < 9 and self.board[move] == ' ':\n                    self.board[move] = self.current_player\n                    valid_move = True\n                else:\n                    print(\"Invalid move. Try again.\")\n            except ValueError:\n                print(\"Please enter a number between 1 and 9.\")\n\n    def check_winner(self):\n        winning_combinations = [\n            (0, 1, 2), (3, 4, 5), (6, 7, 8),  # horizontal\n            (0, 3, 6), (1, 4, 7), (2, 5, 8),  # vertical\n            (0, 4, 8), (2, 4, 6)              # diagonal\n        ]\n        for combo in winning_combinations:\n            if self.board[combo[0]] == self.board[combo[1]] == self.board[combo[2]] != ' ':\n                return self.board[combo[0]]\n        return None\n\n    def is_board_full(self):\n        return ' ' not in self.board\n\n    def switch_player(self):\n        self.current_player = 'O' if self.current_player == 'X' else 'X'\n\n    def play_game(self):\n        while True:\n            self.display_board()\n            self.player_move()\n            winner = self.check_winner()\n            if winner:\n                self.display_board()\n                print(f\"Player {winner} wins!\")\n                break\n            if self.is_board_full():\n                self.display_board()\n                print(\"It's a tie!\")\n                break\n            self.switch_player()\n\n\nif __name__ == \"__main__\":\n    game = TicTacToe()\n    game.play_game()\n```",
    "1": "```python\nimport random\n\nclass Hangman:\n    def __init__(self, word_list):\n        self.word_list = word_list\n        self.word = \"\"\n        self.guesses = []\n        self.max_attempts = 6\n        self.attempts = 0\n        self.is_won = False\n\n    def choose_word(self):\n        self.word = random.choice(self.word_list).upper()\n\n    def display_word(self):\n        display = ''.join([letter if letter in self.guesses else '_' for letter in self.word])\n        return display\n\n    def guess_letter(self, letter):\n        if letter in self.guesses:\n            return \"You already guessed that letter.\"\n        self.guesses.append(letter)\n        if letter not in self.word:\n            self.attempts += 1\n            return \"Incorrect guess.\"\n        if all(letter in self.guesses for letter in self.word):\n            self.is_won = True\n            return \"Congratulations! You've guessed the word!\"\n        return \"Good guess!\"\n\n    def is_game_over(self):\n        return self.attempts >= self.max_attempts or self.is_won\n\n    def play(self):\n        self.choose_word()\n        print(\"Welcome to Hangman!\")\n        \n        while not self.is_game_over():\n            print(f\"Word: {self.display_word()}\")\n            print(f\"Attempts left: {self.max_attempts - self.attempts}\")\n            guess = input(\"Guess a letter: \").upper()\n            \n            if len(guess) != 1 or not guess.isalpha():\n                print(\"Please enter a single valid letter.\")\n                continue\n\n            result = self.guess_letter(guess)\n            print(result)\n\n        if not self.is_won:\n            print(f\"You've run out of attempts! The word was: {self.word}\")\n\nif __name__ == \"__main__\":\n    words = [\"python\", \"hangman\", \"challenge\", \"programming\", \"developer\"]\n    game = Hangman(words)\n    game.play()\n```",
    "2": "```python\nimport random\n\nclass RockPaperScissors:\n    def __init__(self):\n        self.choices = ['rock', 'paper', 'scissors']\n        self.score = {'player': 0, 'computer': 0}\n\n    def get_player_choice(self):\n        choice = input(\"Enter rock, paper, or scissors (or 'quit' to exit): \").lower()\n        while choice not in self.choices and choice != 'quit':\n            print(\"Invalid choice. Please try again.\")\n            choice = input(\"Enter rock, paper, or scissors (or 'quit' to exit): \").lower()\n        return choice\n\n    def get_computer_choice(self):\n        return random.choice(self.choices)\n\n    def determine_winner(self, player_choice, computer_choice):\n        if player_choice == computer_choice:\n            return 'tie'\n        elif (player_choice == 'rock' and computer_choice == 'scissors') or \\\n             (player_choice == 'paper' and computer_choice == 'rock') or \\\n             (player_choice == 'scissors' and computer_choice == 'paper'):\n            return 'player'\n        else:\n            return 'computer'\n\n    def play(self):\n        print(\"Welcome to Rock-Paper-Scissors!\")\n        while True:\n            player_choice = self.get_player_choice()\n            if player_choice == 'quit':\n                print(\"Thanks for playing!\")\n                break\n            \n            computer_choice = self.get_computer_choice()\n            print(f\"Computer chose: {computer_choice}\")\n\n            winner = self.determine_winner(player_choice, computer_choice)\n            if winner == 'tie':\n                print(\"It's a tie!\")\n            elif winner == 'player':\n                print(\"You win!\")\n                self.score['player'] += 1\n            else:\n                print(\"Computer wins!\")\n                self.score['computer'] += 1\n            \n            print(f\"Score: Player {self.score['player']} - Computer {self.score['computer']}\")\n\nif __name__ == \"__main__\":\n    game = RockPaperScissors()\n    game.play()\n```",
    "3": "```python\nimport random\nimport curses\n\nclass SnakeGame:\n    def __init__(self, stdscr):\n        self.stdscr = stdscr\n        self.window_height = 20\n        self.window_width = 60\n        self.snake = [(self.window_height // 2, self.window_width // 4)]\n        self.snake_direction = (0, 1)  # Initially moving to the right\n        self.food = None\n        self.score = 0\n        self.game_over = False\n        self.setup()\n\n    def setup(self):\n        curses.curs_set(0)\n        self.stdscr.clear()\n        self.stdscr.nodelay(1)\n        self.stdscr.timeout(100)\n        self.place_food()\n        self.draw()\n\n    def place_food(self):\n        while True:\n            food = (random.randint(1, self.window_height - 2), random.randint(1, self.window_width - 2))\n            if food not in self.snake:\n                self.food = food\n                break\n\n    def draw(self):\n        self.stdscr.clear()\n        for y, x in self.snake:\n            self.stdscr.addch(y, x, curses.ACS_CKBOARD)\n        self.stdscr.addch(self.food[0], self.food[1], curses.ACS_PI)\n        self.stdscr.addstr(0, 2, f'Score: {self.score}')\n        self.stdscr.refresh()\n\n    def change_direction(self, key):\n        if key == curses.KEY_UP and self.snake_direction != (1, 0):\n            self.snake_direction = (-1, 0)\n        elif key == curses.KEY_DOWN and self.snake_direction != (-1, 0):\n            self.snake_direction = (1, 0)\n        elif key == curses.KEY_LEFT and self.snake_direction != (0, 1):\n            self.snake_direction = (0, -1)\n        elif key == curses.KEY_RIGHT and self.snake_direction != (0, -1):\n            self.snake_direction = (0, 1)\n\n    def move_snake(self):\n        head_y, head_x = self.snake[0]\n        new_head = (head_y + self.snake_direction[0], head_x + self.snake_direction[1])\n        \n        if (new_head[0] in [0, self.window_height] or\n                new_head[1] in [0, self.window_width] or\n                new_head in self.snake):\n            self.game_over = True\n            return\n        \n        self.snake.insert(0, new_head)\n\n        if new_head == self.food:\n            self.score += 1\n            self.place_food()\n        else:\n            self.snake.pop()\n\n    def play(self):\n        while not self.game_over:\n            key = self.stdscr.getch()\n            self.change_direction(key)\n            self.move_snake()\n            self.draw()\n\n        self.stdscr.addstr(self.window_height // 2, self.window_width // 2 - 5, \"Game Over!\")\n        self.stdscr.addstr(self.window_height // 2 + 1, self.window_width // 2 - 5, f'Final Score: {self.score}')\n        self.stdscr.refresh()\n        self.stdscr.getch()\n\ndef main():\n    curses.wrapper(SnakeGame)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "4": "```python\nimport random\n\nclass Minesweeper:\n    def __init__(self, width=10, height=10, mines=10):\n        self.width = width\n        self.height = height\n        self.mines = mines\n        self.board = [[' ' for _ in range(width)] for _ in range(height)]\n        self.visible = [[' ' for _ in range(width)] for _ in range(height)]\n        self.game_over = False\n        self.populate_mines()\n        self.calculate_numbers()\n\n    def populate_mines(self):\n        mine_positions = set()\n        while len(mine_positions) < self.mines:\n            pos = (random.randint(0, self.height - 1), random.randint(0, self.width - 1))\n            mine_positions.add(pos)\n        for (y, x) in mine_positions:\n            self.board[y][x] = '*'\n\n    def calculate_numbers(self):\n        for y in range(self.height):\n            for x in range(self.width):\n                if self.board[y][x] == '*':\n                    continue\n                count = sum((ny, nx) in self.board for ny in range(max(0, y - 1), min(self.height, y + 2))\n                             for nx in range(max(0, x - 1), min(self.width, x + 2)) if self.board[ny][nx] == '*')\n                if count > 0:\n                    self.board[y][x] = str(count)\n\n    def reveal(self, y, x):\n        if self.game_over or self.visible[y][x] != ' ':\n            return\n        self.visible[y][x] = self.board[y][x]\n        if self.board[y][x] == '*':\n            self.game_over = True\n            return\n        if self.board[y][x] == ' ':\n            for ny in range(max(0, y - 1), min(self.height, y + 2)):\n                for nx in range(max(0, x - 1), min(self.width, x + 2)):\n                    self.reveal(ny, nx)\n\n    def print_board(self):\n        print(\"   \" + \" \".join(str(x) for x in range(self.width)))\n        for y in range(self.height):\n            print(f\"{y} |\", end=\" \")\n            for x in range(self.width):\n                print(self.visible[y][x], end=\" \")\n            print()\n\n    def play(self):\n        while not self.game_over:\n            self.print_board()\n            try:\n                y, x = map(int, input(\"Enter row and column (y x): \").split())\n                if 0 <= y < self.height and 0 <= x < self.width:\n                    self.reveal(y, x)\n                else:\n                    print(\"Invalid coordinates. Try again.\")\n            except ValueError:\n                print(\"Invalid input. Please enter two numbers.\")\n\n        print(\"Game Over!\")\n        self.print_board()\n\n\nif __name__ == \"__main__\":\n    game = Minesweeper()\n    game.play()\n```",
    "5": "```python\nimport random\n\nclass Mastermind:\n    def __init__(self, code_length=4, num_colors=6, max_attempts=10):\n        self.code_length = code_length\n        self.num_colors = num_colors\n        self.max_attempts = max_attempts\n        self.code = self.generate_code()\n        self.attempts = 0\n\n    def generate_code(self):\n        return [random.randint(1, self.num_colors) for _ in range(self.code_length)]\n\n    def get_feedback(self, guess):\n        correct_position = sum(1 for i in range(self.code_length) if guess[i] == self.code[i])\n        correct_color = sum(min(guess.count(x), self.code.count(x)) for x in set(guess)) - correct_position\n        return correct_position, correct_color\n\n    def play(self):\n        print(\"Welcome to Mastermind!\")\n        print(f\"Guess the code consisting of {self.code_length} colors (1 to {self.num_colors}).\")\n        print(f\"You have {self.max_attempts} attempts.\")\n        \n        while self.attempts < self.max_attempts:\n            guess = input(f\"Attempt {self.attempts + 1}: Enter your guess (comma separated): \")\n            guess = list(map(int, guess.split(',')))\n\n            if len(guess) != self.code_length or any(g < 1 or g > self.num_colors for g in guess):\n                print(f\"Invalid guess. Please enter {self.code_length} numbers between 1 and {self.num_colors}.\")\n                continue\n\n            self.attempts += 1\n            correct_position, correct_color = self.get_feedback(guess)\n\n            if correct_position == self.code_length:\n                print(f\"Congratulations! You've guessed the code: {self.code}\")\n                break\n            else:\n                print(f\"Feedback: {correct_position} correct position(s), {correct_color} correct color(s).\")\n\n        if self.attempts == self.max_attempts:\n            print(f\"Sorry, you've run out of attempts. The code was: {self.code}\")\n\nif __name__ == \"__main__\":\n    game = Mastermind()\n    game.play()\n```",
    "6": "```python\nimport random\n\nclass Battleship:\n    def __init__(self, size=5, ships=3):\n        self.size = size\n        self.ships = ships\n        self.board = [['~' for _ in range(size)] for _ in range(size)]\n        self.ships_locations = []\n        self.hits = 0\n        self.place_ships()\n\n    def place_ships(self):\n        while len(self.ships_locations) < self.ships:\n            ship_location = (random.randint(0, self.size-1), random.randint(0, self.size-1))\n            if ship_location not in self.ships_locations:\n                self.ships_locations.append(ship_location)\n\n    def print_board(self):\n        print(\"  \" + \" \".join(str(i) for i in range(self.size)))\n        for i, row in enumerate(self.board):\n            print(str(i) + \" \" + \" \".join(row))\n\n    def make_guess(self, x, y):\n        if (x, y) in self.ships_locations:\n            self.board[x][y] = 'X'\n            self.ships_locations.remove((x, y))\n            self.hits += 1\n            print(\"Hit!\")\n            return True\n        elif self.board[x][y] == '~':\n            self.board[x][y] = 'O'\n            print(\"Miss!\")\n            return False\n        else:\n            print(\"You already guessed that!\")\n            return False\n\n    def is_game_over(self):\n        return self.hits == self.ships\n\n    def play(self):\n        print(\"Welcome to Battleship!\")\n        while not self.is_game_over():\n            self.print_board()\n            try:\n                x, y = map(int, input(\"Enter your guess (row and column): \").split())\n                if x < 0 or x >= self.size or y < 0 or y >= self.size:\n                    print(\"Out of bounds! Please try again.\")\n                    continue\n                self.make_guess(x, y)\n            except ValueError:\n                print(\"Invalid input! Please enter row and column as two integers.\")\n\n        print(\"Congratulations! You've sunk all the ships!\")\n\nif __name__ == \"__main__\":\n    game = Battleship()\n    game.play()\n```",
    "7": "```python\nimport numpy as np\nimport os\nimport time\n\nclass GameOfLife:\n    def __init__(self, rows, cols):\n        self.rows = rows\n        self.cols = cols\n        self.grid = np.zeros((rows, cols), dtype=int)\n\n    def randomize(self):\n        self.grid = np.random.randint(2, size=(self.rows, self.cols))\n\n    def update(self):\n        new_grid = self.grid.copy()\n        for r in range(self.rows):\n            for c in range(self.cols):\n                live_neighbors = self.count_live_neighbors(r, c)\n                if self.grid[r, c] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[r, c] = 0\n                else:\n                    if live_neighbors == 3:\n                        new_grid[r, c] = 1\n        self.grid = new_grid\n\n    def count_live_neighbors(self, r, c):\n        total = 0\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                if (i == 0 and j == 0) or not (0 <= r + i < self.rows) or not (0 <= c + j < self.cols):\n                    continue\n                total += self.grid[r + i, c + j]\n        return total\n\n    def display(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        print(self.grid)\n\n    def run(self, generations):\n        self.randomize()\n        for _ in range(generations):\n            self.display()\n            self.update()\n            time.sleep(0.5)\n\nif __name__ == \"__main__\":\n    rows, cols = 20, 20\n    game = GameOfLife(rows, cols)\n    generations = 100\n    game.run(generations)\n```",
    "8": "```python\nclass ConnectFour:\n    def __init__(self):\n        self.board = [[' ' for _ in range(7)] for _ in range(6)]\n        self.current_player = 'X'\n\n    def print_board(self):\n        for row in self.board:\n            print('|'.join(row))\n            print('-' * 13)\n        print('0 1 2 3 4 5 6')\n\n    def drop_piece(self, column):\n        for row in reversed(range(6)):\n            if self.board[row][column] == ' ':\n                self.board[row][column] = self.current_player\n                return True\n        return False\n\n    def is_winner(self):\n        # Check horizontal, vertical, and diagonal\n        for row in range(6):\n            for col in range(7):\n                if self.board[row][col] == self.current_player:\n                    if self.check_direction(row, col, 1, 0) or \\\n                       self.check_direction(row, col, 0, 1) or \\\n                       self.check_direction(row, col, 1, 1) or \\\n                       self.check_direction(row, col, 1, -1):\n                        return True\n        return False\n\n    def check_direction(self, row, col, delta_row, delta_col):\n        count = 0\n        for _ in range(4):\n            if 0 <= row < 6 and 0 <= col < 7 and self.board[row][col] == self.current_player:\n                count += 1\n                if count == 4:\n                    return True\n            else:\n                break\n            row += delta_row\n            col += delta_col\n        return False\n\n    def is_full(self):\n        return all(self.board[0][col] != ' ' for col in range(7))\n\n    def switch_player(self):\n        self.current_player = 'O' if self.current_player == 'X' else 'X'\n\n    def play(self):\n        while True:\n            self.print_board()\n            column = input(f\"Player {self.current_player}, choose a column (0-6): \")\n            if not column.isdigit() or not 0 <= int(column) <= 6:\n                print(\"Invalid input. Please choose a column between 0 and 6.\")\n                continue\n            column = int(column)\n            if not self.drop_piece(column):\n                print(\"Column full! Try a different column.\")\n                continue\n            if self.is_winner():\n                self.print_board()\n                print(f\"Player {self.current_player} wins!\")\n                break\n            if self.is_full():\n                self.print_board()\n                print(\"It's a tie!\")\n                break\n            self.switch_player()\n\nif __name__ == \"__main__\":\n    game = ConnectFour()\n    game.play()\n```",
    "9": "```python\nimport random\n\nclass Card:\n    def __init__(self, suit, rank):\n        self.suit = suit\n        self.rank = rank\n        self.value = self.get_value()\n\n    def get_value(self):\n        if self.rank in ['J', 'Q', 'K']:\n            return 10\n        elif self.rank == 'A':\n            return 11  # Initially count Ace as 11\n        else:\n            return int(self.rank)\n\n    def __str__(self):\n        return f'{self.rank} of {self.suit}'\n\nclass Deck:\n    def __init__(self):\n        self.cards = [Card(suit, rank) for suit in ['Hearts', 'Diamonds', 'Clubs', 'Spades']\n                      for rank in ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']]\n        random.shuffle(self.cards)\n\n    def deal_card(self):\n        return self.cards.pop()\n\nclass Hand:\n    def __init__(self):\n        self.cards = []\n        self.value = 0\n        self.aces = 0\n\n    def add_card(self, card):\n        self.cards.append(card)\n        self.value += card.value\n        if card.rank == 'A':\n            self.aces += 1\n        self.adjust_for_ace()\n\n    def adjust_for_ace(self):\n        while self.value > 21 and self.aces:\n            self.value -= 10\n            self.aces -= 1\n\nclass BlackjackGame:\n    def __init__(self):\n        self.deck = Deck()\n        self.player_hand = Hand()\n        self.dealer_hand = Hand()\n\n    def start_game(self):\n        for _ in range(2):\n            self.player_hand.add_card(self.deck.deal_card())\n            self.dealer_hand.add_card(self.deck.deal_card())\n        self.show_hands(initial=True)\n        self.player_turn()\n\n    def show_hands(self, initial=False):\n        print(\"\\nDealer's Hand:\")\n        if initial:\n            print(\" <hidden card> \")\n            print(\" \" + str(self.dealer_hand.cards[1]))\n        else:\n            for card in self.dealer_hand.cards:\n                print(\" \" + str(card))\n        print(\"\\nYour Hand:\")\n        for card in self.player_hand.cards:\n            print(\" \" + str(card))\n        print(f\"Your total value: {self.player_hand.value}\")\n\n    def player_turn(self):\n        while self.player_hand.value < 21:\n            action = input(\"Would you like to hit or stand? (h/s): \").lower()\n            if action == 'h':\n                self.player_hand.add_card(self.deck.deal_card())\n                self.show_hands()\n            elif action == 's':\n                break\n            else:\n                print(\"Invalid input. Please enter 'h' or 's'.\")\n        self.dealer_turn()\n\n    def dealer_turn(self):\n        print(\"\\nDealer's turn.\")\n        self.show_hands()\n        while self.dealer_hand.value < 17:\n            print(\"Dealer hits.\")\n            self.dealer_hand.add_card(self.deck.deal_card())\n            self.show_hands()\n        self.determine_winner()\n\n    def determine_winner(self):\n        print(\"\\nFinal Hands:\")\n        self.show_hands(initial=False)\n        if self.player_hand.value > 21:\n            print(\"You bust! Dealer wins.\")\n        elif self.dealer_hand.value > 21:\n            print(\"Dealer busts! You win!\")\n        elif self.player_hand.value > self.dealer_hand.value:\n            print(\"You win!\")\n        elif self.player_hand.value < self.dealer_hand.value:\n            print(\"Dealer wins!\")\n        else:\n            print(\"It's a tie!\")\n\nif __name__ == \"__main__\":\n    game = BlackjackGame()\n    game.start_game()\n```\n",
    "10": "```python\nimport random\n\nclass Hammurabi:\n    def __init__(self):\n        self.year = 1\n        self.bushels = 100\n        self.population = 100\n        self.land = 100\n        self.plague = False\n        self.famine = False\n        self.harvest = 0\n        self.deaths = 0\n\n    def print_status(self):\n        print(f\"Year: {self.year}\")\n        print(f\"Bushels: {self.bushels}\")\n        print(f\"Population: {self.population}\")\n        print(f\"Land: {self.land}\")\n\n    def get_user_input(self):\n        while True:\n            try:\n                land_to_buy = int(input(\"How many acres of land do you want to buy? \"))\n                if land_to_buy < 0 or land_to_buy * 20 > self.bushels:\n                    print(\"Invalid amount. You can't buy that much land.\")\n                    continue\n                break\n            except ValueError:\n                print(\"Please enter a valid number.\")\n        \n        while True:\n            try:\n                bushels_to_feed = int(input(\"How many bushels do you want to feed your people? \"))\n                if bushels_to_feed < 0 or bushels_to_feed > self.bushels:\n                    print(\"Invalid amount. You can't feed more than you have.\")\n                    continue\n                break\n            except ValueError:\n                print(\"Please enter a valid number.\")\n        \n        while True:\n            try:\n                acres_to_plant = int(input(\"How many acres do you want to plant? \"))\n                if acres_to_plant < 0 or acres_to_plant > self.land:\n                    print(\"Invalid amount. You can't plant more than you own.\")\n                    continue\n                break\n            except ValueError:\n                print(\"Please enter a valid number.\")\n        \n        return land_to_buy, bushels_to_feed, acres_to_plant\n\n    def update_game_state(self, land_to_buy, bushels_to_feed, acres_to_plant):\n        if land_to_buy > 0:\n            self.bushels -= land_to_buy * 20\n            self.land += land_to_buy\n\n        if bushels_to_feed > 0:\n            bushels_per_person = bushels_to_feed // self.population\n            self.deaths = self.population - bushels_per_person * 5\n            if self.deaths > 0:\n                self.population -= self.deaths\n\n        self.harvest = acres_to_plant * random.randint(1, 6)\n        self.bushels += self.harvest\n        self.year += 1\n\n    def check_game_over(self):\n        if self.population <= 0:\n            print(\"Your population has died out. You lose!\")\n            return True\n        if self.year > 10:\n            print(\"You have ruled for 10 years. You win!\")\n            return True\n        return False\n\n    def play(self):\n        while True:\n            self.print_status()\n            land_to_buy, bushels_to_feed, acres_to_plant = self.get_user_input()\n            self.update_game_state(land_to_buy, bushels_to_feed, acres_to_plant)\n            if self.check_game_over():\n                break\n\nif __name__ == \"__main__\":\n    game = Hammurabi()\n    game.play()\n```",
    "11": "```python\nimport random\n\nclass LightsOut:\n    def __init__(self, size=5):\n        self.size = size\n        self.board = self.generate_board()\n        self.is_solved = False\n\n    def generate_board(self):\n        return [[random.choice([0, 1]) for _ in range(self.size)] for _ in range(self.size)]\n\n    def toggle_light(self, x, y):\n        if 0 <= x < self.size and 0 <= y < self.size:\n            self.board[x][y] ^= 1\n            if x > 0: self.board[x-1][y] ^= 1\n            if x < self.size - 1: self.board[x+1][y] ^= 1\n            if y > 0: self.board[x][y-1] ^= 1\n            if y < self.size - 1: self.board[x][y+1] ^= 1\n\n    def check_solved(self):\n        self.is_solved = all(light == 0 for row in self.board for light in row)\n\n    def display_board(self):\n        for row in self.board:\n            print(' '.join(['O' if light else '.' for light in row]))\n        print()\n\n    def play(self):\n        while not self.is_solved:\n            self.display_board()\n            try:\n                x, y = map(int, input(f\"Enter coordinates to toggle (row col) [0-{self.size-1}]: \").split())\n                self.toggle_light(x, y)\n                self.check_solved()\n            except (ValueError, IndexError):\n                print(\"Invalid input. Please enter valid coordinates.\")\n\n        print(\"Congratulations! You've solved the puzzle!\")\n\nif __name__ == \"__main__\":\n    game = LightsOut()\n    game.play()\n```",
    "12": "```python\nimport os\nimport time\nimport random\nimport sys\nimport threading\n\nclass PongGame:\n    def __init__(self, width=40, height=20):\n        self.width = width\n        self.height = height\n        self.paddle_height = 3\n        self.ball_x = width // 2\n        self.ball_y = height // 2\n        self.ball_dx = random.choice([-1, 1])\n        self.ball_dy = random.choice([-1, 1])\n        self.paddle1_y = height // 2 - self.paddle_height // 2\n        self.paddle2_y = height // 2 - self.paddle_height // 2\n        self.score1 = 0\n        self.score2 = 0\n        self.running = True\n\n    def draw(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for y in range(self.height):\n            for x in range(self.width):\n                if x == 0 and self.paddle1_y <= y < self.paddle1_y + self.paddle_height:\n                    print('|', end='')\n                elif x == self.width - 1 and self.paddle2_y <= y < self.paddle2_y + self.paddle_height:\n                    print('|', end='')\n                elif x == self.ball_x and y == self.ball_y:\n                    print('O', end='')\n                else:\n                    print(' ', end='')\n            print()\n        print(f'Score - Player 1: {self.score1} | Player 2: {self.score2}')\n\n    def update_ball(self):\n        self.ball_x += self.ball_dx\n        self.ball_y += self.ball_dy\n\n        if self.ball_y <= 0 or self.ball_y >= self.height - 1:\n            self.ball_dy *= -1\n\n        if self.ball_x == 0:\n            if self.paddle1_y <= self.ball_y < self.paddle1_y + self.paddle_height:\n                self.ball_dx *= -1\n            else:\n                self.score2 += 1\n                self.reset_ball()\n\n        if self.ball_x == self.width - 1:\n            if self.paddle2_y <= self.ball_y < self.paddle2_y + self.paddle_height:\n                self.ball_dx *= -1\n            else:\n                self.score1 += 1\n                self.reset_ball()\n\n    def reset_ball(self):\n        self.ball_x = self.width // 2\n        self.ball_y = self.height // 2\n        self.ball_dx = random.choice([-1, 1])\n        self.ball_dy = random.choice([-1, 1])\n\n    def move_paddle(self, paddle, direction):\n        if paddle == 1:\n            if direction == 'up' and self.paddle1_y > 0:\n                self.paddle1_y -= 1\n            elif direction == 'down' and self.paddle1_y < self.height - self.paddle_height:\n                self.paddle1_y += 1\n        elif paddle == 2:\n            if direction == 'up' and self.paddle2_y > 0:\n                self.paddle2_y -= 1\n            elif direction == 'down' and self.paddle2_y < self.height - self.paddle_height:\n                self.paddle2_y += 1\n\n    def game_loop(self):\n        while self.running:\n            self.update_ball()\n            self.draw()\n            time.sleep(0.1)\n\n    def input_thread(self):\n        while self.running:\n            command = input()\n            if command == 'w':\n                self.move_paddle(1, 'up')\n            elif command == 's':\n                self.move_paddle(1, 'down')\n            elif command == 'i':\n                self.move_paddle(2, 'up')\n            elif command == 'k':\n                self.move_paddle(2, 'down')\n            elif command == 'exit':\n                self.running = False\n                break\n\n    def start(self):\n        threading.Thread(target=self.input_thread, daemon=True).start()\n        self.game_loop()\n\nif __name__ == '__main__':\n    game = PongGame()\n    game.start()\n```\n",
    "13": "```python\nimport random\nimport os\nimport sys\nimport time\nimport keyboard\n\nclass Tetris:\n    WIDTH = 10\n    HEIGHT = 20\n    SHAPES = [\n        [[1, 1, 1, 1]],  # I\n        [[1, 1], [1, 1]],  # O\n        [[0, 1, 0], [1, 1, 1]],  # T\n        [[1, 1, 0], [0, 1, 1]],  # S\n        [[0, 1, 1], [1, 1, 0]],  # Z\n        [[1, 0, 0], [1, 1, 1]],  # L\n        [[0, 0, 1], [1, 1, 1]],  # J\n    ]\n\n    def __init__(self):\n        self.board = [[0] * self.WIDTH for _ in range(self.HEIGHT)]\n        self.current_piece = self.new_piece()\n        self.current_position = [0, self.WIDTH // 2 - len(self.current_piece[0]) // 2]\n        self.game_over = False\n\n    def new_piece(self):\n        return random.choice(self.SHAPES)\n\n    def rotate_piece(self):\n        self.current_piece = [list(row) for row in zip(*self.current_piece[::-1])]\n\n    def can_move(self, dx, dy):\n        for r, row in enumerate(self.current_piece):\n            for c, val in enumerate(row):\n                if val:\n                    new_r = r + self.current_position[0] + dy\n                    new_c = c + self.current_position[1] + dx\n                    if (new_r >= self.HEIGHT or new_c < 0 or new_c >= self.WIDTH or\n                            (new_r >= 0 and self.board[new_r][new_c])):\n                        return False\n        return True\n\n    def place_piece(self):\n        for r, row in enumerate(self.current_piece):\n            for c, val in enumerate(row):\n                if val:\n                    self.board[r + self.current_position[0]][c + self.current_position[1]] = 1\n        self.clear_lines()\n\n    def clear_lines(self):\n        new_board = [row for row in self.board if any(val == 0 for val in row)]\n        lines_cleared = self.HEIGHT - len(new_board)\n        self.board = [[0] * self.WIDTH for _ in range(lines_cleared)] + new_board\n\n    def drop_piece(self):\n        if self.can_move(0, 1):\n            self.current_position[0] += 1\n        else:\n            self.place_piece()\n            self.current_piece = self.new_piece()\n            self.current_position = [0, self.WIDTH // 2 - len(self.current_piece[0]) // 2]\n            if not self.can_move(0, 0):\n                self.game_over = True\n\n    def draw_board(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for r in range(self.HEIGHT):\n            row = ''.join(['#' if self.board[r][c] else '.' for c in range(self.WIDTH)])\n            print(row)\n        print(\"\\nControls: [A] Left, [D] Right, [S] Down, [W] Rotate, [Q] Quit\")\n\n    def run(self):\n        while not self.game_over:\n            self.draw_board()\n            time.sleep(0.1)\n            if keyboard.is_pressed('a') and self.can_move(-1, 0):\n                self.current_position[1] -= 1\n            if keyboard.is_pressed('d') and self.can_move(1, 0):\n                self.current_position[1] += 1\n            if keyboard.is_pressed('s'):\n                self.drop_piece()\n            if keyboard.is_pressed('w'):\n                self.rotate_piece()\n            self.drop_piece()\n        print(\"Game Over!\")\n\nif __name__ == \"__main__\":\n    game = Tetris()\n    game.run()\n```",
    "14": "```python\nimport random\nimport os\nimport time\nimport sys\nimport math\n\nclass AsteroidGame:\n    def __init__(self, width=40, height=20, num_asteroids=5):\n        self.width = width\n        self.height = height\n        self.player_x = width // 2\n        self.player_y = height // 2\n        self.asteroids = self.generate_asteroids(num_asteroids)\n        self.score = 0\n        self.game_over = False\n\n    def generate_asteroids(self, num):\n        return [(random.randint(0, self.width - 1), random.randint(0, self.height - 1)) for _ in range(num)]\n\n    def draw(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for y in range(self.height):\n            for x in range(self.width):\n                if (x, y) == (self.player_x, self.player_y):\n                    print('^', end='')\n                elif (x, y) in self.asteroids:\n                    print('*', end='')\n                else:\n                    print(' ', end='')\n            print()\n        print(f'Score: {self.score}')\n\n    def move_player(self, direction):\n        if direction == 'w' and self.player_y > 0:\n            self.player_y -= 1\n        elif direction == 's' and self.player_y < self.height - 1:\n            self.player_y += 1\n        elif direction == 'a' and self.player_x > 0:\n            self.player_x -= 1\n        elif direction == 'd' and self.player_x < self.width - 1:\n            self.player_x += 1\n\n    def update(self):\n        if (self.player_x, self.player_y) in self.asteroids:\n            self.game_over = True\n        else:\n            self.score += 1\n            self.asteroids = self.generate_asteroids(len(self.asteroids))\n\n    def play(self):\n        while not self.game_over:\n            self.draw()\n            direction = input(\"Move (w/a/s/d): \").lower()\n            self.move_player(direction)\n            self.update()\n            time.sleep(0.1)\n        print(\"Game Over! Final Score:\", self.score)\n\nif __name__ == \"__main__\":\n    game = AsteroidGame()\n    game.play()\n```",
    "15": "```python\nimport random\n\nclass Boggle:\n    def __init__(self, size=4):\n        self.size = size\n        self.board = self.generate_board()\n        self.valid_words = set()\n        self.found_words = set()\n\n    def generate_board(self):\n        letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        return [[random.choice(letters) for _ in range(self.size)] for _ in range(self.size)]\n\n    def print_board(self):\n        for row in self.board:\n            print(\" \".join(row))\n        print()\n\n    def load_dictionary(self, filename):\n        with open(filename, 'r') as f:\n            for line in f:\n                self.valid_words.add(line.strip().upper())\n\n    def is_valid_word(self, word):\n        return word in self.valid_words\n\n    def find_words(self):\n        for row in range(self.size):\n            for col in range(self.size):\n                self.search_word(row, col, \"\", set())\n\n    def search_word(self, row, col, current_word, visited):\n        if len(current_word) > 0 and self.is_valid_word(current_word):\n            self.found_words.add(current_word)\n\n        if len(current_word) >= 16:\n            return\n\n        for r in range(max(0, row - 1), min(self.size, row + 2)):\n            for c in range(max(0, col - 1), min(self.size, col + 2)):\n                if (r, c) not in visited:\n                    visited.add((r, c))\n                    self.search_word(r, c, current_word + self.board[r][c], visited)\n                    visited.remove((r, c))\n\n    def play(self):\n        print(\"Welcome to Boggle!\")\n        self.print_board()\n        self.find_words()\n        print(\"Found Words:\")\n        for word in sorted(self.found_words):\n            print(word)\n\nif __name__ == \"__main__\":\n    boggle = Boggle()\n    boggle.load_dictionary('dictionary.txt')  # Make sure to have a valid dictionary file\n    boggle.play()\n```",
    "16": "```python\nimport random\nimport os\nimport sys\nimport time\n\nclass PacMan:\n    def __init__(self):\n        self.board = [[' ' for _ in range(10)] for _ in range(10)]\n        self.pacman_pos = [1, 1]\n        self.food_positions = []\n        self.score = 0\n        self.is_running = True\n        self.generate_food(10)\n\n    def generate_food(self, num_food):\n        while len(self.food_positions) < num_food:\n            pos = [random.randint(0, 9), random.randint(0, 9)]\n            if pos != self.pacman_pos and pos not in self.food_positions:\n                self.food_positions.append(pos)\n\n    def draw_board(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for row in range(10):\n            for col in range(10):\n                if [row, col] == self.pacman_pos:\n                    print('P', end=' ')\n                elif [row, col] in self.food_positions:\n                    print('.', end=' ')\n                else:\n                    print(' ', end=' ')\n            print()\n        print(f\"Score: {self.score}\")\n\n    def move(self, direction):\n        if direction == 'w' and self.pacman_pos[0] > 0:\n            self.pacman_pos[0] -= 1\n        elif direction == 's' and self.pacman_pos[0] < 9:\n            self.pacman_pos[0] += 1\n        elif direction == 'a' and self.pacman_pos[1] > 0:\n            self.pacman_pos[1] -= 1\n        elif direction == 'd' and self.pacman_pos[1] < 9:\n            self.pacman_pos[1] += 1\n\n        self.check_food()\n\n    def check_food(self):\n        if self.pacman_pos in self.food_positions:\n            self.food_positions.remove(self.pacman_pos)\n            self.score += 1\n            if not self.food_positions:\n                self.is_running = False\n\n    def play(self):\n        print(\"Use W (up), A (left), S (down), D (right) to move. Press Q to quit.\")\n        while self.is_running:\n            self.draw_board()\n            move = input(\"Enter move: \").lower()\n            if move in ['w', 'a', 's', 'd']:\n                self.move(move)\n            elif move == 'q':\n                self.is_running = False\n            else:\n                print(\"Invalid move. Use W, A, S, D or Q to quit.\")\n\n        print(\"Game Over! Final Score: \", self.score)\n\nif __name__ == '__main__':\n    game = PacMan()\n    game.play()\n```",
    "17": "```python\nimport random\nimport os\nimport time\nimport sys\n\nclass DinosaurRunner:\n    def __init__(self):\n        self.dino_position = 0\n        self.obstacle_position = 50\n        self.score = 0\n        self.game_over = False\n\n    def clear_screen(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n\n    def draw_game(self):\n        self.clear_screen()\n        print(\"Score:\", self.score)\n        print(\" \" * self.dino_position + \"D\")\n        print(\" \" * self.obstacle_position + \"X\")\n        print(\"\\nPress 'j' to jump, 'q' to quit.\")\n\n    def jump(self):\n        if self.dino_position == 0:\n            self.dino_position = 1\n            print(\"Jumping!\")\n            time.sleep(0.5)  # Simulate jump duration\n            self.dino_position = 0\n\n    def update_game(self):\n        self.obstacle_position -= 1\n        if self.obstacle_position < 0:\n            self.obstacle_position = 50\n            self.score += 1\n            if random.random() < 0.2:  # 20% chance for a new obstacle\n                self.obstacle_position = 50\n\n    def check_collision(self):\n        if self.dino_position == 0 and self.obstacle_position == 0:\n            self.game_over = True\n\n    def run(self):\n        print(\"Welcome to Dinosaur Runner!\")\n        print(\"Avoid the obstacles by jumping!\\n\")\n\n        while not self.game_over:\n            self.draw_game()\n            self.update_game()\n            self.check_collision()\n\n            if self.game_over:\n                break\n\n            user_input = input(\"Action: \")\n            if user_input.lower() == 'j':\n                self.jump()\n            elif user_input.lower() == 'q':\n                print(\"Quitting the game.\")\n                break\n            else:\n                print(\"Invalid input! Use 'j' to jump or 'q' to quit.\")\n\n        print(\"Game Over! Your score is:\", self.score)\n\nif __name__ == \"__main__\":\n    game = DinosaurRunner()\n    game.run()\n```"
}