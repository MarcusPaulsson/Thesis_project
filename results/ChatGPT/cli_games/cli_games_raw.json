{
    "0": "```python\nclass TicTacToe:\n    def __init__(self):\n        self.board = [' ' for _ in range(9)]  # A list to hold the board state\n        self.current_winner = None  # Keep track of the winner!\n\n    def print_board(self):\n        for i in range(3):\n            print('|'.join(self.board[i * 3:(i + 1) * 3]))\n            if i < 2:\n                print('-' * 5)\n\n    def available_moves(self):\n        return [i for i, spot in enumerate(self.board) if spot == ' ']\n\n    def empty_squares(self):\n        return ' ' in self.board\n\n    def make_move(self, square, letter):\n        if self.board[square] == ' ':\n            self.board[square] = letter\n            if self.winner(square, letter):\n                self.current_winner = letter\n            return True\n        return False\n\n    def winner(self, square, letter):\n        row_ind = square // 3\n        row = self.board[row_ind * 3:(row_ind + 1) * 3]\n        if all([spot == letter for spot in row]):\n            return True\n        col_ind = square % 3\n        column = [self.board[col_ind + i * 3] for i in range(3)]\n        if all([spot == letter for spot in column]):\n            return True\n        if square % 2 == 0:\n            diagonal1 = [self.board[i] for i in [0, 4, 8]]\n            if all([spot == letter for spot in diagonal1]):\n                return True\n            diagonal2 = [self.board[i] for i in [2, 4, 6]]\n            if all([spot == letter for spot in diagonal2]):\n                return True\n        return False\n\n    def play(self):\n        print(\"Welcome to Tic-Tac-Toe!\")\n        self.print_board()\n        letter = 'X'\n        while self.empty_squares():\n            move = input(f\"{letter}'s turn. Enter a position (0-8): \")\n            try:\n                move = int(move)\n                if move not in self.available_moves():\n                    print(\"Invalid move. Try again.\")\n                    continue\n                self.make_move(move, letter)\n                self.print_board()\n                if self.current_winner:\n                    print(f\"{letter} wins!\")\n                    return\n                letter = 'O' if letter == 'X' else 'X'\n            except ValueError:\n                print(\"Invalid input. Please enter a number between 0 and 8.\")\n        print(\"It's a tie!\")\n\nif __name__ == '__main__':\n    game = TicTacToe()\n    game.play()\n```",
    "1": "```python\nimport random\n\nclass Hangman:\n    def __init__(self, word_list, max_attempts=6):\n        self.word_list = word_list\n        self.max_attempts = max_attempts\n        self.word = random.choice(self.word_list).upper()\n        self.guesses = set()\n        self.attempts = 0\n\n    def display_word(self):\n        return ' '.join(letter if letter in self.guesses else '_' for letter in self.word)\n\n    def make_guess(self, guess):\n        guess = guess.upper()\n        if guess in self.guesses:\n            return False, \"You've already guessed that letter.\"\n        self.guesses.add(guess)\n        if guess not in self.word:\n            self.attempts += 1\n        return True, None\n\n    def is_won(self):\n        return all(letter in self.guesses for letter in self.word)\n\n    def is_lost(self):\n        return self.attempts >= self.max_attempts\n\n    def play(self):\n        print(\"Welcome to Hangman!\")\n        while not self.is_won() and not self.is_lost():\n            print(f\"Word: {self.display_word()}\")\n            print(f\"Attempts left: {self.max_attempts - self.attempts}\")\n            guess = input(\"Enter a letter: \").strip()\n            if len(guess) != 1 or not guess.isalpha():\n                print(\"Please enter a single letter.\")\n                continue\n            \n            valid, message = self.make_guess(guess)\n            if message:\n                print(message)\n\n        if self.is_won():\n            print(f\"Congratulations! You've won! The word was '{self.word}'.\")\n        else:\n            print(f\"Game over! The word was '{self.word}'.\")\n\nif __name__ == \"__main__\":\n    words = [\"PYTHON\", \"HANGMAN\", \"PROGRAMMING\", \"COMPUTER\", \"DEVELOPER\"]\n    game = Hangman(words)\n    game.play()\n```",
    "2": "```python\nimport random\n\nclass RockPaperScissors:\n    def __init__(self):\n        self.choices = ['rock', 'paper', 'scissors']\n        self.score = {'player': 0, 'computer': 0}\n\n    def get_computer_choice(self):\n        return random.choice(self.choices)\n\n    def get_player_choice(self):\n        choice = input(\"Enter rock, paper, or scissors (or 'quit' to exit): \").lower()\n        while choice not in self.choices and choice != 'quit':\n            print(\"Invalid choice. Please try again.\")\n            choice = input(\"Enter rock, paper, or scissors (or 'quit' to exit): \").lower()\n        return choice\n\n    def determine_winner(self, player, computer):\n        if player == computer:\n            return \"It's a tie!\"\n        elif (player == 'rock' and computer == 'scissors') or \\\n             (player == 'paper' and computer == 'rock') or \\\n             (player == 'scissors' and computer == 'paper'):\n            self.score['player'] += 1\n            return \"You win!\"\n        else:\n            self.score['computer'] += 1\n            return \"Computer wins!\"\n\n    def play(self):\n        print(\"Welcome to Rock-Paper-Scissors!\")\n        while True:\n            player_choice = self.get_player_choice()\n            if player_choice == 'quit':\n                break\n            computer_choice = self.get_computer_choice()\n            print(f\"Computer chose: {computer_choice}\")\n            result = self.determine_winner(player_choice, computer_choice)\n            print(result)\n            print(f\"Score - You: {self.score['player']} | Computer: {self.score['computer']}\")\n        print(\"Thanks for playing!\")\n\nif __name__ == \"__main__\":\n    game = RockPaperScissors()\n    game.play()\n```",
    "3": "```python\nimport random\nimport curses\n\nclass SnakeGame:\n    def __init__(self, height=20, width=60):\n        self.height = height\n        self.width = width\n        self.window = curses.initscr()\n        self.window.keypad(1)\n        self.window.timeout(100)\n        self.snake = [[height // 2, width // 4]]\n        self.snake_direction = curses.KEY_RIGHT\n        self.food = self.place_food()\n        self.score = 0\n\n    def place_food(self):\n        while True:\n            food = [random.randint(1, self.height - 1), random.randint(1, self.width - 1)]\n            if food not in self.snake:\n                return food\n\n    def run(self):\n        while True:\n            next_key = self.window.getch()\n            self.snake_direction = next_key if next_key in [curses.KEY_RIGHT, curses.KEY_LEFT, curses.KEY_UP, curses.KEY_DOWN] else self.snake_direction\n\n            new_head = self.snake[0][:]\n            if self.snake_direction == curses.KEY_DOWN:\n                new_head[0] += 1\n            elif self.snake_direction == curses.KEY_UP:\n                new_head[0] -= 1\n            elif self.snake_direction == curses.KEY_LEFT:\n                new_head[1] -= 1\n            elif self.snake_direction == curses.KEY_RIGHT:\n                new_head[1] += 1\n\n            if new_head in self.snake or new_head[0] in [0, self.height] or new_head[1] in [0, self.width]:\n                curses.endwin()\n                print(\"Game Over! Your score is: {}\".format(self.score))\n                break\n\n            self.snake.insert(0, new_head)\n\n            if self.snake[0] == self.food:\n                self.score += 1\n                self.food = self.place_food()\n            else:\n                self.snake.pop()\n\n            self.window.clear()\n            self.window.border(0)\n            self.window.addstr(0, 2, 'Score: {}'.format(self.score))\n            self.window.addch(int(self.food[0]), int(self.food[1]), curses.ACS_PI)\n            for segment in self.snake:\n                self.window.addch(int(segment[0]), int(segment[1]), curses.ACS_CKBOARD)\n            self.window.refresh()\n\nif __name__ == \"__main__\":\n    curses.wrapper(SnakeGame().run)\n```",
    "4": "```python\nimport random\n\nclass Minesweeper:\n    def __init__(self, width, height, mines):\n        self.width = width\n        self.height = height\n        self.mines = mines\n        self.board = [[' ' for _ in range(width)] for _ in range(height)]\n        self.revealed = [[' ' for _ in range(width)] for _ in range(height)]\n        self.game_over = False\n        self.flags = 0\n        self.place_mines()\n        self.calculate_numbers()\n\n    def place_mines(self):\n        mine_locations = random.sample(range(self.width * self.height), self.mines)\n        for location in mine_locations:\n            row = location // self.width\n            col = location % self.width\n            self.board[row][col] = 'M'\n\n    def calculate_numbers(self):\n        for r in range(self.height):\n            for c in range(self.width):\n                if self.board[r][c] == 'M':\n                    continue\n                self.board[r][c] = str(self.count_mines(r, c))\n\n    def count_mines(self, row, col):\n        count = 0\n        for r in range(max(0, row - 1), min(self.height, row + 2)):\n            for c in range(max(0, col - 1), min(self.width, col + 2)):\n                if self.board[r][c] == 'M':\n                    count += 1\n        return count\n\n    def reveal(self, row, col):\n        if self.game_over or self.revealed[row][col] != ' ':\n            return\n\n        self.revealed[row][col] = self.board[row][col]\n\n        if self.board[row][col] == 'M':\n            self.game_over = True\n            return\n\n        if self.board[row][col] == '0':\n            for r in range(max(0, row - 1), min(self.height, row + 2)):\n                for c in range(max(0, col - 1), min(self.width, col + 2)):\n                    self.reveal(r, c)\n\n    def flag(self, row, col):\n        if self.revealed[row][col] == ' ':\n            self.revealed[row][col] = 'F'\n            self.flags += 1\n        elif self.revealed[row][col] == 'F':\n            self.revealed[row][col] = ' '\n            self.flags -= 1\n\n    def print_board(self):\n        print(' ' + ' '.join(str(i) for i in range(self.width)))\n        for r in range(self.height):\n            print(r, ' '.join(self.revealed[r]))\n\n    def check_win(self):\n        for r in range(self.height):\n            for c in range(self.width):\n                if self.board[r][c] != 'M' and self.revealed[r][c] == ' ':\n                    return False\n        return True\n\n    def play(self):\n        while not self.game_over:\n            self.print_board()\n            command = input(\"Enter command (reveal/flag) and coordinates (row col): \").split()\n            if len(command) != 3:\n                print(\"Invalid input. Please enter a command followed by row and column.\")\n                continue\n\n            cmd, row, col = command[0], int(command[1]), int(command[2])\n\n            if cmd == 'reveal':\n                self.reveal(row, col)\n            elif cmd == 'flag':\n                self.flag(row, col)\n            else:\n                print(\"Invalid command. Use 'reveal' or 'flag'.\")\n\n            if self.check_win():\n                print(\"Congratulations! You've won!\")\n                break\n\n        if self.game_over:\n            self.revealed = self.board\n            self.print_board()\n            print(\"Game over! You hit a mine.\")\n\nif __name__ == \"__main__\":\n    game = Minesweeper(width=10, height=10, mines=10)\n    game.play()\n```",
    "5": "```python\nimport random\n\nclass Mastermind:\n    def __init__(self, code_length=4, max_attempts=10, colors=None):\n        self.code_length = code_length\n        self.max_attempts = max_attempts\n        self.colors = colors or ['R', 'G', 'B', 'Y', 'O', 'P']\n        self.secret_code = self.generate_secret_code()\n        self.attempts = 0\n\n    def generate_secret_code(self):\n        return random.choices(self.colors, k=self.code_length)\n\n    def get_feedback(self, guess):\n        if len(guess) != self.code_length:\n            return \"Invalid guess length.\"\n        \n        correct_position = sum(1 for g, s in zip(guess, self.secret_code) if g == s)\n        correct_color = sum(min(guess.count(c), self.secret_code.count(c)) for c in set(guess)) - correct_position\n        \n        return correct_position, correct_color\n\n    def play(self):\n        print(\"Welcome to Mastermind!\")\n        print(f\"Try to guess the secret code of length {self.code_length}.\")\n        print(f\"You have {self.max_attempts} attempts.\")\n        \n        while self.attempts < self.max_attempts:\n            guess = input(f\"Attempt {self.attempts + 1}: Enter your guess (colors: {', '.join(self.colors)}): \").upper()\n            feedback = self.get_feedback(guess)\n\n            if isinstance(feedback, str):\n                print(feedback)\n                continue\n            \n            correct_position, correct_color = feedback\n            self.attempts += 1\n\n            if correct_position == self.code_length:\n                print(f\"Congratulations! You've guessed the code: {''.join(self.secret_code)}\")\n                return\n            \n            print(f\"Feedback: {correct_position} correct in position, {correct_color} correct color but wrong position.\")\n\n        print(f\"Game over! The secret code was: {''.join(self.secret_code)}\")\n\nif __name__ == \"__main__\":\n    game = Mastermind()\n    game.play()\n```",
    "6": "```python\nimport random\n\nclass Battleship:\n    def __init__(self, size=5, ships=3):\n        self.size = size\n        self.ships = ships\n        self.board = [['~' for _ in range(size)] for _ in range(size)]\n        self.ships_coords = set()\n        self.guesses = set()\n        self.place_ships()\n\n    def place_ships(self):\n        while len(self.ships_coords) < self.ships:\n            x = random.randint(0, self.size - 1)\n            y = random.randint(0, self.size - 1)\n            self.ships_coords.add((x, y))\n\n    def print_board(self, show_ships=False):\n        print(\"  \" + \" \".join(str(i) for i in range(self.size)))\n        for i in range(self.size):\n            row = \" \".join(self.board[i][j] if (i, j) not in self.ships_coords or show_ships else \"~\" for j in range(self.size))\n            print(f\"{i} {row}\")\n\n    def make_guess(self, x, y):\n        if (x, y) in self.guesses:\n            print(\"You already guessed that!\")\n            return False\n        self.guesses.add((x, y))\n        if (x, y) in self.ships_coords:\n            self.board[x][y] = 'X'\n            print(\"Hit!\")\n            return True\n        else:\n            self.board[x][y] = 'O'\n            print(\"Miss!\")\n            return False\n\n    def play(self):\n        print(\"Welcome to Battleship!\")\n        while len(self.guesses) < self.size * self.size and len(self.ships_coords) > 0:\n            self.print_board()\n            try:\n                x = int(input(\"Enter row (0-indexed): \"))\n                y = int(input(\"Enter column (0-indexed): \"))\n                if x < 0 or x >= self.size or y < 0 or y >= self.size:\n                    print(\"Invalid coordinates. Try again.\")\n                    continue\n                hit = self.make_guess(x, y)\n                if hit and (x, y) in self.ships_coords:\n                    self.ships_coords.remove((x, y))\n                    if len(self.ships_coords) == 0:\n                        print(\"You've sunk all the ships! You win!\")\n                        self.print_board(show_ships=True)\n                        return\n            except ValueError:\n                print(\"Invalid input. Please enter numbers.\")\n\n        print(\"Game Over! You ran out of guesses.\")\n        self.print_board(show_ships=True)\n\nif __name__ == \"__main__\":\n    game = Battleship()\n    game.play()\n```",
    "7": "```python\nimport os\nimport time\nimport random\n\nclass GameOfLife:\n    def __init__(self, width=20, height=20):\n        self.width = width\n        self.height = height\n        self.grid = self._create_grid()\n\n    def _create_grid(self):\n        return [[random.choice([0, 1]) for _ in range(self.width)] for _ in range(self.height)]\n\n    def _print_grid(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for row in self.grid:\n            print(' '.join(['█' if cell else ' ' for cell in row]))\n\n    def _count_neighbors(self, x, y):\n        directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n        count = 0\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < self.height and 0 <= ny < self.width:\n                count += self.grid[nx][ny]\n        return count\n\n    def _update_grid(self):\n        new_grid = [[0 for _ in range(self.width)] for _ in range(self.height)]\n        for x in range(self.height):\n            for y in range(self.width):\n                neighbors = self._count_neighbors(x, y)\n                if self.grid[x][y] == 1 and neighbors in (2, 3):\n                    new_grid[x][y] = 1\n                elif self.grid[x][y] == 0 and neighbors == 3:\n                    new_grid[x][y] = 1\n        self.grid = new_grid\n\n    def play(self, generations=10, delay=0.5):\n        for _ in range(generations):\n            self._print_grid()\n            self._update_grid()\n            time.sleep(delay)\n\nif __name__ == \"__main__\":\n    game = GameOfLife()\n    game.play(generations=20, delay=0.5)\n```",
    "8": "```python\nclass ConnectFour:\n    def __init__(self):\n        self.rows = 6\n        self.cols = 7\n        self.board = [[' ' for _ in range(self.cols)] for _ in range(self.rows)]\n        self.current_player = 'X'\n\n    def print_board(self):\n        for row in self.board:\n            print('|'.join(row))\n            print('-' * (self.cols * 2 - 1))\n        print(' '.join(str(i) for i in range(self.cols)))\n\n    def drop_piece(self, col):\n        for row in reversed(range(self.rows)):\n            if self.board[row][col] == ' ':\n                self.board[row][col] = self.current_player\n                return True\n        return False\n\n    def is_winning_move(self, row, col):\n        return (self.check_direction(row, col, 1, 0) or  # horizontal\n                self.check_direction(row, col, 0, 1) or  # vertical\n                self.check_direction(row, col, 1, 1) or  # diagonal /\n                self.check_direction(row, col, 1, -1))   # diagonal \\\n\n    def check_direction(self, row, col, delta_row, delta_col):\n        count = 0\n        for direction in [1, -1]:\n            r, c = row, col\n            while 0 <= r < self.rows and 0 <= c < self.cols and self.board[r][c] == self.current_player:\n                count += 1\n                if count == 4:\n                    return True\n                r += delta_row * direction\n                c += delta_col * direction\n        return False\n\n    def switch_player(self):\n        self.current_player = 'O' if self.current_player == 'X' else 'X'\n\n    def play(self):\n        while True:\n            self.print_board()\n            col = input(f\"Player {self.current_player}, choose a column (0-{self.cols-1}): \")\n            if not col.isdigit() or not (0 <= int(col) < self.cols):\n                print(\"Invalid input. Please try again.\")\n                continue\n\n            col = int(col)\n            if not self.drop_piece(col):\n                print(\"Column full. Try another one.\")\n                continue\n\n            row = next(r for r in reversed(range(self.rows)) if self.board[r][col] == self.current_player)\n\n            if self.is_winning_move(row, col):\n                self.print_board()\n                print(f\"Player {self.current_player} wins!\")\n                break\n\n            self.switch_player()\n\n\nif __name__ == \"__main__\":\n    game = ConnectFour()\n    game.play()\n```",
    "9": "```python\nimport random\n\nclass Card:\n    suits = ['Hearts', 'Diamonds', 'Clubs', 'Spades']\n    ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace']\n    \n    def __init__(self, suit, rank):\n        self.suit = suit\n        self.rank = rank\n\n    def value(self):\n        if self.rank in ['Jack', 'Queen', 'King']:\n            return 10\n        elif self.rank == 'Ace':\n            return 11  # Ace is initially 11, will adjust later\n        else:\n            return int(self.rank)\n\n    def __str__(self):\n        return f\"{self.rank} of {self.suit}\"\n\nclass Deck:\n    def __init__(self):\n        self.cards = [Card(suit, rank) for suit in Card.suits for rank in Card.ranks]\n        random.shuffle(self.cards)\n\n    def deal(self):\n        return self.cards.pop()\n\nclass Hand:\n    def __init__(self):\n        self.cards = []\n\n    def add_card(self, card):\n        self.cards.append(card)\n\n    def value(self):\n        value = sum(card.value() for card in self.cards)\n        aces = sum(1 for card in self.cards if card.rank == 'Ace')\n        while value > 21 and aces:\n            value -= 10\n            aces -= 1\n        return value\n\n    def __str__(self):\n        return ', '.join(str(card) for card in self.cards)\n\nclass Blackjack:\n    def __init__(self):\n        self.deck = Deck()\n        self.player_hand = Hand()\n        self.dealer_hand = Hand()\n\n    def initial_deal(self):\n        for _ in range(2):\n            self.player_hand.add_card(self.deck.deal())\n            self.dealer_hand.add_card(self.deck.deal())\n\n    def display_hands(self, reveal_dealer=False):\n        print(f\"Player's Hand: {self.player_hand} (Value: {self.player_hand.value()})\")\n        if reveal_dealer:\n            print(f\"Dealer's Hand: {self.dealer_hand} (Value: {self.dealer_hand.value()})\")\n        else:\n            print(f\"Dealer's Hand: {self.dealer_hand.cards[0]}, [Hidden]\")\n\n    def player_turn(self):\n        while True:\n            self.display_hands()\n            if self.player_hand.value() > 21:\n                print(\"Player busts! Dealer wins.\")\n                return False\n            \n            action = input(\"Do you want to (h)it or (s)tand? \").strip().lower()\n            if action == 'h':\n                self.player_hand.add_card(self.deck.deal())\n            elif action == 's':\n                break\n            else:\n                print(\"Invalid input! Please enter 'h' or 's'.\")\n        return True\n\n    def dealer_turn(self):\n        while self.dealer_hand.value() < 17:\n            self.dealer_hand.add_card(self.deck.deal())\n\n    def determine_winner(self):\n        player_value = self.player_hand.value()\n        dealer_value = self.dealer_hand.value()\n        print(f\"Final Hands:\\nPlayer's Hand: {self.player_hand} (Value: {player_value})\\nDealer's Hand: {self.dealer_hand} (Value: {dealer_value})\")\n\n        if dealer_value > 21 or player_value > dealer_value:\n            print(\"Player wins!\")\n        elif player_value < dealer_value:\n            print(\"Dealer wins!\")\n        else:\n            print(\"It's a tie!\")\n\n    def play(self):\n        print(\"Welcome to Blackjack!\")\n        self.initial_deal()\n        if self.player_turn():\n            self.dealer_turn()\n            self.display_hands(reveal_dealer=True)\n            self.determine_winner()\n\nif __name__ == \"__main__\":\n    game = Blackjack()\n    game.play()\n```",
    "10": "```python\nimport random\n\nclass Hammurabi:\n    def __init__(self):\n        self.year = 1960\n        self.population = 100\n        self.bushels = 2800\n        self.land = 100\n        self.plague_years = 0\n        self.harvest_yield = 3\n        self.max_years = 10\n        self.game_over = False\n\n    def play(self):\n        while not self.game_over:\n            self.display_status()\n            self.year += 1\n            self.take_turn()\n            self.check_game_over()\n\n    def display_status(self):\n        print(f\"\\nYear: {self.year}\")\n        print(f\"Population: {self.population}\")\n        print(f\"Bushels: {self.bushels}\")\n        print(f\"Land: {self.land} acres\")\n\n    def take_turn(self):\n        self.ask_land()\n        self.ask_food()\n        self.harvest()\n        self.random_events()\n        self.update_population()\n\n    def ask_land(self):\n        while True:\n            try:\n                land = int(input(f\"How many acres of land do you want to buy/sell? (0 to {self.bushels // 20}): \"))\n                if -self.land <= land <= self.bushels // 20:\n                    self.land += land\n                    self.bushels -= land * 20\n                    break\n                else:\n                    print(\"Invalid amount.\")\n            except ValueError:\n                print(\"Please enter a valid number.\")\n\n    def ask_food(self):\n        while True:\n            try:\n                food = int(input(f\"How many bushels do you want to feed your people? (0 to {self.bushels}): \"))\n                if 0 <= food <= self.bushels:\n                    self.bushels -= food\n                    break\n                else:\n                    print(\"Invalid amount.\")\n            except ValueError:\n                print(\"Please enter a valid number.\")\n\n    def harvest(self):\n        harvested = self.land * self.harvest_yield\n        self.bushels += harvested\n        print(f\"You harvested {harvested} bushels.\")\n\n    def random_events(self):\n        if random.random() < 0.15:\n            self.plague_years += 1\n            lost_population = self.population // 2\n            self.population -= lost_population\n            print(f\"A plague has struck! You lost half your population: {lost_population} people.\")\n\n    def update_population(self):\n        if self.bushels < self.population:\n            starved = self.population - self.bushels\n            self.population -= starved\n            print(f\"{starved} people have died from starvation.\")\n        elif self.bushels > self.population * 20:\n            immigrants = (self.bushels - (self.population * 20)) // 20\n            self.population += immigrants\n            print(f\"{immigrants} immigrants have arrived.\")\n\n    def check_game_over(self):\n        if self.year > self.max_years or self.population <= 0:\n            self.game_over = True\n            if self.population <= 0:\n                print(\"Your population has perished. Game over!\")\n            else:\n                print(\"You have completed your 10 years of rule. Game over!\")\n\nif __name__ == \"__main__\":\n    game = Hammurabi()\n    game.play()\n```",
    "11": "```python\nimport random\n\nclass LightsOut:\n    def __init__(self, size=5):\n        self.size = size\n        self.board = self.generate_board()\n    \n    def generate_board(self):\n        return [[random.choice([0, 1]) for _ in range(self.size)] for _ in range(self.size)]\n\n    def toggle(self, row, col):\n        self.board[row][col] ^= 1  # Toggle the selected light\n        if row > 0:\n            self.board[row - 1][col] ^= 1  # Toggle above\n        if row < self.size - 1:\n            self.board[row + 1][col] ^= 1  # Toggle below\n        if col > 0:\n            self.board[row][col - 1] ^= 1  # Toggle left\n        if col < self.size - 1:\n            self.board[row][col + 1] ^= 1  # Toggle right\n\n    def display(self):\n        for row in self.board:\n            print(\" \".join(\"O\" if light else \".\" for light in row))\n        print()\n\n    def is_solved(self):\n        return all(all(light == 0 for light in row) for row in self.board)\n\n    def play(self):\n        while not self.is_solved():\n            self.display()\n            try:\n                row, col = map(int, input(\"Enter row and column to toggle (0-indexed): \").split())\n                if 0 <= row < self.size and 0 <= col < self.size:\n                    self.toggle(row, col)\n                else:\n                    print(\"Invalid input. Please enter numbers within the range.\")\n            except ValueError:\n                print(\"Invalid input. Please enter two integers.\")\n\n        print(\"Congratulations! You've solved the puzzle.\")\n\nif __name__ == \"__main__\":\n    game = LightsOut()\n    game.play()\n```",
    "12": "```python\nimport os\nimport time\nimport random\nimport sys\n\nclass Pong:\n    def __init__(self, width=40, height=20):\n        self.width = width\n        self.height = height\n        self.paddle_height = 3\n        self.ball = [width // 2, height // 2]\n        self.ball_dir = [random.choice([-1, 1]), random.choice([-1, 1])]\n        self.paddle1 = height // 2 - self.paddle_height // 2\n        self.paddle2 = height // 2 - self.paddle_height // 2\n        self.score1 = 0\n        self.score2 = 0\n\n    def draw(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for y in range(self.height):\n            for x in range(self.width):\n                if x == 0 and self.paddle1 <= y < self.paddle1 + self.paddle_height:\n                    print('|', end='')\n                elif x == self.width - 1 and self.paddle2 <= y < self.paddle2 + self.paddle_height:\n                    print('|', end='')\n                elif [x, y] == self.ball:\n                    print('O', end='')\n                else:\n                    print(' ', end='')\n            print()\n        print(f'Score: Player 1: {self.score1} | Player 2: {self.score2}')\n\n    def update_ball(self):\n        self.ball[0] += self.ball_dir[0]\n        self.ball[1] += self.ball_dir[1]\n\n        if self.ball[1] <= 0 or self.ball[1] >= self.height - 1:\n            self.ball_dir[1] *= -1\n\n        if self.ball[0] == 0:\n            self.score2 += 1\n            self.reset_ball()\n        elif self.ball[0] == self.width - 1:\n            self.score1 += 1\n            self.reset_ball()\n\n        if (self.ball[0] == 0 and self.paddle1 <= self.ball[1] < self.paddle1 + self.paddle_height) or \\\n           (self.ball[0] == self.width - 1 and self.paddle2 <= self.ball[1] < self.paddle2 + self.paddle_height):\n            self.ball_dir[0] *= -1\n\n    def reset_ball(self):\n        self.ball = [self.width // 2, self.height // 2]\n        self.ball_dir = [random.choice([-1, 1]), random.choice([-1, 1])]\n\n    def move_paddle(self, player, direction):\n        if player == 1:\n            if direction == 'up' and self.paddle1 > 0:\n                self.paddle1 -= 1\n            elif direction == 'down' and self.paddle1 < self.height - self.paddle_height:\n                self.paddle1 += 1\n        else:\n            if direction == 'up' and self.paddle2 > 0:\n                self.paddle2 -= 1\n            elif direction == 'down' and self.paddle2 < self.height - self.paddle_height:\n                self.paddle2 += 1\n\n    def play(self):\n        while True:\n            self.draw()\n            self.update_ball()\n            time.sleep(0.1)\n\n            if self.score1 >= 5 or self.score2 >= 5:\n                print(\"Game Over!\")\n                break\n\n            # Simple input simulation\n            move = random.choice(['up', 'down', None])\n            if move:\n                self.move_paddle(1, move)\n            move = random.choice(['up', 'down', None])\n            if move:\n                self.move_paddle(2, move)\n\nif __name__ == \"__main__\":\n    game = Pong()\n    game.play()\n```",
    "13": "```python\nimport random\nimport os\nimport sys\nimport time\nimport msvcrt\n\nclass Tetris:\n    def __init__(self):\n        self.board = [[' ' for _ in range(10)] for _ in range(20)]\n        self.shapes = [\n            [['#', '#', '#', '#']],  # I\n            [['#', '#', '#'], [' ', '#', ' ']],  # T\n            [['#', '#'], ['#', '#']],  # O\n            [[' ', '#', '#'], ['#', '#', ' ']],  # S\n            [['#', '#', ' '], [' ', '#', '#']],  # Z\n            [['#', ' '], ['#', ' '], ['#', '#']],  # J\n            [[' ', '#'], [' ', '#'], ['#', '#']]   # L\n        ]\n        self.current_shape = None\n        self.current_position = (0, 0)\n        self.score = 0\n        self.game_over = False\n\n    def new_shape(self):\n        self.current_shape = random.choice(self.shapes)\n        self.current_position = (0, len(self.board[0]) // 2 - len(self.current_shape[0]) // 2)\n\n    def rotate_shape(self):\n        self.current_shape = [list(row) for row in zip(*self.current_shape[::-1])]\n\n    def can_move(self, dx, dy):\n        for i, row in enumerate(self.current_shape):\n            for j, cell in enumerate(row):\n                if cell == '#':\n                    x, y = self.current_position[0] + i + dy, self.current_position[1] + j + dx\n                    if x < 0 or x >= len(self.board) or y < 0 or y >= len(self.board[0]) or (y < len(self.board[0]) and self.board[x][y] == '#'):\n                        return False\n        return True\n\n    def merge_shape(self):\n        for i, row in enumerate(self.current_shape):\n            for j, cell in enumerate(row):\n                if cell == '#':\n                    self.board[self.current_position[0] + i][self.current_position[1] + j] = '#'\n\n    def clear_lines(self):\n        cleared_lines = 0\n        for i in range(len(self.board) - 1, -1, -1):\n            if all(cell == '#' for cell in self.board[i]):\n                cleared_lines += 1\n                del self.board[i]\n                self.board.insert(0, [' ' for _ in range(10)])\n        self.score += cleared_lines\n\n    def print_board(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for row in self.board:\n            print('|' + ''.join(row) + '|')\n        print(f'Score: {self.score}')\n        print('Controls: [A] Left, [D] Right, [S] Down, [W] Rotate, [Q] Quit')\n\n    def drop(self):\n        while self.can_move(0, 1):\n            self.current_position = (self.current_position[0] + 1, self.current_position[1])\n            self.print_board()\n            time.sleep(0.5)\n        self.merge_shape()\n        self.clear_lines()\n        self.new_shape()\n        if not self.can_move(0, 0):\n            self.game_over = True\n\n    def play(self):\n        self.new_shape()\n        while not self.game_over:\n            self.print_board()\n            if msvcrt.kbhit():\n                key = msvcrt.getch()\n                if key == b'a' and self.can_move(-1, 0):\n                    self.current_position = (self.current_position[0], self.current_position[1] - 1)\n                elif key == b'd' and self.can_move(1, 0):\n                    self.current_position = (self.current_position[0], self.current_position[1] + 1)\n                elif key == b's' and self.can_move(0, 1):\n                    self.current_position = (self.current_position[0] + 1, self.current_position[1])\n                elif key == b'w':\n                    self.rotate_shape()\n                    if not self.can_move(0, 0):\n                        self.rotate_shape()  # Undo rotate if not valid\n                elif key == b'q':\n                    break\n            self.drop()\n        print(\"Game Over! Your score was:\", self.score)\n\nif __name__ == \"__main__\":\n    game = Tetris()\n    game.play()\n```",
    "14": "```python\nimport random\nimport os\nimport sys\nimport time\nimport math\n\nclass AsteroidGame:\n    def __init__(self):\n        self.width = 40\n        self.height = 20\n        self.player_pos = [self.width // 2, self.height // 2]\n        self.asteroids = []\n        self.score = 0\n        self.game_over = False\n        self.generate_asteroids()\n\n    def generate_asteroids(self, count=5):\n        for _ in range(count):\n            x = random.randint(0, self.width - 1)\n            y = random.randint(0, self.height - 1)\n            self.asteroids.append([x, y])\n\n    def draw(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for y in range(self.height):\n            for x in range(self.width):\n                if [x, y] == self.player_pos:\n                    print('A', end='')\n                elif [x, y] in self.asteroids:\n                    print('*', end='')\n                else:\n                    print(' ', end='')\n            print()\n        print(f'Score: {self.score}')\n\n    def move_player(self, direction):\n        if direction == 'w' and self.player_pos[1] > 0:\n            self.player_pos[1] -= 1\n        elif direction == 's' and self.player_pos[1] < self.height - 1:\n            self.player_pos[1] += 1\n        elif direction == 'a' and self.player_pos[0] > 0:\n            self.player_pos[0] -= 1\n        elif direction == 'd' and self.player_pos[0] < self.width - 1:\n            self.player_pos[0] += 1\n\n    def check_collision(self):\n        if self.player_pos in self.asteroids:\n            self.game_over = True\n\n    def run(self):\n        while not self.game_over:\n            self.draw()\n            command = input('Move (w/a/s/d): ').strip().lower()\n            if command in ['w', 'a', 's', 'd']:\n                self.move_player(command)\n                self.check_collision()\n                self.score += 1\n            else:\n                print('Invalid command!')\n            time.sleep(0.1)\n        \n        print('Game Over! Your score:', self.score)\n\nif __name__ == \"__main__\":\n    game = AsteroidGame()\n    game.run()\n```",
    "15": "```python\nimport random\nimport string\n\nclass Boggle:\n    def __init__(self, size=4):\n        self.size = size\n        self.board = self.generate_board()\n        self.words_found = set()\n        self.dictionary = self.load_dictionary()\n\n    def generate_board(self):\n        letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        return [[random.choice(letters) for _ in range(self.size)] for _ in range(self.size)]\n\n    def load_dictionary(self):\n        # A simple dictionary for demonstration; replace with a comprehensive word list.\n        return set(word.strip().upper() for word in [\n            \"CAT\", \"DOG\", \"COT\", \"BAT\", \"RAT\", \"HAT\", \"HATTER\", \"TAT\", \"AT\", \"TO\", \"TOY\", \"BOG\", \"BOGGLE\"\n        ])\n\n    def display_board(self):\n        for row in self.board:\n            print(' '.join(row))\n        print()\n\n    def is_valid_word(self, word):\n        return word in self.dictionary\n\n    def find_words(self):\n        for row in range(self.size):\n            for col in range(self.size):\n                self.search_word(row, col, \"\", set())\n\n    def search_word(self, row, col, current_word, visited):\n        if (row < 0 or col < 0 or row >= self.size or col >= self.size or\n                (row, col) in visited):\n            return\n        \n        current_word += self.board[row][col]\n        visited.add((row, col))\n\n        if self.is_valid_word(current_word):\n            self.words_found.add(current_word)\n\n        # Explore all 8 directions\n        for r in range(-1, 2):\n            for c in range(-1, 2):\n                if r == 0 and c == 0:\n                    continue\n                self.search_word(row + r, col + c, current_word, visited)\n\n        visited.remove((row, col))\n\n    def play(self):\n        print(\"Welcome to Boggle!\")\n        self.display_board()\n        \n        self.find_words()\n        \n        print(\"Words found:\")\n        for word in sorted(self.words_found):\n            print(word)\n\nif __name__ == \"__main__\":\n    game = Boggle()\n    game.play()\n```",
    "16": "```python\nimport random\nimport os\nimport time\n\nclass PacMan:\n    def __init__(self, width=10, height=10, num_ghosts=2):\n        self.width = width\n        self.height = height\n        self.num_ghosts = num_ghosts\n        self.pacman_pos = [0, 0]\n        self.ghosts = []\n        self.score = 0\n        self.map = [[' ' for _ in range(self.width)] for _ in range(self.height)]\n        self.food_count = 0\n        self.game_over = False\n\n        self.initialize_game()\n\n    def initialize_game(self):\n        for _ in range(self.num_ghosts):\n            ghost_pos = self.random_position()\n            while ghost_pos == self.pacman_pos:\n                ghost_pos = self.random_position()\n            self.ghosts.append(ghost_pos)\n\n        for _ in range(self.width * self.height // 3):\n            food_pos = self.random_position()\n            while food_pos == self.pacman_pos or food_pos in self.ghosts:\n                food_pos = self.random_position()\n            self.map[food_pos[0]][food_pos[1]] = '.'\n            self.food_count += 1\n\n    def random_position(self):\n        return [random.randint(0, self.height - 1), random.randint(0, self.width - 1)]\n\n    def display_map(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for r in range(self.height):\n            for c in range(self.width):\n                if [r, c] == self.pacman_pos:\n                    print('P', end=' ')\n                elif [r, c] in self.ghosts:\n                    print('G', end=' ')\n                else:\n                    print(self.map[r][c], end=' ')\n            print()\n        print(f\"Score: {self.score}\")\n\n    def move_pacman(self, direction):\n        if direction == 'w' and self.pacman_pos[0] > 0:\n            self.pacman_pos[0] -= 1\n        elif direction == 's' and self.pacman_pos[0] < self.height - 1:\n            self.pacman_pos[0] += 1\n        elif direction == 'a' and self.pacman_pos[1] > 0:\n            self.pacman_pos[1] -= 1\n        elif direction == 'd' and self.pacman_pos[1] < self.width - 1:\n            self.pacman_pos[1] += 1\n\n        self.check_collision()\n\n    def check_collision(self):\n        if self.map[self.pacman_pos[0]][self.pacman_pos[1]] == '.':\n            self.score += 1\n            self.map[self.pacman_pos[0]][self.pacman_pos[1]] = ' '\n            self.food_count -= 1\n\n        if self.pacman_pos in self.ghosts:\n            self.game_over = True\n\n    def move_ghosts(self):\n        for i in range(len(self.ghosts)):\n            move = random.choice([[0, 1], [0, -1], [1, 0], [-1, 0]])\n            new_pos = [self.ghosts[i][0] + move[0], self.ghosts[i][1] + move[1]]\n            if 0 <= new_pos[0] < self.height and 0 <= new_pos[1] < self.width:\n                self.ghosts[i] = new_pos\n\n    def play(self):\n        while not self.game_over and self.food_count > 0:\n            self.display_map()\n            direction = input(\"Move (w/a/s/d): \").strip().lower()\n            self.move_pacman(direction)\n            self.move_ghosts()\n            time.sleep(0.5)\n\n        if self.game_over:\n            print(\"Game Over! Final Score:\", self.score)\n        else:\n            print(\"You ate all the food! Final Score:\", self.score)\n\nif __name__ == \"__main__\":\n    game = PacMan()\n    game.play()\n```",
    "17": "```python\nimport random\nimport time\nimport sys\nimport threading\n\nclass DinosaurRunner:\n    def __init__(self):\n        self.dino_pos = 0\n        self.obstacles = []\n        self.score = 0\n        self.game_over = False\n        self.obstacle_interval = 2  # seconds\n        self.game_speed = 0.1  # seconds (delay between game updates)\n\n    def start(self):\n        print(\"Welcome to Dinosaur Runner!\")\n        print(\"Press 'j' to jump and 'q' to quit.\")\n        threading.Thread(target=self.spawn_obstacles).start()\n        self.run_game()\n\n    def spawn_obstacles(self):\n        while not self.game_over:\n            obstacle_pos = random.randint(1, 10)\n            self.obstacles.append(obstacle_pos)\n            time.sleep(self.obstacle_interval)\n\n    def run_game(self):\n        while not self.game_over:\n            self.clear_screen()\n            self.display_game()\n            self.handle_input()\n            self.check_collision()\n            self.score += 1\n            time.sleep(self.game_speed)\n\n    def display_game(self):\n        print(f\"Score: {self.score}\")\n        print(\" \" * self.dino_pos + \"D\")\n        for i in range(1, 11):\n            if i in self.obstacles:\n                print(\" \" * i + \"X\")\n            else:\n                print(\" \" * i + \" \")\n    \n    def handle_input(self):\n        if sys.stdin in select.select([sys.stdin], [], [], 0)[0]:\n            input_char = sys.stdin.read(1)\n            if input_char == 'j':\n                self.jump()\n            elif input_char == 'q':\n                self.game_over = True\n\n    def jump(self):\n        print(\"Jumping!\")\n        time.sleep(0.5)  # simulate jump time\n\n    def check_collision(self):\n        if self.dino_pos in self.obstacles:\n            self.game_over = True\n            print(\"Game Over! Final Score:\", self.score)\n\n    def clear_screen(self):\n        print(\"\\033[H\\033[J\", end=\"\")\n\nif __name__ == \"__main__\":\n    game = DinosaurRunner()\n    game.start()\n```\n\nThis code provides a simple command-line implementation of a Dinosaur Runner game, where you can jump to avoid obstacles. To play, run the code, and use the 'j' key to jump and 'q' to quit."
}