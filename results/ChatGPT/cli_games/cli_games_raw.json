{
    "0": "```python\nclass TicTacToe:\n    def __init__(self):\n        self.board = [' ' for _ in range(9)]  # A list to hold the board state\n        self.current_player = 'X'  # Starting player\n\n    def print_board(self):\n        print(\"\\n\")\n        print(f\" {self.board[0]} | {self.board[1]} | {self.board[2]} \")\n        print(\"---|---|---\")\n        print(f\" {self.board[3]} | {self.board[4]} | {self.board[5]} \")\n        print(\"---|---|---\")\n        print(f\" {self.board[6]} | {self.board[7]} | {self.board[8]} \")\n        print(\"\\n\")\n\n    def is_winner(self):\n        win_conditions = [\n            (0, 1, 2), (3, 4, 5), (6, 7, 8),  # horizontal\n            (0, 3, 6), (1, 4, 7), (2, 5, 8),  # vertical\n            (0, 4, 8), (2, 4, 6)               # diagonal\n        ]\n        for a, b, c in win_conditions:\n            if self.board[a] == self.board[b] == self.board[c] != ' ':\n                return True\n        return False\n\n    def is_draw(self):\n        return ' ' not in self.board\n\n    def make_move(self, position):\n        if self.board[position] == ' ':\n            self.board[position] = self.current_player\n            return True\n        return False\n\n    def switch_player(self):\n        self.current_player = 'O' if self.current_player == 'X' else 'X'\n\n    def play(self):\n        while True:\n            self.print_board()\n            move = input(f\"Player {self.current_player}, enter your move (1-9): \")\n            if move.isdigit() and 1 <= int(move) <= 9:\n                position = int(move) - 1\n                if self.make_move(position):\n                    if self.is_winner():\n                        self.print_board()\n                        print(f\"Player {self.current_player} wins!\")\n                        break\n                    if self.is_draw():\n                        self.print_board()\n                        print(\"It's a draw!\")\n                        break\n                    self.switch_player()\n                else:\n                    print(\"Invalid move. Try again.\")\n            else:\n                print(\"Invalid input. Please enter a number between 1 and 9.\")\n\nif __name__ == \"__main__\":\n    game = TicTacToe()\n    game.play()\n```",
    "1": "```python\nimport random\n\nclass Hangman:\n    def __init__(self):\n        self.words = [\"python\", \"hangman\", \"programming\", \"developer\", \"software\", \"keyboard\", \"interface\", \"challenge\"]\n        self.secret_word = random.choice(self.words)\n        self.guesses = []\n        self.max_attempts = 6\n        self.attempts = 0\n\n    def display_word(self):\n        return ' '.join([letter if letter in self.guesses else '_' for letter in self.secret_word])\n\n    def guess_letter(self, letter):\n        if letter in self.guesses:\n            print(\"You already guessed that letter.\")\n            return False\n        self.guesses.append(letter)\n        if letter not in self.secret_word:\n            self.attempts += 1\n            print(f\"Incorrect guess. You have {self.max_attempts - self.attempts} attempts left.\")\n            return False\n        return True\n\n    def is_won(self):\n        return all(letter in self.guesses for letter in self.secret_word)\n\n    def is_lost(self):\n        return self.attempts >= self.max_attempts\n\n    def play(self):\n        print(\"Welcome to Hangman!\")\n        while not self.is_won() and not self.is_lost():\n            print(\"\\nCurrent word:\", self.display_word())\n            guess = input(\"Guess a letter: \").lower()\n            if len(guess) != 1 or not guess.isalpha():\n                print(\"Please enter a single letter.\")\n                continue\n\n            self.guess_letter(guess)\n\n        if self.is_won():\n            print(\"\\nCongratulations! You've guessed the word:\", self.secret_word)\n        else:\n            print(\"\\nSorry, you've lost. The word was:\", self.secret_word)\n\nif __name__ == \"__main__\":\n    game = Hangman()\n    game.play()\n```\n",
    "2": "```python\nimport random\n\ndef get_user_choice():\n    user_input = input(\"Enter Rock, Paper, or Scissors (or 'quit' to exit): \").strip().lower()\n    if user_input in ['rock', 'paper', 'scissors']:\n        return user_input\n    elif user_input == 'quit':\n        return None\n    else:\n        print(\"Invalid choice. Please try again.\")\n        return get_user_choice()\n\ndef get_computer_choice():\n    return random.choice(['rock', 'paper', 'scissors'])\n\ndef determine_winner(user_choice, computer_choice):\n    if user_choice == computer_choice:\n        return \"It's a tie!\"\n    elif (user_choice == 'rock' and computer_choice == 'scissors') or \\\n         (user_choice == 'paper' and computer_choice == 'rock') or \\\n         (user_choice == 'scissors' and computer_choice == 'paper'):\n        return \"You win!\"\n    else:\n        return \"Computer wins!\"\n\ndef play_game():\n    print(\"Welcome to Rock-Paper-Scissors!\")\n    while True:\n        user_choice = get_user_choice()\n        if user_choice is None:\n            print(\"Thank you for playing!\")\n            break\n        computer_choice = get_computer_choice()\n        print(f\"You chose: {user_choice.capitalize()}\")\n        print(f\"Computer chose: {computer_choice.capitalize()}\")\n        result = determine_winner(user_choice, computer_choice)\n        print(result)\n\nif __name__ == \"__main__\":\n    play_game()\n```",
    "3": "```python\nimport curses\nfrom random import randint\n\n# Initialize the window\nstdscr = curses.initscr()\ncurses.curs_set(0)\nsh, sw = stdscr.getmaxyx()  # get height and width of window\nw = curses.newwin(sh, sw, 0, 0)  # create a new window\nw.keypad(1)  # enable keypad input\nw.timeout(100)  # refresh window every 100 milliseconds\n\n# Initial snake and food positions\nsnk_x = sw // 4\nsnk_y = sh // 2\nsnake = [\n    [snk_y, snk_x],\n    [snk_y, snk_x - 1],\n    [snk_y, snk_x - 2]\n]\nfood = [sh // 2, sw // 2]\nw.addch(int(food[0]), int(food[1]), curses.ACS_PI)\n\n# Game logic variables\nkey = curses.KEY_RIGHT  # initial direction\nscore = 0\n\nwhile True:\n    next_key = w.getch()  # get the next key\n    key = key if next_key == -1 else next_key  # update direction if a key is pressed\n\n    # Calculate new head of the snake\n    new_head = [snake[0][0], snake[0][1]]\n\n    if key == curses.KEY_DOWN:\n        new_head[0] += 1\n    if key == curses.KEY_UP:\n        new_head[0] -= 1\n    if key == curses.KEY_LEFT:\n        new_head[1] -= 1\n    if key == curses.KEY_RIGHT:\n        new_head[1] += 1\n\n    # Insert new head\n    snake.insert(0, new_head)\n\n    # Check if snake has eaten food\n    if snake[0] == food:\n        score += 1\n        food = None\n        while food is None:\n            nf = [\n                randint(1, sh-1),\n                randint(1, sw-1)\n            ]\n            food = nf if nf not in snake else None\n        w.addch(int(food[0]), int(food[1]), curses.ACS_PI)\n    else:\n        # Remove the last segment of the snake\n        tail = snake.pop()\n        w.addch(int(tail[0]), int(tail[1]), ' ')\n\n    # Check for collision with borders or itself\n    if (snake[0][0] in [0, sh] or\n            snake[0][1] in [0, sw] or\n            snake[0] in snake[1:]):\n        curses.endwin()\n        quit()\n\n    # Draw snake\n    w.addch(int(snake[0][0]), int(snake[0][1]), curses.ACS_CKBOARD)\n```\n\nTo run this code, ensure you have a terminal that supports curses and execute it in your Python environment. Use the arrow keys to control the snake.",
    "4": "Here's a full implementation of the Minesweeper game with a command line interface in Python:\n\n```python\nimport random\nimport os\n\nclass Minesweeper:\n    def __init__(self, width, height, mines):\n        self.width = width\n        self.height = height\n        self.mines = mines\n        self.board = [[' ' for _ in range(width)] for _ in range(height)]\n        self.visible = [[' ' for _ in range(width)] for _ in range(height)]\n        self.game_over = False\n        self.place_mines()\n        self.calculate_numbers()\n\n    def place_mines(self):\n        mine_positions = set()\n        while len(mine_positions) < self.mines:\n            position = (random.randint(0, self.height - 1), random.randint(0, self.width - 1))\n            mine_positions.add(position)\n        for (y, x) in mine_positions:\n            self.board[y][x] = '*'\n\n    def calculate_numbers(self):\n        for y in range(self.height):\n            for x in range(self.width):\n                if self.board[y][x] == '*':\n                    continue\n                count = sum(\n                    1 for i in range(-1, 2) for j in range(-1, 2)\n                    if 0 <= y + i < self.height and 0 <= x + j < self.width\n                    and self.board[y + i][x + j] == '*'\n                )\n                self.board[y][x] = str(count) if count > 0 else ' '\n\n    def display_board(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        print(\"Current Board:\")\n        print(\"  \" + \" \".join(str(x) for x in range(self.width)))\n        for y in range(self.height):\n            print(y, \" \".join(self.visible[y]))\n\n    def reveal(self, y, x):\n        if self.board[y][x] == '*':\n            self.game_over = True\n            return\n        self._reveal(y, x)\n\n    def _reveal(self, y, x):\n        if self.visible[y][x] != ' ':\n            return\n        self.visible[y][x] = self.board[y][x]\n        if self.board[y][x] == ' ':\n            for i in range(-1, 2):\n                for j in range(-1, 2):\n                    if 0 <= y + i < self.height and 0 <= x + j < self.width:\n                        self._reveal(y + i, x + j)\n\n    def flag(self, y, x):\n        if self.visible[y][x] == ' ':\n            self.visible[y][x] = 'F'\n        elif self.visible[y][x] == 'F':\n            self.visible[y][x] = ' '\n\n    def is_won(self):\n        return all(\n            self.visible[y][x] != ' ' or self.board[y][x] == '*'\n            for y in range(self.height) for x in range(self.width)\n        )\n\ndef main():\n    width, height, mines = 10, 10, 10\n    game = Minesweeper(width, height, mines)\n\n    while not game.game_over and not game.is_won():\n        game.display_board()\n        user_input = input(\"Enter command (reveal x y / flag x y): \").strip().split()\n        \n        if len(user_input) == 3:\n            command, x, y = user_input\n            x, y = int(x), int(y)\n            if command == 'reveal':\n                game.reveal(y, x)\n            elif command == 'flag':\n                game.flag(y, x)\n\n    game.display_board()\n    if game.game_over:\n        print(\"Game Over! You hit a mine!\")\n    else:\n        print(\"Congratulations! You've",
    "5": "```python\nimport random\n\nclass Mastermind:\n    def __init__(self, code_length=4, max_attempts=10, colors=None):\n        self.code_length = code_length\n        self.max_attempts = max_attempts\n        self.colors = colors if colors else ['R', 'G', 'B', 'Y', 'O', 'P']\n        self.secret_code = self.generate_code()\n\n    def generate_code(self):\n        return [random.choice(self.colors) for _ in range(self.code_length)]\n\n    def evaluate_guess(self, guess):\n        if len(guess) != self.code_length:\n            raise ValueError(f\"Guess must be {self.code_length} characters long.\")\n        \n        correct_position = sum(1 for i in range(self.code_length) if guess[i] == self.secret_code[i])\n        correct_color = sum(min(guess.count(color), self.secret_code.count(color)) for color in set(guess)) - correct_position\n        \n        return correct_position, correct_color\n\n    def play(self):\n        print(\"Welcome to Mastermind!\")\n        print(f\"Guess the secret code composed of {self.code_length} colors from: {', '.join(self.colors)}.\")\n        print(f\"You have {self.max_attempts} attempts to guess the code.\")\n\n        for attempt in range(1, self.max_attempts + 1):\n            guess = input(f\"Attempt {attempt}: Enter your guess: \").upper().strip()\n\n            try:\n                correct_position, correct_color = self.evaluate_guess(guess)\n            except ValueError as e:\n                print(e)\n                continue\n\n            if correct_position == self.code_length:\n                print(\"Congratulations! You've cracked the code!\")\n                break\n            \n            print(f\"Correct color and position: {correct_position}, Correct color but wrong position: {correct_color}\")\n        else:\n            print(f\"Sorry, you've used all attempts. The secret code was: {''.join(self.secret_code)}\")\n\nif __name__ == \"__main__\":\n    game = Mastermind()\n    game.play()\n```",
    "6": "```python\nimport random\n\nclass Battleship:\n    def __init__(self):\n        self.board_size = 5\n        self.board = [['~' for _ in range(self.board_size)] for _ in range(self.board_size)]\n        self.ships = []\n        self.is_game_over = False\n\n    def place_ships(self):\n        for _ in range(3):  # Place 3 ships\n            while True:\n                ship_row = random.randint(0, self.board_size - 1)\n                ship_col = random.randint(0, self.board_size - 1)\n                if (ship_row, ship_col) not in self.ships:\n                    self.ships.append((ship_row, ship_col))\n                    break\n\n    def print_board(self):\n        print(\"  \" + \" \".join(str(i) for i in range(self.board_size)))\n        for idx, row in enumerate(self.board):\n            print(idx, \" \".join(row))\n\n    def make_guess(self, row, col):\n        if (row, col) in self.ships:\n            self.board[row][col] = 'X'\n            self.ships.remove((row, col))\n            print(\"Hit!\")\n        else:\n            self.board[row][col] = 'O'\n            print(\"Miss!\")\n\n        if not self.ships:\n            self.is_game_over = True\n            print(\"Congratulations! You've sunk all the ships!\")\n\n    def get_guess(self):\n        while True:\n            try:\n                guess = input(\"Enter your guess (row and column): \")\n                row, col = map(int, guess.split())\n                if 0 <= row < self.board_size and 0 <= col < self.board_size:\n                    return row, col\n                else:\n                    print(\"Invalid input. Please enter numbers between 0 and 4.\")\n            except ValueError:\n                print(\"Invalid input. Please enter row and column as two integers separated by a space.\")\n\n    def play(self):\n        self.place_ships()\n        print(\"Welcome to Battleship!\")\n        while not self.is_game_over:\n            self.print_board()\n            row, col = self.get_guess()\n            self.make_guess(row, col)\n        self.print_board()\n        print(\"Game Over!\")\n\nif __name__ == \"__main__\":\n    game = Battleship()\n    game.play()\n```",
    "7": "Here's a full implementation of Conway's Game of Life with a command line interface in Python:\n\n```python\nimport numpy as np\nimport os\nimport time\nimport sys\n\nclass GameOfLife:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n        self.grid = np.zeros((height, width), dtype=int)\n\n    def randomize(self, density=0.2):\n        for i in range(self.height):\n            for j in range(self.width):\n                self.grid[i][j] = 1 if np.random.rand() < density else 0\n\n    def update(self):\n        new_grid = self.grid.copy()\n        for i in range(self.height):\n            for j in range(self.width):\n                total = int(\n                    self.grid[i, (j-1) % self.width] + \n                    self.grid[i, (j+1) % self.width] + \n                    self.grid[(i-1) % self.height, j] + \n                    self.grid[(i+1) % self.height, j] + \n                    self.grid[(i-1) % self.height, (j-1) % self.width] + \n                    self.grid[(i-1) % self.height, (j+1) % self.width] + \n                    self.grid[(i+1) % self.height, (j-1) % self.width] + \n                    self.grid[(i+1) % self.height, (j+1) % self.width]\n                )\n\n                if self.grid[i, j] == 1:\n                    if total < 2 or total > 3:\n                        new_grid[i, j] = 0\n                else:\n                    if total == 3:\n                        new_grid[i, j] = 1\n\n        self.grid = new_grid\n\n    def display(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        print(\"\\n\".join(\"\".join(\"█\" if cell else \" \" for cell in row) for row in self.grid))\n\ndef main():\n    width = 40\n    height = 20\n    game = GameOfLife(width, height)\n    game.randomize(density=0.2)\n\n    try:\n        while True:\n            game.display()\n            game.update()\n            time.sleep(0.1)\n    except KeyboardInterrupt:\n        print(\"Game exited.\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nTo run this code, simply copy it into a Python file (e.g., `game_of_life.py`) and execute it in your command line. You can stop the game by pressing `Ctrl+C`.",
    "8": "```python\nimport numpy as np\n\nROWS = 6\nCOLUMNS = 7\nCONNECT = 4\n\nclass ConnectFour:\n    def __init__(self):\n        self.board = np.zeros((ROWS, COLUMNS), int)\n        self.game_over = False\n        self.turn = 0\n\n    def drop_piece(self, column):\n        for row in range(ROWS-1, -1, -1):\n            if self.board[row][column] == 0:\n                self.board[row][column] = 1 if self.turn == 0 else 2\n                break\n\n    def is_valid_location(self, column):\n        return self.board[ROWS-1][column] == 0\n\n    def winning_move(self):\n        for row in range(ROWS):\n            for col in range(COLUMNS - 3):\n                if self.check_line(row, col, 0, 1):\n                    return True\n        for row in range(ROWS - 3):\n            for col in range(COLUMNS):\n                if self.check_line(row, col, 1, 0):\n                    return True\n        for row in range(ROWS - 3):\n            for col in range(COLUMNS - 3):\n                if self.check_line(row, col, 1, 1):\n                    return True\n        for row in range(3, ROWS):\n            for col in range(COLUMNS - 3):\n                if self.check_line(row, col, -1, 1):\n                    return True\n        return False\n\n    def check_line(self, row, col, row_step, col_step):\n        piece = self.board[row][col]\n        if piece == 0:\n            return False\n        for i in range(1, CONNECT):\n            if self.board[row + i * row_step][col + i * col_step] != piece:\n                return False\n        return True\n\n    def print_board(self):\n        print(np.flip(self.board, 0))\n\n    def play(self):\n        while not self.game_over:\n            self.print_board()\n            column = int(input(f\"Player {self.turn + 1}, choose a column (0-6): \"))\n            if self.is_valid_location(column):\n                self.drop_piece(column)\n                if self.winning_move():\n                    self.print_board()\n                    print(f\"Player {self.turn + 1} wins!\")\n                    self.game_over = True\n                self.turn ^= 1\n            else:\n                print(\"Column full or invalid. Try again.\")\n\nif __name__ == '__main__':\n    game = ConnectFour()\n    game.play()\n```",
    "9": "Here's a full implementation of the Blackjack game with a command line interface in Python:\n\n```python\nimport random\n\n# Constants\nSUITS = ['Hearts', 'Diamonds', 'Clubs', 'Spades']\nRANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace']\nVALUES = {\n    '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,\n    'Jack': 10, 'Queen': 10, 'King': 10, 'Ace': 11\n}\n\nclass Card:\n    def __init__(self, suit, rank):\n        self.suit = suit\n        self.rank = rank\n\n    def __str__(self):\n        return f\"{self.rank} of {self.suit}\"\n\nclass Deck:\n    def __init__(self):\n        self.cards = [Card(suit, rank) for suit in SUITS for rank in RANKS]\n        random.shuffle(self.cards)\n\n    def deal(self):\n        return self.cards.pop()\n\nclass Hand:\n    def __init__(self):\n        self.cards = []\n        self.value = 0\n        self.aces = 0\n\n    def add_card(self, card):\n        self.cards.append(card)\n        self.value += VALUES[card.rank]\n        if card.rank == 'Ace':\n            self.aces += 1\n        self.adjust_for_ace()\n\n    def adjust_for_ace(self):\n        while self.value > 21 and self.aces:\n            self.value -= 10\n            self.aces -= 1\n\n    def __str__(self):\n        return ', '.join(str(card) for card in self.cards) + f\" (Value: {self.value})\"\n\nclass BlackjackGame:\n    def __init__(self):\n        self.deck = Deck()\n        self.player_hand = Hand()\n        self.dealer_hand = Hand()\n\n    def initial_deal(self):\n        for _ in range(2):\n            self.player_hand.add_card(self.deck.deal())\n            self.dealer_hand.add_card(self.deck.deal())\n\n    def show_hands(self, reveal_dealer=False):\n        print(f\"Player's Hand: {self.player_hand}\")\n        if reveal_dealer:\n            print(f\"Dealer's Hand: {self.dealer_hand}\")\n        else:\n            print(f\"Dealer's Hand: {self.dealer_hand.cards[0]}, [Hidden]\")\n\n    def player_turn(self):\n        while True:\n            self.show_hands()\n            if self.player_hand.value > 21:\n                print(\"Bust! You lose.\")\n                return False\n            \n            action = input(\"Do you want to [h]it or [s]tand? \").lower()\n            if action == 'h':\n                self.player_hand.add_card(self.deck.deal())\n            elif action == 's':\n                break\n            else:\n                print(\"Invalid input, please choose 'h' or 's'.\")\n\n        return True\n\n    def dealer_turn(self):\n        while self.dealer_hand.value < 17:\n            self.dealer_hand.add_card(self.deck.deal())\n\n    def determine_winner(self):\n        print(\"\\nFinal Hands:\")\n        self.show_hands(reveal_dealer=True)\n\n        if self.dealer_hand.value > 21:\n            print(\"Dealer busts! You win!\")\n        elif self.player_hand.value > self.dealer_hand.value:\n            print(\"You win!\")\n        elif self.player_hand.value < self.dealer_hand.value:\n            print(\"You lose!\")\n        else:\n            print(\"It's a tie!\")\n\ndef main():\n    while True:\n        print(\"Welcome to Blackjack!\")\n       ",
    "10": "Here's a complete implementation of the game Hammurabi with a command line interface in Python:\n\n```python\nimport random\n\nclass Hammurabi:\n    def __init__(self):\n        self.year = 1\n        self.bushels = 100\n        self.population = 100\n        self.land = 100\n        self.plague = False\n        self.famine = False\n        self.harvest_yield = 3\n\n    def print_status(self):\n        print(f\"\\nYear: {self.year}\")\n        print(f\"Bushels: {self.bushels}\")\n        print(f\"Population: {self.population}\")\n        print(f\"Land: {self.land}\")\n        print(f\"Plague: {'Yes' if self.plague else 'No'}\")\n        print(f\"Famine: {'Yes' if self.famine else 'No'}\")\n\n    def plant_crops(self, bushels):\n        if bushels > self.bushels:\n            print(\"You don't have enough bushels!\")\n            return 0\n        self.bushels -= bushels\n        return bushels\n\n    def harvest(self, planted):\n        if planted > self.land:\n            print(\"You can't plant more than the land you have!\")\n            return 0\n        yield_harvest = planted * self.harvest_yield\n        self.bushels += yield_harvest\n        return yield_harvest\n\n    def handle_population_change(self):\n        if self.famine:\n            self.population -= int(self.population * 0.2)\n        if self.plague:\n            self.population -= int(self.population * 0.1)\n\n    def next_year(self):\n        self.year += 1\n        self.handle_population_change()\n        self.check_events()\n\n    def check_events(self):\n        if random.random() < 0.1:  # 10% chance of plague\n            self.plague = True\n        else:\n            self.plague = False\n\n        if random.random() < 0.1:  # 10% chance of famine\n            self.famine = True\n        else:\n            self.famine = False\n\n    def play(self):\n        while self.year <= 10 and self.population > 0:\n            self.print_status()\n            planted = int(input(\"Enter the number of bushels to plant: \"))\n            bushels_used = self.plant_crops(planted)\n            if bushels_used > 0:\n                harvest_yield = self.harvest(bushels_used)\n                print(f\"You harvested {harvest_yield} bushels!\")\n            self.next_year()\n\n        if self.population <= 0:\n            print(\"Your population has died out. You lose!\")\n        else:\n            print(\"Game over! You survived 10 years.\")\n\nif __name__ == \"__main__\":\n    game = Hammurabi()\n    game.play()\n```\n\nYou can run this code in a Python environment. It creates a simple text-based version of the Hammurabi game where the player can plant crops and manage resources over a span of 10 years, facing random events like plague and famine.",
    "11": "```python\nimport random\n\nclass LightsOut:\n    def __init__(self, size=5):\n        self.size = size\n        self.board = self.generate_board()\n\n    def generate_board(self):\n        return [[random.choice([0, 1]) for _ in range(self.size)] for _ in range(self.size)]\n\n    def display_board(self):\n        for row in self.board:\n            print(\" \".join(\"■\" if cell == 1 else \"□\" for cell in row))\n        print()\n\n    def toggle(self, x, y):\n        self.board[x][y] ^= 1  # Toggle the current light\n        # Toggle adjacent lights\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < self.size and 0 <= ny < self.size:\n                self.board[nx][ny] ^= 1\n\n    def is_solved(self):\n        return all(cell == 0 for row in self.board for cell in row)\n\n    def play(self):\n        while not self.is_solved():\n            self.display_board()\n            try:\n                move = input(f\"Enter your move (row and column) or 'q' to quit: \")\n                if move.lower() == 'q':\n                    print(\"Thanks for playing!\")\n                    break\n                x, y = map(int, move.split())\n                if 0 <= x < self.size and 0 <= y < self.size:\n                    self.toggle(x, y)\n                else:\n                    print(\"Invalid move. Please enter valid row and column numbers.\")\n            except (ValueError, IndexError):\n                print(\"Invalid input. Please enter two integers separated by space.\")\n\n        if self.is_solved():\n            print(\"Congratulations! You've turned off all the lights!\")\n\nif __name__ == \"__main__\":\n    game = LightsOut()\n    game.play()\n```",
    "12": "Here is a simple implementation of the classic game Pong using Python with a command-line interface. This version uses the `curses` library for handling the display in the terminal.\n\n```python\nimport curses\nimport time\n\n# Constants\nWINDOW_HEIGHT = 20\nWINDOW_WIDTH = 40\nPADDLE_HEIGHT = 4\nPADDLE_WIDTH = 1\nBALL = 'O'\nPADDLE = '|'\nPADDLE_SPEED = 1\nBALL_SPEED_X = 1\nBALL_SPEED_Y = 1\n\nclass PongGame:\n    def __init__(self, stdscr):\n        self.stdscr = stdscr\n        self.window = curses.newwin(WINDOW_HEIGHT, WINDOW_WIDTH, 0, 0)\n        self.window.keypad(True)\n        self.window.timeout(100)\n        self.paddle1_y = WINDOW_HEIGHT // 2 - PADDLE_HEIGHT // 2\n        self.paddle2_y = WINDOW_HEIGHT // 2 - PADDLE_HEIGHT // 2\n        self.ball_x = WINDOW_WIDTH // 2\n        self.ball_y = WINDOW_HEIGHT // 2\n        self.ball_speed_x = BALL_SPEED_X\n        self.ball_speed_y = BALL_SPEED_Y\n        self.score1 = 0\n        self.score2 = 0\n\n    def draw(self):\n        self.window.clear()\n        # Draw paddles\n        for i in range(PADDLE_HEIGHT):\n            self.window.addch(self.paddle1_y + i, 1, PADDLE)\n            self.window.addch(self.paddle2_y + i, WINDOW_WIDTH - 2, PADDLE)\n        # Draw ball\n        self.window.addch(self.ball_y, self.ball_x, BALL)\n        # Draw scores\n        self.window.addstr(0, 2, f'Score: {self.score1}  {self.score2}')\n        self.window.refresh()\n\n    def update_ball(self):\n        self.ball_x += self.ball_speed_x\n        self.ball_y += self.ball_speed_y\n\n        # Ball collision with paddles\n        if self.ball_x == 2 and self.paddle1_y <= self.ball_y <= self.paddle1_y + PADDLE_HEIGHT - 1:\n            self.ball_speed_x = -self.ball_speed_x\n        elif self.ball_x == WINDOW_WIDTH - 3 and self.paddle2_y <= self.ball_y <= self.paddle2_y + PADDLE_HEIGHT - 1:\n            self.ball_speed_x = -self.ball_speed_x\n\n        # Ball collision with top and bottom\n        if self.ball_y <= 0 or self.ball_y >= WINDOW_HEIGHT - 1:\n            self.ball_speed_y = -self.ball_speed_y\n\n        # Ball out of bounds\n        if self.ball_x <= 0:\n            self.score2 += 1\n            self.reset_ball()\n        elif self.ball_x >= WINDOW_WIDTH - 1:\n            self.score1 += 1\n            self.reset_ball()\n\n    def reset_ball(self):\n        self.ball_x = WINDOW_WIDTH // 2\n        self.ball_y = WINDOW_HEIGHT // 2\n        self.ball_speed_x = BALL_SPEED_X * (-1 if self.score1 > self.score2 else 1)\n        self.ball_speed_y = BALL_SPEED_Y\n\n    def move_paddle(self, paddle, direction):\n        if paddle == 1:\n            if direction == 'up' and self.paddle1_y > 0:\n                self.paddle1_y -= PADDLE_SPEED\n            elif direction == 'down' and self.paddle1_y < WINDOW_HEIGHT - PADDLE_HEIGHT:\n                self.paddle1_y += PADDLE_SPEED\n        elif paddle == 2:\n            if direction == 'up' and self.paddle2_y > 0:\n                self.paddle2_y -= PADDLE_SPEED\n            elif direction == 'down' and self.p",
    "13": "Here's a complete implementation of a simple Tetris game that runs in the command line using Python. This implementation uses the `curses` library for handling the terminal display.\n\n```python\nimport random\nimport curses\n\n# Define the shapes of Tetriminos\nSHAPES = [\n    [[1, 1, 1, 1]],  # I\n    [[1, 1], [1, 1]],  # O\n    [[0, 1, 0], [1, 1, 1]],  # T\n    [[1, 1, 0], [0, 1, 1]],  # S\n    [[0, 1, 1], [1, 1, 0]],  # Z\n    [[1, 1, 1], [1, 0, 0]],  # L\n    [[1, 1, 1], [0, 0, 1]],  # J\n]\n\nclass Tetris:\n    def __init__(self, stdscr):\n        self.stdscr = stdscr\n        self.screen_height = 20\n        self.screen_width = 10\n        self.board = [[0] * self.screen_width for _ in range(self.screen_height)]\n        self.current_piece = None\n        self.current_x = 0\n        self.current_y = 0\n        self.score = 0\n        self.game_over = False\n        self.spawn_piece()\n\n    def draw_board(self):\n        self.stdscr.clear()\n        for y in range(self.screen_height):\n            for x in range(self.screen_width):\n                if self.board[y][x]:\n                    self.stdscr.addstr(y, x, 'X')\n        if self.current_piece:\n            for y, row in enumerate(self.current_piece):\n                for x, cell in enumerate(row):\n                    if cell:\n                        self.stdscr.addstr(self.current_y + y, self.current_x + x, 'X')\n        self.stdscr.addstr(self.screen_height, 0, f'Score: {self.score}')\n        self.stdscr.refresh()\n\n    def spawn_piece(self):\n        self.current_piece = random.choice(SHAPES)\n        self.current_x = self.screen_width // 2 - len(self.current_piece[0]) // 2\n        self.current_y = 0\n        if self.check_collision(self.current_piece, self.current_x, self.current_y):\n            self.game_over = True\n\n    def rotate_piece(self):\n        self.current_piece = [list(row) for row in zip(*self.current_piece[::-1])]\n        if self.check_collision(self.current_piece, self.current_x, self.current_y):\n            self.current_piece = [list(row) for row in zip(*self.current_piece)][::-1]\n\n    def check_collision(self, piece, offset_x, offset_y):\n        for y, row in enumerate(piece):\n            for x, cell in enumerate(row):\n                if cell and (x + offset_x < 0 or x + offset_x >= self.screen_width or\n                             y + offset_y >= self.screen_height or\n                             self.board[y + offset_y][x + offset_x]):\n                    return True\n        return False\n\n    def place_piece(self):\n        for y, row in enumerate(self.current_piece):\n            for x, cell in enumerate(row):\n                if cell:\n                    self.board[y + self.current_y][x + self.current_x] = 1\n        self.clear_lines()\n        self.spawn_piece()\n\n    def clear_lines(self):\n        new_board = [row for row in self.board if any(cell == 0 for cell in row)]\n        lines_cleared = self.screen_height - len(new_board)\n        self.score += lines_cleared\n        new_board = [[0] * self.screen_width for _ in range(lines_cleared)] + new_board\n",
    "14": "Here's a simple implementation of the Asteroids game in Python using a command line interface. This version uses the `curses` library to handle the screen rendering and keyboard input. \n\n```python\nimport curses\nimport random\nimport math\n\n# Constants\nWIDTH = 80\nHEIGHT = 24\nASTEROID_COUNT = 5\nBULLET_COUNT = 5\n\n# Directions\nUP = 1\nDOWN = 2\nLEFT = 3\nRIGHT = 4\n\nclass Game:\n    def __init__(self, stdscr):\n        self.stdscr = stdscr\n        self.player_pos = [WIDTH // 2, HEIGHT // 2]\n        self.player_angle = 0\n        self.bullets = []\n        self.asteroids = []\n        self.score = 0\n        self.running = True\n\n        # Create asteroids\n        for _ in range(ASTEROID_COUNT):\n            self.asteroids.append([random.randint(0, WIDTH-1), random.randint(0, HEIGHT-1)])\n\n    def draw_player(self):\n        x, y = self.player_pos\n        self.stdscr.addstr(y, x, \"A\")\n\n    def draw_asteroids(self):\n        for x, y in self.asteroids:\n            self.stdscr.addstr(y, x, \"O\")\n\n    def draw_bullets(self):\n        for x, y in self.bullets:\n            self.stdscr.addstr(y, x, \"|\")\n\n    def move_bullets(self):\n        for bullet in self.bullets[:]:\n            bullet[0] += int(math.cos(math.radians(self.player_angle)))\n            bullet[1] -= int(math.sin(math.radians(self.player_angle)))\n            if bullet[0] < 0 or bullet[0] >= WIDTH or bullet[1] < 0 or bullet[1] >= HEIGHT:\n                self.bullets.remove(bullet)\n\n    def move_asteroids(self):\n        for asteroid in self.asteroids[:]:\n            asteroid[0] += random.choice([-1, 0, 1])\n            asteroid[1] += random.choice([-1, 0, 1])\n            asteroid[0] = max(0, min(WIDTH - 1, asteroid[0]))\n            asteroid[1] = max(0, min(HEIGHT - 1, asteroid[1]))\n\n    def check_collisions(self):\n        for bullet in self.bullets[:]:\n            for asteroid in self.asteroids[:]:\n                if bullet[0] == asteroid[0] and bullet[1] == asteroid[1]:\n                    self.bullets.remove(bullet)\n                    self.asteroids.remove(asteroid)\n                    self.score += 1\n                    break\n\n    def run(self):\n        self.stdscr.clear()\n        while self.running:\n            self.stdscr.clear()\n            self.draw_player()\n            self.draw_asteroids()\n            self.draw_bullets()\n            self.stdscr.addstr(0, 0, f\"Score: {self.score}\")\n\n            self.move_bullets()\n            self.move_asteroids()\n            self.check_collisions()\n\n            self.stdscr.refresh()\n\n            key = self.stdscr.getch()\n            if key == curses.KEY_UP:\n                self.player_angle = (self.player_angle - 5) % 360\n            elif key == curses.KEY_DOWN:\n                self.player_angle = (self.player_angle + 5) % 360\n            elif key == ord(' '):  # Fire bullet\n                if len(self.bullets) < BULLET_COUNT:\n                    bullet_x = self.player_pos[0] + int(math.cos(math.radians(self.player_angle)))\n                    bullet_y = self.player_pos[1] - int(math.sin(math.radians(self.player_angle)))\n                    self.bullets.append([bullet_x, bullet",
    "15": "Below is a full implementation of the game Boggle with a command line interface in Python:\n\n```python\nimport random\nimport string\nimport itertools\n\nclass Boggle:\n    def __init__(self, size=4):\n        self.size = size\n        self.board = self.generate_board()\n        self.dictionary = self.load_dictionary()\n        self.found_words = set()\n\n    def generate_board(self):\n        letters = [random.choice(string.ascii_uppercase) for _ in range(self.size * self.size)]\n        return [letters[i:i + self.size] for i in range(0, len(letters), self.size)]\n\n    def load_dictionary(self):\n        # A small set of words for demonstration\n        return {\"BAT\", \"TAB\", \"CAT\", \"ACT\", \"COT\", \"DOG\", \"GOD\", \"HAT\", \"HARD\", \"HARDER\", \"ART\", \"CARD\"}\n\n    def display_board(self):\n        for row in self.board:\n            print(\" \".join(row))\n        print()\n\n    def is_valid_word(self, word):\n        return word in self.dictionary\n\n    def find_words(self, word, x, y, visited):\n        if len(word) > 1 and self.is_valid_word(word):\n            self.found_words.add(word)\n        \n        if len(word) >= 16:  # Max length of a word is size squared\n            return\n\n        for dx, dy in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < self.size and 0 <= ny < self.size and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                self.find_words(word + self.board[nx][ny], nx, ny, visited)\n                visited.remove((nx, ny))\n\n    def search_words(self):\n        for x in range(self.size):\n            for y in range(self.size):\n                visited = {(x, y)}\n                self.find_words(self.board[x][y], x, y, visited)\n\n    def play(self):\n        print(\"Welcome to Boggle!\")\n        self.display_board()\n        self.search_words()\n        print(\"Found words:\", self.found_words)\n\nif __name__ == \"__main__\":\n    boggle_game = Boggle()\n    boggle_game.play()\n```\n\n### Instructions to Run:\n1. Copy the code into a Python file (e.g., `boggle.py`).\n2. Run the file using Python 3: `python boggle.py`.\n3. The game will generate a random 4x4 Boggle board and display the found words from the predefined dictionary. \n\nFeel free to expand the dictionary or adjust the board size as needed!",
    "16": "Here's a simple implementation of a text-based version of Pac-Man in Python with a command line interface. This version is quite simplified and focuses on the core mechanics. You can run this code in a Python environment.\n\n```python\nimport random\nimport os\nimport time\n\nclass Game:\n    def __init__(self):\n        self.width = 10\n        self.height = 10\n        self.pacman_pos = [1, 1]\n        self.food_positions = [[random.randint(0, self.height - 1), random.randint(0, self.width - 1)] for _ in range(5)]\n        self.score = 0\n        self.game_over = False\n        self.directions = {\n            'w': [-1, 0],\n            's': [1, 0],\n            'a': [0, -1],\n            'd': [0, 1]\n        }\n\n    def draw_board(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for r in range(self.height):\n            for c in range(self.width):\n                if [r, c] == self.pacman_pos:\n                    print(\"P\", end=\" \")\n                elif [r, c] in self.food_positions:\n                    print(\"F\", end=\" \")\n                else:\n                    print(\".\", end=\" \")\n            print()\n        print(f\"Score: {self.score}\")\n\n    def move_pacman(self, direction):\n        if direction in self.directions:\n            new_pos = [\n                self.pacman_pos[0] + self.directions[direction][0],\n                self.pacman_pos[1] + self.directions[direction][1]\n            ]\n            if 0 <= new_pos[0] < self.height and 0 <= new_pos[1] < self.width:\n                self.pacman_pos = new_pos\n                self.check_food_collision()\n\n    def check_food_collision(self):\n        if self.pacman_pos in self.food_positions:\n            self.food_positions.remove(self.pacman_pos)\n            self.score += 1\n            if not self.food_positions:\n                self.game_over = True\n\n    def play(self):\n        while not self.game_over:\n            self.draw_board()\n            move = input(\"Enter move (w/a/s/d): \").strip().lower()\n            self.move_pacman(move)\n            time.sleep(0.1)\n        print(\"Game Over! Your final score is:\", self.score)\n\nif __name__ == \"__main__\":\n    game = Game()\n    game.play()\n```\n\nThis code creates a simple Pac-Man game where the player can move Pac-Man around a board using the 'w', 'a', 's', and 'd' keys to collect food ('F'). The game ends when all food is collected.",
    "17": "Here is a simple implementation of the Dinosaur Runner game with a command line interface in Python:\n\n```python\nimport random\nimport time\nimport sys\nimport threading\n\nclass DinosaurRunner:\n    def __init__(self):\n        self.score = 0\n        self.is_running = True\n        self.obstacle_position = 50  # Starting position of the obstacle\n        self.dino_position = 0  # Starting position of the Dino\n\n    def jump(self):\n        print(\"Dino jumped!\")\n        time.sleep(0.5)  # Simulating the jump duration\n        print(\"Dino landed.\")\n    \n    def generate_obstacle(self):\n        # Randomly decide if an obstacle should appear\n        if random.choice([True, False]):\n            self.obstacle_position = 50\n            print(\"An obstacle has appeared!\")\n        else:\n            self.obstacle_position = -1  # No obstacle\n\n    def move_dino(self):\n        while self.is_running:\n            if self.obstacle_position != -1:\n                if self.dino_position >= self.obstacle_position:\n                    print(\"Game Over! You hit an obstacle.\")\n                    self.is_running = False\n                    break\n            time.sleep(1)\n            self.score += 1\n            print(f\"Score: {self.score}\")\n\n    def game_loop(self):\n        while self.is_running:\n            self.generate_obstacle()\n            time.sleep(2)  # Generate new obstacles every 2 seconds\n\n    def start_game(self):\n        print(\"Starting Dinosaur Runner Game!\")\n        threading.Thread(target=self.move_dino).start()\n        self.game_loop()\n\n        while self.is_running:\n            command = input(\"Press 'j' to jump or 'q' to quit: \").strip().lower()\n            if command == 'j':\n                self.jump()\n            elif command == 'q':\n                print(\"Quitting the game.\")\n                self.is_running = False\n            else:\n                print(\"Invalid command. Please press 'j' to jump or 'q' to quit.\")\n        \n        print(f\"Final Score: {self.score}\")\n\nif __name__ == \"__main__\":\n    game = DinosaurRunner()\n    game.start_game()\n```\n\nThis code creates a simple command-line Dinosaur Runner game where the player can jump to avoid obstacles. The player's score increases over time, and the game ends if the player hits an obstacle. You can run the code in a Python environment to play the game."
}