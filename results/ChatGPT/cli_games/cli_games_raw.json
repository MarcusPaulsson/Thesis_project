{
    "0": "```python\nclass TicTacToe:\n    def __init__(self):\n        self.board = [' ' for _ in range(9)]  # A list to hold the board state\n        self.current_player = 'X'  # Starting player\n\n    def print_board(self):\n        print(f\"{self.board[0]} | {self.board[1]} | {self.board[2]}\")\n        print(\"--+---+--\")\n        print(f\"{self.board[3]} | {self.board[4]} | {self.board[5]}\")\n        print(\"--+---+--\")\n        print(f\"{self.board[6]} | {self.board[7]} | {self.board[8]}\")\n\n    def is_winner(self):\n        winning_combinations = [\n            (0, 1, 2), (3, 4, 5), (6, 7, 8),  # Horizontal\n            (0, 3, 6), (1, 4, 7), (2, 5, 8),  # Vertical\n            (0, 4, 8), (2, 4, 6)               # Diagonal\n        ]\n        for combo in winning_combinations:\n            if self.board[combo[0]] == self.board[combo[1]] == self.board[combo[2]] != ' ':\n                return True\n        return False\n\n    def is_full(self):\n        return ' ' not in self.board\n\n    def make_move(self, position):\n        if self.board[position] == ' ':\n            self.board[position] = self.current_player\n            return True\n        return False\n\n    def switch_player(self):\n        self.current_player = 'O' if self.current_player == 'X' else 'X'\n\n    def play(self):\n        while True:\n            self.print_board()\n            try:\n                move = int(input(f\"Player {self.current_player}, enter a position (1-9): \")) - 1\n                if move < 0 or move > 8:\n                    print(\"Invalid position! Please enter a number between 1 and 9.\")\n                    continue\n                if not self.make_move(move):\n                    print(\"Position already taken! Try again.\")\n                    continue\n            except ValueError:\n                print(\"Invalid input! Please enter a number between 1 and 9.\")\n                continue\n\n            if self.is_winner():\n                self.print_board()\n                print(f\"Player {self.current_player} wins!\")\n                break\n\n            if self.is_full():\n                self.print_board()\n                print(\"It's a tie!\")\n                break\n\n            self.switch_player()\n\nif __name__ == \"__main__\":\n    game = TicTacToe()\n    game.play()\n```",
    "1": "```python\nimport random\n\nclass Hangman:\n    def __init__(self):\n        self.words = [\"python\", \"hangman\", \"programming\", \"developer\", \"interface\", \"function\"]\n        self.word = random.choice(self.words)\n        self.guesses = []\n        self.max_attempts = 6\n        self.attempts = 0\n\n    def display_word(self):\n        displayed = ''.join([letter if letter in self.guesses else '_' for letter in self.word])\n        print(f\"Word: {displayed}\")\n\n    def get_guess(self):\n        while True:\n            guess = input(\"Enter a letter: \").lower()\n            if len(guess) == 1 and guess.isalpha():\n                if guess in self.guesses:\n                    print(\"You've already guessed that letter.\")\n                else:\n                    return guess\n            else:\n                print(\"Invalid input. Please enter a single letter.\")\n\n    def play(self):\n        print(\"Welcome to Hangman!\")\n        while self.attempts < self.max_attempts:\n            self.display_word()\n            guess = self.get_guess()\n            self.guesses.append(guess)\n\n            if guess not in self.word:\n                self.attempts += 1\n                print(f\"Wrong guess! You have {self.max_attempts - self.attempts} attempts left.\")\n\n            if all(letter in self.guesses for letter in self.word):\n                print(f\"Congratulations! You've guessed the word: {self.word}\")\n                return\n        \n        print(f\"Game over! The word was: {self.word}\")\n\nif __name__ == \"__main__\":\n    game = Hangman()\n    game.play()\n```",
    "2": "```python\nimport random\n\ndef get_user_choice():\n    user_input = input(\"Enter your choice (rock, paper, scissors): \").lower()\n    while user_input not in ['rock', 'paper', 'scissors']:\n        print(\"Invalid choice. Please try again.\")\n        user_input = input(\"Enter your choice (rock, paper, scissors): \").lower()\n    return user_input\n\ndef get_computer_choice():\n    return random.choice(['rock', 'paper', 'scissors'])\n\ndef determine_winner(user_choice, computer_choice):\n    if user_choice == computer_choice:\n        return \"It's a tie!\"\n    elif (user_choice == 'rock' and computer_choice == 'scissors') or \\\n         (user_choice == 'scissors' and computer_choice == 'paper') or \\\n         (user_choice == 'paper' and computer_choice == 'rock'):\n        return \"You win!\"\n    else:\n        return \"You lose!\"\n\ndef play_game():\n    while True:\n        user_choice = get_user_choice()\n        computer_choice = get_computer_choice()\n        print(f\"Computer chose: {computer_choice}\")\n        result = determine_winner(user_choice, computer_choice)\n        print(result)\n\n        play_again = input(\"Do you want to play again? (yes/no): \").lower()\n        if play_again != 'yes':\n            print(\"Thanks for playing!\")\n            break\n\nif __name__ == \"__main__\":\n    play_game()\n```",
    "3": "```python\nimport random\nimport curses\n\n# Initialize the curses module\nstdscr = curses.initscr()\ncurses.curs_set(0)\nsh, sw = stdscr.getmaxyx()  # Get height and width of window\nw = curses.newwin(sh, sw, 0, 0)  # Create a new window\nw.keypad(1)  # Enable keypad input\nw.timeout(100)  # Refresh window every 100 milliseconds\n\n# Initial snake and food positions\nsnk_x = sw // 4\nsnk_y = sh // 2\nsnake = [\n    [snk_y, snk_x],\n    [snk_y, snk_x - 1],\n    [snk_y, snk_x - 2]\n]\nfood = [sh // 2, sw // 2]\nw.addch(int(food[0]), int(food[1]), curses.ACS_PI)\n\nkey = curses.KEY_RIGHT  # Initial direction\n\nwhile True:\n    next_key = w.getch()\n    key = key if next_key == -1 else next_key\n\n    # Calculate new head of the snake\n    new_head = [snake[0][0], snake[0][1]]\n\n    if key == curses.KEY_DOWN:\n        new_head[0] += 1\n    if key == curses.KEY_UP:\n        new_head[0] -= 1\n    if key == curses.KEY_LEFT:\n        new_head[1] -= 1\n    if key == curses.KEY_RIGHT:\n        new_head[1] += 1\n\n    # Check for collision with borders or self\n    if (new_head[0] in [0, sh] or\n        new_head[1] in [0, sw] or\n        new_head in snake):\n        curses.endwin()\n        quit()\n\n    # Insert new head\n    snake.insert(0, new_head)\n\n    # Check if snake has eaten the food\n    if snake[0] == food:\n        food = None\n        while food is None:\n            nf = [\n                random.randint(1, sh - 1),\n                random.randint(1, sw - 1)\n            ]\n            food = nf if nf not in snake else None\n        w.addch(int(food[0]), int(food[1]), curses.ACS_PI)\n    else:\n        # Remove the last segment of the snake\n        tail = snake.pop()\n        w.addch(int(tail[0]), int(tail[1]), ' ')\n\n    # Draw the snake\n    w.addch(int(snake[0][0]), int(snake[0][1]), curses.ACS_CKBOARD)\n```",
    "4": "```python\nimport random\n\nclass Minesweeper:\n    def __init__(self, width, height, mines):\n        self.width = width\n        self.height = height\n        self.mines = mines\n        self.board = self.create_board()\n        self.revealed = [[False] * width for _ in range(height)]\n        self.game_over = False\n\n    def create_board(self):\n        board = [['0'] * self.width for _ in range(self.height)]\n        mine_positions = random.sample(range(self.width * self.height), self.mines)\n\n        for pos in mine_positions:\n            row, col = divmod(pos, self.width)\n            board[row][col] = '*'\n            for r in range(max(0, row - 1), min(self.height, row + 2)):\n                for c in range(max(0, col - 1), min(self.width, col + 2)):\n                    if board[r][c] != '*':\n                        board[r][c] = str(int(board[r][c]) + 1)\n\n        return board\n\n    def reveal(self, row, col):\n        if self.revealed[row][col]:\n            return\n        self.revealed[row][col] = True\n\n        if self.board[row][col] == '*':\n            self.game_over = True\n            return\n        elif self.board[row][col] == '0':\n            for r in range(max(0, row - 1), min(self.height, row + 2)):\n                for c in range(max(0, col - 1), min(self.width, col + 2)):\n                    if not self.revealed[r][c]:\n                        self.reveal(r, c)\n\n    def print_board(self):\n        for r in range(self.height):\n            for c in range(self.width):\n                if self.revealed[r][c]:\n                    print(self.board[r][c], end=' ')\n                else:\n                    print('.', end=' ')\n            print()\n        print()\n\n    def play(self):\n        while not self.game_over:\n            self.print_board()\n            try:\n                row, col = map(int, input(\"Enter row and column to reveal (e.g., 0 1): \").split())\n                if 0 <= row < self.height and 0 <= col < self.width:\n                    self.reveal(row, col)\n                else:\n                    print(\"Invalid input. Please enter valid coordinates.\")\n            except ValueError:\n                print(\"Invalid input. Please enter two integers.\")\n\n        print(\"Game Over! You hit a mine.\")\n        self.print_board()\n\nif __name__ == \"__main__\":\n    width = 10\n    height = 10\n    mines = 10\n    game = Minesweeper(width, height, mines)\n    game.play()\n```",
    "5": "```python\nimport random\n\nclass Mastermind:\n    def __init__(self, code_length=4, max_attempts=10):\n        self.code_length = code_length\n        self.max_attempts = max_attempts\n        self.code = self.generate_code()\n        self.attempts = 0\n\n    def generate_code(self):\n        return [random.randint(0, 9) for _ in range(self.code_length)]\n\n    def get_feedback(self, guess):\n        correct_position = sum(1 for i in range(self.code_length) if guess[i] == self.code[i])\n        correct_color = sum(min(guess.count(n), self.code.count(n)) for n in set(guess)) - correct_position\n        return correct_position, correct_color\n\n    def play(self):\n        print(\"Welcome to Mastermind!\")\n        print(f\"Guess the {self.code_length}-digit code. You have {self.max_attempts} attempts.\")\n\n        while self.attempts < self.max_attempts:\n            guess = input(f\"Attempt {self.attempts + 1}: Enter your guess (4 digits, 0-9): \")\n            if not guess.isdigit() or len(guess) != self.code_length:\n                print(\"Invalid input. Please enter exactly 4 digits.\")\n                continue\n\n            guess = list(map(int, guess))\n            self.attempts += 1\n            correct_position, correct_color = self.get_feedback(guess)\n\n            if correct_position == self.code_length:\n                print(f\"Congratulations! You've guessed the code: {''.join(map(str, self.code))}\")\n                return\n\n            print(f\"Feedback: {correct_position} correct position(s), {correct_color} correct color(s)\")\n\n        print(f\"Sorry! You've used all attempts. The code was: {''.join(map(str, self.code))}\")\n\nif __name__ == \"__main__\":\n    game = Mastermind()\n    game.play()\n```",
    "6": "```python\nimport random\n\nclass Ship:\n    def __init__(self, size):\n        self.size = size\n        self.hits = 0\n\n    def hit(self):\n        self.hits += 1\n\n    def is_sunk(self):\n        return self.hits >= self.size\n\n\nclass Board:\n    def __init__(self, size):\n        self.size = size\n        self.board = [[' ' for _ in range(size)] for _ in range(size)]\n        self.ships = []\n\n    def place_ship(self, ship, x, y, orientation):\n        if orientation == 'H':\n            for i in range(ship.size):\n                self.board[x][y + i] = 'S'\n        else:\n            for i in range(ship.size):\n                self.board[x + i][y] = 'S'\n        self.ships.append(ship)\n\n    def display(self, show_ships=False):\n        print(\"  \" + \" \".join(str(i) for i in range(self.size)))\n        for i in range(self.size):\n            row = str(i) + \" \"\n            for j in range(self.size):\n                cell = self.board[i][j]\n                if cell == 'S' and not show_ships:\n                    row += '. '\n                else:\n                    row += cell + ' '\n            print(row)\n\n    def attack(self, x, y):\n        if self.board[x][y] == 'S':\n            self.board[x][y] = 'H'\n            for ship in self.ships:\n                if ship.size > 0:\n                    ship.hit()\n                    return True\n        else:\n            self.board[x][y] = 'M'\n        return False\n\n    def all_sunk(self):\n        return all(ship.is_sunk() for ship in self.ships)\n\n\nclass Game:\n    def __init__(self, size=5):\n        self.board = Board(size)\n        self.setup()\n\n    def setup(self):\n        ship_sizes = [2, 3]\n        for size in ship_sizes:\n            placed = False\n            while not placed:\n                x = random.randint(0, self.board.size - 1)\n                y = random.randint(0, self.board.size - 1)\n                orientation = random.choice(['H', 'V'])\n                if self.can_place_ship(x, y, size, orientation):\n                    self.board.place_ship(Ship(size), x, y, orientation)\n                    placed = True\n\n    def can_place_ship(self, x, y, size, orientation):\n        if orientation == 'H':\n            if y + size > self.board.size:\n                return False\n            return all(self.board.board[x][y + i] == ' ' for i in range(size))\n        else:\n            if x + size > self.board.size:\n                return False\n            return all(self.board.board[x + i][y] == ' ' for i in range(size))\n\n    def play(self):\n        while True:\n            self.board.display()\n            try:\n                x = int(input(\"Enter row (0-{}): \".format(self.board.size - 1)))\n                y = int(input(\"Enter column (0-{}): \".format(self.board.size - 1)))\n                if self.board.attack(x, y):\n                    print(\"Hit!\")\n                else:\n                    print(\"Miss!\")\n            except (ValueError, IndexError):\n                print(\"Invalid input. Please try again.\")\n                continue\n\n            if self.board.all_sunk():\n                print(\"All ships sunk! You win!\")\n                self.board.display(show_ships=True)\n                break\n\n\nif __name__ == '__main__':\n    game = Game(size=5)\n    game.play()\n```",
    "7": "```python\nimport os\nimport time\nimport random\n\nclass GameOfLife:\n    def __init__(self, width=20, height=20):\n        self.width = width\n        self.height = height\n        self.board = self.create_board()\n\n    def create_board(self):\n        return [[random.choice([0, 1]) for _ in range(self.width)] for _ in range(self.height)]\n\n    def print_board(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for row in self.board:\n            print(' '.join(['█' if cell else ' ' for cell in row]))\n        print(\"\\nPress Ctrl+C to stop.\")\n\n    def update_board(self):\n        new_board = [[0] * self.width for _ in range(self.height)]\n        for y in range(self.height):\n            for x in range(self.width):\n                alive_neighbors = self.count_alive_neighbors(x, y)\n                if self.board[y][x] == 1:\n                    new_board[y][x] = 1 if alive_neighbors in (2, 3) else 0\n                else:\n                    new_board[y][x] = 1 if alive_neighbors == 3 else 0\n        self.board = new_board\n\n    def count_alive_neighbors(self, x, y):\n        alive_neighbors = 0\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                if i == 0 and j == 0:\n                    continue\n                nx, ny = x + i, y + j\n                if 0 <= nx < self.width and 0 <= ny < self.height:\n                    alive_neighbors += self.board[ny][nx]\n        return alive_neighbors\n\n    def run(self):\n        try:\n            while True:\n                self.print_board()\n                self.update_board()\n                time.sleep(0.5)\n        except KeyboardInterrupt:\n            print(\"\\nGame Over!\")\n\nif __name__ == \"__main__\":\n    game = GameOfLife()\n    game.run()\n```",
    "8": "```python\nimport numpy as np\n\nROWS = 6\nCOLUMNS = 7\nEMPTY = 0\nPLAYER1 = 1\nPLAYER2 = 2\n\ndef create_board():\n    return np.zeros((ROWS, COLUMNS), dtype=int)\n\ndef print_board(board):\n    for row in board:\n        print(\" | \".join(str(int(cell)) for cell in row))\n        print(\"-\" * (COLUMNS * 4 - 3))\n\ndef is_valid_location(board, col):\n    return board[ROWS - 1][col] == EMPTY\n\ndef get_next_open_row(board, col):\n    for r in range(ROWS):\n        if board[r][col] == EMPTY:\n            return r\n\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\ndef winning_move(board, piece):\n    # Check horizontal locations\n    for c in range(COLUMNS - 3):\n        for r in range(ROWS):\n            if all(board[r][c + i] == piece for i in range(4)):\n                return True\n\n    # Check vertical locations\n    for c in range(COLUMNS):\n        for r in range(ROWS - 3):\n            if all(board[r + i][c] == piece for i in range(4)):\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLUMNS - 3):\n        for r in range(ROWS - 3):\n            if all(board[r + i][c + i] == piece for i in range(4)):\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLUMNS - 3):\n        for r in range(3, ROWS):\n            if all(board[r - i][c + i] == piece for i in range(4)):\n                return True\n\n    return False\n\ndef main():\n    board = create_board()\n    game_over = False\n    turn = 0\n\n    print(\"Welcome to Connect Four!\")\n    print_board(board)\n\n    while not game_over:\n        col = int(input(f\"Player {turn % 2 + 1}, make your selection (0-{COLUMNS - 1}): \"))\n\n        if is_valid_location(board, col):\n            row = get_next_open_row(board, col)\n            drop_piece(board, row, col, PLAYER1 if turn % 2 == 0 else PLAYER2)\n\n            print_board(board)\n\n            if winning_move(board, PLAYER1 if turn % 2 == 0 else PLAYER2):\n                print(f\"Player {turn % 2 + 1} wins!\")\n                game_over = True\n\n            turn += 1\n\nif __name__ == \"__main__\":\n    main()\n```",
    "9": "```python\nimport random\n\n# Card values\nVALUES = {\n    '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,\n    '10': 10, 'J': 10, 'Q': 10, 'K': 10, 'A': 11\n}\n\n# Card deck\nSUITS = ['Hearts', 'Diamonds', 'Clubs', 'Spades']\nRANKS = list(VALUES.keys())\nDECK = [(rank, suit) for rank in RANKS for suit in SUITS]\n\ndef calculate_hand_value(hand):\n    value = sum(VALUES[card[0]] for card in hand)\n    # Adjust for Aces\n    aces = sum(1 for card in hand if card[0] == 'A')\n    while value > 21 and aces:\n        value -= 10\n        aces -= 1\n    return value\n\ndef deal_card(deck):\n    return deck.pop(random.randint(0, len(deck) - 1))\n\ndef display_hand(hand, hide_first_card=False):\n    if hide_first_card:\n        return \"[Hidden Card], \" + \", \".join(f\"{rank} of {suit}\" for rank, suit in hand[1:])\n    return \", \".join(f\"{rank} of {suit}\" for rank, suit in hand)\n\ndef blackjack():\n    print(\"Welcome to Blackjack!\")\n    deck = DECK.copy()\n    random.shuffle(deck)\n\n    player_hand = [deal_card(deck), deal_card(deck)]\n    dealer_hand = [deal_card(deck), deal_card(deck)]\n\n    # Player's turn\n    while True:\n        print(f\"Your hand: {display_hand(player_hand)} (Value: {calculate_hand_value(player_hand)})\")\n        print(f\"Dealer's hand: {display_hand(dealer_hand, hide_first_card=True)}\")\n        \n        if calculate_hand_value(player_hand) == 21:\n            print(\"Blackjack! You win!\")\n            return\n        elif calculate_hand_value(player_hand) > 21:\n            print(\"Bust! You lose.\")\n            return\n\n        action = input(\"Do you want to (h)it or (s)tand? \").strip().lower()\n        if action == 'h':\n            player_hand.append(deal_card(deck))\n        elif action == 's':\n            break\n\n    # Dealer's turn\n    while calculate_hand_value(dealer_hand) < 17:\n        dealer_hand.append(deal_card(deck))\n\n    # Final results\n    print(f\"Your hand: {display_hand(player_hand)} (Value: {calculate_hand_value(player_hand)})\")\n    print(f\"Dealer's hand: {display_hand(dealer_hand)} (Value: {calculate_hand_value(dealer_hand)})\")\n\n    player_value = calculate_hand_value(player_hand)\n    dealer_value = calculate_hand_value(dealer_hand)\n\n    if dealer_value > 21 or player_value > dealer_value:\n        print(\"You win!\")\n    elif player_value < dealer_value:\n        print(\"You lose.\")\n    else:\n        print(\"It's a tie!\")\n\nif __name__ == \"__main__\":\n    blackjack()\n```",
    "10": "```python\nimport random\n\nclass HammurabiGame:\n    def __init__(self):\n        self.year = 1\n        self.bushels = 100\n        self.population = 100\n        self.land = 100\n        self.plague_years = 0\n        self.harvest_yield = 3\n        self.rats = 0\n        self.famine_years = 0\n\n    def display_status(self):\n        print(f\"\\nYear: {self.year}\")\n        print(f\"Bushels: {self.bushels}\")\n        print(f\"Population: {self.population}\")\n        print(f\"Land: {self.land}\")\n        print(f\"Plague Years: {self.plague_years}\")\n        print(f\"Rats: {self.rats}\")\n        print(f\"Famine Years: {self.famine_years}\\n\")\n\n    def harvest(self):\n        if self.land > 0:\n            yield_harvest = self.land * self.harvest_yield\n            self.bushels += yield_harvest\n            print(f\"You harvested {yield_harvest} bushels.\")\n        else:\n            print(\"You have no land to harvest.\")\n\n    def feed_population(self, bushels_to_feed):\n        if bushels_to_feed > self.bushels:\n            print(\"Not enough bushels to feed the population!\")\n            self.population -= self.population // 10  # Lose 10% of population\n        else:\n            self.bushels -= bushels_to_feed\n\n    def plant_crops(self, acres):\n        if acres > self.bushels:\n            print(\"Not enough bushels to plant crops!\")\n        else:\n            self.bushels -= acres\n            self.land += acres\n            print(f\"You planted {acres} acres of crops.\")\n\n    def random_events(self):\n        event = random.choice(['plague', 'rats', 'famine', 'none'])\n        if event == 'plague':\n            self.plague_years += 1\n            self.population -= self.population // 2  # Population cut by half\n            print(\"A plague has struck! Half of your population has died.\")\n        elif event == 'rats':\n            self.rats = random.randint(1, 30)\n            self.bushels -= self.rats\n            if self.bushels < 0:\n                self.bushels = 0\n            print(f\"Rats have eaten {self.rats} bushels!\")\n        elif event == 'famine':\n            self.famine_years += 1\n            self.population -= self.population // 5  # Population cut by 20%\n            print(\"A famine has occurred! Your population suffers.\")\n\n    def play(self):\n        while self.year <= 10 and self.population > 0:\n            self.display_status()\n            print(\"Actions: 1) Harvest, 2) Feed population, 3) Plant crops\")\n            action = input(\"Choose an action (1/2/3): \")\n\n            if action == '1':\n                self.harvest()\n            elif action == '2':\n                bushels_to_feed = int(input(\"Enter bushels to feed the population: \"))\n                self.feed_population(bushels_to_feed)\n            elif action == '3':\n                acres = int(input(\"Enter acres to plant: \"))\n                self.plant_crops(acres)\n            else:\n                print(\"Invalid action. Try again.\")\n\n            self.random_events()\n            self.year += 1\n\n        self.end_game()\n\n    def end_game(self):\n        print(\"\\nGame Over\")\n        if self.population <= 0:\n            print(\"Your civilization has perished.\")\n        else:\n            print(\"You survived for 10 years. Well done!\")\n\nif __name__ == \"__main__\":\n    game = HammurabiGame()\n    game.play()\n```",
    "11": "```python\nimport random\n\nclass LightsOut:\n    def __init__(self, size=5):\n        self.size = size\n        self.board = self.generate_board()\n\n    def generate_board(self):\n        return [[random.choice([0, 1]) for _ in range(self.size)] for _ in range(self.size)]\n\n    def display_board(self):\n        for row in self.board:\n            print(\" \".join(['O' if cell == 1 else '.' for cell in row]))\n        print()\n\n    def toggle(self, x, y):\n        if 0 <= x < self.size and 0 <= y < self.size:\n            self.board[x][y] ^= 1  # Toggle the light\n            # Toggle adjacent lights\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                self.toggle(x + dx, y + dy)\n\n    def is_solved(self):\n        return all(cell == 0 for row in self.board for cell in row)\n\n    def play(self):\n        while not self.is_solved():\n            self.display_board()\n            try:\n                x, y = map(int, input(\"Enter row and column to toggle (e.g., '1 2'): \").split())\n                self.toggle(x, y)\n            except (ValueError, IndexError):\n                print(\"Invalid input, please enter valid row and column numbers.\")\n        print(\"Congratulations! You solved the puzzle!\")\n\nif __name__ == \"__main__\":\n    game = LightsOut()\n    game.play()\n```",
    "12": "```python\nimport os\nimport sys\nimport time\nimport keyboard\n\n# Constants\nWIDTH = 40\nHEIGHT = 20\nPADDLE_HEIGHT = 4\nBALL_CHAR = 'O'\nPADDLE_CHAR = '|'\nEMPTY_CHAR = ' '\n\n# Game state\nball_x = WIDTH // 2\nball_y = HEIGHT // 2\nball_dx = 1\nball_dy = 1\npaddle_left_y = (HEIGHT // 2) - (PADDLE_HEIGHT // 2)\npaddle_right_y = (HEIGHT // 2) - (PADDLE_HEIGHT // 2)\n\ndef draw():\n    os.system('cls' if os.name == 'nt' else 'clear')\n    for y in range(HEIGHT):\n        for x in range(WIDTH):\n            if x == 0 and paddle_left_y <= y < paddle_left_y + PADDLE_HEIGHT:\n                print(PADDLE_CHAR, end='')\n            elif x == WIDTH - 1 and paddle_right_y <= y < paddle_right_y + PADDLE_HEIGHT:\n                print(PADDLE_CHAR, end='')\n            elif x == ball_x and y == ball_y:\n                print(BALL_CHAR, end='')\n            else:\n                print(EMPTY_CHAR, end='')\n        print()\n    print(\"Use 'w' and 's' to move left paddle, 'i' and 'k' to move right paddle. Press 'q' to quit.\")\n\ndef update():\n    global ball_x, ball_y, ball_dx, ball_dy, paddle_left_y, paddle_right_y\n    \n    # Move the ball\n    ball_x += ball_dx\n    ball_y += ball_dy\n\n    # Ball collision with top and bottom walls\n    if ball_y <= 0 or ball_y >= HEIGHT - 1:\n        ball_dy *= -1\n\n    # Ball collision with paddles\n    if ball_x == 0 and paddle_left_y <= ball_y < paddle_left_y + PADDLE_HEIGHT:\n        ball_dx *= -1\n    elif ball_x == WIDTH - 1 and paddle_right_y <= ball_y < paddle_right_y + PADDLE_HEIGHT:\n        ball_dx *= -1\n\n    # Reset ball if it goes out of bounds\n    if ball_x < 0 or ball_x >= WIDTH:\n        ball_x = WIDTH // 2\n        ball_y = HEIGHT // 2\n        ball_dx = 1 if ball_dx > 0 else -1\n        ball_dy = 1 if ball_dy > 0 else -1\n\ndef handle_input():\n    global paddle_left_y, paddle_right_y\n    if keyboard.is_pressed('w') and paddle_left_y > 0:\n        paddle_left_y -= 1\n    if keyboard.is_pressed('s') and paddle_left_y < HEIGHT - PADDLE_HEIGHT:\n        paddle_left_y += 1\n    if keyboard.is_pressed('i') and paddle_right_y > 0:\n        paddle_right_y -= 1\n    if keyboard.is_pressed('k') and paddle_right_y < HEIGHT - PADDLE_HEIGHT:\n        paddle_right_y += 1\n    if keyboard.is_pressed('q'):\n        sys.exit()\n\ndef main():\n    while True:\n        handle_input()\n        update()\n        draw()\n        time.sleep(0.1)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "13": "```python\nimport random\nimport sys\nimport os\nimport time\nimport threading\n\n# Constants\nBOARD_WIDTH = 10\nBOARD_HEIGHT = 20\nSHAPES = [\n    [['.....',\n      '.....',\n      '..X..',\n      '.....',\n      '.....'],\n     ['.....',\n      '.....',\n      '..X..',\n      '.....',\n      '.....']],\n    \n    [['.....',\n      '.....',\n      '..X..',\n      '..X..',\n      '.....'],\n     ['.....',\n      '.....',\n      '..XX.',\n      '.....',\n      '.....']],\n    \n    [['.....',\n      '.....',\n      '.XX..',\n      '..X..',\n      '.....'],\n     ['.....',\n      '..X..',\n      '..XX.',\n      '.....',\n      '.....']],\n\n    [['.....',\n      '.....',\n      'XX...',\n      '.....',\n      '.....'],\n     ['.....',\n      '.X...',\n      '.XX..',\n      '.....',\n      '.....']],\n    \n    [['.....',\n      '.....',\n      '.X...',\n      '.X...',\n      '.....'],\n     ['.....',\n      '..XX.',\n      '.....',\n      '.....',\n      '.....']],\n    \n    [['.....',\n      '.....',\n      'X....',\n      'X....',\n      '.....'],\n     ['.....',\n      '.....',\n      'XXX..',\n      '.....',\n      '.....']],\n    \n    [['.....',\n      '.....',\n      '..X..',\n      '..X..',\n      '.....'],\n     ['.....',\n      '.XX..',\n      '.....',\n      '.....',\n      '.....']]\n]\n\nclass Tetris:\n    def __init__(self):\n        self.board = [['.' for _ in range(BOARD_WIDTH)] for _ in range(BOARD_HEIGHT)]\n        self.current_piece = self.new_piece()\n        self.current_x = BOARD_WIDTH // 2 - 1\n        self.current_y = 0\n        self.game_over = False\n        self.score = 0\n\n    def new_piece(self):\n        return random.choice(SHAPES)\n\n    def rotate_piece(self):\n        self.current_piece = self.current_piece[1:] + self.current_piece[:1]\n\n    def valid_position(self, dx=0, dy=0):\n        for y, row in enumerate(self.current_piece[0]):\n            for x, cell in enumerate(row):\n                if cell == 'X':\n                    new_x = self.current_x + x + dx\n                    new_y = self.current_y + y + dy\n                    if new_x < 0 or new_x >= BOARD_WIDTH or new_y >= BOARD_HEIGHT:\n                        return False\n                    if new_y >= 0 and self.board[new_y][new_x] == 'X':\n                        return False\n        return True\n\n    def merge_piece(self):\n        for y, row in enumerate(self.current_piece[0]):\n            for x, cell in enumerate(row):\n                if cell == 'X':\n                    self.board[self.current_y + y][self.current_x + x] = 'X'\n\n    def clear_lines(self):\n        lines_to_clear = [i for i, row in enumerate(self.board) if all(cell == 'X' for cell in row)]\n        for i in lines_to_clear:\n            self.board.pop(i)\n            self.board.insert(0, ['.' for _ in range(BOARD_WIDTH)])\n        self.score += len(lines_to_clear)\n\n    def drop_piece(self):\n        if self.valid_position(dy=1):\n            self.current_y += 1\n        else:\n            self.merge_piece()\n            self.clear_lines()\n            self.current_piece = self.new_piece()\n            self.current_x = BOARD_WIDTH // 2 - 1\n            self.current_y = 0\n            if not self.valid_position():\n                self.game_over = True\n\n    def print_board(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        print(f\"Score: {self.score}\")\n        for row in self.board:\n            print(' '.join(row))\n        print()\n\ndef game_loop(game):\n    while not game.game_over:\n        game.drop_piece()\n        game.print_board()\n        time.sleep(0.5)\n\ndef main():\n    game = Tetris()\n    threading.Thread(target=game_loop, args=(game,), daemon=True).start()\n    \n    while not game.game_over:\n        command = input(\"Enter command (a: left, d: right, s: down, r: rotate, q: quit): \").strip()\n        if command == 'a':\n            if game.valid_position(dx=-1):\n                game.current_x -= 1\n        elif command == 'd':\n            if game.valid_position(dx=1):\n                game.current_x += 1\n        elif command == 's':\n            game.drop_piece()\n        elif command == 'r':\n            game.rotate_piece()\n            if not game.valid_position():\n                game.rotate_piece()\n        elif command == 'q':\n            game.game_over = True\n\n    print(\"Game Over! Your score was:\", game.score)\n\nif __name__ == '__main__':\n    main()\n```\n",
    "14": "Sure! Below is a simple implementation of the Asteroids game in Python using the command line interface. It utilizes the `curses` module for handling user inputs and screen rendering.\n\n```python\nimport curses\nimport random\nimport math\n\n# Constants\nWIDTH = 80\nHEIGHT = 24\nASTEROID_COUNT = 5\nASTEROID_SYMBOL = '*'\nSHIP_SYMBOL = 'A'\n\nclass Asteroid:\n    def __init__(self):\n        self.x = random.randint(0, WIDTH - 1)\n        self.y = random.randint(0, HEIGHT - 1)\n        self.dx = random.choice([-1, 1])\n        self.dy = random.choice([-1, 1])\n\n    def move(self):\n        self.x += self.dx\n        self.y += self.dy\n        if self.x <= 0 or self.x >= WIDTH - 1:\n            self.dx *= -1\n        if self.y <= 0 or self.y >= HEIGHT - 1:\n            self.dy *= -1\n\nclass Ship:\n    def __init__(self):\n        self.x = WIDTH // 2\n        self.y = HEIGHT // 2\n        self.angle = 0\n\n    def turn_left(self):\n        self.angle -= 5\n\n    def turn_right(self):\n        self.angle += 5\n\n    def move(self):\n        rad = math.radians(self.angle)\n        self.x += int(math.cos(rad))\n        self.y += int(math.sin(rad))\n        self.x %= WIDTH\n        self.y %= HEIGHT\n\ndef draw_window(stdscr, ship, asteroids):\n    stdscr.clear()\n    stdscr.addstr(ship.y, ship.x, SHIP_SYMBOL)\n    for asteroid in asteroids:\n        stdscr.addstr(asteroid.y, asteroid.x, ASTEROID_SYMBOL)\n    stdscr.refresh()\n\ndef main(stdscr):\n    curses.curs_set(0)\n    stdscr.nodelay(1)\n    stdscr.timeout(100)\n\n    ship = Ship()\n    asteroids = [Asteroid() for _ in range(ASTEROID_COUNT)]\n\n    while True:\n        draw_window(stdscr, ship, asteroids)\n\n        key = stdscr.getch()\n        if key == curses.KEY_LEFT:\n            ship.turn_left()\n        elif key == curses.KEY_RIGHT:\n            ship.turn_right()\n        elif key == ord('w'):\n            ship.move()\n        elif key == ord('q'):\n            break\n\n        for asteroid in asteroids:\n            asteroid.move()\n\ncurses.wrapper(main)\n```\n\nTo run the game, save this code in a file named `asteroids.py`, and execute it in a terminal that supports `curses`. Use the left and right arrow keys to turn the ship and 'w' to move forward. Press 'q' to exit the game.",
    "15": "```python\nimport random\nimport string\nimport time\n\nclass Boggle:\n    def __init__(self, size=4):\n        self.size = size\n        self.board = self.generate_board()\n        self.words_found = set()\n        self.dictionary = self.load_dictionary()\n\n    def generate_board(self):\n        letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        return [[random.choice(letters) for _ in range(self.size)] for _ in range(self.size)]\n\n    def load_dictionary(self):\n        with open('dictionary.txt', 'r') as file:\n            return set(word.strip().upper() for word in file)\n\n    def display_board(self):\n        for row in self.board:\n            print(' '.join(row))\n        print()\n\n    def is_valid_word(self, word):\n        return word in self.dictionary\n\n    def find_words(self, word, x, y, visited):\n        if not self.is_valid_word(word):\n            return False\n        \n        if word in self.words_found:\n            return False\n        \n        self.words_found.add(word)\n        return True\n\n    def search_word(self, word, x, y, visited):\n        if (x, y) in visited:\n            return\n        \n        visited.add((x, y))\n        word += self.board[x][y]\n\n        if self.find_words(word, x, y, visited):\n            print(f\"Found: {word}\")\n\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if 0 <= x + dx < self.size and 0 <= y + dy < self.size:\n                    self.search_word(word, x + dx, y + dy, visited)\n\n        visited.remove((x, y))\n\n    def play(self):\n        print(\"Welcome to Boggle!\")\n        self.display_board()\n        start_time = time.time()\n        duration = 180  # 3 minutes\n\n        while time.time() - start_time < duration:\n            word = input(\"Enter a word (or 'exit' to quit): \").strip().upper()\n            if word == 'EXIT':\n                break\n            if self.is_valid_word(word):\n                self.search_word('', 0, 0, set())\n            else:\n                print(\"Invalid word or not found on the board.\")\n\n        print(\"Game over!\")\n        print(\"Words found:\", self.words_found)\n\nif __name__ == \"__main__\":\n    game = Boggle()\n    game.play()\n```\n\nMake sure you have a file named `dictionary.txt` in the same directory as this script, containing valid words (one per line).",
    "16": "Creating a full implementation of the game Pac-Man in a command line interface is quite extensive. Below is a simplified version of a text-based Pac-Man game in Python. Note that this implementation does not include advanced features and graphics, as it's meant for a command line interface.\n\n```python\nimport random\nimport os\nimport time\n\n# Constants\nWALL = '#'\nSPACE = ' '\nPACMAN = 'P'\nDOT = '.'\nGHOST = 'G'\nWIDTH = 10\nHEIGHT = 10\nNUM_GHOSTS = 2\nNUM_DOTS = 10\n\nclass Game:\n    def __init__(self):\n        self.board = self.create_board()\n        self.pacman_position = (0, 0)\n        self.score = 0\n        self.ghosts = self.place_ghosts()\n        self.game_over = False\n\n    def create_board(self):\n        board = [[SPACE for _ in range(WIDTH)] for _ in range(HEIGHT)]\n        # Place walls\n        for i in range(WIDTH):\n            board[0][i] = WALL\n            board[HEIGHT - 1][i] = WALL\n        for i in range(HEIGHT):\n            board[i][0] = WALL\n            board[i][WIDTH - 1] = WALL\n        # Place dots\n        for _ in range(NUM_DOTS):\n            while True:\n                x, y = random.randint(1, HEIGHT - 2), random.randint(1, WIDTH - 2)\n                if board[x][y] == SPACE:\n                    board[x][y] = DOT\n                    break\n        return board\n\n    def place_ghosts(self):\n        ghosts = []\n        for _ in range(NUM_GHOSTS):\n            while True:\n                x, y = random.randint(1, HEIGHT - 2), random.randint(1, WIDTH - 2)\n                if (x, y) != self.pacman_position and self.board[x][y] == SPACE:\n                    ghosts.append((x, y))\n                    self.board[x][y] = GHOST\n                    break\n        return ghosts\n\n    def print_board(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        for y in range(HEIGHT):\n            for x in range(WIDTH):\n                if (y, x) == self.pacman_position:\n                    print(PACMAN, end='')\n                else:\n                    print(self.board[y][x], end='')\n            print()\n        print(f'Score: {self.score}')\n\n    def move_pacman(self, direction):\n        x, y = self.pacman_position\n        if direction == 'w' and x > 0:\n            x -= 1\n        elif direction == 's' and x < HEIGHT - 1:\n            x += 1\n        elif direction == 'a' and y > 0:\n            y -= 1\n        elif direction == 'd' and y < WIDTH - 1:\n            y += 1\n        if self.board[x][y] != WALL:\n            self.pacman_position = (x, y)\n            if self.board[x][y] == DOT:\n                self.score += 1\n                self.board[x][y] = SPACE\n            self.check_game_over()\n\n    def check_game_over(self):\n        for ghost in self.ghosts:\n            if ghost == self.pacman_position:\n                self.game_over = True\n\n    def move_ghosts(self):\n        for i in range(len(self.ghosts)):\n            x, y = self.ghosts[i]\n            move = random.choice([(0, 1), (0, -1), (1, 0), (-1, 0)])  # random move\n            new_x, new_y = x + move[0], y + move[1]\n            if self.board[new_x][new_y] == SPACE:\n                self.board[x][y] = SPACE\n                self.ghosts[i] = (new_x, new_y)\n                self.board[new_x][new_y] = GHOST\n\n    def play(self):\n        while not self.game_over:\n            self.print_board()\n            direction = input(\"Move (w/a/s/d): \")\n            self.move_pacman(direction)\n            self.move_ghosts()\n        self.print_board()\n        print(\"Game Over! Your score was:\", self.score)\n\nif __name__ == \"__main__\":\n    game = Game()\n    game.play()\n```\n\nTo run the game, save the code in a file called `pacman.py` and execute it using Python (`python pacman.py`). Use `w`, `a`, `s`, `d` keys to move Pac-Man around the board. The game will end if Pac-Man collides with a ghost.",
    "17": "```python\nimport random\nimport time\nimport os\nimport sys\n\nclass DinosaurRunner:\n    def __init__(self):\n        self.score = 0\n        self.game_over = False\n        self.obstacles = ['-', '!', 'O']  # Different obstacles\n        self.player_pos = 0\n\n    def print_game_state(self):\n        os.system('cls' if os.name == 'nt' else 'clear')\n        print(\"Dinosaur Runner\")\n        print(\"Score:\", self.score)\n        print(\"Press 'x' to jump, 'q' to quit.\")\n        print(\" \" * self.player_pos + \"D\")\n        print(\"\\n\" + self.generate_obstacles())\n\n    def generate_obstacles(self):\n        return ''.join(random.choice(self.obstacles) for _ in range(20))\n\n    def jump(self):\n        if not self.game_over:\n            self.score += 1\n            print(\"Jumped over an obstacle!\")\n            time.sleep(0.5)\n\n    def check_collision(self, obstacles):\n        if obstacles[self.player_pos] in self.obstacles:\n            self.game_over = True\n            print(\"Game Over! You hit an obstacle.\")\n\n    def play(self):\n        while not self.game_over:\n            self.print_game_state()\n            obstacles = self.generate_obstacles()\n            self.check_collision(obstacles)\n            if self.game_over:\n                break\n            action = input(\"Action: \")\n            if action == 'x':\n                self.jump()\n            elif action == 'q':\n                print(\"Thanks for playing!\")\n                sys.exit()\n            else:\n                print(\"Invalid action. Press 'x' to jump or 'q' to quit.\")\n\n        print(\"Final Score:\", self.score)\n\nif __name__ == \"__main__\":\n    game = DinosaurRunner()\n    game.play()\n```\n"
}