{
    "7": "```python\ndef day_when_barn_empty(n, m):\n    grains = n\n    day = 0\n    \n    while grains > 0:\n        day += 1\n        grains = min(n, grains + m)  # Add grains and ensure it doesn't exceed capacity\n        grains -= day  # Sparrows eat grains\n        \n    return day\n\n# Read input\nn, m = map(int, input().split())\nprint(day_when_barn_empty(n, m))\n```",
    "1": "```python\ndef max_digit_sum_integer(x):\n    str_x = str(x)\n    length = len(str_x)\n    max_sum = sum(int(d) for d in str_x)\n    result = x\n\n    for i in range(length):\n        if str_x[i] != '0':\n            # Create a candidate by decreasing the current digit and setting all following digits to 9\n            candidate = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (length - i - 1)\n            candidate_int = int(candidate)\n            if candidate_int > 0:\n                candidate_digit_sum = sum(int(d) for d in candidate)\n                if (candidate_digit_sum > max_sum) or (candidate_digit_sum == max_sum and candidate_int > result):\n                    max_sum = candidate_digit_sum\n                    result = candidate_int\n\n    return result\n\nx = int(input().strip())\nprint(max_digit_sum_integer(x))\n```",
    "2": "```python\ndef is_lucky_year(year):\n    \"\"\"Check if a year is lucky (has no more than one non-zero digit).\"\"\"\n    non_zero_digits = sum(1 for digit in str(year) if digit != '0')\n    return non_zero_digits <= 1\n\ndef next_lucky_year(current_year):\n    \"\"\"Find the next lucky year after the given current year.\"\"\"\n    next_year = current_year + 1\n    while not is_lucky_year(next_year):\n        next_year += 1\n    return next_year - current_year\n\ndef main():\n    # Input\n    current_year = int(input())\n    \n    # Output the number of years until the next lucky year\n    print(next_lucky_year(current_year))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "4": "```python\ndef contains_lucky_digit(hh, mm):\n    \"\"\"Check if the given hour and minute contain the lucky digit '7'.\"\"\"\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef time_before(hh, mm, minutes):\n    \"\"\"Calculate the time that is 'minutes' before the given hh:mm.\"\"\"\n    total_minutes = hh * 60 + mm - minutes\n    total_minutes = total_minutes % (24 * 60)  # wrap around for 24 hours\n    return divmod(total_minutes, 60)  # returns (hh, mm)\n\ndef minimum_snooze_presses(x, hh, mm):\n    \"\"\"Calculate the minimum number of snooze presses required for a lucky time.\"\"\"\n    presses = 0\n    while not contains_lucky_digit(hh, mm):\n        hh, mm = time_before(hh, mm, x)\n        presses += 1\n    return presses\n\n# Input\nx = int(input())\nhh, mm = map(int, input().split())\n\n# Output\nprint(minimum_snooze_presses(x, hh, mm))\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    # Create an array to track the painted sections\n    painted = [0] * (n + 1)\n\n    # Function to calculate the number of painted sections\n    def calculate_painted_count(exclude_indices):\n        painted_count = [0] * (n + 1)\n        for i in range(q):\n            if i not in exclude_indices:\n                l, r = painters[i]\n                for j in range(l, r + 1):\n                    painted_count[j] += 1\n        return sum(1 for x in painted_count if x > 0)\n\n    max_count = 0\n\n    # Try excluding each pair of painters\n    for i in range(q):\n        for j in range(i + 1, q):\n            painted_count = calculate_painted_count({i, j})\n            max_count = max(max_count, painted_count)\n\n    return max_count\n\n# Read input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Get the result and print it\nresult = max_painted_sections(n, q, painters)\nprint(result)\n```",
    "0": "```python\ndef maxAccordionLength(s: str) -> int:\n    opening_bracket_index = s.find('[')\n    closing_bracket_index = s.rfind(']')\n    \n    # Check for valid brackets\n    if opening_bracket_index == -1 or closing_bracket_index == -1 or opening_bracket_index >= closing_bracket_index:\n        return -1\n    \n    # Find the first colon after the opening bracket\n    first_colon_index = s.find(':', opening_bracket_index)\n    # Find the last colon before the closing bracket\n    last_colon_index = s.rfind(':', opening_bracket_index, closing_bracket_index)\n    \n    # Check for valid colons\n    if first_colon_index == -1 or last_colon_index == -1 or first_colon_index >= last_colon_index:\n        return -1\n    \n    # Count vertical lines between the two colons\n    vertical_lines_count = s[first_colon_index + 1:last_colon_index].count('|')\n    \n    # Calculate the maximum length of the accordion\n    max_length = 4 + vertical_lines_count\n    \n    return max_length\n\n# Input reading\ns = input().strip()\nprint(maxAccordionLength(s))\n```",
    "8": "```python\ndef min_tiles_to_draw(tiles):\n    # Parse tiles into a structured format\n    counts = {}\n    for tile in tiles:\n        num = int(tile[0])\n        suit = tile[1]\n        if suit not in counts:\n            counts[suit] = []\n        counts[suit].append(num)\n\n    def has_koutsu(nums):\n        return len(nums) == 3 and nums[0] == nums[1] == nums[2]\n\n    def has_shuntsu(nums):\n        if len(nums) < 3:\n            return False\n        nums.sort()\n        for i in range(len(nums) - 2):\n            if nums[i] + 1 == nums[i + 1] and nums[i + 1] + 1 == nums[i + 2]:\n                return True\n        return False\n\n    # Check for existing mentsus\n    for nums in counts.values():\n        if has_koutsu(sorted(nums)) or has_shuntsu(sorted(nums)):\n            return 0  # A mentsu already exists\n\n    # Analyze potential draws for shuntsu\n    for nums in counts.values():\n        nums.sort()\n        if len(nums) == 2:\n            if abs(nums[0] - nums[1]) <= 2:\n                return 1  # One draw can complete a shuntsu\n            return 2  # Two draws needed to form a shuntsu\n        elif len(nums) == 1:\n            if nums[0] == 1 or nums[0] == 9:\n                return 2  # Need two draws to form a shuntsu\n            return 1  # One draw can complete a shuntsu\n\n    # If no mentsu is found, need at least 2 tiles to draw\n    return 2\n\n# Read input\ntiles = input().strip().split()\nprint(min_tiles_to_draw(tiles))\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    \n    for query in queries:\n        n, x = query[0]\n        blows = query[1]\n        \n        min_blow_needed = float('inf')\n        can_defeat = False\n        \n        for d, h in blows:\n            effective_damage = d - h\n            \n            # If the blow can defeat Zmei in one hit\n            if d >= x:\n                min_blow_needed = min(min_blow_needed, 1)\n                can_defeat = True\n                continue\n            \n            # If the blow is ineffective (no reduction in heads or worse)\n            if effective_damage <= 0:\n                continue\n            \n            # Calculate the number of blows needed to reduce heads to zero\n            blows_needed = (x + effective_damage - 1) // effective_damage\n            min_blow_needed = min(min_blow_needed, blows_needed)\n            can_defeat = True\n            \n        results.append(min_blow_needed if can_defeat else -1)\n    \n    return results\n\n# Example usage\nt = 3\nqueries = [\n    ((3, 10), [(6, 3), (8, 2), (1, 4)]),\n    ((4, 10), [(4, 1), (3, 2), (2, 6), (1, 100)]),\n    ((1, 100), [(2, 15), (10, 11), (14, 100)])\n]\n\nresults = min_blows_to_defeat_zmei(t, queries)\nfor res in results:\n    print(res)\n```",
    "5": "```python\ndef minimum_seconds_to_close_tabs(n, pos, l, r):\n    # If no tabs need to be closed, return 0\n    if l == 1 and r == n:\n        return 0\n\n    seconds = 0\n\n    # Determine if cursor needs to move to the leftmost or rightmost tab of the segment\n    if pos < l:\n        seconds += (l - pos) + 1  # Move to l and close tabs to the left\n    elif pos > r:\n        seconds += (pos - r) + 1  # Move to r and close tabs to the right\n    else:\n        # If the cursor is within the segment\n        left_closing = (l - 1) - pos + 1 if l > 1 else 0  # Close left if needed\n        right_closing = pos - (r + 1) + 1 if r < n else 0  # Close right if needed\n        seconds += min(left_closing, right_closing) + (1 if left_closing or right_closing else 0)\n\n    return seconds\n\n# Read input and output the result\nn, pos, l, r = map(int, input().strip().split())\nprint(minimum_seconds_to_close_tabs(n, pos, l, r))\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    red_tiles = n // a\n    blue_tiles = n // b\n    both_tiles = n // (a * b // gcd(a, b))\n\n    total_chocolates = (red_tiles * p) + (blue_tiles * q) - (both_tiles * min(p, q))\n    \n    return total_chocolates\n\n# Reading input\nn, a, b, p, q = map(int, input().split())\nprint(max_chocolates(n, a, b, p, q))\n```",
    "10": "```python\ndef calculate_days_off(n):\n    # Maximum possible days off\n    max_days_off = min(n, 2)\n\n    # Minimum possible days off calculation\n    full_weeks = n // 7\n    remaining_days = n % 7\n    \n    min_days_off = full_weeks * 2\n    if remaining_days >= 5:\n        min_days_off += 2\n\n    return min_days_off, max_days_off\n\n# Read input\nn = int(input().strip())\n# Calculate and print the result\nresult = calculate_days_off(n)\nprint(result[0], result[1])\n```",
    "15": "```python\ndef is_favorite_in_sequence(a, b, c):\n    if c == 0:\n        return a == b\n    return (b - a) % c == 0 and (b - a) // c >= 0\n\ndef main():\n    a, b, c = map(int, input().split())\n    if is_favorite_in_sequence(a, b, c):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    segments = []\n    current_length = 0\n\n    # Step 1: Find segments of 'G's\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n\n    if current_length > 0:\n        segments.append(current_length)\n\n    # If there are no 'G's, return 0\n    if not segments:\n        return 0\n\n    # Step 2: Calculate the maximum beauty possible with one swap\n    max_length = max(segments)\n    max_possible_length = max_length\n\n    # Combine segments of 'G's with a swap of one 'S' in between\n    for i in range(len(segments) - 1):\n        combined_length = segments[i] + segments[i + 1]\n        max_possible_length = max(max_possible_length, combined_length)\n\n    # Check if we can extend the longest segment by one if there's at least one 'S'\n    if 'S' in trophies:\n        max_possible_length = max(max_possible_length, max_length + 1)\n\n    return max_possible_length\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\nprint(max_beauty_after_swap(n, trophies))\n```",
    "16": "```python\ndef can_form_regular_bracket_sequence(cnt_open_open, cnt_open_close, cnt_close_open, cnt_close_close):\n    # Calculate the total number of opening and closing brackets\n    total_opening = cnt_open_open + cnt_open_close  # Total opening brackets\n    total_closing = cnt_open_close + cnt_close_close  # Total closing brackets\n\n    # Ensure the number of opening brackets is at least equal to the number of closing brackets\n    if total_opening != total_closing or cnt_open_open < cnt_close_open:\n        return 0\n    return 1\n\n# Read inputs\ncnt_open_open = int(input().strip())\ncnt_open_close = int(input().strip())\ncnt_close_open = int(input().strip())\ncnt_close_close = int(input().strip())\n\n# Print the result\nprint(can_form_regular_bracket_sequence(cnt_open_open, cnt_open_close, cnt_close_open, cnt_close_close))\n```",
    "9": "```python\ndef find_grandpas_sofa(d, n, m, sofas, counts):\n    cnt_l, cnt_r, cnt_t, cnt_b = counts\n    positions = []\n\n    # Collect sofa positions and their indices\n    for idx, (x1, y1, x2, y2) in enumerate(sofas):\n        positions.append((min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2), idx + 1))\n\n    # Check each sofa and count its neighbors\n    for x1, y1, x2, y2, index in positions:\n        left_count = right_count = top_count = bottom_count = 0\n        \n        for x3, y3, x4, y4, other_index in positions:\n            if index == other_index:\n                continue\n            \n            if x2 < x3:  # Current sofa is to the left of another sofa\n                left_count += 1\n            elif x1 > x4:  # Current sofa is to the right of another sofa\n                right_count += 1\n            elif y2 < y3:  # Current sofa is above another sofa\n                top_count += 1\n            elif y1 > y4:  # Current sofa is below another sofa\n                bottom_count += 1\n        \n        # Check if counts match\n        if (left_count == cnt_l and right_count == cnt_r and\n                top_count == cnt_t and bottom_count == cnt_b):\n            return index\n\n    return -1\n\n# Input reading\nd = int(input())\nn, m = map(int, input().split())\nsofas = [tuple(map(int, input().split())) for _ in range(d)]\ncounts = tuple(map(int, input().split()))\n\n# Find and print the result\nresult = find_grandpas_sofa(d, n, m, sofas, counts)\nprint(result)\n```",
    "14": "```python\ndef is_stack_sortable(permutation):\n    stack = []\n    b = []\n    for num in permutation:\n        stack.append(num)\n        while stack and (not b or stack[-1] <= b[-1]):\n            b.append(stack.pop())\n    return b == sorted(permutation)\n\ndef restore_permutation(n, k, given):\n    remaining = sorted(set(range(1, n + 1)) - set(given), reverse=True)\n\n    # Check if the given part is stack-sortable\n    if not is_stack_sortable(given):\n        return -1\n\n    result = given[:]\n    stack = []\n\n    for num in given:\n        while remaining and (not stack or remaining[-1] >= stack[-1]):\n            stack.append(remaining.pop())\n        \n        while stack and (not result or stack[-1] <= result[-1]):\n            result.append(stack.pop())\n\n    while stack:\n        result.append(stack.pop())\n\n    return result if len(result) == n else -1\n\n# Read input\nn, k = map(int, input().split())\ngiven = list(map(int, input().split()))\n\n# Get the result\nresult = restore_permutation(n, k, given)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef find_course_order(n, k, main_courses, dependencies):\n    # Create an adjacency list and an in-degree counter\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    \n    # Build the graph and in-degree array\n    for course_id in range(1, n + 1):\n        for dep in dependencies[course_id - 1]:\n            graph[dep].append(course_id)\n            in_degree[course_id] += 1\n\n    # Queue for courses with no dependencies\n    queue = deque(course_id for course_id in range(1, n + 1) if in_degree[course_id] == 0)\n\n    passed_courses = []\n    main_courses_set = set(main_courses)\n    main_courses_passed = set()\n    \n    while queue:\n        current_course = queue.popleft()\n        passed_courses.append(current_course)\n        \n        # If the current course is a main course, mark it as passed\n        if current_course in main_courses_set:\n            main_courses_passed.add(current_course)\n        \n        # Process all courses dependent on the current course\n        for neighbor in graph[current_course]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    # Check if all main courses are passed\n    if main_courses_passed != main_courses_set:\n        return -1\n    \n    return len(passed_courses), passed_courses\n\n# Input reading\nn, k = map(int, input().split())\nmain_courses = list(map(int, input().split()))\ndependencies = [list(map(int, input().split()))[1:] for _ in range(n)]\n\n# Get the result\nresult = find_course_order(n, k, main_courses, dependencies)\n\n# Output\nif result == -1:\n    print(-1)\nelse:\n    m, order = result\n    print(m)\n    print(\" \".join(map(str, order)))\n```",
    "17": "```python\ndef standing_spectators(n, k, t):\n    if t <= k:\n        return t\n    elif t <= n:\n        return k\n    else:\n        return n + k - t\n\n# Read input values\nn, k, t = map(int, input().strip().split())\n# Print the result\nprint(standing_spectators(n, k, t))\n```",
    "18": "```python\ndef lexicographically_minimal_string(s):\n    t = []\n    u = []\n    \n    s_list = list(s)\n    \n    while s_list or t:\n        if s_list:\n            t.append(s_list.pop(0))\n        \n        while t:\n            if not s_list or t[-1] <= s_list[0]:\n                u.append(t.pop())\n            else:\n                break\n    \n    return ''.join(u)\n\n# Read input\ns = input().strip()\n# Print the result\nprint(lexicographically_minimal_string(s))\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef increment_time(hh, mm):\n    mm += 1\n    if mm == 60:\n        mm = 0\n        hh += 1\n        if hh == 24:\n            hh = 0\n    return hh, mm\n\ndef minutes_until_palindrome(start_time):\n    hh, mm = map(int, start_time.split(':'))\n    count = 0\n    \n    while not is_palindrome(f\"{hh:02}:{mm:02}\"):\n        hh, mm = increment_time(hh, mm)\n        count += 1\n        \n    return count\n\n# Input reading\ninput_time = input().strip()\n# Calculate and print the result\nprint(minutes_until_palindrome(input_time))\n```",
    "21": "```python\ndef maximum_distance_after_swap(n, a):\n    # Find the indices of the minimum and maximum elements\n    min_index = a.index(1)\n    max_index = a.index(n)\n\n    # Calculate the current distance\n    current_distance = abs(min_index - max_index)\n\n    # Potential maximum distances after one swap\n    distance_with_first = abs(0 - max_index)  # Swap 1 with a[0]\n    distance_with_last = abs(n - 1 - max_index)  # Swap 1 with a[n-1]\n    distance_with_first_min = abs(min_index - 0)  # Swap n with a[0]\n    distance_with_last_min = abs(min_index - (n - 1))  # Swap n with a[n-1]\n\n    # Calculate the maximum possible distance\n    max_distance = max(current_distance, distance_with_first, distance_with_last,\n                       distance_with_first_min, distance_with_last_min)\n\n    return max_distance\n\n# Reading input\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Output the result\nprint(maximum_distance_after_swap(n, a))\n```",
    "27": "```python\ndef min_operations(n, s):\n    # Initially, the minimum operations is the length of the string (typing all characters)\n    min_ops = n\n    \n    # Iterate through possible lengths of the prefix to copy\n    for i in range(1, n // 2 + 1):\n        # Check if the substring can be doubled and is a prefix of the entire string\n        if s[:i] == s[i:2*i]:\n            # Calculate operations: type i characters, copy, and type the remaining characters\n            ops = i + 1 + (n - 2 * i)\n            min_ops = min(min_ops, ops)\n    \n    return min_ops\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(min_operations(n, s))\n```",
    "22": "```python\ndef is_s_palindrome(s: str) -> str:\n    # Define a mapping of characters to their mirror counterparts\n    mirror_map = {\n        'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', \n        'M': 'M', 'O': 'O', 'o': 'o', 'p': 'q', 'q': 'p', \n        'T': 'T', 'U': 'U', 'v': 'v', 'W': 'W', 'X': 'X', \n        'Y': 'Y', 'Z': 'Z'\n    }\n    \n    n = len(s)\n    for i in range((n + 1) // 2):  # Check up to the middle of the string\n        left_char = s[i]\n        right_char = s[n - 1 - i]\n        \n        # Validate and check for mirror characters\n        if (left_char not in mirror_map) or (right_char not in mirror_map) or (mirror_map[left_char] != right_char):\n            return \"NIE\"\n    \n    return \"TAK\"\n\n# Read input\ns = input().strip()\n# Print result\nprint(is_s_palindrome(s))\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a, b):\n    a_str = str(a)\n    b_str = str(b)\n    \n    # Sort the digits of a in descending order\n    sorted_digits = sorted(a_str, reverse=True)\n    \n    # Function to find the largest permutation <= b\n    def backtrack(current, remaining):\n        if len(current) == len(a_str):\n            num = int(''.join(current))\n            return num if num <= b else -1\n        \n        max_number = -1\n        for i in range(len(remaining)):\n            if i > 0 and remaining[i] == remaining[i - 1]:\n                continue\n            \n            next_digit = remaining[i]\n            next_remaining = remaining[:i] + remaining[i + 1:]\n            \n            if not current and next_digit == '0':\n                continue\n            \n            candidate = backtrack(current + [next_digit], next_remaining)\n            max_number = max(max_number, candidate)\n        \n        return max_number\n    \n    return backtrack([], sorted_digits)\n\n# Input Reading\na = int(input().strip())\nb = int(input().strip())\n\n# Output the result\nprint(max_permutation_not_exceeding(a, b))\n```",
    "19": "```python\ndef is_valid_record(n, stats):\n    previous_plays = previous_clears = 0\n    \n    for plays, clears in stats:\n        if plays < previous_plays or clears < previous_clears or clears > plays:\n            return False\n        if (plays - previous_plays) < (clears - previous_clears):\n            return False\n        \n        previous_plays, previous_clears = plays, clears\n    \n    return True\n\ndef check_records(test_cases):\n    results = []\n    \n    for n, stats in test_cases:\n        valid = is_valid_record(n, stats)\n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Read input\nT = int(input())\ntest_cases = []\n\nfor _ in range(T):\n    n = int(input())\n    stats = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, stats))\n\n# Get results and print them\nresults = check_records(test_cases)\nprint(\"\\n\".join(results))\n```",
    "25": "```python\ndef generate_symmetric_matrix(n, k):\n    if k > n * n or k < 0 or (n % 2 == 1 and k % 2 == 1):\n        return -1\n\n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k <= 0:\n            break\n        for j in range(i, n):\n            if i == j:  # Fill the main diagonal\n                if k >= 1:\n                    matrix[i][j] = 1\n                    k -= 1\n            else:  # Fill the symmetric pair (i, j) and (j, i)\n                if k >= 2:\n                    matrix[i][j] = 1\n                    matrix[j][i] = 1\n                    k -= 2\n\n    return matrix if k == 0 else -1\n\n# Read input\nn, k = map(int, input().strip().split())\nresult = generate_symmetric_matrix(n, k)\n\n# Print output\nif result == -1:\n    print(result)\nelse:\n    for row in result:\n        print(\" \".join(map(str, row)))\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # The number of unique rooms visited by the x-mouse is equal to m,\n    # and we need traps in all rooms except room 0.\n    return m - 1\n\n# Read input\nm, x = map(int, input().split())\n# Calculate and print the minimum number of traps needed\nprint(minimum_traps(m, x))\n```",
    "28": "```python\ndef create_rename_script(n, files):\n    examples = []\n    regulars = []\n    \n    for name, file_type in files:\n        if file_type == '1':\n            examples.append(name)\n        else:\n            regulars.append(name)\n    \n    total_files = n\n    e = len(examples)\n    \n    moves = []\n    \n    # Renaming examples to 1, 2, ..., e\n    for i in range(e):\n        moves.append(f\"move {examples[i]} {i + 1}\")\n    \n    # Renaming regular tests to e + 1, e + 2, ..., n\n    for i in range(len(regulars)):\n        moves.append(f\"move {regulars[i]} {e + i + 1}\")\n    \n    # Final output\n    print(len(moves))\n    print(\"\\n\".join(moves))\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    files = [input().strip().split() for _ in range(n)]\n    create_rename_script(n, files)\n```",
    "24": "```python\ndef can_alice_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # right, down, diagonal right-down, diagonal left-down\n    n = 10  # board size\n\n    def check_win(x, y):\n        for dx, dy in directions:\n            count = 1  # Start counting from the current position\n            # Check in the positive direction\n            count += count_streak(x, y, dx, dy)\n            # Check in the negative direction\n            count += count_streak(x, y, -dx, -dy)\n            \n            if count >= 5:\n                return True\n        return False\n\n    def count_streak(x, y, dx, dy):\n        count = 0\n        for step in range(1, 5):\n            nx, ny = x + step * dx, y + step * dy\n            if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                count += 1\n            else:\n                break\n        return count\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                board[i][j] = 'X'  # Place a cross temporarily\n                if check_win(i, j):\n                    return 'YES'\n                board[i][j] = '.'  # Reset the cell\n\n    return 'NO'\n\n\n# Read input\nboard = [input().strip() for _ in range(10)]\nprint(can_alice_win(board))\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    low, high = 1, max(a, b)\n    result = 0\n    \n    while low <= high:\n        mid = (low + high) // 2\n        \n        # Calculate the number of plates we can fill with at least mid pieces of each cake\n        plates_from_a = a // mid\n        plates_from_b = b // mid\n        \n        # Total plates filled must be at least n\n        if plates_from_a + plates_from_b >= n:\n            result = mid  # mid is a valid solution\n            low = mid + 1  # try for a bigger x\n        else:\n            high = mid - 1  # try for a smaller x\n            \n    return result\n\n# Read input\nn, a, b = map(int, input().split())\n# Output the result\nprint(max_min_pieces(n, a, b))\n```",
    "26": "```python\ndef main():\n    # Read input values and convert them to floats\n    x, y, z = map(float, input().split())\n    \n    # Define the expressions and their corresponding labels\n    expressions = [\n        (x ** (y ** z), \"x^y^z\"),\n        (x ** (z ** y), \"x^z^y\"),\n        ((x ** y) ** z, \"(x^y)^z\"),\n        ((x ** z) ** y, \"(x^z)^y\"),\n        (y ** (x ** z), \"y^x^z\"),\n        (y ** (z ** x), \"y^z^x\"),\n        ((y ** x) ** z, \"(y^x)^z\"),\n        ((y ** z) ** x, \"(y^z)^x\"),\n        (z ** (x ** y), \"z^x^y\"),\n        (z ** (y ** x), \"z^y^x\"),\n        ((z ** x) ** y, \"(z^x)^y\"),\n        ((z ** y) ** x, \"(z^y)^x\"),\n    ]\n    \n    # Find the maximum value and the corresponding expression\n    max_value, max_expression = max(expressions, key=lambda pair: pair[0])\n    \n    # Print the result\n    print(max_expression)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "32": "```python\ndef is_valid_journey(n, journey):\n    current_position = 0  # Starting at the North Pole, represented as 0 km\n    for distance, direction in journey:\n        if current_position == 0 and direction != \"South\":\n            return \"NO\"  # At North Pole, can only move South\n        if current_position == 20000 and direction != \"North\":\n            return \"NO\"  # At South Pole, can only move North\n\n        if direction == \"North\":\n            current_position -= distance\n        elif direction == \"South\":\n            current_position += distance\n        elif direction in {\"West\", \"East\"}:\n            continue  # Moving East or West does not affect North/South position\n        \n        # Check if the current position goes out of bounds\n        if current_position < 0 or current_position > 20000:\n            return \"NO\"\n\n    return \"YES\" if current_position == 0 else \"NO\"  # Must end at the North Pole\n\n\n# Input reading\nn = int(input())\njourney = [tuple(input().split()) for _ in range(n)]\njourney = [(int(t), d) for t, d in journey]\n\n# Output the result\nprint(is_valid_journey(n, journey))\n```",
    "29": "```python\ndef min_replacements_to_make_lucky(ticket: str) -> int:\n    # Step 1: Split the ticket into two halves and convert to integers\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n\n    # Step 2: Calculate the sums of both halves\n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n\n    # Step 3: If they are already equal, no replacements are needed\n    if sum_first == sum_second:\n        return 0\n\n    # Step 4: Calculate the difference in sums\n    difference = abs(sum_first - sum_second)\n\n    # Step 5: Calculate potential changes for both halves\n    changes = []\n    if sum_first > sum_second:\n        changes = sorted([digit for digit in second_half], reverse=True) + sorted([9 - digit for digit in first_half], reverse=True)\n    else:\n        changes = sorted([9 - digit for digit in first_half], reverse=True) + sorted([digit for digit in second_half], reverse=True)\n\n    # Step 6: Count the minimum number of changes needed to cover the difference\n    replacements = 0\n    for change in changes:\n        difference -= change\n        replacements += 1\n        if difference <= 0:\n            break\n\n    return replacements\n\n# Example usage:\nticket = input().strip()\nprint(min_replacements_to_make_lucky(ticket))\n```",
    "35": "```python\ndef is_valid_flag(n, m, flag):\n    def check_horizontal_stripes():\n        if n % 3 != 0:\n            return False\n        stripe_height = n // 3\n        colors = set()\n        for i in range(3):\n            current_color = flag[i * stripe_height][0]\n            colors.add(current_color)\n            for row in flag[i * stripe_height:i * stripe_height + stripe_height]:\n                if row != current_color * m:\n                    return False\n        return len(colors) == 3\n\n    def check_vertical_stripes():\n        if m % 3 != 0:\n            return False\n        stripe_width = m // 3\n        colors = set()\n        for i in range(3):\n            current_color = flag[0][i * stripe_width]\n            colors.add(current_color)\n            for row in flag:\n                if row[i * stripe_width:i * stripe_width + stripe_width] != current_color * stripe_width:\n                    return False\n        return len(colors) == 3\n\n    return \"YES\" if check_horizontal_stripes() or check_vertical_stripes() else \"NO\"\n\n# Reading input\nn, m = map(int, input().split())\nflag = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(is_valid_flag(n, m, flag))\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    m0, x0, x1 = m, 0, 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef birthday_paradox(n, k):\n    MOD = 10**6 + 3\n    days = 1 << n  # Efficiently calculate 2^n\n\n    if k > days:\n        return 1, 1  # Guaranteed shared birthday\n\n    prob_no_shared = 1\n    for i in range(k):\n        prob_no_shared = prob_no_shared * (days - i) % MOD\n\n    total_prob = pow(days, k, MOD)\n    prob_shared = (total_prob - prob_no_shared) % MOD\n\n    common_divisor = gcd(prob_shared, total_prob)\n    A = (prob_shared // common_divisor) % MOD\n    B = (total_prob // common_divisor) % MOD\n\n    return A, B\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    result = birthday_paradox(n, k)\n    print(result[0], result[1])\n```",
    "37": "```python\ndef can_break_shield(a, b, c):\n    # Iterate over the possible number of shots from the Ebony gun\n    for shots_from_ebony in range(c // a + 1):\n        remaining_damage = c - a * shots_from_ebony\n        # Check if the remaining damage can be dealt by the Ivory gun\n        if remaining_damage >= 0 and remaining_damage % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Read input values\na, b, c = map(int, input().split())\n# Output the result\nprint(can_break_shield(a, b, c))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    \n    # Check if the entire string is a palindrome\n    if not is_palindrome(s):\n        return n\n    \n    # Check if all characters in the string are the same\n    if all(char == s[0] for char in s):\n        return 0\n    \n    # If the string is a palindrome but not all characters are the same,\n    # the longest non-palindrome substring can be obtained by removing\n    # either the first or the last character.\n    return n - 1\n\n# Read input\ns = input().strip()\n# Output the result\nprint(longest_non_palindrome_substring(s))\n```",
    "40": "```python\ndef determine_round_status(n, ratings):\n    # Check if any rating has changed\n    if any(before != after for before, after in ratings):\n        return \"rated\"\n    \n    # Check if ratings are in non-increasing order\n    if any(ratings[i][0] < ratings[i + 1][0] for i in range(n - 1)):\n        return \"unrated\"\n    \n    return \"maybe\"\n\n# Read input\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Determine and print the round status\nprint(determine_round_status(n, ratings))\n```",
    "33": "```python\ndef count_common_terms(a1, b1, a2, b2, L, R):\n    def first_term(a, b, start):\n        if a == 0:\n            return b if b >= start else None\n        n = (start - b + a - 1) // a  # ceil((start - b) / a)\n        return a * n + b if n >= 0 else None\n    \n    def last_term(a, b, end):\n        if a == 0:\n            return b if b <= end else None\n        n = (end - b) // a  # floor((end - b) / a)\n        return a * n + b if n >= 0 else None\n\n    # Find the first and last common terms for both sequences\n    first_x = first_term(a1, b1, L)\n    last_x = last_term(a1, b1, R)\n\n    if first_x is None or last_x is None or first_x > R or last_x < L:\n        return 0\n\n    count_a1 = (last_x - first_x) // a1 + 1\n\n    first_y = first_term(a2, b2, L)\n    last_y = last_term(a2, b2, R)\n\n    if first_y is None or last_y is None or first_y > R or last_y < L:\n        return 0\n\n    count_a2 = (last_y - first_y) // a2 + 1\n\n    return min(count_a1, count_a2)\n\n# Input\na1, b1, a2, b2, L, R = map(int, input().split())\n# Output\nprint(count_common_terms(a1, b1, a2, b2, L, R))\n```",
    "38": "```python\ndef can_coincide_tracks(n, L, kefa_distances, sasha_distances):\n    # Calculate the differences between consecutive barriers for both Kefa and Sasha\n    kefa_gaps = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    sasha_gaps = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Double the sasha_gaps to handle the circular nature\n    doubled_sasha_gaps = sasha_gaps * 2\n    \n    # Check if kefa_gaps can be found in doubled_sasha_gaps\n    for i in range(n):\n        if kefa_gaps == doubled_sasha_gaps[i:i+n]:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input processing\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Get the result and print\nresult = can_coincide_tracks(n, L, kefa_distances, sasha_distances)\nprint(result)\n```",
    "42": "```python\ndef count_distinct_cyclical_strings(n, s):\n    from itertools import product\n\n    # Generate all possible binary strings of length n\n    all_strings = (''.join(p) for p in product('01', repeat=n))\n    \n    distinct_cyclical_strings = set()\n    \n    for t in all_strings:\n        # Check if any cyclical shift of t contains s\n        if any(s in (t[i:] + t[:i]) for i in range(n)):\n            distinct_cyclical_strings.add(t)\n\n    return len(distinct_cyclical_strings)\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_distinct_cyclical_strings(n, s))\n```",
    "36": "```python\ndef get_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 1\n\n    # Determine the layer of the hexagonal spiral\n    while n >= moves_in_layer:\n        n -= moves_in_layer\n        layer += 1\n        moves_in_layer = 6 * layer\n\n    # Calculate the initial position and determine the direction and steps in the current layer\n    x, y = layer, 0\n    direction = n // layer\n    steps_in_direction = n % layer\n\n    # Move based on the calculated direction\n    if direction == 0:  # right\n        x += steps_in_direction\n    elif direction == 1:  # top-right\n        x += layer\n        y += steps_in_direction\n    elif direction == 2:  # top-left\n        x += layer - steps_in_direction\n        y += layer\n    elif direction == 3:  # left\n        x -= steps_in_direction\n        y += layer\n    elif direction == 4:  # bottom-left\n        x -= layer\n        y -= steps_in_direction\n    elif direction == 5:  # bottom-right\n        x -= layer - steps_in_direction\n        y -= layer\n\n    return (x, y)\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    result = get_coordinates(n)\n    print(result[0], result[1])\n```",
    "41": "```python\ndef nearest_zero_distance(n, arr):\n    distances = [float('inf')] * n\n    last_zero_index = -1\n\n    # Forward pass to find distances to the nearest zero on the left\n    for i in range(n):\n        if arr[i] == 0:\n            last_zero_index = i\n            distances[i] = 0\n        elif last_zero_index != -1:\n            distances[i] = i - last_zero_index\n\n    # Backward pass to find distances to the nearest zero on the right\n    last_zero_index = -1\n    for i in range(n - 1, -1, -1):\n        if arr[i] == 0:\n            last_zero_index = i\n        elif last_zero_index != -1:\n            distances[i] = min(distances[i], last_zero_index - i)\n\n    print(' '.join(map(str, distances)))\n\n# Example usage\nif __name__ == \"__main__\":\n    n = int(input())\n    arr = list(map(int, input().split()))\n    nearest_zero_distance(n, arr)\n```",
    "48": "```python\ndef kth_largest_in_multiplication_table(n, m, k):\n    left, right = 1, n * m\n    \n    while left < right:\n        mid = (left + right) // 2\n        count = sum(min(mid // i, m) for i in range(1, n + 1))\n        \n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return left\n\n# Read input values\nn, m, k = map(int, input().strip().split())\n# Output the result\nprint(kth_largest_in_multiplication_table(n, m, k))\n```",
    "44": "```python\ndef minimal_time_to_post_office(distance, segment_length, drive_time, walk_time, repair_time):\n    # Calculate the number of full segments and the remaining distance\n    full_segments = distance // segment_length\n    remaining_distance = distance % segment_length\n\n    # Calculate the time spent driving full segments with repairs\n    total_drive_time = full_segments * (segment_length * drive_time + repair_time)\n    \n    if full_segments > 0:\n        total_drive_time -= repair_time  # Remove the last repair time as it's not needed after the last segment\n\n    # Add time for the remaining distance\n    total_drive_time += remaining_distance * drive_time\n\n    # Calculate the time if Vasiliy walks the entire distance\n    total_walk_time = distance * walk_time\n\n    # Return the minimum time between driving and walking\n    return min(total_drive_time, total_walk_time)\n\n# Input reading\nd, k, a, b, t = map(int, input().split())\nprint(minimal_time_to_post_office(d, k, a, b, t))\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Calculate the minimum sum required for k positive integers\n    min_required_sum = k * (k + 1) // 2\n    \n    # Check if it's possible to create such a sequence\n    if min_required_sum > n:\n        return -1  # Not enough sum to create a sequence of k positive integers\n    \n    # Calculate the remaining sum after taking the minimum required sum\n    remaining = n - min_required_sum\n    \n    # Calculate the maximum GCD we can achieve\n    g = remaining // k\n    \n    # Construct the sequence with the maximum GCD\n    sequence = [(i + g) for i in range(1, k + 1)]\n    \n    return sequence\n\n# Read input\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    length = 1  # Starting with 1-digit numbers\n    count = 9   # There are 9 one-digit numbers\n    start = 1   # The first one-digit number is 1\n\n    # Determine the length of the number that contains the k-th digit\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    # Find the exact number that contains the k-th digit\n    start += (k - 1) // length\n    num_str = str(start)\n    \n    # Find the digit's position in that number\n    digit_index = (k - 1) % length\n    return num_str[digit_index]\n\nif __name__ == \"__main__\":\n    k = int(input().strip())\n    print(find_kth_digit(k))\n```",
    "43": "```python\nimport math\nimport sys\n\ndef minimal_angle_pair(n, vectors):\n    # Calculate angles and their original indices\n    angles = [(math.atan2(y, x), i + 1) for i, (x, y) in enumerate(vectors)]\n    \n    # Sort angles\n    angles.sort(key=lambda item: item[0])\n\n    # Initialize variables to track minimum angle and corresponding indices\n    min_angle = float('inf')\n    min_pair = (0, 0)\n\n    # Check angles between consecutive vectors and wrap around to the beginning\n    for i in range(n):\n        j = (i + 1) % n\n        angle1, index1 = angles[i]\n        angle2, index2 = angles[j]\n        \n        # Calculate non-oriented angle\n        non_oriented_angle = abs(angle2 - angle1)\n        if non_oriented_angle > math.pi:\n            non_oriented_angle = 2 * math.pi - non_oriented_angle\n        \n        # Update minimum angle and pair if found\n        if non_oriented_angle < min_angle:\n            min_angle = non_oriented_angle\n            min_pair = (index1, index2)\n\n    return min_pair\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read\n    data = input_data().strip().splitlines()\n    \n    n = int(data[0])\n    vectors = [tuple(map(int, line.split())) for line in data[1:n + 1]]\n    \n    result = minimal_angle_pair(n, vectors)\n    print(result[0], result[1])\n```",
    "51": "```python\nfrom collections import Counter\n\ndef find_x_y(n, divisors):\n    divisor_count = Counter(divisors)\n    \n    x, y = 1, 1\n\n    for d, count in divisor_count.items():\n        if count == 2:\n            x *= d\n            y *= d\n        else:\n            if x % d != 0:\n                x *= d\n            else:\n                y *= d\n    \n    return x, y\n\n# Input reading\nn = int(input().strip())\ndivisors = list(map(int, input().strip().split()))\n\n# Finding x and y\nx, y = find_x_y(n, divisors)\n\n# Output result\nprint(x, y)\n```",
    "46": "```python\ndef count_divisible_pairs(n, m):\n    # Initialize counts for remainders when divided by 5\n    count_x = [0] * 5\n    count_y = [0] * 5\n\n    # Count occurrences of each remainder in range 1 to n\n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n\n    # Count occurrences of each remainder in range 1 to m\n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n\n    # Calculate total pairs where (x + y) % 5 == 0\n    total_pairs = (\n        count_x[0] * count_y[0] + \n        count_x[1] * count_y[4] + \n        count_x[2] * count_y[3] + \n        count_x[3] * count_y[2] + \n        count_x[4] * count_y[1]\n    )\n\n    return total_pairs\n\n# Read input values for n and m\nn, m = map(int, input().split())\n# Output the result\nprint(count_divisible_pairs(n, m))\n```",
    "56": "```python\ndef remove_trailing_zeros(x):\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef f(x):\n    return remove_trailing_zeros(x + 1)\n\ndef count_reachable_numbers(n):\n    reachable = set()\n    current = n\n    \n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    \n    return len(reachable)\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    print(count_reachable_numbers(n))\n```",
    "54": "```python\ndef minimum_D(n, a):\n    min_a = min(a)\n    max_a = max(a)\n    \n    if max_a == min_a:\n        return 0  # All elements are already equal\n    \n    diff = max_a - min_a\n    \n    # Check if the difference is odd\n    if diff % 2 != 0:\n        return -1  # Impossible to make all equal\n    \n    D = diff // 2\n    \n    # Check if we can achieve equal elements with the chosen D\n    for value in a:\n        if not (min_a <= value + D <= max_a) and not (min_a <= value - D <= max_a):\n            return -1\n    \n    return D\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(minimum_D(n, a))\n```",
    "52": "```python\nfrom itertools import combinations\n\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_select = m // 2\n    total_max_sum = 0\n\n    for row in matrix:\n        possible_sums = set()\n        \n        # Generate all possible sums from selecting up to max_select elements\n        for r in range(max_select + 1):\n            for combo in combinations(row, r):\n                possible_sums.add(sum(combo))\n        \n        # Filter sums to find the maximum that is divisible by k\n        divisible_sums = [s for s in possible_sums if s % k == 0]\n        total_max_sum += max(divisible_sums, default=0)  # Use default=0 to handle empty case\n\n    return total_max_sum\n\n# Reading input\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculating the maximum sum divisible by k\nresult = max_sum_divisible_by_k(n, m, k, matrix)\nprint(result)\n```",
    "47": "```python\ndef max_beauty_with_multiplication(n, x, a):\n    def kadane(arr):\n        max_sum = 0\n        current_sum = 0\n        for value in arr:\n            current_sum += value\n            max_sum = max(max_sum, current_sum)\n            current_sum = max(current_sum, 0)\n        return max_sum\n\n    # Calculate the maximum beauty without any multiplication\n    max_beauty = kadane(a)\n\n    # Prepare to find the maximum beauty with multiplication\n    total_sum = sum(a)\n    max_subarray_sum_with_multiplier = float('-inf')\n\n    for start in range(n):\n        current_sum = 0\n        for end in range(start, n):\n            current_sum += a[end]\n            # Calculate potential new beauty with this subarray multiplied by x\n            modified_sum = current_sum * x\n            new_beauty = total_sum - current_sum + modified_sum\n            max_subarray_sum_with_multiplier = max(max_subarray_sum_with_multiplier, new_beauty)\n\n    # The result is the maximum of the beauty without multiplication and with multiplication\n    return max(max_beauty, max_subarray_sum_with_multiplier)\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_beauty_with_multiplication(n, x, a))\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = float('-inf')\n    result_length = 0\n    sequence = []\n\n    while left <= right:\n        if a[left] < a[right]:\n            chosen = None\n            if a[left] > last_taken:\n                chosen = 'L'\n            if a[right] > last_taken and (chosen is None or a[right] > a[left]):\n                chosen = 'R'\n\n            if chosen == 'L':\n                last_taken = a[left]\n                sequence.append(chosen)\n                result_length += 1\n                left += 1\n            elif chosen == 'R':\n                last_taken = a[right]\n                sequence.append(chosen)\n                result_length += 1\n                right -= 1\n            else:\n                break\n        else:\n            chosen = None\n            if a[right] > last_taken:\n                chosen = 'R'\n            if a[left] > last_taken and (chosen is None or a[left] > a[right]):\n                chosen = 'L'\n\n            if chosen == 'R':\n                last_taken = a[right]\n                sequence.append(chosen)\n                result_length += 1\n                right -= 1\n            elif chosen == 'L':\n                last_taken = a[left]\n                sequence.append(chosen)\n                result_length += 1\n                left += 1\n            else:\n                break\n\n    print(result_length)\n    print(''.join(sequence))\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\nlongest_increasing_sequence(n, a)\n```",
    "59": "```python\ndef min_operations_to_remainder(n, x, y, decimal_number):\n    # Define the target pattern based on y and x\n    target_pattern = '0' * y + '1' + '0' * (x - y - 1)\n    \n    # Extract the relevant portion of the number (last x digits)\n    relevant_part = decimal_number[-x:]\n    \n    # Count the number of operations needed to match the target pattern\n    operations_needed = sum(1 for i in range(x) if relevant_part[i] != target_pattern[i])\n    \n    return operations_needed\n\n# Read input values\nn, x, y = map(int, input().split())\ndecimal_number = input().strip()\n\n# Print the result of the minimum operations needed\nprint(min_operations_to_remainder(n, x, y, decimal_number))\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph):\n    visited = [-1] * (len(graph) + 1)\n    queue = deque([start])\n    visited[start] = 0\n    farthest_node = start\n\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if visited[neighbor] == -1:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > visited[farthest_node]:\n                    farthest_node = neighbor\n\n    return farthest_node, visited\n\ndef find_max_edges(n, edges):\n    graph = defaultdict(list)\n    \n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # First BFS to find the farthest node from an arbitrary node (e.g., node 1)\n    farthest_from_start, _ = bfs(1, graph)\n    \n    # Second BFS to find the farthest node from the previously found farthest node\n    farthest_from_a, distances = bfs(farthest_from_start, graph)\n    \n    # The diameter length of the tree\n    diameter_length = distances[farthest_from_a]\n\n    # Reconstruct the path from farthest_from_start to farthest_from_a\n    path = []\n    current = farthest_from_a\n    queue = deque([farthest_from_start])\n    parents = {farthest_from_start: None}\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in parents:\n                parents[neighbor] = node\n                queue.append(neighbor)\n\n    # Backtrack to get the path\n    while current is not None:\n        path.append(current)\n        current = parents[current]\n\n    # Selecting nodes A, B, and C\n    A = path[0]\n    B = path[-1]\n    C = path[len(path) // 2]  # Picking a middle node in the path\n\n    return diameter_length + 1, (A, B, C)\n\n# Input reading\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\n# Find maximum edges and the vertices\nresult, vertices = find_max_edges(n, edges)\n\n# Output the results\nprint(result)\nprint(*vertices)\n```",
    "60": "```python\ndef has_palindrome_subsequence(test_cases):\n    results = []\n    \n    for n, a in test_cases:\n        seen = {}\n        found = False\n        \n        for i in range(n):\n            if a[i] in seen and i - seen[a[i]] >= 2:\n                found = True\n                break\n            seen[a[i]] = i\n        \n        results.append(\"YES\" if found else \"NO\")\n    \n    return results\n\ndef main():\n    t = int(input())\n    test_cases = [(\n        int(input()),\n        list(map(int, input().split()))\n    ) for _ in range(t)]\n\n    results = has_palindrome_subsequence(test_cases)\n\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "63": "```python\ndef minimum_instability(n, a):\n    # Sort the array to easily access the minimum and maximum values\n    a.sort()\n    \n    # Calculate the instability for the two cases of removal\n    instability_remove_min = a[-1] - a[1]  # Remove minimum element\n    instability_remove_max = a[-2] - a[0]  # Remove maximum element\n    \n    # Return the minimum instability after removing one element\n    return min(instability_remove_min, instability_remove_max)\n\n# Input reading\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Output the result\nprint(minimum_instability(n, a))\n```",
    "62": "```python\ndef minimum_operations(test_cases):\n    results = []\n\n    for a, b, c in test_cases:\n        min_operations = float('inf')\n        best_triple = (a, b, c)\n\n        # Try all valid values of A, B, C\n        for A in range(1, a + 2):  # A can be from 1 to a + 1\n            for B in range(max(A, b - 1), b + 2):  # B must be >= A\n                if B % A == 0:  # Check if B is divisible by A\n                    for C in range(max(B, c - 1), c + 2):  # C must be >= B\n                        if C % B == 0:  # Check if C is divisible by B\n                            operations = abs(A - a) + abs(B - b) + abs(C - c)\n                            if operations < min_operations:\n                                min_operations = operations\n                                best_triple = (A, B, C)\n\n        results.append((min_operations, best_triple))\n\n    return results\n\n\n# Read input\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = minimum_operations(test_cases)\n\n# Print output\nfor res in results:\n    print(res[0])\n    print(*res[1])\n```",
    "55": "```python\ndef is_visible(white, black1, black2):\n    # Check if the white sheet is completely covered by either black sheet\n    def is_completely_covered(white, black):\n        wx1, wy1, wx2, wy2 = white\n        bx1, by1, bx2, by2 = black\n        return bx1 <= wx1 and bx2 >= wx2 and by1 <= wy1 and by2 >= wy2\n\n    # Check visibility\n    if is_completely_covered(white, black1) or is_completely_covered(white, black2):\n        return \"NO\"\n\n    wx1, wy1, wx2, wy2 = white\n    b1 = black1\n    b2 = black2\n    \n    # Check if any part of the white sheet is visible\n    if (wx2 <= b1[0] or b1[2] <= wx1 or wy2 <= b1[1] or b1[3] <= wy1) or \\\n       (wx2 <= b2[0] or b2[2] <= wx1 or wy2 <= b2[1] or b2[3] <= wy1):\n        return \"YES\"\n\n    return \"NO\"\n\n\n# Input reading\nwhite_sheet = tuple(map(int, input().split()))\nblack_sheet1 = tuple(map(int, input().split()))\nblack_sheet2 = tuple(map(int, input().split()))\n\n# Output the result\nprint(is_visible(white_sheet, black_sheet1, black_sheet2))\n```",
    "61": "```python\ndef max_after_replacement(n, a, f):\n    # Create a mapping of original digits to their replacements\n    f_map = {str(i + 1): str(f[i]) for i in range(9)}\n\n    # Convert the input number into a list of characters for easy manipulation\n    result = list(a)\n    replacement_started = False\n\n    for i in range(n):\n        current_digit = a[i]\n        new_digit = f_map[current_digit]\n\n        # Start replacing if the new digit is greater than the current digit\n        if new_digit > current_digit and not replacement_started:\n            replacement_started = True\n            result[i] = new_digit\n        # Continue replacing as long as it is beneficial\n        elif replacement_started:\n            if new_digit >= current_digit:\n                result[i] = new_digit\n            else:\n                break  # Stop if no further benefit\n\n    return ''.join(result)\n\n# Input reading\nn = int(input().strip())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\n# Output the result\nprint(max_after_replacement(n, a, f))\n```",
    "65": "```python\ndef moves_to_transform(n, m):\n    if m % n != 0:\n        return -1\n    \n    factor = m // n\n    count_2 = 0\n    count_3 = 0\n    \n    while factor % 2 == 0:\n        factor //= 2\n        count_2 += 1\n    \n    while factor % 3 == 0:\n        factor //= 3\n        count_3 += 1\n    \n    return count_2 + count_3 if factor == 1 else -1\n\ndef main():\n    n, m = map(int, input().split())\n    print(moves_to_transform(n, m))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "57": "```python\ndef assign_gifts(n, friends):\n    # Create a list to store the final gift assignments\n    final_gifts = friends[:]\n    \n    # Identify unassigned friends (f_i = 0) and assigned gifts\n    unassigned = []\n    assigned = set()\n    \n    for i in range(n):\n        if final_gifts[i] == 0:\n            unassigned.append(i + 1)  # Store 1-based index\n        else:\n            assigned.add(final_gifts[i])\n    \n    # Determine gifts that need to be assigned\n    not_assigned_gifts = [i for i in range(1, n + 1) if i not in assigned]\n    \n    # Assign gifts to unassigned friends\n    for i in range(len(unassigned)):\n        friend_index = unassigned[i]\n        gift_index = not_assigned_gifts[i]\n        \n        # Ensure that the gift is not assigned to themselves\n        if gift_index == friend_index:\n            # If gift_index is the same as friend_index, swap with the next one\n            if i + 1 < len(not_assigned_gifts):\n                gift_index = not_assigned_gifts[i + 1]\n                not_assigned_gifts[i + 1] = not_assigned_gifts[i]\n        \n        final_gifts[friend_index - 1] = gift_index\n    \n    return final_gifts\n\n# Read input\nn = int(input())\nfriends = list(map(int, input().split()))\n\n# Get the result\nresult = assign_gifts(n, friends)\n\n# Print the result\nprint(' '.join(map(str, result)))\n```",
    "58": "```python\ndef color_array(n, k, a):\n    from collections import defaultdict\n\n    # Step 1: Create a mapping of values to their indices\n    color_map = defaultdict(list)\n    \n    # Step 2: Fill the color_map with indices of each unique element\n    for index, value in enumerate(a):\n        color_map[value].append(index)\n        \n    # Step 3: Check if the number of unique elements exceeds the available colors\n    if len(color_map) > k:\n        print(\"NO\")\n        return\n    \n    # Step 4: Prepare the coloring array\n    coloring = [0] * n\n    current_color = 1\n    color_count = 0\n    \n    # Step 5: Assign colors to elements ensuring distinct elements have distinct colors\n    for indices in color_map.values():\n        for idx in indices:\n            coloring[idx] = current_color\n        current_color += 1\n        color_count += 1\n        \n        # Reset color if we exceed k\n        if current_color > k:\n            current_color = 1\n            \n    # Step 6: Ensure all colors from 1 to k are used\n    if color_count < k:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, coloring)))\n\n# Example usage:\nn, k = map(int, input().split())\na = list(map(int, input().split()))\ncolor_array(n, k, a)\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Compute the longest prefix which is also a suffix (LPS array)\n    lps = [0] * n\n    j = 0  # Length of the previous longest prefix suffix\n    for i in range(1, n):\n        while j > 0 and t[i] != t[j]:\n            j = lps[j - 1]\n        if t[i] == t[j]:\n            j += 1\n            lps[i] = j\n        else:\n            lps[i] = 0\n\n    # Determine the length of the overlap\n    overlap_length = lps[-1]\n    \n    # Construct the result string\n    result = t + t[overlap_length:] * (k - 1)\n    \n    return result\n\n# Input reading\nn, k = map(int, input().split())\nt = input().strip()\n\n# Generate and print the result string\nresult_string = construct_string(n, k, t)\nprint(result_string)\n```",
    "67": "```python\ndef find_nice_indices(n, a):\n    total_sum = sum(a)\n    count = {}\n    nice_indices = []\n\n    # Count the occurrences of each element\n    for number in a:\n        count[number] = count.get(number, 0) + 1\n\n    for i in range(n):\n        # Calculate the sum of the remaining elements after removing a[i]\n        remaining_sum = total_sum - a[i]\n\n        # Check if remaining_sum is even and calculate the target\n        if remaining_sum % 2 == 0:\n            target = remaining_sum // 2\n            \n            # Ensure that the target is in the remaining elements\n            # We must ensure that if target is the same as a[i], it occurs more than once\n            if (target in count and \n                (target != a[i] or count[target] > 1)):\n                nice_indices.append(i + 1)  # Store index as 1-based\n\n    return nice_indices\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Get nice indices\nnice_indices = find_nice_indices(n, a)\n\n# Print results\nprint(len(nice_indices))\nif nice_indices:\n    print(' '.join(map(str, nice_indices)))\n```",
    "71": "```python\ndef count_set_bits(n: int) -> int:\n    \"\"\"Count the number of set bits (1s) in the binary representation of a number.\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef main():\n    a = int(input(\"Enter an integer (1 ≤ a ≤ 64): \").strip())\n    if 1 <= a <= 64:\n        result = count_set_bits(a)\n        print(result)\n    else:\n        print(\"Input must be between 1 and 64.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import Counter\n\n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n    \n    # Calculate the maximum number of unique subsequences we can create\n    unique_counts = []\n    \n    for length in range(1, n + 1):\n        count_of_length = sum(1 for char in char_count if char_count[char] >= length)\n        if count_of_length > 0:\n            unique_counts.append(count_of_length)\n    \n    total_unique_count = sum(unique_counts)\n\n    # Step 3: Check if it's possible to get k unique subsequences\n    if total_unique_count < k:\n        return -1\n\n    # Step 4: Calculate the minimum cost\n    total_cost = 0\n    remaining_k = k\n\n    # Iterate through potential lengths of subsequences\n    for length in range(n + 1):\n        if remaining_k <= 0:\n            break\n        \n        count_of_length = unique_counts[length] if length < len(unique_counts) else 0\n        if count_of_length > 0:\n            if remaining_k >= count_of_length:\n                total_cost += (n - length) * count_of_length\n                remaining_k -= count_of_length\n            else:\n                total_cost += (n - length) * remaining_k\n                remaining_k = 0\n\n    return total_cost\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "73": "```python\ndef can_complete_wall(n, heights):\n    max_height = max(heights)\n\n    # Count occurrences of each height\n    height_count = {}\n    for height in heights:\n        if height in height_count:\n            height_count[height] += 1\n        else:\n            height_count[height] = 1\n\n    # Check if there are any gaps in the heights\n    for height in range(max_height + 1):\n        if height not in height_count:\n            # If there's a height gap, check if it can be filled\n            if height_count.get(height + 1, 0) < 2:\n                return \"NO\"\n\n    return \"YES\"\n\n# Input reading\nn = int(input())\nheights = list(map(int, input().split()))\n\n# Output result\nprint(can_complete_wall(n, heights))\n```",
    "77": "```python\ndef minimum_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    print(minimum_difference(n))\n```",
    "70": "```python\ndef find_midpoint(start_hour, start_minute, end_hour, end_minute):\n    # Convert start and end times to total minutes\n    start_time = start_hour * 60 + start_minute\n    end_time = end_hour * 60 + end_minute\n    \n    # Calculate midpoint in total minutes\n    midpoint_time = (start_time + end_time) // 2\n    \n    # Convert back to hours and minutes\n    midpoint_hour = midpoint_time // 60\n    midpoint_minute = midpoint_time % 60\n    \n    # Format output with leading zeros\n    return f\"{midpoint_hour:02}:{midpoint_minute:02}\"\n\n# Input reading\nstart_time_input = input().strip()\nend_time_input = input().strip()\n\n# Parse input\nh1, m1 = map(int, start_time_input.split(':'))\nh2, m2 = map(int, end_time_input.split(':'))\n\n# Calculate and print the midpoint\nprint(find_midpoint(h1, m1, h2, m2))\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    days = [0] * n  # Initialize days with 0 (rest days)\n    preparation_needed = [0] * m  # Track preparation days needed for each exam\n    exam_days = set()  # To track exam days\n\n    # Populate exam days and needed preparation days\n    for i in range(m):\n        s, d, c = exams[i]\n        preparation_needed[i] = c\n        for day in range(s - 1, d - 1):  # Convert to 0-based index\n            exam_days.add(day)\n\n    # Check if we have enough days for preparation\n    total_preparation_days = sum(preparation_needed)\n    if total_preparation_days + m > n:  # Total days needed exceeds available days\n        return -1\n\n    # Prepare schedule\n    for i in range(m):\n        s, d, c = exams[i]\n        preparation_days_count = 0\n        \n        # Try to allocate preparation days\n        for day in range(s - 1, d - 1):  # Convert to 0-based index\n            if preparation_days_count < c and days[day] == 0:  # Only prepare if it's a rest day\n                days[day] = i + 1  # Mark day for preparation for exam i\n                preparation_days_count += 1\n        \n        # Check if we allocated enough preparation days\n        if preparation_days_count < c:\n            return -1\n    \n    # Allocate exam days\n    for i in range(m):\n        d = exams[i][1]  # Get the exam day (1-based index)\n        days[d - 1] = m + 1  # Mark the exam day (0-based index)\n\n    return days\n\n# Input reading\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the result\nresult = schedule_exams(n, m, exams)\n\n# Output result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "76": "```python\ndef can_construct_symmetric_square(t, test_cases):\n    results = []\n\n    for n, m, tiles in test_cases:\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n\n        tile_map = {}\n        for tile in tiles:\n            top_left, top_right, bottom_left, bottom_right = tile\n            tile_map[(top_left, top_right)] = (bottom_left, bottom_right)\n\n        can_construct = any((top_right, top_left) in tile_map for (top_left, top_right), (bottom_left, bottom_right) in tile_map.items())\n        \n        results.append(\"YES\" if can_construct else \"NO\")\n\n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = [tuple(map(int, input().split())) + tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, m, tiles))\n\n# Get results\nresults = can_construct_symmetric_square(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "75": "```python\ndef max_days_without_additional_food(a, b, c):\n    # Food schedule: Fish (0, 3, 6), Rabbit (1, 5), Chicken (2, 4)\n    food_schedule = [a, c, b, c, a, b, a]  # Mon, Tue, Wed, Thu, Fri, Sat, Sun\n    max_days = 0\n\n    # Try starting from each day of the week (0 to 6)\n    for start_day in range(7):\n        remaining_food = food_schedule[:]  # Copy food amounts\n        days = 0\n\n        # Simulate days of eating\n        while True:\n            current_day = (start_day + days) % 7\n            if remaining_food[current_day] > 0:\n                remaining_food[current_day] -= 1\n                days += 1\n            else:\n                break\n        \n        max_days = max(max_days, days)\n\n    return max_days\n\n# Read input\na, b, c = map(int, input().split())\n# Get the result\nresult = max_days_without_additional_food(a, b, c)\n# Print the result\nprint(result)\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n    \n    # Early exit if the desired degree is not feasible\n    if D >= n:\n        return \"NO\"\n\n    # Construct the graph from edges\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Check if the first vertex can meet the degree requirement\n    if len(graph[1]) < D:\n        return \"NO\"\n    \n    # Initialize variables for spanning tree construction\n    spanning_tree_edges = []\n    visited = set([1])\n    degree_count = 0\n    \n    # Use BFS to ensure we can reach the required degree for vertex 1\n    queue = deque([1])\n    \n    while queue and degree_count < D:\n        current = queue.popleft()\n        \n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                spanning_tree_edges.append((current, neighbor))\n                visited.add(neighbor)\n                queue.append(neighbor)\n                degree_count += 1\n                \n                if degree_count == D:\n                    break\n    \n    # If we don't have the required degree for vertex 1\n    if degree_count < D:\n        return \"NO\"\n    \n    # Continue to build the spanning tree ensuring connectivity\n    for u, v in edges:\n        if len(spanning_tree_edges) == n - 1:\n            break\n        if (u in visited and v not in visited) or (v in visited and u not in visited):\n            spanning_tree_edges.append((u, v))\n            visited.update([u, v])\n    \n    # Ensure we have a valid spanning tree\n    if len(spanning_tree_edges) != n - 1:\n        return \"NO\"\n    \n    # Prepare the output\n    result = [\"YES\"]\n    result.extend(f\"{u} {v}\" for u, v in spanning_tree_edges)\n    \n    return \"\\n\".join(result)\n\n# Read input\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the result and print\nresult = find_spanning_tree(n, m, D, edges)\nprint(result)\n```",
    "74": "```python\ndef min_cost_to_get_k_subsequences(n, k, s):\n    unique_subsequences = set()\n    subsequence_costs = []\n    \n    # Generate all unique subsequences\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            subsequence = s[i:j]\n            if subsequence not in unique_subsequences:\n                unique_subsequences.add(subsequence)\n                # Cost is n - length of subsequence\n                subsequence_costs.append(n - len(subsequence))\n\n    # Check if we have enough unique subsequences\n    if len(unique_subsequences) < k:\n        return -1  \n\n    # Sort costs to find the minimum total cost for k subsequences\n    subsequence_costs.sort()\n    total_cost = sum(subsequence_costs[:k])\n    \n    return total_cost\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_get_k_subsequences(n, k, s))\n```",
    "82": "```python\ndef max_problems_solved(n, k, problems):\n    left_count = 0\n    \n    # Count solvable problems from the left\n    while left_count < n and problems[left_count] <= k:\n        left_count += 1\n    \n    right_count = 0\n    # Count solvable problems from the right\n    while right_count < n - left_count and problems[n - 1 - right_count] <= k:\n        right_count += 1\n    \n    # Ensure we don't double count the middle problems if left and right counts overlap\n    return left_count + right_count - (left_count + right_count > n)\n\n# Input reading\nn, k = map(int, input().split())\nproblems = list(map(int, input().split()))\n\n# Output the result\nprint(max_problems_solved(n, k, problems))\n```",
    "81": "```python\ndef can_reorder_strings(strings):\n    # Sort strings by their lengths\n    strings.sort(key=len)\n\n    # Check if the ordering is valid\n    for i in range(1, len(strings)):\n        # Check if the previous string is a substring of the current string\n        if strings[i - 1] not in strings[i]:\n            return False, []\n\n    return True, strings\n\ndef main():\n    n = int(input().strip())\n    strings = [input().strip() for _ in range(n)]\n    \n    is_possible, ordered_strings = can_reorder_strings(strings)\n\n    if is_possible:\n        print(\"YES\")\n        print(\"\\n\".join(ordered_strings))\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n: int) -> int:\n    s = str(n)\n    length = len(s)\n    moves = float('inf')\n    \n    # Valid endings for divisibility by 25\n    targets = ['00', '25', '50', '75']\n\n    for target in targets:\n        last_digit, first_digit = target[1], target[0]\n        \n        # Initialize positions as -1 (not found)\n        pos_last = pos_first = -1\n        \n        # Find the position of the last digit in the target\n        for i in range(length - 1, -1, -1):\n            if s[i] == last_digit:\n                pos_last = i\n                break\n        \n        if pos_last == -1:\n            continue  # Skip if last digit not found\n\n        # Find the position of the first digit in the target before the last digit\n        for i in range(pos_last - 1, -1, -1):\n            if s[i] == first_digit:\n                pos_first = i\n                break\n        \n        if pos_first == -1:\n            continue  # Skip if first digit not found\n        \n        # Calculate the moves required to bring first_digit next to last_digit\n        moves_required = (length - 1 - pos_last) + (pos_first - (pos_last - 1))\n        moves = min(moves, moves_required)\n\n    return moves if moves != float('inf') else -1\n\n# Read input\nn = int(input().strip())\n# Get result and print it\nresult = min_moves_to_divisible_by_25(n)\nprint(result)\n```",
    "80": "```python\ndef minimum_colors_to_sort(n, s):\n    # Create a list to store the color for each character\n    colors = [0] * n\n    # A dictionary to store the last positions of each character\n    last_position = {}\n    \n    # The number of unique colors used\n    current_color = 1\n\n    for i in range(n):\n        char = s[i]\n        if char in last_position:\n            # If the character was seen before, assign the same color\n            colors[i] = colors[last_position[char]]\n        else:\n            # If it's a new character, assign a new color\n            colors[i] = current_color\n            current_color += 1\n        \n        last_position[char] = i\n\n    # The number of unique colors used\n    unique_colors = current_color - 1\n    \n    return unique_colors, colors\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Get the result\nresult, coloring = minimum_colors_to_sort(n, s)\n\n# Output the result\nprint(result)\nprint(\" \".join(map(str, coloring)))\n```",
    "72": "```python\ndef maximal_intersection_length(n, segments):\n    if n == 2:\n        # Directly compute the length when there are only two segments\n        return max(0, min(segments[0][1], segments[1][1]) - max(segments[0][0], segments[1][0]))\n\n    # Extract left and right endpoints\n    lefts = [segment[0] for segment in segments]\n    rights = [segment[1] for segment in segments]\n\n    # Initialize arrays for maximum left and minimum right values\n    max_left = [0] * n\n    min_right = [0] * n\n\n    max_left[0] = lefts[0]\n    for i in range(1, n):\n        max_left[i] = max(max_left[i - 1], lefts[i])\n    \n    min_right[n - 1] = rights[n - 1]\n    for i in range(n - 2, -1, -1):\n        min_right[i] = min(min_right[i + 1], rights[i])\n    \n    # Calculate the maximal intersection length excluding each segment\n    max_length = 0\n    for i in range(n):\n        current_max_left = max_left[i - 1] if i > 0 else max_left[1]\n        current_min_right = min_right[i + 1] if i < n - 1 else min_right[n - 2]\n\n        # Calculate the intersection length\n        intersection_length = max(0, current_min_right - current_max_left)\n        max_length = max(max_length, intersection_length)\n\n    return max_length\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split(\"\\n\")\nn = int(data[0])\nsegments = [tuple(map(int, line.split())) for line in data[1:]]\n\n# Get the result and print\nresult = maximal_intersection_length(n, segments)\nprint(result)\n```",
    "85": "```python\ndef find_price(A, B):\n    for price in range(1, 10001):  # Increased upper limit for better coverage\n        if (price * 0.08 // 1 == A) and (price * 0.10 // 1 == B):\n            return price\n    return -1\n\n# Read input\nA, B = map(int, input().strip().split())\n# Find and print the result\nprint(find_price(A, B))\n```",
    "78": "```python\nMOD = 1000000007\n\ndef count_regular_sequences(n, s):\n    len_s = len(s)\n    current_balance = 0\n    min_balance = 0\n\n    # Calculate current balance and minimum balance for the substring s\n    for char in s:\n        if char == '(':\n            current_balance += 1\n        else:\n            current_balance -= 1\n        min_balance = min(min_balance, current_balance)\n\n    # Validity check for substring s\n    if current_balance < 0 or current_balance + n < len_s or min_balance < 0:\n        return 0\n\n    # Dynamic programming table to count valid bracket sequences\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case: one way to have an empty sequence\n\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            dp[i][j] = dp[i - 1][j]  # Add a closing bracket\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1]  # Add an opening bracket\n            dp[i][j] %= MOD\n\n    # Calculate valid sequences that can be formed with remaining brackets\n    valid_sequences = 0\n    for k in range(n + 1):\n        if 0 <= k + current_balance <= n:\n            valid_sequences += dp[n - len_s][k + current_balance]\n            valid_sequences %= MOD\n\n    return valid_sequences\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Output result\nprint(count_regular_sequences(n, s))\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n    \n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            # Calculate the perimeter for the current rectangle configuration\n            perimeter = 2 * (width + height)\n            min_perimeter = min(min_perimeter, perimeter)\n\n            # No need to check for swapped width and height as it gives the same perimeter\n            \n            # Check if we can form rectangles with the individual colors\n            for color_tiles in (a, b):\n                for color_width in range(1, int(color_tiles**0.5) + 1):\n                    if color_tiles % color_width == 0:\n                        color_height = color_tiles // color_width\n                        perimeter = 2 * (color_width + color_height)\n                        min_perimeter = min(min_perimeter, perimeter + 2 * (width + height))\n\n    return min_perimeter\n\n# Read input\na, b = map(int, input().strip().split())\n# Output the result\nprint(minimal_perimeter(a, b))\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects by the rating required in ascending order\n    projects.sort(key=lambda x: x[0])\n    \n    for required_rating, rating_change in projects:\n        if r < required_rating:  # Check if current rating is sufficient\n            return \"NO\"\n        r += rating_change  # Update rating after project completion\n        if r < 0:  # Ensure rating doesn't fall below zero\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_complete_projects(n, r, projects))\n```",
    "92": "```python\ndef find_integer_pair(x):\n    target_product = round(x * 10)\n    \n    for a in range(1, 11):\n        for b in range(1, 11):\n            if a * b == target_product:\n                return a, b\n\n# Read input and convert to float\nx = float(input().strip())\na, b = find_integer_pair(x)\n\n# Print the result\nprint(a, b)\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects by their required rating (a_i)\n    projects.sort(key=lambda x: x[0])\n    \n    count = 0\n    current_rating = r\n    \n    # Try to complete projects in sorted order\n    for a_i, b_i in projects:\n        if current_rating >= a_i:  # Check if we can start the project\n            count += 1  # We can complete this project\n            current_rating += b_i  # Update the rating after completing the project\n            \n            if current_rating < 0:  # Ensure rating does not drop below zero\n                break\n    \n    return count\n\ndef main():\n    # Read input\n    n, r = map(int, input().split())\n    projects = [tuple(map(int, input().split())) for _ in range(n)]\n\n    # Get the maximum number of projects that can be completed\n    result = max_projects(n, r, projects)\n\n    # Print the result\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "86": "```python\ndef can_solve_problems(n, k):\n    # Calculate the minimum and maximum sums based on the conditions\n    min_required = k * (k + 1) // 2\n    max_possible = sum(2 ** i for i in range(k))\n\n    # Check if it's possible to distribute problems\n    if n < min_required or n > max_possible:\n        print(\"NO\")\n        return\n\n    # Start with the minimum configuration\n    a = list(range(1, k + 1))\n    remaining_problems = n - min_required\n\n    # Distribute the remaining problems from the end of the list\n    for i in range(k - 1, -1, -1):\n        # Calculate the maximum increase for a[i]\n        max_increase = (1 << (k - 1 - i)) - 1\n        increase = min(remaining_problems, max_increase)\n        a[i] += increase\n        remaining_problems -= increase\n\n        if remaining_problems <= 0:\n            break\n\n    print(\"YES\")\n    print(' '.join(map(str, a)))\n\n# Input reading\nn, k = map(int, input().split())\ncan_solve_problems(n, k)\n```",
    "91": "```python\ndef max_removable_length(s: str, t: str) -> int:\n    n, m = len(s), len(t)\n    \n    # Initialize arrays to store the first and last occurrences of t's characters in s\n    left, right = [-1] * m, [-1] * m\n\n    # Fill the left array to find the first occurrences\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n\n    # Fill the right array to find the last occurrences\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n\n    # Calculate the maximum removable length\n    max_length = 0\n    \n    # Check removable length between the left and right occurrences\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n\n    # Consider removing characters before the first character of t\n    max_length = max(max_length, left[0])\n    # Consider removing characters after the last character of t\n    max_length = max(max_length, n - right[m - 1] - 1)\n\n    return max_length\n\n# Input reading\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(max_removable_length(s, t))\n```",
    "90": "```python\ndef can_reach_end(n, m, d, platforms):\n    # Calculate total length of platforms\n    total_length = sum(platforms)\n\n    # Calculate minimum required length to place platforms\n    min_required_length = (m - 1) * d + total_length\n    if min_required_length > n:\n        return \"NO\", []\n\n    # Initialize the river configuration\n    river = [0] * n\n    current_position = 0\n\n    for platform_index in range(m):\n        # Place the platform at the current position\n        for j in range(platforms[platform_index]):\n            river[current_position] = platform_index + 1  # 1-based index for platforms\n            current_position += 1\n\n        # Move the current position forward by the jump distance (d) if not the last platform\n        if platform_index < m - 1:\n            current_position += d\n\n    return \"YES\", river\n\n# Read input\nn, m, d = map(int, input().split())\nplatforms = list(map(int, input().split()))\n\n# Get output\nresult, river_configuration = can_reach_end(n, m, d, platforms)\n\n# Print result\nprint(result)\nif result == \"YES\":\n    print(\" \".join(map(str, river_configuration)))\n```",
    "84": "```python\ndef can_color_string(n, s):\n    # Create a list to represent the coloring\n    coloring = ['0'] * n\n    \n    # Dictionary to count occurrences of each character\n    char_count = {}\n    \n    # Count occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Check if any character appears more than 2 times\n    if any(count > 2 for count in char_count.values()):\n        return \"NO\"\n    \n    # Assign colors based on character positions\n    color_toggle = {}\n    for i in range(n):\n        char = s[i]\n        if char not in color_toggle:\n            color_toggle[char] = 0  # Start with color '0'\n        coloring[i] = str(color_toggle[char])\n        # Toggle the color for the next occurrence of the same character\n        color_toggle[char] = 1 - color_toggle[char]\n    \n    return \"YES\", ''.join(coloring)\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Get the result\nresult = can_color_string(n, s)\n\n# Print output\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    print(result[1])\n```",
    "97": "```python\ndef min_coins_to_move_chips(n, chips):\n    even_count = sum(1 for chip in chips if chip % 2 == 0)\n    odd_count = n - even_count\n    return min(even_count, odd_count)\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    chips = list(map(int, input().strip().split()))\n    print(min_coins_to_move_chips(n, chips))\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Initialize the binary string as a list of characters\n    result = []\n    \n    # Determine the starting character based on the majority\n    current_char = '0' if a >= b else '1'\n    \n    # Create the alternating pattern required to satisfy the x transitions\n    for _ in range(x + 1):\n        result.append(current_char)\n        current_char = '1' if current_char == '0' else '0'\n    \n    # Count how many zeros and ones we have used\n    zeros_used = result.count('0')\n    ones_used = result.count('1')\n    \n    # Populate the remaining characters\n    while zeros_used < a or ones_used < b:\n        if zeros_used < a:\n            result.append('0')\n            zeros_used += 1\n        if ones_used < b:\n            result.append('1')\n            ones_used += 1\n            \n    return ''.join(result)\n\n# Read input\na, b, x = map(int, input().split())\n# Generate and print the binary string\nprint(construct_binary_string(a, b, x))\n```",
    "98": "```python\ndef min_moves_to_reach_n(N: int) -> int:\n    min_moves = float('inf')\n\n    # To find the factors of N\n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            # Calculate moves to (i, j)\n            current_moves = (i - 1) + (j - 1)\n            min_moves = min(min_moves, current_moves)\n\n    return min_moves\n\n# Read input\nN = int(input().strip())\n# Output the minimum moves\nprint(min_moves_to_reach_n(N))\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    # Check if the parameters make it impossible to construct such a tree\n    if d > 2 * (k - 1) or (d == 1 and n > 2) or (d == 0 and n > 1) or (n == 1 and d > 0):\n        print(\"NO\")\n        return\n\n    edges = []\n    \n    # Create the main path for diameter d\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n    \n    current_vertex = d + 2  # The next available vertex after creating the diameter path\n\n    # Attach remaining vertices to ensure degree constraints\n    degree = [0] * (d + 2)  # Track the degree of vertices from 1 to d + 1\n\n    for i in range(1, d + 1):\n        while degree[i] < k and current_vertex <= n:\n            edges.append((i, current_vertex))\n            degree[i] += 1\n            current_vertex += 1\n            \n            # If we have filled all vertices, we can stop early\n            if current_vertex > n:\n                break\n\n    # If there are still vertices left, attach them to the last vertex in the diameter path\n    last_vertex = d + 1\n    while current_vertex <= n:\n        if degree[last_vertex] < k:\n            edges.append((last_vertex, current_vertex))\n            degree[last_vertex] += 1\n            current_vertex += 1\n        else:\n            # Find a new vertex to attach current_vertex to\n            for i in range(1, d + 1):\n                if degree[i] < k:\n                    edges.append((i, current_vertex))\n                    degree[i] += 1\n                    current_vertex += 1\n                    break\n\n    print(\"YES\")\n    for u, v in edges:\n        print(u, v)\n\n# Read input\nn, d, k = map(int, input().split())\nconstruct_tree(n, d, k)\n```",
    "88": "```python\ndef is_palindromic_matrix_possible(n, numbers):\n    from collections import Counter\n\n    # Count the frequency of each number\n    count = Counter(numbers)\n\n    # Check for the number of odd occurrences\n    odd_count = sum(1 for freq in count.values() if freq % 2 != 0)\n\n    # For a palindromic matrix:\n    # - If n is even, all numbers must have even frequencies.\n    # - If n is odd, at most one number can have an odd frequency.\n    if (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n        return False, None\n\n    # Initialize the matrix\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Fill the matrix with numbers\n    half_matrix = [[0] * (n // 2) for _ in range(n // 2)]\n    middle_value = None\n\n    # Fill half of the matrix with pairs\n    index = 0\n    for number, freq in count.items():\n        while freq > 0:\n            if freq % 2 == 1:\n                middle_value = number  # Store the middle value for odd n\n            half_matrix[index // (n // 2)][index % (n // 2)] = number\n            freq -= 2\n            index += 1\n\n    # Fill the complete matrix by mirroring the half\n    for i in range(n // 2):\n        for j in range(n // 2):\n            matrix[i][j] = half_matrix[i][j]\n            matrix[i][n - j - 1] = half_matrix[i][j]\n            matrix[n - i - 1][j] = half_matrix[i][j]\n            matrix[n - i - 1][n - j - 1] = half_matrix[i][j]\n\n    # Fill the middle row/column if n is odd\n    if n % 2 == 1 and middle_value is not None:\n        mid_index = n // 2\n        for j in range(n):\n            matrix[mid_index][j] = middle_value\n            matrix[j][mid_index] = middle_value\n            \n    return True, matrix\n\n# Input reading\nn = int(input().strip())\nnumbers = list(map(int, input().strip().split()))\n\n# Check if it's possible to create a palindromic matrix\npossible, result = is_palindromic_matrix_possible(n, numbers)\n\nif possible:\n    print(\"YES\")\n    for row in result:\n        print(\" \".join(map(str, row)))\nelse:\n    print(\"NO\")\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Create a base list with n 'a's, n 'b's, and n 'c's\n    base_list = ['a'] * n + ['b'] * n + ['c'] * n\n\n    # Function to check if the last two characters form a forbidden substring\n    def is_forbidden(last_two):\n        return last_two in {s, t}\n\n    # Attempt to construct a valid string\n    result = []\n    for char in base_list:\n        if len(result) >= 1 and is_forbidden(result[-1] + char):\n            # If appending this char leads to a forbidden substring, try to find a different char\n            for alternate in base_list:\n                if alternate != char and not is_forbidden(result[-1] + alternate):\n                    result.append(alternate)\n                    base_list.remove(alternate)\n                    break\n            else:\n                # If no valid alternate found, return \"NO\"\n                return \"NO\"\n        else:\n            result.append(char)\n\n    return \"YES\\n\" + ''.join(result)\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\nt = input().strip()\n\n# Generate and print the result\nresult = generate_string(n, s, t)\nprint(result)\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    # Step 1: Calculate the prefix sums to find the permutation p\n    p = [0] * n\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n    \n    # Step 2: Normalize the permutation to start from 1\n    min_p = min(p)\n    offset = 1 - min_p\n    \n    # Apply offset to ensure all values are positive and start from 1\n    p = [x + offset for x in p]\n\n    # Step 3: Check if p is a valid permutation\n    if len(set(p)) != n or any(x < 1 or x > n for x in p):\n        return -1\n    return p\n\n# Read input\nn = int(input())\nq = list(map(int, input().split()))\n\n# Get the result\nresult = restore_permutation(n, q)\n\n# Print the output\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "99": "```python\ndef rock_paper_scissors(n, a1, a2, a3, b1, b2, b3):\n    # Calculate maximum wins for Alice\n    max_wins = min(a1, b2) + min(a2, b3) + min(a3, b1)\n    \n    # Calculate losses for Alice\n    alice_losses = max(0, b1 - a3) + max(0, b2 - a1) + max(0, b3 - a2)\n    \n    # Calculate minimum wins for Alice\n    min_wins = n - alice_losses\n    \n    return min_wins, max_wins\n\n# Read input values\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\n# Get results\nmin_wins, max_wins = rock_paper_scissors(n, a1, a2, a3, b1, b2, b3)\n\n# Print results\nprint(min_wins, max_wins)\n```"
}