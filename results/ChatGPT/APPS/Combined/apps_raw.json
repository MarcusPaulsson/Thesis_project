{
    "4": "```python\ndef is_lucky_time(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef find_lucky_time(x, hh, mm):\n    minutes_passed = 0\n    \n    while True:\n        if is_lucky_time(hh, mm):\n            return minutes_passed // x\n        \n        minutes_passed += x\n        mm -= x\n        \n        if mm < 0:\n            mm += 60\n            hh -= 1\n            \n            if hh < 0:\n                hh += 24\n\ndef main():\n    x = int(input())\n    hh, mm = map(int, input().split())\n    print(find_lucky_time(x, hh, mm))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "7": "```python\ndef day_when_barn_empty(n, m):\n    day = 0\n    grains = n\n    \n    while grains > 0:\n        day += 1\n        grains = min(grains + m, n)  # Add grains to the barn, respecting capacity\n        grains -= day  # Sparrows eat grains\n        \n    return day\n\n# Read input\nn, m = map(int, input().split())\n# Output the result\nprint(day_when_barn_empty(n, m))\n```",
    "2": "```python\ndef next_lucky_year(current_year):\n    def is_lucky(year):\n        # Check if the year has no more than one non-zero digit\n        non_zero_digits = [digit for digit in str(year) if digit != '0']\n        return len(non_zero_digits) <= 1\n\n    next_year = current_year + 1\n    while not is_lucky(next_year):\n        next_year += 1\n\n    return next_year - current_year\n\n# Read input\nn = int(input().strip())\n# Output the result\nprint(next_lucky_year(n))\n```",
    "1": "```python\ndef max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n    \n    best_number = x\n    max_sum = sum(int(d) for d in str_x)\n    \n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit and setting all following digits to 9\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        new_number = int(new_number)\n        \n        if new_number > 0:\n            current_sum = sum(int(d) for d in str(new_number))\n            if current_sum > max_sum or (current_sum == max_sum and new_number > best_number):\n                best_number = new_number\n                max_sum = current_sum\n    \n    return best_number\n\nx = int(input().strip())\nprint(max_digit_sum(x))\n```",
    "5": "```python\ndef min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0  # No tabs to close\n\n    seconds = 0\n\n    # Close tabs to the left of l\n    if pos < l:\n        seconds += l - pos  # Move to l\n        seconds += 1  # Close left tabs\n    elif pos > l:\n        seconds += pos - l  # Move to l if needed\n        seconds += 1  # Close left tabs\n\n    # Close tabs to the right of r\n    if pos > r:\n        seconds += pos - r  # Move to r\n        seconds += 1  # Close right tabs\n    elif pos < r:\n        seconds += r - pos  # Move to r if needed\n        seconds += 1  # Close right tabs\n\n    return seconds\n\n# Example usage\nn, pos, l, r = map(int, input().split())\nprint(min_seconds_to_close_tabs(n, pos, l, r))\n```",
    "0": "```python\ndef max_acordion_length(s: str) -> int:\n    left_bracket_index = s.find('[')\n    right_bracket_index = s.rfind(']')\n\n    # Check if valid brackets are found\n    if left_bracket_index == -1 or right_bracket_index == -1 or left_bracket_index >= right_bracket_index:\n        return -1\n\n    # Count colons and vertical lines between the brackets\n    colon_count = s[left_bracket_index + 1:right_bracket_index].count(':')\n    vertical_line_count = s[left_bracket_index + 1:right_bracket_index].count('|')\n\n    # We need at least two colons for a valid accordion\n    if colon_count < 2:\n        return -1\n\n    # The maximum length of the accordion\n    return 2 + vertical_line_count  # 2 for the colons and the vertical lines in between\n\n# Example usage\ns = input().strip()\nprint(max_acordion_length(s))\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    \n    for n, x, blows in queries:\n        min_blows = float('inf')\n        possible = False\n        \n        for d, h in blows:\n            if d >= x:\n                # If we can defeat Zmei in one blow\n                min_blows = min(min_blows, 1)\n                possible = True\n            else:\n                # Calculate the effective reduction after one blow\n                effective_heads = x - d + h\n                if effective_heads < x:\n                    # Calculate how many blows are needed to bring heads to 0\n                    blows_needed = (x - d + h - 1) // (h - d) + 1\n                    min_blows = min(min_blows, blows_needed)\n                    possible = True\n        \n        results.append(min_blows if possible else -1)\n    \n    return results\n```",
    "10": "```python\ndef calculate_days_off(n):\n    full_weeks = n // 7\n    work_days = full_weeks * 5\n    days_off = full_weeks * 2\n    \n    remaining_days = n % 7\n    \n    # Calculate minimum days off\n    min_days_off = days_off\n    # Calculate maximum days off\n    max_days_off = days_off + min(remaining_days, 2)\n    \n    return min_days_off, max_days_off\n\nn = int(input())\nmin_days_off, max_days_off = calculate_days_off(n)\nprint(min_days_off, max_days_off)\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    count_a = n // a\n    count_b = n // b\n    lcm_ab = a * (b // gcd(a, b))\n    count_ab = n // lcm_ab\n\n    # Calculate chocolates if we prioritize Red tiles\n    chocolates_red_first = (count_a - count_ab) * p + (count_b - count_ab) * q + count_ab * max(p, q)\n\n    return chocolates_red_first\n\n# Read input\nn, a, b, p, q = map(int, input().split())\n# Calculate and print the result\nprint(max_chocolates(n, a, b, p, q))\n```",
    "17": "```python\ndef standing_spectators(n, k, t):\n    if t <= k:\n        return t\n    elif t <= n:\n        return k\n    else:\n        return n + k - t\n\n# Input reading\nn, k, t = map(int, input().split())\n# Output the result\nprint(standing_spectators(n, k, t))\n```",
    "9": "```python\ndef find_grandpa_sofa(d, n, m, sofas, counts):\n    cnt_l, cnt_r, cnt_t, cnt_b = counts\n\n    for i in range(d):\n        left_count = right_count = top_count = bottom_count = 0\n        x1_i, y1_i, x2_i, y2_i = sofas[i]\n\n        for j in range(d):\n            if i == j:\n                continue\n            x1_j, y1_j, x2_j, y2_j = sofas[j]\n\n            if x2_i < x1_j:  # Sofa i is to the left of sofa j\n                left_count += 1\n            elif x1_i > x2_j:  # Sofa j is to the left of sofa i\n                right_count += 1\n            if y2_i < y1_j:  # Sofa i is above sofa j\n                top_count += 1\n            elif y1_i > y2_j:  # Sofa j is above sofa i\n                bottom_count += 1\n\n        if (left_count == cnt_l and right_count == cnt_r and \n                top_count == cnt_t and bottom_count == cnt_b):\n            return i + 1  # Return 1-based index\n\n    return -1\n\n# Input reading\nd = int(input())\nn, m = map(int, input().split())\nsofas = [tuple(map(int, input().split())) for _ in range(d)]\ncounts = tuple(map(int, input().split()))\n\n# Output the result\nprint(find_grandpa_sofa(d, n, m, sofas, counts))\n```",
    "15": "```python\ndef is_favorite_in_sequence(a, b, c):\n    if c == 0:\n        return a == b\n    return (b - a) % c == 0 and (b - a) // c >= 0\n\ndef main():\n    a, b, c = map(int, input().split())\n    result = \"YES\" if is_favorite_in_sequence(a, b, c) else \"NO\"\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "8": "```python\ndef min_tiles_to_draw(tiles):\n    from collections import Counter\n\n    # Count occurrences of each tile\n    counts = Counter(tiles)\n\n    # Check for koutsu (triplet)\n    if any(count >= 3 for count in counts.values()):\n        return 0  # Already has a koutsu\n\n    # Organize tiles by suit\n    suits = {'m': [], 'p': [], 's': []}\n    for tile in tiles:\n        number = int(tile[0])\n        suit = tile[1]\n        suits[suit].append(number)\n\n    # Sort the numbers in each suit\n    for suit in suits:\n        suits[suit].sort()\n\n    # Check for existing shuntsu (sequence)\n    for numbers in suits.values():\n        if any(numbers[i] + 1 == numbers[i + 1] and numbers[i] + 2 == numbers[i + 2] for i in range(len(numbers) - 2)):\n            return 0  # Already has a shuntsu\n\n    # Check for possible shuntsu with one draw\n    for numbers in suits.values():\n        for i in range(len(numbers)):\n            # Check for completing a sequence\n            if (numbers[i] - 1) not in numbers or (numbers[i] + 1) not in numbers:\n                return 1  # Can complete a shuntsu with one draw\n\n            # Check for gaps in the sequence\n            if i > 0 and numbers[i] - numbers[i - 1] > 1:\n                return 1  # Can draw a tile to complete a shuntsu\n\n    # If no mentsu can be formed with one draw, it requires two draws\n    return 2\n\n# Read input\ntiles = input().strip().split()\n# Output the result\nprint(min_tiles_to_draw(tiles))\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    # Create a list to track the coverage of each section\n    coverage = [0] * (n + 1)\n\n    # Count the coverage for each painter\n    for l, r in painters:\n        coverage[l] += 1\n        if r + 1 <= n:\n            coverage[r + 1] -= 1\n\n    # Calculate the actual coverage using prefix sums\n    for i in range(1, n + 1):\n        coverage[i] += coverage[i - 1]\n\n    # Calculate the total painted sections with all painters\n    total_painted = sum(1 for i in range(1, n + 1) if coverage[i] > 0)\n\n    max_painted = total_painted\n\n    # Try excluding each pair of painters\n    for i in range(q):\n        for j in range(i + 1, q):\n            # Create a temporary coverage array\n            temp_coverage = coverage[:]\n            l1, r1 = painters[i]\n            l2, r2 = painters[j]\n\n            # Remove the coverage of the excluded painters\n            for k in range(l1, r1 + 1):\n                temp_coverage[k] -= 1\n            for k in range(l2, r2 + 1):\n                temp_coverage[k] -= 1\n\n            # Count the painted sections after excluding the two painters\n            painted_after_exclusion = sum(1 for k in range(1, n + 1) if temp_coverage[k] > 0)\n            max_painted = max(max_painted, painted_after_exclusion)\n\n    return max_painted\n\n# Read input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Get the result and print it\nresult = max_painted_sections(n, q, painters)\nprint(result)\n```",
    "16": "```python\ndef can_form_regular_bracket_sequence(cnt1, cnt2, cnt3, cnt4):\n    # Calculate total open and close brackets\n    total_open = cnt1 + cnt2\n    total_close = cnt2 + cnt4\n    \n    # Check if we can balance the brackets\n    if total_open < total_close:\n        return 0\n    \n    # Check if we have enough opening brackets to match closing ones\n    if cnt1 > cnt4 + cnt2:\n        return 0\n    \n    return 1\n\n# Read input values\ncnt1 = int(input().strip())\ncnt2 = int(input().strip())\ncnt3 = int(input().strip())\ncnt4 = int(input().strip())\n\n# Output the result\nprint(can_form_regular_bracket_sequence(cnt1, cnt2, cnt3, cnt4))\n```",
    "18": "```python\ndef lexicographically_minimal_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        while t and (not u or t[-1] <= u[-1]):\n            u.append(t.pop())\n    \n    return ''.join(u)\n\n# Read input\ns = input().strip()\n# Get the result\nresult = lexicographically_minimal_string(s)\n# Print the result\nprint(result)\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    segments = []\n    current_length = 0\n    \n    # Calculate lengths of segments of 'G's\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n            \n    if current_length > 0:\n        segments.append(current_length)\n    \n    # If there are no 'G's, return 0\n    if not segments:\n        return 0\n    \n    # If there's only one segment, return its length\n    if len(segments) == 1:\n        return segments[0]\n    \n    # Calculate the maximum possible length after one swap\n    max_possible_length = max(segments)\n    \n    for i in range(len(segments) - 1):\n        # Check if we can merge two segments by swapping one 'S'\n        max_possible_length = max(max_possible_length, segments[i] + segments[i + 1])\n    \n    # If we can swap an 'S' with a 'G' at the ends, we can add 1 to the max length\n    if 'S' in trophies:\n        max_possible_length += 1\n    \n    return max_possible_length\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\nprint(max_beauty_after_swap(n, trophies))\n```",
    "14": "```python\ndef restore_stack_sortable_permutation(n, k, given):\n    used = set(given)\n    result = list(given)\n    stack = []\n    next_number = n\n\n    for i in range(k - 1, -1, -1):\n        while next_number > 0 and next_number not in used:\n            stack.append(next_number)\n            next_number -= 1\n\n        if stack and stack[-1] > result[i]:\n            return -1\n\n        while stack and stack[-1] <= result[i]:\n            result.append(stack.pop())\n\n        result.append(result[i])\n\n    while stack:\n        result.append(stack.pop())\n\n    if len(result) != n:\n        return -1\n\n    return result\n\n# Input reading\nn, k = map(int, input().split())\ngiven = list(map(int, input().split()))\n\n# Get the result\nresult = restore_stack_sortable_permutation(n, k, given)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef find_course_order(n, k, main_courses, dependencies):\n    indegree = [0] * (n + 1)\n    graph = defaultdict(list)\n    \n    # Build the graph and indegree array\n    for i in range(1, n + 1):\n        for dep in dependencies[i - 1]:\n            graph[dep].append(i)\n            indegree[i] += 1\n    \n    # Queue for courses that can be taken (indegree 0)\n    queue = deque(course for course in range(1, n + 1) if indegree[course] == 0)\n    \n    order = []\n    taken_courses = set()\n    \n    # Process the courses\n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        taken_courses.add(course)\n        \n        for next_course in graph[course]:\n            indegree[next_course] -= 1\n            if indegree[next_course] == 0:\n                queue.append(next_course)\n    \n    # Check if all main courses can be taken\n    if not all(main in taken_courses for main in main_courses):\n        return -1\n    \n    # Collect the necessary courses\n    necessary_courses = set(main_courses)\n    final_order = []\n    \n    for course in order:\n        if course in necessary_courses:\n            necessary_courses.remove(course)\n        final_order.append(course)\n        if not necessary_courses:\n            break\n    \n    return len(final_order), final_order\n\n# Input reading\nn, k = map(int, input().split())\nmain_courses = list(map(int, input().split()))\ndependencies = [list(map(int, input().split()[1:])) for _ in range(n)]\n\n# Get the result\nresult = find_course_order(n, k, main_courses, dependencies)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(result[0])\n    print(' '.join(map(str, result[1])))\n```",
    "19": "```python\ndef is_records_correct(test_cases):\n    results = []\n    \n    for n, stats in test_cases:\n        valid = True\n        prev_p, prev_c = 0, 0\n        \n        for p, c in stats:\n            if p < prev_p or c < prev_c or c > p:\n                valid = False\n                break\n            if (p - prev_p) < (c - prev_c):\n                valid = False\n                break\n            \n            prev_p, prev_c = p, c\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Read input\nT = int(input())\ntest_cases = []\n\nfor _ in range(T):\n    n = int(input())\n    stats = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, stats))\n\n# Get results\nresults = is_records_correct(test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "21": "```python\ndef max_distance_after_swap(n, a):\n    min_index = a.index(1)\n    max_index = a.index(n)\n\n    # Current distance\n    current_distance = abs(min_index - max_index)\n\n    # Calculate potential new distances after swapping\n    potential_distances = [\n        abs(0 - max_index),  # Swap 1 with the first element\n        abs(n - 1 - max_index),  # Swap 1 with the last element\n        abs(min_index - 0),  # Swap n with the first element\n        abs(min_index - (n - 1))  # Swap n with the last element\n    ]\n\n    # The maximum distance after one swap\n    max_distance = max(current_distance, *potential_distances)\n\n    return max_distance\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_distance_after_swap(n, a))\n```",
    "20": "```python\ndef is_palindrome(time_str):\n    return time_str == time_str[::-1]\n\ndef increment_time(hh, mm):\n    mm += 1\n    if mm == 60:\n        mm = 0\n        hh += 1\n        if hh == 24:\n            hh = 0\n    return hh, mm\n\ndef minutes_until_palindrome(current_time):\n    hh, mm = map(int, current_time.split(':'))\n    minutes = 0\n    \n    while not is_palindrome(f\"{hh:02}:{mm:02}\"):\n        hh, mm = increment_time(hh, mm)\n        minutes += 1\n        \n    return minutes\n\nif __name__ == \"__main__\":\n    current_time = input().strip()\n    print(minutes_until_palindrome(current_time))\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a, b):\n    from itertools import permutations\n\n    a_str = str(a)\n    b_str = str(b)\n\n    # Generate all unique permutations of the digits of a\n    permuted_numbers = set(int(''.join(p)) for p in permutations(a_str))\n\n    # Filter permutations to find the maximum that does not exceed b\n    valid_numbers = [num for num in permuted_numbers if num <= b and len(str(num)) == len(a_str)]\n\n    return max(valid_numbers)\n\n# Input reading\na = int(input().strip())\nb = int(input().strip())\n\n# Get the result and print it\nresult = max_permutation_not_exceeding(a, b)\nprint(result)\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    max_possible_ones = n * (n + 1) // 2\n    if k > max_possible_ones:\n        return -1\n\n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k <= 0:\n            break\n        # Fill the diagonal first\n        if k > 0:\n            matrix[i][i] = 1\n            k -= 1\n        \n        for j in range(i + 1, n):\n            if k <= 1:\n                break\n            # Fill the symmetric positions\n            if k >= 2:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n\n    return matrix if k == 0 else -1\n\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror_chars = {\n        'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M',\n        'O': 'O', 'p': 'q', 'q': 'p', 'R': 'R', 'S': 'S', 'T': 'T',\n        'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X', 'Y': 'Y', 'o': 'o',\n        'x': 'x'\n    }\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        left_char = s[i]\n        right_char = s[n - 1 - i]\n        \n        if mirror_chars.get(left_char) != right_char:\n            return \"NIE\"\n    \n    return \"TAK\"\n\ns = input().strip()\nprint(is_s_palindrome(s))\n```",
    "30": "```python\ndef minimum_traps(m: int, x: int) -> int:\n    \"\"\"\n    Calculate the minimum number of traps needed to catch the x-mouse in a campus with m rooms.\n    \n    Parameters:\n    m (int): The number of rooms.\n    x (int): The parameter of the x-mouse.\n    \n    Returns:\n    int: The minimum number of traps required.\n    \"\"\"\n    return m - 1\n\n# Read input\nm, x = map(int, input().split())\n# Output the result\nprint(minimum_traps(m, x))\n```",
    "24": "```python\ndef can_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # vertical, horizontal, diagonal, anti-diagonal\n    n = 10\n\n    def check_win(x, y):\n        for dx, dy in directions:\n            count = 1  # Count the current position\n            # Check in the positive direction\n            for step in range(1, 5):\n                nx, ny = x + step * dx, y + step * dy\n                if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                    count += 1\n                else:\n                    break\n            # Check in the negative direction\n            for step in range(1, 5):\n                nx, ny = x - step * dx, y - step * dy\n                if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                    count += 1\n                else:\n                    break\n            if count >= 5:\n                return True\n        return False\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                board[i][j] = 'X'  # Place a cross\n                if check_win(i, j):\n                    return \"YES\"\n                board[i][j] = '.'  # Undo the move\n    return \"NO\"\n\n# Read input\nboard = [input().strip() for _ in range(10)]\nprint(can_win(board))\n```",
    "28": "```python\ndef rename_files(n, files):\n    examples = []\n    regulars = []\n    \n    for name, type_ in files:\n        if type_ == '1':\n            examples.append(name)\n        else:\n            regulars.append(name)\n    \n    moves = []\n    # Move examples to their new names\n    for i, example in enumerate(examples):\n        new_name = str(i + 1)\n        moves.append(f\"move {example} {new_name}\")\n    \n    # Move regular tests to their new names\n    for i, regular in enumerate(regulars):\n        new_name = str(len(examples) + i + 1)\n        moves.append(f\"move {regular} {new_name}\")\n    \n    print(len(moves))\n    for move in moves:\n        print(move)\n\n# Read input\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\nrename_files(n, files)\n```",
    "26": "```python\ndef calculate_expressions(x, y, z):\n    expressions = [\n        (x ** (y ** z), \"x^y^z\"),\n        (x ** (z ** y), \"x^z^y\"),\n        ((x ** y) ** z, \"(x^y)^z\"),\n        ((x ** z) ** y, \"(x^z)^y\"),\n        (y ** (x ** z), \"y^x^z\"),\n        (y ** (z ** x), \"y^z^x\"),\n        ((y ** x) ** z, \"(y^x)^z\"),\n        ((y ** z) ** x, \"(y^z)^x\"),\n        (z ** (x ** y), \"z^x^y\"),\n        (z ** (y ** x), \"z^y^x\"),\n        ((z ** x) ** y, \"(z^x)^y\"),\n        ((z ** y) ** x, \"(z^y)^x\"),\n    ]\n    \n    return expressions\n\ndef find_max_expression(x, y, z):\n    expressions = calculate_expressions(x, y, z)\n    max_value, max_index = max(expressions, key=lambda item: item[0])\n    \n    return max_index\n\nif __name__ == \"__main__\":\n    x, y, z = map(float, input().split())\n    result = find_max_expression(x, y, z)\n    print(result)\n```",
    "27": "```python\ndef min_operations(n, s):\n    # Start with the assumption that we will type all characters one by one\n    min_ops = n\n    \n    # Check for possible copy operations\n    for i in range(1, n // 2 + 1):\n        # If the prefix s[0:i] can be doubled and still fit within the string\n        if s[:i] == s[i:2*i] and 2*i <= n:\n            # Calculate operations: type i characters, copy, and type remaining\n            remaining_chars = n - 2 * i\n            min_ops = min(min_ops, i + 1 + remaining_chars)\n    \n    return min_ops\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(min_operations(n, s))\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket: str) -> int:\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    # Calculate the difference\n    diff = abs(sum_first - sum_second)\n    \n    # Create a list of possible changes\n    changes = []\n    if sum_first > sum_second:\n        changes = [9 - digit for digit in first_half] + second_half\n    else:\n        changes = first_half + [9 - digit for digit in second_half]\n    \n    # Sort changes in descending order\n    changes.sort(reverse=True)\n    \n    replacements = 0\n    for change in changes:\n        diff -= change\n        replacements += 1\n        if diff <= 0:\n            break\n    \n    return replacements\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    def can_distribute(x):\n        plates_for_a = (a + x - 1) // x  # Ceiling division\n        plates_for_b = (b + x - 1) // x  # Ceiling division\n        return plates_for_a + plates_for_b <= n\n\n    left, right = 1, max(a, b)\n    result = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_distribute(mid):\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n\n# Input reading\nn, a, b = map(int, input().split())\nprint(max_min_pieces(n, a, b))\n```",
    "37": "```python\ndef can_deal_exact_damage(a, b, c):\n    for x in range(c // a + 1):\n        if (c - a * x) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Input reading\na, b, c = map(int, input().split())\nprint(can_deal_exact_damage(a, b, c))\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    m0, x0, x1 = m, 0, 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef birthday_paradox(n, k):\n    MOD = 1000003\n    days = 1 << n  # 2^n\n    if k > days:\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the probability of no collision\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator = (numerator * (days - i)) % MOD\n        denominator = (denominator * days) % MOD\n\n    # Probability of at least one collision\n    A = (denominator - numerator) % MOD\n    B = denominator\n\n    # Reduce A/B to irreducible form\n    common_gcd = gcd(A, B)\n    A //= common_gcd\n    B //= common_gcd\n\n    return A % MOD, B % MOD\n\n# Read input\nn, k = map(int, input().split())\nresult = birthday_paradox(n, k)\nprint(result[0], result[1])\n```",
    "35": "```python\ndef is_valid_flag(n, m, field):\n    # Check if the number of rows is divisible by 3\n    if n % 3 != 0:\n        return \"NO\"\n    \n    stripe_height = n // 3\n    colors = set()\n    \n    # Check for horizontal stripes\n    for i in range(3):\n        stripe_color = field[i * stripe_height][0]\n        colors.add(stripe_color)\n        \n        for j in range(stripe_height):\n            if field[i * stripe_height + j] != stripe_color * m:\n                return \"NO\"\n    \n    # Check if we have exactly three different colors\n    if len(colors) != 3:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Output result\nprint(is_valid_flag(n, m, field))\n```",
    "32": "```python\ndef is_valid_journey(n, journey):\n    position = 0  # Position on the meridian, starting at North Pole (0 km)\n    MAX_POSITION = 20000  # South Pole position\n\n    for t, direction in journey:\n        # Validate movement from North and South Poles\n        if position == 0 and direction != \"South\":\n            return \"NO\"  # At North Pole, can only move South\n        if position == MAX_POSITION and direction != \"North\":\n            return \"NO\"  # At South Pole, can only move North\n\n        # Update position based on direction\n        if direction == \"North\":\n            position -= t\n        elif direction == \"South\":\n            position += t\n        # West and East do not change the position\n\n        # Check if position goes out of bounds\n        if position < 0 or position > MAX_POSITION:\n            return \"NO\"\n\n    # Must end at North Pole\n    return \"YES\" if position == 0 else \"NO\"\n\n# Input reading\nn = int(input())\njourney = [tuple(input().split()) for _ in range(n)]\njourney = [(int(t), dir) for t, dir in journey]\n\n# Output the result\nprint(is_valid_journey(n, journey))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    \n    # If the entire string is not a palindrome, return its length\n    if not is_palindrome(s):\n        return n\n    \n    # Check if all characters are the same\n    if s.count(s[0]) == n:\n        return 0\n    \n    # If the string is a palindrome but not all characters are the same,\n    # we can remove one character to create a non-palindrome substring\n    return n - 1\n\n# Input reading\ns = input().strip()\n# Output the result\nprint(longest_non_palindrome_substring(s))\n```",
    "40": "```python\ndef determine_round_rating(n, ratings):\n    # Check if any rating has changed\n    for a, b in ratings:\n        if a != b:\n            return \"rated\"\n    \n    # Check if the ratings are in non-increasing order\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            return \"unrated\"\n    \n    return \"maybe\"\n\n# Input reading\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(determine_round_rating(n, ratings))\n```",
    "36": "```python\ndef hexagonal_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 1\n\n    while n >= moves_in_layer:\n        n -= moves_in_layer\n        layer += 1\n        moves_in_layer = 6 * layer\n\n    x, y = layer, 0\n\n    if n == 0:\n        return (x, y)\n\n    directions = [\n        (1, 0),   # right\n        (0, 1),   # top right\n        (-1, 1),  # top left\n        (-1, 0),  # left\n        (0, -1),  # bottom left\n        (1, -1)   # bottom right\n    ]\n\n    dx, dy = directions[n % 6]\n    x += dx * (n // 6 + 1)\n    y += dy * (n // 6 + 1)\n\n    for i in range(n % 6):\n        dx, dy = directions[i]\n        x += dx\n        y += dy\n\n    return (x, y)\n\nn = int(input().strip())\nx, y = hexagonal_coordinates(n)\nprint(x, y)\n```",
    "38": "```python\ndef can_coincide_tracks(n, L, kefa_distances, sasha_distances):\n    # Calculate the differences between consecutive barriers for Kefa and Sasha\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Check if sasha_diffs can be obtained by rotating kefa_diffs\n    double_kefa_diffs = kefa_diffs * 2  # Create a doubled list for easy rotation check\n    for i in range(n):\n        if double_kefa_diffs[i:i + n] == sasha_diffs:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_coincide_tracks(n, L, kefa_distances, sasha_distances))\n```",
    "42": "```python\ndef count_cyclical_strings(n, s):\n    from itertools import product\n\n    def is_valid(t):\n        # Check if s is a substring of any cyclic shift of t\n        double_t = t + t\n        return s in double_t\n\n    count = 0\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if is_valid(t):\n            count += 1\n\n    return count\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_cyclical_strings(n, s))\n```",
    "33": "```python\ndef count_common_ap(a1, b1, a2, b2, L, R):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    def find_first_valid(start, step, offset):\n        if step == 0:\n            return offset if start <= offset <= R else None\n        if start > R:\n            return None\n        if start < L:\n            if (L - offset) % step == 0:\n                return L\n            return L + (step - (L - offset) % step) % step\n        return start + (step - (start - offset) % step) % step\n\n    def find_last_valid(end, step, offset):\n        if step == 0:\n            return offset if L <= offset <= end else None\n        if end < L:\n            return None\n        if end > R:\n            if (R - offset) % step == 0:\n                return R\n            return R - (R - offset) % step\n        return end - (end - offset) % step\n\n    step = a1 * a2 // gcd(a1, a2)\n    offset = b2 - b1\n\n    first_x = find_first_valid(L, step, b1)\n    last_x = find_last_valid(R, step, b1)\n\n    if first_x is None or last_x is None or first_x > last_x:\n        return 0\n\n    return (last_x - first_x) // step + 1\n\n# Input reading\na1, b1, a2, b2, L, R = map(int, input().split())\n# Output the result\nprint(count_common_ap(a1, b1, a2, b2, L, R))\n```",
    "41": "```python\ndef nearest_zero_distance(n, arr):\n    distances = [float('inf')] * n\n    last_zero_index = -1\n\n    # Forward pass to find distances to the nearest zero on the left\n    for i in range(n):\n        if arr[i] == 0:\n            last_zero_index = i\n            distances[i] = 0\n        elif last_zero_index != -1:\n            distances[i] = i - last_zero_index\n\n    # Backward pass to find distances to the nearest zero on the right\n    last_zero_index = -1\n    for i in range(n - 1, -1, -1):\n        if arr[i] == 0:\n            last_zero_index = i\n        elif last_zero_index != -1:\n            distances[i] = min(distances[i], last_zero_index - i)\n\n    print(' '.join(map(str, distances)))\n\n# Example usage:\n# n = int(input())\n# arr = list(map(int, input().split()))\n# nearest_zero_distance(n, arr)\n```",
    "49": "```python\ndef find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n\n    # Determine the range where the k-th digit lies\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    # Find the actual number containing the k-th digit\n    start += (k - 1) // length\n    num_str = str(start)\n\n    # Return the k-th digit\n    return int(num_str[(k - 1) % length])\n\n# Read input and print the result\nk = int(input().strip())\nprint(find_kth_digit(k))\n```",
    "48": "```python\ndef kth_largest_in_multiplication_table(n, m, k):\n    left, right = 1, n * m\n    \n    while left < right:\n        mid = (left + right) // 2\n        count = sum(min(mid // i, m) for i in range(1, n + 1))\n        \n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return left\n\n# Read input\nn, m, k = map(int, input().split())\n# Output the k-th largest number\nprint(kth_largest_in_multiplication_table(n, m, k))\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Calculate the minimum sum of the first k positive integers\n    min_sum = k * (k + 1) // 2\n    \n    # If n is less than the minimum sum, return -1\n    if n < min_sum:\n        return -1\n    \n    # The maximum GCD we can use is n // k\n    max_gcd = n // k\n    \n    # Calculate the actual sequence\n    sequence = [(i + 1) for i in range(k)]\n    \n    # Calculate the current sum of the sequence\n    current_sum = sum(sequence)\n    \n    # Adjust the last element to make the sum equal to n\n    sequence[-1] += (n - current_sum)\n    \n    # Scale the sequence by the maximum GCD\n    sequence = [x * max_gcd for x in sequence]\n    \n    return sequence\n\n# Read input\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "44": "```python\ndef minimal_time_to_post_office(d, k, a, b, t):\n    # Calculate the time if Vasiliy walks the entire distance\n    min_time = d * b\n    \n    # Calculate the number of full segments Vasiliy can drive\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Time taken if Vasiliy drives full segments and walks the remaining distance\n    time_with_driving = full_segments * (k * a + t) + remaining_distance * b - t\n    min_time = min(min_time, time_with_driving)\n    \n    # Check if he can drive fewer segments and walk the rest\n    for segments in range(full_segments + 1):\n        distance_driven = segments * k\n        time_taken = segments * (k * a + t) + (d - distance_driven) * b\n        \n        # If he drives the last segment, he doesn't need to repair after it\n        if segments > 0:\n            time_taken -= t\n        \n        min_time = min(min_time, time_taken)\n    \n    return min_time\n\n# Input reading\nd, k, a, b, t = map(int, input().split())\nprint(minimal_time_to_post_office(d, k, a, b, t))\n```",
    "43": "```python\nimport sys\nimport math\n\ndef minimal_angle_pair(vectors):\n    n = len(vectors)\n    angles = []\n\n    for i, (x, y) in enumerate(vectors):\n        angle = math.atan2(y, x)\n        angles.append((angle, i + 1))  # Store angle and index (1-based)\n\n    # Sort angles\n    angles.sort()\n\n    # To handle the circular nature, append the first angle + 2Ï€\n    angles.append((angles[0][0] + 2 * math.pi, angles[0][1]))\n\n    min_angle = float('inf')\n    min_pair = (0, 0)\n\n    for i in range(n):\n        angle1, index1 = angles[i]\n        angle2, index2 = angles[i + 1]\n        angle_diff = angle2 - angle1\n\n        if angle_diff < min_angle:\n            min_angle = angle_diff\n            min_pair = (index1, index2)\n\n    return min_pair\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read\n    data = input_data().splitlines()\n    n = int(data[0])\n    vectors = [tuple(map(int, line.split())) for line in data[1:n + 1]]\n    \n    result = minimal_angle_pair(vectors)\n    print(result[0], result[1])\n```",
    "46": "```python\ndef count_divisible_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n    \n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n        \n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n        \n    result = sum(count_x[i] * count_y[(5 - i) % 5] for i in range(5))\n    \n    return result\n\nn, m = map(int, input().split())\nprint(count_divisible_pairs(n, m))\n```",
    "47": "```python\ndef max_beauty_with_subarray(n, x, a):\n    def kadane(arr):\n        max_ending_here = max_so_far = 0\n        for value in arr:\n            max_ending_here = max(0, max_ending_here + value)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    original_beauty = kadane(a)\n\n    if x == 0:\n        return original_beauty\n\n    max_increase = 0\n    current_sum = 0\n\n    for value in a:\n        current_sum += value\n        max_increase = max(max_increase, current_sum * x)\n        if current_sum < 0:\n            current_sum = 0\n\n    return max(original_beauty, original_beauty + max_increase)\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_beauty_with_subarray(n, x, a))\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef count_reachable(n):\n    reachable = set()\n    current = n\n    \n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    \n    return len(reachable)\n\nn = int(input().strip())\nprint(count_reachable(n))\n```",
    "54": "```python\ndef min_D_to_equalize(n, a):\n    min_a = min(a)\n    max_a = max(a)\n\n    if max_a == min_a:\n        return 0\n\n    difference = max_a - min_a\n\n    if difference % 2 == 0:\n        return difference // 2\n    return -1\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_D_to_equalize(n, a))\n```",
    "51": "```python\nfrom collections import Counter\nimport sys\n\ndef find_x_y(n, divisors):\n    count = Counter(divisors)\n    x, y = 1, 1\n    \n    for d, freq in count.items():\n        if freq == 2:\n            x *= d\n            y *= d\n        elif freq == 1:\n            if x > y:\n                x *= d\n            else:\n                y *= d\n                \n    return x, y\n\nif __name__ == \"__main__\":\n    n = int(sys.stdin.readline().strip())\n    divisors = list(map(int, sys.stdin.readline().strip().split()))\n    \n    x, y = find_x_y(n, divisors)\n    print(x, y)\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = float('-inf')\n    moves = []\n\n    while left <= right:\n        if a[left] < a[right]:\n            if a[left] > last_taken:\n                moves.append('L')\n                last_taken = a[left]\n                left += 1\n            elif a[right] > last_taken:\n                moves.append('R')\n                last_taken = a[right]\n                right -= 1\n            else:\n                break\n        else:\n            if a[right] > last_taken:\n                moves.append('R')\n                last_taken = a[right]\n                right -= 1\n            elif a[left] > last_taken:\n                moves.append('L')\n                last_taken = a[left]\n                left += 1\n            else:\n                break\n\n    print(len(moves))\n    print(''.join(moves))\n\n# Example usage:\n# n = int(input())\n# a = list(map(int, input().split()))\n# longest_increasing_sequence(n, a)\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_elements = m // 2\n    dp = [[-1] * k for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        row = sorted(matrix[i - 1], reverse=True)\n        current_dp = dp[i - 1][:]\n\n        for j in range(1, max_elements + 1):\n            if j > len(row):\n                break\n            \n            current_sum = sum(row[:j])\n            for r in range(k):\n                if current_dp[r] != -1:\n                    new_sum = current_dp[r] + current_sum\n                    new_remainder = new_sum % k\n                    dp[i][new_remainder] = max(dp[i][new_remainder], new_sum)\n\n        for r in range(k):\n            dp[i][r] = max(dp[i][r], current_dp[r])\n\n    return max(dp[n])\n\n# Example usage:\n# n, m, k = map(int, input().split())\n# matrix = [list(map(int, input().split())) for _ in range(n)]\n# print(max_sum_divisible_by_k(n, m, k, matrix))\n```",
    "59": "```python\ndef min_operations_to_remainder(n, x, y, number):\n    # Create the target pattern with '0's and a '1' at the y-th position\n    target = ['0'] * x\n    target[y] = '1'\n    \n    # Count the number of changes needed\n    changes_needed = sum(1 for i in range(x) if number[n - 1 - i] != target[x - 1 - i])\n    \n    return changes_needed\n\n# Read input\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# Calculate and print the result\nresult = min_operations_to_remainder(n, x, y, number)\nprint(result)\n```",
    "57": "```python\ndef fill_gift_values(n, f):\n    # Create a set of friends who are already receiving gifts\n    received = {fi for fi in f if fi != 0}\n    \n    # Find friends who are not receiving gifts\n    not_received = [i for i in range(1, n + 1) if i not in received]\n    \n    # Fill in the zeros in f\n    result = f[:]\n    zero_indices = [i for i in range(n) if f[i] == 0]\n    \n    for idx, zero_index in enumerate(zero_indices):\n        # Assign the next friend who is not receiving a gift\n        result[zero_index] = not_received[idx]\n    \n    # Ensure no one gives a gift to themselves\n    for i in range(n):\n        if result[i] == i + 1:\n            # Swap with the last not_received friend\n            result[i], result[zero_indices[-1]] = result[zero_indices[-1]], result[i]\n            break\n    \n    return result\n\n# Read input\nn = int(input())\nf = list(map(int, input().split()))\n\n# Get the result and print it\nresult = fill_gift_values(n, f)\nprint(' '.join(map(str, result)))\n```",
    "58": "```python\ndef color_array(n, k, a):\n    from collections import defaultdict\n    \n    # Step 1: Count occurrences of each number\n    count = defaultdict(int)\n    for num in a:\n        count[num] += 1\n    \n    # Step 2: Check if any number occurs more than k times\n    if any(c > k for c in count.values()):\n        return \"NO\"\n    \n    # Step 3: Prepare to assign colors\n    color_assignment = [0] * n\n    color_used = defaultdict(int)\n    \n    # Step 4: Assign colors\n    for i in range(n):\n        num = a[i]\n        color_used[num] += 1\n        color_assignment[i] = color_used[num] % k or k  # Ensure color is in the range [1, k]\n    \n    return \"YES\", color_assignment\n\n# Input reading\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nresult = color_array(n, k, a)\n\n# Output the result\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    print(' '.join(map(str, result[1])))\n```",
    "60": "```python\ndef has_palindromic_subsequence(test_cases):\n    results = []\n    for n, a in test_cases:\n        index_map = {}\n        found = False\n        \n        for i in range(n):\n            if a[i] in index_map:\n                # Check if the distance between the same numbers is at least 2\n                if i - index_map[a[i]] >= 2:\n                    found = True\n                    break\n            index_map[a[i]] = i\n        \n        results.append(\"YES\" if found else \"NO\")\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = [(int(input()), list(map(int, input().split()))) for _ in range(t)]\n\n# Get results\nresults = has_palindromic_subsequence(test_cases)\n\n# Print results\nprint(\"\\n\".join(results))\n```",
    "63": "```python\ndef minimum_instability(n, a):\n    if n <= 2:\n        return 0  # If there are only two elements, removing one will always result in zero instability\n\n    a.sort()\n    # Calculate the instability after removing the smallest or the largest element\n    instability_remove_min = a[-1] - a[1]  # Remove the smallest element\n    instability_remove_max = a[-2] - a[0]  # Remove the largest element\n    \n    return min(instability_remove_min, instability_remove_max)\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(minimum_instability(n, a))\n```",
    "65": "```python\ndef min_moves_to_transform(n, m):\n    if m % n != 0:\n        return -1\n    \n    ratio = m // n\n    moves = 0\n    \n    while ratio > 1:\n        if ratio % 2 == 0:\n            ratio //= 2\n            moves += 1\n        elif ratio % 3 == 0:\n            ratio //= 3\n            moves += 1\n        else:\n            return -1\n    \n    return moves\n\n# Read input\nn, m = map(int, input().split())\n# Print the result\nprint(min_moves_to_transform(n, m))\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Find the longest suffix of t that is also a prefix\n    overlap_length = 0\n    for i in range(1, n):\n        if t[:i] == t[n - i:]:\n            overlap_length = i\n\n    # Construct the result string\n    result = t + (t[overlap_length:] * (k - 1))\n    return result\n\n# Input reading\nn, k = map(int, input().split())\nt = input().strip()\n\n# Output the result\nprint(construct_string(n, k, t))\n```",
    "55": "```python\ndef can_see_white_sheet(white, black1, black2):\n    x1, y1, x2, y2 = white\n    x3, y3, x4, y4 = black1\n    x5, y5, x6, y6 = black2\n\n    # Check if any part of the white sheet is visible\n    visible = (\n        x1 > x4 or  # Left of black sheet 1\n        x2 < x3 or  # Right of black sheet 1\n        y1 > y4 or  # Below black sheet 1\n        y2 < y3 or  # Above black sheet 1\n        x1 > x6 or  # Left of black sheet 2\n        x2 < x5 or  # Right of black sheet 2\n        y1 > y6 or  # Below black sheet 2\n        y2 < y5     # Above black sheet 2\n    )\n\n    # Check if the white sheet is completely covered by both black sheets\n    covered_by_black1 = (x3 < x1 < x4 and y3 < y1 < y4 and x3 < x2 < x4 and y3 < y2 < y4)\n    covered_by_black2 = (x5 < x1 < x6 and y5 < y1 < y6 and x5 < x2 < x6 and y5 < y2 < y6)\n\n    return visible or not (covered_by_black1 and covered_by_black2)\n\n# Read input\nwhite_sheet = tuple(map(int, input().split()))\nblack_sheet1 = tuple(map(int, input().split()))\nblack_sheet2 = tuple(map(int, input().split()))\n\n# Determine if some part of the white sheet can be seen\nif can_see_white_sheet(white_sheet, black_sheet1, black_sheet2):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph):\n    visited = {start: 0}\n    queue = deque([start])\n    farthest_node = start\n    max_distance = 0\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > max_distance:\n                    max_distance = visited[neighbor]\n                    farthest_node = neighbor\n                    \n    return farthest_node, max_distance\n\ndef find_max_edges_in_paths(n, edges):\n    graph = defaultdict(list)\n    \n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Step 1: Find the farthest node from an arbitrary node (1)\n    farthest_from_start, _ = bfs(1, graph)\n    \n    # Step 2: Find the farthest node from the previously found node\n    farthest_from_a, _ = bfs(farthest_from_start, graph)\n    \n    # Step 3: Find the farthest node from the second farthest node\n    farthest_from_b, max_distance = bfs(farthest_from_a, graph)\n    \n    # To find a third distinct vertex not in the path from farthest_from_a to farthest_from_b\n    path = []\n    parent = {}\n    \n    def find_path(node):\n        while node in parent:\n            path.append(node)\n            node = parent[node]\n        path.append(node)\n    \n    def bfs_with_parent(start):\n        queue = deque([start])\n        visited = {start}\n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n    \n    bfs_with_parent(farthest_from_a)\n    find_path(farthest_from_b)\n    \n    path_set = set(path)\n    third_vertex = next((v for v in range(1, n + 1) if v not in path_set), None)\n    \n    return max_distance + 1, farthest_from_a, farthest_from_b, third_vertex\n\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\nmax_edges, a, b, c = find_max_edges_in_paths(n, edges)\nprint(max_edges)\nprint(a, b, c)\n```",
    "61": "```python\ndef max_after_replacement(n, a, f):\n    a_list = list(a)\n    f = [0] + f  # Adjust index to match digit values (1-9)\n    \n    modified = False\n    for i in range(n):\n        original_digit = int(a_list[i])\n        new_digit = f[original_digit]\n        \n        if new_digit > original_digit and not modified:\n            modified = True\n        \n        if modified:\n            a_list[i] = str(new_digit)\n        \n        if modified and new_digit < original_digit:\n            break\n    \n    return ''.join(a_list)\n\n# Input reading\nn = int(input())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\n# Output the result\nprint(max_after_replacement(n, a, f))\n```",
    "67": "```python\ndef find_nice_indices(n, a):\n    total_sum = sum(a)\n    nice_indices = []\n\n    for i in range(n):\n        # Calculate the remaining sum after removing a[i]\n        remaining_sum = total_sum - a[i]\n        # Check if the remaining sum is even and if half of it exists in the array\n        if remaining_sum % 2 == 0 and (remaining_sum // 2) in a:\n            # Ensure that we are not counting the removed element itself\n            if (remaining_sum // 2) != a[i] or a.count(a[i]) > 1:\n                nice_indices.append(i + 1)\n\n    return nice_indices\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    nice_indices = find_nice_indices(n, a)\n    \n    print(len(nice_indices))\n    if nice_indices:\n        print(\" \".join(map(str, nice_indices)))\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        min_moves = float('inf')\n        best_triple = (0, 0, 0)\n\n        # Iterate over possible values for A\n        for A in range(1, a + 1):\n            # Find the closest B that is divisible by A\n            B = (b // A) * A\n            if B < b:\n                B += A\n            \n            # Find the closest C that is divisible by B\n            C = (c // B) * B\n            if C < c:\n                C += B\n            \n            # Calculate the number of operations needed\n            moves = abs(A - a) + abs(B - b) + abs(C - c)\n\n            if moves < min_moves:\n                min_moves = moves\n                best_triple = (A, B, C)\n\n        results.append((min_moves, best_triple))\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations(t, test_cases)\n\n# Output results\nfor moves, (A, B, C) in results:\n    print(moves)\n    print(A, B, C)\n```",
    "71": "```python\ndef count_set_bits(n: int) -> int:\n    \"\"\"Return the number of set bits (1s) in the binary representation of n.\"\"\"\n    return bin(n).count('1')\n\ndef main():\n    a = int(input(\"Enter an integer (1 â‰¤ a â‰¤ 64): \"))\n    if 1 <= a <= 64:\n        print(count_set_bits(a))\n    else:\n        print(\"Input must be between 1 and 64.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
    "73": "```python\ndef can_complete_wall(n, heights):\n    max_height = max(heights)\n    \n    # Calculate the total number of bricks needed\n    total_bricks_needed = sum(max_height - height for height in heights)\n    \n    # Check if the total number of bricks needed is even\n    return total_bricks_needed % 2 == 0\n\n# Input reading\nn = int(input())\nheights = list(map(int, input().split()))\n\n# Output result\nprint(\"YES\" if can_complete_wall(n, heights) else \"NO\")\n```",
    "70": "```python\ndef midpoint_of_contest(start_time, end_time):\n    # Convert start and end times to total minutes\n    start_hours, start_minutes = map(int, start_time.split(':'))\n    end_hours, end_minutes = map(int, end_time.split(':'))\n    \n    start_total_minutes = start_hours * 60 + start_minutes\n    end_total_minutes = end_hours * 60 + end_minutes\n    \n    # Calculate the midpoint in total minutes\n    midpoint_total_minutes = (start_total_minutes + end_total_minutes) // 2\n    \n    # Convert back to hours and minutes\n    midpoint_hours = midpoint_total_minutes // 60\n    midpoint_minutes = midpoint_total_minutes % 60\n    \n    # Format and return the result\n    return f\"{midpoint_hours:02}:{midpoint_minutes:02}\"\n\n# Input reading\nstart_time = input().strip()\nend_time = input().strip()\n\n# Output the midpoint of the contest\nprint(midpoint_of_contest(start_time, end_time))\n```",
    "77": "```python\ndef minimum_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    print(minimum_difference(n))\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    unique_subsequences = set()\n    \n    # Generate all unique subsequences using bit manipulation\n    for i in range(1 << n):\n        subsequence = ''.join(s[j] for j in range(n) if (i & (1 << j)))\n        unique_subsequences.add(subsequence)\n    \n    # If the number of unique subsequences is less than k, return -1\n    if len(unique_subsequences) < k:\n        return -1\n    \n    # Calculate the costs of each unique subsequence\n    costs = sorted(n - len(subseq) for subseq in unique_subsequences)\n    \n    # Return the sum of the smallest k costs\n    return sum(costs[:k])\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    days = [0] * n  # Initialize days with 0 (rest)\n    exam_days = [False] * (n + 1)  # Track exam days\n    prepare_count = [0] * (m + 1)  # Track preparation days for each exam\n\n    # Mark exam days\n    for i in range(m):\n        _, d_i, _ = exams[i]\n        exam_days[d_i] = True\n\n    # Prepare for exams\n    for i in range(m):\n        s_i, d_i, c_i = exams[i]\n        prepared = 0\n        \n        for day in range(s_i - 1, d_i - 1):  # s_i to d_i - 1\n            if prepared < c_i and days[day] == 0:  # If we need more preparation days and it's a rest day\n                days[day] = i + 1  # Prepare for exam i\n                prepared += 1\n        \n        if prepared < c_i:  # If we couldn't prepare enough days\n            return -1\n\n    # Assign exam days\n    for i in range(m):\n        _, d_i, _ = exams[i]\n        days[d_i - 1] = m + 1  # Mark exam day\n\n    return days\n\n# Input reading\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the schedule\nresult = schedule_exams(n, m, exams)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import defaultdict\n    from math import comb\n\n    # Count frequency of each character\n    freq = defaultdict(int)\n    for char in s:\n        freq[char] += 1\n\n    # Calculate the total number of unique subsequences\n    unique_subsequences = 0\n    subsequence_costs = []\n\n    # Generate all possible subsequences and their costs\n    for length in range(1, n + 1):\n        for count in freq.values():\n            if count >= length:\n                # Calculate the number of subsequences of this length\n                num_subsequences = comb(count, length)\n                unique_subsequences += num_subsequences\n                subsequence_costs.append((length, num_subsequences))\n\n    # If we cannot form at least k unique subsequences\n    if unique_subsequences < k:\n        return -1\n\n    # Sort costs by length (cost increases with length)\n    subsequence_costs.sort()\n\n    # Calculate the minimum cost to obtain k unique subsequences\n    total_cost = 0\n    remaining_k = k\n\n    for length, num in subsequence_costs:\n        if remaining_k <= 0:\n            break\n        if num <= remaining_k:\n            total_cost += num * (n - length)\n            remaining_k -= num\n        else:\n            total_cost += remaining_k * (n - length)\n            remaining_k = 0\n\n    return total_cost\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n\n    if D >= n:\n        print(\"NO\")\n        return\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    degree = {i: 0 for i in range(1, n + 1)}\n    spanning_tree_edges = []\n    visited = set()\n\n    # BFS to construct the spanning tree\n    def bfs(start):\n        queue = deque([start])\n        visited.add(start)\n\n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if neighbor not in visited and degree[node] < D:\n                    spanning_tree_edges.append((node, neighbor))\n                    degree[node] += 1\n                    degree[neighbor] += 1\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n                    if degree[node] == D:\n                        break\n\n    bfs(1)\n\n    if degree[1] != D:\n        print(\"NO\")\n        return\n\n    # Add remaining edges to complete the spanning tree\n    for u in range(1, n + 1):\n        for v in graph[u]:\n            if degree[u] < 1 and degree[v] < 1 and (u, v) not in spanning_tree_edges and (v, u) not in spanning_tree_edges:\n                spanning_tree_edges.append((u, v))\n                degree[u] += 1\n                degree[v] += 1\n                if len(spanning_tree_edges) == n - 1:\n                    break\n\n    if len(spanning_tree_edges) == n - 1:\n        print(\"YES\")\n        for u, v in spanning_tree_edges:\n            print(u, v)\n    else:\n        print(\"NO\")\n\n# Example usage:\n# n, m, D = map(int, input().split())\n# edges = [tuple(map(int, input().split())) for _ in range(m)]\n# find_spanning_tree(n, m, D, edges)\n```",
    "76": "```python\ndef can_construct_symmetric_square(t, test_cases):\n    results = []\n    \n    for n, m, tiles in test_cases:\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        can_form = False\n        top_right_bottom_left_pairs = set()\n        \n        for top_left, top_right, bottom_left, bottom_right in tiles:\n            top_right_bottom_left_pairs.add((top_right, bottom_left))\n            if top_left == bottom_right:\n                can_form = True\n        \n        if can_form or any((bottom_left, top_right) in top_right_bottom_left_pairs for _, top_right, bottom_left, _ in tiles):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Example usage:\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        top = list(map(int, input().split()))\n        bottom = list(map(int, input().split()))\n        tiles.append((top[0], top[1], bottom[0], bottom[1]))  # Store as a tuple\n    test_cases.append((n, m, tiles))\n\nresults = can_construct_symmetric_square(t, test_cases)\nfor result in results:\n    print(result)\n```",
    "81": "```python\ndef can_reorder_strings(n, strings):\n    # Sort strings by length and then lexicographically\n    strings.sort(key=lambda x: (len(x), x))\n    \n    # Check if each string is a substring of the next one\n    for i in range(n - 1):\n        if strings[i] not in strings[i + 1]:\n            return \"NO\"\n    \n    return \"YES\", strings\n\n# Input reading\nn = int(input().strip())\nstrings = [input().strip() for _ in range(n)]\n\n# Get the result\nresult = can_reorder_strings(n, strings)\n\n# Output the result\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    print(\"\\n\".join(result[1]))\n```",
    "82": "```python\ndef max_problems_solved(n, k, difficulties):\n    left = 0\n    right = n - 1\n    solved = 0\n\n    while left <= right:\n        if difficulties[left] <= k:\n            solved += 1\n            left += 1\n        elif difficulties[right] <= k:\n            solved += 1\n            right -= 1\n        else:\n            break\n\n    return solved\n\n# Input reading\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Output the result\nprint(max_problems_solved(n, k, difficulties))\n```",
    "85": "```python\ndef find_price(A, B):\n    for price in range(1, 10001):  # Adjusted upper limit to include 10000\n        tax_8 = int(price * 0.08)\n        tax_10 = int(price * 0.10)\n        \n        if tax_8 == A and tax_10 == B:\n            return price\n            \n    return -1\n\nif __name__ == \"__main__\":\n    import sys\n    input_data = sys.stdin.read().strip()\n    A, B = map(int, input_data.split())\n    result = find_price(A, B)\n    print(result)\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    \n    # Possible pairs of digits that can form numbers divisible by 25\n    target_pairs = ['00', '25', '50', '75']\n    min_moves = float('inf')\n    \n    for target in target_pairs:\n        last_digit = target[1]\n        first_digit = target[0]\n        \n        # Find the last occurrence of the last digit\n        last_digit_index = s.rfind(last_digit)\n        if last_digit_index == -1:\n            continue\n        \n        # Find the first occurrence of the first digit before the last digit\n        first_digit_index = s.rfind(first_digit, 0, last_digit_index)\n        if first_digit_index == -1:\n            continue\n        \n        # Calculate moves to bring first_digit to the front of last_digit\n        moves = (last_digit_index - first_digit_index) + (length - 1 - last_digit_index)\n        min_moves = min(min_moves, moves)\n    \n    return min_moves if min_moves != float('inf') else -1\n\n# Example usage:\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n\n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            # Check for red rectangle\n            for red_width in range(1, int(a**0.5) + 1):\n                if a % red_width == 0:\n                    red_height = a // red_width\n                    if red_width <= width and red_height <= height:\n                        # Check for blue rectangle\n                        for blue_width in range(1, int(b**0.5) + 1):\n                            if b % blue_width == 0:\n                                blue_height = b // blue_width\n                                if blue_width <= width and blue_height <= height:\n                                    perimeter = 2 * (width + height)\n                                    min_perimeter = min(min_perimeter, perimeter)\n\n    return min_perimeter\n\n# Input reading\na, b = map(int, input().split())\nprint(minimal_perimeter(a, b))\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    from collections import defaultdict\n    \n    # Step 1: Create a mapping of character positions\n    char_positions = defaultdict(list)\n    for index, char in enumerate(s):\n        char_positions[char].append(index)\n    \n    # Step 2: Create a list to store colors\n    colors = [0] * n\n    color_count = 0\n    \n    # Step 3: Assign colors based on the positions of characters\n    for char in sorted(char_positions.keys()):\n        positions = char_positions[char]\n        current_color = 1\n        \n        for pos in positions:\n            colors[pos] = current_color\n            \n            # If the next character is the same, keep the same color\n            if current_color < color_count:\n                current_color += 1\n        \n        # Update the color count\n        color_count = max(color_count, current_color)\n    \n    return color_count, colors\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult_color_count, result_colors = min_colors_to_sort(n, s)\n\n# Output the result\nprint(result_color_count)\nprint(' '.join(map(str, result_colors)))\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    lefts = [l for l, r in segments]\n    rights = [r for l, r in segments]\n\n    # Precompute prefix and suffix max/min values\n    prefix_max_left = [0] * n\n    suffix_max_left = [0] * n\n    prefix_min_right = [0] * n\n    suffix_min_right = [0] * n\n\n    prefix_max_left[0] = lefts[0]\n    for i in range(1, n):\n        prefix_max_left[i] = max(prefix_max_left[i - 1], lefts[i])\n\n    suffix_max_left[n - 1] = lefts[n - 1]\n    for i in range(n - 2, -1, -1):\n        suffix_max_left[i] = max(suffix_max_left[i + 1], lefts[i])\n\n    prefix_min_right[0] = rights[0]\n    for i in range(1, n):\n        prefix_min_right[i] = min(prefix_min_right[i - 1], rights[i])\n\n    suffix_min_right[n - 1] = rights[n - 1]\n    for i in range(n - 2, -1, -1):\n        suffix_min_right[i] = min(suffix_min_right[i + 1], rights[i])\n\n    max_length = 0\n\n    for i in range(n):\n        if i == 0:\n            max_left = suffix_max_left[1]\n            min_right = suffix_min_right[1]\n        elif i == n - 1:\n            max_left = prefix_max_left[n - 2]\n            min_right = prefix_min_right[n - 2]\n        else:\n            max_left = max(prefix_max_left[i - 1], suffix_max_left[i + 1])\n            min_right = min(prefix_min_right[i - 1], suffix_min_right[i + 1])\n\n        intersection_length = max(0, min_right - max_left)\n        max_length = max(max_length, intersection_length)\n\n    return max_length\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Define the food consumption pattern for each day of the week\n    week_pattern = [0, 1, 2, 0, 1, 2, 0]  # 0: fish, 1: rabbit, 2: chicken\n    food_needed = [3, 2, 2]  # Number of each food type needed in one week\n\n    # Calculate full weeks that can be sustained\n    full_weeks = min(a // food_needed[0], b // food_needed[1], c // food_needed[2])\n    \n    # Deduct the food used for full weeks\n    a -= full_weeks * food_needed[0]\n    b -= full_weeks * food_needed[1]\n    c -= full_weeks * food_needed[2]\n\n    max_days = full_weeks * 7\n\n    # Try starting from each day of the week\n    for start_day in range(7):\n        remaining_a, remaining_b, remaining_c = a, b, c\n        current_days = 0\n        \n        for i in range(7):\n            day = (start_day + i) % 7\n            if day == 0:  # Fish food\n                if remaining_a > 0:\n                    remaining_a -= 1\n                    current_days += 1\n                else:\n                    break\n            elif day == 1:  # Rabbit stew\n                if remaining_b > 0:\n                    remaining_b -= 1\n                    current_days += 1\n                else:\n                    break\n            elif day == 2:  # Chicken stake\n                if remaining_c > 0:\n                    remaining_c -= 1\n                    current_days += 1\n                else:\n                    break\n        \n        max_days = max(max_days, full_weeks * 7 + current_days)\n\n    return max_days\n\n# Input reading\na, b, c = map(int, input().split())\nprint(max_days(a, b, c))\n```",
    "78": "```python\nMOD = 10**9 + 7\n\ndef count_regular_sequences(n, s):\n    m = len(s)\n    \n    # Precompute the Catalan numbers up to 2n\n    catalan = [0] * (n + 1)\n    catalan[0] = 1\n    for i in range(1, n + 1):\n        catalan[i] = sum(catalan[j] * catalan[i - 1 - j] for j in range(i)) % MOD\n\n    # Check the balance of the substring s\n    balance = 0\n    min_balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n\n    # If the total balance is negative or cannot be balanced with n pairs\n    if balance < 0 or balance + n < 0:\n        return 0\n\n    # Count the number of valid sequences\n    total_count = 0\n    for prefix_length in range(n + 1):\n        if prefix_length + m > 2 * n:\n            break\n        \n        prefix_balance = prefix_length + min_balance\n        suffix_balance = n - (prefix_length + balance)\n        \n        if prefix_balance < 0 or suffix_balance < 0:\n            continue\n        \n        total_count += (catalan[prefix_balance] * catalan[suffix_balance]) % MOD\n        total_count %= MOD\n\n    return total_count\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_regular_sequences(n, s))\n```",
    "84": "```python\ndef can_color_string(n, s):\n    from collections import Counter\n    \n    # Count occurrences of each character\n    count = Counter(s)\n    \n    # Check if any character appears more than twice\n    if any(v > 2 for v in count.values()):\n        return \"NO\"\n    \n    # Prepare the coloring array\n    coloring = ['0'] * n\n    last_color = '0'\n    \n    # Assign colors based on the characters\n    for i in range(n):\n        if i > 0 and s[i] == s[i - 1]:\n            coloring[i] = last_color\n        else:\n            last_color = '1' if last_color == '0' else '0'\n            coloring[i] = last_color\n    \n    return \"YES\\n\" + ''.join(coloring)\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(can_color_string(n, s))\n```",
    "92": "```python\nx = float(input().strip())\n\n# Calculate integers a and b based on the input x\na = min(max(int(x * 10), 1), 10)\nb = min(max(int(x * 10) % 10 + 1, 1), 10)\n\nprint(a, b)\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects by required rating, then by rating change\n    projects.sort(key=lambda x: (x[0], x[1]))\n\n    completed_projects = 0\n    current_rating = r\n\n    # Process projects\n    for required_rating, rating_change in projects:\n        if current_rating >= required_rating:\n            completed_projects += 1\n            current_rating += rating_change\n            if current_rating < 0:\n                break\n\n    return completed_projects\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_projects(n, r, projects))\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects by their required rating (a_i)\n    projects.sort(key=lambda x: x[0])\n    \n    for a, b in projects:\n        if r < a:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_complete_projects(n, r, projects))\n```",
    "86": "```python\ndef solve_problems(n, k):\n    # Calculate the minimum sum of problems needed to satisfy the conditions\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n\n    # Initialize the array with the minimum required problems for each day\n    a = list(range(1, k + 1))\n    current_sum = min_sum\n\n    # Calculate remaining problems to distribute\n    remaining = n - current_sum\n\n    # Distribute the remaining problems from the last day to the first\n    for i in range(k - 1, -1, -1):\n        # Maximum we can add to a[i] while satisfying the conditions\n        max_add = a[i]  # We can add at most a[i] to keep the conditions satisfied\n        add = min(remaining, max_add)\n        a[i] += add\n        remaining -= add\n        if remaining <= 0:\n            break\n\n    if remaining > 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n\n# Example usage\nn, k = map(int, input().split())\nsolve_problems(n, k)\n```",
    "91": "```python\ndef max_removable_length(s: str, t: str) -> int:\n    n, m = len(s), len(t)\n    \n    # Create prefix and suffix arrays to track positions of t in s\n    prefix = [-1] * m\n    suffix = [-1] * m\n    \n    # Fill prefix array\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            prefix[j] = i\n            j += 1\n            \n    # Fill suffix array\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            suffix[j] = i\n            j -= 1\n            \n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        if prefix[i] != -1 and suffix[i + 1] != -1:\n            max_length = max(max_length, suffix[i + 1] - prefix[i] - 1)\n    \n    # Consider removing from the start or the end\n    max_length = max(max_length, suffix[0])  # Remove from start\n    max_length = max(max_length, n - 1 - prefix[m - 1])  # Remove from end\n    \n    return max_length\n```",
    "90": "```python\ndef can_reach_end(n, m, d, c):\n    total_length = sum(c)\n\n    # If the maximum jump distance is greater than or equal to the width of the river\n    if d >= n + 1:\n        print(\"YES\")\n        print(\"0 \" + \"0 \" * (n - 1) + str(m))\n        return\n\n    # Calculate the minimum required gap between platforms\n    min_required_gap = (m - 1) * d\n\n    # If the total length of platforms plus the minimum required gaps exceeds n, it's impossible\n    if total_length + min_required_gap > n:\n        print(\"NO\")\n        return\n\n    # Initialize the result array with zeros\n    result = [0] * n\n    position = 0\n\n    for i in range(m):\n        # Place the platform at the current position\n        for j in range(c[i]):\n            result[position] = i + 1\n            position += 1\n        # Move the position to the right by d for the next platform\n        position += d\n\n    print(\"YES\")\n    print(\" \".join(map(str, result)))\n\n# Read input\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Call the function\ncan_reach_end(n, m, d, c)\n```",
    "98": "```python\ndef min_moves_to_reach_n(N):\n    min_moves = float('inf')\n    \n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            moves = (i - 1) + (j - 1)  # Moves to reach (i, j) from (1, 1)\n            min_moves = min(min_moves, moves)\n    \n    return min_moves\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    N = int(input().strip())\n    print(min_moves_to_reach_n(N))\n```",
    "97": "```python\ndef min_coins_to_move_chips(n, positions):\n    even_count = sum(1 for pos in positions if pos % 2 == 0)\n    odd_count = n - even_count\n    return min(even_count, odd_count)\n\n# Input reading\nn = int(input().strip())\npositions = list(map(int, input().strip().split()))\n\n# Output the result\nprint(min_coins_to_move_chips(n, positions))\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    # Initialize the permutation array\n    p = [0] * n\n\n    # Calculate the prefix sums to find the permutation\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n\n    # Find the minimum value in p to adjust the permutation to start from 1\n    min_p = min(p)\n    offset = 1 - min_p\n\n    # Adjust the permutation\n    for i in range(n):\n        p[i] += offset\n\n    # Validate the adjusted permutation\n    if len(set(p)) == n and all(1 <= x <= n for x in p):\n        print(\" \".join(map(str, p)))\n    else:\n        print(-1)\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1 or (d == 1 and n > 2) or (n > k + 1 and d == 1):\n        print(\"NO\")\n        return\n\n    edges = []\n    \n    # Create the main path for the diameter\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n    \n    # Now we have d edges, and we need to connect the remaining vertices\n    current_vertex = d + 2\n    for i in range(1, d + 1):\n        while len([e for e in edges if i in e]) < k and current_vertex <= n:\n            edges.append((i, current_vertex))\n            current_vertex += 1\n            \n    if current_vertex <= n:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    for u, v in edges:\n        print(u, v)\n\n# Read input\nn, d, k = map(int, input().split())\nconstruct_tree(n, d, k)\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Determine the base pattern based on the number of transitions needed\n    pattern = []\n    \n    # Calculate the number of transitions we can create\n    transitions = min(x, a + b - 1)\n    \n    # Create the alternating pattern\n    for i in range(transitions + 1):\n        if i % 2 == 0 and a > 0:\n            pattern.append('0')\n            a -= 1\n        elif i % 2 == 1 and b > 0:\n            pattern.append('1')\n            b -= 1\n    \n    # Fill the remaining characters\n    pattern.append('0' * a)\n    pattern.append('1' * b)\n    \n    # Join the list into a string\n    result = ''.join(pattern)\n    \n    # Return the constructed binary string\n    return result\n\n# Read input\na, b, x = map(int, input().split())\n# Generate and print the binary string\nprint(construct_binary_string(a, b, x))\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Create a list to hold the result\n    res = []\n    \n    # Count of each character\n    counts = {'a': n, 'b': n, 'c': n}\n    \n    # Function to check if the last two characters in res form a forbidden substring\n    def is_forbidden():\n        return ''.join(res[-2:]) in (s, t) if len(res) >= 2 else False\n    \n    # Fill the result while ensuring no forbidden substrings\n    while sum(counts.values()) > 0:\n        for char in 'abc':\n            if counts[char] > 0:\n                res.append(char)\n                counts[char] -= 1\n                \n                # Check if the last two characters form a forbidden substring\n                if is_forbidden():\n                    res.pop()  # Remove the last character added\n                    counts[char] += 1  # Restore the count\n                else:\n                    break  # Valid addition, continue to next character\n\n    # Join the result list into a string\n    result_string = ''.join(res)\n    \n    # Check if the result is valid\n    if len(result_string) == 3 * n and not is_forbidden():\n        return \"YES\\n\" + result_string\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\ns = input().strip()\nt = input().strip()\n\n# Generate and print the result\nprint(generate_string(n, s, t))\n```",
    "99": "```python\ndef rock_paper_scissors(n, a, b):\n    a_rock, a_scissors, a_paper = a  # Alice's counts for rock, scissors, paper\n    b_rock, b_scissors, b_paper = b  # Bob's counts for rock, scissors, paper\n\n    # Calculate maximum wins for Alice\n    max_wins = min(a_rock, b_paper) + min(a_scissors, b_rock) + min(a_paper, b_scissors)\n\n    # Calculate minimum wins for Alice\n    # Calculate losses for Alice\n    alice_losses = max(0, b_rock - a_paper) + max(0, b_scissors - a_rock) + max(0, b_paper - a_scissors)\n    min_wins = n - alice_losses\n\n    return min_wins, max_wins\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Get results\nresult = rock_paper_scissors(n, a, b)\n\n# Output results\nprint(result[0], result[1])\n```",
    "88": "```python\ndef create_palindromic_matrix(n, numbers):\n    from collections import Counter\n    \n    count = Counter(numbers)\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Check for the number of odd occurrences\n    odd_count = sum(1 for freq in count.values() if freq % 2 != 0)\n    \n    # Validate the possibility of creating a palindromic matrix\n    if (n % 2 == 1 and odd_count > 1) or (n % 2 == 0 and odd_count > 0):\n        return \"NO\"\n    \n    # Fill the half matrix with half of the frequencies\n    half_matrix = []\n    for num, freq in count.items():\n        half_matrix.extend([num] * (freq // 2))\n    \n    # Create the top half of the matrix\n    for i in range(n // 2):\n        for j in range(n // 2):\n            if half_matrix:\n                value = half_matrix.pop()\n                matrix[i][j] = value\n                matrix[i][n - j - 1] = value\n                matrix[n - i - 1][j] = value\n                matrix[n - i - 1][n - j - 1] = value\n    \n    # If n is odd, place the center element\n    if n % 2 == 1:\n        center_row = n // 2\n        center_col = n // 2\n        for num, freq in count.items():\n            if freq % 2 == 1:\n                matrix[center_row][center_col] = num\n                break\n    \n    return \"YES\", matrix\n\nn = int(input())\nnumbers = list(map(int, input().split()))\n\nresult = create_palindromic_matrix(n, numbers)\n\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for row in result[1]:\n        print(\" \".join(map(str, row)))\n```"
}