{
    "7": "```python\ndef find_empty_day(n, m):\n    day = 0\n    grains = n\n\n    while grains > 0:\n        day += 1\n        grains = min(grains + m, n)  # Add grains brought to the barn, respecting capacity\n        grains -= day  # Sparrows eat grains\n\n    return day\n\n# Input reading\nn, m = map(int, input().split())\n# Output the result\nprint(find_empty_day(n, m))\n```",
    "2": "```python\ndef is_lucky_year(year):\n    \"\"\"Check if the year is lucky (has at most one non-zero digit).\"\"\"\n    non_zero_digits = sum(1 for digit in str(year) if digit != '0')\n    return non_zero_digits <= 1\n\ndef next_lucky_year(current_year):\n    \"\"\"Find the next lucky year after the current year.\"\"\"\n    next_year = current_year + 1\n    while not is_lucky_year(next_year):\n        next_year += 1\n    return next_year - current_year\n\n# Input\nn = int(input().strip())\n# Output\nprint(next_lucky_year(n))\n```",
    "10": "```python\ndef calculate_days_off(n):\n    complete_weeks = n // 7\n    remaining_days = n % 7\n    \n    # Minimum days off: all complete weeks contribute 2 days off\n    min_days_off = complete_weeks * 2\n    \n    # Maximum days off: can take days off from remaining days\n    max_days_off = min_days_off + min(remaining_days, 2)\n    \n    return min_days_off, max_days_off\n\n# Input\nn = int(input().strip())\n# Calculate and output the result\nmin_off, max_off = calculate_days_off(n)\nprint(min_off, max_off)\n```",
    "5": "```python\ndef minimum_seconds_to_close_tabs(n, pos, l, r):\n    # If no tabs need to be closed\n    if l == 1 and r == n:\n        return 0\n\n    seconds = 0\n\n    if pos < l:\n        # Move cursor to l and close tabs to the left\n        seconds += (l - pos) + 1\n    elif pos > r:\n        # Move cursor to r and close tabs to the right\n        seconds += (pos - r) + 1\n    else:\n        # Cursor is between l and r\n        left_moves = (pos - l) + 1  # Move to l and close left\n        right_moves = (r - pos) + 1  # Move to r and close right\n        seconds += min(left_moves, right_moves)\n\n    return seconds\n\n# Read input\nn, pos, l, r = map(int, input().split())\n# Print the result\nprint(minimum_seconds_to_close_tabs(n, pos, l, r))\n```",
    "0": "```python\ndef max_acordion_length(s: str) -> int:\n    opening_bracket = '['\n    closing_bracket = ']'\n    colon = ':'\n    vertical_line = '|'\n    \n    # Initialize variables to track positions\n    first_colon_index = -1\n    last_colon_index = -1\n    \n    # Traverse the string to find the accordion structure\n    for i, char in enumerate(s):\n        if char == opening_bracket:\n            first_colon_index = s.find(colon, i)\n            if first_colon_index != -1:\n                last_colon_index = s.rfind(colon, first_colon_index + 1)\n                if last_colon_index != -1:\n                    vertical_lines_count = s.count(vertical_line, first_colon_index + 1, last_colon_index)\n                    # Calculate the length of the accordion\n                    accordion_length = 2 + vertical_lines_count  # 2 for brackets and colons\n                    return accordion_length\n    \n    # If no valid accordion structure is found\n    return -1\n\n# Example usage\nprint(max_acordion_length(\"|[a:b:|]\"))  # Output: 4\nprint(max_acordion_length(\"|]:[|:]\"))   # Output: -1\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    \n    for n, x, blows in queries:\n        # Initialize the best blow variables\n        best_d = 0\n        best_h = float('inf')\n        \n        # Find the best blow\n        for d, h in blows:\n            if d > best_d:\n                best_d = d\n                best_h = h\n            elif d == best_d:\n                best_h = min(best_h, h)\n        \n        # If the best blow can defeat Zmei Gorynich in one hit\n        if best_d >= x:\n            results.append(1)\n            continue\n        \n        # If the best blow does not reduce heads effectively\n        if best_h >= best_d:\n            results.append(-1)\n            continue\n        \n        # Calculate the number of blows needed\n        blows_needed = 0\n        while x > 0:\n            blows_needed += 1\n            x -= best_d\n            if x > 0:\n                x += best_h\n        \n        results.append(blows_needed)\n    \n    return results\n\n# Input reading\nt = int(input())\nqueries = []\n\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\n# Get results and print\nresults = min_blows_to_defeat_zmei(t, queries)\nfor result in results:\n    print(result)\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    segments = []\n    current_length = 0\n    \n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n    \n    if current_length > 0:\n        segments.append(current_length)\n    \n    if not segments:\n        return 0\n    \n    max_length = max(segments)\n    \n    if len(segments) > 1:\n        max_length = max(max_length, segments[0] + segments[1] + 1)\n    \n    return max_length\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\n\n# Output the result\nprint(max_beauty_after_swap(n, trophies))\n```",
    "1": "```python\ndef max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n    \n    best_number = x\n    max_digit_sum = sum(int(digit) for digit in str_x)\n    \n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a candidate by reducing the current digit and setting all following digits to '9'\n        candidate = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        candidate_int = int(candidate)\n        \n        if candidate_int <= x:\n            candidate_digit_sum = sum(int(digit) for digit in candidate)\n            if (candidate_digit_sum > max_digit_sum) or (candidate_digit_sum == max_digit_sum and candidate_int > best_number):\n                best_number = candidate_int\n                max_digit_sum = candidate_digit_sum\n    \n    return best_number\n\nif __name__ == \"__main__\":\n    x = int(input().strip())\n    print(max_digit_sum(x))\n```",
    "9": "```python\ndef find_grandpas_sofa(d, n, m, sofas, counts):\n    cnt_l, cnt_r, cnt_t, cnt_b = counts\n\n    for i in range(d):\n        x1, y1, x2, y2 = sofas[i]\n        \n        left_count = sum(1 for j in range(d) if j != i and (sofas[j][0] < x1 and (sofas[j][1] == y1 or sofas[j][3] == y1)))\n        right_count = sum(1 for j in range(d) if j != i and (sofas[j][0] > x2 and (sofas[j][1] == y1 or sofas[j][3] == y1)))\n        top_count = sum(1 for j in range(d) if j != i and (sofas[j][1] < y1 and (sofas[j][0] == x1 or sofas[j][2] == x2)))\n        bottom_count = sum(1 for j in range(d) if j != i and (sofas[j][1] > y2 and (sofas[j][0] == x1 or sofas[j][2] == x2)))\n\n        if (left_count == cnt_l and right_count == cnt_r and \n            top_count == cnt_t and bottom_count == cnt_b):\n            return i + 1  # Return 1-based index\n\n    return -1\n\n# Input reading\nd = int(input())\nn, m = map(int, input().split())\nsofas = [tuple(map(int, input().split())) for _ in range(d)]\ncounts = tuple(map(int, input().split()))\n\n# Output the result\nprint(find_grandpas_sofa(d, n, m, sofas, counts))\n```",
    "15": "```python\ndef is_favorite_in_sequence(a, b, c):\n    if c == 0:\n        return a == b\n    return (b - a) % c == 0 and (b - a) // c >= 0\n\n# Input reading\na, b, c = map(int, input().split())\n\n# Output result\nprint(\"YES\" if is_favorite_in_sequence(a, b, c) else \"NO\")\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    # Calculate the number of tiles painted Red\n    red_tiles = n // a\n    # Calculate the number of tiles painted Blue\n    blue_tiles = n // b\n    # Calculate the number of tiles painted both Red and Blue (overlap)\n    overlap_tiles = n // (a * b)\n    \n    # Total chocolates from Red tiles\n    total_red_chocolates = red_tiles * p\n    # Total chocolates from Blue tiles\n    total_blue_chocolates = blue_tiles * q\n    # Subtract the overlap since they are counted twice\n    total_chocolates = total_red_chocolates + total_blue_chocolates - (overlap_tiles * min(p, q))\n    \n    return total_chocolates\n\n# Example usage\nif __name__ == \"__main__\":\n    print(max_chocolates(5, 2, 3, 12, 15))  # Output: 39\n    print(max_chocolates(20, 2, 3, 3, 5))   # Output: 51\n    print(max_chocolates(1, 1, 1, 1, 1))     # Output: 1\n    print(max_chocolates(1, 2, 2, 2, 2))     # Output: 0\n    print(max_chocolates(2, 1, 3, 3, 3))     # Output: 6\n```",
    "8": "```python\ndef min_tiles_to_draw(tiles):\n    hand = [(int(tile[0]), tile[1]) for tile in tiles]\n\n    def has_koutsu(hand):\n        counts = {}\n        for number, suit in hand:\n            counts[(number, suit)] = counts.get((number, suit), 0) + 1\n        return any(count == 3 for count in counts.values())\n\n    def has_shuntsu(hand):\n        suits = {}\n        for number, suit in hand:\n            suits.setdefault(suit, []).append(number)\n\n        for numbers in suits.values():\n            numbers.sort()\n            for i in range(len(numbers) - 2):\n                if (numbers[i] + 1 in numbers) and (numbers[i] + 2 in numbers):\n                    return True\n        return False\n\n    if has_koutsu(hand) or has_shuntsu(hand):\n        return 0\n\n    needed = float('inf')\n\n    # Check for koutsu formation\n    for number, suit in hand:\n        needed = min(needed, 1)\n\n    # Check for shuntsu formation\n    suits = {}\n    for number, suit in hand:\n        suits.setdefault(suit, []).append(number)\n\n    for numbers in suits.values():\n        numbers.sort()\n        for i in range(len(numbers)):\n            if i > 0 and i < len(numbers) - 1:\n                if numbers[i - 1] + 1 == numbers[i] and numbers[i] + 1 == numbers[i + 1]:\n                    needed = min(needed, 0)\n            if i == 0 and numbers[i] + 1 not in numbers:\n                needed = min(needed, 1)\n            if i == len(numbers) - 1 and numbers[i] - 1 not in numbers:\n                needed = min(needed, 1)\n\n    return needed\n\n# Input reading\ntiles = input().strip().split()\n# Output the result\nprint(min_tiles_to_draw(tiles))\n```",
    "17": "```python\ndef standing_spectators(n, k, t):\n    if t <= k:\n        return t\n    elif t <= n:\n        return k\n    else:\n        return n + k - t\n\n# Read input\nn, k, t = map(int, input().split())\n# Output the result\nprint(standing_spectators(n, k, t))\n```",
    "14": "```python\ndef is_stack_sortable(n, k, p):\n    stack = []\n    result = p[:]\n    used = set(p)\n    next_number = n\n\n    for i in range(k):\n        while stack and stack[-1] == next_number:\n            result.append(stack.pop())\n            next_number -= 1\n\n        if p[i] > next_number:\n            return -1\n\n        stack.append(p[i])\n        next_number = p[i] - 1\n\n    while next_number > 0:\n        if next_number not in used:\n            result.append(next_number)\n        else:\n            while stack and stack[-1] == next_number:\n                result.append(stack.pop())\n        next_number -= 1\n\n    while stack:\n        result.append(stack.pop())\n\n    return result\n\ndef main():\n    n, k = map(int, input().split())\n    p = list(map(int, input().split()))\n\n    result = is_stack_sortable(n, k, p)\n\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "18": "```python\ndef lexicographically_minimal_string(s):\n    t = []\n    u = []\n    n = len(s)\n    index = 0\n\n    while index < n or t:\n        if index < n:\n            t.append(s[index])\n            index += 1\n        \n        # Move characters from t to u if possible\n        while t:\n            # Check if we can pop from t to u\n            if not u or t[-1] <= u[-1]:\n                u.append(t.pop())\n            else:\n                break\n\n    return ''.join(u)\n\n# Read input\ns = input().strip()\n# Get the result\nresult = lexicographically_minimal_string(s)\n# Print the result\nprint(result)\n```",
    "16": "```python\ndef can_form_regular_bracket_sequence(cnt1, cnt2, cnt3, cnt4):\n    # Calculate the total number of opening and closing brackets\n    total_opening = cnt1 + cnt2\n    total_closing = cnt2 + cnt4\n    \n    # Check if the number of opening and closing brackets can balance\n    if total_opening != total_closing:\n        return 0\n    \n    # Check if we can balance the brackets\n    if cnt1 > cnt4 + cnt2:\n        return 0\n    \n    return 1\n\n# Input reading\ncnt1 = int(input().strip())\ncnt2 = int(input().strip())\ncnt3 = int(input().strip())\ncnt4 = int(input().strip())\n\n# Output the result\nprint(can_form_regular_bracket_sequence(cnt1, cnt2, cnt3, cnt4))\n```",
    "13": "```python\nfrom collections import defaultdict, deque\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, k = map(int, data[0].split())\n    main_courses = set(map(int, data[1].split()))\n    \n    dependencies = defaultdict(list)\n    indegree = [0] * (n + 1)\n    \n    for i in range(2, n + 2):\n        line = list(map(int, data[i].split()))\n        t_i = line[0]\n        for j in range(1, t_i + 1):\n            dependencies[line[j]].append(i - 1)  # i - 2 + 2 = i\n            indegree[i - 1] += 1\n    \n    # To track courses that need to be taken\n    courses_to_take = set(main_courses)\n    queue = deque(main_courses)\n    \n    while queue:\n        current = queue.popleft()\n        for prereq in dependencies[current]:\n            indegree[prereq] -= 1\n            if indegree[prereq] == 0:\n                queue.append(prereq)\n                courses_to_take.add(prereq)\n    \n    # Check if we can take all necessary courses\n    if len(courses_to_take) < len(main_courses):\n        print(-1)\n        return\n    \n    # Topological sort to determine the order of courses\n    order = []\n    queue = deque(i for i in range(1, n + 1) if indegree[i] == 0 and i in courses_to_take)\n    \n    while queue:\n        current = queue.popleft()\n        order.append(current)\n        for prereq in dependencies[current]:\n            indegree[prereq] -= 1\n            if indegree[prereq] == 0 and prereq in courses_to_take:\n                queue.append(prereq)\n    \n    if len(order) < len(courses_to_take):\n        print(-1)\n    else:\n        print(len(order))\n        print(' '.join(map(str, order)))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "20": "```python\ndef is_palindrome(time_str):\n    return time_str == time_str[::-1]\n\ndef next_palindrome_time(hh, mm):\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        \n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return (hh, mm)\n\ndef min_sleep_minutes(current_time):\n    hh, mm = map(int, current_time.split(':'))\n    target_hh, target_mm = next_palindrome_time(hh, mm)\n    \n    # Calculate the difference in minutes\n    minutes_passed = (target_hh * 60 + target_mm) - (hh * 60 + mm)\n    return minutes_passed if minutes_passed >= 0 else minutes_passed + 1440\n\n# Input\ncurrent_time = input().strip()\n# Output\nprint(min_sleep_minutes(current_time))\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a: int, b: int) -> int:\n    from itertools import permutations\n\n    str_a = str(a)\n    str_b = str(b)\n    \n    # Generate all unique permutations of the digits of a\n    permuted_numbers = set(int(''.join(p)) for p in permutations(str_a))\n    \n    # Filter valid numbers that are less than or equal to b and have the same length as a\n    valid_numbers = [num for num in permuted_numbers if num <= b and len(str(num)) == len(str_a) and str(num)[0] != '0']\n    \n    # Return the maximum valid number\n    return max(valid_numbers)\n\n# Input reading\na = int(input().strip())\nb = int(input().strip())\n\n# Output the result\nprint(max_permutation_not_exceeding(a, b))\n```",
    "22": "```python\ndef is_s_palindrome(s: str) -> str:\n    # Define a mapping of characters to their mirror reflections\n    mirror_map = {\n        'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M', \n        'O': 'O', 'p': 'q', 'q': 'p', 'R': 'R', 'S': 'S', 'T': 'T', \n        'U': 'U', 'v': 'v', 'W': 'W', 'X': 'X', 'Y': 'Y', 'Z': 'Z', \n        'o': 'o', 'x': 'x'\n    }\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        left_char = s[i]\n        right_char = s[n - 1 - i]\n        \n        # Check if the characters are mirror reflections\n        if left_char not in mirror_map or mirror_map[left_char] != right_char:\n            return \"NIE\"\n    \n    return \"TAK\"\n\n# Read input\ns = input().strip()\n# Print the result\nprint(is_s_palindrome(s))\n```",
    "19": "```python\ndef is_records_correct(test_cases):\n    results = []\n    \n    for n, stats in test_cases:\n        valid = True\n        \n        for i in range(1, n):\n            p_prev, c_prev = stats[i - 1]\n            p_i, c_i = stats[i]\n            \n            if p_i < p_prev or c_i < c_prev or c_i > p_i:\n                valid = False\n                break\n            \n            if (p_i - p_prev) < (c_i - c_prev):\n                valid = False\n                break\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Input reading\nT = int(input())\ntest_cases = []\n\nfor _ in range(T):\n    n = int(input())\n    stats = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, stats))\n\n# Get results and print\nresults = is_records_correct(test_cases)\nprint(\"\\n\".join(results))\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    # Create an array to track the coverage of each section\n    coverage = [0] * (n + 1)\n\n    # Calculate the coverage for each painter\n    for l, r in painters:\n        for i in range(l, r + 1):\n            coverage[i] += 1\n\n    # Calculate the total painted sections with all painters\n    total_painted = sum(1 for i in range(1, n + 1) if coverage[i] > 0)\n\n    # If we need to remove 2 painters, we need to find the minimum impact\n    min_impact = float('inf')\n\n    # Check the impact of removing each pair of painters\n    for i in range(q):\n        for j in range(i + 1, q):\n            # Create a temporary coverage array\n            temp_coverage = coverage[:]\n            l1, r1 = painters[i]\n            l2, r2 = painters[j]\n\n            # Remove the coverage of the i-th painter\n            for k in range(l1, r1 + 1):\n                temp_coverage[k] -= 1\n\n            # Remove the coverage of the j-th painter\n            for k in range(l2, r2 + 1):\n                temp_coverage[k] -= 1\n\n            # Calculate the painted sections after removing the two painters\n            painted_after_removal = sum(1 for k in range(1, n + 1) if temp_coverage[k] > 0)\n            impact = total_painted - painted_after_removal\n            min_impact = min(min_impact, impact)\n\n    # The maximum painted sections after hiring q - 2 painters\n    return total_painted - min_impact\n\n# Input reading\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output the result\nprint(max_painted_sections(n, q, painters))\n```",
    "27": "```python\ndef min_operations(n, s):\n    min_ops = n  # Start with the maximum operations (typing all characters)\n\n    # Check all possible prefix lengths\n    for i in range(1, n):\n        # Check if the prefix can be copied\n        if s[:i] == s[i:i+i]:  # Ensure the prefix matches the next segment\n            # Calculate operations: type prefix + copy + remaining characters\n            operations = i + 1 + (n - (i + i))\n            min_ops = min(min_ops, operations)\n\n    return min_ops\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(min_operations(n, s))\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # The minimum number of traps needed is equal to x\n    return x\n\n# Read input\nm, x = map(int, input().split())\n# Output the result\nprint(minimum_traps(m, x))\n```",
    "24": "```python\ndef can_alice_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # vertical, horizontal, diagonal down-right, diagonal down-left\n    n = 10\n\n    def check_win(x, y):\n        for dx, dy in directions:\n            count = 1  # Start with the current move\n            # Check in the positive direction\n            for step in range(1, 5):\n                nx, ny = x + step * dx, y + step * dy\n                if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                    count += 1\n                else:\n                    break\n            # Check in the negative direction\n            for step in range(1, 5):\n                nx, ny = x - step * dx, y - step * dy\n                if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                    count += 1\n                else:\n                    break\n            if count >= 5:\n                return True\n        return False\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                board[i][j] = 'X'  # Temporarily place 'X'\n                if check_win(i, j):\n                    return \"YES\"\n                board[i][j] = '.'  # Reset the cell\n\n    return \"NO\"\n\n# Read the input\nboard = [input().strip() for _ in range(10)]\nprint(can_alice_win(board))\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    # Check if it's possible to place k ones in a symmetric matrix\n    if k > n * n or (n % 2 == 0 and k % 2 != 0):\n        return -1\n    \n    # Initialize the matrix with zeros\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Fill the matrix to make it lexicographically maximal\n    for i in range(n):\n        if k <= 0:\n            break\n        \n        # Fill the diagonal first if there are remaining ones\n        if k > 0:\n            matrix[i][i] = 1\n            k -= 1\n        \n        # Fill the symmetric pairs (i, j) and (j, i)\n        for j in range(i + 1, n):\n            if k >= 2:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n            \n            if k <= 0:\n                break\n    \n    # Return the matrix or -1 if not possible\n    return matrix if k == 0 else -1\n\n# Input reading\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(\" \".join(map(str, row)))\n```",
    "28": "```python\ndef rename_files(n, files):\n    examples = []\n    regulars = []\n    \n    # Separate files into examples and regular tests\n    for name, type_ in files:\n        if type_ == '1':\n            examples.append(name)\n        else:\n            regulars.append(name)\n    \n    # Prepare the output script\n    moves = []\n    \n    # Rename example files to 1, 2, ..., e\n    for i, example in enumerate(examples):\n        new_name = str(i + 1)\n        moves.append(f\"move {example} {new_name}\")\n    \n    # Rename regular files to e + 1, e + 2, ..., n\n    for i, regular in enumerate(regulars):\n        new_name = str(len(examples) + i + 1)\n        moves.append(f\"move {regular} {new_name}\")\n    \n    # Output the results\n    print(len(moves))\n    for move in moves:\n        print(move)\n\n# Read input\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\n# Call the function\nrename_files(n, files)\n```",
    "26": "```python\ndef calculate_expressions(x, y, z):\n    return [\n        (x ** (y ** z), \"x^y^z\"),\n        (x ** (z ** y), \"x^z^y\"),\n        ((x ** y) ** z, \"(x^y)^z\"),\n        ((x ** z) ** y, \"(x^z)^y\"),\n        (y ** (x ** z), \"y^x^z\"),\n        (y ** (z ** x), \"y^z^x\"),\n        ((y ** x) ** z, \"(y^x)^z\"),\n        ((y ** z) ** x, \"(y^z)^x\"),\n        (z ** (x ** y), \"z^x^y\"),\n        (z ** (y ** x), \"z^y^x\"),\n        ((z ** x) ** y, \"(z^x)^y\"),\n        ((z ** y) ** x, \"(z^y)^x\"),\n    ]\n\ndef find_max_expression(x, y, z):\n    expressions = calculate_expressions(x, y, z)\n    max_value, max_expr = max(expressions, key=lambda item: item[0])\n    return max_expr\n\n# Input reading\nx, y, z = map(float, input().strip().split())\n\n# Finding the maximum expression\nresult = find_max_expression(x, y, z)\n\n# Output the result\nprint(result)\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket: str) -> int:\n    # Split the ticket into two halves and convert to integers\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    # Calculate the sums of both halves\n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    # Calculate the difference\n    difference = abs(sum_first - sum_second)\n    \n    # If the sums are already equal, no replacements are needed\n    if difference == 0:\n        return 0\n    \n    # Create a list of possible changes (max change per digit)\n    changes = []\n    if sum_first < sum_second:\n        # Need to increase the first half or decrease the second half\n        changes.extend(9 - digit for digit in first_half)  # Max increase for first half\n        changes.extend(digit for digit in second_half)     # Max decrease for second half\n    else:\n        # Need to decrease the first half or increase the second half\n        changes.extend(digit for digit in first_half)      # Max decrease for first half\n        changes.extend(9 - digit for digit in second_half) # Max increase for second half\n    \n    # Sort changes in descending order to maximize the effect of each change\n    changes.sort(reverse=True)\n    \n    # Calculate the minimum number of replacements needed\n    replacements = 0\n    for change in changes:\n        difference -= change\n        replacements += 1\n        if difference <= 0:\n            break\n    \n    return replacements\n\n# Example usage\nticket = input().strip()\nprint(min_replacements_to_lucky(ticket))\n```",
    "33": "```python\ndef count_common_terms(a1, b1, a2, b2, L, R):\n    def find_terms(a, b, limit):\n        terms = set()\n        k = 0\n        while True:\n            term = a * k + b\n            if term > limit:\n                break\n            terms.add(term)\n            k += 1\n        return terms\n\n    terms1 = find_terms(a1, b1, R)\n    terms2 = find_terms(a2, b2, R)\n\n    common_terms = terms1.intersection(terms2)\n    count = sum(1 for x in common_terms if L <= x <= R)\n\n    return count\n\n# Input reading\na1, b1, a2, b2, L, R = map(int, input().split())\n# Output the result\nprint(count_common_terms(a1, b1, a2, b2, L, R))\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    def can_distribute(x):\n        plates_from_a = a // x\n        plates_from_b = b // x\n        return plates_from_a + plates_from_b >= n\n\n    left, right = 1, max(a, b)\n    result = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_distribute(mid):\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n\nif __name__ == \"__main__\":\n    n, a, b = map(int, input().split())\n    print(max_min_pieces(n, a, b))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    \n    # If the entire string is not a palindrome, return its length\n    if not is_palindrome(s):\n        return n\n    \n    # Check if all characters are the same\n    if s.count(s[0]) == n:\n        return 0\n    \n    # If the string is a palindrome but not all characters are the same,\n    # the longest non-palindrome substring can be obtained by removing\n    # one character from either end.\n    return n - 1\n\n# Input\ns = input().strip()\n# Output\nprint(longest_non_palindrome_substring(s))\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    m0, x0, x1 = m, 0, 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef birthday_paradox(n, k):\n    MOD = 10**6 + 3\n    days = 1 << n  # 2^n days\n\n    if k > days:\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the probability of no shared birthdays\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator = (numerator * (days - i)) % MOD\n        denominator = (denominator * days) % MOD\n\n    # Probability of at least one shared birthday\n    A = (denominator - numerator) % MOD\n    B = denominator\n\n    # Reduce A/B to irreducible form\n    common_gcd = gcd(A, B)\n    A //= common_gcd\n    B //= common_gcd\n\n    return A % MOD, B % MOD\n\n# Input reading\nn, k = map(int, input().split())\nresult = birthday_paradox(n, k)\nprint(result[0], result[1])\n```",
    "38": "```python\ndef can_coincide(n, L, kefa_distances, sasha_distances):\n    # Calculate the gaps between consecutive barriers for both Kefa and Sasha\n    kefa_gaps = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    sasha_gaps = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Double the Kefa gaps to facilitate rotation comparison\n    doubled_kefa_gaps = kefa_gaps * 2\n    \n    # Check if Sasha's gaps can be found in the doubled Kefa gaps\n    for i in range(n):\n        if doubled_kefa_gaps[i:i+n] == sasha_gaps:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_coincide(n, L, kefa_distances, sasha_distances))\n```",
    "32": "```python\ndef is_valid_journey(n, journey):\n    current_position = 0  # Position in kilometers from the North Pole (0 to 20000)\n\n    for t, direction in journey:\n        if current_position == 0 and direction != \"South\":\n            return \"NO\"  # At North Pole, can only move South\n        if current_position == 20000 and direction != \"North\":\n            return \"NO\"  # At South Pole, can only move North\n        \n        if direction == \"South\":\n            current_position += t\n        elif direction == \"North\":\n            current_position -= t\n        # West and East do not affect the North/South position\n        # No need to handle them explicitly as they don't change current_position\n        \n        # Check if the position goes out of bounds\n        if current_position < 0 or current_position > 20000:\n            return \"NO\"\n    \n    # Journey must end at the North Pole\n    return \"YES\" if current_position == 0 else \"NO\"\n\n# Input reading\nn = int(input())\njourney = [tuple(input().split()) for _ in range(n)]\njourney = [(int(t), direction) for t, direction in journey]\n\n# Output the result\nprint(is_valid_journey(n, journey))\n```",
    "35": "```python\ndef is_valid_flag(n, m, field):\n    # Check if the number of rows is divisible by 3\n    if n % 3 != 0:\n        return \"NO\"\n    \n    stripe_height = n // 3\n    colors = set()\n    \n    # Check for horizontal stripes\n    for i in range(3):\n        stripe = field[i * stripe_height:(i + 1) * stripe_height]\n        first_color = stripe[0][0]\n        \n        # Check if all characters in the stripe are the same and equal to the first color\n        if any(row != first_color * m for row in stripe):\n            return \"NO\"\n        \n        colors.add(first_color)\n    \n    # Check if we have exactly three different colors\n    if len(colors) != 3:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(is_valid_flag(n, m, field))\n```",
    "40": "```python\ndef determine_round_rating(n, ratings):\n    # Check if any participant's rating has changed\n    for before, after in ratings:\n        if before != after:\n            return \"rated\"\n    \n    # Check if the standings are in non-increasing order of ratings\n    for i in range(1, n):\n        if ratings[i-1][0] < ratings[i][0]:\n            return \"unrated\"\n    \n    return \"maybe\"\n\n# Read input\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Determine and print the result\nprint(determine_round_rating(n, ratings))\n```",
    "36": "```python\ndef get_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    # Determine the layer of the spiral\n    layer = 0\n    while n > 6 * layer:\n        n -= 6 * layer\n        layer += 1\n\n    # Initialize coordinates based on the layer\n    x, y = layer, 0\n\n    # Calculate the coordinates based on the position in the layer\n    if n > 0:\n        if n <= layer:\n            x -= n\n        elif n <= 2 * layer:\n            x = -layer\n            y += (n - layer)\n        elif n <= 3 * layer:\n            x += (n - 2 * layer)\n            y = layer\n        elif n <= 4 * layer:\n            x += layer\n            y -= (n - 3 * layer)\n        elif n <= 5 * layer:\n            x = (n - 4 * layer) - layer\n            y -= layer\n        else:  # n <= 6 * layer\n            x -= (layer - (n - 5 * layer))\n            y = -layer\n\n    return (x, y)\n\n# Read input\nn = int(input().strip())\n# Get coordinates and print\ncoordinates = get_coordinates(n)\nprint(coordinates[0], coordinates[1])\n```",
    "41": "```python\ndef nearest_zero_distance(n, arr):\n    distances = [float('inf')] * n\n    last_zero_index = -1\n\n    # First pass: from left to right\n    for i in range(n):\n        if arr[i] == 0:\n            last_zero_index = i\n            distances[i] = 0\n        elif last_zero_index != -1:\n            distances[i] = i - last_zero_index\n\n    # Second pass: from right to left\n    last_zero_index = -1\n    for i in range(n - 1, -1, -1):\n        if arr[i] == 0:\n            last_zero_index = i\n        elif last_zero_index != -1:\n            distances[i] = min(distances[i], last_zero_index - i)\n\n    return distances\n\n# Input reading\nn = int(input().strip())\narr = list(map(int, input().strip().split()))\n\n# Get the result and print it\nresult = nearest_zero_distance(n, arr)\nprint(\" \".join(map(str, result)))\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n\n    # Function to check if a string contains s as a substring\n    def contains_substring(t, s):\n        return s in t\n\n    # Generate all binary strings of length n\n    all_strings = [''.join(p) for p in product('01', repeat=n)]\n    distinct_cyclic_strings = set()\n\n    for t in all_strings:\n        # Check all cyclic shifts of t\n        for i in range(n):\n            cyclic_shift = t[i:] + t[:i]\n            if contains_substring(cyclic_shift, s):\n                distinct_cyclic_strings.add(t)\n                break  # No need to check further shifts for this string\n\n    return len(distinct_cyclic_strings)\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_cyclic_strings(n, s))\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Calculate the minimum sum of the first k natural numbers\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        return -1\n\n    # Calculate the maximum possible GCD\n    max_gcd = n // k\n    while max_gcd > 0:\n        # Calculate the required sum with this GCD\n        required_sum = min_sum * max_gcd\n        if required_sum <= n:\n            # If we can form the sequence\n            sequence = [(i * max_gcd) for i in range(1, k + 1)]\n            return sequence\n        max_gcd -= 1\n\n    return -1\n\n# Input reading\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    length = 1  # Current digit length\n    count = 9   # Count of numbers with the current digit length\n    start = 1   # Starting number with the current digit length\n\n    # Determine the range where the k-th digit lies\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    # Find the actual number containing the k-th digit\n    start += (k - 1) // length\n    num_str = str(start)\n\n    # Find the specific digit\n    digit_index = (k - 1) % length\n    return num_str[digit_index]\n\nif __name__ == \"__main__\":\n    k = int(input().strip())\n    print(find_kth_digit(k))\n```",
    "46": "```python\ndef count_divisible_pairs(n, m):\n    # Count occurrences of each remainder when divided by 5\n    count_x = [0] * 5\n    count_y = [0] * 5\n\n    # Count how many numbers in range 1 to n give each remainder when divided by 5\n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n\n    # Count how many numbers in range 1 to m give each remainder when divided by 5\n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n\n    # Calculate the number of valid pairs\n    total_pairs = sum(count_x[r] * count_y[(5 - r) % 5] for r in range(5))\n\n    return total_pairs\n\n# Read input\nn, m = map(int, input().split())\n# Print the result\nprint(count_divisible_pairs(n, m))\n```",
    "44": "```python\ndef minimal_time_to_post_office(d, k, a, b, t):\n    # Calculate the time if Vasiliy walks the entire distance\n    min_time = d * b\n    \n    # Calculate the number of full segments Vasiliy can drive\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Calculate time for driving full segments and walking the remaining distance\n    time_with_driving = (full_segments * (k * a + t)) + (remaining_distance * a)\n    \n    # If there are full segments, subtract the last repair time\n    if full_segments > 0:\n        time_with_driving -= t\n    \n    # Update minimum time if driving is better\n    min_time = min(min_time, time_with_driving)\n    \n    # Check if he can drive the last segment without needing to repair\n    if remaining_distance > 0:\n        time_with_driving += t + (remaining_distance * a)\n        min_time = min(min_time, time_with_driving)\n    \n    return min_time\n\n# Read input values\nd, k, a, b, t = map(int, input().split())\n# Output the minimal time\nprint(minimal_time_to_post_office(d, k, a, b, t))\n```",
    "51": "```python\ndef find_x_y(n, divisors):\n    from collections import Counter\n    \n    # Count the occurrences of each divisor\n    divisor_count = Counter(divisors)\n    \n    # Initialize x and y\n    x = 1\n    y = 1\n    \n    # Iterate through the counted divisors\n    for d, count in divisor_count.items():\n        if count == 2:\n            # If the divisor appears twice, it is a common divisor\n            x *= d\n            y *= d\n        elif count == 1:\n            # If the divisor appears once, assign it to x or y\n            if x < y:\n                x *= d\n            else:\n                y *= d\n    \n    return x, y\n\n# Input reading\nn = int(input().strip())\ndivisors = list(map(int, input().strip().split()))\n\n# Find x and y\nx, y = find_x_y(n, divisors)\n\n# Output the result\nprint(x, y)\n```",
    "54": "```python\ndef find_minimum_D(n, a):\n    min_a = min(a)\n    max_a = max(a)\n\n    if min_a == max_a:\n        return 0  # All elements are already equal\n\n    # Calculate the difference between the maximum and minimum values\n    diff = max_a - min_a\n\n    # Check if the difference can be evenly divided into three parts\n    if diff % 2 == 0:\n        return diff // 2\n    else:\n        return -1\n\n# Input reading\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Output the result\nprint(find_minimum_D(n, a))\n```",
    "56": "```python\ndef remove_trailing_zeros(x):\n    \"\"\"Increment x by 1 and remove trailing zeros.\"\"\"\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef count_reachable_numbers(n):\n    \"\"\"Count how many different numbers are reachable from n using the function f.\"\"\"\n    reachable_numbers = set()\n    current = n\n    \n    while current not in reachable_numbers:\n        reachable_numbers.add(current)\n        current = remove_trailing_zeros(current)\n    \n    return len(reachable_numbers)\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    print(count_reachable_numbers(n))\n```",
    "47": "```python\ndef max_beauty_with_multiplier(n, x, a):\n    def kadane(arr):\n        max_ending_here = max_so_far = 0\n        for value in arr:\n            max_ending_here = max(0, max_ending_here + value)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    max_beauty = kadane(a)\n\n    max_with_multiplier = 0\n    current_sum = 0\n\n    # Calculate maximum beauty with multiplier from the start\n    for i in range(n):\n        current_sum += a[i]\n        max_with_multiplier = max(max_with_multiplier, current_sum * x)\n        current_sum = max(0, current_sum)\n\n    current_sum = 0\n    # Calculate maximum beauty with multiplier from the end\n    for i in range(n - 1, -1, -1):\n        current_sum += a[i]\n        max_with_multiplier = max(max_with_multiplier, current_sum * x)\n        current_sum = max(0, current_sum)\n\n    return max(max_beauty, max_with_multiplier)\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_beauty_with_multiplier(n, x, a))\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = -1\n    moves = []\n    \n    while left <= right:\n        if a[left] > last_taken and (a[right] <= last_taken or a[left] < a[right]):\n            moves.append('L')\n            last_taken = a[left]\n            left += 1\n        elif a[right] > last_taken:\n            moves.append('R')\n            last_taken = a[right]\n            right -= 1\n        else:\n            break\n    \n    return len(moves), ''.join(moves)\n\n# Input reading\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Get the result\nk, s = longest_increasing_sequence(n, a)\n\n# Output the result\nprint(k)\nprint(s)\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_elements = m // 2\n    dp = [[-1] * k for _ in range(n + 1)]\n    dp[0][0] = 0  # Base case: sum of 0 is divisible by k\n\n    for i in range(1, n + 1):\n        row = sorted(matrix[i - 1], reverse=True)[:max_elements]\n        current_sums = {0}  # Start with the sum of choosing no elements\n\n        for num in row:\n            new_sums = {s + num for s in current_sums}  # Use set comprehension for new sums\n            current_sums.update(new_sums)  # Merge new sums into current sums\n\n        for s in current_sums:\n            mod = s % k\n            if dp[i - 1][mod] != -1:\n                dp[i][mod] = max(dp[i][mod], dp[i - 1][mod] + s)\n\n        for mod in range(k):\n            if dp[i - 1][mod] != -1:\n                dp[i][mod] = max(dp[i][mod], dp[i - 1][mod])\n\n    return max(dp[n])\n\n# Read input\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = max_sum_divisible_by_k(n, m, k, matrix)\nprint(result)\n```",
    "58": "```python\ndef color_array(n, k, a):\n    from collections import defaultdict\n\n    color_assignment = [0] * n  # To store the color of each element\n    color_count = defaultdict(int)  # To count occurrences of each color\n    element_to_colors = defaultdict(set)  # To store which colors are assigned to each element\n\n    # Step 2: Assign colors\n    for i in range(n):\n        element = a[i]\n        # Try to assign a color to this element\n        for color in range(1, k + 1):\n            if color_count[color] < 1 and color not in element_to_colors[element]:\n                color_assignment[i] = color\n                color_count[color] += 1\n                element_to_colors[element].add(color)\n                break\n\n    # Step 3: Check if we have assigned all colors\n    if len(color_count) < k:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, color_assignment)))\n\n# Example usage\nn, k = map(int, input().split())\na = list(map(int, input().split()))\ncolor_array(n, k, a)\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph):\n    visited = {start: 0}\n    queue = deque([start])\n    farthest_node = start\n    max_distance = 0\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > max_distance:\n                    max_distance = visited[neighbor]\n                    farthest_node = neighbor\n                    \n    return farthest_node, max_distance\n\ndef find_max_edges_and_vertices(n, edges):\n    graph = defaultdict(list)\n    \n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Step 1: Find the farthest node from an arbitrary node (1)\n    farthest_from_start, _ = bfs(1, graph)\n    \n    # Step 2: Find the farthest node from the farthest node found\n    farthest_from_farthest, max_distance = bfs(farthest_from_start, graph)\n    \n    # Step 3: Get the path from farthest_from_start to farthest_from_farthest\n    def get_path(start, end):\n        parent = {}\n        queue = deque([start])\n        visited = {start}\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end in parent:\n            path.append(end)\n            end = parent[end]\n        path.append(start)\n        return path[::-1]\n    \n    longest_path = get_path(farthest_from_start, farthest_from_farthest)\n    \n    # Step 4: Select three vertices from the longest path\n    a = longest_path[0]\n    b = longest_path[len(longest_path) // 2]\n    c = longest_path[-1]\n    \n    # The maximum number of edges in the union of paths\n    max_edges = 3 * (len(longest_path) - 1)\n    \n    return max_edges, a, b, c\n\n# Input reading\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\n# Get the result\nmax_edges, a, b, c = find_max_edges_and_vertices(n, edges)\n\n# Output the result\nprint(max_edges)\nprint(a, b, c)\n```",
    "60": "```python\ndef has_palindrome_subsequence(test_cases):\n    results = []\n    for n, a in test_cases:\n        found = False\n        first_occurrence = {}\n        \n        for i in range(n):\n            if a[i] in first_occurrence:\n                if i - first_occurrence[a[i]] >= 2:\n                    found = True\n                    break\n            else:\n                first_occurrence[a[i]] = i\n        \n        results.append(\"YES\" if found else \"NO\")\n    \n    return results\n\ndef main():\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append((n, a))\n\n    results = has_palindrome_subsequence(test_cases)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "57": "```python\ndef assign_gifts(n, f):\n    # Identify givers and receivers\n    givers = set(range(1, n + 1)) - set(f)  # Friends who have not been assigned a gift\n    receivers = {gift for gift in f if gift != 0}  # Friends who are already assigned a gift\n\n    # Prepare to fill in the zeros\n    result = f[:]  # Copy the original list to result\n    zero_indices = [i for i in range(n) if f[i] == 0]  # Indices of friends who have not chosen a gift\n\n    # Assign gifts to friends with f_i = 0\n    for i in zero_indices:\n        for giver in givers:\n            if giver != i + 1:  # Ensure the giver does not give to themselves\n                result[i] = giver\n                givers.remove(giver)  # Remove the giver from the available set\n                receivers.add(giver)  # Add the giver to the receivers\n                break\n\n    return result\n\n# Input reading\nn = int(input())\nf = list(map(int, input().split()))\n\n# Get the result and print it\nresult = assign_gifts(n, f)\nprint(' '.join(map(str, result)))\n```",
    "63": "```python\ndef minimum_instability(n, a):\n    # Sort the array to easily find min and max after removing one element\n    a.sort()\n    \n    # Calculate the instability after removing the first or the last element\n    instability_remove_first = a[-1] - a[1]  # Remove the smallest element\n    instability_remove_last = a[-2] - a[0]   # Remove the largest element\n    \n    # The minimum instability after removing one element\n    return min(instability_remove_first, instability_remove_last)\n\n# Input reading\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Output the result\nprint(minimum_instability(n, a))\n```",
    "59": "```python\ndef min_operations_to_remainder(n, x, y, number):\n    # Construct the target pattern for the last x digits\n    target_remainder = '0' * (x - y - 1) + '1' + '0' * y\n    current_remainder = number[-x:]  # Get the last x digits of the number\n    \n    # Count the number of changes needed\n    operations_needed = sum(1 for i in range(x) if current_remainder[i] != target_remainder[i])\n    \n    return operations_needed\n\n# Input reading\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# Calculate and print the result\nresult = min_operations_to_remainder(n, x, y, number)\nprint(result)\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Find the longest suffix of t which is also a prefix\n    overlap_length = 0\n    for i in range(1, n):\n        if t.startswith(t[i:]):\n            overlap_length = n - i\n            break\n\n    # Construct the result string\n    result = t + (t[overlap_length:] * (k - 1))\n    return result\n\n# Read input\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the result and print it\nresult_string = construct_string(n, k, t)\nprint(result_string)\n```",
    "62": "```python\ndef min_operations_to_divisible_triplet(test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        min_operations = float('inf')\n        best_triplet = (a, b, c)\n\n        # Iterate over possible values for A\n        for A in range(1, a + 1):\n            # Calculate the nearest multiples of A for B and C\n            B = ((b + A - 1) // A) * A  # Next multiple of A >= b\n            if B < b:\n                B = (b // A) * A  # Previous multiple of A <= b\n            \n            C = ((c + B - 1) // B) * B  # Next multiple of B >= c\n            if C < c:\n                C = (c // B) * B  # Previous multiple of B <= c\n            \n            # Calculate operations needed\n            operations = abs(A - a) + abs(B - b) + abs(C - c)\n            \n            # Update minimum operations and best triplet\n            if operations < min_operations:\n                min_operations = operations\n                best_triplet = (A, B, C)\n\n        results.append((min_operations, best_triplet))\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations_to_divisible_triplet(test_cases)\n\n# Print output\nfor operations, triplet in results:\n    print(operations)\n    print(*triplet)\n```",
    "71": "```python\ndef calculate_output(a: int) -> int:\n    \"\"\"Calculate the output based on the input integer a.\"\"\"\n    return (a - 1).bit_length()\n\ndef main():\n    # Read input\n    a = int(input().strip())\n    # Output the result\n    print(calculate_output(a))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "61": "```python\ndef max_number_after_replacement(n, a, f):\n    # Convert the function mapping to a list for easier access\n    f = [0] + f  # f[0] is unused, f[1] to f[9] are used\n    \n    # Convert the string a into a list of characters for easier manipulation\n    a_list = list(a)\n    \n    # Flag to indicate if we have started replacing\n    replacing = False\n    \n    for i in range(n):\n        current_digit = int(a_list[i])\n        mapped_digit = f[current_digit]\n        \n        # If we haven't started replacing and the mapped digit is greater, start replacing\n        if not replacing and mapped_digit > current_digit:\n            replacing = True\n        \n        # If we are in the replacing mode, replace the digit\n        if replacing:\n            if mapped_digit >= current_digit:\n                a_list[i] = str(mapped_digit)\n            else:\n                # Stop replacing if the mapped digit is less than the current digit\n                break\n    \n    # Join the list back into a string and return the result\n    return ''.join(a_list)\n\n# Input reading\nn = int(input().strip())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\n# Get the result and print it\nresult = max_number_after_replacement(n, a, f)\nprint(result)\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    # Initialize the schedule with zeros (rest days)\n    schedule = [0] * n\n    \n    # Try to allocate preparation days\n    for i in range(m):\n        s_i, d_i, c_i = exams[i]\n        days_allocated = 0\n        \n        # Allocate preparation days between s_i and d_i - 1\n        for day in range(s_i - 1, d_i - 1):\n            if days_allocated < c_i and schedule[day] == 0:\n                schedule[day] = i + 1  # Mark the day for preparation for exam i\n                days_allocated += 1\n        \n        # If we couldn't allocate enough preparation days, return -1\n        if days_allocated < c_i:\n            return -1\n    \n    # Now allocate the exam days\n    for i in range(m):\n        d_i = exams[i][1]\n        schedule[d_i - 1] = m + 1  # Mark the exam day\n    \n    return schedule\n\n# Read input\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the schedule\nresult = schedule_exams(n, m, exams)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "70": "```python\ndef calculate_midpoint(start_time, end_time):\n    # Convert start and end times to total minutes\n    start_minutes = start_time[0] * 60 + start_time[1]\n    end_minutes = end_time[0] * 60 + end_time[1]\n    \n    # Calculate the midpoint in total minutes\n    midpoint_minutes = (start_minutes + end_minutes) // 2\n    \n    # Convert back to hours and minutes\n    h3 = midpoint_minutes // 60\n    m3 = midpoint_minutes % 60\n    \n    return h3, m3\n\ndef parse_time(time_str):\n    return tuple(map(int, time_str.strip().split(':')))\n\ndef format_time(h, m):\n    return f\"{h:02}:{m:02}\"\n\n# Read input\nstart_time = parse_time(input())\nend_time = parse_time(input())\n\n# Calculate midpoint\nh3, m3 = calculate_midpoint(start_time, end_time)\n\n# Print output in the required format\nprint(format_time(h3, m3))\n```",
    "67": "```python\ndef find_nice_indices(n, a):\n    total_sum = sum(a)\n    nice_indices = []\n    element_count = {}\n\n    # Count occurrences of each element\n    for num in a:\n        element_count[num] = element_count.get(num, 0) + 1\n\n    for i in range(n):\n        remaining_sum = total_sum - a[i]\n\n        # Check if remaining_sum is even and if half of it exists in the array\n        if remaining_sum % 2 == 0:\n            target = remaining_sum // 2\n            # Check if target exists in the element count\n            if target in element_count:\n                # Ensure we are not counting the removed element itself\n                if target != a[i] or element_count[target] > 1:\n                    nice_indices.append(i + 1)  # Store 1-based index\n\n    return nice_indices\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Find nice indices\nnice_indices = find_nice_indices(n, a)\n\n# Output results\nprint(len(nice_indices))\nif nice_indices:\n    print(' '.join(map(str, nice_indices)))\n```",
    "55": "```python\ndef is_white_sheet_visible(white_sheet, black_sheets):\n    x1, y1, x2, y2 = white_sheet\n\n    # Check if the white sheet is completely covered by either black sheet\n    covered_by_first_black = (black_sheets[0][0] <= x1 < black_sheets[0][2] and \n                               black_sheets[0][1] <= y1 < black_sheets[0][3] and \n                               black_sheets[0][0] <= x2 < black_sheets[0][2] and \n                               black_sheets[0][1] <= y2 < black_sheets[0][3])\n    \n    covered_by_second_black = (black_sheets[1][0] <= x1 < black_sheets[1][2] and \n                                black_sheets[1][1] <= y1 < black_sheets[1][3] and \n                                black_sheets[1][0] <= x2 < black_sheets[1][2] and \n                                black_sheets[1][1] <= y2 < black_sheets[1][3])\n\n    # Check if the white sheet is completely covered by both black sheets\n    if (black_sheets[0][0] <= x1 and black_sheets[0][2] >= x2 and \n        black_sheets[0][1] <= y1 and black_sheets[0][3] >= y2) or \\\n       (black_sheets[1][0] <= x1 and black_sheets[1][2] >= x2 and \n        black_sheets[1][1] <= y1 and black_sheets[1][3] >= y2):\n        return \"NO\"\n\n    # Check if there is any part of the white sheet that is visible\n    visible = (\n        (x1 > black_sheets[0][2] or x2 < black_sheets[0][0] or y1 > black_sheets[0][3] or y2 < black_sheets[0][1]) or\n        (x1 > black_sheets[1][2] or x2 < black_sheets[1][0] or y1 > black_sheets[1][3] or y2 < black_sheets[1][1])\n    )\n\n    return \"YES\" if visible else \"NO\"\n\n# Input reading\nwhite_sheet = list(map(int, input().split()))\nblack_sheets = [list(map(int, input().split())) for _ in range(2)]\n\n# Output the result\nprint(is_white_sheet_visible(white_sheet, black_sheets))\n```",
    "77": "```python\ndef minimum_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    print(minimum_difference(n))\n```",
    "73": "```python\ndef can_complete_wall(n, heights):\n    max_height = max(heights)\n\n    # Check if all heights can be raised to the maximum height\n    for height in heights:\n        if height < max_height and (max_height - height) % 2 != 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn = int(input().strip())\nheights = list(map(int, input().strip().split()))\n\n# Output the result\nprint(can_complete_wall(n, heights))\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n\n    if D >= n:\n        return \"NO\"\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    if len(graph[1]) < D:\n        return \"NO\"\n\n    spanning_tree_edges = []\n    visited = [False] * (n + 1)\n    visited[1] = True\n    degree_count = 0\n\n    queue = deque([1])\n    \n    while queue and degree_count < D:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                spanning_tree_edges.append((current, neighbor))\n                queue.append(neighbor)\n                degree_count += 1\n                if degree_count == D:\n                    break\n\n    if degree_count < D:\n        return \"NO\"\n\n    for u in range(1, n + 1):\n        if not visited[u]:\n            for v in graph[u]:\n                if visited[v]:\n                    spanning_tree_edges.append((u, v))\n                    visited[u] = True\n                    break\n\n    if len(spanning_tree_edges) != n - 1:\n        return \"NO\"\n\n    result = [\"YES\"]\n    result.extend(f\"{u} {v}\" for u, v in spanning_tree_edges)\n    return \"\\n\".join(result)\n\n# Read input\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the result\nresult = find_spanning_tree(n, m, D, edges)\nprint(result)\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    lefts = [l for l, r in segments]\n    rights = [r for l, r in segments]\n\n    overall_min = max(lefts)\n    overall_max = min(rights)\n\n    # Sort lefts and rights to find second min and max\n    lefts_sorted = sorted(lefts)\n    rights_sorted = sorted(rights)\n\n    second_overall_min = lefts_sorted[-2] if n > 2 else float('-inf')\n    second_overall_max = rights_sorted[-2] if n > 2 else float('inf')\n\n    max_length = 0\n\n    for i in range(n):\n        l, r = segments[i]\n\n        effective_min = second_overall_min if l == overall_min else overall_min\n        effective_max = second_overall_max if r == overall_max else overall_max\n\n        intersection_length = max(0, effective_max - effective_min)\n        max_length = max(max_length, intersection_length)\n\n    return max_length\n\n# Input reading\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_intersection_length(n, segments))\n```",
    "68": "```python\nfrom collections import Counter\nfrom math import comb\n\ndef min_cost_to_obtain_set(n, k, s):\n    freq = Counter(s)\n    \n    # Calculate the number of unique subsequences we can generate\n    unique_subsequences = 0\n    costs = []\n    \n    # Generate all possible subsequences and their costs\n    for length in range(1, n + 1):\n        subseq_count = sum(comb(freq[char], length) for char in freq)\n        if subseq_count > 0:\n            unique_subsequences += subseq_count\n            costs.append((length, subseq_count * (n - length)))\n    \n    # If we cannot generate enough unique subsequences\n    if unique_subsequences < k:\n        return -1\n    \n    # Sort costs by length\n    costs.sort()\n    \n    # Calculate the minimum cost to obtain k unique subsequences\n    total_cost = 0\n    remaining_k = k\n    \n    for length, cost in costs:\n        if remaining_k <= 0:\n            break\n        # Calculate how many we can take from this length\n        take = min(remaining_k, cost // (n - length))\n        total_cost += take * (n - length)\n        remaining_k -= take\n    \n    return total_cost\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    # Step 1: Create a set to store unique subsequences\n    unique_subsequences = set()\n    \n    # Step 2: Generate all possible subsequences\n    for i in range(1 << n):  # There are 2^n possible subsequences\n        subsequence = ''.join(s[j] for j in range(n) if i & (1 << j))\n        unique_subsequences.add(subsequence)\n    \n    # Step 3: Calculate the cost for each unique subsequence\n    costs = [n - len(subseq) for subseq in unique_subsequences]\n    \n    # Step 4: Sort costs to find the minimum total cost for k unique subsequences\n    costs.sort()\n    \n    # Step 5: Check if we can obtain k unique subsequences\n    if len(costs) < k:\n        return -1\n    \n    # Step 6: Calculate the total minimum cost for the first k costs\n    return sum(costs[:k])\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "82": "```python\ndef max_problems_solved(n, k, difficulties):\n    left, right = 0, n - 1\n    solved_count = 0\n\n    while left <= right:\n        if difficulties[left] <= k:\n            solved_count += 1\n            left += 1\n        elif difficulties[right] <= k:\n            solved_count += 1\n            right -= 1\n        else:\n            break\n\n    return solved_count\n\n# Input reading\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Output the result\nprint(max_problems_solved(n, k, difficulties))\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    from collections import defaultdict\n\n    # Step 1: Identify the positions of each character\n    char_positions = defaultdict(list)\n    for index, char in enumerate(s):\n        char_positions[char].append(index)\n\n    # Step 2: Create a list to hold the colors\n    colors = [0] * n\n    color_count = 0\n\n    # Step 3: Assign colors based on the positions of characters\n    last_color = {}\n    for char in sorted(char_positions.keys()):\n        color_count += 1\n        for pos in char_positions[char]:\n            colors[pos] = color_count\n\n    # Step 4: Output the results\n    print(color_count)\n    print(' '.join(map(str, colors)))\n\n# Example usage\nn = int(input())\ns = input().strip()\nmin_colors_to_sort(n, s)\n```",
    "78": "```python\nMOD = 10**9 + 7\n\ndef count_regular_sequences(n, s):\n    m = len(s)\n    \n    # Precompute the number of valid sequences of length 2k\n    dp = [[0] * (n + 1) for _ in range(2 * n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, 2 * n + 1):\n        for j in range(n + 1):\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD\n            if j < n:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD\n\n    # Calculate the balance of the string s\n    balance = 0\n    min_balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n\n    # Check if the balance is valid\n    if balance < 0 or balance > n or (n - balance) < -min_balance:\n        return 0\n\n    # Count valid sequences with s as a substring\n    total_count = 0\n    for i in range(n - (balance - min_balance) + 1):\n        total_count = (total_count + dp[2 * (n - i)][(n - i) + min_balance]) % MOD\n\n    return total_count\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_regular_sequences(n, s))\n```",
    "81": "```python\ndef can_reorder_strings(strings):\n    # Step 1: Sort strings by length\n    strings.sort(key=len)\n    \n    # Step 2: Check if each string is a substring of the next one\n    for i in range(len(strings) - 1):\n        if strings[i] not in strings[i + 1]:\n            return \"NO\"\n    \n    # Step 3: If all checks passed, return the ordered strings\n    return \"YES\", strings\n\ndef main():\n    # Input reading\n    n = int(input())\n    strings = [input().strip() for _ in range(n)]\n\n    # Get the result\n    result = can_reorder_strings(strings)\n\n    # Output the result\n    if result == \"NO\":\n        print(result)\n    else:\n        print(result[0])\n        print(\"\\n\".join(result[1]))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "75": "```python\ndef max_days_without_purchases(a, b, c):\n    # Define the food consumption pattern for each day of the week\n    food_pattern = ['fish', 'rabbit', 'chicken', 'fish', 'chicken', 'rabbit', 'fish']\n    \n    # Calculate the maximum number of complete weeks that can be sustained\n    complete_weeks = min(a // 3, b // 2, c // 2)\n    \n    # Deduct the food consumed in complete weeks\n    a -= complete_weeks * 3\n    b -= complete_weeks * 2\n    c -= complete_weeks * 2\n    \n    # Total days from complete weeks\n    max_days = complete_weeks * 7\n    \n    # Check starting from each day of the week\n    for start_day in range(7):\n        days = 0\n        a_temp, b_temp, c_temp = a, b, c\n        \n        # Simulate the days of the week starting from start_day\n        for i in range(7):\n            current_day = (start_day + i) % 7\n            if food_pattern[current_day] == 'fish' and a_temp > 0:\n                a_temp -= 1\n                days += 1\n            elif food_pattern[current_day] == 'rabbit' and b_temp > 0:\n                b_temp -= 1\n                days += 1\n            elif food_pattern[current_day] == 'chicken' and c_temp > 0:\n                c_temp -= 1\n                days += 1\n            else:\n                break\n        \n        max_days = max(max_days, days)\n    \n    return max_days\n\n# Input reading\na, b, c = map(int, input().split())\n# Output the result\nprint(max_days_without_purchases(a, b, c))\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n: int) -> int:\n    s = str(n)\n    length = len(s)\n    moves = float('inf')\n\n    # Check for pairs of digits that can form 25 or 00\n    for target in ['00', '25']:\n        last_index = -1\n        \n        # Find the last occurrence of the last_digit\n        for i in range(length - 1, -1, -1):\n            if s[i] == target[1]:\n                last_index = i\n                break\n        \n        if last_index == -1:\n            continue  # If we can't find the last_digit, skip this target\n        \n        second_last_index = -1\n        \n        # Now find the second_last_digit before the last_index\n        for i in range(last_index - 1, -1, -1):\n            if s[i] == target[0]:\n                second_last_index = i\n                break\n        \n        if second_last_index == -1:\n            continue  # If we can't find the second_last_digit, skip this target\n        \n        # Calculate moves to bring second_last_index to the front of last_index\n        moves_needed = (last_index - second_last_index) + (last_index - 1 - second_last_index)\n        moves = min(moves, moves_needed)\n\n    return moves if moves != float('inf') else -1\n\n# Read input\nn = int(input().strip())\n# Get the result and print it\nresult = min_moves_to_divisible_by_25(n)\nprint(result)\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n\n    # Iterate through possible widths of the rectangle\n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            # Check both (width, height) and (height, width)\n            for w, h in [(width, height), (height, width)]:\n                # Check if we can fit red and blue tiles in rectangles\n                if (w >= 1 and h >= (a + b) // w) and (h >= 1 and w >= (a + b) // h):\n                    perimeter = 2 * (w + h)\n                    min_perimeter = min(min_perimeter, perimeter)\n\n    return min_perimeter\n\n# Input reading\na, b = map(int, input().strip().split())\n# Output the result\nprint(minimal_perimeter(a, b))\n```",
    "84": "```python\ndef can_color_string(n, s):\n    from collections import Counter\n\n    # Step 1: Count occurrences of each character\n    count = Counter(s)\n\n    # Step 2: Check if any character occurs more than twice\n    if any(cnt > 2 for cnt in count.values()):\n        return \"NO\", \"\"\n\n    # Step 3: Create a coloring scheme\n    color = []\n    for char in s:\n        # Determine color based on the count of '0's and '1's used\n        if color.count('0') < (count[char] + 1) // 2:\n            color.append('0')\n        else:\n            color.append('1')\n\n    return \"YES\", ''.join(color)\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult, coloring = can_color_string(n, s)\n\n# Output the result\nprint(result)\nif result == \"YES\":\n    print(coloring)\n```",
    "76": "```python\ndef can_construct_symmetric_square(t, test_cases):\n    results = []\n    \n    for n, m, tiles in test_cases:\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        tile_map = {}\n        \n        for tile in tiles:\n            top_left, top_right = tile[0]\n            bottom_left, bottom_right = tile[1]\n            tile_map[(top_left, top_right)] = (bottom_left, bottom_right)\n        \n        can_form_symmetric = any(\n            (top_right, top_left) in tile_map and tile_map[(top_right, top_left)] == (bottom_right, bottom_left)\n            for tile in tiles\n            for top_left, top_right in [tile[0]]\n            for bottom_left, bottom_right in [tile[1]]\n        )\n        \n        results.append(\"YES\" if can_form_symmetric else \"NO\")\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = [((int(input().split()[0]), int(input().split()[1])), \n               (int(input().split()[0]), int(input().split()[1]))) for _ in range(n)]\n    test_cases.append((n, m, tiles))\n\n# Get results\nresults = can_construct_symmetric_square(t, test_cases)\n\n# Print results\nprint(\"\\n\".join(results))\n```",
    "86": "```python\ndef solve_polycarp(n, k):\n    # Calculate the minimum and maximum sums of problems that can be solved in k days\n    min_sum = k * (k + 1) // 2\n    max_sum = k * (2 * k + 1) // 2\n\n    # Check if n is within the possible range\n    if n < min_sum or n > max_sum:\n        print(\"NO\")\n        return\n\n    # Initialize the array with the minimum required problems for each day\n    a = list(range(1, k + 1))\n    current_sum = sum(a)\n\n    # Calculate the remaining problems to distribute\n    remaining = n - current_sum\n\n    # Distribute the remaining problems while respecting the constraints\n    for i in range(k - 1, -1, -1):\n        # Calculate the maximum increase possible for a[i]\n        max_increase = min(remaining, a[i] - 1 + a[i] // 2)\n        a[i] += max_increase\n        remaining -= max_increase\n\n        if remaining <= 0:\n            break\n\n    print(\"YES\")\n    print(\" \".join(map(str, a)))\n\n# Read input\nn, k = map(int, input().split())\nsolve_polycarp(n, k)\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects based on the required rating (a_i)\n    projects.sort(key=lambda x: x[0])\n    \n    for a, b in projects:\n        if r < a:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_complete_projects(n, r, projects))\n```",
    "92": "```python\ndef find_integers(x):\n    # Iterate through possible values for a and b\n    for a in range(1, 11):\n        for b in range(1, 11):\n            # Check if the product of a and b is approximately equal to x\n            if abs(a * b - x) < 1e-6:  # Using a small epsilon for floating-point comparison\n                return a, b\n\ndef main():\n    # Read input\n    x = float(input().strip())\n    \n    # Get the result\n    result = find_integers(x)\n    \n    # Print the output\n    print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects based on their required rating and rating change\n    projects.sort(key=lambda x: (x[0], -x[1]))\n\n    completed_projects = 0\n    current_rating = r\n\n    while True:\n        progress_made = False\n        for i in range(len(projects)):\n            a_i, b_i = projects[i]\n            if current_rating >= a_i:\n                # Complete the project\n                current_rating += b_i\n                completed_projects += 1\n                # Remove the project from the list\n                projects.pop(i)\n                progress_made = True\n                break\n        if not progress_made:\n            break\n\n    return completed_projects\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_projects(n, r, projects))\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Initialize the result list\n    result = []\n    \n    # Determine the starting character based on the counts of a and b\n    if a > b:\n        current_char = '0'\n        a -= 1\n    else:\n        current_char = '1'\n        b -= 1\n    \n    # Create the alternating pattern based on x transitions\n    for _ in range(x):\n        result.append(current_char)\n        if current_char == '0':\n            current_char = '1'\n            b -= 1\n        else:\n            current_char = '0'\n            a -= 1\n    \n    # Append remaining characters\n    result.extend(['0'] * a)\n    result.extend(['1'] * b)\n    \n    # Join the list into a string and return\n    return ''.join(result)\n\n# Read input\na, b, x = map(int, input().split())\n# Generate and print the binary string\nprint(construct_binary_string(a, b, x))\n```",
    "97": "```python\ndef min_coins_to_move_chips(n, positions):\n    even_count = sum(1 for x in positions if x % 2 == 0)\n    odd_count = n - even_count\n    return min(even_count, odd_count)\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    positions = list(map(int, input().strip().split()))\n    print(min_coins_to_move_chips(n, positions))\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    # Step 1: Check for impossible conditions\n    if d > 2 * (k - 1) + 1 or (d == 1 and n > 2) or (n > k + 1 and d == 1):\n        return \"NO\"\n    \n    # Step 2: Initialize the tree structure\n    edges = []\n    \n    # Step 3: Create the main path for the diameter\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n    \n    # Step 4: Add additional nodes to maintain the degree constraint\n    current_node = d + 2\n    for i in range(1, d + 1):\n        while len([e for e in edges if e[0] == i or e[1] == i]) < k and current_node <= n:\n            edges.append((i, current_node))\n            current_node += 1\n            if current_node > n:\n                break\n    \n    # Step 5: Check if we have used all nodes\n    if current_node <= n:\n        return \"NO\"\n    \n    # Step 6: Return the result\n    result = [\"YES\"]\n    result.extend(f\"{u} {v}\" for u, v in edges)\n    return \"\\n\".join(result)\n\n# Input reading\nn, d, k = map(int, input().split())\nprint(construct_tree(n, d, k))\n```",
    "91": "```python\ndef max_removable_length(s: str, t: str) -> int:\n    n, m = len(s), len(t)\n\n    # Create arrays to store the positions of t in s\n    left = [0] * m\n    right = [0] * m\n\n    # Fill left array with positions of t in s from the start\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n\n    # Fill right array with positions of t in s from the end\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n\n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n\n    # Consider removing from the start to the first character of t\n    max_length = max(max_length, right[0])\n    # Consider removing from the last character of t to the end\n    max_length = max(max_length, n - 1 - left[m - 1])\n\n    return max_length\n\n# Input reading\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(max_removable_length(s, t))\n```",
    "88": "```python\ndef create_palindromic_matrix(n, numbers):\n    from collections import Counter\n    \n    # Count the frequency of each number\n    count = Counter(numbers)\n    \n    # Check for the possibility of forming a palindromic matrix\n    odd_count = sum(1 for freq in count.values() if freq % 2 != 0)\n    if odd_count > 1:\n        return \"NO\"\n    \n    # Prepare the matrix\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Fill the half list with half of the frequencies\n    half = []\n    center_value = None\n    for value, freq in count.items():\n        half.extend([value] * (freq // 2))\n        if freq % 2 != 0:\n            center_value = value\n    \n    # Fill the matrix symmetrically\n    index = 0\n    for i in range(n):\n        for j in range(n):\n            if i < (n + 1) // 2:  # Fill only the top half and the center row if n is odd\n                if j < (n + 1) // 2:  # Fill only the left half and the center column if n is odd\n                    matrix[i][j] = half[index]\n                    matrix[i][n - j - 1] = half[index]\n                    matrix[n - i - 1][j] = half[index]\n                    matrix[n - i - 1][n - j - 1] = half[index]\n                    index += 1\n                elif n % 2 == 1 and j == n // 2:  # Fill the center cell if n is odd\n                    matrix[i][j] = center_value\n                    matrix[n - i - 1][j] = center_value\n    \n    return \"YES\", matrix\n\n# Input reading\nn = int(input().strip())\nnumbers = list(map(int, input().strip().split()))\n\n# Generate the result\nresult = create_palindromic_matrix(n, numbers)\n\n# Output the result\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for row in result[1]:\n        print(\" \".join(map(str, row)))\n```",
    "90": "```python\ndef can_cross_river(n, m, d, c):\n    total_length = sum(c)\n    \n    # If the maximum jump distance allows reaching the end directly\n    if d >= n + 1:\n        result = [0] * n\n        position = 0\n        for i in range(m):\n            for j in range(c[i]):\n                result[position] = i + 1\n                position += 1\n        return \"YES\", result\n    \n    # Calculate the minimum required gaps between platforms\n    min_required_gaps = (m - 1) * (d - 1)\n    \n    # Check if the total length of platforms and required gaps fit in the river\n    if total_length + min_required_gaps > n:\n        return \"NO\", []\n    \n    # Construct the result array\n    result = [0] * n\n    position = 0\n    for i in range(m):\n        # Place the platform\n        for j in range(c[i]):\n            result[position] = i + 1\n            position += 1\n        # Add a gap if it's not the last platform\n        if i < m - 1:\n            position += (d - 1)  # Leave space for the next jump\n    \n    return \"YES\", result\n\n# Input reading\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Function call\nresult = can_cross_river(n, m, d, c)\n\n# Output result\nprint(result[0])\nif result[0] == \"YES\":\n    print(\" \".join(map(str, result[1])))\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    # Step 1: Initialize the permutation array\n    p = [0] * n\n    \n    # Step 2: Calculate the values of p based on q\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n    \n    # Step 3: Normalize the permutation to start from 1\n    min_value = min(p)\n    offset = 1 - min_value\n    \n    # Step 4: Adjust the permutation values\n    p = [x + offset for x in p]\n    \n    # Step 5: Check if the adjusted permutation is valid\n    if len(set(p)) == n and all(1 <= x <= n for x in p):\n        print(\" \".join(map(str, p)))\n    else:\n        print(-1)\n\n# Example usage:\nn = int(input())\nq = list(map(int, input().split()))\nrestore_permutation(n, q)\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Initialize counts for 'a', 'b', and 'c'\n    counts = {'a': n, 'b': n, 'c': n}\n    \n    # Create a list to build the result string\n    res = []\n    \n    # Function to check if the last two characters form a forbidden substring\n    def is_forbidden():\n        return ''.join(res[-2:]) in (s, t) if len(res) >= 2 else False\n    \n    # Build the result string while avoiding forbidden substrings\n    while sum(counts.values()) > 0:\n        for char in 'abc':\n            if counts[char] > 0:\n                res.append(char)\n                counts[char] -= 1\n                if is_forbidden():\n                    res.pop()\n                    counts[char] += 1\n                else:\n                    break\n        else:\n            # If we couldn't add any character, it means we are stuck\n            return \"NO\", \"\"\n    \n    # Check if the result is valid\n    return \"YES\", ''.join(res)\n\n# Input reading\nn = int(input())\ns = input().strip()\nt = input().strip()\n\n# Generate the result\nresult = generate_string(n, s, t)\n\n# Output the result\nprint(result[0])\nif result[0] == \"YES\":\n    print(result[1])\n```",
    "99": "```python\ndef rock_paper_scissors(n, a, b):\n    # Unpack Alice's and Bob's choices\n    a_rock, a_scissors, a_paper = a\n    b_rock, b_scissors, b_paper = b\n\n    # Calculate maximum wins for Alice\n    max_wins = min(a_rock, b_scissors) + min(a_scissors, b_paper) + min(a_paper, b_rock)\n\n    # Calculate losses for Alice\n    losses = max(0, b_rock - a_paper) + max(0, b_scissors - a_rock) + max(0, b_paper - a_scissors)\n\n    # Minimum wins for Alice is total rounds minus losses\n    min_wins = n - losses\n\n    return min_wins, max_wins\n\n# Read input\nn = int(input().strip())\na = list(map(int, input().strip().split()))\nb = list(map(int, input().strip().split()))\n\n# Get results\nmin_wins, max_wins = rock_paper_scissors(n, a, b)\n\n# Print output\nprint(min_wins, max_wins)\n```"
}