{
    "7": "```python\ndef find_empty_day(n, m):\n    day = 0\n    grains = n\n    \n    while grains > 0:\n        day += 1\n        grains = min(grains + m, n)  # Add grains brought to the barn, respecting capacity\n        grains -= day  # Sparrows eat grains\n        \n    return day\n\n# Input reading\nn, m = map(int, input().split())\nprint(find_empty_day(n, m))\n```",
    "2": "```python\ndef is_lucky_year(year):\n    non_zero_digits = [digit for digit in str(year) if digit != '0']\n    return len(non_zero_digits) <= 1\n\ndef next_lucky_year(current_year):\n    next_year = current_year + 1\n    while not is_lucky_year(next_year):\n        next_year += 1\n    return next_year - current_year\n\n# Input\nn = int(input())\n# Output\nprint(next_lucky_year(n))\n```",
    "4": "```python\ndef is_lucky_time(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef time_before(hh, mm, minutes):\n    total_minutes = (hh * 60 + mm - minutes) % (24 * 60)\n    return divmod(total_minutes, 60)\n\ndef minimum_snooze_presses(x, hh, mm):\n    presses = 0\n    while not is_lucky_time(hh, mm):\n        presses += 1\n        hh, mm = time_before(hh, mm, x)\n    return presses\n\n# Input reading\nx = int(input().strip())\nhh, mm = map(int, input().strip().split())\n\n# Output the result\nprint(minimum_snooze_presses(x, hh, mm))\n```",
    "5": "```python\ndef minimum_seconds_to_close_tabs(n, pos, l, r):\n    # If all tabs are within the range [l, r], no action is needed\n    if l == 1 and r == n:\n        return 0\n    \n    seconds = 0\n\n    # Close tabs to the left of l if necessary\n    if l > 1:\n        seconds += abs(pos - l) + 1  # Move to l and close tabs to the left\n\n    # Close tabs to the right of r if necessary\n    if r < n:\n        seconds += abs(pos - r) + 1  # Move to r and close tabs to the right\n\n    return seconds\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    \n    for n, x, blows in queries:\n        min_blows = float('inf')\n        \n        for d, h in blows:\n            if d >= x:\n                min_blows = min(min_blows, 1)\n            else:\n                effective_damage = d - h\n                if effective_damage > 0:\n                    blows_needed = (x - d + effective_damage - 1) // effective_damage + 1\n                    min_blows = min(min_blows, blows_needed)\n        \n        results.append(min_blows if min_blows != float('inf') else -1)\n    \n    return results\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    def calculate_painted(excluded_indices):\n        painted_sections = [0] * (n + 1)\n        for index in range(q):\n            if index not in excluded_indices:\n                l, r = painters[index]\n                for i in range(l, r + 1):\n                    painted_sections[i] = 1\n        return sum(painted_sections)\n\n    max_sections = 0\n\n    # Try removing each pair of painters\n    for i in range(q):\n        for j in range(i + 1, q):\n            painted_count = calculate_painted({i, j})\n            max_sections = max(max_sections, painted_count)\n\n    return max_sections\n\n# Read input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Get the result and print it\nresult = max_painted_sections(n, q, painters)\nprint(result)\n```",
    "1": "```python\ndef max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n    \n    max_number = x\n    max_sum = sum(int(digit) for digit in str_x)\n    \n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit by 1\n        # and setting all following digits to 9\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        new_number = int(new_number)\n        \n        if new_number <= x:\n            current_sum = sum(int(digit) for digit in str(new_number))\n            if (current_sum > max_sum) or (current_sum == max_sum and new_number > max_number):\n                max_number = new_number\n                max_sum = current_sum\n    \n    return max_number\n\nx = int(input())\nprint(max_digit_sum(x))\n```",
    "0": "```python\ndef max_acordion_length(s: str) -> int:\n    left_bracket_index = s.find('[')\n    colon_index = s.find(':', left_bracket_index + 1)\n    right_bracket_index = s.rfind(']', colon_index + 1)\n    \n    if left_bracket_index == -1 or colon_index == -1 or right_bracket_index == -1:\n        return -1\n\n    vertical_lines_count = s.count('|', colon_index + 1, right_bracket_index)\n\n    # Calculate the maximum length of the accordion\n    accordion_length = 2 + vertical_lines_count  # 2 for the brackets and colons\n    return accordion_length\n\n# Example usage\ns = input().strip()\nprint(max_acordion_length(s))\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    # Calculate the number of tiles painted Red, Blue, and both\n    red_tiles = n // a\n    blue_tiles = n // b\n    both_tiles = n // (a * b)\n\n    # Calculate the maximum chocolates\n    max_chocolates = (red_tiles - both_tiles) * p + (blue_tiles - both_tiles) * q + both_tiles * max(p, q)\n\n    return max_chocolates\n```",
    "10": "```python\ndef calculate_days_off(n):\n    # Constants for work days and days off in a week\n    WORK_DAYS = 5\n    DAYS_OFF = 2\n    WEEK_LENGTH = WORK_DAYS + DAYS_OFF\n    \n    # Calculate total complete weeks and remaining days\n    total_weeks = n // WEEK_LENGTH\n    remaining_days = n % WEEK_LENGTH\n    \n    # Minimum days off is determined by complete weeks\n    min_days_off = total_weeks * DAYS_OFF\n    \n    # Maximum days off can include remaining days if they are days off\n    max_days_off = min_days_off + min(remaining_days, DAYS_OFF)\n    \n    return min_days_off, max_days_off\n\n# Input reading\nn = int(input().strip())\nmin_days, max_days = calculate_days_off(n)\nprint(min_days, max_days)\n```",
    "15": "```python\ndef is_favorite_in_sequence(a, b, c):\n    if c == 0:\n        return a == b\n    return (b - a) % c == 0 and (b - a) // c >= 0\n\ndef main():\n    a, b, c = map(int, input().split())\n    result = \"YES\" if is_favorite_in_sequence(a, b, c) else \"NO\"\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "8": "```python\ndef min_tiles_to_draw(tiles):\n    # Parse the input tiles\n    hand = [(int(tile[0]), tile[1]) for tile in tiles]\n    \n    # Count occurrences of each tile\n    counts = {}\n    for num, suit in hand:\n        counts[(num, suit)] = counts.get((num, suit), 0) + 1\n    \n    # Check for koutsu (triplet)\n    if any(count == 3 for count in counts.values()):\n        return 0  # Already have a koutsu\n    \n    # Organize tiles by suit\n    suits = {'m': [], 'p': [], 's': []}\n    for num, suit in hand:\n        suits[suit].append(num)\n    \n    # Check for shuntsu (sequence)\n    for suit in suits:\n        nums = sorted(suits[suit])\n        if len(nums) >= 3:\n            for i in range(len(nums) - 2):\n                if nums[i] + 1 == nums[i + 1] and nums[i + 1] + 1 == nums[i + 2]:\n                    return 0  # Already have a shuntsu\n    \n    # Calculate the minimum tiles needed to draw\n    needed = float('inf')\n    \n    for suit in suits:\n        nums = sorted(suits[suit])\n        for i in range(len(nums)):\n            # Check for potential shuntsu with one draw\n            if nums[i] > 1 and (nums[i] - 1) not in nums:\n                needed = min(needed, 1)  # Can draw (num[i] - 1)\n            if nums[i] < 9 and (nums[i] + 1) not in nums:\n                needed = min(needed, 1)  # Can draw (num[i] + 1)\n            if i < len(nums) - 1 and nums[i + 1] - nums[i] > 1:\n                needed = min(needed, 2)  # Need two draws to fill the gap\n    \n    return needed if needed != float('inf') else 2  # If no possible shuntsu, need at least 2 draws\n\n# Read input\ntiles = input().strip().split()\n# Output the result\nprint(min_tiles_to_draw(tiles))\n```",
    "17": "```python\ndef standing_spectators(n, k, t):\n    if t <= k:\n        return t\n    elif t <= n:\n        return k\n    else:\n        return n + k - t\n\n# Example usage:\n# n, k, t = map(int, input().split())\n# print(standing_spectators(n, k, t))\n```",
    "14": "```python\ndef restore_stack_sortable_permutation(n, k, p):\n    used = set(p)\n    result = p[:]\n    stack = []\n    next_num = n\n\n    for i in range(k):\n        while stack and stack[-1] < next_num:\n            result.append(stack.pop())\n\n        if p[i] != next_num:\n            while next_num > 0 and next_num not in used:\n                stack.append(next_num)\n                next_num -= 1\n\n        if p[i] != next_num:\n            return -1\n\n        next_num -= 1\n\n    while stack:\n        result.append(stack.pop())\n\n    return result\n\n# Input reading\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result and print\nresult = restore_stack_sortable_permutation(n, k, p)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "18": "```python\ndef lexicographically_minimal_string(s: str) -> str:\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        \n        while t and (not s or t[-1] <= s[0]):\n            u.append(t.pop())\n        \n        if s:\n            s = s[1:]\n    \n    while t:\n        u.append(t.pop())\n    \n    return ''.join(u)\n\n# Example usage\ns = input().strip()\nprint(lexicographically_minimal_string(s))\n```",
    "16": "```python\ndef can_form_regular_bracket_sequence(cnt1, cnt2, cnt3, cnt4):\n    # Calculate the total number of opening and closing brackets\n    opening_brackets = cnt1 + cnt2\n    closing_brackets = cnt2 + cnt4\n    \n    # Check if the number of opening and closing brackets can form a regular sequence\n    if opening_brackets >= closing_brackets and (opening_brackets - closing_brackets) <= cnt3:\n        return 1\n    return 0\n\n# Read input values\ncnt1 = int(input().strip())\ncnt2 = int(input().strip())\ncnt3 = int(input().strip())\ncnt4 = int(input().strip())\n\n# Output the result\nprint(can_form_regular_bracket_sequence(cnt1, cnt2, cnt3, cnt4))\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef find_course_order(n, k, main_courses, dependencies):\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    \n    # Build the graph and in-degree array\n    for course in range(1, n + 1):\n        for dep in dependencies[course - 1]:\n            graph[dep].append(course)\n            in_degree[course] += 1\n    \n    queue = deque()\n    \n    # Add all courses that have no dependencies\n    for course in range(1, n + 1):\n        if in_degree[course] == 0:\n            queue.append(course)\n    \n    order = []\n    courses_to_take = set(main_courses)\n    \n    while queue:\n        current = queue.popleft()\n        order.append(current)\n        \n        if current in courses_to_take:\n            courses_to_take.remove(current)\n        \n        for neighbor in graph[current]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    if courses_to_take:\n        return -1\n    \n    return len(order), order\n\n# Input reading\nn, k = map(int, input().split())\nmain_courses = list(map(int, input().split()))\ndependencies = [list(map(int, input().split()[1:])) for _ in range(n)]\n\n# Find the course order\nresult = find_course_order(n, k, main_courses, dependencies)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    m, order = result\n    print(m)\n    print(' '.join(map(str, order)))\n```",
    "19": "```python\ndef is_records_correct(test_cases):\n    results = []\n    \n    for n, records in test_cases:\n        valid = True\n        previous_p, previous_c = 0, 0\n        \n        for p, c in records:\n            if p < previous_p or c < previous_c or c > p:\n                valid = False\n                break\n            if (p - previous_p) < (c - previous_c):\n                valid = False\n                break\n            \n            previous_p, previous_c = p, c\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Read input\nT = int(input())\ntest_cases = []\n\nfor _ in range(T):\n    n = int(input())\n    records = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, records))\n\n# Get results\nresults = is_records_correct(test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    max_length = 0\n    current_length = 0\n    segments = []\n\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n                max_length = max(max_length, current_length)\n            current_length = 0\n\n    if current_length > 0:\n        segments.append(current_length)\n        max_length = max(max_length, current_length)\n\n    if max_length == 0:\n        return 0\n\n    if len(segments) == 1:\n        return max_length\n\n    max_possible_length = max_length\n\n    for i in range(len(segments) - 1):\n        max_possible_length = max(max_possible_length, segments[i] + segments[i + 1] + 1)\n\n    return max_possible_length\n\n# Example usage:\nn = int(input())\ntrophies = input().strip()\nprint(max_beauty_after_swap(n, trophies))\n```",
    "20": "```python\ndef is_palindrome(time_str):\n    return time_str == time_str[::-1]\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return minutes_passed\n\ndef min_sleep_minutes(current_time):\n    hh, mm = map(int, current_time.split(':'))\n    return next_palindrome_time(hh, mm)\n\n# Input reading\ncurrent_time = input().strip()\nprint(min_sleep_minutes(current_time))\n```",
    "9": "```python\ndef find_grandpas_sofa(d, n, m, sofas, counts):\n    cnt_l, cnt_r, cnt_t, cnt_b = counts\n\n    for i in range(d):\n        x1, y1, x2, y2 = sofas[i]\n        \n        left_count = sum(1 for j in range(d) if j != i and (sofas[j][0] < x1 and sofas[j][1] == y1 or sofas[j][0] < x2 and sofas[j][1] == y2))\n        right_count = sum(1 for j in range(d) if j != i and (sofas[j][0] > x1 and sofas[j][1] == y1 or sofas[j][0] > x2 and sofas[j][1] == y2))\n        top_count = sum(1 for j in range(d) if j != i and (sofas[j][0] == x1 and sofas[j][1] < y1 or sofas[j][0] == x2 and sofas[j][1] < y2))\n        bottom_count = sum(1 for j in range(d) if j != i and (sofas[j][0] == x1 and sofas[j][1] > y1 or sofas[j][0] == x2 and sofas[j][1] > y2))\n\n        if (left_count == cnt_l and right_count == cnt_r and \n            top_count == cnt_t and bottom_count == cnt_b):\n            return i + 1  # Return 1-based index\n\n    return -1\n\n# Input reading\nd = int(input())\nn, m = map(int, input().split())\nsofas = [tuple(map(int, input().split())) for _ in range(d)]\ncounts = tuple(map(int, input().split()))\n\n# Output the result\nprint(find_grandpas_sofa(d, n, m, sofas, counts))\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a: int, b: int) -> int:\n    from itertools import permutations\n\n    str_a = str(a)\n    str_b = str(b)\n\n    # Generate all unique permutations of the digits of a\n    permuted_numbers = set(int(''.join(p)) for p in permutations(str_a))\n\n    # Filter valid numbers that are less than or equal to b and have the same length as a\n    valid_numbers = [num for num in permuted_numbers if num <= b and len(str(num)) == len(str_a)]\n\n    # Return the maximum valid number or a if no valid number is found\n    return max(valid_numbers) if valid_numbers else a\n\n# Input reading\na = int(input().strip())\nb = int(input().strip())\n\n# Output the result\nprint(max_permutation_not_exceeding(a, b))\n```",
    "22": "```python\ndef is_s_palindrome(s: str) -> str:\n    mirror_map = {\n        'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M',\n        'O': 'O', 'p': 'q', 'q': 'p', 'R': 'R', 'S': 'S', 'T': 'T',\n        'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X', 'Y': 'Y', 'Z': 'Z',\n        'o': 'o', 'x': 'x'\n    }\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        left_char = s[i]\n        right_char = s[n - 1 - i]\n        \n        if left_char not in mirror_map or mirror_map[left_char] != right_char:\n            return \"NIE\"\n    \n    return \"TAK\"\n\n# Read input\ns = input().strip()\n# Output the result\nprint(is_s_palindrome(s))\n```",
    "21": "```python\ndef max_distance_after_swap(n, a):\n    min_index = a.index(1)\n    max_index = a.index(n)\n\n    # Calculate initial distance\n    initial_distance = abs(min_index - max_index)\n\n    # Possible new positions after swap\n    new_positions = [\n        (0, max_index),  # Swap 1 with the first element\n        (n - 1, max_index),  # Swap 1 with the last element\n        (min_index, 0),  # Swap n with the first element\n        (min_index, n - 1)  # Swap n with the last element\n    ]\n\n    # Calculate maximum distance after one swap\n    max_distance = initial_distance\n    for new_pos in new_positions:\n        new_distance = abs(new_pos[0] - new_pos[1])\n        max_distance = max(max_distance, new_distance)\n\n    return max_distance\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result and print it\nresult = max_distance_after_swap(n, a)\nprint(result)\n```",
    "27": "```python\ndef min_operations(n, s):\n    # Start with the assumption that we will type each character one by one\n    min_ops = n\n    \n    # Check for possible copy operations\n    for i in range(1, n // 2 + 1):\n        # Check if the substring s[0:i] can be repeated to form the prefix of s\n        if s[:i] == s[i:2*i] and 2*i <= n:\n            # Calculate operations: type i characters, copy, and type the remaining characters\n            remaining_chars = n - 2 * i\n            min_ops = min(min_ops, i + 1 + remaining_chars)\n    \n    return min_ops\n\n# Input reading\nn = int(input())\ns = input()\n\n# Output the result\nprint(min_operations(n, s))\n```",
    "24": "```python\ndef can_alice_win(board):\n    def check_win(x, y):\n        directions = [(1, 0), (0, 1), (1, 1), (1, -1)]\n        for dx, dy in directions:\n            count = 1\n            \n            # Check in the positive direction\n            count += count_in_direction(x, y, dx, dy)\n            # Check in the negative direction\n            count += count_in_direction(x, y, -dx, -dy)\n            \n            if count >= 5:\n                return True\n        return False\n\n    def count_in_direction(x, y, dx, dy):\n        count = 0\n        nx, ny = x + dx, y + dy\n        while 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n            count += 1\n            nx += dx\n            ny += dy\n        return count\n\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                board[i][j] = 'X'  # Place Alice's cross\n                if check_win(i, j):\n                    return \"YES\"\n                board[i][j] = '.'  # Reset the cell\n    return \"NO\"\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    # Validate input k\n    if k > n * n or k < 0 or (n % 2 == 0 and k % 2 != 0):\n        return -1\n\n    # Initialize the matrix with zeros\n    matrix = [[0] * n for _ in range(n)]\n\n    # Fill the matrix to make it lexicographically maximal\n    for i in range(n):\n        if k <= 0:\n            break\n        \n        # Fill the diagonal\n        if k > 0:\n            matrix[i][i] = 1\n            k -= 1\n        \n        # Fill symmetric pairs\n        for j in range(i + 1, n):\n            if k >= 2:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n            if k <= 0:\n                break\n\n    # Check if there are remaining ones that couldn't be placed\n    return -1 if k > 0 else matrix\n\n# Read input\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\n# Print output\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket: str) -> int:\n    # Calculate the sums of the first and last three digits\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    # Calculate the difference between the two sums\n    difference = abs(sum_first - sum_second)\n    \n    # If the sums are equal, no replacements are needed\n    if difference == 0:\n        return 0\n    \n    # Calculate the maximum possible changes we can make\n    changes = [9 - digit for digit in first_half] + [digit for digit in second_half]\n    \n    # Sort changes in descending order\n    changes.sort(reverse=True)\n    \n    # Count the minimum number of changes needed to cover the difference\n    replacements = 0\n    for change in changes:\n        difference -= change\n        replacements += 1\n        if difference <= 0:\n            break\n    \n    return replacements\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # The number of traps needed is equal to the number of unique rooms\n    # visited before returning to the starting point, which is m - 1.\n    return m - 1\n\n# Read input\nm, x = map(int, input().split())\n# Output the result\nprint(minimum_traps(m, x))\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    def can_distribute(x):\n        plates_for_a = a // x\n        plates_for_b = b // x\n        return plates_for_a + plates_for_b >= n\n\n    left, right = 1, max(a, b)\n    result = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_distribute(mid):\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n\n# Input reading\nn, a, b = map(int, input().split())\nprint(max_min_pieces(n, a, b))\n```",
    "32": "```python\ndef is_valid_journey(n, journey):\n    current_position = 0  # Position in kilometers from the North Pole (0 to 20000)\n    \n    for t, direction in journey:\n        if current_position == 0 and direction != \"South\":\n            return \"NO\"\n        if current_position == 20000 and direction != \"North\":\n            return \"NO\"\n        \n        if direction == \"South\":\n            current_position += t\n        elif direction == \"North\":\n            current_position -= t\n        # East and West do not affect the North/South position\n        elif direction in {\"East\", \"West\"}:\n            continue\n        \n        # Check if the current position is out of bounds\n        if current_position < 0 or current_position > 20000:\n            return \"NO\"\n    \n    return \"YES\" if current_position == 0 else \"NO\"\n```",
    "28": "```python\ndef rename_files(n, files):\n    examples = []\n    regulars = []\n    \n    # Separate files into examples and regular tests\n    for name, type_ in files:\n        if type_ == '1':\n            examples.append(name)\n        else:\n            regulars.append(name)\n    \n    # Prepare the moves\n    moves = []\n    \n    # Rename examples\n    for i, example in enumerate(examples):\n        moves.append(f\"move {example} {i + 1}\")\n    \n    # Rename regular tests\n    for i, regular in enumerate(regulars):\n        moves.append(f\"move {regular} {len(examples) + i + 1}\")\n    \n    # Output the result\n    print(len(moves))\n    print(\"\\n\".join(moves))\n\n# Read input\nn = int(input())\nfiles = [input().split() for _ in range(n)]\nrename_files(n, files)\n```",
    "35": "```python\ndef is_valid_flag(n, m, field):\n    # Check if the number of rows is divisible by 3\n    if n % 3 != 0:\n        return \"NO\"\n    \n    stripe_height = n // 3\n    colors = set()\n    \n    # Check horizontal stripes\n    for i in range(3):\n        stripe = field[i * stripe_height:(i + 1) * stripe_height]\n        first_row_color = stripe[0][0]\n        \n        # Check if all rows in the stripe are the same color\n        if any(row != first_row_color * m for row in stripe):\n            return \"NO\"\n        \n        colors.add(first_row_color)\n    \n    # Check if we have exactly three different colors\n    return \"YES\" if len(colors) == 3 else \"NO\"\n\n# Input reading\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(is_valid_flag(n, m, field))\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    m0, x0, x1 = m, 0, 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef birthday_paradox(n, k):\n    MOD = 1000003\n    days = 1 << n  # 2^n\n    if k > days:\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the probability of no shared birthdays\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator *= (days - i)\n        denominator *= days\n        numerator %= MOD\n        denominator %= MOD\n\n    # Probability of at least one shared birthday\n    A = (denominator - numerator) % MOD\n    B = denominator % MOD\n\n    # Reduce A/B to irreducible form\n    common_gcd = gcd(A, B)\n    A //= common_gcd\n    B //= common_gcd\n\n    return A % MOD, B % MOD\n\n# Input reading\nn, k = map(int, input().split())\nresult = birthday_paradox(n, k)\nprint(result[0], result[1])\n```",
    "36": "```python\ndef find_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 0\n\n    # Determine the layer in which the move n is located\n    while n > moves_in_layer:\n        layer += 1\n        moves_in_layer = 6 * layer\n\n    # Calculate the coordinates based on the layer and remaining moves\n    x, y = layer, 0\n    remaining_moves = n - (moves_in_layer - 6 * layer)\n\n    if remaining_moves > 0:\n        # Each segment of the layer corresponds to a direction\n        direction = remaining_moves // layer\n        steps = remaining_moves % layer\n\n        if direction == 0:  # right\n            x += steps\n        elif direction == 1:  # top-right\n            x += steps\n            y += steps\n        elif direction == 2:  # top-left\n            x -= steps\n            y += steps\n        elif direction == 3:  # left\n            x -= steps\n        elif direction == 4:  # bottom-left\n            x -= steps\n            y -= steps\n        elif direction == 5:  # bottom-right\n            x += steps\n            y -= steps\n\n    return (x, y)\n\nn = int(input())\nx, y = find_coordinates(n)\nprint(x, y)\n```",
    "37": "```python\ndef can_deal_exact_damage(a, b, c):\n    for x in range(c // a + 1):\n        if (c - a * x) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Input reading\na, b, c = map(int, input().split())\nprint(can_deal_exact_damage(a, b, c))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    \n    # Check if the entire string is a palindrome\n    if not is_palindrome(s):\n        return n\n    \n    # Check if all characters are the same\n    if s.count(s[0]) == n:\n        return 0\n    \n    # The longest non-palindrome substring can be obtained by removing one character from either end\n    return n - 1\n\n# Read input\ns = input().strip()\n# Output the result\nprint(longest_non_palindrome_substring(s))\n```",
    "40": "```python\ndef determine_round_rating(n, ratings):\n    # Check if any rating has changed\n    for a, b in ratings:\n        if a != b:\n            return \"rated\"\n    \n    # Check if the ratings are in non-increasing order\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            return \"unrated\"\n    \n    return \"maybe\"\n\n# Input reading\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(determine_round_rating(n, ratings))\n```",
    "33": "```python\ndef count_common_ap_integers(a1, b1, a2, b2, L, R):\n    def find_first_valid_x(start, step, b, limit):\n        if step == 0:\n            return b if start <= limit else None\n        if (start - b) % step == 0 and start <= limit:\n            return start\n        if step > 0:\n            return b + ((start - b + step - 1) // step) * step\n        return None\n\n    def find_last_valid_x(end, step, b):\n        if step == 0:\n            return b if end >= b else None\n        if (end - b) % step == 0:\n            return end\n        if step > 0:\n            return b + (end - b) // step * step\n        return None\n\n    # Calculate the first and last valid x for both progressions\n    first_x1 = find_first_valid_x(L, a1, b1, R)\n    last_x1 = find_last_valid_x(R, a1, b1)\n    \n    first_x2 = find_first_valid_x(L, a2, b2, R)\n    last_x2 = find_last_valid_x(R, a2, b2)\n\n    # If any of the ranges are invalid, return 0\n    if None in (first_x1, last_x1, first_x2, last_x2):\n        return 0\n\n    # Calculate the common range\n    start = max(first_x1, first_x2)\n    end = min(last_x1, last_x2)\n\n    if start > end:\n        return 0\n\n    # Count the number of valid integers in the common range\n    count = (end - start) // a1 + 1\n    return count\n\n# Input reading\na1, b1, a2, b2, L, R = map(int, input().split())\nresult = count_common_ap_integers(a1, b1, a2, b2, L, R)\nprint(result)\n```",
    "38": "```python\ndef can_coincide_tracks(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between consecutive barriers for Kefa\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    # Calculate the distances between consecutive barriers for Sasha\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Check if the two lists of differences can match by rotation\n    double_kefa_diffs = kefa_diffs * 2  # Concatenate to allow rotation matching\n    return \"YES\" if any(double_kefa_diffs[i:i + n] == sasha_diffs for i in range(n)) else \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_coincide_tracks(n, L, kefa_distances, sasha_distances))\n```",
    "42": "```python\ndef count_cyclic_binary_strings(n, s):\n    from itertools import product\n\n    total_count = 0\n    seen = set()\n\n    # Generate all possible binary strings of length n\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        # Check if any cyclic shift of t contains s as a substring\n        if any(s in t[i:] + t[:i] for i in range(n)):\n            seen.add(t)\n\n    return len(seen)\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_cyclic_binary_strings(n, s))\n```",
    "26": "```python\ndef main():\n    import sys\n    from math import pow\n\n    # Step 1: Read input and parse the numbers\n    x, y, z = map(float, input().strip().split())\n\n    # Step 2: Define expressions and their corresponding labels\n    expressions = [\n        (pow(x, pow(y, z)), \"x^y^z\"),\n        (pow(x, pow(z, y)), \"x^z^y\"),\n        (pow(pow(x, y), z), \"(x^y)^z\"),\n        (pow(pow(x, z), y), \"(x^z)^y\"),\n        (pow(y, pow(x, z)), \"y^x^z\"),\n        (pow(y, pow(z, x)), \"y^z^x\"),\n        (pow(pow(y, x), z), \"(y^x)^z\"),\n        (pow(pow(y, z), x), \"(y^z)^x\"),\n        (pow(z, pow(x, y)), \"z^x^y\"),\n        (pow(z, pow(y, x)), \"z^y^x\"),\n        (pow(pow(z, x), y), \"(z^x)^y\"),\n        (pow(pow(z, y), x), \"(z^y)^x\"),\n    ]\n\n    # Step 3: Find the maximum value and corresponding expression\n    max_value = float('-inf')\n    max_expression = \"\"\n    \n    for value, expr in expressions:\n        if value > max_value:\n            max_value = value\n            max_expression = expr\n\n    # Output the result\n    print(max_expression)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "48": "```python\ndef kth_largest_in_multiplication_table(n, m, k):\n    left, right = 1, n * m\n    \n    while left < right:\n        mid = (left + right) // 2\n        count = sum(min(mid // i, m) for i in range(1, n + 1))\n        \n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return left\n\n# Input reading\nn, m, k = map(int, input().split())\nprint(kth_largest_in_multiplication_table(n, m, k))\n```",
    "41": "```python\ndef nearest_zero_distance(n, array):\n    distances = [float('inf')] * n\n    last_zero_index = -1\n\n    # Forward pass to find distances to the nearest zero\n    for i in range(n):\n        if array[i] == 0:\n            last_zero_index = i\n            distances[i] = 0\n        elif last_zero_index != -1:\n            distances[i] = i - last_zero_index\n\n    # Backward pass to find distances to the nearest zero\n    last_zero_index = -1\n    for i in range(n - 1, -1, -1):\n        if array[i] == 0:\n            last_zero_index = i\n        elif last_zero_index != -1:\n            distances[i] = min(distances[i], last_zero_index - i)\n\n    return distances\n\n# Example usage:\nn = int(input())\narray = list(map(int, input().split()))\nresult = nearest_zero_distance(n, array)\nprint(' '.join(map(str, result)))\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Calculate the minimum sum required for the first k natural numbers\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        return -1\n\n    # Calculate the maximum possible gcd\n    max_gcd = n // k\n\n    # Iterate to find the largest gcd that allows forming a valid sequence\n    for g in range(max_gcd, 0, -1):\n        total = g * min_sum  # Total sum if we use g as the gcd\n        if total <= n:\n            # We can form the sequence\n            sequence = [g * i for i in range(1, k + 1)]\n            # Adjust the last element to match the sum n\n            sequence[-1] += (n - total)\n            return sequence\n\n    return -1\n\n# Read input\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\n# Print output\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "47": "```python\ndef max_beauty_with_subarray(n, x, a):\n    def kadane(arr):\n        max_ending_here = max_so_far = 0\n        for value in arr:\n            max_ending_here = max(0, max_ending_here + value)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    original_beauty = kadane(a)\n\n    max_increase = 0\n    current_sum = 0\n    for value in a:\n        current_sum += value\n        max_increase = max(max_increase, current_sum * x)\n        if current_sum < 0:\n            current_sum = 0\n\n    max_beauty = max(original_beauty, original_beauty + max_increase)\n\n    return max_beauty\n```",
    "44": "```python\ndef minimal_time_to_post_office(d, k, a, b, t):\n    # Total time if Vasiliy walks the entire distance\n    walk_time = d * b\n    \n    # Initialize the minimum time with the walking time\n    min_time = walk_time\n    \n    # Calculate the number of full segments Vasiliy can drive\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Calculate time for driving full segments and walking the remaining distance\n    if full_segments > 0:\n        driving_time = full_segments * k * a\n        repair_time = (full_segments - 1) * t if full_segments > 1 else 0\n        total_time = driving_time + repair_time + remaining_distance * b\n        min_time = min(min_time, total_time)\n    \n    # Check if Vasiliy can drive one less segment and walk the rest\n    if full_segments > 0:\n        driving_time = (full_segments - 1) * k * a\n        repair_time = (full_segments - 1) * t\n        total_time = driving_time + repair_time + k * a + remaining_distance * b\n        min_time = min(min_time, total_time)\n    \n    return min_time\n\n# Input reading\nd, k, a, b, t = map(int, input().split())\nprint(minimal_time_to_post_office(d, k, a, b, t))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    length = 1  # Current digit length\n    count = 9   # Count of numbers with the current digit length\n    start = 1   # Starting number with the current digit length\n\n    # Determine the range where the k-th digit lies\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    # Find the actual number that contains the k-th digit\n    start += (k - 1) // length\n    num_str = str(start)\n    \n    # Find the specific digit\n    return num_str[(k - 1) % length]\n\nk = int(input().strip())\nprint(find_kth_digit(k))\n```",
    "46": "```python\ndef count_divisible_pairs(n, m):\n    # Count occurrences of each remainder when divided by 5\n    count_x = [0] * 5\n    count_y = [0] * 5\n    \n    # Count how many numbers in range 1 to n give each remainder when divided by 5\n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n    \n    # Count how many numbers in range 1 to m give each remainder when divided by 5\n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n    \n    # Calculate the number of valid pairs (x, y)\n    total_pairs = sum(count_x[r] * count_y[(5 - r) % 5] for r in range(5))\n    \n    return total_pairs\n\n# Read input\nn, m = map(int, input().split())\n# Print the result\nprint(count_divisible_pairs(n, m))\n```",
    "43": "```python\nimport sys\nimport math\n\ndef find_min_angle_pair(n, vectors):\n    angles = []\n\n    # Calculate angles and store with their original indices\n    for i in range(n):\n        x, y = vectors[i]\n        angle = math.atan2(y, x)  # Angle in radians\n        angles.append((angle, i + 1))  # Store angle and 1-based index\n\n    # Sort angles\n    angles.sort()\n\n    # Initialize minimum angle and pair of indices\n    min_angle = float('inf')\n    min_pair = (0, 0)\n\n    # Check adjacent angles in the sorted list\n    for i in range(n):\n        angle1, index1 = angles[i]\n        angle2, index2 = angles[(i + 1) % n]  # Wrap around to first element\n        \n        # Calculate the non-oriented angle\n        angle_diff = angle2 - angle1\n        if angle_diff < 0:\n            angle_diff += 2 * math.pi\n        \n        # Update minimum angle and pair if found a smaller angle\n        if angle_diff < min_angle:\n            min_angle = angle_diff\n            min_pair = (index1, index2)\n\n    return min_pair\n\n# Read input\nn = int(sys.stdin.readline().strip())\nvectors = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\n# Find and print the result\nresult = find_min_angle_pair(n, vectors)\nprint(result[0], result[1])\n```",
    "51": "```python\ndef find_x_y(n, divisors):\n    from collections import Counter\n    \n    # Count occurrences of each divisor\n    divisor_count = Counter(divisors)\n    \n    # The maximum divisor is either x or y\n    x = max(divisor_count)\n    divisor_count[x] -= 1  # Remove one occurrence of x\n    \n    # Now find y by checking the remaining divisors\n    y = 1\n    for d, count in divisor_count.items():\n        if count > 0:\n            y *= d ** count\n    \n    return x, y\n\n# Input reading\nn = int(input().strip())\ndivisors = list(map(int, input().strip().split()))\n\n# Finding x and y\nx, y = find_x_y(n, divisors)\n\n# Output the result\nprint(x, y)\n```",
    "56": "```python\ndef count_reachable_numbers(n):\n    reachable = set()\n\n    def f(x):\n        x += 1\n        while x % 10 == 0:\n            x //= 10\n        return x\n\n    current = n\n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n\n    return len(reachable)\n\nn = int(input())\nprint(count_reachable_numbers(n))\n```",
    "59": "```python\ndef min_operations_to_remainder(n, x, y, number):\n    # Create the target pattern based on y\n    target = ['0'] * x\n    target[y] = '1'\n    \n    # Count the number of operations needed\n    operations = sum(1 for i in range(x) if number[n - 1 - i] != target[x - 1 - i])\n    \n    return operations\n\n# Read input\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# Get the result and print it\nresult = min_operations_to_remainder(n, x, y, number)\nprint(result)\n```",
    "54": "```python\ndef find_minimum_D(n, a):\n    min_a = min(a)\n    max_a = max(a)\n    \n    # Check if it's possible to make all elements equal\n    if max_a - min_a > 2 * (max_a - min_a) // 2:\n        return -1\n    \n    if max_a == min_a:\n        return 0\n    \n    # Calculate the minimum D\n    D = (max_a - min_a + 1) // 2\n    return D\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(find_minimum_D(n, a))\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = float('-inf')\n    moves = []\n\n    while left <= right:\n        if a[left] > last_taken and (a[right] <= last_taken or a[left] < a[right]):\n            last_taken = a[left]\n            moves.append('L')\n            left += 1\n        elif a[right] > last_taken:\n            last_taken = a[right]\n            moves.append('R')\n            right -= 1\n        else:\n            break\n\n    return len(moves), ''.join(moves)\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Function call and output\nlength, sequence = longest_increasing_sequence(n, a)\nprint(length)\nprint(sequence)\n```",
    "60": "```python\ndef has_palindrome_subsequence(t, test_cases):\n    results = []\n    \n    for n, a in test_cases:\n        last_seen = {}\n        found = False\n        \n        for i in range(n):\n            if a[i] in last_seen:\n                # Check if the distance between the same elements is at least 2\n                if i - last_seen[a[i]] >= 2:\n                    found = True\n                    break\n            last_seen[a[i]] = i\n        \n        results.append(\"YES\" if found else \"NO\")\n    \n    return results\n```",
    "58": "```python\ndef color_array(n, k, a):\n    from collections import defaultdict\n\n    # Step 1: Initialize variables\n    color_assignment = [0] * n\n    frequency = defaultdict(list)\n\n    # Step 2: Organize indices of each unique number\n    for index, value in enumerate(a):\n        frequency[value].append(index)\n\n    # Step 3: Check if coloring is possible\n    if len(frequency) > k:\n        return \"NO\"\n\n    # Step 4: Assign colors\n    current_color = 1\n    for indices in frequency.values():\n        for i, index in enumerate(indices):\n            color_assignment[index] = (i % k) + 1\n\n    return \"YES\", color_assignment\n\n# Example usage:\n# n, k = map(int, input().split())\n# a = list(map(int, input().split()))\n# result = color_array(n, k, a)\n# if result == \"NO\":\n#     print(result)\n# else:\n#     print(result[0])\n#     print(\" \".join(map(str, result[1])))\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_elements = m // 2\n    dp = [[-1] * k for _ in range(n + 1)]\n    dp[0][0] = 0  # Base case: sum of 0 is divisible by k\n\n    for i in range(1, n + 1):\n        row = sorted(matrix[i - 1], reverse=True)[:max_elements]\n        current_sums = {0}  # Start with the sum of choosing no elements\n\n        for value in row:\n            current_sums.update({s + value for s in current_sums})\n\n        for mod in range(k):\n            if dp[i - 1][mod] != -1:\n                for s in current_sums:\n                    new_sum = dp[i - 1][mod] + s\n                    new_mod = new_sum % k\n                    dp[i][new_mod] = max(dp[i][new_mod], new_sum)\n\n    return max(dp[n])\n\n# Example usage:\n# n, m, k = map(int, input().split())\n# matrix = [list(map(int, input().split())) for _ in range(n)]\n# print(max_sum_divisible_by_k(n, m, k, matrix))\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph, n):\n    visited = [-1] * (n + 1)\n    queue = deque([start])\n    visited[start] = 0\n    farthest_node = start\n\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if visited[neighbor] == -1:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > visited[farthest_node]:\n                    farthest_node = neighbor\n\n    return farthest_node, visited\n\ndef find_max_edges_and_vertices(n, edges):\n    graph = defaultdict(list)\n    \n    # Build the graph\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # Step 1: Find the farthest node from an arbitrary node (1)\n    farthest_node_from_start, _ = bfs(1, graph, n)\n\n    # Step 2: Find the farthest node from the previously found farthest node\n    farthest_node, distances = bfs(farthest_node_from_start, graph, n)\n\n    # Step 3: Find the second farthest node from the farthest node found\n    second_farthest_node, distances_from_second = bfs(farthest_node, graph, n)\n\n    # The maximum number of edges is the distance between these two farthest nodes\n    max_edges = distances[second_farthest_node]\n\n    # Collect the path nodes\n    path_nodes = []\n    current = second_farthest_node\n    while current != farthest_node:\n        path_nodes.append(current)\n        for neighbor in graph[current]:\n            if distances[neighbor] == distances[current] - 1:\n                current = neighbor\n                break\n    path_nodes.append(farthest_node)\n\n    # Choose any three distinct vertices from the path\n    a, b, c = path_nodes[0], path_nodes[1], path_nodes[2]\n\n    return max_edges, a, b, c\n\n# Input reading\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\n# Get the result\nresult = find_max_edges_and_vertices(n, edges)\n\n# Output the result\nprint(result[0])\nprint(result[1], result[2], result[3])\n```",
    "63": "```python\ndef minimum_instability(n, a):\n    # Sort the array to easily find the min and max after removing an element\n    a.sort()\n    \n    # Calculate the minimum instability after removing one element\n    instability_remove_min = a[-1] - a[1]  # Remove the smallest element\n    instability_remove_max = a[-2] - a[0]  # Remove the largest element\n    \n    # Return the minimum instability\n    return min(instability_remove_min, instability_remove_max)\n\n# Example usage:\n# n = int(input())\n# a = list(map(int, input().split()))\n# print(minimum_instability(n, a))\n```",
    "61": "```python\ndef max_number_after_replacement(n, a, f):\n    # Convert the function mapping to a list where index 0 corresponds to digit '1'\n    f = [0] + f  # Adding a dummy value at index 0 for convenience\n\n    # Convert the string of digits into a list of integers\n    digits = list(map(int, a))\n    \n    # Initialize a flag to indicate if we have started replacing\n    replacing = False\n    \n    # Iterate through the digits\n    for i in range(n):\n        current_digit = digits[i]\n        mapped_digit = f[current_digit]\n        \n        if mapped_digit > current_digit:\n            # Start replacing if the mapped digit is greater\n            digits[i] = mapped_digit\n            replacing = True\n        elif mapped_digit < current_digit and replacing:\n            # Stop replacing if we encounter a mapped digit less than the current digit\n            break\n    \n    # Convert the list of digits back to a string\n    return ''.join(map(str, digits))\n\n# Example usage:\nn = int(input())\na = input().strip()\nf = list(map(int, input().strip().split()))\nprint(max_number_after_replacement(n, a, f))\n```",
    "55": "```python\ndef can_see_white_sheet(white_sheet, black_sheet1, black_sheet2):\n    x1, y1, x2, y2 = white_sheet\n    x3, y3, x4, y4 = black_sheet1\n    x5, y5, x6, y6 = black_sheet2\n\n    # Check if the white sheet is completely covered by both black sheets\n    is_covered = (\n        (x3 <= x1 < x4 and y3 <= y1 < y4) and\n        (x5 <= x1 < x6 and y5 <= y1 < y6) and\n        (x3 <= x2 <= x4 and y3 <= y2 <= y4) and\n        (x5 <= x2 <= x6 and y5 <= y2 <= y6)\n    )\n\n    if is_covered:\n        return \"NO\"\n\n    # Check for visibility\n    visible_left = x3 >= x2 or x5 >= x2\n    visible_right = x4 <= x1 or x6 <= x1\n    visible_below = y3 >= y2 or y5 >= y2\n    visible_above = y4 <= y1 or y6 <= y1\n\n    if visible_left or visible_right or visible_below or visible_above:\n        return \"YES\"\n\n    return \"NO\"\n\n# Input reading\nwhite_sheet = tuple(map(int, input().split()))\nblack_sheet1 = tuple(map(int, input().split()))\nblack_sheet2 = tuple(map(int, input().split()))\n\n# Call the function and print the result\nresult = can_see_white_sheet(white_sheet, black_sheet1, black_sheet2)\nprint(result)\n```",
    "65": "```python\ndef transform_moves(n, m):\n    if m % n != 0:\n        return -1\n    \n    quotient = m // n\n    moves = 0\n    \n    while quotient > 1:\n        if quotient % 2 == 0:\n            quotient //= 2\n            moves += 1\n        elif quotient % 3 == 0:\n            quotient //= 3\n            moves += 1\n        else:\n            return -1\n    \n    return moves\n\n# Input reading\nn, m = map(int, input().split())\nprint(transform_moves(n, m))\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Find the longest prefix which is also a suffix\n    lps = [0] * n\n    j = 0  # length of previous longest prefix suffix\n    i = 1\n\n    # Preprocess the pattern to create the lps array\n    while i < n:\n        if t[i] == t[j]:\n            j += 1\n            lps[i] = j\n            i += 1\n        else:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                lps[i] = 0\n                i += 1\n\n    # The length of the longest prefix which is also a suffix\n    overlap_length = lps[-1]\n\n    # Construct the result string\n    result = t + (t[overlap_length:] * (k - 1))\n    return result\n\n# Read input\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the result and print it\nprint(construct_string(n, k, t))\n```",
    "57": "```python\ndef assign_gifts(n, friends):\n    givers = {i for i in range(1, n + 1) if i not in friends}\n    receivers = {f for f in friends if f != 0}\n    \n    result = friends[:]\n    givers = list(givers)\n    giver_index = 0\n\n    for i in range(n):\n        if result[i] == 0:\n            while giver_index < len(givers):\n                if givers[giver_index] not in receivers and givers[giver_index] != i + 1:\n                    result[i] = givers[giver_index]\n                    giver_index += 1\n                    break\n                giver_index += 1\n\n    return result\n\n# Example usage\nn = int(input())\nfriends = list(map(int, input().split()))\nresult = assign_gifts(n, friends)\nprint(' '.join(map(str, result)))\n```",
    "71": "```python\ndef calculate_output(a: int) -> int:\n    \"\"\"Calculate the bit length of (a - 1).\"\"\"\n    return (a - 1).bit_length()\n\ndef main():\n    a = int(input().strip())\n    if 1 <= a <= 64:\n        print(calculate_output(a))\n    else:\n        raise ValueError(\"Input must be between 1 and 64 inclusive.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    # Initialize the schedule with zeros (rest days)\n    schedule = [0] * n\n    \n    # Process each exam\n    for i in range(m):\n        s_i, d_i, c_i = exams[i]\n        # Adjust to 0-based index\n        s_i -= 1\n        d_i -= 1\n        \n        # Find available preparation days\n        available_days = [j for j in range(s_i, d_i) if schedule[j] == 0]\n        \n        # Check if we can allocate preparation days\n        if len(available_days) < c_i:\n            return -1  # Not enough days to prepare\n        \n        # Allocate preparation days\n        for j in range(c_i):\n            schedule[available_days[j]] = i + 1  # Mark preparation for exam i+1\n        \n        # Mark the exam day\n        schedule[d_i] = m + 1  # Mark the exam day\n    \n    return schedule\n\n# Read input\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the schedule\nresult = schedule_exams(n, m, exams)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "67": "```python\ndef find_nice_indices(n, a):\n    total_sum = sum(a)\n    nice_indices = []\n    count = {}\n\n    # Count occurrences of each element\n    for num in a:\n        count[num] = count.get(num, 0) + 1\n\n    for i in range(n):\n        current_value = a[i]\n        remaining_sum = total_sum - current_value\n        \n        # Check if the remaining sum is even and if the target can be found\n        if remaining_sum % 2 == 0:\n            target = remaining_sum // 2\n            if target in count:\n                # Ensure we have enough occurrences of target\n                if (target != current_value and count[target] > 0) or (target == current_value and count[target] > 1):\n                    nice_indices.append(i + 1)  # Store 1-based index\n\n    return nice_indices\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find nice indices\nnice_indices = find_nice_indices(n, a)\n\n# Print output\nprint(len(nice_indices))\nif nice_indices:\n    print(\" \".join(map(str, nice_indices)))\n```",
    "62": "```python\ndef min_operations_to_divisible_triplet(test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        min_operations = float('inf')\n        best_triplet = (a, b, c)\n        \n        # Iterate through possible values for A\n        for A in range(1, a + 1):\n            # Find the closest B that is divisible by A\n            B = (b // A) * A if b % A == 0 else ((b // A) + 1) * A\n            \n            # Ensure B is at least A\n            if B < A:\n                B = A\n            \n            # Find the closest C that is divisible by B\n            C = (c // B) * B if c % B == 0 else ((c // B) + 1) * B\n            \n            # Ensure C is at least B\n            if C < B:\n                C = B\n            \n            # Calculate the number of operations\n            operations = abs(A - a) + abs(B - b) + abs(C - c)\n            \n            # Update if we found a better solution\n            if operations < min_operations:\n                min_operations = operations\n                best_triplet = (A, B, C)\n        \n        results.append((min_operations, best_triplet))\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations_to_divisible_triplet(test_cases)\n\n# Print output\nfor operations, triplet in results:\n    print(operations)\n    print(*triplet)\n```",
    "70": "```python\ndef calculate_midpoint(start_time, end_time):\n    # Convert start and end times to total minutes\n    start_minutes = start_time[0] * 60 + start_time[1]\n    end_minutes = end_time[0] * 60 + end_time[1]\n    \n    # Calculate midpoint in total minutes\n    midpoint_minutes = (start_minutes + end_minutes) // 2\n    \n    # Convert back to hours and minutes\n    h3 = midpoint_minutes // 60\n    m3 = midpoint_minutes % 60\n    \n    return h3, m3\n\ndef parse_time(time_str):\n    return tuple(map(int, time_str.split(':')))\n\ndef format_time(h, m):\n    return f\"{h:02}:{m:02}\"\n\n# Read input\nstart_time = parse_time(input().strip())\nend_time = parse_time(input().strip())\n\n# Calculate midpoint\nmidpoint = calculate_midpoint(start_time, end_time)\n\n# Print result in the required format\nprint(format_time(*midpoint))\n```",
    "73": "```python\ndef can_complete_wall(n, heights):\n    max_height = max(heights)\n    total_bricks_needed = sum(max_height - height for height in heights)\n    \n    # Check if the total number of bricks needed is even\n    return total_bricks_needed % 2 == 0\n\n# Read input\nn = int(input())\nheights = list(map(int, input().split()))\n\n# Output result\nprint(\"YES\" if can_complete_wall(n, heights) else \"NO\")\n```",
    "77": "```python\ndef minimum_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    print(minimum_difference(n))\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    lefts = [segments[i][0] for i in range(n)]\n    rights = [segments[i][1] for i in range(n)]\n    \n    max_left = max(lefts)\n    min_right = min(rights)\n\n    second_max_left = -1\n    second_min_right = float('inf')\n\n    for i in range(n):\n        if lefts[i] != max_left:\n            second_max_left = max(second_max_left, lefts[i])\n        if rights[i] != min_right:\n            second_min_right = min(second_min_right, rights[i])\n\n    max_length = 0\n    for i in range(n):\n        current_left = second_max_left if lefts[i] == max_left else max_left\n        current_right = second_min_right if rights[i] == min_right else min_right\n        \n        intersection_length = max(0, current_right - current_left)\n        max_length = max(max_length, intersection_length)\n\n    return max_length\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import Counter\n\n    # Count the frequency of each character in the string\n    freq = Counter(s)\n    \n    total_cost = 0\n    unique_subsequences = 0\n\n    # Iterate over possible lengths of subsequences\n    for length in range(1, n + 1):\n        current_length_subsequences = sum(1 for count in freq.values() if count >= length)\n\n        if current_length_subsequences == 0:\n            break\n        \n        # Each subsequence of this length has a cost of (n - length)\n        total_cost += current_length_subsequences * (n - length)\n        unique_subsequences += current_length_subsequences\n        \n        # Check if we have reached the required size k\n        if unique_subsequences >= k:\n            return total_cost\n    \n    # If we exit the loop and haven't reached k unique subsequences, it's impossible\n    return -1\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n\n    if D >= n:\n        print(\"NO\")\n        return\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    if len(graph[1]) < D:\n        print(\"NO\")\n        return\n\n    spanning_tree_edges = []\n    visited = set()\n    visited.add(1)\n\n    # Connect vertex 1 to D neighbors\n    degree_count = 0\n    for neighbor in graph[1]:\n        if degree_count < D:\n            spanning_tree_edges.append((1, neighbor))\n            visited.add(neighbor)\n            degree_count += 1\n        else:\n            break\n\n    # Use BFS to add remaining edges to form a spanning tree\n    queue = deque([1])\n    while queue and len(spanning_tree_edges) < n - 1:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                spanning_tree_edges.append((current, neighbor))\n                queue.append(neighbor)\n                if len(spanning_tree_edges) == n - 1:\n                    break\n\n    if len(spanning_tree_edges) == n - 1:\n        print(\"YES\")\n        for u, v in spanning_tree_edges:\n            print(u, v)\n    else:\n        print(\"NO\")\n\n# Example usage:\n# n, m, D = map(int, input().split())\n# edges = [tuple(map(int, input().split())) for _ in range(m)]\n# find_spanning_tree(n, m, D, edges)\n```",
    "76": "```python\ndef can_construct_symmetric_square(t, test_cases):\n    results = []\n    \n    for n, m, tiles in test_cases:\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        top_left_bottom_right = set()\n        top_right_bottom_left = set()\n        \n        for tile in tiles:\n            top_left, top_right = tile[0]\n            bottom_left, bottom_right = tile[1]\n            top_left_bottom_right.add((top_left, bottom_right))\n            top_right_bottom_left.add((top_right, bottom_left))\n        \n        if any(tile in top_right_bottom_left for tile in top_left_bottom_right):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n```",
    "81": "```python\ndef can_reorder_strings(n, strings):\n    # Step 1: Sort strings by their lengths\n    strings.sort(key=len)\n\n    # Step 2: Check if each string is a substring of the next one\n    for i in range(n - 1):\n        if strings[i] not in strings[i + 1]:\n            return \"NO\"\n\n    # Step 3: If all checks passed, return the result\n    return \"YES\", strings\n\n# Read input\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\n# Get the result\nresult = can_reorder_strings(n, strings)\n\n# Print the output\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    print('\\n'.join(result[1]))\n```",
    "82": "```python\ndef max_problems_solved(n, k, difficulties):\n    left, right = 0, n - 1\n    solved_count = 0\n\n    while left <= right:\n        if difficulties[left] <= k:\n            solved_count += 1\n            left += 1\n        elif difficulties[right] <= k:\n            solved_count += 1\n            right -= 1\n        else:\n            break\n\n    return solved_count\n\n# Input reading\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Output the result\nprint(max_problems_solved(n, k, difficulties))\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Define the food consumption pattern for each day of the week\n    food_pattern = [0, 0, 1, 0, 0, 1, 2]  # 0: fish, 1: rabbit, 2: chicken\n    food_needed = [3, 2, 2]  # Full week consumption: fish, rabbit, chicken\n    \n    # Calculate the maximum full weeks we can sustain\n    full_weeks = min(a // food_needed[0], b // food_needed[1], c // food_needed[2])\n    a -= full_weeks * food_needed[0]\n    b -= full_weeks * food_needed[1]\n    c -= full_weeks * food_needed[2]\n    \n    # Calculate the maximum additional days we can sustain after full weeks\n    max_additional_days = 0\n    \n    for start_day in range(7):\n        remaining_a, remaining_b, remaining_c = a, b, c\n        days = 0\n        \n        for i in range(7):\n            day = (start_day + i) % 7\n            if food_pattern[day] == 0:  # Fish food days\n                if remaining_a > 0:\n                    remaining_a -= 1\n                    days += 1\n                else:\n                    break\n            elif food_pattern[day] == 1:  # Rabbit stew days\n                if remaining_b > 0:\n                    remaining_b -= 1\n                    days += 1\n                else:\n                    break\n            else:  # Chicken stake days\n                if remaining_c > 0:\n                    remaining_c -= 1\n                    days += 1\n                else:\n                    break\n        \n        max_additional_days = max(max_additional_days, days)\n    \n    return full_weeks * 7 + max_additional_days\n\n# Input reading\na, b, c = map(int, input().split())\nprint(max_days(a, b, c))\n```",
    "74": "```python\nfrom collections import Counter\nfrom math import comb\n\ndef min_cost_to_obtain_set(n, k, s):\n    freq = Counter(s)\n    unique_chars = len(freq)\n    \n    if unique_chars < k:\n        return -1\n    \n    total_subsequences = 0\n    costs = []\n    \n    for length in range(1, n + 1):\n        subseq_count = sum(comb(freq[char], length) for char in freq if freq[char] >= length)\n        total_subsequences += subseq_count\n        costs.append((n - length) * subseq_count)\n        \n        if total_subsequences >= k:\n            break\n    \n    if total_subsequences < k:\n        return -1\n    \n    min_cost = 0\n    remaining = k\n    \n    for length, cost in enumerate(costs):\n        if remaining <= 0:\n            break\n        if total_subsequences >= remaining:\n            min_cost += cost * remaining\n            break\n        else:\n            min_cost += cost * total_subsequences\n            remaining -= total_subsequences\n    \n    return min_cost\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n: int) -> int:\n    s = str(n)\n    length = len(s)\n    min_moves = float('inf')\n\n    # Check for pairs of digits that can form 00 or 25\n    for target in ['00', '25']:\n        moves = 0\n        target_found = False\n\n        for i in range(length - 1, -1, -1):\n            if s[i] == target[1] and target_found:\n                # Found the second digit of the target pair\n                moves += (length - 1 - i)  # Moves to bring this digit to the end\n                break\n            elif s[i] == target[0]:\n                # Found the first digit of the target pair\n                target_found = True\n            elif target_found:\n                # Count moves to bring this digit to the end if we already found the first digit\n                moves += 1\n\n        if target_found and moves < min_moves:\n            min_moves = moves\n\n    return min_moves if min_moves != float('inf') else -1\n\n# Example usage\nn = int(input())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "78": "```python\ndef count_regular_sequences(n, s):\n    MOD = 10**9 + 7\n    m = len(s)\n\n    # Precompute factorials and inverse factorials\n    fact = [1] * (2 * n + 1)\n    for i in range(2, 2 * n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n\n    def mod_inv(x):\n        return pow(x, MOD - 2, MOD)\n\n    inv_fact = [1] * (2 * n + 1)\n    for i in range(2, 2 * n + 1):\n        inv_fact[i] = mod_inv(fact[i])\n\n    # Check if s can be part of a valid sequence\n    balance = 0\n    min_balance = 0\n    for char in s:\n        balance += 1 if char == '(' else -1\n        min_balance = min(min_balance, balance)\n\n    if balance < 0 or balance > 2 * n or min_balance < 0:\n        return 0\n\n    # Count valid sequences\n    total_sequences = 0\n    for prefix_length in range(n + 1):\n        suffix_length = n - prefix_length\n        if prefix_length + m + suffix_length == n:\n            total_sequences += (fact[prefix_length + suffix_length] * inv_fact[prefix_length] % MOD * inv_fact[suffix_length] % MOD)\n            total_sequences %= MOD\n\n    return total_sequences\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(count_regular_sequences(n, s))\n```",
    "84": "```python\ndef can_color_string(n, s):\n    from collections import Counter\n    \n    # Step 1: Count occurrences of each character\n    count = Counter(s)\n    \n    # Step 2: Check if any character appears more than twice\n    if any(cnt > 2 for cnt in count.values()):\n        print(\"NO\")\n        return\n    \n    # Step 3: Create a coloring scheme\n    color = ['0'] * n\n    last_color = '0'\n    \n    for i in range(n):\n        if i > 0 and s[i] == s[i - 1]:\n            color[i] = last_color\n        else:\n            last_color = '1' if last_color == '0' else '0'\n            color[i] = last_color\n    \n    print(\"YES\")\n    print(''.join(color))\n\n# Example usage:\n# n = int(input())\n# s = input().strip()\n# can_color_string(n, s)\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    from collections import defaultdict\n\n    # Step 1: Identify the unique characters and their positions\n    char_positions = defaultdict(list)\n    for index, char in enumerate(s):\n        char_positions[char].append(index)\n\n    # Step 2: Create a color mapping based on the positions of characters\n    color = [0] * n\n    color_count = 0\n\n    # Step 3: Assign colors based on the positions of characters\n    for char in sorted(char_positions.keys()):\n        positions = char_positions[char]\n        for i in range(len(positions)):\n            if i == 0:\n                color[positions[i]] = color_count + 1\n            else:\n                # If the current character position is adjacent to the previous one, assign the same color\n                if positions[i] - positions[i - 1] == 1:\n                    color[positions[i]] = color[positions[i - 1]]\n                else:\n                    color_count += 1\n                    color[positions[i]] = color_count + 1\n        color_count += 1\n\n    # Step 4: Output the results\n    print(color_count)\n    print(' '.join(map(str, color)))\n\n# Example usage\nn = int(input())\ns = input().strip()\nmin_colors_to_sort(n, s)\n```",
    "85": "```python\ndef find_price_before_tax(A, B):\n    for price in range(1, 10000):  # Arbitrarily chosen upper limit for price\n        tax_8 = price * 0.08\n        tax_10 = price * 0.10\n        \n        if int(tax_8) == A and int(tax_10) == B:\n            return price\n            \n    return -1\n\n# Read input\nA, B = map(int, input().split())\n# Output the result\nprint(find_price_before_tax(A, B))\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects by their required rating\n    projects.sort(key=lambda x: x[0])\n    \n    completed_projects = 0\n    current_rating = r\n    \n    for required_rating, rating_change in projects:\n        if current_rating >= required_rating:\n            completed_projects += 1\n            current_rating += rating_change\n            # Ensure the rating does not fall below zero\n            if current_rating < 0:\n                break\n    \n    return completed_projects\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_projects(n, r, projects))\n```",
    "86": "```python\ndef solve_polycarp(n, k):\n    # Calculate the minimum sum required to satisfy the conditions\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n    \n    # Initialize the array with the minimum required problems\n    a = list(range(1, k + 1))\n    current_sum = min_sum\n    \n    # Calculate the remaining problems to distribute\n    remaining = n - current_sum\n    \n    # Distribute the remaining problems from the last day to the first\n    for i in range(k - 1, -1, -1):\n        # Calculate the maximum we can add to a[i] while respecting the conditions\n        max_add = min(remaining, (2 * a[i]) - a[i] - 1)  # Ensure a[i] < a[i+1]\n        a[i] += max_add\n        remaining -= max_add\n        \n        if remaining <= 0:\n            break\n    \n    if remaining > 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n\n# Example usage:\n# n, k = map(int, input().split())\n# solve_polycarp(n, k)\n```",
    "92": "```python\ndef find_integers(x):\n    for a in range(1, 11):\n        for b in range(1, 11):\n            if abs(a * b - x) < 1e-6:\n                return a, b\n\nif __name__ == \"__main__\":\n    x = float(input().strip())\n    result = find_integers(x)\n    print(result[0], result[1])\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects by their required rating (a_i)\n    projects.sort(key=lambda x: x[0])\n    \n    for a, b in projects:\n        if r < a:  # Check if current rating is less than required\n            return \"NO\"\n        r += b  # Update rating after completing the project\n        if r < 0:  # Check if rating falls below zero\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_complete_projects(n, r, projects))\n```",
    "97": "```python\ndef min_coins_to_move_chips(n, positions):\n    even_count = sum(1 for position in positions if position % 2 == 0)\n    odd_count = n - even_count\n    return min(even_count, odd_count)\n\n# Input reading\nn = int(input().strip())\npositions = list(map(int, input().strip().split()))\nprint(min_coins_to_move_chips(n, positions))\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    # Check for impossible conditions\n    if d > 2 * (k - 1) + 1 or (d == 1 and n > 2) or (n > k * (k - 1) + 1):\n        print(\"NO\")\n        return\n\n    edges = []\n    \n    # Create the main path of length d\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n    \n    # Now we have d + 1 vertices in the main path\n    current_vertex = d + 2\n    \n    # Connect remaining vertices\n    for i in range(1, d + 2):\n        while len([e for e in edges if i in e]) < k and current_vertex <= n:\n            edges.append((i, current_vertex))\n            current_vertex += 1\n            if current_vertex > n:\n                break\n    \n    # Check if we used all vertices\n    if current_vertex <= n:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for u, v in edges:\n            print(u, v)\n\n# Example usage:\n# n, d, k = map(int, input().split())\n# construct_tree(n, d, k)\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n\n    # Iterate through possible widths for the rectangle\n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            # Check both (width, height) and (height, width)\n            for w, h in [(width, height), (height, width)]:\n                # Check for red tiles\n                for red_w in range(1, w + 1):\n                    if a % red_w == 0:\n                        red_h = a // red_w\n                        if red_h <= h:\n                            min_perimeter = min(min_perimeter, 2 * (w + h))\n                \n                # Check for blue tiles\n                for blue_w in range(1, w + 1):\n                    if b % blue_w == 0:\n                        blue_h = b // blue_w\n                        if blue_h <= h:\n                            min_perimeter = min(min_perimeter, 2 * (w + h))\n\n    return min_perimeter\n\n# Read input\na, b = map(int, input().split())\n# Print the result\nprint(minimal_perimeter(a, b))\n```",
    "90": "```python\ndef can_reach_end(n, m, d, c):\n    river = [0] * n  # Initialize the river array\n\n    # If the maximum jump distance allows reaching the end directly\n    if d >= n + 1:\n        position = 0\n        for i in range(m):\n            for j in range(c[i]):\n                river[position] = i + 1\n                position += 1\n        return \"YES\", river\n\n    position = 0  # Start placing platforms\n    for i in range(m):\n        # Place the platform at the current position\n        for j in range(c[i]):\n            if position < n:\n                river[position] = i + 1\n                position += 1\n        \n        # Move to the next available position after placing the current platform\n        position += d  # Jump to the next possible position\n\n    # Check if we have filled the river correctly\n    if position <= n:\n        return \"YES\", river\n    else:\n        return \"NO\", []\n\n# Input reading\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Function call and output\nresult, river = can_reach_end(n, m, d, c)\nprint(result)\nif result == \"YES\":\n    print(\" \".join(map(str, river)))\n```",
    "91": "```python\ndef max_removable_length(s: str, t: str) -> int:\n    n, m = len(s), len(t)\n\n    # Create arrays to store the first occurrence of t in s from the left and right\n    left = [-1] * m\n    right = [-1] * m\n\n    # Fill the left array\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n\n    # Fill the right array\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n\n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n\n    # Check the case where we can remove from the start to the end of t\n    max_length = max(max_length, left[m - 1])\n\n    # Check the case where we can remove from the start of t to the end of s\n    max_length = max(max_length, n - right[0] - 1)\n\n    return max_length\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Initialize the binary string\n    s = []\n    \n    # Determine the starting character based on the larger count\n    current_char = '0' if a >= b else '1'\n    s.append(current_char)\n    \n    # Adjust counts\n    if current_char == '0':\n        a -= 1\n    else:\n        b -= 1\n\n    # Fill the string with alternating characters until we reach x transitions\n    for _ in range(x):\n        next_char = '1' if current_char == '0' else '0'\n        s.append(next_char)\n        \n        if next_char == '0':\n            a -= 1\n        else:\n            b -= 1\n        \n        current_char = next_char\n\n    # Fill the remaining characters with the last used character\n    while a > 0 or b > 0:\n        if current_char == '0' and a > 0:\n            s.append('0')\n            a -= 1\n        elif current_char == '1' and b > 0:\n            s.append('1')\n            b -= 1\n        \n        # Switch current_char if we can add the other character\n        if current_char == '0' and b > 0:\n            current_char = '1'\n        elif current_char == '1' and a > 0:\n            current_char = '0'\n\n    return ''.join(s)\n\n# Read input\na, b, x = map(int, input().split())\n# Generate and print the binary string\nprint(construct_binary_string(a, b, x))\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    # Step 1: Initialize the permutation array\n    p = [0] * n\n    \n    # Step 2: Calculate the values of p based on q\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n    \n    # Step 3: Normalize the permutation to start from 1\n    min_value = min(p)\n    offset = 1 - min_value\n    \n    # Step 4: Adjust the permutation values\n    for i in range(n):\n        p[i] += offset\n    \n    # Step 5: Check if the permutation is valid\n    if len(set(p)) == n and all(1 <= x <= n for x in p):\n        print(' '.join(map(str, p)))\n    else:\n        print(-1)\n```",
    "88": "```python\nfrom collections import Counter\n\ndef is_palindromic_matrix_possible(n, numbers):\n    count = Counter(numbers)\n    odd_count = sum(1 for freq in count.values() if freq % 2 != 0)\n    \n    if (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n        return False\n    \n    return True\n\ndef construct_palindromic_matrix(n, numbers):\n    count = Counter(numbers)\n    matrix = [[0] * n for _ in range(n)]\n    \n    half_n = (n + 1) // 2\n    idx = 0\n    \n    for num, freq in count.items():\n        for _ in range(freq // 2):\n            row, col = divmod(idx, n)\n            matrix[row][col] = num\n            matrix[n - 1 - row][n - 1 - col] = num\n            idx += 1\n            \n    if n % 2 == 1:\n        center = n // 2\n        for num, freq in count.items():\n            if freq % 2 == 1:\n                matrix[center][center] = num\n                break\n    \n    return matrix\n\ndef main():\n    n = int(input().strip())\n    numbers = list(map(int, input().strip().split()))\n    \n    if not is_palindromic_matrix_possible(n, numbers):\n        print(\"NO\")\n        return\n    \n    matrix = construct_palindromic_matrix(n, numbers)\n    \n    print(\"YES\")\n    for row in matrix:\n        print(\" \".join(map(str, row)))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "99": "```python\ndef rock_paper_scissors(n, a, b):\n    a_rock, a_scissors, a_paper = a\n    b_rock, b_scissors, b_paper = b\n\n    # Calculate maximum wins for Alice\n    max_wins = min(a_rock, b_scissors) + min(a_scissors, b_paper) + min(a_paper, b_rock)\n\n    # Calculate losses for Alice\n    losses = max(0, b_rock - a_paper) + max(0, b_scissors - a_rock) + max(0, b_paper - a_scissors)\n    min_wins = n - losses\n\n    return min_wins, max_wins\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Get results\nmin_wins, max_wins = rock_paper_scissors(n, a, b)\n\n# Output results\nprint(min_wins, max_wins)\n```",
    "98": "```python\ndef min_moves_to_reach_n(N):\n    min_moves = float('inf')\n    \n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            moves = (i - 1) + (j - 1)\n            min_moves = min(min_moves, moves)\n    \n    return min_moves\n\nN = int(input().strip())\nprint(min_moves_to_reach_n(N))\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Count of each character\n    counts = {'a': n, 'b': n, 'c': n}\n    \n    # Create a list to hold the result\n    res = []\n    \n    # Function to check if adding a character would create a forbidden substring\n    def can_add_char(c):\n        if len(res) >= 1 and res[-1] == c:\n            return False\n        if len(res) >= 1 and res[-1] + c in (s, t):\n            return False\n        return True\n    \n    # Try to build the result string\n    while sum(counts.values()) > 0:\n        for char in 'abc':\n            if counts[char] > 0 and can_add_char(char):\n                res.append(char)\n                counts[char] -= 1\n                break\n        else:\n            # If we went through all characters and couldn't add any, we are stuck\n            return \"NO\"\n    \n    # Join the result list into a string\n    result_string = ''.join(res)\n    \n    # Check if the result contains forbidden substrings\n    if s in result_string or t in result_string:\n        return \"NO\"\n    \n    return \"YES\\n\" + result_string\n\n# Input reading\nn = int(input())\ns = input().strip()\nt = input().strip()\n\n# Generate and print the result\nprint(generate_string(n, s, t))\n```"
}