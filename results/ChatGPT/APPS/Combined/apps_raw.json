{
    "7": "```python\ndef find_empty_day(n, m):\n    day = 0\n    grains = n\n\n    while grains > 0:\n        day += 1\n        grains = min(grains + m, n)  # Add grains brought to the barn, respecting capacity\n        grains -= day  # Sparrows eat grains equal to the day number\n        \n    return day\n\n# Input reading\nn, m = map(int, input().split())\nprint(find_empty_day(n, m))\n```",
    "2": "```python\ndef is_lucky_year(year):\n    \"\"\"Check if a year is lucky based on the number of non-zero digits.\"\"\"\n    non_zero_count = sum(1 for digit in str(year) if digit != '0')\n    return non_zero_count <= 1\n\ndef next_lucky_year(current_year):\n    \"\"\"Find the next lucky year after the current year.\"\"\"\n    next_year = current_year + 1\n    while not is_lucky_year(next_year):\n        next_year += 1\n    return next_year - current_year\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    print(next_lucky_year(n))\n```",
    "1": "```python\ndef max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n    max_sum_number = x\n\n    for i in range(n):\n        if str_x[i] != '0':\n            candidate = list(str_x)\n            candidate[i] = str(int(candidate[i]) - 1)\n            candidate[i+1:] = ['9'] * (n - i - 1)\n            candidate_number = int(''.join(candidate))\n            \n            if candidate_number <= x:\n                max_sum_number = max(max_sum_number, candidate_number)\n\n    return max_sum_number\n\n# Read input\nx = int(input().strip())\n# Output the result\nprint(max_digit_sum(x))\n```",
    "4": "```python\ndef is_lucky_time(hh, mm):\n    \"\"\"Check if the given time contains the digit '7'.\"\"\"\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef time_before(hh, mm, minutes):\n    \"\"\"Calculate the time that is a certain number of minutes before the given time.\"\"\"\n    total_minutes = hh * 60 + mm - minutes\n    if total_minutes < 0:\n        total_minutes += 24 * 60  # Wrap around to the previous day\n    return divmod(total_minutes, 60)\n\ndef min_snooze_presses(x, hh, mm):\n    \"\"\"Determine the minimum number of snooze presses needed to reach a lucky time.\"\"\"\n    presses = 0\n    while not is_lucky_time(hh, mm):\n        presses += 1\n        hh, mm = time_before(hh, mm, x)\n    return presses\n\n# Input reading\nx = int(input().strip())\nhh, mm = map(int, input().strip().split())\n\n# Output the result\nprint(min_snooze_presses(x, hh, mm))\n```",
    "5": "```python\ndef min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0  # No tabs to close\n\n    seconds = 0\n\n    if pos < l:\n        # Move to l and close left tabs, then move to r and close right tabs\n        seconds += (l - pos) + 1 + (r - l) + 1\n    elif pos > r:\n        # Move to r and close right tabs, then move to l and close left tabs\n        seconds += (pos - r) + 1 + (r - l) + 1\n    else:\n        # pos is between l and r\n        if l > 1:\n            seconds += (pos - l) + 1  # Move to l and close left tabs\n        if r < n:\n            seconds += (r - pos) + 1  # Move to r and close right tabs\n\n    return seconds\n\n# Example usage\nn, pos, l, r = map(int, input().split())\nprint(min_seconds_to_close_tabs(n, pos, l, r))\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    # Create a function to calculate the number of painted sections\n    def calculate_painted(painter_indices):\n        painted = [0] * (n + 1)\n        for index in painter_indices:\n            l, r = painters[index]\n            painted[l:r + 1] = [1] * (r - l + 1)  # Mark painted sections\n        return sum(painted)\n\n    max_sections = 0\n    \n    # Iterate over all pairs of painters to remove\n    for i in range(q):\n        for j in range(i + 1, q):\n            painter_indices = [k for k in range(q) if k != i and k != j]\n            max_sections = max(max_sections, calculate_painted(painter_indices))\n\n    return max_sections\n\n# Read input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Get result and print\nresult = max_painted_sections(n, q, painters)\nprint(result)\n```",
    "0": "```python\ndef maxAccordionLength(s: str) -> int:\n    n = len(s)\n    \n    # Find the last occurrence of the opening bracket '['\n    left_bracket_index = s.rfind('[')\n    # Find the first occurrence of the closing bracket ']'\n    right_bracket_index = s.find(']', left_bracket_index)\n    \n    # If there's no valid brackets or they are in the wrong order, return -1\n    if left_bracket_index == -1 or right_bracket_index == -1 or left_bracket_index >= right_bracket_index:\n        return -1\n\n    # Count the number of ':' and '|' between the brackets\n    colon_count = s[left_bracket_index + 1:right_bracket_index].count(':')\n    pipe_count = s[left_bracket_index + 1:right_bracket_index].count('|')\n\n    # There must be at least 2 colons and at least 0 pipes\n    if colon_count < 2:\n        return -1\n\n    # The maximum length is the length of the brackets plus the pipes and colons\n    max_length = (right_bracket_index - left_bracket_index + 1)  # Length of '[::]'\n    return max_length\n\n# Read input and output the result\ns = input().strip()\nprint(maxAccordionLength(s))\n```",
    "10": "```python\ndef calculate_days_off(n):\n    # Constants\n    WORK_DAYS = 5\n    OFF_DAYS = 2\n    WEEK_LENGTH = WORK_DAYS + OFF_DAYS\n    \n    # Complete weeks and remaining days calculation\n    complete_weeks = n // WEEK_LENGTH\n    remaining_days = n % WEEK_LENGTH\n    \n    # Minimum days off based on complete weeks\n    min_days_off = complete_weeks * OFF_DAYS\n    \n    # Maximum days off includes remaining days if they fall within off days\n    max_days_off = min_days_off + min(remaining_days, OFF_DAYS)\n    \n    return min_days_off, max_days_off\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the result\nmin_off, max_off = calculate_days_off(n)\nprint(min_off, max_off)\n```",
    "15": "```python\ndef will_number_appear(a, b, c):\n    if c == 0:\n        return \"YES\" if a == b else \"NO\"\n    \n    difference = b - a\n    if difference % c == 0 and difference // c >= 0:\n        return \"YES\"\n    \n    return \"NO\"\n\n# Read input\na, b, c = map(int, input().split())\n# Output result\nprint(will_number_appear(a, b, c))\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n\n    for query in queries:\n        n, x, blows = query\n        min_blows = float('inf')\n        max_effective_damage = 0\n        \n        for d, h in blows:\n            if d >= x:\n                # If the blow can defeat Zmei in one hit\n                min_blows = 1\n                break\n            \n            effective_damage = d - h\n            if effective_damage > 0:\n                max_effective_damage = max(max_effective_damage, effective_damage)\n\n        if min_blows == 1:\n            results.append(1)\n            continue\n        \n        if max_effective_damage <= 0:\n            results.append(-1)\n            continue\n        \n        blows_needed = (x + max_effective_damage - 1) // max_effective_damage\n        results.append(blows_needed)\n    \n    return results\n\n# Read input\nt = int(input().strip())\nqueries = []\n\nfor _ in range(t):\n    n, x = map(int, input().strip().split())\n    blows = [tuple(map(int, input().strip().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\n# Get results\nresults = min_blows_to_defeat_zmei(t, queries)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    # Calculate the number of tiles painted Red\n    red_tiles = n // a\n    # Calculate the number of tiles painted Blue\n    blue_tiles = n // b\n    # Calculate the number of tiles painted both Red and Blue\n    both_tiles = n // (a * b)\n\n    # Calculate total chocolates for both scenarios\n    total_chocolates_red = (red_tiles - both_tiles) * p + (blue_tiles * q)\n    total_chocolates_blue = (blue_tiles - both_tiles) * q + (red_tiles * p)\n    \n    # Return the maximum of both scenarios\n    return max(total_chocolates_red, total_chocolates_blue)\n\n# Example usage\nif __name__ == \"__main__\":\n    n, a, b, p, q = map(int, input().split())\n    print(max_chocolates(n, a, b, p, q))\n```",
    "8": "```python\ndef minimum_draws(tiles):\n    # Count occurrences of tiles using a dictionary\n    counts = {}\n    for tile in tiles:\n        num = int(tile[0])\n        suit = tile[1]\n        counts[(num, suit)] = counts.get((num, suit), 0) + 1\n    \n    # Check for koutsu (triplet)\n    if any(count >= 3 for count in counts.values()):\n        return 0  # No draws needed if we have a triplet\n    \n    # Organize tiles by suit\n    suits = {'m': [], 'p': [], 's': []}\n    for (num, suit), count in counts.items():\n        suits[suit].append(num)\n    \n    # Check for shuntsu (sequences) in each suit\n    for suit, numbers in suits.items():\n        numbers.sort()\n        n = len(numbers)\n        \n        # Check for existing shuntsu\n        for i in range(n - 2):\n            if numbers[i + 2] - numbers[i] == 2 and numbers[i + 1] - numbers[i] == 1:\n                return 0  # No draws needed if we have a sequence\n\n        # Check for draws needed to form a shuntsu\n        for number in numbers:\n            needed_tiles = [(number - 1, suit), (number + 1, suit)]\n            if all(tile not in counts for tile in needed_tiles):\n                return 2  # Need 2 draws\n            elif any(tile not in counts for tile in needed_tiles):\n                return 1  # Need 1 draw\n\n    return 2  # If no koutsu or shuntsu can be formed, need 2 draws\n\n# Read input\ntiles = input().strip().split()\n# Get the result and print\nresult = minimum_draws(tiles)\nprint(result)\n```",
    "17": "```python\ndef mexican_wave(n, k, t):\n    if t <= k:\n        return t\n    elif t <= n:\n        return k\n    else:  # t > n\n        return n + k - t\n\n# Read input values\nn, k, t = map(int, input().split())\n# Print the result\nprint(mexican_wave(n, k, t))\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    segments = []\n    current_length = 0\n\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n            \n    if current_length > 0:\n        segments.append(current_length)\n\n    if not segments:\n        return 0\n    \n    max_beauty = max(segments)\n\n    if len(segments) == 1:\n        return max_beauty\n\n    for i in range(len(segments) - 1):\n        potential_beauty = segments[i] + segments[i + 1]\n        max_beauty = max(max_beauty, potential_beauty)\n\n    return max_beauty\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\n\n# Get the result and print it\nprint(max_beauty_after_swap(n, trophies))\n```",
    "16": "```python\ndef can_form_regular_bracket_sequence(cnt1, cnt2, cnt3, cnt4):\n    # Calculate total counts of opening and closing brackets\n    opening_brackets = cnt1 + cnt2  # Total opening brackets\n    closing_brackets = cnt2 + cnt4   # Total closing brackets\n\n    # Check the balance of brackets\n    if opening_brackets < closing_brackets:\n        return 0\n\n    # Check if we can maintain balance during the sequence\n    if cnt1 > cnt4 + cnt2:\n        return 0\n\n    return 1\n\n# Read input\ncnt1 = int(input().strip())\ncnt2 = int(input().strip())\ncnt3 = int(input().strip())\ncnt4 = int(input().strip())\n\n# Output the result\nprint(can_form_regular_bracket_sequence(cnt1, cnt2, cnt3, cnt4))\n```",
    "9": "```python\ndef find_grandpa_sofa(d, n, m, sofas, conditions):\n    cnt_l, cnt_r, cnt_t, cnt_b = conditions\n    sofa_positions = []\n\n    # Store the normalized positions of each sofa\n    for x1, y1, x2, y2 in sofas:\n        sofa_positions.append((min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)))\n\n    # Function to count the sofas in certain directions\n    def count_sofas(sofa_index):\n        x1, y1, x2, y2 = sofa_positions[sofa_index]\n        left_count = right_count = top_count = bottom_count = 0\n        \n        for j, (sx1, sy1, sx2, sy2) in enumerate(sofa_positions):\n            if j == sofa_index:\n                continue\n            \n            # Count left, right, top, and bottom\n            if sx2 < x1:\n                left_count += 1\n            elif sx1 > x2:\n                right_count += 1\n            \n            if sy2 < y1:\n                top_count += 1\n            elif sy1 > y2:\n                bottom_count += 1\n\n        return left_count, right_count, top_count, bottom_count\n\n    # Find the sofa that matches the conditions\n    for i in range(d):\n        left_count, right_count, top_count, bottom_count = count_sofas(i)\n        if (left_count == cnt_l and \n            right_count == cnt_r and \n            top_count == cnt_t and \n            bottom_count == cnt_b):\n            return i + 1  # Return 1-based index\n\n    return -1\n\n# Input reading\nd = int(input())\nn, m = map(int, input().split())\nsofas = [tuple(map(int, input().split())) for _ in range(d)]\nconditions = tuple(map(int, input().split()))\n\n# Find and print the result\nresult = find_grandpa_sofa(d, n, m, sofas, conditions)\nprint(result)\n```",
    "14": "```python\ndef is_stack_sortable(n, k, p):\n    stack = []\n    b = []\n    remaining = set(range(1, n + 1)) - set(p)\n\n    # Initialize the result array with the given first k elements\n    result = list(p)\n\n    # Process the given elements\n    for i in range(k):\n        while stack and (not remaining or stack[-1] > max(remaining)):\n            b.append(stack.pop())\n        stack.append(p[i])\n\n    # Add remaining elements to the stack in descending order\n    for next_elem in sorted(remaining, reverse=True):\n        while stack and (not remaining or stack[-1] > max(remaining)):\n            b.append(stack.pop())\n        stack.append(next_elem)\n\n    # Empty the stack into b\n    while stack:\n        b.append(stack.pop())\n\n    # Check if b is sorted\n    if b != sorted(b):\n        return -1\n\n    # Fill the result array with b\n    result.extend(b)\n    return result\n\n# Input reading\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result\nresult = is_stack_sortable(n, k, p)\n\n# Output the result\nif result == -1:\n    print(result)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "18": "```python\ndef lexicographically_minimal_string(s: str) -> str:\n    t = []  # Stack to hold characters from s\n    u = []  # Result string as a list of characters\n    s = list(s)  # Convert string to a list for efficient operations\n\n    while s or t:\n        # While there are characters in s, we compare and move characters\n        while s and (not t or s[0] <= t[-1]):\n            t.append(s.pop(0))  # Move character from s to t\n\n        if t:\n            u.append(t.pop())  # Move character from t to u\n\n    return ''.join(u)  # Join list u into a string and return\n\n# Input and output handling\nif __name__ == \"__main__\":\n    s = input().strip()\n    result = lexicographically_minimal_string(s)\n    print(result)\n```",
    "20": "```python\ndef is_palindrome(time_str):\n    return time_str == time_str[::-1]\n\ndef increment_time(hh, mm):\n    mm += 1\n    if mm == 60:\n        mm = 0\n        hh += 1\n        if hh == 24:\n            hh = 0\n    return hh, mm\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        hh, mm = increment_time(hh, mm)\n        minutes_passed += 1\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return minutes_passed\n\ndef main():\n    current_time = input().strip()\n    hh, mm = map(int, current_time.split(':'))\n    result = next_palindrome_time(hh, mm)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a: int, b: int) -> int:\n    from itertools import permutations\n\n    str_a = str(a)\n    str_b = str(b)\n\n    # Generate all unique permutations of the digits of a\n    unique_permutations = sorted(set(permutations(str_a)), reverse=True)\n\n    for p in unique_permutations:\n        candidate = int(''.join(p))\n        # Check if the candidate is less than or equal to b and has the same length as a\n        if candidate <= b and len(str(candidate)) == len(str_a):\n            return candidate\n\n# Input reading\na = int(input().strip())\nb = int(input().strip())\n\n# Function call and output\nprint(max_permutation_not_exceeding(a, b))\n```",
    "13": "```python\nfrom collections import defaultdict, deque\nimport sys\n\ndef find_course_order(n, k, main_courses, dependencies):\n    graph = defaultdict(list)\n    indegree = [0] * (n + 1)\n\n    # Build the graph and calculate indegrees\n    for course in range(1, n + 1):\n        for dep in dependencies[course - 1]:\n            graph[dep].append(course)\n            indegree[course] += 1\n\n    # Initialize queue with courses that have no prerequisites\n    queue = deque(course for course in range(1, n + 1) if indegree[course] == 0)\n    \n    course_order = []\n    \n    while queue:\n        current = queue.popleft()\n        course_order.append(current)\n        \n        for neighbor in graph[current]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n\n    # Check if all main courses can be completed\n    required_courses = set(main_courses)\n    taken_courses = set(course_order)\n\n    if not required_courses.issubset(taken_courses):\n        return -1\n\n    # Gather the courses that need to be taken\n    result_order = []\n    for course in course_order:\n        if course in required_courses or any(dep in taken_courses for dep in dependencies[course - 1]):\n            result_order.append(course)\n\n    return len(result_order), result_order\n\n# Read input\ninput = sys.stdin.read\ndata = input().splitlines()\nn, k = map(int, data[0].split())\nmain_courses = list(map(int, data[1].split()))\ndependencies = [list(map(int, line.split()[1:])) for line in data[2:2 + n]]\n\n# Get the result\nresult = find_course_order(n, k, main_courses, dependencies)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    m, order = result\n    print(m)\n    print(' '.join(map(str, order)))\n```",
    "22": "```python\ndef is_s_palindrome(s: str) -> str:\n    # Define a mapping for reflective symmetry\n    reflection_map = {\n        'A': 'A', 'H': 'H', 'I': 'I', 'M': 'M', 'O': 'O', \n        'T': 'T', 'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X', \n        'Y': 'Y', 'o': 'o', 'v': 'v', 'w': 'w', 'x': 'x'\n    }\n    \n    n = len(s)\n    # Check each character in the first half of the string\n    for i in range((n + 1) // 2):\n        left_char = s[i]\n        right_char = s[n - 1 - i]\n        \n        # Verify if characters reflect correctly\n        if reflection_map.get(left_char) != right_char:\n            return \"NIE\"\n    \n    return \"TAK\"\n\n# Read input\ns = input().strip()\n# Print output\nprint(is_s_palindrome(s))\n```",
    "19": "```python\ndef is_stats_correct(test_cases):\n    results = []\n    \n    for n, records in test_cases:\n        is_correct = True\n        prev_plays, prev_clears = 0, 0\n        \n        for plays, clears in records:\n            if plays < prev_plays or clears < prev_clears or clears > plays:\n                is_correct = False\n                break\n            \n            # Calculate differences\n            plays_diff = plays - prev_plays\n            clears_diff = clears - prev_clears\n            \n            if clears_diff > plays_diff:\n                is_correct = False\n                break\n            \n            prev_plays, prev_clears = plays, clears\n        \n        results.append(\"YES\" if is_correct else \"NO\")\n    \n    return results\n\n# Input reading\nT = int(input())\ntest_cases = []\n\nfor _ in range(T):\n    n = int(input())\n    records = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, records))\n\n# Get results\nresults = is_stats_correct(test_cases)\n\n# Output results\nprint(\"\\n\".join(results))\n```",
    "21": "```python\ndef max_distance_after_swap(n, a):\n    # Find the positions of the minimum (1) and maximum (n) elements\n    min_index = a.index(1)\n    max_index = a.index(n)\n    \n    # Calculate the current distance\n    current_distance = abs(min_index - max_index)\n    \n    # Calculate potential new distances by swapping min and max with ends of the array\n    distance_min_to_left = abs(0 - max_index)  # Swap min (1) with the leftmost element\n    distance_min_to_right = abs(n - 1 - max_index)  # Swap min (1) with the rightmost element\n    distance_max_to_left = abs(0 - min_index)  # Swap max (n) with the leftmost element\n    distance_max_to_right = abs(n - 1 - min_index)  # Swap max (n) with the rightmost element\n    \n    # Calculate the maximum possible distance\n    max_distance = max(current_distance, distance_min_to_left, distance_min_to_right,\n                       distance_max_to_left, distance_max_to_right)\n    \n    return max_distance\n\n# Input handling\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_distance_after_swap(n, a))\n```",
    "27": "```python\ndef min_operations(n, s):\n    # Initialize minimum operations to the length of the string (typing all characters)\n    min_ops = n\n    \n    # Check for possible prefixes that can be doubled\n    for i in range(1, n // 2 + 1):\n        if s[:i] == s[i:2 * i]:\n            # Calculate operations: typing the prefix + 1 for copy + remaining characters\n            min_ops = min(min_ops, i + 1 + (n - 2 * i))\n    \n    return min_ops\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(min_operations(n, s))\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # Since GCD(x, m) = 1, the x-mouse will visit all unique rooms before returning to the start.\n    # Therefore, to catch the mouse, we need traps in all but one room.\n    return m - 1\n\n# Read input\nm, x = map(int, input().strip().split())\n# Output result\nprint(minimum_traps(m, x))\n```",
    "24": "```python\ndef can_alice_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # right, down, diagonal down-right, diagonal down-left\n    n = 10\n\n    def count_consecutive_xs(x, y, dx, dy):\n        count = 0\n        while 0 <= x < n and 0 <= y < n and board[x][y] == 'X':\n            count += 1\n            x += dx\n            y += dy\n        return count\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                board[i][j] = 'X'  # Temporarily place an 'X'\n                \n                for dx, dy in directions:\n                    # Count in both directions\n                    total_count = 1  # Starting with the placed 'X'\n                    total_count += count_consecutive_xs(i + dx, j + dy, dx, dy)  # Positive direction\n                    total_count += count_consecutive_xs(i - dx, j - dy, -dx, -dy)  # Negative direction\n                    \n                    if total_count >= 5:\n                        return \"YES\"\n                \n                board[i][j] = '.'  # Remove the temporary 'X'\n\n    return \"NO\"\n\n# Read the input\nboard = [list(input().strip()) for _ in range(10)]\nprint(can_alice_win(board))\n```",
    "26": "```python\ndef calculate_expressions(x, y, z):\n    # Define the expressions and their corresponding string representations\n    expressions = [\n        (x**(y**z), \"x^y^z\"),\n        (x**(z**y), \"x^z^y\"),\n        ((x**y)**z, \"(x^y)^z\"),\n        ((x**z)**y, \"(x^z)^y\"),\n        (y**(x**z), \"y^x^z\"),\n        (y**(z**x), \"y^z^x\"),\n        ((y**x)**z, \"(y^x)^z\"),\n        ((y**z)**x, \"(y^z)^x\"),\n        (z**(x**y), \"z^x^y\"),\n        (z**(y**x), \"z^y^x\"),\n        ((z**x)**y, \"(z^x)^y\"),\n        ((z**y)**x, \"(z^y)^x\"),\n    ]\n    \n    # Find the maximum value and the corresponding expression with the smallest index\n    max_value_index = max(range(len(expressions)), key=lambda i: expressions[i][0])\n    return expressions[max_value_index][1]\n\n# Read input\ninput_values = input().strip().split()\nx = float(input_values[0])\ny = float(input_values[1])\nz = float(input_values[2])\n\n# Calculate and print the result\nresult_expression = calculate_expressions(x, y, z)\nprint(result_expression)\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    # Check for impossible cases\n    if k > n * n or (k % 2 == 1 and n % 2 == 1 and k > n * (n // 2 + 1)):\n        return -1\n\n    # Initialize an n x n matrix filled with zeros\n    matrix = [[0] * n for _ in range(n)]\n\n    # Fill the matrix to make it symmetric and lexicographically maximal\n    for i in range(n):\n        if k <= 0:\n            break\n        \n        # Fill the diagonal\n        if k > 0:\n            matrix[i][i] = 1\n            k -= 1\n        \n        # Fill the symmetric pairs\n        for j in range(i + 1, n):\n            if k >= 2:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n            \n            if k <= 0:\n                break\n\n    # If there are leftover ones that couldn't be placed, return -1\n    return -1 if k > 0 else matrix\n\n# Read input\nn, k = map(int, input().split())\n\n# Get the symmetric matrix\nresult = create_symmetric_matrix(n, k)\n\n# Output the result\nif result == -1:\n    print(result)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "29": "```python\ndef min_replacements_to_lucky_ticket(ticket: str) -> int:\n    # Calculate the sums of the first and last three digits\n    first_half_sum = sum(int(ticket[i]) for i in range(3))\n    second_half_sum = sum(int(ticket[i]) for i in range(3, 6))\n    \n    # Calculate the difference between the two halves\n    difference = abs(first_half_sum - second_half_sum)\n    \n    # If the ticket is already lucky\n    if difference == 0:\n        return 0\n    \n    # Get the maximum adjustments possible from each half\n    first_half_adjustments = sorted(9 - int(ticket[i]) for i in range(3))\n    second_half_adjustments = sorted(int(ticket[i]) for i in range(3, 6))\n    \n    # Combine adjustments and sort in descending order\n    all_adjustments = sorted(first_half_adjustments + second_half_adjustments, reverse=True)\n    \n    # Try to minimize the number of replacements\n    replacements = 0\n    for adjustment in all_adjustments:\n        difference -= adjustment\n        replacements += 1\n        if difference <= 0:\n            return replacements\n            \n    return replacements  # In case we didn't reach zero\n\n# Example usage\nif __name__ == \"__main__\":\n    ticket = input().strip()\n    print(min_replacements_to_lucky_ticket(ticket))\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    def can_distribute(x):\n        plates_from_a = a // x\n        plates_from_b = b // x\n        return plates_from_a + plates_from_b >= n\n    \n    left, right = 1, max(a, b)\n    max_x = 0\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if can_distribute(mid):\n            max_x = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n            \n    return max_x\n\n# Input reading\nn, a, b = map(int, input().split())\nprint(max_min_pieces(n, a, b))\n```",
    "28": "```python\ndef rename_files(n, files):\n    examples = []\n    regulars = []\n\n    # Split files into examples and regular tests\n    for name, type_ in files:\n        if type_ == '1':\n            examples.append(name)\n        else:\n            regulars.append(name)\n\n    # Prepare the result\n    moves = []\n    \n    # Rename examples to 1, 2, ..., e\n    for i, example_name in enumerate(examples):\n        new_name = str(i + 1)\n        moves.append(f\"move {example_name} {new_name}\")\n\n    # Rename regular tests to e + 1, e + 2, ..., n\n    e = len(examples)\n    for i, regular_name in enumerate(regulars):\n        new_name = str(e + i + 1)\n        current_name = regular_name if i == 0 else str(e + i)\n        moves.append(f\"move {current_name} {new_name}\")\n\n    # Output results\n    print(len(moves))\n    print(\"\\n\".join(moves))\n\n# Read input\nn = int(input().strip())\nfiles = [input().strip().split() for _ in range(n)]\n\nrename_files(n, files)\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef birthday_paradox(n, k):\n    MOD = 1000003\n    days = 1 << n  # 2^n days\n    if k > days:\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the probability of no shared birthdays\n    no_shared_birthdays = 1\n    for i in range(k):\n        no_shared_birthdays *= (days - i)\n        no_shared_birthdays //= (i + 1)\n\n    # Total outcomes\n    total_outcomes = pow(days, k, MOD)\n\n    # Probability of at least one shared birthday\n    A = (total_outcomes - no_shared_birthdays) % MOD\n    B = total_outcomes\n\n    # Reduce A and B to their irreducible forms\n    g = gcd(A, B)\n    A //= g\n    B //= g\n    \n    # Ensure A and B are within bounds after reduction\n    A %= MOD\n    B %= MOD\n    \n    return A, B\n\n# Input\nn, k = map(int, input().split())\nresult = birthday_paradox(n, k)\nprint(result[0], result[1])\n```",
    "32": "```python\ndef is_valid_journey(n, journey):\n    current_position = 0  # Represents the distance from the North Pole (0 to 20000)\n    \n    for distance, direction in journey:\n        if current_position == 0 and direction != \"South\":\n            return \"NO\"  # Cannot move from North Pole except South\n        if current_position == 20000 and direction != \"North\":\n            return \"NO\"  # Cannot move from South Pole except North\n        \n        if direction == \"South\":\n            current_position += distance\n        elif direction == \"North\":\n            current_position -= distance\n        # Directions West and East do not affect the North-South position\n        elif direction in [\"West\", \"East\"]:\n            continue\n        \n        # Ensure we don't go past the poles\n        if current_position < 0 or current_position > 20000:\n            return \"NO\"\n    \n    # Journey must end at the North Pole\n    return \"YES\" if current_position == 0 else \"NO\"\n\n# Read input\nn = int(input().strip())\njourney = [tuple(input().strip().split()) for _ in range(n)]\njourney = [(int(distance), direction) for distance, direction in journey]\n\n# Output result\nprint(is_valid_journey(n, journey))\n```",
    "35": "```python\ndef is_valid_flag(n, m, field):\n    if n % 3 != 0:\n        return \"NO\"\n    \n    stripe_height = n // 3\n    colors = set()\n\n    for i in range(3):\n        stripe_color = field[i * stripe_height][0]\n        colors.add(stripe_color)\n        \n        for j in range(stripe_height):\n            if field[i * stripe_height + j] != stripe_color * m:\n                return \"NO\"\n\n    return \"YES\" if len(colors) == 3 else \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Output result\nprint(is_valid_flag(n, m, field))\n```",
    "37": "```python\ndef can_deal_exact_damage(a, b, c):\n    # Iterate through the possible number of shots from gun Ebony\n    for shots_from_ebony in range(c // a + 1):\n        remaining_damage = c - a * shots_from_ebony\n        # Check if the remaining damage can be exactly dealt with gun Ivory\n        if remaining_damage >= 0 and remaining_damage % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Read input\na, b, c = map(int, input().split())\n# Call the function and print the result\nprint(can_deal_exact_damage(a, b, c))\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n    \n    len_s = len(s)\n    total_count = 0\n    seen_strings = set()\n    \n    # Generate all binary strings of length n\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        \n        # Check if s is a substring of any cyclic shift of t\n        if any(s in t[i:] + t[:i] for i in range(n)):\n            seen_strings.add(t)\n\n    return len(seen_strings)\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_cyclic_strings(n, s))\n```",
    "33": "```python\ndef count_common_terms(a1, b1, a2, b2, L, R):\n    def count_terms(a, b, start, end):\n        if a == 0:\n            return 1 if start <= b <= end else 0\n        \n        # Calculate the first term in the range\n        first_term = max(b, start + (a - (start - b) % a) % a)\n        # Calculate the last term in the range\n        last_term = min(end, b + ((end - b) // a) * a)\n        \n        if first_term > last_term:\n            return 0\n        \n        return (last_term - first_term) // a + 1\n    \n    count1 = count_terms(a1, b1, L, R)\n    count2 = count_terms(a2, b2, L, R)\n\n    count_common = 0\n    \n    for k in range(count1):\n        x = a1 * k + b1\n        if L <= x <= R:\n            # Check if x can be represented in the second progression\n            if (x - b2) % a2 == 0 and (x - b2) // a2 >= 0:\n                count_common += 1\n\n    return count_common\n\n# Input reading\na1, b1, a2, b2, L, R = map(int, input().split())\n# Output the result\nprint(count_common_terms(a1, b1, a2, b2, L, R))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    \n    # If the entire string is not a palindrome, return its length\n    if not is_palindrome(s):\n        return n\n    \n    # Check if all characters in the string are the same\n    if s.count(s[0]) == n:\n        return 0\n    \n    # If the entire string is a palindrome, return n-1\n    return n - 1\n\n# Input\ns = input().strip()\n# Output\nprint(longest_non_palindrome_substring(s))\n```",
    "40": "```python\ndef determine_round_status(n, ratings):\n    # Check if any rating has changed\n    rated = any(before != after for before, after in ratings)\n    \n    # Check if standings are in non-increasing order based on the initial ratings\n    unrated = any(ratings[i][0] < ratings[i + 1][0] for i in range(n - 1))\n\n    if rated:\n        return \"rated\"\n    elif unrated:\n        return \"unrated\"\n    else:\n        return \"maybe\"\n\n# Input reading\nn = int(input().strip())\nratings = [tuple(map(int, input().strip().split())) for _ in range(n)]\n\n# Determine and print the result\nresult = determine_round_status(n, ratings)\nprint(result)\n```",
    "38": "```python\ndef can_coincide_tracks(n, L, kefa_distances, sasha_distances):\n    def calculate_distances(distances):\n        return [(distances[i] - distances[i - 1]) % L for i in range(1, n)] + [(distances[0] + L - distances[-1]) % L]\n\n    kefa_diffs = calculate_distances(kefa_distances)\n    sasha_diffs = calculate_distances(sasha_distances)\n\n    # Check if any rotation of Kefa's distances matches Sasha's distances\n    # We can use string manipulation for easier rotation comparison\n    kefa_str = ' '.join(map(str, kefa_diffs))\n    sasha_str = ' '.join(map(str, sasha_diffs * 2))  # double the Sasha's distances for rotation\n\n    return \"YES\" if kefa_str in sasha_str else \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_coincide_tracks(n, L, kefa_distances, sasha_distances))\n```",
    "36": "```python\ndef hexagon_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    # Determine the layer of the hexagonal spiral\n    layer = 0\n    moves_in_layer = 1\n\n    while n >= moves_in_layer:\n        n -= moves_in_layer\n        layer += 1\n        moves_in_layer = 6 * layer\n\n    # Calculate the position in the current layer\n    x, y = layer, 0\n\n    if n == 0:\n        return (x, y)\n\n    # Each segment has 'layer' moves\n    segment = n // layer\n    position_in_segment = n % layer\n\n    # Move to the corresponding direction based on segment\n    if segment == 0:  # First segment\n        x += position_in_segment\n    elif segment == 1:  # Second segment\n        x -= position_in_segment\n        y += position_in_segment\n    elif segment == 2:  # Third segment\n        x -= position_in_segment\n        y -= position_in_segment\n    elif segment == 3:  # Fourth segment\n        x -= position_in_segment\n        y += position_in_segment\n    elif segment == 4:  # Fifth segment\n        x += position_in_segment\n        y -= position_in_segment\n    elif segment == 5:  # Sixth segment\n        x += position_in_segment\n\n    return (x, y)\n\n# Read input\nn = int(input().strip())\n# Get coordinates\nresult = hexagon_coordinates(n)\n# Print result\nprint(result[0], result[1])\n```",
    "41": "```python\ndef nearest_zero_distance(n, array):\n    distances = [float('inf')] * n\n    last_zero_position = -1\n\n    # First pass: from left to right\n    for i in range(n):\n        if array[i] == 0:\n            last_zero_position = i\n            distances[i] = 0\n        elif last_zero_position != -1:\n            distances[i] = i - last_zero_position\n\n    # Second pass: from right to left\n    for i in range(n - 1, -1, -1):\n        if array[i] == 0:\n            last_zero_position = i\n        elif last_zero_position != -1:\n            distances[i] = min(distances[i], last_zero_position - i)\n\n    return distances\n\n# Reading input\nn = int(input().strip())\narray = list(map(int, input().strip().split()))\n\n# Getting distances and printing the result\nresult = nearest_zero_distance(n, array)\nprint(\" \".join(map(str, result)))\n```",
    "44": "```python\ndef minimal_time_to_post_office(d, k, a, b, t):\n    # Calculate total time if walking the entire distance\n    walking_time = d * b\n    \n    # If driving is quicker than walking, calculate the mixed strategy\n    if a * k + t < b:\n        # Full segments of k that can be driven\n        full_segments = d // k\n        remaining_distance = d % k\n        \n        # Calculate driving time for full segments\n        driving_time = full_segments * (k * a + t)\n        \n        # If there are full segments, subtract the last repair time\n        if full_segments > 0:\n            driving_time -= t\n            \n        # Add time for the remaining distance driven\n        driving_time += remaining_distance * a\n        \n        # Return the minimum of walking time and driving time\n        return min(driving_time, walking_time)\n\n    # If driving is not quicker, just walk\n    return walking_time\n\n# Input reading\nd, k, a, b, t = map(int, input().split())\nprint(minimal_time_to_post_office(d, k, a, b, t))\n```",
    "43": "```python\nimport sys\nimport math\n\ndef main():\n    input_data = sys.stdin.read().strip().splitlines()\n    n = int(input_data[0])\n    vectors = []\n\n    for i in range(1, n + 1):\n        x, y = map(int, input_data[i].split())\n        angle = math.atan2(y, x)\n        vectors.append((angle, i))\n\n    # Sort vectors by angle\n    vectors.sort()\n\n    min_angle = float('inf')\n    answer = (0, 0)\n\n    # Check the minimal angle between consecutive vectors\n    for i in range(n):\n        current_angle = vectors[i][0]\n        next_angle = vectors[(i + 1) % n][0]\n        \n        # Calculate the angle difference\n        angle_diff = (next_angle - current_angle) % (2 * math.pi)\n        if angle_diff > math.pi:\n            angle_diff = 2 * math.pi - angle_diff\n\n        if angle_diff < min_angle:\n            min_angle = angle_diff\n            answer = (vectors[i][1], vectors[(i + 1) % n][1])\n\n    print(answer[0], answer[1])\n\nif __name__ == \"__main__\":\n    main()\n```",
    "48": "```python\ndef kth_largest_in_multiplication_table(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(x // i, m)\n        return count\n\n    left, right = 1, n * m\n    while left < right:\n        mid = (left + right) // 2\n        if count_less_equal(mid) < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Read input\nn, m, k = map(int, input().split())\n# Output the k-th largest number\nprint(kth_largest_in_multiplication_table(n, m, k))\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # The minimum sum of the first k positive integers\n    min_required_sum = k * (k + 1) // 2\n    \n    # If n is less than the minimum required sum, return -1\n    if n < min_required_sum:\n        return -1\n\n    # Calculate the maximum GCD we can start with\n    max_gcd = n // k\n    \n    # Adjust the GCD downwards until the sequence is valid\n    while True:\n        # Calculate the sum of the sequence with the current GCD\n        sum_sequence = max_gcd * min_required_sum\n        \n        if sum_sequence <= n:\n            # Create the sequence with the current GCD\n            sequence = [max_gcd * i for i in range(1, k + 1)]\n            sequence[-1] += (n - sum_sequence)  # Adjust the last element\n            return sequence\n        max_gcd -= 1  # Decrease GCD if the sum exceeds n\n\n# Read input\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\n# Print output\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "46": "```python\ndef count_divisible_pairs(n, m):\n    # Count occurrences of each remainder when divided by 5\n    count_x = [0] * 5\n    count_y = [0] * 5\n    \n    # Count remainders for numbers from 1 to n\n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n    \n    # Count remainders for numbers from 1 to m\n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n    \n    # Calculate the number of valid pairs\n    total_pairs = 0\n    for i in range(5):\n        total_pairs += count_x[i] * count_y[(5 - i) % 5]\n    \n    return total_pairs\n\n# Read input\nn, m = map(int, input().split())\n# Output the result\nprint(count_divisible_pairs(n, m))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    length = 1  # The current digit length (1 for 1-9, 2 for 10-99, etc.)\n    count = 9   # The count of numbers with the current digit length\n    start = 1   # The starting number with the current digit length\n\n    # Determine the range in which the k-th digit falls\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    # Find the actual number that contains the k-th digit\n    start += (k - 1) // length\n    number_str = str(start)\n    \n    # Find the specific digit in that number\n    return number_str[(k - 1) % length]\n\nif __name__ == \"__main__\":\n    # Read input\n    k = int(input().strip())\n    # Print the k-th digit\n    print(find_kth_digit(k))\n```",
    "54": "```python\ndef minimum_d(n, a):\n    min_a = min(a)\n    max_a = max(a)\n\n    # If all elements are equal, return 0\n    if min_a == max_a:\n        return 0\n\n    # Calculate the difference\n    diff = max_a - min_a\n\n    # If the difference is odd, it's impossible to make all elements equal\n    if diff % 2 != 0:\n        return -1\n\n    # Return the minimum D\n    return diff // 2\n\n# Read input\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Print the result\nprint(minimum_d(n, a))\n```",
    "47": "```python\ndef max_beauty_with_subarray(n, x, a):\n    def kadane(arr):\n        max_ending_here = max_so_far = 0\n        for value in arr:\n            max_ending_here = max(0, max_ending_here + value)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    original_beauty = kadane(a)\n    max_increase = 0\n    current_sum = 0\n\n    for value in a:\n        current_sum = max(current_sum + value * x, value * x)\n        max_increase = max(max_increase, current_sum)\n\n    return max(original_beauty, original_beauty + max_increase)\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_beauty_with_subarray(n, x, a))\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = -1\n    moves = []\n\n    while left <= right:\n        if a[left] > last_taken and (a[right] <= last_taken or a[left] < a[right]):\n            last_taken = a[left]\n            moves.append('L')\n            left += 1\n        elif a[right] > last_taken:\n            last_taken = a[right]\n            moves.append('R')\n            right -= 1\n        else:\n            break\n\n    return len(moves), ''.join(moves)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = list(map(int, input().split()))\n    length, sequence = longest_increasing_sequence(n, a)\n    print(length)\n    print(sequence)\n```",
    "51": "```python\ndef find_x_and_y(divisors):\n    from collections import Counter\n    import math\n\n    # Count occurrences of each divisor\n    divisor_count = Counter(divisors)\n\n    # Find the largest divisor, which will be one of the numbers (either x or y)\n    max_divisor = max(divisor_count)\n\n    # Calculate the product of all divisors\n    product_of_divisors = 1\n    for divisor, count in divisor_count.items():\n        product_of_divisors *= divisor ** count\n\n    # Calculate the other number using the product\n    other_number = product_of_divisors // max_divisor\n\n    return max_divisor, other_number\n\n# Input reading\nn = int(input().strip())\ndivisors = list(map(int, input().strip().split()))\n\n# Finding x and y\nx, y = find_x_and_y(divisors)\n\n# Output the result\nprint(x, y)\n```",
    "56": "```python\ndef f(x):\n    \"\"\"Applies the function f to the input x: increments x by 1 and removes trailing zeros.\"\"\"\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef count_reachable_numbers(n):\n    \"\"\"Counts how many different numbers are reachable from n using the function f.\"\"\"\n    reachable = set()\n    current = n\n    \n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    \n    return len(reachable)\n\nif __name__ == \"__main__\":\n    n = int(input(\"Enter a number: \"))\n    print(count_reachable_numbers(n))\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_elements_to_choose = m // 2\n    dp = [[-1] * k for _ in range(n + 1)]\n    dp[0][0] = 0  # Base case: sum of 0 is achievable with 0 elements\n\n    for i in range(1, n + 1):\n        row = sorted(matrix[i - 1], reverse=True)[:max_elements_to_choose]\n        current_sums = [0]  # Start with the sum of 0 (choosing no elements)\n\n        # Calculate all possible sums for the current row\n        for j in range(1, len(row) + 1):\n            current_sums.append(current_sums[-1] + row[j - 1])\n\n        # Update dp for the current row\n        for j in range(k):\n            if dp[i - 1][j] != -1:  # Previous state is valid\n                dp[i][j] = max(dp[i][j], dp[i - 1][j])  # Carry forward previous sums\n                \n                # Try to add combinations of elements from the current row\n                for s in current_sums:\n                    new_sum = dp[i - 1][j] + s\n                    new_mod = new_sum % k\n                    dp[i][new_mod] = max(dp[i][new_mod], new_sum)\n\n    return max(dp[n])\n\n# Input reading\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\nresult = max_sum_divisible_by_k(n, m, k, matrix)\nprint(result)\n```",
    "57": "```python\ndef assign_gifts(n, f):\n    result = f[:]  # Create a copy of the input list to store results\n    givers = set(range(1, n + 1)) - set(f)  # Friends who want to give gifts (0 in f)\n    receivers = [i + 1 for i in range(n) if result[i] == 0]  # Friends who need to assign gifts\n\n    # Assign gifts to receivers\n    for receiver in receivers:\n        # Find a giver that is not the same as the receiver\n        for giver in givers:\n            if giver != receiver:\n                result[receiver - 1] = giver  # Assign the gift\n                givers.remove(giver)  # Remove the assigned giver from the pool\n                break\n\n    return result\n\n# Example of usage\nn = int(input())\nf = list(map(int, input().split()))\nresult = assign_gifts(n, f)\nprint(' '.join(map(str, result)))\n```",
    "59": "```python\ndef min_operations_to_modulo(n, x, y, number):\n    # Define the target pattern based on y and x\n    target_pattern = ['0'] * x\n    target_pattern[y] = '1'  # Set the y-th digit from the right to '1'\n    \n    # Count the number of operations needed to match the target pattern\n    operations = sum(1 for i in range(x) if number[n - 1 - i] != target_pattern[x - 1 - i])\n    \n    return operations\n\n# Read input\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# Output the result\nprint(min_operations_to_modulo(n, x, y, number))\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, tree, n):\n    visited = [-1] * (n + 1)\n    queue = deque([start])\n    visited[start] = 0\n    farthest_node = start\n\n    while queue:\n        node = queue.popleft()\n        for neighbor in tree[node]:\n            if visited[neighbor] == -1:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > visited[farthest_node]:\n                    farthest_node = neighbor\n\n    return farthest_node, visited\n\ndef maximum_edges_in_paths(n, edges):\n    # Build the tree as an adjacency list\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    # Find farthest nodes using BFS\n    farthest_from_start, _ = bfs(1, tree, n)\n    farthest_from_a, distances_from_a = bfs(farthest_from_start, tree, n)\n    farthest_from_b, distances_from_b = bfs(farthest_from_a, tree, n)\n\n    # Maximum edges in paths are calculated as the distance between these two farthest nodes\n    max_edges = distances_from_a[farthest_from_b]\n\n    # Collect three distinct vertices a, b, c\n    vertex_a = farthest_from_start\n    vertex_b = farthest_from_a\n    vertex_c = next(i for i in range(1, n + 1) if i != vertex_a and i != vertex_b)\n\n    return max_edges + 1, vertex_a, vertex_b, vertex_c\n\n# Input handling\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\nresult = maximum_edges_in_paths(n, edges)\nprint(result[0])\nprint(result[1], result[2], result[3])\n```",
    "58": "```python\ndef color_array(n, k, a):\n    from collections import defaultdict\n\n    # Step 1: Initialize data structures for counting and storing positions\n    color_assignment = [0] * n\n    element_positions = defaultdict(list)\n\n    # Step 2: Collect positions of each element\n    for index, value in enumerate(a):\n        element_positions[value].append(index)\n\n    # Step 3: Check if coloring is possible and assign colors\n    color = 1\n    for positions in element_positions.values():\n        if len(positions) > k:\n            print(\"NO\")\n            return\n        \n        # Assign colors to the current element\n        for pos in positions:\n            color_assignment[pos] = color\n            color = color + 1 if color < k else 1\n\n    # Step 4: Ensure all colors are used\n    if len(set(color_assignment)) < k:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(' '.join(map(str, color_assignment)))\n\n# Example usage\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    color_array(n, k, a)\n```",
    "60": "```python\ndef has_palindromic_subsequence(test_cases):\n    results = []\n    \n    for n, a in test_cases:\n        last_occurrence = {}\n        found_palindrome = False\n        \n        for i in range(n):\n            if a[i] in last_occurrence and i - last_occurrence[a[i]] >= 2:\n                found_palindrome = True\n                break\n            last_occurrence[a[i]] = i\n        \n        results.append(\"YES\" if found_palindrome else \"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    test_cases = []\n    \n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1].split()))\n        test_cases.append((n, a))\n        index += 2\n\n    results = has_palindromic_subsequence(test_cases)\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "61": "```python\ndef maximize_number(n, a, f):\n    f_map = {str(i + 1): str(f[i]) for i in range(9)}\n    result = list(a)\n    \n    in_replacement_segment = False\n    \n    for i in range(n):\n        current_digit = a[i]\n        mapped_digit = f_map[current_digit]\n        \n        if mapped_digit > current_digit:\n            result[i] = mapped_digit\n            in_replacement_segment = True\n        elif mapped_digit < current_digit and in_replacement_segment:\n            break\n    \n    return ''.join(result)\n\n# Read inputs\nn = int(input().strip())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\n# Get the result\nprint(maximize_number(n, a, f))\n```",
    "65": "```python\ndef moves_to_transform(n, m):\n    if m % n != 0:\n        return -1\n    \n    quotient = m // n\n    moves = 0\n    \n    while quotient > 1:\n        if quotient % 2 == 0:\n            quotient //= 2\n        elif quotient % 3 == 0:\n            quotient //= 3\n        else:\n            return -1\n        moves += 1\n    \n    return moves\n\n# Input\nn, m = map(int, input().split())\n# Output\nprint(moves_to_transform(n, m))\n```",
    "63": "```python\ndef minimum_instability(n, a):\n    # Sort the array to easily find min and max after removing an element\n    a.sort()\n    \n    # Calculate potential minimum instability after removing one element\n    instability_case1 = a[-1] - a[1]  # Remove the first element\n    instability_case2 = a[-2] - a[0]  # Remove the last element\n    \n    # The minimum instability after removing one element\n    return min(instability_case1, instability_case2)\n\n# Input reading\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Output the result\nprint(minimum_instability(n, a))\n```",
    "66": "```python\ndef minimum_length_string(n, k, t):\n    # Step 1: Find the maximum overlap length\n    overlap_length = 0\n    for i in range(1, n):\n        if t.startswith(t[i:]):\n            overlap_length = n - i\n            break\n\n    # Step 2: Construct the result string\n    # Start with the first occurrence of t\n    result = t\n    # Add remaining k-1 occurrences with the overlap\n    result += t[overlap_length:] * (k - 1)\n\n    return result\n\n# Input reading\nn, k = map(int, input().split())\nt = input().strip()\n\n# Output the result\nprint(minimum_length_string(n, k, t))\n```",
    "55": "```python\ndef can_see_white_sheet(white_coords, black1_coords, black2_coords):\n    x1, y1, x2, y2 = white_coords\n    x3, y3, x4, y4 = black1_coords\n    x5, y5, x6, y6 = black2_coords\n\n    # Check visibility conditions\n    left_visible = (x3 >= x2 or x4 >= x2) or (x5 >= x2 or x6 >= x2)\n    right_visible = (x3 <= x1 or x4 <= x1) or (x5 <= x1 or x6 <= x1)\n    bottom_visible = (y3 >= y2 or y4 >= y2) or (y5 >= y2 or y6 >= y2)\n    top_visible = (y3 <= y1 or y4 <= y1) or (y5 <= y1 or y6 <= y1)\n\n    if left_visible or right_visible or bottom_visible or top_visible:\n        return \"YES\"\n\n    # Check if the black sheets completely cover the white sheet\n    fully_covered = (\n        (x3 <= x1 and x4 >= x2 and y3 <= y1 and y4 >= y2) or\n        (x5 <= x1 and x6 >= x2 and y5 <= y1 and y6 >= y2) or\n        (x3 <= x1 and x4 >= x2 and y5 <= y1 and y6 >= y2) or\n        (x5 <= x1 and x6 >= x2 and y3 <= y1 and y4 >= y2)\n    )\n\n    return \"NO\" if fully_covered else \"YES\"\n\n# Read input values\nwhite_coords = list(map(int, input().split()))\nblack1_coords = list(map(int, input().split()))\nblack2_coords = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_see_white_sheet(white_coords, black1_coords, black2_coords)\nprint(result)\n```",
    "67": "```python\ndef find_nice_indices(n, a):\n    total_sum = sum(a)\n    count = {}\n    \n    # Count occurrences of each number\n    for num in a:\n        count[num] = count.get(num, 0) + 1\n\n    nice_indices = []\n\n    for i in range(n):\n        # Calculate the remaining sum after removing a[i]\n        remaining_sum = total_sum - a[i]\n\n        # Check if there exists an element equal to the remaining sum divided by 2\n        if remaining_sum % 2 == 0:\n            target = remaining_sum // 2\n            \n            # Check if the target can be found in the array\n            if target in count:\n                # Ensure the middle element can be counted correctly\n                if (target != a[i] and count[target] > 0) or (target == a[i] and count[target] > 1):\n                    nice_indices.append(i + 1)  # Store 1-based index\n\n    return nice_indices\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Finding nice indices\nnice_indices = find_nice_indices(n, a)\n\n# Output results\nprint(len(nice_indices))\nif nice_indices:\n    print(\" \".join(map(str, nice_indices)))\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    # Initialize the days array with zeros indicating rest days\n    days = [0] * n\n    exam_days = [0] * n  # To track the exam days\n    \n    # Prepare a list of exams with their respective indices for output\n    exam_list = [(s, d, c, idx + 1) for idx, (s, d, c) in enumerate(exams)]\n    \n    # Sort exams by their exam day\n    exam_list.sort(key=lambda x: x[1])\n    \n    # Allocate preparation days\n    for s, d, c, idx in exam_list:\n        available_days = [j for j in range(s - 1, d - 1) if days[j] == 0]  # Collect available rest days\n\n        # Check if there are enough available days for preparation\n        if len(available_days) < c:\n            return -1\n        \n        # Schedule the preparation days\n        for j in range(c):\n            days[available_days[j]] = idx\n\n        # Mark the exam day\n        exam_days[d - 1] = idx\n\n    # Fill exam days into the days array\n    for i in range(n):\n        if exam_days[i] != 0:\n            days[i] = m + 1  # Mark exam days with (m + 1)\n\n    return days\n\n# Read input\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the schedule\nresult = schedule_exams(n, m, exams)\n\n# Print result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "62": "```python\ndef min_operations_to_divisible_triplet(test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        min_operations = float('inf')\n        best_triplet = (a, b, c)\n\n        # We will iterate over possible values for A, B, and C\n        for A in range(1, a + 2):  # A can be from 1 to a+1\n            for B in range(A, c + 2):  # B can be from A to c+1\n                if B % A == 0:  # Check if B is divisible by A\n                    # Find the nearest C such that C is a multiple of B and C >= B\n                    C = (c // B) * B\n                    if C < B:\n                        C += B\n                    \n                    if C > c:  # Ensure C does not exceed the original c\n                        C = (c // B + 1) * B\n                    \n                    operations = abs(A - a) + abs(B - b) + abs(C - c)\n                    \n                    if operations < min_operations:\n                        min_operations = operations\n                        best_triplet = (A, B, C)\n        \n        results.append((min_operations, best_triplet))\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations_to_divisible_triplet(test_cases)\n\n# Print output\nfor operations, (A, B, C) in results:\n    print(operations)\n    print(A, B, C)\n```",
    "73": "```python\ndef can_complete_wall(n, heights):\n    max_height = max(heights)\n    total_bricks_needed = sum(max_height - height for height in heights)\n    \n    return total_bricks_needed % 2 == 0\n\n# Input reading\nn = int(input().strip())\nheights = list(map(int, input().strip().split()))\n\n# Checking the condition and printing the result\nprint(\"YES\" if can_complete_wall(n, heights) else \"NO\")\n```",
    "70": "```python\ndef calculate_midpoint(start_time: str, end_time: str) -> str:\n    # Parse the start and end times\n    h1, m1 = map(int, start_time.split(':'))\n    h2, m2 = map(int, end_time.split(':'))\n\n    # Convert times to total minutes\n    start_minutes = h1 * 60 + m1\n    end_minutes = h2 * 60 + m2\n\n    # Calculate midpoint in total minutes\n    midpoint_minutes = (start_minutes + end_minutes) // 2\n\n    # Convert midpoint back to hours and minutes\n    h3 = midpoint_minutes // 60\n    m3 = midpoint_minutes % 60\n\n    # Format the result as hh:mm\n    return f\"{h3:02}:{m3:02}\"\n\n# Read input\nstart_time = input().strip()\nend_time = input().strip()\n\n# Calculate and print the midpoint\nprint(calculate_midpoint(start_time, end_time))\n```",
    "71": "```python\ndef count_set_bits(number: int) -> int:\n    \"\"\"Returns the count of set bits (1s) in the binary representation of the given number.\"\"\"\n    count = 0\n\n    while number:\n        count += number & 1  # Increment count if the last bit is set\n        number >>= 1  # Right shift to check the next bit\n\n    return count\n\ndef main():\n    # Read input and ensure it is within the required range\n    a = int(input().strip())\n    if 1 <= a <= 64:\n        print(count_set_bits(a))\n    else:\n        raise ValueError(\"Input must be between 1 and 64 inclusive.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
    "77": "```python\ndef minimum_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    result = minimum_difference(n)\n    print(result)\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    # To store unique subsequences and their costs\n    unique_subsequences = set()\n    total_cost = 0\n    \n    # Generate all possible subsequences using a bitmask approach\n    for i in range(1 << n):  # 2^n possible subsequences\n        subsequence = []\n        for j in range(n):\n            if i & (1 << j):\n                subsequence.append(s[j])\n        subsequence_str = ''.join(subsequence)\n        \n        # Add unique subsequences\n        if subsequence_str not in unique_subsequences:\n            unique_subsequences.add(subsequence_str)\n            total_cost += n - len(subsequence_str)  # Calculate cost of the subsequence\n            \n            # Stop if we have reached the required number of unique subsequences\n            if len(unique_subsequences) == k:\n                break\n\n    # Check if we have enough unique subsequences\n    if len(unique_subsequences) < k:\n        return -1\n\n    return total_cost\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "74": "```python\nfrom itertools import combinations\n\ndef min_cost_to_obtain_set(n, k, s):\n    # Create a set to hold unique subsequences\n    unique_subsequences = set()\n    \n    # Generate all possible subsequences\n    for length in range(n + 1):\n        for comb in combinations(s, length):\n            unique_subsequences.add(''.join(comb))\n    \n    # Check if we can obtain at least k unique subsequences\n    if len(unique_subsequences) < k:\n        return -1\n\n    # Calculate the minimum cost for the first k unique subsequences\n    costs = sorted(n - len(subseq) for subseq in unique_subsequences)\n    return sum(costs[:k])\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "76": "```python\ndef can_construct_symmetric_square(t, test_cases):\n    results = []\n\n    for n, m, tiles in test_cases:\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n\n        can_form_symmetric = False\n\n        # Check for symmetric conditions\n        for a, b, c, d in tiles:\n            if b == c:  # Check if top-right matches bottom-left\n                can_form_symmetric = True\n                break\n\n        results.append(\"YES\" if can_form_symmetric else \"NO\")\n\n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = [tuple(map(int, input().split())) + tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, m, tiles))\n\n# Process and print results\nresults = can_construct_symmetric_square(t, test_cases)\nprint(\"\\n\".join(results))\n```",
    "81": "```python\ndef can_reorder_strings(n, strings):\n    # Sort strings by their lengths\n    strings.sort(key=len)\n    \n    # Check if each string is a substring of the next one\n    for i in range(n - 1):\n        if strings[i] not in strings[i + 1]:\n            return \"NO\"\n    \n    # Return the ordered strings\n    return \"YES\", strings\n\n# Input handling\nn = int(input().strip())\nstrings = [input().strip() for _ in range(n)]\n\n# Process the strings and output the result\nresult = can_reorder_strings(n, strings)\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    print(\"\\n\".join(result[1]))\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    color = [0] * n\n    color_count = 0\n    last_color = {}\n    \n    for i in range(n):\n        char = s[i]\n        if char in last_color:\n            # Use the last assigned color if it can be reused\n            if last_color[char] != color[i - 1]:\n                color[i] = color_count + 1\n                color_count += 1\n            else:\n                color[i] = color[i - 1]\n        else:\n            # Assign a new color\n            color_count += 1\n            color[i] = color_count\n        \n        last_color[char] = color[i]\n    \n    return color_count, color\n\n# Input reading\nn = int(input())\ns = input()\n\n# Get the result\nresult_count, result_colors = min_colors_to_sort(n, s)\n\n# Output the result\nprint(result_count)\nprint(\" \".join(map(str, result_colors)))\n```",
    "82": "```python\ndef max_problems_solved(n, k, difficulties):\n    left, right = 0, n - 1\n    solved_count = 0\n\n    while left <= right:\n        if difficulties[left] <= k:\n            solved_count += 1\n            left += 1\n        elif difficulties[right] <= k:\n            solved_count += 1\n            right -= 1\n        else:\n            break\n\n    return solved_count\n\n# Input reading\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Get and print the result\nresult = max_problems_solved(n, k, difficulties)\nprint(result)\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    lefts = [segment[0] for segment in segments]\n    rights = [segment[1] for segment in segments]\n\n    max_left = [0] * n\n    min_right = [0] * n\n\n    max_left[0] = lefts[0]\n    for i in range(1, n):\n        max_left[i] = max(max_left[i - 1], lefts[i])\n\n    min_right[n - 1] = rights[n - 1]\n    for i in range(n - 2, -1, -1):\n        min_right[i] = min(min_right[i + 1], rights[i])\n\n    max_length = 0\n\n    for i in range(n):\n        intersection_left = max_left[i - 1] if i > 0 else max_left[1]\n        intersection_right = min_right[i + 1] if i < n - 1 else min_right[n - 2]\n\n        length = max(0, intersection_right - intersection_left)\n        max_length = max(max_length, length)\n\n    return max_length\n\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\nresult = max_intersection_length(n, segments)\nprint(result)\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict\n\n    if D >= n:\n        return \"NO\"\n\n    # Create an adjacency list for the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Degree of the first vertex\n    degree_1 = len(graph[1])\n\n    # Check if it's possible to have degree D for vertex 1\n    if D > degree_1:\n        return \"NO\"\n\n    # Start constructing the spanning tree\n    visited = [False] * (n + 1)\n    spanning_tree_edges = []\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if (node == 1 and degree_1 > D) or (node != 1):\n                    spanning_tree_edges.append((node, neighbor))\n                    dfs(neighbor)\n                    if len(spanning_tree_edges) == n - 1:\n                        return True\n                elif node == 1 and degree_1 == D:\n                    # For vertex 1, keep track of degree\n                    if len(spanning_tree_edges) < D:\n                        spanning_tree_edges.append((node, neighbor))\n                        degree_1 -= 1\n                        dfs(neighbor)\n                        if len(spanning_tree_edges) == n - 1:\n                            return True\n        return False\n\n    dfs(1)\n\n    if len(spanning_tree_edges) != n - 1 or degree_1 != 0:\n        return \"NO\"\n\n    result = [\"YES\"]\n    result.extend(f\"{u} {v}\" for u, v in spanning_tree_edges)\n    return \"\\n\".join(result)\n\n# Input reading\nn, m, D = map(int, input().strip().split())\nedges = [tuple(map(int, input().strip().split())) for _ in range(m)]\n\n# Find the spanning tree\noutput = find_spanning_tree(n, m, D, edges)\nprint(output)\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n: int) -> int:\n    s = str(n)\n    length = len(s)\n    target_pairs = ['00', '25', '50', '75']\n    min_moves = float('inf')\n\n    for pair in target_pairs:\n        pos1 = pos2 = -1\n        \n        # Iterate through the string in reverse to find the required digits\n        for i in range(length - 1, -1, -1):\n            if s[i] == pair[1] and pos2 == -1:\n                pos2 = i\n            elif s[i] == pair[0] and pos2 != -1:\n                pos1 = i\n                break\n        \n        # Calculate moves if both positions are valid\n        if pos1 != -1 and pos2 != -1:\n            moves = (length - 1 - pos2) + (pos2 - pos1 - 1)\n            min_moves = min(min_moves, moves)\n\n    return min_moves if min_moves != float('inf') else -1\n\n# Example usage\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    print(min_moves_to_divisible_by_25(n))\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    min_perimeter = float('inf')\n\n    for height_r in range(1, int(a**0.5) + 1):\n        if a % height_r == 0:\n            width_r = a // height_r\n            \n            for height_b in range(1, int(b**0.5) + 1):\n                if b % height_b == 0:\n                    width_b = b // height_b\n                    \n                    # Calculate perimeter for both arrangements\n                    perimeters = [\n                        2 * (max(height_r, height_b) + (width_r + width_b)),\n                        2 * ((height_r + height_b) + max(width_r, width_b))\n                    ]\n                    min_perimeter = min(min_perimeter, *perimeters)\n\n    return min_perimeter\n\n# Input reading\na, b = map(int, input().strip().split())\nprint(minimal_perimeter(a, b))\n```",
    "85": "```python\ndef find_price(A, B):\n    # Loop through potential prices starting from 1\n    for price in range(1, 10000):\n        tax_8 = int(price * 0.08)  # Calculate and floor the tax for 8%\n        tax_10 = int(price * 0.10)  # Calculate and floor the tax for 10%\n        \n        # Check if the calculated taxes match A and B\n        if tax_8 == A and tax_10 == B:\n            return price  # Return the first valid price found\n    \n    return -1  # Return -1 if no valid price is found\n\n# Read input\nA, B = map(int, input().split())\n# Get the result and print it\nprint(find_price(A, B))\n```",
    "78": "```python\nMOD = 10**9 + 7\n\ndef count_regular_bracket_sequences(n, s):\n    m = len(s)\n    \n    # Precompute the number of valid sequences of length 2k\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            dp[i][j] = (dp[i - 1][j + 1] if j + 1 <= i - 1 else 0) + (dp[i - 1][j - 1] if j > 0 else 0)\n            dp[i][j] %= MOD\n\n    # Count the number of left and right brackets in s\n    left_brackets = s.count('(')\n    right_brackets = s.count(')')\n\n    # Validate the brackets count\n    if left_brackets < right_brackets or left_brackets > n or right_brackets > n:\n        return 0\n    \n    # Calculate remaining length for valid sequences\n    remaining_length = 2 * (n - (left_brackets + right_brackets))\n\n    if remaining_length < 0 or (remaining_length // 2) < 0:\n        return 0\n\n    valid_sequences = dp[n - (left_brackets + right_brackets)][0]\n    \n    # Calculate total sequences by placing `s` in valid sequences\n    total_sequences = valid_sequences * (remaining_length + 1) % MOD\n    \n    return total_sequences\n\n# Read input values\nn = int(input().strip())\ns = input().strip()\n\n# Compute the result\nresult = count_regular_bracket_sequences(n, s)\nprint(result)\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Daily food requirements based on starting day\n    food_schedule = ['fish', 'rabbit', 'chicken', 'fish', 'chicken', 'rabbit', 'fish']\n    \n    max_days = 0\n    \n    for start_day in range(7):\n        fish_count, rabbit_count, chicken_count = a, b, c\n        current_days = 0\n        \n        # Simulate the first week from the chosen start day\n        for day in range(7):\n            current_food = food_schedule[(start_day + day) % 7]\n            if current_food == 'fish' and fish_count > 0:\n                fish_count -= 1\n            elif current_food == 'rabbit' and rabbit_count > 0:\n                rabbit_count -= 1\n            elif current_food == 'chicken' and chicken_count > 0:\n                chicken_count -= 1\n            else:\n                break  # Out of food\n            \n            current_days += 1\n        \n        # Calculate full weeks that can be sustained\n        full_weeks = min(fish_count // 3, rabbit_count // 2, chicken_count // 2)\n        remaining_days = current_days + full_weeks * 7\n        \n        # Check for additional days after full weeks\n        remaining_food = [fish_count - full_weeks * 3, rabbit_count - full_weeks * 2, chicken_count - full_weeks * 2]\n        \n        for day in range(7):\n            current_food = food_schedule[(start_day + current_days + day) % 7]\n            if current_food == 'fish' and remaining_food[0] > 0:\n                remaining_food[0] -= 1\n                remaining_days += 1\n            elif current_food == 'rabbit' and remaining_food[1] > 0:\n                remaining_food[1] -= 1\n                remaining_days += 1\n            elif current_food == 'chicken' and remaining_food[2] > 0:\n                remaining_food[2] -= 1\n                remaining_days += 1\n            else:\n                break\n        \n        max_days = max(max_days, remaining_days)\n    \n    return max_days\n\n# Input reading\na, b, c = map(int, input().split())\n# Output the result\nprint(max_days(a, b, c))\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects based on the required rating (a_i)\n    projects.sort(key=lambda x: x[0])\n    max_count = 0\n    current_rating = r\n\n    for a_i, b_i in projects:\n        if current_rating >= a_i:\n            max_count += 1\n            current_rating += b_i\n            # Ensure rating does not fall below zero\n            if current_rating < 0:\n                break\n\n    return max_count\n\n# Read input\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = max_projects(n, r, projects)\nprint(result)\n```",
    "84": "```python\ndef can_color_string(n, s):\n    # Initialize a list to hold the color assignment\n    color = ['0'] * n\n    last_positions = {}\n\n    # Track last positions of each character\n    for i in range(n):\n        char = s[i]\n        if char in last_positions:\n            last_positions[char].append(i)\n        else:\n            last_positions[char] = [i]\n\n    # Check the possibility to color the string\n    for positions in last_positions.values():\n        for i in range(1, len(positions)):\n            if positions[i] - positions[i - 1] == 1:\n                continue\n            if color[positions[i]] == color[positions[i - 1]]:\n                return \"NO\", \"\"\n\n    # Color the string based on sorted order\n    color_map = {}\n    for i in range(n):\n        char = s[i]\n        if char not in color_map:\n            color_map[char] = '0' if len(color_map) % 2 == 0 else '1'\n        color[i] = color_map[char]\n    \n    return \"YES\", ''.join(color)\n\n# Input handling\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult, coloring = can_color_string(n, s)\n\n# Output the result\nprint(result)\nif result == \"YES\":\n    print(coloring)\n```",
    "89": "```python\ndef can_complete_projects(n, initial_rating, projects):\n    # Sort projects by their required rating (a_i)\n    projects.sort(key=lambda x: x[0])\n    \n    current_rating = initial_rating\n    \n    for required_rating, rating_change in projects:\n        if current_rating < required_rating:\n            return \"NO\"\n        current_rating += rating_change\n        if current_rating < 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, initial_rating = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_complete_projects(n, initial_rating, projects))\n```",
    "92": "```python\ndef find_integers(x):\n    # Iterate over possible integer pairs (a, b) where 1 <= a, b <= 10\n    for a in range(1, 11):\n        for b in range(1, 11):\n            # Calculate the value of a * b / (a + b) and compare with x\n            if abs(a * b / (a + b) - x) < 1e-6:  # Tolerance for floating-point comparison\n                return a, b\n\ndef main():\n    # Read input\n    x = float(input().strip())\n    \n    # Find integers\n    a, b = find_integers(x)\n    \n    # Print output\n    print(a, b)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "97": "```python\ndef min_coins_to_move_chips(n, positions):\n    odd_count = sum(1 for pos in positions if pos % 2 != 0)\n    even_count = n - odd_count\n    return min(odd_count, even_count)\n\n# Read input\nn = int(input().strip())\npositions = list(map(int, input().strip().split()))\n\n# Calculate and print the result\nresult = min_coins_to_move_chips(n, positions)\nprint(result)\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Initialize variables for the result and remaining counts\n    result = []\n    first_char, second_char = ('0', '1') if a > b else ('1', '0')\n    first_count, second_count = (a, b) if a > b else (b, a)\n\n    # Create the alternating pattern\n    for _ in range(x):\n        if first_count > 0:\n            result.append(first_char)\n            first_count -= 1\n        if second_count > 0:\n            result.append(second_char)\n            second_count -= 1\n\n    # Add the remaining characters of the majority type\n    result.append(first_char * first_count)\n    result.append(second_char * second_count)\n\n    # Join the list into a string and return\n    return ''.join(result)\n\n# Read input\na, b, x = map(int, input().split())\n# Generate and print the binary string\nprint(construct_binary_string(a, b, x))\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    # Check for impossible conditions\n    if d > 2 * k or (d == 1 and n > 2) or (d == 0 and n > 1):\n        return \"NO\"\n\n    edges = []\n    \n    # Create the main path for the diameter\n    for i in range(1, d + 2):\n        edges.append((i, i + 1))\n    \n    # We have d + 1 nodes in the main path\n    current_node = d + 2\n\n    for i in range(1, d + 2):\n        # Add branches if we have remaining nodes\n        for _ in range(1, k):\n            if current_node > n:\n                break\n            edges.append((i, current_node))\n            current_node += 1\n\n    if current_node <= n:\n        return \"NO\"\n    \n    result = [\"YES\"]\n    result.extend(f\"{a} {b}\" for a, b in edges)\n    return \"\\n\".join(result)\n\n# Read input\nn, d, k = map(int, input().split())\nresult = construct_tree(n, d, k)\nprint(result)\n```",
    "86": "```python\ndef solve_polycarps_problem(n, k):\n    # Calculate the minimum and maximum number of problems that can be solved\n    min_sum = k * (k + 1) // 2  # Minimum problems: 1 + 2 + ... + k\n    max_sum = 0\n    current_day_problems = 1\n\n    # Calculate the maximum sum using the doubling strategy\n    for _ in range(k):\n        max_sum += current_day_problems\n        current_day_problems = min(current_day_problems * 2, current_day_problems + 1)\n\n    # Check if the number of problems can be satisfied\n    if n < min_sum or n > max_sum:\n        print(\"NO\")\n        return\n\n    result = [0] * k\n    current_day_problems = 1\n    remaining_problems = n\n\n    # Assign the minimum required problems for each day\n    for i in range(k):\n        result[i] = current_day_problems\n        remaining_problems -= current_day_problems\n        current_day_problems += 1\n\n    # Distribute the remaining problems respecting the constraints\n    for i in range(k - 1, -1, -1):\n        while remaining_problems > 0:\n            if (i < k - 1 and result[i] < result[i + 1] and result[i] * 2 >= result[i + 1]):\n                result[i] += 1\n                remaining_problems -= 1\n            elif i == k - 1:\n                result[i] += 1\n                remaining_problems -= 1\n            else:\n                break\n\n        if remaining_problems == 0:\n            break\n\n    if remaining_problems > 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, result)))\n\n# Read input\nn, k = map(int, input().split())\nsolve_polycarps_problem(n, k)\n```",
    "90": "```python\ndef can_cross_river(n, m, d, c):\n    result = [0] * n\n    current_position = 0\n\n    for i in range(m):\n        platform_length = c[i]\n        start_position = current_position + 1\n\n        # Place the platform in the result array\n        for j in range(platform_length):\n            if start_position + j < n:\n                result[start_position + j] = i + 1  # 1-based index\n\n        # Update the current position to the end of the current platform\n        current_position = start_position + platform_length - 1\n\n        # Check if we can reach the next platform\n        if i < m - 1 and (current_position + 1 + d < n):\n            return \"NO\"\n\n    return \"YES\", result\n\n# Read input values\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Call the function and get the result\nresult = can_cross_river(n, m, d, c)\n\n# Print the result\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    print(' '.join(map(str, result[1])))\n```",
    "91": "```python\ndef max_removable_substring_length(s: str, t: str) -> int:\n    n, m = len(s), len(t)\n    \n    # Precompute leftmost indices of each character in t from s\n    left_indices = [-1] * m\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left_indices[j] = i\n            j += 1\n    \n    # Precompute rightmost indices of each character in t from s\n    right_indices = [-1] * m\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right_indices[j] = i\n            j -= 1\n\n    # Calculate maximum removable length\n    max_removable_length = 0\n    for i in range(m - 1):\n        max_removable_length = max(max_removable_length, right_indices[i + 1] - left_indices[i] - 1)\n\n    # Consider removing from the start or the end of the string\n    max_removable_length = max(max_removable_length, left_indices[0])  # Removing from start\n    max_removable_length = max(max_removable_length, n - 1 - right_indices[m - 1])  # Removing from end\n\n    return max_removable_length\n\n# Input reading\nif __name__ == \"__main__\":\n    s = input().strip()\n    t = input().strip()\n    \n    # Output the result\n    print(max_removable_substring_length(s, t))\n```",
    "98": "```python\ndef min_moves_to_reach_n(N):\n    min_moves = float('inf')\n    \n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            # Calculate moves to reach (i, j)\n            moves = (i - 1) + (j - 1)\n            min_moves = min(min_moves, moves)\n    \n    return min_moves\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    print(min_moves_to_reach_n(N))\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Create the base string with n 'a's, n 'b's, and n 'c's\n    base = ['a'] * n + ['b'] * n + ['c'] * n\n    \n    # Check for forbidden pairs\n    forbidden_pairs = {s, t}\n\n    # Function to check if the last two characters form a forbidden pair\n    def ends_with_forbidden(pair):\n        return pair in forbidden_pairs\n\n    # Construct the result string\n    result = []\n    for char in base:\n        result.append(char)\n        # If the last two characters form a forbidden pair, skip the next character\n        if len(result) >= 2 and ends_with_forbidden(''.join(result[-2:])):\n            # Find a valid character to replace the last character\n            for replacement in 'abc':\n                if replacement != char and (len(result) < 2 or not ends_with_forbidden(''.join(result[-2:] + [replacement]))):\n                    result[-1] = replacement\n                    break\n\n    # Join the result and check if it contains forbidden substrings\n    result_str = ''.join(result)\n    if any(f in result_str for f in forbidden_pairs):\n        return \"NO\", None\n\n    return \"YES\", result_str\n\n# Reading input\nn = int(input().strip())\ns = input().strip()\nt = input().strip()\n\n# Generating the result\nresult = generate_string(n, s, t)\n\n# Print the output\nprint(result[0])\nif result[0] == \"YES\":\n    print(result[1])\n```",
    "88": "```python\ndef is_palindromic_possible(n, numbers):\n    from collections import Counter\n    \n    count = Counter(numbers)\n    \n    # Check odd frequency count\n    odd_count = sum(1 for freq in count.values() if freq % 2 != 0)\n    \n    # Validate the possibility of forming a palindromic matrix\n    if (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n        return \"NO\", []\n    \n    # Create the matrix\n    matrix = [[0] * n for _ in range(n)]\n    half = n // 2\n    idx = 0\n    \n    # Fill the matrix\n    for num, freq in count.items():\n        while freq > 0:\n            if freq >= 4:\n                # Place in corners\n                matrix[idx][idx] = num\n                matrix[idx][n - 1 - idx] = num\n                matrix[n - 1 - idx][idx] = num\n                matrix[n - 1 - idx][n - 1 - idx] = num\n                freq -= 4\n            elif freq == 2:\n                # Place in middle sides if even size\n                if n % 2 == 0:\n                    matrix[idx][half] = num\n                    matrix[half][idx] = num\n                    matrix[n - 1 - idx][half] = num\n                    matrix[half][n - 1 - idx] = num\n                freq -= 2\n            elif freq == 1:\n                # Place in center if odd size\n                if n % 2 == 1 and odd_count == 1:\n                    matrix[half][half] = num\n                freq -= 1\n            \n            if freq == 0:\n                idx += 1\n                if idx >= half:\n                    idx = half if n % 2 == 1 else half - 1\n    \n    # Fill remaining spots\n    last_num = num\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                matrix[i][j] = last_num\n    \n    return \"YES\", matrix\n\n# Read input\nn = int(input())\nnumbers = list(map(int, input().split()))\n\n# Get result\nresult, matrix = is_palindromic_possible(n, numbers)\n\n# Print output\nprint(result)\nif result == \"YES\":\n    for row in matrix:\n        print(\" \".join(map(str, row)))\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    # Step 1: Initialize permutation array with first element\n    p = [0] * n\n    p[0] = 1  # Starting with p1 = 1 (arbitrary choice)\n\n    # Step 2: Generate the permutation based on differences in q\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n\n    # Step 3: Normalize the permutation to ensure it starts from 1\n    min_value = min(p)\n    for i in range(n):\n        p[i] -= min_value - 1  # Shift to start from 1\n\n    # Step 4: Validate if the resulting array is a valid permutation\n    if len(set(p)) == n and all(1 <= x <= n for x in p):\n        print(' '.join(map(str, p)))\n    else:\n        print(-1)\n\n# Example usage\nn = int(input())\nq = list(map(int, input().split()))\nrestore_permutation(n, q)\n```",
    "99": "```python\ndef rock_paper_scissors(n, alice_counts, bob_counts):\n    a_rock, a_scissors, a_paper = alice_counts  # Alice's counts of Rock, Scissors, Paper\n    b_rock, b_scissors, b_paper = bob_counts    # Bob's counts of Rock, Scissors, Paper\n\n    # Calculate maximum wins for Alice\n    max_wins = min(a_rock, b_paper) + min(a_scissors, b_rock) + min(a_paper, b_scissors)\n\n    # Calculate losses for Alice based on Bob's optimal plays\n    losses = max(0, b_rock - a_paper) + max(0, b_scissors - a_rock) + max(0, b_paper - a_scissors)\n\n    # Minimum wins for Alice\n    min_wins = n - losses\n\n    return min_wins, max_wins\n\n# Reading inputs\nn = int(input().strip())\nalice_counts = list(map(int, input().strip().split()))\nbob_counts = list(map(int, input().strip().split()))\n\n# Getting the results\nmin_wins, max_wins = rock_paper_scissors(n, alice_counts, bob_counts)\n\n# Printing results\nprint(min_wins, max_wins)\n```"
}