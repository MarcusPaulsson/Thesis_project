{
    "0": "```python\ndef max_accordion_length(s):\n    left_bracket_index = -1\n    right_bracket_index = -1\n    colon_indices = []\n\n    for i, char in enumerate(s):\n        if char == '[' and left_bracket_index == -1:\n            left_bracket_index = i\n        elif char == ':' and left_bracket_index != -1:\n            colon_indices.append(i)\n        elif char == ']' and left_bracket_index != -1:\n            right_bracket_index = i\n            break\n\n    if left_bracket_index == -1 or right_bracket_index == -1 or len(colon_indices) < 2:\n        return -1\n\n    # We need at least two colons, one before the vertical lines and one after\n    # We will find the first colon after the left bracket and the last colon before the right bracket\n    first_colon_index = -1\n    last_colon_index = -1\n\n    for i in colon_indices:\n        if i > left_bracket_index:\n            if first_colon_index == -1:\n                first_colon_index = i\n            if i < right_bracket_index:\n                last_colon_index = i\n\n    if first_colon_index == -1 or last_colon_index == -1 or first_colon_index >= last_colon_index:\n        return -1\n\n    # Count the vertical lines between the two colons\n    vertical_lines_count = 0\n    for i in range(first_colon_index + 1, last_colon_index):\n        if s[i] == '|':\n            vertical_lines_count += 1\n\n    # Length of accordion = 1 (for [) + 1 (for :) + vertical lines + 1 (for :) + 1 (for ])\n    return 4 + vertical_lines_count\n\n# Read input\ns = input().strip()\n# Get the result and print it\nprint(max_accordion_length(s))\n```",
    "1": "```python\ndef digit_sum(n):\n    return sum(int(d) for d in str(n))\n\ndef max_digit_sum(x):\n    max_sum = digit_sum(x)\n    result = x\n    \n    # Check numbers with digits reduced to 9\n    str_x = str(x)\n    for i in range(len(str_x)):\n        if str_x[i] == '0':\n            continue\n            \n        # Create a new number by reducing the current digit and setting the rest to 9\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (len(str_x) - i - 1)\n        new_number = int(new_number)\n        \n        if new_number <= x:\n            current_sum = digit_sum(new_number)\n            if current_sum > max_sum or (current_sum == max_sum and new_number > result):\n                max_sum = current_sum\n                result = new_number\n    \n    return result\n\nx = int(input())\nprint(max_digit_sum(x))\n```",
    "2": "```python\ndef next_lucky_year(n):\n    # Increment the year until we find the next lucky year\n    while True:\n        n += 1\n        # Convert the year to string and check the number of non-zero digits\n        if sum(1 for digit in str(n) if digit != '0') <= 1:\n            return n - (n - 1)\n\n# Read input\ncurrent_year = int(input().strip())\n# Print the number of years until the next lucky year\nprint(next_lucky_year(current_year))\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    # Create an array to keep track of the coverage of sections\n    coverage = [0] * (n + 1)\n    \n    # Count the total coverage by all painters\n    for l, r in painters:\n        for j in range(l, r + 1):\n            coverage[j] += 1\n    \n    # To find the maximum painted sections by omitting 2 painters\n    max_sections = 0\n    \n    for i in range(q):\n        for j in range(i + 1, q):\n            # Create a temporary coverage array\n            temp_coverage = coverage[:]\n            # Remove the coverage of the i-th and j-th painters\n            l1, r1 = painters[i]\n            l2, r2 = painters[j]\n            for x in range(l1, r1 + 1):\n                temp_coverage[x] -= 1\n            for x in range(l2, r2 + 1):\n                temp_coverage[x] -= 1\n            \n            # Count the painted sections after removing these two painters\n            painted_sections = sum(1 for k in range(1, n + 1) if temp_coverage[k] > 0)\n            max_sections = max(max_sections, painted_sections)\n    \n    return max_sections\n\n# Input reading\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output the maximum painted sections\nprint(max_painted_sections(n, q, painters))\n```",
    "4": "```python\ndef is_lucky(hh, mm):\n    return '7' in f\"{hh:02d}:{mm:02d}\"\n\ndef minutes_to_hh_mm(hh, mm, minutes):\n    total_minutes = hh * 60 + mm - minutes\n    if total_minutes < 0:\n        total_minutes += 24 * 60  # wrap around to previous day\n    return divmod(total_minutes, 60)\n\nx = int(input())\nhh, mm = map(int, input().split())\n\ny = 0\nwhile True:\n    prev_hh, prev_mm = minutes_to_hh_mm(hh, mm, x * y)\n    if is_lucky(prev_hh, prev_mm):\n        print(y)\n        break\n    y += 1\n```",
    "5": "```python\ndef minimum_seconds(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0  # No tabs to close\n    \n    left_move = max(0, pos - l)  # Move to the leftmost required tab\n    right_move = max(0, r - pos)  # Move to the rightmost required tab\n    \n    # Closing tabs to the left of l\n    close_left = 1 if l > 1 else 0\n    # Closing tabs to the right of r\n    close_right = 1 if r < n else 0\n    \n    # Calculate total time\n    total_time = left_move + close_left + right_move + close_right\n    return total_time\n\n# Input reading\nn, pos, l, r = map(int, input().split())\nprint(minimum_seconds(n, pos, l, r))\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    \n    for query in queries:\n        n, x, blows = query\n        min_blows = float('inf')\n        \n        # Determine the best blow\n        effective_blows = []\n        for d, h in blows:\n            if d > 0:\n                effective_blows.append((d, h))\n        \n        # If no effective blows, Zmei can't be defeated\n        if not effective_blows:\n            results.append(-1)\n            continue\n        \n        # Find the minimum blows needed\n        for d, h in effective_blows:\n            # Calculate the net effect of this blow\n            net_effect = d - h\n            if net_effect >= 0:\n                # If the blow does not reduce heads effectively\n                if x <= d:\n                    # We can defeat Gorynich in one blow\n                    min_blows = min(min_blows, 1)\n            else:\n                # Calculate how many blows are needed\n                blows_needed = (x + net_effect - 1) // net_effect\n                if blows_needed >= 0:\n                    min_blows = min(min_blows, blows_needed)\n\n        if min_blows == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_blows)\n\n    return results\n\n# Reading input\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\n# Getting results\nresults = min_blows_to_defeat_zmei(t, queries)\n\n# Printing results\nfor result in results:\n    print(result)\n```",
    "7": "```python\ndef day_when_barn_empty(n, m):\n    day = 1\n    grains = n\n    \n    while grains > 0:\n        # Add grains to the barn\n        grains += m\n        if grains > n:\n            grains = n\n        \n        # Sparrows eat grains\n        grains -= day\n        \n        day += 1\n    \n    return day - 1\n\n# Input\nn, m = map(int, input().split())\nprint(day_when_barn_empty(n, m))\n```",
    "8": "```python\ndef min_tiles_to_draw(tiles):\n    counts = {'m': {}, 'p': {}, 's': {}}\n    \n    for tile in tiles:\n        num, suit = int(tile[0]), tile[1]\n        if num not in counts[suit]:\n            counts[suit][num] = 0\n        counts[suit][num] += 1\n    \n    # Check for koutsu\n    for suit in counts:\n        if any(count >= 3 for count in counts[suit].values()):\n            return 0\n    \n    # Check for shuntsu\n    for suit in counts:\n        nums = sorted(counts[suit].keys())\n        if len(nums) >= 3:\n            for i in range(len(nums) - 2):\n                if nums[i + 1] == nums[i] + 1 and nums[i + 2] == nums[i] + 2:\n                    return 0\n    \n    # Check if we can make a shuntsu by drawing one tile\n    for suit in counts:\n        nums = sorted(counts[suit].keys())\n        for num in nums:\n            if num - 1 >= 1 and num + 1 <= 9:\n                if (num - 1 in counts[suit] and num + 1 in counts[suit]):\n                    return 1\n    \n    # If no mentsu can be formed with one draw, we will need at least 2\n    return 2\n\n# Input reading\ntiles = input().strip().split()\nprint(min_tiles_to_draw(tiles))\n```",
    "9": "```python\ndef find_grandpa_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b):\n    positions = []\n\n    # Parse the sofa positions\n    for i in range(d):\n        x1, y1, x2, y2 = sofas[i]\n        positions.append((min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)))\n\n    # Count sofas in each direction for each sofa\n    results = []\n    \n    for i in range(d):\n        cnt_left = cnt_right = cnt_top = cnt_bottom = 0\n        for j in range(d):\n            if i == j:\n                continue\n            x1, y1, x2, y2 = positions[i]\n            a1, b1, a2, b2 = positions[j]\n            if a2 < x1:  # j is to the left of i\n                cnt_left += 1\n            elif a1 > x2:  # j is to the right of i\n                cnt_right += 1\n            if b2 < y1:  # j is above i\n                cnt_top += 1\n            elif b1 > y2:  # j is below i\n                cnt_bottom += 1\n        \n        # Check if the counts match the conditions\n        if cnt_left == cnt_l and cnt_right == cnt_r and cnt_top == cnt_t and cnt_bottom == cnt_b:\n            results.append(i + 1)  # Store 1-based index\n\n    return results[0] if results else -1\n\n# Input reading\nd = int(input())\nn, m = map(int, input().split())\nsofas = [tuple(map(int, input().split())) for _ in range(d)]\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\n# Get the result\nresult = find_grandpa_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b)\nprint(result)\n```",
    "10": "```python\nn = int(input())\n\n# Maximum days off: all weekends can fit in the n days\nmax_days_off = (n // 7) * 2 + min(2, n % 7)\n\n# Minimum days off: if there are fewer days than a full week\nmin_days_off = 0 if n < 5 else (n // 7) * 2 + (1 if n % 7 >= 5 else 0)\n\nprint(min_days_off, max_days_off)\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    count_a = n // a\n    count_b = n // b\n    count_ab = n // (a * b)\n    \n    # Calculate chocolates if red tiles are prioritized\n    chocolates_red_first = (count_a - count_ab) * p + (count_b - count_ab) * q\n    \n    # Calculate chocolates if blue tiles are prioritized\n    chocolates_blue_first = (count_b - count_ab) * q + (count_a - count_ab) * p\n    \n    # Return the maximum chocolates from both strategies\n    return max(chocolates_red_first, chocolates_blue_first)\n\n# Read input\nn, a, b, p, q = map(int, input().split())\n\n# Calculate and print the result\nprint(max_chocolates(n, a, b, p, q))\n```",
    "12": "```python\ndef max_beauty_with_swap(n, trophies):\n    if 'G' not in trophies:\n        return 0\n    \n    # Find lengths of segments of golden trophies\n    segments = []\n    current_length = 0\n    \n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n    \n    if current_length > 0:\n        segments.append(current_length)\n        \n    if len(segments) == 0:\n        return 0\n    \n    # Calculate maximum length without any swap\n    max_length = max(segments)\n    \n    # If there's only one segment, no swap can increase the beauty\n    if len(segments) == 1:\n        return max_length\n    \n    # Now consider swapping the first S in between two segments\n    max_possible = max_length\n    \n    for i in range(len(segments) - 1):\n        # The longest segment can be increased by 1 if we swap an 'S' between two 'G' segments\n        max_possible = max(max_possible, segments[i] + segments[i + 1])\n    \n    return min(max_possible + 1, n)\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\n\n# Output the result\nprint(max_beauty_with_swap(n, trophies))\n```",
    "13": "```python\nfrom collections import defaultdict, deque\nimport sys\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, k = map(int, data[0].split())\nmain_courses = list(map(int, data[1].split()))\n\n# Dependency graph and in-degree count\ndependencies = defaultdict(list)\nin_degree = [0] * (n + 1)\n\n# Read course dependencies\nfor i in range(2, n + 2):\n    line = list(map(int, data[i].split()))\n    t_i = line[0]\n    for j in range(1, t_i + 1):\n        dependencies[line[j]].append(i - 1)  # course i-2 depends on line[j]\n        in_degree[i - 1] += 1  # Increase in-degree for course i-2\n\n# Topological sorting using Kahn's algorithm\nqueue = deque()\norder = []\npassed_courses = set()\n\n# Start with courses with no dependencies\nfor i in range(1, n + 1):\n    if in_degree[i - 1] == 0:\n        queue.append(i)\n\nwhile queue:\n    course = queue.popleft()\n    order.append(course)\n    passed_courses.add(course)\n\n    # Reduce in-degree of dependent courses\n    for dependent in dependencies[course]:\n        in_degree[dependent] -= 1\n        if in_degree[dependent] == 0:\n            queue.append(dependent + 1)\n\n# Check if all main courses can be passed\nif not all(course in passed_courses for course in main_courses):\n    print(-1)\nelse:\n    # We need to ensure we pass the main courses in the order needed\n    result = []\n    for course in order:\n        if course in main_courses:\n            result.append(course)\n            main_courses.remove(course)\n        if not main_courses:\n            break\n\n    # Include other passed courses if required\n    for course in order:\n        if course not in result and len(result) < len(passed_courses):\n            result.append(course)\n\n    print(len(result))\n    print(\" \".join(map(str, result)))\n```",
    "14": "```python\ndef is_stack_sortable(n, k, p):\n    # Create a set of used elements from the first k elements\n    used = set(p)\n    \n    # Initialize the stack and the resulting permutation\n    stack = []\n    result = p[:]\n    \n    # The next possible largest number we can use in the result\n    next_max = n\n    \n    for i in range(k):\n        # Ensure that the stack is sorted correctly\n        while stack and stack[-1] < result[i]:\n            # Pop from stack if it maintains order\n            result.append(stack.pop())\n        \n        # If the current element is less than the next max, we push elements to maintain order\n        while next_max > 0 and (next_max in used or next_max > result[i]):\n            stack.append(next_max)\n            next_max -= 1\n        \n        # If the current element is not in stack and not larger than next_max, we have an issue\n        if result[i] < next_max:\n            return -1\n    \n    # Add remaining elements to the stack\n    while next_max > 0:\n        if next_max not in used:\n            stack.append(next_max)\n        next_max -= 1\n    \n    # Add remaining elements from stack to result\n    while stack:\n        result.append(stack.pop())\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result and print\nresult = is_stack_sortable(n, k, p)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "16": "```python\ncnt1 = int(input().strip())\ncnt2 = int(input().strip())\ncnt3 = int(input().strip())\ncnt4 = int(input().strip())\n\n# A regular bracket sequence can be formed if:\n# 1. The number of closing brackets must not exceed the number of opening brackets at any point.\n# 2. At the end, the total number of opening brackets must equal the total number of closing brackets.\n\n# The total opening brackets from ( and ) pairs\ntotal_opening = cnt1 + cnt2\n# The total closing brackets from ) and ( pairs\ntotal_closing = cnt3 + cnt4\n\n# The count of unbalanced opening and closing brackets\nneeded_opening = cnt3\nneeded_closing = cnt1\n\n# Check if we can balance the brackets\nif needed_opening <= total_opening and needed_closing <= total_closing and (total_opening - needed_opening) >= needed_closing:\n    print(1)\nelse:\n    print(0)\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelse:\n    print(n + k - t)\n```",
    "18": "```python\nfrom collections import deque\n\ns = input().strip()\nt = deque()\nu = []\n\nfor char in s:\n    t.append(char)\n\nwhile t:\n    # Find the smallest character in the remaining part of t\n    min_char = min(t)\n    # Find the index of the first occurrence of this character\n    min_index = t.index(min_char)\n    \n    # Move characters from t to u until we reach the min_char\n    for _ in range(min_index + 1):\n        u.append(t.popleft())\n    \n    # Move the min_char to u\n    u.append(t.popleft())\n\n# Join the list to form the final string u\nprint(''.join(u))\n```",
    "19": "```python\ndef check_records(test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, stats = case\n        valid = True\n        \n        for i in range(1, n):\n            p_prev, c_prev = stats[i - 1]\n            p_curr, c_curr = stats[i]\n            \n            if p_curr < p_prev or c_curr < c_prev or c_curr > p_curr:\n                valid = False\n                break\n            \n            if c_curr - c_prev > p_curr - p_prev:\n                valid = False\n                break\n        \n        if valid:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Input processing\nT = int(input())\ntest_cases = []\n\nfor _ in range(T):\n    n = int(input())\n    stats = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, stats))\n\n# Get results and print\nresults = check_records(test_cases)\nfor result in results:\n    print(result)\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome_time(hh, mm):\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        current_time = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(current_time):\n            return hh, mm\n\ndef minutes_until_palindrome(current_time):\n    hh, mm = map(int, current_time.split(':'))\n    count = 0\n    while not is_palindrome(f\"{hh:02}:{mm:02}\"):\n        mm += 1\n        count += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n    return count\n\n# Read input\ncurrent_time = input().strip()\n# Calculate and print the result\nprint(minutes_until_palindrome(current_time))\n```",
    "21": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_index = a.index(1)\nmax_index = a.index(n)\n\n# Calculate the current distance\ncurrent_distance = abs(min_index - max_index)\n\n# Possible new positions after swaps\nnew_positions = [\n    abs(min_index - 0),        # Swap with first element\n    abs(min_index - (n - 1)),  # Swap with last element\n    abs(max_index - 0),        # Swap with first element\n    abs(max_index - (n - 1))   # Swap with last element\n]\n\n# The maximum possible distance after one swap\nmax_distance = max(new_positions)\n\nprint(max(max_distance, current_distance))\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror_chars = {'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M', 'O': 'O', \n                    'o': 'o', 'p': 'q', 'q': 'p', 'R': 'R', 'S': 'S', 'T': 'T', 'U': 'U', \n                    'v': 'v', 'V': 'V', 'w': 'w', 'W': 'W', 'x': 'x', 'Y': 'Y'}\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        left_char = s[i]\n        right_char = s[n - 1 - i]\n        if left_char not in mirror_chars or mirror_chars[left_char] != right_char:\n            print(\"NIE\")\n            return\n    print(\"TAK\")\n\ns = input().strip()\nis_s_palindrome(s)\n```",
    "23": "```python\ndef max_permutation_less_than_b(a, b):\n    from itertools import permutations\n\n    # Convert a to string and create a list of its digits\n    a_str = str(a)\n    b_str = str(b)\n\n    # Generate all unique permutations of the digits of a\n    perms = set(permutations(a_str))\n\n    # Filter permutations to find the maximum valid one not exceeding b\n    max_valid = -1\n    for perm in perms:\n        # Join the tuple of characters back into a string\n        perm_number = int(''.join(perm))\n        # Check if it's valid\n        if perm_number <= b and str(perm_number)[0] != '0' and len(str(perm_number)) == len(a_str):\n            max_valid = max(max_valid, perm_number)\n\n    return max_valid\n\n# Read input\na = int(input().strip())\nb = int(input().strip())\n\n# Get the result and print it\nresult = max_permutation_less_than_b(a, b)\nprint(result)\n```",
    "24": "```python\ndef can_alice_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # right, down, diagonal down-right, diagonal down-left\n    size = 10\n    \n    def check_win(x, y):\n        for dx, dy in directions:\n            count = 1\n            \n            # Check in the positive direction\n            nx, ny = x + dx, y + dy\n            while 0 <= nx < size and 0 <= ny < size and board[nx][ny] == 'X':\n                count += 1\n                nx += dx\n                ny += dy\n            \n            # Check in the negative direction\n            nx, ny = x - dx, y - dy\n            while 0 <= nx < size and 0 <= ny < size and board[nx][ny] == 'X':\n                count += 1\n                nx -= dx\n                ny -= dy\n            \n            if count >= 5:\n                return True\n        return False\n\n    for i in range(size):\n        for j in range(size):\n            if board[i][j] == '.':\n                board[i][j] = 'X'  # Simulate Alice's move\n                if check_win(i, j):\n                    return \"YES\"\n                board[i][j] = '.'  # Undo the move\n\n    return \"NO\"\n\n# Read the input\nboard = [input().strip() for _ in range(10)]\nprint(can_alice_win(board))\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    if k > n * n or k % 2 != 0 and n % 2 == 0:\n        return -1\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k <= 0:\n            break\n        if k >= 2:  # Place 1s on the diagonal and the symmetric position\n            matrix[i][i] = 1\n            k -= 1\n        \n        for j in range(i + 1, n):\n            if k >= 2:  # Place 1s in pairs\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n            \n            if k <= 0:\n                break\n\n    if k > 0:\n        return -1\n\n    return matrix\n\n\n# Input reading\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "26": "```python\nimport math\n\n# Read input\nx, y, z = map(float, input().split())\n\n# Define expressions and their corresponding outputs\nexpressions = [\n    (x**(y**z), \"x^y^z\"),\n    (x**(z**y), \"x^z^y\"),\n    ((x**y)**z, \"(x^y)^z\"),\n    ((x**z)**y, \"(x^z)^y\"),\n    (y**(x**z), \"y^x^z\"),\n    (y**(z**x), \"y^z^x\"),\n    ((y**x)**z, \"(y^x)^z\"),\n    ((y**z)**x, \"(y^z)^x\"),\n    (z**(x**y), \"z^x^y\"),\n    (z**(y**x), \"z^y^x\"),\n    ((z**x)**y, \"(z^x)^y\"),\n    ((z**y)**x, \"(z^y)^x\"),\n]\n\n# Find the maximum value and the smallest index with that value\nmax_value = -float('inf')\nbest_index = -1\n\nfor index, (value, expression) in enumerate(expressions):\n    if value > max_value:\n        max_value = value\n        best_index = index\n\n# Output the corresponding expression\nprint(expressions[best_index][1])\n```",
    "27": "```python\nn = int(input())\ns = input()\n\n# Initialize the minimum operations with the case of typing all characters one by one\nmin_operations = n\n\n# Check for every possible prefix length to see if we can benefit from copying\nfor i in range(1, n):\n    # If the prefix is equal to the substring starting from that point\n    if s[:i] == s[i:i + i]:  # Check if we can copy the prefix\n        # Calculate operations: type the prefix (i) + copy (1) + remaining characters (n - 2*i)\n        operations = i + 1 + (n - 2 * i)\n        min_operations = min(min_operations, operations)\n\n# Print the minimum operations found\nprint(min_operations)\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\n# Separate examples and regular tests\nexamples = []\nregulars = []\nfor name, type_ in files:\n    if type_ == '1':\n        examples.append(name)\n    else:\n        regulars.append(name)\n\ne = len(examples)\nmoves = []\n\n# Rename examples to 1, 2, ..., e\nfor i in range(e):\n    moves.append(f\"move {examples[i]} {i + 1}\")\n\n# Rename regular tests to e + 1, e + 2, ..., n\nfor i in range(len(regulars)):\n    moves.append(f\"move {regulars[i]} {e + i + 1}\")\n\n# Output the results\nprint(len(moves))\nprint(\"\\n\".join(moves))\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    # Calculate the difference\n    diff = abs(sum_first - sum_second)\n    \n    # Create a list of possible changes\n    changes = []\n    \n    if sum_first > sum_second:\n        # We want to reduce the sum of the first half or increase the sum of the second half\n        changes = [9 - d for d in first_half] + [d for d in second_half]\n    else:\n        # We want to reduce the sum of the second half or increase the sum of the first half\n        changes = [9 - d for d in second_half] + [d for d in first_half]\n    \n    # Sort changes in descending order\n    changes.sort(reverse=True)\n    \n    count = 0\n    for change in changes:\n        diff -= change\n        count += 1\n        if diff <= 0:\n            return count\n    \n    return count\n\n# Read input\nticket = input().strip()\n# Output result\nprint(min_replacements_to_lucky(ticket))\n```",
    "30": "```python\ndef min_traps(m, x):\n    # To catch the x-mouse, we need to cover all reachable rooms.\n    # The number of unique rooms visited by the x-mouse is given by Euler's Totient Function.\n    # Since GCD(x, m) = 1, we can directly use m - 1 as the number of traps needed.\n    \n    return m - 1\n\n# Read input\nm, x = map(int, input().split())\n# Output the result\nprint(min_traps(m, x))\n```",
    "31": "```python\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef probability_of_shared_birthday(n, k):\n    MOD = 10**6 + 3\n    days = 1 << n  # This is 2^n\n    \n    if k > days:\n        return (1, 1)  # If k > days, probability is 1\n    \n    # Total ways to choose k birthdays\n    total_ways = pow(days, k, MOD)\n    \n    # Calculate the ways to choose k birthdays with no shared birthday\n    non_shared_ways = 1\n    for i in range(k):\n        non_shared_ways *= (days - i)\n        non_shared_ways %= MOD\n    \n    # Probability of at least two having the same birthday\n    shared_ways = (total_ways - non_shared_ways) % MOD\n    \n    # A and B\n    A = shared_ways\n    B = total_ways\n    \n    # Reduce A/B to its irreducible form\n    divisor = gcd(A, B)\n    A //= divisor\n    B //= divisor\n    \n    return (A % MOD, B % MOD)\n\n# Input reading\nn, k = map(int, input().split())\nresult = probability_of_shared_birthday(n, k)\nprint(result[0], result[1])\n```",
    "32": "```python\nn = int(input())\ncurrent_position = 0  # 0 means North Pole, 20000 means South Pole\n\nvalid = True\n\nfor _ in range(n):\n    t, direction = input().split()\n    t = int(t)\n\n    if current_position == 0 and direction != \"South\":\n        valid = False\n        break\n    if current_position == 20000 and direction != \"North\":\n        valid = False\n        break\n\n    if direction == \"South\":\n        current_position += t\n    elif direction == \"North\":\n        current_position -= t\n    elif direction in [\"West\", \"East\"]:\n        # West and East do not affect the north-south position\n        continue\n\n    if current_position < 0 or current_position > 20000:\n        valid = False\n        break\n\nif valid and current_position == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "33": "```python\ndef count_common_terms(a1, b1, a2, b2, L, R):\n    from math import gcd\n\n    # Normalize the sequences\n    a1, b1 = a1, b1 % a1\n    a2, b2 = a2, b2 % a2\n\n    # Calculate the GCD of the differences\n    g = gcd(a1, a2)\n\n    # Check if the two sequences can produce common terms\n    if (b2 - b1) % g != 0:\n        return 0\n\n    # Find the first term in the intersection of the two sequences\n    x0 = (b2 - b1) // g * (a1 // g) % (a2 // g) * a1 + b1\n    \n    # Generate the first term in the sequence\n    if x0 < L:\n        x0 += ((L - x0 + a1 * a2 // g - 1) // (a1 * a2 // g)) * (a1 * a2 // g)\n    elif x0 > R:\n        return 0\n\n    # Calculate the step size\n    step = a1 * a2 // g\n\n    # Calculate the last term within the range\n    if x0 > R:\n        return 0\n\n    last = R // step * step + (b1 if last % step == b1 else 0)\n\n    # Count the terms\n    if x0 > last:\n        return 0\n\n    return (last - x0) // step + 1\n\n# Input reading\na1, b1, a2, b2, L, R = map(int, input().split())\nresult = count_common_terms(a1, b1, a2, b2, L, R)\nprint(result)\n```",
    "34": "```python\ndef can_distribute(x, n, a, b):\n    # Calculate how many plates can be filled with at least x pieces\n    plates_from_a = a // x\n    plates_from_b = b // x\n    # Check if we can fill at least n plates with the pieces\n    return plates_from_a + plates_from_b >= n\n\ndef maximum_minimum_pieces(n, a, b):\n    left, right = 1, max(a, b)  # x should be at least 1 and at most max(a, b)\n    answer = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_distribute(mid, n, a, b):\n            answer = mid  # mid is a possible solution\n            left = mid + 1  # try for a bigger x\n        else:\n            right = mid - 1  # try for a smaller x\n\n    return answer\n\n# Read input\nn, a, b = map(int, input().split())\n# Get the result and print it\nprint(maximum_minimum_pieces(n, a, b))\n```",
    "35": "```python\ndef is_valid_flag(n, m, flag):\n    # Check for horizontal stripes\n    def check_horizontal():\n        stripe_height = n // 3\n        if n % 3 != 0:\n            return False\n        colors = set()\n        for i in range(3):\n            color = flag[i * stripe_height][0]\n            colors.add(color)\n            for j in range(i * stripe_height, (i + 1) * stripe_height):\n                if flag[j] != color * m:\n                    return False\n        return len(colors) == 3\n\n    # Check for vertical stripes\n    def check_vertical():\n        stripe_width = m // 3\n        if m % 3 != 0:\n            return False\n        colors = set()\n        for i in range(3):\n            color = flag[0][i * stripe_width]\n            colors.add(color)\n            for j in range(m):\n                for k in range(i * stripe_width, (i + 1) * stripe_width):\n                    if flag[j][k] != color:\n                        return False\n        return len(colors) == 3\n\n    return \"YES\" if check_horizontal() or check_vertical() else \"NO\"\n\n# Input reading\nn, m = map(int, input().split())\nflag = [input().strip() for _ in range(n)]\n\n# Output result\nprint(is_valid_flag(n, m, flag))\n```",
    "36": "```python\ndef hexagonal_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 1\n\n    while n >= moves_in_layer:\n        n -= moves_in_layer\n        layer += 1\n        moves_in_layer = 6 * layer\n\n    x, y = layer, 0\n\n    if n == 0:\n        return (x, y)\n\n    # Move to the starting point of the next layer\n    x -= 1\n    n -= 1\n\n    # Each segment of the layer has a length of `layer`\n    # There are 6 segments in total\n    segment_length = layer\n\n    # Determine the segment and the position within the segment\n    segment = n // segment_length\n    position_in_segment = n % segment_length\n\n    # Move based on the segment\n    if segment == 0:  # Right\n        x += position_in_segment\n        y += 0\n    elif segment == 1:  # Top-right\n        x += segment_length\n        y += position_in_segment\n    elif segment == 2:  # Top-left\n        x += segment_length - position_in_segment\n        y += segment_length\n    elif segment == 3:  # Left\n        x -= position_in_segment\n        y += segment_length - position_in_segment\n    elif segment == 4:  # Bottom-left\n        x -= segment_length\n        y -= position_in_segment\n    elif segment == 5:  # Bottom-right\n        x -= segment_length - position_in_segment\n        y -= segment_length\n\n    return (x, y)\n\nn = int(input())\nx, y = hexagonal_coordinates(n)\nprint(x, y)\n```",
    "37": "```python\ndef can_break_shield(a, b, c):\n    for x in range(c // a + 1):\n        if (c - a * x) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\na, b, c = map(int, input().split())\nprint(can_break_shield(a, b, c))\n```",
    "38": "```python\ndef can_run_same_track(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between barriers for Kefa\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    # Calculate the distances between barriers for Sasha\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Check if Kefa's distances can be rotated to match Sasha's distances\n    doubled_kefa_diffs = kefa_diffs * 2\n    for i in range(n):\n        if doubled_kefa_diffs[i:i+n] == sasha_diffs:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_run_same_track(n, L, kefa_distances, sasha_distances))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome(s):\n    n = len(s)\n    \n    # If the string itself is not a palindrome, return its length\n    if not is_palindrome(s):\n        return n\n    \n    # Check if all characters are the same\n    if s.count(s[0]) == n:\n        return 0\n    \n    # The longest non-palindrome substring will be of length n-1\n    return n - 1\n\n# Input\ns = input().strip()\n# Output\nprint(longest_non_palindrome(s))\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if the round is rated\nfor a, b in ratings:\n    if a != b:\n        print(\"rated\")\n        exit()\n\n# Check if the round is unrated\nfor i in range(n - 1):\n    if ratings[i][0] < ratings[i + 1][0]:\n        print(\"unrated\")\n        exit()\n\nprint(\"maybe\")\n```",
    "41": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the distances array with a large number\ndistances = [float('inf')] * n\n\n# First pass: from left to right\nfor i in range(n):\n    if a[i] == 0:\n        distances[i] = 0\n    elif i > 0:\n        distances[i] = distances[i - 1] + 1\n\n# Second pass: from right to left\nfor i in range(n - 1, -1, -1):\n    if a[i] == 0:\n        distances[i] = 0\n    elif i < n - 1:\n        distances[i] = min(distances[i], distances[i + 1] + 1)\n\nprint(\" \".join(map(str, distances)))\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n    \n    m = len(s)\n    count = 0\n    seen = set()\n    \n    # Generate all binary strings of length n\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        # Check for all cyclic shifts of t\n        for i in range(n):\n            if s in t[i:] + t[:i]:\n                # If we found a cyclic shift containing s, add to seen\n                seen.add(t)\n                break\n\n    return len(seen)\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(count_cyclic_strings(n, s))\n```",
    "43": "```python\nimport sys\nimport math\n\ndef angle_between(v1, v2):\n    dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n    magnitude_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n    magnitude_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n    return math.acos(dot_product / (magnitude_v1 * magnitude_v2))\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    vectors = []\n    \n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().strip().split())\n        angle = math.atan2(y, x)\n        vectors.append((angle, i + 1, (x, y)))\n    \n    vectors.sort()  # Sort by angle\n\n    min_angle = float('inf')\n    result = (0, 0)\n    \n    for i in range(n):\n        v1 = vectors[i][2]\n        v2 = vectors[(i + 1) % n][2]\n        angle = angle_between(v1, v2)\n        \n        if angle < min_angle:\n            min_angle = angle\n            result = (vectors[i][1], vectors[(i + 1) % n][1])\n    \n    print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n```",
    "44": "```python\ndef minimal_time(d, k, a, b, t):\n    # Initialize the minimum time\n    min_time = float('inf')\n\n    # Calculate the maximum number of full segments Vasiliy can drive\n    full_segments = d // k\n    remaining_distance = d % k\n\n    # Check all possible ways to drive and walk\n    for segments in range(full_segments + 1):\n        # Distance covered by car\n        distance_by_car = segments * k\n        # Time spent driving\n        time_driving = distance_by_car * a\n        # Time spent repairing the car\n        time_repairing = segments * t\n\n        # Remaining distance that needs to be walked\n        distance_by_foot = d - distance_by_car\n        # Time spent walking\n        time_walking = distance_by_foot * b\n\n        # Total time for this strategy\n        total_time = time_driving + time_repairing + time_walking\n        # Update minimum time found\n        min_time = min(min_time, total_time)\n\n    # Check if he can drive the remaining distance without repair\n    if remaining_distance > 0:\n        time_driving = full_segments * k * a + remaining_distance * a\n        time_repairing = full_segments * t\n        total_time = time_driving + time_repairing\n        min_time = min(min_time, total_time)\n\n    return min_time\n\n# Input\nd, k, a, b, t = map(int, input().split())\n# Output\nprint(minimal_time(d, k, a, b, t))\n```",
    "45": "```python\ndef find_sequence(n, k):\n    if k * (k + 1) // 2 > n:\n        return -1\n    \n    # Calculate the maximum gcd that can be used\n    max_gcd = n // k\n    \n    # Start with the minimum increasing sequence {1, 2, ..., k}\n    seq = list(range(1, k + 1))\n    \n    # Calculate the sum of the initial sequence\n    current_sum = sum(seq)\n    \n    # Calculate the difference needed to reach n\n    difference = n - current_sum\n    \n    # Distribute the difference evenly to maximize gcd\n    if difference > 0:\n        # We can increase each element by the same amount\n        # We can add `difference // k` to each element\n        add = difference // k\n        for i in range(k):\n            seq[i] += add\n        \n        # If there's any remainder, we can distribute it starting from the last element\n        remainder = difference % k\n        for i in range(k - 1, k - 1 - remainder, -1):\n            seq[i] += 1\n    \n    return seq\n\n# Input reading\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "46": "```python\ndef count_divisible_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n    \n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n        \n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n        \n    result = 0\n    for i in range(5):\n        result += count_x[i] * count_y[(5 - i) % 5]\n        \n    return result\n\nn, m = map(int, input().split())\nprint(count_divisible_pairs(n, m))\n```",
    "47": "```python\ndef max_beauty(n, x, a):\n    # Calculate the original maximum subarray sum (Kadane's algorithm)\n    def kadane(arr):\n        max_sum = 0\n        current_sum = 0\n        for value in arr:\n            current_sum += value\n            if current_sum < 0:\n                current_sum = 0\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n\n    original_beauty = kadane(a)\n\n    # If x is non-positive, multiplying by x won't help, return original beauty\n    if x <= 0:\n        return original_beauty\n\n    # Calculate the maximum subarray sum considering multiplication by x\n    max_with_multiplication = float('-inf')\n\n    # Prefix sums and the max sum we can achieve\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    # To find the maximum subarray sum after multiplication by x\n    min_prefix = float('inf')\n    for i in range(n + 1):\n        max_with_multiplication = max(max_with_multiplication, prefix_sum[i] - min_prefix + (prefix_sum[i] - min_prefix) * (x - 1))\n        min_prefix = min(min_prefix, prefix_sum[i])\n\n    return max(original_beauty, max_with_multiplication)\n\n# Reading input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Getting the result and printing it\nresult = max_beauty(n, x, a)\nprint(result)\n```",
    "48": "```python\ndef kth_largest_in_multiplication_table(n, m, k):\n    left, right = 1, n * m\n    \n    while left < right:\n        mid = (left + right) // 2\n        count = 0\n        \n        for i in range(1, n + 1):\n            count += min(mid // i, m)\n        \n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left\n\n# Read input\nn, m, k = map(int, input().split())\n# Get the k-th largest number\nresult = kth_largest_in_multiplication_table(n, m, k)\n# Print the result\nprint(result)\n```",
    "49": "```python\ndef find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n\n    # Determine the length of the number that contains the k-th digit\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    # Find the actual number that contains the k-th digit\n    start += (k - 1) // length\n    num_str = str(start)\n    \n    # Find the specific digit\n    digit_index = (k - 1) % length\n    return num_str[digit_index]\n\nk = int(input())\nprint(find_kth_digit(k))\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph):\n    visited = [-1] * (n + 1)\n    visited[start] = 0\n    queue = deque([start])\n    farthest_node = start\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if visited[neighbor] == -1:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > visited[farthest_node]:\n                    farthest_node = neighbor\n    return farthest_node, visited\n\nn = int(input().strip())\ngraph = defaultdict(list)\n\nfor _ in range(n - 1):\n    a, b = map(int, input().strip().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\n# Step 1: Find the farthest node from an arbitrary node (node 1)\nfarthest_node, _ = bfs(1, graph)\n\n# Step 2: Find the farthest node from the farthest node found\nother_farthest_node, dist_from_first = bfs(farthest_node, graph)\n\n# Step 3: Use the path from farthest_node to other_farthest_node to find the maximum\npath = []\ncurrent = other_farthest_node\nwhile current != farthest_node:\n    path.append(current)\n    for neighbor in graph[current]:\n        if dist_from_first[neighbor] == dist_from_first[current] - 1:\n            current = neighbor\n            break\npath.append(farthest_node)\npath.reverse()\n\n# Step 4: Choose three distinct vertices a, b, c from the path\na = path[0]\nb = path[len(path) // 2]  # Middle of the path\nc = path[-1]\n\n# Step 5: The number of edges in the union of paths is |E| = |V| - 1 + |V| - 1 + |V| - 1 - 3 = 3*len(path) - 3\nres = len(path) - 1 + len(path) - 1 + len(path) - 1 - 3\n\nprint(res)\nprint(a, b, c)\n```",
    "51": "```python\nfrom collections import Counter\n\ndef find_x_y(n, divisors):\n    counter = Counter(divisors)\n    gcd = 1\n    \n    # Finding the GCD of the numbers that appear twice\n    for d in counter:\n        if counter[d] == 2:\n            gcd *= d\n    \n    x = gcd\n    y = 1\n    \n    # Finding the other number using the divisors\n    for d in counter:\n        if counter[d] == 1:\n            y *= d\n\n    return x, y\n\n# Read input\nn = int(input())\ndivisors = list(map(int, input().split()))\n\n# Get x and y\nx, y = find_x_y(n, divisors)\n\n# Print output\nprint(x, y)\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    half_m = m // 2\n    dp = [[-1] * k for _ in range(n + 1)]\n    dp[0][0] = 0  # Base case: sum of 0 is achievable with 0 rows\n\n    for i in range(1, n + 1):\n        row = sorted(matrix[i - 1], reverse=True)\n        for j in range(half_m + 1):\n            current_sum = sum(row[:j])\n            for r in range(k):\n                if dp[i - 1][r] != -1:  # If the previous sum is achievable\n                    new_sum = dp[i - 1][r] + current_sum\n                    new_mod = new_sum % k\n                    if dp[i][new_mod] == -1 or new_sum > dp[i][new_mod]:\n                        dp[i][new_mod] = new_sum\n                        \n        # Copy previous row values to current row for no-selection case\n        for r in range(k):\n            if dp[i - 1][r] != -1:\n                if dp[i][r] == -1 or dp[i - 1][r] > dp[i][r]:\n                    dp[i][r] = dp[i - 1][r]\n    \n    # The result will be the maximum sum that is divisible by k\n    return dp[n][0] if dp[n][0] != -1 else 0\n\n# Input parsing\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nresult = max_sum_divisible_by_k(n, m, k, matrix)\nprint(result)\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = -1\n    moves = []\n    \n    while left <= right:\n        if a[left] < a[right]:\n            if a[left] > last_taken:\n                moves.append('L')\n                last_taken = a[left]\n                left += 1\n            elif a[right] > last_taken:\n                moves.append('R')\n                last_taken = a[right]\n                right -= 1\n            else:\n                break\n        else:\n            if a[right] > last_taken:\n                moves.append('R')\n                last_taken = a[right]\n                right -= 1\n            elif a[left] > last_taken:\n                moves.append('L')\n                last_taken = a[left]\n                left += 1\n            else:\n                break\n    \n    print(len(moves))\n    print(''.join(moves))\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\nlongest_increasing_sequence(n, a)\n```",
    "54": "```python\ndef find_minimum_D(n, a):\n    min_a = min(a)\n    max_a = max(a)\n    \n    if min_a == max_a:\n        return 0\n    \n    # Calculate the difference\n    diff = max_a - min_a\n    \n    # If the difference is odd, we cannot split it evenly into two parts\n    if diff % 2 != 0:\n        return -1\n    \n    # The required D is half of the difference\n    D = diff // 2\n    return D\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Finding and printing the result\nresult = find_minimum_D(n, a)\nprint(result)\n```",
    "55": "```python\ndef is_visible(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n    # Check if there is any part of the white sheet that is not covered by both black sheets\n    # The white sheet is visible if it has any area that is outside both black sheets\n    \n    # Check if the entire white sheet is covered by the first black sheet\n    covered_by_first = (x3 < x1 < x4 and y3 < y1 < y4) and (x3 < x2 < x4 and y3 < y2 < y4)\n    # Check if the entire white sheet is covered by the second black sheet\n    covered_by_second = (x5 < x1 < x6 and y5 < y1 < y6) and (x5 < x2 < x6 and y5 < y2 < y6)\n    \n    # If both black sheets cover the white sheet completely, it's not visible\n    if covered_by_first and covered_by_second:\n        return \"NO\"\n    \n    # Check for visibility on the left side of the white sheet\n    if (x3 >= x2 or x5 >= x2) or (y3 >= y2 or y5 >= y2) or (x3 <= x1 and x5 <= x1):\n        return \"YES\"\n    \n    # Check for visibility on the right side of the white sheet\n    if (x4 <= x1 or x6 <= x1) or (y4 <= y1 or y6 <= y1) or (x4 >= x2 and x6 >= x2):\n        return \"YES\"\n    \n    # Check for visibility on the top side of the white sheet\n    if (y3 <= y1 or y4 <= y1 or y5 <= y1 or y6 <= y1) or (y3 >= y2 and y4 >= y2 and y5 >= y2 and y6 >= y2):\n        return \"YES\"\n    \n    # Check for visibility on the bottom side of the white sheet\n    if (y3 >= y2 or y5 >= y2) or (x3 >= x2 and x5 >= x2):\n        return \"YES\"\n\n    return \"NO\"\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Output the result\nprint(is_visible(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6))\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef count_reachable(n):\n    reachable = set()\n    current = n\n    \n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    \n    return len(reachable)\n\nn = int(input())\nprint(count_reachable(n))\n```",
    "57": "```python\ndef fill_gift_choices(n, f):\n    # Find the indices of friends who don't know whom to give gifts to (f_i = 0)\n    unknown_indices = [i for i in range(n) if f[i] == 0]\n    \n    # Create a set of all possible friends (1 to n)\n    all_friends = set(range(1, n + 1))\n    \n    # Find the set of friends who already have a known gift target\n    known_gift_targets = set(f[i] for i in range(n) if f[i] != 0)\n    \n    # Find the remaining friends who need to receive gifts\n    remaining_friends = list(all_friends - known_gift_targets)\n    \n    # Fill in the unknowns\n    for i in range(len(unknown_indices)):\n        friend_idx = unknown_indices[i]\n        # Assign the gift target ensuring no one gives a gift to themselves\n        f[friend_idx] = remaining_friends[i]\n\n    return f\n\n# Input reading\nn = int(input())\nf = list(map(int, input().split()))\n\n# Process and output the result\nresult = fill_gift_choices(n, f)\nprint(\" \".join(map(str, result)))\n```",
    "58": "```python\ndef color_array(n, k, a):\n    from collections import defaultdict\n\n    # Map to keep track of the occurrences of each number\n    occurrence = defaultdict(list)\n\n    # Fill the occurrence map\n    for index, value in enumerate(a):\n        occurrence[value].append(index)\n\n    # Check if we can color the array\n    if len(occurrence) > k:\n        print(\"NO\")\n        return\n\n    # Prepare the result array\n    result = [0] * n\n    color = 1\n\n    # Assign colors\n    for numbers in occurrence.values():\n        for i, index in enumerate(numbers):\n            result[index] = (i % k) + 1\n\n    print(\"YES\")\n    print(' '.join(map(str, result)))\n\n# Example usage with input reading\nn, k = map(int, input().split())\na = list(map(int, input().split()))\ncolor_array(n, k, a)\n```",
    "59": "```python\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# We need to ensure that the last y digits are 0s and the digit at position y (counting from 0) is 1\n# The last x digits should be 0s except for the y-th digit which should be 1\n\n# Count the number of changes needed\nchanges = 0\n\n# Check the last y digits for 0s\nfor i in range(y):\n    if number[n - 1 - i] != '0':\n        changes += 1\n\n# Check the y-th digit for 1\nif number[n - 1 - y] != '1':\n    changes += 1\n\n# Check the remaining (x - y - 1) digits for 0s\nfor i in range(y + 1, x):\n    if number[n - 1 - i] != '0':\n        changes += 1\n\nprint(changes)\n```",
    "60": "```python\ndef has_palindrome_subsequence(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        found = False\n        # Check for any element that appears at least twice with at least one element between them\n        first_occurrence = {}\n        for i in range(n):\n            if a[i] in first_occurrence:\n                # If we've seen this element before and it's not adjacent, we found a palindrome\n                if i - first_occurrence[a[i]] > 1:\n                    found = True\n                    break\n            # Record the first occurrence of the element\n            first_occurrence[a[i]] = i\n        \n        results.append(\"YES\" if found else \"NO\")\n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Get results\nresults = has_palindrome_subsequence(t, test_cases)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "61": "```python\ndef max_transformed_number(n, a, f):\n    # Convert the function into a mapping from digit to its transformed value\n    f_map = {str(i + 1): str(f[i]) for i in range(9)}\n    \n    # Create a list to store the transformed number\n    transformed = []\n    transformation_started = False\n    \n    for digit in a:\n        if not transformation_started and f_map[digit] > digit:\n            # Start transforming if the current digit can be improved\n            transformation_started = True\n        if transformation_started:\n            # Replace the digit with its transformed value\n            transformed.append(f_map[digit])\n        else:\n            transformed.append(digit)\n    \n    # If we finished transforming and the transformation was started\n    # We should ensure we keep transforming till the end if it's beneficial\n    if transformation_started:\n        for i in range(len(transformed)):\n            if transformed[i] < a[i]:\n                break\n            transformed[i] = f_map[a[i]]\n    \n    result = ''.join(transformed)\n    return result\n\n# Input reading\nn = int(input().strip())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\n# Getting the result\nresult = max_transformed_number(n, a, f)\n\n# Printing the result\nprint(result)\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        # Initialize minimum operations and best triple\n        min_ops = float('inf')\n        best_triple = (0, 0, 0)\n\n        # Iterate over possible values for A\n        for A in range(1, a + 1):\n            # B must be a multiple of A, find suitable B\n            for B in range(A, c + 1, A):\n                # C must be a multiple of B, find suitable C\n                for C in range(B, c + 1, B):\n                    # Calculate operations needed\n                    ops = abs(A - a) + abs(B - b) + abs(C - c)\n                    if ops < min_ops:\n                        min_ops = ops\n                        best_triple = (A, B, C)\n\n        results.append((min_ops, best_triple))\n\n    return results\n\n# Input reading\nt = int(input().strip())\ntest_cases = [tuple(map(int, input().strip().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations(t, test_cases)\n\n# Output results\nfor res in results:\n    print(res[0])\n    print(*res[1])\n```",
    "63": "```python\ndef min_instability(n, a):\n    a.sort()\n    return min(a[-1] - a[1], a[-2] - a[0])\n\nn = int(input())\na = list(map(int, input().split()))\nprint(min_instability(n, a))\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    # Create a schedule initialized to rest days\n    schedule = [0] * n\n    \n    # Sort exams by their exam day\n    exams = sorted(exams, key=lambda x: x[1])\n    \n    # Keep track of preparation days needed\n    preparation_needed = [0] * m\n    \n    for i in range(m):\n        s_i, d_i, c_i = exams[i]\n        preparation_needed[i] = c_i  # days needed for preparation\n        # Mark the exam day\n        schedule[d_i - 1] = m + 1  # m + 1 indicates it's an exam day\n    \n    # Try to allocate preparation days\n    for i in range(m):\n        s_i, d_i, c_i = exams[i]\n        days_allocated = 0\n        \n        # Allocate preparation days from s_i to d_i - 1\n        for j in range(s_i - 1, d_i - 1):\n            if days_allocated < c_i and schedule[j] == 0:\n                schedule[j] = i + 1  # Mark as preparing for exam i + 1\n                days_allocated += 1\n        \n        # Check if we allocated enough preparation days\n        if days_allocated < c_i:\n            return -1  # Not enough preparation days\n\n    return schedule\n\n# Read input\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the schedule\nresult = schedule_exams(n, m, exams)\n\n# Print output\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "65": "```python\ndef game_23(n, m):\n    if m % n != 0:\n        return -1\n    \n    ratio = m // n\n    count_2 = 0\n    count_3 = 0\n    \n    while ratio % 2 == 0:\n        ratio //= 2\n        count_2 += 1\n        \n    while ratio % 3 == 0:\n        ratio //= 3\n        count_3 += 1\n    \n    if ratio != 1:\n        return -1\n    \n    return count_2 + count_3\n\n# Read input\nn, m = map(int, input().split())\n# Get the result and print it\nprint(game_23(n, m))\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Find the longest suffix of t that is also a prefix\n    for i in range(n - 1, -1, -1):\n        if t[:i] == t[-i:]:\n            overlap_length = i\n            break\n    else:\n        overlap_length = 0\n\n    # Construct the result string\n    result = t + (t[overlap_length:] * (k - 1))\n    return result\n\n# Read input\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the result and print it\nresult = construct_string(n, k, t)\nprint(result)\n```",
    "67": "```python\ndef find_nice_indices(n, a):\n    total_sum = sum(a)\n    nice_indices = []\n\n    for i in range(n):\n        remaining_sum = total_sum - a[i]\n        if remaining_sum == a[i] * 2:\n            nice_indices.append(i + 1)\n\n    return nice_indices\n\n# Read input\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Find nice indices\nnice_indices = find_nice_indices(n, a)\n\n# Output the results\nprint(len(nice_indices))\nif nice_indices:\n    print(' '.join(map(str, nice_indices)))\n```",
    "68": "```python\ndef min_cost_to_form_set(n, k, s):\n    # Function to calculate the number of distinct subsequences and their costs\n    from collections import Counter\n\n    # Count frequency of each character\n    freq = Counter(s)\n\n    # Initialize variables for total cost and total subsequences\n    total_cost = 0\n    total_subsequences = 0\n    \n    # Calculate distinct subsequences\n    for length in range(1, n + 1):\n        # Number of distinct subsequences of a given length\n        distinct_count = 0\n        for char, count in freq.items():\n            if count >= length:\n                distinct_count += 1\n\n        if distinct_count == 0:\n            break\n\n        # Each subsequence of length `length` has a cost of `n - length`\n        cost_for_this_length = (n - length) * distinct_count\n\n        if total_subsequences + distinct_count < k:\n            total_subsequences += distinct_count\n            total_cost += cost_for_this_length\n        else:\n            # If we can fulfill k with this length\n            needed = k - total_subsequences\n            total_cost += (n - length) * needed\n            break\n\n    # If we could not reach k distinct subsequences\n    if total_subsequences < k:\n        return -1\n    return total_cost\n\n# Reading input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_form_set(n, k, s))\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    if len(graph[1]) < D:\n        print(\"NO\")\n        return\n\n    # Start with vertex 1 and try to build the spanning tree\n    chosen_edges = []\n    degree_count = {i: 0 for i in range(1, n + 1)}\n    degree_count[1] = 0\n\n    # Select D edges from vertex 1\n    for neighbor in graph[1][:D]:\n        chosen_edges.append((1, neighbor))\n        degree_count[1] += 1\n        degree_count[neighbor] += 1\n\n    # Now we need to add edges for the remaining vertices to connect them\n    visited = set([1] + [neighbor for neighbor in graph[1][:D]])\n    queue = deque()\n\n    # Add remaining neighbors of vertex 1 to the queue to explore\n    for neighbor in graph[1][D:]:\n        if degree_count[neighbor] == 0:\n            queue.append(neighbor)\n\n    for i in range(2, n + 1):\n        if i not in visited:\n            queue.append(i)\n\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if degree_count[neighbor] < 1 and neighbor not in visited:\n                chosen_edges.append((current, neighbor))\n                degree_count[current] += 1\n                degree_count[neighbor] += 1\n                visited.add(neighbor)\n                if len(chosen_edges) == n - 1:\n                    break\n        if len(chosen_edges) == n - 1:\n            break\n\n    if len(chosen_edges) != n - 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for u, v in chosen_edges:\n            print(u, v)\n\n# Example usage:\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nfind_spanning_tree(n, m, D, edges)\n```",
    "70": "```python\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Convert start and end times to total minutes\nstart_minutes = h1 * 60 + m1\nend_minutes = h2 * 60 + m2\n\n# Calculate the midpoint in total minutes\nmidpoint_minutes = (start_minutes + end_minutes) // 2\n\n# Convert back to hours and minutes\nh3 = midpoint_minutes // 60\nm3 = midpoint_minutes % 60\n\n# Print result in the required format\nprint(f\"{h3:02}:{m3:02}\")\n```",
    "71": "```python\na = int(input())\noutput = (a - 1).bit_length()\nprint(output)\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    # Create lists to store the left and right ends of the segments\n    left_ends = [segments[i][0] for i in range(n)]\n    right_ends = [segments[i][1] for i in range(n)]\n    \n    # Compute prefix and suffix maximums and minimums\n    max_left_prefix = [0] * n\n    min_right_prefix = [0] * n\n    max_left_suffix = [0] * n\n    min_right_suffix = [0] * n\n\n    max_left_prefix[0] = left_ends[0]\n    min_right_prefix[0] = right_ends[0]\n    \n    for i in range(1, n):\n        max_left_prefix[i] = max(max_left_prefix[i - 1], left_ends[i])\n        min_right_prefix[i] = min(min_right_prefix[i - 1], right_ends[i])\n\n    max_left_suffix[n - 1] = left_ends[n - 1]\n    min_right_suffix[n - 1] = right_ends[n - 1]\n    \n    for i in range(n - 2, -1, -1):\n        max_left_suffix[i] = max(max_left_suffix[i + 1], left_ends[i])\n        min_right_suffix[i] = min(min_right_suffix[i + 1], right_ends[i])\n    \n    max_length = 0\n    \n    for i in range(n):\n        if i == 0:\n            max_left = max_left_suffix[1]\n            min_right = min_right_suffix[1]\n        elif i == n - 1:\n            max_left = max_left_prefix[n - 2]\n            min_right = min_right_prefix[n - 2]\n        else:\n            max_left = max(max_left_prefix[i - 1], max_left_suffix[i + 1])\n            min_right = min(min_right_prefix[i - 1], min_right_suffix[i + 1])\n\n        intersection_length = max(0, min_right - max_left)\n        max_length = max(max_length, intersection_length)\n    \n    return max_length\n\n# Read input\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(max_intersection_length(n, segments))\n```",
    "73": "```python\ndef can_complete_wall(n, heights):\n    max_height = max(heights)\n    total_bricks_needed = 0\n    total_bricks_available = 0\n\n    for height in heights:\n        total_bricks_needed += max_height - height\n        total_bricks_available += height\n\n    if total_bricks_needed <= total_bricks_available:\n        return \"YES\"\n    else:\n        return \"NO\"\n\nn = int(input())\nheights = list(map(int, input().split()))\nprint(can_complete_wall(n, heights))\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    unique_subsequences = set()\n    \n    # Generate all unique subsequences\n    for i in range(1 << n):  # There are 2^n possible subsequences\n        subseq = []\n        for j in range(n):\n            if i & (1 << j):\n                subseq.append(s[j])\n        unique_subsequences.add(''.join(subseq))\n    \n    if len(unique_subsequences) < k:\n        return -1\n    \n    # Sort the unique subsequences based on their length (ascending)\n    sorted_subsequences = sorted(unique_subsequences, key=len)\n    \n    total_cost = 0\n    for i in range(k):\n        total_cost += n - len(sorted_subsequences[i])\n    \n    return total_cost\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Food schedule for each day of the week\n    food_schedule = [0, 0, 1, 0, 0, 2, 0]  # 0: fish, 1: rabbit, 2: chicken\n    food_count = [a, b, c]\n    \n    # Calculate full weeks\n    full_weeks = min(a // 3, b // 2, c // 1)\n    days = full_weeks * 7\n    a -= full_weeks * 3\n    b -= full_weeks * 2\n    c -= full_weeks * 1\n    \n    max_extra_days = 0\n    \n    # Test starting from each day of the week\n    for start_day in range(7):\n        current_a, current_b, current_c = a, b, c\n        extra_days = 0\n        \n        for day in range(7):  # Only need to check 7 days max\n            food_type = food_schedule[(start_day + day) % 7]\n            if food_type == 0 and current_a > 0:\n                current_a -= 1\n                extra_days += 1\n            elif food_type == 1 and current_b > 0:\n                current_b -= 1\n                extra_days += 1\n            elif food_type == 2 and current_c > 0:\n                current_c -= 1\n                extra_days += 1\n            else:\n                break\n        \n        max_extra_days = max(max_extra_days, extra_days)\n    \n    return days + max_extra_days\n\n# Input reading\na, b, c = map(int, input().split())\nprint(max_days(a, b, c))\n```",
    "76": "```python\ndef can_construct_square(n, m, tiles):\n    if m % 2 != 0:\n        return \"NO\"\n    \n    tile_dict = {}\n    for tile in tiles:\n        top_left, top_right = tile[0]\n        bottom_left, bottom_right = tile[1]\n        \n        # Check symmetry conditions\n        if (top_right, bottom_left) not in tile_dict:\n            tile_dict[(top_left, top_right)] = (bottom_left, bottom_right)\n    \n    for (top_left, top_right), (bottom_left, bottom_right) in tile_dict.items():\n        if top_right == bottom_left and top_left == bottom_right:\n            return \"YES\"\n    \n    return \"NO\"\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        tile_top = tuple(map(int, input().split()))\n        tile_bottom = tuple(map(int, input().split()))\n        tiles.append((tile_top, tile_bottom))\n    \n    results.append(can_construct_square(n, m, tiles))\n\nprint(\"\\n\".join(results))\n```",
    "77": "```python\ndef minimum_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nn = int(input().strip())\nprint(minimum_difference(n))\n```",
    "78": "```python\ndef count_regular_sequences(n, s):\n    MOD = 1000000007\n    m = len(s)\n    \n    # Precompute the number of valid bracket sequences of length 2k\n    dp = [0] * (n + 1)\n    dp[0] = 1  # Base case: one valid sequence of length 0 (the empty sequence)\n    \n    for k in range(1, n + 1):\n        for j in range(k):\n            dp[k] = (dp[k] + dp[j] * dp[k - 1 - j]) % MOD\n    \n    # Check if the string s can be a substring of a valid sequence of length 2n\n    bal = 0\n    min_bal = 0\n    for char in s:\n        if char == '(':\n            bal += 1\n        else:\n            bal -= 1\n        min_bal = min(min_bal, bal)\n    \n    # If the balance is negative or the final balance is not zero, return 0\n    if bal < 0 or bal > n or (n - bal) < 0 or (n - bal) % 2 != 0:\n        return 0\n    \n    # Calculate the necessary opening and closing brackets\n    open_needed = (n - bal) // 2\n    close_needed = n - open_needed\n    \n    if open_needed < 0 or close_needed < 0 or open_needed + close_needed != n:\n        return 0\n    \n    # Count valid sequences\n    total_sequences = dp[n]\n    \n    # Now, we need to calculate the valid sequences that can be formed around s\n    count = 0\n    for i in range(max(0, open_needed - min_bal), min(open_needed, n - m + 1) + 1):\n        left_open = open_needed - i\n        right_open = n - (m + left_open)\n        if right_open < 0:\n            continue\n        count = (count + dp[left_open] * dp[right_open]) % MOD\n    \n    return count\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_regular_sequences(n, s))\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    best_moves = float('inf')\n    \n    # Check for valid pairs (00, 25, 50, 75)\n    targets = ['00', '25', '50', '75']\n    \n    for target in targets:\n        last_digit = target[1]\n        second_last_digit = target[0]\n        \n        # Find the positions of the last and second last digits\n        last_index = -1\n        second_last_index = -1\n        \n        for i in range(length-1, -1, -1):\n            if s[i] == last_digit and last_index == -1:\n                last_index = i\n            elif s[i] == second_last_digit and last_index != -1:\n                second_last_index = i\n                # We can stop once we found both digits\n                break\n        \n        if last_index != -1 and second_last_index != -1:\n            # Calculate moves: \n            # We need to bring second_last_index to just before last_index\n            moves = (length - 1 - last_index) + (last_index - second_last_index - 1)\n            best_moves = min(best_moves, moves)\n    \n    return best_moves if best_moves != float('inf') else -1\n\n# Input reading\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    # To hold the color assignments\n    colors = [0] * n\n    \n    # To track the last index of each character\n    last_index = {}\n    \n    # Assign initial colors based on the last occurrence of each character\n    for i in range(n):\n        char = s[i]\n        if char not in last_index:\n            last_index[char] = []\n        last_index[char].append(i)\n    \n    # The maximum number of colors needed\n    max_colors = 1\n    \n    # Now we will assign colors based on the segments of characters\n    for indices in last_index.values():\n        # If there are multiple indices for the same character\n        for j in range(len(indices)):\n            if j == 0:\n                colors[indices[j]] = max_colors\n            else:\n                # Check if we need a new color\n                if indices[j] > indices[j - 1] + 1:\n                    max_colors += 1\n                colors[indices[j]] = max_colors\n    \n    return max_colors, colors\n\n# Read input\nn = int(input())\ns = input()\n\n# Get the result\nres, color_assignment = min_colors_to_sort(n, s)\n\n# Print output\nprint(res)\nprint(\" \".join(map(str, color_assignment)))\n```",
    "81": "```python\ndef can_reorder_strings(strings):\n    # Sort strings by their lengths\n    strings.sort(key=len)\n    \n    # Check if the order is valid\n    for i in range(len(strings)):\n        for j in range(i):\n            if strings[j] not in strings[i]:\n                return \"NO\"\n    \n    # If valid, return the ordered strings\n    return \"YES\", strings\n\n# Read input\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\n# Get the result\nresult = can_reorder_strings(strings)\n\n# Print the result\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for s in result[1]:\n        print(s)\n```",
    "82": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nsolved = 0\n\n# Solve problems from the left\nwhile solved < n and a[solved] <= k:\n    solved += 1\n\n# Solve problems from the right\nwhile solved < n and a[n - 1 - (solved - (n - len(a)))] <= k:\n    solved += 1\n\n# Adjust for double counting if both ends are solvable\nif solved > n:\n    solved = n\n\nprint(solved)\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n    \n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            # Check for red rectangle with width and height\n            if a <= width * height:\n                red_width = min(width, a)\n                red_height = (a + red_width - 1) // red_width\n                if red_height <= height:\n                    perimeter = 2 * (width + height)\n                    min_perimeter = min(min_perimeter, perimeter)\n                    \n            # Check for blue rectangle with width and height\n            if b <= width * height:\n                blue_width = min(width, b)\n                blue_height = (b + blue_width - 1) // blue_width\n                if blue_height <= height:\n                    perimeter = 2 * (width + height)\n                    min_perimeter = min(min_perimeter, perimeter)\n    \n    return min_perimeter\n\n# Input\na, b = map(int, input().strip().split())\n# Output\nprint(minimal_perimeter(a, b))\n```",
    "84": "```python\ndef can_color_string(n, s):\n    # Create a list to hold the count of each character\n    count = {}\n    for char in s:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n\n    # Check if we can color the string\n    color = []\n    for i in range(n):\n        if i > 0 and s[i] < s[i - 1]:\n            # If current character is less than previous, we need to color differently\n            if color and color[-1] == '0':\n                color.append('1')\n            else:\n                color.append('0')\n        else:\n            color.append('0')\n\n    # Check if there are any adjacent characters that are the same but have different colors\n    for i in range(1, n):\n        if s[i] == s[i - 1] and color[i] != color[i - 1]:\n            return \"NO\"\n\n    return \"YES\\n\" + ''.join(color)\n\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result and print it\nresult = can_color_string(n, s)\nprint(result)\n```",
    "85": "```python\nimport sys\nimport math\n\n# Read input\nA, B = map(int, sys.stdin.read().strip().split())\n\n# Initialize the minimum price found\nmin_price = -1\n\n# Check all prices from 1 to 1000 (since A and B are <= 100, we can limit the search)\nfor price in range(1, 1001):\n    tax_8 = math.floor(price * 0.08)\n    tax_10 = math.floor(price * 0.1)\n    \n    if tax_8 == A and tax_10 == B:\n        if min_price == -1 or price < min_price:\n            min_price = price\n\n# Output the result\nprint(min_price)\n```",
    "86": "```python\ndef polycarp_training(n, k):\n    # Calculate the minimum sum of problems required with the given constraints\n    min_sum = k * (k + 1) // 2  # Minimum problems if we solve 1, 2, ..., k problems\n    if n < min_sum:\n        print(\"NO\")\n        return\n\n    # Start with the minimum valid array\n    a = list(range(1, k + 1))\n    current_sum = min_sum\n\n    # Distribute the remaining problems\n    remaining = n - current_sum\n\n    for i in range(k - 1, -1, -1):\n        # Max we can add to a[i] is 2 * a[i] - a[i] = a[i] (to satisfy a[i] < a[i+1] <= 2 * a[i])\n        max_increase = a[i]  # We can at most double the previous day's count\n        if remaining > 0:\n            increase = min(max_increase, remaining)\n            a[i] += increase\n            remaining -= increase\n\n    if remaining > 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n\n# Example usage\nn, k = map(int, input().split())\npolycarp_training(n, k)\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects by their required rating a_i\n    projects.sort(key=lambda x: x[0])\n    \n    count = 0\n    current_rating = r\n    \n    for a, b in projects:\n        if current_rating >= a:  # Check if Polycarp can start the project\n            count += 1  # Increment the count of projects\n            current_rating += b  # Update the rating after completing the project\n            if current_rating < 0:  # Ensure rating does not drop below zero\n                current_rating = 0\n    \n    return count\n\n# Read input\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = max_projects(n, r, projects)\nprint(result)\n```",
    "88": "```python\ndef construct_palindromic_matrix(n, numbers):\n    from collections import Counter\n    \n    # Count occurrences of each number\n    count = Counter(numbers)\n    \n    # Check for impossible conditions\n    odd_count = sum(1 for v in count.values() if v % 2 != 0)\n    \n    # For an n x n matrix, we can have at most one odd-count number if n is odd\n    if (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n        return \"NO\"\n    \n    # Create a list of half of the palindromic matrix\n    half_matrix = []\n    center_row = [0] * n if n % 2 == 1 else None\n    \n    # Fill the half matrix and center row if needed\n    for value, cnt in count.items():\n        pairs = cnt // 2\n        for _ in range(pairs):\n            half_matrix.append(value)\n        \n        if cnt % 2 == 1:\n            if n % 2 == 1:\n                center_row[n // 2] = value  # Place in the center for odd n\n            else:\n                return \"NO\"  # Can't have an odd count in even n\n\n    # Prepare the full matrix\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Fill the half matrix into the top-left quadrant\n    idx = 0\n    for i in range(n):\n        for j in range(n):\n            if i <= n // 2 and j <= n // 2:\n                if i == n - 1 - i and j == n - 1 - j:\n                    # Center cell for odd n\n                    matrix[i][j] = center_row[j] if center_row else 0\n                elif i == n - 1 - i:\n                    # Fill the row in the middle\n                    matrix[i][j] = half_matrix[idx]\n                    matrix[i][n - 1 - j] = half_matrix[idx]\n                    idx += 1\n                elif j == n - 1 - j:\n                    # Fill the column in the middle\n                    matrix[i][j] = half_matrix[idx]\n                    matrix[n - 1 - i][j] = half_matrix[idx]\n                    idx += 1\n                else:\n                    matrix[i][j] = half_matrix[idx]\n                    matrix[n - 1 - i][j] = half_matrix[idx]\n                    matrix[i][n - 1 - j] = half_matrix[idx]\n                    matrix[n - 1 - i][n - 1 - j] = half_matrix[idx]\n                    idx += 1\n\n    return \"YES\", matrix\n\nn = int(input())\nnumbers = list(map(int, input().split()))\n\nresult = construct_palindromic_matrix(n, numbers)\n\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for row in result[1]:\n        print(\" \".join(map(str, row)))\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects based on the required rating (a_i)\n    projects.sort(key=lambda x: x[0])\n    \n    for a, b in projects:\n        if r < a:  # If current rating is less than required for the project\n            return \"NO\"\n        r += b  # Update rating after completing the project\n        if r < 0:  # Rating should not fall below zero\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if all projects can be completed\nresult = can_complete_projects(n, r, projects)\nprint(result)\n```",
    "90": "```python\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Initialize the river cells with zeros\na = [0] * n\n\n# Calculate the total length of platforms\ntotal_length = sum(c)\n\n# Check if we can reach n + 1\nif total_length + (m - 1) * d < n:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    \n    # Place platforms in the array\n    position = 0\n    for i in range(m):\n        # Set the platform index in the cells\n        for j in range(c[i]):\n            a[position] = i + 1\n            position += 1\n        # Move the position by d after each platform, if not the last platform\n        if i < m - 1:\n            position += d\n            \n    print(' '.join(map(str, a)))\n```",
    "91": "```python\ndef max_remove_length(s, t):\n    n, m = len(s), len(t)\n    \n    # Precompute the indices of t in s from the left\n    left = [-1] * m\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n    \n    # Precompute the indices of t in s from the right\n    right = [-1] * m\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n    \n    # Calculate the maximum removable length\n    max_removable = 0\n    for i in range(m - 1):\n        max_removable = max(max_removable, right[i + 1] - left[i] - 1)\n    \n    return max_removable\n\n# Read input\ns = input().strip()\nt = input().strip()\n\n# Get the result and print it\nprint(max_remove_length(s, t))\n```",
    "92": "```python\nx = float(input().strip())\n\n# Calculate the first integer a (1 to 10)\na = int(x) + 1\n\n# Calculate the second integer b (1 to 10)\nb = round((x - a) * 10) % 10 + 1\n\n# Adjust if b is 0\nif b == 0:\n    b = 1\n\nprint(a, b)\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1 or (d > n - 1) or (n > k * (d // 2 + 1)):\n        return \"NO\"\n    \n    edges = []\n    \n    # Create the main path with length d\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n    \n    # Now we have a path of length d, vertices are from 1 to d + 1\n    last_vertex = d + 2\n    \n    # Now we need to attach the remaining vertices\n    for i in range(1, d + 2):\n        if last_vertex > n:\n            break\n        while len([e for e in edges if e[0] == i or e[1] == i]) < k and last_vertex <= n:\n            edges.append((i, last_vertex))\n            last_vertex += 1\n    \n    if last_vertex <= n:\n        return \"NO\"\n    \n    result = [\"YES\"]\n    for u, v in edges:\n        result.append(f\"{u} {v}\")\n    \n    return \"\\n\".join(result)\n\n# Read input\nn, d, k = map(int, input().split())\nprint(construct_tree(n, d, k))\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Start with an empty string\n    s = []\n    \n    # Determine the initial character based on the maximum count\n    if a > b:\n        current_char = '0'\n    else:\n        current_char = '1'\n    \n    # The number of transitions we need to create\n    transitions = min(x, a + b - 1)\n    \n    # Create a sequence that ensures we have the desired number of transitions\n    for i in range(transitions + 1):\n        s.append(current_char)\n        # Toggle between '0' and '1'\n        current_char = '1' if current_char == '0' else '0'\n    \n    # Count how many we've added\n    added_zeros = s.count('0')\n    added_ones = s.count('1')\n    \n    # Fill in the remaining zeros or ones\n    if current_char == '0':\n        remaining = a - added_zeros\n        s += ['0'] * remaining\n        remaining = b - added_ones\n        s += ['1'] * remaining\n    else:\n        remaining = b - added_ones\n        s += ['1'] * remaining\n        remaining = a - added_zeros\n        s += ['0'] * remaining\n    \n    # Join the list into a string and print it\n    print(''.join(s))\n\n# Read input\na, b, x = map(int, input().split())\nconstruct_binary_string(a, b, x)\n```",
    "95": "```python\ndef can_construct_string(n, s, t):\n    # Create a base string with n 'a's, n 'b's, and n 'c's\n    base = 'a' * n + 'b' * n + 'c' * n\n    \n    # Check if we can find positions to create a valid string\n    # We can use a simple approach to rearrange\n    for i in range(3):\n        for j in range(3):\n            if i != j:\n                # Create a potential result by interleaving different characters\n                res = []\n                for k in range(n):\n                    res.append(chr(97 + i))  # 'a' + i\n                    res.append(chr(97 + j))  # 'a' + j\n                res.append(chr(97 + (3 - i - j)))  # add the remaining character\n                result = ''.join(res)\n                \n                # Check if neither s nor t is a substring\n                if s not in result and t not in result:\n                    return \"YES\", result\n    \n    return \"NO\", \"\"\n\n# Read input\nn = int(input().strip())\ns = input().strip()\nt = input().strip()\n\n# Generate and print the result\nresult = can_construct_string(n, s, t)\nprint(result[0])\nif result[0] == \"YES\":\n    print(result[1])\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    p = [0] * n\n    p[0] = 0  # Start with an arbitrary value\n\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n\n    # Normalize the permutation to start from 1\n    min_value = min(p)\n    shift = 1 - min_value\n\n    for i in range(n):\n        p[i] += shift\n\n    # Check if p is a valid permutation\n    if len(set(p)) == n and all(1 <= x <= n for x in p):\n        print(\" \".join(map(str, p)))\n    else:\n        print(-1)\n\n# Input reading\nn = int(input())\nq = list(map(int, input().split()))\n\nrestore_permutation(n, q)\n```",
    "97": "```python\ndef min_coins_to_move_chips(n, positions):\n    odd_count = sum(1 for x in positions if x % 2 != 0)\n    even_count = n - odd_count\n    return min(odd_count, even_count)\n\n# Input reading\nn = int(input())\npositions = list(map(int, input().split()))\n\n# Output the result\nprint(min_coins_to_move_chips(n, positions))\n```",
    "98": "```python\ndef min_moves_to_reach_n(N):\n    moves = float('inf')\n    \n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            moves = min(moves, i + j - 2)\n    \n    return moves\n\nN = int(input())\nprint(min_moves_to_reach_n(N))\n```",
    "99": "```python\ndef calculate_wins(n, a, b):\n    # Maximum wins calculation\n    max_wins = min(a[0], b[2]) + min(a[1], b[0]) + min(a[2], b[1])\n\n    # Minimum wins calculation\n    # First, calculate losses:\n    losses = 0\n    losses += max(0, b[0] - a[2])  # Bob's rock beats Alice's paper\n    losses += max(0, b[1] - a[0])  # Bob's scissors beat Alice's rock\n    losses += max(0, b[2] - a[1])  # Bob's paper beats Alice's scissors\n    \n    # Minimum wins is total rounds minus losses\n    min_wins = n - losses\n\n    return min_wins, max_wins\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculate results\nmin_wins, max_wins = calculate_wins(n, a, b)\n\n# Output results\nprint(min_wins, max_wins)\n```"
}