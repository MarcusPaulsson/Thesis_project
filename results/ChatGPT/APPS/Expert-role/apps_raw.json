{
    "2": "```python\ndef next_lucky_year(n):\n    while True:\n        n += 1\n        if str(n).count('0') + len(set(str(n))) - 1 <= 1:\n            return n - (n - 1)\n\ncurrent_year = int(input())\nprint(next_lucky_year(current_year))\n```",
    "7": "```python\ndef days_until_empty(n, m):\n    day = 0\n    total_grains = n\n    \n    while total_grains > 0:\n        day += 1\n        total_grains += m  # grains are brought to the barn\n        if total_grains > n:\n            total_grains = n  # barn is full\n        \n        total_grains -= day  # sparrows eat grains\n        \n    return day\n\n# Input\nn, m = map(int, input().split())\nprint(days_until_empty(n, m))\n```",
    "5": "```python\nn, pos, l, r = map(int, input().split())\n\nif l == 1 and r == n:\n    print(0)\nelse:\n    moves = 0\n    if pos < l:\n        moves += l - pos  # Move to l\n        moves += 1  # Close left\n        moves += r - l  # Move to r\n        moves += 1  # Close right\n    elif pos > r:\n        moves += pos - r  # Move to r\n        moves += 1  # Close right\n        moves += r - l  # Move to l\n        moves += 1  # Close left\n    else:\n        if pos < l:\n            moves += l - pos  # Move to l\n            moves += 1  # Close left\n        elif pos > r:\n            moves += pos - r  # Move to r\n            moves += 1  # Close right\n        \n        moves += (r - l)  # Move from l to r\n        moves += 1  # Close right\n    \n    print(moves)\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    def painted_length(excluded_indices):\n        painted = [0] * (n + 1)\n        for i in range(q):\n            if i not in excluded_indices:\n                l, r = painters[i]\n                for j in range(l, r + 1):\n                    painted[j] = 1\n        return sum(painted)\n\n    max_sections = 0\n    for i in range(q):\n        for j in range(i + 1, q):\n            excluded_indices = {i, j}\n            max_sections = max(max_sections, painted_length(excluded_indices))\n\n    return max_sections\n\n# Input reading\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Get the result and print it\nresult = max_painted_sections(n, q, painters)\nprint(result)\n```",
    "10": "```python\nn = int(input().strip())\n\nwork_days = n // 7 * 5\ndays_off = n // 7 * 2\n\nremaining_days = n % 7\n\nif remaining_days > 5:\n    days_off += 2\nelif remaining_days > 0:\n    days_off += remaining_days\n\nmin_days_off = days_off\nmax_days_off = days_off + (2 if remaining_days > 0 else 0)\n\nprint(min_days_off, max_days_off)\n```",
    "1": "```python\ndef max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n\n    max_sum = sum(int(d) for d in str_x)\n    result = x\n\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit by 1 and setting all following digits to 9\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        new_number = int(new_number)\n\n        if new_number <= x:\n            current_sum = sum(int(d) for d in str(new_number))\n            if current_sum > max_sum or (current_sum == max_sum and new_number > result):\n                max_sum = current_sum\n                result = new_number\n\n    return result\n\nx = int(input().strip())\nprint(max_digit_sum(x))\n```",
    "4": "```python\ndef is_lucky(hh, mm):\n    return '7' in f\"{hh:02d}:{mm:02d}\"\n\ndef time_before(hh, mm, x, y):\n    total_minutes = hh * 60 + mm - x * y\n    total_minutes %= 1440  # wrap around after 24 hours\n    return total_minutes // 60, total_minutes % 60\n\nx = int(input())\nhh, mm = map(int, input().split())\n\ny = 0\nwhile True:\n    prev_hh, prev_mm = time_before(hh, mm, x, y)\n    if is_lucky(prev_hh, prev_mm):\n        print(y)\n        break\n    y += 1\n```",
    "0": "```python\ndef max_acordion_length(s):\n    # Initialize variables to track positions of brackets and colons\n    open_bracket = -1\n    first_colon = -1\n    last_colon = -1\n    close_bracket = -1\n    \n    # Iterate over the string to find positions\n    for i in range(len(s)):\n        if s[i] == '[' and open_bracket == -1:\n            open_bracket = i\n        elif s[i] == ':' and open_bracket != -1 and first_colon == -1:\n            first_colon = i\n        elif s[i] == ':' and first_colon != -1:\n            last_colon = i\n        elif s[i] == ']' and open_bracket != -1 and last_colon != -1:\n            close_bracket = i\n            break\n    \n    # Check if we have found a valid accordion structure\n    if open_bracket == -1 or first_colon == -1 or last_colon == -1 or close_bracket == -1:\n        return -1\n    \n    # Calculate the number of vertical lines\n    vertical_lines = last_colon - first_colon - 1\n    \n    # The length of the accordion is the sum of the components\n    max_length = 4 + vertical_lines\n    return max_length\n\n# Read input\ns = input().strip()\n# Output the result\nprint(max_acordion_length(s))\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    for query in queries:\n        n, x, blows = query\n        min_blows = float('inf')\n        possible = False\n\n        # Check each blow type\n        for d, h in blows:\n            # If we can defeat with this blow\n            if d >= x:\n                min_blows = min(min_blows, 1)\n                possible = True\n            else:\n                # Calculate how many blows are needed to bring the heads to 0\n                # After a blow we will have curX - d + h heads\n                remaining_heads = x\n                blows_count = 0\n\n                while remaining_heads > 0:\n                    # Deal a blow\n                    blows_count += 1\n                    remaining_heads -= d\n                    if remaining_heads <= 0:\n                        break\n                    # Heads grow back\n                    remaining_heads += h\n\n                if remaining_heads <= 0:\n                    min_blows = min(min_blows, blows_count)\n                    possible = True\n\n        results.append(min_blows if possible else -1)\n\n    return results\n\n# Read input\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\n# Get results\nresults = min_blows_to_defeat_zmei(t, queries)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelse:\n    print(n + k - t)\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    red_tiles = n // a\n    blue_tiles = n // b\n    common_tiles = n // (a * b)  # Tiles that are both red and blue\n\n    # Calculate the number of tiles that can only be painted red or blue\n    only_red = red_tiles - common_tiles\n    only_blue = blue_tiles - common_tiles\n\n    # Calculate total chocolates\n    total_chocolates = (only_red * p) + (only_blue * q) + (common_tiles * max(p, q))\n    \n    return total_chocolates\n\n# Input reading\nn, a, b, p, q = map(int, input().split())\nprint(max_chocolates(n, a, b, p, q))\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "9": "```python\nd = int(input())\nn, m = map(int, input().split())\n\nsofas = []\nfor i in range(d):\n    x1, y1, x2, y2 = map(int, input().split())\n    sofas.append((x1, y1, x2, y2))\n\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\ndef count_neighbors(sofa, sofas):\n    x1, y1, x2, y2 = sofa\n    left = right = top = bottom = 0\n    \n    for sx1, sy1, sx2, sy2 in sofas:\n        if (sx1, sy1) != (x1, y1) and (sx1, sy1) != (x2, y2) and (sx2, sy2) != (x1, y1) and (sx2, sy2) != (x2, y2):\n            if x1 < sx1 < x2:  # sofa is to the left\n                left += 1\n            if x1 > sx1 > x2:  # sofa is to the right\n                right += 1\n            if y1 < sy1 < y2:  # sofa is above\n                top += 1\n            if y1 > sy1 > y2:  # sofa is below\n                bottom += 1\n                \n    return left, right, top, bottom\n\nfor i in range(d):\n    left, right, top, bottom = count_neighbors(sofas[i], sofas)\n    if (left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b):\n        print(i + 1)\n        break\nelse:\n    print(-1)\n```",
    "12": "```python\ndef max_beauty_with_swap(n, trophies):\n    # Find the current longest segment of 'G'\n    max_length = 0\n    current_length = 0\n    segments = []\n    \n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            segments.append(current_length)\n            max_length = max(max_length, current_length)\n            current_length = 0\n    segments.append(current_length)  # Add the last segment\n    max_length = max(max_length, current_length)\n\n    # If there are no 'S' trophies to swap with\n    if 'S' not in trophies:\n        return max_length\n\n    # Now calculate the maximum length if we swap one 'S' with one 'G'\n    max_possible_length = max_length\n    \n    for i in range(len(segments) - 1):\n        # If we can swap the 'S' between two segments of 'G'\n        max_possible_length = max(max_possible_length, segments[i] + segments[i + 1] + 1)\n\n    return max_possible_length\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\n\n# Calculate and output the result\nprint(max_beauty_with_swap(n, trophies))\n```",
    "16": "```python\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\n# A regular bracket sequence can be formed if:\n# The number of opening brackets can match the closing brackets\n# The number of opening brackets must be at least as many as the closing brackets at any point in the sequence.\n\n# Count the total number of opening and closing brackets\ntotal_open = cnt_1 + cnt_2\ntotal_close = cnt_2 + cnt_4\n\n# To be a regular bracket sequence, the total number of open brackets must equal the total number of close brackets,\n# and at any point, the number of closing brackets must not exceed the number of opening brackets.\nif total_open >= total_close and (cnt_1 + cnt_2 >= cnt_3 + cnt_4):\n    print(1)\nelse:\n    print(0)\n```",
    "8": "```python\ndef min_extra_tiles(tiles):\n    tile_counts = {}\n    for tile in tiles:\n        num, suit = int(tile[0]), tile[1]\n        if suit not in tile_counts:\n            tile_counts[suit] = {}\n        if num not in tile_counts[suit]:\n            tile_counts[suit][num] = 0\n        tile_counts[suit][num] += 1\n\n    # Check for koutsu (triplet)\n    for suit in tile_counts:\n        for num in tile_counts[suit]:\n            if tile_counts[suit][num] >= 3:\n                return 0\n\n    # Check for shuntsu (sequence)\n    for suit in tile_counts:\n        nums = sorted(tile_counts[suit].keys())\n        for i in range(len(nums) - 2):\n            if nums[i] + 1 == nums[i + 1] and nums[i + 1] + 1 == nums[i + 2]:\n                return 0\n\n        # Check what we need to form a shuntsu\n        for num in nums:\n            if num - 1 in tile_counts[suit] and num + 1 in tile_counts[suit]:\n                return 0\n\n    # Check how many tiles we need to draw\n    needed = 2  # At most we can need 2 tiles to form a shuntsu\n    for suit in tile_counts:\n        nums = sorted(tile_counts[suit].keys())\n        for num in nums:\n            if num - 1 not in tile_counts[suit] and num + 1 not in tile_counts[suit]:\n                needed = min(needed, 2)  # Need 2 specific tiles\n            else:\n                needed = min(needed, 1)  # Need only 1 tile\n\n    return needed\n\n# Input handling\ntiles = input().strip().split()\nprint(min_extra_tiles(tiles))\n```",
    "14": "```python\ndef is_stack_sortable(n, k, p):\n    given_set = set(p)\n    remaining = [i for i in range(1, n + 1) if i not in given_set]\n    stack = []\n    b = []\n    \n    for i in range(k):\n        while stack and (not remaining or stack[-1] < remaining[-1]):\n            b.append(stack.pop())\n        stack.append(p[i])\n    \n    while stack:\n        b.append(stack.pop())\n    \n    if b != sorted(b):\n        return -1\n    \n    remaining.sort(reverse=True)\n    result = p + remaining\n    \n    return result\n\n# Input reading\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\nresult = is_stack_sortable(n, k, p)\n\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef time_to_palindrome(hh, mm):\n    minutes_passed = 0\n    while True:\n        if is_palindrome(f\"{hh:02}:{mm:02}\"):\n            return minutes_passed\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n\ntime_input = input().strip()\nhh, mm = map(int, time_input.split(':'))\nprint(time_to_palindrome(hh, mm))\n```",
    "19": "```python\ndef check_records(test_cases):\n    results = []\n    for case in test_cases:\n        n, stats = case\n        valid = True\n        for i in range(1, n):\n            p_prev, c_prev = stats[i - 1]\n            p_curr, c_curr = stats[i]\n            if p_curr < p_prev or c_curr < c_prev or c_curr > p_curr:\n                valid = False\n                break\n            if (p_curr - p_prev) < (c_curr - c_prev):\n                valid = False\n                break\n        results.append(\"YES\" if valid else \"NO\")\n    return results\n\n# Input reading and output printing\nimport sys\n\ninput = sys.stdin.read\ndata = input().splitlines()\nindex = 0\nT = int(data[index])\nindex += 1\ntest_cases = []\n\nfor _ in range(T):\n    n = int(data[index])\n    index += 1\n    stats = []\n    for __ in range(n):\n        p, c = map(int, data[index].split())\n        stats.append((p, c))\n        index += 1\n    test_cases.append((n, stats))\n\nresults = check_records(test_cases)\nfor result in results:\n    print(result)\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a, b):\n    from itertools import permutations\n    \n    # Convert numbers to string to work with digits\n    str_a = str(a)\n    str_b = str(b)\n    \n    # Get all unique permutations of the digits of a\n    unique_permutations = sorted(set(permutations(str_a)), reverse=True)\n    \n    # Find the largest permutation that does not exceed b\n    for perm in unique_permutations:\n        candidate = int(''.join(perm))\n        if candidate <= b:\n            return candidate\n    \n    return None  # This should not happen as per the problem statement\n\n# Input reading\na = int(input().strip())\nb = int(input().strip())\n\n# Get the result and print it\nresult = max_permutation_not_exceeding(a, b)\nprint(result)\n```",
    "21": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the positions of the minimum (1) and maximum (n) elements\nmin_pos = a.index(1)\nmax_pos = a.index(n)\n\n# Calculate the current distance\ncurrent_distance = abs(min_pos - max_pos)\n\n# Calculate potential new distances after performing one swap\n# Swap min with the first element or the last element\ndistance_if_swap_first = abs(0 - max_pos)  # Swap min (1) with a[0]\ndistance_if_swap_last = abs(n - 1 - max_pos)  # Swap min (1) with a[n-1]\n\n# Swap max with the first element or the last element\ndistance_if_swap_min_first = abs(min_pos - 0)  # Swap max (n) with a[0]\ndistance_if_swap_min_last = abs(min_pos - (n - 1))  # Swap max (n) with a[n-1]\n\n# The maximum possible distance after one swap\nmax_distance = max(current_distance, distance_if_swap_first, distance_if_swap_last,\n                   distance_if_swap_min_first, distance_if_swap_min_last)\n\nprint(max_distance)\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef topological_sort(n, dependencies):\n    indegree = [0] * (n + 1)\n    graph = defaultdict(list)\n    \n    for course, deps in dependencies.items():\n        for dep in deps:\n            graph[dep].append(course)\n            indegree[course] += 1\n    \n    queue = deque()\n    for i in range(1, n + 1):\n        if indegree[i] == 0:\n            queue.append(i)\n    \n    order = []\n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        for neighbor in graph[course]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return order\n\ndef find_courses(n, k, main_courses, dependencies):\n    order = topological_sort(n, dependencies)\n    if len(order) < n:\n        return -1  # cycle detected or not all courses can be taken\n    \n    course_set = set(main_courses)\n    to_take = []\n    taken_courses = set()\n    \n    for course in order:\n        if course in course_set or any(dep in taken_courses for dep in dependencies[course]):\n            to_take.append(course)\n            taken_courses.add(course)\n            if course in course_set:\n                course_set.remove(course)\n    \n    if course_set:\n        return -1  # not all main courses can be taken\n    \n    return len(to_take), to_take\n\n# Input reading\nn, k = map(int, input().split())\nmain_courses = list(map(int, input().split()))\ndependencies = {}\n\nfor i in range(1, n + 1):\n    data = list(map(int, input().split()))\n    dependencies[i] = data[1:]  # skip the first number which is the count of dependencies\n\nresult = find_courses(n, k, main_courses, dependencies)\n\nif result == -1:\n    print(-1)\nelse:\n    m, courses = result\n    print(m)\n    print(' '.join(map(str, courses)))\n```",
    "25": "```python\ndef create_matrix(n, k):\n    if k > n * (n + 1) // 2:\n        return -1\n    \n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        if k <= 0:\n            break\n        if k >= 2:\n            matrix[i][i] = 1\n            k -= 1\n        for j in range(i + 1, n):\n            if k >= 2:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n            else:\n                break\n    \n    if k > 0:\n        return -1\n    \n    return matrix\n\ndef print_matrix(matrix):\n    if matrix == -1:\n        print(-1)\n    else:\n        for row in matrix:\n            print(\" \".join(map(str, row)))\n\nn, k = map(int, input().split())\nresult = create_matrix(n, k)\nprint_matrix(result)\n```",
    "24": "```python\ndef can_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # horizontal, vertical, diagonal down-right, diagonal down-left\n    n = 10\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                # Simulate placing 'X' at (i, j)\n                board[i][j] = 'X'\n                \n                # Check for winning conditions\n                for dx, dy in directions:\n                    count = 1  # Start with the current position\n\n                    # Check in the positive direction\n                    x, y = i + dx, j + dy\n                    while 0 <= x < n and 0 <= y < n and board[x][y] == 'X':\n                        count += 1\n                        x += dx\n                        y += dy\n\n                    # Check in the negative direction\n                    x, y = i - dx, j - dy\n                    while 0 <= x < n and 0 <= y < n and board[x][y] == 'X':\n                        count += 1\n                        x -= dx\n                        y -= dy\n\n                    # If count reaches 5, Alice wins\n                    if count >= 5:\n                        return 'YES'\n                \n                # Reset the cell back to empty\n                board[i][j] = '.'\n\n    return 'NO'\n\n# Reading input\nboard = [input().strip() for _ in range(10)]\nprint(can_win(board))\n```",
    "27": "```python\nn = int(input())\ns = input()\n\n# Function to find the minimum operations\ndef min_operations(n, s):\n    # Start with typing all characters one by one\n    min_ops = n\n    \n    # Check for every possible prefix length\n    for i in range(1, n // 2 + 1):\n        if s[:i] == s[i:2*i]:  # Check if the first i characters match the next i characters\n            # Calculate the operations: type prefix + copy + remaining characters\n            min_ops = min(min_ops, i + 1 + (n - 2 * i))\n    \n    return min_ops\n\n# Print the result\nprint(min_operations(n, s))\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    # Define the mirror mapping for characters\n    mirror = {\n        'A': 'A', 'B': '', 'C': '', 'D': '', 'E': '', 'F': '', 'G': '',\n        'H': 'H', 'I': 'I', 'J': '', 'K': '', 'L': '', 'M': 'M', 'N': '',\n        'O': 'O', 'P': '', 'Q': '', 'R': '', 'S': '', 'T': 'T', 'U': 'U',\n        'V': 'V', 'W': 'W', 'X': 'X', 'Y': 'Y', 'Z': '',\n        'a': 'a', 'b': '', 'c': '', 'd': '', 'e': '', 'f': '', 'g': '',\n        'h': 'h', 'i': 'i', 'j': '', 'k': '', 'l': '', 'm': 'm', 'n': '',\n        'o': 'o', 'p': '', 'q': '', 'r': '', 's': '', 't': 't', 'u': 'u',\n        'v': 'v', 'w': 'w', 'x': 'x', 'y': 'y', 'z': ''\n    }\n    \n    n = len(s)\n    for i in range(n // 2):\n        if mirror.get(s[i], '') != s[n - 1 - i] or mirror.get(s[n - 1 - i], '') != s[i]:\n            return \"NIE\"\n    \n    return \"TAK\"\n\ns = input().strip()\nprint(is_s_palindrome(s))\n```",
    "18": "```python\ndef lexicographically_minimal_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        while t:\n            if len(u) == 0 or t[-1] <= u[-1]:\n                u.append(t.pop())\n            else:\n                break\n    \n    return ''.join(u)\n\ns = input().strip()\nresult = lexicographically_minimal_string(s)\nprint(result)\n```",
    "30": "```python\ndef min_traps(m, x):\n    # Since GCD(x, m) = 1, the sequence will visit m distinct rooms\n    # until it returns to the starting position.\n    # The number of unique rooms visited is equal to m.\n    return m\n\nm, x = map(int, input().split())\nprint(min_traps(m, x))\n```",
    "26": "```python\nimport sys\n\n# Read input\nx, y, z = map(float, sys.stdin.readline().strip().split())\n\n# Define the expressions and their corresponding values\nexpressions = [\n    (f\"x^y^z\", x ** (y ** z)),\n    (f\"x^z^y\", x ** (z ** y)),\n    (f\"(x^y)^z\", (x ** y) ** z),\n    (f\"(x^z)^y\", (x ** z) ** y),\n    (f\"y^x^z\", y ** (x ** z)),\n    (f\"y^z^x\", y ** (z ** x)),\n    (f\"(y^x)^z\", (y ** x) ** z),\n    (f\"(y^z)^x\", (y ** z) ** x),\n    (f\"z^x^y\", z ** (x ** y)),\n    (f\"z^y^x\", z ** (y ** x)),\n    (f\"(z^x)^y\", (z ** x) ** y),\n    (f\"(z^y)^x\", (z ** y) ** x)\n]\n\n# Find the maximum value and the corresponding expression\nmax_value = -1\nmax_expression = \"\"\nfor expr, value in expressions:\n    if value > max_value:\n        max_value = value\n        max_expression = expr\n\n# Output the result\nprint(max_expression)\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef calculate_probability(n, k):\n    MOD = 1000003\n    days = 1 << n  # This is 2^n\n\n    if k > days:\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the total outcomes B\n    B = pow(days, k, MOD)\n\n    # Calculate the favorable outcomes A\n    favorable_outcomes = 1\n    for i in range(k):\n        favorable_outcomes *= (days - i)\n        favorable_outcomes %= MOD\n\n    # Probability of at least two people having the same birthday\n    A = (B - favorable_outcomes) % MOD\n\n    # Reduce A/B to irreducible form\n    g = gcd(A, B)\n    A //= g\n    B //= g\n\n    return A % MOD, B % MOD\n\nn, k = map(int, input().split())\nA, B = calculate_probability(n, k)\nprint(A, B)\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = []\nregulars = []\nfor name, typ in files:\n    if typ == '1':\n        examples.append(name)\n    else:\n        regulars.append(name)\n\nmoves = []\n# Renaming examples to 1, 2, ..., e\nfor i in range(len(examples)):\n    moves.append(f\"move {examples[i]} {i + 1}\")\n# Renaming regular tests to e + 1, e + 2, ..., n\nfor i in range(len(regulars)):\n    moves.append(f\"move {regulars[i]} {len(examples) + i + 1}\")\n\nprint(len(moves))\nfor move in moves:\n    print(move)\n```",
    "32": "```python\ndef is_valid_journey(n, journey):\n    current_position = 0  # Position in kilometers from North Pole (0 means North Pole, 20000 means South Pole)\n\n    for t, direction in journey:\n        if current_position == 0 and direction != \"South\":\n            return \"NO\"\n        if current_position == 20000 and direction != \"North\":\n            return \"NO\"\n\n        if direction == \"North\":\n            current_position -= t\n        elif direction == \"South\":\n            current_position += t\n        elif direction in [\"West\", \"East\"]:\n            continue  # No change in position\n\n        if current_position < 0 or current_position > 20000:\n            return \"NO\"\n\n    return \"YES\" if current_position == 0 else \"NO\"\n\n# Input reading\nn = int(input())\njourney = [tuple(input().split()) for _ in range(n)]\njourney = [(int(t), dir) for t, dir in journey]\n\n# Output result\nprint(is_valid_journey(n, journey))\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    left, right = 1, max(a, b)\n    \n    while left < right:\n        mid = (left + right + 1) // 2\n        if (a // mid) + (b // mid) >= n:\n            left = mid\n        else:\n            right = mid - 1\n            \n    return left\n\n# Read input\nn, a, b = map(int, input().split())\n# Get the result\nresult = max_min_pieces(n, a, b)\n# Print the result\nprint(result)\n```",
    "37": "```python\ndef can_deal_exact_damage(a, b, c):\n    for x in range(c // a + 1):\n        if (c - a * x) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Input\na, b, c = map(int, input().split())\n# Output\nprint(can_deal_exact_damage(a, b, c))\n```",
    "33": "```python\ndef count_common_integers(a1, b1, a2, b2, L, R):\n    def adjust(start, step):\n        if start < L:\n            # Find the first valid integer >= L\n            start += ((L - start + step - 1) // step) * step\n        elif start > R:\n            return None\n        return start\n\n    # Calculate the first valid x values for both sequences\n    start1 = adjust(b1, a1)\n    start2 = adjust(b2, a2)\n\n    if start1 is None or start2 is None:\n        return 0\n\n    # Ensure we start from the maximum of both starts\n    start = max(start1, start2)\n\n    # Count the number of valid integers in the range [L, R]\n    count = 0\n    while start <= R:\n        if (start - b1) % a1 == 0 and (start - b2) % a2 == 0:\n            count += 1\n        start += max(a1, a2)\n\n    return count\n\n# Input reading\na1, b1, a2, b2, L, R = map(int, input().split())\nresult = count_common_integers(a1, b1, a2, b2, L, R)\nprint(result)\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    # Calculate the difference\n    diff = abs(sum_first - sum_second)\n    \n    # Create lists of potential changes\n    changes = []\n    if sum_first < sum_second:\n        changes = [9 - digit for digit in first_half] + [digit for digit in second_half]\n    else:\n        changes = [digit for digit in first_half] + [9 - digit for digit in second_half]\n    \n    # Sort changes in descending order to maximize the effect of each change\n    changes.sort(reverse=True)\n    \n    replacements = 0\n    for change in changes:\n        diff -= change\n        replacements += 1\n        if diff <= 0:\n            break\n    \n    return replacements\n\n# Example usage\nticket = input().strip()\nprint(min_replacements_to_lucky(ticket))\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\nrated = False\nunrated = False\n\nfor a, b in ratings:\n    if a != b:\n        rated = True\n        break\n\nif rated:\n    print(\"rated\")\nelse:\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            unrated = True\n            break\n    \n    if unrated:\n        print(\"unrated\")\n    else:\n        print(\"maybe\")\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    if not is_palindrome(s):\n        return n\n    \n    # If the entire string is a palindrome, check for non-palindromic substrings\n    for i in range(n):\n        for j in range(i + 1, n):\n            if not is_palindrome(s[i:j + 1]):\n                return j - i + 1\n    \n    return 0\n\n# Input\ns = input().strip()\n# Output\nprint(longest_non_palindrome_substring(s))\n```",
    "35": "```python\ndef is_valid_flag(n, m, flag):\n    colors = {'R', 'G', 'B'}\n    \n    # Check horizontal stripes\n    def check_horizontal():\n        stripe_height = n // 3\n        if n % 3 != 0:\n            return False\n        for i in range(3):\n            stripe_color = flag[i * stripe_height][0]\n            if stripe_color not in colors:\n                return False\n            if any(flag[j][k] != stripe_color for j in range(i * stripe_height, (i + 1) * stripe_height) for k in range(m)):\n                return False\n        return len(set(flag[i * stripe_height][0] for i in range(3))) == 3\n\n    # Check vertical stripes\n    def check_vertical():\n        stripe_width = m // 3\n        if m % 3 != 0:\n            return False\n        for i in range(3):\n            stripe_color = flag[0][i * stripe_width]\n            if stripe_color not in colors:\n                return False\n            if any(flag[j][k] != stripe_color for j in range(n) for k in range(i * stripe_width, (i + 1) * stripe_width)):\n                return False\n        return len(set(flag[0][i * stripe_width] for i in range(3))) == 3\n\n    return \"YES\" if check_horizontal() or check_vertical() else \"NO\"\n\n# Input reading\nn, m = map(int, input().split())\nflag = [input().strip() for _ in range(n)]\n\n# Output result\nprint(is_valid_flag(n, m, flag))\n```",
    "36": "```python\ndef hex_spiral_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 1\n\n    # Find the layer\n    while n >= moves_in_layer:\n        n -= moves_in_layer\n        layer += 1\n        moves_in_layer = 6 * layer\n\n    # Calculate the coordinates\n    x, y = layer, 0\n    if n == 0:\n        return (x, y)\n\n    # The starting point of the current layer is at (layer, 0)\n    # Each segment of the layer is 1 step in the direction of the hexagon\n    for i in range(n):\n        if i < layer:\n            x -= 1  # Move left\n        elif i < 2 * layer:\n            x -= 1  # Move left\n            y += 1  # Move up\n        elif i < 3 * layer:\n            y += 1  # Move up\n        elif i < 4 * layer:\n            x += 1  # Move right\n            y += 1  # Move up\n        elif i < 5 * layer:\n            x += 1  # Move right\n        else:\n            x += 1  # Move right\n            y -= 1  # Move down\n\n    return (x, y)\n\nn = int(input())\nx, y = hex_spiral_coordinates(n)\nprint(x, y)\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n\n    def is_valid(t):\n        # Check if s is a substring of any cyclic shift of t\n        doubled_t = t + t\n        return s in doubled_t\n\n    # Generate all binary strings of length n\n    all_strings = [''.join(p) for p in product('01', repeat=n)]\n    \n    # Count distinct cyclic strings that contain s as a substring\n    count = 0\n    seen = set()\n    \n    for t in all_strings:\n        if is_valid(t):\n            # To avoid counting cyclic shifts as different strings, we use a canonical form\n            min_t = min(t[i:] + t[:i] for i in range(n))\n            if min_t not in seen:\n                seen.add(min_t)\n                count += 1\n\n    return count\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_cyclic_strings(n, s))\n```",
    "41": "```python\ndef nearest_zero_distance(n, arr):\n    distances = [float('inf')] * n\n    last_zero_index = -1\n\n    # First pass: from left to right\n    for i in range(n):\n        if arr[i] == 0:\n            last_zero_index = i\n            distances[i] = 0\n        elif last_zero_index != -1:\n            distances[i] = i - last_zero_index\n\n    # Second pass: from right to left\n    last_zero_index = -1\n    for i in range(n - 1, -1, -1):\n        if arr[i] == 0:\n            last_zero_index = i\n        elif last_zero_index != -1:\n            distances[i] = min(distances[i], last_zero_index - i)\n\n    print(' '.join(map(str, distances)))\n\n# Input reading\nn = int(input())\narr = list(map(int, input().split()))\nnearest_zero_distance(n, arr)\n```",
    "48": "```python\ndef find_kth_largest(n, m, k):\n    low, high = 1, n * m\n\n    while low < high:\n        mid = (low + high) // 2\n        count = sum(min(mid // i, m) for i in range(1, n + 1))\n\n        if count < k:\n            low = mid + 1\n        else:\n            high = mid\n\n    return low\n\n# Read input\nn, m, k = map(int, input().split())\n# Get the k-th largest number\nresult = find_kth_largest(n, m, k)\n# Print the result\nprint(result)\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Check if it's possible to create a sequence of k numbers that sum to n\n    if n < (k * (k + 1)) // 2:\n        return -1\n    \n    # Calculate the maximum gcd we can have\n    max_gcd = n // k\n    \n    # Create the sequence with the calculated gcd\n    sequence = [(i + 1) * max_gcd for i in range(k)]\n    \n    # Adjust the last element to ensure the sum equals n\n    sequence[-1] += (n - sum(sequence))\n    \n    # Check if the sequence is strictly increasing and valid\n    if sequence[-1] > sequence[-2]:\n        return sequence\n    else:\n        return -1\n\n# Input reading\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "47": "```python\ndef max_subarray_sum(arr):\n    max_ending_here = max_so_far = 0\n    for x in arr:\n        max_ending_here = max(0, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\ndef max_beauty_with_subarray(n, x, a):\n    original_beauty = max_subarray_sum(a)\n\n    # Calculate the effect of multiplying a subarray by x\n    max_gain = 0\n    current_gain = 0\n\n    for i in range(n):\n        current_gain += a[i] * x\n        # Calculate potential beauty when including the original array sum\n        max_gain = max(max_gain, current_gain + original_beauty)\n\n        # Reset current_gain if it drops below 0 (similar to max subarray logic)\n        if current_gain < 0:\n            current_gain = 0\n\n    return max(max_gain, original_beauty)\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\nprint(max_beauty_with_subarray(n, x, a))\n```",
    "46": "```python\ndef count_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n    \n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n    \n    for i in range(1, m + 1):\n        count_y[i % 5] += 1\n    \n    result = 0\n    for i in range(5):\n        result += count_x[i] * count_y[(5 - i) % 5]\n    \n    return result\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))\n```",
    "43": "```python\nimport sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    vectors = []\n    \n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().strip().split())\n        angle = math.atan2(y, x)  # Get the angle of the vector\n        vectors.append((angle, i + 1))  # Store angle and index (1-based)\n\n    # Sort by angle\n    vectors.sort()\n\n    # To find the minimal angle, check adjacent angles and consider the circular nature\n    min_angle = float('inf')\n    best_pair = (0, 0)\n\n    for i in range(n):\n        # Compare with the next vector, considering the circular wrap\n        j = (i + 1) % n\n        angle1 = vectors[i][0]\n        angle2 = vectors[j][0]\n        angle_diff = angle2 - angle1\n\n        # Adjust for circular angle\n        if angle_diff < 0:\n            angle_diff += 2 * math.pi\n        \n        # Non-oriented angle is the smaller of angle_diff and its supplement\n        min_non_oriented_angle = min(angle_diff, 2 * math.pi - angle_diff)\n\n        if min_non_oriented_angle < min_angle:\n            min_angle = min_non_oriented_angle\n            best_pair = (vectors[i][1], vectors[j][1])\n\n    print(best_pair[0], best_pair[1])\n\nif __name__ == \"__main__\":\n    main()\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = float('-inf')\n    moves = []\n    \n    while left <= right:\n        if a[left] > last_taken and (a[right] <= last_taken or a[left] < a[right]):\n            moves.append('L')\n            last_taken = a[left]\n            left += 1\n        elif a[right] > last_taken:\n            moves.append('R')\n            last_taken = a[right]\n            right -= 1\n        else:\n            break\n\n    print(len(moves))\n    print(''.join(moves))\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\nlongest_increasing_sequence(n, a)\n```",
    "38": "```python\ndef can_match_tracks(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between barriers for Kefa and Sasha\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Double the Kefa's differences to account for circular matching\n    kefa_diffs_extended = kefa_diffs + kefa_diffs\n    \n    # Check if Sasha's differences can be found in the extended Kefa's differences\n    for start in range(n):\n        if kefa_diffs_extended[start:start + n] == sasha_diffs:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Reading input\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_match_tracks(n, L, kefa_distances, sasha_distances))\n```",
    "51": "```python\nfrom collections import Counter\nimport math\n\ndef find_x_y(n, divisors):\n    counter = Counter(divisors)\n    common_divisors = [d for d, count in counter.items() if count > 1]\n\n    gcd = 1\n    for d in common_divisors:\n        gcd = math.gcd(gcd, d)\n\n    x = gcd\n    y = 1\n    for d in divisors:\n        if d % x == 0:\n            y *= d // x\n\n    return (x, y)\n\nn = int(input().strip())\ndivisors = list(map(int, input().strip().split()))\n\nx, y = find_x_y(n, divisors)\nprint(x, y)\n```",
    "49": "```python\ndef find_kth_digit(k):\n    digit_length = 1\n    count = 9\n    start = 1\n    \n    while k > digit_length * count:\n        k -= digit_length * count\n        digit_length += 1\n        count *= 10\n        start *= 10\n    \n    start += (k - 1) // digit_length\n    num_str = str(start)\n    return int(num_str[(k - 1) % digit_length])\n\nk = int(input().strip())\nprint(find_kth_digit(k))\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_select = m // 2\n    dp = [[0] * k for _ in range(max_select + 1)]\n\n    for row in matrix:\n        current_dp = [dp[:] for dp in dp]\n        row.sort(reverse=True)\n        for num in row[:max_select]:\n            for j in range(max_select, 0, -1):\n                for r in range(k):\n                    new_sum = current_dp[j - 1][r] + num\n                    current_dp[j][new_sum % k] = max(current_dp[j][new_sum % k], new_sum)\n        dp = current_dp\n\n    return max(dp[j][0] for j in range(max_select + 1))\n\n# Input reading\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nresult = max_sum_divisible_by_k(n, m, k, matrix)\nprint(result)\n```",
    "44": "```python\ndef minimal_time(d, k, a, b, t):\n    # Total time if Vasiliy walks the entire distance\n    walk_time = d * b\n    \n    # Initialize the minimal time with the walk time\n    min_time = walk_time\n    \n    # Calculate the maximum number of complete segments Vasiliy can drive\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Time spent if he drives full segments and walks the remaining distance\n    drive_time = full_segments * k * a + (full_segments - 1) * t + remaining_distance * b\n    min_time = min(min_time, drive_time)\n    \n    # If there are full segments, consider the case where he repairs the car\n    if full_segments > 0:\n        drive_time = full_segments * k * a + (full_segments * t) + remaining_distance * b\n        min_time = min(min_time, drive_time)\n    \n    # Consider driving less than full segments\n    for i in range(full_segments + 1):\n        # Time if he drives i segments, repairs, then walks the remaining distance\n        drive_time = i * k * a + i * t + remaining_distance * b\n        min_time = min(min_time, drive_time)\n    \n    return min_time\n\n# Read input values\nd, k, a, b, t = map(int, input().split())\n# Calculate and print the minimal time\nprint(minimal_time(d, k, a, b, t))\n```",
    "54": "```python\ndef min_D_to_equal(a):\n    a_min = min(a)\n    a_max = max(a)\n\n    if a_min == a_max:\n        return 0\n\n    # The distance we need to cover\n    distance = a_max - a_min\n\n    # If there are only two distinct elements\n    if len(set(a)) == 2:\n        return distance // 2\n\n    # If there are more than two distinct elements\n    unique_values = sorted(set(a))\n    \n    if len(unique_values) > 3 or (len(unique_values) == 3 and unique_values[2] - unique_values[0] != unique_values[1] - unique_values[0]):\n        return -1\n    \n    # If we have exactly three unique values\n    if len(unique_values) == 3:\n        if unique_values[2] - unique_values[1] == unique_values[1] - unique_values[0]:\n            return unique_values[1] - unique_values[0]\n        else:\n            return -1\n\n    return -1\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_D_to_equal(a))\n```",
    "55": "```python\ndef is_white_sheet_visible(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n    # Check if any part of the white sheet is visible\n    # The white sheet is visible if there is any point that:\n    # 1. Is not strictly inside the white sheet (i.e., at least one of its edges)\n    # 2. Is strictly outside both black sheets\n    \n    # Check bottom edge of the white sheet\n    if y1 > y4 and y1 > y6:  # bottom edge of white is above both black sheets\n        return \"YES\"\n    \n    # Check top edge of the white sheet\n    if y2 < y3 and y2 < y5:  # top edge of white is below both black sheets\n        return \"YES\"\n    \n    # Check left edge of the white sheet\n    if x1 > x4 and x1 > x6:  # left edge of white is right of both black sheets\n        return \"YES\"\n    \n    # Check right edge of the white sheet\n    if x2 < x3 and x2 < x5:  # right edge of white is left of both black sheets\n        return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Output result\nprint(is_white_sheet_visible(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6))\n```",
    "59": "```python\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# We need to check the last x digits of the number\ntarget = ['0'] * x\ntarget[y] = '1'  # We want to set the y-th digit to 1\ntarget = ''.join(target)\n\n# Get the last x digits from the number\ncurrent = number[-x:]\n\n# Count the number of changes required\nchanges = sum(1 for i in range(x) if current[i] != target[i])\n\nprint(changes)\n```",
    "56": "```python\ndef remove_trailing_zeros(x):\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef f(x):\n    return remove_trailing_zeros(x + 1)\n\ndef count_reachable_numbers(n):\n    reachable = set()\n    current = n\n    \n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    \n    return len(reachable)\n\nn = int(input())\nprint(count_reachable_numbers(n))\n```",
    "57": "```python\ndef distribute_gifts(n, f):\n    # Prepare a list for the final output\n    nf = f[:]\n    \n    # Identify friends who want to give gifts to someone\n    givers = set(i + 1 for i in range(n) if f[i] != 0)\n    # Identify friends who can receive gifts (those with f[i] == 0)\n    receivers = set(i + 1 for i in range(n) if f[i] == 0)\n\n    # Friends who need to be filled in\n    need_to_fill = list(receivers - givers)\n\n    # Fill the unknown values\n    idx = 0\n    for i in range(n):\n        if nf[i] == 0:\n            # Find a suitable recipient that is not the current index + 1\n            while need_to_fill[idx] == i + 1:\n                idx += 1\n            nf[i] = need_to_fill[idx]\n            idx += 1\n\n    print(\" \".join(map(str, nf)))\n\n# Input reading\nn = int(input())\nf = list(map(int, input().split()))\ndistribute_gifts(n, f)\n```",
    "60": "```python\ndef has_palindrome_subsequence(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        found = False\n        # Check for any element that appears at least twice\n        indices = {}\n        for i in range(n):\n            if a[i] in indices:\n                # If we find the same element again and the distance is at least 2\n                if i - indices[a[i]] >= 2:\n                    found = True\n                    break\n            indices[a[i]] = i\n        results.append(\"YES\" if found else \"NO\")\n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Get results and print them\nresults = has_palindrome_subsequence(t, test_cases)\nfor result in results:\n    print(result)\n```",
    "63": "```python\ndef min_instability(n, a):\n    a.sort()\n    \n    # Remove the first element or the last element\n    instability_remove_first = a[-1] - a[1]\n    instability_remove_last = a[-2] - a[0]\n    \n    return min(instability_remove_first, instability_remove_last)\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_instability(n, a))\n```",
    "58": "```python\ndef color_array(n, k, a):\n    from collections import defaultdict\n\n    # Dictionary to keep track of the frequency of each number\n    freq = defaultdict(int)\n    for num in a:\n        freq[num] += 1\n\n    # If we have any number that appears more than k times, it's impossible\n    if any(count > k for count in freq.values()):\n        print(\"NO\")\n        return\n\n    # Prepare to store the result colors\n    result = [0] * n\n    color_assignments = defaultdict(list)\n\n    # Assign colors while maintaining the frequency\n    for i in range(n):\n        num = a[i]\n        # Find the next color for this number\n        color = len(color_assignments[num]) % k + 1\n        color_assignments[num].append(color)\n        result[i] = color\n\n    # Check if we have at least one of each color\n    if len(set(result)) < k:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(' '.join(map(str, result)))\n\n# Input reading\nn, k = map(int, input().split())\na = list(map(int, input().split()))\ncolor_array(n, k, a)\n```",
    "65": "```python\ndef transform_steps(n, m):\n    if m % n != 0:\n        return -1\n    \n    quotient = m // n\n    count2 = 0\n    count3 = 0\n    \n    while quotient % 2 == 0:\n        quotient //= 2\n        count2 += 1\n        \n    while quotient % 3 == 0:\n        quotient //= 3\n        count3 += 1\n    \n    if quotient != 1:\n        return -1\n    \n    return count2 + count3\n\n# Input reading\nn, m = map(int, input().split())\nprint(transform_steps(n, m))\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        min_ops = float('inf')\n        best_triplet = (0, 0, 0)\n\n        for A in range(1, a + 1):\n            for B in range(A, c + 1):\n                if B % A == 0:\n                    for C in range(B, c + 1):\n                        if C % B == 0:\n                            ops = (A - a) + (B - b) + (C - c)\n                            if ops < min_ops:\n                                min_ops = ops\n                                best_triplet = (A, B, C)\n\n        results.append((min_ops, best_triplet))\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations(t, test_cases)\n\n# Print output\nfor ops, (A, B, C) in results:\n    print(ops)\n    print(A, B, C)\n```",
    "66": "```python\ndef minimum_string(n, k, t):\n    # Find the longest suffix of t that is also a prefix\n    # This will help in minimizing the length of the resulting string\n    longest_overlap = 0\n    for i in range(1, n):\n        if t[:n - i] == t[i:]:\n            longest_overlap = n - i\n            break\n    \n    # Construct the result\n    result = t + (t[longest_overlap:] * (k - 1))\n    return result\n\n# Input reading\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the minimum string\nresult = minimum_string(n, k, t)\n\n# Output the result\nprint(result)\n```",
    "61": "```python\nn = int(input())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\nmax_number = list(a)  # Start with the original number as a list of characters\ni = 0\n\nwhile i < n:\n    if f[int(a[i]) - 1] > int(a[i]):\n        # Start replacing if f(x) is greater than x\n        while i < n and f[int(a[i]) - 1] >= int(a[i]):\n            max_number[i] = str(f[int(a[i]) - 1])\n            i += 1\n        break\n    elif f[int(a[i]) - 1] < int(a[i]):\n        # Once we find a digit where f(x) is less than x, we stop\n        break\n    i += 1\n\n# If we started replacing, we continue replacing until we find a digit that would be reduced\nwhile i < n and f[int(a[i]) - 1] >= int(a[i]):\n    max_number[i] = str(f[int(a[i]) - 1])\n    i += 1\n\nprint(''.join(max_number))\n```",
    "71": "```python\nimport math\n\na = int(input())\noutput = math.floor(math.log2(a))\nprint(output)\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    days = [0] * n\n    preparation_needed = [0] * m\n    exam_days = set()\n    \n    for i in range(m):\n        s, d, c = exams[i]\n        preparation_needed[i] = c\n        for j in range(s - 1, d - 1):  # s-1 to d-2 (0-indexed)\n            if days[j] == 0:\n                days[j] = i + 1  # mark it for preparation\n\n        exam_days.add(d - 1)  # mark the exam day\n\n    for i in range(m):\n        s, d, c = exams[i]\n        count = 0\n        for j in range(s - 1, d - 1):\n            if days[j] == i + 1:\n                count += 1\n        if count < c:\n            return -1\n    \n    for i in range(n):\n        if i in exam_days:\n            days[i] = m + 1  # exam day\n    \n    return days\n\n# Input reading\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\nresult = schedule_exams(n, m, exams)\n\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "67": "```python\ndef find_nice_indices(n, a):\n    total_sum = sum(a)\n    nice_indices = []\n\n    for i in range(n):\n        remaining_sum = total_sum - a[i]\n        if remaining_sum % 2 == 0:\n            target = remaining_sum // 2\n            if target in a:\n                if target != a[i] or a.count(target) > 1:\n                    nice_indices.append(i + 1)\n\n    return len(nice_indices), nice_indices\n\nn = int(input())\na = list(map(int, input().split()))\n\nk, indices = find_nice_indices(n, a)\n\nprint(k)\nif k > 0:\n    print(' '.join(map(str, indices)))\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph, n):\n    dist = [-1] * (n + 1)\n    dist[start] = 0\n    queue = deque([start])\n    farthest_node = start\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if dist[neighbor] == -1:\n                dist[neighbor] = dist[node] + 1\n                queue.append(neighbor)\n                if dist[neighbor] > dist[farthest_node]:\n                    farthest_node = neighbor\n                    \n    return farthest_node, dist\n\ndef main():\n    n = int(input().strip())\n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        u, v = map(int, input().strip().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Find the farthest node from an arbitrary start node (node 1)\n    farthest_from_start, _ = bfs(1, graph, n)\n    # Find the farthest node from the previous farthest node\n    farthest_from_far, dist_from_far = bfs(farthest_from_start, graph, n)\n    \n    # Get the farthest distance and nodes involved\n    max_distance_node = farthest_from_far\n    diameter_length = dist_from_far[max_distance_node]\n\n    # To find three vertices a, b, c, we can use the two endpoints of the diameter\n    # and one other node that maximizes the edges in the paths\n    # We can choose the middle point of the diameter path or any leaf\n    \n    # Let's get the diameter path\n    path = []\n    current = max_distance_node\n    while current != farthest_from_start:\n        path.append(current)\n        for neighbor in graph[current]:\n            if dist_from_far[neighbor] == dist_from_far[current] - 1:\n                current = neighbor\n                break\n    path.append(farthest_from_start)\n    path.reverse()\n    \n    # Choosing a, b from the diameter ends, and c as a leaf or any node not in the path\n    a = path[0]\n    b = path[-1]\n    c = -1\n    \n    for node in range(1, n + 1):\n        if node not in path:\n            c = node\n            break\n\n    # The maximum number of edges in the union of paths\n    max_edges = diameter_length + 1 + (len(graph[a]) - 1) + (len(graph[b]) - 1)\n    print(max_edges)\n    print(a, b, c)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "73": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmax_height = max(a)\n# Check if the wall can be completed\ncan_complete = True\n\nfor height in a:\n    if height < max_height and (height % 2) != (max_height % 2):\n        can_complete = False\n        break\n\nprint(\"YES\" if can_complete else \"NO\")\n```",
    "77": "```python\nn = int(input())\ntotal_sum = n * (n + 1) // 2\nprint(total_sum % 2)\n```",
    "70": "```python\ndef calculate_midpoint(h1, m1, h2, m2):\n    # Convert start and end times to total minutes\n    start_minutes = h1 * 60 + m1\n    end_minutes = h2 * 60 + m2\n    \n    # Calculate midpoint in minutes\n    midpoint_minutes = (start_minutes + end_minutes) // 2\n    \n    # Convert midpoint back to hours and minutes\n    h3 = midpoint_minutes // 60\n    m3 = midpoint_minutes % 60\n    \n    # Print results in required format\n    print(f\"{h3:02}:{m3:02}\")\n\n# Read input\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Calculate and output the midpoint\ncalculate_midpoint(h1, m1, h2, m2)\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import Counter\n\n    # Count frequencies of each character\n    freq = Counter(s)\n    \n    # Count how many distinct subsequences we can generate\n    subseq_count = 0\n    cost = 0\n    total_cost = 0\n    \n    # We will keep track of how many subsequences we can generate\n    for length in range(n + 1):  # Consider all lengths from 0 to n\n        # Calculate how many subsequences of this length we can create\n        # The number of distinct subsequences of a given length can be calculated as:\n        # 2^(number of distinct characters) - 1 (the empty subsequence)\n        # But we need to consider not exceeding k\n        if length > 0:\n            current_subseq_count = 1\n            for count in freq.values():\n                current_subseq_count *= (count + 1)  # Each character can be used 0 to count times\n            \n            current_subseq_count -= 1  # Exclude the empty subsequence\n            \n            if subseq_count + current_subseq_count >= k:\n                # We can fulfill the requirement of k subsequences\n                remaining_needed = k - subseq_count\n                total_cost += remaining_needed * (n - length)\n                break\n            else:\n                # Accumulate the cost for all subsequences of this length\n                total_cost += current_subseq_count * (n - length)\n                subseq_count += current_subseq_count\n\n    # If we exit the loop and have not reached k subsequences\n    if subseq_count < k:\n        return -1\n    \n    return total_cost\n\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result and print it\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    unique_subsequences = set()\n    total_cost = 0\n    \n    # To collect all possible distinct subsequences\n    for i in range(1 << n):\n        subseq = []\n        for j in range(n):\n            if i & (1 << j):\n                subseq.append(s[j])\n        unique_subseq = ''.join(subseq)\n        if unique_subseq not in unique_subsequences:\n            unique_subsequences.add(unique_subseq)\n            total_cost += n - len(unique_subseq)\n        \n        if len(unique_subsequences) >= k:\n            break\n    \n    if len(unique_subsequences) < k:\n        return -1\n    return total_cost\n\nn, k = map(int, input().split())\ns = input().strip()\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "76": "```python\ndef can_construct_symmetric_square(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Check for pairs of tiles that can form the symmetric structure\n        possible = False\n        for i in range(n):\n            for j in range(n):\n                if tiles[i][1][0] == tiles[j][0][0] and tiles[i][1][1] == tiles[j][0][1]:\n                    possible = True\n                    break\n            if possible:\n                break\n        \n        results.append(\"YES\" if possible else \"NO\")\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        top = tuple(map(int, input().split()))\n        bottom = tuple(map(int, input().split()))\n        tiles.append((top, bottom))\n    test_cases.append((n, m, tiles))\n\n# Get results\nresults = can_construct_symmetric_square(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    \n    # Check for pairs of digits that make the number divisible by 25\n    possible_pairs = [(0, 5), (2, 5), (5, 0), (7, 5)]\n    found = False\n    min_moves = float('inf')\n    \n    for i in range(length):\n        for j in range(i + 1, length):\n            if (s[i], s[j]) in possible_pairs:\n                if s[j] != '0' or (j == length - 1):\n                    # Calculate moves to bring s[i] to the correct position\n                    # and s[j] to the position after s[i]\n                    moves = (j - i) + (length - 1 - j)\n                    min_moves = min(min_moves, moves)\n                    found = True\n    \n    return min_moves if found else -1\n\n# Input\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "81": "```python\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\n# Sort strings by their lengths\nstrings.sort(key=len)\n\n# Check if the ordering is valid\nfor i in range(n):\n    for j in range(i):\n        if strings[j] not in strings[i]:\n            print(\"NO\")\n            exit()\n\nprint(\"YES\")\nfor s in strings:\n    print(s)\n```",
    "75": "```python\ndef max_days(a, b, c):\n    week_food = [a, b, c, a, b, c, c]  # Food sequence corresponding to the week\n    max_days = 0\n\n    for start_day in range(7):\n        food = week_food[:]  # Copy the food list for this starting day\n        days = 0\n        while True:\n            current_day = (start_day + days) % 7\n            if food[current_day] > 0:\n                food[current_day] -= 1\n                days += 1\n            else:\n                break\n        max_days = max(max_days, days)\n\n    full_weeks = min(a // 3, b // 2, c // 2)  # Calculate full weeks of food\n    max_days += full_weeks * 7  # Add full weeks to max days\n\n    # Remaining food after full weeks\n    a -= full_weeks * 3\n    b -= full_weeks * 2\n    c -= full_weeks * 2\n\n    # Try to consume the remaining food\n    for start_day in range(7):\n        food = [a, b, c, a, b, c, c]  # Reset for remaining food\n        days = 0\n        while True:\n            current_day = (start_day + days) % 7\n            if food[current_day] > 0:\n                food[current_day] -= 1\n                days += 1\n            else:\n                break\n        max_days = max(max_days, days)\n\n    return max_days\n\n# Input reading\na, b, c = map(int, input().split())\nprint(max_days(a, b, c))\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n\n    if D >= n:\n        print(\"NO\")\n        return\n\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n\n    if len(graph[1]) < D:\n        print(\"NO\")\n        return\n\n    tree_edges = []\n    visited = set()\n    visited.add(1)\n\n    # Start by connecting vertex 1 to D neighbors\n    for neighbor in graph[1][:D]:\n        tree_edges.append((1, neighbor))\n        visited.add(neighbor)\n\n    # Use a queue to perform BFS/DFS for the rest of the vertices\n    queue = deque()\n    for neighbor in graph[1][:D]:\n        queue.append(neighbor)\n\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                tree_edges.append((current, neighbor))\n                queue.append(neighbor)\n                if len(tree_edges) == n - 1:\n                    break\n        if len(tree_edges) == n - 1:\n            break\n\n    if len(tree_edges) == n - 1:\n        print(\"YES\")\n        for v, u in tree_edges:\n            print(v, u)\n    else:\n        print(\"NO\")\n\n# Example usage\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nfind_spanning_tree(n, m, D, edges)\n```",
    "72": "```python\ndef maximal_intersection_length(n, segments):\n    lefts = [l for l, r in segments]\n    rights = [r for l, r in segments]\n\n    # Precompute the maximum left and minimum right excluding each segment\n    max_left_exclude = [0] * n\n    min_right_exclude = [0] * n\n    \n    # Calculate prefix max for left ends\n    prefix_max_left = [0] * n\n    prefix_max_left[0] = lefts[0]\n    for i in range(1, n):\n        prefix_max_left[i] = max(prefix_max_left[i - 1], lefts[i])\n    \n    # Calculate suffix max for left ends\n    suffix_max_left = [0] * n\n    suffix_max_left[-1] = lefts[-1]\n    for i in range(n - 2, -1, -1):\n        suffix_max_left[i] = max(suffix_max_left[i + 1], lefts[i])\n    \n    # Calculate prefix min for right ends\n    prefix_min_right = [0] * n\n    prefix_min_right[0] = rights[0]\n    for i in range(1, n):\n        prefix_min_right[i] = min(prefix_min_right[i - 1], rights[i])\n    \n    # Calculate suffix min for right ends\n    suffix_min_right = [0] * n\n    suffix_min_right[-1] = rights[-1]\n    for i in range(n - 2, -1, -1):\n        suffix_min_right[i] = min(suffix_min_right[i + 1], rights[i])\n    \n    max_length = 0\n    for i in range(n):\n        if i == 0:\n            max_left = suffix_max_left[1]\n            min_right = prefix_min_right[1]\n        elif i == n - 1:\n            max_left = prefix_max_left[n - 2]\n            min_right = suffix_min_right[n - 2]\n        else:\n            max_left = max(prefix_max_left[i - 1], suffix_max_left[i + 1])\n            min_right = min(prefix_min_right[i - 1], suffix_min_right[i + 1])\n        \n        intersection_length = max(0, min_right - max_left)\n        max_length = max(max_length, intersection_length)\n    \n    return max_length\n\n# Read input\nn = int(input().strip())\nsegments = [tuple(map(int, input().strip().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(maximal_intersection_length(n, segments))\n```",
    "85": "```python\ndef find_price(A, B):\n    for price in range(1, 10000):  # Arbitrarily high upper limit\n        tax_8 = (price * 8) // 100\n        tax_10 = (price * 10) // 100\n        if tax_8 == A and tax_10 == B:\n            return price\n    return -1\n\nA, B = map(int, input().split())\nresult = find_price(A, B)\nprint(result)\n```",
    "82": "```python\nn, k = map(int, input().split())\nproblems = list(map(int, input().split()))\n\nsolved = 0\n\n# Solve from the left\nwhile solved < n and problems[solved] <= k:\n    solved += 1\n\n# Solve from the right\nwhile solved < n and problems[n - 1 - (solved - 1)] <= k:\n    solved += 1\n\n# If we counted the same problem from both ends, subtract it\nif solved > n and problems[solved - 1] <= k:\n    solved -= 1\n\nprint(solved)\n```",
    "87": "```python\ndef max_project_subset(n, r, projects):\n    # Sort projects by their required rating a_i\n    projects.sort()\n    \n    count = 0\n    current_rating = r\n    \n    for a_i, b_i in projects:\n        if current_rating >= a_i:\n            count += 1\n            current_rating += b_i\n            # Ensure rating does not fall below zero\n            if current_rating < 0:\n                break\n    \n    return count\n\n# Read input\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = max_project_subset(n, r, projects)\nprint(result)\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    from collections import defaultdict\n\n    # Create a list of positions for each character\n    positions = defaultdict(list)\n    for index, char in enumerate(s):\n        positions[char].append(index)\n    \n    # Determine the number of colors needed\n    max_color = 1\n    coloring = [0] * n\n    color_map = {}\n\n    for char in sorted(positions.keys()):  # Process characters in alphabetical order\n        indices = positions[char]\n        current_color = max_color\n\n        for idx in indices:\n            if coloring[idx] == 0:  # If not colored yet\n                coloring[idx] = current_color\n                \n        max_color += 1  # Increment color for the next character\n\n    # We need to adjust the colors to ensure we can sort via swaps\n    color_to_use = [0] * (max_color - 1)\n    for i in range(n):\n        color_to_use[coloring[i] - 1] = max(color_to_use[coloring[i] - 1], coloring[i])\n\n    # Finalize the coloring\n    final_color = []\n    for i in range(n):\n        final_color.append(color_to_use[coloring[i] - 1])\n\n    print(max_color - 1)\n    print(' '.join(map(str, final_color)))\n\n# Example inputs\nn = int(input().strip())\ns = input().strip()\nmin_colors_to_sort(n, s)\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects based on the required rating\n    projects.sort()\n    \n    for a, b in projects:\n        if r < a:  # If current rating is less than required for the project\n            return \"NO\"\n        r += b  # Update rating after completing the project\n        if r < 0:  # If rating goes below zero, it's invalid\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_complete_projects(n, r, projects))\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n    \n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            # Check for red rectangle\n            for r_width in range(1, int(a**0.5) + 1):\n                if a % r_width == 0:\n                    r_height = a // r_width\n                    if r_width <= width and r_height <= height:\n                        perimeter = 2 * (width + height)\n                        min_perimeter = min(min_perimeter, perimeter)\n                \n            # Check for blue rectangle\n            for b_width in range(1, int(b**0.5) + 1):\n                if b % b_width == 0:\n                    b_height = b // b_width\n                    if b_width <= width and b_height <= height:\n                        perimeter = 2 * (width + height)\n                        min_perimeter = min(min_perimeter, perimeter)\n\n    return min_perimeter\n\na, b = map(int, input().split())\nprint(minimal_perimeter(a, b))\n```",
    "84": "```python\ndef can_color_string(n, s):\n    # Count the occurrences of each character\n    from collections import Counter\n    count = Counter(s)\n    \n    # If any character appears more than twice, it is impossible to color\n    if any(c > 2 for c in count.values()):\n        return \"NO\"\n    \n    # Create a list to store the coloring\n    coloring = ['0'] * n\n    \n    # We will use two colors: '0' and '1'\n    color = 0\n    \n    # Last seen position for each character\n    last_seen = {}\n    \n    for i in range(n):\n        char = s[i]\n        \n        # If we have seen this character before, color it the same as the last one\n        if char in last_seen:\n            coloring[i] = coloring[last_seen[char]]\n        else:\n            # Assign a new color\n            coloring[i] = str(color)\n            color = 1 - color  # Toggle color for next unique character\n            \n        last_seen[char] = i\n    \n    return \"YES\", ''.join(coloring)\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Check and output the result\nresult = can_color_string(n, s)\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    print(result[1])\n```",
    "86": "```python\ndef solve_problems(n, k):\n    # Minimum sum of problems solved with constraints\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n\n    # Start with the minimum required problems solved each day\n    a = list(range(1, k + 1))\n    current_sum = min_sum\n\n    # Distribute the remaining problems\n    remaining = n - current_sum\n    for i in range(k - 1, -1, -1):\n        # The maximum number of problems we can add to a[i]\n        # We can add at most (2 * a[i]) - a[i] = a[i] to keep the next day's constraints\n        max_increase = a[i]  # We can increase a[i] by at most a[i]\n        increase = min(remaining, max_increase)\n        a[i] += increase\n        remaining -= increase\n        if remaining == 0:\n            break\n\n    if remaining > 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n\n# Example usage\nsolve_problems(26, 6)\nsolve_problems(8, 3)\nsolve_problems(1, 1)\nsolve_problems(9, 4)\nsolve_problems(7, 2)\n```",
    "92": "```python\nx = float(input().strip())\n\n# The formula to determine the integers a and b based on the input x\n# is derived from the formula x = (a * b) / (a + b).\n# We will search for integers a and b in the range [1, 10].\n\nfound = False\nfor a in range(1, 11):\n    for b in range(1, 11):\n        if abs(x - (a * b) / (a + b)) < 1e-6:\n            print(a, b)\n            found = True\n            break\n    if found:\n        break\n```",
    "78": "```python\nMOD = 10**9 + 7\n\ndef count_regular_sequences(n, s):\n    m = len(s)\n    \n    # Precompute factorials and inverse factorials for combinations\n    fact = [1] * (2*n + 1)\n    inv_fact = [1] * (2*n + 1)\n    \n    for i in range(2, 2*n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n\n    inv_fact[2*n] = pow(fact[2*n], MOD - 2, MOD)\n    for i in range(2*n - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    # Function to calculate C(n, k) = n! / (k! * (n-k)!)\n    def C(n, k):\n        if k < 0 or k > n:\n            return 0\n        return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD\n\n    # Check the balance of the string s\n    balance = 0\n    min_balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n\n    # If the balance is negative or more than n, return 0\n    if balance > n or min_balance < 0:\n        return 0\n    \n    # Remaining open and close brackets after placing s\n    remaining_open = n - (s.count('('))\n    remaining_close = n - (s.count(')'))\n    \n    result = 0\n    for i in range(remaining_open + 1):\n        # i is the number of open brackets before s\n        # remaining_open - i is the number of open brackets after s\n        # remaining_close must match the total number of closing brackets\n        result += C(remaining_open, i) * C(remaining_open + remaining_close - 1, remaining_close - 1) % MOD\n        result %= MOD\n\n    return result\n\nn = int(input().strip())\ns = input().strip()\nprint(count_regular_sequences(n, s))\n```",
    "97": "```python\nn = int(input())\npositions = list(map(int, input().split()))\n\neven_count = sum(1 for x in positions if x % 2 == 0)\nodd_count = n - even_count\n\n# The minimum number of coins needed is the smaller of the two counts\nresult = min(even_count, odd_count)\nprint(result)\n```",
    "98": "```python\ndef min_moves_to_n(N):\n    min_moves = float('inf')\n    \n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            moves = (i - 1) + (j - 1)\n            min_moves = min(min_moves, moves)\n    \n    return min_moves\n\nN = int(input().strip())\nprint(min_moves_to_n(N))\n```",
    "88": "```python\ndef create_palindromic_matrix(n, numbers):\n    from collections import Counter\n\n    count = Counter(numbers)\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Check if it's possible to create a palindromic matrix\n    odd_count = 0\n    center_value = None\n    \n    for value, cnt in count.items():\n        if cnt % 2 != 0:\n            odd_count += 1\n            center_value = value\n        if odd_count > 1:\n            return \"NO\"\n    \n    # Fill the matrix\n    # Half the matrix (the upper half and the left half)\n    for i in range((n + 1) // 2):\n        for j in range((n + 1) // 2):\n            if i == j and n % 2 == 1 and odd_count == 1:\n                # Place center value in the middle for odd sizes\n                matrix[i][j] = center_value\n                count[center_value] -= 1\n            else:\n                for value in list(count.keys()):\n                    if count[value] >= 4:\n                        matrix[i][j] = value\n                        matrix[i][n - j - 1] = value\n                        matrix[n - i - 1][j] = value\n                        matrix[n - i - 1][n - j - 1] = value\n                        count[value] -= 4\n                        break\n    \n    # Fill any remaining values if necessary\n    for value, cnt in count.items():\n        while cnt > 0:\n            placed = False\n            for i in range(n):\n                for j in range(n):\n                    if matrix[i][j] == 0:\n                        matrix[i][j] = value\n                        cnt -= 1\n                        placed = True\n                        if cnt == 0:\n                            break\n                if not placed:\n                    break\n            if cnt == 0:\n                break\n    \n    return \"YES\", matrix\n\n# Read input\nn = int(input())\nnumbers = list(map(int, input().split()))\n\n# Get result\nresult = create_palindromic_matrix(n, numbers)\n\n# Output\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for row in result[1]:\n        print(\" \".join(map(str, row)))\n```",
    "90": "```python\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculate the total length of all platforms\ntotal_length = sum(c)\n\n# If the max jump distance d is greater than or equal to n, we can always reach the end\nif d >= n:\n    result = [0] * n\n    position = 0\n    for i in range(m):\n        for j in range(c[i]):\n            result[position] = i + 1\n            position += 1\n    print(\"YES\")\n    print(\" \".join(map(str, result)))\nelse:\n    # Try to place the platforms\n    result = [0] * n\n    position = 0\n    \n    for i in range(m):\n        # If the current platform can fit within the jump distance\n        if position + c[i] - 1 <= n and (i == 0 or position - (c[i-1] if i > 0 else 0) <= d):\n            for j in range(c[i]):\n                result[position] = i + 1\n                position += 1\n        else:\n            print(\"NO\")\n            exit(0)\n        \n        # Move the position to the next platform start\n        if i < m - 1:\n            position += d - c[i]\n            position = max(position, sum(c[:i+1])) # Ensure we don't overlap\n    \n    print(\"YES\")\n    print(\" \".join(map(str, result)))\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d >= n or d * k < n - 1:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    edges = []\n    \n    # Create a path of length d\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n    \n    # Current vertex where we can attach new vertices\n    current_vertex = d + 1\n    \n    # Degree counts\n    degree = [0] * (n + 1)\n    \n    # Attach remaining vertices\n    for i in range(1, d + 2):\n        while degree[i] < k and current_vertex <= n:\n            edges.append((i, current_vertex))\n            degree[i] += 1\n            degree[current_vertex] += 1\n            current_vertex += 1\n    \n    if current_vertex <= n:\n        print(\"NO\")\n        return\n    \n    for u, v in edges:\n        print(u, v)\n\n# Input reading\nn, d, k = map(int, input().split())\nconstruct_tree(n, d, k)\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n = len(s)\n    m = len(t)\n\n    # Precompute left and right indices\n    left = [0] * m\n    right = [0] * m\n\n    # Fill left array\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n\n    # Fill right array\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n\n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n\n    # Check edges\n    max_length = max(max_length, right[0])  # Remove from start to first char of t\n    max_length = max(max_length, n - 1 - left[m - 1])  # Remove from last char of t to end\n\n    return max_length\n\n# Input reading\ns = input().strip()\nt = input().strip()\n\n# Output result\nprint(max_removable_length(s, t))\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    p = [0] * n\n    p[0] = 0  # Start from an arbitrary point\n\n    # Calculate p based on q\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n\n    # Shift p to make sure all values are positive and within the range [1, n]\n    min_p = min(p)\n    shift = 1 - min_p\n\n    for i in range(n):\n        p[i] += shift\n\n    # Check if p is a valid permutation\n    if len(set(p)) == n and all(1 <= x <= n for x in p):\n        print(' '.join(map(str, p)))\n    else:\n        print(-1)\n\n# Read input\nn = int(input())\nq = list(map(int, input().split()))\n\n# Restore the permutation\nrestore_permutation(n, q)\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Create the base string with n 'a's, n 'b's, and n 'c's\n    base_string = 'a' * n + 'b' * n + 'c' * n\n    \n    # Check if it's possible to form a valid string\n    if s[0] == t[0] or s[0] == t[1] or s[1] == t[0] or s[1] == t[1]:\n        print(\"NO\")\n        return\n    \n    # Initialize the result list\n    res = []\n\n    # Create a list of characters to work with\n    chars = ['a'] * n + ['b'] * n + ['c'] * n\n    \n    # Current characters to be added\n    current = 0\n    \n    while current < len(chars):\n        # Try to add a character while avoiding the substrings s and t\n        for i in range(current, len(chars)):\n            # Check the last two added characters\n            if len(res) >= 1 and chars[i] == res[-1]:\n                continue\n            if len(res) >= 2 and (res[-1] == s[0] and res[-2] == s[1]) or (res[-1] == t[0] and res[-2] == t[1]):\n                continue\n            \n            # Add the character to the result\n            res.append(chars[i])\n            # Move the current pointer\n            current += 1\n            break\n        else:\n            # If we can't add any character, break the loop\n            break\n            \n    # If we filled the result with the necessary length\n    if len(res) == 3 * n:\n        print(\"YES\")\n        print(''.join(res))\n    else:\n        print(\"NO\")\n\n# Read input\nn = int(input())\ns = input().strip()\nt = input().strip()\n\n# Generate the string\ngenerate_string(n, s, t)\n```",
    "99": "```python\nn = int(input())\na_1, a_2, a_3 = map(int, input().split())\nb_1, b_2, b_3 = map(int, input().split())\n\n# Maximum wins for Alice\nmax_wins = min(a_1, b_2) + min(a_2, b_3) + min(a_3, b_1)\n\n# Minimum wins for Alice\n# Calculate total draws\ndraws = min(a_1, b_1) + min(a_2, b_2) + min(a_3, b_3)\n# Remaining rounds after draws\nremaining_rounds = n - draws\n# Alice's minimum wins is the remaining rounds minus Bob's wins\nmin_wins = max(0, remaining_rounds - (b_1 + b_2 + b_3 - (a_1 + a_2 + a_3)))\n\nprint(min_wins, max_wins)\n```",
    "94": "```python\na, b, x = map(int, input().split())\n\n# Determine how many transitions we need to create.\n# Each transition requires at least one '0' and one '1'.\n# We need to ensure we have enough to satisfy the request.\nif x % 2 == 0:\n    # Even number of transitions\n    zeros = a\n    ones = b\n    s = []\n    \n    # Start with a 0 or 1 based on availability and x\n    start_with_one = ones >= zeros\n    if start_with_one:\n        s.append('1')\n        ones -= 1\n    else:\n        s.append('0')\n        zeros -= 1\n    \n    for i in range(x // 2):\n        if start_with_one:\n            s.append('0')\n            s.append('1')\n            zeros -= 1\n            ones -= 1\n        else:\n            s.append('1')\n            s.append('0')\n            ones -= 1\n            zeros -= 1\n    \n    # Now we add the remaining characters\n    if start_with_one:\n        s += ['1'] * ones + ['0'] * zeros\n    else:\n        s += ['0'] * zeros + ['1'] * ones\n\nelse:\n    # Odd number of transitions\n    if a < b:\n        s = ['0']  # start with 0, then alternate\n        zeros = a - 1\n        ones = b\n    else:\n        s = ['1']  # start with 1, then alternate\n        ones = b - 1\n        zeros = a\n    \n    for i in range(x // 2):\n        s.append('1' if s[-1] == '0' else '0')\n        if s[-1] == '1':\n            ones -= 1\n        else:\n            zeros -= 1\n    \n    # Add one more transition\n    s.append('1' if s[-1] == '0' else '0')\n    if s[-1] == '1':\n        ones -= 1\n    else:\n        zeros -= 1\n    \n    # Now add the remaining characters\n    s += ['1'] * ones + ['0'] * zeros\n\nprint(''.join(s))\n```"
}