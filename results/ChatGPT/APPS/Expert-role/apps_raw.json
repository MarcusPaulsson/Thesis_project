{
    "2": "```python\nn = int(input())\n\ndef is_lucky_year(year):\n    non_zero_digits = sum(1 for digit in str(year) if digit != '0')\n    return non_zero_digits <= 1\n\nnext_year = n + 1\nwhile not is_lucky_year(next_year):\n    next_year += 1\n\nprint(next_year - n)\n```",
    "4": "```python\ndef is_lucky(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef minutes_to_time(hh, mm, minutes):\n    total_minutes = hh * 60 + mm - minutes\n    total_minutes %= 1440  # Wrap around after 24 hours\n    return divmod(total_minutes, 60)\n\ndef minimum_snoozes(x, hh, mm):\n    y = 0\n    while True:\n        alarm_hh, alarm_mm = minutes_to_time(hh, mm, x * y)\n        if is_lucky(alarm_hh, alarm_mm):\n            return y\n        y += 1\n\nx = int(input())\nhh, mm = map(int, input().split())\nprint(minimum_snoozes(x, hh, mm))\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    def painted_count(excluded):\n        painted = [0] * (n + 1)\n        for i in range(q):\n            if i == excluded:\n                continue\n            l, r = painters[i]\n            for j in range(l, r + 1):\n                painted[j] = 1\n        return sum(painted)\n\n    max_sections = 0\n    for i in range(q):\n        max_sections = max(max_sections, painted_count(i))\n    \n    return max_sections\n\n# Input reading\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output the result\nprint(max_painted_sections(n, q, painters))\n```",
    "7": "```python\ndef days_until_empty(n, m):\n    day = 0\n    total_eaten = 0\n    \n    while n > 0:\n        day += 1\n        total_eaten += day\n        \n        # Add grains to the barn\n        n += m\n        \n        # If the barn exceeds its capacity, it remains full\n        if n > m:\n            n = min(n, m)\n        \n        # Sparrows eat grains\n        n -= total_eaten\n        \n    return day\n\n# Input reading\nn, m = map(int, input().split())\nprint(days_until_empty(n, m))\n```",
    "10": "```python\nn = int(input())\n\n# Calculate the maximum days off\nmax_days_off = (n // 7) * 2 + min(2, n % 7)\n\n# Calculate the minimum days off\nif n < 5:\n    min_days_off = 0\nelse:\n    min_days_off = (n // 7) * 2\n\nprint(min_days_off, max_days_off)\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    for query in queries:\n        n, x, blows = query\n        min_blows = float('inf')\n        possible = False\n        \n        for d, h in blows:\n            if d >= x:\n                min_blows = min(min_blows, 1)\n                possible = True\n            else:\n                # Calculate the effective heads after one blow\n                effective_heads = x - d + h\n                if effective_heads < x:\n                    # Calculate the number of blows needed\n                    blows_needed = (x - d + h - 1) // (h - d) + 1\n                    min_blows = min(min_blows, blows_needed)\n                    possible = True\n        \n        results.append(min_blows if possible else -1)\n    \n    return results\n\n# Input reading\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\n# Get results\nresults = min_blows_to_defeat_zmei(t, queries)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "5": "```python\ndef min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0  # No tabs to close\n    seconds = 0\n\n    # Close tabs to the left of l\n    if l > 1:\n        if pos < l:\n            seconds += (l - pos) + 1  # Move to l and close\n        else:\n            seconds += (pos - l) + 1  # Move to l and close\n    else:\n        seconds += 0  # No tabs to close on the left\n\n    # Close tabs to the right of r\n    if r < n:\n        if pos > r:\n            seconds += (pos - r) + 1  # Move to r and close\n        else:\n            seconds += (r - pos) + 1  # Move to r and close\n    else:\n        seconds += 0  # No tabs to close on the right\n\n    return seconds\n\n# Read input\nn, pos, l, r = map(int, input().split())\n# Output the result\nprint(min_seconds_to_close_tabs(n, pos, l, r))\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    count_a = n // a\n    count_b = n // b\n    count_ab = n // (a * b // gcd(a, b))\n    \n    # Calculate chocolates if we prioritize Red tiles\n    chocolates_red_first = count_a * p + (count_b - count_ab) * q\n    \n    # Calculate chocolates if we prioritize Blue tiles\n    chocolates_blue_first = count_b * q + (count_a - count_ab) * p\n    \n    return max(chocolates_red_first, chocolates_blue_first)\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n# Input reading\nn, a, b, p, q = map(int, input().split())\nprint(max_chocolates(n, a, b, p, q))\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelif t <= n + k:\n    print(n + k - t)\n\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef find_course_order(n, k, main_courses, dependencies):\n    indegree = [0] * (n + 1)\n    graph = defaultdict(list)\n    \n    for i in range(1, n + 1):\n        for dep in dependencies[i - 1]:\n            graph[dep].append(i)\n            indegree[i] += 1\n    \n    queue = deque()\n    for course in range(1, n + 1):\n        if indegree[course] == 0:\n            queue.append(course)\n    \n    order = []\n    passed_courses = set()\n    \n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        passed_courses.add(course)\n        \n        for neighbor in graph[course]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    if not all(course in passed_courses for course in main_courses):\n        return -1\n    \n    return len(order), order\n\n# Input reading\nn, k = map(int, input().split())\nmain_courses = list(map(int, input().split()))\ndependencies = [list(map(int, input().split()[1:])) for _ in range(n)]\n\n# Finding the course order\nresult = find_course_order(n, k, main_courses, dependencies)\n\n# Output\nif result == -1:\n    print(-1)\nelse:\n    print(result[0])\n    print(' '.join(map(str, result[1])))\n```",
    "1": "```python\ndef max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n    \n    # Start with the original number\n    max_number = x\n    max_sum = sum(int(d) for d in str_x)\n    \n    # Try to create numbers by reducing digits\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit and setting all following digits to 9\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        new_number = int(new_number)\n        \n        if new_number > 0 and new_number <= x:\n            new_sum = sum(int(d) for d in str(new_number))\n            if new_sum > max_sum or (new_sum == max_sum and new_number > max_number):\n                max_number = new_number\n                max_sum = new_sum\n    \n    return max_number\n\nx = int(input())\nprint(max_digit_sum(x))\n```",
    "18": "```python\ndef minimal_lexicographic_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        while t:\n            if not u or t[-1] <= u[-1]:\n                u.append(t.pop())\n            else:\n                break\n    \n    return ''.join(u)\n\ns = input().strip()\nprint(minimal_lexicographic_string(s))\n```",
    "0": "```python\ndef max_acordion_length(s):\n    n = len(s)\n    left_bracket_index = -1\n    right_bracket_index = -1\n    max_length = -1\n\n    for i in range(n):\n        if s[i] == '[':\n            left_bracket_index = i\n        elif s[i] == ']':\n            right_bracket_index = i\n            if left_bracket_index != -1 and right_bracket_index > left_bracket_index:\n                # Count the number of ':' and '|' between the brackets\n                colon_count = 0\n                pipe_count = 0\n                for j in range(left_bracket_index + 1, right_bracket_index):\n                    if s[j] == ':':\n                        colon_count += 1\n                    elif s[j] == '|':\n                        pipe_count += 1\n                if colon_count >= 2:\n                    # Valid accordion found\n                    length = 2 + pipe_count  # 2 for the colons and brackets\n                    max_length = max(max_length, length)\n\n    return max_length\n\ns = input().strip()\nprint(max_acordion_length(s))\n```",
    "8": "```python\ndef min_tiles_to_draw(tiles):\n    from collections import defaultdict\n\n    counts = defaultdict(int)\n    for tile in tiles:\n        counts[tile] += 1\n\n    # Check for koutsu (triplet)\n    for count in counts.values():\n        if count == 3:\n            return 0\n\n    # Check for shuntsu (sequence)\n    suits = defaultdict(list)\n    for tile in tiles:\n        num = int(tile[0])\n        suit = tile[1]\n        suits[suit].append(num)\n\n    for suit in suits.values():\n        suit.sort()\n        for i in range(len(suit) - 2):\n            if suit[i] + 1 == suit[i + 1] and suit[i] + 2 == suit[i + 2]:\n                return 0\n\n    # Check how many tiles are needed to form a shuntsu\n    needed = float('inf')\n    for suit in suits:\n        nums = sorted(suits[suit])\n        for i in range(len(nums)):\n            # Check for possible sequences\n            for j in range(3):\n                target = nums[i] + j\n                if target not in nums:\n                    # Count how many tiles we need to draw\n                    draw_count = 0\n                    if target - 1 not in nums:\n                        draw_count += 1\n                    if target not in nums:\n                        draw_count += 1\n                    if target + 1 not in nums:\n                        draw_count += 1\n                    needed = min(needed, draw_count)\n\n    return needed if needed != float('inf') else 2\n\ntiles = input().split()\nprint(min_tiles_to_draw(tiles))\n```",
    "16": "```python\ncnt1 = int(input())\ncnt2 = int(input())\ncnt3 = int(input())\ncnt4 = int(input())\n\n# A regular bracket sequence can be formed if:\n# 1. The total number of opening brackets must be equal to the total number of closing brackets.\n# 2. At any point in the sequence, the number of closing brackets must not exceed the number of opening brackets.\n\n# Calculate the total number of opening and closing brackets\nopen_brackets = cnt1 + cnt2\nclose_brackets = cnt2 + cnt3\n\n# Check the conditions for a regular bracket sequence\nif open_brackets >= close_brackets and (cnt1 - cnt3) >= 0:\n    print(1)\nelse:\n    print(0)\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    # Find the current maximum length of golden trophies\n    max_length = 0\n    current_length = 0\n    segments = []\n\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n                max_length = max(max_length, current_length)\n            current_length = 0\n\n    if current_length > 0:\n        segments.append(current_length)\n        max_length = max(max_length, current_length)\n\n    # If there are no golden trophies, return 0\n    if max_length == 0:\n        return 0\n\n    # If there is only one segment of golden trophies, we can only swap with a silver trophy\n    if len(segments) == 1:\n        return max_length\n\n    # Calculate the maximum possible length after one swap\n    max_possible_length = max_length\n    for i in range(len(segments) - 1):\n        # Check if we can connect two segments by swapping a silver trophy\n        max_possible_length = max(max_possible_length, segments[i] + segments[i + 1])\n\n    # If we can swap a silver trophy with a golden one, we can increase the length by 1\n    return min(max_possible_length + 1, n)\n\n# Read input\nn = int(input())\ntrophies = input().strip()\n\n# Get the result\nresult = max_beauty_after_swap(n, trophies)\n\n# Print the result\nprint(result)\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return minutes_passed\n\ntime_input = input().strip()\nhh, mm = map(int, time_input.split(':'))\nresult = next_palindrome_time(hh, mm)\nprint(result)\n```",
    "19": "```python\ndef check_records(test_cases):\n    results = []\n    for case in test_cases:\n        n = case[0]\n        records = case[1]\n        valid = True\n        \n        for i in range(n):\n            p_i, c_i = records[i]\n            if i > 0:\n                p_prev, c_prev = records[i - 1]\n                if p_i < p_prev or c_i < c_prev or c_i > p_i:\n                    valid = False\n                    break\n                if p_i - p_prev < c_i - c_prev:\n                    valid = False\n                    break\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Input reading\nT = int(input())\ntest_cases = []\nfor _ in range(T):\n    n = int(input())\n    records = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, records))\n\n# Check records and print results\nresults = check_records(test_cases)\nfor result in results:\n    print(result)\n```",
    "14": "```python\ndef stack_sortable_permutation(n, k, p):\n    # Create a set of used elements from the first k elements\n    used = set(p)\n    \n    # Initialize the result permutation with the first k elements\n    result = p[:]\n    \n    # Initialize the next available number to fill in the permutation\n    next_available = n\n    \n    # Stack to simulate the stack operations\n    stack = []\n    \n    # Iterate through the first k elements\n    for i in range(k):\n        # While the stack is not empty and the top of the stack is less than the next element\n        while stack and stack[-1] < next_available:\n            result.append(stack.pop())\n        \n        # If the current element is less than the next available, we cannot form a valid permutation\n        if p[i] < next_available:\n            return -1\n        \n        # Push the current element onto the stack\n        stack.append(p[i])\n        \n        # Decrease the next available number\n        next_available -= 1\n    \n    # Fill the remaining elements in the result\n    while next_available > 0:\n        if next_available not in used:\n            result.append(next_available)\n        next_available -= 1\n    \n    # Check if the result is stack-sortable\n    stack = []\n    b = []\n    \n    for num in result:\n        stack.append(num)\n        while stack and (not b or stack[-1] <= b[-1]):\n            b.append(stack.pop())\n    \n    if len(b) != n:\n        return -1\n    \n    return result\n\n# Input reading\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result\nresult = stack_sortable_permutation(n, k, p)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "21": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_index = a.index(1)\nmax_index = a.index(n)\n\n# Calculate the current distance\ncurrent_distance = abs(min_index - max_index)\n\n# Calculate the maximum possible distance after one swap\nmax_distance = max(min_index, max_index, n - 1 - min_index, n - 1 - max_index)\n\n# The maximum distance we can achieve is either the current distance or the new maximum distance\nresult = max(current_distance, max_distance)\n\nprint(result)\n```",
    "9": "```python\ndef find_grandpas_sofa(d, n, m, sofas, counts):\n    cnt_l, cnt_r, cnt_t, cnt_b = counts\n    sofas_count = []\n\n    for i in range(d):\n        x1, y1, x2, y2 = sofas[i]\n        left = right = top = bottom = 0\n        \n        # Determine the position of the current sofa\n        if x1 == x2:  # Vertical sofa\n            if y1 < y2:\n                y1, y2 = y2, y1  # Ensure y1 < y2\n            # Check for sofas to the left and right\n            for j in range(d):\n                if i == j:\n                    continue\n                x3, y3, x4, y4 = sofas[j]\n                if x3 == x4:  # Vertical sofa\n                    if y3 < y4:\n                        y3, y4 = y4, y3  # Ensure y3 < y4\n                    if x3 < x1:  # Left\n                        left += 1\n                    elif x3 > x1:  # Right\n                        right += 1\n                else:  # Horizontal sofa\n                    if x3 < x1 and (y3 == y1 or y4 == y1):  # Left\n                        left += 1\n                    elif x3 > x1 and (y3 == y2 or y4 == y2):  # Right\n                        right += 1\n        else:  # Horizontal sofa\n            if x1 < x2:\n                x1, x2 = x2, x1  # Ensure x1 < x2\n            # Check for sofas to the top and bottom\n            for j in range(d):\n                if i == j:\n                    continue\n                x3, y3, x4, y4 = sofas[j]\n                if x3 == x4:  # Vertical sofa\n                    if y3 < y4:\n                        y3, y4 = y4, y3  # Ensure y3 < y4\n                    if y3 < y1:  # Top\n                        top += 1\n                    elif y3 > y2:  # Bottom\n                        bottom += 1\n                else:  # Horizontal sofa\n                    if y3 < y1 and (x3 == x1 or x4 == x1):  # Top\n                        top += 1\n                    elif y3 > y2 and (x3 == x2 or x4 == x2):  # Bottom\n                        bottom += 1\n\n        if left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b:\n            sofas_count.append(i + 1)  # Store the 1-based index\n\n    return sofas_count[0] if sofas_count else -1\n\n\n# Input reading\nd = int(input())\nn, m = map(int, input().split())\nsofas = [tuple(map(int, input().split())) for _ in range(d)]\ncounts = tuple(map(int, input().split()))\n\n# Output the result\nprint(find_grandpas_sofa(d, n, m, sofas, counts))\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a, b):\n    from itertools import permutations\n\n    a_str = str(a)\n    b_str = str(b)\n\n    # Generate all unique permutations of the digits of a\n    permuted_numbers = sorted(set(int(''.join(p)) for p in permutations(a_str)), reverse=True)\n\n    # Find the maximum permutation that does not exceed b\n    for num in permuted_numbers:\n        if num <= b and len(str(num)) == len(a_str):\n            return num\n\n# Input reading\na = int(input().strip())\nb = int(input().strip())\n\n# Output the result\nprint(max_permutation_not_exceeding(a, b))\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # Since GCD(x, m) = 1, the x-mouse will visit all rooms in the cycle\n    # The number of unique rooms visited is equal to m\n    # The number of traps needed is equal to the number of unique rooms visited\n    return m\n\nm, x = map(int, input().split())\nprint(minimum_traps(m, x))\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror_chars = {'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M', 'O': 'O', 'o': 'o', 'p': 'q', 'q': 'p', 'R': 'R', 'S': 'S', 'T': 'T', 'U': 'U', 'v': 'v', 'V': 'V', 'W': 'W', 'x': 'x', 'Y': 'Y'}\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        if s[i] not in mirror_chars or s[n - 1 - i] != mirror_chars[s[i]]:\n            print(\"NIE\")\n            return\n    print(\"TAK\")\n\ns = input().strip()\nis_s_palindrome(s)\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = []\nregulars = []\n\nfor name, type_ in files:\n    if type_ == '1':\n        examples.append(name)\n    else:\n        regulars.append(name)\n\nmoves = []\ne = len(examples)\n\nfor i in range(e):\n    moves.append(f\"move {examples[i]} {i + 1}\")\n\nfor i in range(len(regulars)):\n    moves.append(f\"move {regulars[i]} {e + i + 1}\")\n\nprint(len(moves))\nfor move in moves:\n    print(move)\n```",
    "27": "```python\ndef min_operations(n, s):\n    min_ops = n  # Start with the maximum operations (typing each character)\n    \n    # Check for every possible prefix length\n    for i in range(1, n + 1):\n        prefix = s[:i]\n        # Check if the string can be formed by prefix + copy + remaining characters\n        if s.startswith(prefix):\n            # Calculate operations: type prefix + copy + remaining characters\n            operations = i + 1 + (n - 2 * i) if n >= 2 * i else i\n            min_ops = min(min_ops, operations)\n    \n    return min_ops\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(min_operations(n, s))\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    # Calculate the difference\n    diff = abs(sum_first - sum_second)\n    \n    # Create a list of possible changes\n    changes = []\n    if sum_first > sum_second:\n        # We need to decrease the first half or increase the second half\n        changes += [9 - digit for digit in first_half]  # Maximize decrease from first half\n        changes += [digit for digit in second_half]     # Maximize increase from second half\n    else:\n        # We need to decrease the second half or increase the first half\n        changes += [9 - digit for digit in second_half]  # Maximize decrease from second half\n        changes += [digit for digit in first_half]       # Maximize increase from first half\n    \n    # Sort changes in descending order\n    changes.sort(reverse=True)\n    \n    # Calculate the minimum number of changes needed\n    count = 0\n    for change in changes:\n        diff -= change\n        count += 1\n        if diff <= 0:\n            break\n    \n    return count\n\n# Example usage\nticket = input().strip()\nprint(min_replacements_to_lucky(ticket))\n```",
    "24": "```python\ndef can_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # vertical, horizontal, diagonal, anti-diagonal\n    n = 10\n\n    def check_win(x, y):\n        for dx, dy in directions:\n            count = 1  # count the current cross\n            # check in the positive direction\n            for step in range(1, 5):\n                nx, ny = x + step * dx, y + step * dy\n                if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                    count += 1\n                else:\n                    break\n            # check in the negative direction\n            for step in range(1, 5):\n                nx, ny = x - step * dx, y - step * dy\n                if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                    count += 1\n                else:\n                    break\n            if count >= 5:\n                return True\n        return False\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                board[i][j] = 'X'  # place a cross\n                if check_win(i, j):\n                    return \"YES\"\n                board[i][j] = '.'  # revert back\n    return \"NO\"\n\n# Read input\nboard = [input().strip() for _ in range(10)]\nprint(can_win(board))\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef birthday_paradox(n, k):\n    MOD = 1000003\n    days = 1 << n  # 2^n\n    if k > days:\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the probability of no shared birthdays\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator *= (days - i)\n        denominator *= days\n        numerator %= MOD\n        denominator %= MOD\n\n    # Probability of at least one shared birthday\n    A = (denominator - numerator) % MOD\n    B = denominator\n\n    # Reduce A/B to irreducible form\n    common_gcd = gcd(A, B)\n    A //= common_gcd\n    B //= common_gcd\n\n    return A % MOD, B % MOD\n\n# Read input\nn, k = map(int, input().split())\nresult = birthday_paradox(n, k)\nprint(result[0], result[1])\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    def can_distribute(x):\n        plates_for_a = (a + x - 1) // x  # ceil(a / x)\n        plates_for_b = (b + x - 1) // x  # ceil(b / x)\n        return plates_for_a + plates_for_b <= n\n\n    left, right = 1, max(a, b)\n    while left < right:\n        mid = (left + right + 1) // 2\n        if can_distribute(mid):\n            left = mid\n        else:\n            right = mid - 1\n    return left\n\nn, a, b = map(int, input().split())\nprint(max_min_pieces(n, a, b))\n```",
    "26": "```python\nimport sys\n\n# Read input\nx, y, z = map(float, sys.stdin.readline().strip().split())\n\n# Define the expressions and their corresponding values\nexpressions = [\n    (x**(y**z), \"x^y^z\"),\n    (x**(z**y), \"x^z^y\"),\n    ((x**y)**z, \"(x^y)^z\"),\n    ((x**z)**y, \"(x^z)^y\"),\n    (y**(x**z), \"y^x^z\"),\n    (y**(z**x), \"y^z^x\"),\n    ((y**x)**z, \"(y^x)^z\"),\n    ((y**z)**x, \"(y^z)^x\"),\n    (z**(x**y), \"z^x^y\"),\n    (z**(y**x), \"z^y^x\"),\n    ((z**x)**y, \"(z^x)^y\"),\n    ((z**y)**x, \"(z^y)^x\")\n]\n\n# Find the maximum value and its corresponding expression\nmax_value = -1\nmax_index = -1\n\nfor i, (value, expr) in enumerate(expressions):\n    if value > max_value:\n        max_value = value\n        max_index = i\n\n# Output the corresponding expression\nprint(expressions[max_index][1])\n```",
    "32": "```python\ndef is_valid_journey(n, journey):\n    position = 0  # Position on the meridian, 0 is North Pole, 20000 is South Pole\n\n    for t, direction in journey:\n        if position == 0 and direction != \"South\":\n            return \"NO\"\n        if position == 20000 and direction != \"North\":\n            return \"NO\"\n\n        if direction == \"South\":\n            position += t\n        elif direction == \"North\":\n            position -= t\n        elif direction == \"East\" or direction == \"West\":\n            # East and West do not change the position on the meridian\n            continue\n\n        if position < 0 or position > 20000:\n            return \"NO\"\n\n    if position != 0:\n        return \"NO\"\n\n    return \"YES\"\n\n# Input reading\nn = int(input())\njourney = [tuple(input().split()) for _ in range(n)]\njourney = [(int(t), direction) for t, direction in journey]\n\n# Output result\nprint(is_valid_journey(n, journey))\n```",
    "37": "```python\ndef can_deal_exact_damage(a, b, c):\n    for x in range(c // a + 1):\n        if (c - a * x) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\na, b, c = map(int, input().split())\nprint(can_deal_exact_damage(a, b, c))\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    if k > n * (n + 1) // 2:\n        return -1\n\n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k <= 0:\n            break\n        for j in range(i, n):\n            if k >= 2 and i != j:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n            elif k == 1 and i == j:\n                matrix[i][j] = 1\n                k -= 1\n                break\n\n    if k > 0:\n        return -1\n\n    return matrix\n\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    \n    if not is_palindrome(s):\n        return n\n    \n    for length in range(n - 1, 0, -1):\n        for start in range(n - length + 1):\n            substring = s[start:start + length]\n            if not is_palindrome(substring):\n                return length\n    \n    return 0\n\ns = input().strip()\nprint(longest_non_palindrome_substring(s))\n```",
    "35": "```python\ndef is_valid_flag(n, m, field):\n    colors = set()\n    stripe_height = n // 3\n\n    if n % 3 != 0:\n        return \"NO\"\n\n    # Check horizontal stripes\n    for i in range(3):\n        stripe = field[i * stripe_height:(i + 1) * stripe_height]\n        if len(set(row for row in stripe)) != 1:\n            return \"NO\"\n        colors.add(stripe[0][0])\n\n    if len(colors) != 3:\n        return \"NO\"\n\n    # Check if all rows in each stripe are the same\n    for i in range(3):\n        for j in range(stripe_height):\n            if field[i * stripe_height + j] != stripe[0]:\n                return \"NO\"\n\n    return \"YES\"\n\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\nprint(is_valid_flag(n, m, field))\n```",
    "36": "```python\ndef hexagonal_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 6 * layer\n\n    while n > moves_in_layer:\n        n -= moves_in_layer\n        layer += 1\n        moves_in_layer = 6 * layer\n\n    x, y = layer, 0\n\n    if n == 0:\n        return (x, y)\n\n    # Determine the direction and the position in the layer\n    direction = n // layer\n    position = n % layer\n\n    if direction == 0:  # Right\n        x += position\n        y += 0\n    elif direction == 1:  # Up-right\n        x += layer\n        y += position\n    elif direction == 2:  # Up-left\n        x += layer - position\n        y += layer\n    elif direction == 3:  # Left\n        x -= position\n        y += layer\n    elif direction == 4:  # Down-left\n        x -= layer\n        y -= position\n    elif direction == 5:  # Down-right\n        x -= layer - position\n        y -= layer\n\n    return (x, y)\n\nn = int(input())\nx, y = hexagonal_coordinates(n)\nprint(x, y)\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if any rating has changed\nrated = any(a != b for a, b in ratings)\n\nif rated:\n    print(\"rated\")\nelse:\n    # Check if the standings are in non-increasing order of ratings\n    for i in range(1, n):\n        if ratings[i-1][0] < ratings[i][0]:\n            print(\"unrated\")\n            break\n    else:\n        print(\"maybe\")\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n\n    def is_cyclic_shift(s1, s2):\n        return len(s1) == len(s2) and s1 in (s2 + s2)\n\n    def contains_substring(cyclic_str, substring):\n        for i in range(len(cyclic_str)):\n            if substring in cyclic_str[i:] + cyclic_str[:i]:\n                return True\n        return False\n\n    distinct_strings = set()\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if contains_substring(t, s):\n            distinct_strings.add(t)\n\n    return len(distinct_strings)\n\nn = int(input())\ns = input().strip()\nresult = count_cyclic_strings(n, s)\nprint(result)\n```",
    "38": "```python\ndef can_coincide(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between consecutive barriers for Kefa\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    # Calculate the distances between consecutive barriers for Sasha\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Check if kefa_diffs can be rotated to match sasha_diffs\n    for i in range(n):\n        if kefa_diffs == sasha_diffs[i:] + sasha_diffs[:i]:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output result\nprint(can_coincide(n, L, kefa_distances, sasha_distances))\n```",
    "41": "```python\ndef nearest_zero_distance(n, a):\n    distances = [float('inf')] * n\n    last_zero = -1\n\n    # Forward pass to find distances to the nearest zero\n    for i in range(n):\n        if a[i] == 0:\n            last_zero = i\n            distances[i] = 0\n        elif last_zero != -1:\n            distances[i] = i - last_zero\n\n    # Backward pass to find distances to the nearest zero\n    last_zero = -1\n    for i in range(n - 1, -1, -1):\n        if a[i] == 0:\n            last_zero = i\n        elif last_zero != -1:\n            distances[i] = min(distances[i], last_zero - i)\n\n    return distances\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result and print it\nresult = nearest_zero_distance(n, a)\nprint(' '.join(map(str, result)))\n```",
    "33": "```python\ndef count_common_ap(a1, b1, a2, b2, L, R):\n    from math import gcd\n\n    # Calculate the step size and the offset\n    step = abs(a1 * a2 // gcd(a1, a2))\n    \n    # Calculate the first common term\n    if a1 == a2:\n        if b1 == b2:\n            # If both sequences are identical\n            start = max(L, b1)\n            end = min(R, b1 + (R - b1) // a1 * a1)\n            return (end - start) // a1 + 1 if start <= end else 0\n        else:\n            return 0\n    \n    # Find the first common term\n    offset = (b2 - b1) % gcd(a1, a2)\n    if offset != 0:\n        return 0\n    \n    # Find the first term in the range [L, R]\n    first_term = (b1 + a1 * ((L - b1 + a1 - 1) // a1)) if (L - b1) % a1 != 0 else L\n    if first_term < L:\n        first_term += step\n    \n    # Find the last term in the range [L, R]\n    last_term = (b1 + a1 * ((R - b1) // a1))\n    if last_term > R:\n        last_term -= step\n    \n    # Count the number of terms\n    if first_term > last_term:\n        return 0\n    \n    return (last_term - first_term) // step + 1\n\n# Input reading\na1, b1, a2, b2, L, R = map(int, input().split())\n# Output the result\nprint(count_common_ap(a1, b1, a2, b2, L, R))\n```",
    "46": "```python\ndef count_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n    \n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n        \n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n        \n    result = 0\n    for i in range(5):\n        result += count_x[i] * count_y[(5 - i) % 5]\n        \n    return result\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    start += (k - 1) // length\n    num_str = str(start)\n    return int(num_str[(k - 1) % length])\n\nk = int(input())\nprint(find_kth_digit(k))\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Minimum sum of first k positive integers\n    min_sum = k * (k + 1) // 2\n    \n    if n < min_sum:\n        return -1\n    \n    # The maximum GCD we can use is n // k\n    max_gcd = n // k\n    \n    # We need to find the largest GCD such that the sum of the sequence is n\n    for g in range(max_gcd, 0, -1):\n        # Calculate the sum of the first k multiples of g\n        sum_k_multiples = g * min_sum\n        \n        if sum_k_multiples <= n and (n - sum_k_multiples) % g == 0:\n            # We can form the sequence\n            remainder = (n - sum_k_multiples) // g\n            sequence = [g * i for i in range(1, k)] + [g * (k + remainder)]\n            return sequence\n    \n    return -1\n\n# Input reading\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "43": "```python\nimport sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    vectors = []\n\n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().strip().split())\n        angle = math.atan2(y, x)\n        vectors.append((angle, i + 1))\n\n    vectors.sort()\n\n    min_angle = float('inf')\n    min_pair = (0, 0)\n\n    for i in range(n):\n        angle1, index1 = vectors[i]\n        angle2, index2 = vectors[(i + 1) % n]\n        angle_diff = abs(angle2 - angle1)\n        angle_diff = min(angle_diff, 2 * math.pi - angle_diff)\n\n        if angle_diff < min_angle:\n            min_angle = angle_diff\n            min_pair = (index1, index2)\n\n    print(min_pair[0], min_pair[1])\n\nif __name__ == \"__main__\":\n    main()\n```",
    "51": "```python\nfrom collections import Counter\nimport sys\n\ndef find_x_and_y(divisors):\n    count = Counter(divisors)\n    common_divisors = [d for d in count if count[d] > 1]\n    \n    # The largest number in the list should be x or y\n    x = max(divisors)\n    y = 1\n    \n    # Remove the largest number from the count\n    count[x] -= 1\n    if count[x] == 0:\n        del count[x]\n    \n    # Now we need to find y\n    for d in count:\n        if count[d] > 0:\n            y = d\n            break\n    \n    return x, y\n\nif __name__ == \"__main__\":\n    n = int(sys.stdin.readline().strip())\n    divisors = list(map(int, sys.stdin.readline().strip().split()))\n    \n    x, y = find_x_and_y(divisors)\n    print(x, y)\n```",
    "48": "```python\ndef kth_largest_in_multiplication_table(n, m, k):\n    left, right = 1, n * m\n    \n    while left < right:\n        mid = (left + right) // 2\n        count = sum(min(mid // i, m) for i in range(1, n + 1))\n        \n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return left\n\nn, m, k = map(int, input().split())\nprint(kth_largest_in_multiplication_table(n, m, k))\n```",
    "44": "```python\ndef minimal_time_to_post_office(d, k, a, b, t):\n    # Calculate the time if Vasiliy walks the entire distance\n    min_time = d * b\n    \n    # Calculate the maximum number of full segments Vasiliy can drive\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Calculate the time for driving full segments and walking the remaining distance\n    if full_segments > 0:\n        time_with_driving = full_segments * (k * a + t) + remaining_distance * b - t\n        min_time = min(min_time, time_with_driving)\n    \n    # Calculate the time for driving full segments and repairing the car\n    if full_segments > 0 and remaining_distance > 0:\n        time_with_driving_and_repair = full_segments * (k * a + t) + remaining_distance * a\n        min_time = min(min_time, time_with_driving_and_repair)\n    \n    # Calculate the time for driving the last segment if it fits\n    if remaining_distance > 0:\n        time_with_partial_drive = full_segments * (k * a + t) + remaining_distance * a\n        min_time = min(min_time, time_with_partial_drive)\n    \n    return min_time\n\n# Input reading\nd, k, a, b, t = map(int, input().split())\nprint(minimal_time_to_post_office(d, k, a, b, t))\n```",
    "54": "```python\ndef minimum_D(n, a):\n    min_a = min(a)\n    max_a = max(a)\n\n    if min_a == max_a:\n        return 0\n\n    if (max_a - min_a) % 2 != 0:\n        return -1\n\n    D = (max_a - min_a) // 2\n    return D\n\nn = int(input())\na = list(map(int, input().split()))\nprint(minimum_D(n, a))\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef reachable_count(n):\n    reachable = set()\n    current = n\n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    return len(reachable)\n\nn = int(input())\nprint(reachable_count(n))\n```",
    "47": "```python\ndef max_beauty(n, x, a):\n    # Function to calculate the maximum subarray sum using Kadane's algorithm\n    def kadane(arr):\n        max_ending_here = max_so_far = 0\n        for value in arr:\n            max_ending_here = max(0, max_ending_here + value)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    # Calculate the beauty of the original array\n    original_beauty = kadane(a)\n\n    # If x is 1, multiplying by x doesn't change the array\n    if x == 1:\n        return original_beauty\n\n    # Calculate the maximum beauty after multiplying a subarray by x\n    max_with_x = 0\n    current_sum = 0\n\n    for i in range(n):\n        current_sum += a[i]\n        max_with_x = max(max_with_x, current_sum * x)\n        current_sum = max(current_sum, 0)\n\n    # Now we need to consider the case where we multiply a subarray by x\n    # We will calculate the maximum sum of the array after applying the multiplication\n    max_sum_with_x = 0\n    current_sum = 0\n\n    for i in range(n):\n        current_sum += a[i]\n        max_sum_with_x = max(max_sum_with_x, current_sum)\n        current_sum = max(current_sum, 0)\n\n    # Now we need to consider the case where we multiply a subarray by x\n    max_sum_with_x = max(max_sum_with_x, original_beauty + max_with_x)\n\n    return max(original_beauty, max_sum_with_x)\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_beauty(n, x, a))\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_choose = m // 2\n    dp = [[-1] * k for _ in range(max_choose + 1)]\n    dp[0][0] = 0  # Base case: choosing 0 elements gives sum 0 which is divisible by k\n\n    for row in matrix:\n        current_dp = [dp[i][:] for i in range(max_choose + 1)]\n        row.sort(reverse=True)  # Sort row in descending order to maximize sum\n        for count in range(1, max_choose + 1):\n            for j in range(min(count, len(row)) + 1):\n                if j > 0:\n                    new_sum = sum(row[:j])\n                    for mod in range(k):\n                        if current_dp[count - j][mod] != -1:\n                            new_mod = (mod + new_sum) % k\n                            new_value = current_dp[count - j][mod] + new_sum\n                            current_dp[count][new_mod] = max(current_dp[count][new_mod], new_value)\n        dp = current_dp\n\n    return max(dp[i][0] for i in range(max_choose + 1) if dp[i][0] != -1)\n\n# Input reading\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_sum_divisible_by_k(n, m, k, matrix))\n```",
    "61": "```python\ndef max_number_after_replacement(n, a, f):\n    a_list = list(a)\n    modified = False\n    \n    for i in range(n):\n        original_digit = int(a_list[i])\n        new_digit = f[original_digit - 1]\n        \n        if new_digit > original_digit:\n            a_list[i] = str(new_digit)\n            modified = True\n        elif modified and new_digit < original_digit:\n            break\n    \n    return ''.join(a_list)\n\n# Input reading\nn = int(input())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\n# Output the result\nprint(max_number_after_replacement(n, a, f))\n```",
    "59": "```python\ndef min_operations_to_remainder(n, x, y, number):\n    # The target remainder is 10^y, which means we need the last (y+1) digits\n    # to be '000...010...0' where there are y zeros followed by a 1.\n    \n    target = ['0'] * x\n    target[y] = '1'\n    \n    # Count the number of changes needed\n    operations = 0\n    for i in range(x):\n        if number[n - 1 - i] != target[x - 1 - i]:\n            operations += 1\n            \n    return operations\n\n# Input reading\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# Output the result\nprint(min_operations_to_remainder(n, x, y, number))\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph):\n    visited = {start: 0}\n    queue = deque([start])\n    farthest_node = start\n    max_distance = 0\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > max_distance:\n                    max_distance = visited[neighbor]\n                    farthest_node = neighbor\n                    \n    return farthest_node, max_distance\n\ndef find_max_edges_and_vertices(n, edges):\n    graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Step 1: Find the farthest node from an arbitrary node (1)\n    farthest_from_start, _ = bfs(1, graph)\n    \n    # Step 2: Find the farthest node from the farthest node found in step 1\n    farthest_from_a, _ = bfs(farthest_from_start, graph)\n    \n    # Step 3: Find the farthest node from the farthest node found in step 2\n    farthest_from_b, _ = bfs(farthest_from_a, graph)\n    \n    # The diameter of the tree is the distance between farthest_from_start and farthest_from_b\n    diameter_length = _\n\n    # To maximize the number of edges in the paths, we can choose the endpoints of the diameter\n    # and one more vertex that is not on the path between them.\n    \n    # We can use BFS again to find the path from farthest_from_start to farthest_from_b\n    def find_path(start, end):\n        parent = {start: None}\n        queue = deque([start])\n        path = []\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in graph[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        # Reconstruct the path\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        \n        return path[::-1]\n    \n    path = find_path(farthest_from_start, farthest_from_b)\n    \n    # Choose the two endpoints of the diameter\n    a = farthest_from_start\n    b = farthest_from_b\n    \n    # Choose a third vertex that is not on the path\n    path_set = set(path)\n    c = None\n    for node in range(1, n + 1):\n        if node not in path_set and node != a and node != b:\n            c = node\n            break\n    \n    return diameter_length + 1, a, b, c\n\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\nres, a, b, c = find_max_edges_and_vertices(n, edges)\nprint(res)\nprint(a, b, c)\n```",
    "55": "```python\ndef can_see_white_sheet(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n    # Check if there is any part of the white sheet that is not covered by both black sheets\n    # The white sheet is visible if there is at least one point that is:\n    # - Not strictly inside the white sheet (i.e., outside or on the border)\n    # - Strictly outside both black sheets\n\n    # Check the left side of the white sheet\n    if x1 > x3 and x1 > x5:\n        return \"YES\"\n    \n    # Check the right side of the white sheet\n    if x2 < x4 and x2 < x6:\n        return \"YES\"\n    \n    # Check the bottom side of the white sheet\n    if y1 > y4 and y1 > y6:\n        return \"YES\"\n    \n    # Check the top side of the white sheet\n    if y2 < y3 and y2 < y5:\n        return \"YES\"\n    \n    # Check if the white sheet is completely covered by both black sheets\n    if (x3 <= x1 < x4 and y3 <= y1 < y4 and\n        x3 < x2 <= x4 and y3 < y2 <= y4) or \\\n       (x5 <= x1 < x6 and y5 <= y1 < y6 and\n        x5 < x2 <= x6 and y5 < y2 <= y6):\n        return \"NO\"\n    \n    # If none of the above conditions are met, the white sheet is visible\n    return \"YES\"\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Output the result\nprint(can_see_white_sheet(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6))\n```",
    "57": "```python\ndef fill_gift_values(n, f):\n    # Create a list to store the final gift assignments\n    nf = f[:]\n    \n    # Find the friends who have not been assigned a gift\n    unassigned = []\n    for i in range(n):\n        if nf[i] == 0:\n            unassigned.append(i + 1)  # Store 1-based index\n\n    # Find the friends who are already assigned gifts\n    assigned = set(fi for fi in f if fi != 0)\n\n    # Find the friends who are not assigned any gifts\n    not_assigned = [i for i in range(1, n + 1) if i not in assigned]\n\n    # Fill the unassigned friends with the not assigned friends\n    for i in range(len(unassigned)):\n        # Assign the gift to the next available friend\n        nf[unassigned[i] - 1] = not_assigned[i]\n\n    return nf\n\n# Input reading\nn = int(input())\nf = list(map(int, input().split()))\n\n# Get the result\nresult = fill_gift_values(n, f)\n\n# Print the result\nprint(' '.join(map(str, result)))\n```",
    "58": "```python\ndef color_array(n, k, a):\n    from collections import defaultdict\n\n    color_assignment = [0] * n\n    color_count = defaultdict(int)\n    element_positions = defaultdict(list)\n\n    # Collect positions of each element\n    for index, value in enumerate(a):\n        element_positions[value].append(index)\n\n    # Check if we can color the array\n    if any(len(positions) > k for positions in element_positions.values()):\n        print(\"NO\")\n        return\n\n    # Assign colors\n    current_color = 1\n    for positions in element_positions.values():\n        for pos in positions:\n            color_assignment[pos] = current_color\n            current_color += 1\n            if current_color > k:\n                current_color = 1\n\n    print(\"YES\")\n    print(\" \".join(map(str, color_assignment)))\n\n# Example usage:\n# n, k = map(int, input().split())\n# a = list(map(int, input().split()))\n# color_array(n, k, a)\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        min_moves = float('inf')\n        best_triplet = (a, b, c)\n\n        # Check for all possible A, B, C combinations\n        for A in range(1, a + 1):\n            for B in range(A, c + 1):\n                if B % A == 0:\n                    C = B\n                    while C <= 10000:\n                        moves = abs(A - a) + abs(B - b) + abs(C - c)\n                        if moves < min_moves:\n                            min_moves = moves\n                            best_triplet = (A, B, C)\n                        C += B\n        \n        results.append((min_moves, best_triplet))\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations(t, test_cases)\n\n# Print output\nfor moves, triplet in results:\n    print(moves)\n    print(*triplet)\n```",
    "63": "```python\ndef min_instability(n, a):\n    a.sort()\n    # Remove the smallest or the largest element\n    instability_remove_min = a[-1] - a[1]  # Remove the smallest element\n    instability_remove_max = a[-2] - a[0]  # Remove the largest element\n    return min(instability_remove_min, instability_remove_max)\n\nn = int(input())\na = list(map(int, input().split()))\nprint(min_instability(n, a))\n```",
    "65": "```python\ndef min_moves(n, m):\n    if m % n != 0:\n        return -1\n    \n    ratio = m // n\n    moves = 0\n    \n    while ratio > 1:\n        if ratio % 2 == 0:\n            ratio //= 2\n            moves += 1\n        elif ratio % 3 == 0:\n            ratio //= 3\n            moves += 1\n        else:\n            return -1\n            \n    return moves\n\nn, m = map(int, input().split())\nprint(min_moves(n, m))\n```",
    "60": "```python\ndef has_palindrome_subsequence(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        found = False\n        # Use a dictionary to track the first occurrence of each number\n        first_occurrence = {}\n        for i in range(n):\n            if a[i] in first_occurrence:\n                # If we find the same number again, we can form a palindrome\n                if i - first_occurrence[a[i]] >= 2:\n                    found = True\n                    break\n            else:\n                first_occurrence[a[i]] = i\n        results.append(\"YES\" if found else \"NO\")\n    return results\n\n# Example usage:\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\nresults = has_palindrome_subsequence(t, test_cases)\nfor result in results:\n    print(result)\n```",
    "71": "```python\ndef count_set_bits(n):\n    return bin(n).count('1')\n\na = int(input())\nprint(count_set_bits(a))\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = -1\n    moves = []\n    \n    while left <= right:\n        if a[left] < a[right]:\n            if a[left] > last_taken:\n                moves.append('L')\n                last_taken = a[left]\n                left += 1\n            elif a[right] > last_taken:\n                moves.append('R')\n                last_taken = a[right]\n                right -= 1\n            else:\n                break\n        else:\n            if a[right] > last_taken:\n                moves.append('R')\n                last_taken = a[right]\n                right -= 1\n            elif a[left] > last_taken:\n                moves.append('L')\n                last_taken = a[left]\n                left += 1\n            else:\n                break\n\n    print(len(moves))\n    print(''.join(moves))\n\n# Example usage:\n# n = int(input())\n# a = list(map(int, input().split()))\n# longest_increasing_sequence(n, a)\n```",
    "70": "```python\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Convert start and end times to minutes\nstart_minutes = h1 * 60 + m1\nend_minutes = h2 * 60 + m2\n\n# Calculate the midpoint in minutes\nmidpoint_minutes = (start_minutes + end_minutes) // 2\n\n# Convert back to hours and minutes\nh3 = midpoint_minutes // 60\nm3 = midpoint_minutes % 60\n\n# Print the result in hh:mm format\nprint(f\"{h3:02}:{m3:02}\")\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Find the longest suffix of t that is also a prefix\n    for i in range(n - 1, -1, -1):\n        if t[:i] == t[-i:]:\n            overlap_length = i\n            break\n    else:\n        overlap_length = 0\n\n    # Construct the result string\n    result = t + (t[overlap_length:] * (k - 1))\n    return result\n\n# Read input\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the result and print it\nresult = construct_string(n, k, t)\nprint(result)\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    days = [0] * n\n    exam_days = set()\n    preparation_needed = [0] * m\n    \n    for i in range(m):\n        s, d, c = exams[i]\n        preparation_needed[i] = c\n        exam_days.add(d - 1)  # Store exam days (0-indexed)\n    \n    for i in range(m):\n        s, d, c = exams[i]\n        prep_days = 0\n        \n        for j in range(s - 1, d - 1):  # s-1 to d-2 (0-indexed)\n            if prep_days < c and days[j] == 0:\n                days[j] = i + 1  # Mark preparation for exam i\n                prep_days += 1\n        \n        if prep_days < c:\n            return -1  # Not enough preparation days\n    \n    for i in range(n):\n        if days[i] == 0 and i in exam_days:\n            days[i] = m + 1  # Mark exam day\n        elif days[i] == 0:\n            days[i] = 0  # Rest day\n    \n    return days\n\n# Input reading\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\nresult = schedule_exams(n, m, exams)\n\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "67": "```python\ndef find_nice_indices(n, a):\n    total_sum = sum(a)\n    nice_indices = []\n\n    for i in range(n):\n        if (total_sum - a[i]) % 2 == 0:\n            target = (total_sum - a[i]) // 2\n            if target in a and (target != a[i] or a.count(target) > 1):\n                nice_indices.append(i + 1)\n\n    print(len(nice_indices))\n    if nice_indices:\n        print(\" \".join(map(str, nice_indices)))\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\nfind_nice_indices(n, a)\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import Counter\n    \n    # Count the frequency of each character\n    freq = Counter(s)\n    \n    # Calculate the total number of unique subsequences\n    total_unique_subsequences = 0\n    total_cost = 0\n    \n    # Generate all possible subsequences and their costs\n    for length in range(n + 1):\n        for char, count in freq.items():\n            if count > 0:\n                # Calculate the number of subsequences of this length\n                subsequences_count = (1 << count) - 1  # 2^count - 1 (excluding empty subsequence)\n                total_unique_subsequences += subsequences_count\n                \n                # Calculate the cost for subsequences of this length\n                total_cost += subsequences_count * (n - length)\n                \n                if total_unique_subsequences >= k:\n                    return total_cost\n    \n    # If we cannot reach k unique subsequences\n    if total_unique_subsequences < k:\n        return -1\n    \n    return total_cost\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result and print it\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "73": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmax_height = max(a)\ntotal_bricks_needed = 0\n\nfor height in a:\n    total_bricks_needed += max_height - height\n\n# Check if the total number of bricks needed is even\nif total_bricks_needed % 2 == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "77": "```python\ndef minimum_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nn = int(input())\nprint(minimum_difference(n))\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    unique_subsequences = set()\n    \n    # Generate all possible subsequences\n    for i in range(1 << n):\n        subsequence = []\n        for j in range(n):\n            if i & (1 << j):\n                subsequence.append(s[j])\n        unique_subsequences.add(''.join(subsequence))\n    \n    # If we can't obtain k unique subsequences\n    if len(unique_subsequences) < k:\n        return -1\n    \n    # Calculate the minimum cost\n    costs = []\n    for subseq in unique_subsequences:\n        cost = n - len(subseq)\n        costs.append(cost)\n    \n    costs.sort()\n    \n    return sum(costs[:k])\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    lefts = [l for l, r in segments]\n    rights = [r for l, r in segments]\n\n    # Precompute the maximum left and minimum right excluding each segment\n    max_left_exclude = [0] * n\n    min_right_exclude = [0] * n\n\n    max_left = float('-inf')\n    for i in range(n):\n        max_left_exclude[i] = max_left\n        max_left = max(max_left, lefts[i])\n\n    min_right = float('inf')\n    for i in range(n - 1, -1, -1):\n        min_right_exclude[i] = min_right\n        min_right = min(min_right, rights[i])\n\n    max_length = 0\n    for i in range(n):\n        left = max(max_left_exclude[i], lefts[i])\n        right = min(min_right_exclude[i], rights[i])\n        if right >= left:\n            max_length = max(max_length, right - left)\n\n    return max_length\n\n# Input reading\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\nprint(max_intersection_length(n, segments))\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n\n    if D >= n:\n        print(\"NO\")\n        return\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    degree = {i: 0 for i in range(1, n + 1)}\n    spanning_tree_edges = []\n    visited = set()\n    \n    # BFS to create a spanning tree\n    def bfs(start):\n        queue = deque([start])\n        visited.add(start)\n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if neighbor not in visited and degree[node] < D:\n                    visited.add(neighbor)\n                    spanning_tree_edges.append((node, neighbor))\n                    degree[node] += 1\n                    degree[neighbor] += 1\n                    queue.append(neighbor)\n                    if degree[node] == D:\n                        break\n\n    bfs(1)\n\n    if degree[1] != D:\n        print(\"NO\")\n        return\n\n    # Add remaining edges to complete the spanning tree\n    for u in range(1, n + 1):\n        for v in graph[u]:\n            if degree[u] < 1 and degree[v] < 1 and (u, v) not in spanning_tree_edges and (v, u) not in spanning_tree_edges:\n                spanning_tree_edges.append((u, v))\n                degree[u] += 1\n                degree[v] += 1\n                if len(spanning_tree_edges) == n - 1:\n                    break\n\n    if len(spanning_tree_edges) == n - 1:\n        print(\"YES\")\n        for u, v in spanning_tree_edges:\n            print(u, v)\n    else:\n        print(\"NO\")\n\n# Example usage:\n# n, m, D = map(int, input().split())\n# edges = [tuple(map(int, input().split())) for _ in range(m)]\n# find_spanning_tree(n, m, D, edges)\n```",
    "82": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncount = 0\n\n# Solve from the left\nwhile count < n and a[count] <= k:\n    count += 1\n\n# Solve from the right\nwhile count < n and a[n - 1 - (count - (n - len(a)))] <= k:\n    count += 1\n\n# Adjust for double counting\nif count > n:\n    count = n\n\nprint(count)\n```",
    "81": "```python\ndef can_reorder_strings(n, strings):\n    # Sort strings by length\n    strings.sort(key=len)\n    \n    # Check if the ordering is valid\n    for i in range(1, n):\n        found = False\n        for j in range(i):\n            if strings[j] in strings[i]:\n                found = True\n                break\n        if not found:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    for s in strings:\n        print(s)\n\n# Input reading\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\ncan_reorder_strings(n, strings)\n```",
    "76": "```python\ndef can_construct_symmetric_square(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Check for pairs of tiles that can form the required symmetry\n        can_form = False\n        tile_map = {}\n        \n        for tile in tiles:\n            top_left, top_right = tile[0]\n            bottom_left, bottom_right = tile[1]\n            # Store tiles in a way to check symmetry easily\n            tile_map[(top_left, top_right)] = (bottom_left, bottom_right)\n        \n        # Check if we can find a matching tile for symmetry\n        for tile in tiles:\n            top_left, top_right = tile[0]\n            bottom_left, bottom_right = tile[1]\n            if (bottom_left, bottom_right) in tile_map:\n                can_form = True\n                break\n        \n        results.append(\"YES\" if can_form else \"NO\")\n    \n    return results\n\n# Input reading and function calling would go here\n```",
    "84": "```python\ndef can_color_string(n, s):\n    # Count occurrences of each character\n    from collections import Counter\n    count = Counter(s)\n    \n    # Check if any character appears more than twice\n    if any(c > 2 for c in count.values()):\n        return \"NO\"\n    \n    # Prepare the coloring\n    color = ['0'] * n\n    last_color = '0'\n    \n    # Assign colors\n    for i in range(n):\n        if i > 0 and s[i] == s[i - 1]:\n            color[i] = last_color\n        else:\n            last_color = '1' if last_color == '0' else '0'\n            color[i] = last_color\n    \n    return \"YES\", ''.join(color)\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult = can_color_string(n, s)\n\n# Output the result\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    print(result[1])\n```",
    "85": "```python\ndef find_price(A, B):\n    for price in range(1, 10000):  # Arbitrarily large limit for price\n        tax_8 = price * 0.08\n        tax_10 = price * 0.10\n        if int(tax_8) == A and int(tax_10) == B:\n            return price\n    return -1\n\nA, B = map(int, input().split())\nresult = find_price(A, B)\nprint(result)\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    from collections import defaultdict\n\n    # Step 1: Create a mapping of characters to their positions\n    char_positions = defaultdict(list)\n    for index, char in enumerate(s):\n        char_positions[char].append(index)\n\n    # Step 2: Create a list to store the color for each character\n    colors = [0] * n\n    color_count = 0\n\n    # Step 3: Assign colors based on the positions of characters\n    for char in sorted(char_positions.keys()):\n        positions = char_positions[char]\n        current_color = 1\n        for pos in positions:\n            # If the current position can be colored with the same color as the last one\n            if pos > 0 and s[pos] == s[pos - 1]:\n                colors[pos] = colors[pos - 1]\n            else:\n                colors[pos] = current_color\n                current_color += 1\n                color_count = max(color_count, current_color - 1)\n\n    return color_count, colors\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Get the result\nresult_color_count, result_colors = min_colors_to_sort(n, s)\n\n# Output the result\nprint(result_color_count)\nprint(' '.join(map(str, result_colors)))\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    min_moves = float('inf')\n\n    # Check for pairs of digits that can form 25 or 00\n    for target in ['00', '25']:\n        last_digit = target[1]\n        first_digit = target[0]\n        \n        # Find the last occurrence of the last_digit\n        last_index = -1\n        for i in range(length - 1, -1, -1):\n            if s[i] == last_digit:\n                last_index = i\n                break\n        \n        if last_index == -1:\n            continue  # No last_digit found\n        \n        # Now find the first_digit before the last_digit\n        first_index = -1\n        for i in range(last_index - 1, -1, -1):\n            if s[i] == first_digit:\n                first_index = i\n                break\n        \n        if first_index == -1:\n            continue  # No first_digit found\n        \n        # Calculate moves to bring first_digit to the front of last_digit\n        moves = (last_index - first_index) + (first_index)\n        min_moves = min(min_moves, moves)\n\n    return min_moves if min_moves != float('inf') else -1\n\n# Read input\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n    \n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            # Check for red rectangle\n            for red_width in range(1, int(a**0.5) + 1):\n                if a % red_width == 0:\n                    red_height = a // red_width\n                    if red_width <= width and red_height <= height:\n                        # Check for blue rectangle\n                        for blue_width in range(1, int(b**0.5) + 1):\n                            if b % blue_width == 0:\n                                blue_height = b // blue_width\n                                if blue_width <= width and blue_height <= height:\n                                    perimeter = 2 * (width + height)\n                                    min_perimeter = min(min_perimeter, perimeter)\n    \n    return min_perimeter\n\na, b = map(int, input().split())\nprint(minimal_perimeter(a, b))\n```",
    "78": "```python\nMOD = 10**9 + 7\n\ndef count_regular_sequences(n, s):\n    m = len(s)\n    \n    # Precompute factorials and inverse factorials\n    fact = [1] * (2 * n + 1)\n    for i in range(2, 2 * n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n\n    def mod_inv(x):\n        return pow(x, MOD - 2, MOD)\n\n    inv_fact = [1] * (2 * n + 1)\n    for i in range(2, 2 * n + 1):\n        inv_fact[i] = mod_inv(fact[i])\n\n    # Check the balance of the substring s\n    balance = 0\n    min_balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n\n    if balance < 0 or balance + 2 * n < 0:\n        return 0\n\n    # Count valid placements of s in a valid sequence\n    total_count = 0\n    for prefix_length in range(n + 1):\n        suffix_length = n - prefix_length\n        if min_balance + prefix_length < 0:\n            continue\n        \n        # Calculate the number of valid sequences\n        total_count += (fact[prefix_length + suffix_length] * inv_fact[prefix_length] % MOD * inv_fact[suffix_length] % MOD) % MOD\n        total_count %= MOD\n\n    return total_count\n\nn = int(input())\ns = input().strip()\nprint(count_regular_sequences(n, s))\n```",
    "86": "```python\ndef solve_problems(n, k):\n    # Minimum sum of the first k natural numbers\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n    \n    # Start with the minimum valid sequence\n    a = list(range(1, k + 1))\n    current_sum = min_sum\n    \n    # Distribute the remaining problems\n    remaining = n - current_sum\n    for i in range(k - 1, -1, -1):\n        # Maximum we can add to a[i] while respecting the constraints\n        max_add = min(remaining, (2 * a[i]) - a[i])\n        a[i] += max_add\n        remaining -= max_add\n        if remaining <= 0:\n            break\n    \n    if sum(a) == n:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n    else:\n        print(\"NO\")\n\n# Example usage\nn, k = map(int, input().split())\nsolve_problems(n, k)\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    projects.sort(key=lambda x: (x[0], -x[1]))  # Sort by required rating, then by rating change\n    count = 0\n    current_rating = r\n    \n    for a, b in projects:\n        if current_rating >= a:  # Can start the project\n            count += 1\n            current_rating += b  # Update rating after completing the project\n            if current_rating < 0:  # Ensure rating doesn't fall below zero\n                break\n    \n    return count\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_projects(n, r, projects))\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects by their required rating\n    projects.sort(key=lambda x: x[0])\n    \n    for a, b in projects:\n        if r < a:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if all projects can be completed\nresult = can_complete_projects(n, r, projects)\nprint(result)\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Define the food consumption pattern for each day of the week\n    week_pattern = [0, 0, 1, 0, 0, 1, 0]  # Fish food on Mon, Thu, Sun; Rabbit stew on Tue, Sat; Chicken stake on Wed\n    food_needed = [0, 0, 0]  # [fish, rabbit, chicken]\n    \n    # Count how many of each food is needed in one week\n    for i in range(7):\n        if week_pattern[i] == 0:\n            food_needed[0] += 1  # Fish food\n        elif week_pattern[i] == 1:\n            food_needed[1] += 1  # Rabbit stew\n        else:\n            food_needed[2] += 1  # Chicken stake\n    \n    # Calculate how many complete weeks can be sustained\n    full_weeks = min(a // food_needed[0], b // food_needed[1], c // food_needed[2])\n    days = full_weeks * 7\n    \n    # Remaining food after consuming full weeks\n    a -= full_weeks * food_needed[0]\n    b -= full_weeks * food_needed[1]\n    c -= full_weeks * food_needed[2]\n    \n    # Check for the maximum additional days possible starting from each day of the week\n    max_additional_days = 0\n    for start_day in range(7):\n        remaining_a, remaining_b, remaining_c = a, b, c\n        additional_days = 0\n        \n        for day in range(7):\n            current_day = (start_day + day) % 7\n            if current_day in [0, 3, 6]:  # Fish food days\n                if remaining_a > 0:\n                    remaining_a -= 1\n                    additional_days += 1\n                else:\n                    break\n            elif current_day in [1, 5]:  # Rabbit stew days\n                if remaining_b > 0:\n                    remaining_b -= 1\n                    additional_days += 1\n                else:\n                    break\n            else:  # Chicken stake day\n                if remaining_c > 0:\n                    remaining_c -= 1\n                    additional_days += 1\n                else:\n                    break\n        \n        max_additional_days = max(max_additional_days, additional_days)\n    \n    return days + max_additional_days\n\n# Input reading\na, b, c = map(int, input().split())\nprint(max_days(a, b, c))\n```",
    "92": "```python\nx = float(input().strip())\n\n# Calculate the integers a and b\na = int(x * 10) % 10 + 1\nb = int(x * 10) // 10 + 1\n\n# Ensure a and b are within the range [1, 10]\nif a < 1:\n    a = 1\nif a > 10:\n    a = 10\nif b < 1:\n    b = 1\nif b > 10:\n    b = 10\n\nprint(a, b)\n```",
    "98": "```python\ndef min_moves_to_n(N):\n    moves = float('inf')\n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            moves = min(moves, i + j - 2)\n    return moves\n\nN = int(input())\nprint(min_moves_to_n(N))\n```",
    "97": "```python\ndef min_coins_to_move_chips(n, positions):\n    odd_count = sum(1 for x in positions if x % 2 != 0)\n    even_count = n - odd_count\n    return min(odd_count, even_count)\n\nn = int(input())\npositions = list(map(int, input().split()))\nprint(min_coins_to_move_chips(n, positions))\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Create the base string with n 'a's, n 'b's, and n 'c's\n    base = 'a' * n + 'b' * n + 'c' * n\n    \n    # Check if the forbidden substrings are present\n    if s in base or t in base:\n        return \"NO\"\n    \n    # Try to construct a valid string\n    from itertools import permutations\n    \n    # Generate all permutations of the base string\n    for perm in set(permutations(base)):\n        res = ''.join(perm)\n        if s not in res and t not in res:\n            return \"YES\\n\" + res\n    \n    return \"NO\"\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\nt = input().strip()\n\n# Generate the result\nresult = generate_string(n, s, t)\nprint(result)\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    p = [0] * n\n    p[0] = 0  # We can start from any arbitrary number, we will adjust later\n\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n\n    min_p = min(p)\n    # Shift the permutation to make the smallest element 1\n    shift = 1 - min_p\n\n    for i in range(n):\n        p[i] += shift\n\n    # Check if the resulting permutation is valid\n    if len(set(p)) == n and all(1 <= x <= n for x in p):\n        print(\" \".join(map(str, p)))\n    else:\n        print(-1)\n\n# Example usage:\nn = int(input())\nq = list(map(int, input().split()))\nrestore_permutation(n, q)\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n\n    # Create arrays to store the first occurrence of t in s from the left and right\n    left = [0] * m\n    right = [0] * m\n\n    # Fill the left array\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n\n    # Fill the right array\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n\n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n\n    # Consider removing from the start or the end\n    max_length = max(max_length, right[0])  # Remove from the start\n    max_length = max(max_length, n - 1 - left[m - 1])  # Remove from the end\n\n    return max_length\n\n# Read input\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(max_removable_length(s, t))\n```",
    "90": "```python\ndef can_reach_end(n, m, d, c):\n    # Calculate the total length of platforms\n    total_length = sum(c)\n    \n    # If the maximum jump distance is greater than or equal to n, we can always reach the end\n    if d >= n + 1:\n        print(\"YES\")\n        print(\"0 \" * n + str(1))\n        return\n    \n    # Initialize the river representation\n    river = [0] * n\n    \n    # Start placing platforms\n    current_position = 0\n    for i in range(m):\n        # Place the platform at the current position\n        for j in range(c[i]):\n            if current_position < n:\n                river[current_position] = i + 1\n                current_position += 1\n            else:\n                break\n    \n    # Check if we can reach the end\n    last_position = -1\n    for i in range(n):\n        if river[i] != 0:\n            last_position = i\n    \n    # Check if we can jump from the last platform to the end\n    if last_position == -1 or (last_position + d < n + 1):\n        print(\"NO\")\n        return\n    \n    # Output the result\n    print(\"YES\")\n    print(\" \".join(map(str, river)))\n\n# Read input\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\ncan_reach_end(n, m, d, c)\n```",
    "88": "```python\ndef create_palindromic_matrix(n, numbers):\n    from collections import Counter\n    \n    count = Counter(numbers)\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Check if we can form a palindromic matrix\n    odd_count = 0\n    center_value = None\n    \n    for value, cnt in count.items():\n        if cnt % 2 != 0:\n            odd_count += 1\n            center_value = value\n        if odd_count > 1:\n            return \"NO\"\n    \n    # Fill the matrix\n    half_matrix = []\n    for value, cnt in count.items():\n        half_matrix.extend([value] * (cnt // 2))\n    \n    half_size = len(half_matrix)\n    if n % 2 == 0:\n        # Even size matrix\n        for i in range(n // 2):\n            for j in range(n // 2):\n                matrix[i][j] = half_matrix[i * (n // 2) + j]\n                matrix[i][n - j - 1] = matrix[i][j]\n                matrix[n - i - 1][j] = matrix[i][j]\n                matrix[n - i - 1][n - j - 1] = matrix[i][j]\n    else:\n        # Odd size matrix\n        for i in range(n // 2):\n            for j in range(n // 2):\n                matrix[i][j] = half_matrix[i * (n // 2) + j]\n                matrix[i][n - j - 1] = matrix[i][j]\n                matrix[n - i - 1][j] = matrix[i][j]\n                matrix[n - i - 1][n - j - 1] = matrix[i][j]\n        \n        # Place the center value\n        matrix[n // 2][n // 2] = center_value\n    \n    return \"YES\", matrix\n\nn = int(input())\nnumbers = list(map(int, input().split()))\n\nresult = create_palindromic_matrix(n, numbers)\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for row in result[1]:\n        print(\" \".join(map(str, row)))\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1 or (d == 1 and n > 2) or (d == 0 and n > 1):\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    edges = []\n    \n    # Create the main path for the diameter\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n    \n    # Now we have d edges, which means we have d + 1 vertices in the main path\n    current_vertex = d + 2\n    \n    # We will attach the remaining vertices to the first vertex of the path\n    for i in range(1, n - (d + 1) + 1):\n        if i <= k - 1:\n            edges.append((1, current_vertex))\n            current_vertex += 1\n        else:\n            # If we exceed the degree limit, we need to attach to the next available vertex\n            edges.append((2, current_vertex))\n            current_vertex += 1\n\n    for u, v in edges:\n        print(u, v)\n\n# Read input\nn, d, k = map(int, input().split())\nconstruct_tree(n, d, k)\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Start with the base pattern\n    if x % 2 == 0:\n        pattern = '01' * (x // 2)\n    else:\n        pattern = '01' * (x // 2) + '0'\n    \n    # Count how many zeros and ones are used\n    used_zeros = pattern.count('0')\n    used_ones = pattern.count('1')\n    \n    # Remaining zeros and ones\n    remaining_zeros = a - used_zeros\n    remaining_ones = b - used_ones\n    \n    # Add remaining zeros and ones to the end of the pattern\n    if remaining_zeros > 0:\n        pattern += '0' * remaining_zeros\n    if remaining_ones > 0:\n        pattern += '1' * remaining_ones\n    \n    # If we have more than one segment, we need to ensure we don't exceed x transitions\n    if x < a + b - 1:\n        # We need to adjust the pattern to ensure exactly x transitions\n        if remaining_zeros > 0 and remaining_ones > 0:\n            # We can add a block of zeros or ones to reduce transitions\n            if pattern[-1] == '0':\n                pattern += '0' * (remaining_zeros - 1)\n            else:\n                pattern += '1' * (remaining_ones - 1)\n    \n    return pattern\n\n# Read input\na, b, x = map(int, input().split())\n# Construct and print the binary string\nprint(construct_binary_string(a, b, x))\n```",
    "99": "```python\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\n# Maximum wins for Alice\nmax_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n\n# Minimum wins for Alice\n# Calculate losses for Alice\nalice_losses = 0\nalice_losses += max(0, b1 - a3)  # Bob's rock beats Alice's paper\nalice_losses += max(0, b2 - a1)  # Bob's scissors beats Alice's rock\nalice_losses += max(0, b3 - a2)  # Bob's paper beats Alice's scissors\n\nmin_wins = n - alice_losses\n\nprint(min_wins, max_wins)\n```"
}