{
    "2": "```python\ndef next_lucky_year(n):\n    while True:\n        n += 1\n        if str(n).count('0') + len(set(str(n))) - 1 <= 1:\n            return n - (n - 1)\n\ncurrent_year = int(input())\nprint(next_lucky_year(current_year))\n```",
    "7": "```python\ndef find_empty_day(n, m):\n    day = 0\n    total_eaten = 0\n    \n    while n > 0:\n        day += 1\n        total_eaten += day\n        \n        # Add grains to the barn\n        n += m\n        \n        # If the barn exceeds its capacity, it remains full\n        if n > m:\n            n = min(n, n + m)\n        \n        # Sparrows eat grains\n        n -= total_eaten\n        \n    return day\n\n# Read input\nn, m = map(int, input().split())\nprint(find_empty_day(n, m))\n```",
    "10": "```python\nn = int(input())\n\n# Calculate maximum days off\nmax_days_off = (n // 7) * 2 + min(2, n % 7)\n\n# Calculate minimum days off\nif n < 5:\n    min_days_off = 0\nelse:\n    min_days_off = (n // 7) * 2\n\nprint(min_days_off, max_days_off)\n```",
    "1": "```python\ndef sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef find_max_digit_sum(x):\n    max_sum = sum_of_digits(x)\n    best_number = x\n    \n    # Check numbers by reducing the last digits to 9\n    str_x = str(x)\n    for i in range(len(str_x)):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit and setting the rest to 9\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (len(str_x) - i - 1)\n        new_number = int(new_number)\n        \n        if new_number > 0 and new_number <= x:\n            current_sum = sum_of_digits(new_number)\n            if current_sum > max_sum or (current_sum == max_sum and new_number > best_number):\n                max_sum = current_sum\n                best_number = new_number\n\n    return best_number\n\nx = int(input().strip())\nprint(find_max_digit_sum(x))\n```",
    "5": "```python\nn, pos, l, r = map(int, input().split())\n\nif l == 1 and r == n:\n    print(0)\nelse:\n    moves = 0\n    if pos < l:\n        moves += l - pos  # Move to l\n        moves += 1  # Close left\n    elif pos > r:\n        moves += pos - r  # Move to r\n        moves += 1  # Close right\n    else:\n        # If pos is between l and r\n        left_moves = (pos - l) + 1  # Move to l and close left\n        right_moves = (r - pos) + 1  # Move to r and close right\n        moves = min(left_moves, right_moves)\n\n    if l > 1:\n        moves += 1  # Close left if there are tabs to close\n    if r < n:\n        moves += 1  # Close right if there are tabs to close\n\n    print(moves)\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    \n    for query in queries:\n        n, x, blows = query\n        min_blows = float('inf')\n        \n        for d, h in blows:\n            if d >= x:\n                min_blows = min(min_blows, 1)\n            else:\n                # Calculate the effective heads after one blow\n                effective_heads = x - d + h\n                if effective_heads <= 0:\n                    min_blows = min(min_blows, 1)\n                else:\n                    # Calculate how many blows are needed to bring heads to 0\n                    # We need to reduce effective_heads to 0\n                    # Each blow reduces by d and adds h\n                    # So we need to find the number of blows needed\n                    # Let k be the number of blows\n                    # effective_heads - k * h <= 0\n                    # k * d >= effective_heads\n                    # k >= effective_heads / d\n                    # k >= (effective_heads + h - 1) // h (to round up)\n                    # k >= (effective_heads + d - 1) // d (to round up)\n                    k = (effective_heads + d - 1) // d\n                    min_blows = min(min_blows, k + 1)\n        \n        results.append(min_blows if min_blows != float('inf') else -1)\n    \n    return results\n\n# Input reading\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\n# Get results\nresults = min_blows_to_defeat_zmei(t, queries)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "0": "```python\ndef max_acordion_length(s):\n    # Initialize variables to track the positions of the required characters\n    left_bracket = -1\n    first_colon = -1\n    last_colon = -1\n    right_bracket = -1\n    \n    # Iterate through the string to find the required characters\n    for i, char in enumerate(s):\n        if char == '[' and left_bracket == -1:\n            left_bracket = i\n        elif char == ':' and left_bracket != -1 and first_colon == -1:\n            first_colon = i\n        elif char == ':' and first_colon != -1:\n            last_colon = i\n        elif char == ']' and last_colon != -1 and right_bracket == -1:\n            right_bracket = i\n            \n    # Check if we found a valid accordion structure\n    if left_bracket == -1 or first_colon == -1 or last_colon == -1 or right_bracket == -1:\n        return -1\n    \n    # Calculate the maximum length of the accordion\n    vertical_lines_count = last_colon - first_colon - 1\n    accordion_length = 4 + vertical_lines_count  # 4 for [::]\n    \n    return accordion_length\n\n# Read input\ns = input().strip()\n# Output the result\nprint(max_acordion_length(s))\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "9": "```python\nd = int(input())\nn, m = map(int, input().split())\n\nsofas = []\nfor i in range(d):\n    x1, y1, x2, y2 = map(int, input().split())\n    sofas.append((x1, y1, x2, y2))\n\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\ndef count_neighbors(sofa):\n    x1, y1, x2, y2 = sofa\n    left = right = top = bottom = 0\n    \n    for other in sofas:\n        if other == sofa:\n            continue\n        ox1, oy1, ox2, oy2 = other\n        \n        if x1 == x2:  # Vertical sofa\n            if ox1 == ox2:  # Other is also vertical\n                if y2 < oy1:  # Other is below\n                    bottom += 1\n                elif oy2 < y1:  # Other is above\n                    top += 1\n            else:  # Other is horizontal\n                if x1 < ox1:  # Other is to the right\n                    right += 1\n                elif ox1 < x1:  # Other is to the left\n                    left += 1\n        else:  # Horizontal sofa\n            if ox1 == ox2:  # Other is vertical\n                if y1 < oy1:  # Other is below\n                    bottom += 1\n                elif oy2 < y1:  # Other is above\n                    top += 1\n            else:  # Other is also horizontal\n                if y1 < oy1:  # Other is below\n                    bottom += 1\n                elif oy1 < y1:  # Other is above\n                    top += 1\n\n    return left, right, top, bottom\n\nfor i in range(d):\n    left, right, top, bottom = count_neighbors(sofas[i])\n    if left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b:\n        print(i + 1)\n        break\nelse:\n    print(-1)\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelif t <= n + k:\n    print(n + k - t)\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    # Create a list to store the coverage of each section\n    coverage = [0] * (n + 1)\n\n    # Calculate the total coverage with all painters\n    for l, r in painters:\n        for i in range(l, r + 1):\n            coverage[i] += 1\n\n    # Calculate the painted sections with all painters\n    total_painted = sum(1 for i in range(1, n + 1) if coverage[i] > 0)\n\n    # To find the maximum painted sections when hiring q - 2 painters\n    max_painted = total_painted\n\n    # Check the effect of removing each pair of painters\n    for i in range(q):\n        for j in range(i + 1, q):\n            # Create a temporary coverage array\n            temp_coverage = coverage[:]\n            l1, r1 = painters[i]\n            l2, r2 = painters[j]\n\n            # Remove the coverage of the i-th painter\n            for k in range(l1, r1 + 1):\n                temp_coverage[k] -= 1\n            # Remove the coverage of the j-th painter\n            for k in range(l2, r2 + 1):\n                temp_coverage[k] -= 1\n\n            # Calculate the painted sections after removing these two painters\n            painted_after_removal = sum(1 for k in range(1, n + 1) if temp_coverage[k] > 0)\n            max_painted = max(max_painted, painted_after_removal)\n\n    return max_painted\n\n# Read input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Get the result and print it\nresult = max_painted_sections(n, q, painters)\nprint(result)\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    # Count the longest segment of golden trophies\n    max_length = 0\n    current_length = 0\n    segments = []\n\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n                max_length = max(max_length, current_length)\n            current_length = 0\n\n    if current_length > 0:\n        segments.append(current_length)\n        max_length = max(max_length, current_length)\n\n    # If there are no golden trophies\n    if max_length == 0:\n        return 0\n\n    # If there is only one segment of golden trophies\n    if len(segments) == 1:\n        return max_length\n\n    # Calculate the maximum possible length after one swap\n    max_possible_length = max_length\n\n    for i in range(len(segments) - 1):\n        # Check if we can connect two segments of golden trophies by swapping one silver trophy\n        max_possible_length = max(max_possible_length, segments[i] + segments[i + 1])\n\n    # If we can swap a silver trophy with a golden trophy\n    if 'S' in trophies:\n        max_possible_length += 1\n\n    return max_possible_length\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\n\n# Output the result\nprint(max_beauty_after_swap(n, trophies))\n```",
    "8": "```python\ndef min_tiles_to_draw(tiles):\n    # Parse the input tiles\n    hand = [(int(tile[0]), tile[1]) for tile in tiles]\n    \n    # Check for koutsu (triplet)\n    counts = {}\n    for num, suit in hand:\n        if (num, suit) in counts:\n            counts[(num, suit)] += 1\n        else:\n            counts[(num, suit)] = 1\n    \n    # If there's a koutsu\n    if any(count == 3 for count in counts.values()):\n        return 0\n    \n    # Check for shuntsu (sequence)\n    suits = {'m': [], 'p': [], 's': []}\n    for num, suit in hand:\n        suits[suit].append(num)\n    \n    # Sort the numbers in each suit\n    for suit in suits:\n        suits[suit].sort()\n    \n    # Check for existing shuntsu\n    for suit in suits:\n        for i in range(len(suits[suit]) - 2):\n            if suits[suit][i] + 1 == suits[suit][i + 1] and suits[suit][i] + 2 == suits[suit][i + 2]:\n                return 0\n    \n    # Check how many tiles are needed to form a shuntsu\n    min_needed = float('inf')\n    \n    for suit in suits:\n        for num in suits[suit]:\n            # Check for possible shuntsu formations\n            needed = 0\n            if num - 1 not in suits[suit]:\n                needed += 1\n            if num + 1 not in suits[suit]:\n                needed += 1\n            \n            # If we need 2 tiles to form a shuntsu\n            if needed == 2:\n                min_needed = min(min_needed, 2)\n            # If we need 1 tile to form a shuntsu\n            elif needed == 1:\n                min_needed = min(min_needed, 1)\n    \n    return min_needed if min_needed != float('inf') else 2\n\n# Read input\ntiles = input().strip().split()\n# Output the result\nprint(min_tiles_to_draw(tiles))\n```",
    "16": "```python\ncnt1 = int(input())\ncnt2 = int(input())\ncnt3 = int(input())\ncnt4 = int(input())\n\n# Check if it is possible to form a regular bracket sequence\nif cnt1 + cnt2 < cnt3 + cnt4:\n    print(0)\nelse:\n    # Check if the excess closing brackets can be balanced\n    if cnt3 > cnt1 + cnt2:\n        print(0)\n    else:\n        print(1)\n```",
    "13": "```python\nfrom collections import deque, defaultdict\nimport sys\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, k = map(int, data[0].split())\nmain_courses = list(map(int, data[1].split()))\ndependencies = defaultdict(list)\nin_degree = [0] * (n + 1)\n\n# Read dependencies\nfor i in range(2, n + 2):\n    line = list(map(int, data[i].split()))\n    t_i = line[0]\n    for dep in line[1:t_i + 1]:\n        dependencies[dep].append(i - 1)  # i - 2 + 1 = i - 1 (0-indexed)\n        in_degree[i - 1] += 1\n\n# Topological sort using Kahn's algorithm\nqueue = deque()\nfor i in range(1, n + 1):\n    if in_degree[i] == 0:\n        queue.append(i)\n\norder = []\npassed_courses = set()\n\nwhile queue:\n    course = queue.popleft()\n    order.append(course)\n    passed_courses.add(course)\n    for next_course in dependencies[course]:\n        in_degree[next_course] -= 1\n        if in_degree[next_course] == 0:\n            queue.append(next_course)\n\n# Check if all main courses can be taken\nneeded_courses = set(main_courses)\nfor course in order:\n    if course in needed_courses:\n        needed_courses.remove(course)\n    if not needed_courses:\n        break\n\nif needed_courses:\n    print(-1)\nelse:\n    print(len(order))\n    print(\" \".join(map(str, order)))\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    count_a = n // a\n    count_b = n // b\n    count_ab = n // (a * b // gcd(a, b))\n    \n    # Calculate chocolates if we prioritize Red tiles\n    chocolates_red_first = (count_a - count_ab) * p + (count_b - count_ab) * q + count_ab * max(p, q)\n    \n    # Calculate chocolates if we prioritize Blue tiles\n    chocolates_blue_first = (count_b - count_ab) * q + (count_a - count_ab) * p + count_ab * max(p, q)\n    \n    return max(chocolates_red_first, chocolates_blue_first)\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n# Input reading\nn, a, b, p, q = map(int, input().split())\nprint(max_chocolates(n, a, b, p, q))\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return minutes_passed\n\ntime_input = input().strip()\nhh, mm = map(int, time_input.split(':'))\nresult = next_palindrome_time(hh, mm)\nprint(result)\n```",
    "23": "```python\nfrom itertools import permutations\n\ndef max_permutation_not_exceeding(a, b):\n    a_str = str(a)\n    b_str = str(b)\n    \n    # Generate all unique permutations of the digits of a\n    permuted_numbers = set(int(''.join(p)) for p in permutations(a_str))\n    \n    # Filter out numbers that are greater than b and have the same length as a\n    valid_numbers = [num for num in permuted_numbers if num <= b and len(str(num)) == len(a_str)]\n    \n    # Return the maximum valid number\n    return max(valid_numbers)\n\n# Input\na = int(input().strip())\nb = int(input().strip())\n\n# Output\nprint(max_permutation_not_exceeding(a, b))\n```",
    "19": "```python\ndef check_records(test_cases):\n    results = []\n    for case in test_cases:\n        n, stats = case\n        valid = True\n        for i in range(n):\n            p, c = stats[i]\n            if i > 0:\n                prev_p, prev_c = stats[i - 1]\n                if p < prev_p or c < prev_c or c > p:\n                    valid = False\n                    break\n                if c - prev_c > p - prev_p:\n                    valid = False\n                    break\n        results.append(\"YES\" if valid else \"NO\")\n    return results\n\n# Input reading\nT = int(input())\ntest_cases = []\nfor _ in range(T):\n    n = int(input())\n    stats = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, stats))\n\n# Check records and print results\nresults = check_records(test_cases)\nfor result in results:\n    print(result)\n```",
    "14": "```python\ndef is_stack_sortable(n, k, p):\n    # Create a set for the used numbers\n    used = set(p)\n    # Create a stack and the result array\n    stack = []\n    result = []\n    \n    # The next number we can use\n    next_number = n\n    \n    # Iterate through the first k elements\n    for i in range(k):\n        while next_number > 0 and (next_number in used or (not stack or stack[-1] != next_number)):\n            if next_number not in used:\n                stack.append(next_number)\n            next_number -= 1\n        \n        # Check if we can push the current element to the result\n        if stack and stack[-1] == p[i]:\n            result.append(stack.pop())\n        else:\n            return -1\n    \n    # Now we need to fill the rest of the result\n    while next_number > 0:\n        if next_number not in used:\n            stack.append(next_number)\n        next_number -= 1\n    \n    # Append remaining elements from the stack to the result\n    while stack:\n        result.append(stack.pop())\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result\nresult = is_stack_sortable(n, k, p)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror_chars = {\n        'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M',\n        'O': 'O', 'o': 'o', 'p': 'q', 'q': 'p', 'R': 'R', 'S': 'S',\n        'T': 'T', 'U': 'U', 'v': 'v', 'V': 'V', 'W': 'W', 'x': 'x',\n        'Y': 'Y'\n    }\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        left_char = s[i]\n        right_char = s[n - 1 - i]\n        if left_char not in mirror_chars or mirror_chars[left_char] != right_char:\n            print(\"NIE\")\n            return\n    print(\"TAK\")\n\ns = input().strip()\nis_s_palindrome(s)\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    if k > n * (n + 1) // 2:\n        return -1\n\n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k <= 0:\n            break\n        for j in range(i, n):\n            if k <= 0:\n                break\n            if i == j:\n                if k >= 1:\n                    matrix[i][j] = 1\n                    k -= 1\n            else:\n                if k >= 2:\n                    matrix[i][j] = 1\n                    matrix[j][i] = 1\n                    k -= 2\n\n    if k > 0:\n        return -1\n\n    return matrix\n\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = [name for name, typ in files if typ == '1']\nregulars = [name for name, typ in files if typ == '0']\n\nmoves = []\n# Rename examples to 1, 2, ..., e\nfor i, example in enumerate(examples):\n    moves.append(f\"move {example} {i + 1}\")\n\n# Rename regular tests to e + 1, e + 2, ..., n\nfor i, regular in enumerate(regulars):\n    moves.append(f\"move {regular} {len(examples) + i + 1}\")\n\nprint(len(moves))\nprint(\"\\n\".join(moves))\n```",
    "27": "```python\nn = int(input())\ns = input()\n\n# Initialize the minimum operations to the length of the string\nmin_operations = n\n\n# Check for all possible prefixes\nfor i in range(1, n):\n    # If the prefix can be doubled and still fit in the string\n    if s[:i] == s[i:i+i]:\n        # Calculate operations: type prefix + copy + remaining characters\n        operations = i + 1 + (n - 2 * i)\n        min_operations = min(min_operations, operations)\n\n# Print the minimum operations found\nprint(min_operations)\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # Since GCD(x, m) = 1, the sequence will visit all rooms\n    # The number of unique rooms visited is equal to the number of steps until we return to the starting room\n    # This is equal to m because of the properties of modular arithmetic with coprime numbers\n    return m\n\n# Read input\nm, x = map(int, input().split())\n# Output the result\nprint(minimum_traps(m, x))\n```",
    "18": "```python\ndef lexicographically_minimal_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        while t and (not u or t[-1] <= u[-1]):\n            u.append(t.pop())\n    \n    return ''.join(u)\n\n# Read input\ns = input().strip()\n# Get the result\nresult = lexicographically_minimal_string(s)\n# Print the result\nprint(result)\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    left, right = 1, max(a, b)\n    \n    while left < right:\n        mid = (left + right + 1) // 2\n        if (a // mid) + (b // mid) >= n:\n            left = mid\n        else:\n            right = mid - 1\n            \n    return left\n\n# Read input\nn, a, b = map(int, input().split())\n# Output the result\nprint(max_min_pieces(n, a, b))\n```",
    "24": "```python\ndef can_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # vertical, horizontal, diagonal down-right, diagonal down-left\n    n = 10\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                # Temporarily place 'X' in the empty cell\n                board[i][j] = 'X'\n                \n                for dx, dy in directions:\n                    count = 1\n                    \n                    # Check in the positive direction\n                    x, y = i + dx, j + dy\n                    while 0 <= x < n and 0 <= y < n and board[x][y] == 'X':\n                        count += 1\n                        x += dx\n                        y += dy\n                    \n                    # Check in the negative direction\n                    x, y = i - dx, j - dy\n                    while 0 <= x < n and 0 <= y < n and board[x][y] == 'X':\n                        count += 1\n                        x -= dx\n                        y -= dy\n                    \n                    if count >= 5:\n                        return \"YES\"\n                \n                # Remove the temporary 'X'\n                board[i][j] = '.'\n\n    return \"NO\"\n\n# Read input\nboard = [input().strip() for _ in range(10)]\nprint(can_win(board))\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    # Calculate the difference\n    diff = abs(sum_first - sum_second)\n    \n    # Create a list of possible changes\n    changes = []\n    \n    if sum_first > sum_second:\n        # We need to decrease the first half or increase the second half\n        changes = [9 - digit for digit in first_half] + [digit for digit in second_half]\n    else:\n        # We need to increase the first half or decrease the second half\n        changes = [digit for digit in first_half] + [9 - digit for digit in second_half]\n    \n    # Sort changes in descending order\n    changes.sort(reverse=True)\n    \n    count = 0\n    for change in changes:\n        diff -= change\n        count += 1\n        if diff <= 0:\n            break\n            \n    return count\n\n# Read input\nticket = input().strip()\n# Print output\nprint(min_replacements_to_lucky(ticket))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ns = input().strip()\n\nif not is_palindrome(s):\n    print(len(s))\nelse:\n    # Check for the longest non-palindrome substring\n    n = len(s)\n    # If all characters are the same, return 0\n    if s.count(s[0]) == n:\n        print(0)\n    else:\n        print(n - 1)\n```",
    "32": "```python\ndef is_valid_journey(n, journey):\n    position = 0  # Start at the North Pole (0 km from North Pole)\n    \n    for t, direction in journey:\n        if position == 0 and direction != \"South\":\n            return \"NO\"\n        if position == 20000 and direction != \"North\":\n            return \"NO\"\n        \n        if direction == \"South\":\n            position += t\n        elif direction == \"North\":\n            position -= t\n        elif direction == \"West\" or direction == \"East\":\n            # Moving West or East does not change the position in km from North/South Pole\n            continue\n        \n        if position < 0 or position > 20000:\n            return \"NO\"\n    \n    if position != 0:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn = int(input())\njourney = [tuple(input().split()) for _ in range(n)]\njourney = [(int(t), dir) for t, dir in journey]\n\n# Output the result\nprint(is_valid_journey(n, journey))\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if any rating has changed\nrated = any(a != b for a, b in ratings)\n\nif rated:\n    print(\"rated\")\nelse:\n    # Check if the standings are in non-increasing order of ratings\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            print(\"unrated\")\n            break\n    else:\n        print(\"maybe\")\n```",
    "36": "```python\ndef hexagonal_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 6 * layer\n\n    while n > moves_in_layer:\n        n -= moves_in_layer\n        layer += 1\n        moves_in_layer = 6 * layer\n\n    x, y = layer, 0\n\n    if n == 0:\n        return (x, y)\n\n    # Calculate the position in the current layer\n    direction = n // layer\n    steps = n % layer\n\n    if direction == 0:  # Right\n        x += steps\n        y += 0\n    elif direction == 1:  # Up-right\n        x += steps\n        y += steps\n    elif direction == 2:  # Up-left\n        x -= steps\n        y += steps\n    elif direction == 3:  # Left\n        x -= steps\n        y += 0\n    elif direction == 4:  # Down-left\n        x -= steps\n        y -= steps\n    elif direction == 5:  # Down-right\n        x += steps\n        y -= steps\n\n    return (x, y)\n\nn = int(input().strip())\nx, y = hexagonal_coordinates(n)\nprint(x, y)\n```",
    "33": "```python\ndef count_common_terms(a1, b1, a2, b2, L, R):\n    def find_terms(a, b, limit):\n        terms = set()\n        k = 0\n        while True:\n            term = a * k + b\n            if term > limit:\n                break\n            terms.add(term)\n            k += 1\n        return terms\n\n    terms1 = find_terms(a1, b1, R)\n    terms2 = find_terms(a2, b2, R)\n\n    common_terms = terms1.intersection(terms2)\n    count = sum(1 for x in common_terms if L <= x <= R)\n    \n    return count\n\n# Input reading\na1, b1, a2, b2, L, R = map(int, input().split())\nresult = count_common_terms(a1, b1, a2, b2, L, R)\nprint(result)\n```",
    "41": "```python\ndef nearest_zero_distance(n, a):\n    distances = [float('inf')] * n\n    last_zero_index = -1\n\n    # Forward pass to find distances to the nearest zero on the left\n    for i in range(n):\n        if a[i] == 0:\n            last_zero_index = i\n            distances[i] = 0\n        elif last_zero_index != -1:\n            distances[i] = i - last_zero_index\n\n    last_zero_index = -1\n\n    # Backward pass to find distances to the nearest zero on the right\n    for i in range(n - 1, -1, -1):\n        if a[i] == 0:\n            last_zero_index = i\n        elif last_zero_index != -1:\n            distances[i] = min(distances[i], last_zero_index - i)\n\n    print(' '.join(map(str, distances)))\n\n# Input reading\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\nnearest_zero_distance(n, a)\n```",
    "35": "```python\ndef is_valid_flag(n, m, field):\n    # Check for horizontal stripes\n    if n % 3 == 0:\n        stripe_height = n // 3\n        colors = set()\n        for i in range(3):\n            stripe = field[i * stripe_height:(i + 1) * stripe_height]\n            first_color = stripe[0][0]\n            colors.add(first_color)\n            if any(row != first_color * m for row in stripe):\n                return \"NO\"\n        if len(colors) == 3:\n            return \"YES\"\n    \n    # Check for vertical stripes\n    if m % 3 == 0:\n        stripe_width = m // 3\n        colors = set()\n        for i in range(3):\n            stripe = [row[i * stripe_width:(i + 1) * stripe_width] for row in field]\n            first_color = stripe[0][0]\n            colors.add(first_color)\n            if any(row != first_color * stripe_width for row in stripe):\n                return \"NO\"\n        if len(colors) == 3:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(is_valid_flag(n, m, field))\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    m0, x0, x1 = m, 0, 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef birthday_paradox(n, k):\n    MOD = 1000003\n    days = 1 << n  # 2^n\n    if k > days:\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the probability of no collisions\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator = (numerator * (days - i)) % MOD\n        denominator = (denominator * days) % MOD\n\n    # Probability of at least one collision\n    A = (denominator - numerator + MOD) % MOD\n    B = denominator\n\n    # Reduce A/B to irreducible form\n    common_gcd = gcd(A, B)\n    A //= common_gcd\n    B //= common_gcd\n\n    return A % MOD, B % MOD\n\n# Read input\nn, k = map(int, input().split())\nA, B = birthday_paradox(n, k)\nprint(A, B)\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n\n    def is_cyclic_shift(s1, s2):\n        return len(s1) == len(s2) and s1 in (s2 + s2)\n\n    # Generate all binary strings of length n\n    all_strings = [''.join(p) for p in product('01', repeat=n)]\n    \n    # Filter strings that contain s as a substring\n    valid_strings = [t for t in all_strings if s in t]\n    \n    # Use a set to store unique cyclic strings\n    unique_cyclic_strings = set()\n    \n    for t in valid_strings:\n        # Generate all cyclic shifts of t\n        for i in range(n):\n            cyclic_shift = t[i:] + t[:i]\n            unique_cyclic_strings.add(cyclic_shift)\n    \n    return len(unique_cyclic_strings)\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_cyclic_strings(n, s))\n```",
    "38": "```python\ndef can_be_same_track(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between consecutive barriers for Kefa\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    \n    # Calculate the distances between consecutive barriers for Sasha\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Check if kefa_diffs can be rotated to match sasha_diffs\n    double_kefa_diffs = kefa_diffs * 2\n    \n    for i in range(n):\n        if double_kefa_diffs[i:i + n] == sasha_diffs:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_be_same_track(n, L, kefa_distances, sasha_distances))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n    \n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n    \n    start += (k - 1) // length\n    num_str = str(start)\n    return int(num_str[(k - 1) % length])\n\nk = int(input().strip())\nprint(find_kth_digit(k))\n```",
    "46": "```python\ndef count_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n\n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n\n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n\n    result = 0\n    for i in range(5):\n        result += count_x[i] * count_y[(5 - i) % 5]\n\n    return result\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))\n```",
    "47": "```python\ndef max_beauty(n, x, a):\n    # Function to calculate the maximum subarray sum using Kadane's algorithm\n    def kadane(arr):\n        max_sum = 0\n        current_sum = 0\n        for value in arr:\n            current_sum += value\n            max_sum = max(max_sum, current_sum)\n            current_sum = max(current_sum, 0)\n        return max_sum\n\n    # Calculate the original beauty of the array\n    original_beauty = kadane(a)\n\n    # If x is 0, we can only take the original beauty\n    if x == 0:\n        return original_beauty\n\n    # Calculate the maximum beauty after multiplying a subarray by x\n    max_increase = 0\n    current_sum = 0\n    for i in range(n):\n        current_sum += a[i]\n        # Calculate the potential increase if we multiply the subarray ending at i\n        potential_increase = current_sum * (x - 1)\n        max_increase = max(max_increase, potential_increase)\n        # Reset current_sum if it drops below 0\n        if current_sum < 0:\n            current_sum = 0\n\n    # The maximum beauty after the operation\n    return max(original_beauty, original_beauty + max_increase)\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_beauty(n, x, a))\n```",
    "51": "```python\nfrom collections import Counter\nimport sys\n\ndef find_x_y(divisors):\n    count = Counter(divisors)\n    # The largest number must be either x or y\n    max_divisor = max(count)\n    \n    # Remove the largest number from the count\n    count[max_divisor] -= 1\n    if count[max_divisor] == 0:\n        del count[max_divisor]\n    \n    # Now we need to find the second number\n    # The second number must be the product of the remaining divisors\n    product = 1\n    for d in count:\n        product *= d ** count[d]\n    \n    return max_divisor, product\n\nn = int(input().strip())\ndivisors = list(map(int, input().strip().split()))\n\nx, y = find_x_y(divisors)\nprint(x, y)\n```",
    "44": "```python\ndef minimal_time(d, k, a, b, t):\n    # Calculate the time if Vasiliy walks the entire distance\n    min_time = d * b\n    \n    # Calculate the number of full segments Vasiliy can drive\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Time spent driving full segments and repairing\n    time_driving_full_segments = full_segments * (k * a + t)\n    \n    # Time spent driving the remaining distance\n    time_driving_remaining = remaining_distance * a\n    \n    # Total time if using the car for full segments and walking the remaining distance\n    total_time_using_car = time_driving_full_segments + time_driving_remaining\n    \n    # Compare with walking the full distance\n    min_time = min(min_time, total_time_using_car)\n    \n    # Check if it's better to drive one less segment and walk the remaining distance\n    if full_segments > 0:\n        time_driving_one_less_segment = (full_segments - 1) * (k * a + t) + k * a\n        total_time_one_less_segment = time_driving_one_less_segment + (d - (full_segments - 1) * k) * b\n        min_time = min(min_time, total_time_one_less_segment)\n    \n    return min_time\n\n# Input reading\nd, k, a, b, t = map(int, input().split())\nprint(minimal_time(d, k, a, b, t))\n```",
    "54": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_a = min(a)\nmax_a = max(a)\n\nif min_a == max_a:\n    print(0)\nelse:\n    D = (max_a - min_a) // 2\n    if (max_a - min_a) % 2 == 0:\n        print(D)\n    else:\n        print(-1)\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Minimum sum of the first k positive integers\n    min_sum = k * (k + 1) // 2\n    \n    # If n is less than the minimum sum, it's impossible to form the sequence\n    if n < min_sum:\n        return -1\n    \n    # The maximum GCD we can use is n // k\n    max_gcd = n // k\n    \n    # Start with the first k positive integers\n    sequence = list(range(1, k + 1))\n    \n    # Calculate the current sum of the sequence\n    current_sum = sum(sequence)\n    \n    # Calculate the difference we need to make up\n    diff = n - current_sum\n    \n    # We can increase each element in the sequence by the same amount\n    # to maintain the strictly increasing property\n    # We can add `diff // k` to each element\n    increment = diff // k\n    \n    # Add the increment to each element\n    for i in range(k):\n        sequence[i] += increment\n    \n    # Check if we have any remaining difference to distribute\n    remaining = diff % k\n    \n    # Distribute the remaining difference\n    for i in range(remaining):\n        sequence[i] += 1\n    \n    # The GCD of the sequence will be max_gcd\n    # Scale the sequence by max_gcd\n    sequence = [x * max_gcd for x in sequence]\n    \n    return sequence\n\n# Read input\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\n# Print output\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_choose = m // 2\n    dp = [[-1] * k for _ in range(max_choose + 1)]\n    dp[0][0] = 0  # Base case: sum of 0 with 0 elements chosen\n\n    for row in matrix:\n        new_dp = [dp_row[:] for dp_row in dp]  # Copy the current dp state\n        row.sort(reverse=True)  # Sort row to maximize sum\n        for count in range(max_choose + 1):\n            for j in range(min(count, len(row)) + 1):\n                if j > 0:\n                    current_sum = sum(row[:j])\n                    for mod in range(k):\n                        if dp[count - j][mod] != -1:\n                            new_sum = dp[count - j][mod] + current_sum\n                            new_mod = new_sum % k\n                            new_dp[count][new_mod] = max(new_dp[count][new_mod], new_sum)\n        dp = new_dp\n\n    return max(dp[count][0] for count in range(max_choose + 1) if dp[count][0] != -1)\n\n# Input reading\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_sum_divisible_by_k(n, m, k, matrix))\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef reachable_count(n):\n    reachable = set()\n    current = n\n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    return len(reachable)\n\nn = int(input())\nprint(reachable_count(n))\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = -1\n    result = []\n    moves = []\n\n    while left <= right:\n        if a[left] > last_taken and (a[right] <= last_taken or a[left] < a[right]):\n            result.append(a[left])\n            moves.append('L')\n            last_taken = a[left]\n            left += 1\n        elif a[right] > last_taken:\n            result.append(a[right])\n            moves.append('R')\n            last_taken = a[right]\n            right -= 1\n        else:\n            break\n\n    print(len(result))\n    print(''.join(moves))\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\nlongest_increasing_sequence(n, a)\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph):\n    visited = {start: 0}\n    queue = deque([start])\n    farthest_node = start\n    max_distance = 0\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > max_distance:\n                    max_distance = visited[neighbor]\n                    farthest_node = neighbor\n                    \n    return farthest_node, max_distance\n\ndef find_max_edges(n, edges):\n    graph = defaultdict(list)\n    \n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Step 1: Find the farthest node from an arbitrary node (node 1)\n    farthest_from_start, _ = bfs(1, graph)\n    \n    # Step 2: Find the farthest node from the previously found farthest node\n    farthest_from_a, diameter_length = bfs(farthest_from_start, graph)\n    \n    # Step 3: Get the path from farthest_from_start to farthest_from_a\n    def get_path(start, end):\n        parent = {start: None}\n        queue = deque([start])\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in graph[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        return path[::-1]\n    \n    path = get_path(farthest_from_start, farthest_from_a)\n    \n    # Step 4: Choose three vertices\n    a = path[0]\n    b = path[-1]\n    c = path[len(path) // 2]  # Choose a middle point for c\n    \n    # The maximum number of edges is the diameter length\n    max_edges = diameter_length\n    \n    return max_edges, a, b, c\n\n# Input reading\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\n# Finding the result\nresult = find_max_edges(n, edges)\nprint(result[0])\nprint(result[1], result[2], result[3])\n```",
    "58": "```python\ndef color_array(n, k, a):\n    from collections import defaultdict\n\n    color = [0] * n\n    freq = defaultdict(list)\n\n    # Collect indices for each unique number\n    for i in range(n):\n        freq[a[i]].append(i)\n\n    # Check if we can color the array\n    if any(len(indices) > k for indices in freq.values()):\n        print(\"NO\")\n        return\n\n    # Assign colors\n    current_color = 1\n    for indices in freq.values():\n        for index in indices:\n            color[index] = current_color\n            current_color += 1\n            if current_color > k:\n                current_color = 1\n\n    print(\"YES\")\n    print(\" \".join(map(str, color)))\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncolor_array(n, k, a)\n```",
    "55": "```python\ndef is_white_sheet_visible(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n    # Check if the white sheet is completely covered by the two black sheets\n    covered_left = max(x3, x5)\n    covered_right = min(x4, x6)\n    covered_bottom = max(y3, y5)\n    covered_top = min(y4, y6)\n\n    # Check if the covered area is valid\n    if covered_left < covered_right and covered_bottom < covered_top:\n        # Check if the white sheet is completely covered\n        if (x1 >= covered_left and x2 <= covered_right and\n                y1 >= covered_bottom and y2 <= covered_top):\n            return \"NO\"\n\n    return \"YES\"\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Output the result\nprint(is_white_sheet_visible(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6))\n```",
    "63": "```python\ndef min_instability(n, a):\n    a.sort()\n    # Remove the smallest element or the largest element\n    instability_remove_min = a[-1] - a[1]  # Remove the smallest element\n    instability_remove_max = a[-2] - a[0]  # Remove the largest element\n    return min(instability_remove_min, instability_remove_max)\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_instability(n, a))\n```",
    "59": "```python\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# The target remainder is 10^y, which means we need the last (y+1) digits to be '0' and the (y+1)th digit to be '1'\n# The last x digits of the number\nlast_x_digits = number[-x:]\n\n# We need to change the last (y) digits to '0' and the (y+1)th digit to '1'\nchanges_needed = 0\n\n# Check the last (y) digits (from index -1 to -y)\nfor i in range(1, y + 1):\n    if last_x_digits[-i] != '0':\n        changes_needed += 1\n\n# Check the (y+1)th digit (which is at index -y-1)\nif last_x_digits[-(y + 1)] != '1':\n    changes_needed += 1\n\nprint(changes_needed)\n```",
    "60": "```python\ndef has_palindrome_subsequence(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        found = False\n        index_map = {}\n        for i in range(n):\n            if a[i] in index_map:\n                if i - index_map[a[i]] >= 2:\n                    found = True\n                    break\n            index_map[a[i]] = i\n        results.append(\"YES\" if found else \"NO\")\n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Get results\nresults = has_palindrome_subsequence(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        min_moves = float('inf')\n        best_triple = (a, b, c)\n\n        for A in range(1, a + 1):\n            for B in range(A, c + 1):\n                if B % A == 0:\n                    C = (B // A) * A\n                    moves = abs(A - a) + abs(B - b) + abs(C - c)\n                    if moves < min_moves:\n                        min_moves = moves\n                        best_triple = (A, B, C)\n\n        results.append((min_moves, best_triple))\n\n    return results\n\n# Input reading\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations(t, test_cases)\n\n# Output results\nfor moves, (A, B, C) in results:\n    print(moves)\n    print(A, B, C)\n```",
    "71": "```python\nimport math\n\na = int(input())\noutput = math.ceil(math.log2(a))\nprint(output)\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Find the longest suffix of t that is also a prefix\n    for i in range(n - 1, -1, -1):\n        if t.startswith(t[i:]):\n            overlap_length = n - i\n            break\n    else:\n        overlap_length = 0\n\n    # Construct the result string\n    result = t + (t[overlap_length:] * (k - 1))\n    return result\n\n# Input reading\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the result and print it\nresult = construct_string(n, k, t)\nprint(result)\n```",
    "57": "```python\ndef fill_gift_values(n, f):\n    # Create a list to store the final gift assignments\n    nf = f[:]\n    \n    # Find the friends who have not been assigned a gift\n    unassigned = []\n    for i in range(n):\n        if nf[i] == 0:\n            unassigned.append(i + 1)  # Store 1-based index\n\n    # Find the friends who are already assigned gifts\n    assigned = set(f) - {0}\n\n    # Find the friends who are not assigned any gift\n    not_assigned = [i for i in range(1, n + 1) if i not in assigned]\n\n    # Assign gifts to the unassigned friends\n    for i in range(len(unassigned)):\n        # Assign the next available friend to give a gift to\n        nf[unassigned[i] - 1] = not_assigned[i]\n\n    return nf\n\n# Read input\nn = int(input())\nf = list(map(int, input().split()))\n\n# Get the result\nresult = fill_gift_values(n, f)\n\n# Print the result\nprint(' '.join(map(str, result)))\n```",
    "67": "```python\ndef find_nice_indices(n, a):\n    total_sum = sum(a)\n    nice_indices = []\n\n    for i in range(n):\n        if (total_sum - a[i]) % 2 == 0:\n            target = (total_sum - a[i]) // 2\n            if target in a:\n                # Check if the target is not the same as a[i] or if it appears more than once\n                if target != a[i] or a.count(target) > 1:\n                    nice_indices.append(i + 1)  # Store 1-based index\n\n    print(len(nice_indices))\n    if nice_indices:\n        print(\" \".join(map(str, nice_indices)))\n\n# Example usage\nn = int(input())\na = list(map(int, input().split()))\nfind_nice_indices(n, a)\n```",
    "70": "```python\ndef midpoint_of_contest(h1, m1, h2, m2):\n    # Convert start and end times to total minutes\n    start_minutes = h1 * 60 + m1\n    end_minutes = h2 * 60 + m2\n    \n    # Calculate the midpoint in total minutes\n    midpoint_minutes = (start_minutes + end_minutes) // 2\n    \n    # Convert back to hours and minutes\n    h3 = midpoint_minutes // 60\n    m3 = midpoint_minutes % 60\n    \n    # Print the result in the required format\n    print(f\"{h3:02}:{m3:02}\")\n\n# Read input\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Calculate and print the midpoint\nmidpoint_of_contest(h1, m1, h2, m2)\n```",
    "77": "```python\ndef minimum_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nn = int(input())\nprint(minimum_difference(n))\n```",
    "76": "```python\ndef can_construct_symmetric_square(n, m, tiles):\n    if m % 2 != 0:\n        return \"NO\"\n    \n    top_left = set()\n    top_right = set()\n    bottom_left = set()\n    bottom_right = set()\n    \n    for tile in tiles:\n        tl, tr = tile[0]\n        bl, br = tile[1]\n        top_left.add(tl)\n        top_right.add(tr)\n        bottom_left.add(bl)\n        bottom_right.add(br)\n    \n    # Check if we can form the symmetric pairs\n    for tl in top_left:\n        if tl in bottom_right:\n            return \"YES\"\n    for tr in top_right:\n        if tr in bottom_left:\n            return \"YES\"\n    \n    return \"NO\"\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        top = tuple(map(int, input().split()))\n        bottom = tuple(map(int, input().split()))\n        tiles.append((top, bottom))\n    \n    results.append(can_construct_symmetric_square(n, m, tiles))\n\nprint(\"\\n\".join(results))\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import defaultdict\n    \n    # Count the frequency of each character\n    freq = defaultdict(int)\n    for char in s:\n        freq[char] += 1\n    \n    # Calculate the maximum number of unique subsequences we can generate\n    unique_subsequences_count = 0\n    total_cost = 0\n    \n    # We can generate subsequences of lengths from 0 to n\n    for length in range(n + 1):\n        # The number of subsequences of length `length` is C(n, length)\n        # We can use the formula for combinations to calculate this\n        if length == 0:\n            count = 1  # only the empty subsequence\n        else:\n            count = 0\n            for char in freq:\n                count += freq[char] * (1 << (n - freq[char]))  # 2^(n - freq[char])\n        \n        if unique_subsequences_count + count >= k:\n            # We can reach or exceed k with this length\n            total_cost += (n - length) * (k - unique_subsequences_count)\n            return total_cost\n        \n        unique_subsequences_count += count\n        total_cost += (n - length) * count\n    \n    return -1\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result\nresult = min_cost_to_obtain_set(n, k, s)\n\n# Print the result\nprint(result)\n```",
    "64": "```python\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Schedule initialization\nschedule = [0] * n  # 0 means rest day\nexam_days = set()\n\n# Mark exam days\nfor i in range(m):\n    s, d, c = exams[i]\n    exam_days.add(d - 1)  # d is 1-based, convert to 0-based\n    schedule[d - 1] = m + 1  # m + 1 means an exam day\n\n# Prepare days tracking\nprepare_count = [0] * m\n\n# Try to allocate preparation days\nfor day in range(n):\n    if day in exam_days:\n        continue  # Can't prepare on exam days\n    for i in range(m):\n        if prepare_count[i] < exams[i][2] and exams[i][0] - 1 <= day < exams[i][1] - 1:\n            schedule[day] = i + 1  # Mark preparation for exam i\n            prepare_count[i] += 1\n            break\n\n# Check if all preparations are satisfied\nif all(prepare_count[i] == exams[i][2] for i in range(m)):\n    print(' '.join(map(str, schedule)))\nelse:\n    print(-1)\n```",
    "73": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmax_height = max(a)\ntotal_bricks_needed = sum(max_height - height for height in a)\n\n# Check if the total number of bricks needed is even\nif total_bricks_needed % 2 == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    if D > len(graph[1]):\n        print(\"NO\")\n        return\n\n    # Start building the spanning tree\n    spanning_tree_edges = []\n    degree_count = {i: 0 for i in range(1, n + 1)}\n    degree_count[1] = 0\n\n    # Use a queue for BFS\n    queue = deque([1])\n    visited = set([1])\n    \n    # First, connect vertex 1 to D neighbors\n    for neighbor in graph[1]:\n        if degree_count[1] < D:\n            spanning_tree_edges.append((1, neighbor))\n            degree_count[1] += 1\n            degree_count[neighbor] += 1\n            visited.add(neighbor)\n            queue.append(neighbor)\n\n    # Now, we need to ensure we can connect the rest of the graph\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                spanning_tree_edges.append((current, neighbor))\n                degree_count[current] += 1\n                degree_count[neighbor] += 1\n                visited.add(neighbor)\n                queue.append(neighbor)\n                if len(spanning_tree_edges) == n - 1:\n                    break\n        if len(spanning_tree_edges) == n - 1:\n            break\n\n    # Check if we have a valid spanning tree\n    if len(spanning_tree_edges) == n - 1 and degree_count[1] == D:\n        print(\"YES\")\n        for u, v in spanning_tree_edges:\n            print(u, v)\n    else:\n        print(\"NO\")\n\n# Read input\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nfind_spanning_tree(n, m, D, edges)\n```",
    "82": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncount = 0\n\n# Solve from the left\nwhile count < n and a[count] <= k:\n    count += 1\n\n# Solve from the right\nwhile count < n and a[n - 1 - (count - (n - count))] <= k:\n    count += 1\n\n# Adjust for double counting if both ends are solvable\nif count > n:\n    count = n\n\nprint(count)\n```",
    "81": "```python\ndef can_reorder_strings(n, strings):\n    # Sort strings by length\n    strings.sort(key=len)\n    \n    for i in range(n):\n        for j in range(i):\n            if strings[j] not in strings[i]:\n                print(\"NO\")\n                return\n    \n    print(\"YES\")\n    for s in strings:\n        print(s)\n\n# Read input\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\ncan_reorder_strings(n, strings)\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    unique_subsequences = set()\n    \n    # Generate all subsequences\n    for i in range(1 << n):\n        subsequence = []\n        for j in range(n):\n            if i & (1 << j):\n                subsequence.append(s[j])\n        unique_subsequences.add(''.join(subsequence))\n    \n    # Calculate the cost for each unique subsequence\n    costs = []\n    for subseq in unique_subsequences:\n        cost = n - len(subseq)\n        costs.append(cost)\n    \n    # Sort costs to minimize total cost\n    costs.sort()\n    \n    if len(costs) < k:\n        return -1\n    \n    return sum(costs[:k])\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    # Extract left and right endpoints\n    lefts = [l for l, r in segments]\n    rights = [r for l, r in segments]\n    \n    # Precompute the maximum left and minimum right excluding each segment\n    max_left_exclude = [0] * n\n    min_right_exclude = [0] * n\n    \n    # Calculate prefix max for lefts and suffix min for rights\n    prefix_max_left = [0] * n\n    suffix_min_right = [0] * n\n    \n    prefix_max_left[0] = lefts[0]\n    for i in range(1, n):\n        prefix_max_left[i] = max(prefix_max_left[i - 1], lefts[i])\n    \n    suffix_min_right[n - 1] = rights[n - 1]\n    for i in range(n - 2, -1, -1):\n        suffix_min_right[i] = min(suffix_min_right[i + 1], rights[i])\n    \n    # Calculate max_left_exclude and min_right_exclude\n    for i in range(n):\n        if i == 0:\n            max_left_exclude[i] = prefix_max_left[1]\n        elif i == n - 1:\n            max_left_exclude[i] = prefix_max_left[n - 2]\n        else:\n            max_left_exclude[i] = max(prefix_max_left[i - 1], prefix_max_left[i + 1])\n        \n        if i == 0:\n            min_right_exclude[i] = suffix_min_right[1]\n        elif i == n - 1:\n            min_right_exclude[i] = suffix_min_right[n - 2]\n        else:\n            min_right_exclude[i] = min(suffix_min_right[i - 1], suffix_min_right[i + 1])\n    \n    # Calculate the maximum intersection length after removing each segment\n    max_length = 0\n    for i in range(n):\n        left = max_left_exclude[i]\n        right = min_right_exclude[i]\n        if right >= left:\n            max_length = max(max_length, right - left)\n    \n    return max_length\n\n# Input reading\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_intersection_length(n, segments))\n```",
    "78": "```python\nMOD = 10**9 + 7\n\ndef count_regular_sequences(n, s):\n    m = len(s)\n    \n    # Precompute the number of valid sequences of length 2k\n    dp = [0] * (n + 1)\n    dp[0] = 1  # Base case: one way to form an empty sequence\n    \n    for k in range(1, n + 1):\n        for j in range(k):\n            dp[k] = (dp[k] + dp[j] * dp[k - 1 - j]) % MOD\n            \n    # Check if s can be a valid substring\n    balance = 0\n    min_balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n    \n    if balance < 0 or balance > n or min_balance < 0:\n        return 0\n    \n    # Count valid sequences containing s\n    total_count = 0\n    \n    for prefix_length in range(n + 1):\n        suffix_length = n - (m - 1) - prefix_length\n        if suffix_length < 0:\n            continue\n        \n        # Count valid prefix sequences of length prefix_length\n        prefix_count = dp[prefix_length]\n        \n        # Count valid suffix sequences of length suffix_length\n        suffix_count = dp[suffix_length]\n        \n        # Valid positions for s in the sequence\n        if prefix_length + min_balance >= 0 and prefix_length + balance <= n:\n            total_count = (total_count + prefix_count * suffix_count) % MOD\n            \n    return total_count\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_regular_sequences(n, s))\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    \n    # Check for possible pairs of digits that can form 25 or 00\n    target_pairs = ['00', '25', '50', '75']\n    min_moves = float('inf')\n    \n    for pair in target_pairs:\n        last_digit = pair[1]\n        first_digit = pair[0]\n        \n        # Find the last occurrence of the second digit\n        last_index = -1\n        for i in range(length - 1, -1, -1):\n            if s[i] == last_digit:\n                last_index = i\n                break\n        \n        if last_index == -1:\n            continue  # If we can't find the last digit, skip this pair\n        \n        # Now find the first occurrence of the first digit before the last_index\n        first_index = -1\n        for i in range(last_index - 1, -1, -1):\n            if s[i] == first_digit:\n                first_index = i\n                break\n        \n        if first_index == -1:\n            continue  # If we can't find the first digit, skip this pair\n        \n        # Calculate moves needed to bring the first digit to the position before the last digit\n        moves = (last_index - first_index) + (last_index - 1 - first_index)\n        min_moves = min(min_moves, moves)\n    \n    return min_moves if min_moves != float('inf') else -1\n\n# Input reading\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    from collections import defaultdict\n\n    # Create a mapping of character positions\n    char_positions = defaultdict(list)\n    for i, char in enumerate(s):\n        char_positions[char].append(i)\n\n    # Create a list to store the color for each character\n    colors = [0] * n\n    color = 1\n\n    # Iterate through the characters in sorted order\n    for char in sorted(char_positions.keys()):\n        positions = char_positions[char]\n        # Assign the same color to all occurrences of the character\n        for pos in positions:\n            colors[pos] = color\n        color += 1\n\n    # The number of colors used is the last color - 1\n    num_colors = color - 1\n\n    return num_colors, colors\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Get the result\nnum_colors, coloring = min_colors_to_sort(n, s)\n\n# Output the result\nprint(num_colors)\nprint(' '.join(map(str, coloring)))\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n\n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            # Check for red rectangle\n            for red_width in range(1, int(a**0.5) + 1):\n                if a % red_width == 0:\n                    red_height = a // red_width\n                    if red_width <= width and red_height <= height:\n                        # Check for blue rectangle\n                        for blue_width in range(1, int(b**0.5) + 1):\n                            if b % blue_width == 0:\n                                blue_height = b // blue_width\n                                if blue_width <= width and blue_height <= height:\n                                    perimeter = 2 * (width + height)\n                                    min_perimeter = min(min_perimeter, perimeter)\n\n    return min_perimeter\n\n# Input reading\na, b = map(int, input().split())\nprint(minimal_perimeter(a, b))\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects by their required rating\n    projects.sort(key=lambda x: x[0])\n    \n    count = 0\n    current_rating = r\n    \n    for a, b in projects:\n        if current_rating >= a:\n            count += 1\n            current_rating += b\n            if current_rating < 0:\n                break\n    \n    return count\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_projects(n, r, projects))\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects by their required rating (a_i)\n    projects.sort(key=lambda x: x[0])\n    \n    for a, b in projects:\n        if r < a:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_complete_projects(n, r, projects))\n```",
    "92": "```python\nx = float(input().strip())\n\n# We need to find two integers a and b such that 1 <= a, b <= 10\n# and a * b is approximately equal to x\n\n# We can iterate through possible values of a and b\nfor a in range(1, 11):\n    for b in range(1, 11):\n        if abs(a * b - x) < 1e-6:  # Check if the product is close to x\n            print(a, b)\n            break\n```",
    "84": "```python\ndef can_color_string(n, s):\n    # Count the occurrences of each character\n    from collections import Counter\n    count = Counter(s)\n\n    # Check if any character appears more than twice\n    for char, cnt in count.items():\n        if cnt > 2:\n            print(\"NO\")\n            return\n\n    # Create a coloring array\n    color = ['0'] * n\n\n    # Assign colors based on the character positions\n    for i in range(n):\n        if s[i] == s[i - 1] if i > 0 else None:\n            color[i] = color[i - 1]\n        else:\n            color[i] = '1' if color[i - 1] == '0' else '0'\n\n    print(\"YES\")\n    print(''.join(color))\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\ncan_color_string(n, s)\n```",
    "86": "```python\ndef solve_polycarp(n, k):\n    # Minimum sum of problems that can be solved in k days\n    min_sum = k * (k + 1) // 2\n    # Maximum sum of problems that can be solved in k days\n    max_sum = k * (2 * k + 1) // 2\n\n    if n < min_sum or n > max_sum:\n        print(\"NO\")\n        return\n\n    # Start with the minimum required problems for each day\n    a = list(range(1, k + 1))\n    current_sum = sum(a)\n\n    # Distribute the remaining problems\n    remaining = n - current_sum\n\n    for i in range(k - 1, -1, -1):\n        # Maximum we can add to a[i] while respecting the constraints\n        max_add = min(remaining, (2 * a[i]) - a[i])\n        remaining -= max_add\n        a[i] += max_add\n\n        if remaining <= 0:\n            break\n\n    print(\"YES\")\n    print(\" \".join(map(str, a)))\n\n# Example inputs\ninputs = [\n    (26, 6),\n    (8, 3),\n    (1, 1),\n    (9, 4),\n    (7, 2)\n]\n\nfor n, k in inputs:\n    solve_polycarp(n, k)\n```",
    "90": "```python\ndef can_reach_end(n, m, d, c):\n    # Calculate the total length of platforms\n    total_length = sum(c)\n    \n    # If the maximum jump distance is greater than or equal to the river width, we can always reach the end\n    if d >= n + 1:\n        result = [0] * n\n        pos = 0\n        for i in range(m):\n            for j in range(c[i]):\n                result[pos] = i + 1\n                pos += 1\n        return \"YES\", result\n    \n    # Check if we can place the platforms such that we can jump across\n    result = [0] * n\n    pos = 0\n    for i in range(m):\n        # Place the platform at the current position\n        for j in range(c[i]):\n            result[pos] = i + 1\n            pos += 1\n    \n    # Check if we can jump from the last position of the last platform to n + 1\n    last_platform_end = sum(c)\n    if last_platform_end + d >= n + 1:\n        return \"YES\", result\n    \n    return \"NO\", []\n\n# Read input\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Get the result\nresult = can_reach_end(n, m, d, c)\n\n# Print the result\nif result[0] == \"NO\":\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(\" \".join(map(str, result[1])))\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    p = [0] * n\n    p[0] = 0  # Start with an arbitrary value for p[0]\n\n    # Calculate p based on q\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n\n    # Normalize p to make it a permutation of 1 to n\n    min_p = min(p)\n    for i in range(n):\n        p[i] -= min_p - 1  # Shift to make the smallest element 1\n\n    # Check if p is a valid permutation\n    if sorted(p) == list(range(1, n + 1)):\n        print(' '.join(map(str, p)))\n    else:\n        print(-1)\n\n# Input reading\nn = int(input())\nq = list(map(int, input().split()))\n\nrestore_permutation(n, q)\n```",
    "97": "```python\nn = int(input())\nchips = list(map(int, input().split()))\n\neven_count = sum(1 for x in chips if x % 2 == 0)\nodd_count = n - even_count\n\n# The minimum coins required is the smaller of the two counts\nprint(min(even_count, odd_count))\n```",
    "99": "```python\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\n# Maximum wins for Alice\nmax_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n\n# Minimum wins for Alice\n# Calculate losses for Alice\nalice_losses = 0\nalice_losses += max(0, b1 - a3)  # Bob's rock vs Alice's paper\nalice_losses += max(0, b2 - a1)  # Bob's scissors vs Alice's rock\nalice_losses += max(0, b3 - a2)  # Bob's paper vs Alice's scissors\n\nmin_wins = n - alice_losses\n\nprint(min_wins, max_wins)\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1 or (d == 1 and n > 2) or (n > 1 and d == 0):\n        print(\"NO\")\n        return\n\n    edges = []\n    \n    # Create the main path for the diameter\n    for i in range(d):\n        edges.append((i + 1, i + 2))\n    \n    # Now we have d + 1 vertices in the path\n    current_vertex = d + 2\n    \n    # Connect the remaining vertices\n    for i in range(1, d + 2):\n        if current_vertex > n:\n            break\n        while len([e for e in edges if e[0] == i or e[1] == i]) < k and current_vertex <= n:\n            edges.append((i, current_vertex))\n            current_vertex += 1\n\n    if current_vertex <= n:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for u, v in edges:\n            print(u, v)\n\n# Read input\nn, d, k = map(int, input().split())\nconstruct_tree(n, d, k)\n```",
    "88": "```python\ndef can_form_palindromic_matrix(n, numbers):\n    from collections import Counter\n    \n    count = Counter(numbers)\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Check for the number of odd occurrences\n    odd_count = sum(1 for v in count.values() if v % 2 != 0)\n    \n    # For odd n, we can have one center element, for even n, we can't have any\n    if (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n        return \"NO\"\n    \n    # Fill the matrix\n    half_n = (n + 1) // 2\n    idx = 0\n    for value, freq in count.items():\n        while freq > 0:\n            if freq >= 4:\n                # Place in corners\n                matrix[idx][idx] = value\n                matrix[idx][n - 1 - idx] = value\n                matrix[n - 1 - idx][idx] = value\n                matrix[n - 1 - idx][n - 1 - idx] = value\n                freq -= 4\n            elif freq == 2:\n                # Place in the middle of the sides\n                if idx < half_n:\n                    matrix[idx][n - 1 - idx] = value\n                    matrix[n - 1 - idx][idx] = value\n                freq -= 2\n            elif freq == 1:\n                # Place in the center if possible\n                if n % 2 == 1 and idx == half_n - 1:\n                    matrix[half_n - 1][half_n - 1] = value\n                freq -= 1\n            else:\n                break\n            if idx < half_n - 1:\n                idx += 1\n            else:\n                idx = 0\n    \n    return \"YES\", matrix\n\nn = int(input())\nnumbers = list(map(int, input().split()))\n\nresult = can_form_palindromic_matrix(n, numbers)\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for row in result[1]:\n        print(\" \".join(map(str, row)))\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Start with an empty list to build the string\n    result = []\n    \n    # Determine the starting character based on the number of zeros and ones\n    if a > b:\n        result.append('0')\n        a -= 1\n    else:\n        result.append('1')\n        b -= 1\n    \n    # We need to create x transitions\n    for _ in range(x):\n        if result[-1] == '0':\n            result.append('1')\n            b -= 1\n        else:\n            result.append('0')\n            a -= 1\n    \n    # Now we have used x transitions, we need to fill the rest\n    while a > 0 or b > 0:\n        if result[-1] == '0' and b > 0:\n            result.append('1')\n            b -= 1\n        elif result[-1] == '1' and a > 0:\n            result.append('0')\n            a -= 1\n        elif a > 0:\n            result.append('0')\n            a -= 1\n        elif b > 0:\n            result.append('1')\n            b -= 1\n    \n    # Join the list into a string and return\n    return ''.join(result)\n\n# Read input\na, b, x = map(int, input().split())\n# Construct and print the binary string\nprint(construct_binary_string(a, b, x))\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Create a list of characters to use\n    chars = ['a'] * n + ['b'] * n + ['c'] * n\n    # Create a result list\n    res = []\n    \n    # Function to check if the last two characters in res form a forbidden substring\n    def is_forbidden():\n        if len(res) < 2:\n            return False\n        return ''.join(res[-2:]) in (s, t)\n\n    # Try to build the result string\n    for _ in range(3 * n):\n        for char in chars:\n            res.append(char)\n            if not is_forbidden():\n                chars.remove(char)\n                break\n            res.pop()  # Remove the last character if it leads to forbidden substring\n\n    # Check if we have a valid result\n    if len(res) == 3 * n:\n        return \"YES\", ''.join(res)\n    else:\n        return \"NO\", \"\"\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\nt = input().strip()\n\n# Generate the string\nresult = generate_string(n, s, t)\n\n# Output the result\nprint(result[0])\nif result[0] == \"YES\":\n    print(result[1])\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n    \n    # Create arrays to store the position of characters in s that match t\n    left = [0] * m\n    right = [0] * m\n    \n    # Fill left array\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n    \n    # Fill right array\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n    \n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n    \n    # Consider the case where we can remove from the start or end\n    max_length = max(max_length, right[0])  # Remove from the start\n    max_length = max(max_length, n - 1 - left[m - 1])  # Remove from the end\n    \n    return max_length\n\n# Input reading\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(max_removable_length(s, t))\n```"
}