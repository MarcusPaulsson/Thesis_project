{
    "2": "```python\nn = int(input())\n\ndef next_lucky_year(year):\n    while True:\n        year += 1\n        if str(year).count('0') == len(str(year)) - 1 and str(year).count('1') <= 1:\n            return year\n\nnext_year = next_lucky_year(n)\nprint(next_year - n)\n```",
    "7": "```python\nn, m = map(int, input().split())\n\nday = 0\ngrains = n\n\nwhile grains > 0:\n    day += 1\n    grains += m\n    if grains > n:\n        grains = n\n    grains -= day\n\nprint(day)\n```",
    "5": "```python\nn, pos, l, r = map(int, input().split())\n\n# If no tabs need to be closed\nif l == 1 and r == n:\n    print(0)\nelse:\n    moves = 0\n\n    # Close left tabs if needed\n    if l > 1:\n        if pos > l:\n            moves += pos - l  # Move to l\n        moves += 1  # Close left tabs\n\n    # Close right tabs if needed\n    if r < n:\n        if pos < r:\n            moves += r - pos  # Move to r\n        moves += 1  # Close right tabs\n\n    print(moves)\n```",
    "1": "```python\ndef max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n    max_sum = sum(int(d) for d in str_x)\n    best_number = x\n\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n\n        # Create a new number by reducing the current digit\n        new_number = list(str_x)\n        new_number[i] = str(int(new_number[i]) - 1)\n        for j in range(i + 1, n):\n            new_number[j] = '9'  # Set all subsequent digits to 9\n\n        candidate = int(''.join(new_number))\n        if candidate <= x:\n            current_sum = sum(int(d) for d in str(candidate))\n            if current_sum > max_sum or (current_sum == max_sum and candidate > best_number):\n                max_sum = current_sum\n                best_number = candidate\n\n    return best_number\n\nx = int(input())\nprint(max_digit_sum(x))\n```",
    "4": "```python\ndef is_lucky(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef time_to_minutes(hh, mm):\n    return hh * 60 + mm\n\ndef minutes_to_time(total_minutes):\n    hh = (total_minutes // 60) % 24\n    mm = total_minutes % 60\n    return hh, mm\n\n# Input\nx = int(input())\nhh, mm = map(int, input().split())\n\n# Calculate the target time in minutes\ntarget_time = time_to_minutes(hh, mm)\n\n# Initialize the snooze count\nsnooze_count = 0\n\n# Check for lucky times\nwhile True:\n    current_time = target_time - snooze_count * x\n    if current_time < 0:\n        current_time += 24 * 60  # Wrap around to the previous day\n    current_hh, current_mm = minutes_to_time(current_time)\n    \n    if is_lucky(current_hh, current_mm):\n        print(snooze_count)\n        break\n    \n    snooze_count += 1\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    def painted_length(painters):\n        painted = [0] * (n + 1)\n        for l, r in painters:\n            painted[l] += 1\n            if r + 1 <= n:\n                painted[r + 1] -= 1\n        for i in range(1, n + 1):\n            painted[i] += painted[i - 1]\n        return sum(1 for x in painted[1:] if x > 0)\n\n    max_sections = 0\n    for i in range(q):\n        for j in range(i + 1, q):\n            selected_painters = [painters[k] for k in range(q) if k != i and k != j]\n            max_sections = max(max_sections, painted_length(selected_painters))\n\n    return max_sections\n\n# Input reading\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output the result\nprint(max_painted_sections(n, q, painters))\n```",
    "11": "```python\nn, a, b, p, q = map(int, input().split())\n\n# Calculate the number of tiles painted Red and Blue\nred_count = n // a\nblue_count = n // b\nboth_count = n // (a * b)\n\n# Tiles painted Red and not Blue\nonly_red_count = red_count - both_count\n# Tiles painted Blue and not Red\nonly_blue_count = blue_count - both_count\n\n# Calculate total chocolates\ntotal_chocolates = (only_red_count * p) + (only_blue_count * q) + (both_count * max(p, q))\n\nprint(total_chocolates)\n```",
    "10": "```python\nn = int(input())\n\n# Calculate days off\nmax_days_off = (n // 7) * 2 + min(2, n % 7)\nmin_days_off = 0 if n < 5 else (n // 7) * 2 + (1 if n % 7 >= 5 else 0)\n\nprint(min_days_off, max_days_off)\n```",
    "8": "```python\ndef min_draws(tiles):\n    suits = {'m': [], 'p': [], 's': []}\n    \n    for tile in tiles:\n        number = int(tile[0])\n        suit = tile[1]\n        suits[suit].append(number)\n    \n    # Check for koutsu\n    for suit in suits.values():\n        if len(suit) == 3 and len(set(suit)) == 1:\n            return 0\n    \n    # Check for shuntsu\n    for suit in suits.values():\n        suit.sort()\n        for i in range(len(suit) - 2):\n            if suit[i] + 1 == suit[i + 1] and suit[i] + 2 == suit[i + 2]:\n                return 0\n    \n    # Check for possible shuntsu with one draw\n    for suit in suits.values():\n        suit.sort()\n        for number in suit:\n            if number > 1 and number < 9:  # Can form shuntsu\n                if (number - 1) not in suit or (number + 1) not in suit:\n                    return 1\n            elif number == 1:  # Can only add 2\n                if (number + 1) not in suit:\n                    return 1\n            elif number == 9:  # Can only add 8\n                if (number - 1) not in suit:\n                    return 1\n    \n    # If no shuntsu or koutsu can be formed with one draw, need two draws\n    return 2\n\n# Input reading\ntiles = input().split()\nprint(min_draws(tiles))\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n\n    for i in range(t):\n        n, x = queries[i][0]\n        blows = queries[i][1]\n        \n        min_blow_count = float('inf')\n        can_defeat = False\n        \n        for d, h in blows:\n            if d >= x:\n                # If this blow can defeat Zmei in one hit\n                min_blow_count = 1\n                can_defeat = True\n                break\n            \n            # Calculate the effective reduction after one blow\n            heads_after_blow = x - d + h\n            \n            # If still has heads after the blow\n            if heads_after_blow > 0:\n                # Calculate how many blows are needed to ultimately defeat Zmei\n                effective_heads_to_defeat = heads_after_blow\n                blows_needed = 1  # We already used 1 blow\n                \n                # Calculate how many more blows are needed\n                while effective_heads_to_defeat > 0:\n                    effective_heads_to_defeat -= d\n                    if effective_heads_to_defeat > 0:\n                        effective_heads_to_defeat += h\n                    blows_needed += 1\n                \n                min_blow_count = min(min_blow_count, blows_needed)\n                can_defeat = True\n        \n        if can_defeat:\n            results.append(min_blow_count)\n        else:\n            results.append(-1)\n    \n    return results\n\n# Input reading\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append(((n, x), blows))\n\n# Calculate results\nresults = min_blows_to_defeat_zmei(t, queries)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "9": "```python\nd = int(input())\nn, m = map(int, input().split())\nsofas = []\n\nfor i in range(d):\n    x1, y1, x2, y2 = map(int, input().split())\n    sofas.append((x1, y1, x2, y2))\n\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\ndef count_sofas_position(sofa):\n    x1, y1, x2, y2 = sofa\n    count_l = count_r = count_t = count_b = 0\n    \n    for other in sofas:\n        if other == sofa:\n            continue\n        ox1, oy1, ox2, oy2 = other\n        if (x1 < ox1 and x2 < ox1) or (x1 < ox2 and x2 < ox2):\n            count_l += 1\n        if (x1 > ox1 and x2 > ox1) or (x1 > ox2 and x2 > ox2):\n            count_r += 1\n        if (y1 < oy1 and y2 < oy1) or (y1 < oy2 and y2 < oy2):\n            count_t += 1\n        if (y1 > oy1 and y2 > oy1) or (y1 > oy2 and y2 > oy2):\n            count_b += 1\n            \n    return count_l, count_r, count_t, count_b\n\nfor i in range(d):\n    count = count_sofas_position(sofas[i])\n    if count == (cnt_l, cnt_r, cnt_t, cnt_b):\n        print(i + 1)\n        break\nelse:\n    print(-1)\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelif t <= n + k:\n    print(n + k - t)\n\n```",
    "16": "```python\ncnt1 = int(input())\ncnt2 = int(input())\ncnt3 = int(input())\ncnt4 = int(input())\n\n# Conditions to form a regular bracket sequence\nif cnt1 + cnt2 > cnt3 + cnt4:\n    print(0)\nelse:\n    print(1)\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "18": "```python\ndef minimal_lexicographic_u(s):\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        while t and (not u or t[-1] <= u[-1]):\n            u.append(t.pop())\n    \n    return ''.join(u)\n\n# Input\ns = input().strip()\n# Output\nprint(minimal_lexicographic_u(s))\n```",
    "0": "```python\ndef max_acc_length(s):\n    n = len(s)\n    left_bracket = -1\n    right_bracket = -1\n    colon_count = 0\n    pipe_count = 0\n\n    for i in range(n):\n        if s[i] == '[' and left_bracket == -1:\n            left_bracket = i\n        elif s[i] == ':' and left_bracket != -1:\n            colon_count += 1\n        elif s[i] == ']' and left_bracket != -1:\n            right_bracket = i\n            break\n\n    if left_bracket == -1 or right_bracket == -1 or right_bracket < left_bracket:\n        return -1\n\n    # Count pipes between the first colon after the left bracket and the second colon before the right bracket\n    for i in range(left_bracket + 1, right_bracket):\n        if s[i] == '|':\n            pipe_count += 1\n        elif s[i] == ':':\n            # We should only count pipes between the two colons\n            colon_count -= 1\n\n    if colon_count < 2:\n        return -1\n\n    # The maximum length of the accordion\n    return 4 + pipe_count\n\n# Example usage:\ns = input().strip()\nprint(max_acc_length(s))\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    max_length = 0\n    current_length = 0\n    segments = []\n\n    # Count lengths of golden trophy segments\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n\n    if current_length > 0:\n        segments.append(current_length)\n\n    # If there are no golden trophies\n    if not segments:\n        return 0\n\n    # The maximum length without any swap\n    max_length = max(segments)\n\n    # If there's only one segment of golden trophies, return its length\n    if len(segments) == 1:\n        return max_length\n\n    # Try to combine segments by swapping\n    for i in range(len(segments) - 1):\n        combined_length = segments[i] + segments[i + 1]\n        max_length = max(max_length, combined_length)\n\n    # Also check if we can increase the length by 1 if we have at least one silver trophy to swap\n    if 'S' in trophies:\n        max_length += 1\n\n    return max_length\n\n# Input reading\nn = int(input().strip())\ntrophies = input().strip()\n\n# Output the result\nprint(max_beauty_after_swap(n, trophies))\n```",
    "14": "```python\ndef is_stack_sortable(n, k, p):\n    used = set(p)\n    remaining = [i for i in range(1, n + 1) if i not in used]\n    \n    # Create an empty stack\n    stack = []\n    b = []\n    \n    # Try to construct the lexicographically maximum permutation\n    idx = 0\n    for i in range(k):\n        while idx < len(remaining) and (not stack or stack[-1] < p[i]):\n            stack.append(remaining[idx])\n            idx += 1\n        # Now we can pop from the stack to form b\n        if stack and stack[-1] == p[i]:\n            b.append(stack.pop())\n        else:\n            # If we cannot match p[i], it's impossible\n            return -1\n    \n    # Push remaining elements from remaining to stack\n    while idx < len(remaining):\n        stack.append(remaining[idx])\n        idx += 1\n    \n    # Now, pop all elements from the stack to form b\n    while stack:\n        b.append(stack.pop())\n    \n    return p + b\n\n# Input reading\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\nresult = is_stack_sortable(n, k, p)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "23": "```python\nfrom itertools import permutations\n\ndef max_permutation_not_exceeding(a, b):\n    a_str = str(a)\n    b_str = str(b)\n    \n    # Generate all unique permutations of the digits of a\n    perm_set = set(permutations(a_str))\n    \n    # Filter permutations that are valid (do not have leading zero)\n    valid_numbers = []\n    for perm in perm_set:\n        num_str = ''.join(perm)\n        if num_str[0] != '0' and len(num_str) == len(a_str):\n            valid_numbers.append(int(num_str))\n    \n    # Find the maximum permutation that does not exceed b\n    max_valid = -1\n    for num in valid_numbers:\n        if num <= b:\n            max_valid = max(max_valid, num)\n    \n    return max_valid\n\n# Input reading\na = int(input().strip())\nb = int(input().strip())\n\n# Get the result\nresult = max_permutation_not_exceeding(a, b)\n\n# Output the result\nprint(result)\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return minutes_passed\n\n# Input\ncurrent_time = input().strip()\nhh, mm = map(int, current_time.split(':'))\n\n# Output\nprint(next_palindrome_time(hh, mm))\n```",
    "19": "```python\ndef check_records(test_cases):\n    results = []\n    for case in test_cases:\n        n = case[0]\n        records = case[1]\n        valid = True\n        \n        for i in range(1, n):\n            p_prev, c_prev = records[i - 1]\n            p_curr, c_curr = records[i]\n            \n            # Check for conditions\n            if p_curr < p_prev or c_curr < c_prev or c_curr > p_curr:\n                valid = False\n                break\n            \n            # Check the increase in plays and clears\n            if p_curr - p_prev < c_curr - c_prev:\n                valid = False\n                break\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Read input\nT = int(input())\ntest_cases = []\nfor _ in range(T):\n    n = int(input())\n    records = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, records))\n\n# Get results and print them\nresults = check_records(test_cases)\nfor result in results:\n    print(result)\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef topological_sort(n, prerequisites):\n    in_degree = [0] * (n + 1)\n    graph = defaultdict(list)\n    \n    for course, deps in enumerate(prerequisites, start=1):\n        for dep in deps:\n            graph[dep].append(course)\n            in_degree[course] += 1\n\n    # Queue for the courses with no prerequisites\n    queue = deque()\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            queue.append(i)\n\n    order = []\n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        for neighbor in graph[course]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    return order if len(order) == n else []\n\ndef minimum_courses_to_pass(n, k, main_courses, prerequisites):\n    order = topological_sort(n, prerequisites)\n    \n    if not order:\n        return -1\n\n    passed = set()\n    result = []\n\n    for course in order:\n        if course in main_courses or any(dep in passed for dep in prerequisites[course - 1]):\n            if course not in passed:\n                result.append(course)\n                passed.add(course)\n\n    if all(main in passed for main in main_courses):\n        return len(result), result\n    else:\n        return -1\n\n# Read input\nn, k = map(int, input().split())\nmain_courses = set(map(int, input().split()))\nprerequisites = [list(map(int, input().split()[1:])) for _ in range(n)]\n\n# Get result\nresult = minimum_courses_to_pass(n, k, main_courses, prerequisites)\n\n# Print output\nif result == -1:\n    print(-1)\nelse:\n    m, courses = result\n    print(m)\n    print(' '.join(map(str, courses)))\n```",
    "27": "```python\nn = int(input())\ns = input()\n\nmin_operations = n  # Start with the max operations (typing all characters one by one)\n\nfor i in range(1, n):\n    if s[:i] == s[i:2*i]:  # Check if the prefix is equal to the next segment\n        # If they are equal, we can copy and then type the rest\n        min_operations = min(min_operations, i + 1 + (n - 2 * i))\n\nprint(min_operations)\n```",
    "24": "```python\ndef can_win(field):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # Vertical, Horizontal, Diagonal /\n    \n    for i in range(10):\n        for j in range(10):\n            if field[i][j] == '.':\n                # Try placing 'X' in the empty cell\n                for di, dj in directions:\n                    count = 1  # Count the placed 'X'\n                    \n                    # Check in the positive direction\n                    ni, nj = i + di, j + dj\n                    while 0 <= ni < 10 and 0 <= nj < 10 and field[ni][nj] == 'X':\n                        count += 1\n                        ni += di\n                        nj += dj\n                    \n                    # Check in the negative direction\n                    ni, nj = i - di, j - dj\n                    while 0 <= ni < 10 and 0 <= nj < 10 and field[ni][nj] == 'X':\n                        count += 1\n                        ni -= di\n                        nj -= dj\n                    \n                    # Check if Alice can win\n                    if count >= 5:\n                        return \"YES\"\n    \n    return \"NO\"\n\n# Reading the 10x10 game field input\nfield = [input().strip() for _ in range(10)]\nprint(can_win(field))\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = [name for name, type_ in files if type_ == '1']\nregulars = [name for name, type_ in files if type_ == '0']\n\nmoves = []\nfor i, name in enumerate(examples):\n    moves.append(f\"move {name} {i + 1}\")\n\nfor i, name in enumerate(regulars):\n    moves.append(f\"move {name} {len(examples) + i + 1}\")\n\nprint(len(moves))\nprint(\"\\n\".join(moves))\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror = {\n        'A': 'A', 'B': ' ', 'C': ' ', 'D': ' ', 'E': ' ', 'F': ' ', 'G': ' ', 'H': 'H',\n        'I': 'I', 'J': ' ', 'K': ' ', 'L': ' ', 'M': 'M', 'N': ' ', 'O': 'O', 'P': ' ',\n        'Q': ' ', 'R': ' ', 'S': ' ', 'T': 'T', 'U': 'U', 'V': ' ', 'W': 'W', 'X': 'X',\n        'Y': ' ', 'Z': ' '\n    }\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        left = s[i]\n        right = s[n - 1 - i]\n        if mirror.get(left) != right:\n            print(\"NIE\")\n            return\n    print(\"TAK\")\n\ns = input().strip()\nis_s_palindrome(s)\n```",
    "21": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_index = a.index(1)\nmax_index = a.index(n)\n\n# Current distance\ncurrent_distance = abs(min_index - max_index)\n\n# Possible new distances after one swap\nnew_distance1 = abs(min_index - (n - 1))  # Swap 1 with last element\nnew_distance2 = abs(min_index - 0)        # Swap 1 with first element\nnew_distance3 = abs(max_index - (n - 1))  # Swap n with last element\nnew_distance4 = abs(max_index - 0)        # Swap n with first element\n\n# Calculate maximum possible distance\nmax_distance = max(current_distance, new_distance1, new_distance2, new_distance3, new_distance4)\n\nprint(max_distance)\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    if k > n * n:\n        return -1\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(i, n):\n            if i == j:  # Diagonal element\n                if k > 0:\n                    matrix[i][j] = 1\n                    k -= 1\n            else:  # Off-diagonal elements\n                if k >= 2:\n                    matrix[i][j] = 1\n                    matrix[j][i] = 1\n                    k -= 2\n            \n            if k == 0:\n                break\n        if k == 0:\n            break\n    \n    if k > 0:\n        return -1\n    \n    return matrix\n\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # Since GCD(x, m) = 1, the x-mouse will visit all rooms\n    # in the cycle of length m. We can catch the x-mouse by\n    # placing traps at every room that is visited in one full cycle.\n    return m\n\n# Read input\nm, x = map(int, input().split())\n\n# Output the minimum number of traps needed\nprint(minimum_traps(m, x))\n```",
    "26": "```python\nimport math\n\n# Read input\nx, y, z = map(float, input().split())\n\n# Define the expressions\nexpressions = [\n    (x ** (y ** z), \"x^y^z\"),\n    (x ** (z ** y), \"x^z^y\"),\n    ((x ** y) ** z, \"(x^y)^z\"),\n    ((x ** z) ** y, \"(x^z)^y\"),\n    (y ** (x ** z), \"y^x^z\"),\n    (y ** (z ** x), \"y^z^x\"),\n    ((y ** x) ** z, \"(y^x)^z\"),\n    ((y ** z) ** x, \"(y^z)^x\"),\n    (z ** (x ** y), \"z^x^y\"),\n    (z ** (y ** x), \"z^y^x\"),\n    ((z ** x) ** y, \"(z^x)^y\"),\n    ((z ** y) ** x, \"(z^y)^x\"),\n]\n\n# Find the maximum value and the corresponding expression\nmax_value = -math.inf\nmax_index = -1\n\nfor i, (value, expr) in enumerate(expressions):\n    if value > max_value:\n        max_value = value\n        max_index = i\n\n# Output the corresponding expression\nprint(expressions[max_index][1])\n```",
    "29": "```python\ndef min_replacements(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    # Calculate the difference\n    diff = abs(sum_first - sum_second)\n    \n    # Create lists of possible changes\n    changes_first = sorted([9 - d for d in first_half], reverse=True)\n    changes_second = sorted([9 - d for d in second_half], reverse=True)\n    \n    # Combine the changes and sort in descending order\n    changes = changes_first + changes_second\n    changes.sort(reverse=True)\n    \n    # Determine the minimum number of changes needed\n    replacements = 0\n    for change in changes:\n        diff -= change\n        replacements += 1\n        if diff <= 0:\n            return replacements\n    \n    return replacements\n\n# Read input\nticket = input().strip()\n# Output the result\nprint(min_replacements(ticket))\n```",
    "37": "```python\ndef can_deal_exact_damage(a, b, c):\n    for x in range(c // a + 1):\n        if (c - a * x) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Input reading\na, b, c = map(int, input().split())\nprint(can_deal_exact_damage(a, b, c))\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    left, right = 1, max(a, b)\n    \n    while left < right:\n        mid = (left + right + 1) // 2\n        plates_for_a = (a + mid - 1) // mid\n        plates_for_b = (b + mid - 1) // mid\n        \n        if plates_for_a + plates_for_b <= n:\n            left = mid\n        else:\n            right = mid - 1\n            \n    return left\n\n# Input\nn, a, b = map(int, input().split())\n# Output\nprint(max_min_pieces(n, a, b))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    \n    if not is_palindrome(s):\n        return n\n    \n    for length in range(n - 1, 0, -1):\n        for start in range(n - length + 1):\n            if not is_palindrome(s[start:start + length]):\n                return length\n    \n    return 0\n\ns = input().strip()\nprint(longest_non_palindrome_substring(s))\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if any rating has changed\nrated = any(a != b for a, b in ratings)\n\nif rated:\n    print(\"rated\")\nelse:\n    # Check if the standings are valid\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            print(\"unrated\")\n            break\n    else:\n        print(\"maybe\")\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, p):\n    return pow(a, p - 2, p)\n\ndef birthday_paradox(n, k):\n    mod = 10**6 + 3\n    days = 2 ** n\n\n    if k > days:\n        return (1, 1)\n\n    numerator = 1\n    denominator = 1\n\n    for i in range(k):\n        numerator *= (days - i) % mod\n        denominator *= days % mod\n        numerator %= mod\n        denominator %= mod\n\n    numerator = (denominator - numerator) % mod\n    denominator = denominator % mod\n\n    common_gcd = gcd(numerator, denominator)\n    numerator //= common_gcd\n    denominator //= common_gcd\n\n    return (numerator, denominator)\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    A, B = birthday_paradox(n, k)\n    print(A, B)\n```",
    "36": "```python\ndef get_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    # Determine which layer of the spiral the move is in\n    layer = 0\n    while n > 6 * layer:\n        n -= 6 * layer\n        layer += 1\n\n    # Calculate the coordinates based on the layer and position within the layer\n    x, y = layer, 0  # Start at the rightmost point of the current layer\n\n    if n == 0:\n        return (x, y)\n\n    # Move counter-clockwise through the layer\n    for direction in range(6):\n        if n <= layer:\n            if direction == 0:\n                x -= n\n            elif direction == 1:\n                x -= layer\n                y += n\n            elif direction == 2:\n                x -= layer\n                y += layer\n            elif direction == 3:\n                x += n\n                y += layer\n            elif direction == 4:\n                x += layer\n                y -= n\n            elif direction == 5:\n                x += layer\n                y -= layer\n            break\n        n -= layer\n\n    return (x, y)\n\n# Read input\nn = int(input())\n# Get coordinates\nresult = get_coordinates(n)\n# Print output\nprint(result[0], result[1])\n```",
    "32": "```python\nn = int(input())\ncurrent_distance = 0  # Distance from the North Pole in kilometers\n\nvalid = True\n\nfor _ in range(n):\n    t_i, dir_i = input().split()\n    t_i = int(t_i)\n    \n    if current_distance == 0 and dir_i != \"South\":\n        valid = False\n        break\n    if current_distance == 20000 and dir_i != \"North\":\n        valid = False\n        break\n    \n    if dir_i == \"South\":\n        current_distance += t_i\n    elif dir_i == \"North\":\n        current_distance -= t_i\n    elif dir_i == \"West\" or dir_i == \"East\":\n        # Moving West or East does not affect the distance from the poles\n        pass\n    \n    if current_distance < 0 or current_distance > 20000:\n        valid = False\n        break\n\nif valid and current_distance == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "35": "```python\ndef is_valid_flag(n, m, grid):\n    # Check for horizontal stripes\n    stripe_height = n // 3\n    if n % 3 != 0:\n        return \"NO\"\n    \n    colors = set()\n    for i in range(3):\n        stripe_color = grid[i * stripe_height][0]\n        if stripe_color in colors:\n            return \"NO\"\n        colors.add(stripe_color)\n        for j in range(stripe_height):\n            if grid[i * stripe_height + j] != stripe_color * m:\n                return \"NO\"\n    \n    if len(colors) != 3:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output result\nprint(is_valid_flag(n, m, grid))\n```",
    "38": "```python\ndef can_tracks_coincide(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between barriers for Kefa and Sasha\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Check if Sasha's differences can match Kefa's differences by cyclic rotation\n    double_kefa_diffs = kefa_diffs + kefa_diffs\n    \n    for i in range(n):\n        if double_kefa_diffs[i:i + n] == sasha_diffs:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_distances, sasha_distances))\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n\n    def is_valid_cyclic(t):\n        # Check if s is a substring in any cyclic shift of t\n        doubled_t = t + t\n        return s in doubled_t\n\n    # Generate all binary strings of length n\n    all_binary_strings = [''.join(p) for p in product('01', repeat=n)]\n    \n    # Count valid cyclic strings\n    valid_count = sum(1 for t in all_binary_strings if is_valid_cyclic(t))\n    \n    return valid_count\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_cyclic_strings(n, s))\n```",
    "41": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nd = [0] * n\nlast_zero = -float('inf')\n\n# Forward pass to find distances to the nearest zero on the left\nfor i in range(n):\n    if a[i] == 0:\n        last_zero = i\n        d[i] = 0\n    else:\n        d[i] = i - last_zero\n\nlast_zero = float('inf')\n\n# Backward pass to find distances to the nearest zero on the right\nfor i in range(n - 1, -1, -1):\n    if a[i] == 0:\n        last_zero = i\n    else:\n        d[i] = min(d[i], last_zero - i)\n\nprint(' '.join(map(str, d)))\n```",
    "48": "```python\ndef find_kth_largest(n, m, k):\n    left, right = 1, n * m\n    \n    while left < right:\n        mid = (left + right) // 2\n        count = 0\n        \n        for i in range(1, n + 1):\n            count += min(mid // i, m)\n        \n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return left\n\n# Input\nn, m, k = map(int, input().split())\n# Output\nprint(find_kth_largest(n, m, k))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    digit_length = 1\n    count = 9\n    start = 1\n    \n    while k > digit_length * count:\n        k -= digit_length * count\n        digit_length += 1\n        count *= 10\n        start *= 10\n    \n    start += (k - 1) // digit_length\n    number_str = str(start)\n    return int(number_str[(k - 1) % digit_length])\n\nk = int(input().strip())\nprint(find_kth_digit(k))\n```",
    "46": "```python\ndef count_pairs(n, m):\n    # Count occurrences of remainders when divided by 5\n    count_n = [0] * 5\n    count_m = [0] * 5\n    \n    for i in range(1, n + 1):\n        count_n[i % 5] += 1\n        \n    for j in range(1, m + 1):\n        count_m[j % 5] += 1\n        \n    # Calculate pairs where (x + y) % 5 == 0\n    result = 0\n    for i in range(5):\n        result += count_n[i] * count_m[(5 - i) % 5]\n    \n    return result\n\n# Reading input\nn, m = map(int, input().split())\nprint(count_pairs(n, m))\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Check if it's possible to form a strictly increasing sequence of k positive integers that sum to n\n    if n < k * (k + 1) // 2:\n        return -1\n    \n    # Start with the smallest k integers\n    sequence = list(range(1, k + 1))\n    sum_sequence = sum(sequence)\n    \n    # Calculate the excess we need to distribute\n    excess = n - sum_sequence\n    \n    # Distribute the excess evenly to maximize the GCD\n    # The maximum GCD we can achieve is the excess plus 1 divided by k\n    max_gcd = (excess // k) + 1\n    \n    # Increase each element in the sequence by max_gcd\n    sequence = [x + max_gcd for x in sequence]\n    \n    # Adjust the last element to ensure the sum is exactly n\n    sequence[-1] += excess - (max_gcd * k)\n    \n    return sequence\n\n# Read input\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\n# Print result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "33": "```python\ndef count_common_integers(a1, b1, a2, b2, L, R):\n    from math import gcd\n\n    def count_in_range(a, b, L, R):\n        if a == 0:\n            if b < L or b > R:\n                return 0\n            return R - L + 1\n        start = (L - b + a - 1) // a  # ceil((L - b) / a)\n        end = (R - b) // a            # floor((R - b) / a)\n        return max(0, end - start + 1)\n\n    # Calculate the gcd of the differences\n    g = gcd(a1, a2)\n    \n    # Check if the equations can have common solutions\n    if (b2 - b1) % g != 0:\n        return 0\n\n    # Calculate the values for k and l\n    a1_g = a1 // g\n    a2_g = a2 // g\n    b_diff = b2 - b1\n    b_diff_g = b_diff // g\n\n    # Use the extended Euclidean algorithm to find a solution for modular equation\n    # a1 * x ≡ b_diff (mod a2)\n    def extended_gcd(a, b):\n        if b == 0:\n            return a, 1, 0\n        g, x1, y1 = extended_gcd(b, a % b)\n        x = y1\n        y = x1 - (a // b) * y1\n        return g, x, y\n\n    _, x0, y0 = extended_gcd(a1_g, a2_g)\n\n    # Scale the solution to the specific b_diff\n    x0 *= b_diff_g\n    y0 *= b_diff_g\n\n    # General solution\n    x0 = (x0 % (a2_g)) * (g) + b1\n    step = (a2_g * g)\n\n    # Count valid x in range [L, R]\n    count1 = count_in_range(step, x0, L, R)\n    count2 = count_in_range(step, x0 + step, L, R)\n\n    return count1 + count2\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n# Calculate and print the result\nprint(count_common_integers(a1, b1, a2, b2, L, R))\n```",
    "44": "```python\ndef minimal_time_to_post_office(d, k, a, b, t):\n    # Total time if walking the entire distance\n    min_time = d * b\n    \n    # Calculate how many full segments of k kilometers can be driven\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Time for full segments driving\n    time_with_full_segments = full_segments * (k * a + t)  # driving + repair time\n    \n    # If there are full segments, we subtract the repair time for the last segment\n    if full_segments > 0:\n        time_with_full_segments -= t\n    \n    # Add the time for the remaining distance (either by car or on foot)\n    time_with_full_segments += remaining_distance * a  # driving the remaining distance\n    \n    # Compare with walking the remaining distance\n    time_with_full_segments_alternative = full_segments * (k * a + t) + remaining_distance * b\n    \n    # Update min_time with the best option\n    min_time = min(min_time, time_with_full_segments, time_with_full_segments_alternative)\n\n    return min_time\n\n# Read input\nd, k, a, b, t = map(int, input().split())\n# Get the result\nresult = minimal_time_to_post_office(d, k, a, b, t)\n# Print the result\nprint(result)\n```",
    "43": "```python\nimport sys\nimport math\n\ndef angle_between(v1, v2):\n    # Calculate the angle using the cross and dot product\n    cross_product = v1[0] * v2[1] - v1[1] * v2[0]\n    dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n    return math.atan2(abs(cross_product), dot_product)\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    vectors = []\n    \n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().strip().split())\n        vectors.append((x, y, i + 1))  # Store vector and its index\n    \n    # Sort vectors by angle\n    vectors.sort(key=lambda v: math.atan2(v[1], v[0]))\n    \n    min_angle = float('inf')\n    result = (0, 0)\n    \n    for i in range(n):\n        v1 = vectors[i][:2]\n        v2 = vectors[(i + 1) % n][:2]  # next vector, wrap around\n        angle = angle_between(v1, v2)\n        \n        if angle < min_angle:\n            min_angle = angle\n            result = (vectors[i][2], vectors[(i + 1) % n][2])\n    \n    print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n```",
    "47": "```python\ndef max_subarray_sum(arr):\n    max_ending_here = 0\n    max_so_far = 0\n    for x in arr:\n        max_ending_here = max(0, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\ndef max_beauty_after_operation(n, x, a):\n    # Calculate the original beauty\n    original_beauty = max_subarray_sum(a)\n\n    # Initialize variables for the modified beauty calculation\n    max_increase = 0\n    current_sum = 0\n    total_sum = sum(a)\n\n    # Iterate through the array to find the best subarray to multiply\n    for i in range(n):\n        current_sum += a[i]\n        \n        # If we multiply the current sum by x\n        if x != 0:\n            modified_sum = current_sum * x\n            # Calculate the increase in beauty\n            increase = modified_sum - current_sum\n            max_increase = max(max_increase, increase)\n\n        # Reset current_sum if it becomes negative\n        if current_sum < 0:\n            current_sum = 0\n\n    # The maximum beauty after the operation\n    max_beauty = max(original_beauty, total_sum + max_increase)\n    return max_beauty\n\n# Input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_beauty_after_operation(n, x, a))\n```",
    "51": "```python\nfrom collections import Counter\nimport sys\nimport math\n\nn = int(input())\ndivisors = list(map(int, input().split()))\n\n# Count the occurrences of each divisor\ncount = Counter(divisors)\n\n# Get the unique divisors\nunique_divisors = list(count.keys())\n\n# Initialize x and y\nx = 1\ny = 1\n\n# Calculate x and y using the count of divisors\nfor d in unique_divisors:\n    if count[d] == 1:\n        # d is a divisor of only one of the two numbers\n        if x == 1:\n            x = d\n        else:\n            y = d\n    elif count[d] == 2:\n        # d is a divisor of both numbers\n        x *= d\n        y *= d\n\n# Adjust x and y if they are not set correctly\nif x == 1 and y == 1:\n    x = unique_divisors[0]\n    y = unique_divisors[1]\n\nprint(x, y)\n```",
    "54": "```python\ndef min_D_to_equal_elements(n, a):\n    min_a = min(a)\n    max_a = max(a)\n\n    if max_a == min_a:\n        return 0  # All elements are already equal\n\n    # Calculate the possible D\n    possible_D = (max_a - min_a) // 2\n\n    # Check if it is possible to make all elements equal\n    target1 = min_a + possible_D\n    target2 = max_a - possible_D\n\n    if target1 == target2:\n        return possible_D\n    else:\n        return -1\n\n# Input\nn = int(input())\na = list(map(int, input().split()))\n\n# Output\nresult = min_D_to_equal_elements(n, a)\nprint(result)\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef reachable_count(n):\n    reachable = set()\n    current = n\n    \n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    \n    return len(reachable)\n\nn = int(input())\nprint(reachable_count(n))\n```",
    "57": "```python\nn = int(input())\nf = list(map(int, input().split()))\n\n# Find the friends who want to give gifts and those who are still open\ngivers = set(range(1, n + 1)) - set(f)\nreceivers = set(i + 1 for i in range(n)) - set(i + 1 for i in range(n) if f[i] != 0)\n\n# Convert to list for easier manipulation\ngivers = list(givers)\nreceivers = list(receivers)\n\n# Assign gifts to friends who were unsure\nfor i in range(n):\n    if f[i] == 0:\n        f[i] = givers.pop()\n\n# Output the result\nprint(' '.join(map(str, f)))\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last = -1\n    moves = []\n    \n    while left <= right:\n        if a[left] < a[right] and a[left] > last:\n            moves.append('L')\n            last = a[left]\n            left += 1\n        elif a[left] >= a[right] and a[right] > last:\n            moves.append('R')\n            last = a[right]\n            right -= 1\n        elif a[left] < a[right] and a[right] > last:\n            moves.append('R')\n            last = a[right]\n            right -= 1\n        elif a[left] >= a[right] and a[left] > last:\n            moves.append('L')\n            last = a[left]\n            left += 1\n        else:\n            break\n\n    print(len(moves))\n    print(''.join(moves))\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\nlongest_increasing_sequence(n, a)\n```",
    "59": "```python\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# Create the target pattern based on y\ntarget = ['0'] * x\ntarget[y] = '1'\n\n# Count the number of changes needed\nchanges = 0\nfor i in range(x):\n    if number[n - 1 - i] != target[x - 1 - i]:\n        changes += 1\n\nprint(changes)\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_elements = m // 2\n    dp = [[0] * k for _ in range(max_elements + 1)]\n    \n    for row in matrix:\n        row.sort(reverse=True)\n        new_dp = [dp[:] for dp in dp]\n        \n        for count in range(max_elements + 1):\n            for j in range(k):\n                if dp[count][j] > 0 or count == 0:  # Account for the initial 0 sum\n                    for x in range(1, min(max_elements - count, len(row)) + 1):\n                        sum_selected = sum(row[:x])\n                        new_remainder = (j + sum_selected) % k\n                        new_dp[count + x][new_remainder] = max(new_dp[count + x][new_remainder], dp[count][j] + sum_selected)\n        \n        dp = new_dp\n    \n    return max(dp[count][0] for count in range(max_elements + 1))\n\n# Input handling\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nresult = max_sum_divisible_by_k(n, m, k, matrix)\nprint(result)\n```",
    "58": "```python\ndef color_array(n, k, a):\n    from collections import defaultdict\n\n    color_assignment = [0] * n\n    freq = defaultdict(list)\n\n    # Collect indices of each element in the array\n    for index, value in enumerate(a):\n        freq[value].append(index)\n\n    # Check if it's possible to color\n    if any(len(indices) > k for indices in freq.values()):\n        print(\"NO\")\n        return\n\n    # Assign colors\n    color = 1\n    for indices in freq.values():\n        for idx in indices:\n            color_assignment[idx] = color\n            color += 1\n            if color > k:\n                color = 1\n\n    print(\"YES\")\n    print(' '.join(map(str, color_assignment)))\n\n# Input reading\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncolor_array(n, k, a)\n```",
    "60": "```python\ndef has_palindrome_subsequence(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        found = False\n        index_map = {}\n        \n        for i in range(n):\n            if a[i] in index_map:\n                # Check if the same number has appeared before\n                if (i - index_map[a[i]]) > 1:\n                    found = True\n                    break\n            index_map[a[i]] = i\n        \n        results.append(\"YES\" if found else \"NO\")\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\n\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Process and print results\nresults = has_palindrome_subsequence(t, test_cases)\nfor result in results:\n    print(result)\n```",
    "63": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Sort the array to easily find min and max\na.sort()\n\n# Minimum possible instability after removing one element\n# We can either remove the first element or the last element\n# The resulting instability will be max - min of the remaining elements\nmin_instability = min(a[-1] - a[1], a[-2] - a[0])\n\nprint(min_instability)\n```",
    "65": "```python\ndef transform_moves(n, m):\n    if m % n != 0:\n        return -1\n\n    quotient = m // n\n    moves = 0\n\n    while quotient > 1:\n        if quotient % 2 == 0:\n            quotient //= 2\n            moves += 1\n        elif quotient % 3 == 0:\n            quotient //= 3\n            moves += 1\n        else:\n            return -1\n\n    return moves\n\n# Input\nn, m = map(int, input().split())\n# Output\nprint(transform_moves(n, m))\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph):\n    visited = [-1] * (n + 1)\n    queue = deque([start])\n    visited[start] = 0\n    farthest_node = start\n\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if visited[neighbor] == -1:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > visited[farthest_node]:\n                    farthest_node = neighbor\n\n    return farthest_node, visited\n\ndef find_farthest_nodes(graph):\n    # Start from an arbitrary node (1)\n    farthest_from_start, _ = bfs(1, graph)\n    # Find the farthest node from that node\n    farthest_node, distances = bfs(farthest_from_start, graph)\n    return farthest_from_start, farthest_node, distances\n\ndef get_paths(a, b, c, distances):\n    # The total number of distinct edges in paths a-b, b-c, and a-c\n    return len(set(distances[a]) | set(distances[b]) | set(distances[c]))\n\nn = int(input().strip())\ngraph = defaultdict(list)\n\nfor _ in range(n - 1):\n    a, b = map(int, input().strip().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\n# Find two farthest nodes in the tree\nu, v, distances_u = find_farthest_nodes(graph)\n# Get distances from u\n_, distances_v = bfs(v, graph)\n\n# Find the maximum number of distinct edges\nmax_edges = 0\nbest_triplet = (1, 2, 3)\n\nfor a in range(1, n + 1):\n    for b in range(a + 1, n + 1):\n        if a != b:\n            for c in range(b + 1, n + 1):\n                if a != c and b != c:\n                    edges_count = get_paths(a, b, c, distances_u)\n                    if edges_count > max_edges:\n                        max_edges = edges_count\n                        best_triplet = (a, b, c)\n\nprint(max_edges)\nprint(*best_triplet)\n```",
    "67": "```python\nn = int(input())\na = list(map(int, input().split()))\n\ntotal_sum = sum(a)\nnice_indices = []\n\nfor i in range(n):\n    removed_element = a[i]\n    remaining_sum = total_sum - removed_element\n    \n    if remaining_sum % 2 == 0:\n        target = remaining_sum // 2\n        # Check if target is in the remaining array\n        if (target == removed_element and a.count(target) > 1) or (target != removed_element and target in a):\n            nice_indices.append(i + 1)\n\nprint(len(nice_indices))\nif nice_indices:\n    print(\" \".join(map(str, nice_indices)))\n```",
    "61": "```python\ndef max_possible_number(n, a, f):\n    a = list(a)\n    f = [0] + f  # to align f(1) to f(9) with indices 1 to 9\n    modified = False\n    \n    for i in range(n):\n        original_digit = int(a[i])\n        new_digit = f[original_digit]\n        \n        if new_digit > original_digit:\n            if not modified:\n                modified = True\n                # Start replacing until we find a digit that doesn't increase\n            a[i] = str(new_digit)\n        elif new_digit < original_digit and modified:\n            # Once we start modifying, we should stop if we encounter a digit that doesn't increase\n            break\n    \n    return ''.join(a)\n\n# Input reading\nn = int(input().strip())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\n# Function call and output\nresult = max_possible_number(n, a, f)\nprint(result)\n```",
    "71": "```python\na = int(input())\noutput = (a - 1) // 6 + 1\nprint(output)\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        min_ops = float('inf')\n        best_triple = (0, 0, 0)\n\n        for A in range(1, a + 1):\n            for k in range(1, 10001):\n                B = A * k\n                if B < b:\n                    continue\n                if B > c:\n                    break\n\n                C = B * (B // A)\n                if C < c:\n                    continue\n\n                ops = abs(A - a) + abs(B - b) + abs(C - c)\n                if ops < min_ops:\n                    min_ops = ops\n                    best_triple = (A, B, C)\n\n        results.append((min_ops, best_triple))\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Getting results\nresults = min_operations(t, test_cases)\n\n# Output results\nfor ops, (A, B, C) in results:\n    print(ops)\n    print(A, B, C)\n```",
    "70": "```python\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Convert start and end times to total minutes from the start of the day\nstart_minutes = h1 * 60 + m1\nend_minutes = h2 * 60 + m2\n\n# Calculate the midpoint in total minutes\nmidpoint_minutes = (start_minutes + end_minutes) // 2\n\n# Convert the midpoint back to hours and minutes\nh3 = midpoint_minutes // 60\nm3 = midpoint_minutes % 60\n\n# Print the result in the required format\nprint(f\"{h3:02}:{m3:02}\")\n```",
    "55": "```python\ndef can_see_white_sheet(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n    # Check if there is a visible part of the white sheet\n    # by checking the corners of the white sheet\n    # against the black sheets\n\n    # Check if the white sheet is completely covered by both black sheets\n    if (x3 >= x2 or x4 <= x1 or y3 >= y2 or y4 <= y1) and (x5 >= x2 or x6 <= x1 or y5 >= y2 or y6 <= y1):\n        return \"YES\"\n\n    # Check for each corner of the white sheet if it's visible\n    # i.e., if it lies outside the black sheets\n    corners = [\n        (x1, y1), (x1, y2), (x2, y1), (x2, y2)\n    ]\n\n    for x, y in corners:\n        if not (x3 < x < x4 and y3 < y < y4) and not (x5 < x < x6 and y5 < y < y6):\n            return \"YES\"\n\n    return \"NO\"\n\n# Input reading\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Output result\nprint(can_see_white_sheet(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6))\n```",
    "73": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmax_height = max(a)\nmin_height = min(a)\n\n# Check if all heights can be raised to max_height without gaps\ncan_complete = True\nfor i in range(n):\n    if a[i] < min_height or (i > 0 and a[i] != a[i - 1] and a[i] != max_height):\n        can_complete = False\n        break\n\nprint(\"YES\" if can_complete else \"NO\")\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import Counter\n    \n    # Count frequencies of each character\n    freq = Counter(s)\n    unique_count = len(freq)\n    \n    # If k is greater than the total possible subsequences, return -1\n    if k > (1 << unique_count):\n        return -1\n    \n    # List of all possible subsequences and their costs\n    costs = []\n    \n    # Generate all subsequences\n    for i in range(1 << n):\n        subsequence = ''.join(s[j] for j in range(n) if (i & (1 << j)))\n        costs.append(len(subsequence))\n    \n    costs.sort()\n    \n    # Calculate the minimum cost for the first k unique subsequences\n    total_cost = 0\n    for i in range(k):\n        total_cost += n - costs[i]\n    \n    return total_cost\n\n# Reading input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Getting the result\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "77": "```python\ndef min_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nn = int(input())\nprint(min_difference(n))\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    if D >= n:\n        print(\"NO\")\n        return\n\n    from collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    degree = {i: 0 for i in range(1, n + 1)}\n    spanning_tree_edges = []\n    visited = set()\n    queue = deque([1])\n    visited.add(1)\n\n    while queue:\n        node = queue.popleft()\n        if degree[node] < D:\n            for neighbor in graph[node]:\n                if neighbor not in visited and degree[node] < D:\n                    degree[node] += 1\n                    degree[neighbor] += 1\n                    spanning_tree_edges.append((node, neighbor))\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n\n                if degree[node] == D:\n                    break\n\n    if degree[1] != D:\n        print(\"NO\")\n        return\n\n    # Add remaining edges to complete the spanning tree\n    for u, v in edges:\n        if (u, v) not in spanning_tree_edges and (v, u) not in spanning_tree_edges:\n            if len(spanning_tree_edges) < n - 1:\n                spanning_tree_edges.append((u, v))\n\n    if len(spanning_tree_edges) == n - 1:\n        print(\"YES\")\n        for u, v in spanning_tree_edges:\n            print(u, v)\n    else:\n        print(\"NO\")\n\n\n# Read input\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nfind_spanning_tree(n, m, D, edges)\n```",
    "66": "```python\ndef min_length_string(n, k, t):\n    # Find the longest prefix which is also a suffix\n    lps = [0] * n\n    j = 0  # length of previous longest prefix suffix\n    i = 1\n\n    # Preprocess the pattern to create the lps array\n    while i < n:\n        if t[i] == t[j]:\n            j += 1\n            lps[i] = j\n            i += 1\n        else:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                lps[i] = 0\n                i += 1\n\n    # The length of the longest proper prefix which is also a suffix\n    longest_prefix_suffix_length = lps[-1]\n\n    # Construct the result string\n    # Start with the full string once\n    result = t\n\n    # Add (k-1) times the remaining part of the string\n    result += t[longest_prefix_suffix_length:] * (k - 1)\n\n    return result\n\n# Input reading\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the result and print it\nresult = min_length_string(n, k, t)\nprint(result)\n```",
    "74": "```python\ndef min_cost_to_form_set(n, k, s):\n    unique_subsequences = set()\n    total_cost = 0\n    \n    # Generate all possible subsequences\n    for i in range(1 << n):  # There are 2^n possible subsequences\n        subsequence = []\n        for j in range(n):\n            if i & (1 << j):\n                subsequence.append(s[j])\n        subsequence_str = ''.join(subsequence)\n        if subsequence_str not in unique_subsequences:\n            unique_subsequences.add(subsequence_str)\n            total_cost += (n - len(subsequence_str))\n        \n        if len(unique_subsequences) >= k:\n            break\n            \n    if len(unique_subsequences) < k:\n        return -1\n    return total_cost\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_form_set(n, k, s))\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    # Extract the left and right endpoints of the segments\n    lefts = [seg[0] for seg in segments]\n    rights = [seg[1] for seg in segments]\n\n    # Precompute the maximum left endpoint and minimum right endpoint\n    max_left = [0] * n\n    min_right = [0] * n\n\n    max_left[0] = lefts[0]\n    for i in range(1, n):\n        max_left[i] = max(max_left[i - 1], lefts[i])\n\n    min_right[n - 1] = rights[n - 1]\n    for i in range(n - 2, -1, -1):\n        min_right[i] = min(min_right[i + 1], rights[i])\n\n    # Calculate the maximum possible length of the intersection after removing one segment\n    max_length = 0\n    for i in range(n):\n        if i == 0:\n            l = max_left[1]\n            r = min_right[1]\n        elif i == n - 1:\n            l = max_left[n - 2]\n            r = min_right[n - 2]\n        else:\n            l = max(max_left[i - 1], lefts[i + 1])\n            r = min(min_right[i + 1], rights[i - 1])\n\n        if r >= l:\n            max_length = max(max_length, r - l)\n\n    return max_length\n\n# Input reading\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = max_intersection_length(n, segments)\nprint(result)\n```",
    "64": "```python\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\nschedule = [0] * n  # Initialize schedule with rest days\nexam_days = [0] * n  # Initialize exam days tracker\n\nfor i in range(m):\n    s, d, c = exams[i]\n    s -= 1  # Convert to 0-based index\n    d -= 1  # Convert to 0-based index\n    exam_days[d] = i + 1  # Mark exam day\n\n# Prepare a list to track preparation days\nprep_days = [0] * n\n\nfor i in range(m):\n    s, d, c = exams[i]\n    s -= 1  # Convert to 0-based index\n    d -= 1  # Convert to 0-based index\n    count = 0\n    \n    # Try to assign preparation days\n    for j in range(s, d):\n        if count < c and prep_days[j] == 0:  # If we still need to prepare and the day is free\n            prep_days[j] = i + 1  # Assign preparation for exam i\n            count += 1\n\n    if count < c:  # If we couldn't prepare enough\n        print(-1)\n        exit()\n\n# Now fill the schedule with preparation and exam days\nfor j in range(n):\n    if exam_days[j] != 0:\n        schedule[j] = exam_days[j]  # Assign exam day\n    elif prep_days[j] != 0:\n        schedule[j] = prep_days[j]  # Assign preparation day\n\nprint(' '.join(map(str, schedule)))\n```",
    "80": "```python\nn = int(input())\ns = input()\n\nfrom collections import defaultdict\n\n# Create a mapping of characters to their positions\npositions = defaultdict(list)\nfor i, char in enumerate(s):\n    positions[char].append(i)\n\n# Colors array\ncolors = [0] * n\ncurrent_color = 1\n\n# Create a list of unique characters sorted\nunique_chars = sorted(positions.keys())\n\n# Assign colors based on the positions of characters\nfor char in unique_chars:\n    for i in range(len(positions[char])):\n        colors[positions[char][i]] = current_color\n        current_color += 1 if i == len(positions[char]) - 1 else 0\n\n# The number of colors used is the max in the colors array\nmax_color = max(colors)\n\nprint(max_color)\nprint(' '.join(map(str, colors)))\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Calculate the maximum full weeks that can be fed\n    full_weeks = min(a // 3, b // 2, c // 2)\n    a -= full_weeks * 3\n    b -= full_weeks * 2\n    c -= full_weeks * 2\n    \n    max_days = full_weeks * 7\n    \n    # Check each starting day of the week\n    for start_day in range(7):\n        days = 0\n        food = [a, b, c]\n        week_pattern = [0, 0, 1, 0, 0, 1, 0]  # 0: fish, 1: rabbit, 2: chicken\n        \n        for i in range(7):\n            day = (start_day + i) % 7\n            if day in (0, 3, 6):  # Fish days\n                if food[0] > 0:\n                    food[0] -= 1\n                    days += 1\n                else:\n                    break\n            elif day in (1, 5):  # Rabbit days\n                if food[1] > 0:\n                    food[1] -= 1\n                    days += 1\n                else:\n                    break\n            else:  # Chicken days\n                if food[2] > 0:\n                    food[2] -= 1\n                    days += 1\n                else:\n                    break\n        \n        max_days = max(max_days, days)\n    \n    return max_days\n\n# Read input\na, b, c = map(int, input().split())\n# Print output\nprint(max_days(a, b, c))\n```",
    "81": "```python\ndef can_reorder_strings(n, strings):\n    # Sort strings by length\n    strings.sort(key=len)\n    \n    # Check if each string is a substring of the next ones in the list\n    for i in range(n):\n        for j in range(i + 1, n):\n            if strings[i] not in strings[j]:\n                print(\"NO\")\n                return\n    \n    print(\"YES\")\n    for s in strings:\n        print(s)\n\n# Read input\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\ncan_reorder_strings(n, strings)\n```",
    "82": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nsolved = 0\n\n# Solve problems from the left\nwhile solved < n and a[solved] <= k:\n    solved += 1\n\n# Solve problems from the right\nwhile solved < n and a[n - 1 - (solved - 1)] <= k:\n    solved += 1\n\n# Adjust if we counted any problem twice\nif solved > n:\n    solved = n\n\nprint(solved)\n```",
    "78": "```python\nMOD = 10**9 + 7\n\ndef count_regular_bracket_sequences(n, s):\n    m = len(s)\n    \n    # Precompute factorials and inverse factorials for combinations\n    fact = [1] * (2 * n + 1)\n    for i in range(2, 2 * n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    \n    def modinv(x):\n        return pow(x, MOD - 2, MOD)\n    \n    if n < m // 2 or n < (m + 1) // 2:  # Not enough pairs to accommodate s\n        return 0\n    \n    # Count the number of '(' and ')' in s\n    open_s = s.count('(')\n    close_s = s.count(')')\n    \n    # Check if s can be part of a valid sequence\n    if open_s < close_s:\n        return 0\n    \n    # Calculate the number of valid sequences\n    total_open = n - open_s\n    total_close = n - close_s\n    \n    if total_open < 0 or total_close < 0:\n        return 0\n    \n    # Count valid sequences that can be formed with remaining brackets\n    def count_sequences(open_needed, close_needed):\n        if open_needed < 0 or close_needed < 0 or open_needed > close_needed:\n            return 0\n        return (fact[open_needed + close_needed] * modinv(fact[open_needed]) % MOD) * modinv(fact[close_needed]) % MOD\n    \n    # Count valid sequences before s\n    before_s = count_sequences(n - open_s, n - close_s)\n    \n    # Count valid sequences after s\n    after_s = count_sequences(total_open, total_close)\n    \n    return before_s * after_s % MOD\n\n# Input\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_regular_bracket_sequences(n, s))\n```",
    "85": "```python\nimport sys\nimport math\n\ndef find_price(A, B):\n    for price in range(1, 10000):  # Reasonable upper limit\n        tax_8 = math.floor(price * 0.08)\n        tax_10 = math.floor(price * 0.10)\n        \n        if tax_8 == A and tax_10 == B:\n            return price\n    return -1\n\nif __name__ == \"__main__\":\n    A, B = map(int, sys.stdin.read().strip().split())\n    result = find_price(A, B)\n    print(result)\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n    \n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            # Check both (width, height) and (height, width)\n            for w, h in [(width, height), (height, width)]:\n                if (w >= 1 and h >= 1):\n                    # Red rectangle\n                    for red_width in range(1, w + 1):\n                        if a % red_width == 0:\n                            red_height = a // red_width\n                            if red_height <= h:\n                                # Blue rectangle\n                                for blue_width in range(1, w + 1):\n                                    if b % blue_width == 0:\n                                        blue_height = b // blue_width\n                                        if blue_height <= h:\n                                            perimeter = 2 * (w + h)\n                                            min_perimeter = min(min_perimeter, perimeter)\n    \n    return min_perimeter\n\n# Read input\na, b = map(int, input().split())\nprint(minimal_perimeter(a, b))\n```",
    "84": "```python\ndef can_color_and_sort(n, s):\n    # Count frequencies of each character\n    from collections import Counter\n    count = Counter(s)\n    \n    # Check for impossible cases\n    for char, freq in count.items():\n        if freq > 2:\n            return \"NO\"\n    \n    # Prepare coloring\n    color = []\n    for char in s:\n        if color.count('0') < count[char] // 2:\n            color.append('0')\n        else:\n            color.append('1')\n\n    return \"YES\\n\" + ''.join(color)\n\n# Reading input\nn = int(input())\ns = input()\n\n# Getting the result\nresult = can_color_and_sort(n, s)\n\n# Printing the result\nprint(result)\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    moves = float('inf')\n    \n    # Check for all pairs of digits that can form 00, 25, 50, 75\n    for target in [\"00\", \"25\", \"50\", \"75\"]:\n        last_digit = target[1]\n        second_last_digit = target[0]\n        \n        # Find the position of the last digit first\n        last_position = -1\n        for i in range(length - 1, -1, -1):\n            if s[i] == last_digit:\n                last_position = i\n                break\n        \n        if last_position == -1:\n            continue\n        \n        # Now find the second last digit before the last digit found\n        second_last_position = -1\n        for i in range(last_position - 1, -1, -1):\n            if s[i] == second_last_digit:\n                second_last_position = i\n                break\n        \n        # If we found both digits\n        if second_last_position != -1:\n            # The number of moves to bring them to the end\n            move_count = (last_position - second_last_position) + (length - 1 - last_position)\n            moves = min(moves, move_count)\n    \n    return moves if moves != float('inf') else -1\n\n# Input reading\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "92": "```python\nx = float(input().strip())\n\n# Using a simple nested loop to find any valid pair (a, b)\nfor a in range(1, 11):\n    for b in range(1, 11):\n        if abs(a * b - x) < 1e-6:  # Check if the product is approximately equal to x\n            print(a, b)\n            break\n    else:\n        continue\n    break\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects by their required rating\n    projects.sort(key=lambda x: x[0])\n    \n    for a, b in projects:\n        if r < a:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_complete_projects(n, r, projects))\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects based on the required rating and then by the rating change\n    projects.sort(key=lambda x: (x[0], x[1]))\n\n    max_count = 0\n    current_rating = r\n\n    # Try to complete as many projects as possible\n    for _ in range(n):\n        count = 0\n        temp_rating = current_rating\n        completed_projects = []\n\n        for a_i, b_i in projects:\n            if temp_rating >= a_i:\n                completed_projects.append((a_i, b_i))\n                temp_rating += b_i\n                if temp_rating < 0:  # Rating can't go below zero\n                    break\n                count += 1\n        \n        max_count = max(max_count, count)\n\n        # Remove completed projects from the list for future iterations\n        projects = [p for p in projects if p not in completed_projects]\n\n    return max_count\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_projects(n, r, projects))\n```",
    "86": "```python\ndef solve_problems(n, k):\n    # Minimum problems needed to satisfy the conditions\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n\n    # Maximum problems we can solve on the first day with increasing conditions\n    max_first_day = n // k + (1 if n % k != 0 else 0)\n\n    a = [0] * k\n    for i in range(k):\n        # We start with the minimum required problems for each day\n        a[i] = i + 1\n\n    # Calculate the current sum of problems solved\n    current_sum = sum(a)\n\n    # We need to distribute the remaining problems\n    remaining = n - current_sum\n\n    # Start distributing from the last day backwards\n    for i in range(k - 1, -1, -1):\n        # The maximum we can add to a[i] while respecting the conditions\n        max_add = min(remaining, 2 * a[i] - a[i])\n        if max_add > 0:\n            a[i] += max_add\n            remaining -= max_add\n\n        if remaining <= 0:\n            break\n\n    # Final check if we managed to distribute all problems\n    if sum(a) == n:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n    else:\n        print(\"NO\")\n\n# Read input\nn, k = map(int, input().split())\nsolve_problems(n, k)\n```",
    "76": "```python\ndef can_construct_square(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Prepare to check for symmetry\n        top_left = set()\n        top_right = set()\n        bottom_left = set()\n        bottom_right = set()\n\n        for tile in tiles:\n            top_left.add(tile[0][0])\n            top_right.add(tile[0][1])\n            bottom_left.add(tile[1][0])\n            bottom_right.add(tile[1][1])\n\n        # Check symmetry conditions\n        can_form_symmetric = False\n        for tl in top_left:\n            if tl in bottom_right and tl in top_right and tl in bottom_left:\n                can_form_symmetric = True\n                break\n        \n        results.append(\"YES\" if can_form_symmetric else \"NO\")\n    \n    return results\n\n# Reading input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for __ in range(n):\n        tile = [list(map(int, input().split())), list(map(int, input().split()))]\n        tiles.append(tile)\n    test_cases.append((n, m, tiles))\n\n# Getting results\nresults = can_construct_square(t, test_cases)\n\n# Printing results\nfor result in results:\n    print(result)\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n    \n    # Arrays to store the positions of characters in s that match t\n    left = [0] * m\n    right = [0] * m\n    \n    # Fill left array for the first occurrence\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n    \n    # Fill right array for the last occurrence\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n    \n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n    \n    # Also consider removing from the start to the first character of t\n    max_length = max(max_length, right[0] - 0)\n    # And from the last character of t to the end of s\n    max_length = max(max_length, n - left[m - 1] - 1)\n    \n    return max_length\n\n# Input\ns = input().strip()\nt = input().strip()\n\n# Output\nprint(max_removable_length(s, t))\n```",
    "97": "```python\ndef min_coins_to_move_chips(n, chips):\n    odd_count = sum(1 for x in chips if x % 2 == 1)\n    even_count = n - odd_count\n    return min(odd_count, even_count)\n\nn = int(input())\nchips = list(map(int, input().split()))\nprint(min_coins_to_move_chips(n, chips))\n```",
    "90": "```python\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculate the minimum space needed to place the platforms\nmin_space_needed = sum(c) + (m - 1)  # Total length of platforms + gaps between them\n\n# Check if we can fit the platforms within the river width\nif min_space_needed > n:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    a = [0] * n\n    pos = 0\n    \n    # Place each platform in the array\n    for i in range(m):\n        for j in range(c[i]):\n            a[pos] = i + 1  # Platform indices are 1-based\n            pos += 1\n        if i < m - 1:  # If not the last platform, leave a gap\n            pos += 1  # Move one cell to create a gap\n\n    print(\" \".join(map(str, a)))\n```",
    "88": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nfrom collections import Counter\n\ncount = Counter(a)\nmatrix = [[0] * n for _ in range(n)]\n\n# Check if it is possible to fill the matrix\nodd_count = 0\nfor value, freq in count.items():\n    if freq % 2 == 1:\n        odd_count += 1\n\n# For odd n, we can have one odd frequency; for even n, we cannot have any\nif (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n    print(\"NO\")\nelse:\n    # Fill the matrix\n    half_matrix = []\n    center_value = None\n    \n    for value, freq in count.items():\n        if freq % 2 == 1:\n            center_value = value\n        half_matrix.extend([value] * (freq // 2))\n    \n    half_size = len(half_matrix)\n    \n    # Arrange values in a palindromic way\n    for i in range(n):\n        for j in range(n):\n            if i < n // 2:\n                matrix[i][j] = half_matrix[i] if j < n // 2 else half_matrix[i]\n                matrix[n - 1 - i][j] = matrix[i][j]\n            elif i == n // 2 and n % 2 == 1:\n                if j == n // 2:\n                    matrix[i][j] = center_value\n                else:\n                    matrix[i][j] = half_matrix[i]\n                    matrix[i][n - 1 - j] = matrix[i][j]\n\n    print(\"YES\")\n    for row in matrix:\n        print(' '.join(map(str, row)))\n```",
    "98": "```python\ndef min_moves_to_reach_n(N):\n    moves = float('inf')\n    \n    # Iterate over possible rows (i) from 1 to sqrt(N)\n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            # Calculate the moves needed to reach (i, j)\n            moves = min(moves, (i - 1) + (j - 1))\n    \n    return moves\n\nN = int(input().strip())\nprint(min_moves_to_reach_n(N))\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    p = [0] * n\n    p[0] = 0  # We will adjust later\n\n    # Calculate the prefix sums based on q\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n\n    # Find the minimum value in p to adjust the permutation to start from 1\n    min_p = min(p)\n\n    # Adjust all values to make them start from 1\n    for i in range(n):\n        p[i] -= min_p - 1\n\n    # Check if we have a valid permutation\n    if len(set(p)) == n and all(1 <= x <= n for x in p):\n        print(\" \".join(map(str, p)))\n    else:\n        print(-1)\n\n# Reading input\nn = int(input().strip())\nq = list(map(int, input().strip().split()))\n\n# Restore the permutation\nrestore_permutation(n, q)\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Start with the string made of alternating characters\n    result = []\n    \n    # Determine the initial character based on the counts\n    if a > b:\n        result.append('0')\n        a -= 1\n    else:\n        result.append('1')\n        b -= 1\n\n    # We will create exactly x transitions\n    for _ in range(x):\n        if result[-1] == '0':\n            result.append('1')\n            b -= 1\n        else:\n            result.append('0')\n            a -= 1\n\n    # Fill the remaining characters\n    if result[-1] == '0':\n        result.extend(['0'] * a)\n        result.extend(['1'] * b)\n    else:\n        result.extend(['1'] * b)\n        result.extend(['0'] * a)\n\n    return ''.join(result)\n\n# Read input\na, b, x = map(int, input().split())\n# Print the output\nprint(construct_binary_string(a, b, x))\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1 or d > n - 1:\n        return \"NO\"\n    \n    edges = []\n    # Create the main path for the diameter\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n    \n    # Now we have d edges, and we need to connect the remaining vertices\n    # We have n - (d + 1) vertices left to connect\n    remaining_vertices = n - (d + 1)\n    \n    # If we have remaining vertices, we can attach them to the last vertex in the path\n    if remaining_vertices > 0:\n        last_vertex = d + 1\n        for i in range(remaining_vertices):\n            if len(edges) < n - 1 and edges.count((last_vertex, last_vertex + 1)) < k:\n                edges.append((last_vertex, last_vertex + 1))\n                last_vertex += 1\n    \n    # Check if we exceeded the degree\n    degree_count = {}\n    for u, v in edges:\n        if u in degree_count:\n            degree_count[u] += 1\n        else:\n            degree_count[u] = 1\n        if v in degree_count:\n            degree_count[v] += 1\n        else:\n            degree_count[v] = 1\n        \n    for count in degree_count.values():\n        if count > k:\n            return \"NO\"\n    \n    result = [\"YES\"]\n    for u, v in edges:\n        result.append(f\"{u} {v}\")\n    \n    return \"\\n\".join(result)\n\n# Read input\nn, d, k = map(int, input().split())\nprint(construct_tree(n, d, k))\n```",
    "99": "```python\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\n# Maximum wins for Alice\nmax_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n\n# Minimum wins for Alice\n# Calculate losses\nlosses_a1 = max(0, b1 - a3)  # Bob's rock beats Alice's paper\nlosses_a2 = max(0, b2 - a1)  # Bob's scissors beat Alice's rock\nlosses_a3 = max(0, b3 - a2)  # Bob's paper beats Alice's scissors\n\nmin_wins = n - (losses_a1 + losses_a2 + losses_a3)\n\nprint(min_wins, max_wins)\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Create a list that will hold the result\n    res = []\n    \n    # Characters count\n    count = {'a': n, 'b': n, 'c': n}\n    \n    # Function to check if last two characters form a forbidden substring\n    def is_forbidden(last_two):\n        return last_two == s or last_two == t\n    \n    # Fill the result string\n    for _ in range(3 * n):\n        for char in 'abc':\n            if count[char] > 0:\n                # Check if adding this character would create a forbidden substring\n                if len(res) >= 2 and is_forbidden(res[-2] + char):\n                    continue\n                # Append the character and decrease the count\n                res.append(char)\n                count[char] -= 1\n                break\n        else:\n            # If we couldn't add any character, then it means it's impossible\n            return \"NO\", \"\"\n    \n    return \"YES\", ''.join(res)\n\n# Input reading\nn = int(input())\ns = input().strip()\nt = input().strip()\n\n# Generate the result\nresult = generate_string(n, s, t)\n\n# Output the result\nprint(result[0])\nif result[0] == \"YES\":\n    print(result[1])\n```"
}