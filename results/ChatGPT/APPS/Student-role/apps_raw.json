{
    "30": "```python\ndef min_operations_to_alternating(t, test_cases):\n    results = []\n    for n, s in test_cases:\n        count_01 = count_10 = 0\n        for i in range(n):\n            expected_char = '0' if i % 2 == 0 else '1'\n            if s[i] != expected_char:\n                count_01 += 1\n        for i in range(n):\n            expected_char = '1' if i % 2 == 0 else '0'\n            if s[i] != expected_char:\n                count_10 += 1\n        \n        # Minimum number of operations needed to make the string alternating\n        results.append(min(count_01, count_10) // 2)\n    \n    return results\n\n# Input reading section\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Get results\nresults = min_operations_to_alternating(t, test_cases)\n\n# Output results\nfor res in results:\n    print(res)\n```",
    "31": "```python\ndef skier_time(test_cases):\n    results = []\n    \n    for moves in test_cases:\n        visited_segments = set()\n        current_position = (0, 0)\n        total_time = 0\n        \n        for move in moves:\n            if move == 'N':\n                new_position = (current_position[0], current_position[1] + 1)\n            elif move == 'S':\n                new_position = (current_position[0], current_position[1] - 1)\n            elif move == 'E':\n                new_position = (current_position[0] + 1, current_position[1])\n            elif move == 'W':\n                new_position = (current_position[0] - 1, current_position[1])\n            \n            segment = (current_position, new_position) if current_position < new_position else (new_position, current_position)\n            \n            if segment not in visited_segments:\n                total_time += 5\n                visited_segments.add(segment)\n            else:\n                total_time += 1\n            \n            current_position = new_position\n            \n        results.append(total_time)\n    \n    return results\n\n# Input handling\nt = int(input())\ntest_cases = [input().strip() for _ in range(t)]\nresults = skier_time(test_cases)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "32": "```python\ndef maximum_coins(N):\n    return N // 2\n\nT = int(input())\nresults = []\nfor _ in range(T):\n    N = int(input())\n    results.append(maximum_coins(N))\n\nprint('\\n'.join(map(str, results)))\n```",
    "33": "```python\ndef minimize_number(t, test_cases):\n    results = []\n    \n    for n in test_cases:\n        # The minimum possible number left on the board\n        min_number = (n + 1) // 2\n        results.append(str(min_number))\n        \n        # We need to perform n-1 operations\n        operations = []\n        # Prepare a list of numbers\n        numbers = list(range(1, n + 1))\n        \n        while len(numbers) > 1:\n            # Always take the largest two numbers to minimize the result\n            a = numbers.pop()  # largest\n            b = numbers.pop()  # second largest\n            new_number = (a + b + 1) // 2  # round up\n            operations.append(f\"{a} {b}\")\n            numbers.append(new_number)  # add the new number back to the list\n            numbers.sort()  # Keep the list sorted for next operation\n            \n        results.extend(operations)\n        \n    return results\n\n# Read input\nt = int(input())\ntest_cases = [int(input()) for _ in range(t)]\n\n# Get results\nresults = minimize_number(t, test_cases)\n\n# Print output\nprint(\"\\n\".join(results))\n```",
    "34": "```python\ndef greatest_integer(t, cases):\n    segments_needed = [6, 2, 5, 5, 4, 5, 6, 3, 7, 6]  # segments needed for digits 0-9\n    results = []\n    \n    for n in cases:\n        if n % 2 == 0:  # even case\n            results.append('1' * (n // 2))\n        else:  # odd case\n            results.append('7' + '1' * (n // 2 - 1))\n    \n    return results\n\n# Input reading\nt = int(input().strip())\ncases = [int(input().strip()) for _ in range(t)]\n\n# Get results and print\nresults = greatest_integer(t, cases)\nprint(\"\\n\".join(results))\n```",
    "35": "```python\ndef max_groups(test_cases):\n    results = []\n    for e in test_cases:\n        e.sort()\n        count = 0\n        group_size = 0\n        \n        for inexperience in e:\n            group_size += 1\n            if group_size >= inexperience:\n                count += 1\n                group_size = 0\n        \n        results.append(count)\n    \n    return results\n\nimport sys\ninput = sys.stdin.read\n\ndata = input().splitlines()\nT = int(data[0])\ntest_cases = []\n\nindex = 1\nfor _ in range(T):\n    N = int(data[index])  # Read N but not used\n    explorers = list(map(int, data[index + 1].split()))\n    test_cases.append(explorers)\n    index += 2\n\nresults = max_groups(test_cases)\nprint('\\n'.join(map(str, results)))\n```",
    "36": "```python\nn = int(input())\na = list(map(int, input().split()))\nm = int(input())\nqueries = list(map(int, input().split()))\n\n# Calculate prefix sums to determine the ranges of worm labels in each pile\nprefix_sums = [0] * n\nprefix_sums[0] = a[0]\nfor i in range(1, n):\n    prefix_sums[i] = prefix_sums[i - 1] + a[i]\n\n# For each query, determine which pile it belongs to\nresults = []\nfor query in queries:\n    # Binary search for the correct pile\n    low, high = 0, n - 1\n    while low < high:\n        mid = (low + high) // 2\n        if prefix_sums[mid] < query:\n            low = mid + 1\n        else:\n            high = mid\n    results.append(low + 1)\n\n# Print the results\nprint('\\n'.join(map(str, results)))\n```",
    "37": "```python\ndef generate_good_permutations(n):\n    from itertools import permutations\n\n    def is_good(perm):\n        # Function to check if a permutation is good\n        idx_map = {value: idx for idx, value in enumerate(perm)}\n        visited = [False] * n\n        components = []\n\n        for i in range(n):\n            if not visited[i]:\n                component = []\n                x = i\n                while not visited[x]:\n                    visited[x] = True\n                    component.append(perm[x])\n                    x = idx_map[perm[x]]\n                # Sort component and rotate to max\n                max_val = max(component)\n                max_index = component.index(max_val)\n                rotated_component = component[max_index:] + component[:max_index]\n                components.append(rotated_component)\n\n        components.sort(key=lambda x: x[0])  # Sort by the first element\n        result = []\n        for comp in components:\n            result.extend(comp)\n        return result == list(perm)\n\n    good_perms = []\n    for perm in permutations(range(1, n + 1)):\n        if is_good(perm):\n            good_perms.append(perm)\n\n    return good_perms\n\ndef find_kth_good_permutation(n, k):\n    good_perms = generate_good_permutations(n)\n    if k > len(good_perms):\n        return -1\n    else:\n        return good_perms[k - 1]  # 1-based index\n\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_good_permutation(n, k)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n```",
    "38": "```python\nt = int(input())\nfor _ in range(t):\n    n, k1, k2 = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    \n    # Find the maximum card of each player\n    max_a = max(a)\n    max_b = max(b)\n    \n    # The player with the higher maximum card wins\n    if max_a > max_b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "39": "```python\ndef min_crossroad(test_cases):\n    results = []\n    for a, b, p, s in test_cases:\n        n = len(s)\n        total_cost = 0\n        last_type = ''\n        \n        # Traverse from the end to the start\n        for i in range(n - 1, -1, -1):\n            if s[i] != last_type:\n                # We have encountered a new segment\n                if s[i] == 'A':\n                    total_cost += a\n                else:\n                    total_cost += b\n                last_type = s[i]\n            \n            # Check if the total cost is within the money Petya has\n            if total_cost <= p:\n                results.append(i + 1)  # +1 for 1-based index\n                break\n\n    return results\n\n# Input reading\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\n\nindex = 1\nfor _ in range(t):\n    a, b, p = map(int, data[index].split())\n    s = data[index + 1].strip()\n    test_cases.append((a, b, p, s))\n    index += 2\n\n# Get results and print them\nresults = min_crossroad(test_cases)\nfor res in results:\n    print(res)\n```",
    "40": "```python\ndef min_operations_to_sort(q, queries):\n    results = []\n    \n    for n, a in queries:\n        # Count frequency of each element\n        from collections import Counter\n        count = Counter(a)\n        \n        # Create a sorted version of the array\n        sorted_a = sorted(a)\n        \n        # Find the longest prefix of the sorted array that can be formed\n        max_length = 0\n        current_length = 0\n        \n        for i in range(n):\n            if i == 0 or sorted_a[i] == sorted_a[i-1]:\n                current_length += count[sorted_a[i]]\n            else:\n                # Reset the current length for new element\n                max_length = max(max_length, current_length)\n                current_length = count[sorted_a[i]]\n        \n        # Final check for the last element\n        max_length = max(max_length, current_length)\n        \n        # Minimum operations needed is total elements minus the size of the longest valid prefix\n        min_operations = n - max_length\n        results.append(min_operations)\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nq = int(data[0])\nqueries = []\n\nindex = 1\nfor _ in range(q):\n    n = int(data[index])\n    a = list(map(int, data[index + 1].split()))\n    queries.append((n, a))\n    index += 2\n\n# Get results\nresults = min_operations_to_sort(q, queries)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "41": "```python\ndef make_neat_and_clean(t, test_cases):\n    results = []\n    \n    for n, k, s in test_cases:\n        operations = []\n        # Start by creating a regular sequence with k prefixes\n        target = []\n        for i in range(k):\n            target.append('(')\n        for i in range(k):\n            target.append(')')\n        # Fill the rest with balanced pairs\n        for i in range(n // 2 - k):\n            target.append('(')\n            target.append(')')\n        \n        target = ''.join(target)\n\n        # Find the operations to convert s to target\n        s = list(s)\n        for i in range(n):\n            if s[i] != target[i]:\n                # Find the position to swap with\n                for j in range(i + 1, n):\n                    if s[j] == target[i]:\n                        # Perform the reverse operation\n                        operations.append((i + 1, j + 1))\n                        s[i:j + 1] = s[i:j + 1][::-1]\n                        break\n        \n        results.append(operations)\n    \n    # Printing results\n    output = []\n    for operations in results:\n        output.append(str(len(operations)))\n        for l, r in operations:\n            output.append(f\"{l} {r}\")\n    \n    return \"\\n\".join(output)\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, k = map(int, input().split())\n    s = input().strip()\n    test_cases.append((n, k, s))\n\n# Get results and print\nprint(make_neat_and_clean(t, test_cases))\n```",
    "42": "```python\ndef count_good_substrings(s):\n    n = len(s)\n    count = 0\n    \n    for l in range(n):\n        num = 0\n        for r in range(l, n):\n            num = num * 2 + int(s[r])\n            if r - l + 1 == num:\n                count += 1\n            # Early stop if num exceeds the length of the substring\n            if num > r - l + 1:\n                break\n    \n    return count\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    s = input().strip()\n    results.append(count_good_substrings(s))\n\nprint(\"\\n\".join(map(str, results)))\n```",
    "43": "```python\ndef minimum_time_to_home(t, test_cases):\n    results = []\n    for i in range(t):\n        n = test_cases[i][0]\n        a = test_cases[i][1]\n        b = test_cases[i][2]\n        \n        # Calculate the minimum time\n        min_time = float('inf')\n        total_pickup_time = 0\n        \n        for j in range(n):\n            total_pickup_time += b[j]\n            min_time = min(min_time, max(total_pickup_time, a[j]))\n        \n        results.append(min_time)\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    test_cases.append((n, a, b))\n\n# Get results\nresults = minimum_time_to_home(t, test_cases)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "44": "```python\ndef find_chairs(n):\n    # We can take chairs numbered as even numbers from 2 to 4n\n    return list(range(2, 4 * n + 1, 2))\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    chairs = find_chairs(n)\n    print(\" \".join(map(str, chairs)))\n```",
    "45": "```python\ndef max_nice_staircases(x):\n    count = 0\n    n = 1\n    while x >= n * (n + 1) // 2:\n        count += 1\n        x -= n * (n + 1) // 2\n        n += 1\n    return count\n\nt = int(input())\nfor _ in range(t):\n    x = int(input())\n    print(max_nice_staircases(x))\n```",
    "46": "```python\ndef maximize_wins(test_cases):\n    results = []\n    for s in test_cases:\n        count_R = s.count('R')\n        count_S = s.count('S')\n        count_P = s.count('P')\n        \n        # We choose the move that beats the most frequent move of the bot\n        if count_R >= count_S and count_R >= count_P:\n            results.append('P' * len(s))  # Paper beats Rock\n        elif count_S >= count_R and count_S >= count_P:\n            results.append('R' * len(s))  # Rock beats Scissors\n        else:\n            results.append('S' * len(s))  # Scissors beat Paper\n    return results\n\n# Input reading\nt = int(input())\ntest_cases = [input().strip() for _ in range(t)]\n\n# Getting the results\nresults = maximize_wins(test_cases)\n\n# Output the results\nfor result in results:\n    print(result)\n```",
    "47": "```python\ndef max_strength(n, a):\n    a.sort()\n    max_strength = 0\n    for i in range(n):\n        if i % 2 == 0:\n            max_strength += a[n - 1 - i]\n        else:\n            max_strength -= a[n - 1 - i]\n    return max_strength\n\nt = int(input())\nfor _ in range(t):\n    n, q = map(int, input().split())\n    a = list(map(int, input().split()))\n    result = []\n    result.append(max_strength(n, a))\n    print(*result)\n```",
    "48": "```python\ndef min_trades(t, test_cases):\n    results = []\n    for x, y, k in test_cases:\n        # Calculate total sticks needed\n        total_sticks_needed = k + k * y\n        \n        # Calculate how many sticks we need to buy\n        sticks_to_buy = total_sticks_needed - 1  # We start with 1 stick\n        \n        # Calculate trades for sticks\n        trades_for_sticks = (sticks_to_buy + (x - 1)) // (x - 1)  # ceil(sticks_to_buy / (x - 1))\n        \n        # Calculate trades for coal\n        trades_for_coal = k\n        \n        # Total trades\n        total_trades = trades_for_sticks + trades_for_coal\n        results.append(total_trades)\n    return results\n\n# Read input\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_trades(t, test_cases)\n\n# Print results\nfor res in results:\n    print(res)\n```",
    "49": "```python\ndef count_classy_integers(L, R):\n    count = 0\n    for i in range(1, R + 1):\n        if L <= i <= R:\n            if len(str(i).replace('0', '')) <= 3:\n                count += 1\n    return count\n\nT = int(input())\nresults = []\n\nfor _ in range(T):\n    L, R = map(int, input().split())\n    results.append(count_classy_integers(L, R))\n\nfor result in results:\n    print(result)\n```",
    "50": "```python\ndef min_jars_to_empty(t, test_cases):\n    results = []\n    for n, jars in test_cases:\n        count1 = jars.count(1)\n        count2 = jars.count(2)\n        \n        # If the counts are already equal, no jars need to be emptied\n        if count1 == count2:\n            results.append(0)\n            continue\n        \n        # Calculate how many we need to remove to balance\n        imbalance = abs(count1 - count2) // 2\n        \n        # We need to find the minimum number of jars to empty\n        # The number of jars to empty is the total imbalance\n        total_jars_to_empty = 0\n        \n        # We can keep removing from both sides to balance\n        for i in range(2*n):\n            if jars[i] == 1:\n                count1 -= 1\n            else:\n                count2 -= 1\n            \n            total_jars_to_empty += 1\n            \n            if count1 == count2:\n                break\n        \n        results.append(total_jars_to_empty)\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    jars = list(map(int, input().split()))\n    test_cases.append((n, jars))\n\n# Getting results\nresults = min_jars_to_empty(t, test_cases)\n\n# Output results\nfor res in results:\n    print(res)\n```",
    "51": "```python\ndef can_have_no_winner(n, k, d1, d2):\n    # Remaining games\n    remaining_games = n - k\n    \n    # Wins of team 1, 2, and 3\n    w1 = (d1 + d2) // 2\n    w2 = (d1 - d2) // 2\n    w3 = (d2 - d1) // 2\n\n    # Check if the calculated wins are valid\n    if (d1 + d2) % 2 != 0 or w1 < 0 or w2 < 0 or w3 < 0:\n        return \"no\"\n    \n    # Total wins after k games\n    total_wins = w1 + w2 + w3\n    \n    # Remaining games should be enough to balance the wins\n    if total_wins + remaining_games >= 0 and (total_wins + remaining_games) % 3 == 0:\n        return \"yes\"\n    \n    return \"no\"\n\nt = int(input())\nfor _ in range(t):\n    n, k, d1, d2 = map(int, input().split())\n    print(can_have_no_winner(n, k, d1, d2))\n```",
    "52": "```python\ndef minimum_time(n, tasks):\n    # Sort both the tasks and students' laziness levels\n    tasks.sort()\n    tasks.reverse()  # To minimize the time, we pair the largest with the largest\n    students = tasks.copy()\n    students.sort()\n    \n    total_time = 0\n    for i in range(n):\n        total_time += students[i] * tasks[i]\n        total_time %= 10007  # Take modulo at each step to avoid overflow\n\n    return total_time\n\n# Input reading\nn = int(input())\ntasks = [int(input()) for _ in range(n)]\n\n# Calculate and print the result\nresult = minimum_time(n, tasks)\nprint(result)\n```",
    "53": "```python\ndef min_max_lis(t, test_cases):\n    results = []\n    \n    for n, s in test_cases:\n        # Constructing sequence for minimum LIS\n        min_seq = []\n        left = 1\n        right = n\n        \n        for char in s:\n            if char == '<':\n                min_seq.append(left)\n                left += 1\n            else:\n                min_seq.append(right)\n                right -= 1\n        \n        min_seq.append(left)  # Append the last remaining number\n        results.append(\" \".join(map(str, min_seq)))\n        \n        # Constructing sequence for maximum LIS\n        max_seq = []\n        left = 1\n        right = n\n        \n        for char in s:\n            if char == '<':\n                max_seq.append(left)\n                left += 1\n            else:\n                max_seq.append(right)\n                right -= 1\n        \n        max_seq.append(left)  # Append the last remaining number\n        results.append(\" \".join(map(str, max_seq[::-1])))  # Reverse for max LIS\n        \n    return results\n\n# Input handling\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nt = int(data[0])\ntest_cases = [(int(line.split()[0]), line.split()[1]) for line in data[1:t+1]]\n\n# Get results\nresults = min_max_lis(t, test_cases)\n\n# Output results\nprint(\"\\n\".join(results))\n```",
    "54": "```python\ndef can_win_2048(queries):\n    results = []\n    for query in queries:\n        n, s = query\n        # Check if 2048 is already in the multiset\n        if 2048 in s:\n            results.append(\"YES\")\n            continue\n        \n        # Sum up all the powers of two less than or equal to 2048\n        total = sum(x for x in s if x < 2048)\n        \n        # If the total is at least 2048, we can form it\n        if total >= 2048:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Read input\nq = int(input())\nqueries = []\nfor _ in range(q):\n    n = int(input())\n    s = list(map(int, input().split()))\n    queries.append((n, s))\n\n# Get results\nresults = can_win_2048(queries)\n\n# Print the results\nfor result in results:\n    print(result)\n```",
    "55": "```python\ndef max_equal_length_sticks(n):\n    return (n + 1) // 2\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    print(max_equal_length_sticks(n))\n```",
    "56": "```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    results = []\n    \n    for i in range(1, t + 1):\n        n, k = map(int, data[i].split())\n        \n        # Create an n x n grid initialized to 0\n        grid = [[0] * n for _ in range(n)]\n        \n        # Fill the grid with 1s in a diagonal pattern\n        for j in range(k):\n            row = j // n\n            col = j % n\n            grid[row][col] = 1\n            \n        # Calculate row sums and column sums\n        row_sums = [sum(grid[r]) for r in range(n)]\n        col_sums = [sum(grid[r][c] for r in range(n)) for c in range(n)]\n        \n        max_row = max(row_sums)\n        min_row = min(row_sums)\n        max_col = max(col_sums)\n        min_col = min(col_sums)\n        \n        # Calculate f(A)\n        f_value = (max_row - min_row) ** 2 + (max_col - min_col) ** 2\n        \n        # Store results\n        results.append(f_value)\n        for row in grid:\n            results.append(''.join(map(str, row)))\n    \n    # Output results\n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\n# Uncomment the following line to run the function\n# solve()\n```",
    "57": "```python\ndef can_reduce_to_one(test_cases):\n    results = []\n    for n, a in test_cases:\n        found = False\n        for i in range(n - 1):\n            if a[i] < a[i + 1]:\n                found = True\n                break\n        results.append(\"YES\" if found else \"NO\")\n    return results\n\n# Reading input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Getting results\nresults = can_reduce_to_one(test_cases)\n\n# Printing results\nprint(\"\\n\".join(results))\n```",
    "58": "```python\ndef min_cost_to_break_chocolate(t, queries):\n    results = []\n    \n    for n, m, k in queries:\n        if k == n * m:\n            results.append(0)\n            continue\n        \n        # DP table to store minimum cost for each (n, m, k)\n        dp = [[[float('inf')] * (k + 1) for _ in range(m + 1)] for _ in range(n + 1)]\n        \n        # Base case: 0 cost to get 0 squares\n        for i in range(n + 1):\n            for j in range(m + 1):\n                dp[i][j][0] = 0\n        \n        # Fill the DP table\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                total_squares = i * j\n                \n                # If we can take the whole piece, cost is 0\n                if total_squares <= k:\n                    dp[i][j][total_squares] = 0\n                \n                # Try horizontal cuts\n                for cut in range(1, i):\n                    cost = j * j  # cost of cutting horizontally\n                    for x in range(total_squares + 1):\n                        if dp[cut][j][x] != float('inf'):\n                            dp[i][j][x] = min(dp[i][j][x], dp[cut][j][x] + cost)\n                        if dp[i - cut][j][x] != float('inf'):\n                            dp[i][j][x] = min(dp[i][j][x], dp[i - cut][j][x] + cost)\n                \n                # Try vertical cuts\n                for cut in range(1, j):\n                    cost = i * i  # cost of cutting vertically\n                    for x in range(total_squares + 1):\n                        if dp[i][cut][x] != float('inf'):\n                            dp[i][j][x] = min(dp[i][j][x], dp[i][cut][x] + cost)\n                        if dp[i][j - cut][x] != float('inf'):\n                            dp[i][j][x] = min(dp[i][j][x], dp[i][j - cut][x] + cost)\n        \n        results.append(dp[n][m][k])\n    \n    return results\n\n# Example usage\nt = int(input())\nqueries = [tuple(map(int, input().split())) for _ in range(t)]\nresults = min_cost_to_break_chocolate(t, queries)\n\nfor result in results:\n    print(result)\n```",
    "59": "```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index].split()))\n        index += 1\n        \n        # Find the minimum and maximum of the known values\n        known_values = [x for x in a if x != -1]\n        min_known = min(known_values)\n        max_known = max(known_values)\n        \n        # If no known values, we can choose k freely, let's say 0\n        if not known_values:\n            results.append(\"0 0\")\n            continue\n        \n        # The minimum possible value of m\n        m = max(max_known - min_known, abs(min_known - 0), abs(max_known - 0))\n        \n        # The optimal k\n        k = (min_known + max_known) // 2\n        \n        results.append(f\"{m} {k}\")\n    \n    print(\"\\n\".join(results))\n\nsolve()\n```",
    "60": "```python\ndef smallest_value(t, test_cases):\n    results = []\n    for a, b in test_cases:\n        results.append(a ^ b)\n    return results\n\n# Read input\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = smallest_value(t, test_cases)\n\n# Print output\nfor result in results:\n    print(result)\n```",
    "61": "```python\ndef find_indices(test_cases):\n    results = []\n    for n, p in test_cases:\n        found = False\n        for j in range(1, n - 1):\n            if p[j - 1] < p[j] > p[j + 1]:\n                results.append(f\"YES\\n{j}\\n{j + 1}\\n{j + 2}\")\n                found = True\n                break\n        if not found:\n            results.append(\"NO\")\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    T = int(data[0])\n    test_cases = []\n    \n    index = 1\n    for _ in range(T):\n        n = int(data[index])\n        p = list(map(int, data[index + 1].split()))\n        test_cases.append((n, p))\n        index += 2\n    \n    results = find_indices(test_cases)\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "62": "```python\ndef can_form_keyboard(s):\n    from collections import defaultdict, deque\n    \n    # Create a graph to represent adjacent characters\n    graph = defaultdict(set)\n    degree = defaultdict(int)\n    \n    # Build the graph based on adjacent characters in the string\n    for i in range(len(s) - 1):\n        a, b = s[i], s[i + 1]\n        if b not in graph[a]:\n            graph[a].add(b)\n            graph[b].add(a)\n            degree[a] += 1\n            degree[b] += 1\n\n    # Check for any characters with degree > 2 (which means it can't be a linear layout)\n    for d in degree.values():\n        if d > 2:\n            return \"NO\", \"\"\n    \n    # Find the starting point (a character with degree 1 or any character if all have degree 2)\n    start = None\n    for char in degree:\n        if degree[char] == 1:\n            start = char\n            break\n    if start is None:\n        start = next(iter(degree))  # Just take any character\n\n    # Perform BFS or DFS to get the order of characters\n    visited = set()\n    layout = []\n    queue = deque([start])\n\n    while queue:\n        current = queue.popleft()\n        if current in visited:\n            continue\n        visited.add(current)\n        layout.append(current)\n        \n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n\n    # If we covered all characters\n    if len(visited) < 26:\n        layout = ''.join(layout) + ''.join(chr(i) for i in range(ord('a'), ord('z') + 1) if chr(i) not in visited)\n    else:\n        layout = ''.join(layout)\n\n    return \"YES\", layout\n\n\n# Input handling\nT = int(input())\nresults = []\nfor _ in range(T):\n    s = input().strip()\n    result = can_form_keyboard(s)\n    results.append(result)\n\n# Output results\nfor res in results:\n    if res[0] == \"NO\":\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(res[1])\n```",
    "63": "```python\ndef max_happiness(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, k, a, w = case\n        a.sort()\n        w.sort(reverse=True)\n\n        total_happiness = 0\n        # Assign the maximum elements to the friends according to their weights\n        total_happiness += a[-1] * k  # Each friend gets their own maximum\n        # Each friend gets their minimum based on the weights\n        for i in range(k):\n            total_happiness += a[-(w[i] + 1)]  # Assign the minimum from the remaining highest values\n\n        results.append(total_happiness)\n    \n    return results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nindex = 0\nt = int(data[index])\nindex += 1\ntest_cases = []\n\nfor _ in range(t):\n    n, k = map(int, data[index].split())\n    index += 1\n    a = list(map(int, data[index].split()))\n    index += 1\n    w = list(map(int, data[index].split()))\n    index += 1\n    test_cases.append((n, k, a, w))\n\nresults = max_happiness(t, test_cases)\n\n# Output the results\nfor result in results:\n    print(result)\n```",
    "64": "```python\ndef time_to_meet(n, l, flags):\n    # Initial positions and speeds\n    car1_pos = 0\n    car2_pos = l\n    car1_speed = 1\n    car2_speed = 1\n    \n    flags1 = flags.copy()  # For the first car\n    flags2 = [l - a for a in reversed(flags)]  # Mirror positions for the second car\n\n    # Initialize the time taken until the next flag\n    time1 = 0\n    time2 = 0\n\n    while flags1 or flags2:\n        if not flags1:\n            # Only car2 is moving\n            time_to_next_flag = (flags2[-1] - car2_pos) / car2_speed\n            time2 += time_to_next_flag\n            car2_pos = flags2.pop()\n            car2_speed += 1\n        elif not flags2:\n            # Only car1 is moving\n            time_to_next_flag = (flags1[0] - car1_pos) / car1_speed\n            time1 += time_to_next_flag\n            car1_pos = flags1.pop(0)\n            car1_speed += 1\n        else:\n            # Both cars are moving towards their next flags\n            time_to_next_flag1 = (flags1[0] - car1_pos) / car1_speed\n            time_to_next_flag2 = (flags2[-1] - car2_pos) / car2_speed\n            \n            if time_to_next_flag1 < time_to_next_flag2:\n                time1 += time_to_next_flag1\n                car1_pos = flags1.pop(0)\n                car1_speed += 1\n                # Move car2 during the time taken by car1\n                car2_pos += car2_speed * time_to_next_flag1\n                if car1_pos >= car2_pos:  # They meet\n                    return time1\n            else:\n                time2 += time_to_next_flag2\n                car2_pos = flags2.pop()\n                car2_speed += 1\n                # Move car1 during the time taken by car2\n                car1_pos += car1_speed * time_to_next_flag2\n                if car1_pos >= car2_pos:  # They meet\n                    return time2 + time1\n\n    # Final meeting time calculation if we exhaust all flags\n    if car1_pos < car2_pos:\n        meeting_time = (car2_pos - car1_pos) / (car1_speed + car2_speed)\n        return time1 + time2 + meeting_time\n    return time1 + time2\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    output = []\n    \n    index = 1\n    for _ in range(t):\n        n, l = map(int, data[index].split())\n        flags = list(map(int, data[index + 1].split()))\n        index += 2\n        \n        result = time_to_meet(n, l, flags)\n        output.append(f\"{result:.12f}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "65": "```python\ndef minimum_skip_points(test_cases):\n    results = []\n    for n, bosses in test_cases:\n        skip_points = 0\n        i = 0\n        while i < n:\n            if bosses[i] == 1:\n                skip_points += 1\n                if i + 1 < n and bosses[i + 1] == 1:\n                    i += 2  # If there's another hard boss, skip it as well\n                else:\n                    i += 1  # Move to the next boss\n            else:\n                if i + 1 < n and bosses[i + 1] == 1:\n                    i += 2  # You can take two easy bosses to skip the hard one\n                else:\n                    i += 1  # Just take the easy boss\n        results.append(skip_points)\n    return results\n\n# Reading input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    bosses = list(map(int, input().split()))\n    test_cases.append((n, bosses))\n\n# Getting results\nresults = minimum_skip_points(test_cases)\n\n# Printing results\nfor result in results:\n    print(result)\n```",
    "66": "```python\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    \n    # We can simply sort the arrays and pair them\n    a.sort()\n    b.sort()\n    \n    # Output the sorted arrays\n    print(\" \".join(map(str, a)))\n    print(\" \".join(map(str, b)))\n```",
    "67": "```python\ndef can_make_equal(k, test_cases):\n    results = []\n    \n    for case in range(k):\n        n = test_cases[case][0]\n        s = list(test_cases[case][1])\n        t = list(test_cases[case][2])\n        \n        # Count character occurrences\n        from collections import Counter\n        count_s = Counter(s)\n        count_t = Counter(t)\n        \n        # Combine counts\n        combined_counts = count_s + count_t\n        \n        # Check if the combined counts have even occurrences for each character\n        can_equal = all(count % 2 == 0 for count in combined_counts.values())\n        \n        if not can_equal:\n            results.append(\"No\")\n            continue\n        \n        results.append(\"Yes\")\n        operations = []\n        \n        # Make a list of mismatched positions\n        mismatched_s = []\n        mismatched_t = []\n        \n        for i in range(n):\n            if s[i] != t[i]:\n                mismatched_s.append(i)\n                mismatched_t.append(i)\n        \n        # Now we need to swap characters to make them equal\n        for i in range(len(mismatched_s)):\n            if s[mismatched_s[i]] == t[mismatched_t[i]]:\n                continue\n            \n            # Find the character in t that needs to come to s\n            target_char = s[mismatched_s[i]]\n            target_index_in_t = -1\n            \n            for j in range(n):\n                if t[j] == target_char and j not in mismatched_t:\n                    target_index_in_t = j\n                    break\n            \n            if target_index_in_t != -1:\n                # Swap to bring the correct character into position\n                operations.append((mismatched_s[i] + 1, target_index_in_t + 1))  # 1-indexed\n                s[mismatched_s[i]], t[target_index_in_t] = t[target_index_in_t], s[mismatched_s[i]]\n            \n            # After this, we should have a match at mismatched_s[i]\n            if s[mismatched_s[i]] != t[mismatched_s[i]]:\n                # If not matched, we need an extra swap to fix it\n                operations.append((mismatched_s[i] + 1, mismatched_s[i] + 1))\n                operations.append((mismatched_s[i] + 1, mismatched_t[i] + 1))\n        \n        results.append(f\"{len(operations)}\")\n        for op in operations:\n            results.append(f\"{op[0]} {op[1]}\")\n    \n    return results\n\n# Read input\nk = int(input())\ntest_cases = []\nfor _ in range(k):\n    n = int(input())\n    s = input().strip()\n    t = input().strip()\n    test_cases.append((n, s, t))\n\n# Get results\nresults = can_make_equal(k, test_cases)\n\n# Print results\nfor res in results:\n    print(res)\n```",
    "68": "```python\ndef max_operations(t, test_cases):\n    results = []\n    for n, s in test_cases:\n        count = 0\n        i = 0\n        \n        while i < n:\n            count += 1\n            char = s[i]\n            while i < n and s[i] == char:\n                i += 1\n            while i < n and s[i] != char:\n                i += 1\n        \n        results.append(count)\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Get results\nresults = max_operations(t, test_cases)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "69": "```python\ndef min_cost_to_clear_mines(test_cases):\n    results = []\n    \n    for a, b, mine_map in test_cases:\n        n = len(mine_map)\n        segments = []\n        i = 0\n        \n        # Identify segments of mines\n        while i < n:\n            if mine_map[i] == '1':\n                start = i\n                while i < n and mine_map[i] == '1':\n                    i += 1\n                segments.append((start, i - 1))  # Store the start and end of the segment\n            else:\n                i += 1\n        \n        # If there are no segments, cost is 0\n        if not segments:\n            results.append(0)\n            continue\n        \n        # Calculate minimum cost\n        total_cost = 0\n        last_segment_end = segments[0][1]\n        \n        # Cost for the first segment\n        total_cost += a\n        \n        # Evaluate gaps between segments\n        for j in range(1, len(segments)):\n            gap = segments[j][0] - last_segment_end - 1  # Gap between segments\n            if gap > 0:\n                # Check if placing a mine is cheaper than activating\n                total_cost += min(a, gap * b)  # Activate the next segment or fill the gap\n            total_cost += a  # Cost to activate the current segment\n            last_segment_end = segments[j][1]\n        \n        results.append(total_cost)\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    a, b = map(int, input().split())\n    mine_map = input().strip()\n    test_cases.append((a, b, mine_map))\n\n# Get results and print\nresults = min_cost_to_clear_mines(test_cases)\nfor result in results:\n    print(result)\n```",
    "70": "```python\ndef min_replacements_to_k_complete(t, test_cases):\n    results = []\n    for n, k, s in test_cases:\n        # Number of groups based on period k\n        groups = n // k\n        # To count replacements needed\n        replacements = 0\n        \n        # Each position in the first half of the k-period\n        for i in range((k + 1) // 2):\n            # Count frequency of characters in the corresponding positions\n            freq = {}\n            for j in range(groups):\n                # Positions to consider\n                positions = [j * k + i, j * k + (k - 1 - i)]\n                for pos in positions:\n                    if pos < n:\n                        char = s[pos]\n                        if char in freq:\n                            freq[char] += 1\n                        else:\n                            freq[char] = 1\n            \n            # Total characters in these positions\n            total = sum(freq.values())\n            # Max frequency of a single character\n            max_freq = max(freq.values(), default=0)\n            # Replacements needed for this set of positions\n            replacements += total - max_freq\n            \n        results.append(replacements)\n    \n    return results\n\n# Input reading\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])  # Number of test cases\ntest_cases = []\nfor i in range(1, 2 * t, 2):\n    n, k = map(int, data[i].split())\n    s = data[i + 1]\n    test_cases.append((n, k, s))\n\n# Get results\nresults = min_replacements_to_k_complete(t, test_cases)\n\n# Output results\nsys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n```",
    "71": "```python\ndef min_coins_to_zero(test_cases):\n    results = []\n    for a in test_cases:\n        n = len(a)\n        coins = 0\n        balance = 0\n        \n        for i in range(n):\n            balance += a[i]\n            if balance < 0:\n                coins -= balance  # We need to pay for this deficit\n                balance = 0  # Reset balance as we can only make it zero now\n        \n        results.append(coins)\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input().strip())\n    a = list(map(int, input().strip().split()))\n    test_cases.append(a)\n\n# Get results\nresults = min_coins_to_zero(test_cases)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "72": "```python\ndef is_beautiful(array, k):\n    subarray_sums = set()\n    for i in range(len(array) - k + 1):\n        subarray_sum = sum(array[i:i+k])\n        subarray_sums.add(subarray_sum)\n    return len(subarray_sums) == 1\n\ndef create_beautiful_array(n, k, a):\n    elements = list(set(a))\n    \n    if len(elements) > k:\n        return -1  # Impossible to create a beautiful array\n    \n    result = []\n    for i in range(k):\n        result.append(elements[i % len(elements)])\n    \n    # Create a beautiful array by repeating the pattern\n    m = 10000\n    beautiful_array = (result * (m // k + 1))[:m]\n    \n    return m, beautiful_array\n\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    result = create_beautiful_array(n, k, a)\n    \n    if result == -1:\n        print(-1)\n    else:\n        m, beautiful_array = result\n        print(m)\n        print(' '.join(map(str, beautiful_array)))\n```",
    "73": "```python\ndef mex(arr):\n    present = [False] * (len(arr) + 1)\n    for num in arr:\n        if num < len(present):\n            present[num] = True\n    for i in range(len(present)):\n        if not present[i]:\n            return i\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1].split()))\n        index += 2\n        \n        operations = []\n        \n        for _ in range(2 * n):\n            current_mex = mex(a)\n            if all(a[i] <= a[i + 1] for i in range(len(a) - 1)):\n                break\n            \n            # Replace the first element that is not in the range [0, n)\n            for i in range(n):\n                if a[i] >= n or a[i] < 0:\n                    a[i] = current_mex\n                    operations.append(i + 1)\n                    break\n            \n        results.append(f\"{len(operations)}\")\n        results.append(\" \".join(map(str, operations)))\n    \n    print(\"\\n\".join(results))\n\n# Uncomment the following line to run the function directly when needed.\n# solve()\n```",
    "74": "```python\ndef maximize_army(T, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, k, minions = case\n        # Sort minions based on their initial power and boost effect\n        minions.sort(key=lambda x: (-x[0], -x[1]))\n        \n        actions = []\n        current_minions = []\n        current_power = 0\n        \n        for i in range(n):\n            a_i, b_i = minions[i]\n            # Summon the minion\n            actions.append(i + 1)  # Summon minion i (1-based index)\n            current_minions.append(a_i + sum(b for _, b in current_minions))\n            current_power += current_minions[-1]\n            \n            # If we exceed the number of controllable minions, destroy the weakest one\n            if len(current_minions) > k:\n                # Find the index of the weakest minion\n                weakest_index = current_minions.index(min(current_minions))\n                # Destroy that minion\n                actions.append(-(weakest_index + 1))  # Destroy minion (1-based index)\n                current_power -= current_minions[weakest_index]\n                current_minions.pop(weakest_index)\n        \n        # Result for this case\n        results.append((len(actions), actions))\n    \n    return results\n\n# Input reading\nT = int(input())\ntest_cases = []\n\nfor _ in range(T):\n    n, k = map(int, input().split())\n    minions = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, k, minions))\n\n# Get results\nresults = maximize_army(T, test_cases)\n\n# Output results\nfor m, actions in results:\n    print(m)\n    print(\" \".join(map(str, actions)))\n```",
    "75": "```python\nimport math\n\ndef minimum_square_side_length(n):\n    # Calculate the radius of the circumcircle of the 2n-gon\n    radius = 1 / (2 * math.sin(math.pi / (2 * n)))\n    # The side length of the square needed to contain the 2n-gon\n    square_side_length = radius * math.sqrt(2)\n    return square_side_length\n\nT = int(input())\nresults = []\nfor _ in range(T):\n    n = int(input())\n    results.append(minimum_square_side_length(n))\n\nfor result in results:\n    print(f\"{result:.9f}\")\n```",
    "76": "```python\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n = int(input())\n    if n % 4 == 0 or n % 4 == 2:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nprint(\"\\n\".join(results))\n```",
    "77": "```python\ndef min_cost_to_make_fence_great(q, queries):\n    results = []\n    \n    for query in queries:\n        n = query[0]\n        boards = query[1]\n        \n        # Cost to make the fence great\n        total_cost = 0\n        \n        # We can keep track of the height we need to ensure no duplicates\n        prev_height = -1\n        \n        for i in range(n):\n            a_i, b_i = boards[i]\n            \n            # If the previous height is the same as the current height, we need to increase\n            if a_i == prev_height:\n                # We can increase this board's height\n                # We have to choose the minimum cost option\n                # We can increase it to `a_i + 1`, `a_i + 2`, ..., until it differs from `prev_height`\n                # Cost for increasing this board to a_i + k is k * b_i\n                # We need to find the minimum cost to make it different from prev_height\n                \n                # We can only increase it to a height greater than a_i\n                # Calculate the cost to make it a_i + 1, a_i + 2, etc.\n                # Start with a_i + 1\n                if prev_height == a_i:\n                    cost_to_increase = b_i  # For a_i + 1\n                    total_cost += cost_to_increase\n                    a_i += 1  # We assume we increased it by 1\n            \n            # Update previous height\n            prev_height = a_i\n            \n        results.append(total_cost)\n    \n    return results\n\n# Reading input and executing function\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nq = int(data[0])\nqueries = []\nindex = 1\n\nfor _ in range(q):\n    n = int(data[index])\n    boards = []\n    for i in range(n):\n        a, b = map(int, data[index + 1 + i].split())\n        boards.append((a, b))\n    queries.append((n, boards))\n    index += n + 1\n\nresults = min_cost_to_make_fence_great(q, queries)\nprint(\"\\n\".join(map(str, results)))\n```",
    "78": "```python\ndef min_minutes_to_cross(q, queries):\n    results = []\n    for n, m, grid in queries:\n        # Count black cells in each row and each column\n        row_black_counts = [0] * n\n        col_black_counts = [0] * m\n        \n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    row_black_counts[i] += 1\n                    col_black_counts[j] += 1\n        \n        # Find the minimum number of paints required for each possible cross\n        min_paints = float('inf')\n        \n        for x in range(n):\n            for y in range(m):\n                if grid[x][y] == '.':\n                    # Calculate needed paints for cross at (x, y)\n                    total_paints = (n - row_black_counts[x]) + (m - col_black_counts[y])\n                    min_paints = min(min_paints, total_paints)\n        \n        # If there's already a cross, no need to paint\n        if min_paints == float('inf'):\n            min_paints = 0\n        \n        results.append(min_paints)\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nq = int(data[0])\nqueries = []\nindex = 1\n\nfor _ in range(q):\n    n, m = map(int, data[index].split())\n    grid = data[index + 1:index + 1 + n]\n    queries.append((n, m, grid))\n    index += 1 + n\n\n# Get results\nresults = min_minutes_to_cross(q, queries)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "79": "```python\ndef get_divisors(n):\n    divisors = []\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    divisors.append(n)\n    return divisors\n\ndef solve(n):\n    divisors = get_divisors(n)\n    divisors.sort()\n    \n    # The minimal number of moves needed to ensure no two adjacent numbers are coprime\n    moves = 0\n    \n    # If there are only two divisors, we can directly check and return the result\n    if len(divisors) == 2:\n        return divisors, 0\n    \n    # An initial order that ensures we can minimize moves\n    # For any composite number, we can arrange them in a way that\n    # we have pairs of numbers that share a prime factor\n    initial_order = []\n    \n    # We can create a simple arrangement where we put the smallest prime factor first\n    # and then follow it with the other divisors\n    prime_factors = []\n    for d in divisors:\n        if d < n and n % d == 0:\n            prime_factors.append(d)\n    \n    # We can take the first prime factor and alternate with the rest\n    if prime_factors:\n        initial_order.append(prime_factors[0])\n        for d in divisors:\n            if d != prime_factors[0]:\n                initial_order.append(d)\n    \n    return initial_order, moves\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    order, moves = solve(n)\n    print(\" \".join(map(str, order)))\n    print(moves)\n```",
    "80": "```python\ndef count_pairs(l, r):\n    count = 0\n    for a in range(l, r + 1):\n        for b in range(l, r + 1):\n            if a + b == a ^ b:\n                count += 1\n    return count\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    l, r = map(int, input().split())\n    results.append(count_pairs(l, r))\n\nprint('\\n'.join(map(str, results)))\n```",
    "81": "```python\ndef can_make_equal(t, test_cases):\n    results = []\n    for i in range(t):\n        a = test_cases[i][0]\n        b = test_cases[i][1]\n        c = test_cases[i][2]\n        \n        n = len(a)\n        possible = True\n        \n        for j in range(n):\n            if a[j] == b[j]:\n                continue\n            # Check if we can turn a[j] into b[j] with c[j]\n            if c[j] != a[j] and c[j] != b[j]:\n                possible = False\n                break\n        \n        results.append(\"YES\" if possible else \"NO\")\n    \n    return results\n\nt = int(input())\ntest_cases = [tuple(input().strip() for _ in range(3)) for _ in range(t)]\nresults = can_make_equal(t, test_cases)\nprint(\"\\n\".join(results))\n```",
    "82": "```python\ndef find_permutation_with_same_fingerprint(t, test_cases):\n    results = []\n    for n, p in test_cases:\n        # A simple way to generate a different permutation is to rotate the original\n        p_prime = p[1:] + p[:1]\n        results.append(p_prime)\n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    p = list(map(int, input().split()))\n    test_cases.append((n, p))\n\n# Get results\nresults = find_permutation_with_same_fingerprint(t, test_cases)\n\n# Output results\nfor result in results:\n    print(\" \".join(map(str, result)))\n```",
    "83": "```python\nt = int(input())\nfor _ in range(t):\n    x, y, a, b = map(int, input().split())\n    distance = y - x\n    total_hops = a + b\n    \n    if distance % total_hops == 0:\n        print(distance // total_hops)\n    else:\n        print(-1)\n```",
    "84": "```python\ndef count_exterminable_subarrays(q, queries):\n    results = []\n    \n    for n, a in queries:\n        count = 0\n        # To store the last index of each element\n        last_index = {}\n        # To store the current stack's size\n        stack = []\n        \n        # Iterate over each end index of the subarray\n        for end in range(n):\n            # If the stack is not empty and the top element is the same as the current\n            if stack and stack[-1] == a[end]:\n                stack.pop()  # Pop the top element\n            else:\n                stack.append(a[end])  # Push new element\n            \n            # Check for exterminable subarrays ending at 'end'\n            if not stack:  # If stack is empty\n                count += end + 1  # All subarrays from the start to 'end' are valid\n            \n            # Check for pairs that can form exterminable subarrays\n            if a[end] in last_index:\n                last_pos = last_index[a[end]]\n                if last_pos != -1:  # If there is a valid previous position\n                    count += (last_pos + 1)  # Add the number of valid subarrays ending at this position\n            \n            last_index[a[end]] = end  # Update the last index of the current element\n        \n        results.append(count)\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nindex = 0\nq = int(data[index])\nindex += 1\nqueries = []\n\nfor _ in range(q):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    queries.append((n, a))\n\n# Get the results\nresults = count_exterminable_subarrays(q, queries)\n\n# Print the results\nfor result in results:\n    print(result)\n```",
    "85": "```python\ndef reconstruct_string(t, test_cases):\n    results = []\n    for case in test_cases:\n        s, x = case\n        n = len(s)\n        # Initialize w with all '0's\n        w = ['0'] * n\n        \n        for i in range(n):\n            if s[i] == '1':\n                if i - x >= 0:\n                    w[i - x] = '1'\n                if i + x < n:\n                    w[i + x] = '1'\n        \n        # Validate if w can produce s\n        valid = True\n        for i in range(n):\n            if s[i] == '1':\n                if not ((i - x >= 0 and w[i - x] == '1') or (i + x < n and w[i + x] == '1')):\n                    valid = False\n                    break\n            else:\n                if (i - x >= 0 and w[i - x] == '1') or (i + x < n and w[i + x] == '1'):\n                    valid = False\n                    break\n        \n        if valid:\n            results.append(''.join(w))\n        else:\n            results.append('-1')\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    s = input().strip()\n    x = int(input().strip())\n    test_cases.append((s, x))\n\n# Get results and print\nresults = reconstruct_string(t, test_cases)\nprint(\"\\n\".join(results))\n```",
    "86": "```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1].split()))\n        index += 2\n        \n        count_0 = a.count(0)\n        count_1 = a.count(1)\n        \n        if count_0 % 2 == 0 and count_0 > 0:\n            results.append(f\"{count_0}\")\n            results.append(\" \".join(\"0\" for _ in range(count_0)))\n        elif count_1 % 2 == 0 and count_1 > 0:\n            results.append(f\"{count_1}\")\n            results.append(\" \".join(\"1\" for _ in range(count_1)))\n        else:\n            if count_0 > 0:\n                results.append(f\"{count_0 - 1}\")\n                results.append(\" \".join(\"0\" for _ in range(count_0 - 1)))\n            else:\n                results.append(f\"{count_1 - 1}\")\n                results.append(\" \".join(\"1\" for _ in range(count_1 - 1)))\n\n    print(\"\\n\".join(results))\n\nsolve()\n```",
    "87": "```python\ndef count_ambiguous_pairs(m, d, w):\n    total_pairs = 0\n    # Calculate the maximum offset for the days\n    max_offset = min(d, w)\n    \n    # Calculate the number of ambiguous pairs\n    for x in range(1, m):\n        y_start = x + 1\n        y_end = min(m, x + max_offset - 1)\n        total_pairs += max(0, y_end - y_start + 1)\n\n    return total_pairs\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    m, d, w = map(int, input().split())\n    results.append(count_ambiguous_pairs(m, d, w))\n\nprint('\\n'.join(map(str, results)))\n```",
    "88": "```python\ndef is_possible_visible_pips(x):\n    # The minimum visible pips for one die is 14 (1 on top) and maximum is 20 (6 on top)\n    # For n dice, the number of visible pips can be calculated as:\n    # visible_pips = 14 + 7 * (n - 1), where n is the number of dice.\n    # The series produces values: 14, 21, 28, 35, ..., which is 14 + 7k for k >= 0.\n    \n    if x < 14:\n        return False\n    # Check if (x - 14) is a multiple of 7\n    return (x - 14) % 7 == 0\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])  # number of favourite integers\n    x_values = list(map(int, data[1:t + 1]))\n    \n    results = []\n    for x in x_values:\n        if is_possible_visible_pips(x):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "89": "```python\ndef min_tree_height(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        height = 0\n        current_level = [1]  # Start with the root\n        index = 1  # Start from the second element, since first is the root\n\n        while index < n:\n            next_level = []\n            for node in current_level:\n                # While we can add children to the current node\n                while index < n and a[index] > node:\n                    next_level.append(a[index])\n                    index += 1\n            current_level = next_level\n            height += 1\n        \n        results.append(height)\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().strip().split()))\n    test_cases.append((n, a))\n\n# Calculate and print results\nresults = min_tree_height(t, test_cases)\nfor res in results:\n    print(res)\n```",
    "90": "```python\ndef minimize_k(test_cases):\n    results = []\n    \n    for n, a, l in test_cases:\n        unlocked_values = [a[i] for i in range(n) if l[i] == 0]\n        unlocked_values.sort()  # Sort unlocked values in ascending order\n        index = 0\n        \n        new_a = []\n        for i in range(n):\n            if l[i] == 1:\n                new_a.append(a[i])  # Keep locked values as is\n            else:\n                new_a.append(unlocked_values[index])  # Place sorted unlocked values\n                index += 1\n        \n        results.append(new_a)\n    \n    return results\n\n# Read input and process each test case\nt = int(input())\ntest_cases = []\n\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    test_cases.append((n, a, l))\n\n# Get the result for each test case\nresults = minimize_k(test_cases)\n\n# Print the results\nfor result in results:\n    print(' '.join(map(str, result)))\n```",
    "91": "```python\ndef find_permutation(t, test_cases):\n    results = []\n    for _ in range(t):\n        n = test_cases[_][0]\n        q = test_cases[_][1]\n        \n        used = set()\n        p = []\n        possible = True\n        \n        for i in range(n):\n            if q[i] > (i + 1):  # Check if q[i] is greater than the current index + 1\n                possible = False\n                break\n            \n            if i == 0 or q[i] != q[i - 1]:\n                p.append(q[i])\n                used.add(q[i])\n            else:\n                # We need to find the smallest unused number\n                for num in range(1, n + 1):\n                    if num not in used:\n                        p.append(num)\n                        used.add(num)\n                        break\n        \n        if possible:\n            results.append(\" \".join(map(str, p)))\n        else:\n            results.append(\"-1\")\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    q = list(map(int, input().split()))\n    test_cases.append((n, q))\n\n# Get results\nresults = find_permutation(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "92": "```python\ndef can_transform(s, t):\n    return set(s) & set(t) != set()\n\ndef main():\n    q = int(input())\n    for _ in range(q):\n        s = input().strip()\n        t = input().strip()\n        if can_transform(s, t):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```",
    "93": "```python\ndef minimum_time_to_send_presents(test_cases):\n    results = []\n    \n    for n, m, a, b in test_cases:\n        # Create a mapping of present number to its index in the stack\n        position = {present: i for i, present in enumerate(a)}\n        \n        # Time initialization\n        total_time = 0\n        current_index = -1  # Start above the stack\n\n        for present in b:\n            target_index = position[present]\n            # Calculate how many presents are above the target present\n            if target_index > current_index:\n                k = target_index - current_index - 1\n                total_time += 2 * k + 1\n                current_index = target_index\n\n        results.append(total_time)\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    test_cases.append((n, m, a, b))\n\n# Get results\nresults = minimum_time_to_send_presents(test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "94": "```python\ndef minimize_misfortune(t, test_cases):\n    results = []\n    for n, T, a in test_cases:\n        color = [0] * n\n        freq = {}\n        \n        for i in range(n):\n            if a[i] in freq:\n                freq[a[i]].append(i)\n            else:\n                freq[a[i]] = [i]\n\n        for num in freq:\n            complement = T - num\n            if num == complement:\n                # If num and complement are the same, we can paint half and half\n                indices = freq[num]\n                for i in range(len(indices)):\n                    color[indices[i]] = i % 2\n            elif complement in freq:\n                # Paint all `num` in one color and `complement` in the other\n                for index in freq[num]:\n                    color[index] = 0\n                for index in freq[complement]:\n                    color[index] = 1\n\n        results.append(color)\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, T = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, T, a))\n\n# Get results\nresults = minimize_misfortune(t, test_cases)\n\n# Output results\nfor result in results:\n    print(\" \".join(map(str, result)))\n```",
    "95": "```python\ndef find_integer(t, test_cases):\n    results = []\n    for n in test_cases:\n        if n == 1:\n            results.append(\"-1\")\n        else:\n            # Create a number with n digits where no digit is 0 and not divisible by any of its digits\n            # We can use digits from 1 to 9 and repeat them as needed\n            # A simple approach is to use the sequence 1, 2, ..., n\n            # Avoiding the digits that could cause divisibility issues\n            if n == 2:\n                results.append(\"57\")  # Example for 2 digits\n            elif n == 3:\n                results.append(\"239\")  # Example for 3 digits\n            elif n == 4:\n                results.append(\"6789\")  # Example for 4 digits\n            else:\n                # For n > 4, we can use the pattern of digits 3 to 9\n                # Just repeat digits ensuring they do not divide the number\n                # E.g., form a number using digits 1 to 9\n                results.append(\"\".join(str(i % 9 + 1) for i in range(n)))\n\n    return results\n\n# Read input\nt = int(input())\ntest_cases = [int(input()) for _ in range(t)]\n\n# Get results\nresults = find_integer(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "96": "```python\ndef max_points(test_cases):\n    results = []\n    for case in test_cases:\n        n, T, a, b, problem_types, mandatory_times = case\n        easy_problems = []\n        hard_problems = []\n        \n        for i in range(n):\n            if problem_types[i] == 0:\n                easy_problems.append(mandatory_times[i])\n            else:\n                hard_problems.append(mandatory_times[i])\n        \n        easy_problems.sort()\n        hard_problems.sort()\n        \n        max_points = 0\n        \n        for s in range(T + 1):\n            easy_count = 0\n            hard_count = 0\n            easy_time = 0\n            hard_time = 0\n            \n            for t in easy_problems:\n                if t <= s and easy_time + a <= s:\n                    easy_time += a\n                    easy_count += 1\n            \n            for t in hard_problems:\n                if t <= s and hard_time + b <= s:\n                    hard_time += b\n                    hard_count += 1\n            \n            total_count = easy_count + hard_count\n            if all(t > s or (easy_time + a > s and hard_time + b > s) for t in mandatory_times if t <= s):\n                max_points = max(max_points, total_count)\n        \n        results.append(max_points)\n    \n    return results\n\nm = int(input())\ntest_cases = []\n\nfor _ in range(m):\n    n, T, a, b = map(int, input().split())\n    problem_types = list(map(int, input().split()))\n    mandatory_times = list(map(int, input().split()))\n    test_cases.append((n, T, a, b, problem_types, mandatory_times))\n\nresults = max_points(test_cases)\n\nfor result in results:\n    print(result)\n```",
    "97": "```python\ndef lexicographically_smaller(t, test_cases):\n    results = []\n    \n    for s, c in test_cases:\n        n = len(s)\n        found = False\n        best_name = s\n        \n        # Check if the original name is already smaller\n        if s < c:\n            results.append(s)\n            continue\n        \n        # Try to find a valid swap\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Create a new list to swap characters\n                new_name = list(s)\n                new_name[i], new_name[j] = new_name[j], new_name[i]\n                new_name = ''.join(new_name)\n                \n                # Check if the new name is smaller than c\n                if new_name < c:\n                    if not found or new_name < best_name:\n                        best_name = new_name\n                        found = True\n        \n        results.append(best_name if found else '---')\n    \n    return results\n\n# Read number of test cases\nt = int(input())\ntest_cases = [input().split() for _ in range(t)]\n\n# Get results\nresults = lexicographically_smaller(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "98": "```python\ndef max_perfect_teams(q, queries):\n    results = []\n    for c, m, x in queries:\n        # Maximum teams possible based on coders and mathematicians\n        teams_based_on_specializations = min(c, m)\n        # Maximum teams possible based on total students\n        teams_based_on_total_students = (c + m + x) // 3\n        # The actual maximum teams is the minimum of the two above\n        max_teams = min(teams_based_on_specializations, teams_based_on_total_students)\n        results.append(max_teams)\n    return results\n\n# Read input\nq = int(input())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Get results\nresults = max_perfect_teams(q, queries)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "99": "```python\ndef clean_binary_string(s):\n    # Count the number of 0s and 1s\n    count_0 = s.count('0')\n    count_1 = s.count('1')\n    \n    # The cleanest string will be all 0s followed by all 1s\n    return '0' * count_0 + '1' * count_1\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    n = int(input().strip())\n    s = input().strip()\n    results.append(clean_binary_string(s))\n\nprint('\\n'.join(results))\n```"
}