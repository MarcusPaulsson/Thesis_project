{
    "10": "```python\nn = int(input())\n\n# Calculate maximum days off\nmax_days_off = (n // 7) * 2 + min(2, n % 7)\n\n# Calculate minimum days off\nif n < 5:\n    min_days_off = 0\nelse:\n    min_days_off = (n // 7) * 2\n\nprint(min_days_off, max_days_off)\n```",
    "7": "```python\ndef find_empty_day(n, m):\n    day = 0\n    total_grains = n\n    \n    while total_grains > 0:\n        day += 1\n        total_grains += m  # Grains brought to the barn\n        if total_grains > n:\n            total_grains = n  # Barn is full, excess grains are ignored\n        total_grains -= day  # Sparrows eat grains\n        \n    return day\n\n# Read input\nn, m = map(int, input().split())\n# Output the result\nprint(find_empty_day(n, m))\n```",
    "2": "```python\nn = int(input())\n\ndef next_lucky_year(year):\n    while True:\n        year += 1\n        if str(year).count('0') + len(set(str(year))) - 1 <= 1:\n            return year\n\nnext_year = next_lucky_year(n)\nprint(next_year - n)\n```",
    "0": "```python\ndef max_acc_length(s):\n    n = len(s)\n    left_bracket = -1\n    right_bracket = -1\n    colon_count = 0\n    pipe_count = 0\n\n    # Find the first opening bracket\n    for i in range(n):\n        if s[i] == '[':\n            left_bracket = i\n            break\n\n    # Find the last closing bracket\n    for i in range(n - 1, -1, -1):\n        if s[i] == ']':\n            right_bracket = i\n            break\n\n    # If we don't have both brackets\n    if left_bracket == -1 or right_bracket == -1 or left_bracket >= right_bracket:\n        return -1\n\n    # Count colons and pipes between the brackets\n    for i in range(left_bracket, right_bracket + 1):\n        if s[i] == ':':\n            colon_count += 1\n        elif s[i] == '|':\n            pipe_count += 1\n\n    # We need at least two colons to form an accordion\n    if colon_count < 2:\n        return -1\n\n    # The maximum length of the accordion\n    return 2 + pipe_count  # 2 for the colons, plus the number of pipes\n\n# Read input\ns = input().strip()\n# Output the result\nprint(max_acc_length(s))\n```",
    "1": "```python\ndef max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n    \n    # Start with the maximum number which is x itself\n    max_sum = sum(int(d) for d in str_x)\n    best_number = x\n    \n    # Check numbers by reducing digits\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit and setting all following digits to 9\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        new_number = int(new_number)\n        \n        if new_number <= x:\n            current_sum = sum(int(d) for d in str(new_number))\n            if current_sum > max_sum or (current_sum == max_sum and new_number > best_number):\n                max_sum = current_sum\n                best_number = new_number\n    \n    return best_number\n\nx = int(input())\nprint(max_digit_sum(x))\n```",
    "5": "```python\nn, pos, l, r = map(int, input().split())\n\n# If no tabs need to be closed\nif l == 1 and r == n:\n    print(0)\nelse:\n    seconds = 0\n\n    # Close tabs to the left of l\n    if l > 1:\n        if pos > l:\n            seconds += (pos - l) + 1  # Move to l and close\n        else:\n            seconds += (l - pos) + 1  # Move to l and close\n    else:\n        if pos > 1:\n            seconds += (pos - 1) + 1  # Move to 1 and close\n\n    # Close tabs to the right of r\n    if r < n:\n        if pos < r:\n            seconds += (r - pos) + 1  # Move to r and close\n        else:\n            seconds += (pos - r) + 1  # Move to r and close\n    else:\n        if pos < n:\n            seconds += (n - pos) + 1  # Move to n and close\n\n    print(seconds)\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    count_a = n // a\n    count_b = n // b\n    count_ab = n // (a * b)  # Count of tiles that are divisible by both a and b\n\n    # Calculate chocolates if we paint common tiles Red or Blue\n    chocolates_if_red = count_a * p + (count_b - count_ab) * q\n    chocolates_if_blue = count_b * q + (count_a - count_ab) * p\n\n    return max(chocolates_if_red, chocolates_if_blue)\n\n# Input\nn, a, b, p, q = map(int, input().split())\nprint(max_chocolates(n, a, b, p, q))\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelif t <= n + k:\n    print(n + k - t)\n\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    max_length = 0\n    current_length = 0\n    segments = []\n\n    # Count segments of golden trophies\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n                max_length = max(max_length, current_length)\n            current_length = 0\n    if current_length > 0:\n        segments.append(current_length)\n        max_length = max(max_length, current_length)\n\n    # If there are no golden trophies\n    if max_length == 0:\n        return 0\n\n    # Calculate the maximum possible length after one swap\n    if len(segments) == 1:\n        return max_length  # Only one segment of golden trophies\n\n    # Check possible merges by swapping a silver trophy\n    max_possible = max_length\n    for i in range(1, len(segments)):\n        # Check if we can merge two segments by swapping a silver trophy\n        max_possible = max(max_possible, segments[i - 1] + segments[i])\n\n    return max_possible\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\n\n# Output the result\nprint(max_beauty_after_swap(n, trophies))\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "16": "```python\ncnt1 = int(input())\ncnt2 = int(input())\ncnt3 = int(input())\ncnt4 = int(input())\n\n# Check if it's possible to form a regular bracket sequence\nif cnt1 + cnt2 < cnt3 + cnt4:\n    print(0)\nelif cnt1 > cnt4:\n    print(1)\nelif cnt1 == cnt4:\n    print(1 if cnt2 % 2 == 0 else 0)\nelse:\n    print(0)\n```",
    "8": "```python\ndef min_tiles_to_draw(tiles):\n    suits = {'m': [], 'p': [], 's': []}\n    \n    # Parse the tiles into suits\n    for tile in tiles:\n        number = int(tile[0])\n        suit = tile[1]\n        suits[suit].append(number)\n    \n    # Check for koutsu (triplet)\n    for suit in suits.values():\n        if len(suit) == 3 and suit[0] == suit[1] == suit[2]:\n            return 0  # Already has a koutsu\n    \n    # Check for shuntsu (sequence)\n    for suit in suits.values():\n        if len(suit) >= 3:\n            suit = sorted(suit)\n            for i in range(len(suit) - 2):\n                if suit[i] + 1 == suit[i + 1] and suit[i + 1] + 1 == suit[i + 2]:\n                    return 0  # Already has a shuntsu\n    \n    # Check for possible shuntsu with one draw\n    for suit in suits.values():\n        if len(suit) == 2:\n            # Check if we can form a shuntsu by drawing one tile\n            min_tile = min(suit)\n            max_tile = max(suit)\n            if (min_tile + 1 == max_tile) or (max_tile - 1 == min_tile):\n                return 1  # Can form a shuntsu with one draw\n            if (min_tile + 2 == max_tile):\n                return 1  # Can form a shuntsu with one draw\n            if (min_tile + 1 not in suit) or (max_tile - 1 not in suit):\n                return 1  # Can draw to complete a shuntsu\n    \n    # Check for possible shuntsu with two draws\n    for suit in suits.values():\n        if len(suit) == 1:\n            # Need two draws to form a shuntsu\n            number = suit[0]\n            if number > 1 and number < 9:\n                return 2  # Can draw two tiles to form a shuntsu\n            elif number == 1:\n                return 2  # Need to draw 2 and 3\n            elif number == 9:\n                return 2  # Need to draw 7 and 8\n    \n    return 2  # If all else fails, need two draws\n\n# Input reading\ntiles = input().strip().split()\nprint(min_tiles_to_draw(tiles))\n```",
    "18": "```python\ndef minimal_lexicographic_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        while t and (not u or t[-1] <= u[-1]):\n            u.append(t.pop())\n    \n    return ''.join(u)\n\n# Input\ns = input().strip()\n# Output\nprint(minimal_lexicographic_string(s))\n```",
    "9": "```python\nd = int(input())\nn, m = map(int, input().split())\n\nsofas = []\nfor i in range(d):\n    x1, y1, x2, y2 = map(int, input().split())\n    sofas.append((x1, y1, x2, y2))\n\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\ndef count_relations(sofa):\n    x1, y1, x2, y2 = sofa\n    left = right = top = bottom = 0\n    \n    for other in sofas:\n        if other == sofa:\n            continue\n        ox1, oy1, ox2, oy2 = other\n        if x1 == x2:  # vertical sofa\n            if y2 < oy1:  # other is above\n                top += 1\n            elif y1 > oy2:  # other is below\n                bottom += 1\n        else:  # horizontal sofa\n            if x2 < ox1:  # other is to the left\n                left += 1\n            elif x1 > ox2:  # other is to the right\n                right += 1\n    \n    return left, right, top, bottom\n\nfor i in range(d):\n    left, right, top, bottom = count_relations(sofas[i])\n    if left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b:\n        print(i + 1)\n        break\nelse:\n    print(-1)\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    # Create a list to track the coverage of each section\n    coverage = [0] * (n + 1)\n\n    # Count the coverage for each painter\n    for l, r in painters:\n        for i in range(l, r + 1):\n            coverage[i] += 1\n\n    # Calculate the total painted sections with all painters\n    total_painted = sum(1 for i in range(1, n + 1) if coverage[i] > 0)\n\n    # If we hire q - 2 painters, we need to find the two painters that cover the most sections\n    # and remove their coverage from the total painted sections\n    max_painted = total_painted\n\n    for i in range(q):\n        # Temporarily remove the coverage of the i-th painter\n        l_i, r_i = painters[i]\n        for j in range(l_i, r_i + 1):\n            coverage[j] -= 1\n\n        # Calculate the new number of painted sections\n        painted_after_removal = sum(1 for k in range(1, n + 1) if coverage[k] > 0)\n        max_painted = max(max_painted, painted_after_removal)\n\n        # Restore the coverage of the i-th painter\n        for j in range(l_i, r_i + 1):\n            coverage[j] += 1\n\n    return max_painted\n\n# Read input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Get the result and print it\nresult = max_painted_sections(n, q, painters)\nprint(result)\n```",
    "6": "```python\ndef min_blows_to_defeat(t, queries):\n    results = []\n    for query in queries:\n        n, x, blows = query\n        min_blows = float('inf')\n        \n        # Find the best blow that reduces heads the most and grows the least\n        best_d = 0\n        best_h = float('inf')\n        \n        for d, h in blows:\n            if d > best_d or (d == best_d and h < best_h):\n                best_d = d\n                best_h = h\n        \n        # If the best blow can defeat Gorynich in one hit\n        if best_d >= x:\n            results.append(1)\n            continue\n        \n        # If the best blow does not reduce heads enough\n        if best_d <= best_h:\n            results.append(-1)\n            continue\n        \n        # Calculate the number of blows needed\n        # Effective reduction per blow\n        effective_reduction = best_d - best_h\n        \n        # Calculate the number of blows needed to reduce heads to zero\n        blows_needed = (x - best_d + effective_reduction - 1) // effective_reduction + 1\n        \n        results.append(blows_needed)\n    \n    return results\n\n# Input reading\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\n# Get results\nresults = min_blows_to_defeat(t, queries)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "14": "```python\ndef is_stack_sortable(n, k, p):\n    # Create a set of used elements\n    used = set(p)\n    # Create a list for the remaining elements\n    remaining = [i for i in range(1, n + 1) if i not in used]\n    \n    # Initialize the result with the first k elements\n    result = p[:]\n    \n    # Initialize a stack\n    stack = []\n    \n    # Iterate through the first k elements\n    for i in range(k):\n        # While the stack is not empty and the top of the stack is greater than the next element in remaining\n        while stack and (not remaining or stack[-1] > remaining[-1]):\n            result.append(stack.pop())\n        # Push the current element onto the stack\n        stack.append(p[i])\n    \n    # Now we need to add the remaining elements in a way that keeps the stack sortable\n    for num in sorted(remaining, reverse=True):\n        while stack and stack[-1] < num:\n            result.append(stack.pop())\n        stack.append(num)\n    \n    # Add any remaining elements in the stack to the result\n    while stack:\n        result.append(stack.pop())\n    \n    # Check if the result is a valid permutation\n    if len(result) != n or sorted(result) != list(range(1, n + 1)):\n        return -1\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result\nresult = is_stack_sortable(n, k, p)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return minutes_passed\n\ncurrent_time = input().strip()\nhh, mm = map(int, current_time.split(':'))\nresult = next_palindrome_time(hh, mm)\nprint(result)\n```",
    "19": "```python\ndef check_records(test_cases):\n    results = []\n    for case in test_cases:\n        n = case[0]\n        records = case[1]\n        valid = True\n        \n        for i in range(n):\n            p_i, c_i = records[i]\n            if i > 0:\n                p_prev, c_prev = records[i - 1]\n                if p_i < p_prev or c_i < c_prev or c_i > p_i:\n                    valid = False\n                    break\n                if (p_i - p_prev) < (c_i - c_prev):\n                    valid = False\n                    break\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Input reading\nT = int(input())\ntest_cases = []\nfor _ in range(T):\n    n = int(input())\n    records = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, records))\n\n# Check records and print results\nresults = check_records(test_cases)\nfor result in results:\n    print(result)\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror_chars = {'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M', 'O': 'O', 'o': 'o', 'p': 'q', 'q': 'p', 'R': 'R', 'S': 'S', 'T': 'T', 'U': 'U', 'v': 'v', 'V': 'V', 'W': 'W', 'x': 'x', 'Y': 'Y'}\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        if s[i] not in mirror_chars or s[n - 1 - i] not in mirror_chars:\n            return \"NIE\"\n        if mirror_chars[s[i]] != s[n - 1 - i]:\n            return \"NIE\"\n    \n    return \"TAK\"\n\ns = input().strip()\nprint(is_s_palindrome(s))\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef main():\n    n, k = map(int, input().split())\n    main_courses = list(map(int, input().split()))\n    \n    dependencies = defaultdict(list)\n    indegree = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        line = list(map(int, input().split()))\n        t_i = line[0]\n        for dep in line[1:t_i + 1]:\n            dependencies[dep].append(i)\n            indegree[i] += 1\n    \n    # Queue for courses that can be taken (no dependencies)\n    queue = deque()\n    for i in range(1, n + 1):\n        if indegree[i] == 0:\n            queue.append(i)\n    \n    order = []\n    taken_courses = set()\n    \n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        taken_courses.add(course)\n        \n        for next_course in dependencies[course]:\n            indegree[next_course] -= 1\n            if indegree[next_course] == 0:\n                queue.append(next_course)\n    \n    # Check if all main courses can be taken\n    if not all(course in taken_courses for course in main_courses):\n        print(-1)\n        return\n    \n    # Collect all courses needed to take\n    result = []\n    for course in main_courses:\n        result.append(course)\n        for dep in dependencies[course]:\n            if dep not in result:\n                result.append(dep)\n    \n    # Remove duplicates and sort by order of appearance\n    result = list(dict.fromkeys(result))\n    \n    print(len(result))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    if k > n * (n + 1) // 2:\n        return -1\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k <= 0:\n            break\n        # Place 1 on the diagonal\n        if k > 0:\n            matrix[i][i] = 1\n            k -= 1\n        \n        for j in range(i + 1, n):\n            if k >= 2:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n            if k <= 0:\n                break\n    \n    if k > 0:\n        return -1\n    \n    return matrix\n\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "27": "```python\nn = int(input())\ns = input()\n\nmin_operations = n  # Start with the maximum operations (typing all characters)\n\n# Check for all possible prefixes to copy\nfor i in range(1, n):\n    if s[:i] == s[i:i+i]:  # Check if the prefix can be copied\n        # Operations: type prefix + copy + remaining characters\n        operations = i + 1 + (n - (i * 2))\n        min_operations = min(min_operations, operations)\n\nprint(min_operations)\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a, b):\n    from itertools import permutations\n\n    # Convert a to string and get its digits\n    str_a = str(a)\n    digits = sorted(str_a, reverse=True)  # Sort digits in descending order\n\n    # Generate all unique permutations of the digits\n    unique_permutations = set(permutations(digits))\n\n    # Filter permutations to find the maximum valid number not exceeding b\n    max_number = -1\n    for perm in unique_permutations:\n        num = int(''.join(perm))\n        if num <= b and str(num)[0] != '0':  # Check if it does not start with zero\n            max_number = max(max_number, num)\n\n    return max_number\n\n# Input\na = int(input().strip())\nb = int(input().strip())\n\n# Output\nprint(max_permutation_not_exceeding(a, b))\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = []\nregulars = []\n\nfor name, typ in files:\n    if typ == '1':\n        examples.append(name)\n    else:\n        regulars.append(name)\n\nmoves = []\ne = len(examples)\n\n# Rename examples to 1, 2, ..., e\nfor i in range(e):\n    moves.append(f\"move {examples[i]} {i + 1}\")\n\n# Rename regular tests to e + 1, e + 2, ..., n\nfor i in range(len(regulars)):\n    moves.append(f\"move {regulars[i]} {e + i + 1}\")\n\nprint(len(moves))\nfor move in moves:\n    print(move)\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # Since GCD(x, m) = 1, the x-mouse will visit all rooms in a cycle of length m\n    # The number of traps needed is equal to m - 1 (all rooms except room 0)\n    return m\n\nm, x = map(int, input().split())\nprint(minimum_traps(m, x))\n```",
    "32": "```python\ndef check_journey(n, journey):\n    position = 0  # Position on the meridian, starting at the North Pole (0 km)\n    \n    for t, direction in journey:\n        if position == 0 and direction != \"South\":\n            return \"NO\"  # At North Pole, can only move South\n        if position == 20000 and direction != \"North\":\n            return \"NO\"  # At South Pole, can only move North\n        \n        if direction == \"North\":\n            position -= t\n        elif direction == \"South\":\n            position += t\n        elif direction == \"East\" or direction == \"West\":\n            # East and West do not change the position on the meridian\n            continue\n        \n        # Check if position goes out of bounds\n        if position < 0 or position > 20000:\n            return \"NO\"\n    \n    # Final position must be back at the North Pole\n    if position != 0:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn = int(input())\njourney = [tuple(input().split()) for _ in range(n)]\njourney = [(int(t), dir) for t, dir in journey]\n\n# Output result\nprint(check_journey(n, journey))\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    # Calculate the difference\n    diff = abs(sum_first - sum_second)\n    \n    # Create a list of possible changes\n    changes = []\n    \n    if sum_first > sum_second:\n        # We need to decrease the first half or increase the second half\n        changes += [9 - digit for digit in first_half]  # Maximize decrease from first half\n        changes += [digit for digit in second_half]     # Maximize increase from second half\n    else:\n        # We need to decrease the second half or increase the first half\n        changes += [9 - digit for digit in second_half]  # Maximize decrease from second half\n        changes += [digit for digit in first_half]       # Maximize increase from first half\n    \n    # Sort changes in descending order\n    changes.sort(reverse=True)\n    \n    # Calculate the minimum number of replacements\n    count = 0\n    for change in changes:\n        diff -= change\n        count += 1\n        if diff <= 0:\n            break\n    \n    return count\n\n# Input\nticket = input().strip()\n# Output\nprint(min_replacements_to_lucky(ticket))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    \n    # If the entire string is not a palindrome, return its length\n    if not is_palindrome(s):\n        return n\n    \n    # Check for the longest non-palindrome substring by removing one character\n    for i in range(n):\n        if not is_palindrome(s[:i] + s[i+1:]):\n            return n - 1\n    \n    # If all characters are the same, return 0\n    return 0\n\n# Input\ns = input().strip()\n# Output\nprint(longest_non_palindrome_substring(s))\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    def can_distribute(x):\n        plates_for_a = min(a // x, n)\n        plates_for_b = min(b // x, n)\n        return plates_for_a + plates_for_b >= n\n\n    left, right = 1, max(a, b)\n    answer = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_distribute(mid):\n            answer = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return answer\n\n# Input reading\nn, a, b = map(int, input().split())\nprint(max_min_pieces(n, a, b))\n```",
    "35": "```python\ndef is_valid_flag(n, m, field):\n    # Check if the number of rows is divisible by 3\n    if n % 3 != 0:\n        return \"NO\"\n    \n    stripe_height = n // 3\n    colors = set()\n    \n    # Check horizontal stripes\n    for i in range(3):\n        stripe = field[i * stripe_height:(i + 1) * stripe_height]\n        first_row = stripe[0]\n        \n        # Check if all rows in the stripe are the same\n        if any(row != first_row for row in stripe):\n            return \"NO\"\n        \n        # Check if all characters in the stripe are the same\n        if len(set(first_row)) != 1:\n            return \"NO\"\n        \n        colors.add(first_row[0])\n    \n    # Check if we have exactly 3 different colors\n    if len(colors) != 3:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(is_valid_flag(n, m, field))\n```",
    "36": "```python\ndef hexagonal_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 6 * layer\n\n    while n > moves_in_layer:\n        n -= moves_in_layer\n        layer += 1\n        moves_in_layer = 6 * layer\n\n    x, y = layer, 0\n\n    if n == 0:\n        return (x, y)\n\n    # Determine the position in the current layer\n    direction = n // layer\n    steps = n % layer\n\n    if direction == 0:  # Right\n        x += steps\n    elif direction == 1:  # Top-right\n        x += steps\n        y += steps\n    elif direction == 2:  # Top-left\n        y += steps\n    elif direction == 3:  # Left\n        x -= steps\n        y += steps\n    elif direction == 4:  # Bottom-left\n        x -= steps\n        y -= steps\n    elif direction == 5:  # Bottom-right\n        y -= steps\n\n    return (x, y)\n\nn = int(input().strip())\nx, y = hexagonal_coordinates(n)\nprint(x, y)\n```",
    "24": "```python\ndef can_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # vertical, horizontal, diagonal, anti-diagonal\n    n = 10\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                # Temporarily place 'X' in the empty cell\n                board[i][j] = 'X'\n                \n                for dx, dy in directions:\n                    count = 1\n                    \n                    # Check in the positive direction\n                    x, y = i + dx, j + dy\n                    while 0 <= x < n and 0 <= y < n and board[x][y] == 'X':\n                        count += 1\n                        x += dx\n                        y += dy\n                    \n                    # Check in the negative direction\n                    x, y = i - dx, j - dy\n                    while 0 <= x < n and 0 <= y < n and board[x][y] == 'X':\n                        count += 1\n                        x -= dx\n                        y -= dy\n                    \n                    if count >= 5:\n                        return \"YES\"\n                \n                # Remove the temporary 'X'\n                board[i][j] = '.'\n\n    return \"NO\"\n\n# Read the input\nboard = [input().strip() for _ in range(10)]\nprint(can_win(board))\n```",
    "38": "```python\ndef can_be_same_track(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between consecutive barriers for Kefa and Sasha\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Check if Kefa's differences can match Sasha's differences by rotation\n    for start in range(n):\n        if all(kefa_diffs[i] == sasha_diffs[(i + start) % n] for i in range(n)):\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_be_same_track(n, L, kefa_distances, sasha_distances))\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if any rating has changed\nrated = any(a != b for a, b in ratings)\n\nif rated:\n    print(\"rated\")\nelse:\n    # Check if the standings are in non-increasing order of ratings\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            print(\"unrated\")\n            break\n    else:\n        print(\"maybe\")\n```",
    "31": "```python\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef mod_inv(a, m):\n    m0, x0, x1 = m, 0, 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef birthday_paradox(n, k):\n    MOD = 1000003\n    days = 1 << n  # 2^n\n    if k > days:\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the probability of no collision\n    prob_no_collision_numer = 1\n    prob_no_collision_denom = 1\n    for i in range(k):\n        prob_no_collision_numer *= (days - i)\n        prob_no_collision_denom *= days\n        prob_no_collision_numer %= MOD\n        prob_no_collision_denom %= MOD\n\n    # Probability of at least one collision\n    A = (prob_no_collision_denom - prob_no_collision_numer) % MOD\n    B = prob_no_collision_denom\n\n    # Reduce A/B to irreducible form\n    common_divisor = gcd(A, B)\n    A //= common_divisor\n    B //= common_divisor\n\n    return A % MOD, B % MOD\n\n# Input reading\nn, k = map(int, input().split())\nresult = birthday_paradox(n, k)\nprint(result[0], result[1])\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n    \n    m = len(s)\n    total_count = 0\n    seen = set()\n    \n    # Generate all binary strings of length n\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        # Check if s is a substring in any cyclic shift of t\n        if any(s in t[i:] + t[:i] for i in range(n)):\n            # Add to seen to avoid duplicates\n            seen.add(t)\n    \n    return len(seen)\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_cyclic_strings(n, s))\n```",
    "51": "```python\nfrom collections import Counter\nimport sys\nimport math\n\ndef find_x_y(divisors):\n    count = Counter(divisors)\n    x, y = 1, 1\n    \n    for d in count:\n        if count[d] == 2:\n            x *= d\n            y *= d\n        elif count[d] == 1:\n            if x == 1:\n                x *= d\n            else:\n                y *= d\n\n    return x, y\n\nn = int(input().strip())\ndivisors = list(map(int, input().strip().split()))\n\nx, y = find_x_y(divisors)\nprint(x, y)\n```",
    "41": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the distance array with a large number\ndistances = [float('inf')] * n\n\n# First pass: from left to right\nfor i in range(n):\n    if a[i] == 0:\n        distances[i] = 0\n    elif i > 0:\n        distances[i] = distances[i - 1] + 1\n\n# Second pass: from right to left\nfor i in range(n - 1, -1, -1):\n    if a[i] == 0:\n        distances[i] = 0\n    elif i < n - 1:\n        distances[i] = min(distances[i], distances[i + 1] + 1)\n\nprint(' '.join(map(str, distances)))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n\n    # Determine the range where the k-th digit lies\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    # Find the actual number containing the k-th digit\n    start += (k - 1) // length\n    num_str = str(start)\n    \n    # Find the digit\n    return num_str[(k - 1) % length]\n\nk = int(input())\nprint(find_kth_digit(k))\n```",
    "44": "```python\ndef minimal_time(d, k, a, b, t):\n    # Calculate the time if Vasiliy walks the entire distance\n    walk_time = d * b\n    \n    # Initialize the minimum time with the walking time\n    min_time = walk_time\n    \n    # Calculate the number of full segments Vasiliy can drive\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Calculate the time for driving full segments and walking the remaining distance\n    drive_time = full_segments * k * a\n    repair_time = full_segments * t\n    total_time = drive_time + repair_time + remaining_distance * b\n    \n    # Update the minimum time if this option is better\n    min_time = min(min_time, total_time)\n    \n    # Check if he can drive less than full segments and walk the rest\n    for i in range(full_segments + 1):\n        drive_time = i * k * a\n        repair_time = i * t\n        remaining_distance = d - i * k\n        \n        if remaining_distance >= 0:\n            total_time = drive_time + repair_time + remaining_distance * b\n            min_time = min(min_time, total_time)\n    \n    return min_time\n\n# Input reading\nd, k, a, b, t = map(int, input().split())\nprint(minimal_time(d, k, a, b, t))\n```",
    "33": "```python\ndef count_common_terms(a1, b1, a2, b2, L, R):\n    from math import gcd\n\n    # Calculate the difference and the initial offset\n    d1 = a1\n    d2 = a2\n    b_diff = b2 - b1\n\n    # Calculate the gcd of the two differences\n    g = gcd(d1, d2)\n\n    # Check if the difference is divisible by gcd\n    if b_diff % g != 0:\n        return 0\n\n    # Find the first solution to the equation a1 * k' + b1 = a2 * l' + b2\n    # We can use the extended Euclidean algorithm to find one solution\n    def extended_gcd(a, b):\n        if b == 0:\n            return a, 1, 0\n        g, x1, y1 = extended_gcd(b, a % b)\n        x = y1\n        y = x1 - (a // b) * y1\n        return g, x, y\n\n    _, x0, y0 = extended_gcd(d1, d2)\n    x0 *= b_diff // g\n    y0 *= b_diff // g\n\n    # Now we have one solution (x0, y0)\n    # General solution is:\n    # x = x0 + (d2/g) * t\n    # y = y0 - (d1/g) * t for integer t\n\n    # We need to find the range of t such that L <= x <= R\n    t_min = (L - (x0 + (d2 // g) * 0)) // (d2 // g)\n    t_max = (R - (x0 + (d2 // g) * 0)) // (d2 // g)\n\n    if (x0 + (d2 // g) * t_min) < L:\n        t_min += 1\n    if (x0 + (d2 // g) * t_max) > R:\n        t_max -= 1\n\n    return max(0, t_max - t_min + 1)\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n# Get the result\nresult = count_common_terms(a1, b1, a2, b2, L, R)\n# Print the result\nprint(result)\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Minimum sum of first k positive integers\n    min_sum = k * (k + 1) // 2\n    \n    if n < min_sum:\n        return -1\n    \n    # The maximum GCD we can use\n    max_gcd = (n - min_sum) // k + 1\n    \n    # Create the sequence\n    sequence = [(i + max_gcd) for i in range(1, k + 1)]\n    \n    return sequence\n\n# Read input\nn, k = map(int, input().split())\n\n# Get the result\nresult = find_sequence(n, k)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "46": "```python\ndef count_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n    \n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n    \n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n    \n    result = 0\n    for i in range(5):\n        result += count_x[i] * count_y[(5 - i) % 5]\n    \n    return result\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))\n```",
    "54": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_a = min(a)\nmax_a = max(a)\n\nif min_a == max_a:\n    print(0)\nelse:\n    D = (max_a - min_a) // 2\n    if (max_a - min_a) % 2 == 0:\n        print(D)\n    else:\n        print(-1)\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef reachable_count(n):\n    reachable = set()\n    current = n\n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    return len(reachable)\n\nn = int(input())\nprint(reachable_count(n))\n```",
    "59": "```python\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# Calculate the target pattern\ntarget = ['0'] * x\ntarget[y] = '1'\ntarget = ''.join(target)\n\n# Get the last x digits of the number\ncurrent = number[-x:]\n\n# Count the number of changes needed\noperations = sum(1 for i in range(x) if current[i] != target[i])\n\nprint(operations)\n```",
    "57": "```python\ndef fill_gifts(n, f):\n    # Find the friends who want to give gifts (f_i != 0)\n    givers = set(i + 1 for i in range(n) if f[i] != 0)\n    # Find the friends who are not receiving gifts (f_i == 0)\n    receivers = set(range(1, n + 1)) - givers\n\n    # Fill in the unknown values\n    for i in range(n):\n        if f[i] == 0:\n            # Find a receiver that is not the current friend (i + 1)\n            for r in receivers:\n                if r != i + 1:\n                    f[i] = r\n                    receivers.remove(r)\n                    break\n\n    return f\n\n# Input reading\nn = int(input())\nf = list(map(int, input().split()))\n\n# Fill the gifts and print the result\nresult = fill_gifts(n, f)\nprint(' '.join(map(str, result)))\n```",
    "47": "```python\ndef max_beauty(n, x, a):\n    # Function to calculate maximum subarray sum using Kadane's algorithm\n    def kadane(arr):\n        max_ending_here = max_so_far = 0\n        for value in arr:\n            max_ending_here = max(0, max_ending_here + value)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    # Calculate the original beauty of the array\n    original_beauty = kadane(a)\n\n    # If x is 1 or 0, multiplying won't help, return original beauty\n    if x == 1 or x == 0:\n        return original_beauty\n\n    # Calculate the maximum beauty after multiplying a subarray by x\n    max_increase = 0\n    current_sum = 0\n    for i in range(n):\n        current_sum += a[i]\n        max_increase = max(max_increase, current_sum * x)\n        if current_sum < 0:\n            current_sum = 0\n\n    # Calculate the maximum beauty after applying the operation\n    max_beauty_after_operation = original_beauty + max_increase\n\n    return max(max_beauty_after_operation, original_beauty)\n\n# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result and print it\nresult = max_beauty(n, x, a)\nprint(result)\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_choose = m // 2\n    dp = [[-1] * k for _ in range(max_choose + 1)]\n    dp[0][0] = 0\n\n    for row in matrix:\n        row.sort(reverse=True)\n        current_dp = [dp[i][:] for i in range(max_choose + 1)]\n        \n        for count in range(max_choose + 1):\n            for j in range(min(count, len(row)) + 1):\n                if j > 0:\n                    new_sum = sum(row[:j])\n                    for mod in range(k):\n                        if current_dp[count - j][mod] != -1:\n                            new_mod = (mod + new_sum) % k\n                            new_value = current_dp[count - j][mod] + new_sum\n                            current_dp[count][new_mod] = max(current_dp[count][new_mod], new_value)\n        \n        dp = current_dp\n\n    return max(dp[i][0] for i in range(max_choose + 1))\n\n# Input reading\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_sum_divisible_by_k(n, m, k, matrix))\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = -1\n    sequence = []\n    moves = []\n\n    while left <= right:\n        if a[left] < a[right]:\n            if a[left] > last_taken:\n                sequence.append(a[left])\n                moves.append('L')\n                last_taken = a[left]\n                left += 1\n            elif a[right] > last_taken:\n                sequence.append(a[right])\n                moves.append('R')\n                last_taken = a[right]\n                right -= 1\n            else:\n                break\n        else:\n            if a[right] > last_taken:\n                sequence.append(a[right])\n                moves.append('R')\n                last_taken = a[right]\n                right -= 1\n            elif a[left] > last_taken:\n                sequence.append(a[left])\n                moves.append('L')\n                last_taken = a[left]\n                left += 1\n            else:\n                break\n\n    print(len(sequence))\n    print(''.join(moves))\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\nlongest_increasing_sequence(n, a)\n```",
    "60": "```python\ndef has_palindrome_subsequence(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        found = False\n        # Use a dictionary to track the first occurrence of each number\n        first_occurrence = {}\n        for i in range(n):\n            if a[i] in first_occurrence:\n                # If we find the same number again, we can form a palindrome\n                if i - first_occurrence[a[i]] >= 2:\n                    found = True\n                    break\n            else:\n                first_occurrence[a[i]] = i\n        results.append(\"YES\" if found else \"NO\")\n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Get results\nresults = has_palindrome_subsequence(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "58": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nfrom collections import defaultdict\n\ncoloring = [0] * n\ncolor_count = defaultdict(int)\nused_colors = defaultdict(set)\n\nfor i in range(n):\n    num = a[i]\n    if color_count[num] < k:\n        color_count[num] += 1\n        coloring[i] = color_count[num]\n        used_colors[num].add(color_count[num])\n\nif len(used_colors) < k:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for i in range(n):\n        if coloring[i] == 0:\n            for color in range(1, k + 1):\n                if color not in used_colors[a[i]]:\n                    coloring[i] = color\n                    used_colors[a[i]].add(color)\n                    break\n    print(\" \".join(map(str, coloring)))\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph):\n    visited = [-1] * (n + 1)\n    queue = deque([start])\n    visited[start] = 0\n    farthest_node = start\n\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if visited[neighbor] == -1:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > visited[farthest_node]:\n                    farthest_node = neighbor\n\n    return farthest_node, visited\n\ndef find_max_edges(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Step 1: Find the farthest node from an arbitrary node (1)\n    farthest_node, _ = bfs(1, graph)\n\n    # Step 2: Find the farthest node from the previously found farthest node\n    other_end, distances = bfs(farthest_node, graph)\n\n    # Step 3: Find the farthest node from the other end to get the diameter\n    diameter_length = distances[other_end]\n    \n    # Step 4: Find the path from farthest_node to other_end\n    path = []\n    current = other_end\n    while current != farthest_node:\n        path.append(current)\n        for neighbor in graph[current]:\n            if distances[neighbor] == distances[current] - 1:\n                current = neighbor\n                break\n    path.append(farthest_node)\n    path.reverse()\n\n    # Step 5: Choose three distinct vertices\n    if len(path) >= 3:\n        a, b, c = path[0], path[len(path) // 2], path[-1]\n    else:\n        a, b, c = path[0], path[1], path[2]\n\n    return diameter_length + 1, a, b, c\n\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\nres, a, b, c = find_max_edges(n, edges)\nprint(res)\nprint(a, b, c)\n```",
    "55": "```python\ndef is_visible(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n    # Check if there is any part of the white sheet that is not covered by both black sheets\n    # Check the four corners of the white sheet\n    corners = [\n        (x1, y1),  # bottom left\n        (x1, y2),  # top left\n        (x2, y1),  # bottom right\n        (x2, y2)   # top right\n    ]\n    \n    for x, y in corners:\n        # Check if the point (x, y) is outside the white sheet and not inside both black sheets\n        if (x < x1 or x > x2 or y < y1 or y > y2) and not (\n            (x3 < x < x4 and y3 < y < y4) or (x5 < x < x6 and y5 < y < y6)\n        ):\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Output the result\nprint(is_visible(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6))\n```",
    "63": "```python\ndef min_instability(n, a):\n    a.sort()\n    # Remove the smallest or the largest element\n    instability_remove_min = a[-1] - a[1]  # Remove the smallest element\n    instability_remove_max = a[-2] - a[0]  # Remove the largest element\n    return min(instability_remove_min, instability_remove_max)\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_instability(n, a))\n```",
    "67": "```python\nn = int(input())\na = list(map(int, input().split()))\n\ntotal_sum = sum(a)\nnice_indices = []\n\nfor i in range(n):\n    if (total_sum - a[i]) % 2 == 0:\n        target = (total_sum - a[i]) // 2\n        if target in a and (target != a[i] or a.count(target) > 1):\n            nice_indices.append(i + 1)\n\nprint(len(nice_indices))\nif nice_indices:\n    print(' '.join(map(str, nice_indices)))\n```",
    "71": "```python\ndef count_set_bits(n):\n    return bin(n).count('1')\n\na = int(input())\nprint(count_set_bits(a))\n```",
    "70": "```python\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Convert start and end times to minutes\nstart_minutes = h1 * 60 + m1\nend_minutes = h2 * 60 + m2\n\n# Calculate the midpoint in minutes\nmidpoint_minutes = (start_minutes + end_minutes) // 2\n\n# Convert back to hours and minutes\nh3 = midpoint_minutes // 60\nm3 = midpoint_minutes % 60\n\n# Print the result in the required format\nprint(f\"{h3:02}:{m3:02}\")\n```",
    "64": "```python\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Initialize the schedule with zeros (rest days)\nschedule = [0] * n\n\n# Prepare a list to track the preparation days needed for each exam\nprep_days_needed = [0] * m\n\n# Fill the schedule with exam days\nfor i in range(m):\n    s_i, d_i, c_i = exams[i]\n    schedule[d_i - 1] = m + 1  # Mark the exam day (1-indexed to 0-indexed)\n\n    # Count the number of preparation days needed\n    prep_days_needed[i] = c_i\n\n# Try to allocate preparation days\nfor i in range(m):\n    s_i, d_i, c_i = exams[i]\n    days_allocated = 0\n\n    # Allocate preparation days in the range [s_i, d_i - 1]\n    for j in range(s_i - 1, d_i - 1):\n        if days_allocated < c_i and schedule[j] == 0:\n            schedule[j] = i + 1  # Mark preparation for exam i (1-indexed)\n            days_allocated += 1\n\n    # If we couldn't allocate enough preparation days, it's impossible\n    if days_allocated < c_i:\n        print(-1)\n        exit()\n\n# Print the final schedule\nprint(' '.join(map(str, schedule)))\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        min_ops = float('inf')\n        best_triplet = (0, 0, 0)\n\n        for A in range(1, a + 1):\n            for B in range(A, c + 1):\n                if B % A == 0:\n                    C = B * (c // B)\n                    if C < b:\n                        C += B\n                    while C < b:\n                        C += B\n                    while C > c:\n                        C -= B\n                    \n                    ops = abs(A - a) + abs(B - b) + abs(C - c)\n                    if ops < min_ops:\n                        min_ops = ops\n                        best_triplet = (A, B, C)\n\n        results.append((min_ops, best_triplet))\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations(t, test_cases)\n\n# Output results\nfor ops, triplet in results:\n    print(ops)\n    print(*triplet)\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Find the longest prefix which is also a suffix\n    lps = [0] * n\n    j = 0  # length of previous longest prefix suffix\n    i = 1\n\n    while i < n:\n        if t[i] == t[j]:\n            j += 1\n            lps[i] = j\n            i += 1\n        else:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                lps[i] = 0\n                i += 1\n\n    # The length of the overlap\n    overlap_length = lps[-1]\n    \n    # Construct the result string\n    result = t + (t[overlap_length:] * (k - 1))\n    return result\n\n# Input reading\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the result and print it\nresult = construct_string(n, k, t)\nprint(result)\n```",
    "73": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmax_height = max(a)\nmin_height = min(a)\n\n# Check if the wall can be completed\nif all(x == max_height or x == min_height for x in a):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from itertools import combinations\n    \n    unique_subsequences = set()\n    \n    # Generate all possible subsequences\n    for length in range(n + 1):\n        for comb in combinations(range(n), length):\n            subseq = ''.join(s[i] for i in comb)\n            unique_subsequences.add(subseq)\n    \n    # If we can't obtain k unique subsequences\n    if len(unique_subsequences) < k:\n        return -1\n    \n    # Calculate the costs for the unique subsequences\n    costs = []\n    for subseq in unique_subsequences:\n        cost = n - len(subseq)\n        costs.append(cost)\n    \n    # Sort costs and take the minimum k costs\n    costs.sort()\n    return sum(costs[:k])\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "77": "```python\ndef minimum_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nn = int(input())\nprint(minimum_difference(n))\n```",
    "81": "```python\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\n# Sort strings by length\nstrings.sort(key=len)\n\n# Check if the ordering is valid\nfor i in range(1, n):\n    if strings[i-1] not in strings[i]:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")\n    print(\"\\n\".join(strings))\n```",
    "82": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncount = 0\n\n# Solve from the left\nwhile count < n and a[count] <= k:\n    count += 1\n\n# Solve from the right\nwhile count < n and a[n - 1 - (count - 1)] <= k:\n    count += 1\n\n# Adjust for double counting\nif count > n:\n    count = n\n\nprint(count)\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n\n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            # Check for red rectangle\n            for red_width in range(1, int(a**0.5) + 1):\n                if a % red_width == 0:\n                    red_height = a // red_width\n                    if red_width <= width and red_height <= height:\n                        # Check for blue rectangle\n                        for blue_width in range(1, int(b**0.5) + 1):\n                            if b % blue_width == 0:\n                                blue_height = b // blue_width\n                                if blue_width <= width and blue_height <= height:\n                                    perimeter = 2 * (width + height)\n                                    min_perimeter = min(min_perimeter, perimeter)\n\n    return min_perimeter\n\na, b = map(int, input().split())\nprint(minimal_perimeter(a, b))\n```",
    "78": "```python\nMOD = 10**9 + 7\n\ndef count_regular_sequences(n, s):\n    m = len(s)\n    \n    # Precompute the number of valid sequences of length 2k\n    dp = [0] * (n + 1)\n    dp[0] = 1  # Base case: one valid sequence of length 0\n    \n    for k in range(1, n + 1):\n        for j in range(k):\n            dp[k] = (dp[k] + dp[j] * dp[k - 1 - j]) % MOD\n    \n    # Check if s can be a valid substring\n    balance = 0\n    min_balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n    \n    if balance < 0 or balance > n or min_balance < 0:\n        return 0\n    \n    # Calculate the number of valid sequences containing s\n    total_count = 0\n    \n    # Try to place s at every possible position\n    for i in range(n - (m // 2) + 1):\n        left_needed = (m // 2) + i\n        right_needed = n - left_needed\n        \n        if left_needed < 0 or right_needed < 0:\n            continue\n        \n        total_count = (total_count + dp[left_needed] * dp[right_needed]) % MOD\n    \n    return total_count\n\nn = int(input())\ns = input().strip()\nprint(count_regular_sequences(n, s))\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    moves = float('inf')\n\n    # Check for pairs of digits that can form 25 or 00\n    for target in ['00', '25']:\n        last_digit = target[1]\n        second_last_digit = target[0]\n        \n        # Find the last occurrence of the last_digit\n        last_index = -1\n        for i in range(length - 1, -1, -1):\n            if s[i] == last_digit:\n                last_index = i\n                break\n        \n        if last_index == -1:\n            continue\n        \n        # Now find the second_last_digit before the last_index\n        second_last_index = -1\n        for i in range(last_index - 1, -1, -1):\n            if s[i] == second_last_digit:\n                second_last_index = i\n                break\n        \n        if second_last_index == -1:\n            continue\n        \n        # Calculate moves needed to bring second_last_digit to second_last_index\n        # and last_digit to last_index\n        moves_needed = (last_index - second_last_index) + (last_index - 1 - second_last_index)\n        moves = min(moves, moves_needed)\n\n    return moves if moves != float('inf') else -1\n\n# Input reading\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    lefts = [l for l, r in segments]\n    rights = [r for l, r in segments]\n\n    # Precompute the maximum left and minimum right excluding each segment\n    max_left = [0] * n\n    min_right = [0] * n\n\n    max_left[0] = lefts[0]\n    for i in range(1, n):\n        max_left[i] = max(max_left[i - 1], lefts[i])\n\n    min_right[n - 1] = rights[n - 1]\n    for i in range(n - 2, -1, -1):\n        min_right[i] = min(min_right[i + 1], rights[i])\n\n    max_length = 0\n\n    for i in range(n):\n        if i == 0:\n            current_left = max_left[1]\n            current_right = min_right[1]\n        elif i == n - 1:\n            current_left = max_left[n - 2]\n            current_right = min_right[n - 2]\n        else:\n            current_left = max(max_left[i - 1], lefts[i + 1])\n            current_right = min(min_right[i + 1], rights[i - 1])\n\n        if current_right >= current_left:\n            max_length = max(max_length, current_right - current_left)\n\n    return max_length\n\n# Input reading\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_intersection_length(n, segments))\n```",
    "76": "```python\ndef can_construct_symmetric_square(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Check for pairs of tiles that can form the symmetric structure\n        can_form = False\n        for i in range(n):\n            for j in range(n):\n                if tiles[i][1][0] == tiles[j][0][0] and tiles[i][1][1] == tiles[j][0][1]:\n                    can_form = True\n                    break\n            if can_form:\n                break\n        \n        results.append(\"YES\" if can_form else \"NO\")\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        top = tuple(map(int, input().split()))\n        bottom = tuple(map(int, input().split()))\n        tiles.append((top, bottom))\n    test_cases.append((n, m, tiles))\n\n# Get results\nresults = can_construct_symmetric_square(t, test_cases)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "84": "```python\ndef can_color_string(n, s):\n    # Count occurrences of each character\n    from collections import Counter\n    count = Counter(s)\n    \n    # Check if any character appears more than twice\n    for char, cnt in count.items():\n        if cnt > 2:\n            return \"NO\"\n    \n    # Initialize coloring\n    color = ['0'] * n\n    \n    # Assign colors\n    for i in range(n):\n        if s[i] in s[:i]:\n            color[i] = '1'\n    \n    return \"YES\\n\" + ''.join(color)\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(can_color_string(n, s))\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Check if we can satisfy the degree condition for vertex 1\n    if len(graph[1]) < D:\n        return \"NO\"\n\n    # Start building the spanning tree\n    spanning_tree_edges = []\n    visited = [False] * (n + 1)\n    visited[1] = True\n    degree_count = 0\n\n    # Use a queue for BFS\n    queue = deque([1])\n    \n    while queue:\n        current = queue.popleft()\n        \n        # If we are at vertex 1, we can only take D edges\n        if current == 1:\n            for neighbor in graph[current]:\n                if degree_count < D and not visited[neighbor]:\n                    spanning_tree_edges.append((current, neighbor))\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    degree_count += 1\n                if degree_count == D:\n                    break\n        else:\n            for neighbor in graph[current]:\n                if not visited[neighbor]:\n                    spanning_tree_edges.append((current, neighbor))\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n\n    # Check if we have n-1 edges in the spanning tree\n    if len(spanning_tree_edges) != n - 1:\n        return \"NO\"\n\n    result = [\"YES\"]\n    result.extend(f\"{u} {v}\" for u, v in spanning_tree_edges)\n    return \"\\n\".join(result)\n\n# Read input\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the result\nresult = find_spanning_tree(n, m, D, edges)\nprint(result)\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import defaultdict\n    \n    # Count the frequency of each character\n    freq = defaultdict(int)\n    for char in s:\n        freq[char] += 1\n    \n    # Calculate the maximum number of unique subsequences we can generate\n    unique_subsequences = 0\n    total_cost = 0\n    cost_per_length = [0] * (n + 1)\n    \n    # Calculate the cost for each possible length of subsequence\n    for length in range(n + 1):\n        cost_per_length[length] = n - length\n    \n    # Generate subsequences and calculate their costs\n    for char, count in freq.items():\n        # For each character, we can generate subsequences of lengths 1 to count\n        for length in range(1, count + 1):\n            unique_subsequences += 1\n            total_cost += cost_per_length[length]\n            if unique_subsequences >= k:\n                return total_cost\n    \n    # If we reach here, we couldn't generate enough unique subsequences\n    if unique_subsequences < k:\n        return -1\n    \n    return total_cost\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    projects.sort(key=lambda x: (x[0], -x[1]))  # Sort by required rating, then by rating change descending\n    current_rating = r\n    \n    for a, b in projects:\n        if current_rating < a:\n            return \"NO\"\n        current_rating += b\n        if current_rating < 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(can_complete_projects(n, r, projects))\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects by their required rating\n    projects.sort(key=lambda x: (x[0], x[1]))\n\n    count = 0\n    current_rating = r\n\n    # Try to complete projects in the sorted order\n    for a, b in projects:\n        if current_rating >= a:\n            count += 1\n            current_rating += b\n            if current_rating < 0:\n                break\n\n    return count\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_projects(n, r, projects))\n```",
    "90": "```python\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculate the minimum required space to place the platforms\nmin_required_space = sum(c) + (m - 1)\n\n# If the minimum required space is greater than n, it's impossible\nif min_required_space > n:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    a = [0] * n\n    position = 0\n\n    for i in range(m):\n        for j in range(c[i]):\n            a[position] = i + 1\n            position += 1\n        # Move to the next position after the current platform\n        position += 1  # Leave at least one cell gap\n\n    print(\" \".join(map(str, a)))\n```",
    "92": "```python\nx = float(input().strip())\n\n# We need to find two integers a and b such that 1 <= a, b <= 10\n# and a * b is approximately equal to x\n\n# Since x is between 0 and 5, we can iterate over possible values of a and b\nfor a in range(1, 11):\n    for b in range(1, 11):\n        if abs(a * b - x) < 1e-6:  # Check if the product is close to x\n            print(a, b)\n            break\n```",
    "86": "```python\ndef solve_problems(n, k):\n    # Minimum sum of problems to satisfy the conditions\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n    \n    # Start with the minimum required problems\n    a = list(range(1, k + 1))\n    current_sum = min_sum\n    \n    # Distribute the remaining problems\n    remaining = n - current_sum\n    for i in range(k - 1, -1, -1):\n        # Maximum we can add to a[i] without violating the conditions\n        max_add = min(remaining, (2 * a[i]) - a[i])\n        a[i] += max_add\n        remaining -= max_add\n        if remaining <= 0:\n            break\n    \n    if remaining > 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n\n# Example inputs\nsolve_problems(26, 6)\nsolve_problems(8, 3)\nsolve_problems(1, 1)\nsolve_problems(9, 4)\nsolve_problems(7, 2)\n```",
    "97": "```python\nn = int(input())\nchips = list(map(int, input().split()))\n\neven_count = sum(1 for x in chips if x % 2 == 0)\nodd_count = n - even_count\n\n# The minimum coins required is the smaller of the two counts\nprint(min(even_count, odd_count))\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n    \n    # Create a prefix array to find the first occurrence of t in s\n    prefix = [0] * (m + 1)\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            j += 1\n        prefix[j] = i + 1\n    \n    # Create a suffix array to find the last occurrence of t in s\n    suffix = [0] * (m + 1)\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            j -= 1\n        suffix[j + 1] = i\n    \n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m + 1):\n        if prefix[i] <= suffix[i]:\n            max_length = max(max_length, suffix[i] - prefix[i] + 1)\n    \n    return max_length\n\n# Input reading\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(max_removable_length(s, t))\n```",
    "88": "```python\ndef create_palindromic_matrix(n, numbers):\n    from collections import Counter\n    \n    count = Counter(numbers)\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Check if we can form a palindromic matrix\n    odd_count = 0\n    center_value = None\n    \n    for value, freq in count.items():\n        if freq % 2 == 1:\n            odd_count += 1\n            center_value = value\n        if odd_count > 1:\n            return \"NO\"\n    \n    # Fill the matrix\n    half = []\n    for value, freq in count.items():\n        half.extend([value] * (freq // 2))\n    \n    if n % 2 == 1 and center_value is not None:\n        center_row = n // 2\n        center_col = n // 2\n        matrix[center_row][center_col] = center_value\n    \n    # Fill the top half and bottom half\n    index = 0\n    for i in range((n + 1) // 2):\n        for j in range(n // 2):\n            if index < len(half):\n                matrix[i][j] = half[index]\n                matrix[i][n - j - 1] = half[index]\n                matrix[n - i - 1][j] = half[index]\n                matrix[n - i - 1][n - j - 1] = half[index]\n                index += 1\n    \n    return \"YES\", matrix\n\nn = int(input())\nnumbers = list(map(int, input().split()))\n\nresult = create_palindromic_matrix(n, numbers)\n\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for row in result[1]:\n        print(\" \".join(map(str, row)))\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1 or (d == 1 and n > 2) or (d == 0 and n > 1):\n        print(\"NO\")\n        return\n\n    edges = []\n    \n    # Create a path of length d\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n\n    # Now we have d + 1 vertices in the path\n    current_vertex = d + 2\n\n    # Connect the remaining vertices\n    for i in range(1, d + 2):\n        while len([e for e in edges if e[0] == i or e[1] == i]) < k and current_vertex <= n:\n            edges.append((i, current_vertex))\n            current_vertex += 1\n            if current_vertex > n:\n                break\n\n    if current_vertex <= n:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for u, v in edges:\n            print(u, v)\n\n# Read input\nn, d, k = map(int, input().split())\nconstruct_tree(n, d, k)\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    from collections import defaultdict\n\n    # Step 1: Create a mapping of characters to their positions\n    char_positions = defaultdict(list)\n    for index, char in enumerate(s):\n        char_positions[char].append(index)\n\n    # Step 2: Create a list to hold the color assignments\n    colors = [0] * n\n    current_color = 1\n\n    # Step 3: Assign colors based on the positions of characters\n    for char in sorted(char_positions.keys()):\n        positions = char_positions[char]\n        for i in range(len(positions)):\n            colors[positions[i]] = (i % current_color) + 1\n        current_color = max(current_color, len(positions))\n\n    # Step 4: Output the results\n    print(current_color)\n    print(' '.join(map(str, colors)))\n\n# Example usage\nn = int(input())\ns = input().strip()\nmin_colors_to_sort(n, s)\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    p = [0] * n\n    p[0] = 0  # We can start from any arbitrary value, we will adjust later\n\n    # Calculate the prefix sums to find the values of p\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n\n    # Find the minimum value in p to adjust the permutation to start from 1\n    min_p = min(p)\n    adjustment = 1 - min_p\n\n    # Adjust the permutation\n    for i in range(n):\n        p[i] += adjustment\n\n    # Check if the adjusted permutation is valid\n    if len(set(p)) == n and all(1 <= x <= n for x in p):\n        print(' '.join(map(str, p)))\n    else:\n        print(-1)\n\n# Read input\nn = int(input())\nq = list(map(int, input().split()))\n\n# Restore the permutation\nrestore_permutation(n, q)\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Start with the first character based on the larger count\n    if a > b:\n        s = '0'\n        a -= 1\n    else:\n        s = '1'\n        b -= 1\n\n    # Alternate between 0s and 1s to create the required number of transitions\n    transitions = 0\n    while transitions < x:\n        if s[-1] == '0' and b > 0:\n            s += '1'\n            b -= 1\n        elif s[-1] == '1' and a > 0:\n            s += '0'\n            a -= 1\n        transitions += 1\n\n    # Fill the rest of the string with the remaining characters\n    s += '0' * a + '1' * b\n    return s\n\n# Read input\na, b, x = map(int, input().split())\n# Construct and print the binary string\nprint(construct_binary_string(a, b, x))\n```",
    "99": "```python\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\n# Maximum wins for Alice\nmax_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n\n# Minimum wins for Alice\n# Calculate losses for Alice\nlosses = 0\nlosses += max(0, b1 - a3)  # Bob's rock beats Alice's paper\nlosses += max(0, b2 - a1)  # Bob's scissors beats Alice's rock\nlosses += max(0, b3 - a2)  # Bob's paper beats Alice's scissors\n\nmin_wins = n - losses\n\nprint(min_wins, max_wins)\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Create a list to hold the result\n    res = []\n    \n    # Count of characters\n    count_a = n\n    count_b = n\n    count_c = n\n    \n    # Function to check if the last two characters form a forbidden substring\n    def is_forbidden():\n        if len(res) < 2:\n            return False\n        return ''.join(res[-2:]) == s or ''.join(res[-2:]) == t\n    \n    # Build the result string\n    while count_a > 0 or count_b > 0 or count_c > 0:\n        for char in 'abc':\n            if char == 'a' and count_a > 0:\n                res.append('a')\n                count_a -= 1\n            elif char == 'b' and count_b > 0:\n                res.append('b')\n                count_b -= 1\n            elif char == 'c' and count_c > 0:\n                res.append('c')\n                count_c -= 1\n            \n            # Check if the last two characters form a forbidden substring\n            if is_forbidden():\n                res.pop()  # Remove the last character\n                if char == 'a':\n                    count_a += 1\n                elif char == 'b':\n                    count_b += 1\n                elif char == 'c':\n                    count_c += 1\n                break  # Restart the loop to try the next character\n    \n    # Join the list into a string\n    result_string = ''.join(res)\n    \n    # Check if we have the right length\n    if len(result_string) == 3 * n:\n        print(\"YES\")\n        print(result_string)\n    else:\n        print(\"NO\")\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\nt = input().strip()\n\ngenerate_string(n, s, t)\n```"
}