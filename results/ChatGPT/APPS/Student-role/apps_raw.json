{
    "0": "```python\ndef max_acc_length(s):\n    n = len(s)\n    left_bracket = -1\n    right_bracket = -1\n    \n    # Find the last opening bracket\n    for i in range(n):\n        if s[i] == '[':\n            left_bracket = i\n    \n    # Find the first closing bracket\n    for i in range(n-1, -1, -1):\n        if s[i] == ']':\n            right_bracket = i\n            \n    # If we don't have both brackets, return -1\n    if left_bracket == -1 or right_bracket == -1 or left_bracket >= right_bracket:\n        return -1\n    \n    # Now look for colons and vertical lines\n    first_colon = -1\n    second_colon = -1\n    \n    for i in range(left_bracket + 1, right_bracket):\n        if s[i] == ':':\n            if first_colon == -1:\n                first_colon = i\n            elif second_colon == -1:\n                second_colon = i\n                break\n    \n    # If we don't have two colons, return -1\n    if first_colon == -1 or second_colon == -1:\n        return -1\n    \n    # Determine the number of vertical lines between the colons\n    vertical_lines = second_colon - first_colon - 1\n    \n    # The length of the accordion is the fixed part plus vertical lines\n    accordion_length = 4 + vertical_lines\n    \n    return accordion_length\n\n# Read input\ns = input().strip()\n# Get result and print\nresult = max_acc_length(s)\nprint(result)\n```",
    "1": "```python\ndef sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef max_digit_sum(x):\n    max_sum = sum_of_digits(x)\n    best_number = x\n    \n    # Check numbers by reducing the last digits to 9\n    str_x = str(x)\n    for i in range(len(str_x)):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a candidate by reducing the current digit and setting all following digits to 9\n        candidate = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (len(str_x) - i - 1)\n        candidate = int(candidate)\n        \n        if candidate > 0 and candidate <= x:\n            current_sum = sum_of_digits(candidate)\n            if current_sum > max_sum or (current_sum == max_sum and candidate > best_number):\n                max_sum = current_sum\n                best_number = candidate\n    \n    return best_number\n\nx = int(input().strip())\nprint(max_digit_sum(x))\n```",
    "2": "```python\nn = int(input())\n\ndef is_lucky_year(year):\n    non_zero_digits = [digit for digit in str(year) if digit != '0']\n    return len(non_zero_digits) <= 1\n\nnext_year = n + 1\nwhile not is_lucky_year(next_year):\n    next_year += 1\n\nprint(next_year - n)\n```",
    "3": "```python\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\ndef count_painted(painters):\n    painted = [0] * (n + 1)\n    for l, r in painters:\n        for i in range(l, r + 1):\n            painted[i] = 1\n    return sum(painted)\n\nmax_painted = 0\n\nfor i in range(q):\n    for j in range(i + 1, q):\n        remaining_painters = [painters[k] for k in range(q) if k != i and k != j]\n        max_painted = max(max_painted, count_painted(remaining_painters))\n\nprint(max_painted)\n```",
    "4": "```python\ndef is_lucky(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef minutes_before(hh, mm, x, y):\n    total_minutes = hh * 60 + mm - y * x\n    if total_minutes < 0:\n        total_minutes += 24 * 60  # wrap around to the previous day\n    return total_minutes // 60, total_minutes % 60\n\nx = int(input())\nhh, mm = map(int, input().split())\n\ny = 0\nwhile not is_lucky(*minutes_before(hh, mm, x, y)):\n    y += 1\n\nprint(y)\n```",
    "5": "```python\ndef min_seconds_to_close_tabs(n, pos, l, r):\n    # If all tabs are already within the range [l, r]\n    if l <= pos <= r:\n        return 0\n    \n    # Calculate operations needed\n    seconds = 0\n    \n    # Move to the leftmost tab in the range if necessary\n    if pos < l:\n        seconds += (l - pos)  # Move to tab l\n        seconds += 1          # Close tabs to the left of l\n    elif pos > r:\n        seconds += (pos - r)  # Move to tab r\n        seconds += 1          # Close tabs to the right of r\n    \n    # Close all tabs outside the segment\n    if l > 1:  # Close left side if there are tabs to close\n        seconds += 1\n    if r < n:  # Close right side if there are tabs to close\n        seconds += 1\n    \n    return seconds\n\n# Read input\nn, pos, l, r = map(int, input().split())\n# Get the result and print it\nprint(min_seconds_to_close_tabs(n, pos, l, r))\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    \n    for query in queries:\n        n, x, blows = query\n        min_blow = float('inf')\n        \n        for d, h in blows:\n            if d >= x:\n                min_blow = 1\n            else:\n                # Calculate the effective reduction and growth\n                net_change = d - h\n                if net_change <= 0:\n                    continue  # This blow can never reduce the heads effectively\n                \n                # Calculate how many blows are needed\n                blows_needed = (x - d + net_change - 1) // net_change + 1\n                min_blow = min(min_blow, blows_needed)\n        \n        results.append(min_blow if min_blow != float('inf') else -1)\n    \n    return results\n\n# Example usage:\nt = 3\nqueries = [\n    (3, 10, [(6, 3), (8, 2), (1, 4)]),\n    (4, 10, [(4, 1), (3, 2), (2, 6), (1, 100)]),\n    (2, 15, [(10, 11), (14, 100)])\n]\n\nresults = min_blows_to_defeat_zmei(t, queries)\nfor result in results:\n    print(result)\n```",
    "7": "```python\ndef day_when_barn_empty(n, m):\n    current_grains = n\n    day = 1\n    \n    while current_grains > 0:\n        # Grains are brought to the barn\n        current_grains += m\n        # Check if the barn overflows\n        if current_grains > n:\n            current_grains = n\n        \n        # Sparrows eat grains\n        current_grains -= day\n        \n        # Move to the next day\n        day += 1\n    \n    return day - 1  # Subtract 1 to get the last day it was not empty\n\n# Read input\nn, m = map(int, input().split())\n# Calculate and print the result\nprint(day_when_barn_empty(n, m))\n```",
    "8": "```python\ndef min_draws_needed(tiles):\n    suits = {'m': [], 'p': [], 's': []}\n    \n    # Parse the input tiles\n    for tile in tiles:\n        number = int(tile[0])\n        suit = tile[1]\n        suits[suit].append(number)\n\n    # Check for koutsu (triplet)\n    for suit in suits.values():\n        if len(suit) >= 3 and len(set(suit)) == 1:\n            return 0  # Already has a koutsu\n\n    # Check for shuntsu (sequence)\n    for suit in suits.values():\n        suit.sort()\n        for i in range(len(suit) - 1):\n            if suit[i] + 1 == suit[i + 1]:\n                # Found a sequence, no need to draw\n                return 0\n            if i < len(suit) - 2 and suit[i] + 2 == suit[i + 2]:\n                # Found a gap that can be filled with one tile\n                return 1\n    \n    # Check for missing tiles to create a shuntsu\n    for suit in suits.values():\n        if len(suit) == 2:\n            # Check if we can fill the gap for a shuntsu\n            if abs(suit[0] - suit[1]) == 2:\n                return 1  # Need to draw one tile to complete the sequence\n\n    return 2  # Otherwise, we need to draw two tiles\n\n# Input reading\ntiles = input().strip().split()\nprint(min_draws_needed(tiles))\n```",
    "9": "```python\ndef find_grandpas_sofa(d, n, m, sofas, counts):\n    cnt_l, cnt_r, cnt_t, cnt_b = counts\n    # Create lists to store the sofas positions\n    positions = []\n    \n    for i in range(d):\n        x1, y1, x2, y2 = sofas[i]\n        positions.append((min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)))\n    \n    # Initialize the counts for each sofa\n    left_counts = [0] * d\n    right_counts = [0] * d\n    top_counts = [0] * d\n    bottom_counts = [0] * d\n    \n    # Calculate counts for each sofa\n    for i in range(d):\n        x1, y1, x2, y2 = positions[i]\n        for j in range(d):\n            if i != j:\n                x1_j, y1_j, x2_j, y2_j = positions[j]\n                \n                # Check if j is to the left of i\n                if x2_j < x1:  # sofa j is to the left of sofa i\n                    left_counts[i] += 1\n                # Check if j is to the right of i\n                elif x1_j > x2:  # sofa j is to the right of sofa i\n                    right_counts[i] += 1\n                # Check if j is above i\n                elif y2_j < y1:  # sofa j is above sofa i\n                    top_counts[i] += 1\n                # Check if j is below i\n                elif y1_j > y2:  # sofa j is below sofa i\n                    bottom_counts[i] += 1\n    \n    # Find the matching sofa\n    for i in range(d):\n        if (left_counts[i] == cnt_l and \n            right_counts[i] == cnt_r and \n            top_counts[i] == cnt_t and \n            bottom_counts[i] == cnt_b):\n            return i + 1  # Return 1-based index\n    \n    return -1  # No matching sofa found\n\n# Read input\nd = int(input().strip())\nn, m = map(int, input().strip().split())\nsofas = [tuple(map(int, input().strip().split())) for _ in range(d)]\ncounts = tuple(map(int, input().strip().split()))\n\n# Get the result\nresult = find_grandpas_sofa(d, n, m, sofas, counts)\n\n# Print the result\nprint(result)\n```",
    "10": "```python\nn = int(input())\n\n# Calculate minimum days off\nif n < 5:\n    min_days_off = 0\nelse:\n    min_days_off = n // 7 * 2 + max(0, n % 7 - 5)\n\n# Calculate maximum days off\nmax_days_off = min(n, 2 + (n // 7) * 2)\n\nprint(min_days_off, max_days_off)\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    count_a = n // a\n    count_b = n // b\n    count_ab = n // (a * b)  # Count of indices that are divisible by both a and b\n\n    # Calculate the maximum chocolates based on the strategy\n    # Paint the common divisible by both a and b with the more rewarding color\n    if p > q:\n        chocolates = (count_a * p) + (count_b * q) - (count_ab * q)\n    else:\n        chocolates = (count_a * p) + (count_b * q) - (count_ab * p)\n\n    return chocolates\n\n# Read inputs\nn, a, b, p, q = map(int, input().split())\nprint(max_chocolates(n, a, b, p, q))\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    # Find the lengths of all segments of golden trophies\n    segments = []\n    current_length = 0\n    \n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n            \n    if current_length > 0:\n        segments.append(current_length)\n    \n    # If there are no segments of golden trophies\n    if not segments:\n        return 0\n    \n    # Calculate the maximum length of golden trophies segment\n    max_length = max(segments)\n\n    # If there's only one segment, we cannot increase its length by any swap\n    if len(segments) == 1:\n        return max_length\n    \n    # Check potential enhancements by swaps\n    max_possible = max_length\n    \n    for i in range(len(segments) - 1):\n        # Check if there's a silver trophy between two segments of golden trophies\n        if trophies.count('S') > 0:\n            combined_length = segments[i] + segments[i + 1] + 1\n            max_possible = max(max_possible, combined_length)\n    \n    return max_possible\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\n\n# Output the result\nprint(max_beauty_after_swap(n, trophies))\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef find_course_order(n, k, main_courses, dependencies):\n    # Create a graph for courses and track in-degrees\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    \n    # Fill the graph and in-degree based on dependencies\n    for i in range(1, n + 1):\n        t_i, *deps = dependencies[i - 1]\n        in_degree[i] = t_i\n        for dep in deps:\n            graph[dep].append(i)\n\n    # Queue for courses that can be taken (in-degree == 0)\n    queue = deque()\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            queue.append(i)\n\n    # List of courses to take\n    order = []\n    taken_courses = set()\n    \n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        taken_courses.add(course)\n        \n        for neighbor in graph[course]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    # Check if we can take all main courses\n    if not all(course in taken_courses for course in main_courses):\n        return -1\n\n    # Return the result\n    return len(order), order\n\n# Input reading\nn, k = map(int, input().split())\nmain_courses = list(map(int, input().split()))\ndependencies = [list(map(int, input().split())) for _ in range(n)]\n\n# Finding the course order\nresult = find_course_order(n, k, main_courses, dependencies)\n\n# Output result\nif result == -1:\n    print(-1)\nelse:\n    m, order = result\n    print(m)\n    print(' '.join(map(str, order)))\n```",
    "14": "```python\ndef is_stack_sortable(n, k, p):\n    # Initialize the set of remaining elements\n    remaining = set(range(1, n + 1)) - set(p)\n    stack = []\n    result = p[:]\n    \n    # Process the first k elements\n    for num in p:\n        while stack and stack[-1] < num:\n            # If the top of the stack is less than the current number, we cannot continue\n            return -1\n        stack.append(num)\n    \n    # Fill in the remaining elements in reverse order to achieve lexicographical maximality\n    for num in sorted(remaining, reverse=True):\n        while stack and stack[-1] < num:\n            result.append(stack.pop())\n        stack.append(num)\n    \n    # Empty the stack to get the final result\n    while stack:\n        result.append(stack.pop())\n    \n    return result\n\n# Input reading\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result\nresult = is_stack_sortable(n, k, p)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "16": "```python\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\n# Calculate the balance of open and close brackets\nopen_brackets = cnt_1 + cnt_2\nclose_brackets = cnt_3 + cnt_4\n\n# Check if the total number of openings and closings can form a regular sequence\nif open_brackets == close_brackets:\n    # Check if we can maintain a valid sequence throughout\n    if cnt_1 + cnt_2 >= cnt_4:\n        print(1)\n    else:\n        print(0)\nelse:\n    print(0)\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelse:\n    print(n + k - t)\n```",
    "18": "```python\ndef lexicographically_minimal_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        # Maintain the order of characters in t for forming u\n        while t and (not u or t[-1] <= u[-1]):\n            u.append(t.pop())\n    \n    # If there are still characters left in t after processing s\n    while t:\n        u.append(t.pop())\n    \n    # Join the list to form the final string\n    return ''.join(u)\n\n# Input\ns = input().strip()\n# Output the result\nprint(lexicographically_minimal_string(s))\n```",
    "19": "```python\ndef check_records(test_cases):\n    results = []\n    for _ in range(test_cases):\n        n = int(input())\n        prev_p, prev_c = 0, 0\n        valid = True\n        \n        for _ in range(n):\n            p, c = map(int, input().split())\n            if p < prev_p or c < prev_c or c > p:\n                valid = False\n            if p - prev_p < c - prev_c:\n                valid = False\n            prev_p, prev_c = p, c\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Input handling\nT = int(input())\nresults = check_records(T)\nfor result in results:\n    print(result)\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef time_to_palindrome(hh, mm):\n    minutes_passed = 0\n    while True:\n        if is_palindrome(f\"{hh:02}:{mm:02}\"):\n            return minutes_passed\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n\ncurrent_time = input().strip()\nhh, mm = map(int, current_time.split(':'))\nresult = time_to_palindrome(hh, mm)\nprint(result)\n```",
    "21": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_index = a.index(1)\nmax_index = a.index(n)\n\n# Calculate initial distance\ninitial_distance = abs(min_index - max_index)\n\n# Possible positions for min and max after a swap\nnew_positions = [\n    (0, n - 1),  # swap min with first element or max with last element\n    (n - 1, 0)   # swap max with first element or min with last element\n]\n\nmax_distance = initial_distance\n\nfor min_pos, max_pos in new_positions:\n    new_min_index = min_pos if a[min_pos] == 1 else max_index\n    new_max_index = max_pos if a[max_pos] == n else min_index\n    max_distance = max(max_distance, abs(new_min_index - new_max_index))\n\nprint(max_distance)\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror_letters = {\n        'A': 'A', 'b': 'd', 'C': 'C', 'd': 'b', 'E': 'E', 'H': 'H',\n        'I': 'I', 'J': 'L', 'L': 'J', 'M': 'M', 'O': 'O', 'P': 'P',\n        'Q': 'Q', 'R': 'R', 'S': 'S', 'T': 'T', 'U': 'U', 'V': 'V',\n        'W': 'W', 'X': 'X', 'Y': 'Y', 'Z': 'Z'\n    }\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        if s[i] not in mirror_letters or mirror_letters[s[i]] != s[n - 1 - i]:\n            print(\"NIE\")\n            return\n    print(\"TAK\")\n\ns = input().strip()\nis_s_palindrome(s)\n```",
    "23": "```python\nfrom itertools import permutations\n\ndef max_permutation(a, b):\n    a_str = str(a)\n    b_str = str(b)\n    \n    # Generate all unique permutations of the digits of a\n    permuted_numbers = sorted(set(int(''.join(p)) for p in permutations(a_str)), reverse=True)\n    \n    # Find the maximum permutation that does not exceed b\n    for num in permuted_numbers:\n        if num <= b and len(str(num)) == len(a_str):\n            return num\n\n# Input\na = int(input().strip())\nb = int(input().strip())\n\n# Output\nprint(max_permutation(a, b))\n```",
    "24": "```python\ndef can_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # horizontal, vertical, diagonal down-right, diagonal down-left\n\n    def check_win(x, y):\n        for dx, dy in directions:\n            count = 1  # Count the current move\n            # Check in the positive direction\n            nx, ny = x + dx, y + dy\n            while 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n                nx += dx\n                ny += dy\n            # Check in the negative direction\n            nx, ny = x - dx, y - dy\n            while 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n                nx -= dx\n                ny -= dy\n            if count >= 5:\n                return True\n        return False\n\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                board[i][j] = 'X'  # Place a cross\n                if check_win(i, j):\n                    return 'YES'\n                board[i][j] = '.'  # Remove the cross\n    return 'NO'\n\n# Read input\nboard = [input().strip() for _ in range(10)]\nprint(can_win(board))\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    if k > n * (n + 1) // 2:\n        return -1\n\n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k > 0:\n            matrix[i][i] = 1\n            k -= 1\n        \n        for j in range(i + 1, n):\n            if k >= 2:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n            if k <= 0:\n                break\n\n    return matrix if k == 0 else -1\n\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "26": "```python\n# Read input values\nx, y, z = map(float, input().split())\n\n# Define the expressions and their corresponding representations\nexpressions = [\n    (x ** (y ** z), \"x^y^z\"),\n    (x ** (z ** y), \"x^z^y\"),\n    ((x ** y) ** z, \"(x^y)^z\"),\n    ((x ** z) ** y, \"(x^z)^y\"),\n    (y ** (x ** z), \"y^x^z\"),\n    (y ** (z ** x), \"y^z^x\"),\n    ((y ** x) ** z, \"(y^x)^z\"),\n    ((y ** z) ** x, \"(y^z)^x\"),\n    (z ** (x ** y), \"z^x^y\"),\n    (z ** (y ** x), \"z^y^x\"),\n    ((z ** x) ** y, \"(z^x)^y\"),\n    ((z ** y) ** x, \"(z^y)^x\"),\n]\n\n# Find the maximum value and its index\nmax_value, max_index = max((value, index) for index, (value, _) in enumerate(expressions))\n\n# Print the corresponding expression\nprint(expressions[max_index][1])\n```",
    "27": "```python\nn = int(input())\ns = input().strip()\n\nmin_operations = n  # Start with the assumption that we type everything one by one\n\n# Check for possible copy and append scenarios\nfor i in range(1, n):\n    if s[:i] == s[i:2*i]:\n        # If the prefix matches the next part of the string\n        operations = i + 1 + (n - 2 * i)  # Type i characters, copy, then type the rest\n        min_operations = min(min_operations, operations)\n\nprint(min_operations)\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = []\nregulars = []\n\nfor name, type_ in files:\n    if type_ == '1':\n        examples.append(name)\n    else:\n        regulars.append(name)\n\ne = len(examples)\nmoves = []\n\n# Move example files to their new names\nfor i in range(e):\n    moves.append(f\"move {examples[i]} {i + 1}\")\n\n# Move regular files to their new names\nfor i in range(len(regulars)):\n    moves.append(f\"move {regulars[i]} {e + i + 1}\")\n\nprint(len(moves))\nprint(\"\\n\".join(moves))\n```",
    "29": "```python\ndef min_replacements_to_lucky_ticket(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    diff = abs(sum_first - sum_second)\n    \n    # Create a list of possible changes\n    changes = []\n    \n    if sum_first < sum_second:\n        # We need to increase sum_first or decrease sum_second\n        for digit in first_half:\n            changes.append(9 - digit)  # max increase we can get\n        for digit in second_half:\n            changes.append(digit)       # max decrease we can get\n    else:\n        # We need to increase sum_second or decrease sum_first\n        for digit in second_half:\n            changes.append(9 - digit)  # max increase we can get\n        for digit in first_half:\n            changes.append(digit)       # max decrease we can get\n    \n    changes.sort(reverse=True)\n    \n    replacements = 0\n    for change in changes:\n        diff -= change\n        replacements += 1\n        if diff <= 0:\n            break\n            \n    return replacements\n\n# Read input\nticket = input().strip()\n# Get the minimum replacements\nresult = min_replacements_to_lucky_ticket(ticket)\n# Print the result\nprint(result)\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # Since GCD(x, m) = 1, the x-mouse will visit all rooms by moving through them\n    # The number of distinct rooms visited corresponds to Euler's Totient function Ï†(m)\n    # which is the count of numbers up to m that are coprime to m.\n    \n    # To find the number of traps needed, we can just consider the number of rooms\n    # that will be visited in one cycle.\n    \n    visited_rooms = 0\n    room = 0\n    \n    while True:\n        visited_rooms += 1\n        room = (room * x) % m\n        if room == 0:\n            break\n            \n    return visited_rooms\n\n# Read input\nm, x = map(int, input().split())\n# Output the result\nprint(minimum_traps(m, x))\n```",
    "31": "```python\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef probability_of_shared_birthday(n, k):\n    days = 2 ** n\n    if k > days:\n        return 1, 1  # Guaranteed at least one shared birthday\n\n    # Calculate the probability of no shared birthdays\n    num = 1\n    denom = days ** k\n    for i in range(k):\n        num *= (days - i)\n    \n    # The probability of at least two having the same birthday\n    A = denom - num\n    B = denom\n\n    # Reduce A and B by their gcd\n    common_gcd = gcd(A, B)\n    A //= common_gcd\n    B //= common_gcd\n    \n    # Take modulo\n    mod = 10**6 + 3\n    A %= mod\n    B %= mod\n    \n    return A, B\n\n# Read input\nn, k = map(int, input().split())\nA, B = probability_of_shared_birthday(n, k)\nprint(A, B)\n```",
    "32": "```python\ndef is_valid_journey(n, journey):\n    position = 0  # Position starts at the North Pole (0 km from North Pole)\n    \n    for t, direction in journey:\n        if position == 0 and direction != \"South\":\n            return \"NO\"  # Limak can only move South from the North Pole\n        if position == 20000 and direction != \"North\":\n            return \"NO\"  # Limak can only move North from the South Pole\n        \n        if direction == \"South\":\n            position += t\n        elif direction == \"North\":\n            position -= t\n        elif direction == \"West\" or direction == \"East\":\n            pass  # These directions don't change the position\n        \n        if position < 0 or position > 20000:\n            return \"NO\"  # Invalid position\n    \n    if position != 0:\n        return \"NO\"  # Must end at the North Pole\n    \n    return \"YES\"\n\n# Input reading\nn = int(input())\njourney = [tuple(input().split()) for _ in range(n)]\njourney = [(int(t), direction) for t, direction in journey]\n\n# Output the result\nprint(is_valid_journey(n, journey))\n```",
    "33": "```python\ndef count_common_ap(a1, b1, a2, b2, L, R):\n    # Function to find all values in the range [L, R] that can be expressed as both APs\n    def count_in_ap(a, b, L, R):\n        if a == 0:\n            if b < L or b > R:\n                return 0\n            return (R - L) // a + 1 if L <= R else 0\n        \n        # Find the first term in the AP that is >= L\n        if b < L:\n            first = (L - b + a - 1) // a * a + b\n        else:\n            first = b\n        \n        # Find the last term in the AP that is <= R\n        if b > R:\n            last = (R - b) // a * a + b\n        else:\n            last = b\n        \n        if first > R or last < L:\n            return 0\n        \n        return (last - first) // a + 1\n    \n    # Count terms for both APs\n    count_a1 = count_in_ap(a1, b1, L, R)\n    count_a2 = count_in_ap(a2, b2, L, R)\n    \n    # Use a set to collect common terms\n    common_terms = set()\n    \n    # Generate terms for the first AP\n    for k in range((R - b1) // a1 + 1):\n        term = a1 * k + b1\n        if L <= term <= R:\n            common_terms.add(term)\n    \n    # Count terms for the second AP and check commonality\n    count = 0\n    for l in range((R - b2) // a2 + 1):\n        term = a2 * l + b2\n        if L <= term <= R and term in common_terms:\n            count += 1\n    \n    return count\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n# Get the result\nresult = count_common_ap(a1, b1, a2, b2, L, R)\n# Print the output\nprint(result)\n```",
    "34": "```python\ndef can_distribute(x, n, a, b):\n    # Calculate how many plates can be filled with at least x pieces\n    plates_from_a = a // x\n    plates_from_b = b // x\n    # Check if the total plates filled can satisfy n\n    return plates_from_a + plates_from_b >= n\n\ndef max_min_pieces(n, a, b):\n    low, high = 1, max(a, b)\n    result = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if can_distribute(mid, n, a, b):\n            result = mid  # mid is a potential solution\n            low = mid + 1  # Try for a larger value\n        else:\n            high = mid - 1  # Try for a smaller value\n    return result\n\n# Input\nn, a, b = map(int, input().split())\n# Output\nprint(max_min_pieces(n, a, b))\n```",
    "35": "```python\ndef is_valid_flag(n, m, flag):\n    # Check for horizontal stripes\n    if n % 3 == 0:\n        stripe_height = n // 3\n        colors = set()\n        for i in range(3):\n            stripe = flag[i * stripe_height:(i + 1) * stripe_height]\n            if all(row == stripe[0] for row in stripe) and stripe[0][0] not in colors:\n                colors.add(stripe[0][0])\n            else:\n                return \"NO\"\n        return \"YES\" if len(colors) == 3 else \"NO\"\n    \n    # Check for vertical stripes\n    if m % 3 == 0:\n        stripe_width = m // 3\n        colors = set()\n        for i in range(3):\n            stripe = [row[i * stripe_width:(i + 1) * stripe_width] for row in flag]\n            if all(row == stripe[0] for row in stripe) and stripe[0][0] not in colors:\n                colors.add(stripe[0][0])\n            else:\n                return \"NO\"\n        return \"YES\" if len(colors) == 3 else \"NO\"\n    \n    return \"NO\"\n\n# Input reading\nn, m = map(int, input().split())\nflag = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(is_valid_flag(n, m, flag))\n```",
    "36": "```python\ndef get_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 6\n    total_moves = 0\n    \n    while total_moves + moves_in_layer <= n:\n        total_moves += moves_in_layer\n        layer += 1\n        moves_in_layer += 6\n\n    remaining_moves = n - total_moves\n    x, y = layer, 0\n\n    if remaining_moves == 0:\n        return (x, y)\n\n    # Move in the current layer\n    direction = 0  # Start moving right (east)\n    for _ in range(remaining_moves):\n        if direction == 0:  # East\n            x += 1\n        elif direction == 1:  # North-East\n            y += 1\n            x -= 1\n        elif direction == 2:  # North-West\n            y += 1\n        elif direction == 3:  # West\n            x -= 1\n        elif direction == 4:  # South-West\n            y -= 1\n            x += 1\n        elif direction == 5:  # South-East\n            y -= 1\n        \n        direction = (direction + 1) % 6\n\n    return (x, y)\n\nn = int(input())\nx, y = get_coordinates(n)\nprint(x, y)\n```",
    "37": "```python\ndef can_deal_exact_damage(a, b, c):\n    for x in range(c // a + 1):\n        if (c - a * x) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Input\na, b, c = map(int, input().split())\n# Output\nprint(can_deal_exact_damage(a, b, c))\n```",
    "38": "```python\ndef can_tracks_coincide(n, L, kefa_distances, sasha_distances):\n    # Calculate the differences (gaps) between consecutive barriers and wrap around\n    kefa_gaps = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    sasha_gaps = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Double the gaps for Kefa to handle circular comparison\n    doubled_kefa_gaps = kefa_gaps * 2\n    \n    # Check if sasha_gaps is a contiguous subsequence in doubled_kefa_gaps\n    for start in range(n):\n        if doubled_kefa_gaps[start:start + n] == sasha_gaps:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_distances, sasha_distances))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ns = input().strip()\n\nif not is_palindrome(s):\n    print(len(s))\nelse:\n    # Check if all characters are the same\n    if all(c == s[0] for c in s):\n        print(0)\n    else:\n        print(len(s) - 1)\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\nrated = False\nunrated = False\n\nfor a, b in ratings:\n    if a != b:\n        rated = True\n        break\n\nif rated:\n    print(\"rated\")\nelse:\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            unrated = True\n            break\n\n    if unrated:\n        print(\"unrated\")\n    else:\n        print(\"maybe\")\n```",
    "41": "```python\nn = int(input())\na = list(map(int, input().split()))\n\ndistances = [0] * n\nlast_zero_index = -1\n\n# Forward pass to find distances to the nearest zero on the left\nfor i in range(n):\n    if a[i] == 0:\n        last_zero_index = i\n        distances[i] = 0\n    else:\n        if last_zero_index != -1:\n            distances[i] = i - last_zero_index\n\n# Backward pass to find distances to the nearest zero on the right\nlast_zero_index = -1\nfor i in range(n - 1, -1, -1):\n    if a[i] == 0:\n        last_zero_index = i\n    else:\n        if last_zero_index != -1:\n            distances[i] = min(distances[i], last_zero_index - i)\n\nprint(' '.join(map(str, distances)))\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n\n    def is_cyclic_shift(s1, s2):\n        return len(s1) == len(s2) and s1 in s2 + s2\n\n    # Generate all binary strings of length n\n    binary_strings = [''.join(p) for p in product('01', repeat=n)]\n    \n    distinct_cyclic_strings = set()\n    \n    for t in binary_strings:\n        if s in t:\n            # Check for cyclic shifts and add only the canonical form\n            min_shift = min(t[i:] + t[:i] for i in range(n))\n            distinct_cyclic_strings.add(min_shift)\n    \n    return len(distinct_cyclic_strings)\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(count_cyclic_strings(n, s))\n```",
    "43": "```python\nimport math\n\ndef angle_between(v1, v2):\n    # Calculate the angle between two vectors using the dot product\n    dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n    magnitude_v1 = math.sqrt(v1[0]**2 + v1[1]**2)\n    magnitude_v2 = math.sqrt(v2[0]**2 + v2[1]**2)\n    cos_angle = dot_product / (magnitude_v1 * magnitude_v2)\n    return math.acos(cos_angle)\n\ndef main():\n    n = int(input())\n    vectors = []\n    \n    for i in range(n):\n        x, y = map(int, input().split())\n        vectors.append((x, y, i + 1))  # Save vector with its index\n\n    # Sort vectors by angle\n    vectors.sort(key=lambda v: math.atan2(v[1], v[0]))\n\n    min_angle = float('inf')\n    min_pair = (0, 0)\n\n    for i in range(n):\n        v1 = vectors[i]\n        v2 = vectors[(i + 1) % n]  # Wrap around to the first vector\n        angle = angle_between(v1[:2], v2[:2])\n        \n        if angle < min_angle:\n            min_angle = angle\n            min_pair = (v1[2], v2[2])  # Save indices\n\n    print(min_pair[0], min_pair[1])\n\nif __name__ == \"__main__\":\n    main()\n```",
    "44": "```python\ndef minimal_time(d, k, a, b, t):\n    # Initialize the minimum time to infinity\n    min_time = float('inf')\n    \n    # Calculate how many full segments of k fit into d\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Calculate time using the car for full segments and walking the remaining distance\n    time_with_car = full_segments * (k * a) + remaining_distance * a + full_segments * t\n    min_time = min(min_time, time_with_car)\n    \n    # Check the case where we walk the full distance\n    time_walking = d * b\n    min_time = min(min_time, time_walking)\n    \n    # Consider driving segments and walking the rest\n    for segments in range(full_segments + 1):\n        distance_by_car = segments * k\n        if distance_by_car > d:\n            break\n            \n        time_by_car = distance_by_car * a + segments * t\n        remaining_distance = d - distance_by_car\n        time_by_foot = remaining_distance * b\n\n        total_time = time_by_car + time_by_foot\n        min_time = min(min_time, total_time)\n    \n    return min_time\n\n# Input reading\nd, k, a, b, t = map(int, input().split())\n# Output the minimal time\nprint(minimal_time(d, k, a, b, t))\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Minimum sum of first k positive integers is k * (k + 1) // 2\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        return -1\n\n    # The maximum gcd we can use\n    g = (n - min_sum) // k + 1  # this is the maximum gcd we can use\n\n    # We need to create the sequence\n    result = [i * g for i in range(1, k + 1)]\n    \n    # Adjust the last element to make the sum equal to n\n    result[-1] += (n - sum(result))\n\n    return result\n\n# Input reading\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "46": "```python\ndef count_pairs(n, m):\n    # Count the number of integers in the ranges that give specific remainders when divided by 5\n    count_x = [0] * 5\n    count_y = [0] * 5\n    \n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n    \n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n\n    # Calculate the number of valid pairs\n    result = (\n        count_x[0] * count_y[0] +  # (0, 0)\n        count_x[1] * count_y[4] +  # (1, 4)\n        count_x[2] * count_y[3] +  # (2, 3)\n        count_x[3] * count_y[2] +  # (3, 2)\n        count_x[4] * count_y[1]    # (4, 1)\n    )\n    \n    return result\n\n# Input\nn, m = map(int, input().split())\nprint(count_pairs(n, m))\n```",
    "47": "```python\ndef max_beauty_after_multiplication(n, x, a):\n    def kadane(arr):\n        max_ending_here = 0\n        max_so_far = 0\n        for num in arr:\n            max_ending_here = max(0, max_ending_here + num)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    # Original beauty of the array\n    original_beauty = kadane(a)\n    \n    # Calculate the maximum beauty after multiplying a subarray by x\n    max_beauty_with_multiplication = original_beauty\n    for start in range(n):\n        current_sum = 0\n        for end in range(start, n):\n            current_sum += a[end]\n            modified_sum = current_sum * x\n            new_beauty = kadane(a[:start] + [modified_sum] + a[end+1:])\n            max_beauty_with_multiplication = max(max_beauty_with_multiplication, new_beauty)\n\n    return max_beauty_with_multiplication\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_beauty_after_multiplication(n, x, a))\n```",
    "48": "```python\ndef kth_largest(n, m, k):\n    left, right = 1, n * m\n    \n    while left < right:\n        mid = (left + right) // 2\n        count = sum(min(mid // i, m) for i in range(1, n + 1))\n        \n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return left\n\n# Read input\nn, m, k = map(int, input().split())\n# Output the result\nprint(kth_largest(n, m, k))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n    \n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n    \n    start += (k - 1) // length\n    num_str = str(start)\n    return int(num_str[(k - 1) % length])\n\nk = int(input())\nprint(find_kth_digit(k))\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph, n):\n    distances = [-1] * (n + 1)\n    distances[start] = 0\n    queue = deque([start])\n    farthest_node = start\n\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if distances[neighbor] == -1:  # not visited\n                distances[neighbor] = distances[node] + 1\n                queue.append(neighbor)\n                if distances[neighbor] > distances[farthest_node]:\n                    farthest_node = neighbor\n\n    return farthest_node, distances\n\ndef find_max_edges_in_paths(n, edges):\n    # Create adjacency list for the tree\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # Step 1: Find the farthest node from an arbitrary starting point (1)\n    farthest_from_start, _ = bfs(1, graph, n)\n    \n    # Step 2: Find the farthest node from that farthest node (this gives us one end of the diameter)\n    opposite_end, distances_from_first = bfs(farthest_from_start, graph, n)\n    \n    # Step 3: Find the farthest node from the opposite end (this gives us the other end of the diameter)\n    _, distances_from_second = bfs(opposite_end, graph, n)\n    \n    # Step 4: Find the two nodes which are the farthest from the diameter ends\n    max_distance = 0\n    a, b = -1, -1\n    for i in range(1, n + 1):\n        if distances_from_first[i] + distances_from_second[i] > max_distance:\n            max_distance = distances_from_first[i] + distances_from_second[i]\n            a = farthest_from_start\n            b = opposite_end\n    \n    # Step 5: Find the third vertex to maximize edges\n    # The third vertex should be chosen from the farthest points from the two endpoints\n    candidates = []\n    for i in range(1, n + 1):\n        if i != a and i != b:\n            candidates.append(i)\n    \n    # Find the candidate which maximizes the distance to both a and b\n    c = candidates[0]\n    max_additional_distance = 0\n    \n    for candidate in candidates:\n        additional_distance = min(distances_from_first[candidate], distances_from_second[candidate])\n        if additional_distance > max_additional_distance:\n            max_additional_distance = additional_distance\n            c = candidate\n\n    # The final result is the max number of edges in the paths\n    res = max_distance + 1  # +1 because edges are one less than the number of vertices\n\n    return res, a, b, c\n\n# Input Reading\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\n# Function Call\nresult, a, b, c = find_max_edges_in_paths(n, edges)\n\n# Output Result\nprint(result)\nprint(a, b, c)\n```",
    "51": "```python\nfrom collections import Counter\nfrom math import gcd\n\nn = int(input())\ndivisors = list(map(int, input().split()))\n\n# Count occurrences of each divisor\ncount = Counter(divisors)\n\n# The two numbers x and y can be found as follows:\n# x should be the product of the maximum divisor with the divisor that appears once\n# y should be the maximum divisor itself\nd1, d2 = 1, 1\nfor divisor, occurrences in count.items():\n    if occurrences == 1:\n        d1 = divisor\n    elif occurrences == 2:\n        d2 = divisor\n\n# The maximum divisor from the list\nmax_divisor = max(divisors)\n\n# Calculate x and y\nx = max_divisor * d1\ny = max_divisor * d2\n\n# Output the result\nprint(x, y)\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    from itertools import combinations\n\n    max_elements = m // 2\n    total_max_sum = 0\n\n    # Iterate through each row\n    for row in matrix:\n        row.sort(reverse=True)  # Sort row in descending order to maximize sum\n        current_max_sum = [0] * k  # To store max sum for each modulo class\n        \n        # Try all combinations of selecting up to max_elements\n        for r in range(max_elements + 1):\n            for comb in combinations(row, r):\n                current_sum = sum(comb)\n                current_max_sum[current_sum % k] = max(current_max_sum[current_sum % k], current_sum)\n        \n        total_max_sum += max(current_max_sum)\n\n    return total_max_sum\n\n# Input reading\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print\nresult = max_sum_divisible_by_k(n, m, k, matrix)\nprint(result)\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last = float('-inf')\n    moves = []\n    \n    while left <= right:\n        if a[left] > last and (a[right] <= last or a[left] < a[right]):\n            moves.append('L')\n            last = a[left]\n            left += 1\n        elif a[right] > last:\n            moves.append('R')\n            last = a[right]\n            right -= 1\n        else:\n            break\n    \n    print(len(moves))\n    print(''.join(moves))\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\nlongest_increasing_sequence(n, a)\n```",
    "54": "```python\ndef min_D_to_equal_elements(n, a):\n    min_a = min(a)\n    max_a = max(a)\n    \n    if min_a == max_a:\n        return 0\n    \n    diff = max_a - min_a\n    \n    if diff % 2 == 0:\n        return diff // 2\n    else:\n        return -1\n\nn = int(input())\na = list(map(int, input().split()))\nprint(min_D_to_equal_elements(n, a))\n```",
    "55": "```python\ndef can_see_white_sheet(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n    # Check if there is any point in the visible area of the white sheet\n    # The visible area of the white sheet is outside the boundaries of the black sheets.\n    \n    # Check if the white sheet is completely covered by the black sheets\n    is_covered_by_first_black = (x3 <= x1 and y3 <= y1 and x4 >= x2 and y4 >= y2)\n    is_covered_by_second_black = (x5 <= x1 and y5 <= y1 and x6 >= x2 and y6 >= y2)\n\n    # If both black sheets cover the white sheet completely, return \"NO\"\n    if is_covered_by_first_black and is_covered_by_second_black:\n        return \"NO\"\n\n    # Check visibility on the left side of the white sheet\n    if (x3 >= x2 or x5 >= x2) or (y3 >= y2 or y5 >= y2):\n        return \"YES\"\n\n    # Check visibility on the right side of the white sheet\n    if (x4 <= x1 or x6 <= x1) or (y4 <= y1 or y6 <= y1):\n        return \"YES\"\n\n    # Check visibility on the top side of the white sheet\n    if (y3 >= y2 or y5 >= y2) or (x3 >= x2 or x5 >= x2):\n        return \"YES\"\n\n    # Check visibility on the bottom side of the white sheet\n    if (y4 <= y1 or y6 <= y1) or (x4 <= x1 or x6 <= x1):\n        return \"YES\"\n\n    # If all checks fail, then the white sheet is completely covered\n    return \"NO\"\n\n# Input reading\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Output result\nprint(can_see_white_sheet(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6))\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef count_reachable(n):\n    reachable = set()\n    current = n\n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    return len(reachable)\n\nn = int(input().strip())\nprint(count_reachable(n))\n```",
    "57": "```python\nn = int(input())\nf = list(map(int, input().split()))\n\n# Initialize lists to track givers and receivers\ngivers = []\nreceivers = set(range(1, n + 1))\n\n# Fill known values and track the givers\nfor i in range(n):\n    if f[i] != 0:\n        givers.append((i + 1, f[i]))  # (friend_index, gives_to)\n        receivers.discard(f[i])  # Remove from receivers\n\n# Convert receivers to a list for filling unknowns\nreceivers = list(receivers)\nk = len(givers)\n\n# Now we fill the unknowns\nfor i in range(n):\n    if f[i] == 0:\n        # The current friend must give a gift to someone in receivers\n        # We need to ensure they don't give to themselves\n        f[i] = receivers.pop()  # Assign a receiver to the friend\n\n# Now we need to ensure every friend receives exactly one gift\n# Create a reverse mapping to keep track of who is receiving from whom\nreceive_map = [0] * (n + 1)\nfor i in range(n):\n    if f[i] != 0:\n        receive_map[f[i]] = i + 1\n\n# Ensure that each friend gives a gift and receives one gift\nfor i in range(n):\n    if f[i] == 0:\n        # Find a valid receiver who is not the friend themselves\n        for r in range(1, n + 1):\n            if r != i + 1 and receive_map[r] == 0:\n                f[i] = r\n                receive_map[r] = i + 1\n                break\n\nprint(\" \".join(map(str, f)))\n```",
    "58": "```python\ndef color_array(n, k, a):\n    from collections import defaultdict\n\n    # Dictionary to keep track of color usage\n    color_map = defaultdict(list)\n\n    # Fill color_map with indices of each element in array a\n    for index, value in enumerate(a):\n        color_map[value].append(index)\n\n    # Check if any value in color_map has more than k occurrences\n    if any(len(indices) > k for indices in color_map.values()):\n        print(\"NO\")\n        return\n\n    # Prepare a color assignment array\n    colors = [0] * n\n    current_color = 1\n\n    # Assign colors\n    for indices in color_map.values():\n        for index in indices:\n            colors[index] = current_color\n            current_color += 1\n            if current_color > k:\n                current_color = 1\n\n    # Check if all colors from 1 to k are used\n    used_colors = set(colors)\n    if len(used_colors) < k:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, colors)))\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Call the function\ncolor_array(n, k, a)\n```",
    "59": "```python\ndef min_operations(n, x, y, number):\n    # Target remainder is 10^y, which means we need to have the y-th position as '1'\n    # and all positions from y+1 to x-1 as '0'\n    target = ['0'] * x\n    target[y] = '1'\n    \n    # Count the number of changes needed\n    changes = 0\n    for i in range(x):\n        if number[n - 1 - i] != target[x - 1 - i]:\n            changes += 1\n            \n    return changes\n\n# Input reading\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# Output the result\nprint(min_operations(n, x, y, number))\n```",
    "60": "```python\ndef has_palindrome_subsequence(test_cases):\n    results = []\n    for a in test_cases:\n        n = len(a)\n        found = False\n        # Using a set to track the indices of each number\n        indices = {}\n        for i in range(n):\n            if a[i] in indices:\n                # If we have seen this number before, we can form a palindrome\n                # Check the distance from the last occurrence\n                if i - indices[a[i]] > 1:\n                    found = True\n                    break\n            # Update the last occurrence index\n            indices[a[i]] = i\n        results.append(\"YES\" if found else \"NO\")\n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append(a)\n\n# Get results\nresults = has_palindrome_subsequence(test_cases)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "61": "```python\nn = int(input())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\n# Convert the function f to a 1-indexed array\nf = [0] + f\n\nmax_result = list(a)\nstarted_replacement = False\n\nfor i in range(n):\n    digit = int(a[i])\n    if f[digit] > digit:\n        if not started_replacement:\n            started_replacement = True\n        max_result[i] = str(f[digit])\n    elif f[digit] < digit:\n        if started_replacement:\n            break\n\nprint(''.join(max_result))\n```",
    "62": "```python\ndef min_operations(test_cases):\n    results = []\n    for a, b, c in test_cases:\n        min_operations = float('inf')\n        best_triple = (a, b, c)\n\n        # Check all possible values for A, B, C\n        for A in range(1, 10001):\n            for B in range(A, 10001):\n                if B % A == 0:\n                    for C in range(B, 10001):\n                        if C % B == 0:\n                            operations = abs(A - a) + abs(B - b) + abs(C - c)\n                            if operations < min_operations:\n                                min_operations = operations\n                                best_triple = (A, B, C)\n\n        results.append((min_operations, best_triple))\n\n    return results\n\n\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\nresults = min_operations(test_cases)\n\nfor res in results:\n    print(res[0])\n    print(res[1][0], res[1][1], res[1][2])\n```",
    "63": "```python\ndef min_instability(n, a):\n    a.sort()\n    # Calculate instability after removing the first or the last element\n    return min(a[-1] - a[1], a[-2] - a[0])\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result and print it\nresult = min_instability(n, a)\nprint(result)\n```",
    "64": "```python\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Initialize the schedule with zeros (rest days)\nschedule = [0] * n\n\n# To track the preparation days needed for each exam\npreparation_needed = [0] * m\n\n# Mark exam days in the schedule\nfor i in range(m):\n    s_i, d_i, c_i = exams[i]\n    schedule[d_i - 1] = m + 1  # Mark the exam day\n\n# Prepare for exams\nfor i in range(m):\n    s_i, d_i, c_i = exams[i]\n    days_to_prepare = []\n    \n    # Find available days for preparation\n    for j in range(s_i - 1, d_i - 1):\n        if schedule[j] == 0 and len(days_to_prepare) < c_i:\n            days_to_prepare.append(j)\n    \n    # Check if we have enough days to prepare\n    if len(days_to_prepare) < c_i:\n        print(-1)\n        exit()\n    \n    # Mark preparation days in the schedule\n    for day in days_to_prepare:\n        schedule[day] = i + 1  # Mark preparation for exam i+1\n\n# Print the final schedule\nprint(' '.join(map(str, schedule)))\n```",
    "65": "```python\ndef min_moves(n, m):\n    if m % n != 0:\n        return -1\n    \n    quotient = m // n\n    moves = 0\n    \n    while quotient > 1:\n        if quotient % 2 == 0:\n            quotient //= 2\n            moves += 1\n        elif quotient % 3 == 0:\n            quotient //= 3\n            moves += 1\n        else:\n            return -1\n    \n    return moves\n\n# Read input\nn, m = map(int, input().split())\n# Print the result\nprint(min_moves(n, m))\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Find the longest prefix which is also a suffix\n    # This is a common way to find overlaps in strings\n    lps = [0] * n\n    j = 0  # length of previous longest prefix suffix\n    i = 1\n\n    while i < n:\n        if t[i] == t[j]:\n            j += 1\n            lps[i] = j\n            i += 1\n        else:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                lps[i] = 0\n                i += 1\n\n    # The length of the longest prefix which is also a suffix\n    overlap_length = lps[-1]\n\n    # Construct the minimum length string\n    s = t + (t[overlap_length:] * (k - 1))\n    return s\n\n# Read input\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the result string\nresult = construct_string(n, k, t)\n\n# Print the result\nprint(result)\n```",
    "67": "```python\ndef find_nice_indices(n, a):\n    total_sum = sum(a)\n    nice_indices = []\n\n    for i in range(n):\n        remaining_sum = total_sum - a[i]\n        if remaining_sum == 2 * a[i]:  # Check if the removed element is equal to the sum of the remaining elements\n            nice_indices.append(i + 1)  # Store 1-based index\n\n    print(len(nice_indices))\n    if nice_indices:\n        print(\" \".join(map(str, nice_indices)))\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\nfind_nice_indices(n, a)\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    # Create a set to store unique subsequences\n    unique_subsequences = set()\n    \n    # Generate all possible subsequences\n    for i in range(1 << n):  # 2^n combinations\n        subsequence = []\n        for j in range(n):\n            if (i & (1 << j)) > 0:\n                subsequence.append(s[j])\n        unique_subsequences.add(''.join(subsequence))\n    \n    # Calculate the size of unique subsequences\n    m = len(unique_subsequences)\n\n    # If we can't generate enough unique subsequences\n    if m < k:\n        return -1\n    \n    # Calculate the minimum cost\n    total_cost = 0\n    # We can generate the subsequences of lengths from 0 to n\n    # Collecting costs for all possible lengths\n    costs = [0] * (n + 1)\n    \n    for length in range(n + 1):\n        costs[length] = n - length  # Cost of length 'length' subsequence\n    \n    # We need to take k unique subsequences\n    # We can take sequences of length 0 to n\n    for length in range(n + 1):\n        if k <= 0:\n            break\n        count = min(k, m * (1 << (n - length)))  # Number of subsequences of this length\n        total_cost += count * costs[length]\n        k -= count\n    \n    return total_cost\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict\n    \n    # Build the graph\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    # Check if vertex 1 has enough neighbors\n    if len(graph[1]) < D:\n        print(\"NO\")\n        return\n    \n    # Prepare to collect the spanning tree edges\n    spanning_tree_edges = []\n    visited = set()\n    \n    # Start with vertex 1\n    visited.add(1)\n    \n    # Add edges from vertex 1 to its D neighbors\n    for i in range(D):\n        neighbor = graph[1][i]\n        spanning_tree_edges.append((1, neighbor))\n        visited.add(neighbor)\n\n    # Now we need to add edges from other vertices\n    # Use DFS or BFS to add edges to the spanning tree\n    def dfs(v):\n        for u in graph[v]:\n            if u not in visited:\n                visited.add(u)\n                spanning_tree_edges.append((v, u))\n                dfs(u)\n    \n    # Start DFS from one of the neighbors of 1\n    dfs(graph[1][0])\n    \n    # Check if we have exactly n-1 edges\n    if len(spanning_tree_edges) == n - 1:\n        print(\"YES\")\n        for v, u in spanning_tree_edges:\n            print(v, u)\n    else:\n        print(\"NO\")\n\n# Read input\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nfind_spanning_tree(n, m, D, edges)\n```",
    "70": "```python\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Convert start and end times into total minutes\nstart_minutes = h1 * 60 + m1\nend_minutes = h2 * 60 + m2\n\n# Calculate the midpoint in total minutes\nmid_minutes = (start_minutes + end_minutes) // 2\n\n# Convert back to hours and minutes\nh3 = mid_minutes // 60\nm3 = mid_minutes % 60\n\n# Print the result in the required format\nprint(f'{h3:02}:{m3:02}')\n```",
    "71": "```python\na = int(input())\noutput = (a - 1).bit_length()\nprint(output)\n```",
    "72": "```python\ndef maximal_intersection_after_removal(n, segments):\n    # Separate left and right endpoints\n    lefts = [seg[0] for seg in segments]\n    rights = [seg[1] for seg in segments]\n    \n    # Calculate prefix and suffix max and min\n    prefix_max_right = [0] * n\n    suffix_max_right = [0] * n\n    prefix_min_left = [0] * n\n    suffix_min_left = [0] * n\n    \n    prefix_max_right[0] = rights[0]\n    prefix_min_left[0] = lefts[0]\n    \n    for i in range(1, n):\n        prefix_max_right[i] = max(prefix_max_right[i-1], rights[i])\n        prefix_min_left[i] = min(prefix_min_left[i-1], lefts[i])\n    \n    suffix_max_right[n-1] = rights[n-1]\n    suffix_min_left[n-1] = lefts[n-1]\n    \n    for i in range(n-2, -1, -1):\n        suffix_max_right[i] = max(suffix_max_right[i+1], rights[i])\n        suffix_min_left[i] = min(suffix_min_left[i+1], lefts[i])\n    \n    max_length = 0\n    \n    for i in range(n):\n        if i == 0:\n            max_right = suffix_max_right[1]\n            min_left = suffix_min_left[1]\n        elif i == n - 1:\n            max_right = prefix_max_right[n - 2]\n            min_left = prefix_min_left[n - 2]\n        else:\n            max_right = max(prefix_max_right[i-1], suffix_max_right[i+1])\n            min_left = min(prefix_min_left[i-1], suffix_min_left[i+1])\n        \n        intersection_length = max(0, max_right - min_left)\n        max_length = max(max_length, intersection_length)\n    \n    return max_length\n\n# Read input\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = maximal_intersection_after_removal(n, segments)\nprint(result)\n```",
    "73": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the maximum height of the wall\nmax_height = max(a)\n\n# Check if all parts can reach the maximum height without gaps\nfor height in a:\n    if height < max_height and (height + 1) not in a:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    unique_subsequences = set()\n    \n    # Generate all unique subsequences using a bitmask approach\n    for i in range(1 << n):\n        subsequence = []\n        for j in range(n):\n            if i & (1 << j):\n                subsequence.append(s[j])\n        unique_subsequences.add(''.join(subsequence))\n    \n    # If the number of unique subsequences is less than k, return -1\n    if len(unique_subsequences) < k:\n        return -1\n    \n    # Calculate the minimum cost\n    costs = []\n    for subseq in unique_subsequences:\n        cost = n - len(subseq)\n        costs.append(cost)\n    \n    # Sort costs and take the sum of the smallest k costs\n    costs.sort()\n    return sum(costs[:k])\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Calculate and print the result\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Full week consumption\n    week_consumption = [2, 1, 1]  # fish, rabbit, chicken for Mon, Tue, Wed, Thu, Fri, Sat, Sun\n    week_days = 7\n\n    # Calculate full weeks we can sustain\n    full_weeks = min(a // week_consumption[0], b // week_consumption[1], c // week_consumption[2])\n    days = full_weeks * week_days\n\n    # Remaining food after full weeks\n    a -= full_weeks * week_consumption[0]\n    b -= full_weeks * week_consumption[1]\n    c -= full_weeks * week_consumption[2]\n\n    # Check starting from each day of the week to maximize days\n    max_additional_days = 0\n    for start_day in range(week_days):\n        remaining_a, remaining_b, remaining_c = a, b, c\n        additional_days = 0\n        for day in range(week_days):\n            current_day = (start_day + day) % week_days\n            if current_day in [0, 3, 6]:  # Fish food days\n                if remaining_a > 0:\n                    remaining_a -= 1\n                    additional_days += 1\n                else:\n                    break\n            elif current_day in [1, 5]:  # Rabbit stew days\n                if remaining_b > 0:\n                    remaining_b -= 1\n                    additional_days += 1\n                else:\n                    break\n            else:  # Chicken stake days\n                if remaining_c > 0:\n                    remaining_c -= 1\n                    additional_days += 1\n                else:\n                    break\n\n        max_additional_days = max(max_additional_days, additional_days)\n\n    return days + max_additional_days\n\n# Read input\na, b, c = map(int, input().split())\nprint(max_days(a, b, c))\n```",
    "76": "```python\ndef can_construct_symmetric_square(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        possible = False\n        for i in range(n):\n            for j in range(n):\n                if tiles[i][0][1] == tiles[j][1][0] and tiles[i][1][1] == tiles[j][0][0]:\n                    possible = True\n                    break\n            if possible:\n                break\n        \n        results.append(\"YES\" if possible else \"NO\")\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        top = list(map(int, input().split()))\n        bottom = list(map(int, input().split()))\n        tiles.append((top, bottom))\n    test_cases.append((n, m, tiles))\n\n# Processing and output\nresults = can_construct_symmetric_square(t, test_cases)\nfor result in results:\n    print(result)\n```",
    "77": "```python\ndef minimum_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nn = int(input())\nprint(minimum_difference(n))\n```",
    "78": "```python\ndef count_regular_sequences(n, s):\n    MOD = 1000000007\n    m = len(s)\n    \n    # Precompute Catalan numbers up to 2n\n    catalan = [0] * (n + 1)\n    catalan[0] = 1\n    for i in range(1, n + 1):\n        catalan[i] = 0\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - 1 - j]\n            catalan[i] %= MOD\n            \n    # Check validity of s\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return 0\n            \n    if balance + (n - (m - balance)) < 0:\n        return 0\n    \n    # Count valid sequences by placing s in various positions\n    result = 0\n    for start in range(n - (m // 2) + 1):\n        left_needed = (m // 2) + start\n        right_needed = n - left_needed\n        if left_needed < 0 or right_needed < 0:\n            continue\n            \n        result += (catalan[left_needed] * catalan[right_needed]) % MOD\n        result %= MOD\n        \n    return result\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result and print it\nresult = count_regular_sequences(n, s)\nprint(result)\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    len_s = len(s)\n    \n    # To form a number divisible by 25, we need the last two digits to be 00, 25, 50, or 75\n    targets = ['00', '25', '50', '75']\n    \n    min_moves = float('inf')\n    \n    for target in targets:\n        # The last two digits we want\n        last_digit = target[1]\n        second_last_digit = target[0]\n        \n        # Find the position of the last digit from the end\n        last_digit_index = -1\n        for i in range(len_s - 1, -1, -1):\n            if s[i] == last_digit:\n                last_digit_index = i\n                break\n        \n        # If we couldn't find the last digit, continue to the next target\n        if last_digit_index == -1:\n            continue\n        \n        # Now we need to find the second last digit before the last digit\n        second_last_digit_index = -1\n        for i in range(last_digit_index - 1, -1, -1):\n            if s[i] == second_last_digit:\n                second_last_digit_index = i\n                break\n        \n        # If we couldn't find the second last digit, continue to the next target\n        if second_last_digit_index == -1:\n            continue\n        \n        # Calculate moves to bring second last digit to the position before last digit\n        moves = (last_digit_index - second_last_digit_index) + (last_digit_index - (second_last_digit_index + 1))\n        \n        min_moves = min(min_moves, moves)\n    \n    return min_moves if min_moves != float('inf') else -1\n\n# Input\nn = int(input().strip())\n# Output\nprint(min_moves_to_divisible_by_25(n))\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    # Create a list to store the colors\n    color = [0] * n\n    # Create a dictionary to store last positions of each character\n    last_position = {}\n    \n    # Iterate through the string to assign colors\n    for i in range(n):\n        char = s[i]\n        if char in last_position:\n            # Determine the color to use for this character\n            color[i] = (last_position[char] + 1) % (max_color + 1)\n        else:\n            color[i] = 1  # Start new color\n        last_position[char] = color[i]  # Update last position for this character\n\n    # Calculate the maximum color used\n    max_color = max(color)\n\n    # Output the result\n    print(max_color)\n    print(' '.join(map(str, color)))\n\n# Input reading\nn = int(input())\ns = input()\n\nmin_colors_to_sort(n, s)\n```",
    "81": "```python\ndef can_reorder_strings(strings):\n    # Sort strings by length\n    strings.sort(key=len)\n    \n    for i in range(1, len(strings)):\n        # Check if the current string is a substring of the next one\n        if strings[i-1] not in strings[i]:\n            return \"NO\"\n    \n    return \"YES\\n\" + \"\\n\".join(strings)\n\n# Input reading\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\n# Get the result and print it\nresult = can_reorder_strings(strings)\nprint(result)\n```",
    "82": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncount = 0\n\n# Solve from the left\nwhile count < n and a[count] <= k:\n    count += 1\n\n# Solve from the right\nwhile count < n and a[n - 1 - (count - (n - len(a)))] <= k:\n    count += 1\n\n# Calculate the total problems solved\nresult = count - (n - count)\nprint(result)\n```",
    "83": "```python\ndef min_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n    \n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            for (w, h) in [(width, height), (height, width)]:\n                if (w * h == total_tiles):\n                    # Check if we can form rectangles for red and blue\n                    for red_width in range(1, int(a**0.5) + 1):\n                        if a % red_width == 0:\n                            red_height = a // red_width\n                            if (red_width <= w and red_height <= h) or (red_height <= w and red_width <= h):\n                                for blue_width in range(1, int(b**0.5) + 1):\n                                    if b % blue_width == 0:\n                                        blue_height = b // blue_width\n                                        if (blue_width <= w and blue_height <= h) or (blue_height <= w and blue_width <= h):\n                                            perimeter = 2 * (w + h)\n                                            min_perimeter = min(min_perimeter, perimeter)\n    \n    return min_perimeter\n\n# Read input\na, b = map(int, input().split())\n# Output the result\nprint(min_perimeter(a, b))\n```",
    "84": "```python\ndef can_color_string(n, s):\n    last_seen = {}\n    for i, char in enumerate(s):\n        if char in last_seen:\n            if last_seen[char] % 2 == i % 2:\n                return \"NO\", \"\"\n        last_seen[char] = i\n    \n    coloring = []\n    for i in range(n):\n        if s[i] in last_seen:\n            coloring.append(str(last_seen[s[i]] % 2))\n        else:\n            coloring.append('0')\n            last_seen[s[i]] = i\n    \n    return \"YES\", ''.join(coloring)\n\nn = int(input())\ns = input().strip()\n\nresult, color_string = can_color_string(n, s)\nprint(result)\nif result == \"YES\":\n    print(color_string)\n```",
    "85": "```python\nimport sys\nimport math\n\nA, B = map(int, sys.stdin.read().strip().split())\n\ndef find_price(A, B):\n    for price in range(1, 10000):  # Set a reasonable upper limit\n        tax_8 = math.floor(price * 0.08)\n        tax_10 = math.floor(price * 0.10)\n        if tax_8 == A and tax_10 == B:\n            return price\n    return -1\n\nresult = find_price(A, B)\nprint(result)\n```",
    "86": "```python\ndef solve_training(n, k):\n    # Minimum required problems to satisfy the conditions\n    min_problems = (k * (k + 1)) // 2\n    max_problems = 0\n    a = []\n\n    if n < min_problems:\n        print(\"NO\")\n        return\n\n    # Start with the minimum possible problems per day\n    for i in range(1, k + 1):\n        a.append(i)\n        max_problems += i\n\n    # Calculate the extra problems we can distribute\n    extra_problems = n - max_problems\n\n    # Distribute the extra problems\n    for i in range(k - 1, -1, -1):\n        if extra_problems <= 0:\n            break\n        # The maximum we can add to a[i] is capped by the rules\n        max_increase = min(extra_problems, (a[i] * 2) - a[i])\n        a[i] += max_increase\n        extra_problems -= max_increase\n\n    # Check if we have distributed exactly n problems\n    if sum(a) == n:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n    else:\n        print(\"NO\")\n\n# Read input\nn, k = map(int, input().split())\nsolve_training(n, k)\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects by their required rating\n    projects.sort(key=lambda x: (x[0], x[1]))\n    \n    completed_projects = 0\n    current_rating = r\n    \n    for a, b in projects:\n        if current_rating >= a:  # Can attempt this project\n            completed_projects += 1\n            current_rating += b  # Update current rating after completing the project\n            if current_rating < 0:  # If rating falls below zero, stop\n                break\n    \n    return completed_projects\n\n# Read input\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = max_projects(n, r, projects)\nprint(result)\n```",
    "88": "```python\ndef can_construct_palindromic_matrix(n, nums):\n    from collections import Counter\n    \n    count = Counter(nums)\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Count how many of each number we have\n    odd_count = 0\n    center_value = None\n    \n    for value, cnt in count.items():\n        if cnt % 4 != 0:\n            if cnt % 4 == 2:\n                odd_count += 1\n            elif cnt % 4 == 1:\n                odd_count += 1\n                center_value = value\n            odd_count += cnt // 4\n        else:\n            odd_count += cnt // 4\n            \n    if (n % 2 == 1 and odd_count > 1) or (n % 2 == 0 and odd_count > 0):\n        return \"NO\"\n\n    # Fill the matrix in a palindromic way\n    i, j = 0, 0\n    for value, cnt in count.items():\n        while cnt > 0:\n            if i < n // 2:\n                matrix[i][j] = value\n                matrix[n - 1 - i][j] = value\n                matrix[i][n - 1 - j] = value\n                matrix[n - 1 - i][n - 1 - j] = value\n                cnt -= 4\n                if j < n - 1:\n                    j += 1\n                else:\n                    j = 0\n                    i += 1\n            else:\n                if n % 2 == 1 and i == n // 2 and j == n // 2:\n                    matrix[i][j] = center_value\n                    cnt -= 1\n                break\n\n    return \"YES\", matrix\n\n# Read input\nn = int(input())\nnums = list(map(int, input().split()))\n\nresult = can_construct_palindromic_matrix(n, nums)\n\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for row in result[1]:\n        print(\" \".join(map(str, row)))\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects based on the required rating\n    projects.sort(key=lambda x: x[0])  # Sort by a_i (required rating)\n    \n    for a, b in projects:\n        if r < a:  # If current rating is less than required rating for the project\n            return \"NO\"\n        r += b  # Update rating after completing the project\n        if r < 0:  # If rating falls below 0\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if all projects can be completed\nresult = can_complete_projects(n, r, projects)\nprint(result)\n```",
    "90": "```python\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculate the total length required for the platforms including gaps\ntotal_length = sum(c) + (m - 1)\n\n# Maximum reach from the first position (0)\nmax_reach = d * (total_length // d)\n\nif total_length > n or max_reach < n:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    a = [0] * n\n    position = 0\n\n    for i in range(m):\n        for j in range(c[i]):\n            if position < n:\n                a[position] = i + 1\n                position += 1\n        if i < m - 1:\n            position += 1  # Leave a gap of at least 1 cell between platforms\n\n    print(\" \".join(map(str, a)))\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n    \n    # Create arrays to store the first position of each character in t\n    left = [-1] * m\n    right = [-1] * m\n\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n\n    max_length = 0\n\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n\n    max_length = max(max_length, right[0] + (n - left[m - 1] - 1))\n\n    return max_length\n\ns = input().strip()\nt = input().strip()\nprint(max_removable_length(s, t))\n```",
    "92": "```python\nx = float(input().strip())\n\n# Scale x to a range that fits into integers 1 to 10\n# We can use a simple transformation\na = int((x * 10) % 10) + 1\nb = int((x * 10) // 10) + 1\n\n# Ensure both are in the range of 1 to 10\nif a < 1:\n    a = 1\nif b < 1:\n    b = 1\nif a > 10:\n    a = 10\nif b > 10:\n    b = 10\n\nprint(a, b)\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    # Check impossible conditions\n    if d > 2 * (k - 1) + 1:\n        return \"NO\"\n    \n    # Check if k is too low to create any valid tree with the required diameter\n    if k == 1 and n > 1:\n        return \"NO\"\n    \n    # Build the tree\n    edges = []\n    \n    # Create a base path for the diameter\n    for i in range(d):\n        edges.append((i + 1, i + 2))\n    \n    # Now we need to connect the remaining vertices\n    current_vertex = d + 2\n    \n    # List of available vertices to connect to the main path\n    available_vertices = list(range(1, d + 2))\n    \n    for vertex in available_vertices:\n        # Connect up to k-1 new vertices to this vertex\n        for _ in range(k - 1):\n            if current_vertex <= n:\n                edges.append((vertex, current_vertex))\n                current_vertex += 1\n            else:\n                break\n\n    # Check if we used all vertices\n    if current_vertex - 1 < n:\n        return \"NO\"\n    \n    # If we have a valid configuration, return the edges\n    result = [\"YES\"]\n    result.extend(f\"{u} {v}\" for u, v in edges)\n    return \"\\n\".join(result)\n\n# Read input\nn, d, k = map(int, input().split())\noutput = construct_tree(n, d, k)\nprint(output)\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Initialize an empty string\n    s = []\n    \n    # Determine which character to start with based on the number of 0s and 1s\n    if a > b:\n        start = '0'\n    else:\n        start = '1'\n    \n    # We need to create x transitions\n    # If x is odd, we will finish with the opposite character\n    transition = 0\n    while a > 0 or b > 0:\n        if (transition % 2 == 0 and a > 0) or b == 0:\n            s.append('0')\n            a -= 1\n        else:\n            s.append('1')\n            b -= 1\n        \n        # Increase the transition count\n        if a > 0 and b > 0:\n            transition += 1\n    \n    # If we have used all transitions but still have characters left, fill them\n    while a > 0:\n        s.append('0')\n        a -= 1\n    while b > 0:\n        s.append('1')\n        b -= 1\n    \n    # Adjust the string to have exactly x transitions\n    result = []\n    for i in range(len(s)):\n        result.append(s[i])\n        if i < len(s) - 1 and s[i] != s[i + 1]:\n            transition -= 1\n        if transition < 0:\n            break\n    \n    # If we have more transitions than needed, we can adjust the last part\n    while transition < 0 and len(result) > 1:\n        if result[-1] == '0':\n            result[-1] = '1'\n        else:\n            result[-1] = '0'\n        transition += 1\n    \n    print(''.join(result))\n\n# Read input values\na, b, x = map(int, input().split())\nconstruct_binary_string(a, b, x)\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Create a base string with n 'a's, n 'b's, and n 'c's\n    base_string = 'a' * n + 'b' * n + 'c' * n\n    # Check for forbidden substrings and try to rearrange\n    from itertools import permutations\n\n    # Generate all permutations of the base string\n    for perm in set(permutations(base_string)):\n        candidate = ''.join(perm)\n        if s not in candidate and t not in candidate:\n            return \"YES\\n\" + candidate\n            \n    return \"NO\"\n\n# Read input\nn = int(input())\ns = input().strip()\nt = input().strip()\n\n# Generate and print result\nresult = generate_string(n, s, t)\nprint(result)\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    # Initialize the permutation array\n    p = [0] * n\n    # Start with p[0] as an unknown, we will calculate it later\n    sum_q = 0\n    \n    # Calculate p[i] based on the differences in q\n    for i in range(1, n):\n        sum_q += q[i - 1]\n        p[i] = sum_q\n    \n    # Now, we need to find a suitable p[0]\n    min_p = min(p)\n    # p[0] should be 1 - min_p to ensure the smallest number is 1\n    p[0] = 1 - min_p\n    \n    # Generate the full permutation\n    for i in range(1, n):\n        p[i] += p[0]\n    \n    # Check if the generated permutation is valid\n    if len(set(p)) == n and all(1 <= num <= n for num in p):\n        print(' '.join(map(str, p)))\n    else:\n        print(-1)\n\n# Read inputs\nn = int(input())\nq = list(map(int, input().split()))\n\n# Call the function\nrestore_permutation(n, q)\n```",
    "97": "```python\ndef min_coins_to_move_chips(n, chips):\n    even_count = sum(1 for x in chips if x % 2 == 0)\n    odd_count = n - even_count\n    return min(even_count, odd_count)\n\n# Input reading\nn = int(input())\nchips = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_coins_to_move_chips(n, chips))\n```",
    "98": "```python\ndef min_moves_to_N(N):\n    moves = float('inf')\n    \n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            moves = min(moves, i + j - 2)\n    \n    return moves\n\nN = int(input().strip())\nprint(min_moves_to_N(N))\n```",
    "99": "```python\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\n# Maximum wins calculation\nmax_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n\n# Minimum wins calculation\n# Calculate losses\nalice_losses = max(0, a1 - b3) + max(0, a2 - b1) + max(0, a3 - b2)\nbob_losses = max(0, b1 - a3) + max(0, b2 - a1) + max(0, b3 - a2)\n\nmin_wins = max(0, n - alice_losses - bob_losses)\n\nprint(min_wins, max_wins)\n```"
}