{
    "4": "```python\ndef is_lucky(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef time_before(hh, mm, x):\n    mm -= x\n    if mm < 0:\n        mm += 60\n        hh -= 1\n        if hh < 0:\n            hh += 24\n    return hh, mm\n\nx = int(input())\nhh, mm = map(int, input().split())\n\ny = 0\nwhile not is_lucky(hh, mm):\n    hh, mm = time_before(hh, mm, x)\n    y += 1\n\nprint(y)\n```",
    "2": "```python\nn = int(input())\n\ndef is_lucky(year):\n    return str(year).count('0') + len(set(str(year))) <= 2\n\nnext_year = n + 1\nwhile not is_lucky(next_year):\n    next_year += 1\n\nprint(next_year - n)\n```",
    "0": "```python\ndef max_length_accordion(s):\n    n = len(s)\n    left_bracket = -1\n    right_bracket = -1\n    colon_count = 0\n    vertical_count = 0\n    \n    for i in range(n):\n        if s[i] == '[':\n            left_bracket = i\n            break\n            \n    for i in range(n - 1, -1, -1):\n        if s[i] == ']':\n            right_bracket = i\n            break\n            \n    if left_bracket == -1 or right_bracket == -1 or left_bracket >= right_bracket:\n        return -1\n    \n    for i in range(left_bracket, right_bracket + 1):\n        if s[i] == ':':\n            colon_count += 1\n        elif s[i] == '|':\n            vertical_count += 1\n            \n    if colon_count < 2:\n        return -1\n    \n    # The maximum length of the accordion is 2 colons + vertical lines\n    return 2 + vertical_count\n\ns = input().strip()\nprint(max_length_accordion(s))\n```",
    "5": "```python\nn, pos, l, r = map(int, input().split())\n\nif l == 1 and r == n:\n    print(0)\nelse:\n    moves = 0\n    if pos < l:\n        moves += l - pos  # Move to l\n        moves += 1  # Close to the left\n    elif pos > r:\n        moves += pos - r  # Move to r\n        moves += 1  # Close to the right\n    else:\n        # If pos is between l and r\n        left_moves = (pos - l) + 1  # Move to l and close left\n        right_moves = (r - pos) + 1  # Move to r and close right\n        moves += min(left_moves, right_moves)\n\n    print(moves)\n```",
    "1": "```python\ndef max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n    \n    # Start with the original number\n    max_sum = sum(int(d) for d in str_x)\n    best_number = x\n    \n    # Check numbers by reducing digits\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit and setting all following digits to 9\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        new_number = int(new_number)\n        \n        if new_number > 0:\n            current_sum = sum(int(d) for d in str(new_number))\n            if current_sum > max_sum or (current_sum == max_sum and new_number > best_number):\n                max_sum = current_sum\n                best_number = new_number\n    \n    return best_number\n\nx = int(input())\nprint(max_digit_sum(x))\n```",
    "10": "```python\nn = int(input())\n\n# Calculate the number of complete weeks and remaining days\nweeks = n // 7\nremaining_days = n % 7\n\n# Maximum days off is the total days off in complete weeks plus the days off in remaining days\nmax_days_off = weeks * 2 + min(remaining_days, 2)\n\n# Minimum days off is determined by the number of complete weeks\n# If there are remaining days, they can be either work days or days off\nmin_days_off = 0 if remaining_days < 5 else remaining_days - 5\n\nprint(min_days_off, max_days_off)\n```",
    "9": "```python\nd = int(input())\nn, m = map(int, input().split())\nsofas = []\n\nfor i in range(d):\n    x1, y1, x2, y2 = map(int, input().split())\n    sofas.append((x1, y1, x2, y2))\n\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\ndef count_sofas(sofa, sofas):\n    x1, y1, x2, y2 = sofa\n    left = right = top = bottom = 0\n    \n    for other in sofas:\n        if other == sofa:\n            continue\n        ox1, oy1, ox2, oy2 = other\n        if x1 == x2:  # vertical sofa\n            if y2 < oy1:  # sofa is to the top\n                top += 1\n            elif oy2 < y1:  # sofa is to the bottom\n                bottom += 1\n        else:  # horizontal sofa\n            if x2 < ox1:  # sofa is to the left\n                left += 1\n            elif ox2 < x1:  # sofa is to the right\n                right += 1\n\n    return left, right, top, bottom\n\nfor i in range(d):\n    left, right, top, bottom = count_sofas(sofas[i], sofas)\n    if (left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b):\n        print(i + 1)\n        break\nelse:\n    print(-1)\n```",
    "8": "```python\ndef min_tiles_to_draw(tiles):\n    from collections import Counter\n\n    # Count occurrences of each tile\n    counts = Counter(tiles)\n    \n    # Check for koutsu (triplet)\n    for tile, count in counts.items():\n        if count == 3:\n            return 0  # Already has a koutsu\n\n    # Check for shuntsu (sequence)\n    suits = {'m': [], 'p': [], 's': []}\n    for tile in tiles:\n        number = int(tile[0])\n        suit = tile[1]\n        suits[suit].append(number)\n\n    # Sort the numbers in each suit\n    for suit in suits:\n        suits[suit].sort()\n\n    # Check for existing shuntsu\n    for suit in suits:\n        for i in range(len(suits[suit]) - 2):\n            if suits[suit][i] + 1 == suits[suit][i + 1] and suits[suit][i] + 2 == suits[suit][i + 2]:\n                return 0  # Already has a shuntsu\n\n    # Check how many tiles are needed to form a shuntsu\n    needed_tiles = 2  # Start with the maximum needed to form a shuntsu\n\n    for suit in suits:\n        for number in suits[suit]:\n            # Check for the possibility of forming a shuntsu with one tile drawn\n            if number - 1 in suits[suit] and number + 1 in suits[suit]:\n                return 1  # Can form a shuntsu with one tile drawn\n            if number - 1 not in suits[suit] and number + 1 not in suits[suit]:\n                needed_tiles = min(needed_tiles, 2)  # Need two tiles to form a shuntsu\n            else:\n                needed_tiles = min(needed_tiles, 1)  # Need one tile to form a shuntsu\n\n    return needed_tiles\n\n# Input reading\ntiles = input().strip().split()\nprint(min_tiles_to_draw(tiles))\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    for query in queries:\n        n, x, blows = query\n        min_blow_count = float('inf')\n        possible = False\n        \n        for d, h in blows:\n            if d >= x:\n                # If we can defeat Zmei Gorynich in one blow\n                min_blow_count = min(min_blow_count, 1)\n                possible = True\n            else:\n                # Calculate the effective heads after one blow\n                effective_heads = x - d + h\n                if effective_heads > 0:\n                    # Calculate how many blows are needed to reduce heads to 0\n                    # We need to reduce effective_heads to 0\n                    # Each blow reduces by d and adds h\n                    # So we need to find how many blows are needed\n                    blows_needed = (effective_heads + (d - h) - 1) // (d - h) + 1\n                    min_blow_count = min(min_blow_count, blows_needed)\n                    possible = True\n        \n        if possible:\n            results.append(min_blow_count)\n        else:\n            results.append(-1)\n    \n    return results\n\n# Example usage:\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\nresults = min_blows_to_defeat_zmei(t, queries)\nfor result in results:\n    print(result)\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "7": "```python\ndef day_when_barn_empty(n, m):\n    day = 0\n    total_eaten = 0\n    current_grains = n\n\n    while current_grains > 0:\n        day += 1\n        total_eaten += day\n        current_grains += m\n        if current_grains > n:\n            current_grains = n\n        current_grains -= total_eaten\n\n    return day\n\n# Read input\nn, m = map(int, input().split())\nprint(day_when_barn_empty(n, m))\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelse:\n    print(n + k - t)\n```",
    "16": "```python\ncnt1 = int(input())\ncnt2 = int(input())\ncnt3 = int(input())\ncnt4 = int(input())\n\n# Check the conditions for forming a regular bracket sequence\nif cnt1 + cnt2 >= cnt3 + cnt4 and cnt1 <= cnt3 + 1:\n    print(1)\nelse:\n    print(0)\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    count_a = n // a\n    count_b = n // b\n    count_ab = n // (a * b // gcd(a, b))\n    \n    # Calculate chocolates if we paint Red first\n    chocolates_red_first = (count_a - count_ab) * p + (count_b - count_ab) * q + count_ab * max(p, q)\n    \n    # Calculate chocolates if we paint Blue first\n    chocolates_blue_first = (count_b - count_ab) * q + (count_a - count_ab) * p + count_ab * max(p, q)\n    \n    return max(chocolates_red_first, chocolates_blue_first)\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n# Example usage\nn, a, b, p, q = map(int, input().split())\nprint(max_chocolates(n, a, b, p, q))\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    max_length = 0\n    current_length = 0\n    segments = []\n    \n    # Count segments of golden trophies\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n    if current_length > 0:\n        segments.append(current_length)\n    \n    # If there are no golden trophies\n    if not segments:\n        return 0\n    \n    # Calculate the maximum length without any swap\n    max_length = max(segments)\n    \n    # Check if we can increase the length by swapping\n    for i in range(len(segments) - 1):\n        # If we swap a silver trophy between two segments of golden trophies\n        max_length = max(max_length, segments[i] + segments[i + 1])\n    \n    # If there are silver trophies, we can also consider adding one more golden trophy\n    if 'S' in trophies:\n        max_length += 1\n    \n    return max_length\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\nprint(max_beauty_after_swap(n, trophies))\n```",
    "14": "```python\ndef stack_sortable_permutation(n, k, p):\n    # Initialize the set of used numbers and the stack\n    used = set(p)\n    stack = []\n    result = p[:]\n    \n    # The next number to add to the permutation\n    next_num = n\n    \n    # Iterate over the first k elements\n    for i in range(k):\n        # While we can push numbers to the stack\n        while next_num > 0 and next_num not in used:\n            stack.append(next_num)\n            next_num -= 1\n        \n        # If the stack is not empty and the top of the stack is greater than the current element\n        while stack and stack[-1] > result[i]:\n            result.append(stack.pop())\n    \n    # After processing the first k elements, we need to fill the rest of the permutation\n    while next_num > 0:\n        if next_num not in used:\n            stack.append(next_num)\n        next_num -= 1\n    \n    # Now pop all remaining elements from the stack\n    while stack:\n        result.append(stack.pop())\n    \n    # Check if the result is stack-sortable\n    if len(result) != n:\n        return -1\n    \n    # Check if the result is valid\n    if len(set(result)) != n or sorted(result) != list(range(1, n + 1)):\n        return -1\n    \n    return result\n\n# Input reading\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result\nresult = stack_sortable_permutation(n, k, p)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "21": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_index = a.index(1)\nmax_index = a.index(n)\n\n# Calculate the current distance\ncurrent_distance = abs(min_index - max_index)\n\n# Calculate the maximum possible distance after one swap\nmax_distance = max(min_index, max_index, n - 1 - min_index, n - 1 - max_index)\n\nprint(max_distance)\n```",
    "18": "```python\ndef lexicographically_minimal_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        while t and (not u or t[-1] <= u[-1]):\n            u.append(t.pop())\n    \n    return ''.join(u)\n\ns = input().strip()\nprint(lexicographically_minimal_string(s))\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    # Create an array to count the coverage of each section\n    coverage = [0] * (n + 1)\n\n    # Count the coverage for each painter\n    for l, r in painters:\n        for i in range(l, r + 1):\n            coverage[i] += 1\n\n    # Calculate the total painted sections with all painters\n    total_painted = sum(1 for i in range(1, n + 1) if coverage[i] > 0)\n\n    # If we hire q - 2 painters, we need to find the two painters to exclude\n    max_painted = total_painted\n\n    # Try excluding each pair of painters\n    for i in range(q):\n        for j in range(i + 1, q):\n            # Create a temporary coverage array\n            temp_coverage = coverage[:]\n            l1, r1 = painters[i]\n            l2, r2 = painters[j]\n\n            # Remove the coverage of the excluded painters\n            for k in range(l1, r1 + 1):\n                temp_coverage[k] -= 1\n            for k in range(l2, r2 + 1):\n                temp_coverage[k] -= 1\n\n            # Calculate the painted sections after excluding these two painters\n            painted_after_exclusion = sum(1 for k in range(1, n + 1) if temp_coverage[k] > 0)\n            max_painted = max(max_painted, painted_after_exclusion)\n\n    return max_painted\n\n# Input reading\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Get the result and print it\nresult = max_painted_sections(n, q, painters)\nprint(result)\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return minutes_passed\n\ntime_input = input().strip()\nhh, mm = map(int, time_input.split(':'))\nresult = next_palindrome_time(hh, mm)\nprint(result)\n```",
    "19": "```python\ndef check_records(test_cases):\n    results = []\n    for case in test_cases:\n        n, stats = case\n        valid = True\n        for i in range(n):\n            p_i, c_i = stats[i]\n            if i > 0:\n                p_prev, c_prev = stats[i - 1]\n                if p_i < p_prev or c_i < c_prev or c_i > p_i:\n                    valid = False\n                    break\n                if c_i - c_prev > p_i - p_prev:\n                    valid = False\n                    break\n        results.append(\"YES\" if valid else \"NO\")\n    return results\n\n# Read input\nT = int(input())\ntest_cases = []\nfor _ in range(T):\n    n = int(input())\n    stats = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, stats))\n\n# Get results and print\nresults = check_records(test_cases)\nfor result in results:\n    print(result)\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a, b):\n    from itertools import permutations\n\n    a_str = str(a)\n    b_str = str(b)\n    \n    # Generate all unique permutations of the digits of a\n    permuted_numbers = set(int(''.join(p)) for p in permutations(a_str))\n    \n    # Filter out numbers that are greater than b and have the same length as a\n    valid_numbers = [num for num in permuted_numbers if num <= b and len(str(num)) == len(a_str)]\n    \n    # Return the maximum valid number\n    return max(valid_numbers)\n\n# Input\na = int(input().strip())\nb = int(input().strip())\n\n# Output\nprint(max_permutation_not_exceeding(a, b))\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef find_course_order(n, k, main_courses, dependencies):\n    # Create a graph and in-degree count\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n\n    # Fill the graph and in-degree based on dependencies\n    for i in range(1, n + 1):\n        t_i, *deps = dependencies[i - 1]\n        in_degree[i] = t_i\n        for dep in deps:\n            graph[dep].append(i)\n\n    # Queue for courses that can be taken (in-degree 0)\n    queue = deque()\n    for course in range(1, n + 1):\n        if in_degree[course] == 0:\n            queue.append(course)\n\n    order = []\n    taken_courses = set()\n\n    # Process the courses\n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        taken_courses.add(course)\n\n        for next_course in graph[course]:\n            in_degree[next_course] -= 1\n            if in_degree[next_course] == 0:\n                queue.append(next_course)\n\n    # Check if all main courses can be taken\n    for main in main_courses:\n        if main not in taken_courses:\n            return -1\n\n    # Collect the minimum courses needed\n    result_order = []\n    for course in order:\n        if course in main_courses or any(dep in taken_courses for dep in dependencies[course - 1][1:]):\n            result_order.append(course)\n\n    return len(result_order), result_order\n\n# Input reading\nn, k = map(int, input().split())\nmain_courses = list(map(int, input().split()))\ndependencies = [list(map(int, input().split())) for _ in range(n)]\n\n# Finding the course order\nresult = find_course_order(n, k, main_courses, dependencies)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    m, course_order = result\n    print(m)\n    print(' '.join(map(str, course_order)))\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror_chars = {'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M', 'O': 'O', 'o': 'o', 'p': 'q', 'q': 'p', 'R': 'R', 'S': 'S', 'T': 'T', 'U': 'U', 'v': 'v', 'V': 'V', 'W': 'W', 'X': 'X', 'x': 'x', 'Y': 'Y'}\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        if s[i] not in mirror_chars or mirror_chars[s[i]] != s[n - 1 - i]:\n            print(\"NIE\")\n            return\n    print(\"TAK\")\n\ns = input().strip()\nis_s_palindrome(s)\n```",
    "27": "```python\nn = int(input())\ns = input()\n\nmin_operations = n  # Start with the maximum operations needed (typing all characters)\n\n# Check for possible copy operations\nfor i in range(1, n):\n    if s[:i] == s[i:i+i]:  # Check if the prefix can be copied\n        # Calculate operations: type prefix + 1 copy + remaining characters\n        operations = i + 1 + (n - 2 * i)\n        min_operations = min(min_operations, operations)\n\nprint(min_operations)\n```",
    "30": "```python\ndef min_traps(m, x):\n    # Since GCD(x, m) = 1, the x-mouse will visit all rooms\n    # The number of unique rooms visited is equal to the number of steps\n    # it takes to return to the starting room, which is m.\n    # The number of traps needed is m - 1, but we can place a trap in room 0\n    # and then we need to cover the remaining m - 1 rooms.\n    \n    # The number of traps needed is m - 1 + 1 (for room 0)\n    return m\n\n# Read input\nm, x = map(int, input().split())\n# Output the result\nprint(min_traps(m, x))\n```",
    "24": "```python\ndef can_win(matrix):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # vertical, horizontal, diagonal down-right, diagonal down-left\n    n = 10\n\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == '.':\n                # Temporarily place 'X' in the empty cell\n                matrix[i][j] = 'X'\n                \n                for dx, dy in directions:\n                    count = 1\n                    \n                    # Check in the positive direction\n                    x, y = i + dx, j + dy\n                    while 0 <= x < n and 0 <= y < n and matrix[x][y] == 'X':\n                        count += 1\n                        x += dx\n                        y += dy\n                    \n                    # Check in the negative direction\n                    x, y = i - dx, j - dy\n                    while 0 <= x < n and 0 <= y < n and matrix[x][y] == 'X':\n                        count += 1\n                        x -= dx\n                        y -= dy\n                    \n                    if count >= 5:\n                        return 'YES'\n                \n                # Remove the temporary 'X'\n                matrix[i][j] = '.'\n\n    return 'NO'\n\n# Read input\nmatrix = [input().strip() for _ in range(10)]\nprint(can_win(matrix))\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    if k > n * (n + 1) // 2:\n        return -1\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k <= 0:\n            break\n        for j in range(i, n):\n            if k <= 0:\n                break\n            if i == j:\n                if k >= 1:\n                    matrix[i][j] = 1\n                    k -= 1\n            else:\n                if k >= 2:\n                    matrix[i][j] = 1\n                    matrix[j][i] = 1\n                    k -= 2\n    \n    return matrix\n\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "32": "```python\nn = int(input())\ncurrent_position = 0  # Position in kilometers from the North Pole (0 to 20000)\n\nfor _ in range(n):\n    t, direction = input().split()\n    t = int(t)\n\n    if current_position == 0 and direction != \"South\":\n        print(\"NO\")\n        exit()\n    if current_position == 20000 and direction != \"North\":\n        print(\"NO\")\n        exit()\n\n    if direction == \"South\":\n        current_position += t\n    elif direction == \"North\":\n        current_position -= t\n    elif direction == \"East\" or direction == \"West\":\n        # East and West do not change the position in terms of North-South\n        continue\n\n    if current_position < 0 or current_position > 20000:\n        print(\"NO\")\n        exit()\n\nif current_position != 0:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    low, high = 1, max(a, b)\n    while low < high:\n        mid = (low + high + 1) // 2\n        if (a // mid) + (b // mid) >= n:\n            low = mid\n        else:\n            high = mid - 1\n    return low\n\nn, a, b = map(int, input().split())\nprint(max_min_pieces(n, a, b))\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    diff = abs(sum_first - sum_second)\n    \n    # Calculate the maximum possible changes we can make\n    changes = []\n    if sum_first > sum_second:\n        # We need to decrease sum_first or increase sum_second\n        changes = [9 - digit for digit in first_half] + second_half\n    else:\n        # We need to decrease sum_second or increase sum_first\n        changes = first_half + [9 - digit for digit in second_half]\n    \n    changes.sort(reverse=True)\n    \n    count = 0\n    for change in changes:\n        diff -= change\n        count += 1\n        if diff <= 0:\n            break\n    \n    return count\n\n# Example usage:\nticket = input().strip()\nprint(min_replacements_to_lucky(ticket))\n```",
    "26": "```python\nimport math\n\n# Read input\nx, y, z = map(float, input().split())\n\n# Define the expressions and their corresponding representations\nexpressions = [\n    (x**(y**z), \"x^y^z\"),\n    (x**(z**y), \"x^z^y\"),\n    ((x**y)**z, \"(x^y)^z\"),\n    ((x**z)**y, \"(x^z)^y\"),\n    (y**(x**z), \"y^x^z\"),\n    (y**(z**x), \"y^z^x\"),\n    ((y**x)**z, \"(y^x)^z\"),\n    ((y**z)**x, \"(y^z)^x\"),\n    (z**(x**y), \"z^x^y\"),\n    (z**(y**x), \"z^y^x\"),\n    ((z**x)**y, \"(z^x)^y\"),\n    ((z**y)**x, \"(z^y)^x\"),\n]\n\n# Find the maximum value and its index\nmax_value = -math.inf\nmax_index = -1\n\nfor i, (value, representation) in enumerate(expressions):\n    if value > max_value:\n        max_value = value\n        max_index = i\n\n# Output the corresponding expression\nprint(expressions[max_index][1])\n```",
    "37": "```python\ndef can_deal_exact_damage(a, b, c):\n    for x in range(c // a + 1):\n        if (c - a * x) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Input\na, b, c = map(int, input().split())\nprint(can_deal_exact_damage(a, b, c))\n```",
    "31": "```python\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef mod_inv(a, p):\n    return pow(a, p - 2, p)\n\ndef birthday_paradox(n, k):\n    MOD = 1000003\n    days = 1 << n  # 2^n\n    if k > days:\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the probability of no collisions\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator *= (days - i)\n        denominator *= days\n        numerator %= MOD\n        denominator %= MOD\n\n    # Probability of at least one collision\n    A = (denominator - numerator) % MOD\n    B = denominator % MOD\n\n    # Reduce A/B to irreducible form\n    common_gcd = gcd(A, B)\n    A //= common_gcd\n    B //= common_gcd\n\n    return A % MOD, B % MOD\n\n# Read input\nn, k = map(int, input().split())\nA, B = birthday_paradox(n, k)\nprint(A, B)\n```",
    "35": "```python\nn, m = map(int, input().split())\nflag = [input().strip() for _ in range(n)]\n\ndef is_valid_flag(flag, n, m):\n    colors = set()\n    stripe_height = n // 3\n    \n    if n % 3 != 0:\n        return \"NO\"\n    \n    for i in range(3):\n        stripe = flag[i * stripe_height:(i + 1) * stripe_height]\n        if len(set(stripe)) != 1 or stripe[0][0] not in 'RGB':\n            return \"NO\"\n        colors.add(stripe[0][0])\n    \n    return \"YES\" if len(colors) == 3 else \"NO\"\n\nprint(is_valid_flag(flag, n, m))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    \n    if not is_palindrome(s):\n        return n\n    \n    for length in range(n - 1, 0, -1):\n        for start in range(n - length + 1):\n            substring = s[start:start + length]\n            if not is_palindrome(substring):\n                return length\n    \n    return 0\n\ns = input().strip()\nprint(longest_non_palindrome_substring(s))\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = []\nregulars = []\n\nfor name, type_ in files:\n    if type_ == '1':\n        examples.append(name)\n    else:\n        regulars.append(name)\n\nmoves = []\ne = len(examples)\nn = len(files)\n\n# Rename examples to 1, 2, ..., e\nfor i in range(e):\n    moves.append(f\"move {examples[i]} {i + 1}\")\n\n# Rename regular tests to e + 1, e + 2, ..., n\nfor i in range(len(regulars)):\n    moves.append(f\"move {regulars[i]} {e + i + 1}\")\n\nprint(len(moves))\nfor move in moves:\n    print(move)\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\nrated = False\nunrated = False\n\nfor a, b in ratings:\n    if a != b:\n        rated = True\n        break\n\nif rated:\n    print(\"rated\")\nelse:\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            unrated = True\n            break\n\n    if unrated:\n        print(\"unrated\")\n    else:\n        print(\"maybe\")\n```",
    "36": "```python\ndef hexagonal_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 6 * layer\n\n    while n > moves_in_layer:\n        n -= moves_in_layer\n        layer += 1\n        moves_in_layer = 6 * layer\n\n    x, y = layer, 0\n    direction = n // layer\n    steps = n % layer\n\n    if direction == 0:\n        x -= steps\n    elif direction == 1:\n        x -= steps\n        y += steps\n    elif direction == 2:\n        y += steps\n    elif direction == 3:\n        x += steps\n    elif direction == 4:\n        x += steps\n        y -= steps\n    elif direction == 5:\n        y -= steps\n\n    return (x, y)\n\nn = int(input().strip())\nx, y = hexagonal_coordinates(n)\nprint(x, y)\n```",
    "38": "```python\ndef can_coincide(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between consecutive barriers for Kefa\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    \n    # Calculate the distances between consecutive barriers for Sasha\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Check if kefa_diffs can be rotated to match sasha_diffs\n    for i in range(n):\n        if kefa_diffs == sasha_diffs[i:] + sasha_diffs[:i]:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_coincide(n, L, kefa_distances, sasha_distances))\n```",
    "41": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nd = [0] * n\nlast_zero = -float('inf')\n\n# Forward pass\nfor i in range(n):\n    if a[i] == 0:\n        last_zero = i\n    d[i] = i - last_zero\n\nlast_zero = float('inf')\n\n# Backward pass\nfor i in range(n - 1, -1, -1):\n    if a[i] == 0:\n        last_zero = i\n    d[i] = min(d[i], last_zero - i)\n\nprint(' '.join(map(str, d)))\n```",
    "44": "```python\ndef minimal_time_to_post_office(d, k, a, b, t):\n    # If the car can drive the entire distance without breaking\n    if d <= k:\n        return d * a\n    \n    # Calculate the number of full segments the car can drive\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Time taken if using the car for full segments and walking the remaining distance\n    time_using_car = (full_segments * (k * a + t)) + (remaining_distance * a) - t\n    \n    # Time taken if walking the entire distance\n    time_walking = d * b\n    \n    # Return the minimum time\n    return min(time_using_car, time_walking)\n\n# Read input\nd, k, a, b, t = map(int, input().split())\n# Calculate and print the result\nprint(minimal_time_to_post_office(d, k, a, b, t))\n```",
    "46": "```python\ndef count_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n    \n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n        \n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n        \n    result = 0\n    for i in range(5):\n        result += count_x[i] * count_y[(5 - i) % 5]\n        \n    return result\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))\n```",
    "33": "```python\ndef count_common_ap(a1, b1, a2, b2, L, R):\n    from math import gcd\n\n    # Calculate the step size and the offset\n    step = abs(a1 * a2 // gcd(a1, a2))\n    offset = b2 - b1\n\n    # Find the first valid x in the range [L, R]\n    def first_valid_x():\n        if offset % gcd(a1, a2) != 0:\n            return None  # No solution\n        # Solve for k' in a1 * k' + b1 = x\n        # x = a1 * k' + b1 => k' = (x - b1) / a1\n        # We need to find the smallest x >= L\n        start = (L - b1 + a1 - 1) // a1  # ceil((L - b1) / a1)\n        start_x = a1 * start + b1\n        if start_x < L:\n            start_x += a1\n        return start_x\n\n    # Find the last valid x in the range [L, R]\n    def last_valid_x():\n        # We need to find the largest x <= R\n        end = (R - b1) // a1  # floor((R - b1) / a1)\n        end_x = a1 * end + b1\n        if end_x > R:\n            end_x -= a1\n        return end_x\n\n    first_x = first_valid_x()\n    last_x = last_valid_x()\n\n    if first_x is None or first_x > R or last_x < L:\n        return 0\n\n    # Count the number of valid x's in the range [first_x, last_x]\n    count = (last_x - first_x) // step + 1\n    return count\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n# Output the result\nprint(count_common_ap(a1, b1, a2, b2, L, R))\n```",
    "48": "```python\ndef kth_largest_in_multiplication_table(n, m, k):\n    left, right = 1, n * m\n\n    while left < right:\n        mid = (left + right) // 2\n        count = 0\n        \n        for i in range(1, n + 1):\n            count += min(mid // i, m)\n        \n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left\n\n# Read input\nn, m, k = map(int, input().split())\n# Output the k-th largest number\nprint(kth_largest_in_multiplication_table(n, m, k))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    digit_length = 1\n    count = 9\n    start = 1\n\n    while k > digit_length * count:\n        k -= digit_length * count\n        digit_length += 1\n        count *= 10\n        start *= 10\n\n    start += (k - 1) // digit_length\n    number = str(start)\n    return int(number[(k - 1) % digit_length])\n\nk = int(input().strip())\nprint(find_kth_digit(k))\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Minimum sum of the first k positive integers\n    min_sum = k * (k + 1) // 2\n    \n    if n < min_sum:\n        return -1\n    \n    # The maximum GCD we can use\n    max_gcd = (n - min_sum) // k + 1\n    \n    # Create the sequence\n    sequence = [(i + max_gcd) for i in range(1, k + 1)]\n    \n    # Adjust the last element to ensure the sum is exactly n\n    sequence[-1] += (n - sum(sequence))\n    \n    return sequence\n\n# Read input\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\n# Print output\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "47": "```python\ndef max_beauty_with_subarray(n, x, a):\n    # Function to calculate maximum subarray sum using Kadane's algorithm\n    def kadane(arr):\n        max_ending_here = max_so_far = 0\n        for value in arr:\n            max_ending_here = max(0, max_ending_here + value)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    # Calculate the beauty of the original array\n    original_beauty = kadane(a)\n\n    # If x is 0, multiplying any subarray will not help, return original beauty\n    if x == 0:\n        return original_beauty\n\n    # Calculate the maximum beauty after multiplying a subarray by x\n    max_gain = 0\n    current_gain = 0\n\n    for i in range(n):\n        current_gain += a[i] * (x - 1)\n        max_gain = max(max_gain, current_gain)\n        if current_gain < 0:\n            current_gain = 0\n\n    # The maximum beauty will be the maximum of original beauty and the beauty after the best subarray multiplication\n    return max(original_beauty, original_beauty + max_gain)\n\n# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result and print it\nresult = max_beauty_with_subarray(n, x, a)\nprint(result)\n```",
    "54": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_a = min(a)\nmax_a = max(a)\n\nif min_a == max_a:\n    print(0)\nelse:\n    D = (max_a - min_a) // 2\n    if (max_a - min_a) % 2 == 0:\n        print(D)\n    else:\n        print(-1)\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef reachable_count(n):\n    reachable = set()\n    current = n\n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    return len(reachable)\n\nn = int(input())\nprint(reachable_count(n))\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = -1\n    moves = []\n    \n    while left <= right:\n        if a[left] < a[right]:\n            if a[left] > last_taken:\n                moves.append('L')\n                last_taken = a[left]\n                left += 1\n            elif a[right] > last_taken:\n                moves.append('R')\n                last_taken = a[right]\n                right -= 1\n            else:\n                break\n        else:\n            if a[right] > last_taken:\n                moves.append('R')\n                last_taken = a[right]\n                right -= 1\n            elif a[left] > last_taken:\n                moves.append('L')\n                last_taken = a[left]\n                left += 1\n            else:\n                break\n\n    print(len(moves))\n    print(''.join(moves))\n\n# Example usage:\n# n = int(input())\n# a = list(map(int, input().split()))\n# longest_increasing_sequence(n, a)\n```",
    "43": "```python\nimport sys\nimport math\n\ndef minimal_angle_pair(n, vectors):\n    angles = []\n    \n    for i in range(n):\n        x, y = vectors[i]\n        angle = math.atan2(y, x)\n        angles.append((angle, i + 1))  # Store angle and index (1-based)\n\n    angles.sort()  # Sort by angle\n\n    min_angle = float('inf')\n    best_pair = (0, 0)\n\n    for i in range(n):\n        angle1, index1 = angles[i]\n        angle2, index2 = angles[(i + 1) % n]  # Wrap around to the first element\n        angle_diff = angle2 - angle1\n        \n        if angle_diff < 0:\n            angle_diff += 2 * math.pi\n        \n        if angle_diff > math.pi:\n            angle_diff = 2 * math.pi - angle_diff\n        \n        if angle_diff < min_angle:\n            min_angle = angle_diff\n            best_pair = (index1, index2)\n\n    return best_pair\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    vectors = [tuple(map(int, line.split())) for line in data[1:n + 1]]\n    \n    result = minimal_angle_pair(n, vectors)\n    print(result[0], result[1])\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n\n    len_s = len(s)\n    total_count = 0\n    seen = set()\n\n    # Generate all binary strings of length n\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        # Check if s is a substring in any cyclic shift of t\n        if any(s in t[i:] + t[:i] for i in range(n)):\n            # Add the cyclic string to the set to ensure uniqueness\n            seen.add(t)\n\n    return len(seen)\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_cyclic_strings(n, s))\n```",
    "51": "```python\nfrom collections import Counter\nimport sys\n\ndef find_x_y(n, divisors):\n    count = Counter(divisors)\n    common_divisors = [d for d in count if count[d] > 1]\n    \n    # Calculate x and y\n    x = 1\n    y = 1\n    \n    for d in count:\n        if count[d] == 1:\n            # If the divisor appears once, it belongs to either x or y\n            if x % d == 0:\n                y *= d\n            else:\n                x *= d\n        else:\n            # If the divisor appears twice, it belongs to both x and y\n            x *= d\n            y *= d\n            \n    return x, y\n\n# Read input\nn = int(input().strip())\ndivisors = list(map(int, input().strip().split()))\n\n# Find x and y\nx, y = find_x_y(n, divisors)\n\n# Print the result\nprint(x, y)\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_elements = m // 2\n    dp = [[-1] * k for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        row = sorted(matrix[i - 1], reverse=True)\n        for j in range(max_elements + 1):\n            current_sum = sum(row[:j])\n            for r in range(k):\n                if dp[i - 1][r] != -1:\n                    new_sum = dp[i - 1][r] + current_sum\n                    new_mod = new_sum % k\n                    dp[i][new_mod] = max(dp[i][new_mod], new_sum)\n\n        # Also consider not taking any elements from this row\n        for r in range(k):\n            if dp[i - 1][r] != -1:\n                dp[i][r] = max(dp[i][r], dp[i - 1][r])\n\n    return max(dp[n])\n\n# Input reading\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_sum_divisible_by_k(n, m, k, matrix))\n```",
    "59": "```python\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# We need to check the last x digits of the number\ntarget = ['0'] * x\ntarget[y] = '1'  # We want the y-th position to be 1\ntarget = ''.join(target)\n\n# Get the last x digits of the number\ncurrent = number[-x:]\n\n# Count the number of changes needed\noperations = sum(1 for i in range(x) if current[i] != target[i])\n\nprint(operations)\n```",
    "58": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nfrom collections import defaultdict\n\ncoloring = [0] * n\ncount = defaultdict(int)\n\n# Track the used colors for each number\nused_colors = defaultdict(set)\n\n# Assign colors\nfor i in range(n):\n    num = a[i]\n    # Find the first available color for this number\n    for color in range(1, k + 1):\n        if color not in used_colors[num]:\n            coloring[i] = color\n            used_colors[num].add(color)\n            count[color] += 1\n            break\n\n# Check if we have at least one of each color\nif len(count) < k:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(\" \".join(map(str, coloring)))\n```",
    "57": "```python\nn = int(input())\nf = list(map(int, input().split()))\n\n# Find the friends who have not been assigned gifts\nassigned = set(f) - {0}\nunassigned = [i for i in range(1, n + 1) if i not in assigned]\n\n# Find the indices of friends who have not assigned gifts\nzero_indices = [i for i in range(n) if f[i] == 0]\n\n# Assign gifts to the friends who have not assigned gifts\nfor i in range(len(zero_indices)):\n    f[zero_indices[i]] = unassigned[i]\n\n# Print the result\nprint(' '.join(map(str, f)))\n```",
    "63": "```python\ndef min_instability(n, a):\n    a.sort()\n    # Remove the smallest or the largest element\n    instability_remove_min = a[-1] - a[1]  # Remove the smallest element\n    instability_remove_max = a[-2] - a[0]  # Remove the largest element\n    return min(instability_remove_min, instability_remove_max)\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\nprint(min_instability(n, a))\n```",
    "65": "```python\ndef transform_moves(n, m):\n    if m % n != 0:\n        return -1\n    \n    ratio = m // n\n    moves = 0\n    \n    while ratio > 1:\n        if ratio % 2 == 0:\n            ratio //= 2\n            moves += 1\n        elif ratio % 3 == 0:\n            ratio //= 3\n            moves += 1\n        else:\n            return -1\n            \n    return moves\n\nn, m = map(int, input().split())\nprint(transform_moves(n, m))\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        min_ops = float('inf')\n        best_triple = (0, 0, 0)\n\n        for A in range(1, a + 1):\n            for B in range(A, c + 1):\n                if B % A == 0:\n                    C = B * (B // A)\n                    if C >= B:\n                        ops = abs(a - A) + abs(b - B) + abs(c - C)\n                        if ops < min_ops:\n                            min_ops = ops\n                            best_triple = (A, B, C)\n\n        results.append((min_ops, best_triple))\n\n    return results\n\n# Read input\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations(t, test_cases)\n\n# Print output\nfor ops, triple in results:\n    print(ops)\n    print(*triple)\n```",
    "61": "```python\nn = int(input())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\n# Convert f to a list where f[i] corresponds to f(i+1)\nf = [0] + f  # Adding a dummy value at index 0 for convenience\n\nmax_number = a  # Start with the original number as the maximum\n\n# We will try to find the best segment to replace\ni = 0\nwhile i < n:\n    # Start of a potential segment\n    start = i\n    while i < n and f[int(a[i])] >= int(a[i]):\n        i += 1\n    # Now i is at the first position where we can't replace or at the end\n    if start < i:  # We found a segment to replace\n        # Create a new number with this segment replaced\n        new_number = a[:start] + ''.join(str(f[int(a[j])]) for j in range(start, i)) + a[i:]\n        max_number = max(max_number, new_number)\n    i += 1  # Move to the next character\n\nprint(max_number)\n```",
    "67": "```python\nn = int(input())\na = list(map(int, input().split()))\n\ntotal_sum = sum(a)\nnice_indices = []\n\nfor i in range(n):\n    remaining_sum = total_sum - a[i]\n    if remaining_sum == 2 * a[i]:\n        nice_indices.append(i + 1)\n\nprint(len(nice_indices))\nif nice_indices:\n    print(\" \".join(map(str, nice_indices)))\n```",
    "71": "```python\nimport math\n\na = int(input())\noutput = math.ceil(math.log2(a))\nprint(output)\n```",
    "60": "```python\ndef has_palindrome_subsequence(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        found = False\n        # Use a dictionary to track the first occurrence of each number\n        first_occurrence = {}\n        for i in range(n):\n            if a[i] in first_occurrence:\n                # If we find the same number again and it's not adjacent\n                if i - first_occurrence[a[i]] > 1:\n                    found = True\n                    break\n            else:\n                first_occurrence[a[i]] = i\n        results.append(\"YES\" if found else \"NO\")\n    return results\n\n# Example usage:\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\nresults = has_palindrome_subsequence(t, test_cases)\nfor result in results:\n    print(result)\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Find the longest suffix of t that is also a prefix\n    for i in range(n - 1, -1, -1):\n        if t.startswith(t[i:]):\n            overlap_length = n - i\n            break\n    \n    # Construct the result string\n    result = t + (t[overlap_length:] * (k - 1))\n    return result\n\n# Input reading\nn, k = map(int, input().split())\nt = input().strip()\n\n# Output the result\nprint(construct_string(n, k, t))\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph):\n    visited = {start: 0}\n    queue = deque([start])\n    farthest_node = start\n    max_distance = 0\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > max_distance:\n                    max_distance = visited[neighbor]\n                    farthest_node = neighbor\n                    \n    return farthest_node, max_distance\n\ndef find_max_edges_in_paths(n, edges):\n    graph = defaultdict(list)\n    \n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Step 1: Find the farthest node from an arbitrary node (let's say node 1)\n    farthest_from_start, _ = bfs(1, graph)\n    \n    # Step 2: Find the farthest node from the previously found farthest node\n    farthest_from_a, _ = bfs(farthest_from_start, graph)\n    \n    # Step 3: Find the farthest node from the second farthest node\n    farthest_from_b, _ = bfs(farthest_from_a, graph)\n    \n    # Now we have the two endpoints of the longest path in the tree\n    # We can take any two nodes from the longest path and one more node\n    # that is not on that path to maximize the edges used.\n    \n    # To find the path from farthest_from_start to farthest_from_a\n    def find_path(start, end):\n        parent = {start: None}\n        queue = deque([start])\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in graph[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        return path[::-1]\n    \n    longest_path = find_path(farthest_from_start, farthest_from_a)\n    \n    # Choose the two endpoints of the longest path\n    a = longest_path[0]\n    b = longest_path[-1]\n    \n    # Choose a third node that is not on the longest path\n    path_set = set(longest_path)\n    c = next(node for node in range(1, n + 1) if node not in path_set)\n    \n    # The maximum number of edges in the union of the paths\n    max_edges = len(longest_path) - 1 + len(graph[a]) + len(graph[b]) + len(graph[c]) - 3\n    \n    return max_edges, a, b, c\n\n# Input reading\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\n# Finding the result\nmax_edges, a, b, c = find_max_edges_in_paths(n, edges)\n\n# Output the result\nprint(max_edges)\nprint(a, b, c)\n```",
    "70": "```python\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Convert start and end times to total minutes\nstart_minutes = h1 * 60 + m1\nend_minutes = h2 * 60 + m2\n\n# Calculate the midpoint in total minutes\nmidpoint_minutes = (start_minutes + end_minutes) // 2\n\n# Convert back to hours and minutes\nh3 = midpoint_minutes // 60\nm3 = midpoint_minutes % 60\n\n# Print the result in hh:mm format\nprint(f\"{h3:02}:{m3:02}\")\n```",
    "73": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmax_height = max(a)\ntotal_bricks_needed = 0\ntotal_bricks_available = 0\n\nfor height in a:\n    total_bricks_needed += max_height - height\n    total_bricks_available += height\n\nif total_bricks_needed <= total_bricks_available:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "55": "```python\ndef can_see_white_sheet(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n    # Check if there is any part of the white sheet that is not covered by both black sheets\n    # The white sheet is visible if there is at least one point that is:\n    # - not strictly inside the white sheet (i.e., outside or on the border)\n    # - strictly outside both black sheets\n\n    # Check the left side of the white sheet\n    if x1 > x4 and x1 > x6:  # left of white is to the right of both black sheets\n        return \"YES\"\n    \n    # Check the right side of the white sheet\n    if x2 < x3 and x2 < x5:  # right of white is to the left of both black sheets\n        return \"YES\"\n    \n    # Check the bottom side of the white sheet\n    if y1 > y4 and y1 > y6:  # bottom of white is above both black sheets\n        return \"YES\"\n    \n    # Check the top side of the white sheet\n    if y2 < y3 and y2 < y5:  # top of white is below both black sheets\n        return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Output the result\nprint(can_see_white_sheet(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6))\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    days = [0] * n\n    exam_days = set()\n    prepare_count = [0] * m\n\n    for i in range(m):\n        s_i, d_i, c_i = exams[i]\n        exam_days.add(d_i - 1)  # d_i is 1-indexed, convert to 0-indexed\n        prepare_count[i] = c_i\n\n    # Check if we can fit the preparation days\n    for i in range(m):\n        s_i, d_i, c_i = exams[i]\n        available_days = [j for j in range(s_i - 1, d_i - 1) if days[j] == 0]\n        if len(available_days) < c_i:\n            return -1  # Not enough days to prepare for this exam\n\n        # Allocate preparation days\n        for j in range(c_i):\n            days[available_days[j]] = i + 1  # Mark preparation for exam i+1\n\n    # Mark exam days\n    for i in range(m):\n        d_i = exams[i][1]\n        days[d_i - 1] = m + 1  # Mark exam day\n\n    return days\n\n# Input reading\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\nresult = schedule_exams(n, m, exams)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    # Extract left and right endpoints\n    lefts = [l for l, r in segments]\n    rights = [r for l, r in segments]\n\n    # Calculate the overall max left and min right\n    overall_max_left = max(lefts)\n    overall_min_right = min(rights)\n\n    # Prepare to find the second max left and second min right\n    sorted_lefts = sorted(lefts)\n    sorted_rights = sorted(rights)\n\n    # Find the second max left and second min right\n    second_max_left = sorted_lefts[-2] if n > 1 else float('-inf')\n    second_min_right = sorted_rights[1] if n > 1 else float('inf')\n\n    max_length = 0\n\n    for i in range(n):\n        l, r = segments[i]\n\n        # Determine the effective left and right after removing segment i\n        if l == overall_max_left:\n            effective_left = second_max_left\n        else:\n            effective_left = overall_max_left\n\n        if r == overall_min_right:\n            effective_right = second_min_right\n        else:\n            effective_right = overall_min_right\n\n        # Calculate the length of the intersection\n        intersection_length = max(0, effective_right - effective_left)\n        max_length = max(max_length, intersection_length)\n\n    return max_length\n\n# Input reading\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_intersection_length(n, segments))\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    unique_subsequences = set()\n    \n    # Generate all unique subsequences\n    for i in range(1 << n):\n        subsequence = []\n        for j in range(n):\n            if i & (1 << j):\n                subsequence.append(s[j])\n        unique_subsequences.add(''.join(subsequence))\n    \n    unique_subsequences = list(unique_subsequences)\n    m = len(unique_subsequences)\n    \n    if m < k:\n        return -1\n    \n    # Calculate costs\n    costs = []\n    for subseq in unique_subsequences:\n        cost = n - len(subseq)\n        costs.append(cost)\n    \n    costs.sort()\n    \n    return sum(costs[:k])\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result and print it\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n    \n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    if D >= n or D > len(graph[1]):\n        return \"NO\"\n    \n    # Start building the spanning tree\n    spanning_tree = []\n    visited = [False] * (n + 1)\n    visited[1] = True\n    degree = 0\n    \n    # First, connect vertex 1 to D neighbors if possible\n    for neighbor in graph[1]:\n        if degree < D:\n            spanning_tree.append((1, neighbor))\n            visited[neighbor] = True\n            degree += 1\n    \n    # If we couldn't connect D neighbors, return NO\n    if degree < D:\n        return \"NO\"\n    \n    # Now we need to connect the remaining vertices\n    queue = deque()\n    for neighbor in graph[1]:\n        if visited[neighbor]:\n            queue.append(neighbor)\n    \n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                spanning_tree.append((current, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                if len(spanning_tree) == n - 1:\n                    break\n        if len(spanning_tree) == n - 1:\n            break\n    \n    if len(spanning_tree) == n - 1:\n        result = [\"YES\"]\n        result.extend(f\"{u} {v}\" for u, v in spanning_tree)\n        return \"\\n\".join(result)\n    else:\n        return \"NO\"\n\n# Read input\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the result\nresult = find_spanning_tree(n, m, D, edges)\nprint(result)\n```",
    "77": "```python\ndef minimum_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nn = int(input())\nprint(minimum_difference(n))\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import Counter\n    \n    # Count the frequency of each character in the string\n    freq = Counter(s)\n    \n    # Calculate the number of distinct subsequences we can generate\n    distinct_subsequences = 0\n    total_cost = 0\n    \n    # We can generate subsequences of different lengths\n    for length in range(1, n + 1):\n        # Calculate the number of distinct subsequences of this length\n        # Using the formula: C(n, r) = n! / (r! * (n - r)!)\n        # We can use a simple approach to count distinct subsequences\n        # by considering the frequency of characters\n        count = 1\n        for char, count_char in freq.items():\n            count *= (count_char + 1)  # +1 for choosing 0 to count_char of this character\n        count -= 1  # Subtract the empty subsequence\n        \n        if distinct_subsequences + count >= k:\n            # We can reach or exceed k with this length\n            total_cost += (n - length) * (k - distinct_subsequences)\n            return total_cost\n        else:\n            # Add all distinct subsequences of this length\n            total_cost += (n - length) * count\n            distinct_subsequences += count\n    \n    # If we exit the loop and have not reached k, it's impossible\n    return -1\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result\nresult = min_cost_to_obtain_set(n, k, s)\n\n# Print the result\nprint(result)\n```",
    "76": "```python\ndef can_construct_square(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        half_m = m // 2\n        can_form = False\n        \n        for i in range(n):\n            for j in range(n):\n                if tiles[i][0][1] == tiles[j][1][0]:  # Check if top-right of tile i matches bottom-left of tile j\n                    can_form = True\n                    break\n            if can_form:\n                break\n        \n        results.append(\"YES\" if can_form else \"NO\")\n    \n    return results\n\n# Example usage:\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        top = list(map(int, input().split()))\n        bottom = list(map(int, input().split()))\n        tiles.append((top, bottom))\n    test_cases.append((n, m, tiles))\n\nresults = can_construct_square(t, test_cases)\nfor result in results:\n    print(result)\n```",
    "81": "```python\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\n# Sort strings by length\nstrings.sort(key=len)\n\n# Check if the ordering is valid\nfor i in range(1, n):\n    if strings[i-1] not in strings[i]:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")\n    print(\"\\n\".join(strings))\n```",
    "82": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncount = 0\n\n# Solve from the left\nwhile count < n and a[count] <= k:\n    count += 1\n\n# Solve from the right\nwhile count < n and a[n - 1 - (count - (n - len(a)))] <= k:\n    count += 1\n\n# Adjust count if we counted the same problem from both ends\nif count > n:\n    count = n\n\nprint(count)\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Define the food consumption pattern for each day of the week\n    week_pattern = [0, 1, 2, 0, 1, 2, 0]  # 0: fish, 1: rabbit, 2: chicken\n    food_needed = [3, 2, 2]  # Total food needed for one week\n    \n    # Calculate how many full weeks can be sustained\n    full_weeks = min(a // food_needed[0], b // food_needed[1], c // food_needed[2])\n    \n    # Reduce the food supplies by the amount used in full weeks\n    a -= full_weeks * food_needed[0]\n    b -= full_weeks * food_needed[1]\n    c -= full_weeks * food_needed[2]\n    \n    # Total days from full weeks\n    max_days = full_weeks * 7\n    \n    # Check for each starting day of the week\n    for start_day in range(7):\n        days = 0\n        a_temp, b_temp, c_temp = a, b, c\n        \n        # Simulate the days of the week starting from start_day\n        for i in range(7):\n            current_day = (start_day + i) % 7\n            if week_pattern[current_day] == 0 and a_temp > 0:\n                a_temp -= 1\n                days += 1\n            elif week_pattern[current_day] == 1 and b_temp > 0:\n                b_temp -= 1\n                days += 1\n            elif week_pattern[current_day] == 2 and c_temp > 0:\n                c_temp -= 1\n                days += 1\n            else:\n                break  # No food available for the current day, stop counting\n        \n        max_days = max(max_days, days)\n    \n    return max_days\n\n# Input reading\na, b, c = map(int, input().split())\nprint(max_days(a, b, c))\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    from collections import defaultdict\n\n    # Create a mapping of character positions\n    char_positions = defaultdict(list)\n    for index, char in enumerate(s):\n        char_positions[char].append(index)\n\n    # Create a list to store the color for each character\n    colors = [0] * n\n    color_count = 0\n\n    # Create a list of the characters sorted\n    sorted_chars = sorted(char_positions.keys())\n\n    # Assign colors based on the sorted order\n    for char in sorted_chars:\n        positions = char_positions[char]\n        # Assign a new color for this character\n        color_count += 1\n        for pos in positions:\n            colors[pos] = color_count\n\n    return color_count, colors\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result\nres, coloring = min_colors_to_sort(n, s)\n\n# Print the output\nprint(res)\nprint(' '.join(map(str, coloring)))\n```",
    "85": "```python\nimport sys\nimport math\n\ndef find_price(A, B):\n    for price in range(1, 10000):  # Arbitrarily chosen upper limit\n        tax_8 = math.floor(price * 0.08)\n        tax_10 = math.floor(price * 0.10)\n        \n        if tax_8 == A and tax_10 == B:\n            return price\n            \n    return -1\n\nif __name__ == \"__main__\":\n    A, B = map(int, sys.stdin.read().strip().split())\n    result = find_price(A, B)\n    print(result)\n```",
    "78": "```python\ndef count_regular_sequences(n, s):\n    MOD = 10**9 + 7\n    m = len(s)\n\n    # Precompute factorials and inverse factorials\n    fact = [1] * (2 * n + 1)\n    for i in range(2, 2 * n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n\n    def mod_inv(x):\n        return pow(x, MOD - 2, MOD)\n\n    inv_fact = [1] * (2 * n + 1)\n    for i in range(2, 2 * n + 1):\n        inv_fact[i] = mod_inv(fact[i])\n\n    # Check if s can be part of a regular bracket sequence\n    balance = 0\n    min_balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n\n    if balance < 0 or balance > n or min_balance < 0:\n        return 0\n\n    # Remaining brackets to place\n    remaining_open = n - (s.count('('))\n    remaining_close = n - (s.count(')'))\n\n    # Calculate the number of valid sequences\n    total_sequences = 0\n    for prefix_open in range(remaining_open + 1):\n        prefix_close = remaining_open - prefix_open\n        if prefix_close < 0 or prefix_close > remaining_close:\n            continue\n\n        # Calculate the number of valid sequences with the prefix\n        valid_sequences = (fact[remaining_open + remaining_close] * inv_fact[prefix_open] % MOD * inv_fact[prefix_close] % MOD) % MOD\n        total_sequences = (total_sequences + valid_sequences) % MOD\n\n    return total_sequences\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(count_regular_sequences(n, s))\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects based on the required rating\n    projects.sort(key=lambda x: x[0])\n    \n    for a, b in projects:\n        if r < a:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_complete_projects(n, r, projects))\n```",
    "86": "```python\ndef solve_problems(n, k):\n    # Minimum sum of problems that can be solved in k days\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n    \n    # Maximum sum of problems that can be solved in k days\n    max_sum = 0\n    a = []\n    for i in range(1, k + 1):\n        a.append(i)\n        max_sum += i\n    \n    if n > max_sum * 2:\n        print(\"NO\")\n        return\n    \n    # Start with the minimum valid sequence\n    a = list(range(1, k + 1))\n    current_sum = sum(a)\n    \n    # Distribute the remaining problems\n    remaining = n - current_sum\n    \n    for i in range(k - 1, -1, -1):\n        # Maximum we can add to a[i]\n        max_add = min(remaining, a[i] * 2 - a[i])\n        remaining -= max_add\n        a[i] += max_add\n        \n        if remaining <= 0:\n            break\n    \n    if remaining > 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n\n# Example usage:\nn, k = map(int, input().split())\nsolve_problems(n, k)\n```",
    "84": "```python\ndef can_color_string(n, s):\n    sorted_s = sorted(s)\n    color = ['0'] * n\n    \n    # Create a mapping of characters to their positions in the sorted string\n    char_positions = {}\n    for i, char in enumerate(sorted_s):\n        if char not in char_positions:\n            char_positions[char] = []\n        char_positions[char].append(i)\n    \n    # Assign colors based on the positions in the original string\n    current_color = 0\n    for char in s:\n        if char_positions[char]:\n            pos = char_positions[char].pop(0)\n            color[pos] = str(current_color)\n            current_color = 1 - current_color  # Alternate colors\n    \n    # Check if the coloring allows sorting\n    for i in range(n - 1):\n        if s[i] > s[i + 1] and color[i] == color[i + 1]:\n            return \"NO\"\n    \n    return \"YES\", ''.join(color)\n\nn = int(input())\ns = input().strip()\nresult = can_color_string(n, s)\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    print(result[1])\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    projects.sort(key=lambda x: (x[0], -x[1]))  # Sort by required rating, then by rating change\n    count = 0\n    current_rating = r\n    \n    for a, b in projects:\n        if current_rating >= a:  # Can start the project\n            count += 1\n            current_rating += b  # Update rating after completing the project\n            if current_rating < 0:  # If rating goes below zero, break\n                break\n    \n    return count\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_projects(n, r, projects))\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    min_perimeter = float('inf')\n    \n    for width in range(1, int((a + b) ** 0.5) + 2):\n        if (a + b) % width == 0:\n            height = (a + b) // width\n            \n            # Check red rectangle\n            for red_width in range(1, int(a ** 0.5) + 2):\n                if a % red_width == 0:\n                    red_height = a // red_width\n                    red_perimeter = 2 * (red_width + red_height)\n                    \n                    # Check blue rectangle\n                    for blue_width in range(1, int(b ** 0.5) + 2):\n                        if b % blue_width == 0:\n                            blue_height = b // blue_width\n                            blue_perimeter = 2 * (blue_width + blue_height)\n                            \n                            # Check if they fit in the overall rectangle\n                            if (red_width <= width and red_height <= height) or (red_height <= width and red_width <= height):\n                                if (blue_width <= width and blue_height <= height) or (blue_height <= width and blue_width <= height):\n                                    total_perimeter = 2 * (width + height)\n                                    min_perimeter = min(min_perimeter, total_perimeter)\n    \n    return min_perimeter\n\na, b = map(int, input().split())\nprint(minimal_perimeter(a, b))\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    target = ['0', '0', '2', '5']\n    \n    # Check for possible pairs of digits that can form 00, 25, 50, or 75\n    pairs = [(0, 0), (2, 5), (5, 0), (7, 5)]\n    \n    min_moves = float('inf')\n    \n    for a, b in pairs:\n        pos_a = -1\n        pos_b = -1\n        \n        # Find the last occurrence of b and then the last occurrence of a before it\n        for i in range(length - 1, -1, -1):\n            if s[i] == str(b) and pos_b == -1:\n                pos_b = i\n            elif s[i] == str(a) and pos_b != -1:\n                pos_a = i\n                break\n        \n        if pos_a != -1 and pos_b != -1:\n            # Calculate moves to bring b to the end and a before b\n            moves = (length - 1 - pos_b) + (pos_b - pos_a - 1)\n            min_moves = min(min_moves, moves)\n    \n    return min_moves if min_moves != float('inf') else -1\n\n# Read input\nn = int(input().strip())\n# Get the result\nresult = min_moves_to_divisible_by_25(n)\n# Print the result\nprint(result)\n```",
    "92": "```python\nx = float(input().strip())\n\n# We need to find two integers a and b such that 1 <= a, b <= 10\n# and a * b is approximately equal to x\n\n# Since x is between 0 and 5, we can iterate through possible values of a and b\nfor a in range(1, 11):\n    for b in range(1, 11):\n        if abs(a * b - x) < 1e-6:  # Check if the product is close to x\n            print(a, b)\n            break\n```",
    "97": "```python\nn = int(input())\nx = list(map(int, input().split()))\n\neven_count = sum(1 for xi in x if xi % 2 == 0)\nodd_count = n - even_count\n\n# The minimum coins required is the minimum of moving all to even or all to odd\nprint(min(even_count, odd_count))\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n    \n    # Create arrays to store the positions of t in s\n    left = [0] * m\n    right = [0] * m\n    \n    # Fill the left array\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n    \n    # Fill the right array\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n    \n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n    \n    # Consider removing from the start to the first character of t\n    max_length = max(max_length, right[0])\n    # Consider removing from the last character of t to the end\n    max_length = max(max_length, n - 1 - left[m - 1])\n    \n    return max_length\n\n# Read input\ns = input().strip()\nt = input().strip()\n\n# Get the result and print it\nresult = max_removable_length(s, t)\nprint(result)\n```",
    "98": "```python\ndef min_moves_to_reach_n(N):\n    moves = float('inf')\n    \n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            moves = min(moves, (i - 1) + (j - 1))\n    \n    return moves\n\nN = int(input().strip())\nprint(min_moves_to_reach_n(N))\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    p = [0] * n\n    p[0] = 0  # Start with an arbitrary value for p[1]\n    \n    # Calculate the prefix sums to find p\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n    \n    # Normalize the permutation to start from 1\n    min_p = min(p)\n    for i in range(n):\n        p[i] -= min_p - 1  # Shift to make the smallest element 1\n    \n    # Check if p is a valid permutation\n    if sorted(p) == list(range(1, n + 1)):\n        print(' '.join(map(str, p)))\n    else:\n        print(-1)\n\n# Example usage:\nn = int(input())\nq = list(map(int, input().split()))\nrestore_permutation(n, q)\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Start with the base pattern\n    if x % 2 == 1:\n        # If x is odd, start with '1' if we have more '1's, else start with '0'\n        start_with_one = b > a\n    else:\n        # If x is even, start with '0' if we have more '0's, else start with '1'\n        start_with_one = a > b\n\n    # Initialize the string\n    s = []\n    \n    # Fill the string based on the starting character\n    if start_with_one:\n        s.append('1')\n        b -= 1\n    else:\n        s.append('0')\n        a -= 1\n\n    # Alternate between '0' and '1' until we reach x transitions\n    for i in range(x):\n        if s[-1] == '0':\n            s.append('1')\n            b -= 1\n        else:\n            s.append('0')\n            a -= 1\n\n    # Now fill the rest with the remaining characters\n    while a > 0:\n        s.append('0')\n        a -= 1\n    while b > 0:\n        s.append('1')\n        b -= 1\n\n    # Join the list into a string and print it\n    print(''.join(s))\n\n# Read input\na, b, x = map(int, input().split())\nconstruct_binary_string(a, b, x)\n```",
    "90": "```python\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculate the total length of platforms\ntotal_length = sum(c)\n\n# If the maximum jump distance is greater than or equal to the width of the river, we can always reach the end\nif d >= n + 1:\n    print(\"YES\")\n    print(\"0 \" + \"0 \" * (n - 1) + \"1\")\nelse:\n    # We need to check if we can place the platforms in a way that allows us to jump across\n    # We will try to place the platforms starting from the leftmost position\n    a = [0] * n\n    current_position = 0\n    \n    for i in range(m):\n        # Place the platform at the current position\n        for j in range(c[i]):\n            if current_position < n:\n                a[current_position] = i + 1\n                current_position += 1\n        \n        # Move to the next position after the platform\n        current_position += 1  # Leave at least one cell gap after each platform\n    \n    # Check if we can reach the end\n    reachable = True\n    last_position = -1\n    \n    for i in range(n):\n        if a[i] != 0:\n            last_position = i\n        if last_position != -1 and i - last_position > d:\n            reachable = False\n            break\n    \n    if reachable:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n    else:\n        print(\"NO\")\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1 or (d == 1 and n > 1) or (d == 0 and n > 1):\n        print(\"NO\")\n        return\n\n    edges = []\n    \n    # Create a path of length d\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n    \n    # Now we have d + 1 vertices in the path\n    current_vertex = d + 2\n    \n    # We can attach additional vertices to the first vertex in the path\n    for i in range(1, n - (d + 1) + 1):\n        if len(edges) < n - 1:\n            edges.append((1, current_vertex))\n            current_vertex += 1\n    \n    print(\"YES\")\n    for u, v in edges:\n        print(u, v)\n\n# Read input\nn, d, k = map(int, input().split())\nconstruct_tree(n, d, k)\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Create a list of characters to use\n    chars = ['a'] * n + ['b'] * n + ['c'] * n\n    \n    # Check if it's possible to create a valid string\n    if s[0] == t[0] or s[0] == t[1] or s[1] == t[0] or s[1] == t[1]:\n        print(\"NO\")\n        return\n    \n    # Create a result string\n    res = []\n    \n    # Start with the first character that is not in s or t\n    for i in range(n):\n        if i % 3 == 0:\n            res.append('a')\n        elif i % 3 == 1:\n            res.append('b')\n        else:\n            res.append('c')\n    \n    # Convert list to string\n    res = ''.join(res)\n    \n    # Check for substrings and adjust if necessary\n    for i in range(len(res) - 1):\n        if res[i:i+2] == s or res[i:i+2] == t:\n            # Swap the last character with the current one\n            if i + 2 < len(res):\n                res = res[:i] + res[i+1] + res[i] + res[i+2:]\n            else:\n                res = res[:i] + res[i+1] + res[i]\n            break\n    \n    print(\"YES\")\n    print(res)\n\n# Input reading\nn = int(input())\ns = input().strip()\nt = input().strip()\n\ngenerate_string(n, s, t)\n```",
    "99": "```python\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\n# Maximum wins for Alice\nmax_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n\n# Minimum wins for Alice\n# Calculate losses for Alice\nalice_losses = 0\nalice_losses += max(0, b1 - a3)  # Bob's rock vs Alice's paper\nalice_losses += max(0, b2 - a1)  # Bob's scissors vs Alice's rock\nalice_losses += max(0, b3 - a2)  # Bob's paper vs Alice's scissors\n\nmin_wins = n - alice_losses\n\nprint(min_wins, max_wins)\n```",
    "88": "```python\ndef can_form_palindromic_matrix(n, numbers):\n    from collections import Counter\n    \n    count = Counter(numbers)\n    \n    # Check for the number of odd occurrences\n    odd_count = sum(1 for v in count.values() if v % 2 != 0)\n    \n    # For an n x n matrix, we can have at most one odd count if n is odd\n    # and no odd counts if n is even\n    if (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n        return \"NO\"\n    \n    # Prepare the matrix\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Fill the matrix\n    half = n // 2\n    idx = 0\n    for value, freq in count.items():\n        while freq > 0:\n            if freq >= 4:\n                # Place in corners\n                matrix[idx][idx] = value\n                matrix[idx][n - 1 - idx] = value\n                matrix[n - 1 - idx][idx] = value\n                matrix[n - 1 - idx][n - 1 - idx] = value\n                freq -= 4\n            elif freq >= 2:\n                # Place in sides\n                if idx < half:\n                    matrix[idx][n - 1 - idx] = value\n                    matrix[n - 1 - idx][idx] = value\n                    freq -= 2\n                else:\n                    # If we reach the middle row/column in odd n\n                    if n % 2 == 1 and idx == half:\n                        matrix[idx][idx] = value\n                        freq -= 1\n            else:\n                break\n            idx = (idx + 1) % half\n    \n    # Fill the center for odd n\n    if n % 2 == 1:\n        for value, freq in count.items():\n            if freq % 2 == 1:\n                matrix[half][half] = value\n                break\n    \n    return \"YES\", matrix\n\nn = int(input())\nnumbers = list(map(int, input().split()))\n\nresult = can_form_palindromic_matrix(n, numbers)\n\nif result == \"NO\":\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for row in result[1]:\n        print(\" \".join(map(str, row)))\n```"
}