{
    "2": "```python\nn = int(input())\n\ndef next_lucky_year(year):\n    while True:\n        year += 1\n        if str(year).count('0') + len(set(str(year))) - 1 <= 1:\n            return year\n\nnext_year = next_lucky_year(n)\nprint(next_year - n)\n```",
    "10": "```python\nn = int(input())\n\n# Calculate the number of complete weeks and remaining days\nweeks = n // 7\nremaining_days = n % 7\n\n# Minimum days off is when all remaining days are work days\nmin_days_off = weeks * 2\n\n# Maximum days off is when all remaining days are days off\nmax_days_off = min(remaining_days, 2) + weeks * 2\n\nprint(min_days_off, max_days_off)\n```",
    "7": "```python\ndef find_empty_day(n, m):\n    day = 0\n    total_eaten = 0\n    \n    while n > 0:\n        day += 1\n        total_eaten += day\n        \n        # Add grains to the barn\n        n += m\n        \n        # If the barn is over capacity, it stays full\n        if n > m:\n            n = n  # Barn remains full\n        else:\n            n = n  # Barn is filled with the new grains\n        \n        # Sparrows eat grains\n        n -= total_eaten\n        \n    return day\n\n# Input reading\nn, m = map(int, input().split())\nprint(find_empty_day(n, m))\n```",
    "1": "```python\ndef max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n    \n    # Start with the number itself\n    max_sum = sum(int(d) for d in str_x)\n    best_number = x\n    \n    # Try to create numbers by reducing digits\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit and setting all following digits to 9\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        new_number = int(new_number)\n        \n        if new_number <= x:\n            current_sum = sum(int(d) for d in str(new_number))\n            if current_sum > max_sum or (current_sum == max_sum and new_number > best_number):\n                max_sum = current_sum\n                best_number = new_number\n    \n    return best_number\n\nx = int(input())\nprint(max_digit_sum(x))\n```",
    "5": "```python\nn, pos, l, r = map(int, input().split())\n\n# If no tabs need to be closed\nif l == 1 and r == n:\n    print(0)\n    exit()\n\n# Calculate the number of seconds needed\nseconds = 0\n\n# Move to the leftmost tab that needs to be kept\nif pos < l:\n    seconds += l - pos  # Move to l\n    seconds += 1  # Close to the left\nelif pos > r:\n    seconds += pos - r  # Move to r\n    seconds += 1  # Close to the right\nelse:\n    # If pos is within [l, r]\n    left_close = (pos - l) + 1  # Move to l and close left\n    right_close = (r - pos) + 1  # Move to r and close right\n    seconds += min(left_close, right_close)\n\n# Close the remaining tabs\nif l > 1:\n    seconds += 1  # Close left side if necessary\nif r < n:\n    seconds += 1  # Close right side if necessary\n\nprint(seconds)\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    count_a = n // a\n    count_b = n // b\n    count_ab = n // (a * b // gcd(a, b))\n    \n    # Calculate chocolates\n    chocolates = count_a * p + count_b * q - count_ab * min(p, q)\n    \n    return chocolates\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n# Input\nn, a, b, p, q = map(int, input().split())\nprint(max_chocolates(n, a, b, p, q))\n```",
    "9": "```python\nd = int(input())\nn, m = map(int, input().split())\n\nsofas = []\nfor i in range(d):\n    x1, y1, x2, y2 = map(int, input().split())\n    sofas.append((x1, y1, x2, y2))\n\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\ndef count_sofas(sofas, x1, y1, x2, y2):\n    left = right = top = bottom = 0\n    for (sx1, sy1, sx2, sy2) in sofas:\n        if (sx1, sy1) != (x1, y1) and (sx1, sy1) != (x2, y2):\n            if sx2 < x1:  # sofa is to the left\n                left += 1\n            elif sx1 > x2:  # sofa is to the right\n                right += 1\n            if sy2 < y1:  # sofa is above\n                top += 1\n            elif sy1 > y2:  # sofa is below\n                bottom += 1\n    return left, right, top, bottom\n\nfor i in range(d):\n    x1, y1, x2, y2 = sofas[i]\n    left, right, top, bottom = count_sofas(sofas, x1, y1, x2, y2)\n    if left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b:\n        print(i + 1)\n        break\nelse:\n    print(-1)\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    # Find the lengths of segments of golden trophies\n    segments = []\n    current_length = 0\n    \n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n    \n    if current_length > 0:\n        segments.append(current_length)\n    \n    # If there are no golden trophies\n    if not segments:\n        return 0\n    \n    # Calculate the maximum length of golden trophies without any swap\n    max_length = max(segments)\n    \n    # If there is only one segment, we cannot increase the length by swapping\n    if len(segments) == 1:\n        return max_length\n    \n    # Calculate the maximum possible length with one swap\n    max_possible_length = max_length\n    \n    for i in range(len(segments) - 1):\n        # Check if we can swap a silver trophy between two segments of golden trophies\n        max_possible_length = max(max_possible_length, segments[i] + segments[i + 1])\n    \n    # If we can swap a silver trophy with a golden trophy at the ends\n    if 'S' in trophies:\n        max_possible_length += 1\n    \n    return max_possible_length\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\n\n# Output the result\nprint(max_beauty_after_swap(n, trophies))\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "16": "```python\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\n# Check the conditions for forming a regular bracket sequence\nif cnt_1 + cnt_2 >= cnt_3 + cnt_4 and cnt_3 <= cnt_1 + cnt_2:\n    print(1)\nelse:\n    print(0)\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    # Create a list to track the coverage of each section\n    coverage = [0] * (n + 1)\n\n    # Count the coverage for each painter\n    for l, r in painters:\n        for i in range(l, r + 1):\n            coverage[i] += 1\n\n    # Calculate the total painted sections with all painters\n    total_painted = sum(1 for i in range(1, n + 1) if coverage[i] > 0)\n\n    # If we hire q - 2 painters, we need to find the two painters to exclude\n    max_painted = 0\n\n    for i in range(q):\n        # Create a temporary coverage array to simulate excluding the i-th painter\n        temp_coverage = coverage[:]\n        l_i, r_i = painters[i]\n        \n        # Remove the coverage of the i-th painter\n        for j in range(l_i, r_i + 1):\n            temp_coverage[j] -= 1\n\n        # Calculate the painted sections after excluding the i-th painter\n        painted_after_exclusion = sum(1 for k in range(1, n + 1) if temp_coverage[k] > 0)\n        \n        # Update the maximum painted sections\n        max_painted = max(max_painted, painted_after_exclusion)\n\n    return max_painted\n\n# Input reading\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Get the result and print it\nresult = max_painted_sections(n, q, painters)\nprint(result)\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelse:\n    print(n + k - t)\n```",
    "0": "```python\ndef max_accordion_length(s):\n    n = len(s)\n    left_bracket = -1\n    right_bracket = -1\n    \n    # Find the first opening bracket '['\n    for i in range(n):\n        if s[i] == '[':\n            left_bracket = i\n            break\n            \n    # Find the last closing bracket ']'\n    for i in range(n - 1, -1, -1):\n        if s[i] == ']':\n            right_bracket = i\n            break\n            \n    # If we don't have both brackets, return -1\n    if left_bracket == -1 or right_bracket == -1 or left_bracket >= right_bracket:\n        return -1\n    \n    # Now we need to find the colons ':' and vertical lines '|'\n    first_colon = -1\n    second_colon = -1\n    vertical_lines_count = 0\n    \n    for i in range(left_bracket + 1, right_bracket):\n        if s[i] == ':':\n            if first_colon == -1:\n                first_colon = i\n            elif second_colon == -1:\n                second_colon = i\n                break\n        elif s[i] == '|':\n            vertical_lines_count += 1\n            \n    # If we don't have two colons, return -1\n    if first_colon == -1 or second_colon == -1:\n        return -1\n    \n    # Calculate the maximum length of the accordion\n    max_length = 2 + vertical_lines_count  # 2 for the colons and brackets\n    return max_length + 2  # +2 for the brackets\n\n# Read input\ns = input().strip()\n# Get the result\nresult = max_accordion_length(s)\n# Print the result\nprint(result)\n```",
    "14": "```python\ndef is_stack_sortable(n, k, p):\n    # Create a set of used numbers from the first k elements\n    used = set(p)\n    \n    # Create the remaining elements that need to be added to the permutation\n    remaining = [i for i in range(1, n + 1) if i not in used]\n    \n    # Initialize the stack and the result array\n    stack = []\n    result = p[:]\n    \n    # We will iterate over the first k elements and simulate the stack operations\n    for i in range(k):\n        while stack and (not remaining or stack[-1] < remaining[-1]):\n            result.append(stack.pop())\n        stack.append(p[i])\n    \n    # Now we need to add the remaining elements in a way that keeps the stack sortable\n    for num in reversed(remaining):\n        while stack and stack[-1] < num:\n            result.append(stack.pop())\n        stack.append(num)\n    \n    # Finally, pop all remaining elements from the stack\n    while stack:\n        result.append(stack.pop())\n    \n    # Check if the result is stack-sortable\n    if result == sorted(result):\n        return result\n    else:\n        return -1\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result\nresult = is_stack_sortable(n, k, p)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    \n    for query in queries:\n        n, x = query[0]\n        blows = query[1]\n        \n        # Initialize variables to track the best blow options\n        max_d = 0\n        min_h = float('inf')\n        \n        for d, h in blows:\n            max_d = max(max_d, d)\n            if d < x:\n                min_h = min(min_h, h)\n        \n        # If the maximum damage can defeat Zmei in one blow\n        if max_d >= x:\n            results.append(1)\n            continue\n        \n        # If there's no blow that can reduce heads effectively\n        if min_h == float('inf'):\n            results.append(-1)\n            continue\n        \n        # Calculate the number of blows needed\n        blows_needed = 0\n        while x > 0:\n            blows_needed += 1\n            x -= max_d\n            if x > 0:\n                x += min_h\n        \n        results.append(blows_needed)\n    \n    return results\n\n# Input reading\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append(((n, x), blows))\n\n# Get results\nresults = min_blows_to_defeat_zmei(t, queries)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "8": "```python\ndef min_tiles_to_draw(tiles):\n    # Parse the input tiles\n    hand = [(int(tile[0]), tile[1]) for tile in tiles]\n    \n    # Check for koutsu (triplet)\n    counts = {}\n    for num, suit in hand:\n        if (num, suit) in counts:\n            counts[(num, suit)] += 1\n        else:\n            counts[(num, suit)] = 1\n    \n    # If there's a koutsu, return 0\n    if any(count == 3 for count in counts.values()):\n        return 0\n    \n    # Check for shuntsu (sequence)\n    suits = {'m': [], 'p': [], 's': []}\n    for num, suit in hand:\n        suits[suit].append(num)\n    \n    # Sort the numbers in each suit\n    for suit in suits:\n        suits[suit].sort()\n    \n    # Check for existing shuntsu\n    for suit in suits:\n        for i in range(len(suits[suit]) - 2):\n            if suits[suit][i] + 1 == suits[suit][i + 1] and suits[suit][i] + 2 == suits[suit][i + 2]:\n                return 0\n    \n    # Check for possible shuntsu with one draw\n    for suit in suits:\n        for num in suits[suit]:\n            if num - 1 >= 1 and (num - 1) not in suits[suit]:  # Check for num-1\n                if num + 1 not in suits[suit]:  # Check for num+1\n                    return 1\n            if num + 1 <= 9 and (num + 1) not in suits[suit]:  # Check for num+1\n                if num - 1 not in suits[suit]:  # Check for num-1\n                    return 1\n    \n    # If no shuntsu can be formed with one draw, return 2\n    return 2\n\n# Read input\ntiles = input().strip().split()\n# Output the result\nprint(min_tiles_to_draw(tiles))\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef main():\n    n, k = map(int, input().split())\n    main_courses = list(map(int, input().split()))\n    \n    dependencies = defaultdict(list)\n    indegree = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        data = list(map(int, input().split()))\n        t_i = data[0]\n        for j in range(1, t_i + 1):\n            dep_course = data[j]\n            dependencies[dep_course].append(i)\n            indegree[i] += 1\n    \n    queue = deque()\n    for course in range(1, n + 1):\n        if indegree[course] == 0:\n            queue.append(course)\n    \n    order = []\n    passed_courses = set()\n    \n    while queue:\n        current = queue.popleft()\n        order.append(current)\n        passed_courses.add(current)\n        \n        for dependent in dependencies[current]:\n            indegree[dependent] -= 1\n            if indegree[dependent] == 0:\n                queue.append(dependent)\n    \n    if not all(indegree[course] == 0 for course in main_courses):\n        print(-1)\n        return\n    \n    result = []\n    for course in order:\n        if course in main_courses or any(dep in passed_courses for dep in dependencies[course]):\n            result.append(course)\n    \n    print(len(result))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "18": "```python\ndef lexicographically_minimal_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        while t and (not u or t[-1] <= u[-1]):\n            u.append(t.pop())\n    \n    return ''.join(u)\n\n# Input\ns = input().strip()\n# Output\nprint(lexicographically_minimal_string(s))\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n        \n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return minutes_passed\n\ncurrent_time = input().strip()\nhh, mm = map(int, current_time.split(':'))\nresult = next_palindrome_time(hh, mm)\nprint(result)\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a, b):\n    from itertools import permutations\n\n    a_str = str(a)\n    b_str = str(b)\n\n    # Generate all unique permutations of the digits of a\n    permuted_numbers = set(int(''.join(p)) for p in permutations(a_str))\n\n    # Filter out numbers that are greater than b and have the same length as a\n    valid_numbers = [num for num in permuted_numbers if num <= b and len(str(num)) == len(a_str)]\n\n    # Return the maximum valid number\n    return max(valid_numbers)\n\n# Input\na = int(input().strip())\nb = int(input().strip())\n\n# Output\nprint(max_permutation_not_exceeding(a, b))\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror_chars = {\n        'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M',\n        'O': 'O', 'p': 'q', 'q': 'p', 'R': 'R', 'S': 'S', 'T': 'T',\n        'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X', 'Y': 'Y', 'Z': 'Z'\n    }\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        if s[i] not in mirror_chars or mirror_chars[s[i]] != s[n - 1 - i]:\n            print(\"NIE\")\n            return\n    print(\"TAK\")\n\ns = input().strip()\nis_s_palindrome(s)\n```",
    "27": "```python\nn = int(input())\ns = input()\n\n# Initialize the minimum operations to the length of the string (typing all characters one by one)\nmin_operations = n\n\n# Check for all possible prefixes\nfor i in range(1, n):\n    # Check if the prefix can be doubled and still fit in the string\n    if s[:i] == s[i:i+i] and i + i <= n:\n        # Calculate operations: type prefix + copy + remaining characters\n        operations = i + 1 + (n - (i + i))\n        min_operations = min(min_operations, operations)\n\n# Print the minimum operations found\nprint(min_operations)\n```",
    "30": "```python\ndef min_traps(m, x):\n    # Since GCD(x, m) = 1, the x-mouse will visit all rooms\n    # The number of distinct rooms visited is equal to m\n    # The number of traps needed is m - 1 (to cover all rooms except room 0)\n    return m\n\nm, x = map(int, input().split())\nprint(min_traps(m, x))\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    if k > n * (n + 1) // 2:\n        return -1\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k > 0:\n            matrix[i][i] = 1\n            k -= 1\n        \n        for j in range(i + 1, n):\n            if k > 1:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n            \n            if k <= 0:\n                break\n    \n    if k > 0:\n        return -1\n    \n    return matrix\n\n# Input\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = []\nregulars = []\n\nfor name, type_ in files:\n    if type_ == '1':\n        examples.append(name)\n    else:\n        regulars.append(name)\n\nmoves = []\ne = len(examples)\n\n# Rename example files\nfor i in range(e):\n    moves.append(f\"move {examples[i]} {i + 1}\")\n\n# Rename regular files\nfor i in range(len(regulars)):\n    moves.append(f\"move {regulars[i]} {e + i + 1}\")\n\nprint(len(moves))\nfor move in moves:\n    print(move)\n```",
    "32": "```python\nn = int(input())\ncurrent_position = 0  # Position in kilometers from the North Pole (0 to 20000)\nvalid = True\n\nfor _ in range(n):\n    t, direction = input().split()\n    t = int(t)\n\n    if direction == \"South\":\n        if current_position == 0:  # At North Pole\n            valid = False\n        current_position += t\n    elif direction == \"North\":\n        if current_position == 20000:  # At South Pole\n            valid = False\n        current_position -= t\n    elif direction in [\"West\", \"East\"]:\n        # Moving West or East does not change the position in terms of North/South\n        pass\n\n    # Check if current position is valid\n    if current_position < 0 or current_position > 20000:\n        valid = False\n\n# Final check if we end at the North Pole\nif current_position != 0:\n    valid = False\n\nprint(\"YES\" if valid else \"NO\")\n```",
    "24": "```python\ndef can_win(matrix):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # vertical, horizontal, diagonal right, diagonal left\n    n = 10\n\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == '.':\n                # Temporarily place 'X' in the empty cell\n                matrix[i][j] = 'X'\n                \n                # Check for a win in all directions\n                for dx, dy in directions:\n                    count = 1  # Count the current placed 'X'\n                    \n                    # Check in the positive direction\n                    x, y = i + dx, j + dy\n                    while 0 <= x < n and 0 <= y < n and matrix[x][y] == 'X':\n                        count += 1\n                        x += dx\n                        y += dy\n                    \n                    # Check in the negative direction\n                    x, y = i - dx, j - dy\n                    while 0 <= x < n and 0 <= y < n and matrix[x][y] == 'X':\n                        count += 1\n                        x -= dx\n                        y -= dy\n                    \n                    # If we have 5 or more in a row, Alice wins\n                    if count >= 5:\n                        return \"YES\"\n                \n                # Remove the temporary 'X'\n                matrix[i][j] = '.'\n\n    return \"NO\"\n\n# Read the input matrix\nmatrix = [list(input().strip()) for _ in range(10)]\nprint(can_win(matrix))\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    left, right = 0, max(a, b) + 1\n    \n    while left < right:\n        mid = (left + right + 1) // 2\n        if (a // mid) + (b // mid) >= n:\n            left = mid\n        else:\n            right = mid - 1\n            \n    return left\n\n# Input\nn, a, b = map(int, input().split())\n# Output\nprint(max_min_pieces(n, a, b))\n```",
    "19": "```python\ndef check_records(test_cases):\n    results = []\n    for case in test_cases:\n        n, stats = case\n        valid = True\n        for i in range(n):\n            p_i, c_i = stats[i]\n            if i > 0:\n                p_prev, c_prev = stats[i - 1]\n                if p_i < p_prev or c_i < c_prev or c_i > p_i:\n                    valid = False\n                    break\n                if (p_i - p_prev) < (c_i - c_prev):\n                    valid = False\n                    break\n        results.append(\"YES\" if valid else \"NO\")\n    return results\n\n# Read input\nT = int(input())\ntest_cases = []\nfor _ in range(T):\n    n = int(input())\n    stats = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, stats))\n\n# Check records and print results\nresults = check_records(test_cases)\nfor result in results:\n    print(result)\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    m0, x0, x1 = m, 0, 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef birthday_paradox(n, k):\n    MOD = 1000003\n    days = 1 << n  # 2^n\n    if k > days:\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the probability of no collision\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator *= (days - i)\n        denominator *= days\n        numerator %= MOD\n        denominator %= MOD\n\n    # Probability of at least one collision\n    A = (denominator - numerator) % MOD\n    B = denominator\n\n    # Reduce A/B to irreducible form\n    common_gcd = gcd(A, B)\n    A //= common_gcd\n    B //= common_gcd\n\n    return A % MOD, B % MOD\n\n# Input reading\nn, k = map(int, input().split())\nresult = birthday_paradox(n, k)\nprint(result[0], result[1])\n```",
    "35": "```python\ndef is_valid_flag(n, m, field):\n    # Check for horizontal stripes\n    stripe_height = n // 3\n    if n % 3 != 0 or stripe_height == 0:\n        return \"NO\"\n    \n    colors = set()\n    for i in range(3):\n        stripe_color = field[i * stripe_height][0]\n        if stripe_color not in 'RGB' or stripe_color in colors:\n            return \"NO\"\n        colors.add(stripe_color)\n        for j in range(stripe_height):\n            if field[i * stripe_height + j] != stripe_color * m:\n                return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Output result\nprint(is_valid_flag(n, m, field))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ns = input().strip()\n\nif not is_palindrome(s):\n    print(len(s))\nelse:\n    # Check for the longest non-palindrome substring\n    n = len(s)\n    if len(set(s)) == 1:  # All characters are the same\n        print(0)\n    else:\n        print(n - 1)  # The longest non-palindrome substring can be of length n-1\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    # Calculate the difference\n    diff = abs(sum_first - sum_second)\n    \n    # Create a list of possible changes\n    changes = []\n    if sum_first > sum_second:\n        # We need to decrease the first half or increase the second half\n        changes += [9 - digit for digit in first_half]  # Maximize decrease in first half\n        changes += [digit for digit in second_half]     # Maximize increase in second half\n    else:\n        # We need to decrease the second half or increase the first half\n        changes += [9 - digit for digit in second_half]  # Maximize decrease in second half\n        changes += [digit for digit in first_half]       # Maximize increase in first half\n    \n    # Sort changes in descending order\n    changes.sort(reverse=True)\n    \n    # Count the minimum number of changes needed\n    count = 0\n    for change in changes:\n        diff -= change\n        count += 1\n        if diff <= 0:\n            break\n            \n    return count\n\n# Read input\nticket = input().strip()\n# Output the result\nprint(min_replacements_to_lucky(ticket))\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n    \n    len_s = len(s)\n    total_count = 0\n    \n    # Generate all binary strings of length n\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        # Check if s is a substring in any cyclic shift of t\n        if any(s in t[i:] + t[:i] for i in range(n)):\n            total_count += 1\n            \n    return total_count\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_cyclic_strings(n, s))\n```",
    "36": "```python\ndef hexagonal_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 0\n\n    while moves_in_layer <= n:\n        layer += 1\n        moves_in_layer = 3 * layer * (layer + 1)  # Total moves in the current layer\n\n    layer -= 1\n    moves_in_layer = 3 * layer * (layer + 1)  # Total moves in the previous layer\n    remaining_moves = n - moves_in_layer\n\n    x, y = layer, 0  # Start at the rightmost point of the current layer\n\n    if remaining_moves == 0:\n        return (x, y)\n\n    # Move counter-clockwise around the hexagon\n    if remaining_moves <= layer:\n        x -= remaining_moves\n    elif remaining_moves <= 2 * layer:\n        x = -layer\n        y = remaining_moves - layer\n    else:\n        x = remaining_moves - 3 * layer\n        y = layer\n\n    return (x, y)\n\nn = int(input().strip())\nx, y = hexagonal_coordinates(n)\nprint(x, y)\n```",
    "41": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the distance array with a large number\ndistances = [float('inf')] * n\n\n# First pass: from left to right\nlast_zero = -1\nfor i in range(n):\n    if a[i] == 0:\n        last_zero = i\n    if last_zero != -1:\n        distances[i] = i - last_zero\n\n# Second pass: from right to left\nlast_zero = -1\nfor i in range(n - 1, -1, -1):\n    if a[i] == 0:\n        last_zero = i\n    if last_zero != -1:\n        distances[i] = min(distances[i], last_zero - i)\n\nprint(' '.join(map(str, distances)))\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Minimum sum of first k positive integers\n    min_sum = k * (k + 1) // 2\n    \n    if n < min_sum:\n        return -1\n    \n    # The maximum GCD we can use\n    g = (n - min_sum) // k + 1\n    \n    # Create the sequence\n    sequence = [i + g for i in range(1, k + 1)]\n    \n    return sequence\n\n# Read input\nn, k = map(int, input().split())\n\n# Get the result\nresult = find_sequence(n, k)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if any rating has changed\nrated = any(a != b for a, b in ratings)\n\nif rated:\n    print(\"rated\")\nelse:\n    # Check if the standings are in non-increasing order of ratings\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            print(\"unrated\")\n            break\n    else:\n        print(\"maybe\")\n```",
    "33": "```python\ndef count_common_integers(a1, b1, a2, b2, L, R):\n    from math import gcd\n\n    # Calculate the step size and the offset\n    step = abs(a1 * a2 // gcd(a1, a2))\n    \n    # Find the first valid x in the range [L, R]\n    def first_valid_x():\n        for k in range((L - b1) // a1, (R - b1) // a1 + 2):\n            x = a1 * k + b1\n            if L <= x <= R:\n                return x\n        return None\n\n    # Find the first valid x for the second progression\n    def first_valid_y():\n        for l in range((L - b2) // a2, (R - b2) // a2 + 2):\n            y = a2 * l + b2\n            if L <= y <= R:\n                return y\n        return None\n\n    x_start = first_valid_x()\n    y_start = first_valid_y()\n\n    if x_start is None or y_start is None:\n        return 0\n\n    # Find the first common x\n    if x_start < y_start:\n        x_start = ((y_start - b1 + a1 - 1) // a1) * a1 + b1\n    else:\n        y_start = ((x_start - b2 + a2 - 1) // a2) * a2 + b2\n\n    # Count the number of valid integers in the range\n    count = 0\n    for x in range(x_start, R + 1, step):\n        if L <= x <= R:\n            count += 1\n\n    return count\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n# Output the result\nprint(count_common_integers(a1, b1, a2, b2, L, R))\n```",
    "38": "```python\ndef can_be_same_track(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between barriers for Kefa and Sasha\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Check if sasha_diffs can be obtained by rotating kefa_diffs\n    for i in range(n):\n        if kefa_diffs[i:] + kefa_diffs[:i] == sasha_diffs:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_be_same_track(n, L, kefa_distances, sasha_distances))\n```",
    "46": "```python\ndef count_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n    \n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n        \n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n        \n    result = 0\n    for i in range(5):\n        result += count_x[i] * count_y[(5 - i) % 5]\n        \n    return result\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))\n```",
    "51": "```python\nfrom collections import Counter\nimport sys\nimport math\n\nn = int(input())\ndivisors = list(map(int, input().split()))\n\n# Count the occurrences of each divisor\ncount = Counter(divisors)\n\n# Find the maximum divisor\nmax_divisor = max(count)\n\n# Initialize x and y\nx = 1\ny = 1\n\n# Calculate x and y based on the divisors\nfor d in count:\n    if count[d] == 1:\n        # If the divisor appears once, it belongs to either x or y\n        if x * d <= y * d:\n            x *= d\n        else:\n            y *= d\n    else:\n        # If the divisor appears twice, it belongs to both x and y\n        x *= d\n        y *= d\n\n# Output the results\nprint(x, y)\n```",
    "54": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_a = min(a)\nmax_a = max(a)\n\nif min_a == max_a:\n    print(0)\nelse:\n    D = (max_a - min_a) // 2\n    if (max_a - min_a) % 2 == 0:\n        print(D)\n    else:\n        print(-1)\n```",
    "49": "```python\ndef find_kth_digit(k):\n    digit_length = 1\n    count = 9\n    start = 1\n\n    # Determine the range where the k-th digit lies\n    while k > digit_length * count:\n        k -= digit_length * count\n        digit_length += 1\n        count *= 10\n        start *= 10\n\n    # Find the actual number that contains the k-th digit\n    start += (k - 1) // digit_length\n    number_str = str(start)\n    \n    # Find the specific digit\n    digit_index = (k - 1) % digit_length\n    return number_str[digit_index]\n\n# Input\nk = int(input().strip())\n# Output\nprint(find_kth_digit(k))\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef reachable_count(n):\n    reachable = set()\n    current = n\n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    return len(reachable)\n\nn = int(input())\nprint(reachable_count(n))\n```",
    "44": "```python\ndef minimal_time_to_post_office(d, k, a, b, t):\n    # Calculate the time if Vasiliy walks the entire distance\n    walk_time = d * b\n    \n    # Initialize the minimum time with the walking time\n    min_time = walk_time\n    \n    # Calculate the number of full segments Vasiliy can drive\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Calculate the time for driving full segments and walking the remaining distance\n    drive_time = full_segments * k * a\n    repair_time = full_segments * t\n    total_time = drive_time + repair_time + remaining_distance * b\n    \n    # Update minimum time if this option is better\n    min_time = min(min_time, total_time)\n    \n    # Check if he can drive less than full segments and walk the rest\n    for i in range(full_segments + 1):\n        drive_distance = i * k\n        drive_time = drive_distance * a\n        repair_time = i * t\n        remaining_distance = d - drive_distance\n        \n        total_time = drive_time + repair_time + remaining_distance * b\n        min_time = min(min_time, total_time)\n    \n    return min_time\n\n# Input reading\nd, k, a, b, t = map(int, input().split())\n# Output the result\nprint(minimal_time_to_post_office(d, k, a, b, t))\n```",
    "57": "```python\nn = int(input())\nf = list(map(int, input().split()))\n\n# Find the friends who have not been assigned gifts\nassigned = set(f) - {0}\nunassigned = [i for i in range(1, n + 1) if i not in assigned]\n\n# Find the indices of friends who have not decided whom to give gifts to\nzero_indices = [i for i in range(n) if f[i] == 0]\n\n# Assign gifts to the friends who have not decided\nfor i in range(len(zero_indices)):\n    f[zero_indices[i]] = unassigned[i]\n\n# Print the result\nprint(' '.join(map(str, f)))\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = -1\n    moves = []\n    \n    while left <= right:\n        if a[left] < a[right]:\n            if a[left] > last_taken:\n                moves.append('L')\n                last_taken = a[left]\n                left += 1\n            elif a[right] > last_taken:\n                moves.append('R')\n                last_taken = a[right]\n                right -= 1\n            else:\n                break\n        else:\n            if a[right] > last_taken:\n                moves.append('R')\n                last_taken = a[right]\n                right -= 1\n            elif a[left] > last_taken:\n                moves.append('L')\n                last_taken = a[left]\n                left += 1\n            else:\n                break\n\n    print(len(moves))\n    print(''.join(moves))\n\n# Example usage:\nn = int(input())\na = list(map(int, input().split()))\nlongest_increasing_sequence(n, a)\n```",
    "58": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nfrom collections import defaultdict\n\n# Count occurrences of each number\ncount = defaultdict(int)\nfor num in a:\n    count[num] += 1\n\n# If any number occurs more than k times, it's impossible\nif any(c > k for c in count.values()):\n    print(\"NO\")\n    exit()\n\n# Prepare to assign colors\ncolor_assignment = [0] * n\ncolor_used = defaultdict(int)\n\n# Assign colors\nfor i in range(n):\n    num = a[i]\n    # Use the next color for this number\n    color_used[num] += 1\n    color_assignment[i] = color_used[num] if color_used[num] <= k else 0\n\n# Check if we used all colors\nif len(set(color_assignment)) < k:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(\" \".join(map(str, color_assignment)))\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph):\n    visited = {start: 0}\n    queue = deque([start])\n    farthest_node = start\n    max_distance = 0\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > max_distance:\n                    max_distance = visited[neighbor]\n                    farthest_node = neighbor\n                    \n    return farthest_node, max_distance\n\ndef find_max_edges(n, edges):\n    graph = defaultdict(list)\n    \n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Step 1: Find the farthest node from an arbitrary node (1)\n    farthest_from_start, _ = bfs(1, graph)\n    \n    # Step 2: Find the farthest node from the previously found farthest node\n    farthest_from_a, diameter_length = bfs(farthest_from_start, graph)\n    \n    # Step 3: Get the path from farthest_from_start to farthest_from_a\n    path = []\n    def get_path(node, parent):\n        path.append(node)\n        if node == farthest_from_a:\n            return True\n        for neighbor in graph[node]:\n            if neighbor != parent and get_path(neighbor, node):\n                return True\n        path.pop()\n        return False\n    \n    get_path(farthest_from_start, -1)\n    \n    # Step 4: Choose the three vertices\n    a = path[0]\n    b = path[len(path) // 2]\n    c = path[-1]\n    \n    # The maximum number of edges in the union of paths\n    max_edges = diameter_length + 1\n    \n    return max_edges, a, b, c\n\n# Input reading\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\n# Get the result\nresult = find_max_edges(n, edges)\n\n# Output the result\nprint(result[0])\nprint(result[1], result[2], result[3])\n```",
    "59": "```python\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# We need to ensure that the last x digits of the number have the form:\n# ...000...010...0 (where there are y zeros followed by a 1 and then (x-y-1) zeros)\n# This means we need to check the last x digits of the number.\n\n# The target pattern we want for the last x digits\ntarget = ['0'] * x\ntarget[y] = '1'\n\n# Count the number of changes needed\nchanges = 0\nfor i in range(x):\n    if number[n - 1 - i] != target[x - 1 - i]:\n        changes += 1\n\nprint(changes)\n```",
    "47": "```python\ndef max_beauty(n, x, a):\n    # Function to calculate maximum subarray sum using Kadane's algorithm\n    def kadane(arr):\n        max_ending_here = max_so_far = 0\n        for value in arr:\n            max_ending_here = max(0, max_ending_here + value)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    # Calculate the original beauty of the array\n    original_beauty = kadane(a)\n\n    # If x is 0, the best we can do is the original beauty\n    if x == 0:\n        return original_beauty\n\n    # Calculate the maximum beauty after multiplying a subarray by x\n    max_increase = 0\n    current_sum = 0\n    for i in range(n):\n        current_sum += a[i]\n        # Calculate the potential new beauty if we multiply the current subarray by x\n        potential_new_sum = current_sum * x\n        max_increase = max(max_increase, potential_new_sum)\n        # Reset current_sum if it becomes negative\n        if current_sum < 0:\n            current_sum = 0\n\n    # Calculate the maximum beauty after the operation\n    max_beauty_after_operation = original_beauty + max_increase\n\n    return max(max_beauty_after_operation, original_beauty)\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_beauty(n, x, a))\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_choose = m // 2\n    dp = [[-1] * k for _ in range(n + 1)]\n    dp[0][0] = 0  # Base case: sum of 0 is divisible by k\n\n    for i in range(1, n + 1):\n        row = sorted(matrix[i - 1], reverse=True)\n        current_dp = dp[i - 1][:]  # Copy previous row's dp\n\n        for j in range(1, max_choose + 1):\n            if j > len(row):\n                break\n            current_sum = sum(row[:j])\n            for mod in range(k):\n                if current_dp[mod] != -1:\n                    new_sum = current_dp[mod] + current_sum\n                    new_mod = new_sum % k\n                    current_dp[new_mod] = max(current_dp[new_mod], new_sum)\n\n        dp[i] = current_dp\n\n    return max(dp[n])\n\n# Input reading\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_sum_divisible_by_k(n, m, k, matrix))\n```",
    "63": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Sort the array to easily find min and max after removing one element\na.sort()\n\n# The minimum possible instability after removing one element\n# We can either remove the first element or the last element\nmin_instability = min(a[-1] - a[1], a[-2] - a[0])\n\nprint(min_instability)\n```",
    "71": "```python\nimport math\n\na = int(input())\noutput = math.ceil(math.log2(a))\nprint(output)\n```",
    "60": "```python\ndef has_palindrome_subsequence(test_cases):\n    results = []\n    for n, a in test_cases:\n        found = False\n        # Use a dictionary to track the last index of each number\n        last_index = {}\n        for i in range(n):\n            if a[i] in last_index:\n                # If we find the same number again and there's at least one element in between\n                if i - last_index[a[i]] > 1:\n                    found = True\n                    break\n            last_index[a[i]] = i\n        results.append(\"YES\" if found else \"NO\")\n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Get results\nresults = has_palindrome_subsequence(test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "55": "```python\ndef can_see_white_sheet(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n    # Check if there is any visible part of the white sheet\n    # Check left side\n    if x1 > x4 and x1 > x6:\n        return \"YES\"\n    # Check right side\n    if x2 < x3 and x2 < x5:\n        return \"YES\"\n    # Check bottom side\n    if y1 > y4 and y1 > y6:\n        return \"YES\"\n    # Check top side\n    if y2 < y3 and y2 < y5:\n        return \"YES\"\n    \n    # Check if the white sheet is completely covered by the black sheets\n    covered_left = (x3 <= x1 < x4) or (x5 <= x1 < x6)\n    covered_right = (x3 < x2 <= x4) or (x5 < x2 <= x6)\n    covered_bottom = (y3 <= y1 < y4) or (y5 <= y1 < y6)\n    covered_top = (y3 < y2 <= y4) or (y5 < y2 <= y6)\n    \n    if covered_left and covered_right and covered_bottom and covered_top:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Get the result and print it\nresult = can_see_white_sheet(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6)\nprint(result)\n```",
    "67": "```python\nn = int(input())\na = list(map(int, input().split()))\n\ntotal_sum = sum(a)\nnice_indices = []\n\nfor i in range(n):\n    remaining_sum = total_sum - a[i]\n    if remaining_sum == a[i] * 2:\n        nice_indices.append(i + 1)\n\nprint(len(nice_indices))\nif nice_indices:\n    print(' '.join(map(str, nice_indices)))\n```",
    "70": "```python\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Convert start and end times to total minutes\nstart_minutes = h1 * 60 + m1\nend_minutes = h2 * 60 + m2\n\n# Calculate the midpoint in total minutes\nmidpoint_minutes = (start_minutes + end_minutes) // 2\n\n# Convert back to hours and minutes\nh3 = midpoint_minutes // 60\nm3 = midpoint_minutes % 60\n\n# Print the result in the required format\nprint(f\"{h3:02}:{m3:02}\")\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        min_ops = float('inf')\n        best_triple = (0, 0, 0)\n\n        for A in range(1, a + 1):\n            for B in range(A, c + 1):\n                if B % A == 0:\n                    C = B * (B // A)\n                    if C >= B:\n                        ops = abs(A - a) + abs(B - b) + abs(C - c)\n                        if ops < min_ops:\n                            min_ops = ops\n                            best_triple = (A, B, C)\n\n        results.append((min_ops, best_triple))\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations(t, test_cases)\n\n# Output results\nfor ops, (A, B, C) in results:\n    print(ops)\n    print(A, B, C)\n```",
    "64": "```python\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Prepare the schedule\nschedule = [0] * n  # Initialize all days to rest (0)\nexam_days = [0] * n  # To track which days are exam days\n\n# Mark exam days\nfor i in range(m):\n    s, d, c = exams[i]\n    exam_days[d - 1] = i + 1  # Mark the exam day with the exam index (1-based)\n\n# Prepare for exams\npreparation_days = [0] * m  # Track how many days we have prepared for each exam\nfor i in range(n):\n    if exam_days[i] != 0:\n        exam_index = exam_days[i] - 1\n        schedule[i] = exam_days[i]  # Mark exam day\n    else:\n        # Try to prepare for exams\n        for j in range(m):\n            s, d, c = exams[j]\n            if s - 1 <= i < d - 1 and preparation_days[j] < c:\n                schedule[i] = j + 1  # Mark preparation for exam j\n                preparation_days[j] += 1\n                break\n\n# Check if all preparations are done\nif all(preparation_days[j] == exams[j][2] for j in range(m)):\n    print(\" \".join(map(str, schedule)))\nelse:\n    print(-1)\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Find the longest prefix which is also a suffix\n    lps = [0] * n\n    j = 0  # length of previous longest prefix suffix\n    i = 1\n\n    # Preprocess the pattern to create the lps array\n    while i < n:\n        if t[i] == t[j]:\n            j += 1\n            lps[i] = j\n            i += 1\n        else:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                lps[i] = 0\n                i += 1\n\n    # The length of the longest prefix which is also a suffix\n    longest_prefix_suffix = lps[-1]\n\n    # Construct the result string\n    # Start with the first occurrence of t\n    result = t\n\n    # Append (k-1) times the remaining part of t after the longest prefix suffix\n    result += t[longest_prefix_suffix:] * (k - 1)\n\n    return result\n\n# Read input\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the result and print it\nresult = construct_string(n, k, t)\nprint(result)\n```",
    "73": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmax_height = max(a)\ntotal_bricks_needed = sum(max_height - height for height in a)\n\n# Check if the total number of bricks needed is even\nif total_bricks_needed % 2 == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "77": "```python\nn = int(input())\ntotal_sum = n * (n + 1) // 2\nprint(total_sum % 2)\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import defaultdict\n    \n    # Count the frequency of each character in the string\n    freq = defaultdict(int)\n    for char in s:\n        freq[char] += 1\n    \n    # Calculate the number of unique subsequences we can generate\n    unique_subsequences = 0\n    costs = []\n    \n    # Generate subsequences and their costs\n    for char, count in freq.items():\n        for length in range(1, count + 1):\n            unique_subsequences += 1\n            costs.append(n - length)\n    \n    # If we can't generate enough unique subsequences\n    if unique_subsequences < k:\n        return -1\n    \n    # Sort costs to minimize the total cost\n    costs.sort()\n    \n    # Calculate the minimum cost for the first k unique subsequences\n    return sum(costs[:k])\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "81": "```python\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\n# Sort strings by their lengths\nstrings.sort(key=len)\n\n# Check if the order is valid\nfor i in range(1, n):\n    if strings[i-1] not in strings[i]:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")\n    print(\"\\n\".join(strings))\n```",
    "76": "```python\ndef can_construct_square(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        can_form_symmetric = False\n        for i in range(n):\n            a, b = tiles[i][0]\n            c, d = tiles[i][1]\n            for j in range(n):\n                if i != j:\n                    e, f = tiles[j][0]\n                    g, h = tiles[j][1]\n                    if b == g and c == f:\n                        can_form_symmetric = True\n                        break\n            if can_form_symmetric:\n                break\n        \n        results.append(\"YES\" if can_form_symmetric else \"NO\")\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        top = tuple(map(int, input().split()))\n        bottom = tuple(map(int, input().split()))\n        tiles.append((top, bottom))\n    test_cases.append((n, m, tiles))\n\n# Get results\nresults = can_construct_square(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import Counter\n    \n    # Count the frequency of each character\n    freq = Counter(s)\n    \n    # Calculate the total number of unique subsequences\n    unique_subsequences = 0\n    total_cost = 0\n    \n    # We can generate subsequences of different lengths\n    for length in range(1, n + 1):\n        # Calculate the number of unique subsequences of this length\n        # Using the formula: C(n, length) = n! / (length! * (n - length)!)\n        # We can use a simple combinatorial approach to count unique subsequences\n        # by considering the frequency of characters.\n        \n        # For each character, we can choose to include it or not\n        # Hence, the number of unique subsequences is 2^count - 1 for each character count\n        # But we need to consider the length of subsequences\n        \n        # Count how many unique subsequences we can form of this length\n        count = 0\n        for char, count_char in freq.items():\n            if count_char >= length:\n                count += 1\n        \n        # If we can form subsequences of this length\n        if count > 0:\n            unique_subsequences += count\n            total_cost += (n - length) * count\n        \n        # If we have reached or exceeded k unique subsequences, we can stop\n        if unique_subsequences >= k:\n            return total_cost\n    \n    # If we exit the loop and have not reached k unique subsequences\n    return -1\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result\nresult = min_cost_to_obtain_set(n, k, s)\n\n# Output the result\nprint(result)\n```",
    "82": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncount = 0\n\n# Solve from the left\nwhile count < n and a[count] <= k:\n    count += 1\n\n# Solve from the right\nwhile count < n and a[n - 1 - (count - (n - count))] <= k:\n    count += 1\n\n# If we counted the same problem from both ends, we need to adjust\nif count > n:\n    count = n\n\nprint(count)\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n    \n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Check if we can have degree D for vertex 1\n    if len(graph[1]) < D:\n        print(\"NO\")\n        return\n    \n    # Start building the spanning tree\n    spanning_tree_edges = []\n    visited = [False] * (n + 1)\n    visited[1] = True\n    queue = deque([1])\n    \n    # First, connect vertex 1 to D neighbors\n    degree_count = 0\n    for neighbor in graph[1]:\n        if degree_count < D:\n            spanning_tree_edges.append((1, neighbor))\n            visited[neighbor] = True\n            degree_count += 1\n        else:\n            break\n    \n    # Now, we need to add the rest of the edges to form a spanning tree\n    for neighbor in graph[1]:\n        if degree_count >= D:\n            break\n        if not visited[neighbor]:\n            spanning_tree_edges.append((1, neighbor))\n            visited[neighbor] = True\n            degree_count += 1\n    \n    # BFS to add remaining edges to the spanning tree\n    for start in range(2, n + 1):\n        if not visited[start]:\n            queue.append(start)\n            visited[start] = True\n            while queue:\n                current = queue.popleft()\n                for neighbor in graph[current]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        spanning_tree_edges.append((current, neighbor))\n                        queue.append(neighbor)\n                        if len(spanning_tree_edges) == n - 1:\n                            break\n                if len(spanning_tree_edges) == n - 1:\n                    break\n    \n    # Check if we have a valid spanning tree\n    if len(spanning_tree_edges) == n - 1:\n        print(\"YES\")\n        for u, v in spanning_tree_edges:\n            print(u, v)\n    else:\n        print(\"NO\")\n\n# Read input\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Find and print the spanning tree\nfind_spanning_tree(n, m, D, edges)\n```",
    "72": "```python\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Precompute the maximum left and minimum right endpoints\nmax_left = [0] * n\nmin_right = [0] * n\n\nmax_left[0] = segments[0][0]\nmin_right[0] = segments[0][1]\n\nfor i in range(1, n):\n    max_left[i] = max(max_left[i - 1], segments[i][0])\n    min_right[i] = min(min_right[i - 1], segments[i][1])\n\nmax_left_rev = [0] * n\nmin_right_rev = [0] * n\n\nmax_left_rev[n - 1] = segments[n - 1][0]\nmin_right_rev[n - 1] = segments[n - 1][1]\n\nfor i in range(n - 2, -1, -1):\n    max_left_rev[i] = max(max_left_rev[i + 1], segments[i][0])\n    min_right_rev[i] = min(min_right_rev[i + 1], segments[i][1])\n\nmax_length = 0\n\nfor i in range(n):\n    left = max(max_left[i - 1] if i > 0 else float('-inf'), max_left_rev[i + 1] if i < n - 1 else float('-inf'))\n    right = min(min_right[i - 1] if i > 0 else float('inf'), min_right_rev[i + 1] if i < n - 1 else float('inf'))\n    \n    if left <= right:\n        max_length = max(max_length, right - left)\n\nprint(max_length)\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    from collections import defaultdict\n    \n    # Step 1: Create a mapping of character positions\n    char_positions = defaultdict(list)\n    for index, char in enumerate(s):\n        char_positions[char].append(index)\n    \n    # Step 2: Create a list of colors\n    colors = [0] * n\n    color_count = 0\n    \n    # Step 3: Iterate through the characters in sorted order\n    sorted_chars = sorted(char_positions.keys())\n    for char in sorted_chars:\n        positions = char_positions[char]\n        # Assign a new color for each group of positions\n        for i in range(len(positions)):\n            if i == 0:\n                color_count += 1\n            colors[positions[i]] = color_count\n    \n    # Step 4: Output the result\n    print(color_count)\n    print(' '.join(map(str, colors)))\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\nmin_colors_to_sort(n, s)\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects by their required rating (a_i)\n    projects.sort(key=lambda x: x[0])\n    \n    count = 0\n    current_rating = r\n    \n    for a, b in projects:\n        if current_rating >= a:  # Can start the project\n            count += 1\n            current_rating += b  # Update rating after completing the project\n            if current_rating < 0:  # Ensure rating doesn't fall below zero\n                current_rating = 0\n    \n    return count\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_projects(n, r, projects))\n```",
    "86": "```python\ndef solve_problems(n, k):\n    # Minimum sum of problems that can be solved in k days\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n    \n    # Maximum sum of problems that can be solved in k days\n    max_sum = 0\n    a = []\n    current = 1\n    \n    for i in range(k):\n        a.append(current)\n        max_sum += current\n        current = min(2 * current, current + 1 + (k - i - 1))\n    \n    if n > max_sum:\n        print(\"NO\")\n        return\n    \n    # Now we need to adjust the array to sum to n\n    for i in range(k - 1, -1, -1):\n        while sum(a) < n and a[i] < (2 * a[i]):\n            a[i] += 1\n            if sum(a) == n:\n                break\n    \n    if sum(a) == n:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n    else:\n        print(\"NO\")\n\n# Read input\nn, k = map(int, input().split())\nsolve_problems(n, k)\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects by their required rating\n    projects.sort(key=lambda x: x[0])\n    \n    for a, b in projects:\n        if r < a:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_complete_projects(n, r, projects))\n```",
    "84": "```python\ndef can_color_string(n, s):\n    # Count the frequency of each character\n    from collections import Counter\n    count = Counter(s)\n    \n    # Check if any character appears more than twice\n    if any(freq > 2 for freq in count.values()):\n        return \"NO\"\n    \n    # Initialize the coloring array\n    coloring = ['0'] * n\n    \n    # Assign colors based on the characters\n    color = 0\n    for i in range(n):\n        if i > 0 and s[i] == s[i - 1]:\n            coloring[i] = coloring[i - 1]  # Same color as previous\n        else:\n            coloring[i] = str(color)  # Alternate colors\n            color = 1 - color  # Switch color\n    \n    return \"YES\", ''.join(coloring)\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult = can_color_string(n, s)\n\n# Print the result\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    print(result[1])\n```",
    "90": "```python\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculate the total length of platforms\ntotal_length = sum(c)\n\n# If the maximum jump distance is greater than or equal to the width of the river,\n# we can always reach the other side.\nif d >= n + 1:\n    print(\"YES\")\n    print(\"0 \" + \"0 \" * (n - total_length) + \" \".join(str(i + 1) for i in range(m)))\nelse:\n    # We need to check if we can place the platforms such that we can jump across\n    # We will try to place the platforms with at least `d` distance between them\n    positions = []\n    current_position = 0\n\n    for i in range(m):\n        positions.append(current_position)\n        current_position += c[i]\n\n        # Ensure there's enough space for the next platform\n        if i < m - 1:\n            current_position += d\n\n    # Check if the last platform can reach the end\n    if positions[-1] + c[-1] + d < n + 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        result = [0] * n\n        for i in range(m):\n            for j in range(c[i]):\n                result[positions[i] + j] = i + 1\n        print(\" \".join(map(str, result)))\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    \n    # Check for possible pairs of digits that can form 25 or 00\n    target_pairs = ['00', '25', '50', '75']\n    min_moves = float('inf')\n    \n    for target in target_pairs:\n        # Find the last digit of the target\n        last_digit = target[1]\n        first_digit = target[0]\n        \n        # Find the position of the last digit in the number\n        last_digit_pos = -1\n        for i in range(length - 1, -1, -1):\n            if s[i] == last_digit:\n                last_digit_pos = i\n                break\n        \n        if last_digit_pos == -1:\n            continue\n        \n        # Now find the first digit before the last digit found\n        first_digit_pos = -1\n        for i in range(last_digit_pos - 1, -1, -1):\n            if s[i] == first_digit:\n                first_digit_pos = i\n                break\n        \n        if first_digit_pos == -1:\n            continue\n        \n        # Calculate moves to bring last_digit to the end\n        moves_to_end = length - 1 - last_digit_pos\n        \n        # Calculate moves to bring first_digit to the position before last_digit\n        moves_to_first = last_digit_pos - first_digit_pos\n        \n        total_moves = moves_to_end + moves_to_first\n        \n        min_moves = min(min_moves, total_moves)\n    \n    return min_moves if min_moves != float('inf') else -1\n\n# Input reading\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    min_perimeter = float('inf')\n    \n    # Iterate over all possible widths for the red rectangle\n    for width_r in range(1, int(a**0.5) + 1):\n        if a % width_r == 0:\n            height_r = a // width_r\n            \n            # Now iterate over all possible widths for the blue rectangle\n            for width_b in range(1, int(b**0.5) + 1):\n                if b % width_b == 0:\n                    height_b = b // width_b\n                    \n                    # Calculate the total width and height of the combined rectangle\n                    total_width = max(width_r, width_b)\n                    total_height = height_r + height_b\n                    \n                    # Calculate the perimeter\n                    perimeter = 2 * (total_width + total_height)\n                    min_perimeter = min(min_perimeter, perimeter)\n                    \n                    # Also check the other orientation for blue rectangle\n                    total_width = width_r + width_b\n                    total_height = max(height_r, height_b)\n                    \n                    perimeter = 2 * (total_width + total_height)\n                    min_perimeter = min(min_perimeter, perimeter)\n    \n    return min_perimeter\n\n# Input reading\na, b = map(int, input().split())\nprint(minimal_perimeter(a, b))\n```",
    "92": "```python\nx = float(input().strip())\n\n# We need to find two integers a and b such that 1 <= a, b <= 10\n# and a * b is approximately equal to x.\n\n# Since x is between 0 and 5, we can iterate through possible values of a and b\nfor a in range(1, 11):\n    for b in range(1, 11):\n        if abs(a * b - x) < 1e-6:  # Check if the product is close to x\n            print(a, b)\n            break\n```",
    "97": "```python\nn = int(input())\nchips = list(map(int, input().split()))\n\neven_count = sum(1 for x in chips if x % 2 == 0)\nodd_count = n - even_count\n\n# Minimum coins required to move all chips to the same coordinate\nresult = min(even_count, odd_count)\nprint(result)\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n\n    # Create arrays to store the first occurrence of t in s from the left and right\n    left = [0] * m\n    right = [0] * m\n\n    # Fill the left array\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n\n    # Fill the right array\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n\n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n\n    # Check the case where we can remove from the start to the first character of t\n    max_length = max(max_length, left[0])\n    # Check the case where we can remove from the last character of t to the end\n    max_length = max(max_length, n - 1 - right[m - 1])\n\n    return max_length\n\n# Input reading\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(max_removable_length(s, t))\n```",
    "95": "```python\nn = int(input())\ns = input().strip()\nt = input().strip()\n\n# Create a list of characters to use in the result\nresult = ['a'] * n + ['b'] * n + ['c'] * n\n\n# Function to check if the current result contains forbidden substrings\ndef contains_forbidden_substrings(res, s, t):\n    return s in res or t in res\n\n# Try to generate a valid string\nfrom itertools import permutations\n\n# Generate all permutations of the result\nfor perm in permutations(result):\n    res = ''.join(perm)\n    if not contains_forbidden_substrings(res, s, t):\n        print(\"YES\")\n        print(res)\n        break\nelse:\n    print(\"NO\")\n```",
    "88": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nfrom collections import Counter\n\ncount = Counter(a)\n\n# Check if we can form a palindromic matrix\nodd_count = 0\nfor value in count.values():\n    if value % 2 != 0:\n        odd_count += 1\n\n# For odd n, we can have at most one odd count\n# For even n, we cannot have any odd counts\nif (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n    print(\"NO\")\nelse:\n    # Create the matrix\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Fill the matrix\n    half = []\n    center = None\n    \n    for value, freq in count.items():\n        if freq % 2 == 1:\n            center = value  # For odd n, we can have a center element\n        half.extend([value] * (freq // 2))\n    \n    half.sort()\n    \n    # Fill the top half of the matrix\n    for i in range(n // 2):\n        for j in range(n // 2):\n            matrix[i][j] = half.pop(0)\n            matrix[i][n - j - 1] = matrix[i][j]\n            matrix[n - i - 1][j] = matrix[i][j]\n            matrix[n - i - 1][n - j - 1] = matrix[i][j]\n    \n    # If n is odd, fill the center row and column\n    if n % 2 == 1:\n        for j in range(n):\n            matrix[n // 2][j] = half.pop(0)\n            matrix[j][n // 2] = half.pop(0)\n        matrix[n // 2][n // 2] = center\n    \n    print(\"YES\")\n    for row in matrix:\n        print(\" \".join(map(str, row)))\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    # Initialize the first element of the permutation\n    p = [0] * n\n    p[0] = 1  # Start with p1 = 1\n\n    # Calculate the rest of the permutation based on q\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n\n    # Find the minimum and maximum values in the permutation\n    min_p = min(p)\n    max_p = max(p)\n\n    # Check if the values are within the valid range and unique\n    if max_p - min_p + 1 != n or len(set(p)) != n:\n        print(-1)\n    else:\n        # Adjust the permutation to start from 1\n        adjustment = 1 - min_p\n        p = [x + adjustment for x in p]\n        print(\" \".join(map(str, p)))\n\n# Read input\nn = int(input())\nq = list(map(int, input().split()))\n\n# Restore the permutation\nrestore_permutation(n, q)\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1:\n        print(\"NO\")\n        return\n    \n    if d == 1 and n > 1:\n        print(\"NO\")\n        return\n    \n    if n == 1:\n        print(\"YES\")\n        return\n    \n    edges = []\n    \n    # Create the main path of length d\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n    \n    # Now we have d + 1 vertices in the path\n    current_vertex = d + 2\n    \n    # Attach remaining vertices to the first vertex in the path\n    for i in range(current_vertex, n + 1):\n        edges.append((1, i))\n    \n    # Check if any vertex exceeds degree k\n    degree_count = [0] * (n + 1)\n    for u, v in edges:\n        degree_count[u] += 1\n        degree_count[v] += 1\n    \n    if any(degree > k for degree in degree_count[1:]):\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    for u, v in edges:\n        print(u, v)\n\n# Read input\nn, d, k = map(int, input().split())\nconstruct_tree(n, d, k)\n```",
    "78": "```python\nMOD = 10**9 + 7\n\ndef count_regular_sequences(n, s):\n    m = len(s)\n    \n    # Precompute factorials and inverse factorials\n    fact = [1] * (2 * n + 1)\n    for i in range(2, 2 * n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    \n    def mod_inv(x):\n        return pow(x, MOD - 2, MOD)\n    \n    inv_fact = [1] * (2 * n + 1)\n    for i in range(2, 2 * n + 1):\n        inv_fact[i] = mod_inv(fact[i])\n    \n    # Check if s can be part of a valid sequence\n    balance = 0\n    min_balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n    \n    if balance < 0 or balance > 2 * n or min_balance < 0:\n        return 0\n    \n    # Count valid sequences\n    total_sequences = 0\n    for prefix_length in range(max(0, n - (m - balance)), n + 1):\n        suffix_length = n - prefix_length\n        if suffix_length < 0 or suffix_length + balance < 0:\n            continue\n        \n        # Calculate the number of ways to arrange the remaining brackets\n        remaining_open = prefix_length + (balance // 2)\n        remaining_close = suffix_length + (balance // 2)\n        \n        if remaining_open < 0 or remaining_close < 0:\n            continue\n        \n        total_sequences += (fact[remaining_open + remaining_close] * inv_fact[remaining_open] % MOD) * inv_fact[remaining_close] % MOD\n        total_sequences %= MOD\n    \n    return total_sequences\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(count_regular_sequences(n, s))\n```",
    "99": "```python\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\n# Maximum wins for Alice\nmax_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n\n# Minimum wins for Alice\n# Calculate losses for Alice\nalice_losses = 0\nalice_losses += max(0, b1 - a3)  # Bob's rock beats Alice's paper\nalice_losses += max(0, b2 - a1)  # Bob's scissors beat Alice's rock\nalice_losses += max(0, b3 - a2)  # Bob's paper beats Alice's scissors\n\n# Minimum wins for Alice\nmin_wins = n - alice_losses\n\nprint(min_wins, max_wins)\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Start with the maximum number of transitions\n    transitions = min(x, a + b - 1)\n    \n    # Determine the base pattern\n    pattern = []\n    if transitions % 2 == 0:\n        # Start with 0 if we have an even number of transitions\n        start_with_zero = True\n    else:\n        # Start with 1 if we have an odd number of transitions\n        start_with_zero = False\n    \n    # Create the alternating pattern\n    for i in range(transitions + 1):\n        if (i % 2 == 0) == start_with_zero:\n            pattern.append('0')\n        else:\n            pattern.append('1')\n    \n    # Count how many 0s and 1s we have used\n    used_zeros = pattern.count('0')\n    used_ones = pattern.count('1')\n    \n    # Calculate remaining 0s and 1s\n    remaining_zeros = a - used_zeros\n    remaining_ones = b - used_ones\n    \n    # Fill the remaining 0s and 1s\n    if remaining_zeros > 0:\n        if pattern[0] == '0':\n            pattern = ['0'] * remaining_zeros + pattern\n        else:\n            pattern = ['0'] * remaining_zeros + pattern + ['0'] * remaining_zeros\n    \n    if remaining_ones > 0:\n        if pattern[0] == '1':\n            pattern = ['1'] * remaining_ones + pattern\n        else:\n            pattern = ['1'] * remaining_ones + pattern + ['1'] * remaining_ones\n    \n    # Join the pattern into a string\n    result = ''.join(pattern)\n    \n    # Ensure the string has exactly a zeros and b ones\n    result = result[:a + b]\n    \n    return result\n\n# Input reading\na, b, x = map(int, input().split())\n# Output the result\nprint(construct_binary_string(a, b, x))\n```"
}