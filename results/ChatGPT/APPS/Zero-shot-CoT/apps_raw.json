{
    "0": "```python\ndef solve():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        words = []\n        word_set = set()\n        reversals = []\n        for i in range(n):\n            word = data[index]\n            index += 1\n            \n            words.append(word)\n            word_set.add(word)\n            reversals.append((word[::-1], i + 1))  # (reversed word, original index)\n\n        reverse_map = defaultdict(int)\n        for word in words:\n            reverse_map[(word[0], word[-1])] += 1\n        \n        total_reversals = 0\n        to_reverse = []\n\n        for rev_word, orig_index in reversals:\n            if reverse_map[(rev_word[0], rev_word[-1])] > 0:\n                reverse_map[(rev_word[0], rev_word[-1])] -= 1\n                to_reverse.append(orig_index)\n                total_reversals += 1\n\n        if total_reversals == n:\n            results.append(f\"{total_reversals}\")\n            results.append(\" \".join(map(str, to_reverse)))\n        else:\n            results.append(\"-1\")\n\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()\n```",
    "1": "```python\ndef max_diagonal_moves(q, queries):\n    results = []\n    for n, m, k in queries:\n        # Calculate the minimum moves required to reach (n, m)\n        min_moves = max(n, m)\n        # Check if it's possible to reach (n, m) in exactly k moves\n        if k < min_moves or (k - min_moves) % 2 != 0:\n            results.append(-1)\n        else:\n            # The maximum number of diagonal moves we can make\n            diagonal_moves = min(n, m)\n            # Remaining moves after reaching the target\n            remaining_moves = k - min_moves\n            # Remaining moves can be used to move back and forth\n            max_diagonal = diagonal_moves + min(remaining_moves, (n + m) - diagonal_moves)\n            results.append(max_diagonal)\n    \n    return results\n\n# Read input\nq = int(input())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Get results\nresults = max_diagonal_moves(q, queries)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "2": "```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index].split()))\n        index += 1\n        b = list(map(int, data[index].split()))\n        index += 1\n        c = list(map(int, data[index].split()))\n        index += 1\n        \n        p = [0] * n\n        \n        for i in range(n):\n            if i == 0:\n                p[i] = a[i]  # Start with a1\n            else:\n                if a[i] != p[i - 1]:\n                    p[i] = a[i]\n                elif b[i] != p[i - 1]:\n                    p[i] = b[i]\n                else:\n                    p[i] = c[i]\n        \n        # To ensure the last element is not equal to the first\n        if p[n - 1] == p[0]:\n            if a[n - 1] != p[n - 2] and a[n - 1] != p[0]:\n                p[n - 1] = a[n - 1]\n            elif b[n - 1] != p[n - 2] and b[n - 1] != p[0]:\n                p[n - 1] = b[n - 1]\n            else:\n                p[n - 1] = c[n - 1]\n        \n        results.append(\" \".join(map(str, p)))\n    \n    print(\"\\n\".join(results))\n\nsolve()\n```",
    "3": "```python\ndef max_difference(t, test_cases):\n    results = []\n    for n, k, a in test_cases:\n        # Calculate the total amount of water in all barrels\n        total_water = sum(a)\n        # The maximum possible amount in one barrel after pouring k times\n        max_possible = total_water\n        # The minimum possible amount in one barrel (can be 0 if we pour all water into one barrel)\n        min_possible = 0\n        # Calculate the maximum difference\n        max_diff = max_possible - min_possible\n        results.append(max_diff)\n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, k, a))\n\n# Get results and print them\nresults = max_difference(t, test_cases)\nfor result in results:\n    print(result)\n```",
    "4": "```python\ndef is_beautiful_permutation(t, test_cases):\n    results = []\n    \n    for n, p in test_cases:\n        beautiful = ['0'] * n\n        max_seen = 0\n        \n        for i in range(n):\n            max_seen = max(max_seen, p[i])\n            if max_seen == i + 1:\n                beautiful[i] = '1'\n        \n        results.append(''.join(beautiful))\n    \n    return results\n\n\n# Reading input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    p = list(map(int, input().split()))\n    test_cases.append((n, p))\n\n# Getting results\nresults = is_beautiful_permutation(t, test_cases)\n\n# Printing output\nfor result in results:\n    print(result)\n```",
    "5": "```python\ndef count_permutations(t, test_cases):\n    results = []\n    \n    for n, a in test_cases:\n        count = [0] * (n + 1)\n        for num in a:\n            count[num] += 1\n        \n        left_set, right_set = set(), set()\n        k = 0\n        ways = []\n        \n        for i in range(n):\n            left_set.add(a[i])\n            count[a[i]] -= 1\n            \n            if count[a[i]] == 0:\n                right_set.add(a[i])\n                \n            l1 = i + 1\n            l2 = n - l1\n            \n            if len(left_set) == l1 and len(right_set) == l2:\n                k += 1\n                ways.append((l1, l2))\n        \n        results.append((k, ways))\n    \n    return results\n\n# Input handling\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\n\nindex = 1\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1].split()))\n    test_cases.append((n, a))\n    index += 2\n\nresults = count_permutations(t, test_cases)\n\n# Output\noutput = []\nfor k, ways in results:\n    output.append(str(k))\n    for l1, l2 in ways:\n        output.append(f\"{l1} {l2}\")\n\nprint(\"\\n\".join(output))\n```",
    "6": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(T):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        # We will close the last (4/7)n spots\n        k = min(n, (4 * n) // 7)\n        # We can safely close the last k spots\n        closed_spots = list(range(n - k + 1, n + 1))\n\n        results.append(f\"{k}\")\n        results.append(\" \".join(map(str, closed_spots)))\n\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "7": "```python\ndef minimum_coins_to_win(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n = case[0]\n        voters = case[1]\n        \n        # Sort voters by the number of votes they need to convince others (m_i)\n        voters.sort(key=lambda x: (x[0], x[1]))\n        \n        # Initialize a list to store the minimum cost to convince each voter\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0  # Base case: 0 voters costs 0 coins\n        \n        for m, p in voters:\n            # Traverse backwards to avoid overwriting values that are needed for this iteration\n            for j in range(n, 0, -1):\n                if j - 1 >= m:\n                    dp[j] = min(dp[j], dp[j - 1] + p)\n        \n        # The answer for this test case is the minimum cost to convince all n voters\n        result = min(dp[j] for j in range(n, n + 1))\n        results.append(result)\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\n\nfor _ in range(t):\n    n = int(input())\n    voters = []\n    for _ in range(n):\n        m, p = map(int, input().split())\n        voters.append((m, p))\n    test_cases.append((n, voters))\n\n# Get results and print them\nresults = minimum_coins_to_win(t, test_cases)\nfor res in results:\n    print(res)\n```",
    "8": "```python\ndef max_chess_score(t, test_cases):\n    results = []\n    for n, k, s in test_cases:\n        # Calculate initial score\n        score = 0\n        for i in range(n):\n            if s[i] == 'W':\n                if i == 0 or s[i - 1] == 'L':\n                    score += 1\n                else:\n                    score += 2\n        \n        # Now we have the initial score, let's try to maximize it\n        # Count the number of wins and losses\n        win_segments = []\n        current_wins = 0\n        \n        for i in range(n):\n            if s[i] == 'W':\n                current_wins += 1\n            else:\n                if current_wins > 0:\n                    win_segments.append(current_wins)\n                current_wins = 0\n        \n        if current_wins > 0:\n            win_segments.append(current_wins)\n        \n        # Calculate potential gains from changing losses to wins\n        max_score = score\n        max_gains = []\n        \n        for segment in win_segments:\n            if segment > 0:\n                max_gains.append(segment * 2 - 1)  # Each segment can be extended by 1 win\n            else:\n                max_gains.append(1)  # Each loss can be converted to a win, gaining 1 point\n        \n        # Sort from maximum gain to minimum gain\n        max_gains.sort(reverse=True)\n\n        # Apply changes based on the allowed k\n        for i in range(min(k, len(max_gains))):\n            max_score += max_gains[i]\n        \n        results.append(max_score)\n    \n    return results\n\n# Example usage:\nt = 8\ntest_cases = [\n    (5, 2, \"WLWLL\"),\n    (6, 5, \"LLLWWL\"),\n    (7, 1, \"LWLWLWL\"),\n    (15, 5, \"WWWLLLWWWLLLWWW\"),\n    (40, 7, \"LLWLWLWWWLWLLWLWWWLWLLWLLWLLLLWLLWWWLWWL\"),\n    (1, 0, \"L\"),\n    (1, 1, \"L\"),\n    (6, 1, \"WLLWLW\")\n]\n\nprint(max_chess_score(t, test_cases))\n```",
    "9": "```python\ndef alice_score(s):\n    score_alice = 0\n    score_bob = 0\n    current_char = None\n    count = 0\n    \n    # Count the number of 1's and group them by segments\n    for char in s:\n        if char == current_char:\n            count += 1\n        else:\n            if current_char == '1':\n                score_alice += count if (count % 2 == 1) else count // 2\n                score_bob += count // 2\n            count = 1\n            current_char = char\n            \n    # Last segment\n    if current_char == '1':\n        score_alice += count if (count % 2 == 1) else count // 2\n        score_bob += count // 2\n\n    return score_alice\n\n# Read input\nT = int(input())\nfor _ in range(T):\n    s = input().strip()\n    print(alice_score(s))\n```",
    "10": "```python\ndef find_maximum_subsequence(t, test_cases):\n    results = []\n    \n    for n, p in test_cases:\n        # Initialize variables to store the best subsequence\n        best_subsequence = []\n        \n        # We will always take the first and last element of the permutation\n        best_subsequence.append(p[0])\n        best_subsequence.append(p[-1])\n        \n        # Append the result for this test case\n        results.append((len(best_subsequence), best_subsequence))\n    \n    return results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nt = int(data[0])\ntest_cases = []\n\nline_index = 1\nfor _ in range(t):\n    n = int(data[line_index])\n    p = list(map(int, data[line_index + 1].split()))\n    test_cases.append((n, p))\n    line_index += 2\n\n# Finding the results\nresults = find_maximum_subsequence(t, test_cases)\n\n# Outputting results\noutput = []\nfor k, subsequence in results:\n    output.append(f\"{k}\")\n    output.append(\" \".join(map(str, subsequence)))\n\nprint(\"\\n\".join(output))\n```",
    "11": "```python\ndef min_area_after_insertion(s):\n    # Count the moves in each direction\n    up = s.count('W')\n    down = s.count('S')\n    left = s.count('A')\n    right = s.count('D')\n    \n    # Calculate the initial area of the grid\n    height = up + down + 1\n    width = left + right + 1\n    min_area = height * width\n    \n    # Check if inserting an extra command can reduce the area\n    # We will consider each of the four possible insertions\n    for extra in ['W', 'S', 'A', 'D']:\n        # Create a new counts based on the extra command\n        if extra == 'W':\n            new_height = (up + 1) + down + 1\n        elif extra == 'S':\n            new_height = up + (down + 1) + 1\n        else:\n            new_height = up + down + 1\n        \n        if extra == 'A':\n            new_width = (left + 1) + right + 1\n        elif extra == 'D':\n            new_width = left + (right + 1) + 1\n        else:\n            new_width = left + right + 1\n        \n        new_area = new_height * new_width\n        min_area = min(min_area, new_area)\n    \n    return min_area\n\nT = int(input())\nresults = []\n\nfor _ in range(T):\n    s = input().strip()\n    results.append(min_area_after_insertion(s))\n\nprint('\\n'.join(map(str, results)))\n```",
    "12": "```python\ndef can_transform(a, b):\n    n = len(a)\n    can_increase = False\n    can_decrease = False\n\n    for i in range(n):\n        if a[i] == 1:\n            can_increase = True\n        elif a[i] == -1:\n            can_decrease = True\n\n        if b[i] > a[i] and not can_increase:\n            return \"NO\"\n        if b[i] < a[i] and not can_decrease:\n            return \"NO\"\n\n    return \"YES\"\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    result = can_transform(a, b)\n    results.append(result)\n\nprint(\"\\n\".join(results))\n```",
    "13": "```python\ndef min_days_to_repair_highway(test_cases):\n    results = []\n    for n, g, b in test_cases:\n        # Calculate the minimum high-quality pavement needed\n        high_quality_needed = (n + 1) // 2\n        \n        # Calculate how many full cycles of good and bad days are needed\n        full_cycles_needed = (high_quality_needed + g - 1) // g\n        total_days = full_cycles_needed * (g + b)  # Total days for full cycles\n        \n        # Calculate how many high-quality days we can actually use\n        high_quality_days_used = full_cycles_needed * g\n        \n        # If we have used enough high-quality days, we need to check if we need more days\n        if high_quality_days_used >= high_quality_needed:\n            total_days -= (high_quality_days_used - high_quality_needed)\n        else:\n            # We need to account for the remaining high-quality days after full cycles\n            remaining_high_quality_needed = high_quality_needed - high_quality_days_used\n            total_days += remaining_high_quality_needed  # Add the needed high-quality days\n\n        # Make sure we do not exceed the total length of the highway\n        total_days = max(total_days, n)\n        \n        results.append(total_days)\n    \n    return results\n\n\n# Input reading\nT = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(T)]\n\n# Get the results\nresults = min_days_to_repair_highway(test_cases)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "14": "```python\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    a1, b1 = map(int, input().split())\n    a2, b2 = map(int, input().split())\n\n    # Check if a square can be formed\n    if (a1 == a2 and b1 + b2 == a1) or (a1 == b2 and b1 + a2 == a1) or (b1 == a2 and a1 + b2 == b1) or (b1 == b2 and a1 + a2 == b1):\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nprint(\"\\n\".join(results))\n```",
    "15": "```python\ndef maximal_window_area(t, test_cases):\n    results = []\n    for a, b, x, y in test_cases:\n        # Calculate the maximum area avoiding the dead pixel\n        max_area = max((x + 1) * b, (a - x - 1) * b, a * (y + 1), a * (b - y - 1))\n        results.append(max_area)\n    return results\n\n# Read input\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = maximal_window_area(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "16": "```python\ndef max_score(tc, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, (C, T), problems = case\n        problems.sort(key=lambda x: (-x[1] / (x[0] / 1.0), x[0]))  # sort by score/difficulty ratio and then by difficulty\n        \n        max_score = 0\n        \n        for training_time in range(int(T) + 1):\n            if training_time % 10 != 0:\n                continue\n            \n            # Calculate the new skill after training\n            s = 1.0 + C * (training_time / 60.0)  # Convert training_time to hours for C\n            \n            total_time = training_time\n            score = 0\n            \n            for a_i, p_i in problems:\n                if total_time + 10 > T:\n                    break  # Not enough time to watch the episode\n                \n                total_time += 10  # Watch an episode\n                s *= 0.9  # Skill decreases by 10%\n                \n                time_needed = a_i / s\n                if total_time + time_needed > T:\n                    break  # Not enough time to solve the problem\n                \n                total_time += time_needed\n                score += p_i\n            \n            max_score = max(max_score, score)\n        \n        results.append(max_score)\n    \n    return results\n\n\n# Input reading and function calling\ntc = int(input())\ntest_cases = []\nfor _ in range(tc):\n    n = int(input())\n    C, T = map(float, input().split())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, (C, T), problems))\n\nresults = max_score(tc, test_cases)\nfor result in results:\n    print(result)\n```",
    "17": "```python\ndef count_tuples(test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        count = 0\n        # Dictionary to store the occurrence of each number\n        positions = {}\n        \n        for i in range(n):\n            if a[i] not in positions:\n                positions[a[i]] = []\n            positions[a[i]].append(i)\n\n        # Now we will find valid tuples\n        for j in range(n):\n            for l in range(j + 1, n):\n                if a[j] == a[l]:\n                    # We need to find pairs (i, k) such that i < j < k\n                    for i in range(j):\n                        if a[i] == a[j]:  # a[i] == a[k]\n                            count += len(positions[a[i]]) - (i + 1)  # k must be after i\n            \n        results.append(count)\n\n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Get results\nresults = count_tuples(test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "18": "```python\nimport math\n\ndef minimum_square_size(n):\n    # The length of the side of the square needed to embed the 2n-gon\n    # is derived using the formula: 2 * (1 + sin(π/n))\n    return math.sqrt(2) * (1 + math.sin(math.pi / n))\n\ndef main():\n    T = int(input())\n    results = []\n    for _ in range(T):\n        n = int(input())\n        result = minimum_square_size(n)\n        results.append(f\"{result:.9f}\")\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "19": "```python\ndef min_subscriptions(t, cases):\n    results = []\n    for n, k, d, shows in cases:\n        # To store the unique shows in the current window of size d\n        unique_shows = set()\n        # Initialize the first window\n        for i in range(d):\n            unique_shows.add(shows[i])\n        \n        # The minimum number of subscriptions needed is the size of the unique set\n        min_subs = len(unique_shows)\n        \n        # Slide the window across the shows\n        for i in range(d, n):\n            # Remove the show that is left behind and add the new show in the window\n            unique_shows.add(shows[i])  # Add the new show\n            unique_shows.discard(shows[i - d])  # Remove the show that is sliding out\n            \n            # Update the minimum subscriptions if current unique shows are less\n            min_subs = min(min_subs, len(unique_shows))\n        \n        results.append(min_subs)\n    \n    return results\n\n\n# Input handling\nimport sys\ninput = sys.stdin.read\n\ndata = input().splitlines()\nt = int(data[0])\ncases = []\nindex = 1\nfor _ in range(t):\n    n, k, d = map(int, data[index].split())\n    shows = list(map(int, data[index + 1].split()))\n    cases.append((n, k, d, shows))\n    index += 2\n\n# Get the results\nresults = min_subscriptions(t, cases)\n\n# Print the results\nprint('\\n'.join(map(str, results)))\n```",
    "20": "```python\ndef can_satisfy_customers(test_cases):\n    results = []\n    for n, m, customers in test_cases:\n        current_temp = m\n        current_time = 0\n        min_temp = m\n        max_temp = m\n        possible = True\n        \n        for t, l, h in customers:\n            time_passed = t - current_time\n            min_temp -= time_passed\n            max_temp += time_passed\n            \n            # Update the temperature range based on the preferred range of the customer\n            min_temp = max(min_temp, l)\n            max_temp = min(max_temp, h)\n            \n            if min_temp > max_temp:\n                possible = False\n                break\n            \n            current_time = t\n        \n        if possible:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Read input and prepare test cases\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nq = int(data[0])\ntest_cases = []\nindex = 1\n\nfor _ in range(q):\n    n, m = map(int, data[index].split())\n    customers = []\n    for i in range(n):\n        t, l, h = map(int, data[index + 1 + i].split())\n        customers.append((t, l, h))\n    test_cases.append((n, m, customers))\n    index += n + 1\n\n# Get the results\nresults = can_satisfy_customers(test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "21": "```python\ndef find_min_k(n, S):\n    S_set = set(S)\n    \n    # Check all possible values of k from 1 to 1023 (as k should be positive)\n    for k in range(1, 1024):\n        transformed_set = {s ^ k for s in S}\n        if transformed_set == S_set:\n            return k\n    return -1\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    S = list(map(int, input().split()))\n    print(find_min_k(n, S))\n```",
    "22": "```python\ndef minDigit(x):\n    return min(int(d) for d in str(x))\n\ndef maxDigit(x):\n    return max(int(d) for d in str(x))\n\ndef calculate_a_k(a1, K):\n    a_n = a1\n    for _ in range(K - 1):\n        min_digit = minDigit(a_n)\n        max_digit = maxDigit(a_n)\n        a_n += min_digit * max_digit\n    return a_n\n\nt = int(input())\nfor _ in range(t):\n    a1, K = map(int, input().split())\n    result = calculate_a_k(a1, K)\n    print(result)\n```",
    "23": "```python\ndef min_coins_to_win_election(test_cases):\n    results = []\n    \n    for n, voters in test_cases:\n        voters.sort(key=lambda x: (x[0], x[1]))  # Sort by m_i first, then by p_i\n        min_cost = float('inf')\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        \n        for i in range(n):\n            m_i, p_i = voters[i]\n            # Update the dp array in reverse to avoid using the same voter multiple times\n            for j in range(n, m_i, -1):\n                dp[j] = min(dp[j], dp[j - m_i] + p_i)\n        \n        # The answer for this case is the minimum cost to convince all voters\n        min_cost = min(dp)\n        results.append(min_cost)\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\n\nfor _ in range(t):\n    n = int(input())\n    voters = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, voters))\n\n# Get results\nresults = min_coins_to_win_election(test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "24": "```python\nimport sys\nimport math\n\ndef find_a_b(d):\n    if d == 0:\n        return (0.0, 0.0)\n    if d == 1:\n        return None\n    phi = (1 + math.sqrt(5)) / 2\n    a = (d * phi - d) / (phi ** 2 - 1)\n    b = d - a\n    return (a, b)\n\nt = int(sys.stdin.readline().strip())\nfor _ in range(t):\n    d = int(sys.stdin.readline().strip())\n    result = find_a_b(d)\n    if result is None:\n        print(\"N\")\n    else:\n        a, b = result\n        print(f\"Y {a:.9f} {b:.9f}\")\n```",
    "25": "```python\ndef find_cake_permutations(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, pieces = case\n        degree = [0] * (n + 1)\n        edges = {}\n\n        # Count degrees and store edges\n        for i, (a, b, c) in enumerate(pieces):\n            degree[a] += 1\n            degree[b] += 1\n            degree[c] += 1\n            edges[i + 1] = (a, b, c)\n\n        # Find the starting vertex which has degree 2\n        start_vertex = next(i for i in range(1, n + 1) if degree[i] == 2)\n\n        # Reconstruct the order of vertices\n        order = []\n        visited_edges = set()\n        current_vertex = start_vertex\n\n        while len(order) < n:\n            order.append(current_vertex)\n            next_vertex = None\n            \n            for i in range(1, len(pieces) + 1):\n                if i in visited_edges:\n                    continue\n                a, b, c = edges[i]\n                if current_vertex in (a, b, c):\n                    next_vertex = a if a != current_vertex else (b if b != current_vertex else c)\n                    visited_edges.add(i)\n                    break\n            \n            current_vertex = next_vertex\n\n        # Create the permutation of vertices\n        p = order\n\n        # Create the order of cuts\n        q = []\n        for i in range(1, len(pieces) + 1):\n            a, b, c = edges[i]\n            if (a in p and b in p and c in p):\n                idx = p.index(a)\n                if p[(idx + 1) % n] == b and p[(idx + 2) % n] == c:\n                    q.append(i)\n        \n        results.append((p, q))\n    \n    return results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\nidx = 1\nfor _ in range(t):\n    n = int(data[idx])\n    pieces = [tuple(map(int, data[idx + i + 1].split())) for i in range(n - 2)]\n    test_cases.append((n, pieces))\n    idx += n - 1\n\n# Getting results\nresults = find_cake_permutations(t, test_cases)\n\n# Printing output\noutput = []\nfor p, q in results:\n    output.append(\" \".join(map(str, p)))\n    output.append(\" \".join(map(str, q)))\nprint(\"\\n\".join(output))\n```",
    "26": "```python\ndef can_solve_puzzle(test_cases):\n    results = []\n    for n, m in test_cases:\n        if (n * m) % 2 == 0:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    return results\n\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\nresults = can_solve_puzzle(test_cases)\n\nfor result in results:\n    print(result)\n```",
    "27": "```python\ndef min_moves_to_odd(test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, a = case\n        moves = 0\n        seen = set()\n\n        for number in a:\n            while number % 2 == 0:\n                if number not in seen:\n                    seen.add(number)\n                    moves += 1\n                number //= 2\n        \n        results.append(moves)\n    \n    return results\n\n\n# Input reading\nt = int(input())\ntest_cases = []\n\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Get results\nresults = min_moves_to_odd(test_cases)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "28": "```python\ndef can_form_abacaba(s):\n    target = \"abacaba\"\n    n = len(s)\n    positions = []\n    \n    # Check all possible positions for \"abacaba\"\n    for i in range(n - 6):\n        # Check if we can fit \"abacaba\" in current position\n        can_fit = True\n        for j in range(7):\n            if s[i + j] != '?' and s[i + j] != target[j]:\n                can_fit = False\n                break\n        if can_fit:\n            positions.append(i)\n    \n    # Try to mark one occurrence of \"abacaba\"\n    for pos in positions:\n        # Create a copy of string to modify\n        modified = list(s)\n        # Place \"abacaba\" at position pos\n        for j in range(7):\n            modified[pos + j] = target[j]\n        \n        # Replace remaining '?' with any character (e.g. 'z')\n        for k in range(n):\n            if modified[k] == '?':\n                modified[k] = 'z'\n        \n        # Check if \"abacaba\" occurs exactly once\n        result_str = ''.join(modified)\n        if result_str.count(target) == 1:\n            return \"Yes\", result_str\n    \n    return \"No\", None\n\n# Read number of test cases\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    s = input().strip()\n    result, modified_str = can_form_abacaba(s)\n    print(result)\n    if modified_str:\n        print(modified_str)\n```",
    "29": "```python\ndef k_amazing_numbers(test_cases):\n    results = []\n    for a in test_cases:\n        n = len(a)\n        last_position = {}\n        min_occur = [float('inf')] * (n + 1)\n        \n        for i in range(n):\n            last_position[a[i]] = i\n            \n        for i in range(n):\n            if a[i] in last_position:\n                # Calculate the distance to the next position of the same number\n                if a[i] in min_occur:\n                    min_occur[a[i]] = min(min_occur[a[i]], i - last_position[a[i]])\n                else:\n                    min_occur[a[i]] = i - last_position[a[i]]\n                last_position[a[i]] = i\n        \n        # Handle for the last occurrences\n        for key, value in last_position.items():\n            if key in min_occur:\n                min_occur[key] = min(min_occur[key], n - value)\n\n        k_amazing = [-1] * n\n        for number, distance in min_occur.items():\n            if distance < n:\n                k_amazing[distance] = min(k_amazing[distance], number) if k_amazing[distance] != -1 else number\n\n        for i in range(n - 1, 0, -1):\n            k_amazing[i] = min(k_amazing[i], k_amazing[i + 1]) if k_amazing[i + 1] != -1 else k_amazing[i]\n        \n        results.append(k_amazing[1:n + 1])\n    \n    return results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\nindex = 1\ntest_cases = []\n\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1].split()))\n    test_cases.append(a)\n    index += 2\n\nresults = k_amazing_numbers(test_cases)\n\n# Printing output\nfor result in results:\n    print(\" \".join(map(str, result)))\n```"
}