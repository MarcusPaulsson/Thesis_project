{
    "0": "```python\ndef max_accordion_length(s):\n    n = len(s)\n    left_bracket_index = -1\n    right_bracket_index = -1\n\n    for i in range(n):\n        if s[i] == '[':\n            left_bracket_index = i\n        elif s[i] == ']':\n            right_bracket_index = i\n    \n    if left_bracket_index == -1 or right_bracket_index == -1 or left_bracket_index >= right_bracket_index:\n        return -1\n\n    colon_index_left = -1\n    colon_index_right = -1\n\n    for i in range(left_bracket_index + 1, right_bracket_index):\n        if s[i] == ':':\n            if colon_index_left == -1:\n                colon_index_left = i\n            colon_index_right = i\n    \n    if colon_index_left == -1 or colon_index_right == -1 or colon_index_left == colon_index_right:\n        return -1\n\n    vertical_lines_count = sum(1 for i in range(colon_index_left + 1, colon_index_right) if s[i] == '|')\n\n    return 4 + vertical_lines_count  # 4 for the fixed characters in the accordion\n\n# Read input\ns = input().strip()\n# Output the result\nprint(max_accordion_length(s))\n```",
    "1": "```python\ndef sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef max_digit_sum(x):\n    # Start by considering x itself\n    max_sum = sum_of_digits(x)\n    result = x\n\n    # Check numbers by reducing the last digits to 9\n    str_x = str(x)\n    length = len(str_x)\n\n    # Generate candidates by changing digits to 9\n    for i in range(length):\n        if str_x[i] == '0':\n            continue\n        # Create a new number by reducing the current digit and making all following digits 9\n        candidate = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (length - i - 1)\n        candidate = int(candidate)\n        if candidate <= x:\n            candidate_sum = sum_of_digits(candidate)\n            if candidate_sum > max_sum or (candidate_sum == max_sum and candidate > result):\n                max_sum = candidate_sum\n                result = candidate\n\n    return result\n\nx = int(input())\nprint(max_digit_sum(x))\n```",
    "2": "```python\nn = int(input())\n\ndef next_lucky_year(current_year):\n    while True:\n        current_year += 1\n        if str(current_year).count('0') + len(set(str(current_year))) - 1 <= 1:\n            return current_year\n\nnext_year = next_lucky_year(n)\nprint(next_year - n)\n```",
    "3": "```python\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# We will calculate the painted sections for every combination of q-2 painters\ndef painted_sections(painters):\n    painted = [0] * (n + 1)\n    for l, r in painters:\n        for i in range(l, r + 1):\n            painted[i] = 1\n    return sum(painted)\n\nmax_painted = 0\n\n# Try all combinations of q-2 painters\nfrom itertools import combinations\n\nfor comb in combinations(painters, q - 2):\n    max_painted = max(max_painted, painted_sections(comb))\n\nprint(max_painted)\n```",
    "4": "```python\ndef is_lucky(hh, mm):\n    return '7' in f\"{hh:02d}:{mm:02d}\"\n\ndef minutes_before(hh, mm, x, y):\n    total_minutes = hh * 60 + mm - y * x\n    if total_minutes < 0:\n        total_minutes += 24 * 60\n    return total_minutes // 60, total_minutes % 60\n\nx = int(input())\nhh, mm = map(int, input().split())\n\ny = 0\nwhile True:\n    prev_hh, prev_mm = minutes_before(hh, mm, x, y)\n    if is_lucky(prev_hh, prev_mm):\n        print(y)\n        break\n    y += 1\n```",
    "5": "```python\ndef min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0  # No tabs to close\n    \n    seconds = 0\n    \n    # Move to the left end of the segment\n    if pos < l:\n        seconds += l - pos  # Move to l\n        seconds += 1  # Close tabs to the left\n    else:\n        # Close tabs to the left of l if needed\n        if pos >= l:\n            seconds += max(0, l - pos)  # Move to l if needed\n            seconds += 1  # Close tabs to the left\n\n    # Move to the right end of the segment\n    if pos > r:\n        seconds += pos - r  # Move to r\n        seconds += 1  # Close tabs to the right\n    else:\n        # Close tabs to the right of r if needed\n        if pos <= r:\n            seconds += max(0, pos - r)  # Move to r if needed\n            seconds += 1  # Close tabs to the right\n\n    return seconds\n\n# Read input\nn, pos, l, r = map(int, input().split())\nprint(min_seconds_to_close_tabs(n, pos, l, r))\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    for query in queries:\n        n, x, blows = query\n        min_blows = float('inf')\n        possible = False\n        \n        for d, h in blows:\n            if d >= x:\n                # Can defeat with this blow in one hit\n                min_blows = min(min_blows, 1)\n                possible = True\n            else:\n                # Calculate the effective decrease in heads after the blow\n                effective_decrease = d - h\n                if effective_decrease < 0:\n                    continue  # This blow is not effective\n                # Calculate how many blows needed\n                blows_needed = (x - d + effective_decrease - 1) // effective_decrease + 1\n                min_blows = min(min_blows, blows_needed)\n                possible = True\n        \n        results.append(min_blows if possible else -1)\n    \n    return results\n\n# Example usage\nt = 3\nqueries = [\n    (3, 10, [(6, 3), (8, 2), (1, 4)]),\n    (4, 10, [(4, 1), (3, 2), (2, 6), (1, 100)]),\n    (2, 15, [(10, 11), (14, 100)])\n]\n\nresults = min_blows_to_defeat_zmei(t, queries)\nfor result in results:\n    print(result)\n```",
    "7": "```python\ndef day_when_barn_empty(n, m):\n    day = 1\n    grains = n\n\n    while grains > 0:\n        # Add grains to the barn\n        grains += m\n        if grains > n:\n            grains = n  # Barn can't exceed its capacity\n            \n        # Sparrows eat grains\n        grains -= day\n        day += 1\n\n    return day - 1\n\n# Input\nn, m = map(int, input().split())\nprint(day_when_barn_empty(n, m))\n```",
    "8": "```python\ndef min_tiles_to_draw(tiles):\n    from collections import defaultdict\n\n    suits = defaultdict(list)\n    \n    # Parse the input tiles\n    for tile in tiles:\n        number = int(tile[0])\n        suit = tile[1]\n        suits[suit].append(number)\n\n    # Check for koutsu (triplet)\n    for suit in suits:\n        if len(suits[suit]) == 3 and len(set(suits[suit])) == 1:\n            return 0  # Already has a koutsu\n\n    # Check for shuntsu (sequence)\n    for suit in suits:\n        if len(suits[suit]) >= 3:\n            sorted_numbers = sorted(set(suits[suit]))\n            for i in range(len(sorted_numbers) - 2):\n                if sorted_numbers[i + 1] == sorted_numbers[i] + 1 and sorted_numbers[i + 2] == sorted_numbers[i] + 2:\n                    return 0  # Already has a shuntsu\n\n    # Try to form a shuntsu by drawing one tile\n    for suit in suits:\n        existing_numbers = set(suits[suit])\n        for number in range(1, 10):\n            if (number + 1 in existing_numbers and number + 2 in existing_numbers) or \\\n               (number - 1 in existing_numbers and number + 1 in existing_numbers) or \\\n               (number - 2 in existing_numbers and number - 1 in existing_numbers):\n                return 1  # Can form a shuntsu by drawing one tile\n\n    # If no mentsu can be formed, it requires at least 2 draws\n    return 2\n\n# Read input\ntiles = input().strip().split()\n# Output the result\nprint(min_tiles_to_draw(tiles))\n```",
    "9": "```python\ndef find_grandpa_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b):\n    # To store the count of sofas in each direction with respect to each sofa\n    counts = []\n\n    for i in range(d):\n        count_left = count_right = count_top = count_bottom = 0\n        x1, y1, x2, y2 = sofas[i]\n\n        # Check against all the other sofas\n        for j in range(d):\n            if i == j:\n                continue\n            x1j, y1j, x2j, y2j = sofas[j]\n\n            # Determine the position of sofa j relative to sofa i\n            if x2 < x1j:  # i is to the left of j\n                count_left += 1\n            elif x1 > x2j:  # i is to the right of j\n                count_right += 1\n            elif y2 < y1j:  # i is above j\n                count_top += 1\n            elif y1 > y2j:  # i is below j\n                count_bottom += 1\n\n        counts.append((count_left, count_right, count_top, count_bottom))\n\n    # Now find the sofa that matches the required counts\n    for i in range(d):\n        if counts[i] == (cnt_l, cnt_r, cnt_t, cnt_b):\n            return i + 1  # Return 1-based index\n\n    return -1  # If no such sofa is found\n\n\n# Read input\nd = int(input())\nn, m = map(int, input().split())\nsofas = [tuple(map(int, input().split())) for _ in range(d)]\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\n# Call the function and print the result\nresult = find_grandpa_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b)\nprint(result)\n```",
    "10": "```python\nn = int(input())\n\n# Calculate maximum days off\nmax_days_off = (n // 7) * 2 + min(2, n % 7)\n\n# Calculate minimum days off\nmin_days_off = 0 if n < 5 else (n // 7) * 2 + (1 if n % 7 >= 5 else 0)\n\nprint(min_days_off, max_days_off)\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    # Count the number of tiles that can be painted Red\n    count_red = n // a\n    # Count the number of tiles that can be painted Blue\n    count_blue = n // b\n    # Count the number of tiles that can be painted both Red and Blue\n    count_both = n // (a * b // gcd(a, b))\n    \n    # Calculate the total chocolates for both scenarios\n    total_chocolates_red_first = (count_red - count_both) * p + count_blue * q\n    total_chocolates_blue_first = (count_blue - count_both) * q + count_red * p\n    \n    # Return the maximum chocolates obtainable\n    return max(total_chocolates_red_first, total_chocolates_blue_first)\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n# Read input\nn, a, b, p, q = map(int, input().split())\n# Calculate and print the maximum chocolates\nprint(max_chocolates(n, a, b, p, q))\n```",
    "12": "```python\ndef max_beauty_with_swap(n, trophies):\n    max_length = 0\n    current_length = 0\n    segments = []\n\n    # Calculate current segments of G's\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n                max_length = max(max_length, current_length)\n            current_length = 0\n    if current_length > 0:\n        segments.append(current_length)\n        max_length = max(max_length, current_length)\n\n    # If there are no G's\n    if max_length == 0:\n        return 0\n\n    # If we can swap one S with a G\n    if len(segments) > 1:\n        # We can connect two segments of G's with one S in between\n        for i in range(len(segments) - 1):\n            max_length = max(max_length, segments[i] + segments[i + 1])\n    \n    # If there is at least one S, we can potentially increase the max length by 1\n    if 'S' in trophies:\n        max_length += 1\n\n    return max_length\n\n# Read input\nn = int(input().strip())\ntrophies = input().strip()\n\n# Get the result\nresult = max_beauty_with_swap(n, trophies)\n\n# Print the result\nprint(result)\n```",
    "13": "```python\nfrom collections import defaultdict, deque\nimport sys\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, k = map(int, data[0].split())\nmain_courses = list(map(int, data[1].split()))\n\n# Create an adjacency list and in-degree counter for each course\ndependencies = defaultdict(list)\nin_degree = [0] * (n + 1)\n\n# Read course dependencies\nfor i in range(1, n + 1):\n    line = list(map(int, data[i + 1].split()))\n    t_i = line[0]\n    for j in range(1, t_i + 1):\n        dependencies[line[j]].append(i)\n        in_degree[i] += 1\n\n# To track which courses we need to take\nto_take = set(main_courses)\n# To track all courses we need to take\nall_courses = set(main_courses)\n\n# Use a queue to perform topological sorting\nqueue = deque()\nfor course in range(1, n + 1):\n    if in_degree[course] == 0:\n        queue.append(course)\n\norder_of_courses = []\n\nwhile queue:\n    course = queue.popleft()\n    order_of_courses.append(course)\n\n    # If this course is a main course, add its dependencies to the set\n    if course in to_take:\n        all_courses.add(course)\n        for dependent in dependencies[course]:\n            in_degree[dependent] -= 1\n            if in_degree[dependent] == 0:\n                queue.append(dependent)\n\n# If we couldn't take all main courses, return -1\nif all_courses != set(main_courses):\n    print(-1)\nelse:\n    # Print the result\n    print(len(order_of_courses))\n    print(\" \".join(map(str, order_of_courses)))\n```",
    "14": "```python\ndef is_stack_sortable(p):\n    s = []\n    b = []\n    for num in p:\n        while s and (not b or s[-1] < b[-1]):\n            b.append(s.pop())\n        s.append(num)\n    while s:\n        b.append(s.pop())\n    return b == sorted(b)\n\ndef restore_permutation(n, k, given):\n    used = set(given)\n    remaining = [x for x in range(1, n + 1) if x not in used]\n    \n    if not is_stack_sortable(given + remaining):\n        return -1\n\n    # Construct the lexicographically maximal permutation\n    result = given.copy()\n    remaining.sort(reverse=True)\n    \n    # Add the remaining elements to result\n    result += remaining\n    return result\n\n# Input reading\nn, k = map(int, input().split())\ngiven = list(map(int, input().split()))\n\n# Get the result\nresult = restore_permutation(n, k, given)\n\n# Output the result\nif result == -1:\n    print(result)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "16": "```python\ncnt_1 = int(input().strip())\ncnt_2 = int(input().strip())\ncnt_3 = int(input().strip())\ncnt_4 = int(input().strip())\n\n# To form a valid bracket sequence:\n# - The number of opening brackets must be equal to the number of closing brackets.\n# - At no point in the sequence should the number of closing brackets exceed the number of opening brackets.\n\n# Count of opening and closing brackets\nopening_brackets = cnt_1 + cnt_2\nclosing_brackets = cnt_3 + cnt_4\n\n# The total number of opening brackets should be equal to the total number of closing brackets\nif opening_brackets == closing_brackets:\n    # The number of closing brackets should not exceed the number of opening brackets at any point\n    # This can be ensured by checking:\n    # The number of closing brackets that can be used at the start of the sequence (cnt_3)\n    # should not exceed the number of opening brackets that can be opened before them (cnt_1 + cnt_2)\n    if cnt_3 <= opening_brackets:\n        print(1)\n    else:\n        print(0)\nelse:\n    print(0)\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelse:\n    print(n + k - t)\n```",
    "18": "```python\ns = input().strip()\nt = []\nu = []\n\nwhile s or t:\n    if s:\n        t.append(s[0])\n        s = s[1:]\n    \n    while t:\n        if not u or t[-1] <= u[-1]:\n            u.append(t.pop())\n        else:\n            break\n\nprint(''.join(u))\n```",
    "19": "```python\ndef is_stats_correct(test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, stats = case\n        valid = True\n        \n        for i in range(1, n):\n            p_prev, c_prev = stats[i-1]\n            p_curr, c_curr = stats[i]\n            \n            # Check for non-decreasing plays and clears\n            if p_curr < p_prev or c_curr < c_prev:\n                valid = False\n                break\n            \n            # Check if clears do not exceed plays\n            if c_curr > p_curr:\n                valid = False\n                break\n            \n            # Check the increase in plays and clears\n            if (c_curr - c_prev) > (p_curr - p_prev):\n                valid = False\n                break\n            \n        # Check the first entry\n        p_first, c_first = stats[0]\n        if c_first > p_first:\n            valid = False\n            \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Read input\nT = int(input())\ntest_cases = []\n\nfor _ in range(T):\n    n = int(input())\n    stats = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, stats))\n\n# Get results and print\nresults = is_stats_correct(test_cases)\nfor result in results:\n    print(result)\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome_time(hh, mm):\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        time = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time):\n            return time\n\ndef min_minutes_to_palindrome(current_time):\n    hh, mm = map(int, current_time.split(':'))\n    minutes = 0\n    \n    while True:\n        if is_palindrome(f\"{hh:02}:{mm:02}\"):\n            return minutes\n        minutes += 1\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n\n# Input\ncurrent_time = input().strip()\n# Output\nprint(min_minutes_to_palindrome(current_time))\n```",
    "21": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the positions of the minimum and maximum elements\nmin_index = a.index(1)\nmax_index = a.index(n)\n\n# Calculate the current distance\ncurrent_distance = abs(min_index - max_index)\n\n# The maximum possible distance will either be to swap min with the ends or max with the ends\nmax_distance = max(min_index, max_index, n - 1 - min_index, n - 1 - max_index)\n\n# The result is the maximum of current distance and potential maximum distance\nprint(max(max_distance, current_distance))\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror_chars = {'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M', 'O': 'O', 'p': 'q', 'q': 'p', 'T': 'T', 'U': 'U', 'v': 'v', 'W': 'W', 'X': 'X', 'Y': 'Y', 'o': 'o', 'x': 'x'}\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        if s[i] not in mirror_chars or s[n - 1 - i] != mirror_chars[s[i]]:\n            print(\"NIE\")\n            return\n    print(\"TAK\")\n\ns = input().strip()\nis_s_palindrome(s)\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a, b):\n    from itertools import permutations\n\n    # Convert to string for easier manipulation\n    str_a = str(a)\n    str_b = str(b)\n\n    # Generate all unique permutations of the digits of a\n    permuted_numbers = set(int(''.join(p)) for p in permutations(str_a))\n    \n    # Filter out numbers that start with 0 and are greater than b\n    valid_numbers = [num for num in permuted_numbers if num <= b and str(num)[0] != '0']\n    \n    # Return the maximum valid number\n    return max(valid_numbers)\n\n# Read input\na = int(input().strip())\nb = int(input().strip())\n\n# Get the result and print it\nresult = max_permutation_not_exceeding(a, b)\nprint(result)\n```",
    "24": "```python\ndef can_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]\n    \n    def check_line(x, y, dx, dy):\n        count = 0\n        for step in range(-4, 1):  # Check in both directions\n            nx, ny = x + step * dx, y + step * dy\n            if 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n            else:\n                count = 0\n            \n            if count >= 5:\n                return True\n        return False\n\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                # Temporarily place 'X' to check for a win\n                board[i][j] = 'X'\n                for dx, dy in directions:\n                    if check_line(i, j, dx, dy):\n                        return \"YES\"\n                # Reset the cell back to empty\n                board[i][j] = '.'\n    \n    return \"NO\"\n\n# Read the input\nboard = [input().strip() for _ in range(10)]\nprint(can_win(board))\n```",
    "25": "```python\ndef create_matrix(n, k):\n    if k > n * n or k % 2 != 0 and n % 2 == 0:\n        return -1\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    # Fill the diagonal first\n    for i in range(n):\n        if k > 0:\n            matrix[i][i] = 1\n            k -= 1\n            \n    # Fill the upper triangle (excluding the diagonal)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if k >= 2:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n            if k <= 0:\n                break\n    \n    # If we still have k ones left, it's impossible\n    if k > 0:\n        return -1\n    \n    return matrix\n\n# Input reading\nn, k = map(int, input().split())\nresult = create_matrix(n, k)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "26": "```python\nimport sys\n\n# Read input\nx, y, z = map(float, input().strip().split())\n\n# Define the expressions and their corresponding values\nexpressions = [\n    (f\"x^y^z\", x ** (y ** z)),\n    (f\"x^z^y\", x ** (z ** y)),\n    (f\"(x^y)^z\", (x ** y) ** z),\n    (f\"(x^z)^y\", (x ** z) ** y),\n    (f\"y^x^z\", y ** (x ** z)),\n    (f\"y^z^x\", y ** (z ** x)),\n    (f\"(y^x)^z\", (y ** x) ** z),\n    (f\"(y^z)^x\", (y ** z) ** x),\n    (f\"z^x^y\", z ** (x ** y)),\n    (f\"z^y^x\", z ** (y ** x)),\n    (f\"(z^x)^y\", (z ** x) ** y),\n    (f\"(z^y)^x\", (z ** y) ** x),\n]\n\n# Find the maximum value and its corresponding expression\nmax_value = -1\nmax_expression = \"\"\nfor expression, value in expressions:\n    if value > max_value:\n        max_value = value\n        max_expression = expression\n\n# Output the result\nprint(max_expression)\n```",
    "27": "```python\nn = int(input())\ns = input().strip()\n\nmin_operations = n  # Start with the assumption that we need to type all characters one by one\n\n# Check for every possible length to copy\nfor i in range(1, n // 2 + 1):\n    if s[:i] == s[i:2 * i]:  # Check if the first i characters are the same as the next i characters\n        # If they are equal, we can copy and then type the rest\n        total_length = 2 * i\n        remaining_length = n - total_length\n        operations = i + 1 + remaining_length  # i (type first part) + 1 (copy) + remaining_length (type remaining)\n        min_operations = min(min_operations, operations)\n\n# Output the minimum operations found\nprint(min_operations)\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\nexample_files = []\nregular_files = []\n\nfor name, typ in files:\n    if typ == '1':\n        example_files.append(name)\n    else:\n        regular_files.append(name)\n\ne = len(example_files)\nmoves = []\n\n# Move example files to 1, 2, ..., e\nfor i in range(e):\n    moves.append(f\"move {example_files[i]} {i + 1}\")\n\n# Move regular files to e + 1, e + 2, ..., n\nfor i in range(len(regular_files)):\n    moves.append(f\"move {regular_files[i]} {e + i + 1}\")\n\nprint(len(moves))\nfor move in moves:\n    print(move)\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket):\n    first_half = ticket[:3]\n    second_half = ticket[3:]\n\n    sum_first = sum(int(digit) for digit in first_half)\n    sum_second = sum(int(digit) for digit in second_half)\n\n    if sum_first == sum_second:\n        return 0\n\n    # Calculate the differences\n    diff = abs(sum_first - sum_second)\n\n    # Create a list of possible changes (max changes per digit)\n    changes = []\n    if sum_first < sum_second:\n        for digit in first_half:\n            changes.append(9 - int(digit))  # Max possible gain from first half\n    else:\n        for digit in second_half:\n            changes.append(9 - int(digit))  # Max possible gain from second half\n\n    # Sort the changes in descending order\n    changes.sort(reverse=True)\n\n    # Count the minimum number of changes needed\n    replacements = 0\n    for change in changes:\n        diff -= change\n        replacements += 1\n        if diff <= 0:\n            break\n\n    return replacements\n\n# Example usage\nticket = input().strip()\nprint(min_replacements_to_lucky(ticket))\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # The number of traps needed is m // gcd(x, m)\n    # Since gcd(x, m) = 1, we can directly return m - 1\n    return m - 1\n\nm, x = map(int, input().split())\nprint(minimum_traps(m, x))\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef prob_birthday_paradox(n, k):\n    days = 1 << n  # 2^n\n    \n    if k > days:\n        return 1, 1  # Guaranteed at least one shared birthday\n    \n    # Calculate the probability of no shared birthdays\n    num = 1\n    den = days ** k\n    \n    for i in range(k):\n        num *= (days - i)\n    \n    # Probability of at least one shared birthday\n    prob_not_shared = num / den\n    prob_shared = 1 - prob_not_shared\n    \n    # Convert to fraction A/B\n    A = den - num\n    B = den\n    \n    # Reduce A/B by their gcd\n    g = gcd(A, B)\n    A //= g\n    B //= g\n    \n    # Take modulo\n    mod = 10**6 + 3\n    A %= mod\n    B %= mod\n    \n    return A, B\n\n# Read input\nn, k = map(int, input().split())\nA, B = prob_birthday_paradox(n, k)\nprint(A, B)\n```",
    "32": "```python\ndef check_journey(n, instructions):\n    position = 0  # Starting at North Pole, position is 0 (0 km from the North Pole)\n    \n    for t, direction in instructions:\n        if position == 0 and direction != \"South\":\n            return \"NO\"  # At North Pole, can only move South\n        if position == 20000 and direction != \"North\":\n            return \"NO\"  # At South Pole, can only move North\n        \n        if direction == \"North\":\n            position -= t\n        elif direction == \"South\":\n            position += t\n        elif direction == \"East\" or direction == \"West\":\n            # East and West don't change the position in terms of North/South\n            continue\n        \n        if position < 0 or position > 20000:\n            return \"NO\"  # Out of bounds\n        \n    if position != 0:\n        return \"NO\"  # Must end at North Pole\n    \n    return \"YES\"\n\n\n# Read input\nn = int(input())\ninstructions = [tuple(input().split()) for _ in range(n)]\ninstructions = [(int(t), direction) for t, direction in instructions]\n\n# Check the journey and print result\nresult = check_journey(n, instructions)\nprint(result)\n```",
    "33": "```python\ndef count_integers(a1, b1, a2, b2, L, R):\n    from math import gcd\n\n    # Calculate the step size and the offset\n    step = abs(a1 * a2 // gcd(a1, a2))\n    \n    # Calculate the starting points for both sequences\n    start1 = (L - b1 + a1 - 1) // a1 * a1 + b1\n    start2 = (L - b2 + a2 - 1) // a2 * a2 + b2\n\n    # Calculate the first common point that is >= L\n    if start1 < L:\n        start1 += a1\n    if start2 < L:\n        start2 += a2\n\n    # Find the first common value\n    if start1 == start2:\n        first_common = start1\n    else:\n        first_common = max(start1, start2)\n        while (first_common - b1) % a1 != 0 or (first_common - b2) % a2 != 0:\n            first_common += step\n\n    # Now we need to find the last common value within [L, R]\n    if first_common > R:\n        return 0\n\n    last_common = first_common + ((R - first_common) // step) * step\n\n    # Calculate the number of integers\n    return (last_common - first_common) // step + 1\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n# Get the result\nresult = count_integers(a1, b1, a2, b2, L, R)\n# Print the result\nprint(result)\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    low, high = 1, max(a, b)\n    \n    while low < high:\n        mid = (low + high + 1) // 2\n        if (a // mid) + (b // mid) >= n:\n            low = mid\n        else:\n            high = mid - 1\n            \n    return low\n\n# Read input\nn, a, b = map(int, input().split())\n# Calculate and print the result\nprint(max_min_pieces(n, a, b))\n```",
    "35": "```python\ndef is_valid_flag(n, m, field):\n    colors = {'R', 'G', 'B'}\n    \n    # Check for horizontal stripes\n    stripe_height = n // 3\n    if n % 3 != 0 or stripe_height == 0:\n        return \"NO\"\n    \n    used_colors = set()\n    for i in range(0, n, stripe_height):\n        stripe = field[i]\n        if len(set(stripe)) != 1 or stripe[0] in used_colors:\n            return \"NO\"\n        used_colors.add(stripe[0])\n    \n    if used_colors == colors:\n        return \"YES\"\n    \n    # Check for vertical stripes\n    stripe_width = m // 3\n    if m % 3 != 0 or stripe_width == 0:\n        return \"NO\"\n    \n    used_colors.clear()\n    for j in range(0, m, stripe_width):\n        stripe = [field[i][j] for i in range(n)]\n        if len(set(stripe)) != 1 or stripe[0] in used_colors:\n            return \"NO\"\n        used_colors.add(stripe[0])\n    \n    return \"YES\" if used_colors == colors else \"NO\"\n\n# Input reading\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Output result\nprint(is_valid_flag(n, m, field))\n```",
    "36": "```python\ndef get_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    while n >= 3 * layer * (layer + 1):\n        layer += 1\n\n    n -= 3 * (layer - 1) * layer  # Moves in the previous layers\n    x, y = layer, 0\n\n    # Calculate position based on remaining moves in the current layer\n    if n < layer:\n        x -= n\n    elif n < 2 * layer:\n        x -= layer\n        y += n - layer\n    else:\n        x += n - 2 * layer\n        y += layer\n\n    return (x, y)\n\nn = int(input())\nx, y = get_coordinates(n)\nprint(x, y)\n```",
    "37": "```python\ndef can_break_shield(a, b, c):\n    for x in range(c // a + 1):\n        if (c - a * x) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Input\na, b, c = map(int, input().split())\nprint(can_break_shield(a, b, c))\n```",
    "38": "```python\ndef can_run_same_track(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between barriers for Kefa\n    kefa_gaps = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    # Calculate the distances between barriers for Sasha\n    sasha_gaps = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Check if kefa_gaps can be rotated to match sasha_gaps\n    sasha_gaps_doubled = sasha_gaps + sasha_gaps  # Double the gaps to handle rotation\n    for i in range(n):\n        if kefa_gaps == sasha_gaps_doubled[i:i+n]:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output\nprint(can_run_same_track(n, L, kefa_distances, sasha_distances))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    \n    if not is_palindrome(s):\n        return n\n    \n    # Check if all characters are the same\n    if s == s[0] * n:\n        return 0\n    \n    # If the whole string is a palindrome but not all characters are the same,\n    # then the longest non-palindrome substring can be obtained by removing one character\n    return n - 1\n\ns = input().strip()\nprint(longest_non_palindrome_substring(s))\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if any rating has changed\nrated = any(a != b for a, b in ratings)\n\nif rated:\n    print(\"rated\")\nelse:\n    # Check if the standings are in non-increasing order of ratings\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            print(\"unrated\")\n            break\n    else:\n        print(\"maybe\")\n```",
    "41": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the distance array with a large number\nd = [float('inf')] * n\n\n# First pass: from left to right\nlast_zero = -1\nfor i in range(n):\n    if a[i] == 0:\n        last_zero = i\n    if last_zero != -1:\n        d[i] = i - last_zero\n\n# Second pass: from right to left\nlast_zero = -1\nfor i in range(n-1, -1, -1):\n    if a[i] == 0:\n        last_zero = i\n    if last_zero != -1:\n        d[i] = min(d[i], last_zero - i)\n\nprint(' '.join(map(str, d)))\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n    \n    len_s = len(s)\n    count = 0\n    seen = set()\n    \n    # Generate all binary strings of length n\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        \n        # Check if s is a substring in any cyclic shift of t\n        if any(s in t[i:] + t[:i] for i in range(n)):\n            # Normalize t to account for cyclic shifts\n            min_rotation = min(t[i:] + t[:i] for i in range(n))\n            if min_rotation not in seen:\n                seen.add(min_rotation)\n                count += 1\n\n    return count\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Function call and output\nprint(count_cyclic_strings(n, s))\n```",
    "43": "```python\nimport math\nimport sys\n\ndef angle_between(v1, v2):\n    dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n    magnitude_v1 = math.sqrt(v1[0]**2 + v1[1]**2)\n    magnitude_v2 = math.sqrt(v2[0]**2 + v2[1]**2)\n    return math.acos(dot_product / (magnitude_v1 * magnitude_v2))\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    vectors = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\n    angles = []\n    \n    for i in range(n):\n        angle = math.atan2(vectors[i][1], vectors[i][0])\n        angles.append((angle, i + 1))  # Store angle and its index\n\n    angles.sort()  # Sort by angle\n\n    min_angle = float('inf')\n    pair = (0, 0)\n\n    # Compare each angle with the next one in the sorted list\n    for i in range(n):\n        v1 = angles[i]\n        v2 = angles[(i + 1) % n]  # Wrap around to compare with the first one\n        current_angle = angle_between(vectors[v1[1] - 1], vectors[v2[1] - 1])\n        \n        if current_angle < min_angle:\n            min_angle = current_angle\n            pair = (v1[1], v2[1])\n\n    print(pair[0], pair[1])\n\nif __name__ == \"__main__\":\n    main()\n```",
    "44": "```python\ndef minimal_time(d, k, a, b, t):\n    # Calculate full trips with the car\n    full_trips = d // k\n    remaining_distance = d % k\n    \n    # Time if using the car for all full trips\n    time_using_car = full_trips * (k * a + t) + remaining_distance * a\n    \n    # If there are full trips, we need to subtract the last repair time\n    if full_trips > 0:\n        time_using_car -= t\n    \n    # Time if walking the whole distance\n    time_walking = d * b\n    \n    # Minimum time between using the car and walking\n    return min(time_using_car, time_walking)\n\n# Input reading\nd, k, a, b, t = map(int, input().split())\nprint(minimal_time(d, k, a, b, t))\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Minimum sum of first k natural numbers is k * (k + 1) / 2\n    min_sum = k * (k + 1) // 2\n    \n    if n < min_sum:\n        return -1  # Not enough to create the sequence\n    \n    # The greatest common divisor can be at most n // k\n    gcd = (n - min_sum) // k + 1  # This is the maximum we can use for gcd\n    \n    # Calculate the base sequence\n    base_sequence = [i for i in range(1, k + 1)]\n    \n    # Calculate the adjustment needed\n    adjustment = gcd * k\n    \n    # Final sequence\n    result_sequence = [x + adjustment for x in base_sequence]\n    \n    # Check if the sum is equal to n\n    if sum(result_sequence) == n:\n        return result_sequence\n    else:\n        return -1\n\n# Read input\nn, k = map(int, input().split())\n\n# Get the result\nresult = find_sequence(n, k)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "46": "```python\ndef count_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n\n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n\n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n\n    total_pairs = 0\n    for i in range(5):\n        total_pairs += count_x[i] * count_y[(5 - i) % 5]\n\n    return total_pairs\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))\n```",
    "47": "```python\ndef max_beauty_with_multiplier(n, x, a):\n    def kadane(arr):\n        max_ending_here = max_so_far = 0\n        for num in arr:\n            max_ending_here = max(0, max_ending_here + num)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    # Calculate the beauty of the array without any operation\n    max_beauty = kadane(a)\n\n    # If x is 1 or 0, multiplying won't help, return the current max_beauty\n    if x >= 1:\n        return max_beauty\n\n    # Calculate the effect of multiplying subarrays by x\n    # We will use two passes for the original array and the modified array\n    # to find the maximum contribution after multiplying subarrays\n\n    n = len(a)\n    max_gain = 0\n    prefix_sum = 0\n    \n    for i in range(n):\n        prefix_sum += a[i]\n        max_gain = max(max_gain, prefix_sum * (x - 1))\n        if prefix_sum < 0:\n            prefix_sum = 0\n\n    # Now, we need to find the max contribution from the array after applying x\n    # Use the Kadane's algorithm again for the original array\n    # and for the modified array when multiplied by x\n    max_gain_with_multiplier = kadane([a[i] * x for i in range(n)])\n\n    # The final maximum beauty is the best of the original or modified values\n    return max(max_beauty, max_gain + max_gain_with_multiplier)\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_beauty_with_multiplier(n, x, a))\n```",
    "48": "```python\ndef kth_largest_in_multiplication_table(n, m, k):\n    left, right = 1, n * m\n    \n    while left < right:\n        mid = (left + right) // 2\n        count = 0\n        \n        for i in range(1, n + 1):\n            count += min(mid // i, m)\n        \n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return left\n\n# Read input\nn, m, k = map(int, input().split())\n# Output the k-th largest number\nprint(kth_largest_in_multiplication_table(n, m, k))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    digit_length = 1\n    count = 9\n    start = 1\n    \n    while k > digit_length * count:\n        k -= digit_length * count\n        digit_length += 1\n        count *= 10\n        start *= 10\n    \n    start += (k - 1) // digit_length\n    number = str(start)\n    \n    return int(number[(k - 1) % digit_length])\n\nk = int(input().strip())\nprint(find_kth_digit(k))\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph):\n    visited = [-1] * (n + 1)\n    queue = deque([start])\n    visited[start] = 0\n    farthest_node = start\n\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if visited[neighbor] == -1:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > visited[farthest_node]:\n                    farthest_node = neighbor\n\n    return farthest_node, visited\n\ndef find_max_edges(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Step 1: Find the farthest node from an arbitrary node (let's choose 1)\n    farthest_node_from_1, _ = bfs(1, graph)\n    \n    # Step 2: Find the farthest node from the farthest_node_from_1\n    farthest_node_from_A, distances_A = bfs(farthest_node_from_1, graph)\n    \n    # Step 3: Find the farthest node from the farthest_node_from_A\n    farthest_node_from_B, distances_B = bfs(farthest_node_from_A, graph)\n\n    # The maximum distance between the two farthest nodes gives us the diameter\n    # Now we can pick the two nodes and find a third node\n    max_distance = distances_B[farthest_node_from_B]\n    \n    # Find a third node which is not one of the endpoints of the diameter\n    a = farthest_node_from_A\n    b = farthest_node_from_B\n    c = None\n\n    for i in range(1, n + 1):\n        if i != a and i != b:\n            c = i\n            break\n\n    # The maximum number of edges in the union of the three paths\n    # The number of edges in the tree is n - 1, we need to calculate the edges used in the paths\n    max_edges = max_distance + 1\n\n    return max_edges, a, b, c\n\n# Input reading\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\n# Solve the problem\nmax_edges, a, b, c = find_max_edges(n, edges)\n\n# Output the result\nprint(max_edges)\nprint(a, b, c)\n```",
    "51": "```python\nfrom collections import Counter\nimport sys\n\ndef find_x_y(divisors):\n    count = Counter(divisors)\n    \n    # The maximum divisor is either x or y\n    x = max(divisors)\n    # Start with x and find y\n    y = 1\n    \n    for d in count:\n        if d == x:\n            continue\n        # For each divisor d, we check if it can be part of y\n        if count[d] == 1:\n            y *= d\n    \n    return x, y\n\n# Input reading\nn = int(input().strip())\ndivisors = list(map(int, input().strip().split()))\n\n# Finding x and y\nx, y = find_x_y(divisors)\n\n# Output\nprint(x, y)\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    from itertools import combinations\n    \n    max_choose = m // 2\n    total_max_sum = 0\n    \n    for row in matrix:\n        best_mod_sums = [0] * k\n        \n        # Check all combinations of choosing elements in the row\n        for r in range(max_choose + 1):\n            for comb in combinations(row, r):\n                current_sum = sum(comb)\n                best_mod_sums[current_sum % k] = max(best_mod_sums[current_sum % k], current_sum)\n        \n        # Update the total max sum considering the best choices for each row\n        total_max_sum += max(best_mod_sums)\n    \n    return total_max_sum\n\n# Input handling\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = max_sum_divisible_by_k(n, m, k, matrix)\nprint(result)\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = -1\n    moves = []\n    \n    while left <= right:\n        if a[left] < a[right]:\n            if a[left] > last_taken:\n                moves.append('L')\n                last_taken = a[left]\n                left += 1\n            elif a[right] > last_taken:\n                moves.append('R')\n                last_taken = a[right]\n                right -= 1\n            else:\n                break\n        else:\n            if a[right] > last_taken:\n                moves.append('R')\n                last_taken = a[right]\n                right -= 1\n            elif a[left] > last_taken:\n                moves.append('L')\n                last_taken = a[left]\n                left += 1\n            else:\n                break\n\n    print(len(moves))\n    print(''.join(moves))\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\nlongest_increasing_sequence(n, a)\n```",
    "54": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_a = min(a)\nmax_a = max(a)\n\nif min_a == max_a:\n    print(0)\nelse:\n    diff = max_a - min_a\n    if diff % 2 == 0:\n        print(diff // 2)\n    else:\n        print(-1)\n```",
    "55": "```python\ndef is_visible_white_sheet(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n    # Check if the black sheets cover the entire area of the white sheet\n    covered_left = max(x3, x5)  # farthest left covered by black sheets\n    covered_right = min(x4, x6)  # farthest right covered by black sheets\n    covered_bottom = max(y3, y5)  # highest bottom covered by black sheets\n    covered_top = min(y4, y6)  # lowest top covered by black sheets\n    \n    # Check if the white sheet is completely covered\n    if covered_left < x2 and covered_right > x1 and covered_bottom < y2 and covered_top > y1:\n        return \"NO\"\n    else:\n        return \"YES\"\n\n# Input reading\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Output result\nprint(is_visible_white_sheet(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6))\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef reachable_count(n):\n    reachable = set()\n    current = n\n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    return len(reachable)\n\nn = int(input())\nprint(reachable_count(n))\n```",
    "57": "```python\nn = int(input())\nf = list(map(int, input().split()))\n\n# Track the friends who have not been assigned a gift\ngifted = set(f) - {0}\nunknown = [i for i in range(1, n + 1) if i not in gifted]\nto_assign = [i for i in range(n) if f[i] == 0]\n\n# Assign the gifts for those who have '0'\nfor i in range(len(to_assign)):\n    friend_index = to_assign[i]\n    # Choose a gift recipient from unknown\n    recipient = unknown[i]\n    # Ensure that the assignment is valid (no self-gifting)\n    if recipient == friend_index + 1:  # +1 because friend_index is 0-based\n        # If it is, swap with the next one (wrap around if necessary)\n        recipient = unknown[(i + 1) % len(unknown)]\n    \n    f[friend_index] = recipient\n\nprint(\" \".join(map(str, f)))\n```",
    "58": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nfrom collections import defaultdict\n\n# Count the frequency of each number\nfrequency = defaultdict(int)\nfor number in a:\n    frequency[number] += 1\n\n# If any number appears more than k times, it's impossible\nif any(count > k for count in frequency.values()):\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    \n    # Prepare the coloring\n    color_assignment = [0] * n\n    current_color = 1\n    used_colors = defaultdict(list)\n\n    for i in range(n):\n        number = a[i]\n        if len(used_colors[number]) < k:\n            color_assignment[i] = current_color\n            used_colors[number].append(current_color)\n            current_color += 1\n            if current_color > k:\n                current_color = 1\n        else:\n            # If all colors for this number are used, reuse the first color\n            color_assignment[i] = used_colors[number][0]\n\n    print(\" \".join(map(str, color_assignment)))\n```",
    "59": "```python\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# Calculate the target remainder which is 10^y\ntarget = ['0'] * x\ntarget[y] = '1'\n\n# We need to compare the last x digits of the number with the target\ncurrent = number[-x:]\n\n# Count the number of operations needed\noperations = 0\nfor i in range(x):\n    if current[i] != target[i]:\n        operations += 1\n\nprint(operations)\n```",
    "60": "```python\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    found = False\n    # We will use a dictionary to keep track of the last seen index of each number\n    last_seen = {}\n    \n    for i in range(n):\n        if a[i] in last_seen:\n            # If we see the same number again, we can form a palindrome of length at least 3\n            if i - last_seen[a[i]] >= 2:\n                found = True\n                break\n        last_seen[a[i]] = i\n    \n    print(\"YES\" if found else \"NO\")\n```",
    "61": "```python\nn = int(input().strip())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\nmax_a = list(a)\n\n# Flag to indicate if we are in the process of replacing\nreplacing = False\n\nfor i in range(n):\n    original_digit = int(a[i])\n    new_digit = f[original_digit - 1]\n    \n    if new_digit > original_digit:\n        # Start replacing\n        max_a[i] = str(new_digit)\n        replacing = True\n    elif new_digit < original_digit and replacing:\n        # Stop replacing if we encounter a smaller digit\n        break\n    elif not replacing:\n        max_a[i] = str(original_digit)\n\nprint(''.join(max_a))\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        min_moves = float('inf')\n        best_triplet = (0, 0, 0)\n\n        # Iterate through possible values for A\n        for A in range(1, 10001):  # A can be from 1 to 10000\n            # B must be a multiple of A\n            B = ((b + A - 1) // A) * A  # smallest multiple of A >= b\n            if B < b:\n                B += A  # ensure B is at least b\n            \n            # C must be a multiple of B\n            C = ((c + B - 1) // B) * B  # smallest multiple of B >= c\n            if C < c:\n                C += B  # ensure C is at least c\n\n            # Calculate the number of operations\n            operations = max(0, A - a) + max(0, B - b) + max(0, C - c)\n            \n            # Check if the operations are minimal\n            if operations < min_moves:\n                min_moves = operations\n                best_triplet = (A, B, C)\n\n        results.append((min_moves, best_triplet))\n    \n    return results\n\n# Input reading and function execution\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\nresults = min_operations(t, test_cases)\n\n# Output results\nfor moves, (A, B, C) in results:\n    print(moves)\n    print(A, B, C)\n```",
    "63": "```python\ndef minimum_instability(n, a):\n    a.sort()\n    \n    # To minimize instability after removing one element, we can either:\n    # 1. Remove the maximum element (last element in sorted array)\n    # 2. Remove the minimum element (first element in sorted array)\n    \n    # If we remove the maximum element\n    instability_remove_max = a[-2] - a[0]\n    \n    # If we remove the minimum element\n    instability_remove_min = a[-1] - a[1]\n    \n    # The minimum instability after removing one element\n    return min(instability_remove_max, instability_remove_min)\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result and print it\nresult = minimum_instability(n, a)\nprint(result)\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    days = [0] * n  # Initialize days with 0 (rest days)\n    \n    # Sort exams based on the day of the exam\n    exams.sort(key=lambda x: x[1])\n    \n    # Preparation tracking\n    preparation_days = [0] * m  # How many days are allocated for preparation for each exam\n    exam_days = [0] * m  # When exams are scheduled \n\n    for i in range(m):\n        s_i, d_i, c_i = exams[i]\n        s_i -= 1  # Convert to 0-indexed\n        d_i -= 1  # Convert to 0-indexed\n        exam_days[i] = d_i\n        \n        # Try to allocate preparation days\n        count = 0\n        for j in range(s_i, d_i):\n            if days[j] == 0 and count < c_i:  # Only prepare on rest days\n                days[j] = i + 1  # Marking preparation for exam i\n                count += 1\n        \n        preparation_days[i] = count\n        \n        # If we couldn't allocate enough preparation days, return -1\n        if count < c_i:\n            return -1\n    \n    # Mark exam days\n    for i in range(m):\n        days[exam_days[i]] = m + 1  # Marking exam day\n    \n    return days\n\n# Read input\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the schedule\nresult = schedule_exams(n, m, exams)\n\n# Print the result\nif result == -1:\n    print(result)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "65": "```python\ndef min_moves(n, m):\n    if m % n != 0:\n        return -1\n    \n    k = m // n\n    moves = 0\n    \n    while k > 1:\n        if k % 2 == 0:\n            k //= 2\n            moves += 1\n        elif k % 3 == 0:\n            k //= 3\n            moves += 1\n        else:\n            return -1\n    \n    return moves\n\n# Read input\nn, m = map(int, input().split())\nprint(min_moves(n, m))\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Find the longest suffix of t that is also a prefix\n    for i in range(n - 1, -1, -1):\n        if t.startswith(t[i:]):\n            overlap = i\n            break\n            \n    # Construct the result string\n    result = t + (t[overlap:] * (k - 1))\n    return result\n\n# Read input\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the constructed string\nresult = construct_string(n, k, t)\n\n# Print the result\nprint(result)\n```",
    "67": "```python\ndef find_nice_indices(n, a):\n    total_sum = sum(a)\n    nice_indices = []\n\n    for i in range(n):\n        remaining_sum = total_sum - a[i]\n        if remaining_sum == 2 * a[i]:\n            nice_indices.append(i + 1)\n\n    print(len(nice_indices))\n    if nice_indices:\n        print(\" \".join(map(str, nice_indices)))\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\nfind_nice_indices(n, a)\n```",
    "68": "```python\nfrom itertools import combinations\n\ndef min_cost_to_obtain_set(n, k, s):\n    subsequences = set()\n    \n    # Generate all unique subsequences\n    for i in range(n + 1):\n        for combo in combinations(s, i):\n            subsequences.add(''.join(combo))\n    \n    # If the number of unique subsequences is less than k, return -1\n    if len(subsequences) < k:\n        return -1\n    \n    # Calculate the cost for the k smallest subsequences\n    costs = []\n    for t in subsequences:\n        costs.append(n - len(t))  # Cost is n - |t|\n    \n    costs.sort()\n    \n    return sum(costs[:k])\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result\nresult = min_cost_to_obtain_set(n, k, s)\n\n# Print the result\nprint(result)\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n\n    # Build the graph\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n\n    # Check if we can form a valid spanning tree\n    if D >= n or len(graph[1]) < D:\n        print(\"NO\")\n        return\n\n    # Start building the spanning tree\n    tree_edges = []\n    visited = set()\n    visited.add(1)\n    degree_1 = 0\n\n    # Choose D edges from vertex 1\n    for neighbor in graph[1]:\n        if degree_1 < D:\n            tree_edges.append((1, neighbor))\n            visited.add(neighbor)\n            degree_1 += 1\n        else:\n            break\n\n    # BFS/DFS to add the remaining edges\n    queue = deque()\n    for neighbor in graph[1]:\n        if degree_1 < D:\n            continue\n        if neighbor not in visited:\n            queue.append(neighbor)\n\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                tree_edges.append((current, neighbor))\n                visited.add(neighbor)\n                queue.append(neighbor)\n                if len(tree_edges) == n - 1:\n                    break\n        if len(tree_edges) == n - 1:\n            break\n\n    # If we have exactly n-1 edges, we have a spanning tree\n    if len(tree_edges) == n - 1:\n        print(\"YES\")\n        for v, u in tree_edges:\n            print(v, u)\n    else:\n        print(\"NO\")\n\n# Read input\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Find a spanning tree\nfind_spanning_tree(n, m, D, edges)\n```",
    "70": "```python\n# Read input\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Convert start and end times to minutes\nstart_minutes = h1 * 60 + m1\nend_minutes = h2 * 60 + m2\n\n# Calculate midpoint in minutes\nmidpoint_minutes = (start_minutes + end_minutes) // 2\n\n# Convert back to hours and minutes\nh3 = midpoint_minutes // 60\nm3 = midpoint_minutes % 60\n\n# Print the result with leading zeros\nprint(f\"{h3:02}:{m3:02}\")\n```",
    "71": "```python\nimport math\n\na = int(input())\noutput = math.floor(math.log2(a))\nprint(output)\n```",
    "72": "```python\ndef maximal_intersection_length(n, segments):\n    # Separate the segments into left and right endpoints\n    l = [segments[i][0] for i in range(n)]\n    r = [segments[i][1] for i in range(n)]\n    \n    # Precompute the max of left endpoints and min of right endpoints\n    max_left = [0] * n\n    min_right = [0] * n\n    \n    max_left[0] = l[0]\n    for i in range(1, n):\n        max_left[i] = max(max_left[i - 1], l[i])\n    \n    min_right[n - 1] = r[n - 1]\n    for i in range(n - 2, -1, -1):\n        min_right[i] = min(min_right[i + 1], r[i])\n    \n    max_length = 0\n    \n    for i in range(n):\n        if i == 0:\n            left_bound = max_left[1]\n            right_bound = min_right[1]\n        elif i == n - 1:\n            left_bound = max_left[n - 2]\n            right_bound = min_right[n - 2]\n        else:\n            left_bound = max(max_left[i - 1], l[i + 1])\n            right_bound = min(min_right[i + 1], r[i - 1])\n        \n        intersection_length = max(0, right_bound - left_bound)\n        max_length = max(max_length, intersection_length)\n    \n    return max_length\n\n# Read input\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(maximal_intersection_length(n, segments))\n```",
    "73": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmax_height = max(a)\ntotal_bricks_needed = 0\ncurrent_bricks_available = 0\n\nfor height in a:\n    if height < max_height:\n        total_bricks_needed += (max_height - height)\n    elif height > max_height:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    unique_characters = set(s)\n    count_unique = len(unique_characters)\n    \n    # If number of unique characters is less than k, it's impossible\n    if count_unique < k:\n        return -1\n    \n    # Calculate the total number of unique subsequences we can generate\n    total_subsequences = 0\n    cost = 0\n    power_of_two = 1  # 2^0\n    \n    for length in range(1, n + 1):\n        power_of_two *= 2\n        total_subsequences += power_of_two - 1  # We exclude the empty subsequence\n        cost += n - length  # Cost to add subsequences of this length\n        \n        if total_subsequences >= k:\n            return cost - (total_subsequences - k)  # Adjust cost if we have extras\n    \n    # If we still don't have enough subsequences after considering all lengths\n    return -1\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Calculate and output the result\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Food requirements based on day of the week\n    days = [\n        (1, 0, 0),  # Monday - fish food\n        (1, 0, 0),  # Tuesday - fish food\n        (0, 1, 0),  # Wednesday - rabbit stew\n        (0, 1, 0),  # Thursday - rabbit stew\n        (0, 0, 1),  # Friday - chicken stake\n        (0, 0, 1),  # Saturday - chicken stake\n        (1, 0, 0)   # Sunday - fish food\n    ]\n\n    max_days_count = 0\n\n    for start_day in range(7):\n        fish = a\n        rabbit = b\n        chicken = c\n        days_count = 0\n        \n        for i in range(7):\n            current_day = (start_day + i) % 7\n            if days[current_day][0] > 0:  # Fish food required\n                if fish > 0:\n                    fish -= 1\n                    days_count += 1\n                else:\n                    break\n            elif days[current_day][1] > 0:  # Rabbit stew required\n                if rabbit > 0:\n                    rabbit -= 1\n                    days_count += 1\n                else:\n                    break\n            elif days[current_day][2] > 0:  # Chicken stake required\n                if chicken > 0:\n                    chicken -= 1\n                    days_count += 1\n                else:\n                    break\n\n        max_days_count = max(max_days_count, days_count)\n\n    return max_days_count\n\n# Input\na, b, c = map(int, input().split())\nprint(max_days(a, b, c))\n```",
    "76": "```python\ndef can_construct_square(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        can_form = False\n        for i in range(n):\n            for j in range(n):\n                if tiles[i][1] == tiles[j][0]:  # top right of tile i matches bottom left of tile j\n                    can_form = True\n                    break\n            if can_form:\n                break\n        \n        results.append(\"YES\" if can_form else \"NO\")\n    \n    return results\n\n# Reading input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for __ in range(n):\n        top = list(map(int, input().split()))\n        bottom = list(map(int, input().split()))\n        tiles.append((top[0], top[1], bottom[0], bottom[1]))  # (tl, tr, bl, br)\n    test_cases.append((n, m, tiles))\n\n# Getting results\nresults = can_construct_square(t, test_cases)\n\n# Printing output\nfor result in results:\n    print(result)\n```",
    "77": "```python\ndef min_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nn = int(input())\nprint(min_difference(n))\n```",
    "78": "```python\nMOD = 10**9 + 7\n\ndef count_regular_sequences(n, s):\n    m = len(s)\n    \n    # Check if s can be a substring of a valid sequence\n    balance = 0\n    min_balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n    \n    if balance < 0 or min_balance < 0:\n        return 0\n    \n    # dp[i][b] = number of valid sequences of length i with balance b\n    dp = [[0] * (n + 1) for _ in range(2 * n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, 2 * n + 1):\n        for b in range(n + 1):\n            if b > 0:\n                dp[i][b] = dp[i - 1][b - 1]  # Adding '('\n            if b < n:\n                dp[i][b] += dp[i - 1][b + 1]  # Adding ')'\n            dp[i][b] %= MOD\n    \n    total_count = 0\n    \n    for start in range(2 * n - m + 1):\n        if start > 0:\n            prefix_balance = [0] * (start + 1)\n            for i in range(start):\n                if s[i] == '(':\n                    prefix_balance[i + 1] = prefix_balance[i] + 1\n                else:\n                    prefix_balance[i + 1] = prefix_balance[i] - 1\n            if prefix_balance[start] < 0:\n                continue\n            if prefix_balance[start] + balance < 0:\n                continue\n\n        suffix_balance = [0] * (2 * n - (start + m) + 1)\n        for i in range(2 * n - (start + m)):\n            if s[start + m + i] == '(':\n                suffix_balance[i + 1] = suffix_balance[i] + 1\n            else:\n                suffix_balance[i + 1] = suffix_balance[i] - 1\n\n        if suffix_balance[-1] + balance < 0:\n            continue\n\n        # Count valid sequences before s and after s\n        prefix_valid = dp[start][0]\n        suffix_valid = dp[2 * n - (start + m)][suffix_balance[-1] + balance]\n        \n        total_count += (prefix_valid * suffix_valid) % MOD\n        total_count %= MOD\n    \n    return total_count\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_regular_sequences(n, s))\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    target_ends = [\"00\", \"25\", \"50\", \"75\"]\n    min_moves = float('inf')\n    \n    for target in target_ends:\n        # Try to form the target ending\n        last_digit_pos = -1\n        for i in range(length - 1, -1, -1):\n            if last_digit_pos == -1 and s[i] == target[1]:\n                last_digit_pos = i\n            elif last_digit_pos != -1 and s[i] == target[0]:\n                # Calculate moves needed to bring these two digits to the end\n                moves = (length - 1 - last_digit_pos) + (last_digit_pos - i)\n                min_moves = min(min_moves, moves)\n                break\n\n    return -1 if min_moves == float('inf') else min_moves\n\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    from collections import defaultdict\n\n    # Create a list to store the color for each character\n    colors = [0] * n\n    # Dictionary to store the last index of each character\n    last_index = defaultdict(list)\n\n    # Store the indices of each character in the string\n    for i, char in enumerate(s):\n        last_index[char].append(i)\n\n    # To determine the minimum colors needed\n    color = 1\n    for char in sorted(last_index.keys()):\n        indices = last_index[char]\n        for idx in indices:\n            if colors[idx] == 0:  # If not colored yet\n                colors[idx] = color\n        color += 1\n\n    # Now we need to set the colors in such a way\n    # that adjacent different colors can be swapped\n    max_color = 0\n    for i in range(n):\n        if i > 0 and s[i] != s[i - 1]:\n            # If we encounter different characters, we need to assign a new color\n            max_color = max(max_color, colors[i - 1])\n            colors[i] = max_color + 1\n        else:\n            # If the same character appears, keep the same color\n            colors[i] = colors[i - 1]\n\n    # The number of unique colors used\n    unique_colors = len(set(colors))\n\n    # Print the results\n    print(unique_colors)\n    print(' '.join(map(str, colors)))\n\n# Example usage:\nn = int(input())\ns = input().strip()\nmin_colors_to_sort(n, s)\n```",
    "81": "```python\ndef can_reorder_strings(n, strings):\n    # Sort strings by length\n    strings.sort(key=len)\n    \n    # Check for the substring condition\n    for i in range(n):\n        for j in range(i):\n            if strings[j] not in strings[i]:\n                print(\"NO\")\n                return\n    \n    print(\"YES\")\n    for s in strings:\n        print(s)\n\n# Input reading\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\ncan_reorder_strings(n, strings)\n```",
    "82": "```python\nn, k = map(int, input().split())\nproblems = list(map(int, input().split()))\n\nsolved = 0\n\n# Solve from the left\nwhile solved < n and problems[0] <= k:\n    solved += 1\n    problems.pop(0)\n\n# Solve from the right\nwhile solved < n and problems and problems[-1] <= k:\n    solved += 1\n    problems.pop()\n\nprint(solved)\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n    \n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            # Check both (width, height) and (height, width)\n            for w, h in [(width, height), (height, width)]:\n                # Ensure we can fit a red rectangle and a blue rectangle\n                for r_width in range(1, w + 1):\n                    if a % r_width == 0:\n                        r_height = a // r_width\n                        if r_height <= h:\n                            # Now we have a valid red rectangle\n                            # Calculate remaining area for blue\n                            remaining_width = w\n                            remaining_height = h - r_height\n                            if remaining_height > 0 and remaining_width > 0:\n                                for b_width in range(1, remaining_width + 1):\n                                    if b % b_width == 0:\n                                        b_height = b // b_width\n                                        if b_height <= remaining_height:\n                                            perimeter = 2 * (w + h)\n                                            min_perimeter = min(min_perimeter, perimeter)\n\n    return min_perimeter\n\n# Input reading\na, b = map(int, input().split())\nresult = minimal_perimeter(a, b)\nprint(result)\n```",
    "84": "```python\nn = int(input().strip())\ns = input().strip()\n\nsorted_s = sorted(s)\ncoloring = ['0'] * n\n\n# Build a mapping of character to their positions in the sorted string\nchar_positions = {}\nfor idx, char in enumerate(sorted_s):\n    if char not in char_positions:\n        char_positions[char] = []\n    char_positions[char].append(idx)\n\n# To keep track of how many of each character we have colored\ncolored_count = {char: 0 for char in char_positions}\n\nfor i in range(n):\n    char = s[i]\n    # Get the actual position in the sorted array that this character would go to\n    pos = char_positions[char][colored_count[char]]\n    colored_count[char] += 1\n\n    # If the color for current character is not set, set it to '0' or '1' depending on its position\n    if coloring[pos] == '0':\n        coloring[pos] = '0'\n    else:\n        coloring[pos] = '1'\n\n# Check if the coloring can lead to a sorted arrangement\nfor i in range(1, n):\n    if s[i] < s[i - 1] and coloring[i] == coloring[i - 1]:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")\n    print(''.join(coloring))\n```",
    "85": "```python\nimport math\nimport sys\n\n# Read input\nA, B = map(int, sys.stdin.read().strip().split())\n\n# Initialize the result variable to None\nresult = None\n\n# Check prices from 1 to 1000 (a reasonable range)\nfor price in range(1, 1001):\n    tax_8 = math.floor(price * 0.08)\n    tax_10 = math.floor(price * 0.10)\n    \n    if tax_8 == A and tax_10 == B:\n        result = price\n        break\n\n# Print the result or -1 if no valid price was found\nprint(result if result is not None else -1)\n```",
    "86": "```python\ndef solve_problems(n, k):\n    # Minimum problems that need to be solved in k days\n    min_problems = k * (k + 1) // 2\n    if n < min_problems:\n        print(\"NO\")\n        return\n    \n    # Starting array where we will store the problems solved each day\n    a = list(range(1, k + 1))\n    total = sum(a)\n    \n    # Distributing the remaining problems\n    remaining = n - total\n    \n    # We can increment the last day until we fulfill the constraints\n    for i in range(k - 1, -1, -1):\n        # The maximum we can add to a[i] while respecting the constraints\n        max_add = 2 * a[i] - a[i] - 1  # a[i] < a[i+1] <= 2 * a[i]\n        if i < k - 1:\n            max_add = min(max_add, 2 * a[i] - a[i + 1] - 1)\n        \n        add = min(remaining, max_add)\n        a[i] += add\n        remaining -= add\n        \n        if remaining <= 0:\n            break\n\n    if remaining > 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(' '.join(map(str, a)))\n\n# Example usage\nn, k = map(int, input().split())\nsolve_problems(n, k)\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Separate the projects into two groups: those that increase rating and those that decrease it\n    increase_projects = []\n    decrease_projects = []\n\n    for a, b in projects:\n        if b >= 0:\n            increase_projects.append((a, b))\n        else:\n            decrease_projects.append((a, b))\n\n    # Sort increasing projects by required rating\n    increase_projects.sort()\n\n    # Try to complete all increasing projects first\n    current_rating = r\n    completed_projects = 0\n\n    for a, b in increase_projects:\n        if current_rating >= a:\n            current_rating += b\n            completed_projects += 1\n\n    # Sort decreasing projects by required rating\n    decrease_projects.sort()\n\n    # Try to complete decreasing projects\n    while True:\n        any_completed = False\n        for a, b in decrease_projects:\n            if current_rating >= a:\n                current_rating += b\n                if current_rating < 0:  # If rating drops below zero, we can't complete this project\n                    current_rating -= b  # revert the change\n                else:\n                    completed_projects += 1\n                    any_completed = True\n        if not any_completed:\n            break\n\n    return completed_projects\n\n# Read input\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print\nresult = max_projects(n, r, projects)\nprint(result)\n```",
    "88": "```python\ndef create_palindromic_matrix(n, elements):\n    from collections import Counter\n\n    count = Counter(elements)\n    odd_count = sum(1 for v in count.values() if v % 2 != 0)\n\n    # Check if it's possible to create a palindromic matrix\n    if (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n        return \"NO\"\n\n    # Preparing the matrix\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Fill the matrix with the elements\n    half = n // 2\n    center = (n - 1) // 2\n    sorted_elements = sorted(count.items(), key=lambda x: -x[1])\n    \n    for value, freq in sorted_elements:\n        while freq > 0:\n            if n % 2 == 1 and freq >= 1 and odd_count == 1:\n                matrix[center][center] = value\n                freq -= 1\n                odd_count -= 1\n                continue\n\n            # Fill the quadrants\n            for i in range(half + 1):\n                for j in range(half + 1):\n                    if freq > 0:\n                        if matrix[i][j] == 0:\n                            matrix[i][j] = value\n                            matrix[i][n - 1 - j] = value\n                            matrix[n - 1 - i][j] = value\n                            matrix[n - 1 - i][n - 1 - j] = value\n                            freq -= 4\n                            if freq < 0:\n                                return \"NO\"\n    \n    return \"YES\", matrix\n\n# Input handling\nn = int(input().strip())\nelements = list(map(int, input().strip().split()))\n\nresult = create_palindromic_matrix(n, elements)\n\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for row in result[1]:\n        print(\" \".join(map(str, row)))\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects by their required rating (a_i)\n    projects.sort()\n\n    for a_i, b_i in projects:\n        if r < a_i:  # If current rating is less than required for the project\n            return \"NO\"\n        r += b_i  # Update the rating after completing the project\n        if r < 0:  # If rating drops below zero\n            return \"NO\"\n\n    return \"YES\"\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(can_complete_projects(n, r, projects))\n```",
    "90": "```python\ndef can_cross_river(n, m, d, c):\n    total_platform_length = sum(c)\n    # If the maximum jump distance is greater than or equal to the width of the river,\n    # we can directly reach the other side.\n    if d >= n + 1:\n        print(\"YES\")\n        print(\"0 \" * n + \"1\")  # All cells can be empty except the last one.\n        return\n\n    # We need to check if we can position the platforms such that we can jump across\n    # the gaps between them. We will attempt to place them as left as possible.\n    places = [0] * n\n    current_position = 0\n\n    for index in range(m):\n        platform_length = c[index]\n        if current_position + platform_length > n:\n            print(\"NO\")\n            return\n        # Place the platform\n        for i in range(platform_length):\n            places[current_position + i] = index + 1\n        current_position += platform_length\n\n        # Leave a gap of d between the platforms if possible\n        if index < m - 1:  # No gap needed after the last platform\n            current_position += d\n    \n    # Check if we can reach the end (n + 1) after placing all platforms\n    if current_position > n:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    print(\" \".join(map(str, places)))\n\n# Read input\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\ncan_cross_river(n, m, d, c)\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n    \n    # Precompute the leftmost positions where t can be formed\n    left = [0] * m\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n\n    # Precompute the rightmost positions where t can be formed\n    right = [0] * m\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n\n    # Now we try to find the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n\n    return max_length\n\n# Input reading\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(max_removable_length(s, t))\n```",
    "92": "```python\nx = float(input().strip())\n\n# Iterate through all pairs of integers (a, b) where 1 <= a, b <= 10\nfor a in range(1, 11):\n    for b in range(1, 11):\n        # Check if the condition is satisfied\n        if abs(a * b - x) < 1e-6:\n            print(a, b)\n            break\n    else:\n        continue\n    break\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    # Check if it's possible to construct the tree\n    if d > 2 * k or (d == 1 and n > 2) or (n > k + 1 and d == 1):\n        print(\"NO\")\n        return\n\n    # Start constructing the tree\n    edges = []\n    \n    # Create a chain of length d\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n    \n    # Now we have d + 1 vertices used (1 to d + 1)\n    used_vertices = d + 1\n    \n    # Now we need to connect the remaining vertices\n    # We can connect them to the first vertex (1) or other vertices in the chain\n    for i in range(used_vertices + 1, n + 1):\n        if len(edges) < n - 1:\n            # Try to connect to the first vertex\n            if edges.count((1, i)) == 0 and edges.count((i, 1)) == 0:\n                edges.append((1, i))\n            else:\n                # Connect to vertex 2 if possible\n                if edges.count((2, i)) == 0 and edges.count((i, 2)) == 0:\n                    edges.append((2, i))\n                else:\n                    # Connect to the next in the chain\n                    edges.append((3, i))\n    \n    if len(edges) != n - 1:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    for u, v in edges:\n        print(u, v)\n\n# Read input\nn, d, k = map(int, input().split())\nconstruct_tree(n, d, k)\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Start with an empty string\n    s = []\n    \n    # Determine the starting character based on the parity of x\n    if x % 2 == 1:\n        # Start with '1' if x is odd\n        current_char = '1'\n        b -= 1\n    else:\n        # Start with '0' if x is even\n        current_char = '0'\n        a -= 1\n\n    # We need to create x transitions\n    for i in range(x):\n        s.append(current_char)\n        # Alternate between '0' and '1'\n        current_char = '0' if current_char == '1' else '1'\n    \n    # After x transitions, we need to fill the rest of the string\n    if current_char == '0':\n        # Fill with remaining zeros\n        s.append('0' * a)\n        s.append('1' * b)\n    else:\n        # Fill with remaining ones\n        s.append('1' * b)\n        s.append('0' * a)\n\n    # Join the list to form the final string\n    return ''.join(s)\n\n# Input\na, b, x = map(int, input().split())\n# Output the constructed string\nprint(construct_binary_string(a, b, x))\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Create the base string with n 'a's, n 'b's, and n 'c's\n    base = 'a' * n + 'b' * n + 'c' * n\n    \n    # Check for the two substrings s and t, and try to avoid them\n    # If s or t is made of the same characters, we can directly rearrange\n    if s[0] == s[1] or t[0] == t[1]:\n        # Simply shuffle the base string\n        res = base\n        print(\"YES\")\n        print(res)\n        return\n    \n    def is_valid(res):\n        return s not in res and t not in res\n\n    # Try to generate a valid string by shuffling\n    from itertools import permutations\n    \n    for perm in permutations(base):\n        res = ''.join(perm)\n        if is_valid(res):\n            print(\"YES\")\n            print(res)\n            return\n    \n    print(\"NO\")\n\n# Reading input\nn = int(input().strip())\ns = input().strip()\nt = input().strip()\n\ngenerate_string(n, s, t)\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    p = [0] * n\n    p[0] = 0  # Start with an arbitrary value\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n\n    # Shift the permutation to make all values positive and in the range [1, n]\n    min_value = min(p)\n    shift = 1 - min_value\n\n    for i in range(n):\n        p[i] += shift\n\n    # Check if the result is a valid permutation\n    if len(set(p)) == n and all(1 <= x <= n for x in p):\n        print(' '.join(map(str, p)))\n    else:\n        print(-1)\n\n# Reading input\nn = int(input())\nq = list(map(int, input().split()))\n\n# Restoring the permutation\nrestore_permutation(n, q)\n```",
    "97": "```python\nn = int(input())\nchips = list(map(int, input().split()))\n\neven_count = sum(1 for x in chips if x % 2 == 0)\nodd_count = n - even_count\n\n# The minimum cost is the smaller of the two counts\nmin_cost = min(even_count, odd_count)\nprint(min_cost)\n```",
    "98": "```python\ndef min_moves_to_reach_n(N):\n    min_moves = float('inf')\n    \n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            moves = (i - 1) + (j - 1)  # (i-1) for row moves, (j-1) for column moves\n            min_moves = min(min_moves, moves)\n    \n    return min_moves\n\nN = int(input())\nprint(min_moves_to_reach_n(N))\n```",
    "99": "```python\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\n# Maximum wins for Alice\nmax_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n\n# Minimum wins for Alice\n# To minimize Alice's wins, we can maximize Bob's wins.\n# Bob wins with his rocks against Alice's scissors,\n# Bob wins with his scissors against Alice's paper,\n# Bob wins with his paper against Alice's rock.\n\nalice_loses = min(a2, b1) + min(a3, b2) + min(a1, b3)\nmin_wins = n - alice_loses\n\nprint(min_wins, max_wins)\n```"
}