{
    "2": "```python\ndef next_lucky_year(n):\n    while True:\n        n += 1\n        if sum(1 for digit in str(n) if digit != '0') <= 1:\n            return n - (n - 1)\n\ncurrent_year = int(input())\nprint(next_lucky_year(current_year))\n```",
    "7": "```python\ndef days_until_empty(n, m):\n    day = 0\n    total_eaten = 0\n\n    while n > 0:\n        day += 1\n        n += m  # Add grains brought that day\n        if n > m:  # Ensure barn does not exceed capacity\n            n = n  # No need to change n, it remains up to capacity\n        \n        total_eaten += day  # Total grains eaten by sparrows\n\n        n -= total_eaten  # Subtract the total grains eaten by sparrows\n\n    return day\n\n# Read input\nn, m = map(int, input().split())\nprint(days_until_empty(n, m))\n```",
    "4": "```python\ndef is_lucky(hh, mm):\n    return '7' in f\"{hh:02}{mm:02}\"\n\ndef time_before(hh, mm, x, y):\n    total_minutes = (hh * 60 + mm - y * x) % 1440  # wrap around after 24 hours\n    return total_minutes // 60, total_minutes % 60\n\nx = int(input().strip())\nhh, mm = map(int, input().strip().split())\n\ny = 0\nwhile True:\n    prev_hh, prev_mm = time_before(hh, mm, x, y)\n    if is_lucky(prev_hh, prev_mm):\n        print(y)\n        break\n    y += 1\n```",
    "1": "```python\ndef sum_of_digits(n):\n    return sum(int(d) for d in str(n))\n\ndef max_sum_digits(x):\n    str_x = str(x)\n    n = len(str_x)\n\n    # Start with the original number\n    max_number = x\n    max_digit_sum = sum_of_digits(x)\n\n    # Generate candidates by reducing digits\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        # Create a new candidate by reducing the current digit\n        candidate = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        candidate_number = int(candidate)\n        if candidate_number > 0 and candidate_number <= x:\n            candidate_digit_sum = sum_of_digits(candidate_number)\n            if (candidate_digit_sum > max_digit_sum or \n               (candidate_digit_sum == max_digit_sum and candidate_number > max_number)):\n                max_number = candidate_number\n                max_digit_sum = candidate_digit_sum\n\n    return max_number\n\nx = int(input().strip())\nprint(max_sum_digits(x))\n```",
    "10": "```python\nn = int(input())\n\n# Calculate maximum days off\nmax_days_off = (n // 7) * 2 + min(2, n % 7)\n\n# Calculate minimum days off\nmin_days_off = 0 if n < 5 else (n // 7) * 2\n\nprint(min_days_off, max_days_off)\n```",
    "6": "```python\ndef min_blows_to_defeat(t, queries):\n    results = []\n    \n    for query in queries:\n        n, x, blows = query\n        min_blows = float('inf')\n\n        for d_i, h_i in blows:\n            if d_i >= x:\n                min_blows = min(min_blows, 1)\n            else:\n                effective_heads_lost = d_i - h_i\n                if effective_heads_lost <= 0:\n                    continue\n                blows_needed = (x - d_i + effective_heads_lost - 1) // effective_heads_lost + 1\n                min_blows = min(min_blows, blows_needed)\n\n        results.append(min_blows if min_blows != float('inf') else -1)\n\n    return results\n\n# Input reading\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\n# Process and output results\nresults = min_blows_to_defeat(t, queries)\nfor result in results:\n    print(result)\n```",
    "0": "```python\ndef max_acc_length(s):\n    n = len(s)\n    l_bracket = -1\n    r_bracket = -1\n\n    # Find the last opening bracket '['\n    for i in range(n):\n        if s[i] == '[':\n            l_bracket = i\n\n    # Find the first closing bracket ']'\n    for i in range(n - 1, -1, -1):\n        if s[i] == ']':\n            r_bracket = i\n\n    # Check for valid brackets\n    if l_bracket == -1 or r_bracket == -1 or l_bracket >= r_bracket:\n        return -1\n\n    # Find the first ':' after the opening bracket\n    first_colon = s.find(':', l_bracket + 1, r_bracket)\n    if first_colon == -1:\n        return -1\n\n    # Find the last ':' before the closing bracket\n    second_colon = s.rfind(':', l_bracket, r_bracket)\n    if second_colon == -1 or second_colon <= first_colon:\n        return -1\n\n    # Count the number of '|' between the colons\n    vertical_lines_count = s.count('|', first_colon + 1, second_colon)\n\n    # Calculate the length of the accordion\n    accordion_length = 4 + vertical_lines_count\n    return accordion_length\n\n\n# Input\ns = input().strip()\n# Output\nprint(max_acc_length(s))\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    # Create a function to calculate painted sections with given painters\n    def painted_length(selected_painters):\n        painted = [0] * (n + 1)\n        for l, r in selected_painters:\n            painted[l] += 1\n            if r + 1 <= n:\n                painted[r + 1] -= 1\n        \n        # Calculate the prefix sum to get the actual painted sections\n        total_painted = 0\n        current_paint = 0\n        for i in range(1, n + 1):\n            current_paint += painted[i]\n            if current_paint > 0:\n                total_painted += 1\n        \n        return total_painted\n\n    max_sections = 0\n\n    # Try removing each pair of painters\n    for i in range(q):\n        for j in range(i + 1, q):\n            # Select all painters except the i-th and j-th\n            selected_painters = [painters[k] for k in range(q) if k != i and k != j]\n            max_sections = max(max_sections, painted_length(selected_painters))\n\n    return max_sections\n\n# Input reading\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output result\nprint(max_painted_sections(n, q, painters))\n```",
    "5": "```python\nn, pos, l, r = map(int, input().split())\n\n# If all tabs are within the range l to r, no action is needed\nif l == 1 and r == n:\n    print(0)\n    exit()\n\ntotal_time = 0\n\n# If there are tabs to the left of l\nif l > 1:\n    # Move to the left tab l\n    total_time += abs(pos - l)  # Move to the leftmost needed tab\n    total_time += 1  # Close all tabs to the left of l\n\n# If there are tabs to the right of r\nif r < n:\n    # Move to the right tab r\n    total_time += abs(pos - r)  # Move to the rightmost needed tab\n    total_time += 1  # Close all tabs to the right of r\n\nprint(total_time)\n```",
    "11": "```python\nimport math\n\ndef max_chocolates(n, a, b, p, q):\n    count_red = n // a\n    count_blue = n // b\n    lcm_ab = a * (b // math.gcd(a, b))  # Calculate LCM using GCD\n    count_both = n // lcm_ab\n    \n    # Calculate chocolates for both painting strategies\n    chocolates_option_1 = (count_red - count_both) * p + count_blue * q\n    chocolates_option_2 = count_red * p + (count_blue - count_both) * q\n    \n    return max(chocolates_option_1, chocolates_option_2)\n\nn, a, b, p, q = map(int, input().split())\nresult = max_chocolates(n, a, b, p, q)\nprint(result)\n```",
    "9": "```python\nd = int(input())\nn, m = map(int, input().split())\nsofas = []\n\nfor _ in range(d):\n    x1, y1, x2, y2 = map(int, input().split())\n    sofas.append((x1, y1, x2, y2))\n\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\ndef count_sofas(sofa_index):\n    x1, y1, x2, y2 = sofas[sofa_index]\n    left_count = right_count = top_count = bottom_count = 0\n\n    for i in range(d):\n        if i == sofa_index:\n            continue\n        sx1, sy1, sx2, sy2 = sofas[i]\n        \n        if (x2 < sx1):  # Current sofa is to the left\n            left_count += 1\n        elif (x1 > sx2):  # Current sofa is to the right\n            right_count += 1\n        if (y2 < sy1):  # Current sofa is above\n            top_count += 1\n        elif (y1 > sy2):  # Current sofa is below\n            bottom_count += 1\n\n    return left_count, right_count, top_count, bottom_count\n\nfor i in range(d):\n    left, right, top, bottom = count_sofas(i)\n    if left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b:\n        print(i + 1)\n        break\nelse:\n    print(-1)\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    print(\"YES\" if a == b else \"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    result = t\nelif t <= n:\n    result = k\nelse:\n    result = max(0, n + k - t)\n\nprint(result)\n```",
    "16": "```python\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\n# Calculate total open and close brackets\nopen_brackets = cnt_1 + cnt_2\nclose_brackets = cnt_2 + cnt_4\n\n# Check conditions for a regular bracket sequence\nif open_brackets >= close_brackets and (open_brackets - close_brackets) <= cnt_3:\n    print(1)\nelse:\n    print(0)\n```",
    "12": "```python\ndef max_beauty(n, trophies):\n    segments = []\n    current_length = 0\n    \n    # Count lengths of golden trophy segments\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n    if current_length > 0:\n        segments.append(current_length)\n\n    # If there are no golden trophies\n    if not segments:\n        return 0\n    \n    # Calculate the maximum length of golden trophies without any swaps\n    max_length = max(segments)\n\n    # If there's only one segment, we cannot increase its length by swapping\n    if len(segments) == 1:\n        return max_length\n\n    # Try to merge segments by swapping one silver trophy\n    for i in range(len(segments) - 1):\n        # Check if we can swap a silver between two segments\n        max_length = max(max_length, segments[i] + segments[i + 1])\n\n    # Check if a swap can be made if there is at least one silver trophy\n    if 'S' in trophies:\n        max_length += 1\n\n    return max_length\n\n# Input reading\nn = int(input().strip())\ntrophies = input().strip()\nprint(max_beauty(n, trophies))\n```",
    "18": "```python\ndef minimal_lexicographic_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        while t:\n            if not u or t[-1] <= u[-1]:\n                u.append(t.pop())\n            else:\n                break\n    \n    return ''.join(u)\n\ns = input().strip()\nprint(minimal_lexicographic_string(s))\n```",
    "8": "```python\ndef min_draws_to_win(tiles):\n    from collections import Counter\n\n    def has_koutsu(tiles):\n        counts = Counter(tiles)\n        return any(count == 3 for count in counts.values())\n\n    def has_shuntsu(tiles):\n        suits = {'m': [], 'p': [], 's': []}\n        for tile in tiles:\n            num = int(tile[0])\n            suit = tile[1]\n            suits[suit].append(num)\n\n        for suit_tiles in suits.values():\n            suit_tiles.sort()\n            for i in range(len(suit_tiles) - 2):\n                if (suit_tiles[i + 1] == suit_tiles[i] + 1 and \n                    suit_tiles[i + 2] == suit_tiles[i] + 2):\n                    return True\n        return False\n\n    if has_koutsu(tiles) or has_shuntsu(tiles):\n        return 0\n\n    counts = Counter(tiles)\n    for tile in tiles:\n        num, suit = int(tile[0]), tile[1]\n        \n        if counts[tile] < 3:\n            return 1  # Need one more for koutsu\n\n        if (num > 1 and (num - 1) in counts and (num + 1) in counts):\n            return 0  # Already can form shuntsu\n\n        if num == 1:\n            return 2 if (2 not in counts) else 1\n        elif num == 9:\n            return 2 if (8 not in counts) else 1\n        else:\n            if (num - 1 in counts and num + 1 in counts):\n                return 0\n            elif (num - 1 in counts or num + 1 in counts):\n                return 1\n            else:\n                return 2\n\n    return 2  # If nothing is possible\n\ntiles = input().strip().split()\nprint(min_draws_to_win(tiles))\n```",
    "14": "```python\ndef is_stack_sortable(n, k, p):\n    stack = []\n    remaining = set(range(1, n + 1)) - set(p)\n    answer = p[:]\n\n    # Check if the first k elements are already in descending order\n    for i in range(1, k):\n        if p[i] > p[i - 1]:\n            return -1\n\n    # Fill the remaining part of the permutation\n    for i in range(k, n):\n        # Take the maximum element that can be added\n        if remaining:\n            max_remain = max(remaining)\n        else:\n            max_remain = 0\n        \n        if not stack or (stack and stack[-1] > max_remain):\n            answer.append(p[i - k])  # Append the last p element if we can\n        else:\n            answer.append(max_remain)\n            remaining.remove(max_remain)\n\n        # Push to stack if possible\n        while remaining and (not stack or stack[-1] < max(remaining)):\n            stack.append(max(remaining))\n            remaining.remove(max(remaining))\n\n    # Finalize the answer\n    while stack:\n        answer.append(stack.pop())\n\n    # Validate the final permutation\n    if sorted(answer) == list(range(1, n + 1)):\n        return answer\n    else:\n        return -1\n\n# Input reading\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\nresult = is_stack_sortable(n, k, p)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef main():\n    n, k = map(int, input().split())\n    main_courses = set(map(int, input().split()))\n    \n    dependencies = defaultdict(list)\n    indegree = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        line = list(map(int, input().split()))\n        t_i = line[0]\n        for j in range(1, t_i + 1):\n            dep_course = line[j]\n            dependencies[dep_course].append(i)\n            indegree[i] += 1\n    \n    queue = deque()\n    \n    for course in range(1, n + 1):\n        if indegree[course] == 0:\n            queue.append(course)\n    \n    order = []\n    taken_courses = set()\n    \n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        taken_courses.add(course)\n        \n        for next_course in dependencies[course]:\n            indegree[next_course] -= 1\n            if indegree[next_course] == 0:\n                queue.append(next_course)\n    \n    if not main_courses.issubset(taken_courses):\n        print(-1)\n        return\n    \n    result = []\n    for course in order:\n        if course in main_courses or any(dep in taken_courses for dep in dependencies[course]):\n            result.append(course)\n    \n    print(len(result))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "19": "```python\ndef check_stats(test_cases):\n    results = []\n    for case in test_cases:\n        n, stats = case\n        valid = True\n        \n        for i in range(n):\n            p_i, c_i = stats[i]\n            if (i > 0):\n                p_prev, c_prev = stats[i - 1]\n                \n                # Check if plays or clears have decreased\n                if p_i < p_prev or c_i < c_prev:\n                    valid = False\n                    break\n                \n                # Check if clears exceed plays\n                if c_i > p_i:\n                    valid = False\n                    break\n                \n                # Check if the increase in clears is valid\n                if p_i - p_prev < c_i - c_prev:\n                    valid = False\n                    break\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Read input\nT = int(input())\ntest_cases = []\nfor _ in range(T):\n    n = int(input())\n    stats = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, stats))\n\n# Get results\nresults = check_stats(test_cases)\n\n# Print output\nfor result in results:\n    print(result)\n```",
    "21": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_pos = a.index(1)\nmax_pos = a.index(n)\n\n# Initial distance\ninitial_distance = abs(min_pos - max_pos)\n\n# Calculate potential new distances after one swap\nnew_distances = [\n    abs(0 - max_pos),       # Swap min (1) with the first element\n    abs(n - 1 - max_pos),   # Swap min (1) with the last element\n    abs(min_pos - 0),       # Swap max (n) with the first element\n    abs(min_pos - (n - 1))  # Swap max (n) with the last element\n]\n\n# The maximum distance achievable after one swap\nmax_distance = max(new_distances)\n\n# Print the maximum distance between min and max\nprint(max(max_distance, initial_distance))\n```",
    "27": "```python\nn = int(input())\ns = input()\n\n# The minimum operations needed to type the string\nmin_operations = n\n\n# Check for possible prefixes to copy\nfor i in range(1, n // 2 + 1):\n    if s[:i] == s[i:2*i]:  # Check if the prefix matches the next segment\n        # Calculate operations: type prefix + copy + remaining characters\n        operations = i + 1 + (n - 2 * i)\n        min_operations = min(min_operations, operations)\n\nprint(min_operations)\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef add_minutes(hh, mm, minutes):\n    mm += minutes\n    hh += mm // 60\n    mm %= 60\n    hh %= 24\n    return hh, mm\n\ndef minimum_sleep_minutes(current_time):\n    hh, mm = map(int, current_time.split(':'))\n    minutes = 0\n    \n    while True:\n        formatted_time = f\"{hh:02d}:{mm:02d}\"\n        if is_palindrome(formatted_time):\n            return minutes\n        minutes += 1\n        hh, mm = add_minutes(hh, mm, 1)\n\ncurrent_time = input().strip()\nprint(minimum_sleep_minutes(current_time))\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror = {'A': 'A', 'B': ' ', 'C': ' ', 'D': ' ', 'E': ' ', 'F': ' ', 'G': ' ', 'H': 'H', \n              'I': 'I', 'J': ' ', 'K': ' ', 'L': ' ', 'M': 'M', 'N': ' ', 'O': 'O', 'P': ' ', \n              'Q': ' ', 'R': ' ', 'S': ' ', 'T': 'T', 'U': 'U', 'V': ' ', 'W': 'W', 'X': 'X', \n              'Y': ' ', 'Z': ' '}\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        if mirror.get(s[i], ' ') != mirror.get(s[n - 1 - i], ' '):\n            return \"NIE\"\n    return \"TAK\"\n\ns = input().strip()\nprint(is_s_palindrome(s))\n```",
    "23": "```python\nfrom itertools import permutations\n\ndef max_permutation(a, b):\n    a_str = str(a)\n    b_str = str(b)\n    \n    # Generate all unique permutations of the digits of a\n    perm_set = set(permutations(a_str))\n    \n    max_num = -1\n    for perm in perm_set:\n        # Join the permutation tuple to form a string, then convert to integer\n        num = int(''.join(perm))\n        \n        # Check if the number is valid: less than or equal to b and same length as a\n        if num <= b and len(str(num)) == len(a_str) and str(num)[0] != '0':\n            max_num = max(max_num, num)\n    \n    return max_num\n\n# Input\na = int(input().strip())\nb = int(input().strip())\n\n# Output\nprint(max_permutation(a, b))\n```",
    "26": "```python\nimport math\n\n# Read input\nx, y, z = map(float, input().split())\n\n# Define the 12 expressions\nexpressions = [\n    (x**(y**z), \"x^y^z\"),\n    (x**(z**y), \"x^z^y\"),\n    ((x**y)**z, \"(x^y)^z\"),\n    ((x**z)**y, \"(x^z)^y\"),\n    (y**(x**z), \"y^x^z\"),\n    (y**(z**x), \"y^z^x\"),\n    ((y**x)**z, \"(y^x)^z\"),\n    ((y**z)**x, \"(y^z)^x\"),\n    (z**(x**y), \"z^x^y\"),\n    (z**(y**x), \"z^y^x\"),\n    ((z**x)**y, \"(z^x)^y\"),\n    ((z**y)**x, \"(z^y)^x\")\n]\n\n# Find the maximum value and its index, ensuring to return the first one in case of ties\nmax_value, max_index = max((value, index) for index, (value, _) in enumerate(expressions))\n\n# Print the corresponding expression, adjusting index for 1-based output\nprint(expressions[max_index][1])\n```",
    "24": "```python\ndef can_win(matrix):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]\n    \n    def check_direction(x, y, dx, dy):\n        count = 0\n        for i in range(-4, 1):\n            nx, ny = x + i * dx, y + i * dy\n            if 0 <= nx < 10 and 0 <= ny < 10 and matrix[nx][ny] == 'X':\n                count += 1\n            else:\n                count = 0\n            if count >= 4:\n                return True\n        return False\n\n    for i in range(10):\n        for j in range(10):\n            if matrix[i][j] == '.':\n                for dx, dy in directions:\n                    if check_direction(i, j, dx, dy):\n                        return 'YES'\n    return 'NO'\n\n# Read input\nmatrix = [input().strip() for _ in range(10)]\nprint(can_win(matrix))\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # Since GCD(x, m) = 1, the x-mouse will visit φ(m) distinct rooms\n    # We can place traps in all of these distinct rooms to ensure the mouse is caught.\n    \n    def euler_totient(n):\n        result = n\n        p = 2\n        while p * p <= n:\n            if n % p == 0:\n                while n % p == 0:\n                    n //= p\n                result -= result // p\n            p += 1\n        if n > 1:\n            result -= result // n\n        return result\n    \n    return euler_totient(m)\n\nm, x = map(int, input().split())\nprint(minimum_traps(m, x))\n```",
    "32": "```python\nn = int(input())\nposition = 0  # Position in kilometers from the North Pole\n\nfor _ in range(n):\n    t, direction = input().split()\n    t = int(t)\n\n    # Check movement constraints\n    if position == 0 and direction != \"South\":\n        print(\"NO\")\n        exit()\n    elif position == 20000 and direction != \"North\":\n        print(\"NO\")\n        exit()\n\n    # Update position based on direction\n    if direction == \"South\":\n        position += t\n    elif direction == \"North\":\n        position -= t\n    # East and West do not change the position in terms of North/South\n    elif direction in [\"East\", \"West\"]:\n        continue\n\n    # Check for valid position range\n    if position < 0 or position > 20000:\n        print(\"NO\")\n        exit()\n\n# Check if ending at the North Pole\nif position == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "25": "```python\ndef create_symmetrical_matrix(n, k):\n    # Check if the number of 1s is valid for a symmetric matrix\n    if k > n * n or k < 0 or (n % 2 == 0 and k % 2 == 1):\n        return -1\n    \n    # Initialize the matrix with zeroes\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Fill the matrix to be lexicographically maximal\n    for i in range(n):\n        for j in range(n):\n            if i == j:  # Diagonal elements\n                if k > 0:\n                    matrix[i][j] = 1\n                    k -= 1\n            elif j > i:  # Upper triangle elements\n                if k >= 2:\n                    matrix[i][j] = 1\n                    matrix[j][i] = 1\n                    k -= 2\n            \n            if k <= 0:\n                break\n        if k <= 0:\n            break\n    \n    # If there are still ones left to place, return -1\n    if k > 0:\n        return -1\n    \n    return matrix\n\n# Read input\nn, k = map(int, input().split())\n\n# Create the matrix\nresult = create_symmetrical_matrix(n, k)\n\n# Print the result\nif result == -1:\n    print(result)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = [f[0] for f in files if f[1] == '1']\nregulars = [f[0] for f in files if f[1] == '0']\n\nmoves = []\n# Move examples to 1 to e\nfor i, example in enumerate(examples):\n    moves.append(f\"move {example} {i + 1}\")\n\n# Move regulars to e + 1 to n\nfor i, regular in enumerate(regulars):\n    moves.append(f\"move {regular} {len(examples) + i + 1}\")\n\nprint(len(moves))\nprint(\"\\n\".join(moves))\n```",
    "37": "```python\na, b, c = map(int, input().split())\n\ndef can_deal_exact_damage(a, b, c):\n    for i in range(c // a + 1):\n        if (c - i * a) >= 0 and (c - i * a) % b == 0:\n            return True\n    return False\n\nif can_deal_exact_damage(a, b, c):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    def can_distribute(x):\n        plates_for_a = (a + x - 1) // x  # ceil(a / x)\n        plates_for_b = (b + x - 1) // x  # ceil(b / x)\n        return plates_for_a + plates_for_b <= n\n\n    low, high = 1, max(a, b)\n    result = 0\n\n    while low <= high:\n        mid = (low + high) // 2\n        if can_distribute(mid):\n            result = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return result\n\n# Input reading\nn, a, b = map(int, input().split())\nprint(max_min_pieces(n, a, b))\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inv(a, m):\n    m0, x0, x1 = m, 0, 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef birthday_paradox(n, k):\n    MOD = 1000003\n    days = 1 << n  # 2^n\n    if k > days:\n        return 1, 1  # Guaranteed a match\n\n    prob_no_match = 1\n    for i in range(k):\n        prob_no_match *= (days - i) % MOD\n        prob_no_match %= MOD\n        prob_no_match *= mod_inv(days, MOD)\n        prob_no_match %= MOD\n\n    prob_match = (1 - prob_no_match + MOD) % MOD\n\n    A = prob_match\n    B = 1\n\n    # Calculate A and B\n    if prob_match > 0:\n        A = (A * (days - k)) % MOD\n        B = (B * days) % MOD\n        prob_match -= 1\n\n    # Reduce A and B\n    common_divisor = gcd(A, B)\n    A //= common_divisor\n    B //= common_divisor\n\n    return A % MOD, B % MOD\n\nn, k = map(int, input().split())\nA, B = birthday_paradox(n, k)\nprint(A, B)\n```",
    "35": "```python\ndef is_valid_flag(n, m, grid):\n    # Check for horizontal stripes\n    if n % 3 != 0 or n < 3:\n        return \"NO\"\n\n    stripe_height = n // 3\n    colors = set()\n    \n    for i in range(0, n, stripe_height):\n        current_color = grid[i][0]\n        if current_color in colors or any(grid[j] != current_color * m for j in range(i, i + stripe_height)):\n            return \"NO\"\n        colors.add(current_color)\n\n    # Check for vertical stripes\n    if m % 3 != 0 or m < 3:\n        return \"NO\"\n\n    stripe_width = m // 3\n    colors.clear()\n    \n    for i in range(0, m, stripe_width):\n        current_color = grid[0][i]\n        if current_color in colors or any(grid[j][k] != current_color for j in range(n) for k in range(i, i + stripe_width)):\n            return \"NO\"\n        colors.add(current_color)\n\n    return \"YES\"\n\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\nprint(is_valid_flag(n, m, grid))\n```",
    "29": "```python\ndef min_replacements_to_lucky_ticket(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    diff = abs(sum_first - sum_second)\n    \n    # Create a list of possible gains from changing each digit\n    gains = []\n    if sum_first > sum_second:\n        for digit in first_half:\n            gains.append(digit)  # Changing this digit to 0 will reduce the sum\n        for digit in second_half:\n            gains.append(9 - digit)  # Changing this digit to 9 will increase the sum\n    else:\n        for digit in second_half:\n            gains.append(digit)  # Changing this digit to 0 will reduce the sum\n        for digit in first_half:\n            gains.append(9 - digit)  # Changing this digit to 9 will increase the sum\n    \n    # Sort gains in descending order to maximize the effect with the least changes\n    gains.sort(reverse=True)\n    \n    count_replacements = 0\n    for gain in gains:\n        diff -= gain\n        count_replacements += 1\n        if diff <= 0:\n            break\n    \n    return count_replacements\n\n# Input\nticket = input().strip()\n# Output\nprint(min_replacements_to_lucky_ticket(ticket))\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if any rating has changed\nrated = any(a != b for a, b in ratings)\n\nif rated:\n    print(\"rated\")\nelse:\n    # Check if standings are valid\n    is_valid = all(ratings[i][0] >= ratings[i + 1][0] for i in range(n - 1))\n    if is_valid:\n        print(\"maybe\")\n    else:\n        print(\"unrated\")\n```",
    "41": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the distances array with a large number\ndistances = [float('inf')] * n\n\n# Forward pass to find distances from the left\nfor i in range(n):\n    if a[i] == 0:\n        distances[i] = 0\n    elif i > 0:\n        distances[i] = distances[i - 1] + 1\n\n# Backward pass to find distances from the right\nfor i in range(n - 1, -1, -1):\n    if a[i] == 0:\n        distances[i] = 0\n    else:\n        distances[i] = min(distances[i], distances[i + 1] + 1)\n\nprint(' '.join(map(str, distances)))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ns = input().strip()\n\n# If the entire string is not a palindrome, return its length\nif not is_palindrome(s):\n    print(len(s))\nelse:\n    # Check for the longest non-palindrome substring\n    n = len(s)\n    # If all characters are the same, return 0\n    if s.count(s[0]) == n:\n        print(0)\n    else:\n        # The longest non-palindrome substring can be at least n-1\n        print(n - 1)\n```",
    "36": "```python\ndef hexagon_coordinates(n):\n    if n == 0:\n        return (0, 0)\n    \n    layer = 0\n    moves_in_layer = 0\n    \n    # Finding which layer the n-th move falls into\n    while moves_in_layer <= n:\n        layer += 1\n        moves_in_layer += 6 * layer\n    \n    # Adjusting layer and moves_in_layer to the last valid layer\n    layer -= 1\n    moves_in_layer -= 6 * layer\n    \n    # Calculate position within the identified layer\n    position_in_layer = n - moves_in_layer\n    x, y = layer, 0  # Starting point of the layer in the coordinate system\n    \n    if position_in_layer == 0:\n        return (x, y)\n    \n    direction = position_in_layer // layer\n    steps = position_in_layer % layer\n\n    # Move according to the calculated direction and steps\n    if direction == 0:  # Right\n        x += steps\n    elif direction == 1:  # Up-right\n        x += layer\n        y += steps\n    elif direction == 2:  # Up-left\n        x += layer - steps\n        y += layer\n    elif direction == 3:  # Left\n        x -= steps\n        y += layer\n    elif direction == 4:  # Down-left\n        x -= layer\n        y -= steps\n    elif direction == 5:  # Down-right\n        x -= layer - steps\n        y -= layer\n    \n    return (x, y)\n\nn = int(input().strip())\nx, y = hexagon_coordinates(n)\nprint(x, y)\n```",
    "38": "```python\ndef can_be_same_track(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between barriers for Kefa and Sasha\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Check if sasha_diffs can be found in the doubled kefa_diffs\n    combined_diffs = kefa_diffs * 2  # Concatenate to allow rotation\n    for i in range(n):\n        if combined_diffs[i:i + n] == sasha_diffs:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Get result and print\nresult = can_be_same_track(n, L, kefa_distances, sasha_distances)\nprint(result)\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n\n    def is_cyclic(s1, s2):\n        return s1 in (s2 + s2)\n\n    # Generate all binary strings of length n\n    binary_strings = [''.join(p) for p in product(\"01\", repeat=n)]\n    \n    # Use a set to track unique cyclical strings that contain s\n    unique_cyclic_strings = set()\n\n    # Check each binary string if it contains s in any cyclic shift\n    for t in binary_strings:\n        if any(is_cyclic(s, t[i:] + t[:i]) for i in range(n)):\n            unique_cyclic_strings.add(t)\n\n    return len(unique_cyclic_strings)\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_cyclic_strings(n, s))\n```",
    "43": "```python\nimport sys\nimport math\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn = int(data[0])\nvectors = []\n\nfor i in range(1, n + 1):\n    x, y = map(int, data[i].split())\n    angle = math.atan2(y, x)\n    vectors.append((angle, i))\n\n# Sort vectors based on the angle\nvectors.sort()\n\nmin_angle = float('inf')\nindex_pair = (0, 0)\n\n# Find the minimum angle between consecutive vectors\nfor i in range(n):\n    angle1, index1 = vectors[i]\n    angle2, index2 = vectors[(i + 1) % n]  # Wrap around using modulo\n    angle_diff = angle2 - angle1\n    \n    # Ensure the angle is non-negative\n    if angle_diff < 0:\n        angle_diff += 2 * math.pi\n    \n    # Calculate the non-oriented angle\n    non_oriented_angle = min(angle_diff, 2 * math.pi - angle_diff)\n\n    if non_oriented_angle < min_angle:\n        min_angle = non_oriented_angle\n        index_pair = (index1, index2)\n\nprint(index_pair[0], index_pair[1])\n```",
    "44": "```python\ndef minimal_time(d, k, a, b, t):\n    # Time when Vasiliy only walks\n    time_by_foot = d * b\n    \n    # Time when Vasiliy uses the car\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Total time using car: time for full segments + time for remaining distance\n    time_by_car = full_segments * (k * a + t) + remaining_distance * a\n    \n    # If there is any distance left, subtract the last repair time if it was added\n    if remaining_distance == 0 and full_segments > 0:\n        time_by_car -= t\n    \n    # Compare time by foot and time by car\n    return min(time_by_foot, time_by_car)\n\n# Input reading\nd, k, a, b, t = map(int, input().split())\n# Output the result\nprint(minimal_time(d, k, a, b, t))\n```",
    "46": "```python\ndef count_pairs(n, m):\n    # Count occurrences of each remainder when divided by 5\n    count_x = [0] * 5\n    count_y = [0] * 5\n\n    # Count occurrences of remainders for numbers from 1 to n\n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n\n    # Count occurrences of remainders for numbers from 1 to m\n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n\n    # Count valid pairs (x, y) such that (x + y) % 5 == 0\n    result = 0\n    for i in range(5):\n        result += count_x[i] * count_y[(5 - i) % 5]\n\n    return result\n\n# Input\nn, m = map(int, input().split())\n# Output\nprint(count_pairs(n, m))\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Minimum sum of first k positive integers\n    min_sum = k * (k + 1) // 2\n    \n    if n < min_sum:\n        return -1\n    \n    # Calculate the maximum possible GCD\n    max_gcd = n // k\n    while max_gcd > 0:\n        total = min_sum * max_gcd\n        \n        if total == n:\n            return [i * max_gcd for i in range(1, k + 1)]\n        elif total < n:\n            remainder = n - total\n            if remainder >= k * max_gcd:\n                # Distribute the remainder evenly\n                base_sequence = [i * max_gcd for i in range(1, k + 1)]\n                for i in range(k):\n                    base_sequence[i] += remainder // k\n                return base_sequence\n        \n        max_gcd -= 1\n    \n    return -1\n\n# Input reading\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "48": "```python\ndef kth_largest_in_multiplication_table(n, m, k):\n    low, high = 1, n * m\n\n    while low < high:\n        mid = (low + high) // 2\n        count = sum(min(mid // i, m) for i in range(1, n + 1))\n\n        if count < k:\n            low = mid + 1\n        else:\n            high = mid\n\n    return low\n\n# Read input\nn, m, k = map(int, input().split())\n# Get the k-th largest number in the multiplication table\nresult = kth_largest_in_multiplication_table(n, m, k)\n# Print the result\nprint(result)\n```",
    "47": "```python\ndef max_subarray_sum(arr):\n    max_ending_here = 0\n    max_so_far = 0\n    for x in arr:\n        max_ending_here = max(0, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\ndef max_beauty(n, x, a):\n    original_beauty = max_subarray_sum(a)\n    \n    max_increase = 0\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += a[j]\n            modified_sum = current_sum * x\n            left_sum = max_subarray_sum(a[:i])\n            right_sum = max_subarray_sum(a[j + 1:])\n            total_sum = left_sum + modified_sum + right_sum\n            max_increase = max(max_increase, total_sum)\n    \n    return max(original_beauty, max_increase)\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\nprint(max_beauty(n, x, a))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n    \n    # Determine the range in which the k-th digit resides\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n    \n    # Calculate the actual number containing the k-th digit\n    start += (k - 1) // length\n    num_str = str(start)\n    \n    # Return the specific digit from the number\n    return int(num_str[(k - 1) % length])\n\nk = int(input().strip())\nprint(find_kth_digit(k))\n```",
    "53": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nleft, right = 0, n - 1\nlast_taken = float('-inf')\nsequence = []\nmoves = []\n\nwhile left <= right:\n    if a[left] > last_taken and (a[right] <= last_taken or a[left] < a[right]):\n        sequence.append(a[left])\n        moves.append('L')\n        last_taken = a[left]\n        left += 1\n    elif a[right] > last_taken:\n        sequence.append(a[right])\n        moves.append('R')\n        last_taken = a[right]\n        right -= 1\n    else:\n        break\n\nprint(len(sequence))\nprint(''.join(moves))\n```",
    "51": "```python\nfrom collections import Counter\nfrom math import gcd\nfrom functools import reduce\n\nn = int(input())\ndivisors = list(map(int, input().split()))\n\n# Count the frequency of each divisor\ncount = Counter(divisors)\n\n# Find the maximum divisor, which should be x or y\nmax_divisor = max(count.keys())\n\n# To find x and y, we will iterate over the divisors and determine their possible pairs\n# We can calculate x and y by multiplying all unique divisors\nx = 1\ny = 1\n\n# Separate common and non-common divisors\nfor d in count:\n    if count[d] > 1:\n        # This is a common divisor, multiply it to both x and y\n        x *= d\n        y *= d\n    else:\n        # This is a non-common divisor, assign it to x or y based on their current products\n        if x < y:\n            x *= d\n        else:\n            y *= d\n\nprint(x, y)\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef reachable_count(n):\n    reachable = set()\n    current = n\n    \n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n        \n    return len(reachable)\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    print(reachable_count(n))\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_choose = m // 2\n    dp = [0] * k\n    \n    for row in matrix:\n        # Sort the row in descending order to maximize the sum\n        row.sort(reverse=True)\n        \n        # Temporary dp for the current row\n        current_dp = dp[:]  # Copy previous state\n        \n        # For each number in the row, consider selecting up to max_choose elements\n        for num in row[:max_choose]:\n            for j in range(k):\n                new_sum = current_dp[j] + num\n                new_remainder = new_sum % k\n                # Update the dp array to consider the new sum\n                dp[new_remainder] = max(dp[new_remainder], new_sum)\n    \n    return dp[0]\n\n# Read input\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nresult = max_sum_divisible_by_k(n, m, k, matrix)\nprint(result)\n```",
    "54": "```python\ndef minimum_D(n, a):\n    min_a = min(a)\n    max_a = max(a)\n    \n    if min_a == max_a:\n        return 0\n    \n    difference = max_a - min_a\n    if difference % 2 != 0:\n        return -1\n    \n    D = difference // 2\n    return D\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(minimum_D(n, a))\n```",
    "58": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nfrom collections import defaultdict\n\ncolor_map = defaultdict(list)\nfor index, value in enumerate(a):\n    color_map[value].append(index)\n\n# Check if any number appears more than k times\nif any(len(indices) > k for indices in color_map.values()):\n    print(\"NO\")\nelse:\n    color_assignment = [0] * n\n\n    for value, indices in color_map.items():\n        for i, index in enumerate(indices):\n            color_assignment[index] = (i % k) + 1  # Color from 1 to k\n\n    print(\"YES\")\n    print(\" \".join(map(str, color_assignment)))\n```",
    "59": "```python\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# Create target substring\ntarget = ['0'] * x\ntarget[y] = '1'\n\n# Count the number of operations needed\noperations = 0\nfor i in range(x):\n    if number[n - 1 - i] != target[i]:\n        operations += 1\n\nprint(operations)\n```",
    "33": "```python\ndef count_common_integers(a1, b1, a2, b2, L, R):\n    from math import gcd\n\n    def generate_ap(a, b, start, end):\n        if a == 0:\n            return [b] if start <= b <= end else []\n        \n        if a > 0:\n            first = (start - b + a - 1) // a\n            last = (end - b) // a\n        else:\n            first = (end - b) // a\n            last = (start - b + a - 1) // a\n\n        first_value = a * first + b\n        last_value = a * last + b\n        \n        if first_value > end or last_value < start:\n            return []\n        return list(range(first_value, last_value + a, a))\n\n    d = b2 - b1\n    a = a1\n    b = -a2\n\n    g = gcd(a, -b)\n    if d % g != 0:\n        print(0)\n        return\n\n    a //= g\n    b //= g\n    d //= g\n\n    def extended_gcd(a, b):\n        if b == 0:\n            return a, 1, 0\n        g, x1, y1 = extended_gcd(b, a % b)\n        return g, y1, x1 - (a // b) * y1\n\n    g, x0, y0 = extended_gcd(a, b)\n    x0 *= d\n    y0 *= d\n\n    k_min = (L - b1) // a1\n    k_max = (R - b1) // a1\n\n    t_min = (x0 - k_max * b) // a if b != 0 else (x0 // a)\n    t_max = (x0 - k_min * b) // a if b != 0 else (x0 // a)\n\n    t_start = (t_min + (b - 1)) // b if b > 0 else (t_min // b)\n    t_end = t_max // b\n\n    count = max(0, t_end - t_start + 1)\n    print(count)\n\n# Example input\ncount_common_integers(2, 0, 3, 3, 5, 21)\ncount_common_integers(2, 4, 3, 0, 6, 17)\n```",
    "60": "```python\ndef has_palindrome_subsequence(test_cases):\n    results = []\n    for n, a in test_cases:\n        found = False\n        last_seen = {}\n        for i in range(n):\n            if a[i] in last_seen:\n                if i - last_seen[a[i]] >= 2:\n                    found = True\n                    break\n            last_seen[a[i]] = i\n        results.append(\"YES\" if found else \"NO\")\n    return results\n\n# Reading input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Processing and printing results\nresults = has_palindrome_subsequence(test_cases)\nprint(\"\\n\".join(results))\n```",
    "63": "```python\ndef min_instability(n, a):\n    if n <= 1:\n        return 0  # Edge case: if there's 1 or fewer elements, instability is 0\n    \n    a.sort()\n    # Calculate the instability after removing the smallest or largest element\n    option1 = a[-1] - a[1]  # Remove the smallest element\n    option2 = a[-2] - a[0]  # Remove the largest element\n    return min(option1, option2)\n\nn = int(input().strip())\na = list(map(int, input().strip().split()))\nprint(min_instability(n, a))\n```",
    "65": "```python\ndef min_moves(n, m):\n    if m % n != 0:\n        return -1\n    \n    ratio = m // n\n    moves = 0\n    \n    while ratio > 1:\n        if ratio % 2 == 0:\n            ratio //= 2\n            moves += 1\n        elif ratio % 3 == 0:\n            ratio //= 3\n            moves += 1\n        else:\n            return -1\n    \n    return moves\n\nn, m = map(int, input().split())\nprint(min_moves(n, m))\n```",
    "66": "```python\ndef minimum_length_string(n, k, t):\n    # Find the longest suffix of `t` that is also a prefix\n    overlap_length = 0\n    for i in range(1, n):\n        if t.startswith(t[i:]):\n            overlap_length = n - i\n            break\n    \n    # Construct the result string\n    result = t + (t[overlap_length:] * (k - 1))\n    return result\n\n# Input reading\nn, k = map(int, input().split())\nt = input().strip()\n\n# Output the result\nprint(minimum_length_string(n, k, t))\n```",
    "67": "```python\nn = int(input())\na = list(map(int, input().split()))\n\ntotal_sum = sum(a)\nnice_indices = []\n\nfor j in range(n):\n    remaining_sum = total_sum - a[j]\n    if remaining_sum == a[j]:\n        nice_indices.append(j + 1)\n\nprint(len(nice_indices))\nif nice_indices:\n    print(\" \".join(map(str, nice_indices)))\n```",
    "61": "```python\ndef maximum_number_after_operation(n, a, f):\n    # Convert f to a list of integers for easier indexing\n    f = [0] + f  # f[0] is not used, f[1] corresponds to index 1\n    \n    # Create a list to hold the result\n    result = list(a)\n    \n    # Flag to check if we've started replacing\n    replacing = False\n    \n    for i in range(n):\n        original_digit = int(a[i])\n        new_digit = f[original_digit]\n        \n        # Start replacing when we find a digit that can be replaced\n        if new_digit > original_digit:\n            replacing = True\n            result[i] = str(new_digit)\n        elif new_digit < original_digit and replacing:\n            # If we are replacing and found a digit where replacement doesn't enhance, stop\n            break\n        elif replacing:\n            # Continue replacing if we are already in a replacement phase\n            result[i] = str(new_digit)\n    \n    # Join the result and return the maximum number as a string\n    return ''.join(result)\n\n# Read input\nn = int(input())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\n# Get the maximum number possible after the operation\nmax_number = maximum_number_after_operation(n, a, f)\n\n# Print the result\nprint(max_number)\n```",
    "64": "```python\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Prepare the schedule\nschedule = [0] * n  # Initialize all days with rest (0)\nexam_days = set()   # Store exam days\n\n# Mark the exam days in the schedule\nfor i in range(m):\n    s_i, d_i, c_i = exams[i]\n    schedule[d_i - 1] = m + 1  # Mark the exam day (1-indexed)\n    exam_days.add(d_i)\n\n# Prepare for each exam\nfor i in range(m):\n    s_i, d_i, c_i = exams[i]\n    prepared_days = 0\n\n    # Try to allocate preparation days\n    for day in range(s_i - 1, d_i - 1):\n        if prepared_days < c_i and schedule[day] == 0:  # If it's a rest day\n            schedule[day] = i + 1  # Mark preparation for exam i\n            prepared_days += 1\n\n    if prepared_days < c_i:  # Not enough preparation days\n        print(-1)\n        exit()\n\n# Check if all exams can be passed\nfor i in range(m):\n    if schedule[exams[i][1] - 1] != m + 1:  # Ensure exam day is marked\n        print(-1)\n        exit()\n\nprint(' '.join(map(str, schedule)))\n```",
    "50": "```python\nfrom collections import defaultdict, deque\nimport sys\n\ndef bfs(start):\n    visited = [-1] * (n + 1)\n    queue = deque([start])\n    visited[start] = 0\n    farthest_node = start\n    max_distance = 0\n    \n    while queue:\n        node = queue.popleft()\n        \n        for neighbor in graph[node]:\n            if visited[neighbor] == -1:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                \n                if visited[neighbor] > max_distance:\n                    max_distance = visited[neighbor]\n                    farthest_node = neighbor\n                    \n    return farthest_node, max_distance\n\ndef find_three_nodes():\n    # Step 1: Find a farthest node from an arbitrary node (node 1)\n    farthest_from_start, _ = bfs(1)\n    \n    # Step 2: Find the farthest node from that farthest node (this gives us one endpoint of the diameter)\n    farthest_from_a, diameter_length = bfs(farthest_from_start)\n    \n    # Step 3: The other endpoint of the diameter\n    farthest_from_b, _ = bfs(farthest_from_a)\n    \n    # Now we need to find the third node that maximizes the edges\n    # We can use BFS from one of the endpoints to get the nodes along the diameter path\n    path_nodes = []\n    queue = deque([farthest_from_start])\n    parent = {farthest_from_start: None}\n    \n    while queue:\n        node = queue.popleft()\n        path_nodes.append(node)\n        \n        for neighbor in graph[node]:\n            if neighbor not in parent:\n                parent[neighbor] = node\n                queue.append(neighbor)\n    \n    # Reconstruct the path from farthest_from_start to farthest_from_b\n    diameter_path = []\n    current = farthest_from_b\n    while current is not None:\n        diameter_path.append(current)\n        current = parent[current]\n    \n    diameter_path.reverse()\n    \n    # Choose three nodes: two endpoints of the diameter and one additional node\n    if len(diameter_path) > 2:\n        third_node = diameter_path[len(diameter_path) // 2]\n    else:\n        third_node = diameter_path[0]  # In case of very small diameter\n    \n    return diameter_length + 1, farthest_from_start, third_node, farthest_from_b\n\nn = int(sys.stdin.readline().strip())\ngraph = defaultdict(list)\n\nfor _ in range(n - 1):\n    a, b = map(int, sys.stdin.readline().strip().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\nmax_edges, a, b, c = find_three_nodes()\nprint(max_edges)\nprint(a, b, c)\n```",
    "57": "```python\ndef fill_gifts(n, f):\n    # Determine the set of givers and receivers\n    givers = set(range(1, n + 1)) - set(f[i] for i in range(n) if f[i] != 0)\n    receivers = [i + 1 for i in range(n) if f[i] == 0]\n\n    # Create a mapping of known gift givers\n    gift_map = {i + 1: f[i] for i in range(n) if f[i] != 0}\n\n    # Fill in the undecided gifts\n    undecided_givers = list(givers)\n    idx = 0\n\n    for i in range(n):\n        if f[i] == 0:\n            # Find a receiver who is not the current giver\n            while idx < len(undecided_givers) and undecided_givers[idx] == (i + 1):\n                idx += 1\n                \n            if idx < len(undecided_givers):\n                f[i] = undecided_givers[idx]\n                idx += 1\n            \n    return f\n\n# Input reading\nn = int(input())\nf = list(map(int, input().split()))\n\n# Fill gifts and output the result\nresult = fill_gifts(n, f)\nprint(\" \".join(map(str, result)))\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        min_ops = float('inf')\n        best_triple = (0, 0, 0)\n\n        # Iterate over possible values for A from 1 up to a + 5\n        for A in range(1, a + 6):\n            # B should be a multiple of A, calculate the closest multiples\n            B1 = (b // A) * A\n            B2 = B1 + A\n            \n            for B in (B1, B2):\n                if B < A: continue  # B must be >= A\n                # C should be a multiple of B\n                C1 = (c // B) * B\n                C2 = C1 + B\n                \n                for C in (C1, C2):\n                    if C < B: continue  # C must be >= B\n                    \n                    # Calculate the total operations needed\n                    ops = abs(A - a) + abs(B - b) + abs(C - c)\n                    if ops < min_ops:\n                        min_ops = ops\n                        best_triple = (A, B, C)\n\n        results.append((min_ops, best_triple))\n\n    return results\n\n\n# Input reading and output\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\nresults = min_operations(t, test_cases)\n\nfor res in results:\n    min_ops, (A, B, C) = res\n    print(min_ops)\n    print(A, B, C)\n```",
    "71": "```python\ndef count_set_bits(n):\n    return bin(n).count('1')\n\nif __name__ == \"__main__\":\n    a = int(input(\"Enter an integer between 1 and 64: \"))\n    if 1 <= a <= 64:\n        print(count_set_bits(a))\n    else:\n        print(\"Input must be between 1 and 64.\")\n```",
    "55": "```python\ndef is_visible(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n    # Check if any part of the white sheet is visible by checking the four edges and corners\n    # A point is visible if it's not inside the white sheet and not inside both black sheets\n\n    # Check edges and corners of the white sheet\n    visible = (\n        (x1 - 1 < x3 or x1 - 1 < x5 or x2 + 1 > x4 or x2 + 1 > x6 or \n         y1 - 1 < y3 or y1 - 1 < y5 or y2 + 1 > y4 or y2 + 1 > y6)\n    )\n\n    # Check if any part of the white sheet is not covered by black sheets\n    def is_inside_black(wx, wy):\n        return (x3 < wx < x4 and y3 < wy < y4) or (x5 < wx < x6 and y5 < wy < y6)\n\n    # Check corners of the white sheet\n    white_corners = [(x1, y1), (x1, y2), (x2, y1), (x2, y2)]\n    \n    for wx, wy in white_corners:\n        if not is_inside_black(wx, wy):\n            return \"YES\"\n\n    # Check edges of the white sheet\n    white_edges_x = [x1 - 1, x2, x1, x2 + 1]\n    white_edges_y = [y1 - 1, y2, y1, y2 + 1]\n\n    for wx in white_edges_x:\n        for wy in [y1, y2]:\n            if not is_inside_black(wx, wy):\n                return \"YES\"\n\n    for wy in white_edges_y:\n        for wx in [x1, x2]:\n            if not is_inside_black(wx, wy):\n                return \"YES\"\n\n    return \"NO\"\n\n\n# Input\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Output\nprint(is_visible(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6))\n```",
    "70": "```python\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Convert start and end times to total minutes\nstart_minutes = h1 * 60 + m1\nend_minutes = h2 * 60 + m2\n\n# Calculate the midpoint in total minutes\nmidpoint_minutes = (start_minutes + end_minutes) // 2\n\n# Convert the midpoint back to hours and minutes\nh3 = midpoint_minutes // 60\nm3 = midpoint_minutes % 60\n\n# Print the result in the required format\nprint(f\"{h3:02}:{m3:02}\")\n```",
    "73": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmax_height = max(a)\n\n# Check for gaps\nfor height in a:\n    if height < max_height and (height + 1) not in a:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")\n```",
    "77": "```python\ndef minimum_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nn = int(input().strip())\nprint(minimum_difference(n))\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    unique_subsequences = set()\n    \n    # Generate all possible subsequences\n    from itertools import combinations\n    for length in range(n + 1):\n        for indices in combinations(range(n), length):\n            subseq = ''.join(s[i] for i in indices)\n            unique_subsequences.add(subseq)\n    \n    # If we cannot obtain k unique subsequences\n    if len(unique_subsequences) < k:\n        return -1\n\n    # Calculate costs of subsequences\n    costs = [n - len(subseq) for subseq in unique_subsequences]\n    \n    # Sort costs and take the minimum k costs\n    costs.sort()\n    return sum(costs[:k])\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "80": "```python\nn = int(input())\ns = input()\n\n# Create a list to store colors for each character in the string\ncolors = [0] * n\ncolor_count = 0\n\n# A dictionary to track the last used color for each character\nlast_color = {}\n\n# Iterate through the string and assign colors\nfor i in range(n):\n    char = s[i]\n    # If the character has been seen before, use the last assigned color\n    if char in last_color:\n        colors[i] = last_color[char]\n    else:\n        # Assign a new color\n        color_count += 1\n        last_color[char] = color_count\n        colors[i] = color_count\n\n# Output the results\nprint(color_count)\nprint(' '.join(map(str, colors)))\n```",
    "81": "```python\ndef can_reorder_strings(n, strings):\n    # Sort the strings by their lengths\n    strings.sort(key=len)\n\n    # Check if the ordering works\n    for i in range(1, n):\n        if strings[i-1] not in strings[i]:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    for string in strings:\n        print(string)\n\n# Read input\nn = int(input().strip())\nstrings = [input().strip() for _ in range(n)]\n\n# Process and print the result\ncan_reorder_strings(n, strings)\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Check if we can satisfy the degree condition for vertex 1\n    if len(graph[1]) < D:\n        print(\"NO\")\n        return\n\n    # Prepare to store the spanning tree edges\n    spanning_tree = []\n    visited = [False] * (n + 1)\n    visited[1] = True\n\n    # Start BFS from vertex 1\n    queue = deque([1])\n    \n    # Add edges from vertex 1 to its neighbors until we reach degree D\n    degree_count = 0\n    for neighbor in graph[1]:\n        if degree_count < D:\n            spanning_tree.append((1, neighbor))\n            visited[neighbor] = True\n            degree_count += 1\n            queue.append(neighbor)\n\n    # Now perform BFS/DFS to add remaining edges\n    while queue and degree_count < D:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                spanning_tree.append((current, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                if len(spanning_tree) == n - 1:  # Stop if we have enough edges\n                    break\n\n    # Add additional edges for vertex 1 to ensure its degree is D\n    if degree_count < D:\n        for neighbor in graph[1]:\n            if degree_count < D and visited[neighbor]:\n                continue\n            if degree_count < D:\n                spanning_tree.append((1, neighbor))\n                degree_count += 1\n                if degree_count == D:\n                    break\n\n    # Check if we have formed a spanning tree\n    if len(spanning_tree) == n - 1 and degree_count == D:\n        print(\"YES\")\n        for u, v in spanning_tree:\n            print(u, v)\n    else:\n        print(\"NO\")\n\n# Read input\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nfind_spanning_tree(n, m, D, edges)\n```",
    "72": "```python\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Create lists to store the left and right endpoints\nlefts = [l for l, r in segments]\nrights = [r for l, r in segments]\n\n# Precompute the max left and min right while excluding each segment\nmax_left = [0] * n\nmin_right = [0] * n\n\n# Fill max_left\nmax_left[0] = lefts[0]\nfor i in range(1, n):\n    max_left[i] = max(max_left[i-1], lefts[i])\n\n# Fill min_right\nmin_right[n-1] = rights[n-1]\nfor i in range(n-2, -1, -1):\n    min_right[i] = min(min_right[i+1], rights[i])\n\n# Now calculate max intersection length when excluding each segment\nmax_length = 0\nfor i in range(n):\n    if i == 0:\n        current_left = max_left[1]\n        current_right = min_right[1]\n    elif i == n-1:\n        current_left = max_left[n-2]\n        current_right = min_right[n-2]\n    else:\n        current_left = max(max_left[i-1], lefts[i+1])\n        current_right = min(min_right[i+1], rights[i-1])\n    \n    max_length = max(max_length, max(0, current_right - current_left))\n\nprint(max_length)\n```",
    "76": "```python\ndef can_construct_symmetric_square(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:  # m must be even for a symmetric square\n            results.append(\"NO\")\n            continue\n        \n        # Check for valid pairs\n        valid_pairs = set()\n        for tile in tiles:\n            top_left, top_right = tile[0]\n            bottom_left, bottom_right = tile[1]\n            valid_pairs.add((top_right, bottom_left))  # This must match for symmetry\n        \n        # We need at least one tile that can form a symmetric pair\n        found_symmetric_pair = False\n        for tile in tiles:\n            top_left, top_right = tile[0]\n            bottom_left, bottom_right = tile[1]\n            if (top_left, bottom_right) in valid_pairs:\n                found_symmetric_pair = True\n                break\n        \n        results.append(\"YES\" if found_symmetric_pair else \"NO\")\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for __ in range(n):\n        tile_top = list(map(int, input().split()))\n        tile_bottom = list(map(int, input().split()))\n        tiles.append((tile_top, tile_bottom))\n    test_cases.append((n, m, tiles))\n\n# Get results\nresults = can_construct_symmetric_square(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "85": "```python\ndef find_price(A, B):\n    for price in range(1, 10000):\n        tax_8 = int(price * 0.08)\n        tax_10 = int(price * 0.10)\n        if tax_8 == A and tax_10 == B:\n            return price\n    return -1\n\nA, B = map(int, input().split())\nresult = find_price(A, B)\nprint(result)\n```",
    "78": "```python\nMOD = 10**9 + 7\n\ndef count_regular_sequences(n, s):\n    len_s = len(s)\n    \n    # Precompute the number of ways to form regular bracket sequences of length 2k\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for k in range(1, n + 1):\n        for j in range(k):\n            dp[k] = (dp[k] + dp[j] * dp[k - 1 - j]) % MOD\n            \n    total_regular_sequences = dp[n]\n    \n    # Check how many open and close brackets are in s\n    open_s = s.count('(')\n    close_s = s.count(')')\n    \n    # If s has more close brackets than open brackets, it's impossible\n    if open_s < close_s or open_s > n or close_s > n:\n        return 0\n    \n    # We need to find valid placements for s in the regular sequence\n    valid_count = 0\n    \n    for start in range(n - (len_s - 1) + 1):\n        open_before = start\n        close_before = (n - 1) - (len_s - 1 - open_s) - start\n        \n        # Check if it is valid to insert s here\n        if open_before < close_before:\n            continue\n        \n        # Total remaining open and close brackets\n        remaining_open = n - open_s\n        remaining_close = n - close_s\n        \n        # Valid placements count\n        if remaining_open >= remaining_close:\n            valid_count += dp[remaining_open]\n            valid_count %= MOD\n            \n    return valid_count\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Calculate the result\nresult = count_regular_sequences(n, s)\n\n# Output the result\nprint(result)\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import Counter\n\n    # Count the frequency of each character in the string\n    freq = Counter(s)\n    \n    # Calculate the total number of unique subsequences and their costs\n    total_cost = 0\n    unique_subsequences = 0\n    \n    for count in sorted(freq.values(), reverse=True):\n        # Calculate unique subsequences contributed by this character\n        current_subsequences = 0\n        \n        for length in range(1, count + 1):\n            num_subsequences = 1 << (count - length)  # 2^(count-length)\n            current_subsequences += num_subsequences\n            total_cost += (n - length) * num_subsequences  # cost for this length\n            \n            if current_subsequences >= k:\n                break\n        \n        unique_subsequences += current_subsequences\n        \n        if unique_subsequences >= k:\n            break\n\n    if unique_subsequences < k:\n        return -1  # Impossible to obtain k unique subsequences\n\n    # Now we need to find the minimum cost to obtain exactly k unique subsequences\n    remaining_k = k\n    current_cost = 0\n    \n    for count in sorted(freq.values(), reverse=True):\n        for length in range(1, count + 1):\n            num_subsequences = 1 << (count - length)  # Number of subsequences of this length\n            \n            if remaining_k <= num_subsequences:\n                current_cost += (n - length) * remaining_k\n                return current_cost\n            \n            current_cost += (n - length) * num_subsequences\n            remaining_k -= num_subsequences\n            \n            if remaining_k <= 0:\n                break\n\n    return current_cost\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "82": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nsolved = 0\n\n# Solve from the left\nwhile solved < n and a[solved] <= k:\n    solved += 1\n\n# Solve from the right\nwhile solved < n and a[n - 1 - (solved - 1)] <= k:\n    solved += 1\n\n# Adjust if both ends contributed to the solved count\nif solved > n:\n    solved = n\n\nprint(solved)\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    min_moves = float('inf')\n\n    # Check for pairs '00', '25', '50', '75'\n    targets = ['00', '25', '50', '75']\n\n    for target in targets:\n        last_digit = target[1]\n        second_last_digit = target[0]\n        \n        # We need to find last_digit first, then second_last_digit\n        last_digit_index = -1\n        for i in range(length - 1, -1, -1):\n            if s[i] == last_digit:\n                last_digit_index = i\n                # Look for second_last_digit to the left of last_digit\n                for j in range(last_digit_index - 1, -1, -1):\n                    if s[j] == second_last_digit:\n                        # Calculate moves: (last_digit_index - j) + (length - 1 - last_digit_index)\n                        moves = (last_digit_index - j) + (length - 1 - last_digit_index)\n                        min_moves = min(min_moves, moves)\n                        break  # Found a valid pair, no need to search further for this last_digit\n                break  # Move to the next target after finding the last_digit\n\n    return min_moves if min_moves != float('inf') else -1\n\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Define the food consumption pattern for a week\n    week_pattern = [0, 1, 2, 0, 1, 2, 0]  # 0: fish, 1: rabbit, 2: chicken\n    food_count = [a, b, c]\n    \n    def days_from_starting_day(start):\n        food_available = food_count[:]\n        days = 0\n        \n        # Consume food for the first week based on the starting day\n        for i in range(7):\n            day = (start + i) % 7\n            if food_available[week_pattern[day]] > 0:\n                food_available[week_pattern[day]] -= 1\n                days += 1\n            else:\n                break\n        \n        # Calculate how many full weeks can be sustained with the remaining food\n        full_weeks = min(food_available[0] // 3, food_available[1] // 2, food_available[2] // 1)\n        days += full_weeks * 7\n        \n        # Update remaining food after full weeks\n        food_available[0] -= full_weeks * 3\n        food_available[1] -= full_weeks * 2\n        food_available[2] -= full_weeks * 1\n        \n        # Continue to consume food with the remaining supplies\n        while True:\n            day = (start + days) % 7\n            if food_available[week_pattern[day]] > 0:\n                food_available[week_pattern[day]] -= 1\n                days += 1\n            else:\n                break\n        \n        return days\n\n    max_days_count = 0\n    for start_day in range(7):\n        max_days_count = max(max_days_count, days_from_starting_day(start_day))\n    \n    return max_days_count\n\n# Input\na, b, c = map(int, input().split())\nprint(max_days(a, b, c))\n```",
    "84": "```python\ndef can_color_string(n, s):\n    # Create a list to keep track of the frequency of each character\n    freq = [0] * 26\n    for char in s:\n        freq[ord(char) - ord('a')] += 1\n        \n    # Check if any character occurs more than twice\n    if any(count > 2 for count in freq):\n        print(\"NO\")\n        return\n    \n    # Create the coloring based on the character positions\n    color = ['0'] * n\n    current_color = 0\n    last_char = None\n    \n    for i in range(n):\n        if last_char is None or s[i] != last_char:\n            current_color = 1 - current_color  # Alternate colors\n        color[i] = str(current_color)\n        last_char = s[i]\n    \n    print(\"YES\")\n    print(\"\".join(color))\n\n# Read input\nn = int(input())\ns = input().strip()\ncan_color_string(n, s)\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total = a + b\n    min_perimeter = float('inf')\n\n    for width in range(1, int(total**0.5) + 1):\n        if total % width == 0:\n            length = total // width\n            \n            # Check for red rectangle\n            for red_width in range(1, int(a**0.5) + 1):\n                if a % red_width == 0:\n                    red_length = a // red_width\n                    if red_width <= width and red_length <= length:\n                        # Check for blue rectangle\n                        for blue_width in range(1, int(b**0.5) + 1):\n                            if b % blue_width == 0:\n                                blue_length = b // blue_width\n                                if blue_width <= width and blue_length <= length:\n                                    perimeter = 2 * (width + length)\n                                    min_perimeter = min(min_perimeter, perimeter)\n    \n    return min_perimeter\n\na, b = map(int, input().split())\nprint(minimal_perimeter(a, b))\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    projects.sort(key=lambda x: (x[0], -x[1]))  # Sort projects by required rating, then by rating change descending\n    completed = 0\n    \n    while True:\n        progress = False\n        for i in range(len(projects)):\n            a, b = projects[i]\n            if a <= r:  # If current rating is enough to start the project\n                if r + b >= 0:  # After completing the project, rating must not drop below zero\n                    r += b\n                    completed += 1\n                    projects[i] = (float('inf'), 0)  # Mark project as completed\n                    progress = True\n        if not progress:  # No more projects can be completed\n            break\n            \n    return completed\n\n# Input reading section\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_projects(n, r, projects))\n```",
    "86": "```python\ndef solve_problems(n, k):\n    # Minimum sum of first k increasing numbers: 1 + 2 + ... + k\n    min_sum = k * (k + 1) // 2\n    # Maximum sum if we double each day: 1 + 2 + ... + k\n    # The maximum achievable sum is when we double each previous day's problems\n    max_sum = sum(2**i for i in range(k))\n\n    if n < min_sum or n > max_sum:\n        print(\"NO\")\n        return\n    \n    # Start with the minimum array\n    a = list(range(1, k + 1))\n    current_sum = min_sum\n    \n    # Adjust the last day to fit the requirements\n    for i in range(k - 1, -1, -1):\n        while current_sum < n and a[i] < 2 * (a[i - 1] if i > 0 else 0) and current_sum + 1 <= n:\n            current_sum += 1\n            a[i] += 1\n        \n    print(\"YES\")\n    print(\" \".join(map(str, a)))\n\n# Example usage:\nn, k = map(int, input().split())\nsolve_problems(n, k)\n```",
    "90": "```python\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculate the minimum required position to reach the last cell (n + 1)\nrequired_length = sum(c) + (m - 1)  # platforms + gaps\n\nif required_length > n:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    a = [0] * n\n    current_position = 0\n    \n    for i in range(m):\n        # Place the platform\n        for j in range(c[i]):\n            a[current_position] = i + 1  # platform index is 1-based\n            current_position += 1\n        # Add gap only if this is not the last platform\n        if i < m - 1:\n            current_position += 1  # gap between platforms\n\n    print(\" \".join(map(str, a)))\n```",
    "92": "```python\nx = float(input().strip())\n\n# We will find two integers a and b such that 1 <= a, b <= 10 and a * b / (a + b) = x\n# This is equivalent to finding integers a and b such that a * b = x * (a + b)\n\nfor a in range(1, 11):\n    for b in range(1, 11):\n        if abs(a * b / (a + b) - x) < 1e-6:\n            print(a, b)\n            exit()  # Use exit to stop the program after finding the first solution\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects by their required rating, secondary sort by rating change\n    projects.sort(key=lambda x: (x[0], -x[1]))\n\n    for a, b in projects:\n        if r < a:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n\n    return \"YES\"\n\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\nprint(can_complete_projects(n, r, projects))\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1 or (d == 1 and n > 2) or (n > 1 and d == 0):\n        print(\"NO\")\n        return\n\n    edges = []\n    \n    # Create the main path for the diameter\n    for i in range(1, d + 2):\n        edges.append((i, i + 1))\n    \n    current_vertex = d + 2\n    # Add branches to the path\n    for i in range(1, d + 2):\n        for _ in range(k - 1):\n            if current_vertex <= n:\n                edges.append((i, current_vertex))\n                current_vertex += 1\n            else:\n                break\n        if current_vertex > n:\n            break\n    \n    if current_vertex <= n:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for u, v in edges:\n            print(u, v)\n\n# Read input\nn, d, k = map(int, input().split())\nconstruct_tree(n, d, k)\n```",
    "97": "```python\nn = int(input())\nchips = list(map(int, input().split()))\n\neven_count = sum(1 for x in chips if x % 2 == 0)\nodd_count = n - even_count\n\n# The minimum cost is the smaller of moving all to an even position or moving all to an odd position\nprint(min(even_count, odd_count))\n```",
    "98": "```python\ndef min_moves_to_reach_n(N):\n    moves = float('inf')\n    \n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            moves = min(moves, i + j - 2)\n\n    return moves\n\nN = int(input())\nprint(min_moves_to_reach_n(N))\n```",
    "96": "```python\nn = int(input())\nq = list(map(int, input().split()))\n\n# Initialize the permutation array\np = [0] * n\n\n# Calculate p based on q\nfor i in range(1, n):\n    p[i] = p[i - 1] + q[i - 1]\n\n# Find the minimum value in p\nmin_p = min(p)\n\n# Adjust the array to make the smallest element 1\nadjustment = 1 - min_p\nfor i in range(n):\n    p[i] += adjustment\n\n# Check if the permutation is valid\nif len(set(p)) == n and all(1 <= x <= n for x in p):\n    print(' '.join(map(str, p)))\nelse:\n    print(-1)\n```",
    "99": "```python\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\n# Maximum wins for Alice\nmax_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n\n# Minimum wins for Alice\n# Calculate losses for Alice\nalice_losses = max(0, b1 - a3) + max(0, b2 - a1) + max(0, b3 - a2)\nmin_wins = n - alice_losses\n\nprint(min_wins, max_wins)\n```",
    "88": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nfrom collections import Counter\n\ncounter = Counter(a)\nmatrix = [[0] * n for _ in range(n)]\n\n# Count how many numbers can fit into the palindrome structure\nodd_count = 0\neven_pairs = []\nfor num, count in counter.items():\n    if count % 2 == 1:\n        odd_count += 1\n    even_pairs.append(count // 2)\n\n# For odd n, we can have one odd count; for even n, we can't have any\nif (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n    print(\"NO\")\nelse:\n    # Prepare half of the matrix and the center element if needed\n    half = []\n    center_element = None\n    \n    for num, count in counter.items():\n        half.extend([num] * (count // 2))\n        if count % 2 == 1:\n            center_element = num\n\n    # Fill the matrix\n    index = 0\n    for i in range(n):\n        for j in range(n):\n            if i < n // 2:  # Fill top half\n                matrix[i][j] = half[index]\n                matrix[n - i - 1][n - j - 1] = half[index]\n                if j < n // 2:\n                    index += 1\n            \n            elif i == n // 2 and n % 2 == 1:  # Fill the center row\n                if j == n // 2:\n                    matrix[i][j] = center_element\n            \n            else:  # Fill bottom half\n                matrix[i][j] = matrix[n - i - 1][n - j - 1]\n\n    print(\"YES\")\n    for row in matrix:\n        print(\" \".join(map(str, row)))\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n    \n    # Create arrays to store the position of match for t in s\n    left = [-1] * m\n    right = [-1] * m\n    \n    # Fill the left array\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n            \n    # Fill the right array\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n    \n    # Calculate the maximum removable substring length\n    max_length = 0\n    \n    for i in range(m - 1):\n        if left[i] != -1 and right[i + 1] != -1:\n            max_length = max(max_length, right[i + 1] - left[i] - 1)\n    \n    # Also consider removing from the start or the end\n    max_length = max(max_length, right[0] + 1)  # remove from the start\n    max_length = max(max_length, n - left[m - 1] - 1)  # remove from the end\n    \n    return max_length\n\n# Input reading\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(max_removable_length(s, t))\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Check for impossible cases\n    if (s[0] == t[0] or s[1] == t[1]) and (s[0] == s[1] or t[0] == t[1]):\n        return \"NO\"\n    \n    # Initialize counts for 'a', 'b', and 'c'\n    count = {'a': n, 'b': n, 'c': n}\n    \n    # Start building the result string\n    result = []\n    \n    # Function to append a character while ensuring no invalid substrings\n    def append_char():\n        for char in 'abc':\n            if count[char] > 0:\n                # Check the last two characters in the result to avoid forbidden substrings\n                if len(result) < 2 or result[-1] != char or result[-2] != char:\n                    return char\n        return None\n    \n    # Construct the result string\n    for _ in range(3 * n):\n        char = append_char()\n        if char is None:\n            return \"NO\"\n        result.append(char)\n        count[char] -= 1\n    \n    # Final check for forbidden substrings\n    for i in range(len(result) - 1):\n        if ''.join(result[i:i+2]) == s or ''.join(result[i:i+2]) == t:\n            return \"NO\"\n    \n    return \"YES\", ''.join(result)\n\nn = int(input())\ns = input().strip()\nt = input().strip()\n\nresult = generate_string(n, s, t)\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    print(result[1])\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    result = []\n    \n    # Determine the starting character\n    if x % 2 == 0:\n        start_with_zero = True\n    else:\n        start_with_zero = False\n    \n    # Initialize the result based on starting character\n    if start_with_zero:\n        if a > 0:\n            result.append('0')\n            a -= 1\n        else:\n            result.append('1')\n            b -= 1\n    else:\n        if b > 0:\n            result.append('1')\n            b -= 1\n        else:\n            result.append('0')\n            a -= 1\n\n    # Alternate between 0 and 1 for x transitions\n    for _ in range(x):\n        if result[-1] == '0' and b > 0:\n            result.append('1')\n            b -= 1\n        elif result[-1] == '1' and a > 0:\n            result.append('0')\n            a -= 1\n            \n    # Fill the rest with the last character\n    last_char = result[-1]\n    while a > 0 or b > 0:\n        if last_char == '0' and b > 0:\n            result.append('1')\n            b -= 1\n            last_char = '1'\n        elif last_char == '1' and a > 0:\n            result.append('0')\n            a -= 1\n            last_char = '0'\n\n    return ''.join(result)\n\n# Read input values\na, b, x = map(int, input().split())\n# Print the result\nprint(construct_binary_string(a, b, x))\n```"
}