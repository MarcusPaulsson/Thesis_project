{
    "2": "```python\nn = int(input())\n\ndef is_lucky(year):\n    # Count non-zero digits\n    non_zero_count = sum(1 for digit in str(year) if digit != '0')\n    return non_zero_count <= 1\n\nnext_year = n + 1\nwhile not is_lucky(next_year):\n    next_year += 1\n\nprint(next_year - n)\n```",
    "7": "```python\ndef find_empty_day(n, m):\n    grains = n\n    day = 1\n    \n    while True:\n        # Add grains to the barn\n        grains += m\n        if grains > n:\n            grains = n\n        \n        # Sparrows eat grains\n        grains -= day\n        if grains <= 0:\n            return day\n        \n        day += 1\n\n# Input\nn, m = map(int, input().split())\nprint(find_empty_day(n, m))\n```",
    "4": "```python\ndef is_lucky(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef time_before(hh, mm, minutes):\n    total_minutes = (hh * 60 + mm - minutes) % (24 * 60)\n    return divmod(total_minutes, 60)\n\ndef min_snoozes(x, hh, mm):\n    y = 0\n    while not is_lucky(*time_before(hh, mm, x * y)):\n        y += 1\n    return y\n\nx = int(input().strip())\nhh, mm = map(int, input().strip().split())\n\nprint(min_snoozes(x, hh, mm))\n```",
    "10": "```python\nn = int(input())\n\n# Calculate maximum days off\nmax_days_off = (n // 7) * 2 + min(2, n % 7)\n\n# Calculate minimum days off\nif n < 5:\n    min_days_off = 0\nelse:\n    min_days_off = (n // 7) * 2 + (1 if n % 7 >= 1 else 0)\n\nprint(min_days_off, max_days_off)\n```",
    "1": "```python\ndef sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef max_sum_digit_number(x):\n    s = str(x)\n    n = len(s)\n    \n    max_number = x\n    max_digit_sum = sum_of_digits(x)\n\n    for i in range(n):\n        if s[i] != '0':\n            new_number = list(s)\n            new_number[i] = str(int(s[i]) - 1)\n            new_number[i + 1:] = '9' * (n - i - 1)\n            new_number = int(''.join(new_number))\n            \n            if new_number > 0 and new_number <= x:\n                current_digit_sum = sum_of_digits(new_number)\n                if (current_digit_sum > max_digit_sum) or (current_digit_sum == max_digit_sum and new_number > max_number):\n                    max_number = new_number\n                    max_digit_sum = current_digit_sum\n\n    return max_number\n\nx = int(input().strip())\nprint(max_sum_digit_number(x))\n```",
    "5": "```python\ndef min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0  # No tabs to close\n\n    seconds = 0\n\n    # Adjust the cursor position if it's outside the range [l, r]\n    if pos < l:\n        seconds += (l - pos)  # Move right to l\n        pos = l\n    elif pos > r:\n        seconds += (pos - r)  # Move left to r\n        pos = r\n\n    # Now pos is in the range [l, r]\n    # Close tabs to the left if needed\n    if l > 1:\n        seconds += (l - 1)  # Close all tabs to the left of l\n\n    # Close tabs to the right if needed\n    if r < n:\n        seconds += (n - r)  # Close all tabs to the right of r\n\n    return seconds\n\n# Read input\nn, pos, l, r = map(int, input().split())\n# Get the result and print it\nprint(min_seconds_to_close_tabs(n, pos, l, r))\n```",
    "8": "```python\ndef min_draws_to_win(tiles):\n    # Convert tiles to a more manageable format\n    counts = {}\n    suits = {'m': [], 'p': [], 's': []}\n    \n    for tile in tiles:\n        number = int(tile[0])\n        suit = tile[1]\n        counts[tile] = counts.get(tile, 0) + 1\n        suits[suit].append(number)\n    \n    # Check for koutsu (triplet)\n    if any(count == 3 for count in counts.values()):\n        return 0  # Already have a koutsu\n\n    # Sort numbers for each suit\n    for suit in suits:\n        suits[suit].sort()\n\n    # Check for existing shuntsu\n    for suit in suits:\n        for i in range(len(suits[suit]) - 2):\n            if suits[suit][i] + 1 == suits[suit][i + 1] and suits[suit][i + 1] + 1 == suits[suit][i + 2]:\n                return 0  # Already have a shuntsu\n\n    # Check if we can form a shuntsu by drawing 1 tile\n    for suit in suits:\n        for number in suits[suit]:\n            # Check if we can complete a sequence\n            if number - 1 >= 1 and (number - 1) not in suits[suit]:  # Need number - 1\n                return 1\n            if number + 1 <= 9 and (number + 1) not in suits[suit]:  # Need number + 1\n                return 1\n\n    # No tile can create a shuntsu, we must draw 2 tiles\n    return 2\n\ntiles = input().split()\nprint(min_draws_to_win(tiles))\n```",
    "0": "```python\ndef max_accordion_length(s):\n    # Initialize positions for the required characters\n    left_bracket_pos = s.find('[')\n    first_colon_pos = s.find(':', left_bracket_pos + 1)\n    second_colon_pos = s.find(':', first_colon_pos + 1)\n    right_bracket_pos = s.find(']', second_colon_pos + 1)\n\n    # Check if all required characters were found in the correct order\n    if left_bracket_pos == -1 or first_colon_pos == -1 or second_colon_pos == -1 or right_bracket_pos == -1:\n        return -1\n\n    # Calculate the number of vertical lines '|' between the two colons\n    vertical_lines_count = s[first_colon_pos + 1:second_colon_pos].count('|')\n\n    # The length of the accordion is 4 (for the brackets and colons) plus the vertical lines\n    return 4 + vertical_lines_count\n\n# Input reading\ns = input().strip()\n# Output the maximum accordion length\nprint(max_accordion_length(s))\n```",
    "9": "```python\nd = int(input())\nn, m = map(int, input().split())\n\nsofas = []\nfor _ in range(d):\n    x1, y1, x2, y2 = map(int, input().split())\n    sofas.append((min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)))\n\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\ndef count_situation(sofa):\n    x1, y1, x2, y2 = sofa\n    left = right = top = bottom = 0\n    \n    for other in sofas:\n        if other == sofa:\n            continue\n        ox1, oy1, ox2, oy2 = other\n        \n        if x2 < ox1:  # Sofa is to the left\n            left += 1\n        if x1 > ox2:  # Sofa is to the right\n            right += 1\n        if y2 < oy1:  # Sofa is on top\n            top += 1\n        if y1 > oy2:  # Sofa is below\n            bottom += 1\n    \n    return left, right, top, bottom\n\nfor i in range(d):\n    left, right, top, bottom = count_situation(sofas[i])\n    if (left == cnt_l) and (right == cnt_r) and (top == cnt_t) and (bottom == cnt_b):\n        print(i + 1)\n        break\nelse:\n    print(-1)\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    print(\"YES\" if a == b else \"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "11": "```python\nimport math\n\ndef max_chocolates(n, a, b, p, q):\n    # Count the number of tiles painted Red\n    red_count = n // a\n    # Count the number of tiles painted Blue\n    blue_count = n // b\n    # Count the number of tiles painted Red and Blue\n    both_count = n // (a * b // math.gcd(a, b))\n    \n    # Calculate maximum chocolates\n    # If we paint the overlapping tiles as Red\n    option1 = (red_count - both_count) * p + (blue_count - both_count) * q + both_count * p\n    # If we paint the overlapping tiles as Blue\n    option2 = (red_count - both_count) * p + (blue_count - both_count) * q + both_count * q\n    \n    return max(option1, option2)\n\nn, a, b, p, q = map(int, input().split())\nprint(max_chocolates(n, a, b, p, q))\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelse:\n    print(n + k - t)\n```",
    "18": "```python\ns = input().strip()\nt = []\nu = []\n\nfor char in s:\n    t.append(char)\n    while t and (not u or t[-1] <= u[-1]):\n        u.append(t.pop())\n\n# Append any remaining characters in t to u\nwhile t:\n    u.append(t.pop())\n\nprint(''.join(u))\n```",
    "16": "```python\ncnt1 = int(input())\ncnt2 = int(input())\ncnt3 = int(input())\ncnt4 = int(input())\n\n# Regular bracket sequence conditions\nif cnt1 + cnt2 + cnt3 + cnt4 == 0:\n    print(1)\nelse:\n    open_needed = cnt1 + cnt2\n    close_needed = cnt3 + cnt4\n    \n    # Check if we can match the opening and closing brackets\n    if open_needed >= close_needed and (open_needed - close_needed) % 2 == 0:\n        print(1)\n    else:\n        print(0)\n```",
    "6": "```python\ndef min_blows_to_defeat(t, queries):\n    results = []\n    \n    for i in range(t):\n        n, x = queries[i][0], queries[i][1]\n        blows = queries[i][2]\n        \n        min_blow = float('inf')\n        max_effective_d = 0\n        \n        for d, h in blows:\n            if d >= x:\n                # If d is greater than or equal to x, it can defeat Zmei in one blow\n                min_blow = 1\n                break\n            else:\n                # Calculate the effective reduction in heads\n                effective_d = d - h\n                if effective_d > 0:\n                    max_effective_d = max(max_effective_d, effective_d)\n        \n        if min_blow == 1:\n            results.append(1)\n            continue\n        \n        if max_effective_d <= 0:\n            results.append(-1)\n            continue\n        \n        # Calculate the number of blows needed\n        blows_needed = (x - max_effective_d + max_effective_d - 1) // max_effective_d\n        \n        results.append(blows_needed + 1)  # +1 for the blow that will take it to zero\n    \n    return results\n\n# Input reading and function call\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\nresults = min_blows_to_defeat(t, queries)\nfor result in results:\n    print(result)\n```",
    "3": "```python\ndef maximize_painted_sections(n, q, painters):\n    total_sections = [0] * (n + 2)\n    \n    for l, r in painters:\n        total_sections[l] += 1\n        total_sections[r + 1] -= 1\n\n    # Calculate the number of painted sections if all painters are hired\n    painted_sections = [0] * (n + 1)\n    current_paint = 0\n    for i in range(1, n + 1):\n        current_paint += total_sections[i]\n        painted_sections[i] = current_paint\n\n    # Calculate the painted sections count\n    painted_count = sum(1 for i in range(1, n + 1) if painted_sections[i] > 0)\n\n    # Now to find the maximum sections painted by hiring q - 2 painters\n    max_painted = 0\n\n    for i in range(q):\n        l1, r1 = painters[i]\n        # Temporarily remove the effect of painter i\n        temp_sections = painted_sections[:]\n        \n        for j in range(l1, r1 + 1):\n            temp_sections[j] -= 1\n\n        # Re-calculate painted sections without painter i\n        current_count = sum(1 for k in range(1, n + 1) if temp_sections[k] > 0)\n        \n        for j in range(i + 1, q):\n            l2, r2 = painters[j]\n            # Temporarily remove the effect of painter j\n            temp_sections2 = temp_sections[:]\n            \n            for k in range(l2, r2 + 1):\n                temp_sections2[k] -= 1\n\n            # Re-calculate painted sections without painter i and j\n            current_count2 = sum(1 for k in range(1, n + 1) if temp_sections2[k] > 0)\n            max_painted = max(max_painted, current_count2)\n\n    return max(max_painted, painted_count)\n\n# Input reading\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output result\nprint(maximize_painted_sections(n, q, painters))\n```",
    "12": "```python\ndef max_beauty_with_swap(n, trophies):\n    lengths = []\n    max_length = 0\n    current_length = 0\n\n    # Calculate lengths of consecutive 'G's\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                lengths.append(current_length)\n                max_length = max(max_length, current_length)\n            current_length = 0\n\n    # Append any remaining length of 'G's\n    if current_length > 0:\n        lengths.append(current_length)\n        max_length = max(max_length, current_length)\n\n    # If there are no 'G's, return 0\n    if not lengths:\n        return 0\n\n    # If there's only one segment of 'G's, the best we can do is that segment\n    if len(lengths) == 1:\n        return max_length\n\n    # Calculate potential new max length by swapping\n    potential_max = max_length\n    for i in range(len(lengths) - 1):\n        # If we can swap a 'S' between two segments of 'G's\n        potential_max = max(potential_max, lengths[i] + lengths[i + 1])\n\n    return min(potential_max + 1, n)  # Ensure we do not exceed n\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\n\n# Output the result\nprint(max_beauty_with_swap(n, trophies))\n```",
    "21": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Find positions of the minimum and maximum elements\nmin_pos = a.index(1)\nmax_pos = a.index(n)\n\n# Calculate current distance\ncurrent_distance = abs(min_pos - max_pos)\n\n# Potential new positions after swapping\nnew_distance1 = abs(0 - max_pos)  # Swap min with the first element\nnew_distance2 = abs(n - 1 - max_pos)  # Swap min with the last element\nnew_distance3 = abs(min_pos - 0)  # Swap max with the first element\nnew_distance4 = abs(min_pos - (n - 1))  # Swap max with the last element\n\n# Calculate the maximum distance possible after one swap\nmax_distance = max(new_distance1, new_distance2, new_distance3, new_distance4)\n\n# Print the result\nprint(max(max_distance, current_distance))\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef main():\n    n, k = map(int, input().split())\n    main_courses = list(map(int, input().split()))\n    \n    # Adjacency list for the graph of courses\n    dependencies = defaultdict(list)\n    # In-degree count for topological sorting\n    in_degree = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        data = list(map(int, input().split()))\n        t_i = data[0]\n        for dep in data[1:t_i + 1]:\n            dependencies[dep].append(i)\n            in_degree[i] += 1\n\n    # Queue for courses with no dependencies (in-degree of 0)\n    queue = deque()\n    \n    # Start with all courses that have no dependencies\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    # List to maintain the order of completed courses\n    order = []\n    passed_courses = set()\n    \n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        passed_courses.add(course)\n        \n        for dependent_course in dependencies[course]:\n            in_degree[dependent_course] -= 1\n            if in_degree[dependent_course] == 0:\n                queue.append(dependent_course)\n\n    # Check if we can complete all main courses\n    if not all(course in passed_courses for course in main_courses):\n        print(-1)\n        return\n\n    # Collect all courses needed to pass\n    needed_courses = set(main_courses)\n    result_courses = []\n    \n    for course in order:\n        result_courses.append(course)\n        if course in needed_courses:\n            needed_courses.remove(course)\n        if not needed_courses:\n            break\n    \n    # The result courses will be the ones passed until all main are completed\n    print(len(result_courses))\n    print(\" \".join(map(str, result_courses)))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return minutes_passed\n\ncurrent_time = input().strip()\nhh, mm = map(int, current_time.split(\":\"))\nresult = next_palindrome_time(hh, mm)\nprint(result)\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror_chars = {\n        'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M',\n        'O': 'O', 'o': 'o', 'p': 'q', 'q': 'p', 'R': 'R', 'S': 'S',\n        'T': 'T', 'U': 'U', 'v': 'v', 'V': 'V', 'W': 'W', 'x': 'x',\n        'Y': 'Y'\n    }\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        left_char = s[i]\n        right_char = s[n - 1 - i]\n        \n        if left_char not in mirror_chars or right_char != mirror_chars[left_char]:\n            print(\"NIE\")\n            return\n    print(\"TAK\")\n\ns = input().strip()\nis_s_palindrome(s)\n```",
    "23": "```python\nfrom itertools import permutations\n\ndef max_permutation_not_exceeding(a, b):\n    a_str = str(a)\n    b_str = str(b)\n    \n    # Generate all unique permutations of the digits of a\n    perm = sorted(set(permutations(a_str)), reverse=True)\n\n    for p in perm:\n        # Join the tuple of characters to form a number\n        num_str = ''.join(p)\n        # Skip permutations that lead with '0' or don't match the length of a\n        if num_str[0] != '0' and len(num_str) == len(a_str):\n            num = int(num_str)\n            # Check if it is less than or equal to b\n            if num <= b:\n                return num\n\n# Input reading\na = int(input().strip())\nb = int(input().strip())\n\n# Get and print the result\nresult = max_permutation_not_exceeding(a, b)\nprint(result)\n```",
    "19": "```python\ndef is_stats_correct(test_cases):\n    results = []\n    for stats in test_cases:\n        n = stats[0]\n        plays_and_clears = stats[1]\n        \n        valid = True\n        prev_p, prev_c = 0, 0\n        \n        for p, c in plays_and_clears:\n            if p < prev_p or c < prev_c or c > p:\n                valid = False\n                break\n            if (c - prev_c) > (p - prev_p):\n                valid = False\n                break\n            prev_p, prev_c = p, c\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Input reading\nT = int(input())\ntest_cases = []\n\nfor _ in range(T):\n    n = int(input())\n    plays_and_clears = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, plays_and_clears))\n\nresults = is_stats_correct(test_cases)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "30": "```python\ndef min_traps(m, x):\n    # Since GCD(x, m) = 1, the x-mouse will visit all rooms except for room 0.\n    # Therefore, we need to set traps for all the remaining m-1 rooms.\n    return m - 1\n\n# Input reading\nm, x = map(int, input().split())\n# Output the result\nprint(min_traps(m, x))\n```",
    "27": "```python\nn = int(input())\ns = input().strip()\n\nmin_operations = n  # Start with the assumption that we will type all characters one by one\n\nfor i in range(1, n // 2 + 1):  # Check up to half the length of the string\n    if s[:i] == s[i:2*i]:  # Check if we can copy the first i characters\n        operations = i + 1 + (n - 2 * i)  # i (initial characters) + 1 (copy operation) + remaining characters\n        min_operations = min(min_operations, operations)\n\nprint(min_operations)\n```",
    "14": "```python\ndef is_stack_sortable(p):\n    stack = []\n    b = []\n    index = 0\n    n = len(p)\n\n    for x in range(1, n + 1):\n        while stack and stack[-1] == p[index]:\n            b.append(stack.pop())\n            index += 1\n        if index < n and p[index] == x:\n            b.append(x)\n            index += 1\n        else:\n            stack.append(x)\n\n    while stack:\n        b.append(stack.pop())\n\n    return b == sorted(b)\n\ndef restore_permutation(n, k, p):\n    used = set(p)\n    remaining = [x for x in range(1, n + 1) if x not in used]\n    \n    if not is_stack_sortable(p + remaining):\n        return -1\n\n    result = p.copy()\n    remaining.sort(reverse=True)\n    j = 0\n\n    for x in remaining:\n        while j < len(remaining) and (not result or x > remaining[j]):\n            result.append(remaining[j])\n            j += 1\n            \n    return result\n\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\nresult = restore_permutation(n, k, p)\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "25": "```python\ndef create_matrix(n, k):\n    max_possible_k = n * (n + 1) // 2\n    if k > max_possible_k:\n        return -1  # Not enough space to place k ones\n    \n    matrix = [[0] * n for _ in range(n)]\n\n    # Fill the matrix to be lexicographically maximal\n    for i in range(n):\n        if k <= 0:\n            break\n        for j in range(i, n):\n            if k > 0:\n                matrix[i][j] = 1\n                if i != j:\n                    matrix[j][i] = 1  # Make it symmetric\n                    k -= 2  # Off-diagonal counts as two\n                else:\n                    k -= 1  # Diagonal counts as one\n\n    if k > 0:\n        return -1  # Still remaining ones that couldn't be placed\n\n    return matrix\n\n# Input reading\nn, k = map(int, input().split())\nresult = create_matrix(n, k)\n\n# Output result\nif result == -1:\n    print(result)\nelse:\n    for row in result:\n        print(\" \".join(map(str, row)))\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = []\nregulars = []\nfor name, type_ in files:\n    if type_ == '1':\n        examples.append(name)\n    else:\n        regulars.append(name)\n\nnum_examples = len(examples)\nnum_regulars = len(regulars)\n\nmoves = []\n# Renaming example files\nfor i in range(num_examples):\n    moves.append(f\"move {examples[i]} {i + 1}\")\n\n# Renaming regular files\nfor i in range(num_regulars):\n    moves.append(f\"move {regulars[i]} {num_examples + i + 1}\")\n\n# Output the result\nprint(len(moves))\nprint(\"\\n\".join(moves))\n```",
    "24": "```python\ndef can_win(matrix):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # down, right, down-right, down-left\n\n    def check_win(x, y):\n        for dx, dy in directions:\n            count = 1  # Start with the current position\n            # Check in the positive direction\n            nx, ny = x + dx, y + dy\n            while 0 <= nx < 10 and 0 <= ny < 10 and matrix[nx][ny] == 'X':\n                count += 1\n                nx += dx\n                ny += dy\n            # Check in the negative direction\n            nx, ny = x - dx, y - dy\n            while 0 <= nx < 10 and 0 <= ny < 10 and matrix[nx][ny] == 'X':\n                count += 1\n                nx -= dx\n                ny -= dy\n            if count >= 5:\n                return True\n        return False\n\n    for i in range(10):\n        for j in range(10):\n            if matrix[i][j] == '.':\n                matrix[i][j] = 'X'  # Try placing a cross\n                if check_win(i, j):\n                    return 'YES'\n                matrix[i][j] = '.'  # Reset the cell back\n    return 'NO'\n\n\n# Read input matrix\nmatrix = [input().strip() for _ in range(10)]\nprint(can_win(matrix))\n```",
    "26": "```python\n# Read input\nx, y, z = map(float, input().split())\n\n# Calculate all expressions with their labels\nexpressions = [\n    (x ** (y ** z), \"x^y^z\"),\n    (x ** (z ** y), \"x^z^y\"),\n    ((x ** y) ** z, \"(x^y)^z\"),\n    ((x ** z) ** y, \"(x^z)^y\"),\n    (y ** (x ** z), \"y^x^z\"),\n    (y ** (z ** x), \"y^z^x\"),\n    ((y ** x) ** z, \"(y^x)^z\"),\n    ((y ** z) ** x, \"(y^z)^x\"),\n    (z ** (x ** y), \"z^x^y\"),\n    (z ** (y ** x), \"z^y^x\"),\n    ((z ** x) ** y, \"(z^x)^y\"),\n    ((z ** y) ** x, \"(z^y)^x\"),\n]\n\n# Find the maximum value and corresponding expression\nmax_value, max_index = max((value, idx) for idx, (value, _) in enumerate(expressions))\n# Output the corresponding expression with the smallest index\nprint(expressions[max_index][1])\n```",
    "32": "```python\ndef check_journey(n, journey):\n    position = 0  # North Pole is 0, South Pole is 20000\n    for t, direction in journey:\n        # Check for valid moves from the poles\n        if position == 0 and direction != \"South\":\n            return \"NO\"\n        if position == 20000 and direction != \"North\":\n            return \"NO\"\n        \n        # Update position based on direction\n        if direction == \"South\":\n            position += t\n        elif direction == \"North\":\n            position -= t\n        # West and East do not affect the North/South position\n\n        # Check if the position goes out of bounds\n        if position < 0 or position > 20000:\n            return \"NO\"\n    \n    # Check if we are back at the North Pole\n    return \"YES\" if position == 0 else \"NO\"\n\n# Input reading\nn = int(input())\njourney = [tuple(input().split()) for _ in range(n)]\njourney = [(int(t), dir) for t, dir in journey]\n\n# Output result\nprint(check_journey(n, journey))\n```",
    "29": "```python\ndef min_replacements(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    # If already lucky\n    if sum_first == sum_second:\n        return 0\n    \n    # Calculate the difference\n    diff = abs(sum_first - sum_second)\n    \n    # Create lists of possible changes for each half\n    if sum_first > sum_second:\n        changes = sorted([9 - d for d in first_half], reverse=True)\n    else:\n        changes = sorted([9 - d for d in second_half], reverse=True)\n    \n    count = 0\n    for change in changes:\n        diff -= change\n        count += 1\n        if diff <= 0:\n            return count\n            \n    return count\n\n# Read input\nticket = input().strip()\n# Get the result\nresult = min_replacements(ticket)\n# Print the result\nprint(result)\n```",
    "37": "```python\ndef can_deal_exact_damage(a, b, c):\n    # Loop through the maximum number of shots from the first gun (Ebony)\n    for i in range(c // a + 1):\n        # Calculate the remaining damage needed after i shots from Ebony\n        remaining_damage = c - i * a\n        # Check if remaining damage can be achieved with shots from Ivory\n        if remaining_damage >= 0 and remaining_damage % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Input reading\na, b, c = map(int, input().split())\nprint(can_deal_exact_damage(a, b, c))\n```",
    "34": "```python\ndef can_distribute(x, n, a, b):\n    plates_for_a = (a + x - 1) // x  # Ceiling division of a by x\n    plates_for_b = (b + x - 1) // x  # Ceiling division of b by x\n    return plates_for_a + plates_for_b <= n\n\ndef max_min_pieces(n, a, b):\n    low, high = 1, max(a, b)\n    while low < high:\n        mid = (low + high + 1) // 2\n        if can_distribute(mid, n, a, b):\n            low = mid  # mid is a valid distribution, try for a larger minimum\n        else:\n            high = mid - 1  # mid is too large, try a smaller minimum\n    return low\n\nn, a, b = map(int, input().split())\nprint(max_min_pieces(n, a, b))\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef birthday_paradox(n, k):\n    MOD = 10**6 + 3\n    days = 1 << n  # 2^n\n    \n    if k > days:\n        return 1, 1  # Guaranteed to have at least one shared birthday\n    \n    # Calculate the probability of no shared birthdays\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator *= (days - i)\n        denominator *= days\n        if numerator >= MOD:\n            numerator %= MOD\n        if denominator >= MOD:\n            denominator %= MOD\n\n    # Probability of at least one shared birthday\n    prob_shared_num = (denominator - numerator + MOD) % MOD\n    prob_shared_den = denominator % MOD\n    \n    # Reduce fraction\n    common_gcd = gcd(prob_shared_num, prob_shared_den)\n    prob_shared_num //= common_gcd\n    prob_shared_den //= common_gcd\n    \n    # Apply modulo to ensure coprimality\n    prob_shared_num %= MOD\n    prob_shared_den %= MOD\n    \n    return prob_shared_num, prob_shared_den\n\n# Read input\nn, k = map(int, input().split())\nA, B = birthday_paradox(n, k)\nprint(A, B)\n```",
    "35": "```python\nn, m = map(int, input().split())\nflag = [input().strip() for _ in range(n)]\n\ndef is_valid_flag(flag):\n    colors = {'R', 'G', 'B'}\n    \n    # Check for horizontal stripes\n    if n % 3 == 0:\n        stripe_height = n // 3\n        used_colors = set()\n        for i in range(3):\n            stripe = flag[i * stripe_height:(i + 1) * stripe_height]\n            if len(set(stripe)) != 1 or stripe[0][0] not in colors:\n                return False\n            used_colors.add(stripe[0][0])\n        return used_colors == colors\n    \n    # Check for vertical stripes\n    if m % 3 == 0:\n        stripe_width = m // 3\n        used_colors = set()\n        for i in range(3):\n            stripe = [row[i * stripe_width:(i + 1) * stripe_width] for row in flag]\n            if len(set(stripe)) != 1 or stripe[0][0] not in colors:\n                return False\n            used_colors.add(stripe[0][0])\n        return used_colors == colors\n    \n    return False\n\nprint(\"YES\" if is_valid_flag(flag) else \"NO\")\n```",
    "40": "```python\nn = int(input())\nparticipants = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if any participant's rating has changed\nrated = any(a != b for a, b in participants)\n\n# Check if participants are in non-increasing order by their pre-round ratings\nunrated = any(participants[i][0] < participants[i + 1][0] for i in range(n - 1))\n\nif rated:\n    print(\"rated\")\nelif unrated:\n    print(\"unrated\")\nelse:\n    print(\"maybe\")\n```",
    "38": "```python\ndef can_coincide(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between consecutive barriers for Kefa and Sasha\n    kefa_gaps = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    sasha_gaps = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n\n    # Check if Sasha's gaps can be obtained from Kefa's gaps by rotation\n    double_kefa_gaps = kefa_gaps * 2  # Concatenate Kefa's gaps with itself\n\n    # Check for a matching segment of length n in the doubled gaps\n    for i in range(n):\n        if double_kefa_gaps[i:i + n] == sasha_gaps:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output result\nprint(can_coincide(n, L, kefa_distances, sasha_distances))\n```",
    "41": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the distance array with a large value\ndistances = [float('inf')] * n\n\n# First pass: left to right\nlast_zero = -1\nfor i in range(n):\n    if a[i] == 0:\n        last_zero = i\n    if last_zero != -1:\n        distances[i] = i - last_zero\n\n# Second pass: right to left\nlast_zero = -1\nfor i in range(n - 1, -1, -1):\n    if a[i] == 0:\n        last_zero = i\n    if last_zero != -1:\n        distances[i] = min(distances[i], last_zero - i)\n\nprint(' '.join(map(str, distances)))\n```",
    "42": "```python\ndef count_cyclical_strings(n, s):\n    from itertools import product\n    \n    len_s = len(s)\n    all_strings = set()\n    \n    # Generate all binary strings of length n\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        # Check if any cyclical shift of t contains s as a substring\n        if any(s in t[i:] + t[:i] for i in range(n)):\n            all_strings.add(t)\n\n    return len(all_strings)\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Ensure the string s is not longer than n\nif len(s) > n:\n    print(0)\nelse:\n    # Get the result\n    result = count_cyclical_strings(n, s)\n    # Print the result\n    print(result)\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ns = input().strip()\n\nif not is_palindrome(s):\n    print(len(s))\nelse:\n    # Check for the longest non-palindromic substring\n    # If all characters are the same, then all substrings are palindromes\n    if len(set(s)) == 1:\n        print(0)\n    else:\n        # The longest non-palindromic substring will be the entire string minus one character\n        print(len(s) - 1)\n```",
    "36": "```python\ndef hexagonal_spiral(n):\n    if n == 0:\n        return (0, 0)\n    \n    layer = 0\n    while n > 6 * layer:\n        n -= 6 * layer\n        layer += 1\n    \n    x, y = layer, 0\n    \n    if n == 0:\n        return (x, y)\n    \n    # Determine the position in the current layer\n    segment_length = layer\n    if n <= segment_length:\n        x -= n\n        y += 0\n    elif n <= 2 * segment_length:\n        x -= segment_length\n        y += n - segment_length\n    elif n <= 3 * segment_length:\n        x += n - 2 * segment_length\n        y += segment_length\n    elif n <= 4 * segment_length:\n        x += segment_length\n        y -= n - 3 * segment_length\n    elif n <= 5 * segment_length:\n        x += n - 4 * segment_length\n        y -= segment_length\n    else:\n        x -= segment_length\n        y -= n - 5 * segment_length\n    \n    return (x, y)\n\nn = int(input())\nx, y = hexagonal_spiral(n)\nprint(x, y)\n```",
    "46": "```python\ndef count_pairs(n, m):\n    # Count how many numbers in the first column have each remainder when divided by 5\n    count_x = [0] * 5\n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n    \n    # Count how many numbers in the second column have each remainder when divided by 5\n    count_y = [0] * 5\n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n    \n    # Calculate the number of valid pairs\n    result = 0\n    for k in range(5):\n        result += count_x[k] * count_y[(5 - k) % 5]\n    \n    return result\n\n# Read input\nn, m = map(int, input().split())\n# Print the result\nprint(count_pairs(n, m))\n```",
    "33": "```python\ndef count_intersection(a1, b1, a2, b2, L, R):\n    from math import gcd\n\n    # Adjust b1 and b2 for the equations\n    b1 = b1 % a1\n    b2 = b2 % a2\n\n    # Calculate the step size (lcm) and the gcd\n    g = gcd(a1, a2)\n    step = (a1 // g) * a2  # lcm(a1, a2)\n\n    # Determine the values of x that satisfy both equations\n    diff = (b2 - b1) % a2\n    inv_a1 = pow(a1 // g, -1, a2 // g)  # Modular inverse\n    t = (diff * inv_a1) % (a2 // g)\n\n    # Particular solution x0\n    x0 = b1 + a1 * t\n\n    # Adjust x0 to be within the bounds [L, R]\n    if x0 < L:\n        x0 += ((L - x0 + step - 1) // step) * step\n    elif x0 > R:\n        return 0  # No valid solution if x0 is beyond R\n\n    # Count the number of valid solutions in the range [L, R]\n    last_valid = R - (R - x0) % step\n\n    if last_valid < x0:\n        return 0\n\n    return (last_valid - x0) // step + 1\n\n# Input reading\na1, b1, a2, b2, L, R = map(int, input().split())\n# Output the result\nprint(count_intersection(a1, b1, a2, b2, L, R))\n```",
    "44": "```python\nd, k, a, b, t = map(int, input().split())\n\n# The time if Vasiliy walks the entire distance\nmin_time = d * b\n\n# Calculate the maximum number of full k segments he can drive\nfull_segments = d // k\nremaining_distance = d % k\n\n# Calculate the time taken if using the car for full segments and walking the rest\ncar_time = full_segments * (k * a + t) + remaining_distance * a\nif full_segments > 0:\n    car_time -= t  # Remove the last repair time if the last segment is not needed\n\nmin_time = min(min_time, car_time)\n\n# Check time for all possible numbers of segments driven by car\nfor i in range(1, full_segments + 1):\n    # i segments driven by car, remaining distances walked\n    distance_driven = i * k\n    distance_walked = d - distance_driven\n    \n    if distance_walked >= 0:\n        current_time = (i * (k * a + t) + distance_walked * b)\n        current_time -= t  # Remove the last repair time if not needed\n        min_time = min(min_time, current_time)\n\n# Consider the case of driving the last segment partially if there's remaining distance\nif remaining_distance > 0:\n    current_time = (full_segments * (k * a + t) + remaining_distance * a)\n    if full_segments > 0:\n        current_time -= t  # Remove the last repair time if the last segment is not needed\n    min_time = min(min_time, current_time)\n\nprint(min_time)\n```",
    "48": "```python\ndef kth_largest_in_multiplication_table(n, m, k):\n    # Binary search to find the k-th largest number\n    left, right = 1, n * m\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        # Count how many numbers are less than or equal to mid\n        count = 0\n        for i in range(1, n + 1):\n            count += min(mid // i, m)\n        \n        # If count is less than k, we need a larger number\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left\n\n# Read input\nn, m, k = map(int, input().split())\n# Get the k-th largest number\nresult = kth_largest_in_multiplication_table(n, m, k)\n# Print the result\nprint(result)\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Check if it's possible to create such a sequence\n    min_sum = k * (k + 1) // 2\n    if min_sum > n:\n        return -1\n    \n    # The remaining value after using the first k natural numbers\n    remaining = n - min_sum\n    \n    # The GCD can be maximized by adding the same value to each element\n    gcd = remaining // k\n    \n    # The base sequence is the first k natural numbers\n    sequence = [i + gcd for i in range(1, k + 1)]\n    \n    # Adjust the last element to ensure the sum is exactly n\n    sequence[-1] += (remaining % k)\n    \n    return sequence\n\n# Input\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\n# Output\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "47": "```python\ndef max_subarray_sum(arr):\n    max_sum = 0\n    current_sum = 0\n    for num in arr:\n        current_sum = max(0, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef max_beauty_after_operation(n, x, a):\n    original_beauty = max_subarray_sum(a)\n    \n    if x <= 0:\n        return original_beauty\n    \n    max_gain = 0\n    current_gain = 0\n    for i in range(n):\n        potential_gain = a[i] * (x - 1)\n        current_gain += potential_gain\n        max_gain = max(max_gain, current_gain)\n        if current_gain < 0:\n            current_gain = 0\n    \n    return original_beauty + max_gain\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_beauty_after_operation(n, x, a))\n```",
    "43": "```python\nimport math\nimport sys\n\ndef angle_between(v1, v2):\n    dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n    magnitude_v1 = math.sqrt(v1[0]**2 + v1[1]**2)\n    magnitude_v2 = math.sqrt(v2[0]**2 + v2[1]**2)\n    cos_angle = dot_product / (magnitude_v1 * magnitude_v2)\n    return math.acos(max(-1.0, min(1.0, cos_angle)))  # Clamping to avoid domain errors\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    vectors = []\n\n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().strip().split())\n        angle = math.atan2(y, x)  # Get the angle of the vector\n        vectors.append((angle, i + 1, (x, y)))  # Store angle, index, and vector\n\n    # Sort by angle\n    vectors.sort()\n\n    min_angle = float('inf')\n    best_pair = (0, 0)\n\n    for i in range(n):\n        v1 = vectors[i][2]\n        v2 = vectors[(i + 1) % n][2]  # Wrap around to compare with the first vector\n        \n        current_angle = angle_between(v1, v2)\n        \n        if current_angle < min_angle:\n            min_angle = current_angle\n            best_pair = (vectors[i][1], vectors[(i + 1) % n][1])\n\n    print(best_pair[0], best_pair[1])\n\nif __name__ == \"__main__\":\n    main()\n```",
    "49": "```python\ndef find_kth_digit(k):\n    digit_length = 1\n    count = 9\n    start = 1\n\n    # Determine the range in which the k-th digit falls\n    while k > digit_length * count:\n        k -= digit_length * count\n        digit_length += 1\n        count *= 10\n        start *= 10\n\n    # Find the actual number that contains the k-th digit\n    number = start + (k - 1) // digit_length\n    digit_index = (k - 1) % digit_length\n\n    # Extract the specific digit from the number\n    return str(number)[digit_index]\n\nk = int(input())\nprint(find_kth_digit(k))\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef reachable_count(n):\n    reachable = set()\n    current = n\n    \n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    \n    return len(reachable)\n\nn = int(input().strip())\nprint(reachable_count(n))\n```",
    "54": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_a = min(a)\nmax_a = max(a)\n\nif min_a == max_a:\n    print(0)\nelse:\n    diff = max_a - min_a\n    if diff % 2 == 0:\n        print(diff // 2)\n    else:\n        print(-1)\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    from itertools import combinations\n\n    max_choose = m // 2\n    total_sum = 0\n\n    for row in matrix:\n        max_row_sum = 0\n        # Generate all combinations of the row with sizes from 0 to max_choose\n        for r in range(max_choose + 1):\n            for comb in combinations(row, r):\n                current_sum = sum(comb)\n                if current_sum % k == 0:\n                    max_row_sum = max(max_row_sum, current_sum)\n        \n        total_sum += max_row_sum\n\n    return total_sum\n\n# Input reading\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print\nresult = max_sum_divisible_by_k(n, m, k, matrix)\nprint(result)\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = float('-inf')\n    sequence = []\n    moves = []\n    \n    while left <= right:\n        can_take_left = a[left] > last_taken\n        can_take_right = a[right] > last_taken\n        \n        if can_take_left and (not can_take_right or a[left] < a[right]):\n            last_taken = a[left]\n            sequence.append(a[left])\n            moves.append('L')\n            left += 1\n        elif can_take_right:\n            last_taken = a[right]\n            sequence.append(a[right])\n            moves.append('R')\n            right -= 1\n        else:\n            break\n    \n    print(len(sequence))\n    print(''.join(moves))\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\nlongest_increasing_sequence(n, a)\n```",
    "59": "```python\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# Create the target pattern: '0' * y + '1' + '0' * (x - y - 1)\ntarget = ['0'] * x\ntarget[y] = '1'\n\n# Initialize a counter for the number of operations needed\noperations = 0\n\n# Check the last x digits of the number against the target pattern\nfor i in range(x):\n    if number[n - x + i] != target[i]:\n        operations += 1\n\nprint(operations)\n```",
    "58": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nfrom collections import defaultdict\n\ncoloring = [0] * n\ncolor_used = defaultdict(list)\n\n# Gather indices of each unique element\nfor i in range(n):\n    color_used[a[i]].append(i)\n\n# Check if any element appears more than k times\nif any(len(indices) > k for indices in color_used.values()):\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    current_color = 1\n    # Assign colors while ensuring distinctness\n    for indices in color_used.values():\n        for index in indices:\n            coloring[index] = current_color\n            current_color += 1\n            if current_color > k:\n                current_color = 1\n\n    print(\" \".join(map(str, coloring)))\n```",
    "51": "```python\nfrom collections import Counter\n\ndef restore_xy(n, divisors):\n    count = Counter(divisors)\n    \n    # Identify the maximum divisor, which is the candidate for x or y\n    max_divisor = max(divisors)\n    \n    # Find the second maximum divisor which must be x or y\n    second_max_divisor = 1\n    for d in divisors:\n        if d < max_divisor:\n            second_max_divisor = max(second_max_divisor, d)\n    \n    # Calculate potential x and y\n    x = max_divisor\n    y = second_max_divisor\n    \n    # Ensure y is the correct value by checking divisor counts\n    temp_count = count.copy()\n    \n    for d in divisors:\n        if x % d == 0 and temp_count[d] > 0:\n            temp_count[d] -= 1\n        if y % d == 0 and temp_count[d] > 0:\n            temp_count[d] -= 1\n    \n    # Check if all counts are satisfied\n    if all(v == 0 for v in temp_count.values()):\n        return x, y\n    \n    return None\n\n# Input reading\nn = int(input())\ndivisors = list(map(int, input().split()))\n\n# Call the function and print the result\nresult = restore_xy(n, divisors)\nif result:\n    print(result[0], result[1])\n```",
    "61": "```python\nn = int(input())\na = input().strip()\nf = list(map(int, input().split()))\n\nmax_number = list(a)\nchanged = False\n\nfor i in range(n):\n    current_digit = int(a[i])\n    new_digit = f[current_digit - 1]\n    \n    if new_digit > current_digit:\n        if not changed:\n            changed = True\n        max_number[i] = str(new_digit)\n    elif new_digit < current_digit and changed:\n        break\n\nprint(''.join(max_number))\n```",
    "63": "```python\ndef min_instability(n, a):\n    # Sort the array to easily find max and min after removing one element\n    a.sort()\n    \n    # Calculate the two possible instabilities after removing one element\n    instability1 = a[-1] - a[1]  # Remove the smallest element\n    instability2 = a[-2] - a[0]  # Remove the largest element\n    \n    # Return the minimum of the two calculated instabilities\n    return min(instability1, instability2)\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result and print it\nresult = min_instability(n, a)\nprint(result)\n```",
    "57": "```python\nn = int(input())\nf = list(map(int, input().split()))\n\n# Track friends who have not yet given a gift and who are supposed to receive gifts\nunknown_indices = []\ngifted = set()\n\nfor i in range(n):\n    if f[i] == 0:\n        unknown_indices.append(i)  # Store 0-based index\n    else:\n        gifted.add(f[i])\n\n# Find friends who are not in the gifted set\nnot_gifted = [i for i in range(1, n + 1) if i not in gifted]\n\n# Fill in the unknown gift receivers\nfor i in range(len(unknown_indices)):\n    # Assign gifts while ensuring no one gives a gift to themselves\n    current_unknown_index = unknown_indices[i]\n    if (current_unknown_index + 1) in not_gifted:\n        # If the friend wants to give a gift to themselves, swap with next\n        if i < len(unknown_indices) - 1:\n            not_gifted[i], not_gifted[i + 1] = not_gifted[i + 1], not_gifted[i]\n    \n    f[current_unknown_index] = not_gifted[i]  # Update the gift list\n\nprint(\" \".join(map(str, f)))\n```",
    "60": "```python\ndef has_palindrome_subsequence(test_cases):\n    results = []\n    for n, a in test_cases:\n        found = False\n        # Create a dictionary to store the last seen index of each number\n        last_seen = {}\n        for i in range(n):\n            if a[i] in last_seen:\n                # If we have seen this number before, we can form a palindrome\n                if i - last_seen[a[i]] >= 2:\n                    found = True\n                    break\n            last_seen[a[i]] = i\n        results.append(\"YES\" if found else \"NO\")\n    return results\n\n# Reading input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Get results and print them\nresults = has_palindrome_subsequence(test_cases)\nprint(\"\\n\".join(results))\n```",
    "55": "```python\ndef is_visible(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n    # Check if the black sheets completely cover the white sheet\n    is_covered = (x3 >= x2 or x4 <= x1 or y3 >= y2 or y4 <= y1) and (x5 >= x2 or x6 <= x1 or y5 >= y2 or y6 <= y1)\n    \n    if is_covered:\n        return \"NO\"\n    \n    # Check if there is any part of the white sheet visible\n    visible = (x3 < x1 and x4 > x1) or (x5 < x1 and x6 > x1) or (x3 < x2 and x4 > x2) or (x5 < x2 and x6 > x2) or \\\n              (y3 < y1 and y4 > y1) or (y5 < y1 and y6 > y1) or (y3 < y2 and y4 > y2) or (y5 < y2 and y6 > y2)\n    \n    return \"YES\" if visible else \"NO\"\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Output the result\nprint(is_visible(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6))\n```",
    "65": "```python\ndef game_23(n, m):\n    if m % n != 0:\n        return -1\n    \n    ratio = m // n\n    count_2 = 0\n    count_3 = 0\n    \n    while ratio % 2 == 0:\n        ratio //= 2\n        count_2 += 1\n        \n    while ratio % 3 == 0:\n        ratio //= 3\n        count_3 += 1\n        \n    if ratio != 1:\n        return -1\n    \n    return count_2 + count_3\n\n# Input\nn, m = map(int, input().split())\n# Output\nprint(game_23(n, m))\n```",
    "67": "```python\ndef find_nice_indices(n, a):\n    total_sum = sum(a)\n    nice_indices = []\n\n    for i in range(n):\n        remaining_sum = total_sum - a[i]\n        if remaining_sum == 2 * a[i]:\n            nice_indices.append(i + 1)  # Store 1-based index\n\n    return nice_indices\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find nice indices\nnice_indices = find_nice_indices(n, a)\n\n# Print output\nprint(len(nice_indices))\nif nice_indices:\n    print(' '.join(map(str, nice_indices)))\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Find the longest prefix that is also a suffix\n    prefix_suffix_length = 0\n    for i in range(1, n):\n        if t[:i] == t[-i:]:\n            prefix_suffix_length = i\n    \n    # Construct the result string\n    result = t + (t[prefix_suffix_length:] * (k - 1))\n    \n    return result\n\n# Input reading\nn, k = map(int, input().split())\nt = input().strip()\n\n# Output the result\nprint(construct_string(n, k, t))\n```",
    "62": "```python\ndef min_operations(test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        min_operations = float('inf')\n        best_triplet = (a, b, c)\n\n        # A can be 1 to a+1 (inclusive)\n        for A in range(1, a + 2):\n            # B can be A to c (inclusive)\n            for B in range(A, c + 1):\n                # C can be B to c (inclusive) and must be a multiple of B\n                C = (B * ((c + B - 1) // B))  # smallest multiple of B >= c\n                if C < B:\n                    continue\n                \n                # Calculate the number of operations needed\n                operations = abs(A - a) + abs(B - b) + abs(C - c)\n                if operations < min_operations:\n                    min_operations = operations\n                    best_triplet = (A, B, C)\n\n        results.append((min_operations, best_triplet))\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations(test_cases)\n\n# Print output\nfor operations, (A, B, C) in results:\n    print(operations)\n    print(A, B, C)\n```",
    "71": "```python\na = int(input())\nif 1 <= a <= 64:\n    output = (a - 1).bit_length()\n    print(output)\nelse:\n    print(\"Input must be between 1 and 64.\")\n```",
    "64": "```python\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Initialize the schedule\nschedule = [0] * n  # 0 means rest, will use 1 to m for exam prep and m+1 for exams\n\n# Mark exam days\nfor i in range(m):\n    s_i, d_i, c_i = exams[i]\n    schedule[d_i - 1] = m + 1  # Exam day\n\n# Prepare for exams\nfor i in range(m):\n    s_i, d_i, c_i = exams[i]\n    days_needed = c_i\n    # Prepare for this exam in the available days\n    for j in range(s_i - 1, d_i - 1):\n        if schedule[j] == 0:  # Can only prepare on rest days\n            schedule[j] = i + 1  # Mark as preparing for exam i\n            days_needed -= 1\n            if days_needed == 0:\n                break\n    \n    if days_needed > 0:  # If we couldn't find enough days to prepare\n        print(-1)\n        exit()\n\n# Print the final schedule\nprint(' '.join(map(str, schedule)))\n```",
    "70": "```python\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Convert start and end times to minutes since midnight\nstart_minutes = h1 * 60 + m1\nend_minutes = h2 * 60 + m2\n\n# Calculate the midpoint in minutes\nmidpoint_minutes = (start_minutes + end_minutes) // 2\n\n# Convert the midpoint back to hours and minutes\nh3 = midpoint_minutes // 60\nm3 = midpoint_minutes % 60\n\n# Print the result in the required format\nprint(f\"{h3:02}:{m3:02}\")\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, n, graph):\n    dist = [-1] * (n + 1)\n    dist[start] = 0\n    q = deque([start])\n    farthest_node = start\n\n    while q:\n        node = q.popleft()\n        for neighbor in graph[node]:\n            if dist[neighbor] == -1:\n                dist[neighbor] = dist[node] + 1\n                q.append(neighbor)\n                if dist[neighbor] > dist[farthest_node]:\n                    farthest_node = neighbor\n    \n    return farthest_node, dist\n\ndef find_diameter_path(graph, start, end, dist_from_start):\n    path = []\n    current = end\n    while current != start:\n        path.append(current)\n        for neighbor in graph[current]:\n            if dist_from_start[neighbor] == dist_from_start[current] - 1:\n                current = neighbor\n                break\n    path.append(start)\n    return path[::-1]  # Reverse to get the path from start to end\n\ndef main():\n    n = int(input().strip())\n    graph = defaultdict(list)\n\n    for _ in range(n - 1):\n        a, b = map(int, input().strip().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # Step 1: Find the farthest node from an arbitrary node (node 1)\n    farthest_node_from_start, _ = bfs(1, n, graph)\n\n    # Step 2: Find the farthest node from that farthest node\n    farthest_node, dist_from_one_end = bfs(farthest_node_from_start, n, graph)\n\n    # Step 3: Find the path and distances from the other endpoint\n    diameter_path = find_diameter_path(graph, farthest_node_from_start, farthest_node, dist_from_one_end)\n    diameter_length = len(diameter_path) - 1  # Number of edges\n\n    # Choosing three distinct vertices: first, middle, last of the diameter path\n    a = diameter_path[0]\n    c = diameter_path[-1]\n    b = diameter_path[len(diameter_path) // 2]  # Middle node\n\n    # The maximum edges covered\n    max_edges = diameter_length + 1  # edges are one less than the number of nodes in the path\n\n    print(max_edges)\n    print(a, b, c)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "73": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmax_height = max(a)\ntotal_bricks_needed = sum(max_height - height for height in a)\n\n# Check if the total number of bricks needed is even\n# An even number of bricks can be used to equalize the wall\nif total_bricks_needed % 2 == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "77": "```python\ndef minimum_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nn = int(input().strip())\nprint(minimum_difference(n))\n```",
    "81": "```python\ndef can_rearrange_as_substrings(n, strings):\n    # Sort strings by length\n    strings.sort(key=len)\n    \n    # Check if each string is a substring of the next strings\n    for i in range(n):\n        for j in range(i + 1, n):\n            if strings[i] not in strings[j]:\n                print(\"NO\")\n                return\n            \n    print(\"YES\")\n    print(\"\\n\".join(strings))\n\n# Input handling\nn = int(input().strip())\nstrings = [input().strip() for _ in range(n)]\ncan_rearrange_as_substrings(n, strings)\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import defaultdict\n\n    # Count distinct subsequences and their deletion costs\n    distinct_subsequences = set()\n    costs = []\n\n    # Generate all subsequences using bit masking\n    for i in range(1 << n):\n        subseq = []\n        deleted_count = 0\n        for j in range(n):\n            if i & (1 << j):\n                subseq.append(s[j])\n            else:\n                deleted_count += 1\n        subseq_str = ''.join(subseq)\n        if subseq_str not in distinct_subsequences:\n            distinct_subsequences.add(subseq_str)\n            costs.append(deleted_count)\n\n    # Number of distinct subsequences\n    total_distinct = len(distinct_subsequences)\n\n    # If we can't have k distinct subsequences\n    if total_distinct < k:\n        return -1\n\n    # Sort the costs to minimize total cost\n    costs.sort()\n\n    # The minimum cost to obtain k distinct subsequences\n    return sum(costs[:k])\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    # Extract left and right endpoints\n    lefts = [l for l, r in segments]\n    rights = [r for l, r in segments]\n    \n    # Calculate the maximum and second maximum of lefts and rights\n    max_left = max(lefts)\n    second_max_left = sorted(lefts)[-2] if n > 2 else float('-inf')\n    \n    max_right = max(rights)\n    second_max_right = sorted(rights)[-2] if n > 2 else float('inf')\n    \n    max_length = 0\n    \n    for i in range(n):\n        l_i, r_i = segments[i]\n        \n        # Determine the effective left and right after removing segment i\n        effective_left = max(max_left if l_i != max_left else second_max_left, l_i)\n        effective_right = min(max_right if r_i != max_right else second_max_right, r_i)\n        \n        # Calculate the intersection length\n        intersection_length = max(0, effective_right - effective_left)\n        max_length = max(max_length, intersection_length)\n    \n    return max_length\n\n# Read input\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = max_intersection_length(n, segments)\nprint(result)\n```",
    "74": "```python\nfrom itertools import combinations\n\ndef min_cost_to_get_k_subsequences(n, k, s):\n    unique_chars = set(s)\n    unique_count = len(unique_chars)\n\n    if k > (1 << unique_count) - 1:  # 2^unique_count - 1\n        return -1\n\n    costs = []\n    for length in range(1, n + 1):\n        for subseq in combinations(s, length):\n            subseq_str = ''.join(subseq)\n            if subseq_str not in costs:\n                costs.append(subseq_str)\n                if len(costs) == k:\n                    return sum(n - len(t) for t in costs)\n    \n    return -1\n\nn, k = map(int, input().split())\ns = input().strip()\nresult = min_cost_to_get_k_subsequences(n, k, s)\nprint(result)\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n    \n    # Build the adjacency list\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Check if the first vertex has enough neighbors to satisfy degree D\n    if len(graph[1]) < D:\n        print(\"NO\")\n        return\n    \n    spanning_tree = []\n    degree = {i: 0 for i in range(1, n + 1)}\n    \n    # Start with vertex 1 and take D edges\n    for neighbor in graph[1][:D]:\n        spanning_tree.append((1, neighbor))\n        degree[1] += 1\n        degree[neighbor] += 1\n    \n    # Use a queue for BFS to complete the spanning tree\n    queue = deque([1])\n    visited = {1}\n    \n    while queue and len(spanning_tree) < n - 1:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if degree[current] > 1 and degree[neighbor] < 1:  # Ensure we can add this edge\n                spanning_tree.append((current, neighbor))\n                degree[current] += 1\n                degree[neighbor] += 1\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n\n    # Validate spanning tree\n    if len(spanning_tree) != n - 1 or degree[1] != D:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for u, v in spanning_tree:\n            print(u, v)\n\n# Input handling\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nfind_spanning_tree(n, m, D, edges)\n```",
    "76": "```python\ndef can_construct_square(n, m, tiles):\n    if m % 2 != 0:\n        return \"NO\"\n    \n    # To construct a symmetric matrix, we need matching tiles\n    tile_pairs = set()\n\n    for tile in tiles:\n        top_left, top_right = tile[0]\n        bottom_left, bottom_right = tile[1]\n        tile_pairs.add((top_right, bottom_left, bottom_right, top_left))\n    \n    # Check for each tile if there is a corresponding tile to match\n    for tile in tiles:\n        top_left, top_right = tile[0]\n        bottom_left, bottom_right = tile[1]\n        if (bottom_right, top_left, top_left, bottom_left) not in tile_pairs:\n            return \"NO\"\n    \n    return \"YES\"\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    \n    for _ in range(n):\n        top = list(map(int, input().split()))\n        bottom = list(map(int, input().split()))\n        tiles.append((top, bottom))\n    \n    result = can_construct_square(n, m, tiles)\n    results.append(result)\n\nprint(\"\\n\".join(results))\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    # Create a list to store the coloring\n    colors = [0] * n\n    color = 1\n    last_seen = {}\n    \n    for i in range(n):\n        char = s[i]\n        # If this character has been seen before and is not adjacent\n        if char in last_seen and last_seen[char] != i - 1:\n            colors[i] = color + 1\n            color += 1\n        else:\n            colors[i] = color\n        \n        last_seen[char] = i  # Update last seen position\n    \n    # The number of colors used\n    res = max(colors)\n    \n    return res, colors\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Get the result\nres, coloring = min_colors_to_sort(n, s)\n\n# Output the result\nprint(res)\nprint(\" \".join(map(str, coloring)))\n```",
    "78": "```python\ndef count_bracket_sequences(n, s):\n    MOD = 10**9 + 7\n    m = len(s)\n    \n    # Precompute the Catalan numbers up to 2n\n    catalan = [0] * (n + 1)\n    catalan[0] = 1\n    for i in range(1, n + 1):\n        catalan[i] = (catalan[i - 1] * (2 * (2 * i - 1)) % MOD * pow(i + 1, MOD - 2, MOD)) % MOD\n    \n    # Check the validity of the substring s\n    balance = 0\n    min_balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n\n    # If the balance is not valid or too negative, return 0\n    if balance < 0 or balance + n < 0 or min_balance < 0:\n        return 0\n\n    # Count the valid configurations around the substring s\n    left_needed = (n - (balance + 1)) // 2\n    right_needed = (n - (balance - 1)) // 2\n\n    if (n - (balance + 1)) % 2 != 0 or (n - (balance - 1)) % 2 != 0 or left_needed < 0 or right_needed < 0:\n        return 0\n\n    # Total valid sequences\n    return (catalan[left_needed] * catalan[right_needed]) % MOD\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Calculate and print the result\nprint(count_bracket_sequences(n, s))\n```",
    "84": "```python\ndef can_be_sorted(n, s):\n    last_position = {}\n    color = ['0'] * n\n\n    for i in range(n):\n        if s[i] in last_position:\n            if last_position[s[i]] + 1 < i:\n                # Alternate colors for characters that have appeared before and are not adjacent\n                color[i] = '1' if color[last_position[s[i]]] == '0' else '0'\n        last_position[s[i]] = i\n\n    # Check if there are any adjacent characters that are out of order and have the same color\n    for i in range(n - 1):\n        if s[i] > s[i + 1] and color[i] == color[i + 1]:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(''.join(color))\n\n\nn = int(input())\ns = input().strip()\ncan_be_sorted(n, s)\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    target_endings = ['00', '25', '50', '75']\n    min_moves = float('inf')\n\n    for ending in target_endings:\n        last_digit, second_last_digit = ending[1], ending[0]\n\n        # Find the position of the last digit first\n        last_pos = -1\n        for i in range(length - 1, -1, -1):\n            if s[i] == last_digit:\n                last_pos = i\n                break\n\n        if last_pos == -1:\n            continue  # last digit not found\n\n        # Now find the second last digit before the last digit\n        second_last_pos = -1\n        for i in range(last_pos - 1, -1, -1):\n            if s[i] == second_last_digit:\n                second_last_pos = i\n                break\n\n        if second_last_pos == -1:\n            continue  # second last digit not found\n\n        # Calculate moves to bring the second last digit to the front of last digit\n        moves = (length - 1 - last_pos) + (last_pos - second_last_pos - 1)\n        min_moves = min(min_moves, moves)\n\n    return min_moves if min_moves != float('inf') else -1\n\n# Input reading\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "82": "```python\nn, k = map(int, input().split())\nproblems = list(map(int, input().split()))\n\nsolved = 0\n\n# Solve from the left\nwhile solved < n and problems[solved] <= k:\n    solved += 1\n\n# Solve from the right\nwhile solved < n and problems[n - 1 - (solved - 1)] <= k:\n    solved += 1\n\n# Adjust if we have counted the same problem from both ends\nif solved > n:\n    solved = n\n\n# Calculate the total unique problems solved\nleft_solved = 0\nright_solved = 0\n\n# Count solved problems from the left\nwhile left_solved < n and problems[left_solved] <= k:\n    left_solved += 1\n\n# Count solved problems from the right\nwhile right_solved < n and problems[n - 1 - right_solved] <= k:\n    right_solved += 1\n\n# Total solved problems, ensuring we don't double count\ntotal_solved = left_solved + right_solved\nif left_solved + right_solved > n:\n    total_solved = n\n\nprint(total_solved)\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Define the food consumption pattern for each day of the week\n    week_pattern = [0, 1, 2, 0, 0, 1, 2]  # 0: fish food, 1: rabbit stew, 2: chicken stake\n\n    # Calculate the number of full weeks we can sustain\n    full_weeks = min(a // 3, b // 2, c // 2)\n    days = full_weeks * 7\n\n    # Update the remaining food after full weeks\n    a -= full_weeks * 3\n    b -= full_weeks * 2\n    c -= full_weeks * 2\n\n    # Check each day of the week to start and calculate the maximum extra days\n    max_extra_days = 0\n    for start in range(7):\n        remaining_a, remaining_b, remaining_c = a, b, c\n        extra_days = 0\n        current_day = start\n\n        while True:\n            food_type = week_pattern[current_day]\n            if food_type == 0 and remaining_a > 0:\n                remaining_a -= 1\n            elif food_type == 1 and remaining_b > 0:\n                remaining_b -= 1\n            elif food_type == 2 and remaining_c > 0:\n                remaining_c -= 1\n            else:\n                break\n            extra_days += 1\n            current_day = (current_day + 1) % 7\n\n        max_extra_days = max(max_extra_days, extra_days)\n\n    return days + max_extra_days\n\n# Read input\na, b, c = map(int, input().split())\n# Calculate and print the result\nprint(max_days(a, b, c))\n```",
    "86": "```python\ndef solve_problems(n, k):\n    # Minimum sum of problems needed is the sum of first k natural numbers\n    min_sum = k * (k + 1) // 2\n    # Maximum sum possible with the constraints\n    max_sum = sum(2 ** i for i in range(k))  # 1, 2, 4, ..., 2^(k-1)\n\n    if n < min_sum or n > max_sum:\n        print(\"NO\")\n        return\n    \n    # Now we need to construct a valid solution\n    a = []\n    current = 1\n    remaining = n - min_sum  # how much we can distribute to meet n\n    \n    for i in range(k):\n        a.append(current)\n        if remaining > 0:\n            # Max we can add to current while keeping the rules\n            max_add = min(remaining, (2 * current) - current)  # must remain positive and <= 2 * current\n            current += max_add\n            remaining -= max_add\n        current += 1  # increment for next day need\n\n    print(\"YES\")\n    print(\" \".join(map(str, a)))\n\n# Read input\nn, k = map(int, input().split())\nsolve_problems(n, k)\n```",
    "85": "```python\nimport sys\n\ndef find_price(A, B):\n    for price in range(1, 10001):  # Set a reasonable upper limit for search\n        tax_8 = price * 0.08 // 1  # Using floor division for clarity\n        tax_10 = price * 0.1 // 1\n        if tax_8 == A and tax_10 == B:\n            return price\n    return -1\n\nif __name__ == \"__main__\":\n    A, B = map(int, sys.stdin.read().strip().split())\n    if 1 <= A <= B <= 100:\n        result = find_price(A, B)\n        print(result)\n    else:\n        print(-1)\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n\n    # Check all possible dimensions for the total rectangle\n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n\n            # Check for all possible dimensions of the red rectangle\n            for r_width in range(1, int(a**0.5) + 1):\n                if a % r_width == 0:\n                    r_height = a // r_width\n                    # Ensure red rectangle fits within the total rectangle\n                    if (r_width <= width and r_height <= height) or (r_height <= width and r_width <= height):\n                        # Check for all possible dimensions of the blue rectangle\n                        for b_width in range(1, int(b**0.5) + 1):\n                            if b % b_width == 0:\n                                b_height = b // b_width\n                                # Ensure blue rectangle fits within the total rectangle\n                                if (b_width <= width and b_height <= height) or (b_height <= width and b_width <= height):\n                                    # Calculate perimeter\n                                    perimeter = 2 * (width + height)\n                                    min_perimeter = min(min_perimeter, perimeter)\n\n    return min_perimeter\n\n# Read input\na, b = map(int, input().split())\nprint(minimal_perimeter(a, b))\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects: first by required rating, then by rating change (negative changes come last)\n    projects.sort(key=lambda x: (x[0], x[1] if x[1] >= 0 else float('inf')))\n\n    completed = 0\n    current_rating = r\n\n    for required, change in projects:\n        if current_rating >= required:\n            completed += 1\n            current_rating += change\n            if current_rating < 0:\n                break  # If rating goes below zero, stop\n        # There is no need for an else statement since we just skip to the next project\n\n    return completed\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(max_projects(n, r, projects))\n```",
    "92": "```python\nx = float(input().strip())\n\n# Scale x to the range of 1 to 10\nscaled_x = x * 2\n\n# Choose integers a and b such that a / b is close to scaled_x\na = int(scaled_x)\nb = 1\n\n# Adjust a and b to ensure they are within the range of 1 to 10\nif a < 1:\n    a = 1\nelif a > 10:\n    a = 10\n\n# Since b is initialized to 1, we only adjust it if a is too small\nif scaled_x > 10:\n    b = 10\nelse:\n    # Select a suitable b to get closer to scaled_x\n    b = max(1, min(10, round(a / scaled_x)))\n\nprint(a, b)\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects based on their required rating (a_i)\n    projects.sort(key=lambda x: x[0])\n    \n    current_rating = r\n    \n    for required_rating, rating_change in projects:\n        # Check if current rating is sufficient to start the project\n        if current_rating < required_rating:\n            return \"NO\"\n        # Update current rating after completing the project\n        current_rating += rating_change\n        # Ensure the rating does not drop below zero\n        if current_rating < 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input handling\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_complete_projects(n, r, projects))\n```",
    "96": "```python\nn = int(input())\nq = list(map(int, input().split()))\n\n# Calculate the prefix sums to get the permutation\np = [0] * n\nfor i in range(1, n):\n    p[i] = p[i - 1] + q[i - 1]\n\n# Normalize the permutation to be between 1 and n\nmin_p = min(p)\np = [x - min_p + 1 for x in p]\n\n# Check if p is a valid permutation\nif len(set(p)) == n and all(1 <= x <= n for x in p):\n    print(\" \".join(map(str, p)))\nelse:\n    print(-1)\n```",
    "90": "```python\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Check if we can reach n + 1 directly\nif d >= n + 1:\n    print(\"YES\")\n    print(\"0 \" + \" \".join(str(1) for _ in range(n)) + \" 2\")\nelse:\n    # Create the answer array filled with zeros\n    answer = [0] * n\n    current_position = 0\n\n    for i in range(m):\n        # Place the platform at the current position\n        answer[current_position:current_position + c[i]] = [i + 1] * c[i]\n        current_position += c[i]\n\n        # Check if we can jump from the last position of the last platform to n + 1\n        if current_position - 1 + d >= n + 1:\n            break\n\n        # Move to the next platform position with at least d gap if it's not the last platform\n        if i < m - 1:\n            current_position += d\n\n    # Final check to see if we can reach to n + 1\n    if current_position - 1 + d < n + 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, answer)))\n```",
    "98": "```python\ndef min_moves_to_product(N):\n    moves = float('inf')\n    \n    # Check every pair (i, j) such that i * j = N\n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            # Calculate moves to reach (i, j)\n            current_moves = (i - 1) + (j - 1)\n            moves = min(moves, current_moves)\n    \n    return moves\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    print(min_moves_to_product(N))\n```",
    "97": "```python\ndef min_coins_to_move_chips(n, positions):\n    even_count = sum(1 for x in positions if x % 2 == 0)\n    odd_count = n - even_count\n    return min(even_count, odd_count)\n\nn = int(input())\npositions = list(map(int, input().split()))\nprint(min_coins_to_move_chips(n, positions))\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n    \n    # Find the first occurrences of t in s\n    left = [0] * m\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n    \n    # Find the last occurrences of t in s\n    right = [0] * m\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n    \n    max_length = 0\n    \n    # Calculate the maximum removable length\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n    \n    # Consider removing from the start to the first occurrence of t[0]\n    max_length = max(max_length, left[0])\n    \n    # Consider removing from the last occurrence of t[m-1] to the end\n    max_length = max(max_length, n - right[m - 1] - 1)\n    \n    return max_length\n\n# Input\ns = input().strip()\nt = input().strip()\n\n# Output\nprint(max_removable_length(s, t))\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Initialize the string\n    s = []\n    \n    # Determine the starting character\n    if a > b:\n        s.append('0')\n        a -= 1\n    else:\n        s.append('1')\n        b -= 1\n\n    # Current segments of different characters\n    current_segments = 1\n\n    # Add alternating characters until we reach x\n    while current_segments < x and (a > 0 or b > 0):\n        if s[-1] == '0' and b > 0:\n            s.append('1')\n            b -= 1\n        elif s[-1] == '1' and a > 0:\n            s.append('0')\n            a -= 1\n        current_segments += 1\n\n    # Fill the remaining with the last character\n    last_char = s[-1]\n    remaining_count = a if last_char == '0' else b\n    s.extend([last_char] * remaining_count)\n    s.extend(['1' if last_char == '0' else '0'] * (b if last_char == '0' else a))\n\n    return ''.join(s)\n\n# Read input values\na, b, x = map(int, input().split())\n# Generate and print the binary string\nprint(construct_binary_string(a, b, x))\n```",
    "95": "```python\nn = int(input())\ns = input().strip()\nt = input().strip()\n\n# Create the resulting string with n 'a's, n 'b's, and n 'c's\nres = ['a'] * n + ['b'] * n + ['c'] * n\n\n# Function to check if the substrings s or t are present\ndef contains_substrings(res, s, t):\n    result_str = ''.join(res)\n    return s in result_str or t in result_str\n\n# Generate a valid string\ndef generate_valid_string(n, s, t):\n    # Create a simple base pattern\n    base_pattern = \"abc\" * n\n    # Check if the basic pattern contains s or t\n    if contains_substrings(base_pattern, s, t):\n        # If it does, we can try a different arrangement\n        # Attempt to create a pattern that avoids s and t\n        res = []\n        for i in range(n):\n            res.append('a')\n            res.append('b')\n            res.append('c')\n        \n        # Convert to string\n        res_str = ''.join(res)\n        if not contains_substrings(res_str, s, t):\n            return res_str\n    \n    # If the basic pattern works, return it\n    return base_pattern\n\nresult = generate_valid_string(n, s, t)\n\nif result:\n    print(\"YES\")\n    print(result)\nelse:\n    print(\"NO\")\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) or (d == 1 and n > 2) or (d > 1 and n == 1) or n > 1 + k * (d // 2):\n        return \"NO\"\n    \n    edges = []\n    \n    # Create a line with d + 1 vertices to ensure the diameter d\n    for i in range(d):\n        edges.append((i + 1, i + 2))\n    \n    # Now we have d + 1 vertices used\n    current_vertex = d + 2\n    \n    # Keep track of the degree of each vertex\n    degree = [0] * (n + 1)\n    for i in range(1, d + 2):\n        degree[i] = 1\n    \n    # Connect the remaining vertices to ensure degree constraints\n    for i in range(current_vertex, n + 1):\n        # Find a vertex to connect to that doesn't exceed degree k\n        for j in range(1, d + 2):\n            if degree[j] < k:\n                edges.append((j, i))\n                degree[j] += 1\n                break\n    \n    if len(edges) != n - 1:\n        return \"NO\"\n\n    result = [\"YES\"]\n    for edge in edges:\n        result.append(f\"{edge[0]} {edge[1]}\")\n    \n    return \"\\n\".join(result)\n\n# Read input\nn, d, k = map(int, input().split())\nresult = construct_tree(n, d, k)\nprint(result)\n```",
    "99": "```python\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\n# Maximum wins for Alice\nmax_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n\n# Minimum losses for Alice\nalice_losses = 0\nalice_losses += max(0, b1 - a3)  # Bob's rock beats Alice's paper\nalice_losses += max(0, b2 - a1)  # Bob's scissors beats Alice's rock\nalice_losses += max(0, b3 - a2)  # Bob's paper beats Alice's scissors\n\n# Minimum wins is total rounds minus Alice's losses\nmin_wins = n - alice_losses\n\nprint(min_wins, max_wins)\n```",
    "88": "```python\ndef create_palindromic_matrix(n, numbers):\n    from collections import Counter\n    \n    # Count the occurrences of each number\n    count = Counter(numbers)\n    \n    # Check the number of odd-count numbers\n    odd_count = sum(1 for v in count.values() if v % 2 != 0)\n    \n    # For an n x n matrix:\n    # - If n is odd, we can have at most 1 number with an odd count in the center\n    # - If n is even, we cannot have any number with an odd count\n    if (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n        return \"NO\"\n\n    # Create the empty matrix\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Prepare for filling the matrix\n    half = n // 2\n    center = n // 2\n\n    # Fill the matrix with pairs\n    num_list = []\n    for num, cnt in count.items():\n        num_list.extend([num] * cnt)\n    \n    # Fill the 4 quadrants\n    idx = 0\n    for i in range(half):\n        for j in range(half):\n            num = num_list[idx]\n            matrix[i][j] = num\n            matrix[i][n - j - 1] = num\n            matrix[n - i - 1][j] = num\n            matrix[n - i - 1][n - j - 1] = num\n            idx += 1\n    \n    # If n is odd, fill the center\n    if n % 2 == 1:\n        for num, cnt in count.items():\n            if cnt % 2 != 0:\n                matrix[center][center] = num\n                break\n            \n    return \"YES\", matrix\n\nn = int(input())\nnumbers = list(map(int, input().split()))\n\nresult = create_palindromic_matrix(n, numbers)\n\nif result == \"NO\":\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for row in result[1]:\n        print(' '.join(map(str, row)))\n```"
}