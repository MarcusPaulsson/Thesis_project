{
    "2": "```python\nn = int(input())\n\ndef is_lucky(year):\n    return len(set(str(year)) - {'0'}) <= 1\n\nnext_year = n + 1\nwhile not is_lucky(next_year):\n    next_year += 1\n\nprint(next_year - n)\n```",
    "4": "```python\ndef is_lucky(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef time_before(hh, mm, x, y):\n    total_minutes = (hh * 60 + mm - y * x) % (24 * 60)\n    return total_minutes // 60, total_minutes % 60\n\nx = int(input().strip())\nhh, mm = map(int, input().strip().split())\n\ny = 0\nwhile not is_lucky(*time_before(hh, mm, x, y)):\n    y += 1\n\nprint(y)\n```",
    "7": "```python\ndef days_until_empty(n, m):\n    day = 0\n    total_eaten = 0\n    \n    while n > 0:\n        day += 1\n        total_eaten += day\n        \n        # Add grains to the barn\n        n += m\n        \n        # If the barn is over capacity, it remains full\n        if n > m:\n            n = m\n        \n        # Sparrows eat grains\n        n -= total_eaten\n        \n        # Ensure n does not go below zero\n        n = max(n, 0)\n        \n    return day\n\n# Read input\nn, m = map(int, input().split())\nprint(days_until_empty(n, m))\n```",
    "0": "```python\ndef max_acordion_length(s):\n    n = len(s)\n    max_length = -1\n    left_bracket = -1\n\n    for i in range(n):\n        if s[i] == '[':\n            left_bracket = i\n        elif s[i] == ']' and left_bracket != -1:\n            # Count the number of ':' and '|' between the brackets\n            colon_count = 0\n            pipe_count = 0\n            for j in range(left_bracket + 1, i):\n                if s[j] == ':':\n                    colon_count += 1\n                elif s[j] == '|':\n                    pipe_count += 1\n            if colon_count >= 2:\n                # We can form an accordion\n                length = 2 + pipe_count + 2  # [ : | : ]\n                max_length = max(max_length, length)\n            # Reset left_bracket after processing a right bracket\n            left_bracket = -1\n\n    return max_length\n\ns = input().strip()\nresult = max_acordion_length(s)\nprint(result)\n```",
    "1": "```python\ndef max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n    max_sum = sum(int(d) for d in str_x)\n    best_number = x\n\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        # Create a new number by reducing the current digit and setting all following digits to 9\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        new_number = int(new_number)\n        if new_number > 0 and new_number <= x:\n            current_sum = sum(int(d) for d in str(new_number))\n            if current_sum > max_sum or (current_sum == max_sum and new_number > best_number):\n                max_sum = current_sum\n                best_number = new_number\n\n    return best_number\n\nx = int(input().strip())\nprint(max_digit_sum(x))\n```",
    "10": "```python\nn = int(input())\n\n# Calculate the maximum days off\nmax_days_off = (n // 7) * 2 + min(2, n % 7)\n\n# Calculate the minimum days off\nmin_days_off = 0 if n < 5 else (n // 7) * 2\n\nprint(min_days_off, max_days_off)\n```",
    "9": "```python\nd = int(input())\nn, m = map(int, input().split())\n\nsofas = []\nfor _ in range(d):\n    x1, y1, x2, y2 = map(int, input().split())\n    sofas.append((min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)))\n\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\ndef count_sofas(sofa, sofas):\n    x1, y1, x2, y2 = sofa\n    left = right = top = bottom = 0\n    \n    for other in sofas:\n        if other == sofa:\n            continue\n        ox1, oy1, ox2, oy2 = other\n        if x2 < ox1:  # sofa is to the left\n            left += 1\n        elif x1 > ox2:  # sofa is to the right\n            right += 1\n        elif y2 < oy1:  # sofa is above\n            top += 1\n        elif y1 > oy2:  # sofa is below\n            bottom += 1\n            \n    return left, right, top, bottom\n\nfor i in range(d):\n    left, right, top, bottom = count_sofas(sofas[i], sofas)\n    if (left, right, top, bottom) == (cnt_l, cnt_r, cnt_t, cnt_b):\n        print(i + 1)\n        break\nelse:\n    print(-1)\n```",
    "5": "```python\nn, pos, l, r = map(int, input().split())\n\nif l == 1 and r == n:\n    print(0)\nelse:\n    moves = 0\n    \n    if pos < l:\n        moves += l - pos  # Move to l\n        moves += 1  # Close left\n    elif pos > r:\n        moves += pos - r  # Move to r\n        moves += 1  # Close right\n    else:\n        # If pos is between l and r\n        left_moves = (pos - l) + 1  # Move to l and close left\n        right_moves = (r - pos) + 1  # Move to r and close right\n        moves = min(left_moves, right_moves)\n\n    # Close all tabs to the left of l if necessary\n    if l > 1:\n        moves += (l - 1)  # Close all tabs to the left of l\n    # Close all tabs to the right of r if necessary\n    if r < n:\n        moves += (n - r)  # Close all tabs to the right of r\n\n    print(moves)\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    # Create an array to count the coverage of each section\n    coverage = [0] * (n + 1)\n\n    # Count the coverage of each section by all painters\n    for l, r in painters:\n        for i in range(l, r + 1):\n            coverage[i] += 1\n\n    # Calculate the total painted sections with all painters\n    total_painted = sum(1 for i in range(1, n + 1) if coverage[i] > 0)\n\n    # If we hire q - 2 painters, we need to find the two painters that cover the least sections\n    contributions = []\n    for l, r in painters:\n        contribution = sum(1 for i in range(l, r + 1) if coverage[i] == 1)\n        contributions.append(contribution)\n\n    # Sort contributions in ascending order\n    contributions.sort()\n\n    # The maximum painted sections we can achieve is total painted minus the contributions of the two least contributing painters\n    if len(contributions) >= 2:\n        max_painted = total_painted - (contributions[0] + contributions[1])\n    else:\n        max_painted = total_painted\n\n    return max(max_painted, 0)  # Ensure we don't return negative painted sections\n\n# Input reading\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output the result\nprint(max_painted_sections(n, q, painters))\n```",
    "8": "```python\ndef min_tiles_to_draw(tiles):\n    from collections import defaultdict\n\n    # Parse the input tiles\n    hand = tiles.split()\n    counts = defaultdict(int)\n    suits = {'m': [], 'p': [], 's': []}\n\n    for tile in hand:\n        num = int(tile[0])\n        suit = tile[1]\n        counts[tile] += 1\n        suits[suit].append(num)\n\n    # Check for koutsu (triplet)\n    if any(count == 3 for count in counts.values()):\n        return 0  # Already has a koutsu\n\n    # Check for shuntsu (sequence)\n    for suit, numbers in suits.items():\n        unique_numbers = sorted(set(numbers))\n        for i in range(len(unique_numbers) - 2):\n            if unique_numbers[i] + 1 == unique_numbers[i + 1] and unique_numbers[i] + 2 == unique_numbers[i + 2]:\n                return 0  # Already has a shuntsu\n\n    # If no mentsu, check how many tiles are needed\n    needed = 2  # Start with the worst case (need 2 tiles)\n\n    for suit, numbers in suits.items():\n        unique_numbers = sorted(set(numbers))\n        \n        # Check for possible shuntsu with one additional tile\n        for num in unique_numbers:\n            if (num + 1 not in unique_numbers) and (num + 2 not in unique_numbers):\n                if (num + 1 <= 9) or (num - 1 >= 1):\n                    needed = min(needed, 1)  # Can form a shuntsu with one tile\n\n    return needed\n\n# Read input\ntiles = input().strip()\n# Output the result\nprint(min_tiles_to_draw(tiles))\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    segments = []\n    current_length = 0\n    \n    # Count segments of golden trophies\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n    if current_length > 0:\n        segments.append(current_length)\n    \n    # If there are no golden trophies\n    if not segments:\n        return 0\n    \n    # Calculate the maximum length without any swap\n    max_length = max(segments)\n    \n    # Check for possible improvement by swapping\n    for i in range(len(segments) - 1):\n        # If we swap a silver trophy between two segments of golden trophies\n        max_length = max(max_length, segments[i] + segments[i + 1])\n    \n    # If there is at least one silver trophy, we can swap it with a golden trophy\n    if 'S' in trophies:\n        max_length = max(max_length, max(segments) + 1)\n    \n    return max_length\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\nprint(max_beauty_after_swap(n, trophies))\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    count_a = n // a\n    count_b = n // b\n    count_ab = n // lcm(a, b)\n    \n    # Calculate chocolates if we prioritize Red or Blue\n    chocolates_if_red_first = (count_a - count_ab) * p + (count_b - count_ab) * q + count_ab * max(p, q)\n    chocolates_if_blue_first = (count_b - count_ab) * q + (count_a - count_ab) * p + count_ab * max(p, q)\n    \n    return max(chocolates_if_red_first, chocolates_if_blue_first)\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return x * (y // gcd(x, y))\n\n# Read input\nn, a, b, p, q = map(int, input().split())\nprint(max_chocolates(n, a, b, p, q))\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    \n    for query in queries:\n        n, x, blows = query\n        min_blow_count = float('inf')\n        \n        for d, h in blows:\n            if d >= x:\n                min_blow_count = min(min_blow_count, 1)\n            elif h >= d:\n                continue  # This blow is not effective as it grows more heads than it cuts\n            else:\n                # Calculate the effective reduction per blow\n                effective_reduction = d - h\n                # Calculate the number of blows needed\n                blows_needed = (x - d + effective_reduction - 1) // effective_reduction + 1\n                min_blow_count = min(min_blow_count, blows_needed)\n        \n        results.append(min_blow_count if min_blow_count != float('inf') else -1)\n    \n    return results\n\n# Example usage:\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\nresults = min_blows_to_defeat_zmei(t, queries)\nfor result in results:\n    print(result)\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelse:\n    print(n + k - t)\n```",
    "16": "```python\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\n# Calculate the balance of opening and closing brackets\nopen_brackets = cnt_1 + cnt_2\nclose_brackets = cnt_3 + cnt_4\n\n# Check if the number of opening and closing brackets can form a regular sequence\nif open_brackets == close_brackets and cnt_1 <= cnt_2 + cnt_3:\n    print(1)\nelse:\n    print(0)\n```",
    "14": "```python\ndef stack_sortable_permutation(n, k, p):\n    used = set(p)\n    remaining = [i for i in range(1, n + 1) if i not in used]\n    s = []\n    b = []\n    \n    for i in range(k):\n        while s and (not remaining or s[-1] < remaining[-1]):\n            b.append(s.pop())\n        s.append(p[i])\n    \n    while remaining:\n        while s and (not remaining or s[-1] < remaining[-1]):\n            b.append(s.pop())\n        if remaining:\n            s.append(remaining.pop())\n    \n    while s:\n        b.append(s.pop())\n    \n    if b == sorted(b):\n        return p + sorted(remaining, reverse=True)\n    else:\n        return -1\n\nn, k = map(int, input().split())\np = list(map(int, input().split()))\nresult = stack_sortable_permutation(n, k, p)\n\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    print(\"YES\" if a == b else \"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "18": "```python\ndef minimal_lexicographic_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        while t and (not u or t[-1] <= u[-1]):\n            u.append(t.pop())\n    \n    return ''.join(u)\n\ns = input().strip()\nprint(minimal_lexicographic_string(s))\n```",
    "13": "```python\nfrom collections import deque, defaultdict\nimport sys\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, k = map(int, data[0].split())\nmain_courses = list(map(int, data[1].split()))\ndependencies = defaultdict(list)\nin_degree = [0] * (n + 1)\n\n# Read dependencies\nfor i in range(1, n + 1):\n    line = list(map(int, data[i + 1].split()))\n    t_i = line[0]\n    for dep in line[1:t_i + 1]:\n        dependencies[dep].append(i)\n        in_degree[i] += 1\n\n# Topological sorting using Kahn's algorithm\nqueue = deque()\nfor i in range(1, n + 1):\n    if in_degree[i] == 0:\n        queue.append(i)\n\norder = []\npassed_courses = set()\n\nwhile queue:\n    course = queue.popleft()\n    order.append(course)\n    passed_courses.add(course)\n    for next_course in dependencies[course]:\n        in_degree[next_course] -= 1\n        if in_degree[next_course] == 0:\n            queue.append(next_course)\n\n# Check if all main courses can be passed\nif not all(course in passed_courses for course in main_courses):\n    print(-1)\nelse:\n    # Collect all courses that need to be passed\n    result_courses = set()\n    for course in main_courses:\n        result_courses.add(course)\n        for dep in dependencies[course]:\n            result_courses.add(dep)\n\n    # Ensure we have a valid order\n    result_courses = list(dict.fromkeys(order))  # Remove duplicates while preserving order\n    result_courses = [course for course in result_courses if course in passed_courses]\n\n    print(len(result_courses))\n    print(' '.join(map(str, result_courses)))\n```",
    "21": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_index = a.index(1)\nmax_index = a.index(n)\n\n# Calculate initial distance\ninitial_distance = abs(min_index - max_index)\n\n# Possible new distances after one swap\nnew_distances = [\n    abs(0 - max_index),  # Swap 1 with the first element\n    abs(n - 1 - max_index),  # Swap 1 with the last element\n    abs(min_index - 0),  # Swap n with the first element\n    abs(min_index - (n - 1))  # Swap n with the last element\n]\n\n# The maximum distance we can achieve\nmax_distance = max(new_distances)\n\n# Output the maximum distance\nprint(max(max_distance, initial_distance))\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return minutes_passed\n\ntime_input = input().strip()\nhh, mm = map(int, time_input.split(':'))\nresult = next_palindrome_time(hh, mm)\nprint(result)\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror_chars = {\n        'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M', \n        'O': 'O', 'p': 'q', 'q': 'p', 'T': 'T', 'U': 'U', 'v': 'v', \n        'W': 'W', 'X': 'X', 'Y': 'Y', 'o': 'o', 'x': 'x'\n    }\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        if s[i] not in mirror_chars or mirror_chars[s[i]] != s[n - 1 - i]:\n            print(\"NIE\")\n            return\n    print(\"TAK\")\n\ns = input().strip()\nis_s_palindrome(s)\n```",
    "19": "```python\ndef check_records(test_cases):\n    results = []\n    for case in test_cases:\n        n, records = case\n        valid = True\n        \n        for i in range(n):\n            p_i, c_i = records[i]\n            if i > 0:\n                p_prev, c_prev = records[i - 1]\n                if p_i < p_prev or c_i < c_prev or c_i > p_i:\n                    valid = False\n                    break\n                if (p_i - p_prev) < (c_i - c_prev):\n                    valid = False\n                    break\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Input reading\nT = int(input())\ntest_cases = []\nfor _ in range(T):\n    n = int(input())\n    records = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, records))\n\n# Check records and print results\nresults = check_records(test_cases)\nfor result in results:\n    print(result)\n```",
    "27": "```python\nn = int(input())\ns = input()\n\nmin_operations = n  # Start with the maximum operations (typing all characters)\n\nfor i in range(1, n // 2 + 1):\n    if s[:i] == s[i:2*i]:  # Check if the prefix can be copied\n        # Calculate operations: type i characters, copy, and type the rest\n        operations = i + 1 + (n - 2 * i)\n        min_operations = min(min_operations, operations)\n\n# If the string length is odd, we need to consider typing all characters\nif n % 2 == 1:\n    min_operations = min(min_operations, n)\n\nprint(min_operations)\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a, b):\n    from itertools import permutations\n    \n    a_str = str(a)\n    b_str = str(b)\n    \n    # Generate all unique permutations of the digits of a\n    permuted_numbers = set(int(''.join(p)) for p in permutations(a_str))\n    \n    # Filter out numbers that are greater than b and have the same length as a\n    valid_numbers = [num for num in permuted_numbers if num <= b and len(str(num)) == len(a_str) and str(num)[0] != '0']\n    \n    # Return the maximum valid number\n    return max(valid_numbers)\n\n# Input reading\na = int(input().strip())\nb = int(input().strip())\n\n# Output the result\nprint(max_permutation_not_exceeding(a, b))\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = [name for name, type_ in files if type_ == '1']\nregulars = [name for name, type_ in files if type_ == '0']\n\nmoves = []\n# Renaming examples to 1, 2, ..., e\nfor i, name in enumerate(examples):\n    moves.append(f\"move {name} {i + 1}\")\n\n# Renaming regular tests to e + 1, e + 2, ..., n\nfor i, name in enumerate(regulars):\n    moves.append(f\"move {name} {len(examples) + i + 1}\")\n\nprint(len(moves))\nfor move in moves:\n    print(move)\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    if k > n * n or (k % 2 != 0 and n % 2 == 0):\n        return -1\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k >= 2 and i != n - 1 - i:\n            matrix[i][i] = 1\n            matrix[n - 1 - i][n - 1 - i] = 1\n            k -= 2\n        elif k >= 1 and i == n - 1 - i:\n            matrix[i][i] = 1\n            k -= 1\n            \n        if k == 0:\n            break\n    \n    if k > 0:\n        return -1\n    \n    return matrix\n\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "24": "```python\ndef can_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # horizontal, vertical, diagonal, anti-diagonal\n    n = 10\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                # Temporarily place 'X' in the empty cell\n                board[i][j] = 'X'\n                \n                # Check all directions\n                for dx, dy in directions:\n                    count = 1  # Count the placed 'X'\n                    \n                    # Check in the positive direction\n                    x, y = i + dx, j + dy\n                    while 0 <= x < n and 0 <= y < n and board[x][y] == 'X':\n                        count += 1\n                        x += dx\n                        y += dy\n                    \n                    # Check in the negative direction\n                    x, y = i - dx, j - dy\n                    while 0 <= x < n and 0 <= y < n and board[x][y] == 'X':\n                        count += 1\n                        x -= dx\n                        y -= dy\n                    \n                    # If count reaches 5, Alice can win\n                    if count >= 5:\n                        return 'YES'\n                \n                # Restore the empty cell\n                board[i][j] = '.'\n\n    return 'NO'\n\n# Read input\nboard = [input().strip() for _ in range(10)]\nprint(can_win(board))\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # The number of traps needed is equal to m - 1 (for rooms 1 to m-1) + 1 (for room 0)\n    return m - 1\n\nm, x = map(int, input().split())\nprint(minimum_traps(m, x))\n```",
    "26": "```python\nimport math\n\n# Read input\nx, y, z = map(float, input().split())\n\n# Define the expressions with their corresponding labels\nexpressions = [\n    (x**(y**z), \"x^y^z\"),\n    (x**(z**y), \"x^z^y\"),\n    ((x**y)**z, \"(x^y)^z\"),\n    ((x**z)**y, \"(x^z)^y\"),\n    (y**(x**z), \"y^x^z\"),\n    (y**(z**x), \"y^z^x\"),\n    ((y**x)**z, \"(y^x)^z\"),\n    ((y**z)**x, \"(y^z)^x\"),\n    (z**(x**y), \"z^x^y\"),\n    (z**(y**x), \"z^y^x\"),\n    ((z**x)**y, \"(z^x)^y\"),\n    ((z**y)**x, \"(z^y)^x\"),\n]\n\n# Find the maximum value and its index\nmax_value = -math.inf\nmax_index = -1\n\nfor i, (value, expr) in enumerate(expressions):\n    if value > max_value:\n        max_value = value\n        max_index = i\n\n# Output the corresponding expression\nprint(expressions[max_index][1])\n```",
    "32": "```python\nn = int(input())\nposition = 0  # Position in kilometers from the North Pole (0 at North Pole, 20000 at South Pole)\n\nvalid = True\n\nfor _ in range(n):\n    t, direction = input().split()\n    t = int(t)\n\n    if direction == \"North\":\n        if position == 0 or position + t > 20000:\n            valid = False\n            break\n        position += t\n    elif direction == \"South\":\n        if position == 20000 or position - t < 0:\n            valid = False\n            break\n        position -= t\n    elif direction in [\"West\", \"East\"]:\n        # Moving West or East does not change the position in terms of North/South\n        continue\n\n# Check if the journey is valid and ends at the North Pole\nif valid and position == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    diff = abs(sum_first - sum_second)\n    \n    # Calculate the maximum possible changes\n    changes = []\n    if sum_first > sum_second:\n        changes = [9 - digit for digit in second_half]\n    else:\n        changes = [9 - digit for digit in first_half]\n    \n    changes.sort(reverse=True)\n    \n    count = 0\n    for change in changes:\n        diff -= change\n        count += 1\n        if diff <= 0:\n            break\n            \n    return count\n\nticket = input().strip()\nprint(min_replacements_to_lucky(ticket))\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    def can_distribute(x):\n        plates_for_a = (a + x - 1) // x  # ceil(a / x)\n        plates_for_b = (b + x - 1) // x  # ceil(b / x)\n        return plates_for_a + plates_for_b <= n\n\n    low, high = 1, max(a, b)\n    while low < high:\n        mid = (low + high + 1) // 2\n        if can_distribute(mid):\n            low = mid\n        else:\n            high = mid - 1\n    return low\n\nn, a, b = map(int, input().split())\nprint(max_min_pieces(n, a, b))\n```",
    "37": "```python\ndef can_deal_exact_damage(a, b, c):\n    for i in range(c // a + 1):\n        if (c - a * i) >= 0 and (c - a * i) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\na, b, c = map(int, input().split())\nprint(can_deal_exact_damage(a, b, c))\n```",
    "33": "```python\ndef count_integers(a1, b1, a2, b2, L, R):\n    from math import gcd\n\n    # Calculate the least common multiple of the step sizes\n    step = abs(a1 * a2 // gcd(a1, a2))\n    \n    # Determine the starting point based on the offsets\n    start = max(b1, b2)\n    offset = abs(b1 - b2)\n\n    # Adjust start to the first valid x in the range\n    if (start - offset) % step != 0:\n        start += step - (start - offset) % step\n\n    # Ensure start is at least L\n    if start < L:\n        start += ((L - start + step - 1) // step) * step\n\n    # Count valid integers in the range [L, R]\n    if start > R:\n        return 0\n\n    return (R - start) // step + 1\n\n# Input reading\na1, b1, a2, b2, L, R = map(int, input().split())\n# Output the result\nprint(count_integers(a1, b1, a2, b2, L, R))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ns = input().strip()\n\nif not is_palindrome(s):\n    print(len(s))\nelse:\n    # Check for the longest non-palindrome substring\n    if len(set(s)) == 1:  # All characters are the same\n        print(0)\n    else:\n        print(len(s) - 1)  # The longest non-palindrome substring will be of length len(s) - 1\n```",
    "36": "```python\ndef hexagonal_coordinates(n):\n    if n == 0:\n        return (0, 0)\n    \n    layer = 0\n    moves_in_layer = 0\n    \n    # Find the layer where the nth move is located\n    while n > moves_in_layer + 6 * layer:\n        moves_in_layer += 6 * layer\n        layer += 1\n    \n    # Calculate the position in the current layer\n    x, y = layer, 0\n    position_in_layer = n - moves_in_layer\n    \n    # Determine the coordinates based on the position in the layer\n    if position_in_layer < layer:\n        x -= position_in_layer\n    elif position_in_layer < 2 * layer:\n        x -= layer\n        y += position_in_layer - layer\n    elif position_in_layer < 3 * layer:\n        y += layer\n        x += position_in_layer - 2 * layer\n    elif position_in_layer < 4 * layer:\n        x += layer\n        y -= position_in_layer - 3 * layer\n    elif position_in_layer < 5 * layer:\n        y -= layer\n        x -= position_in_layer - 4 * layer\n    else:\n        x -= position_in_layer - 5 * layer\n    \n    return (x, y)\n\nn = int(input())\nx, y = hexagonal_coordinates(n)\nprint(x, y)\n```",
    "35": "```python\ndef is_valid_flag(n, m, field):\n    colors = set()\n    stripe_height = None\n    current_color = None\n    current_height = 0\n\n    for i in range(n):\n        row = field[i]\n        if len(set(row)) != 1 or row[0] not in {'R', 'G', 'B'}:\n            return \"NO\"\n        \n        if current_color is None:\n            current_color = row[0]\n            current_height = 1\n        elif row[0] == current_color:\n            current_height += 1\n        else:\n            colors.add(current_color)\n            if stripe_height is None:\n                stripe_height = current_height\n            elif current_height != stripe_height:\n                return \"NO\"\n            current_color = row[0]\n            current_height = 1\n\n    colors.add(current_color)\n    if current_height != stripe_height:\n        return \"NO\"\n\n    return \"YES\" if len(colors) == 3 else \"NO\"\n\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\nprint(is_valid_flag(n, m, field))\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    m0, x0, x1 = m, 0, 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef birthday_paradox(n, k):\n    MOD = 1000003\n    days = 1 << n  # 2^n\n    if k > days:\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the probability of no collision\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator = (numerator * (days - i)) % MOD\n        denominator = (denominator * days) % MOD\n\n    # Probability of at least one collision\n    A = (denominator - numerator) % MOD\n    B = denominator\n\n    # Reduce A/B to irreducible form\n    common_gcd = gcd(A, B)\n    A //= common_gcd\n    B //= common_gcd\n\n    return A % MOD, B % MOD\n\n# Input reading\nn, k = map(int, input().split())\nA, B = birthday_paradox(n, k)\nprint(A, B)\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if any participant's rating has changed\nif any(a != b for a, b in ratings):\n    print(\"rated\")\nelse:\n    # Check if the ratings are in non-increasing order\n    if any(ratings[i][0] < ratings[i + 1][0] for i in range(n - 1)):\n        print(\"unrated\")\n    else:\n        print(\"maybe\")\n```",
    "41": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nd = [float('inf')] * n\n\n# First pass: from left to right\nfor i in range(n):\n    if a[i] == 0:\n        d[i] = 0\n    elif i > 0:\n        d[i] = d[i - 1] + 1\n\n# Second pass: from right to left\nfor i in range(n - 1, -1, -1):\n    if i < n - 1:\n        d[i] = min(d[i], d[i + 1] + 1)\n\nprint(' '.join(map(str, d)))\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n\n    len_s = len(s)\n    total_count = 0\n    seen = set()\n\n    # Generate all binary strings of length n\n    for t in product('01', repeat=n):\n        t = ''.join(t)\n        # Check if s is a substring of any cyclic shift of t\n        if any(s in t[i:] + t[:i] for i in range(n)):\n            # Store the canonical form of the cyclic string to avoid duplicates\n            min_rotation = min(t[i:] + t[:i] for i in range(n))\n            seen.add(min_rotation)\n\n    return len(seen)\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_cyclic_strings(n, s))\n```",
    "38": "```python\ndef can_be_same_track(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between consecutive barriers for Kefa\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    # Calculate the distances between consecutive barriers for Sasha\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Check if kefa_diffs can be rotated to match sasha_diffs\n    double_kefa_diffs = kefa_diffs * 2\n    \n    # Use slicing to check for a match\n    for i in range(n):\n        if double_kefa_diffs[i:i+n] == sasha_diffs:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_be_same_track(n, L, kefa_distances, sasha_distances))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    digit_length = 1\n    count = 9\n    start = 1\n\n    while k > digit_length * count:\n        k -= digit_length * count\n        digit_length += 1\n        count *= 10\n        start *= 10\n\n    start += (k - 1) // digit_length\n    num_str = str(start)\n    return int(num_str[(k - 1) % digit_length])\n\nk = int(input())\nprint(find_kth_digit(k))\n```",
    "46": "```python\ndef count_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n    \n    # Count occurrences of each remainder when divided by 5 for x\n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n        \n    # Count occurrences of each remainder when divided by 5 for y\n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n        \n    result = 0\n    # Calculate the number of valid pairs\n    for i in range(5):\n        result += count_x[i] * count_y[(5 - i) % 5]\n        \n    return result\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))\n```",
    "43": "```python\nimport sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    vectors = []\n    \n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().strip().split())\n        angle = math.atan2(y, x)\n        vectors.append((angle, i + 1))  # Store angle and index (1-based)\n    \n    # Sort vectors by angle\n    vectors.sort()\n    \n    min_angle = float('inf')\n    best_pair = (0, 0)\n    \n    # Check adjacent pairs in the sorted list\n    for i in range(n):\n        angle1, index1 = vectors[i]\n        angle2, index2 = vectors[(i + 1) % n]  # Wrap around\n        \n        # Calculate the non-oriented angle\n        angle_diff = abs(angle2 - angle1)\n        angle_diff = min(angle_diff, 2 * math.pi - angle_diff)  # Non-oriented angle\n        \n        if angle_diff < min_angle:\n            min_angle = angle_diff\n            best_pair = (index1, index2)\n    \n    print(best_pair[0], best_pair[1])\n\nif __name__ == \"__main__\":\n    main()\n```",
    "44": "```python\ndef minimal_time(d, k, a, b, t):\n    total_time = float('inf')\n    \n    # Calculate time if using the car for all full segments\n    full_segments = d // k\n    remaining_distance = d % k\n\n    # Time if using the car for all full segments\n    time_using_car = full_segments * (k * a + t) + remaining_distance * a\n    if full_segments > 0:\n        time_using_car -= t  # Remove the last repair time if we don't need it\n\n    # Time if walking the entire distance\n    time_walking = d * b\n\n    # Compare the time using car and walking\n    total_time = min(time_using_car, time_walking)\n\n    # Consider mixed strategies\n    for i in range(full_segments + 1):\n        time = i * (k * a + t) + (d - i * k) * b\n        if i > 0:\n            time -= t  # Remove the last repair time if we don't need it\n        total_time = min(total_time, time)\n\n    return total_time\n\n# Input reading\nd, k, a, b, t = map(int, input().split())\nprint(minimal_time(d, k, a, b, t))\n```",
    "48": "```python\ndef kth_largest_in_multiplication_table(n, m, k):\n    left, right = 1, n * m\n    \n    while left < right:\n        mid = (left + right) // 2\n        count = sum(min(mid // i, m) for i in range(1, n + 1))\n        \n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return left\n\nn, m, k = map(int, input().split())\nprint(kth_largest_in_multiplication_table(n, m, k))\n```",
    "51": "```python\nfrom collections import Counter\nimport sys\n\ndef find_x_y(divisors):\n    count = Counter(divisors)\n    unique_divisors = list(count.keys())\n    \n    # Initialize x and y\n    x = 1\n    y = 1\n    \n    # Calculate x and y based on the counts of divisors\n    for d in unique_divisors:\n        if count[d] == 2:\n            x *= d\n            y *= d\n        elif count[d] == 1:\n            x *= d\n    \n    return x, y\n\nn = int(input().strip())\ndivisors = list(map(int, input().strip().split()))\n\nx, y = find_x_y(divisors)\nprint(x, y)\n```",
    "54": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_a = min(a)\nmax_a = max(a)\n\nif min_a == max_a:\n    print(0)\nelse:\n    diff = max_a - min_a\n    if diff % 2 == 0:\n        print(diff // 2)\n    else:\n        print(-1)\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef reachable_count(n):\n    reachable = set()\n    current = n\n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    return len(reachable)\n\nn = int(input())\nprint(reachable_count(n))\n```",
    "47": "```python\ndef max_beauty_with_subarray(n, x, a):\n    # Calculate the maximum sum of any subarray (Kadane's algorithm)\n    def kadane(arr):\n        max_ending_here = max_so_far = 0\n        for value in arr:\n            max_ending_here = max(0, max_ending_here + value)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    # Original beauty of the array\n    original_beauty = kadane(a)\n\n    # If x is 0, we can only take the original beauty\n    if x == 0:\n        return original_beauty\n\n    # Calculate the maximum beauty after multiplying a subarray by x\n    max_increase = 0\n    current_sum = 0\n    for i in range(n):\n        current_sum += a[i]\n        max_increase = max(max_increase, current_sum * x)\n        if current_sum < 0:\n            current_sum = 0\n\n    # Calculate the maximum beauty considering the increase\n    max_beauty = original_beauty + max_increase\n\n    return max_beauty\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_beauty_with_subarray(n, x, a))\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Minimum sum of the first k positive integers\n    min_sum = k * (k + 1) // 2\n    \n    if n < min_sum:\n        return -1\n    \n    # The maximum GCD we can use is n // k\n    max_gcd = n // k\n    \n    # We can construct the sequence\n    sequence = [(i + 1) for i in range(k)]\n    \n    # Calculate the current sum of the sequence\n    current_sum = sum(sequence)\n    \n    # Calculate the difference needed to reach n\n    difference = n - current_sum\n    \n    # Distribute the difference evenly to maximize GCD\n    for i in range(k):\n        sequence[i] += difference // k\n    \n    # Distribute any remaining difference to the last elements\n    for i in range(difference % k):\n        sequence[k - 1 - i] += 1\n    \n    # Scale the sequence by the maximum GCD\n    sequence = [x * max_gcd for x in sequence]\n    \n    return sequence\n\n# Input reading\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    from itertools import combinations\n\n    max_half = m // 2\n    total_sum = 0\n\n    for row in matrix:\n        row.sort(reverse=True)\n        best_sum = 0\n        \n        # Check all combinations of elements up to max_half\n        for count in range(max_half + 1):\n            for comb in combinations(row, count):\n                current_sum = sum(comb)\n                if current_sum % k == 0:\n                    best_sum = max(best_sum, current_sum)\n        \n        total_sum += best_sum\n\n    return total_sum\n\n# Input reading\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_sum_divisible_by_k(n, m, k, matrix))\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = -1\n    result = []\n    moves = []\n\n    while left <= right:\n        if a[left] > last_taken and (a[right] <= last_taken or a[left] < a[right]):\n            last_taken = a[left]\n            result.append(last_taken)\n            moves.append('L')\n            left += 1\n        elif a[right] > last_taken:\n            last_taken = a[right]\n            result.append(last_taken)\n            moves.append('R')\n            right -= 1\n        else:\n            break\n\n    print(len(result))\n    print(''.join(moves))\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\nlongest_increasing_sequence(n, a)\n```",
    "59": "```python\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# Create the target remainder pattern\ntarget_remainder = ['0'] * x\ntarget_remainder[y] = '1'  # Set the y-th position to 1 for remainder 10^y\n\n# Count the number of changes needed\nchanges = 0\nfor i in range(x):\n    if number[n - 1 - i] != target_remainder[x - 1 - i]:\n        changes += 1\n\nprint(changes)\n```",
    "61": "```python\nn = int(input())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\nmax_number = a\nchanged = False\nstart = 0\n\nfor i in range(n):\n    current_digit = int(a[i])\n    mapped_digit = f[current_digit - 1]\n    \n    if not changed and mapped_digit > current_digit:\n        changed = True\n        start = i\n    elif changed and mapped_digit < current_digit:\n        break\n\nif changed:\n    result = a[:start] + ''.join(str(f[int(d) - 1]) for d in a[start:i]) + a[i:]\n    max_number = max(max_number, result)\n\nprint(max(max_number, a))\n```",
    "58": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nfrom collections import defaultdict\n\ncoloring = [0] * n\ncolor_used = defaultdict(list)\n\nfor i in range(n):\n    color_used[a[i]].append(i)\n\nif len(color_used) < k:\n    print(\"NO\")\nelse:\n    color = 1\n    for indices in color_used.values():\n        if len(indices) < k:\n            # If there are not enough distinct colors available for this group\n            for index in indices:\n                coloring[index] = color\n                color = (color % k) + 1\n        else:\n            # Assign colors from 1 to k for the first k distinct elements\n            for j in range(k):\n                coloring[indices[j]] = j + 1\n            # Continue coloring the rest with the available colors\n            for index in indices[k:]:\n                coloring[index] = (j + 1) % k + 1\n\n    print(\"YES\")\n    print(\" \".join(map(str, coloring)))\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph):\n    visited = {start: 0}\n    queue = deque([start])\n    farthest_node = start\n    max_distance = 0\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > max_distance:\n                    max_distance = visited[neighbor]\n                    farthest_node = neighbor\n                    \n    return farthest_node, max_distance\n\ndef find_max_edges(n, edges):\n    graph = defaultdict(list)\n    \n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Step 1: Find the farthest node from an arbitrary node (1)\n    farthest_node_from_start, _ = bfs(1, graph)\n    \n    # Step 2: Find the farthest node from the previously found farthest node\n    opposite_node, diameter_length = bfs(farthest_node_from_start, graph)\n    \n    # Step 3: Get the path from farthest_node_from_start to opposite_node\n    path = []\n    def get_path(node, parent):\n        if node == opposite_node:\n            path.append(node)\n            return True\n        for neighbor in graph[node]:\n            if neighbor != parent and get_path(neighbor, node):\n                path.append(node)\n                return True\n        return False\n    \n    get_path(farthest_node_from_start, -1)\n    path.reverse()\n    \n    # Step 4: Choose three vertices from the path\n    if len(path) >= 3:\n        a, b, c = path[0], path[len(path) // 2], path[-1]\n    else:\n        a, b, c = path[0], path[1], path[2]\n    \n    # The number of edges in the union of paths\n    res = diameter_length + 1\n    \n    return res, a, b, c\n\n# Input reading\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\n# Find the result\nresult = find_max_edges(n, edges)\n\n# Output the result\nprint(result[0])\nprint(result[1], result[2], result[3])\n```",
    "63": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmax_a = max(a)\nmin_a = min(a)\n\n# Count occurrences of max and min\ncount_max = a.count(max_a)\ncount_min = a.count(min_a)\n\n# Calculate possible instabilities\nif count_max > 1:\n    instability_remove_max = max_a - min_a\nelse:\n    instability_remove_max = max(a[:-1]) - min(a[:-1])\n\nif count_min > 1:\n    instability_remove_min = max_a - min_a\nelse:\n    instability_remove_min = max(a[1:]) - min(a[1:])\n\n# The minimum instability after removing one element\nresult = min(instability_remove_max, instability_remove_min)\nprint(result)\n```",
    "60": "```python\ndef has_palindrome_subsequence(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        found = False\n        last_occurrence = {}\n        for i in range(n):\n            if a[i] in last_occurrence:\n                # Check if the distance between the same elements is at least 2\n                if i - last_occurrence[a[i]] >= 2:\n                    found = True\n                    break\n            last_occurrence[a[i]] = i\n        results.append(\"YES\" if found else \"NO\")\n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Get results\nresults = has_palindrome_subsequence(t, test_cases)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "55": "```python\ndef can_see_white_sheet(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n    # Check if there is any part of the white sheet that is not covered by both black sheets\n    # Check the four corners of the white sheet\n    corners = [\n        (x1, y1),  # bottom left\n        (x1, y2),  # top left\n        (x2, y1),  # bottom right\n        (x2, y2)   # top right\n    ]\n    \n    for cx, cy in corners:\n        # Check if the corner is outside the white sheet and outside both black sheets\n        if (cx < x1 or cx > x2 or cy < y1 or cy > y2) and not (x3 < cx < x4 and y3 < cy < y4) and not (x5 < cx < x6 and y5 < cy < y6):\n            return \"YES\"\n    \n    # Check the edges of the white sheet\n    edges = [\n        (x1, y1 - 1),  # below bottom edge\n        (x1, y2 + 1),  # above top edge\n        (x1 - 1, y1),  # left of left edge\n        (x2 + 1, y1)   # right of right edge\n    ]\n    \n    for ex, ey in edges:\n        if not (x3 < ex < x4 and y3 < ey < y4) and not (x5 < ex < x6 and y5 < ey < y6):\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Output result\nprint(can_see_white_sheet(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6))\n```",
    "65": "```python\nn, m = map(int, input().split())\n\nif m % n != 0:\n    print(-1)\nelse:\n    ratio = m // n\n    count_2 = 0\n    count_3 = 0\n    \n    while ratio % 2 == 0:\n        ratio //= 2\n        count_2 += 1\n    \n    while ratio % 3 == 0:\n        ratio //= 3\n        count_3 += 1\n    \n    if ratio == 1:\n        print(count_2 + count_3)\n    else:\n        print(-1)\n```",
    "66": "```python\ndef min_length_string(n, k, t):\n    # Find the longest suffix of t that is also a prefix\n    overlap_length = 0\n    for i in range(1, n):\n        if t.startswith(t[i:]):\n            overlap_length = n - i\n            break\n    \n    # Construct the result string\n    result = t + (t[overlap_length:] * (k - 1))\n    return result\n\n# Read input\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the result and print it\nprint(min_length_string(n, k, t))\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        min_moves = float('inf')\n        best_triplet = (0, 0, 0)\n\n        # Iterate over possible values for A\n        for A in range(1, a + 1):\n            # Iterate over possible values for B that are multiples of A\n            for B in range(max(A, b), c + 1):\n                if B % A == 0:\n                    # Iterate over possible values for C that are multiples of B\n                    for C in range(max(B, c), c + 1):\n                        if C % B == 0:\n                            moves = abs(A - a) + abs(B - b) + abs(C - c)\n                            if moves < min_moves:\n                                min_moves = moves\n                                best_triplet = (A, B, C)\n\n        results.append((min_moves, best_triplet))\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations(t, test_cases)\n\n# Output results\nfor moves, triplet in results:\n    print(moves)\n    print(*triplet)\n```",
    "67": "```python\nn = int(input())\na = list(map(int, input().split()))\n\ntotal_sum = sum(a)\nnice_indices = []\n\n# Count occurrences of each element for quick lookup\nfrom collections import Counter\ncount = Counter(a)\n\nfor i in range(n):\n    target = total_sum - a[i]\n    if target % 2 == 0:\n        target //= 2\n        if target in count:\n            # Check if we can form the target by removing a[i]\n            if (target != a[i] and count[target] > 0) or (target == a[i] and count[target] > 1):\n                nice_indices.append(i + 1)\n\nprint(len(nice_indices))\nif nice_indices:\n    print(\" \".join(map(str, nice_indices)))\n```",
    "71": "```python\ndef count_set_bits(n):\n    return bin(n).count('1')\n\nif __name__ == \"__main__\":\n    a = int(input().strip())\n    if 1 <= a <= 64:\n        print(count_set_bits(a))\n    else:\n        raise ValueError(\"Input must be between 1 and 64 inclusive.\")\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    days = [0] * n\n    exam_days = set()\n\n    for i in range(m):\n        s, d, c = exams[i]\n        exam_days.add(d - 1)  # Store exam days (0-indexed)\n\n    preparation_days = [0] * m  # Count of preparation days for each exam\n    for i in range(m):\n        s, d, c = exams[i]\n        for j in range(s - 1, d - 1):  # s-1 to d-2 (0-indexed)\n            if preparation_days[i] < c and days[j] == 0:\n                days[j] = i + 1  # Mark preparation for exam i\n                preparation_days[i] += 1\n\n    for i in range(m):\n        if preparation_days[i] < exams[i][2]:  # If not enough preparation days\n            return -1\n\n    for i in range(n):\n        if days[i] == 0:\n            if i in exam_days:\n                days[i] = m + 1  # Mark exam day\n            else:\n                days[i] = 0  # Rest day\n\n    return days\n\n# Input reading\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the schedule\nresult = schedule_exams(n, m, exams)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "70": "```python\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Convert start and end times to minutes\nstart_minutes = h1 * 60 + m1\nend_minutes = h2 * 60 + m2\n\n# Calculate midpoint in minutes\nmid_minutes = (start_minutes + end_minutes) // 2\n\n# Convert back to hours and minutes\nh3 = mid_minutes // 60\nm3 = mid_minutes % 60\n\n# Print result in hh:mm format\nprint(f\"{h3:02}:{m3:02}\")\n```",
    "73": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmax_height = max(a)\ntotal_bricks_needed = sum(max_height - height for height in a)\n\n# Check if the total number of bricks needed is even\nif total_bricks_needed % 2 == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import defaultdict\n\n    # Count the frequency of each character\n    freq = defaultdict(int)\n    for char in s:\n        freq[char] += 1\n\n    # Calculate the number of unique subsequences and their costs\n    unique_subsequences = 0\n    costs = []\n\n    # Generate all possible subsequences and their costs\n    for length in range(n + 1):\n        for char, count in freq.items():\n            if count > 0:\n                # The cost to create a subsequence of this length\n                cost = n - length\n                # Count how many unique subsequences of this length can be formed\n                count_of_subsequences = min(count, 2 ** length - 1)\n                unique_subsequences += count_of_subsequences\n                costs.extend([cost] * count_of_subsequences)\n\n    # If we cannot form at least k unique subsequences\n    if unique_subsequences < k:\n        return -1\n\n    # Sort costs and sum the minimum k costs\n    costs.sort()\n    return sum(costs[:k])\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "77": "```python\nn = int(input())\ntotal_sum = n * (n + 1) // 2\nprint(total_sum % 2)\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    unique_subsequences = set()\n    total_cost = 0\n\n    # Generate all unique subsequences\n    for i in range(1 << n):\n        subsequence = []\n        for j in range(n):\n            if i & (1 << j):\n                subsequence.append(s[j])\n        unique_subsequence = ''.join(subsequence)\n        if unique_subsequence not in unique_subsequences:\n            unique_subsequences.add(unique_subsequence)\n            total_cost += n - len(unique_subsequence)\n\n    if len(unique_subsequences) < k:\n        return -1\n    else:\n        return total_cost\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result and print it\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "81": "```python\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\n# Sort strings by length\nstrings.sort(key=len)\n\n# Check if the order is valid\nfor i in range(1, n):\n    if strings[i-1] not in strings[i]:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")\n    print(\"\\n\".join(strings))\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n    \n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    if len(graph[1]) < D:\n        print(\"NO\")\n        return\n    \n    # Start building the spanning tree\n    spanning_tree_edges = []\n    visited = [False] * (n + 1)\n    visited[1] = True\n    degree = 0\n    \n    # First, connect D edges from vertex 1\n    for neighbor in graph[1]:\n        if degree < D:\n            spanning_tree_edges.append((1, neighbor))\n            visited[neighbor] = True\n            degree += 1\n        else:\n            break\n    \n    # If we couldn't connect D edges, return NO\n    if degree < D:\n        print(\"NO\")\n        return\n    \n    # Use BFS or DFS to add the remaining edges\n    queue = deque()\n    for neighbor in graph[1]:\n        if visited[neighbor]:\n            continue\n        queue.append(neighbor)\n    \n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                spanning_tree_edges.append((current, neighbor))\n                queue.append(neighbor)\n                if len(spanning_tree_edges) == n - 1:\n                    break\n        if len(spanning_tree_edges) == n - 1:\n            break\n    \n    if len(spanning_tree_edges) == n - 1:\n        print(\"YES\")\n        for u, v in spanning_tree_edges:\n            print(u, v)\n    else:\n        print(\"NO\")\n\n# Example usage:\n# n, m, D = map(int, input().split())\n# edges = [tuple(map(int, input().split())) for _ in range(m)]\n# find_spanning_tree(n, m, D, edges)\n```",
    "76": "```python\ndef can_construct_square(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Check for symmetric pairs\n        can_form_symmetric = False\n        for i in range(n):\n            for j in range(n):\n                if tiles[i][1][0] == tiles[j][0][1] and tiles[i][1][1] == tiles[j][0][0]:\n                    can_form_symmetric = True\n                    break\n            if can_form_symmetric:\n                break\n        \n        results.append(\"YES\" if can_form_symmetric else \"NO\")\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        top = list(map(int, input().split()))\n        bottom = list(map(int, input().split()))\n        tiles.append((top, bottom))\n    test_cases.append((n, m, tiles))\n\n# Get results\nresults = can_construct_square(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    from collections import defaultdict\n\n    # Step 1: Determine the positions of each character\n    positions = defaultdict(list)\n    for i, char in enumerate(s):\n        positions[char].append(i)\n\n    # Step 2: Create a color array\n    color = [0] * n\n    current_color = 1\n\n    # Step 3: Assign colors based on the positions\n    last_position = -1\n    for char in sorted(positions.keys()):\n        for pos in positions[char]:\n            if last_position == -1 or pos > last_position:\n                color[pos] = current_color\n                last_position = pos\n            else:\n                # If we encounter a position that is not greater, we need a new color\n                current_color += 1\n                color[pos] = current_color\n                last_position = pos\n\n    # Step 4: Output the result\n    print(current_color)\n    print(' '.join(map(str, color)))\n\n# Example usage:\nn = int(input())\ns = input().strip()\nmin_colors_to_sort(n, s)\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n\n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            for w, h in [(width, height), (height, width)]:\n                if (a <= w * h and (a % w == 0 and a // w <= h)) or (b <= w * h and (b % w == 0 and b // w <= h)):\n                    perimeter = 2 * (w + h)\n                    min_perimeter = min(min_perimeter, perimeter)\n\n    return min_perimeter\n\na, b = map(int, input().split())\nprint(minimal_perimeter(a, b))\n```",
    "85": "```python\nimport sys\nimport math\n\ndef find_price(A, B):\n    for price in range(1, 10000):  # Arbitrarily chosen upper limit for price\n        tax_8 = math.floor(price * 0.08)\n        tax_10 = math.floor(price * 0.10)\n        \n        if tax_8 == A and tax_10 == B:\n            return price\n    return -1\n\nif __name__ == \"__main__\":\n    A, B = map(int, sys.stdin.read().strip().split())\n    if 1 <= A <= B <= 100:  # Validate input constraints\n        result = find_price(A, B)\n        print(result)\n    else:\n        print(-1)  # Print -1 if input constraints are not met\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    left = [segments[i][0] for i in range(n)]\n    right = [segments[i][1] for i in range(n)]\n    \n    max_left = [0] * n\n    min_right = [0] * n\n    \n    max_left[0] = left[0]\n    for i in range(1, n):\n        max_left[i] = max(max_left[i - 1], left[i])\n    \n    min_right[n - 1] = right[n - 1]\n    for i in range(n - 2, -1, -1):\n        min_right[i] = min(min_right[i + 1], right[i])\n    \n    max_length = 0\n    \n    for i in range(n):\n        if i == 0:\n            current_left = max_left[1]\n            current_right = min_right[1]\n        elif i == n - 1:\n            current_left = max_left[n - 2]\n            current_right = min_right[n - 2]\n        else:\n            current_left = max(max_left[i - 1], left[i + 1])\n            current_right = min(min_right[i + 1], right[i - 1])\n        \n        current_length = max(0, current_right - current_left)\n        max_length = max(max_length, current_length)\n    \n    return max_length\n\n# Input reading\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\nprint(max_intersection_length(n, segments))\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Define the food consumption pattern for each day of the week\n    week_pattern = [0, 0, 1, 0, 0, 1, 0]  # Fish: 0, Rabbit: 1, Chicken: 2\n    food_needed = [3, 2, 1]  # Weekly food requirements: Fish, Rabbit, Chicken\n    \n    # Calculate the total number of complete weeks that can be sustained\n    full_weeks = min(a // food_needed[0], b // food_needed[1], c // food_needed[2])\n    a -= full_weeks * food_needed[0]\n    b -= full_weeks * food_needed[1]\n    c -= full_weeks * food_needed[2]\n    \n    # Calculate the maximum days after full weeks\n    max_days = full_weeks * 7\n    \n    # Try starting from each day of the week\n    for start_day in range(7):\n        remaining_a, remaining_b, remaining_c = a, b, c\n        days = 0\n        \n        for i in range(7):\n            day = (start_day + i) % 7\n            if day in [0, 3, 6]:  # Fish food days\n                if remaining_a > 0:\n                    remaining_a -= 1\n                    days += 1\n                else:\n                    break\n            elif day in [1, 5]:  # Rabbit stew days\n                if remaining_b > 0:\n                    remaining_b -= 1\n                    days += 1\n                else:\n                    break\n            else:  # Chicken stake days\n                if remaining_c > 0:\n                    remaining_c -= 1\n                    days += 1\n                else:\n                    break\n        \n        max_days = max(max_days, full_weeks * 7 + days)\n    \n    return max_days\n\n# Read input\na, b, c = map(int, input().split())\n# Output the result\nprint(max_days(a, b, c))\n```",
    "82": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncount = 0\n\n# Solve from the left\nwhile count < n and a[count] <= k:\n    count += 1\n\n# Solve from the right\nwhile count < n and a[n - 1 - (count - count)] <= k:\n    count += 1\n\n# Adjust count if both ends are solved\nif count > n:\n    count = n\n\n# The total problems solved is the count of problems solved from both ends\nprint(count)\n```",
    "78": "```python\nMOD = 10**9 + 7\n\ndef count_regular_sequences(n, s):\n    m = len(s)\n    \n    # Precompute Catalan numbers up to 2n\n    catalan = [0] * (n + 1)\n    catalan[0] = 1\n    for i in range(1, n + 1):\n        catalan[i] = sum(catalan[j] * catalan[i - 1 - j] for j in range(i)) % MOD\n    \n    # Check if s can be a valid substring\n    balance = 0\n    min_balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n    \n    if balance < 0 or balance > n or min_balance < 0:\n        return 0\n    \n    # Count valid sequences with s as a substring\n    total_count = 0\n    for prefix_length in range(n + 1):\n        if prefix_length + m > 2 * n:\n            break\n        \n        prefix_balance = 0\n        for i in range(prefix_length):\n            prefix_balance += 1  # Assume all '(' in prefix for balance check\n        \n        if prefix_balance < 0:\n            continue\n        \n        suffix_length = 2 * n - (prefix_length + m)\n        suffix_balance = n - (prefix_balance + balance)\n        \n        if suffix_balance < 0:\n            continue\n        \n        total_count += (catalan[prefix_balance] * catalan[suffix_balance]) % MOD\n        total_count %= MOD\n    \n    return total_count\n\nn = int(input())\ns = input().strip()\nprint(count_regular_sequences(n, s))\n```",
    "84": "```python\nn = int(input())\ns = input().strip()\n\n# Count occurrences of each character\nfrom collections import Counter\ncount = Counter(s)\n\n# Check if we can color the string\ncoloring = ['0'] * n\nlast_color = '0'\n\nfor i in range(n):\n    if i > 0 and s[i] == s[i - 1]:\n        coloring[i] = coloring[i - 1]\n    else:\n        # Alternate colors\n        last_color = '1' if last_color == '0' else '0'\n        coloring[i] = last_color\n\n# Check if the coloring is valid\nfor char in count:\n    if count[char] > 1:\n        # Check if we can separate the same characters\n        positions = [i for i in range(n) if s[i] == char]\n        if len(set(coloring[i] for i in positions)) == 1:\n            print(\"NO\")\n            exit()\n\nprint(\"YES\")\nprint(''.join(coloring))\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    moves = float('inf')\n\n    for i in range(length - 1, 0, -1):\n        if s[i] in '05':\n            for j in range(i - 1, -1, -1):\n                if s[j] in '27':\n                    # Calculate moves needed to bring s[j] to the front and s[i] to the second position\n                    moves_needed = (length - 1 - j) + (length - 1 - i) - 1\n                    moves = min(moves, moves_needed)\n                    break\n                elif s[j] in '05':\n                    # Calculate moves needed to bring s[j] to the front and s[i] to the second position\n                    moves_needed = (length - 1 - j) + (length - 1 - i) - 1\n                    moves = min(moves, moves_needed)\n                    break\n\n    return moves if moves != float('inf') else -1\n\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "92": "```python\nx = float(input().strip())\n\n# We need to find two integers a and b such that 1 <= a, b <= 10\n# and a * b is approximately equal to x\n\n# We can iterate through all possible pairs (a, b)\nfor a in range(1, 11):\n    for b in range(1, 11):\n        if abs(a * b - x) < 1e-6:  # Check if the product is close to x\n            print(a, b)\n            exit()  # Exit after finding the first valid pair\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects based on the required rating in ascending order\n    projects.sort(key=lambda x: x[0])\n    \n    for a, b in projects:\n        if r < a:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_complete_projects(n, r, projects))\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    projects.sort(key=lambda x: (x[0], x[1]))  # Sort by required rating first, then by rating change\n    completed = 0\n    current_rating = r\n    \n    while True:\n        progress_made = False\n        for i in range(len(projects)):\n            a_i, b_i = projects[i]\n            if a_i <= current_rating:  # Can complete this project\n                new_rating = current_rating + b_i\n                if new_rating >= 0:  # Ensure rating does not fall below zero\n                    current_rating = new_rating\n                    completed += 1\n                    projects[i] = (float('inf'), 0)  # Mark as completed\n                    progress_made = True\n        if not progress_made:  # No more projects can be completed\n            break\n\n    return completed\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_projects(n, r, projects))\n```",
    "86": "```python\ndef solve_problems(n, k):\n    # Minimum sum of the first k natural numbers\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n    \n    # Start with the minimum valid sequence\n    a = list(range(1, k + 1))\n    current_sum = min_sum\n    \n    # Distribute the remaining problems\n    remaining = n - current_sum\n    for i in range(k - 1, -1, -1):\n        # Maximum we can add to a[i] while satisfying the conditions\n        max_add = (2 * a[i]) - a[i] - 1  # a[i] < a[i+1] <= 2 * a[i]\n        add = min(remaining, max_add)\n        a[i] += add\n        remaining -= add\n        if remaining <= 0:\n            break\n    \n    if remaining > 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n\n# Example usage\nn, k = map(int, input().split())\nsolve_problems(n, k)\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n    \n    # Precompute the leftmost positions of t in s\n    left = [-1] * m\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n    \n    # Precompute the rightmost positions of t in s\n    right = [-1] * m\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n    \n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n    \n    # Consider removing from the start to the first character of t\n    max_length = max(max_length, right[0] + 1)\n    # Consider removing from the last character of t to the end\n    max_length = max(max_length, n - left[m - 1] - 1)\n    \n    return max_length\n\ns = input().strip()\nt = input().strip()\nprint(max_removable_length(s, t))\n```",
    "97": "```python\nn = int(input())\nx = list(map(int, input().split()))\n\neven_count = sum(1 for i in x if i % 2 == 0)\nodd_count = n - even_count\n\n# The minimum coins required is the smaller of the two counts\nprint(min(even_count, odd_count))\n```",
    "88": "```python\nfrom collections import Counter\n\nn = int(input())\na = list(map(int, input().split()))\n\ncount = Counter(a)\nmatrix = [[0] * n for _ in range(n)]\n\n# Check for the number of odd counts\nodd_count = 0\nodd_value = None\n\nfor value, cnt in count.items():\n    if cnt % 2 != 0:\n        odd_count += 1\n        odd_value = value\n\n# If n is odd, we can have one odd count, if n is even, we can't have any\nif (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n    print(\"NO\")\n    exit()\n\n# Fill the matrix\nhalf = []\nfor value, cnt in count.items():\n    half.extend([value] * (cnt // 2))\n\n# Create the palindromic structure\nfor i in range(n // 2):\n    for j in range(n // 2):\n        matrix[i][j] = half.pop()\n        matrix[i][n - j - 1] = matrix[i][j]\n        matrix[n - i - 1][j] = matrix[i][j]\n        matrix[n - i - 1][n - j - 1] = matrix[i][j]\n\n# If n is odd, place the odd value in the center\nif n % 2 == 1:\n    matrix[n // 2][n // 2] = odd_value\n\nprint(\"YES\")\nfor row in matrix:\n    print(\" \".join(map(str, row)))\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1 or (d == 1 and n > 2) or (d == 0 and n > 1):\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    edges = []\n    \n    # Create a path of length d\n    for i in range(1, d + 2):\n        edges.append((i, i + 1))\n    \n    # Now we have d + 1 vertices in the path\n    current_vertex = d + 2\n    \n    # Connect remaining vertices\n    for i in range(1, d + 2):\n        if current_vertex > n:\n            break\n        while len([e for e in edges if e[0] == i or e[1] == i]) < k and current_vertex <= n:\n            edges.append((i, current_vertex))\n            current_vertex += 1\n    \n    # If we still have vertices left, we can connect them to any of the existing vertices\n    while current_vertex <= n:\n        edges.append((1, current_vertex))\n        current_vertex += 1\n    \n    # Output the edges\n    for u, v in edges:\n        print(u, v)\n\nn, d, k = map(int, input().split())\nconstruct_tree(n, d, k)\n```",
    "98": "```python\ndef min_moves_to_reach_n(N):\n    min_moves = float('inf')\n    \n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            moves = (i - 1) + (j - 1)\n            min_moves = min(min_moves, moves)\n    \n    return min_moves\n\nN = int(input())\nprint(min_moves_to_reach_n(N))\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    p = [0] * n\n    p[0] = 0  # Start with an arbitrary value\n\n    # Calculate the prefix sums to find the values of p\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n\n    # Normalize the permutation to start from 1\n    min_value = min(p)\n    for i in range(n):\n        p[i] -= min_value - 1\n\n    # Check if the resulting array is a valid permutation\n    if sorted(p) == list(range(1, n + 1)):\n        print(' '.join(map(str, p)))\n    else:\n        print(-1)\n\n# Read input\nn = int(input())\nq = list(map(int, input().split()))\n\n# Restore the permutation\nrestore_permutation(n, q)\n```",
    "90": "```python\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculate the total length of platforms\ntotal_length = sum(c)\n\n# If the maximum jump distance is greater than or equal to the width of the river, it's always possible\nif d >= n + 1:\n    print(\"YES\")\n    print(\"0 \" + \"0 \" * (n - 1) + str(m))\n    exit()\n\n# Check if we can place the platforms such that we can reach the end\n# We need to ensure that the gaps between platforms do not exceed d\npositions = []\ncurrent_position = 1\n\nfor length in c:\n    positions.append(current_position)\n    current_position += length\n\n# Check if the gaps between the platforms can be filled with jumps\nfor i in range(1, len(positions)):\n    gap = positions[i] - (positions[i - 1] + c[i - 1])\n    if gap > d:\n        print(\"NO\")\n        exit()\n\n# Check the gap before the first platform and after the last platform\nif positions[0] - 1 > d or (n + 1) - (positions[-1] + c[-1]) > d:\n    print(\"NO\")\n    exit()\n\n# If we can place the platforms, let's construct the output\nresult = [0] * n\ncurrent_position = 0\n\nfor i in range(m):\n    for j in range(c[i]):\n        result[current_position] = i + 1\n        current_position += 1\n    if i < m - 1:\n        current_position += d - c[i]  # Leave a gap of at most d\n\nprint(\"YES\")\nprint(\" \".join(map(str, result)))\n```",
    "99": "```python\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\n# Maximum wins for Alice\nmax_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n\n# Minimum wins for Alice\n# Calculate the losses for Alice\nalice_losses = max(0, b1 - a3) + max(0, b2 - a1) + max(0, b3 - a2)\nmin_wins = n - alice_losses\n\nprint(min_wins, max_wins)\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Determine the base pattern based on x\n    if x % 2 == 0:\n        pattern = '01' * (x // 2)\n    else:\n        pattern = '01' * (x // 2) + '0'\n    \n    # Count how many 0s and 1s are used in the pattern\n    used_0s = pattern.count('0')\n    used_1s = pattern.count('1')\n    \n    # Calculate remaining 0s and 1s\n    remaining_0s = a - used_0s\n    remaining_1s = b - used_1s\n    \n    # Add remaining 0s or 1s to the end of the pattern\n    if remaining_0s > 0:\n        pattern += '0' * remaining_0s\n    if remaining_1s > 0:\n        pattern += '1' * remaining_1s\n    \n    # If we have more 1s than 0s, we need to ensure we start with 1\n    if b > a:\n        pattern = pattern.replace('0', 'x').replace('1', '0').replace('x', '1')\n    \n    return pattern\n\n# Read input\na, b, x = map(int, input().split())\n# Generate and print the binary string\nprint(construct_binary_string(a, b, x))\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Count of each character\n    a_count = b_count = c_count = n\n    \n    # Create a list to hold the result\n    res = []\n    \n    # Function to check if the last two characters form a forbidden substring\n    def is_forbidden():\n        return ''.join(res[-2:]) == s or ''.join(res[-2:]) == t\n    \n    # Build the result string\n    while a_count > 0 or b_count > 0 or c_count > 0:\n        for char in 'abc':\n            if char == 'a' and a_count > 0:\n                res.append(char)\n                a_count -= 1\n            elif char == 'b' and b_count > 0:\n                res.append(char)\n                b_count -= 1\n            elif char == 'c' and c_count > 0:\n                res.append(char)\n                c_count -= 1\n            \n            # Check if the last two characters form a forbidden substring\n            if is_forbidden():\n                res.pop()  # Remove the last character added\n                if char == 'a':\n                    a_count += 1\n                elif char == 'b':\n                    b_count += 1\n                elif char == 'c':\n                    c_count += 1\n                break  # Restart the loop to try adding a different character\n        else:\n            # If we went through all characters and couldn't add any, we are stuck\n            print(\"NO\")\n            return\n\n    # Join the result list into a string\n    result_string = ''.join(res)\n    \n    # Check if we have a valid result\n    if s in result_string or t in result_string:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(result_string)\n\n# Input reading\nn = int(input())\ns = input().strip()\nt = input().strip()\n\ngenerate_string(n, s, t)\n```",
    "57": "```python\ndef fill_gifts(n, f):\n    assigned = set(fi for fi in f if fi != 0)\n    unassigned = [i for i in range(1, n + 1) if i not in assigned]\n    zero_indices = [i for i in range(n) if f[i] == 0]\n\n    for i in range(len(zero_indices)):\n        friend_index = zero_indices[i]\n        gift_index = unassigned[i]\n\n        # Ensure the gift is not assigned to the friend themselves\n        if gift_index == friend_index + 1:\n            # Swap with the next unassigned friend if possible\n            if i + 1 < len(unassigned):\n                unassigned[i], unassigned[i + 1] = unassigned[i + 1], unassigned[i]\n\n        f[friend_index] = unassigned[i]\n\n    return f\n\n# Input reading\nn = int(input())\nf = list(map(int, input().split()))\n\n# Fill the gifts and print the result\nresult = fill_gifts(n, f)\nprint(' '.join(map(str, result)))\n```"
}