{
    "2": "```python\ndef is_lucky_year(year):\n    return str(year).count('0') <= 1\n\nn = int(input(\"Enter a year: \"))\nnext_year = n + 1\n\nwhile not is_lucky_year(next_year):\n    next_year += 1\n\nprint(next_year - n)\n```",
    "3": "```python\nfrom itertools import combinations\n\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\nmax_painted = 0\n\nfor comb in combinations(range(q), q - 2):\n    painted_sections = set()\n    for i in comb:\n        l, r = painters[i]\n        painted_sections.update(range(l, r + 1))\n    max_painted = max(max_painted, len(painted_sections))\n\nprint(max_painted)\n```",
    "5": "```python\nn, pos, l, r = map(int, input().split())\n\nif l == 1 and r == n:\n    print(0)  # No tabs to close\nelse:\n    moves = 0\n\n    # Move to the left side if needed\n    if l > 1:\n        if pos > l:\n            moves += (pos - l)  # Move to the leftmost tab in segment\n        moves += 1  # Close tabs to the left\n\n    # Move to the right side if needed\n    if r < n:\n        if pos < r:\n            moves += (r - pos)  # Move to the rightmost tab in segment\n        moves += 1  # Close tabs to the right\n\n    print(moves)\n```",
    "7": "```python\ndef find_empty_day(n, m):\n    day = 0\n    total_eaten = 0\n    \n    while n > 0:\n        day += 1\n        n += m  # grains brought to the barn\n        total_eaten += day  # total grains eaten by day 'day'\n        \n        n -= total_eaten  # subtract the grains eaten by sparrows\n        if n < 0:\n            return day  # barn becomes empty on this day\n            \n    return day\n\n# Input reading\nn, m = map(int, input().split())\nprint(find_empty_day(n, m))\n```",
    "4": "```python\ndef is_lucky(h, m):\n    return '7' in f\"{h:02d}{m:02d}\"\n\ndef time_before(hh, mm, x):\n    mm -= x\n    if mm < 0:\n        mm += 60\n        hh -= 1\n    if hh < 0:\n        hh += 24\n    return hh, mm\n\ndef main():\n    x = int(input(\"Enter the number of minutes to go back: \"))\n    hh, mm = map(int, input(\"Enter the current time (hh mm): \").split())\n\n    if not (0 <= hh < 24 and 0 <= mm < 60):\n        print(\"Invalid time format. Please enter hours (0-23) and minutes (0-59).\")\n        return\n\n    y = 0\n    while not is_lucky(hh, mm):\n        hh, mm = time_before(hh, mm, x)\n        y += 1\n\n    print(y)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "1": "```python\ndef max_digit_sum(x):\n    str_x = str(x)\n    max_sum = sum(int(d) for d in str_x)\n    best_number = x\n    \n    for i in range(len(str_x)):\n        if str_x[i] == '0':\n            continue\n        \n        candidate = list(str_x)\n        candidate[i] = str(int(candidate[i]) - 1)\n        candidate[i + 1:] = '9' * (len(candidate) - i - 1)\n        \n        candidate_number = int(''.join(candidate))\n        \n        if candidate_number <= x:\n            candidate_sum = sum(int(d) for d in str(candidate_number))\n            if (candidate_sum > max_sum) or (candidate_sum == max_sum and candidate_number > best_number):\n                max_sum = candidate_sum\n                best_number = candidate_number\n    \n    return best_number\n\nif __name__ == \"__main__\":\n    x = int(input().strip())\n    print(max_digit_sum(x))\n```",
    "10": "```python\ndef calculate_days_off(n):\n    if n < 0:\n        raise ValueError(\"Number of days cannot be negative.\")\n    \n    # Calculate maximum possible days off\n    max_days_off = min(2, n)\n\n    # Calculate minimum possible days off\n    weeks = n // 7\n    remaining_days = n % 7\n\n    # Minimum days off will be 2 for each complete week, plus depending on remaining days\n    min_days_off = weeks * 2 + max(0, remaining_days - 5)\n\n    return min_days_off, max_days_off\n\nif __name__ == \"__main__\":\n    try:\n        n = int(input(\"Enter the number of days: \"))\n        min_days_off, max_days_off = calculate_days_off(n)\n        print(min_days_off, max_days_off)\n    except ValueError as e:\n        print(f\"Invalid input: {e}\")\n```",
    "6": "```python\ndef min_blows_to_defeat(t, queries):\n    results = []\n    \n    for i in range(t):\n        (n, x), blows = queries[i]\n        \n        max_damage = max(d for d, h in blows)\n        min_growth = min(h for d, h in blows)\n        \n        if max_damage <= min_growth:\n            results.append(-1 if max_damage < x else 1)\n        else:\n            blows_needed = 0\n            while x > 0:\n                blows_needed += 1\n                x = max(0, x - max_damage + min_growth)\n            results.append(blows_needed)\n    \n    return results\n\n# Read input\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append(((n, x), blows))\n\n# Get results\nresults = min_blows_to_defeat(t, queries)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "0": "```python\ns = input().strip()\n\n# Initialize variables to track the positions of brackets and colons\nopen_bracket_index = s.find('[')\nfirst_colon_index = s.find(':', open_bracket_index)\nlast_colon_index = s.rfind(':', first_colon_index)\nclose_bracket_index = s.find(']', last_colon_index)\n\n# Determine if a valid accordion can be formed\nif open_bracket_index != -1 and first_colon_index != -1 and last_colon_index != -1 and close_bracket_index != -1:\n    # Calculate the maximum length of the accordion\n    vertical_lines_count = s[first_colon_index + 1:last_colon_index].count('|')\n    max_length = 5 + vertical_lines_count  # [ : |* : ]\n    print(max_length)\nelse:\n    print(-1)\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    print(\"YES\" if a == b else \"NO\")\nelse:\n    is_reachable = (b - a) % c == 0 and (b - a) // c >= 0\n    print(\"YES\" if is_reachable else \"NO\")\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    result = t\nelif t <= n:\n    result = k\nelse:\n    result = n + k - t\n\nprint(result)\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    from math import gcd\n    \n    count_a = n // a\n    count_b = n // b\n    lcm_ab = (a * b) // gcd(a, b)  # Least common multiple of a and b\n    count_ab = n // lcm_ab  # count of indices divisible by both a and b\n\n    # Calculate number of chocolates\n    chocolates_option1 = (count_a * p) + ((count_b - count_ab) * q)\n    chocolates_option2 = (count_b * q) + ((count_a - count_ab) * p)\n\n    return max(chocolates_option1, chocolates_option2)\n\n# Read input safely\ntry:\n    n, a, b, p, q = map(int, input(\"Enter values for n, a, b, p, q separated by spaces: \").split())\n    if n < 0 or a <= 0 or b <= 0 or p < 0 or q < 0:\n        raise ValueError(\"n must be non-negative and a, b must be positive; p and q must be non-negative.\")\n    print(max_chocolates(n, a, b, p, q))\nexcept ValueError as e:\n    print(\"Invalid input:\", e)\n```",
    "9": "```python\nd = int(input())\nn, m = map(int, input().split())\n\nsofas = [tuple(map(int, input().split())) for _ in range(d)]\n\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\ndef count_relation(sofa, sofas):\n    (x1, y1, x2, y2) = sofa\n    left = right = top = bottom = 0\n    \n    for (a1, a2, b1, b2) in sofas:\n        if (a1, a2) != (x1, y1) and (a1, a2) != (x2, y2) and (b1, b2) != (x1, y1) and (b1, b2) != (x2, y2):\n            if a1 == b1:  # Same vertical line\n                if a2 < b2:\n                    left += 1\n                else:\n                    right += 1\n            elif a2 == b2:  # Same horizontal line\n                if a1 < b1:\n                    top += 1\n                else:\n                    bottom += 1\n\n    return left, right, top, bottom\n\nfor i in range(d):\n    left, right, top, bottom = count_relation(sofas[i], sofas)\n    if (left, right, top, bottom) == (cnt_l, cnt_r, cnt_t, cnt_b):\n        print(i + 1)\n        break\nelse:\n    print(-1)\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    segments = []\n    current_length = 0\n    \n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n            \n    if current_length > 0:\n        segments.append(current_length)\n    \n    if not segments:  # No golden trophies\n        return 0\n    \n    max_length = max(segments)\n    \n    for i in range(len(segments) - 1):\n        combined_length = segments[i] + segments[i + 1]\n        max_length = max(max_length, combined_length)\n    \n    if 'S' in trophies:  # Check for silver trophies\n        max_length += 1\n    \n    return max_length\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    trophies = input().strip()\n    print(max_beauty_after_swap(n, trophies))\n```",
    "18": "```python\ndef minimal_lexicographic_string(s):\n    from collections import Counter\n    \n    char_count = Counter(s)\n    result = []\n\n    while char_count:\n        smallest_char = min(char_count)\n        result.append(smallest_char)\n        char_count[smallest_char] -= 1\n        \n        if char_count[smallest_char] == 0:\n            del char_count[smallest_char]\n    \n    return ''.join(result)\n\ns = input().strip()\nresult = minimal_lexicographic_string(s)\nprint(result)\n```",
    "8": "```python\ndef can_form_koutsu(tiles):\n    tile_count = {}\n    for tile in tiles:\n        tile_count[tile] = tile_count.get(tile, 0) + 1\n    return any(count >= 3 for count in tile_count.values())\n\ndef can_form_shuntsu(tiles):\n    suit_dict = {'m': [], 'p': [], 's': []}\n    for tile in tiles:\n        num = int(tile[0])\n        suit = tile[1]\n        suit_dict[suit].append(num)\n    \n    for nums in suit_dict.values():\n        nums = sorted(set(nums))  # Use set to avoid duplicates\n        if len(nums) >= 3:\n            for i in range(len(nums) - 2):\n                if nums[i] + 1 in nums and nums[i] + 2 in nums:\n                    return True\n    return False\n\ntiles = input().strip().split()\n\nif can_form_koutsu(tiles) or can_form_shuntsu(tiles):\n    print(0)\nelse:\n    possible_draws = set()\n    for tile in tiles:\n        num = int(tile[0])\n        suit = tile[1]\n        if num > 1:  # Prevent negative numbers\n            possible_draws.add(f\"{num-1}{suit}\")\n        if num < 9:  # Prevent numbers greater than 9\n            possible_draws.add(f\"{num+1}{suit}\")\n    \n    for draw in possible_draws:\n        if can_form_koutsu(tiles + [draw]) or can_form_shuntsu(tiles + [draw]):\n            print(1)\n            break\n    else:\n        print(2)\n```",
    "14": "```python\ndef is_stack_sortable(k, p):\n    stack = []\n    b = []\n    next_to_push = 1\n    for i in range(k):\n        while next_to_push <= len(p) and (next_to_push in stack or next_to_push in p[:k]):\n            next_to_push += 1\n        if p[i] < next_to_push:\n            return False\n        stack.append(p[i])\n        while stack and (not b or stack[-1] < b[-1]):\n            b.append(stack.pop())\n    return True\n\ndef restore_permutation(n, k, p):\n    if not is_stack_sortable(k, p):\n        return -1\n    \n    remaining_numbers = set(range(1, n + 1)) - set(p)\n    result = p.copy()\n    \n    for _ in range(n - k):\n        next_to_add = max(remaining_numbers)\n        result.append(next_to_add)\n        remaining_numbers.remove(next_to_add)\n    \n    return result\n\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\nresult = restore_permutation(n, k, p)\nif result == -1:\n    print(result)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "16": "```python\ndef is_regular_bracket_sequence_valid(cnt_1, cnt_2, cnt_3, cnt_4):\n    open_needed = cnt_1 + cnt_2  # Opening brackets from \"((\" and \"()\"\n    close_needed = cnt_2 + cnt_4  # Closing brackets from \"() and \"))\"\n\n    # Check if closing brackets exceed opening brackets\n    if close_needed > open_needed:\n        return 0\n\n    # Check if unmatched open brackets exceed unmatched close brackets\n    if cnt_3 > open_needed:\n        return 0\n\n    return 1\n\n# Read input counts\ntry:\n    cnt_1 = int(input(\"Enter count of '((': \"))\n    cnt_2 = int(input(\"Enter count of '()': \"))\n    cnt_3 = int(input(\"Enter count of ')(': \"))\n    cnt_4 = int(input(\"Enter count of ')): ' \"))\n    \n    # Validate input\n    if any(count < 0 for count in (cnt_1, cnt_2, cnt_3, cnt_4)):\n        print(\"Counts must be non-negative.\")\n    else:\n        print(is_regular_bracket_sequence_valid(cnt_1, cnt_2, cnt_3, cnt_4))\nexcept ValueError:\n    print(\"Invalid input. Please enter integers.\")\n```",
    "21": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_index = a.index(1)\nmax_index = a.index(n)\n\n# Calculate the current distance\ncurrent_distance = abs(min_index - max_index)\n\n# The maximum possible distance after one swap could be:\nmax_distance = max(min_index + (n - 1 - max_index), (n - 1 - min_index) + max_index)\n\n# The result is the maximum of current distance and max_distance\nresult = max(current_distance, max_distance)\nprint(result)\n```",
    "19": "```python\ndef check_records(test_cases):\n    results = []\n    \n    for n, stats in test_cases:\n        valid = True\n        \n        for i in range(1, n):\n            p, c = stats[i]\n            prev_p, prev_c = stats[i - 1]\n            if p < prev_p or c < prev_c or c > p or c - prev_c > p - prev_p:\n                valid = False\n                break\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Read input\nT = int(input().strip())\ntest_cases = []\n\nfor _ in range(T):\n    n = int(input().strip())\n    stats = [tuple(map(int, input().strip().split())) for _ in range(n)]\n    test_cases.append((n, stats))\n\n# Get results\nresults = check_records(test_cases)\n\n# Print results\nprint(\"\\n\".join(results))\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a, b):\n    from itertools import permutations\n    \n    a_str = str(a)\n    permuted_numbers = {int(''.join(p)) for p in permutations(a_str)}  # Use set comprehension for uniqueness\n    \n    # Use a generator to find valid numbers without creating a complete list\n    valid_numbers = (num for num in permuted_numbers if num <= b and len(str(num)) == len(a_str))\n    \n    # Return the maximum of the valid numbers, or None if no valid numbers exist\n    return max(valid_numbers, default=None)\n\n# Read input\na = int(input().strip())\nb = int(input().strip())\n\n# Get the result\nresult = max_permutation_not_exceeding(a, b)\n\n# Print the result or a message if no valid permutation exists\nprint(result if result is not None else \"No valid permutation found\")\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror_chars = {\n        'A': 'A', 'H': 'H', 'I': 'I', 'M': 'M', \n        'O': 'O', 'T': 'T', 'U': 'U', 'V': 'V', \n        'W': 'W', 'X': 'X', 'Y': 'Y'\n    }\n    \n    n = len(s)\n    \n    for i in range((n + 1) // 2):\n        left_char = s[i]\n        right_char = s[n - 1 - i]\n        \n        if left_char not in mirror_chars or mirror_chars[left_char] != right_char:\n            print(\"NIE\")\n            return\n    \n    print(\"TAK\")\n\ns = input().strip().upper()\nis_s_palindrome(s)\n```",
    "27": "```python\nn = int(input())\ns = input().strip()\n\n# Initialize the minimum operations to n (typing all characters one by one)\nmin_operations = n\n\n# Try every possible split to find the best copy point\nfor i in range(1, n):\n    # The prefix we are considering to copy\n    prefix = s[:i]\n    # The next part of the string after the prefix\n    remaining = s[i:]\n\n    # Check if the remaining string starts with the prefix\n    if remaining.startswith(prefix):\n        # Calculate the required operations\n        operations = i + 1 + (len(remaining) - len(prefix))\n        min_operations = min(min_operations, operations)\n\n# Output the minimum operations found\nprint(min_operations)\n```",
    "20": "```python\ndef is_palindrome(time_str):\n    return time_str == time_str[::-1]\n\ndef next_palindrome_time(hh, mm):\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return (hh, mm)\n\ndef time_difference(hh1, mm1, hh2, mm2):\n    return (hh2 * 60 + mm2) - (hh1 * 60 + mm1)\n\ncurrent_time = input().strip()\nhh, mm = map(int, current_time.split(':'))\nnext_hh, next_mm = next_palindrome_time(hh, mm)\nresult = time_difference(hh, mm, next_hh, next_mm)\nprint(result)\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    if k > n * n or (n % 2 == 0 and k % 2 == 1) or (n % 2 == 1 and k > n * n - n):\n        return -1\n\n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k <= 0:\n            break\n        for j in range(i, n):\n            if k <= 0:\n                break\n            if i == j:  # Main diagonal\n                if k > 0:\n                    matrix[i][j] = 1\n                    k -= 1\n            else:  # Symmetric positions\n                if k >= 2:\n                    matrix[i][j] = 1\n                    matrix[j][i] = 1\n                    k -= 2\n\n    return matrix if k == 0 else -1\n\ndef main():\n    n, k = map(int, input(\"Enter values for n and k: \").split())\n    result = create_symmetric_matrix(n, k)\n\n    if result == -1:\n        print(-1)\n    else:\n        for row in result:\n            print(' '.join(map(str, row)))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    n, k = map(int, data[0].split())\n    main_courses = set(map(int, data[1].split()))\n\n    dependencies = defaultdict(list)\n    indegree = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        line = list(map(int, data[i + 1].split()))\n        t_i = line[0]\n        for dep in line[1:t_i + 1]:\n            dependencies[dep].append(i)\n            indegree[i] += 1\n\n    # Topological sort to find the order of courses\n    queue = deque()\n    for i in range(1, n + 1):\n        if indegree[i] == 0:\n            queue.append(i)\n\n    order = []\n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        for next_course in dependencies[course]:\n            indegree[next_course] -= 1\n            if indegree[next_course] == 0:\n                queue.append(next_course)\n\n    # Check if we can complete all main courses\n    if not main_courses.issubset(set(order)):\n        print(-1)\n        return\n\n    # Determine the minimum courses to take\n    taken_courses = set()\n    result = []\n\n    for course in order:\n        if course in main_courses or any(dep not in taken_courses for dep in dependencies[course]):\n            result.append(course)\n            taken_courses.add(course)\n\n    print(len(result))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = [f[0] for f in files if f[1] == '1']\nregulars = [f[0] for f in files if f[1] == '0']\n\nmoves = []\n\n# Move examples to their new positions\nmoves.extend(f\"move {file} {i + 1}\" for i, file in enumerate(examples))\n\n# Move regulars to their new positions\nmoves.extend(f\"move {file} {len(examples) + i + 1}\" for i, file in enumerate(regulars))\n\nprint(len(moves))\nprint(\"\\n\".join(moves))\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket):\n    if len(ticket) != 6 or not ticket.isdigit():\n        raise ValueError(\"Ticket must be a string of 6 digits.\")\n\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    diff = abs(sum_first - sum_second)\n    \n    # Calculate the maximum possible changes for each digit\n    changes = [(9 - digit) if i < 3 else digit for i, digit in enumerate(first_half + second_half)]\n    \n    changes.sort(reverse=True)  # Sort changes in descending order\n    \n    count = 0\n    for change in changes:\n        diff -= change\n        count += 1\n        if diff <= 0:\n            return count\n    \n    return count  # This will only happen if there are not enough digits to cover the difference\n\n\n# Input reading\nticket = input().strip()\nprint(min_replacements_to_lucky(ticket))\n```",
    "26": "```python\nimport math\n\ndef main():\n    # Read and parse the input\n    try:\n        x, y, z = map(float, input(\"Enter three numbers separated by spaces: \").strip().split())\n    except ValueError:\n        print(\"Invalid input. Please enter three numerical values.\")\n        return\n\n    # Define the expressions and their corresponding string representations\n    expressions = [\n        (x**(y**z), \"x^y^z\"),\n        (x**(z**y), \"x^z^y\"),\n        ((x**y)**z, \"(x^y)^z\"),\n        ((x**z)**y, \"(x^z)^y\"),\n        (y**(x**z), \"y^x^z\"),\n        (y**(z**x), \"y^z^x\"),\n        ((y**x)**z, \"(y^x)^z\"),\n        ((y**z)**x, \"(y^z)^x\"),\n        (z**(x**y), \"z^x^y\"),\n        (z**(y**x), \"z^y^x\"),\n        ((z**x)**y, \"(z^x)^y\"),\n        ((z**y)**x, \"(z^y)^x\"),\n    ]\n\n    # Find the maximum value and its corresponding index\n    max_value, max_index = max((val, idx) for idx, (val, _) in enumerate(expressions))\n\n    # Output the corresponding expression\n    print(expressions[max_index][1])\n\nif __name__ == \"__main__\":\n    main()\n```",
    "24": "```python\ndef can_alice_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # vertical, horizontal, diagonal\n    \n    def count_streaks(x, y, dx, dy):\n        count = 0\n        for step in range(5):\n            nx, ny = x + step * dx, y + step * dy\n            if 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n            else:\n                break\n        return count\n    \n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                for dx, dy in directions:\n                    total_count = count_streaks(i, j, dx, dy) + count_streaks(i, j, -dx, -dy)\n                    if total_count >= 4:  # +1 for the new cross we would place\n                        return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nboard = [input().strip() for _ in range(10)]\nif all(len(row) == 10 for row in board):  # Ensure each row has exactly 10 characters\n    print(can_alice_win(board))\nelse:\n    print(\"Input error: Each row must contain exactly 10 characters.\")\n```",
    "32": "```python\nn = int(input())\ncurrent_position = 0  # 0 for North Pole, 20000 for South Pole\n\nfor _ in range(n):\n    t, direction = input().split()\n    t = int(t)\n\n    if current_position == 0 and direction != \"South\":\n        print(\"NO\")\n        break\n    elif current_position == 20000 and direction != \"North\":\n        print(\"NO\")\n        break\n    elif direction == \"North\":\n        current_position -= t\n    elif direction == \"South\":\n        current_position += t\n    elif direction in {\"West\", \"East\"}:\n        continue\n\n    if current_position < 0 or current_position > 20000:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\" if current_position == 0 else \"NO\")\n```",
    "34": "```python\ndef can_distribute(x, n, a, b):\n    plates_for_a = (a + x - 1) // x  # Minimum plates needed for cake a\n    plates_for_b = (b + x - 1) // x  # Minimum plates needed for cake b\n    return plates_for_a + plates_for_b <= n\n\ndef max_min_pieces(n, a, b):\n    left, right = 1, max(a, b)\n    while left < right:\n        mid = (left + right + 1) // 2\n        if can_distribute(mid, n, a, b):\n            left = mid\n        else:\n            right = mid - 1\n    return left\n\ndef main():\n    try:\n        n, a, b = map(int, input(\"Enter n, a, b values separated by space: \").split())\n        if n < 1 or a < 1 or b < 1:\n            raise ValueError(\"All input values must be positive integers.\")\n        result = max_min_pieces(n, a, b)\n        print(result)\n    except ValueError as e:\n        print(f\"Invalid input: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
    "37": "```python\ndef can_deal_exact_damage(a, b, c):\n    if a <= 0 or b <= 0:\n        return \"No\"\n    for i in range(c // a + 1):\n        if (c - i * a) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Input\na, b, c = map(int, input().split())\n# Output\nprint(can_deal_exact_damage(a, b, c))\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if any rating has changed\nif any(a != b for a, b in ratings):\n    print(\"rated\")\nelse:\n    # Check the order of the ratings\n    if all(ratings[i][0] >= ratings[i + 1][0] for i in range(n - 1)):\n        print(\"maybe\")\n    else:\n        print(\"unrated\")\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    def euler_totient(n):\n        result = n\n        p = 2\n        while p * p <= n:\n            if n % p == 0:\n                while n % p == 0:\n                    n //= p\n                result -= result // p\n            p += 1\n        if n > 1:\n            result -= result // n\n        return result\n    \n    return euler_totient(m)\n\nif __name__ == \"__main__\":\n    m, x = map(int, input(\"Enter values for m and x, separated by a space: \").split())\n    print(minimum_traps(m, x))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    if n <= 1 or not is_palindrome(s):\n        return n\n    \n    for length in range(n - 1, 0, -1):\n        for start in range(n - length + 1):\n            substring = s[start:start + length]\n            if not is_palindrome(substring):\n                return length\n    \n    return 0\n\nif __name__ == \"__main__\":\n    s = input().strip()\n    print(longest_non_palindrome_substring(s))\n```",
    "36": "```python\ndef hexagonal_spiral(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    while n > 3 * layer * (layer + 1):\n        layer += 1\n    \n    moves_in_previous_layer = 3 * layer * (layer - 1)\n    position_in_layer = n - moves_in_previous_layer\n\n    if position_in_layer < layer:\n        x = layer\n        y = position_in_layer - layer\n    elif position_in_layer < 2 * layer:\n        x = layer - (position_in_layer - layer)\n        y = layer\n    else:\n        x = -layer\n        y = layer - (position_in_layer - 2 * layer)\n\n    return (x, y)\n\nif __name__ == \"__main__\":\n    try:\n        n = int(input(\"Enter a non-negative integer: \").strip())\n        if n < 0:\n            raise ValueError(\"Input must be a non-negative integer.\")\n        x, y = hexagonal_spiral(n)\n        print(x, y)\n    except ValueError as e:\n        print(e)\n```",
    "31": "```python\nfrom math import gcd\n\ndef birthday_paradox(n, k):\n    days = 1 << n  # This is 2^n\n    if k > days:\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the probability of no collision\n    no_collision_num = 1\n    for i in range(k):\n        no_collision_num *= (days - i)\n\n    no_collision_den = days ** k\n\n    # The probability of at least one collision\n    collision_num = no_collision_den - no_collision_num\n    collision_den = no_collision_den\n\n    # Reduce the fraction\n    common_divisor = gcd(collision_num, collision_den)\n    A = collision_num // common_divisor\n    B = collision_den // common_divisor\n\n    # Take modulo\n    MOD = 10**6 + 3\n    A %= MOD\n    B %= MOD\n\n    # Ensure A and B are coprime after modulo\n    if gcd(A, B) != 1:\n        raise ValueError(\"A and B are not coprime after modulo.\")\n\n    return A, B\n\ndef main():\n    # Read input and validate\n    try:\n        n, k = map(int, input(\"Enter n and k separated by space: \").split())\n        if n < 1 or k < 1:\n            raise ValueError(\"n and k must be positive integers.\")\n    except ValueError as e:\n        print(f\"Input error: {e}\")\n        return\n\n    A, B = birthday_paradox(n, k)\n    print(A, B)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "33": "```python\nfrom math import gcd\n\ndef count_common_terms(a1, b1, a2, b2, L, R):\n    # Normalize b1 and b2 to the same form\n    b1_mod_a1 = b1 % a1\n    b2_mod_a2 = b2 % a2\n\n    # Find the step size using the gcd\n    step = abs(a1 * a2 // gcd(a1, a2))\n\n    # Find the first valid x in the range [L, R]\n    first_x = None\n    for k in range(max(0, (L - b1) // a1), (R - b1) // a1 + 1):\n        x = a1 * k + b1\n        if L <= x <= R:\n            first_x = x\n            break\n\n    if first_x is None:\n        return 0\n\n    # Adjust first_x to satisfy the second equation\n    if (first_x - b2) % a2 != 0:\n        first_x += (a2 - (first_x - b2) % a2) % a2\n\n    if first_x > R:\n        return 0\n\n    # Calculate the count of valid x's in the range [L, R]\n    count = (R - first_x) // step + 1\n    return count\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n# Output the result\nprint(count_common_terms(a1, b1, a2, b2, L, R))\n```",
    "35": "```python\ndef is_valid_flag(n, m, field):\n    colors = {'R', 'G', 'B'}\n\n    # Check horizontal stripe pattern\n    def check_horizontal():\n        if n % 3 != 0:\n            return False\n        \n        stripe_height = n // 3\n        seen_colors = set()\n        for i in range(3):\n            stripe = field[i * stripe_height:(i + 1) * stripe_height]\n            if len(set(''.join(row) for row in stripe)) != 1:\n                return False\n            color = stripe[0][0]\n            if color in seen_colors or color not in colors:\n                return False\n            seen_colors.add(color)\n        return seen_colors == colors\n\n    # Check vertical stripe pattern\n    def check_vertical():\n        if m % 3 != 0:\n            return False\n        \n        stripe_width = m // 3\n        seen_colors = set()\n        for i in range(3):\n            stripe = [row[i * stripe_width:(i + 1) * stripe_width] for row in field]\n            if len(set(''.join(stripe))) != 1:\n                return False\n            color = stripe[0][0]\n            if color in seen_colors or color not in colors:\n                return False\n            seen_colors.add(color)\n        return seen_colors == colors\n\n    return check_horizontal() or check_vertical()\n\n# Read input\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Output result\nprint(\"YES\" if is_valid_flag(n, m, field) else \"NO\")\n```",
    "38": "```python\ndef can_coincide(n, L, kefa_distances, sasha_distances):\n    # Calculate the differences (gaps) between consecutive barriers for Kefa and Sasha\n    kefa_gaps = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    sasha_gaps = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Create a doubled list of Sasha's gaps to account for circular shifts\n    doubled_sasha_gaps = sasha_gaps * 2\n    \n    # Check if Kefa's gaps are a contiguous subsequence in the doubled Sasha's gaps\n    if any(kefa_gaps == doubled_sasha_gaps[i:i + n] for i in range(n)):\n        return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_coincide(n, L, kefa_distances, sasha_distances)\nprint(result)\n```",
    "41": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nd = [float('inf')] * n\n\n# First pass: from left to right\nlast_zero = -1\nfor i in range(n):\n    if a[i] == 0:\n        last_zero = i\n        d[i] = 0\n    elif last_zero != -1:\n        d[i] = i - last_zero\n\n# Second pass: from right to left\nlast_zero = -1\nfor i in range(n - 1, -1, -1):\n    if a[i] == 0:\n        last_zero = i\n    elif last_zero != -1:\n        d[i] = min(d[i], last_zero - i)\n\nprint(' '.join(map(str, d)))\n```",
    "42": "```python\ndef count_cyclical_strings(n, s):\n    from itertools import product\n\n    s_len = len(s)\n    total_count = 0\n    seen = set()\n\n    # Generate all possible binary strings of length n\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        # Check if any cyclical shift contains the substring s\n        if any(s in (t[i:] + t[:i]) for i in range(n)):\n            seen.add(t)  # No need to check if it's already seen\n            total_count += 1\n\n    return total_count\n\n# Input reading\nn = int(input(\"Enter the length of the binary strings: \"))\ns = input(\"Enter the substring to check: \").strip()\n\n# Result calculation and output\nresult = count_cyclical_strings(n, s)\nprint(result)\n```",
    "48": "```python\ndef kth_largest_in_multiplication_table(n, m, k):\n    left, right = 1, n * m\n\n    while left < right:\n        mid = (left + right) // 2\n        count = sum(min(mid // i, m) for i in range(1, n + 1))\n\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left\n\n# Input\nn, m, k = map(int, input().split())\n# Output the k-th largest number\nprint(kth_largest_in_multiplication_table(n, m, k))\n```",
    "46": "```python\ndef count_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n\n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n\n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n\n    return sum(count_x[i] * count_y[(5 - i) % 5] for i in range(5))\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    print(count_pairs(n, m))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    if k <= 0:\n        raise ValueError(\"k must be a positive integer.\")\n\n    length = 1\n    count = 9\n    start = 1\n\n    # Determine the range where the k-th digit falls\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    # Find the actual number that contains the k-th digit\n    start += (k - 1) // length\n    number = str(start)\n    \n    # Find the specific digit\n    digit_index = (k - 1) % length\n    return number[digit_index]\n\ntry:\n    k = int(input(\"Enter a positive integer k: \"))\n    print(find_kth_digit(k))\nexcept ValueError as e:\n    print(e)\n```",
    "51": "```python\nfrom collections import Counter\n\ndef main():\n    n = int(input(\"Enter the number of divisors: \"))\n    divisors = list(map(int, input(\"Enter the divisors: \").split()))\n\n    if n != len(divisors):\n        print(\"Error: The number of divisors provided does not match the count.\")\n        return\n\n    # Count occurrences of each divisor\n    count = Counter(divisors)\n\n    # The product of the unique divisors\n    unique_divisors = set(divisors)\n    x_y_product = 1\n    for d in unique_divisors:\n        x_y_product *= d\n\n    # x is the maximum divisor, y is calculated as the product divided by x\n    x = max(unique_divisors)\n    y = x_y_product // x if x != 0 else 0\n\n    print(x, y)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "47": "```python\ndef max_beauty_with_subarray(n, x, a):\n    # Function to calculate maximum subarray sum using Kadane's algorithm\n    def kadane(arr):\n        max_sum = float('-inf')\n        current_sum = 0\n        for value in arr:\n            current_sum += value\n            max_sum = max(max_sum, current_sum)\n            current_sum = max(current_sum, 0)\n        return max_sum\n\n    # Calculate the original beauty of the array\n    original_beauty = kadane(a)\n\n    # To store the maximum beauty after modifying a subarray\n    max_beauty = original_beauty\n\n    # Calculate maximum sum of subarray when multiplied by x\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += a[j]\n            # Calculate modified sum with subarray a[i:j+1] multiplied by x\n            modified_sum = current_sum * x + sum(a[k] for k in range(n) if not (i <= k <= j))\n            # Update max beauty\n            max_beauty = max(max_beauty, modified_sum)\n\n    return max_beauty\n\n# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nresult = max_beauty_with_subarray(n, x, a)\n\n# Print the result\nprint(result)\n```",
    "54": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_a = min(a)\nmax_a = max(a)\n\nif min_a == max_a:\n    print(0)\nelse:\n    difference = max_a - min_a\n    print(difference // 2 if difference % 2 == 0 else -1)\n```",
    "44": "```python\ndef minimal_time_to_post_office(d, k, a, b, t):\n    # Calculate time if Vasiliy walks the entire distance\n    time_if_walks = d * b\n    \n    # Initialize minimum time as walking time\n    min_time = time_if_walks\n    \n    # Calculate the number of full segments the car can drive\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Time taken to use the car for full segments\n    time_with_car = full_segments * (k * a + t) - (t if full_segments > 0 else 0)\n    \n    # Add time for remaining distance (by car or foot)\n    if remaining_distance > 0:\n        time_with_car_drive_remaining = time_with_car + (remaining_distance * a)\n        time_with_car_walk_remaining = time_with_car + t + (remaining_distance * b)\n        \n        min_time = min(min_time, time_with_car_drive_remaining, time_with_car_walk_remaining)\n    else:\n        min_time = min(min_time, time_with_car)\n    \n    return min_time\n\n# Input reading\nd, k, a, b, t = map(int, input().split())\n# Output result\nprint(minimal_time_to_post_office(d, k, a, b, t))\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    from itertools import combinations\n\n    max_elements = m // 2\n    total_sum = 0\n\n    # Process each row to get the best possible sums modulo k\n    for row in matrix:\n        best_mod_sums = [0] * k  # Array to keep track of max sums for each modulo k\n\n        # Consider all combinations of choosing up to max_elements from the row\n        for count in range(max_elements + 1):\n            for combo in combinations(row, count):\n                current_sum = sum(combo)\n                mod = current_sum % k\n                best_mod_sums[mod] = max(best_mod_sums[mod], current_sum)\n\n        # Add the best found sum to the total sum\n        total_sum += max(best_mod_sums)\n\n    return total_sum\n\n# Input reading\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print\nresult = max_sum_divisible_by_k(n, m, k, matrix)\nprint(result)\n```",
    "45": "```python\ndef create_sequence(n, k):\n    min_required_sum = k * (k + 1) // 2\n    if min_required_sum > n:\n        return -1\n    \n    # Start with the maximum GCD and create the initial sequence\n    max_gcd = n // k\n    sequence = [max_gcd * i for i in range(1, k + 1)]\n    \n    # Calculate the current sum of the sequence\n    current_sum = sum(sequence)\n    \n    # Calculate the difference needed to reach the target sum\n    difference = n - current_sum\n    \n    # If the difference is non-negative, adjust the last element\n    if difference >= 0:\n        sequence[-1] += difference\n        return sequence\n    else:\n        return -1\n\n# Reading input\nn, k = map(int, input().split())\nresult = create_sequence(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "56": "```python\ndef f(x):\n    return x // 10 if x % 10 == 0 else x + 1\n\ndef reachable_count(n):\n    reachable = set()\n    while n not in reachable:\n        reachable.add(n)\n        n = f(n)\n    return len(reachable)\n\nn = int(input())\nprint(reachable_count(n))\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = float('-inf')\n    result = []\n    directions = []\n    \n    while left <= right:\n        if a[left] < last_taken and a[right] < last_taken:\n            break\n        \n        if a[left] >= last_taken and (a[right] < last_taken or a[left] <= a[right]):\n            last_taken = a[left]\n            result.append(last_taken)\n            directions.append('L')\n            left += 1\n        elif a[right] >= last_taken:\n            last_taken = a[right]\n            result.append(last_taken)\n            directions.append('R')\n            right -= 1\n    \n    print(len(result))\n    print(''.join(directions))\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\nlongest_increasing_sequence(n, a)\n```",
    "57": "```python\nn = int(input())\nf = list(map(int, input().split()))\n\n# Find the friends who have not been assigned a recipient (f_i = 0)\nunassigned = [i for i in range(n) if f[i] == 0]\n\n# Ensure there are at least two unassigned friends\nif len(unassigned) < 2:\n    raise ValueError(\"There should be at least two unassigned friends.\")\n\n# Prepare a list for the final assignments\nresult = f[:]\n\n# Assign unassigned friends to each other in a way that no one gives a gift to themselves\nfor i in range(len(unassigned)):\n    recipient_index = (i + 1) % len(unassigned)  # This ensures a circular assignment\n    result[unassigned[i]] = unassigned[recipient_index] + 1  # Adjusting for 1-based index\n\nprint(\" \".join(map(str, result)))\n```",
    "60": "```python\ndef has_palindromic_subsequence(test_cases):\n    results = []\n    for n, a in test_cases:\n        seen = {}\n        found = False\n        for i in range(n):\n            if a[i] in seen and i - seen[a[i]] > 1:\n                found = True\n                break\n            seen[a[i]] = i\n        results.append(\"YES\" if found else \"NO\")\n    return results\n\ndef main():\n    t = int(input())\n    test_cases = [(\n        int(input()), \n        list(map(int, input().split()))\n    ) for _ in range(t)]\n    \n    results = has_palindromic_subsequence(test_cases)\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "63": "```python\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\nif n <= 2:\n    print(0)\nelse:\n    a.sort()\n    instability_if_remove_max = a[-2] - a[0]\n    instability_if_remove_min = a[-1] - a[1]\n    \n    result = min(instability_if_remove_max, instability_if_remove_min)\n    print(result)\n```",
    "43": "```python\nimport math\nimport sys\n\ndef angle_between(v1, v2):\n    dot = v1[0] * v2[0] + v1[1] * v2[1]\n    det = v1[0] * v2[1] - v1[1] * v2[0]\n    return math.atan2(det, dot)\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    vectors = []\n\n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().strip().split())\n        angle = math.atan2(y, x)\n        vectors.append((angle, i + 1))\n\n    # Sort by angle\n    vectors.sort()\n\n    # To find the minimal angle, we also need to consider the wrap-around case\n    min_angle = float('inf')\n    pair_indices = (0, 0)\n\n    for i in range(n):\n        v1 = vectors[i]\n        v2 = vectors[(i + 1) % n]  # Wrap around to compare with the first vector\n        angle_diff = abs(v1[0] - v2[0])\n        \n        # Ensure we take the non-oriented angle\n        if angle_diff > math.pi:\n            angle_diff = 2 * math.pi - angle_diff\n        \n        if angle_diff < min_angle:\n            min_angle = angle_diff\n            pair_indices = (v1[1], v2[1])\n\n    print(pair_indices[0], pair_indices[1])\n\nif __name__ == \"__main__\":\n    main()\n```",
    "55": "```python\ndef is_visible(white_sheet, black_sheets):\n    # Unpack the coordinates for better readability\n    x1, y1, x2, y2 = white_sheet\n    (x3, y3, x4, y4), (x5, y5, x6, y6) = black_sheets\n    \n    # Check if the white sheet is completely covered by any of the black sheets\n    covered_by_first = (x3 <= x1 <= x2 <= x4 and y3 <= y1 <= y2 <= y4)\n    covered_by_second = (x5 <= x1 <= x2 <= x6 and y5 <= y1 <= y2 <= y6)\n    \n    if covered_by_first and covered_by_second:\n        print(\"NO\")\n        return\n\n    # Check if there is any visible part\n    visible = (\n        (x1 < x3 or x2 > x4 or y1 < y3 or y2 > y4) or\n        (x1 < x5 or x2 > x6 or y1 < y5 or y2 > y6)\n    )\n    \n    print(\"YES\" if visible else \"NO\")\n\n# Read input\nwhite_sheet = list(map(int, input().split()))\nblack_sheets = [tuple(map(int, input().split())) for _ in range(2)]\n\n# Call the function\nis_visible(white_sheet, black_sheets)\n```",
    "59": "```python\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# Ensure the input number is long enough\nif len(number) != n:\n    raise ValueError(\"The length of the input number does not match n.\")\n\n# Calculate the number of changes needed\nchanges = 0\n\n# Check the (y + 1)th digit from the end\nif number[n - (y + 1)] != '1':\n    changes += 1\n\n# Check the last y digits\nfor i in range(y):\n    if number[n - (i + 1)] != '0':\n        changes += 1\n\nprint(changes)\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph):\n    queue = deque([start])\n    visited = {start: 0}\n    farthest_node = start\n\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > visited[farthest_node]:\n                    farthest_node = neighbor\n\n    return farthest_node, visited\n\ndef find_max_edges(n, edges):\n    graph = defaultdict(list)\n\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Step 1: Find the farthest node from an arbitrary node (node 1)\n    farthest_node, _ = bfs(1, graph)\n\n    # Step 2: Find the farthest node from the found farthest node\n    opposite_node, distances = bfs(farthest_node, graph)\n\n    # Step 3: Find the diameter of the tree\n    diameter_length = distances[opposite_node]\n\n    # Step 4: Construct the path from farthest_node to opposite_node\n    path_nodes = []\n    current = opposite_node\n    while current != farthest_node:\n        path_nodes.append(current)\n        for neighbor in graph[current]:\n            if distances[neighbor] == distances[current] - 1:\n                current = neighbor\n                break\n\n    path_nodes.append(farthest_node)\n    path_nodes.reverse()\n\n    # Choose the endpoints of the longest path and one of their neighbors\n    a = path_nodes[0]\n    b = path_nodes[-1]\n    c = path_nodes[len(path_nodes) // 2]\n\n    return diameter_length + 1, a, b, c\n\ndef main():\n    n = int(input(\"Enter the number of nodes: \"))\n    if n < 2:\n        print(\"The number of nodes must be at least 2.\")\n        return\n    \n    edges = [tuple(map(int, input(\"Enter edge (u v): \").split())) for _ in range(n - 1)]\n    result, a, b, c = find_max_edges(n, edges)\n    print(result)\n    print(a, b, c)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "62": "```python\ndef min_operations(test_cases):\n    results = []\n    for a, b, c in test_cases:\n        min_ops = float('inf')\n        best_triplet = (0, 0, 0)\n        \n        for A in range(1, 10001):\n            for B in range(A, 10001, A):\n                for C in range(B, 10001, B):\n                    ops = abs(A - a) + abs(B - b) + abs(C - c)\n                    if ops < min_ops:\n                        min_ops = ops\n                        best_triplet = (A, B, C)\n\n        results.append((min_ops, best_triplet))\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Processing the test cases\nresults = min_operations(test_cases)\n\n# Output results\nfor ops, triplet in results:\n    print(ops)\n    print(*triplet)\n```",
    "58": "```python\ndef color_array(n, k, a):\n    from collections import defaultdict\n\n    color = [0] * n\n    freq = defaultdict(list)\n\n    for index, value in enumerate(a):\n        freq[value].append(index)\n\n    if len(freq) < k:\n        print(\"NO\")\n        return\n\n    color_count = [0] * (k + 1)\n    current_color = 1\n\n    for indices in freq.values():\n        for index in indices:\n            color[index] = current_color\n            color_count[current_color] += 1\n            current_color += 1\n            if current_color > k:\n                current_color = 1\n\n    if any(c == 0 for c in color_count[1:k + 1]):\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, color)))\n\n# Example usage\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    color_array(n, k, a)\n```",
    "61": "```python\nn = int(input())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\n# Convert f to a direct mapping for digits 0 to 9\nf = [0] + f  # Add a dummy 0 at index 0 to make indexing easier\n\n# Create the maximum number\nmax_number = list(a)\nchanged = False\n\nfor i in range(n):\n    current_digit = int(a[i])\n    if f[current_digit] > current_digit:\n        max_number[i] = str(f[current_digit])\n        changed = True  # Mark that we've started changing\n    elif f[current_digit] < current_digit and changed:\n        break  # Stop changing segment after we start\n\nprint(\"\".join(max_number))\n```",
    "67": "```python\ndef find_nice_indices(n, a):\n    total_sum = sum(a)\n    nice_indices = []\n\n    for i in range(n):\n        if total_sum - a[i] == a[i]:\n            nice_indices.append(i + 1)  # Store indices in 1-based format\n    \n    print(len(nice_indices))\n    if nice_indices:\n        print(' '.join(map(str, nice_indices)))\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    a = list(map(int, input().strip().split()))\n    \n    if n > 0 and len(a) == n:\n        find_nice_indices(n, a)\n    else:\n        print(\"Invalid input: Ensure the number of elements matches the specified count.\")\n```",
    "71": "```python\ntry:\n    a = int(input(\"Enter a positive integer: \"))\n    if a <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    output = (a - 1).bit_length()\n    print(output)\nexcept ValueError as e:\n    print(e)\n```",
    "65": "```python\ndef number_of_moves(n, m):\n    if m % n != 0:\n        return -1\n\n    ratio = m // n\n    count_2 = 0\n    count_3 = 0\n\n    while ratio % 2 == 0:\n        ratio //= 2\n        count_2 += 1\n\n    while ratio % 3 == 0:\n        ratio //= 3\n        count_3 += 1\n\n    return count_2 + count_3 if ratio == 1 else -1\n\n# Read input\ntry:\n    n, m = map(int, input(\"Enter two integers (n m): \").split())\n    result = number_of_moves(n, m)\n    print(result)\nexcept ValueError:\n    print(\"Invalid input. Please enter two integers.\")\n```",
    "73": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmax_height = max(a)\ntotal_bricks_needed = sum(max_height - h for h in a)\n\n# Check if the total height can be achieved without any gaps\ncurrent_height = 0\nis_possible = True\n\nfor height in a:\n    if height > current_height:\n        current_height = height\n    elif height < current_height:\n        is_possible = False\n        break\n\nprint(\"YES\" if is_possible else \"NO\")\n```",
    "70": "```python\ndef calculate_midpoint_time(start_time: str, end_time: str) -> str:\n    h1, m1 = map(int, start_time.split(':'))\n    h2, m2 = map(int, end_time.split(':'))\n\n    # Convert start and end time to total minutes\n    start_minutes = h1 * 60 + m1\n    end_minutes = h2 * 60 + m2\n\n    # Calculate the midpoint in total minutes\n    midpoint_minutes = (start_minutes + end_minutes) // 2\n\n    # Convert back to hours and minutes, ensuring to handle overflow properly\n    h3 = (midpoint_minutes // 60) % 24  # Use % 24 to wrap around hours\n    m3 = midpoint_minutes % 60\n\n    # Return the result in the required format\n    return f\"{h3:02}:{m3:02}\"\n\n# Example usage\nstart_time = input(\"Enter start time (HH:MM): \")\nend_time = input(\"Enter end time (HH:MM): \")\nprint(calculate_midpoint_time(start_time, end_time))\n```",
    "77": "```python\ndef min_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2 != 0\n\ntry:\n    n = int(input(\"Enter a positive integer: \"))\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    print(min_difference(n))\nexcept ValueError as e:\n    print(f\"Invalid input: {e}\")\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import defaultdict\n    from itertools import combinations\n\n    # Count the frequency of each character in the string\n    freq = defaultdict(int)\n    for char in s:\n        freq[char] += 1\n\n    # Generate unique subsequences and their costs\n    unique_subsequences = set()\n    total_cost = 0\n\n    # We can generate subsequences by picking combinations of indices\n    for length in range(1, n + 1):\n        for indices in combinations(range(n), length):\n            subsequence = ''.join(s[i] for i in indices)\n            if subsequence not in unique_subsequences:\n                unique_subsequences.add(subsequence)\n                cost = n - length  # cost is the number of deleted characters\n                total_cost += cost\n\n                # If we already have k unique subsequences, we can stop\n                if len(unique_subsequences) >= k:\n                    return total_cost\n    \n    # If we have fewer than k unique subsequences, it's impossible\n    return -1 if len(unique_subsequences) < k else total_cost\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result and print\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Use KMP (Knuth-Morris-Pratt) failure function to find the longest prefix which is also a suffix\n    pi = [0] * n\n    j = 0\n\n    for i in range(1, n):\n        while j > 0 and t[i] != t[j]:\n            j = pi[j - 1]\n        if t[i] == t[j]:\n            j += 1\n        pi[i] = j\n\n    # The length of the longest prefix which is also a suffix\n    overlap_length = pi[-1]\n\n    # Construct the final string\n    non_overlapping_part = t[overlap_length:]\n    result = t + non_overlapping_part * (k - 1)\n\n    return result\n\ndef main():\n    # Read input\n    n, k = map(int, input().split())\n    t = input().strip()\n\n    # Validate input\n    if n <= 0 or k <= 0 or len(t) != n:\n        raise ValueError(\"Invalid input: n and k must be positive integers and the length of t must equal n.\")\n\n    # Get the constructed string\n    result = construct_string(n, k, t)\n\n    # Print the result\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    # Prepare the schedule with zeros\n    schedule = [0] * n\n    \n    # Prepare to track available days for preparation\n    available_days = [0] * n\n    \n    # Fill the available days for preparation\n    for s_i, d_i, c_i in exams:\n        for day in range(s_i - 1, d_i - 1):  # from s_i to d_i-1\n            available_days[day] += 1\n    \n    # Try to allocate preparation days\n    for exam_index, (s_i, d_i, c_i) in enumerate(exams):\n        days_needed = c_i\n        \n        for day in range(s_i - 1, d_i - 1):\n            if schedule[day] == 0 and days_needed > 0:\n                schedule[day] = exam_index + 1  # Prepare for exam exam_index\n                days_needed -= 1\n        \n        if days_needed > 0:\n            return -1  # Not enough preparation days\n    \n    return schedule\n\n# Input reading\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the schedule\nresult = schedule_exams(n, m, exams)\n\n# Output result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "74": "```python\ndef min_cost_to_get_subsequences(n, k, s):\n    if k <= 0:\n        return 0  # No subsequences needed\n    \n    unique_chars = set(s)\n    max_subsequences = 0\n    costs = []\n    \n    # Count distinct characters and calculate costs for subsequences\n    for char in unique_chars:\n        count = s.count(char)\n        costs.append(count)  # Each character can contribute subsequences\n        max_subsequences += (1 << count) - 1  # 2^count - 1\n    \n    # If we can't form enough unique subsequences\n    if max_subsequences < k:\n        return -1\n    \n    # Sort costs in descending order to minimize total cost\n    costs.sort(reverse=True)\n    \n    total_cost = 0\n    needed = k\n    \n    # Calculate minimum cost to get k unique subsequences\n    for i in range(min(len(costs), needed)):\n        total_cost += costs[i]\n    \n    # If more unique subsequences are needed than we have distinct characters\n    if needed > len(costs):\n        total_cost += (needed - len(costs)) * n  # Remaining needed subsequences come from full length\n    \n    return total_cost\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get result\nresult = min_cost_to_get_subsequences(n, k, s)\n\n# Print result\nprint(result)\n```",
    "76": "```python\ndef can_construct_square(n, m, tiles):\n    if m % 2 != 0:\n        return \"NO\"\n    \n    # Check if any tile can form a square\n    for tile_top, tile_bottom in tiles:\n        if tile_top[1] == tile_bottom[0]:  # Check if top right == bottom left\n            return \"YES\"\n    \n    return \"NO\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        tiles = []\n        for __ in range(n):\n            tile_top = list(map(int, data[index].split()))\n            index += 1\n            tile_bottom = list(map(int, data[index].split()))\n            index += 1\n            tiles.append((tile_top, tile_bottom))\n        \n        result = can_construct_square(n, m, tiles)\n        results.append(result)\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "72": "```python\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Precompute the maximum left endpoint and minimum right endpoint\nmax_left = [0] * n\nmin_right = [0] * n\n\nmax_left[0] = segments[0][0]\nmin_right[0] = segments[0][1]\n\nfor i in range(1, n):\n    max_left[i] = max(max_left[i - 1], segments[i][0])\n    min_right[i] = min(min_right[i - 1], segments[i][1])\n\nmax_left_suffix = [0] * n\nmin_right_suffix = [0] * n\n\nmax_left_suffix[n - 1] = segments[n - 1][0]\nmin_right_suffix[n - 1] = segments[n - 1][1]\n\nfor i in range(n - 2, -1, -1):\n    max_left_suffix[i] = max(max_left_suffix[i + 1], segments[i][0])\n    min_right_suffix[i] = min(min_right_suffix[i + 1], segments[i][1])\n\nmax_length = 0\n\nfor i in range(n):\n    left = max(max_left[i - 1] if i > 0 else float('-inf'),\n                max_left_suffix[i + 1] if i < n - 1 else float('-inf'))\n    right = min(min_right[i - 1] if i > 0 else float('inf'),\n                 min_right_suffix[i + 1] if i < n - 1 else float('inf'))\n\n    if left <= right:\n        max_length = max(max_length, right - left)\n\nprint(max_length)\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    # To store the index of characters\n    char_indices = {}\n\n    # Collect the positions of each character\n    for i, char in enumerate(s):\n        if char not in char_indices:\n            char_indices[char] = []\n        char_indices[char].append(i)\n\n    # Initialize the colors array\n    colors = [0] * n\n    color = 0\n\n    # Iterate through the sorted unique characters\n    for char in sorted(char_indices.keys()):\n        color += 1  # Increment the color for each unique character\n        for idx in char_indices[char]:\n            colors[idx] = color\n\n    # The number of colors used is the maximum color value\n    res = color\n\n    print(res)\n    print(' '.join(map(str, colors)))\n\n# Read input\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    s = input().strip()\n    min_colors_to_sort(n, s)\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n    \n    # Build the adjacency list for the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Check if it's possible to have the degree of vertex 1 equal to D\n    if len(graph[1]) < D:\n        print(\"NO\")\n        return\n\n    # Collect the edges of the spanning tree\n    spanning_tree_edges = []\n    degree_count = {i: 0 for i in range(1, n + 1)}\n    \n    # Start the spanning tree construction\n    queue = deque([1])\n    degree_count[1] = 0  # Start with vertex 1\n    used = {1}  # Track used vertices\n\n    while queue:\n        current = queue.popleft()\n        \n        # Stop if vertex 1 has reached the desired degree\n        if current == 1 and degree_count[1] == D:\n            continue\n        \n        for neighbor in graph[current]:\n            # Only consider edges that do not exceed the required degree for vertex 1\n            if degree_count[current] < (D if current == 1 else n - 1) and degree_count[neighbor] < n - 1:\n                spanning_tree_edges.append((current, neighbor))\n                degree_count[current] += 1\n                degree_count[neighbor] += 1\n                \n                if neighbor != 1 and neighbor not in used:\n                    queue.append(neighbor)\n                    used.add(neighbor)\n                \n                # If we reached the required degree for vertex 1, we can stop\n                if current == 1 and degree_count[1] == D:\n                    break\n\n    # Check if we have used n-1 edges and degree of vertex 1 is D\n    if len(spanning_tree_edges) == n - 1 and degree_count[1] == D:\n        print(\"YES\")\n        for u, v in spanning_tree_edges:\n            print(u, v)\n    else:\n        print(\"NO\")\n\n\n# Input reading\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nn, m, D = map(int, data[0].split())\nedges = [tuple(map(int, line.split())) for line in data[1:m + 1]]\n\n# Call the function\nfind_spanning_tree(n, m, D, edges)\n```",
    "81": "```python\ndef can_reorder_strings(n, strings):\n    # Sort strings by their lengths\n    strings.sort(key=len)\n\n    # Check the substring condition\n    for i in range(1, n):\n        if not any(strings[j] in strings[i] for j in range(i)):\n            return \"NO\"\n\n    return \"YES\\n\" + \"\\n\".join(strings)\n\n# Read input\nn = int(input().strip())\nstrings = [input().strip() for _ in range(n)]\n\n# Get the result and print it\nprint(can_reorder_strings(n, strings))\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Food schedule: 0: Fish, 1: Rabbit, 2: Chicken\n    food_schedule = [0, 1, 2, 0, 1, 2, 0]  # Monday to Sunday\n    \n    max_days_possible = 0\n    \n    for start_day in range(7):\n        fish, rabbit, chicken = a, b, c\n        days = 0\n        \n        # Simulate the first week\n        for i in range(7):\n            day = (start_day + i) % 7\n            if food_schedule[day] == 0 and fish > 0:  # Fish food\n                fish -= 1\n                days += 1\n            elif food_schedule[day] == 1 and rabbit > 0:  # Rabbit stew\n                rabbit -= 1\n                days += 1\n            elif food_schedule[day] == 2 and chicken > 0:  # Chicken steak\n                chicken -= 1\n                days += 1\n            else:\n                break\n        \n        # Calculate full weeks that can be sustained\n        full_weeks = min(fish // 3, rabbit // 2, chicken // 2)\n        if full_weeks > 0:\n            days += full_weeks * 7\n            fish -= full_weeks * 3\n            rabbit -= full_weeks * 2\n            chicken -= full_weeks * 2\n        \n        # Continue for remaining days after full weeks\n        for i in range(7):\n            day = (start_day + i) % 7\n            if food_schedule[day] == 0 and fish > 0:  # Fish food\n                fish -= 1\n                days += 1\n            elif food_schedule[day] == 1 and rabbit > 0:  # Rabbit stew\n                rabbit -= 1\n                days += 1\n            elif food_schedule[day] == 2 and chicken > 0:  # Chicken steak\n                chicken -= 1\n                days += 1\n            else:\n                break\n\n        max_days_possible = max(max_days_possible, days)\n    \n    return max_days_possible\n\n# Input reading\na, b, c = map(int, input().split())\nprint(max_days(a, b, c))\n```",
    "82": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nsolved = 0\n\n# Solve from the left\nwhile solved < n and a[solved] <= k:\n    solved += 1\n\n# Solve from the right\nwhile solved < n and a[n - 1 - (solved - 1)] <= k:\n    solved += 1\n\n# If we've counted a problem from both ends, we need to subtract one\nif solved > 0 and a[solved - 1] <= k and solved > n:\n    solved -= 1\n\nprint(solved)\n```",
    "85": "```python\ndef find_price(A, B):\n    for price in range(1, 10000):  # Arbitrarily chosen upper limit\n        tax_8 = price * 0.08  # Consumption tax at 8%\n        tax_10 = price * 0.10  # Consumption tax at 10%\n        if int(tax_8) == A and int(tax_10) == B:\n            return price\n    return -1\n\n# Input reading\nA, B = map(int, input().split())\nresult = find_price(A, B)\nprint(result)\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    \n    # Target pairs for divisibility by 25\n    targets = ['00', '25', '50', '75']\n    \n    min_moves = float('inf')\n    \n    for target in targets:\n        last_digit = target[1]\n        first_digit = target[0]\n        \n        last_index = -1\n        first_index = -1\n        \n        # Search for the last character of the target in reverse\n        for i in range(length - 1, -1, -1):\n            if s[i] == last_digit:\n                last_index = i\n                # Now search for the first character of the target\n                for j in range(last_index - 1, -1, -1):\n                    if s[j] == first_digit:\n                        first_index = j\n                        break\n                if first_index != -1:\n                    # Calculate moves\n                    moves = (last_index - first_index) + (last_index - 1 - first_index)\n                    min_moves = min(min_moves, moves)\n                break  # No need to continue searching once the last_index is found\n        \n    return min_moves if min_moves != float('inf') else -1\n\n# Read input\nn = int(input())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "84": "```python\nn = int(input().strip())\ns = input().strip()\n\n# To check the conditions for coloring\ncolor = [''] * n\nlast_position = {}\npossible = True\n\nfor i in range(n):\n    if s[i] in last_position:\n        # If the character has appeared before, check if we can assign the same color\n        color[i] = '0' if color[last_position[s[i]]] == '1' else '1'\n    else:\n        # Assign the first color '0' if it's the first occurrence\n        color[i] = '0'\n    \n    last_position[s[i]] = i\n\n# Check if the string can be sorted with the current coloring\nfor i in range(n - 1):\n    if s[i] > s[i + 1] and color[i] == color[i + 1]:\n        possible = False\n        break\n\nprint(\"YES\" if possible else \"NO\")\nif possible:\n    print(''.join(color))\n```",
    "92": "```python\ntry:\n    x = float(input().strip())\n    a = (int(x * 10) % 10) + 1\n    b = (int(x * 100) % 10) + 1\n    print(a, b)\nexcept ValueError:\n    print(\"Invalid input. Please enter a valid number.\")\n```",
    "90": "```python\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculate the total length of platforms and the maximum reachable distance\ntotal_length = sum(c)\nmax_possible_jump = d * (total_length + 1)\n\nif max_possible_jump < n:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    river = [0] * n\n    current_position = 0\n    \n    for platform_index in range(m):\n        for _ in range(c[platform_index]):\n            if current_position < n:\n                river[current_position] = platform_index + 1\n                current_position += 1\n                \n        # Move the current position to the next jumpable area\n        if current_position < n:  # Ensure we don't exceed the river length\n            current_position += 1\n\n    print(\" \".join(map(str, river)))\n```",
    "78": "```python\ndef count_regular_sequences(n, s):\n    MOD = 1000000007\n    m = len(s)\n\n    # Check if s can be part of a regular bracket sequence\n    balance = 0\n    min_balance = 0\n    for char in s:\n        balance += 1 if char == '(' else -1\n        min_balance = min(min_balance, balance)\n\n    # If the balance is not zero or min_balance < 0, it can't be part of a valid sequence\n    if balance != 0 or min_balance < 0:\n        return 0\n\n    # Calculate the number of valid sequences of length 2n\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(n + 1):\n            if j < n:\n                dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % MOD  # Adding '('\n            if j > 0:\n                dp[i + 1][j - 1] = (dp[i + 1][j - 1] + dp[i][j]) % MOD  # Adding ')'\n\n    total_sequences = dp[n][0]\n\n    # Count the number of ways to place s in the regular sequences\n    count = 0\n    for i in range(n - m + 1):\n        left_balance = sum(1 if s[j] == '(' else -1 for j in range(i))\n        right_balance = sum(1 if s[j] == '(' else -1 for j in range(i + m, n))\n\n        if left_balance < 0 or right_balance < 0:\n            continue\n\n        ways_left = dp[i][left_balance]\n        ways_right = dp[n - (i + m)][right_balance]\n        count = (count + ways_left * ways_right) % MOD\n\n    return count\n\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_regular_sequences(n, s))\n```",
    "86": "```python\ndef solve_polycarp(n, k):\n    # Minimum problems needed to satisfy the constraints\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n    \n    # Start with the minimum possible values\n    a = list(range(1, k + 1))\n    \n    # Calculate the remaining problems to distribute\n    remaining = n - min_sum\n    \n    # Distribute the remaining problems\n    for i in range(k - 1, -1, -1):\n        max_add = remaining  # We can add at most the remaining problems\n        a[i] += max_add\n        remaining -= max_add\n        \n        if remaining <= 0:\n            break\n            \n    if remaining > 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n\n# Read input\ntry:\n    n, k = map(int, input().split())\n    solve_polycarp(n, k)\nexcept ValueError:\n    print(\"Invalid input. Please enter two integers.\")\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects based on the required rating\n    projects.sort(key=lambda x: x[0])\n    \n    for a, b in projects:\n        if r < a:  # If current rating is less than required for the project\n            return \"NO\"\n        r += b  # Update the rating after completing the project\n        if r < 0:  # If rating goes below zero, return \"NO\"\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\ntry:\n    n, r = map(int, input().split())\n    if n < 1 or r < 0:\n        raise ValueError(\"Invalid input values for n or r.\")\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n    exit(1)\n\nprojects = []\nfor _ in range(n):\n    try:\n        project = tuple(map(int, input().split()))\n        if len(project) != 2 or project[0] < 0 or project[1] < -r:\n            raise ValueError(\"Invalid project data.\")\n        projects.append(project)\n    except ValueError as e:\n        print(f\"Error: {e}\")\n        exit(1)\n\n# Output the result\nprint(can_complete_projects(n, r, projects))\n```",
    "83": "```python\ndef min_perimeter(a, b):\n    total_tiles = a + b\n    min_perim = float('inf')\n\n    # Iterate through all possible width values for the rectangle containing a+b tiles\n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n\n            # Check combinations of width and height for red tiles\n            for r_width in range(1, int(a**0.5) + 1):\n                if a % r_width == 0:\n                    r_height = a // r_width\n                    if r_width <= width and r_height <= height:\n                        remaining_space = (width - r_width) * height + (height - r_height) * width\n                        if b <= remaining_space:\n                            min_perim = min(min_perim, 2 * (width + height))\n\n            # Check combinations of width and height for blue tiles\n            for b_width in range(1, int(b**0.5) + 1):\n                if b % b_width == 0:\n                    b_height = b // b_width\n                    if b_width <= width and b_height <= height:\n                        remaining_space = (width - b_width) * height + (height - b_height) * width\n                        if a <= remaining_space:\n                            min_perim = min(min_perim, 2 * (width + height))\n\n    return min_perim if min_perim != float('inf') else 0\n\n# Read input\na, b = map(int, input().split())\n# Calculate and print the minimal perimeter\nprint(min_perimeter(a, b))\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n\n    # Early exit if t is longer than s\n    if m > n:\n        return n\n\n    # Create an array to store the position of each character of t in s\n    pos_t = []\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            pos_t.append(i)\n            j += 1\n\n    # If not all characters of t are found in s, return the full length of s\n    if len(pos_t) < m:\n        return n\n\n    # Leftmost and rightmost indices to keep t as a subsequence\n    left, right = pos_t[0], pos_t[-1]\n\n    # The maximum removable length is the total length minus the length of remaining parts\n    max_removal_length = left + (n - right - 1)\n\n    return max_removal_length\n\n# Input reading\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(max_removable_length(s, t))\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    # Check for impossible configurations\n    if d > 2 * (k - 1) + 1 or (d == 1 and n > 2) or (n > 1 and d == 0):\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    \n    edges = []\n    \n    # Create the main path for the diameter\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n    \n    # Number of used vertices including the path\n    used_vertices = d + 1\n    \n    # Create branches from the path\n    for i in range(1, d + 1):\n        if used_vertices >= n:\n            break\n        for _ in range(k - 1):  # Add at most `k - 1` branches to each node\n            if used_vertices >= n:\n                break\n            edges.append((i, used_vertices + 1))\n            used_vertices += 1\n    \n    # Verify if we have exactly n - 1 edges\n    if len(edges) != n - 1:\n        print(\"NO\")\n    else:\n        for u, v in edges:\n            print(u, v)\n\n# Input reading\nn, d, k = map(int, input().split())\nconstruct_tree(n, d, k)\n```",
    "97": "```python\nn = int(input())\nx = list(map(int, input().split()))\n\neven_count = sum(1 for i in x if i % 2 == 0)\nodd_count = n - even_count\n\nprint(min(even_count, odd_count))\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects based on their required rating and then by rating change\n    projects.sort(key=lambda x: (x[0], x[1]))\n\n    # Track the number of projects completed\n    completed_projects = 0\n\n    # To keep track of the current rating\n    current_rating = r\n\n    # While we can still complete projects\n    while True:\n        completed_this_round = 0\n        for a, b in projects:\n            if current_rating >= a:  # Check if we can complete this project\n                new_rating = current_rating + b\n                if new_rating >= 0:  # Check if completing it keeps rating non-negative\n                    current_rating = new_rating\n                    completed_projects += 1\n                    completed_this_round += 1\n\n        # If no projects were completed in this round, break the loop\n        if completed_this_round == 0:\n            break\n\n    return completed_projects\n\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = max_projects(n, r, projects)\nprint(result)\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Start with an empty list to build the string\n    s = []\n    \n    # Determine the starting character based on the counts of 0s and 1s\n    if a + b < x + 1 or (x % 2 == 1 and (a == 0 or b == 0)):\n        print(\"Impossible to construct the string with the given parameters.\")\n        return\n    \n    is_zero_turn = a >= b  # Start with '0' if more or equal zeros than ones\n    for i in range(x + 1):\n        if is_zero_turn:\n            if a > 0:\n                s.append('0')\n                a -= 1\n            is_zero_turn = False\n        else:\n            if b > 0:\n                s.append('1')\n                b -= 1\n            is_zero_turn = True\n            \n    # Fill the rest with the remaining characters\n    s.extend(['0'] * a)\n    s.extend(['1'] * b)\n    \n    # Join the list into a string and print it\n    print(''.join(s))\n\n# Input reading\na, b, x = map(int, input().split())\nconstruct_binary_string(a, b, x)\n```",
    "96": "```python\nn = int(input())\nq = list(map(int, input().split()))\n\n# Initialize the permutation array\np = [0] * n\n\n# Compute p_1 using the prefix sum of q\nfor i in range(1, n):\n    p[i] = p[i - 1] + q[i - 1]\n\n# Normalize the permutation to make it start from 1\nmin_val = min(p)\noffset = 1 - min_val\n\n# Create the final permutation\np = [x + offset for x in p]\n\n# Check if the permutation is valid\nif len(set(p)) == n and all(1 <= x <= n for x in p):\n    print(\" \".join(map(str, p)))\nelse:\n    print(-1)\n```",
    "98": "```python\ndef min_moves_to_reach(N):\n    if N <= 1:\n        return 0\n    \n    min_moves = float('inf')\n    \n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            moves = (i - 1) + (j - 1)\n            min_moves = min(min_moves, moves)\n    \n    return min_moves\n\ntry:\n    N = int(input().strip())\n    print(min_moves_to_reach(N))\nexcept ValueError:\n    print(\"Please enter a valid integer.\")\n```",
    "99": "```python\ndef calculate_wins():\n    n = int(input(\"Enter the total number of games: \"))\n    a1, a2, a3 = map(int, input(\"Enter Alice's counts (a1 a2 a3): \").split())\n    b1, b2, b3 = map(int, input(\"Enter Bob's counts (b1 b2 b3): \").split())\n\n    # Maximum wins for Alice\n    max_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n\n    # Minimum wins for Alice\n    bob_wins = min(b1, a2) + min(b2, a3) + min(b3, a1)\n    min_wins = n - bob_wins\n\n    print(min_wins, max_wins)\n\nif __name__ == \"__main__\":\n    calculate_wins()\n```",
    "88": "```python\ndef is_possible(n, counts):\n    # Check if the counts can form a palindromic matrix\n    odd_count = sum(1 for count in counts if count % 2 != 0)\n    return not ((n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1))\n\ndef fill_matrix(n, counts):\n    # Create an empty n x n matrix\n    matrix = [[0] * n for _ in range(n)]\n    # Create a list of elements to place in the matrix\n    elements = []\n    \n    for number, count in counts.items():\n        elements.extend([number] * count)\n\n    # Fill the matrix in a palindromic manner\n    idx = 0\n    for i in range((n + 1) // 2):\n        for j in range((n + 1) // 2):\n            if idx < len(elements):  # Prevent index out of range\n                matrix[i][j] = elements[idx]\n                matrix[i][n - j - 1] = elements[idx]\n                matrix[n - i - 1][j] = elements[idx]\n                matrix[n - i - 1][n - j - 1] = elements[idx]\n                idx += 1\n\n    return matrix\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    from collections import Counter\n    counts = Counter(a)\n    \n    if not is_possible(n, counts.values()):\n        print(\"NO\")\n        return\n    \n    matrix = fill_matrix(n, counts)\n    print(\"YES\")\n    for row in matrix:\n        print(' '.join(map(str, row)))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "95": "```python\ndef is_valid_result(res, s, t):\n    return not (s in res or t in res)\n\ndef add_char(res, char, last_chars):\n    if res and res[-1] == char:\n        return False\n    if len(res) >= 2 and (res[-1] == last_chars[0] and res[-2] == last_chars[1]):\n        return False\n    res.append(char)\n    return True\n\ndef build_result(n, s, t):\n    a_count = b_count = c_count = n\n    res = []\n\n    while a_count > 0 or b_count > 0 or c_count > 0:\n        if a_count > 0 and add_char(res, 'a', (s[0], t[0])):\n            a_count -= 1\n        elif b_count > 0 and add_char(res, 'b', (s[0], t[0])):\n            b_count -= 1\n        elif c_count > 0 and add_char(res, 'c', (s[0], t[0])):\n            c_count -= 1\n        else:\n            return \"NO\", \"\"\n\n    result_str = ''.join(res)\n    return (\"NO\", \"\") if not is_valid_result(result_str, s, t) else (\"YES\", result_str)\n\nn = int(input())\ns = input().strip()\nt = input().strip()\n\nresult = build_result(n, s, t)\nif result[0] == \"NO\":\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(result[1])\n```"
}