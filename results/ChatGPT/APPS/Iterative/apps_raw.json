{
    "2": "```python\nn = int(input())\n\ndef is_lucky(year):\n    non_zero_digits = [d for d in str(year) if d != '0']\n    return len(non_zero_digits) <= 1\n\nnext_year = n + 1\nwhile not is_lucky(next_year):\n    next_year += 1\n\nprint(next_year - n)\n```",
    "10": "```python\nn = int(input())\n\n# Calculate the maximum days off\nmax_days_off = (n // 7) * 2 + min(2, n % 7)\n\n# Calculate the minimum days off\nmin_days_off = 0 if n < 5 else (n // 7) * 2\n\nprint(min_days_off, max_days_off)\n```",
    "7": "```python\ndef find_empty_day(n, m):\n    day = 0\n    total_eaten = 0\n    \n    while n > 0:\n        day += 1\n        total_eaten += day\n        \n        # Add grains to the barn\n        n += m\n        \n        # Ensure barn does not exceed its capacity\n        if n > m:\n            n = min(n, m + n)  # This line is unnecessary and can be removed\n        \n        # Sparrows eat grains\n        n -= total_eaten\n        \n    return day\n\n# Read input\nn, m = map(int, input().split())\nprint(find_empty_day(n, m))\n```",
    "1": "```python\ndef max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n    \n    # Start with the original number\n    max_sum = sum(int(d) for d in str_x)\n    best_number = x\n    \n    # Try to create numbers by reducing digits\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit by 1 and setting all following digits to 9\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        new_number = int(new_number)\n        \n        if new_number <= x:\n            current_sum = sum(int(d) for d in str(new_number))\n            if current_sum > max_sum or (current_sum == max_sum and new_number > best_number):\n                max_sum = current_sum\n                best_number = new_number\n    \n    return best_number\n\nx = int(input().strip())\nprint(max_digit_sum(x))\n```",
    "5": "```python\nn, pos, l, r = map(int, input().split())\n\nif l == 1 and r == n:\n    print(0)\nelse:\n    moves = 0\n    \n    if pos < l:\n        moves += l - pos  # Move to the leftmost tab to close\n        moves += (r - l + 1)  # Close all tabs to the right\n    elif pos > r:\n        moves += pos - r  # Move to the rightmost tab to close\n        moves += (r - l + 1)  # Close all tabs to the left\n    else:\n        # Cursor is between l and r\n        left_moves = (pos - l) + (r - l + 1)  # Move to l and close left\n        right_moves = (r - pos) + (r - l + 1)  # Move to r and close right\n        moves = min(left_moves, right_moves)\n\n    print(moves)\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    # Create a list to store the painted sections count\n    painted_count = [0] * (n + 1)\n\n    # Function to calculate the number of painted sections with a specific set of painters\n    def count_painted(painter_indices):\n        painted = [0] * (n + 1)\n        for index in painter_indices:\n            l, r = painters[index]\n            for j in range(l, r + 1):\n                painted[j] = 1\n        return sum(painted)\n\n    max_sections = 0\n\n    # Try every combination of q - 2 painters\n    from itertools import combinations\n    for indices in combinations(range(q), q - 2):\n        max_sections = max(max_sections, count_painted(indices))\n\n    return max_sections\n\n# Read input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Get the result and print it\nresult = max_painted_sections(n, q, painters)\nprint(result)\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    for query in queries:\n        n, x, blows = query\n        min_blows = float('inf')\n        possible = False\n        \n        for d, h in blows:\n            if d >= x:\n                min_blows = min(min_blows, 1)\n                possible = True\n            else:\n                # Calculate the effective damage per blow\n                effective_damage = d - h\n                if effective_damage > 0:\n                    # Calculate how many blows are needed to reduce heads to zero\n                    blows_needed = (x - d + effective_damage - 1) // effective_damage + 1\n                    min_blows = min(min_blows, blows_needed)\n                    possible = True\n        \n        if possible:\n            results.append(min_blows)\n        else:\n            results.append(-1)\n    \n    return results\n\n# Input reading\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\n# Get results\nresults = min_blows_to_defeat_zmei(t, queries)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    count_a = n // a\n    count_b = n // b\n    count_ab = n // (a * b)\n    \n    # Calculate the maximum chocolates\n    chocolates_a = count_a * p\n    chocolates_b = count_b * q\n    \n    # If p > q, prioritize Red (a), otherwise prioritize Blue (b)\n    if p > q:\n        chocolates = chocolates_a + (count_b - count_ab) * q\n    else:\n        chocolates = chocolates_b + (count_a - count_ab) * p\n    \n    return chocolates\n\n# Input\nn, a, b, p, q = map(int, input().split())\nprint(max_chocolates(n, a, b, p, q))\n```",
    "9": "```python\nd = int(input())\nn, m = map(int, input().split())\nsofas = []\n\nfor _ in range(d):\n    x1, y1, x2, y2 = map(int, input().split())\n    sofas.append((x1, y1, x2, y2))\n\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\ndef count_sofas(sofa, sofas):\n    x1, y1, x2, y2 = sofa\n    left = right = top = bottom = 0\n    \n    for other in sofas:\n        if other == sofa:\n            continue\n        ox1, oy1, ox2, oy2 = other\n        if x2 < ox1:  # sofa is to the left\n            left += 1\n        elif x1 > ox2:  # sofa is to the right\n            right += 1\n        elif y2 < oy1:  # sofa is above\n            top += 1\n        elif y1 > oy2:  # sofa is below\n            bottom += 1\n            \n    return left, right, top, bottom\n\nfor i in range(d):\n    left, right, top, bottom = count_sofas(sofas[i], sofas)\n    if (left, right, top, bottom) == (cnt_l, cnt_r, cnt_t, cnt_b):\n        print(i + 1)\n        break\nelse:\n    print(-1)\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    print(\"YES\" if a == b else \"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelse:\n    print(n + k - t)\n```",
    "8": "```python\ndef min_draws_to_win(tiles):\n    from collections import defaultdict\n\n    # Parse the input tiles\n    hand = tiles.split()\n    counts = defaultdict(int)\n    suits = defaultdict(list)\n\n    for tile in hand:\n        number = int(tile[0])\n        suit = tile[1]\n        counts[(number, suit)] += 1\n        suits[suit].append(number)\n\n    # Check for existing mentsus\n    def has_koutsu():\n        return any(count >= 3 for count in counts.values())\n\n    def has_shuntsu():\n        for suit, numbers in suits.items():\n            numbers = sorted(set(numbers))  # Unique and sorted numbers\n            for i in range(len(numbers) - 2):\n                if (numbers[i] + 1 in numbers) and (numbers[i] + 2 in numbers):\n                    return True\n        return False\n\n    if has_koutsu() or has_shuntsu():\n        return 0\n\n    # Check for draws needed\n    def can_form_shuntsu_with_one_draw():\n        for suit, numbers in suits.items():\n            numbers = sorted(set(numbers))  # Unique and sorted numbers\n            for i in range(len(numbers)):\n                if i > 0 and numbers[i] - 1 == numbers[i - 1]:  # Check for a pair\n                    if numbers[i] + 1 not in numbers:  # Need the next number\n                        return True\n                if i < len(numbers) - 1 and numbers[i] + 1 == numbers[i + 1]:  # Check for a pair\n                    if numbers[i] - 1 not in numbers:  # Need the previous number\n                        return True\n        return False\n\n    if can_form_shuntsu_with_one_draw():\n        return 1\n\n    # If no mentsus and can't form with one draw, check for two draws\n    return 2\n\n# Read input\ntiles = input().strip()\n# Output the result\nprint(min_draws_to_win(tiles))\n```",
    "16": "```python\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\n# Calculate the balance of opening and closing brackets\nopen_brackets = cnt_1 + cnt_2\nclose_brackets = cnt_3 + cnt_4\n\n# Check if the number of opening and closing brackets can balance\nif open_brackets < close_brackets:\n    print(0)\nelse:\n    # Check if we can maintain a non-negative balance while forming the sequence\n    if cnt_3 > open_brackets:\n        print(0)\n    else:\n        # Check if we have enough opening brackets to balance the closing ones\n        if cnt_1 < cnt_4:\n            print(0)\n        else:\n            print(1)\n```",
    "18": "```python\ndef lexicographically_minimal_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        while t and (not u or t[-1] <= u[-1]):\n            u.append(t.pop())\n    \n    return ''.join(u)\n\ns = input().strip()\nresult = lexicographically_minimal_string(s)\nprint(result)\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    segments = []\n    current_length = 0\n\n    # Calculate the lengths of segments of golden trophies\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n    if current_length > 0:\n        segments.append(current_length)\n\n    # If there are no golden trophies\n    if not segments:\n        return 0\n\n    # If there's only one segment, we can only swap with a silver trophy\n    if len(segments) == 1:\n        return segments[0]\n\n    # Calculate the maximum beauty by considering swaps\n    max_beauty = max(segments)\n    for i in range(len(segments) - 1):\n        # Check if we can connect two segments by swapping a silver trophy\n        max_beauty = max(max_beauty, segments[i] + segments[i + 1])\n\n    # If we can swap a silver trophy to extend the longest segment\n    max_beauty = max(max_beauty, max(segments) + 1)\n\n    return max_beauty\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\n\n# Output the result\nprint(max_beauty_after_swap(n, trophies))\n```",
    "14": "```python\ndef is_stack_sortable(n, k, p):\n    # Create a set of used elements\n    used = set(p)\n    # Create a list for the remaining elements\n    remaining = [i for i in range(1, n + 1) if i not in used]\n    \n    # Initialize the stack and the result array\n    stack = []\n    result = []\n    \n    # Iterate through the first k elements\n    for i in range(k):\n        # While stack is not empty and the top of the stack is less than the next element in p\n        while stack and stack[-1] < p[i]:\n            result.append(stack.pop())\n        # Push the current element onto the stack\n        stack.append(p[i])\n    \n    # Now we need to add the remaining elements in a way that keeps the result stack-sortable\n    for num in sorted(remaining, reverse=True):\n        while stack and stack[-1] < num:\n            result.append(stack.pop())\n        stack.append(num)\n    \n    # Empty the stack\n    while stack:\n        result.append(stack.pop())\n    \n    # Check if the result is a valid permutation\n    if len(result) != n or sorted(result) != list(range(1, n + 1)):\n        return -1\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result\nresult = is_stack_sortable(n, k, p)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "19": "```python\ndef check_records(test_cases):\n    results = []\n    for case in test_cases:\n        n, records = case\n        valid = True\n        prev_p, prev_c = 0, 0\n        \n        for p, c in records:\n            if p < prev_p or c < prev_c or c > p:\n                valid = False\n                break\n            if (p - prev_p) < (c - prev_c):\n                valid = False\n                break\n            \n            prev_p, prev_c = p, c\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Read input\nT = int(input())\ntest_cases = []\n\nfor _ in range(T):\n    n = int(input())\n    records = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, records))\n\n# Get results and print them\nresults = check_records(test_cases)\nfor result in results:\n    print(result)\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return minutes_passed\n\ncurrent_time = input().strip()\nhh, mm = map(int, current_time.split(':'))\nresult = next_palindrome_time(hh, mm)\nprint(result)\n```",
    "23": "```python\nfrom itertools import permutations\n\ndef max_permutation_not_exceeding(a, b):\n    a_str = str(a)\n    b_str = str(b)\n    \n    # Generate all unique permutations of the digits of a\n    permuted_numbers = set(int(''.join(p)) for p in permutations(a_str))\n    \n    # Filter out numbers that are greater than b and have the same length as a\n    valid_numbers = [num for num in permuted_numbers if num <= b and len(str(num)) == len(a_str) and str(num)[0] != '0']\n    \n    # Return the maximum valid number\n    return max(valid_numbers)\n\n# Input\na = int(input().strip())\nb = int(input().strip())\n\n# Output the result\nprint(max_permutation_not_exceeding(a, b))\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror_chars = {\n        'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M',\n        'O': 'O', 'o': 'o', 'p': 'q', 'q': 'p', 'R': 'R', 'S': 'S',\n        'T': 'T', 'U': 'U', 'v': 'v', 'V': 'V', 'W': 'W', 'x': 'x', 'Y': 'Y'\n    }\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        left_char = s[i]\n        right_char = s[n - 1 - i]\n        \n        if left_char not in mirror_chars or right_char not in mirror_chars:\n            return \"NIE\"\n        if mirror_chars[left_char] != right_char:\n            return \"NIE\"\n    \n    return \"TAK\"\n\ns = input().strip()\nprint(is_s_palindrome(s))\n```",
    "30": "```python\ndef min_traps(m, x):\n    # Since GCD(x, m) = 1, the x-mouse will visit all m rooms.\n    # To catch the x-mouse, we need traps in all rooms except the starting room.\n    return m - 1\n\nm, x = map(int, input().split())\nprint(min_traps(m, x))\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = []\nregulars = []\n\nfor name, typ in files:\n    if typ == '1':\n        examples.append(name)\n    else:\n        regulars.append(name)\n\ne = len(examples)\nmoves = []\n\n# Rename examples to 1, 2, ..., e\nfor i in range(e):\n    moves.append(f\"move {examples[i]} {i + 1}\")\n\n# Rename regular tests to e + 1, e + 2, ..., n\nfor i in range(len(regulars)):\n    moves.append(f\"move {regulars[i]} {e + i + 1}\")\n\nprint(len(moves))\nprint(\"\\n\".join(moves))\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef main():\n    n, k = map(int, input().split())\n    main_courses = set(map(int, input().split()))\n    \n    # Build the graph and indegree count\n    graph = defaultdict(list)\n    indegree = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        data = list(map(int, input().split()))\n        t_i = data[0]\n        dependencies = data[1:t_i + 1]\n        for dep in dependencies:\n            graph[dep].append(i)\n            indegree[i] += 1\n    \n    # Topological sort using Kahn's algorithm\n    queue = deque()\n    for course in range(1, n + 1):\n        if indegree[course] == 0:\n            queue.append(course)\n    \n    order = []\n    while queue:\n        current = queue.popleft()\n        order.append(current)\n        for neighbor in graph[current]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check if we can complete all main courses\n    completed_courses = set()\n    for course in order:\n        if course in main_courses:\n            completed_courses.add(course)\n        if len(completed_courses) == len(main_courses):\n            break\n    \n    if len(completed_courses) < len(main_courses):\n        print(-1)\n        return\n    \n    # Collect all courses needed to complete the main courses\n    needed_courses = set()\n    for course in main_courses:\n        stack = [course]\n        while stack:\n            current = stack.pop()\n            if current not in needed_courses:\n                needed_courses.add(current)\n                stack.extend(graph[current])\n    \n    # Filter the order to only include needed courses\n    result = [course for course in order if course in needed_courses]\n    \n    print(len(result))\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "27": "```python\nn = int(input())\ns = input()\n\nmin_operations = n  # Start with the maximum operations (typing all characters)\n\n# Check for all possible prefixes\nfor i in range(1, n + 1):\n    prefix = s[:i]\n    # Check if the string can be formed by prefix + copy + remaining characters\n    if s.startswith(prefix * 2):\n        # If we can copy the prefix, we need to type i characters, then 1 copy, then the remaining characters\n        operations = i + 1 + (n - 2 * i)\n        min_operations = min(min_operations, operations)\n\n# Output the minimum operations found\nprint(min_operations)\n```",
    "24": "```python\ndef can_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # horizontal, vertical, diagonal, anti-diagonal\n    n = 10\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                # Temporarily place 'X' in the empty cell\n                board[i][j] = 'X'\n                \n                # Check all directions for a winning line\n                for dx, dy in directions:\n                    count = 1\n                    \n                    # Check in the positive direction\n                    x, y = i + dx, j + dy\n                    while 0 <= x < n and 0 <= y < n and board[x][y] == 'X':\n                        count += 1\n                        x += dx\n                        y += dy\n                    \n                    # Check in the negative direction\n                    x, y = i - dx, j - dy\n                    while 0 <= x < n and 0 <= y < n and board[x][y] == 'X':\n                        count += 1\n                        x -= dx\n                        y -= dy\n                    \n                    if count >= 5:\n                        return \"YES\"\n                \n                # Restore the empty cell\n                board[i][j] = '.'\n    \n    return \"NO\"\n\n# Read input\nboard = [input().strip() for _ in range(10)]\nprint(can_win(board))\n```",
    "0": "```python\ndef max_length_accordion(s):\n    n = len(s)\n    left_bracket_index = -1\n    right_bracket_index = -1\n    max_length = -1\n\n    # Find the first opening bracket\n    for i in range(n):\n        if s[i] == '[':\n            left_bracket_index = i\n            break\n\n    # Find the last closing bracket\n    for i in range(n - 1, -1, -1):\n        if s[i] == ']':\n            right_bracket_index = i\n            break\n\n    # If we didn't find both brackets or they are in the wrong order, return -1\n    if left_bracket_index == -1 or right_bracket_index == -1 or left_bracket_index >= right_bracket_index:\n        return -1\n\n    # Now we need to find the colons and vertical lines\n    first_colon_index = -1\n    second_colon_index = -1\n    vertical_lines_count = 0\n\n    # Find the first colon after the left bracket\n    for i in range(left_bracket_index + 1, right_bracket_index):\n        if s[i] == ':':\n            if first_colon_index == -1:\n                first_colon_index = i\n            elif second_colon_index == -1:\n                second_colon_index = i\n                break\n        elif s[i] == '|':\n            if first_colon_index != -1:\n                vertical_lines_count += 1\n\n    # If we didn't find two colons, return -1\n    if first_colon_index == -1 or second_colon_index == -1:\n        return -1\n\n    # The maximum length of the accordion\n    max_length = 4 + vertical_lines_count  # 4 for [::] and vertical lines in between\n\n    return max_length\n\n# Read input\ns = input().strip()\n# Get the result and print it\nprint(max_length_accordion(s))\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    if k > n * (n + 1) // 2:\n        return -1\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k > 0:\n            matrix[i][i] = 1\n            k -= 1\n        \n        for j in range(i + 1, n):\n            if k >= 2:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n            \n            if k == 0:\n                break\n        \n        if k == 0:\n            break\n    \n    if k > 0:\n        return -1\n    \n    return matrix\n\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    # Calculate the difference\n    diff = abs(sum_first - sum_second)\n    \n    # Create a list of possible changes\n    changes = []\n    if sum_first > sum_second:\n        # We need to decrease sum_first or increase sum_second\n        changes = [9 - d for d in first_half] + [d for d in second_half]\n    else:\n        # We need to decrease sum_second or increase sum_first\n        changes = [9 - d for d in second_half] + [d for d in first_half]\n    \n    # Sort changes in descending order\n    changes.sort(reverse=True)\n    \n    count = 0\n    for change in changes:\n        diff -= change\n        count += 1\n        if diff <= 0:\n            break\n    \n    return count\n\n# Input\nticket = input().strip()\n# Output\nprint(min_replacements_to_lucky(ticket))\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inv(a, p):\n    return pow(a, p - 2, p)\n\ndef birthday_paradox(n, k):\n    MOD = 1000003\n    days = 1 << n  # 2^n\n    if k > days:\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the probability of no shared birthdays\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator *= (days - i)\n        denominator *= days\n        numerator %= MOD\n        denominator %= MOD\n\n    # Probability of at least one shared birthday\n    A = (denominator - numerator) % MOD\n    B = denominator\n\n    # Reduce A/B to irreducible form\n    common_gcd = gcd(A, B)\n    A //= common_gcd\n    B //= common_gcd\n\n    return A % MOD, B % MOD\n\n# Read input\nn, k = map(int, input().split())\nA, B = birthday_paradox(n, k)\nprint(A, B)\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ns = input().strip()\n\nif not is_palindrome(s):\n    print(len(s))\nelse:\n    # Check for the longest non-palindrome substring\n    n = len(s)\n    # If all characters are the same, return 0\n    if s.count(s[0]) == n:\n        print(0)\n    else:\n        print(n - 1)  # The longest non-palindrome substring can be of length n-1\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    def can_distribute(x):\n        plates_for_a = (a + x - 1) // x  # ceil(a / x)\n        plates_for_b = (b + x - 1) // x  # ceil(b / x)\n        return plates_for_a + plates_for_b <= n\n\n    low, high = 1, max(a, b)\n    result = 0\n\n    while low <= high:\n        mid = (low + high) // 2\n        if can_distribute(mid):\n            result = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return result\n\n# Read input\nn, a, b = map(int, input().split())\n# Output the result\nprint(max_min_pieces(n, a, b))\n```",
    "32": "```python\nn = int(input())\nposition = 0  # Position in kilometers from the North Pole (0 = North Pole, 20000 = South Pole)\n\nvalid = True\n\nfor _ in range(n):\n    t, direction = input().split()\n    t = int(t)\n\n    if position == 0 and direction != \"South\":\n        valid = False\n        break\n    elif position == 20000 and direction != \"North\":\n        valid = False\n        break\n\n    if direction == \"South\":\n        position += t\n    elif direction == \"North\":\n        position -= t\n    # West and East do not affect the North/South position\n    elif direction in (\"West\", \"East\"):\n        continue\n\n    # Check if the position is out of bounds\n    if position < 0 or position > 20000:\n        valid = False\n        break\n\n# Check if the journey ends at the North Pole\nif valid and position == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if any participant's rating has changed\nif any(a != b for a, b in ratings):\n    print(\"rated\")\nelse:\n    # Check if the ratings are in non-increasing order\n    unrated = any(ratings[i][0] < ratings[i + 1][0] for i in range(n - 1))\n    if unrated:\n        print(\"unrated\")\n    else:\n        print(\"maybe\")\n```",
    "38": "```python\ndef can_be_same_track(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between barriers for Kefa and Sasha\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Create a double version of Sasha's differences for easier rotation checking\n    sasha_diffs_extended = sasha_diffs * 2\n    \n    # Check if Kefa's differences can match Sasha's differences by rotation\n    for i in range(n):\n        if kefa_diffs == sasha_diffs_extended[i:i+n]:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_be_same_track(n, L, kefa_distances, sasha_distances))\n```",
    "41": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the distance array with a large number\ndistances = [float('inf')] * n\n\n# First pass: from left to right\nfor i in range(n):\n    if a[i] == 0:\n        distances[i] = 0\n    elif i > 0:\n        distances[i] = distances[i - 1] + 1\n\n# Second pass: from right to left\nfor i in range(n - 1, -1, -1):\n    if a[i] == 0:\n        distances[i] = 0\n    else:\n        distances[i] = min(distances[i], distances[i + 1] + 1)\n\nprint(' '.join(map(str, distances)))\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n\n    len_s = len(s)\n    total_count = 0\n    seen = set()\n\n    # Generate all binary strings of length n\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        # Check if s is a substring in any cyclic shift of t\n        if any(s in t[i:] + t[:i] for i in range(n)):\n            # Add the cyclic string to the set to ensure uniqueness\n            seen.add(t)\n\n    return len(seen)\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_cyclic_strings(n, s))\n```",
    "35": "```python\ndef is_valid_flag(n, m, field):\n    if n % 3 != 0:\n        return \"NO\"\n    \n    stripe_height = n // 3\n    colors = set()\n    \n    # Check for horizontal stripes\n    for i in range(3):\n        stripe_color = field[i * stripe_height][0]\n        if stripe_color not in 'RGB' or stripe_color in colors:\n            return \"NO\"\n        colors.add(stripe_color)\n        for j in range(stripe_height):\n            if field[i * stripe_height + j] != stripe_color * m:\n                return \"NO\"\n    \n    return \"YES\" if len(colors) == 3 else \"NO\"\n\ndef main():\n    n, m = map(int, input().split())\n    field = [input().strip() for _ in range(n)]\n    \n    result = is_valid_flag(n, m, field)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Minimum sum of first k positive integers\n    min_sum = k * (k + 1) // 2\n    \n    if n < min_sum:\n        return -1\n    \n    # The maximum GCD we can use\n    g = (n - min_sum) // k + 1\n    \n    # Create the sequence\n    sequence = [i + g for i in range(1, k + 1)]\n    \n    return sequence\n\n# Read input\nn, k = map(int, input().split())\n\n# Get the result\nresult = find_sequence(n, k)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "36": "```python\ndef hexagonal_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 1\n\n    # Determine the layer where the nth move is located\n    while n >= moves_in_layer:\n        n -= moves_in_layer\n        layer += 1\n        moves_in_layer = 6 * layer\n\n    # Starting coordinates at the beginning of the layer\n    x, y = layer, 0\n\n    # If no moves are left, return the current coordinates\n    if n == 0:\n        return (x, y)\n\n    # Directions for moving in the hexagonal grid\n    directions = [\n        (1, 0),  # right\n        (0, 1),  # top-right\n        (-1, 1), # top-left\n        (-1, 0), # left\n        (0, -1), # bottom-left\n        (1, -1)  # bottom-right\n    ]\n\n    # Move in the determined direction for the remaining moves\n    for i in range(n):\n        dx, dy = directions[i % 6]\n        x += dx\n        y += dy\n\n    return (x, y)\n\nn = int(input().strip())\nx, y = hexagonal_coordinates(n)\nprint(x, y)\n```",
    "49": "```python\ndef find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n\n    # Determine the range where the k-th digit falls\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    # Find the actual number that contains the k-th digit\n    start += (k - 1) // length\n    num_str = str(start)\n    \n    # Find the digit in that number\n    digit_index = (k - 1) % length\n    return num_str[digit_index]\n\nk = int(input().strip())\nprint(find_kth_digit(k))\n```",
    "46": "```python\ndef count_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n    \n    # Count occurrences of each remainder when divided by 5 for x\n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n        \n    # Count occurrences of each remainder when divided by 5 for y\n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n        \n    result = 0\n    # Calculate pairs where (x + y) % 5 == 0\n    for i in range(5):\n        result += count_x[i] * count_y[(5 - i) % 5]\n        \n    return result\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))\n```",
    "47": "```python\ndef max_subarray_sum(arr):\n    max_ending_here = max_so_far = 0\n    for x in arr:\n        max_ending_here = max(0, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\ndef max_beauty_with_multiplier(n, x, a):\n    original_beauty = max_subarray_sum(a)\n\n    if x == 0:\n        return original_beauty\n\n    max_increase = 0\n    current_sum = 0\n    for i in range(n):\n        current_sum += a[i]\n        potential_increase = current_sum * (x - 1)\n        max_increase = max(max_increase, potential_increase)\n        if current_sum < 0:\n            current_sum = 0\n\n    return max(original_beauty, original_beauty + max_increase)\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\nprint(max_beauty_with_multiplier(n, x, a))\n```",
    "44": "```python\ndef minimal_time_to_post_office(d, k, a, b, t):\n    # Calculate the time if Vasiliy walks the entire distance\n    min_time = d * b\n    \n    # Calculate the number of full segments Vasiliy can drive\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Time taken if Vasiliy drives full segments and then walks the remaining distance\n    if full_segments > 0:\n        time_with_driving = (full_segments * k * a) + (full_segments - 1) * t + remaining_distance * b\n        min_time = min(min_time, time_with_driving)\n    \n    # Consider the case where Vasiliy drives less than full segments\n    for i in range(full_segments + 1):\n        time_with_driving = (i * k * a) + (i * t) + (d - i * k) * b\n        min_time = min(min_time, time_with_driving)\n    \n    return min_time\n\n# Input reading\nd, k, a, b, t = map(int, input().split())\n# Output the result\nprint(minimal_time_to_post_office(d, k, a, b, t))\n```",
    "51": "```python\nfrom collections import Counter\nimport sys\n\ndef find_x_y(divisors):\n    count = Counter(divisors)\n    # The largest number must be either x or y\n    max_divisor = max(count)\n    \n    # Remove the largest number from the count\n    count[max_divisor] -= 1\n    if count[max_divisor] == 0:\n        del count[max_divisor]\n    \n    # Now we need to find the other number\n    # The second number must be the product of the remaining divisors\n    product = 1\n    for d, freq in count.items():\n        product *= d ** freq\n    \n    return max_divisor, product\n\nn = int(input().strip())\ndivisors = list(map(int, input().strip().split()))\n\nx, y = find_x_y(divisors)\nprint(x, y)\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef reachable_count(n):\n    reachable = set()\n    current = n\n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    return len(reachable)\n\nn = int(input().strip())\nprint(reachable_count(n))\n```",
    "55": "```python\n# Read input coordinates for the white sheet and the two black sheets\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Determine the coverage of the black sheets\ncovered_left = min(x3, x5)\ncovered_right = max(x4, x6)\ncovered_bottom = min(y3, y5)\ncovered_top = max(y4, y6)\n\n# Check if the white sheet is fully covered by the black sheets\nif (x2 <= covered_left or x1 >= covered_right or\n    y2 <= covered_bottom or y1 >= covered_top):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "33": "```python\ndef count_common_integers(a1, b1, a2, b2, L, R):\n    from math import gcd\n\n    # Calculate the step size and the least common multiple\n    step = abs(a1 * a2 // gcd(a1, a2))\n\n    # Function to find the first valid x in the range [L, R] for a given progression\n    def first_valid_x(a, b):\n        if a == 0:\n            return b if L <= b <= R else None\n        k = (L - b + a - 1) // a\n        x = a * k + b\n        return x if L <= x <= R else None\n\n    # Function to find the last valid x in the range [L, R] for a given progression\n    def last_valid_x(a, b):\n        if a == 0:\n            return b if L <= b <= R else None\n        k = (R - b) // a\n        x = a * k + b\n        return x if L <= x <= R else None\n\n    # Get the first and last valid x from both progressions\n    x1 = first_valid_x(a1, b1)\n    x2 = first_valid_x(a2, b2)\n\n    if x1 is None or x2 is None:\n        return 0\n\n    # Calculate the first common x\n    first_common = max(x1, x2)\n    if (first_common - b1) % a1 != 0 or (first_common - b2) % a2 != 0:\n        return 0\n\n    # Calculate the last valid x\n    last_common = min(last_valid_x(a1, b1), last_valid_x(a2, b2))\n    if last_common is None or last_common < first_common:\n        return 0\n\n    # Count the number of valid integers in the range\n    return (last_common - first_common) // step + 1\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n# Get the result\nresult = count_common_integers(a1, b1, a2, b2, L, R)\n# Print the result\nprint(result)\n```",
    "54": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(0)\nelse:\n    min_a = min(a)\n    max_a = max(a)\n    \n    if max_a == min_a:\n        print(0)\n    elif max_a - min_a == 1:\n        print(1)\n    elif (max_a - min_a) % 2 == 0:\n        mid = (max_a + min_a) // 2\n        if mid in a:\n            print((max_a - min_a) // 2)\n        else:\n            print(-1)\n    else:\n        print(-1)\n```",
    "59": "```python\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# Create the target pattern for the last x digits\ntarget = ['0'] * x\ntarget[y] = '1'  # Set the y-th position to '1' for remainder 10^y\n\n# Count the number of changes needed\nchanges = 0\nfor i in range(x):\n    if number[n - 1 - i] != target[x - 1 - i]:\n        changes += 1\n\nprint(changes)\n```",
    "53": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nleft, right = 0, n - 1\nlast_taken = -1\nresult = []\nmoves = []\n\nwhile left <= right:\n    if a[left] < a[right]:\n        if a[left] > last_taken:\n            last_taken = a[left]\n            result.append(a[left])\n            moves.append('L')\n            left += 1\n        elif a[right] > last_taken:\n            last_taken = a[right]\n            result.append(a[right])\n            moves.append('R')\n            right -= 1\n        else:\n            break\n    else:\n        if a[right] > last_taken:\n            last_taken = a[right]\n            result.append(a[right])\n            moves.append('R')\n            right -= 1\n        elif a[left] > last_taken:\n            last_taken = a[left]\n            result.append(a[left])\n            moves.append('L')\n            left += 1\n        else:\n            break\n\nprint(len(result))\nprint(''.join(moves))\n```",
    "57": "```python\nn = int(input())\nf = list(map(int, input().split()))\n\n# Determine the friends who want to give gifts (those who have f_i != 0)\ngivers = set(range(1, n + 1)) - set(f)\n# Determine the friends who are already assigned to receive gifts\nreceivers = set(f) - {0}\n\n# Convert givers to a list for easier manipulation\ngivers = list(givers)\n\n# Fill the unknown values (f_i = 0)\nfor i in range(n):\n    if f[i] == 0:\n        # Find a giver who hasn't been assigned yet\n        for giver in givers:\n            if giver != i + 1 and giver not in receivers:\n                f[i] = giver\n                receivers.add(giver)\n                break\n\nprint(' '.join(map(str, f)))\n```",
    "58": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nfrom collections import defaultdict\n\n# Dictionary to hold the indices of each number\nindices = defaultdict(list)\n\nfor index, value in enumerate(a):\n    indices[value].append(index)\n\n# Check if we can color the array\nif len(indices) > k:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    color = [0] * n\n    current_color = 1\n    \n    # Assign colors while ensuring distinct colors for each number\n    for value, index_list in indices.items():\n        for index in index_list:\n            color[index] = current_color\n        current_color += 1\n        if current_color > k:\n            current_color = 1\n\n    # Ensure all colors from 1 to k are used at least once\n    used_colors = set(color)\n    if len(used_colors) < k:\n        print(\"NO\")\n    else:\n        print(\" \".join(map(str, color)))\n```",
    "63": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Sort the array to easily find min and max after removing an element\na.sort()\n\n# The minimum possible instability after removing one element\n# We can either remove the first element or the last element\nmin_instability = min(a[-1] - a[1], a[-2] - a[0])\n\nprint(min_instability)\n```",
    "50": "```python\nimport sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn = int(data[0])\nedges = [tuple(map(int, line.split())) for line in data[1:n]]\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\ndef bfs(start):\n    visited = [-1] * (n + 1)\n    queue = deque([start])\n    visited[start] = 0\n    farthest_node = start\n    max_distance = 0\n\n    while queue:\n        node = queue.popleft()\n        for neighbor in tree[node]:\n            if visited[neighbor] == -1:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > max_distance:\n                    max_distance = visited[neighbor]\n                    farthest_node = neighbor\n\n    return farthest_node, max_distance\n\n# Step 1: Find the farthest node from an arbitrary node (1)\nfarthest_from_start, _ = bfs(1)\n\n# Step 2: Find the farthest node from the farthest node found in step 1\nfarthest_from_farthest, diameter_length = bfs(farthest_from_start)\n\n# Step 3: Collect the path from farthest_from_start to farthest_from_farthest\ndef find_path(start, end):\n    parent = [-1] * (n + 1)\n    queue = deque([start])\n    visited = [False] * (n + 1)\n    visited[start] = True\n\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            break\n        for neighbor in tree[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                parent[neighbor] = node\n                queue.append(neighbor)\n\n    path = []\n    while end != -1:\n        path.append(end)\n        end = parent[end]\n    return path[::-1]\n\npath = find_path(farthest_from_start, farthest_from_farthest)\n\n# Step 4: Choose three vertices from the path\na = path[0]\nb = path[-1]\nc = path[len(path) // 2]  # Choose a middle point\n\n# Step 5: Calculate the number of edges in the union of paths\n# The maximum number of edges in the union of paths is:\nmax_edges = len(path) - 1 + (n - len(path))\n\nprint(max_edges)\nprint(a, b, c)\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_choose = m // 2\n    dp = [[-1] * k for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        row = sorted(matrix[i - 1], reverse=True)\n        current_dp = dp[i - 1][:]\n        \n        for j in range(1, max_choose + 1):\n            if j > len(row):\n                break\n            current_sum = sum(row[:j])\n            for r in range(k):\n                if current_dp[r] != -1:\n                    new_sum = current_dp[r] + current_sum\n                    new_rem = new_sum % k\n                    if dp[i][new_rem] < new_sum:\n                        dp[i][new_rem] = new_sum\n\n        for r in range(k):\n            if dp[i - 1][r] != -1:\n                dp[i][r] = max(dp[i][r], dp[i - 1][r])\n\n    return dp[n][0] if dp[n][0] != -1 else 0\n\n# Input reading\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_sum_divisible_by_k(n, m, k, matrix))\n```",
    "60": "```python\ndef has_palindrome_subsequence(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        found = False\n        # Use a dictionary to track the last seen index of each number\n        last_seen = {}\n        for i in range(n):\n            if a[i] in last_seen:\n                # If we have seen this number before, check the distance\n                if i - last_seen[a[i]] >= 2:\n                    found = True\n                    break\n            last_seen[a[i]] = i\n        results.append(\"YES\" if found else \"NO\")\n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Get results\nresults = has_palindrome_subsequence(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "67": "```python\nn = int(input())\na = list(map(int, input().split()))\n\ntotal_sum = sum(a)\nnice_indices = []\n\nfor j in range(n):\n    remaining_sum = total_sum - a[j]\n    if remaining_sum == a[j] * 2:\n        nice_indices.append(j + 1)\n\nprint(len(nice_indices))\nif nice_indices:\n    print(' '.join(map(str, nice_indices)))\n```",
    "66": "```python\ndef minimum_length_string(n, k, t):\n    # Find the longest suffix of t that is also a prefix\n    overlap_length = 0\n    for i in range(1, n):\n        if t.startswith(t[i:]):\n            overlap_length = n - i\n            break\n\n    # Construct the result string\n    result = t + (t[overlap_length:] * (k - 1))\n    return result\n\n# Read input\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the result and print it\nresult = minimum_length_string(n, k, t)\nprint(result)\n```",
    "71": "```python\na = int(input())\nif 1 <= a <= 64:\n    output = (a - 1).bit_length()\n    print(output)\nelse:\n    print(\"Input must be between 1 and 64.\")\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        min_ops = float('inf')\n        best_triple = (0, 0, 0)\n\n        for A in range(1, a + 1):\n            for B in range(A, c + 1):\n                if B % A == 0:\n                    C = (B // A) * A\n                    if C < b:\n                        C += A * ((b - C + A - 1) // A)\n                    if C >= B:\n                        ops = abs(A - a) + abs(B - b) + abs(C - c)\n                        if ops < min_ops:\n                            min_ops = ops\n                            best_triple = (A, B, C)\n\n        results.append((min_ops, best_triple))\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations(t, test_cases)\n\n# Output results\nfor ops, (A, B, C) in results:\n    print(ops)\n    print(A, B, C)\n```",
    "70": "```python\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Convert start and end times to total minutes\nstart_minutes = h1 * 60 + m1\nend_minutes = h2 * 60 + m2\n\n# Calculate midpoint in total minutes\nmidpoint_minutes = (start_minutes + end_minutes) // 2\n\n# Convert back to hours and minutes\nh3 = midpoint_minutes // 60\nm3 = midpoint_minutes % 60\n\n# Print the result in hh:mm format\nprint(f\"{h3:02}:{m3:02}\")\n```",
    "77": "```python\nn = int(input())\ntotal_sum = n * (n + 1) // 2\nprint(total_sum % 2)\n```",
    "73": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmax_height = max(a)\ntotal_bricks_needed = 0\ntotal_bricks_available = sum(a)\n\nfor height in a:\n    if height < max_height:\n        total_bricks_needed += max_height - height\n\n# Check if the total available bricks can cover the needed bricks\nif total_bricks_available >= total_bricks_needed:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import Counter\n    from math import comb\n\n    # Count the frequency of each character\n    freq = Counter(s)\n    \n    # Calculate the number of unique subsequences we can generate\n    unique_subsequences_count = 0\n    subsequence_costs = []\n\n    # Generate subsequences and their costs\n    for length in range(1, n + 1):\n        for char in freq:\n            if freq[char] >= length:\n                # The number of ways to choose 'length' characters from 'freq[char]'\n                count = comb(freq[char], length)\n                unique_subsequences_count += count\n                subsequence_costs.extend([n - length] * count)\n    \n    # If we cannot generate enough unique subsequences\n    if unique_subsequences_count < k:\n        return -1\n    \n    # Sort costs to minimize the total cost\n    subsequence_costs.sort()\n    \n    # Calculate the minimum cost to obtain k unique subsequences\n    total_cost = sum(subsequence_costs[:k])\n    \n    return total_cost\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "64": "```python\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Prepare the schedule\nschedule = [0] * n  # 0 means rest day\nexam_days = set()\n\n# Mark exam days\nfor i in range(m):\n    s, d, c = exams[i]\n    exam_days.add(d - 1)  # d is 1-based, convert to 0-based for index\n\n# Prepare for exams\npreparation_days = [0] * m\nfor i in range(m):\n    s, d, c = exams[i]\n    count = 0\n    for day in range(s - 1, d - 1):\n        if count < c and schedule[day] == 0:  # If it's a rest day\n            schedule[day] = i + 1  # Mark preparation for exam i\n            count += 1\n    preparation_days[i] = count\n\n# Check if all preparations are done\nif any(preparation_days[i] < exams[i][2] for i in range(m)):\n    print(-1)\nelse:\n    # Fill exam days\n    for i in range(m):\n        d = exams[i][1] - 1\n        schedule[d] = m + 1  # Mark exam day\n\n    print(\" \".join(map(str, schedule)))\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    unique_subsequences = set()\n    total_cost = 0\n    \n    # Generate all possible subsequences\n    for i in range(1 << n):\n        subsequence = []\n        for j in range(n):\n            if i & (1 << j):\n                subsequence.append(s[j])\n        subsequence_str = ''.join(subsequence)\n        if subsequence_str not in unique_subsequences:\n            unique_subsequences.add(subsequence_str)\n            total_cost += n - len(subsequence_str)\n            if len(unique_subsequences) == k:\n                return total_cost\n    \n    return -1 if len(unique_subsequences) < k else total_cost\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "81": "```python\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\n# Sort strings by length\nstrings.sort(key=len)\n\n# Check if the order is valid\nfor i in range(1, n):\n    if strings[i-1] not in strings[i]:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")\n    print(\"\\n\".join(strings))\n```",
    "82": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncount = 0\n\n# Solve from the left\nwhile count < n and a[count] <= k:\n    count += 1\n\n# Solve from the right\nright_count = 0\nwhile right_count < n and a[n - 1 - right_count] <= k:\n    right_count += 1\n\n# Adjust count to avoid double counting if both ends are solved\nif count + right_count > n:\n    count = n\nelse:\n    count += right_count\n\nprint(count)\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    lefts = [l for l, r in segments]\n    rights = [r for l, r in segments]\n\n    max_left = max(lefts)\n    min_right = min(rights)\n\n    # Precompute the second max left and second min right\n    sorted_lefts = sorted(lefts)\n    sorted_rights = sorted(rights)\n\n    second_max_left = sorted_lefts[-2] if n > 1 else float('-inf')\n    second_min_right = sorted_rights[1] if n > 1 else float('inf')\n\n    max_length = 0\n\n    for l, r in segments:\n        current_left = second_max_left if l == max_left else max_left\n        current_right = second_min_right if r == min_right else min_right\n\n        if current_left <= current_right:\n            max_length = max(max_length, current_right - current_left)\n\n    return max_length\n\n# Input reading\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_intersection_length(n, segments))\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    # Create a list to store the color of each character\n    colors = [0] * n\n    # Create a dictionary to track the last seen index of each character\n    last_seen = {}\n    color_count = 0\n    \n    for i in range(n):\n        char = s[i]\n        if char not in last_seen:\n            color_count += 1\n            last_seen[char] = color_count\n        colors[i] = last_seen[char]\n    \n    # Output the result\n    print(color_count)\n    print(' '.join(map(str, colors)))\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\nmin_colors_to_sort(n, s)\n```",
    "76": "```python\ndef can_construct_symmetric_square(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Check for pairs of tiles that can form a symmetric structure\n        tile_set = set()\n        can_form_symmetric = False\n        \n        for tile in tiles:\n            top_left, top_right = tile[0]\n            bottom_left, bottom_right = tile[1]\n            tile_set.add((top_left, top_right, bottom_left, bottom_right))\n            # Check for the symmetric counterpart\n            if (top_right, top_left, bottom_right, bottom_left) in tile_set:\n                can_form_symmetric = True\n        \n        results.append(\"YES\" if can_form_symmetric else \"NO\")\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        top = tuple(map(int, input().split()))\n        bottom = tuple(map(int, input().split()))\n        tiles.append((top, bottom))\n    test_cases.append((n, m, tiles))\n\n# Get results\nresults = can_construct_symmetric_square(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n    \n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n\n    if len(graph[1]) < D:\n        print(\"NO\")\n        return\n\n    # Start building the spanning tree\n    spanning_tree_edges = []\n    visited = [False] * (n + 1)\n    visited[1] = True\n    degree = 0\n\n    # Use a queue for BFS\n    queue = deque([1])\n    \n    while queue:\n        current = queue.popleft()\n        \n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                if degree < D and current == 1:\n                    # Connect this neighbor to vertex 1\n                    spanning_tree_edges.append((1, neighbor))\n                    degree += 1\n                else:\n                    # Connect this neighbor to the current node\n                    spanning_tree_edges.append((current, neighbor))\n                \n                visited[neighbor] = True\n                queue.append(neighbor)\n\n                # Stop if we already have enough edges\n                if len(spanning_tree_edges) == n - 1:\n                    break\n        if len(spanning_tree_edges) == n - 1:\n            break\n\n    if degree != D or len(spanning_tree_edges) != n - 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for v, u in spanning_tree_edges:\n            print(v, u)\n\n# Input reading\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nfind_spanning_tree(n, m, D, edges)\n```",
    "84": "```python\ndef can_color_string(n, s):\n    from collections import Counter\n    \n    # Count occurrences of each character\n    count = Counter(s)\n    \n    # Check if any character appears more than twice\n    if any(cnt > 2 for cnt in count.values()):\n        return \"NO\", \"\"\n    \n    # Create a coloring scheme\n    color = ['0'] * n\n    last_color = '0'\n    \n    for i in range(n):\n        if i > 0 and s[i] == s[i - 1]:\n            color[i] = color[i - 1]  # Same color as previous\n        else:\n            # Alternate color\n            last_color = '1' if last_color == '0' else '0'\n            color[i] = last_color\n    \n    return \"YES\", ''.join(color)\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult, coloring = can_color_string(n, s)\n\n# Output the result\nprint(result)\nif result == \"YES\":\n    print(coloring)\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    target_pairs = ['00', '25', '50', '75']\n    min_moves = float('inf')\n\n    for pair in target_pairs:\n        last_digit = pair[1]\n        first_digit = pair[0]\n        \n        # Find the last occurrence of the second digit\n        last_index = -1\n        for i in range(length - 1, -1, -1):\n            if s[i] == last_digit:\n                last_index = i\n                break\n        \n        if last_index == -1:\n            continue\n        \n        # Now find the first occurrence of the first digit before the last_index\n        first_index = -1\n        for i in range(last_index - 1, -1, -1):\n            if s[i] == first_digit:\n                first_index = i\n                break\n        \n        if first_index == -1:\n            continue\n        \n        # Calculate moves to bring first_index to the position before last_index\n        moves = (last_index - first_index) + (length - 1 - last_index)\n        min_moves = min(min_moves, moves)\n\n    return min_moves if min_moves != float('inf') else -1\n\n# Input reading\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n\n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            # Check for red rectangle\n            for red_width in range(1, int(a**0.5) + 1):\n                if a % red_width == 0:\n                    red_height = a // red_width\n                    if red_width <= width and red_height <= height:\n                        # Check for blue rectangle\n                        for blue_width in range(1, int(b**0.5) + 1):\n                            if b % blue_width == 0:\n                                blue_height = b // blue_width\n                                if blue_width <= width and blue_height <= height:\n                                    perimeter = 2 * (width + height)\n                                    min_perimeter = min(min_perimeter, perimeter)\n\n    return min_perimeter\n\na, b = map(int, input().split())\nprint(minimal_perimeter(a, b))\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects by their required rating (a_i)\n    projects.sort(key=lambda x: x[0])\n    \n    for a, b in projects:\n        if r < a:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_complete_projects(n, r, projects))\n```",
    "78": "```python\nMOD = 10**9 + 7\n\ndef count_regular_sequences(n, s):\n    m = len(s)\n    \n    # Precompute factorials and inverse factorials\n    fact = [1] * (2 * n + 1)\n    for i in range(2, 2 * n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    \n    def mod_inv(x):\n        return pow(x, MOD - 2, MOD)\n    \n    inv_fact = [1] * (2 * n + 1)\n    for i in range(2, 2 * n + 1):\n        inv_fact[i] = mod_inv(fact[i])\n    \n    # Check if s can be part of a valid sequence\n    balance = 0\n    min_balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n    \n    if balance < 0 or balance > 2 * n or min_balance < 0:\n        return 0\n    \n    # Count the number of valid sequences of length 2n\n    total_valid_sequences = 0\n    \n    for prefix_length in range(n + 1):\n        suffix_length = n - prefix_length\n        if suffix_length < 0:\n            continue\n        \n        # Valid prefix must have a balance of 0 at the end\n        prefix_balance = prefix_length - (n - prefix_length)\n        \n        if prefix_balance < 0:\n            continue\n        \n        # Valid suffix must also have a balance of 0 at the end\n        suffix_balance = suffix_length - (n - suffix_length)\n        \n        if suffix_balance < 0:\n            continue\n        \n        # Count valid sequences\n        total_valid_sequences += (fact[prefix_length] * inv_fact[prefix_length // 2] % MOD) * (fact[suffix_length] * inv_fact[suffix_length // 2] % MOD) % MOD\n        total_valid_sequences %= MOD\n    \n    return total_valid_sequences\n\nn = int(input())\ns = input().strip()\nprint(count_regular_sequences(n, s))\n```",
    "92": "```python\nx = float(input().strip())\n\n# Iterate through all possible pairs (a, b) in the range [1, 10]\nfor a in range(1, 11):\n    for b in range(1, 11):\n        if abs(a * b - x) < 1e-6:  # Check if the product is close to x\n            print(a, b)\n            exit()  # Exit after finding the first valid pair\n```",
    "86": "```python\ndef solve(n, k):\n    # Minimum sum of the first k natural numbers\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n\n    # Initialize the array with the minimum valid values\n    a = list(range(1, k + 1))\n    current_sum = min_sum\n\n    # Try to adjust the last element to reach n\n    for i in range(k - 1, -1, -1):\n        # Calculate the maximum value we can assign to a[i]\n        max_value = 2 * a[i] if i < k - 1 else n - current_sum + a[i]\n        # Ensure we don't exceed the required total n\n        if current_sum < n:\n            increment = min(max_value - a[i], n - current_sum)\n            a[i] += increment\n            current_sum += increment\n\n        # If we have reached the required sum, we can stop\n        if current_sum == n:\n            break\n\n    # Check if the conditions are satisfied\n    valid = True\n    for i in range(1, k):\n        if not (a[i - 1] < a[i] <= 2 * a[i - 1]):\n            valid = False\n            break\n\n    if valid and current_sum == n:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n    else:\n        print(\"NO\")\n\n# Read input\nn, k = map(int, input().split())\nsolve(n, k)\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects by required rating, then by rating change descending\n    projects.sort(key=lambda x: (x[0], -x[1]))\n    completed = 0\n\n    while True:\n        progress = False\n        for i in range(len(projects)):\n            a, b = projects[i]\n            if r >= a:  # Can complete this project\n                r += b  # Update rating\n                completed += 1\n                projects[i] = (float('inf'), 0)  # Mark as completed\n                progress = True\n                break  # Restart from the beginning\n        if not progress:\n            break  # No more projects can be completed\n\n    return completed\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = max_projects(n, r, projects)\nprint(result)\n```",
    "97": "```python\nn = int(input())\nchips = list(map(int, input().split()))\n\neven_count = sum(1 for x in chips if x % 2 == 0)\nodd_count = n - even_count\n\n# The minimum cost is the number of chips that are in the minority\nprint(min(even_count, odd_count))\n```",
    "88": "```python\nfrom collections import Counter\n\nn = int(input())\na = list(map(int, input().split()))\n\ncount = Counter(a)\nmatrix = [[0] * n for _ in range(n)]\n\n# Check for the number of odd occurrences\nodd_count = 0\nodd_value = None\n\nfor value, freq in count.items():\n    if freq % 2 != 0:\n        odd_count += 1\n        odd_value = value\n    if odd_count > 1:\n        print(\"NO\")\n        exit()\n\n# If n is odd, we can have one odd frequency number in the center\nif n % 2 == 1 and odd_count == 0:\n    print(\"NO\")\n    exit()\n\n# Fill the matrix\nhalf_matrix = []\nfor value, freq in count.items():\n    half_matrix.extend([value] * (freq // 2))\n\n# Create the palindromic structure\nhalf_size = len(half_matrix)\ncenter = [odd_value] * (n % 2)  # Only add the odd value if n is odd\n\n# Fill the top half of the matrix\nfor i in range(n // 2):\n    matrix[i] = half_matrix[i:half_size - i] + center + half_matrix[half_size - i:half_size][::-1]\n\n# Fill the bottom half of the matrix\nfor i in range(n // 2):\n    matrix[n - 1 - i] = matrix[i][:]\n\n# If n is odd, fill the center row\nif n % 2 == 1:\n    matrix[n // 2] = center + half_matrix + half_matrix[::-1]\n\nprint(\"YES\")\nfor row in matrix:\n    print(\" \".join(map(str, row)))\n```",
    "95": "```python\nn = int(input())\ns = input().strip()\nt = input().strip()\n\n# Create a list of characters to use\nchars = ['a'] * n + ['b'] * n + ['c'] * n\n\n# Function to check if the current string contains forbidden substrings\ndef contains_forbidden_substrings(res):\n    return s in res or t in res\n\n# Generate a valid string without forbidden substrings\ndef generate_valid_string(n, s, t):\n    # Start with a base pattern that avoids the forbidden substrings\n    base = \"abc\" * n\n    # Check if the base contains forbidden substrings\n    if contains_forbidden_substrings(base):\n        # If it does, we can try to rearrange\n        # We can use a simple strategy to avoid forbidden pairs\n        # by cycling through the characters\n        res = []\n        for i in range(n):\n            if i % 2 == 0:\n                res.append('a')\n                res.append('b')\n                res.append('c')\n            else:\n                res.append('c')\n                res.append('a')\n                res.append('b')\n        res = ''.join(res)\n        if contains_forbidden_substrings(res):\n            return \"NO\"\n        return res\n    return base\n\nresult = generate_valid_string(n, s, t)\nif result == \"NO\":\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(result)\n```",
    "90": "```python\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculate the total length of platforms\ntotal_length = sum(c)\n\n# If the maximum jump distance is greater than or equal to n, we can always reach the end\nif d >= n:\n    print(\"YES\")\n    print(\"0 \" * n + str(m))\n    exit()\n\n# We need to check if we can place the platforms such that we can jump from 0 to n + 1\n# The maximum distance we can jump is d, so we need to ensure that the gaps between platforms\n# do not exceed d.\n\n# Start placing platforms\na = [0] * n\ncurrent_position = 0\n\n# Place platforms in the array\nfor i in range(m):\n    for j in range(c[i]):\n        a[current_position + j] = i + 1\n    current_position += c[i]\n\n# Check if we can jump from the end of the last platform to n + 1\nif current_position + d >= n + 1:\n    print(\"YES\")\n    print(\" \".join(map(str, a)))\nelse:\n    # Check for gaps between platforms\n    gap = d\n    last_position = 0\n    \n    for i in range(m):\n        # Check if we can jump from the last position to the start of the current platform\n        if last_position + gap < current_position:\n            print(\"NO\")\n            exit()\n        last_position += c[i]\n\n    # Final check from the last platform to n + 1\n    if last_position + d >= n + 1:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n    else:\n        print(\"NO\")\n```",
    "99": "```python\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\n# Maximum wins for Alice\nmax_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n\n# Minimum wins for Alice\n# Calculate losses for Alice\nalice_losses = max(0, b1 - a3) + max(0, b2 - a1) + max(0, b3 - a2)\nmin_wins = n - alice_losses\n\nprint(min_wins, max_wins)\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Determine the starting character based on the parity of x\n    start_with_one = (x % 2 == 1 and b > 0) or (x % 2 == 0 and a == 0)\n\n    # Initialize the result list\n    result = []\n    \n    # Determine the initial character\n    current_char = '1' if start_with_one else '0'\n    \n    # Alternate characters for x transitions\n    for i in range(x):\n        result.append(current_char)\n        current_char = '0' if current_char == '1' else '1'\n    \n    # Count how many 0s and 1s we have used\n    used_zeros = result.count('0')\n    used_ones = result.count('1')\n    \n    # Calculate remaining 0s and 1s\n    remaining_zeros = a - used_zeros\n    remaining_ones = b - used_ones\n    \n    # Add remaining characters to the end of the result\n    if current_char == '0':\n        result.append('0' * remaining_zeros)\n        result.append('1' * remaining_ones)\n    else:\n        result.append('1' * remaining_ones)\n        result.append('0' * remaining_zeros)\n    \n    # Join the result list into a string\n    return ''.join(result)\n\n# Read input\na, b, x = map(int, input().split())\n\n# Construct and print the binary string\nprint(construct_binary_string(a, b, x))\n```",
    "96": "```python\nn = int(input())\nq = list(map(int, input().split()))\n\n# Initialize the permutation array\np = [0] * n\n\n# Build the permutation based on the differences\nfor i in range(1, n):\n    p[i] = p[i - 1] + q[i - 1]\n\n# Find the minimum value in p to normalize it to start from 1\nmin_p = min(p)\n\n# Normalize the permutation to start from 1\nfor i in range(n):\n    p[i] -= min_p - 1\n\n# Check if the permutation is valid\nif len(set(p)) == n and all(1 <= x <= n for x in p):\n    print(' '.join(map(str, p)))\nelse:\n    print(-1)\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n\n    # Precompute the leftmost and rightmost positions of t in s\n    left = [0] * m\n    right = [0] * m\n\n    # Fill left array\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n\n    # Fill right array\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n\n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n\n    # Consider removing from the start to the first character of t\n    max_length = max(max_length, right[0])\n    # Consider removing from the last character of t to the end\n    max_length = max(max_length, n - 1 - left[m - 1])\n\n    return max_length\n\n# Input reading\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(max_removable_length(s, t))\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1 or (d > 1 and n < d + 1) or (k == 1 and n > 1):\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    edges = []\n    \n    # Create the main path for the diameter\n    for i in range(1, d + 2):\n        edges.append((i, i + 1))\n    \n    # Now we have a path of length d, which uses d edges and d + 1 vertices\n    current_vertex = d + 2\n    \n    # Attach remaining vertices\n    for i in range(1, d + 2):\n        while len(edges) < n - 1 and len([e for e in edges if e[0] == i or e[1] == i]) < k:\n            if current_vertex > n:\n                break\n            edges.append((i, current_vertex))\n            current_vertex += 1\n    \n    # If we still have vertices left to connect\n    while current_vertex <= n:\n        for i in range(1, d + 2):\n            if len(edges) >= n - 1:\n                break\n            if len([e for e in edges if e[0] == i or e[1] == i]) < k:\n                edges.append((i, current_vertex))\n                current_vertex += 1\n        if current_vertex > n:\n            break\n    \n    if len(edges) == n - 1:\n        for u, v in edges:\n            print(u, v)\n    else:\n        print(\"NO\")\n\n# Read input\nn, d, k = map(int, input().split())\nconstruct_tree(n, d, k)\n```"
}