{
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelse:\n    print(n + k - t)\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "10": "```python\nn = int(input())\n\n# Maximum days off: all days can be off if n is less than or equal to 2\nmax_days_off = min(n, 2)\n\n# Minimum days off: calculate complete weeks and remaining days\nfull_weeks = n // 7\nremaining_days = n % 7\n\n# Each full week contributes 2 days off\nmin_days_off = full_weeks * 2\n\n# Check the remaining days\nif remaining_days >= 5:\n    min_days_off += 2  # If there are 5 or more remaining days, there are 2 days off\nelif remaining_days >= 2:\n    min_days_off += 1  # If there are 2 to 4 remaining days, there is 1 day off\n# If remaining_days is 0 or 1, no additional days off\n\nprint(min_days_off, max_days_off)\n```",
    "18": "```python\ndef minimal_string(s):\n    t = []\n    u = []\n    \n    # Reverse iterate through the string s and build the t\n    for char in s:\n        t.append(char)\n    \n    # We will use a list to simulate the stack behavior for t\n    t = t[::-1]  # Reverse t to treat it like a stack (LIFO)\n    \n    # While t is not empty, we will choose characters for u\n    while t:\n        # Find the minimum character from the current perspective in t\n        min_char = min(t)\n        min_index = t.index(min_char)\n        \n        # Append characters to u until we reach the min_index\n        for _ in range(min_index + 1):\n            u.append(t.pop(0))  # Pop from the front (simulating extraction from t)\n        \n        # Remove this character from t after adding to u\n        if min_char in t:\n            t.remove(min_char)\n    \n    # Join the list u to form the result string\n    return ''.join(u)\n\n# Read input\ns = input().strip()\n# Get the result and print\nresult = minimal_string(s)\nprint(result)\n```",
    "16": "```python\ndef can_form_regular_bracket_sequence(cnt1, cnt2, cnt3, cnt4):\n    # A regular bracket sequence can be formed if:\n    # 1. The number of opening brackets can match the number of closing brackets.\n    # 2. At any point in the sequence, the number of closing brackets should not exceed the number of opening brackets.\n    \n    # Calculate the balance of opening and closing brackets\n    open_count = cnt1 + cnt2  # Opening brackets from \"((\" and \"()\"\n    close_count = cnt3 + cnt4  # Closing brackets from \")(\" and \"))\"\n    \n    # Check if there are enough opening brackets to match the closing brackets\n    if open_count < close_count:\n        return 0\n    \n    # Calculate the excess opening and closing brackets\n    excess_open = cnt1 - cnt4  # Excess opening that needs to be matched\n    excess_close = cnt3  # Closing brackets that can be used\n    \n    # We need to ensure that the excess opening brackets can be matched by the closing brackets\n    if excess_open < 0:\n        return 0\n    \n    return 1\n\n# Read input\ncnt1 = int(input())\ncnt2 = int(input())\ncnt3 = int(input())\ncnt4 = int(input())\n\n# Output the result\nprint(can_form_regular_bracket_sequence(cnt1, cnt2, cnt3, cnt4))\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n        current_time = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(current_time):\n            return minutes_passed\n\n# Read input\ninput_time = input().strip()\nhh, mm = map(int, input_time.split(':'))\n\n# Get the result\nresult = next_palindrome_time(hh, mm)\n\n# Output the result\nprint(result)\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    # Calculate the number of tiles painted Red, Blue and both\n    red_tiles = n // a\n    blue_tiles = n // b\n    both_tiles = n // (a * b)\n\n    # Calculate the maximum chocolates\n    # Calculate chocolates if we paint all tiles Red then Blue\n    total_chocolates_red_first = (red_tiles - both_tiles) * p + (blue_tiles * q)\n    \n    # Calculate chocolates if we paint all tiles Blue then Red\n    total_chocolates_blue_first = (blue_tiles - both_tiles) * q + (red_tiles * p)\n\n    # Take the maximum\n    return max(total_chocolates_red_first, total_chocolates_blue_first)\n\n# Example usage\nn, a, b, p, q = map(int, input().split())\nprint(max_chocolates(n, a, b, p, q))\n```",
    "21": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the positions of the minimum (1) and maximum (n) elements\nmin_pos = a.index(1)\nmax_pos = a.index(n)\n\n# Calculate the current distance\ncurrent_distance = abs(min_pos - max_pos)\n\n# Calculate the maximum possible distance after one swap\nmax_distance = max(\n    abs(min_pos - 0),         # Swap min with the first element\n    abs(min_pos - (n - 1)),  # Swap min with the last element\n    abs(max_pos - 0),         # Swap max with the first element\n    abs(max_pos - (n - 1))    # Swap max with the last element\n)\n\n# Print the maximum distance achievable by one swap\nprint(max(max_distance, current_distance))\n```",
    "12": "```python\ndef max_beauty_with_one_swap(n, trophies):\n    # Step 1: Find the lengths of contiguous segments of 'G'\n    segments = []\n    current_length = 0\n    \n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n    \n    if current_length > 0:\n        segments.append(current_length)\n\n    # Step 2: Calculate the maximum beauty without any swaps\n    max_beauty = max(segments) if segments else 0\n\n    # Step 3: Check for possible swaps to increase the beauty\n    if len(segments) < 2:\n        return max_beauty  # No possible swaps if less than two segments\n\n    # Step 4: Check adjacent segments to see if a swap could merge them\n    for i in range(len(segments) - 1):\n        max_beauty = max(max_beauty, segments[i] + segments[i + 1])\n    \n    # We can also consider the case where we swap a 'S' with a 'G' on the edge\n    if trophies[0] == 'S' and segments:\n        max_beauty = max(max_beauty, segments[0] + 1)\n    if trophies[-1] == 'S' and segments:\n        max_beauty = max(max_beauty, segments[-1] + 1)\n\n    return max_beauty\n\n# Input reading\nn = int(input().strip())\ntrophies = input().strip()\n\n# Output the result\nprint(max_beauty_with_one_swap(n, trophies))\n```",
    "14": "```python\ndef is_stack_sortable(n, k, p):\n    # Create a set for the used values and a stack\n    used = set(p)\n    stack = []\n    result = p[:]\n    \n    # The next number to place into the permutation\n    next_number = n\n    \n    # Traverse the given permutation\n    for i in range(k):\n        # While the stack has elements and the top of the stack is the next expected number\n        while stack and stack[-1] == next_number:\n            result.append(stack.pop())\n            next_number -= 1\n        \n        # If the current number is less than the next_number, we cannot stack-sort\n        if p[i] > next_number:\n            return -1\n        \n        # Push the current number to the stack\n        stack.append(p[i])\n    \n    # Now we need to fill the rest of the permutation\n    while len(result) < n:\n        while stack and stack[-1] == next_number:\n            result.append(stack.pop())\n            next_number -= 1\n        \n        # We can only add numbers that are not used yet\n        while next_number in used:\n            next_number -= 1\n        \n        if next_number <= 0:\n            return -1\n        \n        result.append(next_number)\n        used.add(next_number)\n        next_number -= 1\n    \n    # Final check, if the stack can be emptied correctly\n    while stack:\n        if stack[-1] != next_number:\n            return -1\n        result.append(stack.pop())\n        next_number -= 1\n        \n    return result\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result and print\nresult = is_stack_sortable(n, k, p)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "23": "```python\ndef max_permuted_not_exceeding(a, b):\n    from itertools import permutations\n\n    # Convert numbers to strings to work with digits\n    str_a = str(a)\n    str_b = str(b)\n    \n    # Generate all unique permutations of the digits of a\n    permuted_numbers = sorted(set(int(''.join(p)) for p in permutations(str_a)), reverse=True)\n    \n    # Find the maximum number that does not exceed b\n    for num in permuted_numbers:\n        if num <= b:\n            return num\n\n# Read input\na = int(input().strip())\nb = int(input().strip())\n\n# Get the result and print it\nresult = max_permuted_not_exceeding(a, b)\nprint(result)\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    # Define the mirror pairs\n    mirror_pairs = {\n        'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M',\n        'O': 'O', 'p': 'q', 'q': 'p', 'R': 'R', 'S': 'S', 'T': 'T',\n        'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X', 'Y': 'Y', 'Z': 'Z',\n        'o': 'o', 'x': 'x'\n    }\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        left_char = s[i]\n        right_char = s[n - 1 - i]\n        \n        if left_char not in mirror_pairs or mirror_pairs[left_char] != right_char:\n            print(\"NIE\")\n            return\n    \n    print(\"TAK\")\n\n# Read input\ns = input().strip()\nis_s_palindrome(s)\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef find_course_order(n, k, main_courses, dependencies):\n    # Create an adjacency list for dependencies and a list for in-degrees\n    adj_list = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    \n    # Build the graph\n    for i in range(1, n + 1):\n        dep = dependencies[i - 1]\n        for dep_course in dep:\n            adj_list[dep_course].append(i)\n            in_degree[i] += 1\n            \n    # Queue for courses that can be taken (in-degree 0)\n    queue = deque()\n    for course in range(1, n + 1):\n        if in_degree[course] == 0:\n            queue.append(course)\n    \n    order = []\n    courses_taken = set()\n    \n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        courses_taken.add(course)\n        \n        # Reduce in-degree for dependent courses\n        for next_course in adj_list[course]:\n            in_degree[next_course] -= 1\n            if in_degree[next_course] == 0:\n                queue.append(next_course)\n    \n    # Check if all main courses can be taken\n    required_courses = set(main_courses)\n    all_courses = set(order)\n\n    if not required_courses.issubset(all_courses):\n        return -1\n    \n    # Include all necessary courses\n    result = []\n    for course in order:\n        if course in required_courses or any(dep in courses_taken for dep in dependencies[course - 1]):\n            result.append(course)\n    \n    return len(result), result\n\n# Input reading\nn, k = map(int, input().split())\nmain_courses = list(map(int, input().split()))\ndependencies = []\n\nfor _ in range(n):\n    dep_info = list(map(int, input().split()))\n    dependencies.append(dep_info[1:])  # Only take the dependencies, ignore the first number\n\n# Get the result\nresult = find_course_order(n, k, main_courses, dependencies)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    m, course_order = result\n    print(m)\n    print(' '.join(map(str, course_order)))\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexample_files = []\nregular_files = []\n\nfor filename, file_type in files:\n    if file_type == '1':\n        example_files.append(filename)\n    else:\n        regular_files.append(filename)\n\ntotal_examples = len(example_files)\ntotal_regulars = len(regular_files)\n\nmoves = []\n\n# Move example files to their new names\nfor i in range(total_examples):\n    moves.append(f\"move {example_files[i]} {i + 1}\")\n\n# Move regular files to their new names\nfor i in range(total_regulars):\n    moves.append(f\"move {regular_files[i]} {total_examples + i + 1}\")\n\nprint(len(moves))\nfor move in moves:\n    print(move)\n```",
    "19": "```python\ndef is_records_correct(test_cases):\n    results = []\n    \n    for case in test_cases:\n        n = case[0]\n        stats = case[1]\n        \n        valid = True\n        previous_p = 0\n        previous_c = 0\n        \n        for p, c in stats:\n            if p < previous_p or c < previous_c or c > p:\n                valid = False\n                break\n            \n            if c - previous_c > p - previous_p:\n                valid = False\n                break\n            \n            previous_p = p\n            previous_c = c\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\n\nfor _ in range(t):\n    n = int(input())\n    stats = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, stats))\n\n# Get results\nresults = is_records_correct(test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "27": "```python\nn = int(input())\ns = input()\n\n# Initialize the minimum operations to the maximum possible (typing all characters)\nmin_operations = n\n\n# Check for every possible prefix of the string\nfor i in range(1, n + 1):\n    prefix = s[:i]\n    # Check if the string starts with the current prefix repeated\n    if s.startswith(prefix * (n // i)):\n        # Calculate operations: type the prefix, copy it once, and type the remainder\n        operations = i + (n - i) // i + (n - i) % i\n        min_operations = min(min_operations, operations)\n\nprint(min_operations)\n```",
    "25": "```python\ndef fill_matrix(n, k):\n    if k > 2 * (n * (n + 1) // 2):  # Maximum number of 1's in a symmetric matrix\n        return -1\n\n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k <= 0:\n            break\n        # Place 1 on the diagonal\n        if k > 0:\n            matrix[i][i] = 1\n            k -= 1\n        \n        for j in range(i + 1, n):\n            if k >= 2:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n            \n            if k <= 0:\n                break\n    \n    if k > 0:  # If there are still ones left to place\n        return -1\n    \n    return matrix\n\n# Reading input\nn, k = map(int, input().split())\nresult = fill_matrix(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(\" \".join(map(str, row)))\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # Since GCD(x, m) = 1, x has a multiplicative inverse mod m\n    # The minimum number of traps needed is the number of distinct rooms the mouse visits\n    # which is equal to the order of x modulo m.\n    \n    traps = 0\n    visited = set()\n    current_room = 0\n    \n    while current_room not in visited:\n        visited.add(current_room)\n        current_room = (current_room * x) % m\n        traps += 1\n    \n    return traps\n\n# Input reading\nm, x = map(int, input().split())\n# Output the result\nprint(minimum_traps(m, x))\n```",
    "24": "```python\ndef can_alice_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # vertical, horizontal, diagonal, anti-diagonal\n    n = 10  # size of the board\n\n    def check_win(x, y):\n        for dx, dy in directions:\n            count = 1  # count includes the new 'X' we are placing\n            # Check in the positive direction\n            for step in range(1, 5):\n                nx, ny = x + step * dx, y + step * dy\n                if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                    count += 1\n                else:\n                    break\n            # Check in the negative direction\n            for step in range(1, 5):\n                nx, ny = x - step * dx, y - step * dy\n                if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                    count += 1\n                else:\n                    break\n            if count >= 5:\n                return True\n        return False\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                if check_win(i, j):\n                    return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nboard = [input().strip() for _ in range(10)]\nprint(can_alice_win(board))\n```",
    "26": "```python\nimport math\n\n# Read input\nx, y, z = map(float, input().split())\n\n# Define the expressions and their corresponding representations\nexpressions = [\n    (x**(y**z), 'x^y^z'),\n    (x**(z**y), 'x^z^y'),\n    ((x**y)**z, '(x^y)^z'),\n    ((x**z)**y, '(x^z)^y'),\n    (y**(x**z), 'y^x^z'),\n    (y**(z**x), 'y^z^x'),\n    ((y**x)**z, '(y^x)^z'),\n    ((y**z)**x, '(y^z)^x'),\n    (z**(x**y), 'z^x^y'),\n    (z**(y**x), 'z^y^x'),\n    ((z**x)**y, '(z^x)^y'),\n    ((z**y)**x, '(z^y)^x')\n]\n\n# Find the maximum value and the corresponding expression\nmax_value = -math.inf\nmax_index = -1\n\nfor index, (value, representation) in enumerate(expressions):\n    if value > max_value:\n        max_value = value\n        max_index = index\n\n# Output the corresponding expression\nprint(expressions[max_index][1])\n```",
    "37": "```python\ndef can_break_shield(a, b, c):\n    # Check all possible combinations of shots from Ebony and Ivory\n    for x in range(c // a + 1):  # x is the number of shots from Ebony\n        remaining_damage = c - a * x\n        if remaining_damage >= 0 and remaining_damage % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Input\na, b, c = map(int, input().split())\n# Output\nprint(can_break_shield(a, b, c))\n```",
    "32": "```python\ndef is_journey_valid(n, movements):\n    current_position = 20000  # Starting at North Pole, 0 km to South Pole, 20000 km from North Pole\n\n    for t, direction in movements:\n        if current_position == 20000 and direction != \"South\":\n            return \"NO\"  # At North Pole, can only move South\n        if current_position == 0 and direction != \"North\":\n            return \"NO\"  # At South Pole, can only move North\n        \n        if direction == \"South\":\n            current_position -= t\n        elif direction == \"North\":\n            current_position += t\n        elif direction in [\"West\", \"East\"]:\n            # West and East do not change the position in terms of North-South distance\n            pass\n        \n        # Check if current_position goes out of bounds\n        if current_position < 0 or current_position > 20000:\n            return \"NO\"\n\n    # Check if we end at the North Pole\n    if current_position != 20000:\n        return \"NO\"\n\n    return \"YES\"\n\n# Read input\nn = int(input())\nmovements = [tuple(input().split()) for _ in range(n)]\nmovements = [(int(t), dir) for t, dir in movements]\n\n# Get the result and print it\nresult = is_journey_valid(n, movements)\nprint(result)\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    def can_distribute(x):\n        plates_for_a = min(n, a // x)\n        plates_for_b = min(n - plates_for_a, b // x)\n        return plates_for_a + plates_for_b >= n\n\n    left, right = 1, max(a, b)\n    result = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_distribute(mid):\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n\n# Read input\nn, a, b = map(int, input().split())\n# Calculate and print the result\nprint(max_min_pieces(n, a, b))\n```",
    "35": "```python\ndef is_valid_flag(n, m, grid):\n    # Check if there are exactly three colors\n    colors = set()\n    for row in grid:\n        colors.update(row)\n    \n    if len(colors) != 3:\n        return \"NO\"\n\n    # Check for horizontal stripes\n    stripe_height = n // 3\n    if n % 3 != 0 or stripe_height == 0:\n        return \"NO\"\n    \n    # Check each stripe\n    seen_colors = set()\n    for i in range(3):\n        stripe_color = grid[i * stripe_height][0]\n        if stripe_color in seen_colors:\n            return \"NO\"\n        seen_colors.add(stripe_color)\n        \n        for j in range(i * stripe_height, (i + 1) * stripe_height):\n            if grid[j] != stripe_color * m:\n                return \"NO\"\n\n    return \"YES\"\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    result = is_valid_flag(n, m, grid)\n    print(result)\n\nmain()\n```",
    "36": "```python\ndef hexagonal_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    # Determine the layer of the spiral\n    layer = 0\n    while n > 3 * layer * (layer + 1):\n        layer += 1\n\n    # Number of moves in the previous layer\n    moves_in_previous_layer = 3 * layer * (layer - 1)\n    \n    # Position in the current layer\n    position_in_layer = n - moves_in_previous_layer\n\n    # Calculate the coordinates based on position in the layer\n    if position_in_layer < layer:\n        x, y = layer, position_in_layer\n    elif position_in_layer < 2 * layer:\n        x, y = layer - (position_in_layer - layer), layer\n    else:\n        x, y = -layer, layer - (position_in_layer - 2 * layer)\n\n    return (x, y)\n\nn = int(input().strip())\nx, y = hexagonal_coordinates(n)\nprint(x, y)\n```",
    "29": "```python\ndef min_replacements_to_lucky_ticket(ticket):\n    # Split the ticket into two halves\n    left = list(map(int, ticket[:3]))\n    right = list(map(int, ticket[3:]))\n\n    # Calculate the sums of the two halves\n    left_sum = sum(left)\n    right_sum = sum(right)\n\n    # Calculate the difference\n    diff = abs(left_sum - right_sum)\n    \n    # If the sums are already equal, no replacements are needed\n    if diff == 0:\n        return 0\n\n    # Create a list of possible adjustments\n    adjustments = []\n    \n    # Calculate the maximum possible adjustments from both halves\n    for i in left:\n        adjustments.append(9 - i)  # Max increase for left half\n    for i in right:\n        adjustments.append(i)        # Max decrease for right half\n\n    # Sort adjustments in descending order\n    adjustments.sort(reverse=True)\n\n    # Initialize the number of replacements\n    replacements = 0\n    current_diff = 0\n\n    # Make replacements until the current difference is covered\n    for adjustment in adjustments:\n        current_diff += adjustment\n        replacements += 1\n        if current_diff >= diff:\n            break\n    \n    return replacements\n\n# Example usage\nticket = input().strip()\nprint(min_replacements_to_lucky_ticket(ticket))\n```",
    "38": "```python\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Normalize distances for Kefa and Sasha\ndef normalize(distances):\n    normalized = []\n    for i in range(n):\n        normalized.append((distances[i] - distances[0]) % L)\n    return normalized\n\nkefa_normalized = normalize(kefa_distances)\nsasha_normalized = normalize(sasha_distances)\n\n# Check if Kefa's normalized distances match Sasha's normalized distances in any circular permutation\ndef can_match(kefa, sasha):\n    double_kefa = kefa + kefa\n    sasha_length = len(sasha)\n    for i in range(len(kefa)):\n        if double_kefa[i:i+sasha_length] == sasha:\n            return True\n    return False\n\nif can_match(kefa_normalized, sasha_normalized):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "31": "```python\ndef gcd(x, y):\n    while y != 0:\n        x, y = y, x % y\n    return x\n\ndef birthday_paradox(n, k):\n    MOD = 1000003\n    days = 1 << n  # This is 2^n\n\n    if k > days:\n        return 1, 1  # P(at least two share a birthday) = 1 when k > days\n\n    # Calculate P(no two share a birthday)\n    prob_no_shared = 1\n    for i in range(k):\n        prob_no_shared *= (days - i)\n        prob_no_shared //= days  # As we multiply we can divide the days\n\n    prob_shared = 1 - prob_no_shared  # P(at least two share a birthday)\n    \n    # Prob shared = (1 - P(no shared)) = (Days * Days * ... * Days - (Days - 0) * (Days - 1) * ... * (Days - k + 1)) / Days^k\n    A = (days**k - prob_no_shared * days**k) % MOD\n    B = days**k % MOD\n\n    # Reduce A/B to be coprime\n    common_divisor = gcd(A, B)\n    A //= common_divisor\n    B //= common_divisor\n\n    return A % MOD, B % MOD\n\n# Read input\nn, k = map(int, input().split())\nA, B = birthday_paradox(n, k)\nprint(A, B)\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\nrated = False\nunrated = False\n\nfor before, after in ratings:\n    if before != after:\n        rated = True\n        break\n\nif rated:\n    print(\"rated\")\nelse:\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            unrated = True\n            break\n            \n    if unrated:\n        print(\"unrated\")\n    else:\n        print(\"maybe\")\n```",
    "33": "```python\ndef count_common_ap(a1, b1, a2, b2, L, R):\n    # Calculate the first term of the two sequences\n    start1 = b1\n    start2 = b2\n    \n    # Adjust the start values to be >= L\n    if start1 < L:\n        if (L - start1) % a1 != 0:\n            start1 += (L - start1) // a1 * a1 + a1\n        else:\n            start1 = L\n    \n    if start2 < L:\n        if (L - start2) % a2 != 0:\n            start2 += (L - start2) // a2 * a2 + a2\n        else:\n            start2 = L\n    \n    # Identify the maximum possible value to consider\n    end1 = R // a1 * a1 + b1\n    end2 = R // a2 * a2 + b2\n    \n    # Store the common terms\n    common_terms = set()\n    \n    # Generate terms of the first arithmetic progression\n    for x in range(start1, R + 1, a1):\n        if L <= x <= R:\n            common_terms.add(x)\n    \n    # Count the numbers in the second arithmetic progression that are also in the common_terms\n    count = 0\n    for x in range(start2, R + 1, a2):\n        if x in common_terms:\n            count += 1\n    \n    return count\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n\n# Get the result\nresult = count_common_ap(a1, b1, a2, b2, L, R)\n\n# Print the result\nprint(result)\n```",
    "42": "```python\ndef count_circular_binary_strings(n, s):\n    from itertools import product\n\n    m = len(s)\n    count = 0\n    seen = set()\n\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        # Check if s is a substring in any cyclic shift of t\n        if any(s in t[i:] + t[:i] for i in range(n)):\n            # Add the string in its canonical form to avoid duplicates\n            canonical = min(t[i:] + t[:i] for i in range(n))\n            seen.add(canonical)\n\n    return len(seen)\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(count_circular_binary_strings(n, s))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    \n    # Check if the entire string is a palindrome\n    if not is_palindrome(s):\n        return n  # The whole string itself is the longest non-palindrome substring\n    \n    # Check for non-palindromic substrings by removing one character from either end\n    for i in range(n):\n        # Remove character from the start\n        if not is_palindrome(s[i:]):\n            return n - 1  # All substrings of this length will be non-palindromic\n        \n        # Remove character from the end\n        if not is_palindrome(s[:n - i]):\n            return n - 1  # All substrings of this length will be non-palindromic\n\n    return 0  # If all substrings are palindromic\n\n# Input\ns = input().strip()\n# Output\nprint(longest_non_palindrome_substring(s))\n```",
    "41": "```python\nn = int(input())\narray = list(map(int, input().split()))\n\n# Initialize the distance array with a large number\ndistances = [float('inf')] * n\n\n# First pass: from left to right\nfor i in range(n):\n    if array[i] == 0:\n        distances[i] = 0\n    elif i > 0:\n        distances[i] = distances[i - 1] + 1\n\n# Second pass: from right to left\nfor i in range(n - 1, -1, -1):\n    if array[i] == 0:\n        distances[i] = 0\n    elif i < n - 1:\n        distances[i] = min(distances[i], distances[i + 1] + 1)\n\nprint(' '.join(map(str, distances)))\n```",
    "46": "```python\ndef count_divisible_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n    \n    # Count occurrences of remainders for x in range 1 to n\n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n    \n    # Count occurrences of remainders for y in range 1 to m\n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n    \n    # Calculate the number of valid pairs\n    result = 0\n    for i in range(5):\n        result += count_x[i] * count_y[(5 - i) % 5]\n    \n    return result\n\n# Read input\nn, m = map(int, input().split())\nprint(count_divisible_pairs(n, m))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    digit_length = 1\n    count = 9\n    start = 1\n\n    while k > digit_length * count:\n        k -= digit_length * count\n        digit_length += 1\n        count *= 10\n        start *= 10\n\n    # Determine the actual number containing the k-th digit\n    start += (k - 1) // digit_length\n    number_str = str(start)\n    \n    # Find the specific digit\n    digit_index = (k - 1) % digit_length\n    return number_str[digit_index]\n\n# Input reading\nk = int(input())\nprint(find_kth_digit(k))\n```",
    "48": "```python\ndef kth_largest_in_multiplication_table(n, m, k):\n    # Binary search for the k-th largest number\n    left, right = 1, n * m\n    \n    while left < right:\n        mid = (left + right) // 2\n        count = 0\n        \n        # Count how many numbers are less than or equal to mid\n        for i in range(1, n + 1):\n            count += min(mid // i, m)\n        \n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return left\n\n# Input reading\nn, m, k = map(int, input().split())\n# Output the k-th largest number\nprint(kth_largest_in_multiplication_table(n, m, k))\n```",
    "44": "```python\ndef minimal_time_to_post_office(d, k, a, b, t):\n    if k >= d:\n        # If the car can drive the entire distance without breaking\n        return d * a\n    \n    # Calculate the number of full segments the car can drive before needing repair\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Time spent if driving the full segments\n    time_by_car = full_segments * (k * a + t)  # time driving full segments + repair time\n\n    # If there is remaining distance after the last full segment\n    if remaining_distance > 0:\n        time_by_car += remaining_distance * a  # time for the remaining distance\n    \n    # Calculate time if walking the entire distance\n    time_by_foot = d * b\n    \n    # The minimal time\n    return min(time_by_car, time_by_foot)\n\n# Example usage:\nd, k, a, b, t = map(int, input().split())\nprint(minimal_time_to_post_office(d, k, a, b, t))\n```",
    "43": "```python\nimport sys\nimport math\n\ndef minimal_angle_pair(n, vectors):\n    angles = []\n    \n    for i in range(n):\n        x, y = vectors[i]\n        angle = math.atan2(y, x)\n        angles.append((angle, i + 1))  # Store angle and 1-based index\n\n    # Sort angles\n    angles.sort()\n\n    # To handle the circular nature, we append the first angle + 2Ï€\n    angles.append((angles[0][0] + 2 * math.pi, angles[0][1]))\n\n    min_angle = float('inf')\n    best_pair = (0, 0)\n\n    # Find the minimal angle between consecutive angles\n    for i in range(n):\n        angle1, index1 = angles[i]\n        angle2, index2 = angles[i + 1]\n        angle_diff = angle2 - angle1\n\n        if angle_diff < min_angle:\n            min_angle = angle_diff\n            best_pair = (index1, index2)\n\n    return best_pair\n\n# Input reading\nn = int(sys.stdin.readline().strip())\nvectors = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\n# Get the result\nresult = minimal_angle_pair(n, vectors)\n\n# Output the result\nprint(result[0], result[1])\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    from itertools import combinations\n\n    max_elements_to_choose = m // 2\n    total_sum = 0\n\n    for row in matrix:\n        # Generate all combinations of choosing elements from the row\n        best_sum = 0\n        for r in range(max_elements_to_choose + 1):\n            for comb in combinations(row, r):\n                current_sum = sum(comb)\n                if current_sum % k == 0:\n                    best_sum = max(best_sum, current_sum)\n        total_sum += best_sum\n\n    return total_sum\n\n# Read input\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Get the result\nresult = max_sum_divisible_by_k(n, m, k, matrix)\n\n# Print the result\nprint(result)\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Check if it is possible to have a strictly increasing sequence of k elements that sum to n\n    min_sum = k * (k + 1) // 2  # 1 + 2 + ... + k\n    if n < min_sum:\n        return -1\n\n    # The maximum GCD we can use is n // k, because we need each number to be at least that much\n    max_gcd = n // k\n\n    # We can start from max_gcd and build the sequence\n    sequence = [(i + 1) * max_gcd for i in range(k)]\n\n    # Check if the sum exceeds n\n    current_sum = sum(sequence)\n    if current_sum > n:\n        return -1\n\n    # Adjust the last element to make the sum equal to n\n    sequence[-1] += n - current_sum\n\n    return sequence\n\n# Read input\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\n# Print result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "47": "```python\ndef max_beauty_with_multiplication(n, x, a):\n    # Helper function to calculate maximum subarray sum using Kadane's algorithm\n    def kadane(arr):\n        max_sum = 0\n        current_sum = 0\n        for value in arr:\n            current_sum += value\n            if current_sum < 0:\n                current_sum = 0\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n    \n    # Calculate the original maximum beauty\n    original_beauty = kadane(a)\n    \n    # Calculate the maximum beauty after multiplying a subarray by x\n    max_increase = 0\n    current_sum = 0\n    \n    for i in range(n):\n        current_sum += a[i]\n        if i == 0:\n            max_increase = current_sum * x\n        else:\n            max_increase = max(max_increase, current_sum * x)\n        if current_sum < 0:\n            current_sum = 0\n    \n    # Calculate the maximum beauty after considering the subarray\n    max_beauty_after_multiplication = original_beauty + max_increase\n    \n    return max(max_beauty_after_multiplication, original_beauty)\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the maximum beauty\nprint(max_beauty_with_multiplication(n, x, a))\n```",
    "51": "```python\nfrom collections import Counter\nfrom math import gcd\n\ndef find_x_y(n, divisors):\n    count = Counter(divisors)\n    \n    # The largest element in the list must be the maximum of x and y\n    max_divisor = max(divisors)\n    \n    # Get common divisors (those that have a count of 2)\n    common_divisors = [d for d in count if count[d] == 2]\n    \n    # Calculate the potential x and y\n    x = 1\n    y = 1\n    \n    for d in divisors:\n        if count[d] == 1:\n            # If the divisor appears once, assign it to one of x or y\n            if x * d <= max_divisor:\n                x *= d\n            else:\n                y *= d\n    \n    # Now we must include the common divisors\n    for d in common_divisors:\n        x *= d\n        y *= d\n    \n    return x, y\n\n# Input reading\nn = int(input())\ndivisors = list(map(int, input().split()))\n\n# Find x and y\nx, y = find_x_y(n, divisors)\n\n# Output the result\nprint(x, y)\n```",
    "54": "```python\ndef find_minimum_D(n, a):\n    min_a = min(a)\n    max_a = max(a)\n    \n    if min_a == max_a:\n        return 0\n    \n    if (max_a - min_a) % 2 != 0:\n        return -1\n    \n    D = (max_a - min_a) // 2\n    return D\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(find_minimum_D(n, a))\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = -1\n    result_length = 0\n    result_moves = []\n\n    while left <= right:\n        if a[left] <= a[right]:\n            if a[left] > last_taken:\n                last_taken = a[left]\n                result_moves.append('L')\n                result_length += 1\n                left += 1\n            else:\n                break\n        else:\n            if a[right] > last_taken:\n                last_taken = a[right]\n                result_moves.append('R')\n                result_length += 1\n                right -= 1\n            else:\n                break\n\n    print(result_length)\n    print(''.join(result_moves))\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\nlongest_increasing_sequence(n, a)\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef count_reachable_numbers(n):\n    reachable = set()\n    current = n\n    \n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n        \n    return len(reachable)\n\nn = int(input())\nprint(count_reachable_numbers(n))\n```",
    "59": "```python\ndef min_operations_to_remainder(n, x, y, num_str):\n    # Calculate the required pattern for the last x digits\n    required_pattern = ['0'] * x\n    required_pattern[y] = '1'  # Set the y-th position to 1 for the remainder 10^y\n    required_pattern = ''.join(required_pattern)\n    \n    # Get the last x digits of the input number\n    current_suffix = num_str[-x:]\n    \n    # Count the number of changes required\n    operations = 0\n    for i in range(x):\n        if current_suffix[i] != required_pattern[i]:\n            operations += 1\n    \n    return operations\n\n# Input reading\nn, x, y = map(int, input().split())\nnum_str = input().strip()\n\n# Calculate and print the result\nresult = min_operations_to_remainder(n, x, y, num_str)\nprint(result)\n```",
    "60": "```python\ndef has_palindrome_subsequence(test_cases):\n    results = []\n    for n, a in test_cases:\n        found = False\n        # Create a dictionary to track the last seen index of each number\n        last_seen = {}\n        for i in range(n):\n            if a[i] in last_seen:\n                # If we find the same number again, check if the distance is at least 2\n                if i - last_seen[a[i]] >= 2:\n                    found = True\n                    break\n            # Update the last seen index of the current number\n            last_seen[a[i]] = i\n        results.append(\"YES\" if found else \"NO\")\n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Get results\nresults = has_palindrome_subsequence(test_cases)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "55": "```python\ndef is_visible(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n    # Check if the white sheet is completely covered by both black sheets\n    covered_left = max(x3, x5)  # rightmost left edge of both black sheets\n    covered_right = min(x4, x6)  # leftmost right edge of both black sheets\n    covered_bottom = max(y3, y5)  # uppermost bottom edge of both black sheets\n    covered_top = min(y4, y6)  # lowermost top edge of both black sheets\n\n    # Check if the white sheet is fully covered\n    if covered_left < covered_right and covered_bottom < covered_top:\n        # If the black sheets cover the entirety of the white sheet\n        if covered_left < x2 and covered_right > x1 and covered_bottom < y2 and covered_top > y1:\n            return \"NO\"\n\n    return \"YES\"\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Output the result\nprint(is_visible(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6))\n```",
    "57": "```python\ndef fill_gift_values(n, f):\n    # Create a list to hold the final gift values\n    nf = f[:]\n    \n    # Find all the friends that have a known gift\n    known_givers = set(fi for fi in f if fi != 0)\n    \n    # Find all the friends that have an unknown gift (f_i = 0)\n    unknown_givers = [i + 1 for i in range(n) if f[i] == 0]\n    \n    # Find all the friends that are targeted to receive a gift\n    known_receivers = set(range(1, n + 1)) - known_givers\n    \n    # Fill in the unknown gift values\n    for i in range(len(unknown_givers)):\n        # The current unknown giver\n        giver = unknown_givers[i]\n        \n        # Select a receiver from the known receivers\n        receiver = known_receivers.pop()\n        \n        # Assign the gift\n        nf[giver - 1] = receiver\n        \n        # If there are still unknown givers, put this receiver in the known givers\n        known_givers.add(receiver)\n        \n        # If there are still unknown receivers, we might need to re-add this to the pool\n        if len(known_receivers) == 0:\n            known_receivers.add(giver)\n            break\n    \n    # Now, fill in any remaining 0s ensuring no one gives a gift to themselves\n    for i in range(n):\n        if nf[i] == 0:\n            nf[i] = known_receivers.pop()\n    \n    return nf\n\n# Input reading\nn = int(input())\nf = list(map(int, input().split()))\n\n# Get the result and print it\nresult = fill_gift_values(n, f)\nprint(' '.join(map(str, result)))\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        min_moves = float('inf')\n        best_triplet = (a, b, c)\n        \n        for A in range(1, a + 1):\n            for B in range(A, c + 1):\n                if B % A == 0:\n                    C = B * (B // A)  # Ensure C is a multiple of B\n                    if C >= b:\n                        moves = abs(A - a) + abs(B - b) + abs(C - c)\n                        if moves < min_moves:\n                            min_moves = moves\n                            best_triplet = (A, B, C)\n        \n        results.append((min_moves, best_triplet))\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations(t, test_cases)\n\n# Print results\nfor moves, (A, B, C) in results:\n    print(moves)\n    print(A, B, C)\n```",
    "61": "```python\ndef max_number_after_replacement(n, a, f):\n    a_list = list(a)\n    f = [0] + f  # Make f 1-indexed\n    modified = False\n\n    for i in range(n):\n        current_digit = int(a_list[i])\n        if f[current_digit] > current_digit:\n            a_list[i] = str(f[current_digit])\n            modified = True\n        elif modified and f[current_digit] < current_digit:\n            break  # Stop replacing once we encounter a digit that won't increase the number\n\n    return ''.join(a_list)\n\n# Reading input\nn = int(input().strip())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\n# Output the result\nprint(max_number_after_replacement(n, a, f))\n```",
    "63": "```python\ndef min_instability(n, a):\n    # Sort the array to easily find the min and max values after removing an element\n    a.sort()\n    \n    # The instability after removing the first or the last element\n    instability_remove_first = a[-1] - a[1]  # Remove the first element\n    instability_remove_last = a[-2] - a[0]   # Remove the last element\n    \n    # The minimum instability\n    return min(instability_remove_first, instability_remove_last)\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_instability(n, a))\n```",
    "64": "```python\nn, m = map(int, input().split())\nexams = [list(map(int, input().split())) for _ in range(m)]\nschedule = [0] * n  # Initialize the schedule with rest days (0)\n\n# Mark exam days\nfor i in range(m):\n    s, d, c = exams[i]\n    schedule[d - 1] = m + 1  # Mark exam day with m + 1\n\n# Prepare for exams\nfor i in range(m):\n    s, d, c = exams[i]\n    prepared_days = 0\n    for j in range(s - 1, d - 1):  # From s_i to d_i - 1\n        if prepared_days < c and schedule[j] == 0:  # Only prepare on rest days\n            schedule[j] = i + 1  # Mark preparation day with exam number (1-indexed)\n            prepared_days += 1\n            \n    # Check if we have prepared enough days\n    if prepared_days < c:\n        print(-1)\n        exit()\n\n# Print the final schedule\nprint(' '.join(map(str, schedule)))\n```",
    "71": "```python\nimport math\n\na = int(input())\noutput = math.floor(math.log2(a))\nprint(output)\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Find the longest suffix of t that is also a prefix\n    for i in range(1, n):\n        if t[:i] == t[-i:]:\n            overlap_length = i\n            break\n    else:\n        overlap_length = 0\n    \n    # Create the resulting string by using the prefix and overlap\n    result = t + (t[overlap_length:] * (k - 1))\n    \n    return result\n\n# Input reading\nn, k = map(int, input().split())\nt = input().strip()\n\n# Construct and print the result\nresult = construct_string(n, k, t)\nprint(result)\n```",
    "58": "```python\ndef color_array(n, k, a):\n    from collections import defaultdict\n    \n    # Step 1: Create a dictionary to keep track of positions of each number\n    positions = defaultdict(list)\n    for index, value in enumerate(a):\n        positions[value].append(index)\n    \n    # Step 2: Check if coloring is possible\n    # If any number has more than k occurrences, it's impossible to color\n    for value in positions.values():\n        if len(value) > k:\n            print(\"NO\")\n            return\n    \n    # Step 3: Generate coloring\n    coloring = [0] * n\n    color_used = [0] * (k + 1)  # To track which colors have been used for each number\n    current_color = 1\n    \n    for value in positions:\n        for index in positions[value]:\n            # Assign the next available color for this number\n            coloring[index] = current_color\n            color_used[current_color] += 1\n            # Move to the next color\n            current_color += 1\n            if current_color > k:\n                current_color = 1\n    \n    # Step 4: Check if all colors are used\n    if all(color_used[i] > 0 for i in range(1, k + 1)):\n        print(\"YES\")\n        print(\" \".join(map(str, coloring)))\n    else:\n        print(\"NO\")\n\n# Example usage\nn, k = map(int, input().split())\na = list(map(int, input().split()))\ncolor_array(n, k, a)\n```",
    "70": "```python\n# Read input\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'),)\n\n# Convert start and end times to total minutes\nstart_minutes = h1 * 60 + m1\nend_minutes = h2 * 60 + m2\n\n# Calculate midpoint in total minutes\nmidpoint_minutes = (start_minutes + end_minutes) // 2\n\n# Convert midpoint back to hours and minutes\nh3 = midpoint_minutes // 60\nm3 = midpoint_minutes % 60\n\n# Print output in hh:mm format\nprint(f\"{h3:02}:{m3:02}\")\n```",
    "67": "```python\ndef find_nice_indices(n, a):\n    total_sum = sum(a)\n    nice_indices = []\n\n    for i in range(n):\n        remaining_sum = total_sum - a[i]\n        if remaining_sum % 2 == 0:\n            half_remaining_sum = remaining_sum // 2\n            if half_remaining_sum in a[:i] + a[i+1:]:\n                nice_indices.append(i + 1)  # store 1-based index\n\n    print(len(nice_indices))\n    if nice_indices:\n        print(' '.join(map(str, nice_indices)))\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\nfind_nice_indices(n, a)\n```",
    "50": "```python\ndef dfs(node, parent, depth, graph, depths, farthest):\n    depths[node] = depth\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, depth + 1, graph, depths, farthest)\n            if depths[neighbor] > depths[farthest[0]]:\n                farthest[0] = neighbor\n\ndef find_farthest(node, graph):\n    depths = [-1] * len(graph)\n    farthest = [node]\n    dfs(node, -1, 0, graph, depths, farthest)\n    return farthest[0], depths\n\ndef get_edges_count(a, b, c, parent, graph):\n    path_edges = set()\n    def add_path_edges(start, end):\n        while start != end:\n            path_edges.add((min(start, parent[start]), max(start, parent[start])))\n            start = parent[start]\n    \n    add_path_edges(a, b)\n    add_path_edges(b, c)\n    add_path_edges(a, c)\n    \n    return len(path_edges)\n\ndef main():\n    import sys\n    from collections import defaultdict\n    \n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    graph = defaultdict(list)\n    \n    for line in data[1:n]:\n        u, v = map(int, line.split())\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Step 1: Find two farthest points in the tree\n    first_farthest, _ = find_farthest(1, graph)\n    second_farthest, depths = find_farthest(first_farthest, graph)\n    \n    # Step 2: Get parent information for the path\n    parent = [-1] * (n + 1)\n    stack = [(first_farthest, -1)]\n    while stack:\n        node, par = stack.pop()\n        parent[node] = par\n        for neighbor in graph[node]:\n            if neighbor != par:\n                stack.append((neighbor, node))\n\n    # Step 3: Get the farthest point from the second farthest to get all edges\n    third_farthest, _ = find_farthest(second_farthest, graph)\n    \n    # Step 4: Calculate edges\n    result_edges = get_edges_count(first_farthest, second_farthest, third_farthest, parent, graph)\n    \n    print(result_edges)\n    print(first_farthest, second_farthest, third_farthest)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "73": "```python\ndef can_complete_wall(n, heights):\n    max_height = max(heights)\n    for h in heights:\n        if h < max_height and (h + 1) not in heights:\n            return \"NO\"\n    return \"YES\"\n\nn = int(input())\nheights = list(map(int, input().split()))\nprint(can_complete_wall(n, heights))\n```",
    "77": "```python\ndef minimum_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nn = int(input())\nprint(minimum_difference(n))\n```",
    "65": "```python\ndef min_moves_to_transform(n, m):\n    if m % n != 0:\n        return -1\n\n    ratio = m // n\n    moves = 0\n\n    while ratio > 1:\n        if ratio % 2 == 0:\n            ratio //= 2\n            moves += 1\n        elif ratio % 3 == 0:\n            ratio //= 3\n            moves += 1\n        else:\n            return -1\n\n    return moves\n\n# Input reading\nn, m = map(int, input().split())\n# Output the result\nprint(min_moves_to_transform(n, m))\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    # Create a set to store unique subsequences\n    unique_subsequences = set()\n\n    # Generate all possible subsequences using bit masking\n    for mask in range(1 << n):\n        subsequence = []\n        for i in range(n):\n            if mask & (1 << i):\n                subsequence.append(s[i])\n        unique_subsequences.add(''.join(subsequence))\n\n    # Calculate the number of unique subsequences\n    unique_count = len(unique_subsequences)\n    \n    # If the number of unique subsequences is less than k, return -1\n    if unique_count < k:\n        return -1\n\n    # Calculate the minimum cost to obtain k unique subsequences\n    sorted_lengths = sorted(n - len(subseq) for subseq in unique_subsequences)\n    return sum(sorted_lengths[:k])\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result and print it\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    # Prepare to find the maximum and second maximum right endpoints\n    max_right = float('-inf')\n    second_max_right = float('-inf')\n    min_left = float('inf')\n\n    # First pass to find max and second max right endpoints and min left endpoint\n    for l, r in segments:\n        if r > max_right:\n            second_max_right = max_right\n            max_right = r\n        elif r > second_max_right:\n            second_max_right = r\n        min_left = min(min_left, l)\n\n    # Prepare to find the maximum intersection length after removing each segment\n    max_length = 0\n\n    for l, r in segments:\n        # Determine the right endpoint to consider after removing this segment\n        if r == max_right:\n            right_endpoint = second_max_right\n        else:\n            right_endpoint = max_right\n\n        # Calculate the intersection length\n        intersection_length = max(0, right_endpoint - min_left)\n        max_length = max(max_length, intersection_length)\n\n    return max_length\n\n# Input reading\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_intersection_length(n, segments))\n```",
    "81": "```python\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\n# Sort strings by length\nstrings.sort(key=len)\n\n# Check for substring condition\nfor i in range(n):\n    for j in range(i):\n        if strings[j] not in strings[i]:\n            print(\"NO\")\n            exit()\n\nprint(\"YES\")\nfor string in strings:\n    print(string)\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import Counter\n    \n    # Count the frequency of each character in the string\n    freq = Counter(s)\n    \n    # Calculate the total number of unique subsequences we can generate\n    unique_subsequences = 0\n    cost = 0\n    \n    # We can create a subsequence of length i by deleting (n - i) characters\n    # We iterate over all possible lengths of subsequences\n    for length in range(1, n + 1):\n        # Number of unique subsequences of this specific length\n        unique_count = 1\n        for char, count in freq.items():\n            if count >= length:\n                unique_count *= (count - length + 1)\n        \n        if unique_count > 0:\n            unique_subsequences += unique_count\n            cost += unique_count * (n - length)\n        \n        # If we have reached the required size, we can stop\n        if unique_subsequences >= k:\n            return cost\n    \n    # If we exit the loop and haven't reached k, it's impossible\n    return -1\n\n# Read input values\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result and print\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "76": "```python\ndef can_construct_square(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        can_form_symmetry = False\n        # Check if any tile can form symmetric pairs\n        for tile in tiles:\n            top_left, top_right = tile[0]\n            bottom_left, bottom_right = tile[1]\n            if top_right == bottom_left:\n                can_form_symmetry = True\n                break\n        \n        if can_form_symmetry:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Read input and prepare data\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        top = tuple(map(int, input().split()))\n        bottom = tuple(map(int, input().split()))\n        tiles.append((top, bottom))\n    test_cases.append((n, m, tiles))\n\n# Get results and print them\nresults = can_construct_square(t, test_cases)\nfor result in results:\n    print(result)\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Food consumption pattern based on the day of the week\n    food_pattern = [1, 1, 0, 1, 0, 1, 0]  # Fish: 1, Rabbit: 1, Chicken: 0\n    max_days = 0\n\n    # Check each starting day of the week\n    for start_day in range(7):\n        # Copy the original food supplies\n        fish = a\n        rabbit = b\n        chicken = c\n        \n        days = 0\n        \n        # Simulate the days of the week\n        for i in range(7):\n            day_of_week = (start_day + i) % 7\n            \n            if day_of_week in [0, 3, 6]:  # Fish days\n                if fish > 0:\n                    fish -= 1\n                    days += 1\n                else:\n                    break\n            elif day_of_week in [1, 5]:  # Rabbit days\n                if rabbit > 0:\n                    rabbit -= 1\n                    days += 1\n                else:\n                    break\n            else:  # Chicken days\n                if chicken > 0:\n                    chicken -= 1\n                    days += 1\n                else:\n                    break\n        \n        max_days = max(max_days, days)\n\n    return max_days\n\n# Input\na, b, c = map(int, input().split())\n# Output\nprint(max_days(a, b, c))\n```",
    "85": "```python\ndef find_price(A, B):\n    for price in range(1, 10000):  # Arbitrarily chosen upper limit\n        tax_8 = int(price * 0.08)\n        tax_10 = int(price * 0.10)\n        if tax_8 == A and tax_10 == B:\n            return price\n    return -1\n\n# Input\nA, B = map(int, input().split())\n# Output\nprint(find_price(A, B))\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n\n    # Build the adjacency list\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Check for degree constraints\n    if len(graph[1]) < D:\n        return \"NO\"\n\n    # Use BFS or DFS to find a spanning tree\n    visited = [False] * (n + 1)\n    spanning_tree_edges = []\n\n    # Start with vertex 1\n    visited[1] = True\n    queue = deque([1])\n    degree_count = 0\n\n    # First, let's add D edges from vertex 1\n    for neighbor in graph[1]:\n        if degree_count < D:\n            spanning_tree_edges.append((1, neighbor))\n            visited[neighbor] = True\n            degree_count += 1\n        else:\n            break\n\n    # Now we need to perform BFS/DFS to cover the rest of the graph\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                spanning_tree_edges.append((current, neighbor))\n                queue.append(neighbor)\n                if len(spanning_tree_edges) == n - 1:\n                    break\n        if len(spanning_tree_edges) == n - 1:\n            break\n\n    if len(spanning_tree_edges) == n - 1:\n        return \"YES\", spanning_tree_edges\n    else:\n        return \"NO\"\n\n# Input reading\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\nresult = find_spanning_tree(n, m, D, edges)\n\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for u, v in result[1]:\n        print(u, v)\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n    \n    # Iterate over all possible dimensions of the rectangle\n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            # Check both (width, height) and (height, width)\n            for w, h in [(width, height), (height, width)]:\n                # Check possible red rectangle dimensions\n                for red_width in range(1, w + 1):\n                    if a % red_width == 0:\n                        red_height = a // red_width\n                        if red_height <= h:\n                            perimeter = 2 * (w + h)\n                            min_perimeter = min(min_perimeter, perimeter)\n                \n                # Check possible blue rectangle dimensions\n                for blue_width in range(1, w + 1):\n                    if b % blue_width == 0:\n                        blue_height = b // blue_width\n                        if blue_height <= h:\n                            perimeter = 2 * (w + h)\n                            min_perimeter = min(min_perimeter, perimeter)\n\n    return min_perimeter\n\n# Input\na, b = map(int, input().split())\n# Output\nprint(minimal_perimeter(a, b))\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    # Create a list to hold the color of each character\n    color = [0] * n\n    \n    # A list to track the last occurrence of each character\n    last_occurrence = {}\n    \n    # The number of colors used\n    color_count = 0\n    \n    for i in range(n):\n        char = s[i]\n        \n        # If character has not been seen before, use a new color\n        if char not in last_occurrence:\n            color_count += 1\n            color[i] = color_count\n        else:\n            # If it has been seen, we can assign the same color\n            color[i] = color[last_occurrence[char]]\n        \n        # Update the last occurrence of the character\n        last_occurrence[char] = i\n    \n    return color_count, color\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result\nres, coloring = min_colors_to_sort(n, s)\n\n# Print output\nprint(res)\nprint(' '.join(map(str, coloring)))\n```",
    "78": "```python\nMOD = 1000000007\n\ndef count_regular_bracket_sequences(n, s):\n    m = len(s)\n    \n    # Precompute the number of valid bracket sequences of length 2*k\n    # dp[k] means the number of valid sequences of length 2*k\n    dp = [0] * (n + 1)\n    dp[0] = 1  # Base case: there's one valid sequence of length 0 (the empty sequence)\n\n    for k in range(1, n + 1):\n        for j in range(k):\n            dp[k] = (dp[k] + dp[j] * dp[k - 1 - j]) % MOD\n\n    # Check the required properties of the substring s\n    # We will check if the substring s can be a part of a valid sequence of length 2n\n    \n    # Balance array to check if part of the string is valid\n    balance = 0\n    min_balance = 0\n    \n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n\n    # If the total balance is not zero or the minimum balance is negative, it's invalid\n    if balance < 0 or (n * 2 - m) + balance < 0:\n        return 0\n\n    # Remaining open and close brackets we can place\n    remaining_open = n - (s.count('('))\n    remaining_close = n - (s.count(')'))\n\n    # If we take s as a valid sequence, we need to fill the remaining length\n    total_sequences = 0\n\n    for k in range(remaining_open + 1):\n        if k <= remaining_close:\n            total_sequences = (total_sequences + dp[remaining_open + remaining_close - k]) % MOD\n\n    return total_sequences\n\n# Input reading\nn = int(input())\ns = input()\n\n# Output the result\nprint(count_regular_bracket_sequences(n, s))\n```",
    "84": "```python\ndef can_color_sort(n, s):\n    color = ['0'] * n\n    last_pos = {}\n    \n    for i in range(n):\n        char = s[i]\n        if char in last_pos:\n            # If the same character appears again, we check the last position\n            if last_pos[char] is not None:\n                # Check if the character before the last occurrence is different\n                if s[last_pos[char]] != char:\n                    # Color it differently\n                    color[i] = '1' if color[last_pos[char]] == '0' else '0'\n                # Update last position\n                last_pos[char] = i\n            else:\n                last_pos[char] = i\n        else:\n            last_pos[char] = i\n    \n    # Check for any conflicts while coloring\n    for i in range(n - 1):\n        if s[i] == s[i + 1] and color[i] != color[i + 1]:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    print(''.join(color))\n\n# Input reading\nn = int(input())\ns = input()\n\ncan_color_sort(n, s)\n```",
    "82": "```python\nn, k = map(int, input().split())\nproblems = list(map(int, input().split()))\n\nsolved = 0\n\n# Solve from the left\nwhile solved < n and problems[solved] <= k:\n    solved += 1\n\n# Solve from the right\nwhile solved < n and problems[n - 1 - (solved - 1)] <= k:\n    solved += 1\n\n# If we solved problems from both ends, we need to ensure we don't double count\nif solved > n:\n    solved = n\n\nprint(solved)\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    n_str = str(n)\n    length = len(n_str)\n    \n    # Check for possible pairs of digits that can form '00', '25', '50', '75'\n    targets = ['00', '25', '50', '75']\n    min_moves = float('inf')\n\n    for target in targets:\n        last_digit = target[1]\n        first_digit = target[0]\n        \n        # Find last_digit first\n        last_index = -1\n        for i in range(length - 1, -1, -1):\n            if n_str[i] == last_digit:\n                last_index = i\n                break\n        \n        if last_index == -1:\n            continue  # Last digit not found, move to next target\n        \n        # Now find the first_digit before last_index\n        first_index = -1\n        for i in range(last_index - 1, -1, -1):\n            if n_str[i] == first_digit:\n                first_index = i\n                break\n        \n        if first_index == -1:\n            continue  # First digit not found, move to next target\n        \n        # Calculate moves to bring first_digit to the position before last_digit\n        # Each swap brings first_digit closer by 1 position\n        moves = (last_index - first_index) + (last_index - (first_index + 1))\n        \n        # Update minimum moves\n        min_moves = min(min_moves, moves)\n    \n    return min_moves if min_moves != float('inf') else -1\n\n# Example usage\nn = int(input().strip())\nresult = min_moves_to_divisible_by_25(n)\nprint(result)\n```",
    "92": "```python\nx = float(input().strip())\na = int(x) + 1\nb = int((x - int(x)) * 10) + 1\nprint(a, b)\n```",
    "86": "```python\ndef solve_problems(n, k):\n    # The minimum sum to satisfy the conditions\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n    \n    # Start with the minimum required values\n    a = list(range(1, k + 1))\n    current_sum = sum(a)\n\n    # We need to distribute the remaining problems\n    remaining = n - current_sum\n    \n    # Start from the last element and try to increase it\n    for i in range(k - 1, -1, -1):\n        # Maximum we can increase a[i] to\n        max_increase = 2 * a[i] - a[i]\n        # Max we can add without exceeding the next day's limit\n        add = min(remaining, max_increase)\n        a[i] += add\n        remaining -= add\n        if remaining <= 0:\n            break\n    \n    if remaining > 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n\n# Example usage\nn, k = map(int, input().split())\nsolve_problems(n, k)\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects by the required rating a_i\n    projects.sort(key=lambda x: x[0])\n    \n    completed_projects = 0\n    current_rating = r\n    \n    for a_i, b_i in projects:\n        if current_rating >= a_i:\n            completed_projects += 1\n            current_rating += b_i\n            # Ensure rating does not go below zero\n            if current_rating < 0:\n                break\n\n    return completed_projects\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_projects(n, r, projects))\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects based on the required rating (a_i)\n    projects.sort(key=lambda x: x[0])\n    \n    for a_i, b_i in projects:\n        if r < a_i:  # Check if current rating is less than required\n            return \"NO\"\n        r += b_i  # Update rating after completing the project\n        if r < 0:  # Check if rating goes below zero\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input handling\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_complete_projects(n, r, projects))\n```",
    "97": "```python\ndef min_coins_to_move_chips(n, positions):\n    odd_count = sum(1 for x in positions if x % 2 != 0)\n    even_count = n - odd_count\n    return min(odd_count, even_count)\n\n# Input reading\nn = int(input())\npositions = list(map(int, input().split()))\n\n# Output the result\nprint(min_coins_to_move_chips(n, positions))\n```",
    "90": "```python\ndef can_reach(n, m, d, c):\n    # Initialize the result array with zeros\n    result = [0] * n\n    \n    # Position to place the platforms\n    current_position = 1  # starts from 1 since 0 is the left bank\n\n    # Place each platform\n    for i in range(m):\n        platform_length = c[i]\n        \n        # Place the platform at the current position\n        for j in range(platform_length):\n            result[current_position - 1 + j] = i + 1  # 1-indexed platform\n        current_position += platform_length\n\n        # If we can place the next platform, we need to ensure there's space.\n        if i < m - 1:  # If there is another platform\n            current_position += 1  # Leave a gap for jumping\n\n    # Now we need to check if we can reach n + 1 from 0\n    # We can reach n + 1 if the last platform can be accessed\n    if current_position - 1 <= n:\n        print(\"YES\")\n        print(\" \".join(map(str, result)))\n    else:\n        print(\"NO\")\n\n# Input reading\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\ncan_reach(n, m, d, c)\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    p = [0] * n\n    p[0] = 0  # Starting from an arbitrary point (0)\n    \n    # Calculate p from q\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n    \n    # Adjust to make the minimum value in p to be 1\n    min_p = min(p)\n    if min_p < 1:\n        # Shift all values up to make the smallest value 1\n        shift = 1 - min_p\n        for i in range(n):\n            p[i] += shift\n    \n    # Check if p is a valid permutation\n    if len(set(p)) == n and all(1 <= x <= n for x in p):\n        print(\" \".join(map(str, p)))\n    else:\n        print(-1)\n\n# Input processing\nn = int(input())\nq = list(map(int, input().split()))\n\nrestore_permutation(n, q)\n```",
    "98": "```python\ndef min_moves_to_reach(N):\n    moves = float('inf')\n    \n    # Loop over all possible i values\n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:  # If i is a divisor of N\n            j = N // i\n            # Calculate moves required to reach (i, j)\n            moves = min(moves, i + j - 2)\n    \n    return moves\n\n# Read input\nN = int(input().strip())\n# Output the result\nprint(min_moves_to_reach(N))\n```",
    "88": "```python\ndef create_palindromic_matrix(n, numbers):\n    from collections import Counter\n    \n    # Count occurrences of each number\n    count = Counter(numbers)\n    \n    # Check if the counts can form a palindromic matrix\n    odd_count = 0\n    for freq in count.values():\n        if freq % 2 == 1:\n            odd_count += 1\n            \n    # For even n, there can be no odd counts, for odd n, there can be at most one odd count\n    if (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n        return \"NO\"\n    \n    # Create the matrix\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Fill the matrix with numbers\n    half_matrix = []\n    for num, freq in count.items():\n        half_matrix.extend([num] * (freq // 2))\n    \n    # Create full palindromic matrix\n    idx = 0\n    for i in range(n):\n        for j in range(n):\n            if i < n // 2:\n                matrix[i][j] = half_matrix[idx]\n                matrix[n - 1 - i][j] = half_matrix[idx]\n                matrix[i][n - 1 - j] = half_matrix[idx]\n                matrix[n - 1 - i][n - 1 - j] = half_matrix[idx]\n                idx += 1\n            elif n % 2 == 1 and i == n // 2:\n                if j == n // 2:\n                    # Place the odd count number in the center if needed\n                    for num, freq in count.items():\n                        if freq % 2 == 1:\n                            matrix[i][j] = num\n                            break\n    \n    return \"YES\", matrix\n\n# Input reading\nn = int(input())\nnumbers = list(map(int, input().split()))\n\n# Function call to create the palindromic matrix\nresult = create_palindromic_matrix(n, numbers)\n\n# Output result\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for row in result[1]:\n        print(' '.join(map(str, row)))\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n    \n    # Create arrays to store the position of characters from 't' in 's'\n    left = [-1] * m\n    right = [-1] * m\n    \n    # Fill left array\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n    \n    # Fill right array\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n    \n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n    \n    # Consider removing from the start or end\n    max_length = max(max_length, right[0])  # Remove from start to the first occurrence of t[0]\n    max_length = max(max_length, n - 1 - left[m - 1])  # Remove from the last occurrence of t[m-1] to the end\n    \n    return max_length\n\n# Input reading\ns = input().strip()\nt = input().strip()\n\n# Function call and output\nprint(max_removable_length(s, t))\n```",
    "99": "```python\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\n# Calculate maximum wins for Alice\nmax_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n\n# Calculate minimum wins for Alice\n# To find the minimum wins, we want to maximize Bob's wins\n# Calculate Bob's wins against Alice's moves\nbob_wins = min(a1, b1) + min(a2, b2) + min(a3, b3)\nalice_wins = n - bob_wins  # Total rounds minus Bob's wins gives us Alice's wins\nmin_wins = alice_wins\n\nprint(min_wins, max_wins)\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Create the result list\n    res = []\n    \n    # Count of each character\n    count_a = n\n    count_b = n\n    count_c = n\n    \n    # Create a list of available characters\n    chars = ['a', 'b', 'c']\n    \n    # Function to check if the last two characters form forbidden substrings\n    def is_forbidden():\n        return ''.join(res[-2:]) == s or ''.join(res[-2:]) == t\n    \n    # Start placing characters in the result\n    while count_a > 0 or count_b > 0 or count_c > 0:\n        for char in chars:\n            if char == 'a' and count_a > 0:\n                res.append(char)\n                count_a -= 1\n            elif char == 'b' and count_b > 0:\n                res.append(char)\n                count_b -= 1\n            elif char == 'c' and count_c > 0:\n                res.append(char)\n                count_c -= 1\n            \n            # Check if the last two characters form forbidden substrings\n            if is_forbidden():\n                # If forbidden, backtrack the last character added\n                res.pop()\n                # Restore count for the character that was removed\n                if char == 'a':\n                    count_a += 1\n                elif char == 'b':\n                    count_b += 1\n                elif char == 'c':\n                    count_c += 1\n                \n            # Check if we have completed the string\n            if len(res) == 3 * n:\n                print(\"YES\")\n                print(''.join(res))\n                return\n            \n    print(\"NO\")\n\n# Input reading\nn = int(input())\ns = input().strip()\nt = input().strip()\n\n# Generate the string\ngenerate_string(n, s, t)\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1 or (d == 1 and n > 1) or (n > k * (k - 1) + 1 and d > 1):\n        print(\"NO\")\n        return\n    \n    edges = []\n    \n    # Create the main path for the diameter\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n    \n    # Now we have a path 1-2-3-...-(d+1) making the diameter d\n    current_vertex = d + 2\n    \n    # Attach extra vertices to the path\n    for i in range(1, d + 1):\n        if current_vertex > n:\n            break\n        # Attach vertices to vertex i\n        for _ in range(k - 1):\n            if current_vertex > n:\n                break\n            edges.append((i, current_vertex))\n            current_vertex += 1\n            \n    # If we still have vertices left, we need to attach them\n    while current_vertex <= n:\n        if current_vertex > n:\n            break\n        edges.append((1, current_vertex))  # Attach to the root (or any node)\n        current_vertex += 1\n    \n    # Print the result\n    print(\"YES\")\n    for u, v in edges:\n        print(u, v)\n\n# Example input\nn, d, k = map(int, input().split())\nconstruct_tree(n, d, k)\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Start with the base pattern depending on x\n    if x % 2 == 1:\n        s = '01' * (x // 2) + '0' * (a - (x // 2)) + '1' * (b - (x // 2))\n    else:\n        s = '10' * (x // 2) + '0' * (a - (x // 2)) + '1' * (b - (x // 2))\n    \n    # Adjust the string to meet the exact counts of a and b\n    if a > b:\n        s = s.replace('0', '', a - (x // 2))\n    else:\n        s = s.replace('1', '', b - (x // 2))\n    \n    # Fill remaining characters\n    while len(s) < a + b:\n        if a > 0:\n            s += '0'\n            a -= 1\n        if b > 0:\n            s += '1'\n            b -= 1\n    \n    return s\n\n# Read input\na, b, x = map(int, input().split())\nresult = construct_binary_string(a, b, x)\nprint(result)\n```"
}