{
    "10": "```python\nn = int(input())\n\n# Calculate the maximum days off\nmax_days_off = (n // 7) * 2 + min(2, n % 7)\n\n# Calculate the minimum days off\n# If there are less than 5 work days, all can be days off\nmin_days_off = 0 if n >= 5 else n\n\nprint(min_days_off, max_days_off)\n```",
    "7": "```python\ndef day_when_barn_empty(n, m):\n    day = 0\n    grains = n\n    \n    while grains > 0:\n        day += 1\n        grains += m  # grains brought to the barn\n        if grains > n:\n            grains = n  # barn is full, excess grains are ignored\n        grains -= day  # sparrows eat grains\n        \n    return day\n\n# Input reading\nn, m = map(int, input().split())\nprint(day_when_barn_empty(n, m))\n```",
    "2": "```python\ndef next_lucky_year(n):\n    # Function to check if a year is lucky\n    def is_lucky(year):\n        # Convert year to string and count non-zero digits\n        return sum(1 for digit in str(year) if digit != '0') <= 1\n\n    # Start checking from the next year\n    next_year = n + 1\n    while not is_lucky(next_year):\n        next_year += 1\n\n    return next_year - n\n\n# Input\nn = int(input())\n# Output\nprint(next_lucky_year(n))\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    # Create an array to keep track of painted sections\n    painted = [0] * (n + 1)\n\n    # Function to calculate the number of painted sections\n    def calculate_painted(painters_to_consider):\n        painted_count = [0] * (n + 1)\n        for l, r in painters_to_consider:\n            for i in range(l, r + 1):\n                painted_count[i] = 1\n        return sum(painted_count)\n\n    # Try removing each pair of painters and calculate the painted sections\n    max_sections = 0\n    for i in range(q):\n        for j in range(i + 1, q):\n            # Create a list of painters excluding the i-th and j-th\n            painters_to_consider = [painters[k] for k in range(q) if k != i and k != j]\n            max_sections = max(max_sections, calculate_painted(painters_to_consider))\n\n    return max_sections\n\n# Read input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Get the result and print it\nresult = max_painted_sections(n, q, painters)\nprint(result)\n```",
    "5": "```python\ndef min_seconds_to_close_tabs(n, pos, l, r):\n    # If all tabs are within the range [l, r], no action is needed\n    if l == 1 and r == n:\n        return 0\n    \n    seconds = 0\n    \n    # Close tabs to the left of l\n    if l > 1:\n        # Move to l if not already there\n        if pos < l:\n            seconds += (l - pos)  # Move right to l\n        else:\n            seconds += (pos - l)  # Move left to l\n        \n        seconds += 1  # Close tabs to the left of l\n    \n    # Close tabs to the right of r\n    if r < n:\n        # Move to r if not already there\n        if pos > r:\n            seconds += (pos - r)  # Move left to r\n        else:\n            seconds += (r - pos)  # Move right to r\n        \n        seconds += 1  # Close tabs to the right of r\n    \n    return seconds\n\n# Read input\nn, pos, l, r = map(int, input().split())\n# Print the result\nprint(min_seconds_to_close_tabs(n, pos, l, r))\n```",
    "1": "```python\ndef max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n    \n    # Start with the maximum number being x itself\n    max_num = x\n    max_sum = sum(int(d) for d in str_x)\n    \n    # Check numbers by reducing digits\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit by 1 and setting all following digits to 9\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        new_number = int(new_number)\n        \n        if new_number > 0 and new_number <= x:\n            current_sum = sum(int(d) for d in str(new_number))\n            if current_sum > max_sum or (current_sum == max_sum and new_number > max_num):\n                max_num = new_number\n                max_sum = current_sum\n    \n    return max_num\n\n# Input reading\nx = int(input().strip())\nprint(max_digit_sum(x))\n```",
    "0": "```python\ndef max_acordion_length(s):\n    # Initialize variables to track the positions of the required characters\n    open_bracket = -1\n    first_colon = -1\n    last_colon = -1\n    close_bracket = -1\n    \n    # Iterate through the string to find the required characters\n    for i, char in enumerate(s):\n        if char == '[' and open_bracket == -1:\n            open_bracket = i\n        elif char == ':' and open_bracket != -1 and first_colon == -1:\n            first_colon = i\n        elif char == ':' and first_colon != -1:\n            last_colon = i\n        elif char == ']' and last_colon != -1 and close_bracket == -1:\n            close_bracket = i\n            \n    # Check if we found a valid accordion structure\n    if open_bracket == -1 or first_colon == -1 or last_colon == -1 or close_bracket == -1:\n        return -1\n    \n    # Calculate the number of vertical lines between the colons\n    vertical_lines_count = last_colon - first_colon - 1\n    \n    # Calculate the total length of the accordion\n    accordion_length = 4 + vertical_lines_count\n    \n    return accordion_length\n\n# Read input\ns = input().strip()\n# Get the maximum accordion length\nresult = max_acordion_length(s)\n# Print the result\nprint(result)\n```",
    "6": "```python\ndef min_blows_to_defeat(t, queries):\n    results = []\n    \n    for query in queries:\n        n, x, blows = query\n        min_blows = float('inf')\n        \n        for d, h in blows:\n            if d >= x:\n                min_blows = min(min_blows, 1)\n            else:\n                # Calculate the effective damage after growth\n                effective_damage = d - h\n                if effective_damage > 0:\n                    # Calculate the number of blows needed\n                    blows_needed = (x - d + effective_damage - 1) // effective_damage + 1\n                    min_blows = min(min_blows, blows_needed)\n        \n        results.append(min_blows if min_blows != float('inf') else -1)\n    \n    return results\n\n# Input reading\nt = int(input())\nqueries = []\n\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\n# Get results\nresults = min_blows_to_defeat(t, queries)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    # Calculate the number of tiles painted Red\n    red_tiles = n // a\n    # Calculate the number of tiles painted Blue\n    blue_tiles = n // b\n    # Calculate the number of tiles painted both Red and Blue (common multiples)\n    common_tiles = n // (a * b // gcd(a, b))\n    \n    # Total chocolates from Red tiles\n    total_red_chocolates = red_tiles * p\n    # Total chocolates from Blue tiles\n    total_blue_chocolates = blue_tiles * q\n    \n    # Since common tiles can be painted either Red or Blue, we take the maximum of both scenarios\n    # 1. Paint common tiles Red\n    # 2. Paint common tiles Blue\n    max_chocolates = max(total_red_chocolates + (blue_tiles - common_tiles) * q,\n                         total_blue_chocolates + (red_tiles - common_tiles) * p)\n    \n    return max_chocolates\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n# Example usage\nn, a, b, p, q = map(int, input().split())\nprint(max_chocolates(n, a, b, p, q))\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    # Step 1: Find the current longest segment of 'G's\n    max_length = 0\n    current_length = 0\n    segments = []\n    \n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n                max_length = max(max_length, current_length)\n            current_length = 0\n    \n    if current_length > 0:\n        segments.append(current_length)\n        max_length = max(max_length, current_length)\n    \n    # Step 2: If there are no 'S' trophies, return the current max_length\n    if 'S' not in trophies:\n        return max_length\n    \n    # Step 3: Calculate the maximum possible length after one swap\n    max_possible_length = max_length\n    \n    for i in range(len(segments) - 1):\n        # Check if we can swap an 'S' trophy between two segments of 'G's\n        combined_length = segments[i] + segments[i + 1]\n        max_possible_length = max(max_possible_length, combined_length + 1)\n    \n    return max_possible_length\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\n\n# Output the result\nprint(max_beauty_after_swap(n, trophies))\n```",
    "16": "```python\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\n# Check the conditions for forming a regular bracket sequence\nif cnt_1 + cnt_2 >= cnt_3 + cnt_4 and cnt_1 <= cnt_3 + cnt_2:\n    print(1)\nelse:\n    print(0)\n```",
    "9": "```python\nd = int(input())\nn, m = map(int, input().split())\n\nsofas = []\nfor i in range(d):\n    x1, y1, x2, y2 = map(int, input().split())\n    sofas.append((x1, y1, x2, y2))\n\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\ndef count_neighbors(sofa):\n    x1, y1, x2, y2 = sofa\n    left = right = top = bottom = 0\n    \n    for other in sofas:\n        if other == sofa:\n            continue\n        ox1, oy1, ox2, oy2 = other\n        \n        if x1 == x2:  # Vertical sofa\n            if oy1 < y1:  # Other sofa is above\n                top += 1\n            elif oy1 > y2:  # Other sofa is below\n                bottom += 1\n            elif ox2 < y1:  # Other sofa is to the left\n                left += 1\n            elif ox1 > y2:  # Other sofa is to the right\n                right += 1\n        else:  # Horizontal sofa\n            if ox1 < x1:  # Other sofa is to the left\n                left += 1\n            elif ox1 > x2:  # Other sofa is to the right\n                right += 1\n            elif y1 == y2:  # Same row\n                if ox2 < y1:  # Other sofa is above\n                    top += 1\n                elif oy1 > y2:  # Other sofa is below\n                    bottom += 1\n\n    return left, right, top, bottom\n\nfor i in range(d):\n    left, right, top, bottom = count_neighbors(sofas[i])\n    if (left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b):\n        print(i + 1)\n        break\nelse:\n    print(-1)\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelse:\n    print(n + k - t)\n```",
    "8": "```python\ndef min_tiles_to_draw(tiles):\n    suits = {'m': [], 'p': [], 's': []}\n    \n    # Parse the input tiles and categorize them by suit\n    for tile in tiles:\n        number = int(tile[0])\n        suit = tile[1]\n        suits[suit].append(number)\n    \n    # Check for koutsu (triplet)\n    for suit in suits.values():\n        if len(suit) == 3 and suit[0] == suit[1] == suit[2]:\n            return 0  # Already has a koutsu\n    \n    # Check for shuntsu (sequence)\n    for suit in suits.values():\n        if len(suit) >= 3:\n            suit.sort()\n            for i in range(len(suit) - 2):\n                if suit[i] + 1 == suit[i + 1] and suit[i + 1] + 1 == suit[i + 2]:\n                    return 0  # Already has a shuntsu\n    \n    # Check for potential shuntsu with one draw\n    for suit in suits.values():\n        if len(suit) == 2:\n            # Check if we can form a shuntsu by drawing one tile\n            if (suit[0] + 1 == suit[1] or suit[0] + 2 == suit[1] or suit[1] + 1 == suit[0] or suit[1] + 2 == suit[0]):\n                return 1  # Can form a shuntsu with one draw\n    \n    # Check for potential shuntsu with two draws\n    for suit in suits.values():\n        if len(suit) == 1:\n            # If we have one tile, we need two more to form a shuntsu\n            if suit[0] > 1 and suit[0] < 9:\n                return 2  # Need two draws to form a shuntsu\n            else:\n                return 2  # Need two draws to form a shuntsu (1 or 9 case)\n    \n    return 2  # If we have no tiles or all are different, we need two draws\n\n# Read input\ntiles = input().strip().split()\n# Output the result\nprint(min_tiles_to_draw(tiles))\n```",
    "18": "```python\ndef lexicographically_minimal_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        # Append the character from s to t\n        t.append(char)\n        \n        # While t is not empty and the last character of t is the smallest possible\n        while t:\n            # Find the smallest character in t\n            min_char = min(t)\n            # If the last character of t is the smallest, pop it to u\n            if t[-1] == min_char:\n                u.append(t.pop())\n            else:\n                break\n    \n    # Join the list u to form the resulting string\n    return ''.join(u)\n\n# Input reading\ns = input().strip()\n# Output the result\nprint(lexicographically_minimal_string(s))\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef find_courses(n, k, main_courses, dependencies):\n    # Create a graph and a list to track in-degrees\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    \n    # Build the graph and in-degree count\n    for i in range(1, n + 1):\n        for dep in dependencies[i - 1]:\n            graph[dep].append(i)\n            in_degree[i] += 1\n\n    # Queue for courses that can be taken (in-degree 0)\n    queue = deque()\n    for course in range(1, n + 1):\n        if in_degree[course] == 0:\n            queue.append(course)\n\n    # To track the courses to take\n    order = []\n    taken_courses = set()\n\n    # Process the courses\n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        taken_courses.add(course)\n\n        for next_course in graph[course]:\n            in_degree[next_course] -= 1\n            if in_degree[next_course] == 0:\n                queue.append(next_course)\n\n    # Check if all main courses can be taken\n    for main in main_courses:\n        if main not in taken_courses:\n            return -1\n\n    # Collect all courses that need to be taken\n    result = []\n    for main in main_courses:\n        result.append(main)\n        for course in order:\n            if course not in result and (course not in main_courses or course in taken_courses):\n                result.append(course)\n\n    return len(result), result\n\n# Input reading\nn, k = map(int, input().split())\nmain_courses = list(map(int, input().split()))\ndependencies = [list(map(int, input().split()[1:])) for _ in range(n)]\n\n# Solve the problem\nresult = find_courses(n, k, main_courses, dependencies)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(result[0])\n    print(' '.join(map(str, result[1])))\n```",
    "19": "```python\ndef check_records(test_cases):\n    results = []\n    for case in test_cases:\n        n = case[0]\n        records = case[1]\n        \n        valid = True\n        prev_p, prev_c = 0, 0\n        \n        for p, c in records:\n            if p < prev_p or c < prev_c or c > p:\n                valid = False\n                break\n            if p - prev_p < c - prev_c:\n                valid = False\n                break\n            \n            prev_p, prev_c = p, c\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Read input\nT = int(input())\ntest_cases = []\n\nfor _ in range(T):\n    n = int(input())\n    records = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, records))\n\n# Get results\nresults = check_records(test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return minutes_passed\n\ntime_input = input().strip()\nhh, mm = map(int, time_input.split(':'))\nresult = next_palindrome_time(hh, mm)\nprint(result)\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a, b):\n    from itertools import permutations\n    \n    # Convert a to string to work with its digits\n    str_a = str(a)\n    str_b = str(b)\n    \n    # Generate all unique permutations of the digits of a\n    perms = set(permutations(str_a))\n    \n    # Filter out permutations that are valid (not starting with '0' and not exceeding b)\n    valid_perms = []\n    for perm in perms:\n        num = int(''.join(perm))\n        if num <= b and str(num) == str_a:  # Check if it has the same length as a\n            valid_perms.append(num)\n    \n    # Return the maximum valid permutation\n    return max(valid_perms)\n\n# Input reading\na = int(input().strip())\nb = int(input().strip())\n\n# Get the result\nresult = max_permutation_not_exceeding(a, b)\n\n# Print the result\nprint(result)\n```",
    "14": "```python\ndef is_stack_sortable(n, k, p):\n    # Create a set of used elements from the first k elements\n    used = set(p)\n    # The remaining elements that need to be added to the permutation\n    remaining = [i for i in range(1, n + 1) if i not in used]\n    \n    # Initialize the result with the first k elements\n    result = p[:]\n    \n    # Initialize a stack\n    stack = []\n    \n    # The next number we expect to append to the result\n    next_expected = 1\n    \n    # Iterate through the first k elements\n    for i in range(k):\n        while stack and stack[-1] == next_expected:\n            result.append(stack.pop())\n            next_expected += 1\n        \n        # If the current element is not the expected one\n        if p[i] != next_expected:\n            # Push the current element onto the stack\n            stack.append(p[i])\n        else:\n            # If it is the expected one, append it to the result\n            result.append(p[i])\n            next_expected += 1\n    \n    # Now we need to process the remaining elements\n    for num in sorted(remaining, reverse=True):\n        while stack and stack[-1] == next_expected:\n            result.append(stack.pop())\n            next_expected += 1\n        stack.append(num)\n    \n    # Finally, empty the stack if possible\n    while stack and stack[-1] == next_expected:\n        result.append(stack.pop())\n        next_expected += 1\n    \n    # Check if we have added all numbers from 1 to n\n    if next_expected - 1 == n:\n        print(\" \".join(map(str, result)))\n    else:\n        print(-1)\n\n# Example usage\nn, k = map(int, input().split())\np = list(map(int, input().split()))\nis_stack_sortable(n, k, p)\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    if k > n * n or (n % 2 == 0 and k % 2 != 0):\n        return -1\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k <= 0:\n            break\n        for j in range(i, n):\n            if k <= 0:\n                break\n            if i == j:  # Diagonal element\n                if k >= 1:\n                    matrix[i][j] = 1\n                    k -= 1\n            else:  # Symmetric pair\n                if k >= 2:\n                    matrix[i][j] = 1\n                    matrix[j][i] = 1\n                    k -= 2\n    \n    if k > 0:\n        return -1\n    \n    return matrix\n\n# Read input\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    # Define a mapping for mirror reflections\n    mirror_map = {\n        'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M',\n        'O': 'O', 'p': 'q', 'q': 'p', 'R': 'R', 'S': 'S', 'T': 'T',\n        'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X', 'Y': 'Y', 'Z': 'Z',\n        'o': 'o', 'x': 'x'\n    }\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        left_char = s[i]\n        right_char = s[n - 1 - i]\n        \n        # Check if the characters are mirror reflections\n        if left_char not in mirror_map or mirror_map[left_char] != right_char:\n            print(\"NIE\")\n            return\n    \n    print(\"TAK\")\n\n# Example usage\ns = input().strip()\nis_s_palindrome(s)\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = []\nregulars = []\n\n# Separate examples and regular tests\nfor name, type_ in files:\n    if type_ == '1':\n        examples.append(name)\n    else:\n        regulars.append(name)\n\n# Prepare the moves\nmoves = []\ne = len(examples)\n\n# Rename examples to 1, 2, ..., e\nfor i in range(e):\n    moves.append(f\"move {examples[i]} {i + 1}\")\n\n# Rename regular tests to e + 1, e + 2, ..., n\nfor i in range(len(regulars)):\n    moves.append(f\"move {regulars[i]} {e + i + 1}\")\n\n# Output the result\nprint(len(moves))\nfor move in moves:\n    print(move)\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # Since GCD(x, m) = 1, the mouse will visit all rooms in a cycle.\n    # The number of unique rooms visited is equal to the number of steps\n    # until it returns to the starting room, which is m.\n    \n    # The number of traps needed is m - 1 (for all rooms except room 0)\n    # plus 1 for room 0 itself.\n    return m\n\n# Read input\nm, x = map(int, input().split())\n# Output the result\nprint(minimum_traps(m, x))\n```",
    "27": "```python\nn = int(input())\ns = input()\n\n# Initialize the minimum operations to the length of the string (typing all characters one by one)\nmin_operations = n\n\n# Check for possible copy operations\nfor i in range(1, n):\n    # If the prefix of length i is equal to the suffix of length i\n    if s[:i] == s[i:2*i]:\n        # Calculate the operations: type i characters, copy, and type the remaining characters\n        operations = i + 1 + (n - 2 * i)\n        min_operations = min(min_operations, operations)\n\nprint(min_operations)\n```",
    "24": "```python\ndef can_win(matrix):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # horizontal, vertical, diagonal /\n    \n    def check_win(x, y):\n        for dx, dy in directions:\n            count = 1\n            \n            # Check in the positive direction\n            nx, ny = x + dx, y + dy\n            while 0 <= nx < 10 and 0 <= ny < 10 and matrix[nx][ny] == 'X':\n                count += 1\n                nx += dx\n                ny += dy\n            \n            # Check in the negative direction\n            nx, ny = x - dx, y - dy\n            while 0 <= nx < 10 and 0 <= ny < 10 and matrix[nx][ny] == 'X':\n                count += 1\n                nx -= dx\n                ny -= dy\n            \n            if count >= 5:\n                return True\n        \n        return False\n    \n    for i in range(10):\n        for j in range(10):\n            if matrix[i][j] == '.':\n                # Temporarily place 'X' to check for a win\n                matrix[i][j] = 'X'\n                if check_win(i, j):\n                    return \"YES\"\n                # Remove the temporary 'X'\n                matrix[i][j] = '.'\n    \n    return \"NO\"\n\n# Read the input\nmatrix = [input().strip() for _ in range(10)]\nprint(can_win(matrix))\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket):\n    # Split the ticket into two halves\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    # Calculate the sums of both halves\n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    # Calculate the difference\n    diff = abs(sum_first - sum_second)\n    \n    # If the ticket is already lucky\n    if diff == 0:\n        return 0\n    \n    # Create a list of possible changes\n    changes = []\n    for digit in first_half:\n        changes.append(9 - digit)  # Max change possible for first half\n    for digit in second_half:\n        changes.append(digit)  # Max change possible for second half\n    \n    # Sort changes in descending order\n    changes.sort(reverse=True)\n    \n    # Calculate the minimum number of replacements needed\n    replacements = 0\n    for change in changes:\n        diff -= change\n        replacements += 1\n        if diff <= 0:\n            break\n    \n    return replacements\n\n# Example usage\nticket = input().strip()\nprint(min_replacements_to_lucky(ticket))\n```",
    "26": "```python\nimport math\n\n# Read input\nx, y, z = map(float, input().split())\n\n# Define the expressions and their corresponding string representations\nexpressions = [\n    (x**(y**z), \"x^y^z\"),\n    (x**(z**y), \"x^z^y\"),\n    ((x**y)**z, \"(x^y)^z\"),\n    ((x**z)**y, \"(x^z)^y\"),\n    (y**(x**z), \"y^x^z\"),\n    (y**(z**x), \"y^z^x\"),\n    ((y**x)**z, \"(y^x)^z\"),\n    ((y**z)**x, \"(y^z)^x\"),\n    (z**(x**y), \"z^x^y\"),\n    (z**(y**x), \"z^y^x\"),\n    ((z**x)**y, \"(z^x)^y\"),\n    ((z**y)**x, \"(z^y)^x\"),\n]\n\n# Find the maximum value and its corresponding index\nmax_value = -math.inf\nmax_index = -1\n\nfor i, (value, expr) in enumerate(expressions):\n    if value > max_value:\n        max_value = value\n        max_index = i\n\n# Output the corresponding expression\nprint(expressions[max_index][1])\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    def can_distribute(x):\n        plates_from_a = a // x\n        plates_from_b = b // x\n        return plates_from_a + plates_from_b >= n\n\n    left, right = 1, max(a, b)\n    result = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_distribute(mid):\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n\n# Input reading\nn, a, b = map(int, input().split())\nprint(max_min_pieces(n, a, b))\n```",
    "32": "```python\ndef is_valid_journey(n, journey):\n    current_distance_from_pole = 0  # Distance from the North Pole in kilometers\n\n    for t, direction in journey:\n        if current_distance_from_pole == 0 and direction != \"South\":\n            return \"NO\"  # At North Pole, can only move South\n        if current_distance_from_pole == 20000 and direction != \"North\":\n            return \"NO\"  # At South Pole, can only move North\n        \n        if direction == \"South\":\n            current_distance_from_pole += t\n        elif direction == \"North\":\n            current_distance_from_pole -= t\n        # East and West do not change the distance from the poles, so we ignore them\n\n        # Check if we exceed the limits\n        if current_distance_from_pole < 0 or current_distance_from_pole > 20000:\n            return \"NO\"\n\n    # Journey must end at the North Pole\n    return \"YES\" if current_distance_from_pole == 0 else \"NO\"\n\n\n# Input reading\nn = int(input())\njourney = [tuple(input().split()) for _ in range(n)]\njourney = [(int(t), dir) for t, dir in journey]\n\n# Output the result\nprint(is_valid_journey(n, journey))\n```",
    "35": "```python\ndef is_valid_flag(n, m, field):\n    # Check if the number of rows is divisible by 3\n    if n % 3 != 0:\n        return \"NO\"\n    \n    # Determine the height of each stripe\n    stripe_height = n // 3\n    \n    # Check for horizontal stripes\n    colors = set()\n    for i in range(3):\n        stripe_color = field[i * stripe_height][0]  # Get the color of the first column in the stripe\n        colors.add(stripe_color)\n        for j in range(stripe_height):\n            if field[i * stripe_height + j] != stripe_color * m:\n                return \"NO\"\n    \n    # Check if we have exactly three different colors\n    if len(colors) != 3:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(is_valid_flag(n, m, field))\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if any rating has changed\nrated = any(a != b for a, b in ratings)\n\nif rated:\n    print(\"rated\")\nelse:\n    # Check if the standings are in non-increasing order of the initial ratings\n    for i in range(1, n):\n        if ratings[i-1][0] < ratings[i][0]:\n            print(\"unrated\")\n            break\n    else:\n        print(\"maybe\")\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    m0, x0, x1 = m, 0, 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef birthday_paradox(n, k):\n    MOD = 1000003\n    days = 1 << n  # 2^n\n    if k > days:\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the probability of no collision\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator *= (days - i)\n        denominator *= days\n        numerator %= MOD\n        denominator %= MOD\n\n    # Probability of at least one collision\n    A = (denominator - numerator) % MOD\n    B = denominator\n\n    # Reduce A/B to irreducible form\n    common_gcd = gcd(A, B)\n    A //= common_gcd\n    B //= common_gcd\n\n    return A % MOD, B % MOD\n\n# Input reading\nn, k = map(int, input().split())\nresult = birthday_paradox(n, k)\nprint(result[0], result[1])\n```",
    "41": "```python\ndef nearest_zero_distance(n, arr):\n    distances = [0] * n\n    last_zero_index = -1\n    \n    # Forward pass to find distances to the nearest zero on the left\n    for i in range(n):\n        if arr[i] == 0:\n            last_zero_index = i\n            distances[i] = 0\n        else:\n            if last_zero_index != -1:\n                distances[i] = i - last_zero_index\n    \n    last_zero_index = -1\n    \n    # Backward pass to find distances to the nearest zero on the right\n    for i in range(n - 1, -1, -1):\n        if arr[i] == 0:\n            last_zero_index = i\n        else:\n            if last_zero_index != -1:\n                distances[i] = min(distances[i], last_zero_index - i)\n    \n    return distances\n\n# Input reading\nn = int(input())\narr = list(map(int, input().split()))\n\n# Get the result\nresult = nearest_zero_distance(n, arr)\n\n# Print the result\nprint(\" \".join(map(str, result)))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    \n    # Check if the entire string is a palindrome\n    if not is_palindrome(s):\n        return n\n    \n    # Check for the longest non-palindrome substring by removing one character from either end\n    for i in range(n):\n        if s[i] != s[0]:  # Check if removing the first character makes it non-palindrome\n            return n - 1\n        if s[i] != s[-1]:  # Check if removing the last character makes it non-palindrome\n            return n - 1\n    \n    # If all characters are the same, return 0\n    return 0\n\n# Input\ns = input().strip()\n# Output\nprint(longest_non_palindrome_substring(s))\n```",
    "38": "```python\ndef can_tracks_coincide(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between consecutive barriers for Kefa\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    # Calculate the distances between consecutive barriers for Sasha\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Check if kefa_diffs can be rotated to match sasha_diffs\n    double_kefa_diffs = kefa_diffs * 2  # Create a doubled list for rotation checking\n    \n    # Check if sasha_diffs is a subarray of double_kefa_diffs\n    for i in range(n):\n        if double_kefa_diffs[i:i+n] == sasha_diffs:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_distances, sasha_distances))\n```",
    "36": "```python\ndef hexagonal_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 0\n\n    # Find the layer where the nth move is located\n    while moves_in_layer <= n:\n        moves_in_layer += 6 * layer\n        layer += 1\n\n    layer -= 1\n    moves_in_layer -= 6 * layer\n\n    # Calculate the position in the layer\n    position_in_layer = n - moves_in_layer\n\n    # Calculate the coordinates based on the layer and position\n    x, y = layer, 0\n\n    if position_in_layer < layer:\n        x -= position_in_layer\n    elif position_in_layer < 2 * layer:\n        x -= layer\n        y += position_in_layer - layer\n    elif position_in_layer < 3 * layer:\n        x += position_in_layer - 2 * layer\n        y += layer\n    elif position_in_layer < 4 * layer:\n        x += layer\n        y -= position_in_layer - 3 * layer\n    elif position_in_layer < 5 * layer:\n        x += 5 * layer - position_in_layer\n        y -= layer\n    else:\n        x -= layer\n        y -= position_in_layer - 5 * layer\n\n    return (x, y)\n\nn = int(input())\nx, y = hexagonal_coordinates(n)\nprint(x, y)\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n\n    # Generate all possible binary strings of length n\n    all_strings = [''.join(p) for p in product('01', repeat=n)]\n    \n    # Function to check if s is a substring of any cyclic shift of t\n    def contains_as_substring(t, s):\n        double_t = t + t  # Concatenate t with itself to check cyclic shifts\n        return s in double_t\n\n    # Count distinct cyclic strings that contain s as a substring\n    count = 0\n    seen = set()\n    \n    for t in all_strings:\n        if contains_as_substring(t, s):\n            # Normalize the cyclic string to avoid counting shifts as different\n            min_rotation = min(t[i:] + t[:i] for i in range(n))\n            if min_rotation not in seen:\n                seen.add(min_rotation)\n                count += 1\n\n    return count\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_cyclic_strings(n, s))\n```",
    "33": "```python\ndef count_common_terms(a1, b1, a2, b2, L, R):\n    # Normalize b1 and b2 to be in the range of L to R\n    def normalize(b, a, L, R):\n        if a == 0:\n            return b if L <= b <= R else None\n        # Find the smallest k such that a * k + b >= L\n        k_start = (L - b + a - 1) // a if a > 0 else (L - b) // a\n        # Find the largest k such that a * k + b <= R\n        k_end = (R - b) // a if a > 0 else (R - b + a - 1) // a\n        return (k_start, k_end)\n\n    # Get the ranges for k' for both progressions\n    k1_range = normalize(b1, a1, L, R)\n    k2_range = normalize(b2, a2, L, R)\n\n    if k1_range is None or k2_range is None:\n        return 0\n\n    k1_start, k1_end = k1_range\n    k2_start, k2_end = k2_range\n\n    # Find the common terms\n    common_terms = set()\n    \n    # Generate terms for the first progression\n    for k in range(k1_start, k1_end + 1):\n        common_terms.add(a1 * k + b1)\n\n    # Count how many of these terms are also in the second progression\n    count = 0\n    for l in range(k2_start, k2_end + 1):\n        term = a2 * l + b2\n        if term in common_terms and L <= term <= R:\n            count += 1\n\n    return count\n\n# Input reading\na1, b1, a2, b2, L, R = map(int, input().split())\n# Output the result\nprint(count_common_terms(a1, b1, a2, b2, L, R))\n```",
    "44": "```python\ndef minimal_time_to_post_office(d, k, a, b, t):\n    # Initialize the minimum time to a large number\n    min_time = float('inf')\n    \n    # Calculate how many full segments of k kilometers can be driven\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Calculate time if using the car for full segments and walking the rest\n    time_using_car = full_segments * (k * a + t) + remaining_distance * a - t  # subtract t for the last segment\n    min_time = min(min_time, time_using_car)\n    \n    # Calculate time if walking the entire distance\n    time_walking = d * b\n    min_time = min(min_time, time_walking)\n    \n    # Check combinations of driving and walking\n    for i in range(full_segments + 1):\n        distance_driven = i * k\n        time_spent = i * (k * a + t)  # time for driving and repairing\n        \n        if distance_driven < d:\n            remaining_distance = d - distance_driven\n            time_spent += remaining_distance * b  # time for walking the remaining distance\n        \n        min_time = min(min_time, time_spent)\n    \n    return min_time\n\n# Read input\nd, k, a, b, t = map(int, input().split())\n# Calculate and print the result\nprint(minimal_time_to_post_office(d, k, a, b, t))\n```",
    "46": "```python\ndef count_divisible_pairs(n, m):\n    # Count how many numbers in the range 1 to n have each remainder when divided by 5\n    count_x = [0] * 5\n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n\n    # Count how many numbers in the range 1 to m have each remainder when divided by 5\n    count_y = [0] * 5\n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n\n    # Calculate the number of valid pairs (x, y) such that (x + y) % 5 == 0\n    result = 0\n    for i in range(5):\n        result += count_x[i] * count_y[(5 - i) % 5]\n\n    return result\n\n# Read input\nn, m = map(int, input().split())\n# Print the result\nprint(count_divisible_pairs(n, m))\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # The minimum sum of the first k positive integers is k * (k + 1) // 2\n    min_sum = k * (k + 1) // 2\n    \n    if n < min_sum:\n        return -1  # Not enough to form a strictly increasing sequence of k numbers\n    \n    # The maximum GCD we can use is n // k\n    max_gcd = n // k\n    \n    # We can form the sequence by using the first k integers multiplied by the max_gcd\n    sequence = [(i + 1) * max_gcd for i in range(k)]\n    \n    # Calculate the sum of this sequence\n    current_sum = sum(sequence)\n    \n    # Adjust the last element to ensure the sum equals n\n    sequence[-1] += n - current_sum\n    \n    return sequence\n\n# Read input\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\n# Print output\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    digit_length = 1\n    count = 9\n    start = 1\n\n    # Determine the range where the k-th digit lies\n    while k > digit_length * count:\n        k -= digit_length * count\n        digit_length += 1\n        count *= 10\n        start *= 10\n\n    # Find the actual number containing the k-th digit\n    start += (k - 1) // digit_length\n    number_str = str(start)\n    \n    # Find the specific digit\n    digit_index = (k - 1) % digit_length\n    return number_str[digit_index]\n\n# Read input\nk = int(input().strip())\n# Output the k-th digit\nprint(find_kth_digit(k))\n```",
    "51": "```python\nfrom collections import Counter\nimport sys\n\ndef find_x_y(n, divisors):\n    count = Counter(divisors)\n    # The largest number in the list must be either x or y\n    max_divisor = max(count)\n    \n    # Initialize x and y\n    x = max_divisor\n    y = 1\n    \n    # Iterate over the divisors to find y\n    for d in count:\n        if count[d] == 1:  # If d appears only once, it must be a divisor of y\n            y *= d\n        elif count[d] == 2:  # If d appears twice, it is a divisor of both x and y\n            continue\n    \n    return x, y\n\n# Read input\nn = int(input().strip())\ndivisors = list(map(int, input().strip().split()))\n\n# Get x and y\nx, y = find_x_y(n, divisors)\n\n# Print the result\nprint(x, y)\n```",
    "47": "```python\ndef max_beauty_with_multiplier(n, x, a):\n    # Function to calculate maximum subarray sum using Kadane's algorithm\n    def kadane(arr):\n        max_ending_here = max_so_far = 0\n        for value in arr:\n            max_ending_here = max(0, max_ending_here + value)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    # Calculate the original beauty of the array\n    original_beauty = kadane(a)\n\n    # Calculate the maximum beauty after multiplying a subarray by x\n    max_gain = 0\n    current_gain = 0\n\n    for i in range(n):\n        current_gain += a[i] * (x - 1)\n        if current_gain < 0:\n            current_gain = 0\n        max_gain = max(max_gain, current_gain)\n\n    # The maximum beauty is either the original beauty or the beauty after applying the multiplier\n    return max(original_beauty, original_beauty + max_gain)\n\n# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result and print it\nresult = max_beauty_with_multiplier(n, x, a)\nprint(result)\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef reachable_count(n):\n    reachable = set()\n    current = n\n    \n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    \n    return len(reachable)\n\nn = int(input())\nprint(reachable_count(n))\n```",
    "57": "```python\nn = int(input())\nf = list(map(int, input().split()))\n\n# Find the friends who have not chosen anyone (f_i = 0)\nunknown_indices = [i for i in range(n) if f[i] == 0]\nchosen_friends = set(f) - {0}\n\n# Find the friends who are not chosen by anyone\nall_friends = set(range(1, n + 1))\nnot_chosen_friends = list(all_friends - chosen_friends)\n\n# Assign the not chosen friends to the unknown indices\nfor i in range(len(unknown_indices)):\n    f[unknown_indices[i]] = not_chosen_friends[i]\n\n# Print the result\nprint(' '.join(map(str, f)))\n```",
    "54": "```python\ndef find_minimum_D(n, a):\n    min_a = min(a)\n    max_a = max(a)\n    \n    if min_a == max_a:\n        return 0  # All elements are already equal\n    \n    # The difference between max and min\n    diff = max_a - min_a\n    \n    # If the difference is odd, we cannot make all elements equal\n    if diff % 2 != 0:\n        return -1\n    \n    # The minimum D is half the difference\n    return diff // 2\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(find_minimum_D(n, a))\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = -1\n    moves = []\n    \n    while left <= right:\n        if a[left] < last_taken and a[right] < last_taken:\n            break\n        \n        if a[left] > last_taken and (a[right] <= last_taken or a[left] < a[right]):\n            moves.append('L')\n            last_taken = a[left]\n            left += 1\n        elif a[right] > last_taken:\n            moves.append('R')\n            last_taken = a[right]\n            right -= 1\n        else:\n            break\n    \n    print(len(moves))\n    print(''.join(moves))\n\n# Example usage\nn = int(input())\na = list(map(int, input().split()))\nlongest_increasing_sequence(n, a)\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_elements_per_row = m // 2\n    dp = [[-1] * k for _ in range(n + 1)]\n    dp[0][0] = 0  # Base case: sum of 0 is achievable with 0 elements\n\n    for i in range(1, n + 1):\n        row = sorted(matrix[i - 1], reverse=True)[:max_elements_per_row]\n        current_dp = dp[i - 1][:]  # Copy previous row dp\n\n        for j in range(1 << len(row)):\n            current_sum = 0\n            count = 0\n            for bit in range(len(row)):\n                if j & (1 << bit):\n                    current_sum += row[bit]\n                    count += 1\n            if count <= max_elements_per_row:\n                mod = current_sum % k\n                if current_dp[mod] < current_sum:\n                    current_dp[mod] = current_sum\n\n        for mod in range(k):\n            if dp[i - 1][mod] != -1:\n                new_sum = dp[i - 1][mod]\n                new_mod = (new_sum + current_dp[mod]) % k\n                if dp[i][new_mod] < new_sum + current_dp[mod]:\n                    dp[i][new_mod] = new_sum + current_dp[mod]\n\n        dp[i] = current_dp\n\n    return max(dp[n])\n\n# Read input\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = max_sum_divisible_by_k(n, m, k, matrix)\nprint(result)\n```",
    "59": "```python\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# We need to check the last x digits of the number\ntarget_remainder = '0' * (x - y - 1) + '1' + '0' * y  # This is the desired pattern\ncurrent_remainder = number[-x:]  # The last x digits of the number\n\n# Count the number of changes needed\noperations = sum(1 for i in range(x) if current_remainder[i] != target_remainder[i])\n\nprint(operations)\n```",
    "61": "```python\ndef max_number_after_replacement(n, a, f):\n    a_list = list(a)\n    modified = False\n    \n    for i in range(n):\n        original_digit = int(a_list[i])\n        new_digit = f[original_digit - 1]\n        \n        if new_digit > original_digit and not modified:\n            # Start replacing\n            modified = True\n            a_list[i] = str(new_digit)\n        elif new_digit < original_digit and modified:\n            # Stop replacing if we encounter a digit that would decrease the number\n            break\n        elif modified:\n            # Continue replacing if we are in the modified state\n            a_list[i] = str(new_digit)\n    \n    return ''.join(a_list)\n\n# Input reading\nn = int(input())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\n# Get the result and print it\nresult = max_number_after_replacement(n, a, f)\nprint(result)\n```",
    "60": "```python\ndef has_palindrome_subsequence(test_cases):\n    results = []\n    for n, a in test_cases:\n        found = False\n        # Use a dictionary to track the first occurrence of each number\n        first_occurrence = {}\n        for i in range(n):\n            if a[i] in first_occurrence:\n                # If we find the same number again, we can form a palindrome\n                if i - first_occurrence[a[i]] >= 2:\n                    found = True\n                    break\n            else:\n                first_occurrence[a[i]] = i\n        results.append(\"YES\" if found else \"NO\")\n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Get results\nresults = has_palindrome_subsequence(test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "55": "```python\ndef can_see_white_sheet(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n    # Check if there is any part of the white sheet that is not covered by both black sheets\n    # The white sheet can be seen if there is at least one point that is:\n    # 1. Not strictly inside the white sheet (i.e., outside or on the boundary)\n    # 2. Strictly outside both black sheets\n\n    # Check the left side of the white sheet\n    if x1 > x4 and x1 > x6:  # left of white is to the right of both black sheets\n        return \"YES\"\n    \n    # Check the right side of the white sheet\n    if x2 < x3 and x2 < x5:  # right of white is to the left of both black sheets\n        return \"YES\"\n    \n    # Check the bottom side of the white sheet\n    if y1 > y4 and y1 > y6:  # bottom of white is above both black sheets\n        return \"YES\"\n    \n    # Check the top side of the white sheet\n    if y2 < y3 and y2 < y5:  # top of white is below both black sheets\n        return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Output the result\nprint(can_see_white_sheet(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6))\n```",
    "67": "```python\ndef find_nice_indices(n, a):\n    total_sum = sum(a)\n    nice_indices = []\n\n    for i in range(n):\n        remaining_sum = total_sum - a[i]\n        if remaining_sum == a[i] * 2:\n            nice_indices.append(i + 1)  # Store 1-based index\n\n    return nice_indices\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Finding nice indices\nnice_indices = find_nice_indices(n, a)\n\n# Output results\nprint(len(nice_indices))\nif nice_indices:\n    print(' '.join(map(str, nice_indices)))\n```",
    "63": "```python\ndef min_instability(n, a):\n    # Sort the array to easily find the min and max after removing an element\n    a.sort()\n    \n    # The minimum instability after removing one element can be calculated\n    # by considering removing the smallest or the largest element\n    # The two cases are:\n    # 1. Remove the smallest element (a[0])\n    # 2. Remove the largest element (a[n-1])\n    \n    instability_case1 = a[-1] - a[1]  # Remove the smallest element\n    instability_case2 = a[-2] - a[0]  # Remove the largest element\n    \n    # The minimum instability is the minimum of the two cases\n    return min(instability_case1, instability_case2)\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_instability(n, a))\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        min_ops = float('inf')\n        best_triple = (0, 0, 0)\n\n        for A in range(1, a + 1):\n            for B in range(A, c + 1):\n                if B % A == 0:\n                    for C in range(B, c + 1):\n                        if C % B == 0:\n                            ops = (A - a) + (B - b) + (C - c)\n                            if ops < 0:\n                                continue\n                            if ops < min_ops:\n                                min_ops = ops\n                                best_triple = (A, B, C)\n\n        results.append((min_ops, best_triple))\n\n    return results\n\n# Read input\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations(t, test_cases)\n\n# Print output\nfor ops, (A, B, C) in results:\n    print(ops)\n    print(A, B, C)\n```",
    "70": "```python\n# Read input\nh1, m1 = map(int, input().strip().split(':'))\nh2, m2 = map(int, input().strip().split(':'))\n\n# Convert start and end times to total minutes\nstart_minutes = h1 * 60 + m1\nend_minutes = h2 * 60 + m2\n\n# Calculate the midpoint in total minutes\nmidpoint_minutes = (start_minutes + end_minutes) // 2\n\n# Convert midpoint back to hours and minutes\nh3 = midpoint_minutes // 60\nm3 = midpoint_minutes % 60\n\n# Print the result in the required format\nprint(f\"{h3:02}:{m3:02}\")\n```",
    "71": "```python\nimport math\n\na = int(input())\noutput = math.floor(math.log2(a))\nprint(output)\n```",
    "73": "```python\ndef can_complete_wall(n, heights):\n    max_height = max(heights)\n    for height in heights:\n        if height < max_height and (height % 2) != (max_height % 2):\n            return \"NO\"\n    return \"YES\"\n\n# Input reading\nn = int(input())\nheights = list(map(int, input().split()))\n\n# Output the result\nprint(can_complete_wall(n, heights))\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    days = [0] * n  # Initialize days with 0 (rest days)\n    exam_days = set()  # To keep track of exam days\n    prepare_needed = [0] * m  # To track preparation days needed for each exam\n\n    # Fill exam days and preparation needs\n    for i in range(m):\n        s, d, c = exams[i]\n        exam_days.add(d - 1)  # Store exam day (0-indexed)\n        prepare_needed[i] = c\n\n    # Prepare for exams\n    for i in range(m):\n        s, d, c = exams[i]\n        s -= 1  # Convert to 0-indexed\n        for j in range(s, d - 1):\n            if prepare_needed[i] > 0 and days[j] == 0:\n                days[j] = i + 1  # Mark preparation for exam i\n                prepare_needed[i] -= 1\n\n    # Check if all preparations are done\n    for i in range(m):\n        if prepare_needed[i] > 0:\n            return -1  # Not enough days to prepare for exam i\n\n    # Fill in exam days\n    for i in range(m):\n        d = exams[i][1] - 1  # Convert to 0-indexed\n        days[d] = m + 1  # Mark exam day\n\n    return days\n\n# Input reading\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the schedule\nresult = schedule_exams(n, m, exams)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import Counter\n    \n    # Count the frequency of each character in the string\n    freq = Counter(s)\n    \n    # Calculate the total number of unique subsequences\n    total_unique_subsequences = 0\n    costs = []\n    \n    # For each unique character, calculate the number of subsequences it can generate\n    for char, count in freq.items():\n        # Number of subsequences that can be formed with this character\n        # is 2^count - 1 (excluding the empty subsequence)\n        num_subsequences = (1 << count) - 1  # 2^count - 1\n        total_unique_subsequences += num_subsequences\n        \n        # Each subsequence of length `l` has a cost of `n - l`\n        for length in range(1, count + 1):\n            costs.append(n - length)\n    \n    # If we cannot form at least k unique subsequences, return -1\n    if total_unique_subsequences < k:\n        return -1\n    \n    # Sort costs to minimize the total cost\n    costs.sort()\n    \n    # Calculate the minimum cost to obtain exactly k unique subsequences\n    min_cost = sum(costs[:k])\n    \n    return min_cost\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result and print it\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "58": "```python\ndef color_array(n, k, a):\n    from collections import defaultdict\n    \n    # Step 1: Count occurrences of each number\n    count = defaultdict(int)\n    for num in a:\n        count[num] += 1\n    \n    # Step 2: Check if any number occurs more than k times\n    for num in count:\n        if count[num] > k:\n            print(\"NO\")\n            return\n    \n    # Step 3: Prepare to assign colors\n    color_assignment = [0] * n\n    color_used = defaultdict(int)  # To track how many times each color is used for each number\n    \n    # Step 4: Assign colors\n    for i in range(n):\n        num = a[i]\n        # Find the next color to assign to this number\n        next_color = (color_used[num] % k) + 1\n        color_assignment[i] = next_color\n        color_used[num] += 1\n    \n    # Step 5: Check if we have used all colors\n    used_colors = set(color_assignment)\n    if len(used_colors) < k:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, color_assignment)))\n\n# Example usage\nn, k = map(int, input().split())\na = list(map(int, input().split()))\ncolor_array(n, k, a)\n```",
    "77": "```python\ndef minimum_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nn = int(input())\nprint(minimum_difference(n))\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph):\n    visited = [-1] * (n + 1)\n    queue = deque([start])\n    visited[start] = 0\n    farthest_node = start\n\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if visited[neighbor] == -1:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > visited[farthest_node]:\n                    farthest_node = neighbor\n\n    return farthest_node, visited\n\ndef find_max_edges(n, edges):\n    graph = defaultdict(list)\n    \n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # Step 1: Find the farthest node from an arbitrary node (1)\n    farthest_from_start, _ = bfs(1, graph)\n\n    # Step 2: Find the farthest node from the farthest node found\n    farthest_from_a, distances_from_a = bfs(farthest_from_start, graph)\n\n    # Step 3: Find the farthest node from the second farthest node\n    farthest_from_b, distances_from_b = bfs(farthest_from_a, graph)\n\n    # The diameter of the tree is the distance between farthest_from_a and farthest_from_b\n    diameter_length = distances_from_a[farthest_from_b]\n\n    # Step 4: Find the nodes on the diameter path\n    path = []\n    current = farthest_from_b\n    while current != farthest_from_start:\n        path.append(current)\n        for neighbor in graph[current]:\n            if distances_from_a[neighbor] == distances_from_a[current] - 1:\n                current = neighbor\n                break\n    path.append(farthest_from_start)\n    path.reverse()\n\n    # Step 5: Choose three distinct vertices from the diameter path\n    if len(path) >= 3:\n        a, b, c = path[0], path[1], path[2]\n    else:\n        a, b, c = path[0], path[1], path[1]  # fallback, should not happen in valid input\n\n    # The maximum number of edges in the union of the paths\n    max_edges = diameter_length + 1\n\n    return max_edges, a, b, c\n\n# Input reading\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\n# Solve the problem\nmax_edges, a, b, c = find_max_edges(n, edges)\n\n# Output the result\nprint(max_edges)\nprint(a, b, c)\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Find the longest prefix which is also a suffix\n    lps = [0] * n\n    j = 0  # length of previous longest prefix suffix\n    i = 1\n\n    # Preprocess the pattern to create the lps array\n    while i < n:\n        if t[i] == t[j]:\n            j += 1\n            lps[i] = j\n            i += 1\n        else:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                lps[i] = 0\n                i += 1\n\n    # The length of the longest prefix which is also a suffix\n    overlap_length = lps[-1]\n\n    # Construct the result string\n    result = t\n    for _ in range(k - 1):\n        result += t[overlap_length:]  # Append the non-overlapping part\n\n    return result\n\n# Input reading\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the result and print it\nresult = construct_string(n, k, t)\nprint(result)\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n\n    if D >= n:\n        print(\"NO\")\n        return\n\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n\n    degree = {i: 0 for i in range(1, n + 1)}\n    spanning_tree_edges = []\n    visited = set()\n    \n    # Start BFS/DFS from vertex 1\n    queue = deque([1])\n    visited.add(1)\n\n    while queue:\n        node = queue.popleft()\n        if degree[node] < D and node == 1:\n            # Try to connect to more nodes if we are at node 1\n            for neighbor in graph[node]:\n                if neighbor not in visited and degree[node] < D:\n                    spanning_tree_edges.append((node, neighbor))\n                    degree[node] += 1\n                    degree[neighbor] += 1\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        else:\n            # Connect to unvisited neighbors\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    spanning_tree_edges.append((node, neighbor))\n                    degree[node] += 1\n                    degree[neighbor] += 1\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n\n    # Check if we have a valid spanning tree\n    if degree[1] != D or len(spanning_tree_edges) != n - 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for v, u in spanning_tree_edges:\n            print(v, u)\n\n# Read input\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\nfind_spanning_tree(n, m, D, edges)\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    lefts = [l for l, r in segments]\n    rights = [r for l, r in segments]\n    \n    # Precompute the maximum left and minimum right excluding each segment\n    max_left = [0] * n\n    min_right = [0] * n\n    \n    max_left[0] = lefts[0]\n    for i in range(1, n):\n        max_left[i] = max(max_left[i - 1], lefts[i])\n    \n    min_right[n - 1] = rights[n - 1]\n    for i in range(n - 2, -1, -1):\n        min_right[i] = min(min_right[i + 1], rights[i])\n    \n    max_length = 0\n    \n    for i in range(n):\n        if i == 0:\n            left = max_left[1]\n            right = min_right[1]\n        elif i == n - 1:\n            left = max_left[n - 2]\n            right = min_right[n - 2]\n        else:\n            left = max(max_left[i - 1], lefts[i + 1])\n            right = min(min_right[i + 1], rights[i - 1])\n        \n        length = max(0, right - left)\n        max_length = max(max_length, length)\n    \n    return max_length\n\n# Input reading\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_intersection_length(n, segments))\n```",
    "82": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncount = 0\n\n# Check from the left\nwhile count < n and a[count] <= k:\n    count += 1\n\n# Check from the right\nwhile count < n and a[n - 1 - (count - 1)] <= k:\n    count += 1\n\n# If we counted the same problem from both ends, subtract 1\nif count > n:\n    count = n\n\nprint(count)\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Define the food consumption pattern for each day of the week\n    week_pattern = [0, 0, 1, 0, 0, 1, 0]  # 0: fish, 1: rabbit, 2: chicken\n    food_needed = [0, 0, 0]  # fish, rabbit, chicken\n    \n    # Calculate the total number of complete weeks we can sustain\n    complete_weeks = min(a // 3, b // 2, c // 2)\n    \n    # Update the food supplies after consuming complete weeks\n    a -= complete_weeks * 3\n    b -= complete_weeks * 2\n    c -= complete_weeks * 2\n    \n    # Total days from complete weeks\n    total_days = complete_weeks * 7\n    \n    # Check for each starting day of the week\n    for start_day in range(7):\n        days = 0\n        current_a, current_b, current_c = a, b, c\n        \n        # Simulate the days of the week starting from start_day\n        for i in range(7):\n            day = (start_day + i) % 7\n            if day in [0, 3, 6]:  # Fish food days\n                if current_a > 0:\n                    current_a -= 1\n                    days += 1\n                else:\n                    break\n            elif day in [1, 5]:  # Rabbit stew days\n                if current_b > 0:\n                    current_b -= 1\n                    days += 1\n                else:\n                    break\n            else:  # Chicken stake days\n                if current_c > 0:\n                    current_c -= 1\n                    days += 1\n                else:\n                    break\n        \n        total_days = max(total_days, complete_weeks * 7 + days)\n    \n    return total_days\n\n# Input reading\na, b, c = map(int, input().split())\nprint(max_days(a, b, c))\n```",
    "76": "```python\ndef can_construct_symmetric_square(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        top_left_bottom_right = set()\n        top_right_bottom_left = set()\n        \n        for tile in tiles:\n            top_left, top_right = tile[0]\n            bottom_left, bottom_right = tile[1]\n            top_left_bottom_right.add((top_left, bottom_right))\n            top_right_bottom_left.add((top_right, bottom_left))\n        \n        if any((x in top_right_bottom_left) for x in top_left_bottom_right):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        top = tuple(map(int, input().split()))\n        bottom = tuple(map(int, input().split()))\n        tiles.append((top, bottom))\n    test_cases.append((n, m, tiles))\n\n# Get results\nresults = can_construct_symmetric_square(t, test_cases)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    # Step 1: Create a set to store unique subsequences\n    unique_subsequences = set()\n    \n    # Step 2: Generate all possible subsequences\n    for i in range(1 << n):  # There are 2^n possible subsequences\n        subsequence = []\n        for j in range(n):\n            if i & (1 << j):  # Check if j-th bit is set\n                subsequence.append(s[j])\n        unique_subsequences.add(''.join(subsequence))\n    \n    # Step 3: Check if we can obtain k unique subsequences\n    if len(unique_subsequences) < k:\n        return -1\n    \n    # Step 4: Calculate the minimum cost\n    sorted_subsequences = sorted(unique_subsequences, key=len)  # Sort by length\n    total_cost = 0\n    for i in range(k):\n        total_cost += n - len(sorted_subsequences[i])  # Cost is n - |t|\n    \n    return total_cost\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    \n    # We need to find pairs of digits '00', '25', '50', '75'\n    targets = ['00', '25', '50', '75']\n    min_moves = float('inf')\n    \n    for target in targets:\n        # Find the last digit of the target\n        last_digit = target[1]\n        first_digit = target[0]\n        \n        # Find the position of the last digit in the number\n        last_pos = -1\n        for i in range(length - 1, -1, -1):\n            if s[i] == last_digit:\n                last_pos = i\n                break\n        \n        if last_pos == -1:\n            continue\n        \n        # Now find the first digit before the last digit\n        first_pos = -1\n        for i in range(last_pos - 1, -1, -1):\n            if s[i] == first_digit:\n                first_pos = i\n                break\n        \n        if first_pos == -1:\n            continue\n        \n        # Calculate moves to bring first_pos to the left of last_pos\n        moves = (length - 1 - last_pos) + (last_pos - first_pos - 1)\n        min_moves = min(min_moves, moves)\n    \n    return min_moves if min_moves != float('inf') else -1\n\n# Read input\nn = int(input().strip())\n# Get the result\nresult = min_moves_to_divisible_by_25(n)\n# Print the result\nprint(result)\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects based on the required rating a_i\n    projects.sort(key=lambda x: x[0])\n    \n    count = 0\n    current_rating = r\n    \n    for a_i, b_i in projects:\n        if current_rating >= a_i:  # Check if Polycarp can start the project\n            count += 1  # Increment the count of projects\n            current_rating += b_i  # Update the current rating after completing the project\n            if current_rating < 0:  # Ensure rating does not fall below zero\n                break\n    \n    return count\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_projects(n, r, projects))\n```",
    "84": "```python\ndef can_color_string(n, s):\n    # Create a list to store the color of each character\n    color = [''] * n\n    \n    # Create a dictionary to count occurrences of each character\n    count = {}\n    for char in s:\n        count[char] = count.get(char, 0) + 1\n    \n    # Create a sorted version of the string\n    sorted_s = sorted(s)\n    \n    # Check if we can color the string\n    for i in range(n):\n        if s[i] != sorted_s[i]:\n            # If the current character is not in the same position as in sorted string\n            # we need to color it differently\n            if color[i] == '':\n                # Assign color '0' to the first occurrence\n                color[i] = '0'\n            else:\n                # If already colored, we need to assign the opposite color\n                color[i] = '1' if color[i] == '0' else '0'\n        else:\n            # If the character is in the same position, we can color it the same\n            color[i] = '0'\n    \n    # Check for conflicts in coloring\n    for i in range(1, n):\n        if s[i] < s[i - 1] and color[i] == color[i - 1]:\n            return \"NO\"\n    \n    return \"YES\", ''.join(color)\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult = can_color_string(n, s)\n\n# Print the result\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    print(result[1])\n```",
    "78": "```python\nMOD = 10**9 + 7\n\ndef count_regular_sequences(n, s):\n    m = len(s)\n    \n    # Precompute the number of valid sequences of length 2k\n    dp = [0] * (n + 1)\n    dp[0] = 1  # Base case: one way to form an empty sequence\n    \n    for k in range(1, n + 1):\n        for j in range(k):\n            dp[k] = (dp[k] + dp[j] * dp[k - 1 - j]) % MOD\n    \n    # Check if the given string s can be part of a valid sequence\n    balance = 0\n    min_balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n    \n    if balance < 0 or balance > 2 * n or min_balance < 0:\n        return 0\n    \n    # Count the number of valid sequences containing s\n    total_count = 0\n    \n    for prefix_length in range(max(0, -min_balance), n - (balance // 2) + 1):\n        suffix_length = n - prefix_length - (m - balance)\n        if suffix_length < 0:\n            continue\n        total_count = (total_count + dp[prefix_length] * dp[suffix_length]) % MOD\n    \n    return total_count\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_regular_sequences(n, s))\n```",
    "86": "```python\ndef solve_problems(n, k):\n    # Minimum sum of problems needed to satisfy the conditions\n    min_sum = k * (k + 1) // 2  # 1 + 2 + ... + k\n    if n < min_sum:\n        print(\"NO\")\n        return\n\n    # Start with the minimum valid sequence\n    a = list(range(1, k + 1))\n    current_sum = min_sum\n\n    # Distribute the remaining problems\n    remaining = n - current_sum\n    for i in range(k - 1, -1, -1):\n        # Maximum we can add to a[i] while respecting the constraints\n        max_add = min(remaining, a[i] - 1 + a[i] // 2)\n        a[i] += max_add\n        remaining -= max_add\n        if remaining <= 0:\n            break\n\n    if remaining > 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n\n# Example usage\nsolve_problems(26, 6)\nsolve_problems(8, 3)\nsolve_problems(1, 1)\nsolve_problems(9, 4)\nsolve_problems(7, 2)\n```",
    "81": "```python\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\n# Sort strings by length\nstrings.sort(key=len)\n\n# Check if the ordering is valid\nfor i in range(1, n):\n    if strings[i-1] not in strings[i]:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")\n    for s in strings:\n        print(s)\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects based on the required rating (a_i)\n    projects.sort(key=lambda x: x[0])\n    \n    for a, b in projects:\n        if r < a:  # If current rating is less than required for the project\n            return \"NO\"\n        r += b  # Update rating after completing the project\n        if r < 0:  # If rating goes below zero\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_complete_projects(n, r, projects))\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n\n    # Iterate through possible widths of the rectangle\n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            # Check both (width, height) and (height, width)\n            for w, h in [(width, height), (height, width)]:\n                # Check if we can fit a red rectangle and a blue rectangle\n                if (a % w == 0 and a // w <= h) or (b % w == 0 and b // w <= h):\n                    perimeter = 2 * (w + h)\n                    min_perimeter = min(min_perimeter, perimeter)\n\n    return min_perimeter\n\n# Input reading\na, b = map(int, input().split())\nprint(minimal_perimeter(a, b))\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    # Step 1: Create a list to store the color assignments\n    colors = [0] * n\n    \n    # Step 2: Create a dictionary to track the last seen index of each character\n    last_seen = {}\n    \n    # Step 3: Initialize the color counter\n    color_count = 0\n    \n    # Step 4: Iterate through the string\n    for i in range(n):\n        char = s[i]\n        \n        # If the character has been seen before, use the same color\n        if char in last_seen:\n            colors[i] = colors[last_seen[char]]\n        else:\n            # If it's a new character, increment the color count and assign a new color\n            color_count += 1\n            colors[i] = color_count\n        \n        # Update the last seen index for the character\n        last_seen[char] = i\n    \n    # Step 5: Output the result\n    print(color_count)\n    print(' '.join(map(str, colors)))\n\n# Example usage\nn = int(input())\ns = input().strip()\nmin_colors_to_sort(n, s)\n```",
    "90": "```python\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculate the total length of platforms\ntotal_length = sum(c)\n\n# Check if we can place the platforms with the given jump distance\nif total_length + (m - 1) * d < n:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    a = [0] * n\n    current_position = 0\n    \n    for i in range(m):\n        # Place the platform at the current position\n        for j in range(c[i]):\n            a[current_position + j] = i + 1\n        current_position += c[i]\n        \n        # Move to the next position considering the jump distance\n        if i < m - 1:\n            current_position += d\n    \n    print(\" \".join(map(str, a)))\n```",
    "97": "```python\nn = int(input())\nchips = list(map(int, input().split()))\n\neven_count = sum(1 for x in chips if x % 2 == 0)\nodd_count = n - even_count\n\n# The minimum cost is the number of chips that are not on the target parity\nmin_cost = min(even_count, odd_count)\n\nprint(min_cost)\n```",
    "99": "```python\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\n# Maximum wins for Alice\nmax_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n\n# Minimum wins for Alice\n# Calculate losses for Alice\nalice_losses = max(0, b1 - a3) + max(0, b2 - a1) + max(0, b3 - a2)\nmin_wins = n - alice_losses\n\nprint(min_wins, max_wins)\n```",
    "92": "```python\nx = float(input().strip())\n\n# We need to find two integers a and b such that 1 <= a, b <= 10\n# and a * b is approximately equal to x\n\n# We will iterate through possible values of a and b\nfor a in range(1, 11):\n    for b in range(1, 11):\n        if abs(a * b - x) < 1e-6:  # Check if the product is close to x\n            print(a, b)\n            break\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    # Initialize the permutation array\n    p = [0] * n\n    \n    # Start with an arbitrary value for p[0]\n    p[0] = 1  # We can start with any value, but 1 is a good choice\n    \n    # Calculate the rest of the permutation using the differences in q\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n    \n    # Find the minimum value in p to adjust the permutation to start from 1\n    min_p = min(p)\n    \n    # Adjust the permutation to ensure it starts from 1\n    adjustment = 1 - min_p\n    for i in range(n):\n        p[i] += adjustment\n    \n    # Check if the adjusted permutation is valid\n    if len(set(p)) == n and all(1 <= x <= n for x in p):\n        print(' '.join(map(str, p)))\n    else:\n        print(-1)\n\n# Example usage\nn = int(input())\nq = list(map(int, input().split()))\nrestore_permutation(n, q)\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Start with an empty string\n    s = []\n    \n    # Determine the starting character based on the larger count\n    if a > b:\n        s.append('0')\n        a -= 1\n    else:\n        s.append('1')\n        b -= 1\n    \n    # We need to create x transitions\n    for i in range(x):\n        if s[-1] == '0':\n            s.append('1')\n            b -= 1\n        else:\n            s.append('0')\n            a -= 1\n    \n    # Now we have used x transitions, we need to fill the rest\n    # Fill with the remaining characters\n    while a > 0:\n        s.append('0')\n        a -= 1\n    while b > 0:\n        s.append('1')\n        b -= 1\n    \n    return ''.join(s)\n\n# Read input\na, b, x = map(int, input().split())\n# Generate and print the binary string\nprint(construct_binary_string(a, b, x))\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Create a list of characters to use in the result\n    chars = ['a'] * n + ['b'] * n + ['c'] * n\n    \n    # Function to check if the last two characters of the result form a forbidden substring\n    def is_forbidden(res):\n        return res[-2:] == s or res[-2:] == t\n    \n    # Initialize the result string\n    res = []\n    \n    # Try to build the result string\n    for char in chars:\n        res.append(char)\n        # If the last two characters form a forbidden substring, we need to adjust\n        while len(res) >= 2 and is_forbidden(res):\n            # Remove the last character and try to replace it with a different character\n            last_char = res.pop()\n            # Find a different character to replace it\n            for replacement in ['a', 'b', 'c']:\n                if replacement != last_char and (len(res) < 1 or res[-1] != replacement):\n                    res.append(replacement)\n                    break\n            else:\n                # If we can't find a valid replacement, return \"NO\"\n                return \"NO\", \"\"\n    \n    return \"YES\", ''.join(res)\n\n# Read input\nn = int(input())\ns = input().strip()\nt = input().strip()\n\n# Generate the string\nresult = generate_string(n, s, t)\n\n# Print the result\nprint(result[0])\nif result[0] == \"YES\":\n    print(result[1])\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n    \n    # Create arrays to store the position of characters in s that match t\n    left = [0] * m\n    right = [0] * m\n    \n    # Fill the left array\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n    \n    # Fill the right array\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n    \n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n    \n    # Consider removing from the start or end\n    max_length = max(max_length, right[0])  # Remove from the start\n    max_length = max(max_length, n - 1 - left[m - 1])  # Remove from the end\n    \n    return max_length\n\n# Input reading\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(max_removable_length(s, t))\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1 or (d == 1 and n > 1) or (n > k + 1 and d == 1):\n        print(\"NO\")\n        return\n\n    edges = []\n    \n    # Create the main path for the diameter\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n    \n    # Now we have d edges, and we need to connect the remaining vertices\n    current_vertex = d + 2\n    for i in range(1, d + 1):\n        if current_vertex > n:\n            break\n        # Connect remaining vertices to the path\n        while len([e for e in edges if e[0] == i or e[1] == i]) < k and current_vertex <= n:\n            edges.append((i, current_vertex))\n            current_vertex += 1\n\n    # If we still have vertices left, we can connect them to any of the previous vertices\n    while current_vertex <= n:\n        edges.append((1, current_vertex))\n        current_vertex += 1\n\n    print(\"YES\")\n    for u, v in edges:\n        print(u, v)\n\n# Read input\nn, d, k = map(int, input().split())\nconstruct_tree(n, d, k)\n```",
    "88": "```python\ndef can_form_palindromic_matrix(n, numbers):\n    from collections import Counter\n    \n    count = Counter(numbers)\n    \n    # Check for the number of odd counts\n    odd_count = sum(1 for v in count.values() if v % 2 != 0)\n    \n    # For an n x n matrix, we can have at most one odd count if n is odd\n    # and no odd counts if n is even\n    if (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n        return \"NO\", []\n    \n    # Create the matrix\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Fill the matrix\n    half_n = (n + 1) // 2\n    idx = 0\n    for num, freq in count.items():\n        for _ in range(freq // 2):\n            matrix[idx // n][idx % n] = num\n            matrix[n - 1 - (idx // n)][n - 1 - (idx % n)] = num\n            idx += 1\n    \n    # Fill the center for odd n\n    if n % 2 == 1:\n        center = n // 2\n        for num, freq in count.items():\n            if freq % 2 == 1:\n                matrix[center][center] = num\n                break\n    \n    # Fill remaining cells for even n\n    for i in range(half_n):\n        for j in range(half_n):\n            if matrix[i][j] == 0:\n                for num, freq in count.items():\n                    if freq > 0:\n                        matrix[i][j] = num\n                        matrix[i][n - 1 - j] = num\n                        matrix[n - 1 - i][j] = num\n                        matrix[n - 1 - i][n - 1 - j] = num\n                        count[num] -= 4\n                        break\n    \n    return \"YES\", matrix\n\nn = int(input())\nnumbers = list(map(int, input().split()))\n\nresult, matrix = can_form_palindromic_matrix(n, numbers)\n\nif result == \"NO\":\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for row in matrix:\n        print(\" \".join(map(str, row)))\n```"
}