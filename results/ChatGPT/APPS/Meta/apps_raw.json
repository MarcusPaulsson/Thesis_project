{
    "7": "```python\ndef find_empty_day(n, m):\n    day = 0\n    total_eaten = 0\n    \n    while n > 0:\n        day += 1\n        n = min(n + m, n)  # Add grains to the barn, but it can't exceed its capacity\n        total_eaten += day  # Total grains eaten by sparrows up to this day\n        n -= total_eaten  # Update the number of grains in the barn after sparrows eat\n        \n    return day\n\n# Read input\nn, m = map(int, input().split())\nprint(find_empty_day(n, m))\n```",
    "1": "```python\ndef max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n    \n    # Start with the maximum number being x itself\n    max_num = x\n    max_sum = sum(int(d) for d in str_x)\n    \n    # Check numbers by reducing digits\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit and setting the rest to 9\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        new_number = int(new_number)\n        \n        if new_number > 0 and new_number <= x:\n            current_sum = sum(int(d) for d in str(new_number))\n            if current_sum > max_sum or (current_sum == max_sum and new_number > max_num):\n                max_num = new_number\n                max_sum = current_sum\n    \n    return max_num\n\nx = int(input())\nprint(max_digit_sum(x))\n```",
    "0": "```python\ndef max_length_accordion(s):\n    # Initialize variables to track the positions of the required characters\n    left_bracket = -1\n    first_colon = -1\n    last_colon = -1\n    right_bracket = -1\n    \n    # Iterate through the string to find the required characters\n    for i, char in enumerate(s):\n        if char == '[' and left_bracket == -1:\n            left_bracket = i\n        elif char == ':' and left_bracket != -1 and first_colon == -1:\n            first_colon = i\n        elif char == ':' and first_colon != -1:\n            last_colon = i\n        elif char == ']' and last_colon != -1 and right_bracket == -1:\n            right_bracket = i\n            \n    # Check if we have found all necessary components for an accordion\n    if left_bracket == -1 or first_colon == -1 or last_colon == -1 or right_bracket == -1:\n        return -1\n    \n    # Calculate the maximum length of the accordion\n    # The length is determined by the positions of the brackets and colons\n    max_length = right_bracket - left_bracket + 1\n    return max_length\n\n# Example usage\ns = input().strip()\nprint(max_length_accordion(s))\n```",
    "5": "```python\ndef minimum_seconds(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0  # No tabs to close\n\n    seconds = 0\n\n    # Close tabs to the left of l\n    if l > 1:\n        if pos > l:\n            seconds += pos - l  # Move to l\n        else:\n            seconds += l - pos  # Move to l\n        seconds += 1  # Close tabs to the left\n\n    # Close tabs to the right of r\n    if r < n:\n        if pos < r:\n            seconds += r - pos  # Move to r\n        else:\n            seconds += pos - r  # Move to r\n        seconds += 1  # Close tabs to the right\n\n    return seconds\n\n# Read input\nn, pos, l, r = map(int, input().split())\nprint(minimum_seconds(n, pos, l, r))\n```",
    "10": "```python\nn = int(input())\n\n# Calculate the maximum days off\nmax_days_off = (n // 7) * 2 + min(2, n % 7)\n\n# Calculate the minimum days off\nif n < 5:\n    min_days_off = 0\nelse:\n    min_days_off = (n // 7) * 2\n\nprint(min_days_off, max_days_off)\n```",
    "2": "```python\ndef next_lucky_year(n):\n    # Function to check if a year is lucky\n    def is_lucky(year):\n        return str(year).count('0') + len(set(str(year))) <= 2\n\n    # Increment the year until we find the next lucky year\n    while True:\n        n += 1\n        if is_lucky(n):\n            return n - (n - 1)\n\n# Read input\ncurrent_year = int(input())\n# Output the result\nprint(next_lucky_year(current_year))\n```",
    "4": "```python\ndef is_lucky(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef time_before(hh, mm, x):\n    mm -= x\n    if mm < 0:\n        mm += 60\n        hh -= 1\n        if hh < 0:\n            hh += 24\n    return hh, mm\n\ndef minimum_snooze_presses(x, hh, mm):\n    presses = 0\n    while not is_lucky(hh, mm):\n        hh, mm = time_before(hh, mm, x)\n        presses += 1\n    return presses\n\nx = int(input())\nhh, mm = map(int, input().split())\nprint(minimum_snooze_presses(x, hh, mm))\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    \n    for query in queries:\n        n, x, blows = query\n        min_blows = float('inf')\n        \n        for d, h in blows:\n            if d >= x:\n                min_blows = min(min_blows, 1)\n            else:\n                # Calculate the effective damage after growth\n                effective_damage = d - h\n                if effective_damage > 0:\n                    # Calculate the number of blows needed\n                    blows_needed = (x - d + effective_damage - 1) // effective_damage + 1\n                    min_blows = min(min_blows, blows_needed)\n        \n        results.append(min_blows if min_blows != float('inf') else -1)\n    \n    return results\n\n# Example usage:\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\nresults = min_blows_to_defeat_zmei(t, queries)\nfor result in results:\n    print(result)\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelse:\n    print(n + k - t)\n```",
    "8": "```python\ndef min_tiles_to_draw(tiles):\n    # Parse the input tiles\n    hand = [tile for tile in tiles.split()]\n    \n    # Count occurrences of each tile\n    count = {}\n    for tile in hand:\n        count[tile] = count.get(tile, 0) + 1\n    \n    # Check for koutsu (triplet)\n    for tile, cnt in count.items():\n        if cnt == 3:\n            return 0  # Already has a koutsu\n    \n    # Check for shuntsu (sequence)\n    suits = {'m': [], 'p': [], 's': []}\n    for tile in hand:\n        number = int(tile[0])\n        suit = tile[1]\n        suits[suit].append(number)\n    \n    # Sort the numbers in each suit\n    for suit in suits:\n        suits[suit].sort()\n    \n    # Check for existing shuntsu\n    for suit in suits:\n        for i in range(len(suits[suit]) - 2):\n            if suits[suit][i] + 1 == suits[suit][i + 1] and suits[suit][i] + 2 == suits[suit][i + 2]:\n                return 0  # Already has a shuntsu\n    \n    # Check how many tiles need to be drawn for shuntsu\n    needed = 2  # Maximum needed is 2 tiles to form a shuntsu\n    for suit in suits:\n        for number in suits[suit]:\n            # Check for possible shuntsu formations\n            if number - 1 in suits[suit] and number + 1 in suits[suit]:\n                return 0  # Already can form a shuntsu\n            if number - 1 not in suits[suit] and number + 1 not in suits[suit]:\n                needed = min(needed, 2)  # Need 2 tiles\n            else:\n                needed = min(needed, 1)  # Need 1 tile\n    \n    return needed\n\n# Read input\ntiles = input().strip()\n# Output the result\nprint(min_tiles_to_draw(tiles))\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    print(\"YES\" if a == b else \"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "9": "```python\nd = int(input())\nn, m = map(int, input().split())\n\nsofas = []\nfor i in range(d):\n    x1, y1, x2, y2 = map(int, input().split())\n    sofas.append((x1, y1, x2, y2))\n\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\ndef count_sofas(sofa, sofas):\n    x1, y1, x2, y2 = sofa\n    left = right = top = bottom = 0\n    \n    for other in sofas:\n        if other == sofa:\n            continue\n        ox1, oy1, ox2, oy2 = other\n        if x1 == x2:  # vertical sofa\n            if oy1 < y1:  # other is above\n                top += 1\n            elif oy1 > y2:  # other is below\n                bottom += 1\n        else:  # horizontal sofa\n            if ox2 < x1:  # other is to the left\n                left += 1\n            elif ox1 > x2:  # other is to the right\n                right += 1\n\n    return left, right, top, bottom\n\nfor i in range(d):\n    left, right, top, bottom = count_sofas(sofas[i], sofas)\n    if left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b:\n        print(i + 1)\n        break\nelse:\n    print(-1)\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    # Calculate the number of tiles painted Red and Blue\n    red_tiles = n // a\n    blue_tiles = n // b\n    both_tiles = n // (a * b)  # Tiles that can be painted both Red and Blue\n\n    # Calculate the maximum chocolates\n    # We can choose to paint the common tiles either Red or Blue\n    # We will choose the option that gives us more chocolates\n    max_chocolates = (red_tiles * p) + (blue_tiles * q) - (both_tiles * min(p, q))\n    \n    return max_chocolates\n\n# Example usage\n# n, a, b, p, q = map(int, input().split())\n# print(max_chocolates(n, a, b, p, q))\n```",
    "16": "```python\ncnt1 = int(input())\ncnt2 = int(input())\ncnt3 = int(input())\ncnt4 = int(input())\n\n# To form a regular bracket sequence:\n# 1. The number of opening brackets must be equal to the number of closing brackets.\n# 2. The number of closing brackets cannot exceed the number of opening brackets at any point.\n\n# Calculate the total number of opening and closing brackets\nopen_brackets = cnt1 + cnt2\nclose_brackets = cnt3 + cnt4\n\n# Check the conditions for a regular bracket sequence\nif open_brackets >= close_brackets and (cnt1 + cnt2) >= (cnt3):\n    print(1)\nelse:\n    print(0)\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    # Create a list to store the coverage of each section\n    coverage = [0] * (n + 1)\n\n    # Count the coverage for each painter\n    for l, r in painters:\n        for i in range(l, r + 1):\n            coverage[i] += 1\n\n    # Calculate the total painted sections with all painters\n    total_painted = sum(1 for i in range(1, n + 1) if coverage[i] > 0)\n\n    # If we hire q - 2 painters, we need to find the two painters that cover the most sections\n    max_loss = 0\n\n    # Check the effect of removing each pair of painters\n    for i in range(q):\n        for j in range(i + 1, q):\n            # Create a temporary coverage array\n            temp_coverage = coverage[:]\n            l1, r1 = painters[i]\n            l2, r2 = painters[j]\n\n            # Remove the coverage of the i-th painter\n            for k in range(l1, r1 + 1):\n                temp_coverage[k] -= 1\n            \n            # Remove the coverage of the j-th painter\n            for k in range(l2, r2 + 1):\n                temp_coverage[k] -= 1\n\n            # Calculate the painted sections after removing these two painters\n            painted_after_removal = sum(1 for k in range(1, n + 1) if temp_coverage[k] > 0)\n            max_loss = max(max_loss, total_painted - painted_after_removal)\n\n    # The maximum painted sections after hiring q - 2 painters\n    return total_painted - max_loss\n\n# Read input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Get the result and print it\nresult = max_painted_sections(n, q, painters)\nprint(result)\n```",
    "18": "```python\ndef lexicographically_minimal_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        while t:\n            if not u or t[-1] <= u[-1]:\n                u.append(t.pop())\n            else:\n                break\n    \n    return ''.join(u)\n\ns = input().strip()\nprint(lexicographically_minimal_string(s))\n```",
    "21": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the positions of the minimum and maximum elements\nmin_pos = a.index(1)\nmax_pos = a.index(n)\n\n# Calculate the current distance\ncurrent_distance = abs(min_pos - max_pos)\n\n# Calculate the maximum possible distance after one swap\nmax_distance = max(\n    abs(min_pos - 0),  # Swap min with the first element\n    abs(min_pos - (n - 1)),  # Swap min with the last element\n    abs(max_pos - 0),  # Swap max with the first element\n    abs(max_pos - (n - 1))  # Swap max with the last element\n)\n\n# The result is the maximum of the current distance and the calculated maximum distance\nresult = max(current_distance, max_distance)\nprint(result)\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a, b):\n    from itertools import permutations\n    \n    # Convert a to string to work with its digits\n    str_a = str(a)\n    str_b = str(b)\n    \n    # Generate all unique permutations of the digits of a\n    permuted_numbers = set(int(''.join(p)) for p in permutations(str_a))\n    \n    # Filter out numbers that are greater than b and have the same length as a\n    valid_numbers = [num for num in permuted_numbers if num <= b and len(str(num)) == len(str_a)]\n    \n    # Return the maximum of the valid numbers\n    return max(valid_numbers)\n\n# Input reading\na = int(input().strip())\nb = int(input().strip())\n\n# Output the result\nprint(max_permutation_not_exceeding(a, b))\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome_time(hh, mm):\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return time_str\n\ndef minutes_to_palindrome(time):\n    hh, mm = map(int, time.split(':'))\n    minutes = 0\n    while True:\n        if is_palindrome(f\"{hh:02}:{mm:02}\"):\n            return minutes\n        mm += 1\n        minutes += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n\ntime_input = input().strip()\nprint(minutes_to_palindrome(time_input))\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    # Find the current maximum length of golden trophies\n    max_length = 0\n    current_length = 0\n    segments = []\n\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n                max_length = max(max_length, current_length)\n            current_length = 0\n\n    if current_length > 0:\n        segments.append(current_length)\n        max_length = max(max_length, current_length)\n\n    # If there are no golden trophies, return 0\n    if max_length == 0:\n        return 0\n\n    # If there's only one segment of golden trophies, we can only swap with a silver\n    if len(segments) == 1:\n        return max_length\n\n    # Calculate the maximum possible length after one swap\n    max_possible_length = max_length\n    for i in range(len(segments) - 1):\n        # Check if we can merge two segments by swapping one silver trophy\n        max_possible_length = max(max_possible_length, segments[i] + segments[i + 1])\n\n    # If we can swap with a silver trophy, we can increase the length by 1\n    return max_possible_length + 1\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\nprint(max_beauty_after_swap(n, trophies))\n```",
    "19": "```python\ndef check_records(test_cases):\n    results = []\n    for case in test_cases:\n        n = case[0]\n        records = case[1]\n        \n        valid = True\n        previous_p, previous_c = 0, 0\n        \n        for p, c in records:\n            if p < previous_p or c < previous_c or c > p:\n                valid = False\n                break\n            if p - previous_p < c - previous_c:\n                valid = False\n                break\n            \n            previous_p, previous_c = p, c\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Read input\nT = int(input())\ntest_cases = []\nfor _ in range(T):\n    n = int(input())\n    records = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, records))\n\n# Get results and print\nresults = check_records(test_cases)\nfor result in results:\n    print(result)\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef find_courses(n, k, main_courses, dependencies):\n    # Create a graph and a list to track in-degrees\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    \n    # Build the graph and in-degree count\n    for i in range(1, n + 1):\n        for dep in dependencies[i - 1]:\n            graph[dep].append(i)\n            in_degree[i] += 1\n    \n    # Queue for courses that can be taken (in-degree of 0)\n    queue = deque()\n    for course in range(1, n + 1):\n        if in_degree[course] == 0:\n            queue.append(course)\n    \n    # To track the courses we need to take\n    taken_courses = []\n    main_courses_set = set(main_courses)\n    courses_to_take = set(main_courses)\n    \n    # Process the courses\n    while queue:\n        course = queue.popleft()\n        taken_courses.append(course)\n        \n        # If this course is a main course, remove it from the set of courses to take\n        if course in courses_to_take:\n            courses_to_take.remove(course)\n        \n        # Process the dependent courses\n        for neighbor in graph[course]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check if we have taken all main courses\n    if courses_to_take:\n        return -1\n    \n    # Return the result\n    return len(taken_courses), taken_courses\n\n# Input reading\nn, k = map(int, input().split())\nmain_courses = list(map(int, input().split()))\ndependencies = [list(map(int, input().split()[1:])) for _ in range(n)]\n\n# Solve the problem\nresult = find_courses(n, k, main_courses, dependencies)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    m, courses = result\n    print(m)\n    print(' '.join(map(str, courses)))\n```",
    "14": "```python\ndef restore_stack_sortable_permutation(n, k, p):\n    # Create a set of used numbers from the first k elements\n    used = set(p)\n    \n    # Create the remaining numbers that need to be filled in the permutation\n    remaining = [i for i in range(1, n + 1) if i not in used]\n    \n    # Initialize the result with the first k elements\n    result = p[:]\n    \n    # Initialize a stack to simulate the stack operations\n    stack = []\n    \n    # The next number we need to push from remaining\n    next_remaining_index = 0\n    \n    # Iterate over the first k elements to check stack-sortability\n    for i in range(k):\n        # While we can push from remaining and the top of the stack is less than the next needed\n        while (next_remaining_index < len(remaining) and \n               (not stack or stack[-1] > p[i])):\n            stack.append(remaining[next_remaining_index])\n            next_remaining_index += 1\n        \n        # If the top of the stack is the current element, pop it\n        if stack and stack[-1] == p[i]:\n            stack.pop()\n        else:\n            # If we can't match the current element, it's not stack-sortable\n            return -1\n    \n    # Now we need to fill the rest of the result with remaining elements\n    while next_remaining_index < len(remaining):\n        stack.append(remaining[next_remaining_index])\n        next_remaining_index += 1\n    \n    # Pop all remaining elements from the stack to the result\n    while stack:\n        result.append(stack.pop())\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result\nresult = restore_stack_sortable_permutation(n, k, p)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    if k > n * (n + 1) // 2:\n        return -1\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k <= 0:\n            break\n        for j in range(i, n):\n            if k <= 0:\n                break\n            if i == j:  # diagonal element\n                if k >= 1:\n                    matrix[i][j] = 1\n                    k -= 1\n            else:  # symmetric pair\n                if k >= 2:\n                    matrix[i][j] = 1\n                    matrix[j][i] = 1\n                    k -= 2\n    \n    return matrix if k == 0 else -1\n\n# Read input\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\n# Output result\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "27": "```python\nn = int(input())\ns = input()\n\nmin_operations = n  # Start with the maximum operations needed (typing all characters)\n\n# Check for every possible prefix of the string\nfor i in range(1, n + 1):\n    prefix = s[:i]\n    # If the prefix can be repeated to form the beginning of the string\n    if s.startswith(prefix * (n // i)) and n % i == 0:\n        min_operations = min(min_operations, i + (n - i) // i)\n\nprint(min_operations)\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = []\nregulars = []\n\nfor name, type_ in files:\n    if type_ == '1':\n        examples.append(name)\n    else:\n        regulars.append(name)\n\nmoves = []\n# Renaming examples\nfor i in range(len(examples)):\n    moves.append(f\"move {examples[i]} {i + 1}\")\n\n# Renaming regular tests\nfor i in range(len(regulars)):\n    moves.append(f\"move {regulars[i]} {len(examples) + i + 1}\")\n\nprint(len(moves))\nfor move in moves:\n    print(move)\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    # Define a mapping for mirror reflections\n    mirror_map = {\n        'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M', \n        'O': 'O', 'p': 'q', 'q': 'p', 'T': 'T', 'U': 'U', 'v': 'v', \n        'V': 'V', 'W': 'W', 'X': 'X', 'Y': 'Y', 'o': 'o', 'x': 'x'\n    }\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        if s[i] not in mirror_map or mirror_map[s[i]] != s[n - 1 - i]:\n            print(\"NIE\")\n            return\n    print(\"TAK\")\n\ns = input().strip()\nis_s_palindrome(s)\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # Since GCD(x, m) = 1, the x-mouse will visit all rooms in the cycle\n    # The number of unique rooms visited is equal to m - 1\n    # The number of traps needed is m - 1, plus one for room 0\n    return m\n\nm, x = map(int, input().split())\nprint(minimum_traps(m, x))\n```",
    "24": "```python\ndef can_win_in_one_turn(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # horizontal, vertical, diagonal /\n    \n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                # Temporarily place 'X' in the empty cell\n                board[i][j] = 'X'\n                \n                for dx, dy in directions:\n                    count = 1\n                    \n                    # Check in the positive direction\n                    x, y = i + dx, j + dy\n                    while 0 <= x < 10 and 0 <= y < 10 and board[x][y] == 'X':\n                        count += 1\n                        x += dx\n                        y += dy\n                    \n                    # Check in the negative direction\n                    x, y = i - dx, j - dy\n                    while 0 <= x < 10 and 0 <= y < 10 and board[x][y] == 'X':\n                        count += 1\n                        x -= dx\n                        y -= dy\n                    \n                    if count >= 5:\n                        return \"YES\"\n                \n                # Restore the empty cell\n                board[i][j] = '.'\n    \n    return \"NO\"\n\n# Read the board input\nboard = [input().strip() for _ in range(10)]\nprint(can_win_in_one_turn(board))\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    # Calculate the difference\n    diff = abs(sum_first - sum_second)\n    \n    # Calculate the potential changes\n    changes = []\n    if sum_first > sum_second:\n        # We need to decrease the first half or increase the second half\n        changes = [9 - digit for digit in first_half] + second_half\n    else:\n        # We need to decrease the second half or increase the first half\n        changes = first_half + [9 - digit for digit in second_half]\n    \n    # Sort changes in descending order to maximize the impact of each change\n    changes.sort(reverse=True)\n    \n    replacements = 0\n    for change in changes:\n        diff -= change\n        replacements += 1\n        if diff <= 0:\n            break\n    \n    return replacements\n\n# Example usage\nticket = input().strip()\nprint(min_replacements_to_lucky(ticket))\n```",
    "26": "```python\nimport math\n\n# Read input\nx, y, z = map(float, input().split())\n\n# Define the expressions and their corresponding labels\nexpressions = [\n    (x**(y**z), \"x^y^z\"),\n    (x**(z**y), \"x^z^y\"),\n    ((x**y)**z, \"(x^y)^z\"),\n    ((x**z)**y, \"(x^z)^y\"),\n    (y**(x**z), \"y^x^z\"),\n    (y**(z**x), \"y^z^x\"),\n    ((y**x)**z, \"(y^x)^z\"),\n    ((y**z)**x, \"(y^z)^x\"),\n    (z**(x**y), \"z^x^y\"),\n    (z**(y**x), \"z^y^x\"),\n    ((z**x)**y, \"(z^x)^y\"),\n    ((z**y)**x, \"(z^y)^x\")\n]\n\n# Find the maximum value and its corresponding index\nmax_value = -math.inf\nmax_index = -1\n\nfor i, (value, label) in enumerate(expressions):\n    if value > max_value:\n        max_value = value\n        max_index = i\n\n# Output the corresponding expression\nprint(expressions[max_index][1])\n```",
    "37": "```python\ndef can_break_shield(a, b, c):\n    for i in range(c // a + 1):\n        if (c - i * a) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Input reading\na, b, c = map(int, input().split())\nprint(can_break_shield(a, b, c))\n```",
    "32": "```python\ndef is_valid_journey(n, journey):\n    position = 0  # Position starts at the North Pole (0 km)\n    \n    for t, direction in journey:\n        if position == 0 and direction != \"South\":\n            return \"NO\"  # At North Pole, can only move South\n        if position == 20000 and direction != \"North\":\n            return \"NO\"  # At South Pole, can only move North\n        \n        if direction == \"South\":\n            position += t\n        elif direction == \"North\":\n            position -= t\n        elif direction == \"West\" or direction == \"East\":\n            continue  # No change in position\n        \n        if position < 0 or position > 20000:\n            return \"NO\"  # Out of bounds\n        \n    if position != 0:\n        return \"NO\"  # Must end at North Pole\n    \n    return \"YES\"\n\n# Input reading\nn = int(input())\njourney = [tuple(input().split()) for _ in range(n)]\njourney = [(int(t), dir) for t, dir in journey]\n\n# Output result\nprint(is_valid_journey(n, journey))\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    def can_distribute(x):\n        plates_from_a = a // x\n        plates_from_b = b // x\n        return plates_from_a + plates_from_b >= n\n\n    left, right = 1, max(a, b)\n    result = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_distribute(mid):\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n\nn, a, b = map(int, input().split())\nprint(max_min_pieces(n, a, b))\n```",
    "35": "```python\ndef is_valid_flag(n, m, field):\n    # Check for horizontal stripes\n    stripe_height = n // 3\n    if n % 3 != 0:\n        return \"NO\"\n    \n    colors = set()\n    for i in range(3):\n        stripe = field[i * stripe_height:(i + 1) * stripe_height]\n        if len(set(row for row in stripe)) != 1:\n            return \"NO\"\n        colors.add(stripe[0][0])\n    \n    if len(colors) != 3:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(is_valid_flag(n, m, field))\n```",
    "38": "```python\ndef can_tracks_coincide(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between barriers for Kefa\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    # Calculate the distances between barriers for Sasha\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Check if the two lists of differences are the same, considering circular shifts\n    for i in range(n):\n        if kefa_diffs == sasha_diffs[i:] + sasha_diffs[:i]:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_distances, sasha_distances))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    \n    # Check if the entire string is a palindrome\n    if not is_palindrome(s):\n        return n\n    \n    # If the string is a palindrome, check for non-palindromic substrings\n    for i in range(n):\n        for j in range(i + 1, n):\n            if not is_palindrome(s[i:j + 1]):\n                return j - i + 1\n    \n    return 0\n\ns = input().strip()\nprint(longest_non_palindrome_substring(s))\n```",
    "36": "```python\ndef find_coordinates(n):\n    if n == 0:\n        return (0, 0)\n    \n    layer = 0\n    moves_in_layer = 6 * layer\n    \n    while n > moves_in_layer:\n        n -= moves_in_layer\n        layer += 1\n        moves_in_layer = 6 * layer\n    \n    x, y = layer, 0\n    \n    if n == 0:\n        return (x, y)\n    \n    # Calculate the position in the current layer\n    direction = n // layer\n    steps = n % layer\n    \n    if direction == 0:  # Right\n        x += steps\n    elif direction == 1:  # Top-right\n        x += steps\n        y += steps\n    elif direction == 2:  # Top-left\n        y += steps\n    elif direction == 3:  # Left\n        x -= steps\n        y += steps\n    elif direction == 4:  # Bottom-left\n        x -= steps\n    elif direction == 5:  # Bottom-right\n        x += steps\n        y -= steps\n    \n    return (x, y)\n\nn = int(input())\nx, y = find_coordinates(n)\nprint(x, y)\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    m0, x0, x1 = m, 0, 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef birthday_paradox(n, k):\n    MOD = 1000003\n    \n    days = 1 << n  # 2^n\n    if k > days:\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the probability of no collision\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator *= (days - i)\n        denominator *= days\n        numerator %= MOD\n        denominator %= MOD\n\n    # Probability of at least one collision\n    A = (denominator - numerator) % MOD\n    B = denominator % MOD\n\n    # Reduce A/B to irreducible form\n    g = gcd(A, B)\n    A //= g\n    B //= g\n\n    return A, B\n\n# Input reading\nn, k = map(int, input().split())\nresult = birthday_paradox(n, k)\nprint(result[0], result[1])\n```",
    "33": "```python\ndef count_common_ap(a1, b1, a2, b2, L, R):\n    # Calculate the first possible value of x in the range [L, R]\n    def first_value(a, b, start):\n        if (start - b) % a == 0:\n            return start\n        return start + (a - (start - b) % a) % a\n\n    # Calculate the last possible value of x in the range [L, R]\n    def last_value(a, b, end):\n        if (end - b) % a == 0:\n            return end\n        return end - (end - b) % a\n\n    # Find the first and last values for both progressions\n    first_x1 = first_value(a1, b1, L)\n    last_x1 = last_value(a1, b1, R)\n    \n    first_x2 = first_value(a2, b2, L)\n    last_x2 = last_value(a2, b2, R)\n\n    # If the first value of one progression is greater than the last of the other, return 0\n    if first_x1 > last_x2 or first_x2 > last_x1:\n        return 0\n\n    # Calculate the number of common values in the range\n    count = 0\n    for x in range(max(first_x1, first_x2), min(last_x1, last_x2) + 1):\n        if (x - b1) % a1 == 0 and (x - b2) % a2 == 0:\n            count += 1\n\n    return count\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n# Print the result\nprint(count_common_ap(a1, b1, a2, b2, L, R))\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if any rating has changed\nrated = any(a != b for a, b in ratings)\n\nif rated:\n    print(\"rated\")\nelse:\n    # Check if the standings are in non-increasing order of the initial ratings\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            print(\"unrated\")\n            break\n    else:\n        print(\"maybe\")\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n\n    len_s = len(s)\n    total_count = 0\n    seen = set()\n\n    # Generate all binary strings of length n\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        # Check if s is a substring in any cyclic shift of t\n        if any(s in t[i:] + t[:i] for i in range(n)):\n            # Add the cyclic string to the set to ensure uniqueness\n            seen.add(t)\n\n    return len(seen)\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Get the result and print it\nresult = count_cyclic_strings(n, s)\nprint(result)\n```",
    "43": "```python\nimport sys\nimport math\n\ndef minimal_angle_pair(n, vectors):\n    angles = []\n    \n    for i in range(n):\n        x, y = vectors[i]\n        angle = math.atan2(y, x)\n        angles.append((angle, i + 1))  # Store angle and index (1-based)\n    \n    # Sort angles\n    angles.sort()\n    \n    min_angle = float('inf')\n    min_pair = (0, 0)\n    \n    # Check adjacent angles in the sorted list\n    for i in range(n):\n        angle1, index1 = angles[i]\n        angle2, index2 = angles[(i + 1) % n]  # Wrap around for circular comparison\n        \n        # Calculate the non-oriented angle\n        angle_diff = abs(angle2 - angle1)\n        angle_diff = min(angle_diff, 2 * math.pi - angle_diff)  # Non-oriented angle\n        \n        if angle_diff < min_angle:\n            min_angle = angle_diff\n            min_pair = (index1, index2)\n    \n    return min_pair\n\n# Read input\nn = int(sys.stdin.readline().strip())\nvectors = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\n# Get the result\nresult = minimal_angle_pair(n, vectors)\n\n# Print the result\nprint(result[0], result[1])\n```",
    "46": "```python\ndef count_divisible_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n\n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n\n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n\n    result = 0\n    for i in range(5):\n        result += count_x[i] * count_y[(5 - i) % 5]\n\n    return result\n\nn, m = map(int, input().split())\nprint(count_divisible_pairs(n, m))\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Check if it's possible to create a strictly increasing sequence of k positive numbers that sums to n\n    if n < (k * (k + 1)) // 2:\n        return -1  # Not enough to form the sequence\n\n    # The minimum sum of the first k natural numbers is k * (k + 1) / 2\n    # We can find the maximum GCD by starting from 1 and going upwards\n    # The maximum GCD we can use is n // k\n    max_gcd = n // k\n\n    # We will create the sequence with the maximum GCD\n    sequence = [(i + 1) * max_gcd for i in range(k)]\n    total_sum = sum(sequence)\n\n    # Adjust the last element to ensure the sum equals n\n    sequence[-1] += (n - total_sum)\n\n    return sequence\n\n# Read input\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "48": "```python\ndef kth_largest_in_multiplication_table(n, m, k):\n    left, right = 1, n * m\n    \n    while left < right:\n        mid = (left + right) // 2\n        count = sum(min(mid // i, m) for i in range(1, n + 1))\n        \n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return left\n\n# Read input\nn, m, k = map(int, input().split())\n# Output the k-th largest number\nprint(kth_largest_in_multiplication_table(n, m, k))\n```",
    "51": "```python\nfrom collections import Counter\nimport sys\n\ndef find_x_y(n, divisors):\n    count = Counter(divisors)\n    x = 1\n    y = 1\n    \n    for d in count:\n        if count[d] == 2:\n            x *= d\n            y *= d\n        elif count[d] == 1:\n            if x < y:\n                x *= d\n            else:\n                y *= d\n                \n    return x, y\n\nn = int(input().strip())\ndivisors = list(map(int, input().strip().split()))\n\nx, y = find_x_y(n, divisors)\nprint(x, y)\n```",
    "49": "```python\ndef find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n    \n    # Determine the range where the k-th digit lies\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n    \n    # Find the actual number containing the k-th digit\n    start += (k - 1) // length\n    num_str = str(start)\n    \n    # Find the digit in the number\n    return num_str[(k - 1) % length]\n\nk = int(input().strip())\nprint(find_kth_digit(k))\n```",
    "41": "```python\ndef nearest_zero_distance(n, a):\n    distances = [float('inf')] * n\n    last_zero_index = -1\n\n    # Forward pass to find distances to the nearest zero on the left\n    for i in range(n):\n        if a[i] == 0:\n            last_zero_index = i\n            distances[i] = 0\n        elif last_zero_index != -1:\n            distances[i] = i - last_zero_index\n\n    # Backward pass to find distances to the nearest zero on the right\n    last_zero_index = -1\n    for i in range(n - 1, -1, -1):\n        if a[i] == 0:\n            last_zero_index = i\n        elif last_zero_index != -1:\n            distances[i] = min(distances[i], last_zero_index - i)\n\n    print(' '.join(map(str, distances)))\n\n# Example usage:\n# n = int(input())\n# a = list(map(int, input().split()))\n# nearest_zero_distance(n, a)\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = -1\n    result_length = 0\n    result_moves = []\n\n    while left <= right:\n        if a[left] < a[right]:\n            if a[left] > last_taken:\n                last_taken = a[left]\n                result_moves.append('L')\n                result_length += 1\n                left += 1\n            else:\n                break\n        else:\n            if a[right] > last_taken:\n                last_taken = a[right]\n                result_moves.append('R')\n                result_length += 1\n                right -= 1\n            else:\n                break\n\n    print(result_length)\n    print(''.join(result_moves))\n\n# Example usage:\n# n = int(input())\n# a = list(map(int, input().split()))\n# longest_increasing_sequence(n, a)\n```",
    "54": "```python\ndef min_D_to_equalize(n, a):\n    min_a = min(a)\n    max_a = max(a)\n    \n    if max_a - min_a > 2 * (max_a - min_a) // 2:\n        return -1\n    \n    if max_a == min_a:\n        return 0\n    \n    return (max_a - min_a + 1) // 2\n\nn = int(input())\na = list(map(int, input().split()))\nprint(min_D_to_equalize(n, a))\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef count_reachable_numbers(n):\n    reachable = set()\n    current = n\n    \n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    \n    return len(reachable)\n\nn = int(input())\nprint(count_reachable_numbers(n))\n```",
    "44": "```python\ndef minimal_time_to_post_office(d, k, a, b, t):\n    # Initialize the minimum time to a large number\n    min_time = float('inf')\n    \n    # Calculate how many full segments of k kilometers can be driven\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Time if Vasiliy drives all full segments and walks the remaining distance\n    time_if_driving_all = full_segments * (k * a + t) + remaining_distance * a - t\n    min_time = min(min_time, time_if_driving_all)\n    \n    # Check if it's better to walk some distance instead of driving\n    for segments in range(full_segments + 1):\n        distance_driven = segments * k\n        time_spent = segments * (k * a + t)\n        \n        # Remaining distance to walk\n        remaining_distance = d - distance_driven\n        \n        # If remaining distance is negative, break\n        if remaining_distance < 0:\n            break\n        \n        # Calculate total time\n        total_time = time_spent + remaining_distance * b\n        \n        # Update minimum time\n        min_time = min(min_time, total_time)\n    \n    return min_time\n\n# Example usage:\n# d, k, a, b, t = map(int, input().split())\n# print(minimal_time_to_post_office(d, k, a, b, t))\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_elements = m // 2\n    dp = [[-1] * k for _ in range(n + 1)]\n    dp[0][0] = 0  # Base case: 0 elements chosen, sum is 0\n\n    for i in range(1, n + 1):\n        row = sorted(matrix[i - 1], reverse=True)  # Sort row in descending order\n        for j in range(max_elements + 1):\n            current_sum = sum(row[:j])  # Sum of the top j elements\n            for r in range(k):\n                if dp[i - 1][r] != -1:  # If previous row has a valid sum\n                    new_sum = dp[i - 1][r] + current_sum\n                    new_remainder = new_sum % k\n                    dp[i][new_remainder] = max(dp[i][new_remainder], new_sum)\n\n        # Carry forward the previous row's values\n        for r in range(k):\n            dp[i][r] = max(dp[i][r], dp[i - 1][r])\n\n    return max(dp[n])\n\n# Example usage:\n# n, m, k = map(int, input().split())\n# matrix = [list(map(int, input().split())) for _ in range(n)]\n# print(max_sum_divisible_by_k(n, m, k, matrix))\n```",
    "58": "```python\ndef color_array(n, k, a):\n    from collections import defaultdict\n\n    color_assignment = [0] * n\n    color_count = defaultdict(int)\n    color_used = defaultdict(set)\n\n    for i in range(n):\n        value = a[i]\n        if color_count[value] < k:\n            color_count[value] += 1\n            color_assignment[i] = color_count[value]\n            color_used[color_count[value]].add(value)\n        else:\n            # Try to assign a color that has not been used for this value\n            for color in range(1, k + 1):\n                if value not in color_used[color]:\n                    color_assignment[i] = color\n                    color_used[color].add(value)\n                    break\n\n    # Check if we have used all colors at least once\n    if len(color_used) < k:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, color_assignment)))\n\n# Example usage\n# n, k = map(int, input().split())\n# a = list(map(int, input().split()))\n# color_array(n, k, a)\n```",
    "60": "```python\ndef has_palindrome_subsequence(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        found = False\n        # Use a dictionary to track the first occurrence of each number\n        first_occurrence = {}\n        \n        for i in range(n):\n            if a[i] in first_occurrence:\n                # If we find the same number again, we can form a palindrome\n                if i - first_occurrence[a[i]] >= 2:\n                    found = True\n                    break\n            else:\n                first_occurrence[a[i]] = i\n        \n        results.append(\"YES\" if found else \"NO\")\n    \n    return results\n\n# Example usage:\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\nresults = has_palindrome_subsequence(t, test_cases)\nfor result in results:\n    print(result)\n```",
    "63": "```python\ndef min_instability(n, a):\n    a.sort()\n    # The minimum instability can be achieved by removing either the first or the last element\n    return min(a[-1] - a[1], a[-2] - a[0])\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_instability(n, a))\n```",
    "57": "```python\ndef fill_gift_choices(n, f):\n    # Create a list to store the final gift choices\n    nf = f[:]\n    \n    # Find the friends who have not chosen anyone (f_i = 0)\n    unchosen = [i + 1 for i in range(n) if nf[i] == 0]\n    \n    # Find the friends who are already chosen by someone\n    chosen = set(f_i for f_i in nf if f_i != 0)\n    \n    # Find the friends who are not chosen by anyone\n    not_chosen = [i + 1 for i in range(1, n + 1) if i not in chosen]\n    \n    # Fill in the unchosen friends\n    for i in range(len(unchosen)):\n        nf[unchosen[i] - 1] = not_chosen[i]\n    \n    return nf\n\n# Read input\nn = int(input())\nf = list(map(int, input().split()))\n\n# Get the result\nresult = fill_gift_choices(n, f)\n\n# Print the result\nprint(' '.join(map(str, result)))\n```",
    "59": "```python\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# We need to check the last x digits of the number\ntarget_remainder = '0' * y + '1' + '0' * (x - y - 1)  # This is the desired pattern\ncurrent_remainder = number[n - x:]  # Get the last x digits of the number\n\n# Calculate the number of changes needed\nchanges_needed = sum(1 for i in range(x) if current_remainder[i] != target_remainder[i])\n\nprint(changes_needed)\n```",
    "61": "```python\ndef max_number_after_replacement(n, a, f):\n    a_list = list(a)\n    modified = False\n    \n    for i in range(n):\n        original_digit = int(a_list[i])\n        new_digit = f[original_digit - 1]\n        \n        if new_digit > original_digit and not modified:\n            modified = True\n            a_list[i] = str(new_digit)\n        elif new_digit < original_digit and modified:\n            break\n        elif modified:\n            a_list[i] = str(new_digit)\n    \n    return ''.join(a_list)\n\n# Input reading\nn = int(input().strip())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\n# Get the result and print it\nresult = max_number_after_replacement(n, a, f)\nprint(result)\n```",
    "55": "```python\ndef can_see_white_sheet(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n    # Check if there is any part of the white sheet that is not covered by both black sheets\n    # The white sheet is visible if any of the following conditions are true:\n    \n    # Check left side of the white sheet\n    if x1 > x4 and x1 > x6:  # left of white is right of both black sheets\n        return \"YES\"\n    \n    # Check right side of the white sheet\n    if x2 < x3 and x2 < x5:  # right of white is left of both black sheets\n        return \"YES\"\n    \n    # Check bottom side of the white sheet\n    if y1 > y4 and y1 > y6:  # bottom of white is above both black sheets\n        return \"YES\"\n    \n    # Check top side of the white sheet\n    if y2 < y3 and y2 < y5:  # top of white is below both black sheets\n        return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Output the result\nprint(can_see_white_sheet(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6))\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph):\n    visited = {start: 0}\n    queue = deque([start])\n    farthest_node = start\n    max_distance = 0\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > max_distance:\n                    max_distance = visited[neighbor]\n                    farthest_node = neighbor\n                    \n    return farthest_node, max_distance\n\ndef find_max_edges(n, edges):\n    graph = defaultdict(list)\n    \n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Step 1: Find the farthest node from an arbitrary node (1)\n    farthest_from_start, _ = bfs(1, graph)\n    \n    # Step 2: Find the farthest node from the previously found node\n    farthest_from_a, _ = bfs(farthest_from_start, graph)\n    \n    # Step 3: Find the farthest node from the second farthest node\n    farthest_from_b, diameter_length = bfs(farthest_from_a, graph)\n    \n    # The maximum number of edges in the union of paths is the diameter length + 1\n    max_edges = diameter_length + 1\n    \n    # To find the three vertices, we can use the path from farthest_from_start to farthest_from_b\n    # We can use BFS to find the actual path\n    def find_path(start, end):\n        parent = {start: None}\n        queue = deque([start])\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in graph[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        \n        return path[::-1]\n    \n    path = find_path(farthest_from_start, farthest_from_b)\n    \n    # Choose the first, last, and one more node from the path\n    a = path[0]\n    b = path[-1]\n    c = path[len(path) // 2]  # Choose a middle node\n    \n    return max_edges, a, b, c\n\n# Input reading\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\n# Finding the result\nresult = find_max_edges(n, edges)\nprint(result[0])\nprint(result[1], result[2], result[3])\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        min_moves = float('inf')\n        best_triple = (a, b, c)\n        \n        # Check for all possible values of A\n        for A in range(1, a + 1):\n            # B should be a multiple of A\n            B = ((b + A - 1) // A) * A  # smallest multiple of A >= b\n            if B < b:\n                B += A  # ensure B is at least b\n            \n            # C should be a multiple of B\n            C = ((c + B - 1) // B) * B  # smallest multiple of B >= c\n            if C < c:\n                C += B  # ensure C is at least c\n            \n            # Calculate the number of moves\n            moves = (A - a) + (B - b) + (C - c)\n            if moves < min_moves:\n                min_moves = moves\n                best_triple = (A, B, C)\n        \n        results.append((min_moves, best_triple))\n    \n    return results\n\n# Example usage\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\nresults = min_operations(t, test_cases)\n\nfor moves, (A, B, C) in results:\n    print(moves)\n    print(A, B, C)\n```",
    "65": "```python\ndef transform_moves(n, m):\n    if m % n != 0:\n        return -1\n    \n    ratio = m // n\n    moves = 0\n    \n    while ratio > 1:\n        if ratio % 2 == 0:\n            ratio //= 2\n            moves += 1\n        elif ratio % 3 == 0:\n            ratio //= 3\n            moves += 1\n        else:\n            return -1\n            \n    return moves\n\n# Read input\nn, m = map(int, input().split())\n# Print the result\nprint(transform_moves(n, m))\n```",
    "71": "```python\nimport math\n\na = int(input())\noutput = math.floor(math.log2(a))\nprint(output)\n```",
    "47": "```python\ndef max_beauty_with_multiplier(n, x, a):\n    # Function to calculate the maximum subarray sum using Kadane's algorithm\n    def kadane(arr):\n        max_sum = 0\n        current_sum = 0\n        for value in arr:\n            current_sum += value\n            max_sum = max(max_sum, current_sum)\n            current_sum = max(current_sum, 0)\n        return max_sum\n\n    # Calculate the original beauty (max subarray sum)\n    original_beauty = kadane(a)\n\n    # If x is 0, the best we can do is the original beauty\n    if x == 0:\n        return original_beauty\n\n    # Calculate the maximum beauty after multiplying a subarray by x\n    max_increase = 0\n    current_sum = 0\n    for i in range(n):\n        current_sum += a[i]\n        # Calculate the potential increase if we multiply the current subarray by x\n        potential_increase = current_sum * (x - 1)\n        max_increase = max(max_increase, potential_increase)\n        # Reset current_sum if it drops below 0\n        if current_sum < 0:\n            current_sum = 0\n\n    # The maximum beauty is the original beauty plus the best increase we can get\n    return original_beauty + max_increase\n\n# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result and print it\nresult = max_beauty_with_multiplier(n, x, a)\nprint(result)\n```",
    "70": "```python\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Convert start and end times to total minutes\nstart_minutes = h1 * 60 + m1\nend_minutes = h2 * 60 + m2\n\n# Calculate the midpoint in total minutes\nmidpoint_minutes = (start_minutes + end_minutes) // 2\n\n# Convert back to hours and minutes\nh3 = midpoint_minutes // 60\nm3 = midpoint_minutes % 60\n\n# Print the result in the required format\nprint(f\"{h3:02}:{m3:02}\")\n```",
    "73": "```python\ndef can_complete_wall(n, heights):\n    max_height = max(heights)\n    total_bricks_needed = 0\n    \n    for height in heights:\n        total_bricks_needed += max_height - height\n    \n    # Check if the total number of bricks needed is even\n    return \"YES\" if total_bricks_needed % 2 == 0 else \"NO\"\n\n# Input reading\nn = int(input())\nheights = list(map(int, input().split()))\n\n# Output the result\nprint(can_complete_wall(n, heights))\n```",
    "67": "```python\ndef find_nice_indices(n, a):\n    total_sum = sum(a)\n    nice_indices = []\n\n    for i in range(n):\n        if (total_sum - a[i]) % 2 == 0:\n            target = (total_sum - a[i]) // 2\n            if target in a:\n                # Check if the target is not the same as the removed element\n                if target != a[i] or a.count(target) > 1:\n                    nice_indices.append(i + 1)  # Store 1-based index\n\n    print(len(nice_indices))\n    if nice_indices:\n        print(\" \".join(map(str, nice_indices)))\n\n# Example usage:\n# n = int(input())\n# a = list(map(int, input().split()))\n# find_nice_indices(n, a)\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    days = [0] * n  # Initialize days with 0 (rest days)\n    exam_days = [False] * (n + 1)  # Track exam days\n    preparation_needed = [0] * (m + 1)  # Track preparation days needed for each exam\n\n    # Fill exam days and preparation needs\n    for i in range(m):\n        s, d, c = exams[i]\n        exam_days[d] = True\n        preparation_needed[i + 1] = c\n\n    # Prepare for exams\n    for i in range(m):\n        s, d, c = exams[i]\n        count = 0\n        for j in range(s, d):\n            if count < c and days[j - 1] == 0:  # If we can prepare on this day\n                days[j - 1] = i + 1  # Mark preparation for exam i+1\n                count += 1\n        if count < c:  # If we couldn't prepare enough days\n            return -1\n\n    # Assign exam days\n    for i in range(m):\n        d = exams[i][1]\n        days[d - 1] = m + 1  # Mark exam day\n\n    return days\n\n# Input reading\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the schedule\nresult = schedule_exams(n, m, exams)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Find the longest prefix which is also a suffix\n    lps = [0] * n\n    j = 0  # length of previous longest prefix suffix\n    i = 1\n\n    while i < n:\n        if t[i] == t[j]:\n            j += 1\n            lps[i] = j\n            i += 1\n        else:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                lps[i] = 0\n                i += 1\n\n    # The length of the longest prefix which is also a suffix\n    longest_prefix_suffix = lps[-1]\n\n    # The minimum length of the string s\n    min_length = n + (k - 1) * (n - longest_prefix_suffix)\n\n    # Construct the string s\n    s = t\n    for _ in range(k - 1):\n        s += t[longest_prefix_suffix:]\n\n    return s\n\n# Read input\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the result and print it\nresult = construct_string(n, k, t)\nprint(result)\n```",
    "77": "```python\ndef minimum_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nn = int(input())\nprint(minimum_difference(n))\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import Counter\n    \n    # Count the frequency of each character in the string\n    freq = Counter(s)\n    \n    # Calculate the total number of unique subsequences\n    total_subsequences = 0\n    costs = []\n    \n    # For each unique character, calculate the number of subsequences we can create\n    for char, count in freq.items():\n        # The number of subsequences that can be formed with this character\n        # is 2^count - 1 (excluding the empty subsequence)\n        subsequences_count = (1 << count) - 1  # 2^count - 1\n        total_subsequences += subsequences_count\n        \n        # The cost of adding subsequences of length 1 to count\n        for length in range(1, count + 1):\n            costs.append(n - length)\n    \n    # If we cannot create enough unique subsequences\n    if total_subsequences < k:\n        return -1\n    \n    # Sort costs to minimize the total cost\n    costs.sort()\n    \n    # Calculate the minimum cost to obtain exactly k unique subsequences\n    return sum(costs[:k])\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result and print it\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    # Initialize lists to store the left and right endpoints\n    lefts = [0] * n\n    rights = [0] * n\n    \n    for i in range(n):\n        lefts[i], rights[i] = segments[i]\n    \n    # Calculate the maximum and second maximum left endpoint\n    max_left = max(lefts)\n    second_max_left = -1\n    for l in lefts:\n        if l != max_left:\n            second_max_left = max(second_max_left, l)\n    \n    # Calculate the minimum and second minimum right endpoint\n    min_right = min(rights)\n    second_min_right = float('inf')\n    for r in rights:\n        if r != min_right:\n            second_min_right = min(second_min_right, r)\n    \n    # Calculate the maximum intersection length after removing each segment\n    max_length = 0\n    for i in range(n):\n        if lefts[i] == max_left:\n            current_left = second_max_left\n        else:\n            current_left = max_left\n        \n        if rights[i] == min_right:\n            current_right = second_min_right\n        else:\n            current_right = min_right\n        \n        # Calculate the intersection length\n        if current_left <= current_right:\n            max_length = max(max_length, current_right - current_left)\n    \n    return max_length\n\n# Example usage:\n# n = int(input())\n# segments = [tuple(map(int, input().split())) for _ in range(n)]\n# print(max_intersection_length(n, segments))\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n\n    if D >= n:\n        print(\"NO\")\n        return\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    degree = {i: 0 for i in range(1, n + 1)}\n    spanning_tree_edges = []\n    visited = set()\n    \n    # BFS to create a spanning tree\n    def bfs(start):\n        queue = deque([start])\n        visited.add(start)\n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if neighbor not in visited and degree[node] < D:\n                    visited.add(neighbor)\n                    spanning_tree_edges.append((node, neighbor))\n                    degree[node] += 1\n                    degree[neighbor] += 1\n                    queue.append(neighbor)\n                if degree[node] == D:\n                    break\n\n    bfs(1)\n\n    if degree[1] != D:\n        print(\"NO\")\n        return\n\n    # Add remaining edges to complete the spanning tree\n    for u in range(1, n + 1):\n        for v in graph[u]:\n            if degree[u] < 1 and degree[v] < 1 and (u, v) not in spanning_tree_edges and (v, u) not in spanning_tree_edges:\n                spanning_tree_edges.append((u, v))\n                degree[u] += 1\n                degree[v] += 1\n                if len(spanning_tree_edges) == n - 1:\n                    break\n        if len(spanning_tree_edges) == n - 1:\n            break\n\n    if len(spanning_tree_edges) == n - 1:\n        print(\"YES\")\n        for u, v in spanning_tree_edges:\n            print(u, v)\n    else:\n        print(\"NO\")\n\n# Example usage\n# n, m, D = map(int, input().split())\n# edges = [tuple(map(int, input().split())) for _ in range(m)]\n# find_spanning_tree(n, m, D, edges)\n```",
    "81": "```python\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\n# Sort strings by length\nstrings.sort(key=len)\n\n# Check if the ordering is valid\nfor i in range(1, n):\n    if strings[i-1] not in strings[i]:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")\n    print(\"\\n\".join(strings))\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Food consumption pattern based on the day of the week\n    food_pattern = [0, 1, 2, 0, 1, 2, 0]  # 0: fish, 1: rabbit, 2: chicken\n    max_days = 0\n    \n    # Try starting from each day of the week\n    for start_day in range(7):\n        fish = a\n        rabbit = b\n        chicken = c\n        days = 0\n        \n        # Simulate the days of the week\n        for i in range(7):\n            current_day = (start_day + i) % 7\n            if food_pattern[current_day] == 0:  # Fish food\n                if fish > 0:\n                    fish -= 1\n                    days += 1\n                else:\n                    break\n            elif food_pattern[current_day] == 1:  # Rabbit stew\n                if rabbit > 0:\n                    rabbit -= 1\n                    days += 1\n                else:\n                    break\n            else:  # Chicken stake\n                if chicken > 0:\n                    chicken -= 1\n                    days += 1\n                else:\n                    break\n        \n        # Add full weeks\n        full_weeks = min(fish // 3, rabbit // 2, chicken // 2)\n        days += full_weeks * 7\n        \n        # Update maximum days\n        max_days = max(max_days, days)\n    \n    return max_days\n\n# Input reading\na, b, c = map(int, input().split())\nprint(max_days(a, b, c))\n```",
    "76": "```python\ndef can_construct_square(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        top_left = set()\n        bottom_right = set()\n        \n        for tile in tiles:\n            top_left.add((tile[0][0], tile[1][1]))\n            bottom_right.add((tile[1][0], tile[0][1]))\n        \n        if any((a, b) in bottom_right for a, b in top_left):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Example usage\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = [tuple(tuple(map(int, input().split())) for _ in range(2)) for _ in range(n)]\n    test_cases.append((n, m, tiles))\n\nresults = can_construct_square(t, test_cases)\nfor result in results:\n    print(result)\n```",
    "82": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncount = 0\n\n# Solve from the left\nwhile count < n and a[count] <= k:\n    count += 1\n\n# Solve from the right\nwhile count < n and a[n - 1 - (count - 1)] <= k:\n    count += 1\n\n# Adjust for double counting the middle element if both ends are solvable\nif count > n:\n    count = n\n\nprint(count)\n```",
    "78": "```python\ndef count_regular_sequences(n, s):\n    MOD = 1000000007\n    m = len(s)\n\n    # Precompute the number of valid bracket sequences of length 2k\n    dp = [0] * (n + 1)\n    dp[0] = 1  # Base case: one way to have an empty sequence\n\n    for k in range(1, n + 1):\n        for j in range(k):\n            dp[k] = (dp[k] + dp[j] * dp[k - 1 - j]) % MOD\n\n    # Check if s can be part of a valid sequence\n    balance = 0\n    min_balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n\n    if balance < 0 or balance > n or min_balance < 0:\n        return 0\n\n    # Count the number of valid sequences that can be formed\n    total_count = 0\n    for prefix in range(n + 1):\n        if prefix + balance <= n:\n            suffix = n - (prefix + balance)\n            if suffix >= 0:\n                total_count = (total_count + dp[prefix] * dp[suffix]) % MOD\n\n    return total_count\n\n# Input reading\nn = int(input())\ns = input().strip()\nprint(count_regular_sequences(n, s))\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    # Create a list to store the color for each character\n    colors = [0] * n\n    # Create a mapping of characters to their last seen index\n    last_seen = {}\n    # Initialize the color counter\n    color_count = 0\n    \n    for i in range(n):\n        char = s[i]\n        if char in last_seen:\n            # If the character has been seen before, assign the same color\n            colors[i] = colors[last_seen[char]]\n        else:\n            # If it's a new character, increment the color count and assign a new color\n            color_count += 1\n            colors[i] = color_count\n        \n        # Update the last seen index for the character\n        last_seen[char] = i\n    \n    return color_count, colors\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult_count, result_colors = min_colors_to_sort(n, s)\n\n# Print the output\nprint(result_count)\nprint(' '.join(map(str, result_colors)))\n```",
    "85": "```python\ndef find_price(A, B):\n    for price in range(1, 10000):  # Arbitrarily chosen upper limit\n        tax_8 = price * 8 // 100\n        tax_10 = price * 10 // 100\n        if tax_8 == A and tax_10 == B:\n            return price\n    return -1\n\nA, B = map(int, input().split())\nresult = find_price(A, B)\nprint(result)\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    unique_subsequences = set()\n    \n    # Generate all possible subsequences\n    for i in range(1 << n):\n        subsequence = []\n        for j in range(n):\n            if i & (1 << j):\n                subsequence.append(s[j])\n        unique_subsequences.add(''.join(subsequence))\n    \n    # If we cannot obtain k unique subsequences\n    if len(unique_subsequences) < k:\n        return -1\n    \n    # Calculate the minimum cost\n    costs = []\n    for subseq in unique_subsequences:\n        cost = n - len(subseq)\n        costs.append(cost)\n    \n    # Sort costs and take the k smallest\n    costs.sort()\n    return sum(costs[:k])\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result and print it\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "84": "```python\nn = int(input())\ns = input()\n\n# Create a list to store the color assignments\ncolor = ['0'] * n\n\n# Create a list to track the last seen index of each character\nlast_seen = {}\n\n# Iterate through the string\nfor i in range(n):\n    char = s[i]\n    if char in last_seen:\n        # If the character has been seen before, we need to check the last index\n        last_index = last_seen[char]\n        # If the last index is colored differently, we can't sort it\n        if color[last_index] == color[i]:\n            print(\"NO\")\n            exit()\n    # Update the last seen index for the character\n    last_seen[char] = i\n    # Alternate colors for different characters\n    color[i] = '0' if color[i-1] == '1' else '1' if i > 0 else '0'\n\nprint(\"YES\")\nprint(''.join(color))\n```",
    "86": "```python\ndef solve_problems(n, k):\n    # Minimum sum of problems needed to satisfy the conditions\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n    \n    # Start with the minimum valid array\n    a = list(range(1, k + 1))\n    current_sum = sum(a)\n    \n    # Distribute the remaining problems\n    remaining = n - current_sum\n    \n    for i in range(k - 1, -1, -1):\n        # Maximum we can add to a[i] while maintaining the conditions\n        max_add = min(remaining, 2 * a[i] - a[i - 1] if i > 0 else remaining)\n        a[i] += max_add\n        remaining -= max_add\n        if remaining <= 0:\n            break\n    \n    if remaining > 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n\n# Example usage\nn, k = map(int, input().split())\nsolve_problems(n, k)\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects by their required rating\n    projects.sort(key=lambda x: x[0])\n    \n    for a, b in projects:\n        if r < a:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if all projects can be completed\nresult = can_complete_projects(n, r, projects)\nprint(result)\n```",
    "92": "```python\nx = float(input().strip())\n\n# We need to find two integers a and b such that 1 <= a, b <= 10\n# and a * b is approximately equal to x\n\n# Initialize the output variables\na, b = 1, 1\n\n# Iterate through possible values for a and b\nfor i in range(1, 11):\n    for j in range(1, 11):\n        if abs(i * j - x) < 1e-6:  # Check if the product is close to x\n            a, b = i, j\n            break\n    else:\n        continue\n    break\n\nprint(a, b)\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    min_moves = float('inf')\n\n    # Check for pairs of digits that can form 25 or 00\n    for target in ['00', '25', '50', '75']:\n        last_digit = target[1]\n        second_last_digit = target[0]\n        \n        # Find the last occurrence of the last_digit\n        last_index = -1\n        for i in range(length - 1, -1, -1):\n            if s[i] == last_digit:\n                last_index = i\n                break\n        \n        if last_index == -1:\n            continue  # If last_digit is not found, skip\n        \n        # Now find the second_last_digit before last_index\n        second_last_index = -1\n        for i in range(last_index - 1, -1, -1):\n            if s[i] == second_last_digit:\n                second_last_index = i\n                break\n        \n        if second_last_index == -1:\n            continue  # If second_last_digit is not found, skip\n        \n        # Calculate moves needed to bring second_last_digit to second_last_index\n        moves = (last_index - second_last_index) + (length - 1 - last_index)\n        min_moves = min(min_moves, moves)\n\n    return min_moves if min_moves != float('inf') else -1\n\n# Example usage:\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n    \n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            # Check both orientations\n            for w, h in [(width, height), (height, width)]:\n                # Calculate perimeter\n                perimeter = 2 * (w + h)\n                \n                # Check if we can fit red and blue rectangles\n                if (a <= w * h) and (b <= w * h):\n                    # Check if we can form rectangles for both colors\n                    for red_width in range(1, w + 1):\n                        if a % red_width == 0:\n                            red_height = a // red_width\n                            if red_height <= h:\n                                min_perimeter = min(min_perimeter, perimeter)\n                                break\n                    for blue_width in range(1, w + 1):\n                        if b % blue_width == 0:\n                            blue_height = b // blue_width\n                            if blue_height <= h:\n                                min_perimeter = min(min_perimeter, perimeter)\n                                break\n\n    return min_perimeter\n\n# Read input\na, b = map(int, input().split())\nprint(minimal_perimeter(a, b))\n```",
    "90": "```python\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculate the total length of platforms\ntotal_length = sum(c)\n\n# If the maximum jump distance is greater than or equal to the width of the river, we can always reach the other side\nif d >= n + 1:\n    print(\"YES\")\n    print(\"0 \" + \" \".join(str(1) for _ in range(c[0])) + \" \" + \"0 \" * (n - total_length) + \" \" + \" \".join(str(i + 2) for i in range(1, m)))\n    exit()\n\n# Check if we can fit the platforms within the jump distance constraints\npositions = []\ncurrent_position = 1  # Start placing platforms from position 1\n\nfor i in range(m):\n    positions.append(current_position)\n    current_position += c[i]\n\n# Check if the last platform can be reached from the last position\nif positions[-1] - 1 > d:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    result = [0] * n\n    current_position = 0\n    for i in range(m):\n        for j in range(c[i]):\n            result[current_position] = i + 1\n            current_position += 1\n        if i < m - 1:\n            current_position += 1  # Leave a gap of at least 1 cell between platforms\n    print(\" \".join(map(str, result)))\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects by their required rating\n    projects.sort(key=lambda x: x[0])\n    \n    count = 0\n    current_rating = r\n    \n    # First, complete all projects that can be done without going negative\n    for a, b in projects:\n        if current_rating >= a:\n            current_rating += b\n            if current_rating < 0:\n                break\n            count += 1\n            \n    # Now we need to check if we can complete more projects by skipping some\n    # We will use a greedy approach to try to maximize the number of projects\n    completed_projects = []\n    \n    for a, b in projects:\n        if current_rating >= a:\n            completed_projects.append((a, b))\n            current_rating += b\n            \n    # If we have completed projects, we can try to complete more by considering negative b values\n    completed_projects.sort(key=lambda x: x[1])  # Sort by rating change\n    \n    for a, b in completed_projects:\n        if current_rating >= a:\n            current_rating += b\n            if current_rating < 0:\n                break\n            count += 1\n            \n    return count\n\n# Read input\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = max_projects(n, r, projects)\nprint(result)\n```",
    "97": "```python\ndef min_coins_to_move_chips(n, positions):\n    odd_count = sum(1 for x in positions if x % 2 != 0)\n    even_count = n - odd_count\n    return min(odd_count, even_count)\n\nn = int(input())\npositions = list(map(int, input().split()))\nprint(min_coins_to_move_chips(n, positions))\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1 or (d == 1 and n > 2) or (n > k + 1 and d == 1):\n        print(\"NO\")\n        return\n    \n    edges = []\n    \n    # Create the main path of length d\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n    \n    # Now we have d + 1 vertices in the main path\n    current_vertex = d + 2\n    \n    # Attach remaining vertices to the first vertex in the path\n    for i in range(1, n - (d + 1) + 1):\n        if i <= k - 1:\n            edges.append((1, current_vertex))\n            current_vertex += 1\n        else:\n            edges.append((2, current_vertex))\n            current_vertex += 1\n    \n    print(\"YES\")\n    for u, v in edges:\n        print(u, v)\n\n# Read input\nn, d, k = map(int, input().split())\nconstruct_tree(n, d, k)\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n    \n    # Create arrays to store the first occurrences of t in s\n    left = [0] * m\n    right = [0] * m\n    \n    # Fill left array\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n    \n    # Fill right array\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n    \n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n    \n    # Consider removing from the start or end\n    max_length = max(max_length, right[0])  # Remove from the start\n    max_length = max(max_length, n - 1 - left[m - 1])  # Remove from the end\n    \n    return max_length\n\n# Example usage:\ns = input().strip()\nt = input().strip()\nprint(max_removable_length(s, t))\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Initialize the binary string\n    s = []\n    \n    # Determine the starting character based on the counts of a and b\n    if a > b:\n        s.append('0')\n        a -= 1\n    else:\n        s.append('1')\n        b -= 1\n    \n    # We need to create x transitions\n    transitions = x\n    \n    # Create the alternating pattern\n    while transitions > 0:\n        if s[-1] == '0':\n            s.append('1')\n            b -= 1\n        else:\n            s.append('0')\n            a -= 1\n        transitions -= 1\n    \n    # Fill the remaining characters\n    while a > 0:\n        s.append('0')\n        a -= 1\n    while b > 0:\n        s.append('1')\n        b -= 1\n    \n    # Join the list into a string and return\n    return ''.join(s)\n\n# Read input\na, b, x = map(int, input().split())\n# Print the result\nprint(construct_binary_string(a, b, x))\n```",
    "98": "```python\ndef min_moves_to_n(N):\n    moves = float('inf')\n    \n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            moves = min(moves, (i - 1) + (j - 1))\n    \n    return moves\n\nN = int(input())\nprint(min_moves_to_n(N))\n```",
    "99": "```python\ndef rock_paper_scissors(n, a, b):\n    a1, a2, a3 = a  # Alice's counts for rock, scissors, paper\n    b1, b2, b3 = b  # Bob's counts for rock, scissors, paper\n\n    # Maximum wins for Alice\n    max_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n\n    # Minimum wins for Alice\n    # Calculate losses for Alice\n    alice_losses = max(0, b1 - a3) + max(0, b2 - a1) + max(0, b3 - a2)\n    min_wins = n - alice_losses\n\n    return min_wins, max_wins\n\n# Example usage:\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nresult = rock_paper_scissors(n, a, b)\nprint(result[0], result[1])\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Count of each character\n    count_a = count_b = count_c = n\n    \n    # Create a list to hold the result\n    res = []\n    \n    # Function to check if the last two characters form a forbidden substring\n    def is_forbidden():\n        return len(res) >= 2 and (res[-1] + res[-2] == s or res[-1] + res[-2] == t)\n    \n    # Build the result string\n    for _ in range(3 * n):\n        for char in 'abc':\n            if char == 'a' and count_a > 0:\n                res.append(char)\n                count_a -= 1\n                if not is_forbidden():\n                    break\n                res.pop()  # Backtrack\n                count_a += 1\n            elif char == 'b' and count_b > 0:\n                res.append(char)\n                count_b -= 1\n                if not is_forbidden():\n                    break\n                res.pop()  # Backtrack\n                count_b += 1\n            elif char == 'c' and count_c > 0:\n                res.append(char)\n                count_c -= 1\n                if not is_forbidden():\n                    break\n                res.pop()  # Backtrack\n                count_c += 1\n        else:\n            # If we couldn't add any character, it's impossible\n            return \"NO\"\n    \n    return \"YES\\n\" + ''.join(res)\n\n# Read input\nn = int(input())\ns = input().strip()\nt = input().strip()\n\n# Generate the result\nresult = generate_string(n, s, t)\nprint(result)\n```",
    "88": "```python\ndef create_palindromic_matrix(n, numbers):\n    from collections import Counter\n    \n    count = Counter(numbers)\n    \n    # Check for the number of odd occurrences\n    odd_count = sum(1 for v in count.values() if v % 2 != 0)\n    \n    # For odd n, we can have at most one odd count, for even n, we cannot have any\n    if (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n        return \"NO\"\n    \n    # Create the matrix\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Fill the matrix\n    half_n = (n + 1) // 2\n    idx = 0\n    for num, freq in count.items():\n        for _ in range(freq // 2):\n            matrix[idx // n][idx % n] = num\n            matrix[n - 1 - (idx // n)][n - 1 - (idx % n)] = num\n            idx += 1\n            \n    # Fill the center for odd n\n    if n % 2 == 1:\n        for num, freq in count.items():\n            if freq % 2 == 1:\n                matrix[half_n - 1][half_n - 1] = num\n                break\n    \n    # Fill the remaining cells for even n\n    for i in range(half_n):\n        for j in range(half_n):\n            if matrix[i][j] == 0:\n                for num, freq in count.items():\n                    if freq > 0:\n                        matrix[i][j] = num\n                        matrix[i][n - 1 - j] = num\n                        matrix[n - 1 - i][j] = num\n                        matrix[n - 1 - i][n - 1 - j] = num\n                        count[num] -= 4\n                        break\n    \n    return \"YES\", matrix\n\nn = int(input())\nnumbers = list(map(int, input().split()))\n\nresult = create_palindromic_matrix(n, numbers)\n\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for row in result[1]:\n        print(\" \".join(map(str, row)))\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    # Initialize the permutation array\n    p = [0] * n\n    \n    # Set the first element of p\n    p[0] = 1  # We can start with any number, let's start with 1\n    \n    # Calculate the rest of the elements based on q\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n    \n    # Check if the permutation is valid\n    if len(set(p)) != n or any(x < 1 or x > n for x in p):\n        print(-1)\n    else:\n        print(' '.join(map(str, p)))\n\n# Example usage:\n# n = 3\n# q = [-2, 1]\n# restore_permutation(n, q)\n```"
}