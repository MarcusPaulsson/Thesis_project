{
    "2": "```python\nn = int(input())\n\ndef is_lucky(year):\n    non_zero_digits = [digit for digit in str(year) if digit != '0']\n    return len(non_zero_digits) <= 1\n\nnext_year = n + 1\nwhile not is_lucky(next_year):\n    next_year += 1\n\nprint(next_year - n)\n```",
    "10": "```python\nn = int(input())\n\n# Calculate the maximum days off\nmax_days_off = (n // 7) * 2 + min(2, n % 7)\n\n# Calculate the minimum days off\nif n < 5:\n    min_days_off = 0\nelse:\n    min_days_off = (n // 7) * 2\n\nprint(min_days_off, max_days_off)\n```",
    "7": "```python\ndef find_empty_day(n, m):\n    day = 0\n    total_sparrows = 0\n    while n > 0:\n        day += 1\n        total_sparrows += day\n        n = min(n + m, n) - total_sparrows\n    return day\n\nn, m = map(int, input().split())\nprint(find_empty_day(n, m))\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    \n    for query in queries:\n        n, x, blows = query\n        min_blows = float('inf')\n        \n        # Check all blow types\n        for d, h in blows:\n            if d >= x:\n                # If we can defeat Zmei Gorynich in one blow\n                min_blows = min(min_blows, 1)\n            else:\n                # Calculate the effective damage and growth\n                effective_damage = d - h\n                if effective_damage > 0:\n                    # Calculate the number of blows needed\n                    blows_needed = (x - d + effective_damage - 1) // effective_damage + 1\n                    min_blows = min(min_blows, blows_needed)\n        \n        results.append(min_blows if min_blows != float('inf') else -1)\n    \n    return results\n\n# Input reading\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\n# Get results\nresults = min_blows_to_defeat_zmei(t, queries)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "1": "```python\ndef max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n    \n    # Start with the original number\n    max_sum = sum(int(d) for d in str_x)\n    best_number = x\n    \n    # Try to create numbers by reducing digits\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit by 1 and setting all following digits to 9\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        new_number = int(new_number)\n        \n        if new_number > 0 and new_number <= x:\n            current_sum = sum(int(d) for d in str(new_number))\n            if (current_sum > max_sum) or (current_sum == max_sum and new_number > best_number):\n                max_sum = current_sum\n                best_number = new_number\n    \n    return best_number\n\nx = int(input().strip())\nprint(max_digit_sum(x))\n```",
    "0": "```python\ndef max_acordion_length(s):\n    n = len(s)\n    left_bracket = -1\n    right_bracket = -1\n    colon_count = 0\n    vertical_lines = 0\n\n    # Find the first opening bracket\n    for i in range(n):\n        if s[i] == '[':\n            left_bracket = i\n            break\n\n    # If no opening bracket found\n    if left_bracket == -1:\n        return -1\n\n    # Find the last closing bracket\n    for i in range(n - 1, -1, -1):\n        if s[i] == ']':\n            right_bracket = i\n            break\n\n    # If no closing bracket found\n    if right_bracket == -1 or right_bracket <= left_bracket:\n        return -1\n\n    # Count colons and vertical lines between the brackets\n    for i in range(left_bracket + 1, right_bracket):\n        if s[i] == ':':\n            colon_count += 1\n        elif s[i] == '|':\n            vertical_lines += 1\n\n    # We need exactly 2 colons for a valid accordion\n    if colon_count < 2:\n        return -1\n\n    # The maximum length of the accordion\n    return 4 + vertical_lines  # 4 for [::] + vertical lines\n\n# Read input\ns = input().strip()\n# Output the result\nprint(max_acordion_length(s))\n```",
    "5": "```python\nn, pos, l, r = map(int, input().split())\n\nif l == 1 and r == n:\n    print(0)\nelse:\n    moves = 0\n    if pos < l:\n        moves += l - pos  # Move to the leftmost tab to close\n        moves += (r - l + 1)  # Close all tabs to the right\n    elif pos > r:\n        moves += pos - r  # Move to the rightmost tab to close\n        moves += (r - l + 1)  # Close all tabs to the left\n    else:\n        # pos is between l and r\n        left_moves = (pos - l) + (r - l + 1)  # Move to l and close left\n        right_moves = (r - pos) + (r - l + 1)  # Move to r and close right\n        moves = min(left_moves, right_moves)\n    \n    print(moves)\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    # Create a list to keep track of painted sections\n    painted = [0] * (n + 1)\n\n    # Function to calculate the number of painted sections with a given set of painters\n    def calculate_painted(painter_indices):\n        temp_painted = [0] * (n + 1)\n        for i in painter_indices:\n            l, r = painters[i]\n            for j in range(l, r + 1):\n                temp_painted[j] = 1\n        return sum(temp_painted)\n\n    max_sections = 0\n\n    # Try removing each pair of painters\n    for i in range(q):\n        for j in range(i + 1, q):\n            # Get the indices of the remaining painters\n            remaining_painters = [k for k in range(q) if k != i and k != j]\n            painted_sections = calculate_painted(remaining_painters)\n            max_sections = max(max_sections, painted_sections)\n\n    return max_sections\n\n# Input reading\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output the result\nprint(max_painted_sections(n, q, painters))\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    count_red = n // a\n    count_blue = n // b\n    count_both = n // (a * b // gcd(a, b))\n    \n    # Calculate chocolates\n    chocolates = (count_red - count_both) * p + (count_blue - count_both) * q + count_both * max(p, q)\n    \n    return chocolates\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n# Input\nn, a, b, p, q = map(int, input().split())\n# Output\nprint(max_chocolates(n, a, b, p, q))\n```",
    "16": "```python\ncnt1 = int(input())\ncnt2 = int(input())\ncnt3 = int(input())\ncnt4 = int(input())\n\n# Check the conditions for forming a regular bracket sequence\nif cnt1 + cnt2 >= cnt3 + cnt4 and cnt3 <= cnt1 + cnt2:\n    print(1)\nelse:\n    print(0)\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelif t <= n + k:\n    print(n + k - t)\n\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "18": "```python\ndef lexicographically_minimal_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        while t and (not u or t[-1] <= u[-1]):\n            u.append(t.pop())\n    \n    return ''.join(u)\n\n# Read input\ns = input().strip()\n# Get the result\nresult = lexicographically_minimal_string(s)\n# Print the result\nprint(result)\n```",
    "9": "```python\nd = int(input())\nn, m = map(int, input().split())\nsofas = []\n\nfor i in range(d):\n    x1, y1, x2, y2 = map(int, input().split())\n    sofas.append((x1, y1, x2, y2))\n\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\ndef count_sofas(sofas, x1, y1, x2, y2):\n    left = right = top = bottom = 0\n    for (sx1, sy1, sx2, sy2) in sofas:\n        if sx1 == sx2:  # vertical sofa\n            if sy1 < y1:  # sofa is to the left\n                left += 1\n            elif sy1 > y2:  # sofa is to the right\n                right += 1\n            if sx1 < x1:  # sofa is above\n                top += 1\n            elif sx1 > x2:  # sofa is below\n                bottom += 1\n        else:  # horizontal sofa\n            if sx1 < x1:  # sofa is above\n                top += 1\n            elif sx1 > x2:  # sofa is below\n                bottom += 1\n            if sy1 < y1:  # sofa is to the left\n                left += 1\n            elif sy1 > y2:  # sofa is to the right\n                right += 1\n    return left, right, top, bottom\n\nfor i in range(d):\n    x1, y1, x2, y2 = sofas[i]\n    left, right, top, bottom = count_sofas(sofas[:i] + sofas[i+1:], x1, y1, x2, y2)\n    if left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b:\n        print(i + 1)\n        break\nelse:\n    print(-1)\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    max_length = 0\n    current_length = 0\n    segments = []\n    \n    # Count segments of golden trophies\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n                max_length = max(max_length, current_length)\n            current_length = 0\n            \n    if current_length > 0:\n        segments.append(current_length)\n        max_length = max(max_length, current_length)\n    \n    # If there are no golden trophies\n    if not segments:\n        return 0\n    \n    # If there is only one segment of golden trophies\n    if len(segments) == 1:\n        return segments[0]\n    \n    # Calculate the maximum possible length after one swap\n    max_possible_length = max_length\n    for i in range(len(segments) - 1):\n        # Check if we can swap a silver trophy between two segments\n        max_possible_length = max(max_possible_length, segments[i] + segments[i + 1])\n    \n    # We can also consider the case of adding one more golden trophy if we have at least one silver trophy\n    if 'S' in trophies:\n        max_possible_length += 1\n    \n    return max_possible_length\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\n\n# Output the result\nprint(max_beauty_after_swap(n, trophies))\n```",
    "23": "```python\nfrom itertools import permutations\n\na = input().strip()\nb = input().strip()\n\n# Generate all unique permutations of the digits of a\nperms = sorted(set(''.join(p) for p in permutations(a)), reverse=True)\n\n# Find the maximum permutation that is less than or equal to b\nfor perm in perms:\n    if perm <= b:\n        print(perm)\n        break\n```",
    "19": "```python\ndef check_records(test_cases):\n    results = []\n    for case in test_cases:\n        n, stats = case\n        valid = True\n        for i in range(n):\n            p, c = stats[i]\n            if i > 0:\n                prev_p, prev_c = stats[i - 1]\n                if p < prev_p or c < prev_c or (c - prev_c) > (p - prev_p):\n                    valid = False\n                    break\n            if c > p:\n                valid = False\n                break\n        results.append(\"YES\" if valid else \"NO\")\n    return results\n\n# Input reading\nT = int(input())\ntest_cases = []\nfor _ in range(T):\n    n = int(input())\n    stats = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, stats))\n\n# Check records and print results\nresults = check_records(test_cases)\nfor result in results:\n    print(result)\n```",
    "8": "```python\ndef min_draws_to_win(tiles):\n    from collections import defaultdict\n\n    # Parse the input tiles\n    hand = tiles.split()\n    suits = defaultdict(list)\n\n    for tile in hand:\n        num = int(tile[0])\n        suit = tile[1]\n        suits[suit].append(num)\n\n    # Check for koutsu (triplet)\n    for suit in suits:\n        if len(suits[suit]) == 3 and suits[suit].count(suits[suit][0]) == 3:\n            return 0\n\n    # Check for shuntsu (sequence)\n    for suit in suits:\n        nums = sorted(suits[suit])\n        if len(nums) >= 3:\n            for i in range(len(nums) - 2):\n                if nums[i] + 1 == nums[i + 1] and nums[i] + 2 == nums[i + 2]:\n                    return 0\n\n    # Check for possible shuntsu with one draw\n    for suit in suits:\n        nums = sorted(suits[suit])\n        if len(nums) == 2:\n            # Check if we can form a sequence with one draw\n            if (nums[0] + 1 == nums[1]) or (nums[0] + 2 == nums[1]) or (nums[1] - 1 == nums[0]) or (nums[1] - 2 == nums[0]):\n                return 1\n            if (nums[0] == 1 and nums[1] == 2) or (nums[0] == 2 and nums[1] == 3):\n                return 1\n        elif len(nums) == 1:\n            # Check if we can form a sequence with one draw\n            if nums[0] > 1 and nums[0] < 9:\n                return 1\n            elif nums[0] == 1 or nums[0] == 9:\n                return 1\n\n    # If we have no pairs or sequences, we need at least 2 draws\n    return 2\n\n# Read input\ntiles = input().strip()\n# Output the result\nprint(min_draws_to_win(tiles))\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror_chars = {'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M', 'O': 'O', 'p': 'q', 'q': 'p', 'R': 'R', 'S': 'S', 'T': 'T', 'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X', 'Y': 'Y', 'o': 'o', 'x': 'x'}\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        if s[i] not in mirror_chars or s[n - 1 - i] != mirror_chars[s[i]]:\n            print(\"NIE\")\n            return\n    print(\"TAK\")\n\ns = input().strip()\nis_s_palindrome(s)\n```",
    "14": "```python\ndef is_stack_sortable(n, k, p):\n    # Create a set for the given elements\n    given_set = set(p)\n    \n    # Create the remaining elements\n    remaining = [i for i in range(1, n + 1) if i not in given_set]\n    \n    # Initialize the result with the first k elements\n    result = p[:]\n    \n    # Initialize a stack\n    stack = []\n    \n    # We will iterate through the given elements\n    for i in range(k):\n        # If the stack is not empty and the top of the stack is less than the next element\n        while stack and stack[-1] < result[i]:\n            result.append(stack.pop())\n        \n        # Push the current element onto the stack\n        stack.append(result[i])\n    \n    # Now we need to add the remaining elements in a way that keeps the stack sortable\n    for num in sorted(remaining, reverse=True):\n        while stack and stack[-1] < num:\n            result.append(stack.pop())\n        stack.append(num)\n    \n    # Finally, pop all remaining elements from the stack\n    while stack:\n        result.append(stack.pop())\n    \n    # Check if the result is a valid permutation\n    if len(result) != n or len(set(result)) != n:\n        return -1\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result\nresult = is_stack_sortable(n, k, p)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "27": "```python\nn = int(input())\ns = input()\n\nmin_operations = n  # Start with the assumption that we type all characters one by one\n\n# Check for all possible prefixes to copy\nfor i in range(1, n):\n    prefix = s[:i]\n    if s.startswith(prefix, i):  # Check if the string can be formed by prefix + remaining\n        # Operations: type prefix (i) + copy (1) + type remaining (n - 2*i)\n        operations = i + 1 + (n - 2 * i)\n        min_operations = min(min_operations, operations)\n\nprint(min_operations)\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return minutes_passed\n\ntime_input = input().strip()\nhh, mm = map(int, time_input.split(':'))\nresult = next_palindrome_time(hh, mm)\nprint(result)\n```",
    "24": "```python\ndef can_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # vertical, horizontal, diagonal, anti-diagonal\n    n = 10\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                # Temporarily place 'X' in the empty cell\n                board[i][j] = 'X'\n                \n                for dx, dy in directions:\n                    count = 1\n                    \n                    # Check in the positive direction\n                    x, y = i + dx, j + dy\n                    while 0 <= x < n and 0 <= y < n and board[x][y] == 'X':\n                        count += 1\n                        x += dx\n                        y += dy\n                    \n                    # Check in the negative direction\n                    x, y = i - dx, j - dy\n                    while 0 <= x < n and 0 <= y < n and board[x][y] == 'X':\n                        count += 1\n                        x -= dx\n                        y -= dy\n                    \n                    if count >= 5:\n                        return 'YES'\n                \n                # Remove the temporary 'X'\n                board[i][j] = '.'\n\n    return 'NO'\n\n# Read input\nboard = [input().strip() for _ in range(10)]\nprint(can_win(board))\n```",
    "30": "```python\ndef min_traps(m, x):\n    # Since GCD(x, m) = 1, x is coprime to m\n    # The number of distinct rooms visited is equal to m - 1\n    # The number of traps needed is equal to the number of distinct rooms visited\n    # which is m - 1, plus one for room 0.\n    return m\n\nm, x = map(int, input().split())\nprint(min_traps(m, x))\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    if k > n * (n + 1) // 2:\n        return -1\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k <= 0:\n            break\n        for j in range(i, n):\n            if k <= 0:\n                break\n            if i == j:\n                if k >= 1:\n                    matrix[i][j] = 1\n                    k -= 1\n            else:\n                if k >= 2:\n                    matrix[i][j] = 1\n                    matrix[j][i] = 1\n                    k -= 2\n    \n    if k > 0:\n        return -1\n    \n    return matrix\n\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    left, right = 0, min(a, b) + 1\n    \n    while left < right:\n        mid = (left + right + 1) // 2\n        if (a // mid) + (b // mid) >= n:\n            left = mid\n        else:\n            right = mid - 1\n            \n    return left\n\n# Read input\nn, a, b = map(int, input().split())\n# Calculate and print the result\nprint(max_min_pieces(n, a, b))\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    # Calculate the difference\n    diff = abs(sum_first - sum_second)\n    \n    # Create a list of possible changes\n    changes = []\n    if sum_first > sum_second:\n        # We need to decrease the first half or increase the second half\n        changes = [9 - digit for digit in first_half] + [digit for digit in second_half]\n    else:\n        # We need to decrease the second half or increase the first half\n        changes = [digit for digit in first_half] + [9 - digit for digit in second_half]\n    \n    # Sort changes in descending order\n    changes.sort(reverse=True)\n    \n    # Calculate the minimum number of replacements\n    replacements = 0\n    for change in changes:\n        diff -= change\n        replacements += 1\n        if diff <= 0:\n            break\n    \n    return replacements\n\n# Input\nticket = input().strip()\n# Output\nprint(min_replacements_to_lucky(ticket))\n```",
    "32": "```python\nn = int(input())\ncurrent_position = 0  # Position in kilometers from the North Pole (0 to 20000)\n\nvalid = True\n\nfor _ in range(n):\n    t, direction = input().split()\n    t = int(t)\n\n    if direction == \"South\":\n        if current_position == 20000:  # At South Pole\n            valid = False\n        current_position += t\n    elif direction == \"North\":\n        if current_position == 0:  # At North Pole\n            valid = False\n        current_position -= t\n    elif direction in [\"West\", \"East\"]:\n        # Moving West or East does not change the position in terms of North/South\n        pass\n\n    # Check if current position is out of bounds\n    if current_position < 0 or current_position > 20000:\n        valid = False\n\n# Final position must be at the North Pole\nif current_position != 0:\n    valid = False\n\nprint(\"YES\" if valid else \"NO\")\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef main():\n    n, k = map(int, input().split())\n    main_courses = list(map(int, input().split()))\n    \n    # Adjust for 0-based indexing\n    main_courses = [x - 1 for x in main_courses]\n    \n    dependencies = defaultdict(list)\n    in_degree = [0] * n\n    \n    for i in range(n):\n        data = list(map(int, input().split()))\n        t_i = data[0]\n        for dep in data[1:t_i + 1]:\n            dependencies[dep - 1].append(i)\n            in_degree[i] += 1\n    \n    # Queue for courses that can be taken (in-degree 0)\n    queue = deque()\n    for i in range(n):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    order = []\n    taken_courses = set()\n    \n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        taken_courses.add(course)\n        \n        for dependent in dependencies[course]:\n            in_degree[dependent] -= 1\n            if in_degree[dependent] == 0:\n                queue.append(dependent)\n    \n    # Check if we can take all main courses\n    if not all(course in taken_courses for course in main_courses):\n        print(-1)\n        return\n    \n    # We need to pass all main courses and their dependencies\n    result = []\n    for course in order:\n        result.append(course + 1)  # Adjust back to 1-based indexing\n        if course in main_courses:\n            main_courses.remove(course)\n            if not main_courses:\n                break\n    \n    # Add any remaining courses that are not main but are taken\n    result = list(dict.fromkeys(result))  # Remove duplicates while preserving order\n    print(len(result))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    m0, x0, x1 = m, 0, 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef birthday_paradox(n, k):\n    MOD = 1000003\n    days = 1 << n  # 2^n\n    if k > days:\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the probability of no collision\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator *= (days - i)\n        denominator *= days\n        numerator %= MOD\n        denominator %= MOD\n\n    # Probability of at least one collision\n    A = (denominator - numerator) % MOD\n    B = denominator\n\n    # Reduce A/B to its irreducible form\n    common_gcd = gcd(A, B)\n    A //= common_gcd\n    B //= common_gcd\n\n    return A % MOD, B % MOD\n\n# Read input\nn, k = map(int, input().split())\nA, B = birthday_paradox(n, k)\nprint(A, B)\n```",
    "35": "```python\ndef is_valid_flag(n, m, field):\n    colors = set()\n    stripes = []\n    \n    # Check for horizontal stripes\n    current_color = field[0][0]\n    current_height = 0\n    \n    for i in range(n):\n        if field[i][0] != current_color:\n            if current_color in colors:\n                return \"NO\"\n            colors.add(current_color)\n            stripes.append((current_color, current_height))\n            current_color = field[i][0]\n            current_height = 1\n        else:\n            current_height += 1\n            \n    # Add the last stripe\n    if current_color in colors:\n        return \"NO\"\n    colors.add(current_color)\n    stripes.append((current_color, current_height))\n    \n    if len(colors) != 3 or len(stripes) != 3:\n        return \"NO\"\n    \n    # Check if all stripes have the same width\n    for color, height in stripes:\n        if height * m != n:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Output result\nprint(is_valid_flag(n, m, field))\n```",
    "36": "```python\ndef hexagonal_coordinates(n):\n    if n == 0:\n        return (0, 0)\n    \n    layer = 0\n    moves_in_layer = 6 * layer\n    \n    while n > moves_in_layer:\n        n -= moves_in_layer\n        layer += 1\n        moves_in_layer = 6 * layer\n    \n    # The coordinates for the starting point of the layer\n    x, y = layer, 0\n    \n    # The number of steps to move in the current layer\n    steps = n\n    \n    # Determine the direction and move accordingly\n    for direction in range(6):\n        if steps <= direction + 1:\n            if direction == 0:\n                x += steps\n                break\n            elif direction == 1:\n                x -= 1\n                y += steps\n                break\n            elif direction == 2:\n                x -= 1\n                y -= steps\n                break\n            elif direction == 3:\n                x += steps\n                y -= 1\n                break\n            elif direction == 4:\n                x += 1\n                y -= steps\n                break\n            elif direction == 5:\n                x += 1\n                y += steps\n                break\n        steps -= direction + 1\n    \n    return (x, y)\n\nn = int(input().strip())\nx, y = hexagonal_coordinates(n)\nprint(x, y)\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ns = input().strip()\n\nif not is_palindrome(s):\n    print(len(s))\nelse:\n    # Check for the longest non-palindrome substring\n    n = len(s)\n    if len(set(s)) == 1:  # All characters are the same\n        print(0)\n    else:\n        print(n - 1)  # The longest non-palindrome substring can be obtained by removing one character\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = []\nregulars = []\n\nfor name, type_ in files:\n    if type_ == '1':\n        examples.append(name)\n    else:\n        regulars.append(name)\n\nmoves = []\ne = len(examples)\n\n# Rename examples to 1, 2, ..., e\nfor i in range(e):\n    moves.append(f\"move {examples[i]} {i + 1}\")\n\n# Rename regular tests to e + 1, e + 2, ..., n\nfor i in range(len(regulars)):\n    moves.append(f\"move {regulars[i]} {e + i + 1}\")\n\nprint(len(moves))\nprint(\"\\n\".join(moves))\n```",
    "41": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the distance array with a large value\ndistances = [float('inf')] * n\n\n# First pass: from left to right\nfor i in range(n):\n    if a[i] == 0:\n        distances[i] = 0\n    elif i > 0:\n        distances[i] = distances[i - 1] + 1\n\n# Second pass: from right to left\nfor i in range(n - 1, -1, -1):\n    if a[i] == 0:\n        distances[i] = 0\n    elif i < n - 1:\n        distances[i] = min(distances[i], distances[i + 1] + 1)\n\nprint(' '.join(map(str, distances)))\n```",
    "38": "```python\ndef can_be_same_track(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between consecutive barriers for Kefa\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    # Calculate the distances between consecutive barriers for Sasha\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Check if Kefa's differences can be rotated to match Sasha's differences\n    for i in range(n):\n        if kefa_diffs[i:] + kefa_diffs[:i] == sasha_diffs:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_be_same_track(n, L, kefa_distances, sasha_distances))\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n\n    len_s = len(s)\n    total_count = 0\n    seen = set()\n\n    # Generate all binary strings of length n\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        # Check if s is a substring in any cyclic shift of t\n        if any(s in t[i:] + t[:i] for i in range(n)):\n            # Add the cyclic string to the set to ensure uniqueness\n            seen.add(t)\n\n    return len(seen)\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_cyclic_strings(n, s))\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if any rating has changed\nrated = any(a != b for a, b in ratings)\n\nif rated:\n    print(\"rated\")\nelse:\n    # Check if the standings are in non-increasing order of the initial ratings\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            print(\"unrated\")\n            break\n    else:\n        print(\"maybe\")\n```",
    "33": "```python\ndef count_integers(a1, b1, a2, b2, L, R):\n    from math import gcd\n\n    # Calculate the step size and the offset\n    step = abs(a1 * a2 // gcd(a1, a2))\n    \n    # Find the first valid x in the range [L, R]\n    def first_valid_x():\n        for k in range((L - b1 + a1 - 1) // a1, (R - b1) // a1 + 1):\n            x = a1 * k + b1\n            if L <= x <= R:\n                return x\n        return None\n\n    # Find the last valid x in the range [L, R]\n    def last_valid_x():\n        for k in range((R - b1) // a1, (L - b1 - 1) // a1, -1):\n            x = a1 * k + b1\n            if L <= x <= R:\n                return x\n        return None\n\n    # Find the first valid x from the second progression\n    def first_valid_x2():\n        for l in range((L - b2 + a2 - 1) // a2, (R - b2) // a2 + 1):\n            x = a2 * l + b2\n            if L <= x <= R:\n                return x\n        return None\n\n    # Find the last valid x from the second progression\n    def last_valid_x2():\n        for l in range((R - b2) // a2, (L - b2 - 1) // a2, -1):\n            x = a2 * l + b2\n            if L <= x <= R:\n                return x\n        return None\n\n    # Get the first and last valid x from both progressions\n    x1 = first_valid_x()\n    x2 = first_valid_x2()\n    \n    if x1 is None and x2 is None:\n        return 0\n\n    if x1 is None:\n        x1 = x2\n    if x2 is None:\n        x2 = x1\n\n    # Ensure x1 is the smaller one\n    x1, x2 = min(x1, x2), max(x1, x2)\n\n    # Count the number of valid integers in the range [L, R]\n    count = 0\n    for x in range(x1, x2 + 1, step):\n        if L <= x <= R:\n            count += 1\n\n    return count\n\n# Input reading\na1, b1, a2, b2, L, R = map(int, input().split())\nresult = count_integers(a1, b1, a2, b2, L, R)\nprint(result)\n```",
    "49": "```python\ndef find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n\n    # Determine the range where the k-th digit lies\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    # Find the exact number containing the k-th digit\n    start += (k - 1) // length\n    num_str = str(start)\n    \n    # Find the digit in that number\n    digit_index = (k - 1) % length\n    return num_str[digit_index]\n\nk = int(input().strip())\nprint(find_kth_digit(k))\n```",
    "44": "```python\ndef minimal_time(d, k, a, b, t):\n    # Calculate the time if Vasiliy walks the entire distance\n    time_if_walk = d * b\n    \n    # Calculate the number of full segments the car can drive\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Calculate the time if Vasiliy uses the car for full segments and walks the remaining distance\n    time_using_car = full_segments * (k * a + t) + remaining_distance * a\n    \n    # If there are full segments, we need to subtract the last repair time\n    if full_segments > 0:\n        time_using_car -= t\n    \n    # Compare the two strategies and return the minimum time\n    return min(time_if_walk, time_using_car)\n\n# Read input\nd, k, a, b, t = map(int, input().split())\n# Print the result\nprint(minimal_time(d, k, a, b, t))\n```",
    "46": "```python\ndef count_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n\n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n\n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n\n    result = 0\n    for i in range(5):\n        result += count_x[i] * count_y[(5 - i) % 5]\n\n    return result\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))\n```",
    "51": "```python\nfrom collections import Counter\nfrom math import gcd\n\nn = int(input())\ndivisors = list(map(int, input().split()))\n\n# Count the occurrences of each divisor\ncount = Counter(divisors)\n\n# Find the maximum divisor, which should be either x or y\nmax_divisor = max(count.keys())\n\n# Initialize x and y\nx = max_divisor\ny = 1\n\n# For each divisor, check if it can be part of y\nfor d in count:\n    if d != max_divisor:\n        # If d is a divisor of x, it can also be a divisor of y\n        if count[d] == 2:\n            y *= d\n\n# Output the results\nprint(x, y)\n```",
    "47": "```python\ndef max_subarray_sum(arr):\n    max_ending_here = max_so_far = 0\n    for x in arr:\n        max_ending_here = max(0, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\ndef max_beauty_with_multiplier(n, x, a):\n    # Calculate the original beauty\n    original_beauty = max_subarray_sum(a)\n    \n    # If x is 0, the best we can do is the original beauty\n    if x == 0:\n        return original_beauty\n\n    # Calculate the maximum beauty after applying the multiplier\n    max_with_multiplier = original_beauty\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += a[j]\n            # Calculate the new beauty if we multiply the subarray a[i:j+1] by x\n            new_sum = current_sum * x\n            # Calculate the beauty of the rest of the array\n            rest_sum = max_subarray_sum(a[:i] + a[j+1:])\n            max_with_multiplier = max(max_with_multiplier, new_sum + rest_sum)\n\n    return max_with_multiplier\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_beauty_with_multiplier(n, x, a))\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef reachable_count(n):\n    reachable = set()\n    current = n\n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    return len(reachable)\n\nn = int(input())\nprint(reachable_count(n))\n```",
    "53": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nleft, right = 0, n - 1\nlast = -1\nresult = []\nmoves = []\n\nwhile left <= right:\n    if a[left] > last and (a[right] <= last or a[left] < a[right]):\n        result.append(a[left])\n        moves.append('L')\n        last = a[left]\n        left += 1\n    elif a[right] > last:\n        result.append(a[right])\n        moves.append('R')\n        last = a[right]\n        right -= 1\n    else:\n        break\n\nprint(len(result))\nprint(''.join(moves))\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_choose = m // 2\n    dp = [[-1] * k for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        row = matrix[i - 1]\n        row.sort(reverse=True)\n        current_dp = dp[i - 1][:]  # Copy previous row\n\n        for j in range(1, max_choose + 1):\n            if j > len(row):\n                break\n            sum_selected = sum(row[:j])\n            for r in range(k):\n                if current_dp[r] != -1:\n                    new_sum = current_dp[r] + sum_selected\n                    new_remainder = new_sum % k\n                    if new_sum > dp[i][new_remainder]:\n                        dp[i][new_remainder] = new_sum\n\n        for r in range(k):\n            dp[i][r] = max(dp[i][r], current_dp[r])\n\n    return max(dp[n])\n\n# Input reading\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nresult = max_sum_divisible_by_k(n, m, k, matrix)\nprint(result)\n```",
    "59": "```python\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# We need to check the last x digits of the number\ntarget = ['0'] * x\ntarget[y] = '1'  # Set the y-th position to '1' for remainder 10^y\n\n# Count the number of changes needed\nchanges = 0\nfor i in range(x):\n    if number[n - 1 - i] != target[x - 1 - i]:\n        changes += 1\n\nprint(changes)\n```",
    "57": "```python\ndef fill_gift_givers(n, f):\n    # Find the friends who have not been assigned a gift\n    assigned = set(f) - {0}\n    unassigned = [i for i in range(1, n + 1) if i not in assigned]\n    zero_indices = [i for i in range(n) if f[i] == 0]\n\n    # Create a result list initialized with the original values\n    result = f[:]\n\n    # Fill in the unassigned values\n    for i in range(len(zero_indices)):\n        # Assign the unassigned friend to the current zero index\n        result[zero_indices[i]] = unassigned[i]\n\n    # Ensure no one gives a gift to themselves\n    for i in range(len(zero_indices)):\n        if result[zero_indices[i]] == zero_indices[i] + 1:\n            # Swap with the next unassigned if possible\n            if i + 1 < len(zero_indices):\n                result[zero_indices[i]], result[zero_indices[i + 1]] = result[zero_indices[i + 1]], result[zero_indices[i]]\n\n    return result\n\n# Input reading\nn = int(input())\nf = list(map(int, input().split()))\n\n# Get the result\nresult = fill_gift_givers(n, f)\n\n# Print the result\nprint(' '.join(map(str, result)))\n```",
    "58": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nfrom collections import defaultdict\n\n# Count occurrences of each number\ncount = defaultdict(int)\nfor num in a:\n    count[num] += 1\n\n# If any number occurs more than k times, it's impossible\nif any(c > k for c in count.values()):\n    print(\"NO\")\n    exit()\n\n# Prepare to assign colors\ncolor_assignment = [0] * n\ncolor_used = defaultdict(int)\n\n# Assign colors\nfor i in range(n):\n    num = a[i]\n    color_used[num] += 1\n    color_assignment[i] = color_used[num] if color_used[num] <= k else 0\n\n# Check if we have assigned all colors\nif any(c == 0 for c in color_assignment):\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(\" \".join(map(str, color_assignment)))\n```",
    "60": "```python\ndef has_palindrome_subsequence(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        found = False\n        # We will use a dictionary to track the last occurrence of each number\n        last_occurrence = {}\n        \n        for i in range(n):\n            if a[i] in last_occurrence:\n                # Check if we have seen this number before\n                if i - last_occurrence[a[i]] >= 2:\n                    found = True\n                    break\n            last_occurrence[a[i]] = i\n        \n        results.append(\"YES\" if found else \"NO\")\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Get results\nresults = has_palindrome_subsequence(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "63": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Sort the array to easily find min and max after removing one element\na.sort()\n\n# The minimum instability after removing one element can be found by considering\n# two cases: removing the smallest element or removing the largest element.\n# After removing the smallest element, the new min is a[1] and max is a[n-1].\n# After removing the largest element, the new min is a[0] and max is a[n-2].\n\n# Calculate the two possible instabilities\ninstability_remove_min = a[-1] - a[1]\ninstability_remove_max = a[-2] - a[0]\n\n# The minimum instability after removing one element\nmin_instability = min(instability_remove_min, instability_remove_max)\n\nprint(min_instability)\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph):\n    visited = {start: 0}\n    queue = deque([start])\n    farthest_node = start\n    max_distance = 0\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > max_distance:\n                    max_distance = visited[neighbor]\n                    farthest_node = neighbor\n                    \n    return farthest_node, max_distance\n\ndef find_max_edges(n, edges):\n    graph = defaultdict(list)\n    \n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Step 1: Find the farthest node from an arbitrary node (1)\n    farthest_from_start, _ = bfs(1, graph)\n    \n    # Step 2: Find the farthest node from the farthest node found in step 1\n    farthest_from_a, diameter_length = bfs(farthest_from_start, graph)\n    \n    # Step 3: Find the path from farthest_from_start to farthest_from_a\n    path = []\n    parent = {farthest_from_start: None}\n    queue = deque([farthest_from_start])\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in parent:\n                parent[neighbor] = node\n                queue.append(neighbor)\n    \n    # Reconstruct the path\n    current = farthest_from_a\n    while current is not None:\n        path.append(current)\n        current = parent[current]\n    \n    path.reverse()\n    \n    # Step 4: Choose three vertices from the path\n    a = path[0]\n    b = path[len(path) // 2]\n    c = path[-1]\n    \n    # The maximum number of edges in the union of paths\n    max_edges = diameter_length + 1\n    \n    return max_edges, a, b, c\n\n# Input reading\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\n# Find the result\nmax_edges, a, b, c = find_max_edges(n, edges)\n\n# Output the result\nprint(max_edges)\nprint(a, b, c)\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Minimum sum of the first k positive integers\n    min_sum = k * (k + 1) // 2\n    \n    if n < min_sum:\n        return -1\n    \n    # The maximum GCD we can use\n    g = (n - min_sum) // k + 1\n    \n    # Create the sequence\n    sequence = [i + g for i in range(1, k + 1)]\n    \n    return sequence\n\n# Input reading\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "67": "```python\nn = int(input())\na = list(map(int, input().split()))\n\ntotal_sum = sum(a)\nnice_indices = []\n\nfor i in range(n):\n    remaining_sum = total_sum - a[i]\n    if remaining_sum == a[i] * 2:\n        nice_indices.append(i + 1)\n\nprint(len(nice_indices))\nif nice_indices:\n    print(' '.join(map(str, nice_indices)))\n```",
    "55": "```python\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Check if there is any point outside the white sheet and not covered by both black sheets\ndef is_visible():\n    # Check the four corners of the white sheet\n    corners = [\n        (x1, y1),  # bottom left\n        (x1, y2),  # top left\n        (x2, y1),  # bottom right\n        (x2, y2)   # top right\n    ]\n    \n    for (x, y) in corners:\n        # Check if the point (x, y) is outside the white sheet\n        if (x < x1 or x > x2 or y < y1 or y > y2):\n            # Check if the point is strictly outside both black sheets\n            if not (x3 < x < x4 and y3 < y < y4) and not (x5 < x < x6 and y5 < y < y6):\n                return True\n    return False\n\nif is_visible():\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "71": "```python\nimport math\n\na = int(input())\noutput = math.ceil(math.log2(a))\nprint(output)\n```",
    "54": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_a = min(a)\nmax_a = max(a)\n\nif min_a == max_a:\n    print(0)\nelse:\n    D = (max_a - min_a) // 2\n    if (max_a - min_a) % 2 == 0:\n        print(D)\n    else:\n        print(-1)\n```",
    "73": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmax_height = max(a)\ntotal_bricks_needed = 0\ntotal_bricks_available = 0\n\nfor height in a:\n    total_bricks_needed += max_height - height\n    total_bricks_available += height\n\nif total_bricks_available >= total_bricks_needed:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        min_ops = float('inf')\n        best_triple = (0, 0, 0)\n        \n        # Iterate over possible values for A\n        for A in range(1, a + 1):\n            # B must be a multiple of A\n            B = ((b + A - 1) // A) * A  # smallest multiple of A >= b\n            if B < b:\n                B = (b // A) * A  # largest multiple of A <= b\n            \n            # C must be a multiple of B\n            C = ((c + B - 1) // B) * B  # smallest multiple of B >= c\n            if C < c:\n                C = (c // B) * B  # largest multiple of B <= c\n            \n            # Calculate operations needed\n            ops = abs(A - a) + abs(B - b) + abs(C - c)\n            \n            if ops < min_ops:\n                min_ops = ops\n                best_triple = (A, B, C)\n        \n        results.append((min_ops, best_triple))\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations(t, test_cases)\n\n# Output results\nfor ops, (A, B, C) in results:\n    print(ops)\n    print(A, B, C)\n```",
    "70": "```python\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Convert start and end times to total minutes\nstart_minutes = h1 * 60 + m1\nend_minutes = h2 * 60 + m2\n\n# Calculate the midpoint in total minutes\nmidpoint_minutes = (start_minutes + end_minutes) // 2\n\n# Convert back to hours and minutes\nh3 = midpoint_minutes // 60\nm3 = midpoint_minutes % 60\n\n# Print the result in the required format\nprint(f\"{h3:02}:{m3:02}\")\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import defaultdict\n    \n    # Count the frequency of each character in the string\n    freq = defaultdict(int)\n    for char in s:\n        freq[char] += 1\n    \n    # Calculate the number of unique subsequences we can generate\n    unique_subsequences = 0\n    total_cost = 0\n    costs = []\n    \n    # Generate subsequences and their costs\n    for length in range(1, n + 1):\n        # For each unique character, we can create subsequences of this length\n        for char, count in freq.items():\n            if count >= length:\n                # The number of ways to choose 'length' characters from 'count' is C(count, length)\n                # This is equivalent to the number of unique subsequences of this length\n                unique_subsequences += 1\n                costs.append(n - length)  # Cost of adding this subsequence\n    \n    # If we can't generate enough unique subsequences\n    if unique_subsequences < k:\n        return -1\n    \n    # Sort costs to minimize total cost\n    costs.sort()\n    \n    # Calculate the minimum total cost to obtain k unique subsequences\n    return sum(costs[:k])\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result and print it\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "64": "```python\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Prepare a schedule with all days initialized to 0 (rest)\nschedule = [0] * n\n\n# To keep track of preparation days needed for each exam\nprep_needed = [0] * m\n\n# Fill in the exam days in the schedule\nfor i in range(m):\n    s_i, d_i, c_i = exams[i]\n    schedule[d_i - 1] = m + 1  # Mark the exam day (1-indexed to 0-indexed)\n    prep_needed[i] = c_i\n\n# Try to allocate preparation days\nfor i in range(m):\n    s_i, d_i, c_i = exams[i]\n    days_allocated = 0\n    \n    for day in range(s_i - 1, d_i - 1):  # s_i to d_i - 1 (0-indexed)\n        if schedule[day] == 0 and days_allocated < c_i:  # If it's a rest day\n            schedule[day] = i + 1  # Mark preparation for exam i (1-indexed)\n            days_allocated += 1\n    \n    if days_allocated < c_i:  # If we couldn't allocate enough preparation days\n        print(-1)\n        exit()\n\n# Print the final schedule\nprint(\" \".join(map(str, schedule)))\n```",
    "77": "```python\nn = int(input())\ntotal_sum = n * (n + 1) // 2\nprint(total_sum % 2)\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    unique_subsequences = set()\n    \n    # Generate all unique subsequences\n    for i in range(1 << n):\n        subsequence = []\n        for j in range(n):\n            if i & (1 << j):\n                subsequence.append(s[j])\n        unique_subsequences.add(''.join(subsequence))\n    \n    # If we cannot obtain k unique subsequences\n    if len(unique_subsequences) < k:\n        return -1\n    \n    # Calculate costs for each unique subsequence\n    costs = []\n    for subseq in unique_subsequences:\n        cost = n - len(subseq)\n        costs.append(cost)\n    \n    # Sort costs and take the minimum k costs\n    costs.sort()\n    return sum(costs[:k])\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "81": "```python\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\n# Sort strings by length\nstrings.sort(key=len)\n\n# Check if the ordering is valid\nfor i in range(1, n):\n    if strings[i-1] not in strings[i]:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")\n    print(\"\\n\".join(strings))\n```",
    "66": "```python\ndef minimum_length_string(n, k, t):\n    # Find the longest prefix which is also a suffix\n    lps = [0] * n\n    j = 0  # length of previous longest prefix suffix\n    i = 1\n\n    # Preprocess the pattern to create the lps array\n    while i < n:\n        if t[i] == t[j]:\n            j += 1\n            lps[i] = j\n            i += 1\n        else:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                lps[i] = 0\n                i += 1\n\n    # The length of the longest prefix which is also a suffix\n    overlap_length = lps[-1]\n\n    # Construct the result string\n    result = t\n    for _ in range(k - 1):\n        result += t[overlap_length:]\n\n    return result\n\n# Read input\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the result and print it\nresult = minimum_length_string(n, k, t)\nprint(result)\n```",
    "82": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncount = 0\n\n# Solve from the left\nwhile count < n and a[count] <= k:\n    count += 1\n\n# Solve from the right\nwhile count < n and a[n - 1 - (count - 1)] <= k:\n    count += 1\n\n# Adjust for double counting if both ends are solvable\nif count > n:\n    count = n\n\nprint(count)\n```",
    "76": "```python\ndef can_construct_symmetric_square(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Check for pairs of tiles that can form the symmetric structure\n        can_form = False\n        for i in range(n):\n            for j in range(n):\n                if tiles[i][1][0] == tiles[j][0][1] and tiles[i][1][1] == tiles[j][0][0]:\n                    can_form = True\n                    break\n            if can_form:\n                break\n        \n        results.append(\"YES\" if can_form else \"NO\")\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        top = list(map(int, input().split()))\n        bottom = list(map(int, input().split()))\n        tiles.append((top, bottom))\n    test_cases.append((n, m, tiles))\n\n# Get results\nresults = can_construct_symmetric_square(t, test_cases)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    # Extract left and right endpoints\n    lefts = [l for l, r in segments]\n    rights = [r for l, r in segments]\n\n    # Precompute the maximum left and minimum right excluding each segment\n    max_left = [0] * n\n    min_right = [0] * n\n\n    max_left[0] = lefts[0]\n    for i in range(1, n):\n        max_left[i] = max(max_left[i - 1], lefts[i])\n\n    min_right[n - 1] = rights[n - 1]\n    for i in range(n - 2, -1, -1):\n        min_right[i] = min(min_right[i + 1], rights[i])\n\n    max_length = 0\n\n    for i in range(n):\n        if i == 0:\n            current_left = max_left[1]\n            current_right = min_right[1]\n        elif i == n - 1:\n            current_left = max_left[n - 2]\n            current_right = min_right[n - 2]\n        else:\n            current_left = max(max_left[i - 1], lefts[i + 1])\n            current_right = min(min_right[i + 1], rights[i - 1])\n\n        intersection_length = max(0, current_right - current_left)\n        max_length = max(max_length, intersection_length)\n\n    return max_length\n\n# Input reading\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_intersection_length(n, segments))\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    # Create a list to store the color assignments\n    colors = [0] * n\n    # Create a dictionary to track the last seen index of each character\n    last_seen = {}\n    # Initialize the color counter\n    color_count = 0\n\n    for i in range(n):\n        char = s[i]\n        if char in last_seen:\n            # If the character has been seen before, assign the same color\n            colors[i] = colors[last_seen[char]]\n        else:\n            # If it's a new character, increment the color count and assign a new color\n            color_count += 1\n            colors[i] = color_count\n        \n        # Update the last seen index for the character\n        last_seen[char] = i\n\n    return color_count, colors\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result\nres, coloring = min_colors_to_sort(n, s)\n\n# Print the result\nprint(res)\nprint(' '.join(map(str, coloring)))\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    if len(graph[1]) < D:\n        print(\"NO\")\n        return\n\n    # Start building the spanning tree\n    spanning_tree_edges = []\n    visited = [False] * (n + 1)\n    visited[1] = True\n    degree_count = 0\n\n    # First, connect the first vertex to D neighbors\n    for neighbor in graph[1]:\n        if degree_count < D:\n            spanning_tree_edges.append((1, neighbor))\n            visited[neighbor] = True\n            degree_count += 1\n\n    # Now we need to add the remaining vertices\n    queue = deque()\n    for neighbor in graph[1]:\n        if degree_count < D:\n            continue\n        if not visited[neighbor]:\n            queue.append(neighbor)\n\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                spanning_tree_edges.append((current, neighbor))\n                queue.append(neighbor)\n                if len(spanning_tree_edges) == n - 1:\n                    break\n        if len(spanning_tree_edges) == n - 1:\n            break\n\n    if len(spanning_tree_edges) == n - 1:\n        print(\"YES\")\n        for u, v in spanning_tree_edges:\n            print(u, v)\n    else:\n        print(\"NO\")\n\n# Read input\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\nfind_spanning_tree(n, m, D, edges)\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n    \n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            # Check both (width, height) and (height, width)\n            for w, h in [(width, height), (height, width)]:\n                # Check if we can fit a red rectangle and a blue rectangle\n                for r_width in range(1, w + 1):\n                    if a % r_width == 0:\n                        r_height = a // r_width\n                        if r_height <= h:\n                            min_perimeter = min(min_perimeter, 2 * (w + h))\n                            break  # No need to check further for this width\n\n                for b_width in range(1, w + 1):\n                    if b % b_width == 0:\n                        b_height = b // b_width\n                        if b_height <= h:\n                            min_perimeter = min(min_perimeter, 2 * (w + h))\n                            break  # No need to check further for this width\n\n    return min_perimeter\n\n# Input reading\na, b = map(int, input().split())\nprint(minimal_perimeter(a, b))\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects by their required rating\n    projects.sort(key=lambda x: x[0])\n    \n    completed = 0\n    current_rating = r\n    \n    for a, b in projects:\n        if current_rating >= a:\n            completed += 1\n            current_rating += b\n            if current_rating < 0:\n                break\n    \n    return completed\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_projects(n, r, projects))\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    \n    # Check for possible pairs of digits that can form 25 or 00\n    target_pairs = ['00', '25', '50', '75']\n    min_moves = float('inf')\n    \n    for pair in target_pairs:\n        # Find the last digit of the pair\n        last_digit = pair[1]\n        last_digit_index = -1\n        \n        # Find the last occurrence of the last digit in the number\n        for i in range(length - 1, -1, -1):\n            if s[i] == last_digit:\n                last_digit_index = i\n                break\n        \n        if last_digit_index == -1:\n            continue\n        \n        # Now find the first digit of the pair\n        first_digit = pair[0]\n        first_digit_index = -1\n        \n        # Find the first occurrence of the first digit before the last digit\n        for i in range(last_digit_index - 1, -1, -1):\n            if s[i] == first_digit:\n                first_digit_index = i\n                break\n        \n        if first_digit_index == -1:\n            continue\n        \n        # Calculate moves to bring the first digit to the position before last digit\n        moves = (last_digit_index - first_digit_index) + (last_digit_index - (first_digit_index + 1))\n        min_moves = min(min_moves, moves)\n    \n    return min_moves if min_moves != float('inf') else -1\n\n# Input\nn = int(input().strip())\n# Output\nprint(min_moves_to_divisible_by_25(n))\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects by their required rating\n    projects.sort(key=lambda x: x[0])\n    \n    for a, b in projects:\n        if r < a:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_complete_projects(n, r, projects))\n```",
    "84": "```python\ndef can_color_string(n, s):\n    # Count frequency of each character\n    from collections import Counter\n    freq = Counter(s)\n    \n    # Check if any character appears more than twice\n    for count in freq.values():\n        if count > 2:\n            print(\"NO\")\n            return\n    \n    # Create a coloring array\n    color = ['0'] * n\n    \n    # Assign colors\n    last_color = '0'\n    for i in range(n):\n        if s[i] in freq and freq[s[i]] > 0:\n            if freq[s[i]] == 1:\n                color[i] = last_color\n            else:\n                color[i] = '0' if last_color == '1' else '1'\n            freq[s[i]] -= 1\n            last_color = color[i]\n    \n    print(\"YES\")\n    print(''.join(color))\n\n# Read input\nn = int(input())\ns = input().strip()\ncan_color_string(n, s)\n```",
    "90": "```python\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculate the minimum required space to place the platforms\ntotal_length = sum(c)\nmin_required_space = total_length + (m - 1)  # total length + gaps between platforms\n\nif min_required_space > n:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    a = [0] * n\n    position = 0\n\n    for i in range(m):\n        for j in range(c[i]):\n            a[position] = i + 1\n            position += 1\n        if i < m - 1:  # Add a gap of at least 1 cell between platforms\n            position += 1\n\n    print(\" \".join(map(str, a)))\n```",
    "86": "```python\ndef solve(n, k):\n    # Minimum sum of the first k natural numbers\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n    \n    # Maximum sum if we double the previous day's problems\n    max_sum = 0\n    a = []\n    current = 1\n    \n    for i in range(k):\n        a.append(current)\n        max_sum += current\n        current = min(2 * current, current + 1 + (k - i - 1))  # Ensure we can still fill the rest\n    \n    # If the maximum sum we can achieve is less than n, it's impossible\n    if max_sum > n:\n        print(\"NO\")\n        return\n    \n    # Distribute the remaining problems\n    remaining = n - sum(a)\n    \n    for i in range(k - 1, -1, -1):\n        if remaining <= 0:\n            break\n        # The maximum we can add to a[i] without violating the rules\n        max_add = min(remaining, (2 * a[i]) - a[i])\n        a[i] += max_add\n        remaining -= max_add\n    \n    if sum(a) == n:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n    else:\n        print(\"NO\")\n\n# Read input\nn, k = map(int, input().split())\nsolve(n, k)\n```",
    "78": "```python\nMOD = 10**9 + 7\n\ndef count_regular_sequences(n, s):\n    m = len(s)\n    \n    # Precompute factorials and inverse factorials\n    fact = [1] * (2 * n + 1)\n    for i in range(2, 2 * n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    \n    def mod_inv(x):\n        return pow(x, MOD - 2, MOD)\n    \n    inv_fact = [1] * (2 * n + 1)\n    for i in range(2 * n + 1):\n        inv_fact[i] = mod_inv(fact[i])\n    \n    # Check if s can be part of a regular bracket sequence\n    balance = 0\n    min_balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n    \n    if balance < 0 or n < (m + min_balance) // 2:\n        return 0\n    \n    # Count the number of valid sequences\n    total_open = (n - (m + min_balance) // 2)\n    total_close = (n - (m - min_balance) // 2)\n    \n    if total_open < 0 or total_close < 0:\n        return 0\n    \n    result = (fact[total_open + total_close] * inv_fact[total_open] % MOD) * inv_fact[total_close] % MOD\n    return result\n\nn = int(input())\ns = input().strip()\nprint(count_regular_sequences(n, s))\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Start with an empty string\n    s = []\n    \n    # Determine the starting character based on the number of 0s and 1s\n    if a > b:\n        s.append('0')\n        a -= 1\n    else:\n        s.append('1')\n        b -= 1\n    \n    # We need to create x transitions\n    for i in range(x):\n        if s[-1] == '0':\n            s.append('1')\n            b -= 1\n        else:\n            s.append('0')\n            a -= 1\n    \n    # Now we have used x transitions, we need to fill the rest\n    # Fill with the remaining characters\n    while a > 0:\n        s.append('0')\n        a -= 1\n    while b > 0:\n        s.append('1')\n        b -= 1\n    \n    # Join the list into a string and print it\n    print(''.join(s))\n\n# Read input\na, b, x = map(int, input().split())\nconstruct_binary_string(a, b, x)\n```",
    "97": "```python\nn = int(input())\nchips = list(map(int, input().split()))\n\neven_count = sum(1 for x in chips if x % 2 == 0)\nodd_count = n - even_count\n\n# The minimum cost is the smaller of the two counts\nprint(min(even_count, odd_count))\n```",
    "92": "```python\nx = float(input().strip())\n\n# We need to find two integers a and b such that 1 <= a, b <= 10\n# and a * b is approximately equal to x\n\n# We can iterate through all possible pairs (a, b)\nfor a in range(1, 11):\n    for b in range(1, 11):\n        if abs(a * b - x) < 1e-6:  # Check if the product is close to x\n            print(a, b)\n            break\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n    \n    # Precompute the leftmost indices where t can be matched in s\n    left = [0] * m\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n    \n    # Precompute the rightmost indices where t can be matched in s\n    right = [0] * m\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n    \n    # Now find the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n    \n    # Consider removing from the start to the first character of t\n    max_length = max(max_length, right[0])\n    # Consider removing from the last character of t to the end\n    max_length = max(max_length, n - 1 - left[m - 1])\n    \n    return max_length\n\n# Input reading\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(max_removable_length(s, t))\n```",
    "96": "```python\nn = int(input())\nq = list(map(int, input().split()))\n\n# Initialize the permutation array\np = [0] * n\n\n# Calculate the first element p[0] based on the differences\np[0] = 0  # We can start from any arbitrary value, we'll adjust later\n\n# Build the permutation based on the differences\nfor i in range(1, n):\n    p[i] = p[i - 1] + q[i - 1]\n\n# Normalize the permutation to be in the range [1, n]\nmin_p = min(p)\noffset = 1 - min_p\n\nfor i in range(n):\n    p[i] += offset\n\n# Check if the resulting permutation is valid\nif len(set(p)) == n and all(1 <= x <= n for x in p):\n    print(' '.join(map(str, p)))\nelse:\n    print(-1)\n```",
    "99": "```python\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\n# Maximum wins for Alice\nmax_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n\n# Minimum wins for Alice\n# To minimize Alice's wins, we can maximize Bob's wins\n# Bob wins if:\n# - Bob's rock beats Alice's scissors\n# - Bob's scissors beat Alice's paper\n# - Bob's paper beats Alice's rock\nmin_wins = max(0, b1 - a2) + max(0, b2 - a3) + max(0, b3 - a1)\n\nprint(min_wins, max_wins)\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Create a list of characters to use\n    chars = ['a'] * n + ['b'] * n + ['c'] * n\n    # Create a set of forbidden substrings\n    forbidden = {s, t}\n    \n    # Function to check if the last two characters form a forbidden substring\n    def is_forbidden(res):\n        return res[-2:] in forbidden\n    \n    # Result string\n    res = []\n    \n    # Try to build the result string\n    for char in chars:\n        # If adding this character would create a forbidden substring, skip it\n        if len(res) >= 1 and res[-1] == char:\n            continue\n        if len(res) >= 2 and is_forbidden(res + [char]):\n            continue\n        \n        res.append(char)\n    \n    # If we have enough characters, return the result\n    if len(res) == 3 * n:\n        return \"YES\\n\" + ''.join(res)\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\ns = input().strip()\nt = input().strip()\n\n# Generate the result\nresult = generate_string(n, s, t)\nprint(result)\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1:\n        return \"NO\"\n    \n    if d == 1 and n > 2:\n        return \"NO\"\n    \n    if d == 1:\n        if n == 2:\n            return \"YES\\n1 2\"\n        else:\n            return \"NO\"\n    \n    if n <= k + 1 and d > 1:\n        return \"NO\"\n    \n    edges = []\n    \n    # Create the main path of length d\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n    \n    # Now we have d + 1 vertices in the path\n    current_vertex = d + 2\n    \n    # We can add branches to the vertices in the path\n    for i in range(1, d + 1):\n        while len([e for e in edges if e[0] == i or e[1] == i]) < k and current_vertex <= n:\n            edges.append((i, current_vertex))\n            current_vertex += 1\n            if current_vertex > n:\n                break\n    \n    if current_vertex <= n:\n        return \"NO\"\n    \n    result = \"YES\\n\" + \"\\n\".join(f\"{u} {v}\" for u, v in edges)\n    return result\n\nn, d, k = map(int, input().split())\nprint(construct_tree(n, d, k))\n```",
    "88": "```python\nfrom collections import Counter\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Count the frequency of each number\ncount = Counter(a)\n\n# Check if we can form a palindromic matrix\nodd_count = 0\nfor freq in count.values():\n    if freq % 2 != 0:\n        odd_count += 1\n\n# For an n x n matrix:\n# - If n is odd, we can have at most one number with an odd frequency.\n# - If n is even, we cannot have any number with an odd frequency.\nif (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Fill the matrix\n    half = n // 2\n    idx = 0\n    for num, freq in count.items():\n        while freq > 0:\n            if freq >= 4:\n                # Place in corners\n                matrix[idx][idx] = num\n                matrix[idx][n - 1 - idx] = num\n                matrix[n - 1 - idx][idx] = num\n                matrix[n - 1 - idx][n - 1 - idx] = num\n                freq -= 4\n            elif freq >= 2:\n                # Place in sides\n                if idx < half:\n                    matrix[idx][n - 1 - idx] = num\n                    matrix[n - 1 - idx][idx] = num\n                    freq -= 2\n                else:\n                    break\n            else:\n                # Place in the center if n is odd\n                if n % 2 == 1 and freq == 1:\n                    matrix[half][half] = num\n                    freq -= 1\n                break\n            idx += 1\n            if idx >= half:\n                idx = 0\n    \n    # Fill the remaining spots\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                matrix[i][j] = matrix[n - 1 - i][j]\n    \n    for row in matrix:\n        print(\" \".join(map(str, row)))\n```"
}