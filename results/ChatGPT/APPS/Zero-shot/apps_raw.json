{
    "0": "```python\ndef max_length Accordion(s):\n    n = len(s)\n    left_bracket = -1\n    right_bracket = -1\n\n    # Find the last opening bracket '['\n    for i in range(n):\n        if s[i] == '[':\n            left_bracket = i\n\n    # Find the first closing bracket ']'\n    for i in range(n - 1, -1, -1):\n        if s[i] == ']':\n            right_bracket = i\n\n    # If there are no valid brackets, return -1\n    if left_bracket == -1 or right_bracket == -1 or left_bracket >= right_bracket:\n        return -1\n\n    # Find the first colon after the left bracket\n    first_colon = -1\n    for i in range(left_bracket + 1, right_bracket):\n        if s[i] == ':':\n            first_colon = i\n            break\n\n    # If no colon found, return -1\n    if first_colon == -1:\n        return -1\n\n    # Find the last colon before the right bracket\n    last_colon = -1\n    for i in range(right_bracket - 1, left_bracket, -1):\n        if s[i] == ':':\n            last_colon = i\n            break\n\n    # If no colon found, return -1\n    if last_colon == -1 or last_colon <= first_colon:\n        return -1\n\n    # Count the number of vertical lines between the two colons\n    vertical_lines = 0\n    for i in range(first_colon + 1, last_colon):\n        if s[i] == '|':\n            vertical_lines += 1\n\n    # Maximum length of the accordion\n    return 4 + vertical_lines\n\n# Input\ns = input().strip()\n# Output\nprint(max_length Accordion(s))\n```",
    "1": "```python\ndef sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef max_sum_of_digits(x):\n    str_x = str(x)\n    n = len(str_x)\n    \n    # Start with the maximum number equal to x\n    max_number = x\n    max_digit_sum = sum_of_digits(x)\n\n    # Try to create a number by reducing one digit and filling the rest with 9s\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a new number by decrementing the current digit\n        # and setting all subsequent digits to 9\n        new_number = list(str_x)\n        new_number[i] = str(int(new_number[i]) - 1)  # Decrease the digit\n        for j in range(i + 1, n):\n            new_number[j] = '9'  # Set all following digits to 9\n        \n        new_number = int(''.join(new_number))\n        \n        if new_number > 0 and new_number <= x:\n            current_digit_sum = sum_of_digits(new_number)\n            if current_digit_sum > max_digit_sum or (current_digit_sum == max_digit_sum and new_number > max_number):\n                max_number = new_number\n                max_digit_sum = current_digit_sum\n\n    return max_number\n\nx = int(input())\nprint(max_sum_of_digits(x))\n```",
    "2": "```python\nn = int(input())\n\ndef is_lucky(year):\n    non_zero_digits = sum(1 for digit in str(year) if digit != '0')\n    return non_zero_digits <= 1\n\nnext_year = n + 1\nwhile not is_lucky(next_year):\n    next_year += 1\n\nprint(next_year - n)\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    painted = [0] * (n + 1)\n    \n    for l, r in painters:\n        for i in range(l, r + 1):\n            painted[i] += 1\n            \n    total_sections = sum(1 for i in range(1, n + 1) if painted[i] > 0)\n    \n    max_painted = 0\n    \n    for i in range(q):\n        # Create a copy of painted sections\n        painted_copy = painted[:]\n        \n        # Remove the influence of the i-th painter\n        l, r = painters[i]\n        for j in range(l, r + 1):\n            painted_copy[j] -= 1\n            \n        # Count how many sections are still painted\n        sections = sum(1 for k in range(1, n + 1) if painted_copy[k] > 0)\n        \n        # We want to maximize the painted sections\n        max_painted = max(max_painted, sections)\n    \n    return max_painted\n\n# Read input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output the result\nprint(max_painted_sections(n, q, painters))\n```",
    "4": "```python\ndef is_lucky(hh, mm):\n    return '7' in f\"{hh:02d}:{mm:02d}\"\n\ndef time_before(hh, mm, x):\n    mm -= x\n    if mm < 0:\n        mm += 60\n        hh -= 1\n        if hh < 0:\n            hh += 24\n    return hh, mm\n\ndef min_snoozes(x, hh, mm):\n    y = 0\n    while not is_lucky(hh, mm):\n        hh, mm = time_before(hh, mm, x)\n        y += 1\n    return y\n\nx = int(input())\nhh, mm = map(int, input().split())\nprint(min_snoozes(x, hh, mm))\n```",
    "5": "```python\nn, pos, l, r = map(int, input().split())\n\n# If all tabs within the desired segment are already open\nif l == 1 and r == n:\n    print(0)\nelse:\n    seconds = 0\n\n    # Close tabs to the left of l\n    if pos < l:\n        seconds += (l - pos)  # Move to l\n        seconds += 1  # Close left\n    elif pos >= l and pos <= r:\n        # If the cursor is within the range, close left and right as needed\n        if l > 1:\n            seconds += (pos - l) + 1  # Move to l and close left\n        if r < n:\n            seconds += (r - pos) + 1  # Move to r and close right\n    else:  # pos > r\n        # Move to r and close left\n        seconds += (pos - r) + 1  # Move to r\n        if l > 1:\n            seconds += (r - l + 1)  # Close left\n\n    print(seconds)\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    \n    for query in queries:\n        n, x = query[0]\n        blows = query[1]\n        \n        # Find the best blow that reduces heads maximally\n        best_reduction = 0\n        best_growth = float('inf')\n        \n        for d, h in blows:\n            best_reduction = max(best_reduction, d)\n            if d < x:  # Only consider growing heads if we can reduce heads\n                best_growth = min(best_growth, h)\n        \n        if best_reduction <= best_growth:\n            # If the best reduction is less than or equal to growth, we can't win\n            results.append(-1)\n            continue\n        \n        # Calculate the number of blows needed\n        blows_required = 0\n        while x > 0:\n            blows_required += 1\n            x -= best_reduction\n            if x > 0:\n                x += best_growth\n        \n        results.append(blows_required)\n    \n    return results\n\n# Input reading\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append(((n, x), blows))\n\n# Get results\nresults = min_blows_to_defeat_zmei(t, queries)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "7": "```python\ndef day_when_barn_empty(n, m):\n    day = 0\n    total_eaten = 0\n    \n    while n > 0:\n        day += 1\n        total_eaten += day  # Total sparrows that have come until today\n        n += m  # Grains brought to the barn\n        \n        # If barn is full, it can only hold n grains\n        if n > n:\n            n = n  # Barn remains full\n            \n        n -= total_eaten  # Sparrows eat from the barn\n        \n    return day\n\n# Input\nn, m = map(int, input().split())\nprint(day_when_barn_empty(n, m))\n```",
    "8": "```python\ndef can_form_koutsu(tiles):\n    from collections import Counter\n    count = Counter(tiles)\n    return any(v >= 3 for v in count.values())\n\ndef can_form_shuntsu(tiles):\n    suits = {'m': [], 'p': [], 's': []}\n    for tile in tiles:\n        number = int(tile[0])\n        suit = tile[1]\n        suits[suit].append(number)\n\n    for numbers in suits.values():\n        numbers.sort()\n        for i in range(len(numbers) - 2):\n            if (numbers[i] + 1 in numbers) and (numbers[i] + 2 in numbers):\n                return True\n    return False\n\ndef min_draws(tiles):\n    if can_form_koutsu(tiles) or can_form_shuntsu(tiles):\n        return 0\n\n    # Check for koutsu possibility by adding a tile\n    for tile in tiles:\n        if tiles.count(tile) < 2:\n            return 1  # Drawing a third tile for a koutsu\n\n    # Check for shuntsu possibility by adding a tile\n    suits = {'m': [], 'p': [], 's': []}\n    for tile in tiles:\n        number = int(tile[0])\n        suit = tile[1]\n        suits[suit].append(number)\n\n    for suit in suits:\n        numbers = sorted(suits[suit])\n        for number in numbers:\n            if number - 1 not in numbers and number + 1 not in numbers:\n                return 1  # Drawing a tile to complete a shuntsu\n\n    return 2  # At worst, we need to draw 2 tiles\n\ntiles = input().split()\nprint(min_draws(tiles))\n```",
    "9": "```python\nd = int(input())\nn, m = map(int, input().split())\nsofas = []\n\nfor i in range(d):\n    x1, y1, x2, y2 = map(int, input().split())\n    sofas.append((x1, y1, x2, y2))\n\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\ndef count_surrounding(sofa):\n    x1, y1, x2, y2 = sofa\n    left = right = top = bottom = 0\n    \n    for other in sofas:\n        if other == sofa:\n            continue\n        ox1, oy1, ox2, oy2 = other\n        \n        # Check left\n        if (x1 < ox1 and x2 < ox1) or (x1 < ox2 and x2 < ox2):\n            left += 1\n        # Check right\n        if (x1 > ox1 and x2 > ox1) or (x1 > ox2 and x2 > ox2):\n            right += 1\n        # Check top\n        if (y1 < oy1 and y2 < oy1) or (y1 < oy2 and y2 < oy2):\n            top += 1\n        # Check bottom\n        if (y1 > oy1 and y2 > oy1) or (y1 > oy2 and y2 > oy2):\n            bottom += 1\n    \n    return left, right, top, bottom\n\nfor i in range(d):\n    left, right, top, bottom = count_surrounding(sofas[i])\n    if left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b:\n        print(i + 1)\n        break\nelse:\n    print(-1)\n```",
    "10": "```python\nn = int(input())\n\n# Calculate minimum days off\nmin_days_off = (n // 7) * 2\n# Calculate maximum days off\nmax_days_off = min(n, (n // 7) * 2 + (2 if n % 7 > 5 else n % 7))\n\nprint(min_days_off, max_days_off)\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    # Count tiles that can be painted Red\n    count_red = n // a\n    # Count tiles that can be painted Blue\n    count_blue = n // b\n    # Count tiles that can be painted both Red and Blue\n    count_both = n // (a * b // gcd(a, b))\n    \n    # Calculate chocolates\n    total_chocolates = (count_red * p) + (count_blue * q) - (count_both * min(p, q))\n    \n    return total_chocolates\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n# Read input\nn, a, b, p, q = map(int, input().split())\n# Print the result\nprint(max_chocolates(n, a, b, p, q))\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    # Count the current longest segment of golden trophies\n    current_max = 0\n    current_count = 0\n    segments = []\n\n    for trophy in trophies:\n        if trophy == 'G':\n            current_count += 1\n        else:\n            if current_count > 0:\n                segments.append(current_count)\n                current_max = max(current_max, current_count)\n            current_count = 0\n    \n    if current_count > 0:\n        segments.append(current_count)\n        current_max = max(current_max, current_count)\n\n    # If there are no golden trophies, max beauty is 0\n    if not segments:\n        return 0\n\n    # Calculate the maximum possible beauty after one swap\n    max_beauty = current_max\n\n    for i in range(len(segments) - 1):\n        # Consider merging two segments by swapping one silver to golden\n        combined = segments[i] + segments[i + 1]\n        max_beauty = max(max_beauty, combined)\n\n    # Check if we can increase the max length by 1 if there's at least one silver trophy\n    if 'S' in trophies:\n        max_beauty = max(max_beauty, current_max + 1)\n\n    return max_beauty\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\n\n# Output the result\nprint(max_beauty_after_swap(n, trophies))\n```",
    "13": "```python\nfrom collections import defaultdict, deque\nimport sys\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, k = map(int, data[0].split())\nmain_courses = list(map(int, data[1].split()))\ndependencies = defaultdict(list)\nin_degree = [0] * (n + 1)\n\n# Read dependencies\nfor i in range(1, n + 1):\n    course_info = list(map(int, data[i + 1].split()))\n    t_i = course_info[0]\n    for dep in course_info[1:t_i + 1]:\n        dependencies[dep].append(i)\n        in_degree[i] += 1\n\n# Topological sort using Kahn's algorithm\nqueue = deque()\nfor i in range(1, n + 1):\n    if in_degree[i] == 0:\n        queue.append(i)\n\norder = []\ncourses_to_pass = set(main_courses)\n\nwhile queue:\n    course = queue.popleft()\n    order.append(course)\n    \n    for dependent in dependencies[course]:\n        in_degree[dependent] -= 1\n        if in_degree[dependent] == 0:\n            queue.append(dependent)\n\n# Check if we can pass all main courses\npassed_courses = set()\nresult_order = []\n\nfor course in order:\n    if course in courses_to_pass:\n        passed_courses.add(course)\n        result_order.append(course)\n        courses_to_pass.remove(course)\n    \n    # If we have passed all main courses, we can finish\n    if not courses_to_pass:\n        break\n\nif courses_to_pass:\n    print(-1)\nelse:\n    # We need to include all courses that are required to pass main courses\n    # Collect all the courses that have been used to get to the main courses\n    final_passed_courses = set()\n    for course in result_order:\n        if course in passed_courses or course in main_courses:\n            final_passed_courses.add(course)\n            for dep in dependencies[course]:\n                if dep not in final_passed_courses:\n                    final_passed_courses.add(dep)\n    \n    final_passed_courses = sorted(final_passed_courses)\n    print(len(final_passed_courses))\n    print(\" \".join(map(str, final_passed_courses)))\n```",
    "14": "```python\ndef is_stack_sortable(n, k, p):\n    # Create a set of used numbers from the first k elements\n    used = set(p)\n    # Create a list of remaining numbers that need to be filled\n    remaining = [i for i in range(1, n + 1) if i not in used]\n    \n    # Initialize the result array with the first k elements\n    result = p[:]\n    \n    # We will use a stack to simulate the operations\n    stack = []\n    \n    # Pointer for remaining elements\n    remaining_pointer = 0\n    \n    # Simulate the process to build the stack-sortable permutation\n    for i in range(k):\n        # Push elements onto the stack until we reach a point where we can pop\n        while (remaining_pointer < len(remaining) and (not stack or remaining[remaining_pointer] > result[i])):\n            stack.append(remaining[remaining_pointer])\n            remaining_pointer += 1\n        \n        # If we can pop from the stack, do it\n        if stack and (not result or stack[-1] < result[i]):\n            print(-1)\n            return\n        \n        # Pop from the stack to the result if it's valid\n        if stack and stack[-1] == result[i]:\n            stack.pop()\n    \n    # Now we need to add the remaining elements in a way that keeps it sorted\n    while remaining_pointer < len(remaining):\n        stack.append(remaining[remaining_pointer])\n        remaining_pointer += 1\n    \n    # Finalizing the result\n    while stack:\n        result.append(stack.pop())\n    \n    print(\" \".join(map(str, result)))\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Call the function to determine the stack-sortable permutation\nis_stack_sortable(n, k, p)\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "16": "```python\ncnt1 = int(input().strip())\ncnt2 = int(input().strip())\ncnt3 = int(input().strip())\ncnt4 = int(input().strip())\n\n# Total open and close brackets\nopen_brackets = cnt1 + cnt2\nclose_brackets = cnt3 + cnt4\n\n# Condition for a regular bracket sequence\nif open_brackets >= close_brackets and (open_brackets - close_brackets) <= cnt2:\n    print(1)\nelse:\n    print(0)\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelse:\n    print(n + k - t)\n```",
    "18": "```python\nfrom collections import deque\n\ns = input().strip()\nt = deque()\nu = []\n\nfor char in s:\n    t.append(char)\n\nwhile t:\n    # Check the smallest character in t and the remaining characters in s\n    min_char = min(t)\n    # If the front character in s is smaller or equal to min_char, we can add it to t\n    while s and (not t or s[0] <= min_char):\n        t.appendleft(s[0])\n        s = s[1:]\n        min_char = min(t)  # Update min_char after adding to t\n        \n    # Extract the last character from t to append to u\n    u.append(t.pop())\n\n# Join the list into a string and print the result\nprint(''.join(u[::-1]))  # Reverse u to get the correct order\n```",
    "19": "```python\ndef check_records(test_cases):\n    results = []\n    for case in test_cases:\n        n = case[0]\n        records = case[1]\n        \n        valid = True\n        previous_plays, previous_clears = 0, 0\n        \n        for p, c in records:\n            if p < previous_plays or c < previous_clears or c > p:\n                valid = False\n                break\n            \n            if p - previous_plays < c - previous_clears:\n                valid = False\n                break\n            \n            previous_plays, previous_clears = p, c\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Reading input\nT = int(input())\ntest_cases = []\nfor _ in range(T):\n    n = int(input())\n    records = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, records))\n\n# Checking records\nresults = check_records(test_cases)\n\n# Printing results\nfor result in results:\n    print(result)\n```",
    "20": "```python\ndef is_palindrome_time(hh, mm):\n    return f\"{hh:02}:{mm:02}\" == f\"{hh:02}:{mm:02}\"[::-1]\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while not is_palindrome_time(hh, mm):\n        mm += 1\n        minutes_passed += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n    return minutes_passed\n\ntime_input = input().strip()\nhh, mm = map(int, time_input.split(':'))\nresult = next_palindrome_time(hh, mm)\nprint(result)\n```",
    "21": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_index = a.index(1)\nmax_index = a.index(n)\n\n# Calculate initial distance\nmax_distance = abs(min_index - max_index)\n\n# Check distance if we swap min or max with the ends of the array\ndistance_with_min_swapped = max(abs(0 - max_index), abs(n - 1 - max_index))\ndistance_with_max_swapped = max(abs(min_index - 0), abs(min_index - (n - 1)))\n\n# The maximum distance we can achieve\nresult = max(max_distance, distance_with_min_swapped, distance_with_max_swapped)\n\nprint(result)\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror_chars = {'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M', 'O': 'O', \n                    'o': 'o', 'p': 'q', 'q': 'p', 'R': 'R', 'S': 'S', 'T': 'T', \n                    'U': 'U', 'v': 'v', 'V': 'V', 'W': 'W', 'X': 'X', 'Y': 'Y', \n                    'Z': 'Z'}\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        if s[i] not in mirror_chars or mirror_chars[s[i]] != s[n - 1 - i]:\n            print(\"NIE\")\n            return\n    print(\"TAK\")\n\ns = input().strip()\nis_s_palindrome(s)\n```",
    "23": "```python\nfrom itertools import permutations\n\ndef max_permutation_not_exceeding(a, b):\n    a_str = str(a)\n    b_str = str(b)\n    \n    # Generate all unique permutations of the digits in a\n    perm_set = set(permutations(a_str))\n    \n    # Filter valid permutations that do not start with '0' and are less than or equal to b\n    valid_numbers = []\n    for perm in perm_set:\n        num_str = ''.join(perm)\n        if num_str[0] != '0' and int(num_str) <= b:\n            valid_numbers.append(int(num_str))\n    \n    # Return the maximum of the valid numbers\n    return max(valid_numbers)\n\n# Input reading\na = int(input().strip())\nb = int(input().strip())\n\n# Get the result and print it\nresult = max_permutation_not_exceeding(a, b)\nprint(result)\n```",
    "24": "```python\ndef can_alice_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # vertical, horizontal, diagonal down-right, diagonal down-left\n\n    def check_win(x, y):\n        for dx, dy in directions:\n            count = 1\n            \n            # Check in the positive direction\n            nx, ny = x + dx, y + dy\n            while 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n                nx += dx\n                ny += dy\n                \n            # Check in the negative direction\n            nx, ny = x - dx, y - dy\n            while 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n                nx -= dx\n                ny -= dy\n            \n            if count >= 5:\n                return True\n        return False\n\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                board[i][j] = 'X'  # Place Alice's cross\n                if check_win(i, j):\n                    return \"YES\"\n                board[i][j] = '.'  # Reset the cell back to empty\n\n    return \"NO\"\n\n# Read the input\nboard = [input().strip() for _ in range(10)]\nprint(can_alice_win(board))\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    if k > n * n or k % 2 != 0 and k > n * n - n:\n        return -1\n\n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k >= 2:\n            matrix[i][i] = 1\n            k -= 1\n            if k > 0 and i + 1 < n:\n                matrix[i][i + 1] = 1\n                matrix[i + 1][i] = 1\n                k -= 2\n\n    if k > 0:\n        return -1\n    \n    return matrix\n\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "26": "```python\nimport math\n\n# Read input\nx, y, z = map(float, input().strip().split())\n\n# Define all expressions\nexpressions = [\n    (x**(y**z), 'x^y^z'),\n    (x**(z**y), 'x^z^y'),\n    ((x**y)**z, '(x^y)^z'),\n    ((x**z)**y, '(x^z)^y'),\n    (y**(x**z), 'y^x^z'),\n    (y**(z**x), 'y^z^x'),\n    ((y**x)**z, '(y^x)^z'),\n    ((y**z)**x, '(y^z)^x'),\n    (z**(x**y), 'z^x^y'),\n    (z**(y**x), 'z^y^x'),\n    ((z**x)**y, '(z^x)^y'),\n    ((z**y)**x, '(z^y)^x')\n]\n\n# Find the maximum value and the corresponding index\nmax_value, max_expression = max(expressions, key=lambda item: item[0])\n\n# Print the corresponding expression with the maximum value\nprint(max_expression)\n```",
    "27": "```python\nn = int(input())\ns = input()\n\nmin_operations = n  # Initialize with the maximum operations (typing all characters)\n\n# Check possible places to copy the string\nfor i in range(1, n):\n    if s[:i] == s[i:2*i]:  # Check if the substring can be copied\n        copy_length = i\n        remaining_length = n - 2 * copy_length\n        operations = copy_length + 1 + remaining_length  # Type, copy, type remaining\n        min_operations = min(min_operations, operations)\n\n# Check if we can type the whole string without copying\nmin_operations = min(min_operations, n)\n\nprint(min_operations)\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = []\nregulars = []\n\nfor name, type_ in files:\n    if type_ == '1':\n        examples.append(name)\n    else:\n        regulars.append(name)\n\ne = len(examples)\nscript = []\n\n# Rename examples to \"1\", \"2\", ..., \"e\"\nfor i in range(1, e + 1):\n    script.append(f\"move {examples[i - 1]} {i}\")\n\n# Rename regular tests to \"e + 1\", \"e + 2\", ..., \"n\"\nfor i in range(1, n - e + 1):\n    script.append(f\"move {regulars[i - 1]} {e + i}\")\n\nprint(len(script))\nfor line in script:\n    print(line)\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket):\n    # Split the ticket into two halves\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    # Calculate the sums of the two halves\n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    # If ticket is already lucky\n    if sum_first == sum_second:\n        return 0\n    \n    # Calculate the difference\n    diff = abs(sum_first - sum_second)\n    \n    # Create a list of possible changes we can make\n    changes = []\n    \n    # Calculate the maximum possible changes for first half\n    if sum_first < sum_second:\n        for digit in first_half:\n            changes.append(9 - digit)  # Max we can increase this digit\n    else:\n        for digit in second_half:\n            changes.append(9 - digit)  # Max we can increase this digit\n    \n    # Sort changes in descending order\n    changes.sort(reverse=True)\n    \n    # Find minimum replacements\n    replacements = 0\n    for change in changes:\n        diff -= change\n        replacements += 1\n        if diff <= 0:\n            break\n    \n    return replacements\n\n# Input\nticket = input().strip()\n# Output\nprint(min_replacements_to_lucky(ticket))\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # Since GCD(x, m) = 1, the sequence will visit all m rooms.\n    # The number of distinct rooms visited corresponds to the order of x modulo m.\n    \n    # The minimum number of traps needed is equal to the number of distinct\n    # rooms the x-mouse can visit before repeating, which is m.\n    \n    return m - 1  # We can put traps in m-1 rooms.\n\n# Input reading\nm, x = map(int, input().strip().split())\n\n# Output the result\nprint(minimum_traps(m, x))\n```",
    "31": "```python\ndef mod_inv(a, p):\n    return pow(a, p - 2, p)\n\ndef birthday_paradox(n, k):\n    MOD = 10**6 + 3\n    days = 1 << n  # 2^n\n    \n    if k > days:\n        return 1, 1  # Guaranteed at least two people share a birthday\n    \n    # P(no shared birthday) = days / days * (days - 1) / days * ... * (days - k + 1) / days\n    numerator = days\n    denominator = 1\n    \n    for i in range(1, k):\n        numerator *= (days - i)\n        denominator *= days\n        numerator %= MOD\n        denominator %= MOD\n    \n    # P(at least one shared birthday) = 1 - P(no shared birthday)\n    A = (denominator - numerator + MOD) % MOD\n    B = denominator\n    \n    # Reduce A and B\n    gcd_ab = gcd(A, B)\n    A //= gcd_ab\n    B //= gcd_ab\n    \n    return A, B\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    A, B = birthday_paradox(n, k)\n    print(A, B)\n```",
    "32": "```python\ndef is_valid_journey(n, journey):\n    current_position = 0  # 0 represents the North Pole, 20000 represents the South Pole\n    for t, direction in journey:\n        if current_position == 0 and direction != \"South\":\n            return \"NO\"  # At North Pole, can only go South\n        if current_position == 20000 and direction != \"North\":\n            return \"NO\"  # At South Pole, can only go North\n        \n        if direction == \"South\":\n            current_position += t\n        elif direction == \"North\":\n            current_position -= t\n        # West and East do not change the position in terms of latitude\n        # but we need to ensure that we don't go beyond the poles\n        if current_position < 0 or current_position > 20000:\n            return \"NO\"\n    \n    if current_position != 0:\n        return \"NO\"  # Journey must end at the North Pole\n    return \"YES\"\n\n# Input reading\nn = int(input().strip())\njourney = [input().strip().split() for _ in range(n)]\njourney = [(int(t), dir) for t, dir in journey]\n\n# Checking the validity of the journey\nresult = is_valid_journey(n, journey)\nprint(result)\n```",
    "33": "```python\ndef count_common_terms(a1, b1, a2, b2, L, R):\n    # Start with the first arithmetic progression\n    # x = a1 * k' + b1\n    # Start with the second arithmetic progression\n    # x = a2 * l' + b2\n\n    # We will solve for the integer solutions\n    from math import gcd\n    \n    # Calculate the difference and the modulo offset\n    diff = a2 - a1\n    offset = b1 - b2\n    \n    # If the sequences are the same\n    if diff == 0:\n        if (b1 - b2) % a1 == 0:\n            # Find the first and last valid x within [L, R]\n            first = max(L, b1)\n            last = min(R, b1 + (R - b1) // a1 * a1)\n            if first <= last:\n                return (last - first) // a1 + 1\n            else:\n                return 0\n        else:\n            return 0\n\n    # If the sequences are different, we'll find their intersection\n    # We need to solve a1 * k' + b1 = a2 * l' + b2\n    # Rearranging gives us: a1 * k' - a2 * l' = b2 - b1\n\n    # Expressed in the form:\n    # a1 * k' - a2 * l' = offset\n    # We need integer solutions for k' and l'\n\n    # Find the greatest common divisor\n    g = gcd(a1, a2)\n\n    # Check if offset is divisible by g\n    if offset % g != 0:\n        return 0\n\n    # Scale down the equation\n    a1 //= g\n    a2 //= g\n    offset //= g\n\n    # Now we need to find k' and l' such that:\n    # a1 * k' - a2 * l' = offset\n    # where k', l' >= 0\n\n    # The general solution for the diophantine equation can be derived\n    # We need to find particular solutions first\n    # Using extended Euclidean algorithm to find one solution\n    def extended_gcd(x, y):\n        if y == 0:\n            return x, 1, 0\n        g, x1, y1 = extended_gcd(y, x % y)\n        return g, y1, x1 - (x // y) * y1\n\n    g, x0, y0 = extended_gcd(a1, a2)\n\n    # Scaling the solution to our offset\n    x0 *= offset\n    y0 *= offset\n\n    # Now we have one particular solution (x0, y0)\n    # General solution:\n    # k' = x0 + (a2 // g) * t\n    # l' = y0 + (a1 // g) * t\n\n    # We need to find bounds on t such that k' >= 0 and l' >= 0\n    a2_g = a2 // g\n    a1_g = a1 // g\n\n    # Finding bounds for t\n    t_min_k = (-x0 + a2_g - 1) // a2_g if x0 < 0 else 0\n    t_min_l = (-y0 + a1_g - 1) // a1_g if y0 < 0 else 0\n\n    t_min = max(t_min_k, t_min_l)\n    \n    # Finding the maximum t such that within bounds\n    # Substitute k' into the original range [L, R]\n    # a1 * (x0 + a2_g * t) + b1 <= R\n    # a1 * x0 + b1 + a1 * a2_g * t <= R\n    # a1 * a2_g * t <= R - (a1 * x0 + b1)\n    # t <= (R - (a1 * x0 + b1)) // (a1 * a2_g)\n\n    t_max = (R - (a1 * x0 + b1)) // (a1 * a2_g) if a1 * a2_g > 0 else float('inf')\n\n    # t is bounded between t_min and t_max\n    if t_min > t_max:\n        return 0\n    \n    return t_max - t_min + 1\n\n# Reading input\na1, b1, a2, b2, L, R = map(int, input().split())\nresult = count_common_terms(a1, b1, a2, b2, L, R)\nprint(result)\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    def can_distribute(x):\n        plates_from_a = a // x\n        plates_from_b = b // x\n        return plates_from_a + plates_from_b >= n\n    \n    low, high = 1, max(a, b)\n    result = 0\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if can_distribute(mid):\n            result = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return result\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Compute and print the result\nprint(max_min_pieces(n, a, b))\n```",
    "35": "```python\ndef is_valid_flag(n, m, field):\n    # Check for horizontal stripes\n    if n % 3 == 0:\n        stripe_height = n // 3\n        colors = set()\n        for i in range(3):\n            stripe = field[i * stripe_height:(i + 1) * stripe_height]\n            if len(set(row for row in stripe)) != 1:\n                return \"NO\"\n            colors.add(stripe[0][0])\n        if len(colors) == 3:\n            return \"YES\"\n\n    # Check for vertical stripes\n    if m % 3 == 0:\n        stripe_width = m // 3\n        colors = set()\n        for i in range(3):\n            stripe = [row[i * stripe_width:(i + 1) * stripe_width] for row in field]\n            if len(set(row for row in stripe)) != 1:\n                return \"NO\"\n            colors.add(stripe[0][0])\n        if len(colors) == 3:\n            return \"YES\"\n\n    return \"NO\"\n\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\nprint(is_valid_flag(n, m, field))\n```",
    "36": "```python\ndef hexagonal_spiral(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 6\n    total_moves = 0\n\n    while total_moves + moves_in_layer <= n:\n        total_moves += moves_in_layer\n        layer += 1\n        moves_in_layer += 6\n\n    remaining_moves = n - total_moves\n    x, y = layer, 0\n\n    if remaining_moves == 0:\n        return (x, y)\n\n    direction = remaining_moves // 1\n    if direction == 1:\n        x, y = layer, 0\n    elif direction == 2:\n        x, y = layer - (remaining_moves - 1), remaining_moves - 1\n    elif direction == 3:\n        x, y = -remaining_moves + 1, layer\n    elif direction == 4:\n        x, y = -layer, layer - (remaining_moves - 3)\n    elif direction == 5:\n        x, y = -layer + (remaining_moves - 4), -layer\n    elif direction == 6:\n        x, y = remaining_moves - 5, -layer + (remaining_moves - 5)\n\n    return (x, y)\n\nn = int(input().strip())\nresult = hexagonal_spiral(n)\nprint(result[0], result[1])\n```",
    "37": "```python\na, b, c = map(int, input().split())\n\ndef can_deal_exact_damage(a, b, c):\n    for i in range(c // a + 1):\n        if (c - i * a) % b == 0:\n            return True\n    return False\n\nif can_deal_exact_damage(a, b, c):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```",
    "38": "```python\ndef can_be_same_track(n, L, kefa_distances, sasha_distances):\n    # Calculate the differences between consecutive barriers for both\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Check if we can find a rotation of kefa_diffs that matches sasha_diffs\n    for i in range(n):\n        # Rotate kefa_diffs by i positions\n        rotated_kefa_diffs = kefa_diffs[i:] + kefa_diffs[:i]\n        if rotated_kefa_diffs == sasha_diffs:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output result\nprint(can_be_same_track(n, L, kefa_distances, sasha_distances))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ns = input().strip()\n\nif not is_palindrome(s):\n    print(len(s))\nelse:\n    n = len(s)\n    if s[0] != s[-1]:\n        print(n)\n    else:\n        print(0)\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\nrated = False\nunrated = False\n\nfor a, b in ratings:\n    if a != b:\n        rated = True\n        break\n\nif rated:\n    print(\"rated\")\nelse:\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            unrated = True\n            break\n\n    if unrated:\n        print(\"unrated\")\n    else:\n        print(\"maybe\")\n```",
    "41": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the distance array with a large number\ndistances = [float('inf')] * n\n\n# First pass: from left to right\nlast_zero = -1\nfor i in range(n):\n    if a[i] == 0:\n        last_zero = i\n        distances[i] = 0\n    elif last_zero != -1:\n        distances[i] = i - last_zero\n\n# Second pass: from right to left\nlast_zero = -1\nfor i in range(n - 1, -1, -1):\n    if a[i] == 0:\n        last_zero = i\n    elif last_zero != -1:\n        distances[i] = min(distances[i], last_zero - i)\n\nprint(' '.join(map(str, distances)))\n```",
    "42": "```python\ndef count_cyclical_strings(n, s):\n    from itertools import product\n\n    len_s = len(s)\n    total_count = 0\n    seen = set()\n\n    # Generate all possible binary strings of length n\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n\n        # Check if any cyclic shift of t contains s\n        if any(s in t[i:] + t[:i] for i in range(n)):\n            if t not in seen:\n                seen.add(t)\n                total_count += 1\n\n    return total_count\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Get the result and print\nresult = count_cyclical_strings(n, s)\nprint(result)\n```",
    "43": "```python\nimport sys\nimport math\n\ndef angle_with_x_axis(x, y):\n    return math.atan2(y, x)\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    vectors = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n    \n    angles = [(angle_with_x_axis(x, y), i + 1) for i, (x, y) in enumerate(vectors)]\n    angles.sort()\n    \n    min_angle = float('inf')\n    min_index_pair = (0, 0)\n    \n    for i in range(n):\n        a1, index1 = angles[i]\n        a2, index2 = angles[(i + 1) % n]\n        \n        angle_diff = abs(a2 - a1)\n        if angle_diff > math.pi:\n            angle_diff = 2 * math.pi - angle_diff\n        \n        if angle_diff < min_angle:\n            min_angle = angle_diff\n            min_index_pair = (index1, index2)\n    \n    print(min_index_pair[0], min_index_pair[1])\n\nif __name__ == \"__main__\":\n    main()\n```",
    "44": "```python\ndef minimal_time(d, k, a, b, t):\n    # Time if Vasiliy walks the entire distance\n    walk_time = d * b\n\n    # Initialize the minimum time to the walking time\n    min_time = walk_time\n\n    # Calculate the maximum number of full k kilometers Vasiliy can drive\n    full_drives = d // k\n    remaining_distance = d % k\n\n    # Calculate time taken for each possible scenario of driving and walking\n    for drives in range(full_drives + 1):\n        # Distance driven by car\n        distance_driven = drives * k\n\n        # Time taken for driving\n        driving_time = distance_driven * a\n        \n        # Time taken for repairs\n        repairs_time = drives * t\n\n        # Remaining distance to walk\n        distance_to_walk = d - distance_driven\n        \n        # Time taken for walking\n        walking_time = distance_to_walk * b\n\n        # Total time for this combination\n        total_time = driving_time + repairs_time + walking_time\n\n        # Update the minimum time\n        min_time = min(min_time, total_time)\n\n    return min_time\n\n# Read input\nd, k, a, b, t = map(int, input().split())\n# Print the result\nprint(minimal_time(d, k, a, b, t))\n```",
    "45": "```python\ndef find_sequence(n, k):\n    if n < k * (k + 1) // 2:  # Minimum sum of first k positive integers\n        return -1\n\n    # Maximum GCD we can use\n    g = n // k\n    # Adjust the numbers based on the GCD\n    sequence = [i * g for i in range(1, k + 1)]\n    \n    # Calculate the remaining sum after using the minimum strictly increasing sequence\n    remaining = n - sum(sequence)\n    \n    # Distribute the remaining value to the last element in the sequence\n    sequence[-1] += remaining\n    \n    return sequence\n\n# Read input\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "46": "```python\nn, m = map(int, input().split())\n\n# Count how many numbers in the range 1 to n give each remainder when divided by 5\ncount_x = [0] * 5\nfor i in range(1, n + 1):\n    count_x[i % 5] += 1\n\n# Count how many numbers in the range 1 to m give each remainder when divided by 5\ncount_y = [0] * 5\nfor j in range(1, m + 1):\n    count_y[j % 5] += 1\n\n# Calculate the number of valid pairs (x, y)\nresult = 0\nfor r in range(5):\n    result += count_x[r] * count_y[(5 - r) % 5]\n\nprint(result)\n```",
    "47": "```python\ndef max_subarray_sum(arr):\n    max_sum = 0\n    current_sum = 0\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef max_beauty_with_multiplication(n, x, a):\n    original_beauty = max_subarray_sum(a)\n    \n    if x == 1:\n        return original_beauty\n    \n    # Calculate prefix sums\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    max_gain = 0\n    \n    # We will consider every possible subarray [l, r]\n    for l in range(n):\n        for r in range(l, n):\n            # Subarray a[l:r+1] will be multiplied by x\n            subarray_sum = prefix_sum[r + 1] - prefix_sum[l]\n            new_subarray_sum = subarray_sum * x\n            # Gain from changing this subarray\n            gain = new_subarray_sum - subarray_sum\n            \n            # Update maximum gain\n            max_gain = max(max_gain, gain)\n\n    return original_beauty + max_gain\n\n# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = max_beauty_with_multiplication(n, x, a)\nprint(result)\n```",
    "48": "```python\ndef kth_largest_in_multiplication_table(n, m, k):\n    left, right = 1, n * m\n    \n    while left < right:\n        mid = (left + right) // 2\n        count = sum(min(mid // i, m) for i in range(1, n + 1))\n        \n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return left\n\n# Read input\nn, m, k = map(int, input().split())\n# Output the k-th largest number\nprint(kth_largest_in_multiplication_table(n, m, k))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    digit_length = 1\n    count = 9\n    start = 1\n\n    while k > digit_length * count:\n        k -= digit_length * count\n        digit_length += 1\n        count *= 10\n        start *= 10\n\n    start += (k - 1) // digit_length\n    number = str(start)\n    return int(number[(k - 1) % digit_length])\n\nk = int(input().strip())\nprint(find_kth_digit(k))\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, n, graph):\n    dist = [-1] * (n + 1)\n    dist[start] = 0\n    q = deque([start])\n    farthest_node = start\n    \n    while q:\n        node = q.popleft()\n        for neighbor in graph[node]:\n            if dist[neighbor] == -1:  # Not visited\n                dist[neighbor] = dist[node] + 1\n                q.append(neighbor)\n                if dist[neighbor] > dist[farthest_node]:\n                    farthest_node = neighbor\n\n    return farthest_node, dist\n\ndef main():\n    n = int(input())\n    graph = defaultdict(list)\n\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Find the farthest point from an arbitrary starting point (1)\n    farthest_node_from_start, _ = bfs(1, n, graph)\n    \n    # Find the farthest point from the previously found farthest node\n    opposite_node, dist_from_opposite = bfs(farthest_node_from_start, n, graph)\n\n    # Get the farthest node from the opposite node\n    farthest_node_from_opposite, dist_from_farthest = bfs(opposite_node, n, graph)\n\n    # Now we have the diameter ends: farthest_node_from_start and farthest_node_from_opposite\n    # Let's find the third node that maximizes the edge count\n    # We can take the farthest node from the first node we started with (or any node in the tree)\n    \n    # Collect nodes with maximum distance from either endpoint\n    max_distance = -1\n    third_node = -1\n    for i in range(1, n + 1):\n        if dist_from_opposite[i] > max_distance:\n            max_distance = dist_from_opposite[i]\n            third_node = i\n            \n    # The three nodes are:\n    a = farthest_node_from_start\n    b = opposite_node\n    c = third_node\n    \n    # Output the result\n    print(len(set([a, b, c])) + 2)  # The edges involved are the distinct edges in the paths\n    print(a, b, c)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "51": "```python\nfrom collections import Counter\nimport sys\n\nn = int(input().strip())\ndivisors = list(map(int, input().strip().split()))\n\n# Count the occurrences of each divisor\ncount = Counter(divisors)\n\n# Initialize x and y\nx, y = 1, 1\n\n# For each divisor, if it appears twice, it is a common divisor\nfor d in count:\n    if count[d] == 2:\n        # If d appears twice, it is a divisor for both x and y\n        x *= d\n        y *= d\n    elif count[d] == 1:\n        # If d appears once, assign it to either x or y\n        if x < y:\n            x *= d\n        else:\n            y *= d\n\nprint(x, y)\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    from itertools import combinations\n\n    max_half_selection = m // 2\n    total_max_sum = 0\n\n    for row in matrix:\n        row.sort(reverse=True)  # Sort the row in descending order to maximize sum\n        current_max_sum = 0\n        \n        # Check all possible ways to choose up to max_half_selection elements\n        for r in range(max_half_selection + 1):\n            for combo in combinations(row, r):\n                current_sum = sum(combo)\n                if current_sum % k == 0:\n                    current_max_sum = max(current_max_sum, current_sum)\n        \n        total_max_sum += current_max_sum\n\n    return total_max_sum\n\n# Input reading\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = max_sum_divisible_by_k(n, m, k, matrix)\nprint(result)\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = -1\n    result = []\n    moves = []\n\n    while left <= right:\n        if a[left] > last_taken and (a[right] <= last_taken or a[left] < a[right]):\n            result.append(a[left])\n            moves.append('L')\n            last_taken = a[left]\n            left += 1\n        elif a[right] > last_taken:\n            result.append(a[right])\n            moves.append('R')\n            last_taken = a[right]\n            right -= 1\n        else:\n            break\n\n    print(len(result))\n    print(''.join(moves))\n\n# Input reading\nn = int(input().strip())\na = list(map(int, input().strip().split()))\nlongest_increasing_sequence(n, a)\n```",
    "54": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_a = min(a)\nmax_a = max(a)\n\n# If all elements are the same, D = 0 is sufficient\nif min_a == max_a:\n    print(0)\nelse:\n    # Calculate the required D\n    D = (max_a - min_a) // 2\n    if (max_a - min_a) % 2 == 0:\n        print(D)\n    else:\n        print(-1)\n```",
    "55": "```python\ndef is_visible(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n    # Check if the white sheet is completely covered by both black sheets\n    covered_left = max(x1, x3, x5)\n    covered_right = min(x2, x4, x6)\n    covered_bottom = max(y1, y3, y5)\n    covered_top = min(y2, y4, y6)\n\n    # If the covered area does not overlap with the white sheet\n    if covered_left < covered_right and covered_bottom < covered_top:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Determine if some part of the white sheet can be seen\nresult = is_visible(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6)\nprint(result)\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef reachable_count(n):\n    reachable = set()\n    queue = [n]\n    \n    while queue:\n        current = queue.pop()\n        if current not in reachable:\n            reachable.add(current)\n            next_value = f(current)\n            if next_value not in reachable:\n                queue.append(next_value)\n            for i in range(1, 10):\n                next_to_add = current - i\n                if next_to_add > 0 and next_to_add not in reachable:\n                    queue.append(next_to_add)\n    \n    return len(reachable)\n\nn = int(input())\nprint(reachable_count(n))\n```",
    "57": "```python\ndef fill_gifts(n, f):\n    # Identify givers and takers\n    givers = set(range(1, n + 1)) - set(filter(lambda x: x != 0, f))\n    takers = set(filter(lambda x: x != 0, f))\n    \n    # Find the friends who do not have a recipient (f_i = 0)\n    zero_indices = [i for i in range(n) if f[i] == 0]\n    \n    # Prepare a list for the final output\n    nf = f[:]\n    \n    # Assign gifts to friends who have f_i = 0\n    for i in zero_indices:\n        # Find a suitable gift recipient\n        for recipient in givers:\n            if recipient not in takers and recipient != (i + 1):\n                nf[i] = recipient\n                givers.remove(recipient)\n                takers.add(recipient)\n                break\n\n    return nf\n\n# Input reading\nn = int(input().strip())\nf = list(map(int, input().strip().split()))\n\n# Fill in the gifts\nresult = fill_gifts(n, f)\n\n# Output the result\nprint(' '.join(map(str, result)))\n```",
    "58": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nfrom collections import defaultdict\n\n# Store the indices of each unique number\nindex_map = defaultdict(list)\nfor idx, value in enumerate(a):\n    index_map[value].append(idx)\n\n# If we have more unique numbers than colors, it's impossible\nif len(index_map) > k:\n    print(\"NO\")\n    exit()\n\n# Prepare the result array\nresult = [0] * n\ncolor = 1\n\n# Assign colors to elements\nfor indices in index_map.values():\n    for i, idx in enumerate(indices):\n        result[idx] = (i % k) + 1\n\n# Output result\nprint(\"YES\")\nprint(\" \".join(map(str, result)))\n```",
    "59": "```python\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# We need the last x digits to be '000...010...0' where there are y zeros followed by a one\ntarget = ['0'] * x\ntarget[y] = '1'\n\n# Count the number of changes needed\nchanges = 0\nfor i in range(x):\n    if number[n - 1 - i] != target[x - 1 - i]:\n        changes += 1\n\nprint(changes)\n```",
    "60": "```python\ndef has_palindromic_subsequence(test_cases):\n    results = []\n    for n, a in test_cases:\n        found = False\n        # Use a dictionary to track the first occurrence of each number\n        first_occurrence = {}\n        for i in range(n):\n            if a[i] in first_occurrence:\n                # If we find a number that has appeared before\n                # and the distance between their indices is at least 2\n                if i - first_occurrence[a[i]] >= 2:\n                    found = True\n                    break\n            else:\n                first_occurrence[a[i]] = i\n        \n        if found:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Reading input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Getting results and printing\nresults = has_palindromic_subsequence(test_cases)\nfor result in results:\n    print(result)\n```",
    "61": "```python\nn = int(input())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\n# Convert f to a mapping from characters\nf_map = {str(i + 1): str(f[i]) for i in range(9)}\n\n# Initialize result as the original number\nresult = a\n\n# Flag to indicate if we are replacing the segment\nreplacing = False\nnew_number = []\n\nfor digit in a:\n    if not replacing and f_map[digit] > digit:\n        # Start replacing\n        replacing = True\n    elif replacing and f_map[digit] < digit:\n        # Stop replacing if we see a digit that should not be replaced\n        replacing = False\n        \n    if replacing:\n        new_number.append(f_map[digit])\n    else:\n        new_number.append(digit)\n\n# Join the new number and compare with original\nmax_number = ''.join(new_number)\nprint(max(max_number, a))\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        min_ops = float('inf')\n        best_a, best_b, best_c = 0, 0, 0\n        \n        # Loop through possible values for A\n        for A in range(1, a + 2):\n            # For a fixed A, calculate B and C that satisfy the conditions\n            if A > 0:\n                B = ((b + A - 1) // A) * A  # smallest B >= b and divisible by A\n                C = ((c + B - 1) // B) * B  # smallest C >= c and divisible by B\n                \n                ops = abs(A - a) + abs(B - b) + abs(C - c)\n                \n                if ops < min_ops:\n                    min_ops = ops\n                    best_a, best_b, best_c = A, B, C\n        \n        results.append((min_ops, best_a, best_b, best_c))\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations(t, test_cases)\n\n# Output results\nfor res in results:\n    print(res[0])\n    print(res[1], res[2], res[3])\n```",
    "63": "```python\ndef min_instability(n, a):\n    a.sort()\n    # Removing the smallest element or the largest element\n    instability1 = a[-1] - a[1]  # removing the first element\n    instability2 = a[-2] - a[0]  # removing the last element\n    return min(instability1, instability2)\n\nn = int(input())\na = list(map(int, input().split()))\nprint(min_instability(n, a))\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    # Create a schedule list initialized with rest days\n    schedule = [0] * n\n    \n    # Sort exams by their exam day for easier management\n    exams.sort(key=lambda x: x[1])  # Sort by exam day (d_i)\n    \n    # Prepare a list to track the preparation days needed\n    prep_needed = [0] * (n + 1)\n    \n    for i in range(m):\n        s_i, d_i, c_i = exams[i]\n        prep_needed[i + 1] = c_i  # Store the required preparation days for each exam\n    \n    # Attempt to fill the schedule\n    for i in range(m):\n        s_i, d_i, c_i = exams[i]\n        prep_days = 0\n        \n        # Try to allocate preparation days\n        for day in range(s_i - 1, d_i - 1):\n            if prep_needed[i + 1] > 0 and schedule[day] == 0:\n                schedule[day] = i + 1  # Mark preparation for exam i\n                prep_needed[i + 1] -= 1\n                prep_days += 1\n\n        # If we didn't manage to allocate enough preparation days\n        if prep_needed[i + 1] > 0:\n            return -1\n\n        # Now mark the day of the exam\n        schedule[d_i - 1] = m + 1  # Mark the exam day\n\n    return schedule\n\n# Read input\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the result\nresult = schedule_exams(n, m, exams)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "65": "```python\ndef transform_moves(n, m):\n    if m % n != 0:\n        return -1\n    \n    ratio = m // n\n    moves = 0\n    \n    while ratio > 1:\n        if ratio % 2 == 0:\n            ratio //= 2\n            moves += 1\n        elif ratio % 3 == 0:\n            ratio //= 3\n            moves += 1\n        else:\n            return -1\n    \n    return moves\n\nn, m = map(int, input().split())\nprint(transform_moves(n, m))\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Find the longest suffix of t that is also a prefix\n    longest_suffix_prefix = 0\n    for i in range(1, n):\n        if t[:i] == t[-i:]:\n            longest_suffix_prefix = i\n            \n    # Create the result string\n    result = t + (t[longest_suffix_prefix:] * (k - 1))\n    return result\n\n# Input reading\nn, k = map(int, input().split())\nt = input().strip()\n\n# Construct and print the result\nprint(construct_string(n, k, t))\n```",
    "67": "```python\nn = int(input())\na = list(map(int, input().split()))\n\ntotal_sum = sum(a)\nnice_indices = []\n\nfor i in range(n):\n    remaining_sum = total_sum - a[i]\n    if remaining_sum == a[i] * 2:  # Check if the remaining sum equals twice the removed element\n        nice_indices.append(i + 1)  # Store the 1-based index\n\nprint(len(nice_indices))\nif nice_indices:\n    print(' '.join(map(str, nice_indices)))\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    subsequence_count = {}\n    \n    # Generate all unique subsequences and their respective costs\n    from itertools import combinations\n    \n    for length in range(1, n + 1):\n        for indices in combinations(range(n), length):\n            subsequence = ''.join(s[i] for i in indices)\n            cost = n - length\n            if subsequence not in subsequence_count:\n                subsequence_count[subsequence] = cost\n    \n    # If we cannot reach k unique subsequences\n    if len(subsequence_count) < k:\n        return -1\n    \n    # Collect costs and sort them to minimize total cost\n    costs = sorted(subsequence_count.values())\n    \n    # Calculate the minimum total cost for the first k unique subsequences\n    total_cost = sum(costs[:k])\n    \n    return total_cost\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n    \n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Check if the degree D is possible (not exceeding the maximum degree of vertex 1)\n    if len(graph[1]) < D:\n        return \"NO\"\n    \n    # Prepare for BFS/DFS to build the spanning tree\n    visited = [False] * (n + 1)\n    visited[1] = True\n    spanning_tree_edges = []\n    \n    # Start from vertex 1\n    degree_count = 0\n    queue = deque([1])\n    \n    while queue and len(spanning_tree_edges) < n - 1:\n        current = queue.popleft()\n        \n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                if current == 1 and degree_count < D:\n                    # Allow vertex 1 to connect to D neighbors\n                    spanning_tree_edges.append((current, neighbor))\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    degree_count += 1\n                elif current != 1:\n                    # Any other vertex can connect to any unvisited neighbor\n                    spanning_tree_edges.append((current, neighbor))\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                \n                # Stop if we have enough edges\n                if len(spanning_tree_edges) == n - 1:\n                    break\n    \n    # Check if we have a spanning tree of size n-1\n    if len(spanning_tree_edges) != n - 1 or degree_count != D:\n        return \"NO\"\n    \n    result = [\"YES\"]\n    result.extend(f\"{u} {v}\" for u, v in spanning_tree_edges)\n    \n    return \"\\n\".join(result)\n\n# Input reading\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the result\nresult = find_spanning_tree(n, m, D, edges)\n\n# Print the result\nprint(result)\n```",
    "70": "```python\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Convert start and end times to minutes\nstart_minutes = h1 * 60 + m1\nend_minutes = h2 * 60 + m2\n\n# Calculate the midpoint in minutes\nmid_minutes = (start_minutes + end_minutes) // 2\n\n# Convert back to hours and minutes\nh3 = mid_minutes // 60\nm3 = mid_minutes % 60\n\n# Print the result in the specified format\nprint(f\"{h3:02}:{m3:02}\")\n```",
    "71": "```python\na = int(input())\noutput = (a - 1).bit_length()\nprint(output)\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    # Separate the left and right endpoints\n    lefts = [l for l, r in segments]\n    rights = [r for l, r in segments]\n\n    # Calculate the overall max and min of lefts and rights\n    max_left = max(lefts)\n    min_right = min(rights)\n\n    # Prepare to find the maximum length of intersection when one segment is removed\n    max_length = 0\n\n    # Calculate the second maximum left and second minimum right\n    if n == 2:\n        return max(0, min_right - max_left)\n\n    # Initialize second max and min values\n    second_max_left = -float('inf')\n    second_min_right = float('inf')\n\n    for l in lefts:\n        if l > second_max_left and l < max_left:\n            second_max_left = l\n\n    for r in rights:\n        if r < second_min_right and r > min_right:\n            second_min_right = r\n\n    # Calculate the intersection lengths when removing each segment\n    for i in range(n):\n        l_i, r_i = segments[i]\n        \n        if l_i == max_left:\n            new_left = second_max_left\n        else:\n            new_left = max_left\n            \n        if r_i == min_right:\n            new_right = second_min_right\n        else:\n            new_right = min_right\n        \n        # Calculate the length of the intersection\n        length = max(0, new_right - new_left)\n        max_length = max(max_length, length)\n\n    return max_length\n\n# Input reading\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_intersection_length(n, segments))\n```",
    "73": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmax_height = max(a)\nmin_height = min(a)\n\n# Check if all parts can be raised to the max height\nfor height in a:\n    if (height < min_height) or (height > max_height):\n        print(\"NO\")\n        break\nelse:\n    # Check for gaps in the wall\n    if any(a[i] < a[i-1] for i in range(1, n)):\n        print(\"NO\")\n    else:\n        print(\"YES\")\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    # Generate all unique subsequences using a set\n    subsequences = set()\n    \n    # Function to generate subsequences using recursion\n    def generate_subsequences(prefix, index):\n        if index == n:\n            if prefix:\n                subsequences.add(prefix)\n            return\n        # Include current character\n        generate_subsequences(prefix + s[index], index + 1)\n        # Exclude current character\n        generate_subsequences(prefix, index + 1)\n\n    # Start generating subsequences from the first character\n    generate_subsequences(\"\", 0)\n    \n    # Check if we have enough unique subsequences\n    if len(subsequences) < k:\n        return -1\n    \n    # Calculate the total minimum cost\n    # Sort subsequences by their lengths\n    sorted_subsequences = sorted(subsequences, key=len)\n    total_cost = 0\n    for i in range(k):\n        total_cost += n - len(sorted_subsequences[i])\n    \n    return total_cost\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result and print it\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Days of the week food schedule\n    week_food = [a, b, c, a, c, b, a]  # fish, rabbit, chicken respectively\n    \n    # Calculate how many complete weeks can be sustained\n    complete_weeks = min(a // 3, b // 2, c // 1)\n    a -= complete_weeks * 3\n    b -= complete_weeks * 2\n    c -= complete_weeks * 1\n    \n    # Now check for how many additional days we can go\n    max_additional_days = 0\n    \n    # Try starting from each day of the week\n    for start_day in range(7):\n        food = [a, b, c]\n        days = 0\n        \n        # Simulate days\n        for i in range(7):\n            day = (start_day + i) % 7\n            if food[day // 2] > 0:  # fish food for 0, 3, 6 | rabbit for 1, 5 | chicken for 2, 4\n                food[day // 2] -= 1\n                days += 1\n            else:\n                break\n        \n        max_additional_days = max(max_additional_days, days)\n    \n    return complete_weeks * 7 + max_additional_days\n\n# Input\na, b, c = map(int, input().split())\nprint(max_days(a, b, c))\n```",
    "76": "```python\ndef can_construct_symmetric_square(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        # To construct a symmetric m x m square, we need to check if we have\n        # at least one tile type that can fulfill the symmetry requirement.\n        found = False\n        for tile in tiles:\n            # tile is a tuple of tuples: ((a, b), (c, d))\n            a, b = tile[0]\n            c, d = tile[1]\n            if b == c:\n                found = True\n                break\n        \n        if found:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for __ in range(n):\n        top = tuple(map(int, input().split()))\n        bottom = tuple(map(int, input().split()))\n        tiles.append((top, bottom))\n    test_cases.append((n, m, tiles))\n\n# Get results\nresults = can_construct_symmetric_square(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "77": "```python\ndef minimum_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nn = int(input().strip())\nprint(minimum_difference(n))\n```",
    "78": "```python\nMOD = 10**9 + 7\n\ndef count_regular_sequences(n, s):\n    m = len(s)\n    \n    # Precompute Catalan numbers up to 2n\n    C = [0] * (2 * n + 1)\n    C[0] = 1\n    for i in range(1, 2 * n + 1):\n        C[i] = C[i - 1] * (2 * i - 1) // (i + 1) % MOD\n\n    # Check balance and min balance of s\n    balance = 0\n    min_balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n\n    if balance < 0 or balance > 2 * n - m or min_balance < 0:\n        return 0\n\n    # Count valid placements of s in a valid sequence\n    total_count = 0\n    for k in range(n + 1):\n        if k < -min_balance:  # Not enough opening brackets\n            continue\n        if k > n + (balance - m) // 2:  # Too many opening brackets\n            continue\n        \n        total_count += C[n - k] * C[n - k + (balance - m) // 2] % MOD\n        total_count %= MOD\n\n    return total_count\n\nn = int(input())\ns = input().strip()\nprint(count_regular_sequences(n, s))\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    positions = []\n\n    # Find positions of '0' and '5' to form '25' or '00'\n    for i in range(length):\n        if s[i] == '0' or s[i] == '5':\n            positions.append((s[i], i))\n\n    min_moves = float('inf')\n    found = False\n\n    # Check pairs of digits that can form '25', '00', or '75'\n    for i in range(length):\n        for j in range(i + 1, length):\n            if (s[i], s[j]) in [('2', '5'), ('7', '5'), ('0', '0')]:\n                if s[i] == '2' and s[j] == '5':\n                    moves = (j - i) + (length - 1 - j)\n                elif s[i] == '7' and s[j] == '5':\n                    moves = (j - i) + (length - 1 - j)\n                elif s[i] == '0' and s[j] == '0':\n                    moves = (j - i) + (length - 1 - j)\n\n                found = True\n                min_moves = min(min_moves, moves)\n\n    return min_moves if found else -1\n\n# Input reading\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    colors = [0] * n\n    color_count = 0\n    last_seen = {}\n    \n    for i in range(n):\n        char = s[i]\n        if char in last_seen:\n            colors[i] = last_seen[char]\n        else:\n            color_count += 1\n            last_seen[char] = color_count\n            colors[i] = color_count\n            \n        # Ensure that we maintain the correct colorings for sorting\n        for j in range(i):\n            if s[j] > s[i] and colors[j] == colors[i]:\n                colors[j] = color_count + 1\n                color_count += 1\n                \n    print(color_count)\n    print(' '.join(map(str, colors)))\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\nmin_colors_to_sort(n, s)\n```",
    "81": "```python\ndef can_reorder_as_substrings(n, strings):\n    # Sort the strings by their lengths\n    strings.sort(key=len)\n    \n    # Check if each string is a substring of the next strings in the list\n    for i in range(n):\n        for j in range(i + 1, n):\n            if strings[i] not in strings[j]:\n                print(\"NO\")\n                return\n    \n    print(\"YES\")\n    for s in strings:\n        print(s)\n\n# Input reading\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\n# Call the function\ncan_reorder_as_substrings(n, strings)\n```",
    "82": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncount = 0\n\n# Solve from the left\nwhile count < n and a[count] <= k:\n    count += 1\n\n# Solve from the right\nwhile count < n and a[n - 1 - (count - count)] <= k:\n    count += 1\n\n# The count could have counted the overlap in the middle\n# So we need to ensure we don't double count the last problem\nif count > n:\n    count = n\n\nprint(count)\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total = a + b\n    min_perimeter = float('inf')\n\n    for width in range(1, int(total**0.5) + 1):\n        if total % width == 0:\n            height = total // width\n            \n            # Check all combinations of width and height for red and blue rectangles\n            for (x, y) in [(width, height), (height, width)]:\n                # Check for red rectangle\n                for red_width in range(1, int(x**0.5) + 1):\n                    if a % red_width == 0:\n                        red_height = a // red_width\n                        if red_height <= y:\n                            # Check for blue rectangle\n                            for blue_width in range(1, int(x**0.5) + 1):\n                                if b % blue_width == 0:\n                                    blue_height = b // blue_width\n                                    if blue_height <= y:\n                                        perimeter = 2 * (x + y)\n                                        min_perimeter = min(min_perimeter, perimeter)\n\n    return min_perimeter\n\n# Read input\na, b = map(int, input().split())\n# Print the result\nprint(minimal_perimeter(a, b))\n```",
    "84": "```python\ndef can_color_string(n, s):\n    # Create a list to store the positions of each character\n    positions = {}\n    \n    for i, char in enumerate(s):\n        if char not in positions:\n            positions[char] = []\n        positions[char].append(i)\n    \n    # Prepare to create the coloring\n    color = [''] * n\n    current_color = 0\n    \n    # Sort the keys to iterate in alphabetical order\n    sorted_chars = sorted(positions.keys())\n    \n    for char in sorted_chars:\n        # Get the indices for this character\n        indices = positions[char]\n        \n        # Check if we can color without conflict\n        for index in indices:\n            if color[index] == '':\n                color[index] = str(current_color)\n            else:\n                # Conflict in coloring\n                if color[index] != str(current_color):\n                    return \"NO\"\n        \n        # Switch color for the next character\n        current_color = 1 - current_color\n    \n    return \"YES\", ''.join(color)\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Get the result\nresult = can_color_string(n, s)\n\n# Print the output\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    print(result[1])\n```",
    "85": "```python\nA, B = map(int, input().split())\n\ndef find_lowest_price(A, B):\n    for price in range(1, 10000):  # Arbitrary upper limit, can be increased if needed\n        tax_8 = int(price * 0.08)\n        tax_10 = int(price * 0.10)\n        if tax_8 == A and tax_10 == B:\n            return price\n    return -1\n\nresult = find_lowest_price(A, B)\nprint(result)\n```",
    "86": "```python\ndef solve_problems(n, k):\n    # Minimum problems needed with strictly increasing sequence\n    min_needed = k * (k + 1) // 2\n    \n    if n < min_needed:\n        print(\"NO\")\n        return\n    \n    # Start with the minimum valid sequence\n    a = list(range(1, k + 1))\n    remaining = n - min_needed\n    \n    # Distribute the remaining problems as optimally as possible\n    for i in range(k - 1, -1, -1):\n        if remaining == 0:\n            break\n        \n        # Maximum we can add to a[i] while respecting the constraints\n        max_possible_increase = min(remaining, 2 * a[i] - a[i + 1] if i < k - 1 else float('inf'))\n        \n        a[i] += max_possible_increase\n        remaining -= max_possible_increase\n    \n    # Check if we have exactly n problems solved\n    if sum(a) == n:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n    else:\n        print(\"NO\")\n\n# Read input\nn, k = map(int, input().split())\nsolve_problems(n, k)\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects based on required rating\n    projects.sort()\n    \n    completed = 0\n    current_rating = r\n    \n    while True:\n        progress = False\n        for i in range(len(projects)):\n            a, b = projects[i]\n            if a <= current_rating:\n                current_rating += b\n                # If current rating drops below zero, skip this project\n                if current_rating < 0:\n                    current_rating -= b  # revert change\n                else:\n                    completed += 1\n                    projects[i] = (float('inf'), 0)  # mark as completed\n                    progress = True\n                    break\n        if not progress:\n            break\n    \n    return completed\n\n# Read input\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the maximum possible size of the subset\nprint(max_projects(n, r, projects))\n```",
    "88": "```python\ndef create_palindromic_matrix(n, values):\n    from collections import Counter\n\n    count = Counter(values)\n    odd_count = sum(1 for v in count.values() if v % 2 != 0)\n\n    if (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n        return \"NO\"\n\n    matrix = [[0] * n for _ in range(n)]\n    half = []\n\n    for value, cnt in count.items():\n        half.extend([value] * (cnt // 2))\n\n    if n % 2 == 1:\n        center = [value for value, cnt in count.items() if cnt % 2 == 1]\n        if center:\n            center_value = center[0]\n        else:\n            center_value = None\n    else:\n        center_value = None\n\n    if center_value is not None:\n        middle_row = n // 2\n        matrix[middle_row][middle_row] = center_value\n    \n    half_size = len(half)\n    for i in range(half_size // 2):\n        r = i // (n // 2)\n        c = i % (n // 2)\n        value = half[i]\n        matrix[r][c] = value\n        matrix[r][n - c - 1] = value\n        matrix[n - r - 1][c] = value\n        matrix[n - r - 1][n - c - 1] = value\n\n    return \"YES\", matrix\n\nn = int(input())\nvalues = list(map(int, input().split()))\n\nresult = create_palindromic_matrix(n, values)\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for row in result[1]:\n        print(\" \".join(map(str, row)))\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    projects.sort(key=lambda x: x[0])  # Sort projects by required rating\n\n    for a, b in projects:\n        if r < a:  # If current rating is less than required for the project\n            return \"NO\"\n        r += b  # Update rating after completing the project\n        if r < 0:  # Rating should not fall below zero\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(can_complete_projects(n, r, projects))\n```",
    "90": "```python\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# If the maximum jump distance d is greater than or equal to n, it's always possible\nif d >= n:\n    print(\"YES\")\n    print(\"0 \" * (n - sum(c)) + \" \".join(str(i + 1) for i in range(m) for _ in range(c[i])))\nelse:\n    # Calculate the total length of platforms\n    total_length = sum(c)\n    \n    # Calculate the maximum number of gaps needed\n    gaps_needed = m - 1\n    \n    # Check if we can fit the platforms with the gaps\n    if total_length + gaps_needed * d < n:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        result = [0] * n\n        position = 0\n        \n        for i in range(m):\n            # Place the platform\n            for j in range(c[i]):\n                result[position + j] = i + 1\n            position += c[i]\n            # If it's not the last platform, leave a gap\n            if i < m - 1:\n                position += d\n        \n        print(\" \".join(map(str, result)))\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n    \n    # Precompute the positions of each character in t in s\n    left = [0] * m\n    right = [0] * m\n    \n    # Fill the left array\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n    \n    # Fill the right array\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n    \n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n    \n    # Consider the part before the first character of t and after the last character of t\n    max_length = max(max_length, left[0])  # Before first occurrence\n    max_length = max(max_length, n - 1 - right[m - 1])  # After last occurrence\n    \n    return max_length\n\n# Input\ns = input().strip()\nt = input().strip()\n\n# Output\nprint(max_removable_length(s, t))\n```",
    "92": "```python\nx = float(input().strip())\n\n# We need to find integers a and b such that 1 <= a, b <= 10 and a * b is approximately equal to x\n# The simplest approach is to iterate through all possible values for a and b\nfor a in range(1, 11):\n    for b in range(1, 11):\n        if abs(a * b - x) < 1e-6:  # Use a small tolerance for floating point comparison\n            print(a, b)\n            break\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1 or (d > n - 1) or (k == 1 and n > 1) or (d == 0 and n > 1):\n        print(\"NO\")\n        return\n\n    edges = []\n    \n    # Build the main path to achieve the diameter d\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n\n    # Now we have d + 1 vertices in the main path\n    current_vertex = d + 2\n\n    # Connect remaining vertices\n    for i in range(1, d + 2):\n        if current_vertex > n:\n            break\n        # For each vertex in the path, we can add more vertices until we reach degree k\n        for _ in range(k - 1):  # We already have one connection in the path\n            if current_vertex > n:\n                break\n            edges.append((i, current_vertex))\n            current_vertex += 1\n\n    if current_vertex <= n:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for u, v in edges:\n            print(u, v)\n\n# Read input\nn, d, k = map(int, input().strip().split())\nconstruct_tree(n, d, k)\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Start with the maximum alternation\n    s = []\n    \n    # Calculate the number of segments\n    num_segments = x + 1\n    \n    # Determine how many 0s and 1s to distribute in segments\n    zero_segments = min(num_segments, a + 1)\n    one_segments = min(num_segments, b + 1)\n    \n    # Calculate the number of 0s and 1s per segment\n    zeros_per_segment = a // zero_segments\n    ones_per_segment = b // one_segments\n    \n    # Calculate the remaining 0s and 1s after even distribution\n    remaining_zeros = a % zero_segments\n    remaining_ones = b % one_segments\n    \n    # Build the segments\n    for i in range(num_segments):\n        if i % 2 == 0:  # Even index - place 0s\n            count = zeros_per_segment + (1 if i < remaining_zeros else 0)\n            s.append('0' * count)\n        else:  # Odd index - place 1s\n            count = ones_per_segment + (1 if i < remaining_ones else 0)\n            s.append('1' * count)\n    \n    # Join the segments into a single string\n    result = ''.join(s)\n    \n    # If the length of the result is not exactly a + b, adjust by trimming\n    if len(result) > a + b:\n        result = result[:a + b]\n    \n    return result\n\n# Read input\na, b, x = map(int, input().split())\n\n# Generate and print the binary string\nprint(construct_binary_string(a, b, x))\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Create a list of the characters we need\n    chars = ['a'] * n + ['b'] * n + ['c'] * n\n    \n    # Check for impossible cases\n    if (s[0] == t[0] and s[1] == t[1]) or (s[0] == t[1] and s[1] == t[0]):\n        return \"NO\"\n    \n    # Attempt to create the result string\n    from itertools import permutations\n    \n    for perm in permutations(chars):\n        res = ''.join(perm)\n        if s not in res and t not in res:\n            return f\"YES\\n{res}\"\n    \n    return \"NO\"\n\nn = int(input().strip())\ns = input().strip()\nt = input().strip()\n\nresult = generate_string(n, s, t)\nprint(result)\n```",
    "96": "```python\nn = int(input())\nq = list(map(int, input().split()))\n\n# Initialize the permutation array\np = [0] * n\np[0] = 0  # Start from an arbitrary point, we will adjust later\n\n# Build the prefix sums based on q\nfor i in range(1, n):\n    p[i] = p[i - 1] + q[i - 1]\n\n# Find the minimum value in p to adjust to a valid permutation\nmin_p = min(p)\n\n# Adjust all elements to ensure the smallest value is 1\nadjustment = 1 - min_p\nfor i in range(n):\n    p[i] += adjustment\n\n# Check if the adjusted array is a valid permutation\nif len(set(p)) == n and all(1 <= x <= n for x in p):\n    print(' '.join(map(str, p)))\nelse:\n    print(-1)\n```",
    "97": "```python\nn = int(input())\nx = list(map(int, input().split()))\n\neven_count = sum(1 for i in x if i % 2 == 0)\nodd_count = n - even_count\n\n# Minimum coins needed to move all chips to the same coordinate\nresult = min(even_count, odd_count)\nprint(result)\n```",
    "98": "```python\ndef min_moves_to_reach(N):\n    moves = float('inf')\n    \n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            moves = min(moves, (i - 1) + (j - 1))\n    \n    return moves\n\nN = int(input())\nprint(min_moves_to_reach(N))\n```",
    "99": "```python\n# Read input values\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\n# Maximum wins calculation\nmax_wins = min(a1, b2) + min(a2, b3) + min(a3, b1)\n\n# Minimum wins calculation\n# Calculate losses for Alice\nalice_loses = 0\nalice_loses += max(0, b1 - a3)  # Bob's rocks beat Alice's paper\nalice_loses += max(0, b2 - a1)  # Bob's scissors beat Alice's rock\nalice_loses += max(0, b3 - a2)  # Bob's paper beats Alice's scissors\n\nmin_wins = n - alice_loses\n\n# Output the results\nprint(min_wins, max_wins)\n```"
}