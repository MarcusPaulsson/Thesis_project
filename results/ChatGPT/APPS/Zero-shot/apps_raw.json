{
    "2": "```python\nn = int(input())\n\ndef is_lucky(year):\n    non_zero_digits = sum(1 for digit in str(year) if digit != '0')\n    return non_zero_digits <= 1\n\nnext_year = n + 1\nwhile not is_lucky(next_year):\n    next_year += 1\n\nprint(next_year - n)\n```",
    "7": "```python\ndef find_empty_day(n, m):\n    day = 0\n    total_eaten = 0\n    \n    while n > 0:\n        day += 1\n        total_eaten += day\n        \n        # Add grains to the barn\n        n += m\n        \n        # If the barn overflows, it stays full\n        if n > m:\n            n = min(n, m)\n        \n        # Sparrows eat grains\n        n -= total_eaten\n        \n    return day\n\n# Read input\nn, m = map(int, input().split())\nprint(find_empty_day(n, m))\n```",
    "5": "```python\nn, pos, l, r = map(int, input().split())\n\nif l == 1 and r == n:\n    print(0)\nelse:\n    seconds = 0\n    \n    if pos < l:\n        seconds += l - pos  # Move to l\n        seconds += 1  # Close left\n        seconds += r - l  # Move to r\n        seconds += 1  # Close right\n    elif pos > r:\n        seconds += pos - r  # Move to r\n        seconds += 1  # Close right\n        seconds += r - l  # Move to l\n        seconds += 1  # Close left\n    else:\n        # pos is between l and r\n        if pos < l:\n            seconds += l - pos  # Move to l\n            seconds += 1  # Close left\n        elif pos > r:\n            seconds += pos - r  # Move to r\n            seconds += 1  # Close right\n        \n        # Close left if needed\n        if l > 1:\n            seconds += 1  # Close left\n        # Close right if needed\n        if r < n:\n            seconds += 1  # Close right\n\n    print(seconds)\n```",
    "1": "```python\ndef max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n    \n    # Start with the maximum number which is x itself\n    max_sum = sum(int(d) for d in str_x)\n    best_number = x\n    \n    # Check numbers by reducing digits\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit and setting all following digits to 9\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        new_number = int(new_number)\n        \n        if new_number > 0:\n            current_sum = sum(int(d) for d in str(new_number))\n            if current_sum > max_sum or (current_sum == max_sum and new_number > best_number):\n                max_sum = current_sum\n                best_number = new_number\n    \n    return best_number\n\nx = int(input())\nprint(max_digit_sum(x))\n```",
    "0": "```python\ndef max_length_accordion(s):\n    n = len(s)\n    left_bracket = -1\n    right_bracket = -1\n    colon_count = 0\n    vertical_count = 0\n\n    for i in range(n):\n        if s[i] == '[':\n            left_bracket = i\n        elif s[i] == ']':\n            right_bracket = i\n            if left_bracket != -1 and right_bracket > left_bracket:\n                # Count colons and vertical lines between the brackets\n                for j in range(left_bracket + 1, right_bracket):\n                    if s[j] == ':':\n                        colon_count += 1\n                    elif s[j] == '|':\n                        vertical_count += 1\n\n    if left_bracket == -1 or right_bracket == -1 or colon_count < 2:\n        return -1\n\n    # The maximum length of the accordion\n    return 4 + vertical_count  # 4 for the brackets and colons, plus vertical lines\n\ns = input().strip()\nprint(max_length_accordion(s))\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    for query in queries:\n        n, x, blows = query\n        min_blows = float('inf')\n        \n        for d, h in blows:\n            if d >= x:\n                min_blows = min(min_blows, 1)\n            else:\n                effective_heads = d - h\n                if effective_heads <= 0:\n                    continue\n                blows_needed = (x - d + effective_heads - 1) // effective_heads + 1\n                min_blows = min(min_blows, blows_needed)\n        \n        results.append(min_blows if min_blows != float('inf') else -1)\n    \n    return results\n\n# Input reading and function calling\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\nresults = min_blows_to_defeat_zmei(t, queries)\nfor result in results:\n    print(result)\n```",
    "10": "```python\nn = int(input())\n\n# Calculate the maximum days off\nmax_days_off = (n // 7) * 2 + min(2, n % 7)\n\n# Calculate the minimum days off\nif n < 5:\n    min_days_off = 0\nelse:\n    min_days_off = (n // 7) * 2\n\nprint(min_days_off, max_days_off)\n```",
    "9": "```python\nd = int(input())\nn, m = map(int, input().split())\n\nsofas = []\nfor i in range(d):\n    x1, y1, x2, y2 = map(int, input().split())\n    sofas.append((x1, y1, x2, y2))\n\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\ndef count_sofas(sofa, sofas):\n    x1, y1, x2, y2 = sofa\n    left = right = top = bottom = 0\n    \n    for other in sofas:\n        if other == sofa:\n            continue\n        ox1, oy1, ox2, oy2 = other\n        \n        if (x1 < ox1 and x2 < ox1) or (x1 < ox2 and x2 < ox2):\n            left += 1\n        if (x1 > ox1 and x2 > ox1) or (x1 > ox2 and x2 > ox2):\n            right += 1\n        if (y1 < oy1 and y2 < oy1) or (y1 < oy2 and y2 < oy2):\n            top += 1\n        if (y1 > oy1 and y2 > oy1) or (y1 > oy2 and y2 > oy2):\n            bottom += 1\n            \n    return left, right, top, bottom\n\nfor i in range(d):\n    left, right, top, bottom = count_sofas(sofas[i], sofas)\n    if (left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b):\n        print(i + 1)\n        break\nelse:\n    print(-1)\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    # Function to calculate the number of painted sections\n    def painted_count(painters_to_consider):\n        painted = [0] * (n + 1)\n        for l, r in painters_to_consider:\n            for i in range(l, r + 1):\n                painted[i] = 1\n        return sum(painted)\n\n    max_sections = 0\n\n    # Try removing each pair of painters\n    for i in range(q):\n        for j in range(i + 1, q):\n            # Create a list of painters excluding the i-th and j-th\n            remaining_painters = [painters[k] for k in range(q) if k != i and k != j]\n            max_sections = max(max_sections, painted_count(remaining_painters))\n\n    return max_sections\n\n# Read input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Get the result and print it\nresult = max_painted_sections(n, q, painters)\nprint(result)\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    count_a = n // a\n    count_b = n // b\n    count_ab = n // (a * b)\n\n    # Calculate chocolates\n    chocolates_a = count_a * p\n    chocolates_b = count_b * q\n\n    # If p > q, prioritize painting Red\n    if p > q:\n        chocolates = chocolates_a + (count_b - count_ab) * q\n    else:\n        chocolates = (count_a - count_ab) * p + chocolates_b\n\n    return chocolates\n\n# Read input\nn, a, b, p, q = map(int, input().split())\n# Print the result\nprint(max_chocolates(n, a, b, p, q))\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelif t <= n + k:\n    print(n + k - t)\n\n```",
    "18": "```python\ndef minimal_lexicographic_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        while t and (not u or t[-1] <= u[-1]):\n            u.append(t.pop())\n    \n    return ''.join(u)\n\ns = input().strip()\nprint(minimal_lexicographic_string(s))\n```",
    "16": "```python\ncnt1 = int(input())\ncnt2 = int(input())\ncnt3 = int(input())\ncnt4 = int(input())\n\n# Calculate the balance of opening and closing brackets\nopen_needed = cnt1 + cnt2  # Total opening brackets needed\nclose_needed = cnt3 + cnt4  # Total closing brackets needed\n\n# Check if we can form a regular bracket sequence\nif open_needed == close_needed and cnt1 <= cnt4 + cnt2:\n    print(1)\nelse:\n    print(0)\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return minutes_passed\n\ntime_input = input().strip()\nhh, mm = map(int, time_input.split(':'))\nresult = next_palindrome_time(hh, mm)\nprint(result)\n```",
    "21": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_index = a.index(1)\nmax_index = a.index(n)\n\n# Calculate the current distance\ncurrent_distance = abs(min_index - max_index)\n\n# Calculate the maximum possible distance after one swap\nmax_distance = max(min_index, max_index, n - 1 - min_index, n - 1 - max_index)\n\nprint(max_distance)\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    max_length = 0\n    current_length = 0\n    segments = []\n\n    # Calculate lengths of segments of 'G's\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n                max_length = max(max_length, current_length)\n            current_length = 0\n    if current_length > 0:\n        segments.append(current_length)\n        max_length = max(max_length, current_length)\n\n    # If there are no 'G's, return 0\n    if not segments:\n        return 0\n\n    # Check for the possibility of swapping\n    if len(segments) == 1:\n        return max_length  # Only one segment of 'G's\n\n    # Calculate the maximum possible length after one swap\n    max_possible_length = max_length\n    for i in range(len(segments) - 1):\n        # If we swap a 'S' between two segments of 'G's\n        max_possible_length = max(max_possible_length, segments[i] + segments[i + 1])\n\n    # If we can add one more 'G' to the longest segment\n    max_possible_length = min(max_possible_length + 1, n)\n\n    return max_possible_length\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\nprint(max_beauty_after_swap(n, trophies))\n```",
    "14": "```python\ndef is_stack_sortable(n, k, p):\n    # Create a set of used elements\n    used = set(p)\n    # Create a list for the remaining elements\n    remaining = [i for i in range(1, n + 1) if i not in used]\n    \n    # Initialize the result with the first k elements\n    result = p[:]\n    \n    # Initialize a stack\n    stack = []\n    \n    # The next number we need to push to the result\n    next_needed = 1\n    \n    for i in range(k):\n        # While we can pop from the stack to maintain sorted order\n        while stack and stack[-1] == next_needed:\n            result.append(stack.pop())\n            next_needed += 1\n        \n        # If the current element is the next needed, add it to the result\n        if p[i] == next_needed:\n            result.append(p[i])\n            next_needed += 1\n        else:\n            # Otherwise, we push the current element to the stack\n            stack.append(p[i])\n    \n    # Now we need to process the remaining elements\n    for num in sorted(remaining, reverse=True):\n        while stack and stack[-1] == next_needed:\n            result.append(stack.pop())\n            next_needed += 1\n        stack.append(num)\n    \n    # Finally, pop all remaining elements in the stack\n    while stack and stack[-1] == next_needed:\n        result.append(stack.pop())\n        next_needed += 1\n    \n    # If we have used all numbers from 1 to n, we have a valid permutation\n    if next_needed - 1 == n:\n        return result\n    else:\n        return -1\n\n# Input reading\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result\nresult = is_stack_sortable(n, k, p)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "4": "```python\ndef is_lucky(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef time_before(hh, mm, x, y):\n    total_minutes = hh * 60 + mm - y * x\n    if total_minutes < 0:\n        total_minutes += 24 * 60\n    return total_minutes // 60, total_minutes % 60\n\nx = int(input())\nhh, mm = map(int, input().split())\n\ny = 0\nwhile True:\n    prev_hh, prev_mm = time_before(hh, mm, x, y)\n    if is_lucky(prev_hh, prev_mm):\n        print(y)\n        break\n    y += 1\n```",
    "19": "```python\ndef check_records(test_cases):\n    results = []\n    for case in test_cases:\n        n = case[0]\n        records = case[1]\n        valid = True\n        \n        for i in range(n):\n            p_i, c_i = records[i]\n            if i > 0:\n                p_prev, c_prev = records[i - 1]\n                if p_i < p_prev or c_i < c_prev or c_i > p_i:\n                    valid = False\n                    break\n                if c_i - c_prev > p_i - p_prev:\n                    valid = False\n                    break\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Input reading\nT = int(input())\ntest_cases = []\nfor _ in range(T):\n    n = int(input())\n    records = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, records))\n\n# Check records and print results\nresults = check_records(test_cases)\nfor result in results:\n    print(result)\n```",
    "13": "```python\nfrom collections import deque, defaultdict\nimport sys\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, k = map(int, data[0].split())\nmain_courses = list(map(int, data[1].split()))\ndependencies = defaultdict(list)\nindegree = [0] * (n + 1)\n\n# Read dependencies\nfor i in range(1, n + 1):\n    line = list(map(int, data[i + 1].split()))\n    t_i = line[0]\n    for dep in line[1:t_i + 1]:\n        dependencies[dep].append(i)\n        indegree[i] += 1\n\n# Topological sort using Kahn's algorithm\nqueue = deque()\nfor i in range(1, n + 1):\n    if indegree[i] == 0:\n        queue.append(i)\n\norder = []\nwhile queue:\n    course = queue.popleft()\n    order.append(course)\n    for next_course in dependencies[course]:\n        indegree[next_course] -= 1\n        if indegree[next_course] == 0:\n            queue.append(next_course)\n\n# Check if all courses can be completed\nif len(order) < n:\n    print(-1)\n    sys.exit()\n\n# Determine the courses to take\ntaken_courses = set()\nresult = []\n\ndef dfs(course):\n    if course in taken_courses:\n        return\n    taken_courses.add(course)\n    for dep in dependencies[course]:\n        dfs(dep)\n    result.append(course)\n\nfor main_course in main_courses:\n    dfs(main_course)\n\n# Add any additional courses needed\nfor course in order:\n    if course not in taken_courses:\n        dfs(course)\n\nprint(len(result))\nprint(' '.join(map(str, result[::-1])))\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a, b):\n    from itertools import permutations\n\n    a_str = str(a)\n    b_str = str(b)\n    \n    # Generate all unique permutations of the digits of a\n    permuted_numbers = set(int(''.join(p)) for p in permutations(a_str))\n    \n    # Filter out numbers that are greater than b and have the same length as a\n    valid_numbers = [num for num in permuted_numbers if num <= b and len(str(num)) == len(a_str)]\n    \n    # Return the maximum valid number\n    return max(valid_numbers)\n\n# Input\na = int(input().strip())\nb = int(input().strip())\n\n# Output\nprint(max_permutation_not_exceeding(a, b))\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    if k > n * (n + 1) // 2:\n        return -1\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k <= 0:\n            break\n        for j in range(i, n):\n            if i == j:\n                if k > 0:\n                    matrix[i][j] = 1\n                    k -= 1\n            else:\n                if k >= 2:\n                    matrix[i][j] = 1\n                    matrix[j][i] = 1\n                    k -= 2\n            \n            if k <= 0:\n                break\n    \n    return matrix\n\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "27": "```python\nn = int(input())\ns = input()\n\nmin_operations = n  # Start with the maximum operations (typing all characters)\n\nfor i in range(1, n):\n    if s[:i] == s[i:i+i]:  # Check if the prefix can be copied\n        # Calculate operations: type i characters, copy, and type the rest\n        operations = i + 1 + (n - 2 * i)\n        min_operations = min(min_operations, operations)\n\nprint(min_operations)\n```",
    "8": "```python\ndef min_draws(tiles):\n    from collections import Counter\n\n    # Parse the input tiles\n    counts = Counter(tiles)\n    \n    # Check for koutsu (triplet)\n    for tile, count in counts.items():\n        if count >= 3:\n            return 0  # Already has a koutsu\n\n    # Check for shuntsu (sequence)\n    suits = {'m': [], 'p': [], 's': []}\n    for tile in tiles:\n        number = int(tile[0])\n        suit = tile[1]\n        suits[suit].append(number)\n\n    # Sort the numbers in each suit\n    for suit in suits:\n        suits[suit].sort()\n\n    # Check for existing shuntsu\n    for suit, numbers in suits.items():\n        if len(numbers) >= 3:\n            for i in range(len(numbers) - 2):\n                if numbers[i + 1] == numbers[i] + 1 and numbers[i + 2] == numbers[i] + 2:\n                    return 0  # Already has a shuntsu\n\n    # Check how many draws are needed\n    needed = 2  # Start with the maximum needed draws\n\n    for suit, numbers in suits.items():\n        if len(numbers) == 2:\n            # Check if we can form a shuntsu with one draw\n            if (numbers[0] + 1 == numbers[1]) or (numbers[0] + 2 == numbers[1]):\n                needed = min(needed, 1)\n            else:\n                needed = min(needed, 2)\n        elif len(numbers) == 1:\n            # Only one tile, need two draws to form a shuntsu\n            needed = min(needed, 2)\n\n    return needed\n\n# Read input\ntiles = input().strip().split()\n# Output the result\nprint(min_draws(tiles))\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror_chars = {'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M', 'O': 'O', 'o': 'o', 'p': 'q', 'q': 'p', 'R': 'R', 'S': 'S', 'T': 'T', 'U': 'U', 'v': 'v', 'V': 'V', 'W': 'W', 'x': 'x', 'Y': 'Y'}\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        if s[i] not in mirror_chars or s[n - 1 - i] not in mirror_chars:\n            return \"NIE\"\n        if mirror_chars[s[i]] != s[n - 1 - i]:\n            return \"NIE\"\n    \n    return \"TAK\"\n\ns = input().strip()\nprint(is_s_palindrome(s))\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # Since GCD(x, m) = 1, the number of distinct rooms visited is equal to m\n    # The x-mouse will visit all rooms in m steps, so we need to place traps in m - 1 rooms\n    # The only room we can skip is room 0, as it will always be visited.\n    \n    return m\n\nm, x = map(int, input().split())\nprint(minimum_traps(m, x))\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    # Calculate the difference\n    diff = abs(sum_first - sum_second)\n    \n    # Create a list of possible changes\n    changes = []\n    if sum_first > sum_second:\n        # We need to decrease the first half or increase the second half\n        changes = [9 - digit for digit in first_half] + [digit for digit in second_half]\n    else:\n        # We need to increase the first half or decrease the second half\n        changes = [digit for digit in first_half] + [9 - digit for digit in second_half]\n    \n    # Sort changes in descending order\n    changes.sort(reverse=True)\n    \n    # Calculate the minimum number of replacements\n    replacements = 0\n    for change in changes:\n        diff -= change\n        replacements += 1\n        if diff <= 0:\n            break\n    \n    return replacements\n\n# Read input\nticket = input().strip()\n# Print the result\nprint(min_replacements_to_lucky(ticket))\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = [name for name, type_ in files if type_ == '1']\nregulars = [name for name, type_ in files if type_ == '0']\n\nmoves = []\n# Rename examples to 1, 2, ..., e\nfor i, example in enumerate(examples):\n    moves.append(f\"move {example} {i + 1}\")\n\n# Rename regular tests to e + 1, e + 2, ..., n\nfor i, regular in enumerate(regulars):\n    moves.append(f\"move {regular} {len(examples) + i + 1}\")\n\nprint(len(moves))\nfor move in moves:\n    print(move)\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    left, right = 0, max(a, b)\n    \n    while left < right:\n        mid = (left + right + 1) // 2\n        if (a // mid) + (b // mid) >= n:\n            left = mid\n        else:\n            right = mid - 1\n            \n    return left\n\nn, a, b = map(int, input().split())\nprint(max_min_pieces(n, a, b))\n```",
    "37": "```python\ndef can_deal_exact_damage(a, b, c):\n    for i in range(c // a + 1):\n        if (c - a * i) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\na, b, c = map(int, input().split())\nprint(can_deal_exact_damage(a, b, c))\n```",
    "32": "```python\nn = int(input())\nposition = 0  # Position on the meridian, starting at the North Pole (0 km)\nvalid = True\n\nfor _ in range(n):\n    t, direction = input().split()\n    t = int(t)\n\n    if position == 0 and direction != \"South\":\n        valid = False\n        break\n    elif position == 20000 and direction != \"North\":\n        valid = False\n        break\n\n    if direction == \"South\":\n        position += t\n    elif direction == \"North\":\n        position -= t\n    elif direction == \"West\" or direction == \"East\":\n        # Moving West or East does not change the position on the meridian\n        continue\n\n    if position < 0 or position > 20000:\n        valid = False\n        break\n\nif valid and position == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inv(a, p):\n    return pow(a, p - 2, p)\n\ndef birthday_paradox(n, k):\n    MOD = 1000003\n    days = 1 << n  # 2^n\n    if k > days:\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the probability of no collision\n    prob_no_collision = 1\n    for i in range(k):\n        prob_no_collision *= (days - i)\n        prob_no_collision %= MOD\n\n    # Total possible birthday assignments\n    total_assignments = pow(days, k, MOD)\n\n    # Probability of at least one collision\n    A = (total_assignments - prob_no_collision) % MOD\n    B = total_assignments\n\n    # Reduce A and B by their gcd\n    common_gcd = gcd(A, B)\n    A //= common_gcd\n    B //= common_gcd\n\n    return A % MOD, B % MOD\n\n# Read input\nn, k = map(int, input().split())\nresult = birthday_paradox(n, k)\nprint(result[0], result[1])\n```",
    "24": "```python\ndef can_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]\n    \n    def check_win(x, y):\n        for dx, dy in directions:\n            count = 1\n            \n            # Check in the positive direction\n            nx, ny = x + dx, y + dy\n            while 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n                nx += dx\n                ny += dy\n            \n            # Check in the negative direction\n            nx, ny = x - dx, y - dy\n            while 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n                nx -= dx\n                ny -= dy\n            \n            if count >= 5:\n                return True\n        return False\n    \n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                board[i][j] = 'X'  # Place the cross\n                if check_win(i, j):\n                    return \"YES\"\n                board[i][j] = '.'  # Revert back\n    return \"NO\"\n\n# Read input\nboard = [input().strip() for _ in range(10)]\nprint(can_win(board))\n```",
    "36": "```python\ndef hexagonal_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 6 * layer\n\n    while n > moves_in_layer:\n        n -= moves_in_layer\n        layer += 1\n        moves_in_layer = 6 * layer\n\n    x, y = layer, 0\n\n    if n == 0:\n        return (x, y)\n\n    # Determine the direction and the position in the layer\n    direction = n // layer\n    steps = n % layer\n\n    if direction == 0:  # right\n        x += steps\n    elif direction == 1:  # top-right\n        x += steps\n        y += steps\n    elif direction == 2:  # top-left\n        x -= steps\n        y += steps\n    elif direction == 3:  # left\n        x -= steps\n    elif direction == 4:  # bottom-left\n        x -= steps\n        y -= steps\n    elif direction == 5:  # bottom-right\n        x += steps\n        y -= steps\n\n    return (x, y)\n\nn = int(input())\nx, y = hexagonal_coordinates(n)\nprint(x, y)\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ns = input().strip()\n\nif not is_palindrome(s):\n    print(len(s))\nelse:\n    for length in range(len(s) - 1, 0, -1):\n        for start in range(len(s) - length + 1):\n            if not is_palindrome(s[start:start + length]):\n                print(length)\n                exit()\n    print(0)\n```",
    "35": "```python\ndef is_valid_flag(n, m, field):\n    colors = set()\n    stripe_height = None\n    current_color = None\n    current_height = 0\n    \n    for i in range(n):\n        row = field[i]\n        if len(set(row)) != 1:\n            return \"NO\"\n        \n        if current_color is None or row[0] != current_color:\n            if current_color is not None:\n                colors.add(current_color)\n                if stripe_height is None:\n                    stripe_height = current_height\n                elif current_height != stripe_height:\n                    return \"NO\"\n            current_color = row[0]\n            current_height = 1\n        else:\n            current_height += 1\n    \n    colors.add(current_color)\n    \n    if len(colors) == 3 and current_height == stripe_height:\n        return \"YES\"\n    return \"NO\"\n\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\nprint(is_valid_flag(n, m, field))\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if any rating has changed\nrated = any(a != b for a, b in ratings)\n\nif rated:\n    print(\"rated\")\nelse:\n    # Check if the standings are in non-increasing order of the initial ratings\n    for i in range(1, n):\n        if ratings[i-1][0] < ratings[i][0]:\n            print(\"unrated\")\n            break\n    else:\n        print(\"maybe\")\n```",
    "41": "```python\nn = int(input())\na = list(map(int, input().split()))\n\ndistances = [float('inf')] * n\n\n# First pass: from left to right\nfor i in range(n):\n    if a[i] == 0:\n        distances[i] = 0\n    elif i > 0:\n        distances[i] = distances[i - 1] + 1\n\n# Second pass: from right to left\nfor i in range(n - 1, -1, -1):\n    if a[i] == 0:\n        distances[i] = 0\n    elif i < n - 1:\n        distances[i] = min(distances[i], distances[i + 1] + 1)\n\nprint(' '.join(map(str, distances)))\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n\n    len_s = len(s)\n    total_count = 0\n    seen = set()\n\n    # Generate all binary strings of length n\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        # Check if s is a substring of any cyclic shift of t\n        if any(s in t[i:] + t[:i] for i in range(n)):\n            seen.add(t)\n\n    return len(seen)\n\nn = int(input().strip())\ns = input().strip()\nprint(count_cyclic_strings(n, s))\n```",
    "38": "```python\ndef can_be_same_track(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between consecutive barriers for Kefa\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    # Calculate the distances between consecutive barriers for Sasha\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Check if the kefa_diffs can be rotated to match sasha_diffs\n    double_kefa_diffs = kefa_diffs * 2  # Create a doubled list for rotation checking\n    \n    for i in range(n):\n        if double_kefa_diffs[i:i + n] == sasha_diffs:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_be_same_track(n, L, kefa_distances, sasha_distances))\n```",
    "26": "```python\nimport math\n\n# Read input\nx, y, z = map(float, input().split())\n\n# Define the expressions and their corresponding values\nexpressions = [\n    (x**(y**z), \"x^y^z\"),\n    (x**(z**y), \"x^z^y\"),\n    ((x**y)**z, \"(x^y)^z\"),\n    ((x**z)**y, \"(x^z)^y\"),\n    (y**(x**z), \"y^x^z\"),\n    (y**(z**x), \"y^z^x\"),\n    ((y**x)**z, \"(y^x)^z\"),\n    ((y**z)**x, \"(y^z)^x\"),\n    (z**(x**y), \"z^x^y\"),\n    (z**(y**x), \"z^y^x\"),\n    ((z**x)**y, \"(z^x)^y\"),\n    ((z**y)**x, \"(z^y)^x\"),\n]\n\n# Find the maximum value and the corresponding expression\nmax_value = -math.inf\nmax_index = -1\n\nfor i, (value, expr) in enumerate(expressions):\n    if value > max_value:\n        max_value = value\n        max_index = i\n\n# Output the corresponding expression\nprint(expressions[max_index][1])\n```",
    "33": "```python\ndef count_common_integers(a1, b1, a2, b2, L, R):\n    from math import gcd\n\n    # Calculate the step size and the offset\n    step = abs(a1 * a2 // gcd(a1, a2))\n    \n    # Find the first valid x in the range [L, R]\n    def first_valid_x():\n        for k in range((L - b1 + a1 - 1) // a1, (R - b1) // a1 + 1):\n            x1 = a1 * k + b1\n            if L <= x1 <= R:\n                return x1\n        return None\n\n    # Find the last valid x in the range [L, R]\n    def last_valid_x():\n        for k in range((R - b1) // a1, (L - b1 - 1) // a1, -1):\n            x1 = a1 * k + b1\n            if L <= x1 <= R:\n                return x1\n        return None\n\n    # Find the first valid x that satisfies both progressions\n    def find_common_x(start):\n        for l in range((start - b2 + a2 - 1) // a2, (R - b2) // a2 + 1):\n            x2 = a2 * l + b2\n            if x2 >= start and x2 <= R:\n                return x2\n        return None\n\n    # Get the first valid x from the first progression\n    x1 = first_valid_x()\n    if x1 is None:\n        return 0\n\n    # Get the first common x that satisfies both progressions\n    common_x = find_common_x(x1)\n    if common_x is None:\n        return 0\n\n    # Count how many valid x's are in the range [L, R]\n    count = 0\n    while common_x <= R:\n        if common_x >= L:\n            count += 1\n        common_x += step\n\n    return count\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n# Output the result\nprint(count_common_integers(a1, b1, a2, b2, L, R))\n```",
    "46": "```python\ndef count_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n    \n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n        \n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n        \n    result = 0\n    for i in range(5):\n        result += count_x[i] * count_y[(5 - i) % 5]\n        \n    return result\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n    \n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n    \n    start += (k - 1) // length\n    num_str = str(start)\n    return int(num_str[(k - 1) % length])\n\nk = int(input().strip())\nprint(find_kth_digit(k))\n```",
    "48": "```python\ndef kth_largest_in_multiplication_table(n, m, k):\n    left, right = 1, n * m\n    \n    while left < right:\n        mid = (left + right) // 2\n        count = sum(min(mid // i, m) for i in range(1, n + 1))\n        \n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return left\n\nn, m, k = map(int, input().split())\nprint(kth_largest_in_multiplication_table(n, m, k))\n```",
    "43": "```python\nimport sys\nimport math\n\ndef minimal_angle_pair(n, vectors):\n    angles = []\n    \n    for i in range(n):\n        x, y = vectors[i]\n        angle = math.atan2(y, x)\n        angles.append((angle, i + 1))  # Store angle and index (1-based)\n\n    # Sort angles\n    angles.sort()\n\n    # To handle the circular nature of angles, we can duplicate the list with adjusted angles\n    extended_angles = angles + [(angle + 2 * math.pi, idx) for angle, idx in angles]\n\n    min_angle = float('inf')\n    best_pair = (0, 0)\n\n    for i in range(n):\n        angle1, idx1 = extended_angles[i]\n        angle2, idx2 = extended_angles[i + 1]\n        angle_diff = angle2 - angle1\n        \n        if angle_diff < min_angle:\n            min_angle = angle_diff\n            best_pair = (idx1, idx2)\n\n    return best_pair\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    vectors = [tuple(map(int, line.split())) for line in data[1:n + 1]]\n    \n    a, b = minimal_angle_pair(n, vectors)\n    print(a, b)\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Minimum sum of first k natural numbers\n    min_sum = k * (k + 1) // 2\n    \n    if n < min_sum:\n        return -1\n    \n    # The maximum gcd we can use is n // k\n    max_gcd = n // k\n    \n    # We will try to find the sequence\n    for g in range(max_gcd, 0, -1):\n        # Calculate the sum we need to reach with the sequence\n        target_sum = n // g\n        \n        # Check if we can form the sequence with the current gcd\n        if target_sum >= min_sum:\n            # Create the sequence\n            sequence = [(i + 1) * g for i in range(k)]\n            return sequence\n    \n    return -1\n\n# Read input\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\n# Print output\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = -1\n    result = []\n    moves = []\n\n    while left <= right:\n        if a[left] > last_taken and (a[right] <= last_taken or a[left] < a[right]):\n            last_taken = a[left]\n            result.append(last_taken)\n            moves.append('L')\n            left += 1\n        elif a[right] > last_taken:\n            last_taken = a[right]\n            result.append(last_taken)\n            moves.append('R')\n            right -= 1\n        else:\n            break\n\n    print(len(result))\n    print(''.join(moves))\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\nlongest_increasing_sequence(n, a)\n```",
    "51": "```python\nfrom collections import Counter\nimport sys\nimport math\n\ndef find_x_y(divisors):\n    count = Counter(divisors)\n    # The largest number in the list must be either x or y\n    max_divisor = max(divisors)\n    \n    # Calculate the product of all unique divisors\n    product = 1\n    for d in count:\n        product *= d ** (count[d] // 2)\n    \n    # The two numbers x and y can be derived from the product and the largest divisor\n    x = product * (max_divisor // math.gcd(product, max_divisor))\n    y = product * (max_divisor // (x // max_divisor))\n    \n    return x, y\n\nn = int(input().strip())\ndivisors = list(map(int, input().strip().split()))\n\nx, y = find_x_y(divisors)\nprint(x, y)\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef reachable_count(n):\n    reachable = set()\n    current = n\n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    return len(reachable)\n\nn = int(input())\nprint(reachable_count(n))\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_choose = m // 2\n    dp = [[-1] * k for _ in range(max_choose + 1)]\n    dp[0][0] = 0\n\n    for row in matrix:\n        row.sort(reverse=True)\n        current_dp = [dp[i][:] for i in range(max_choose + 1)]\n        \n        for i in range(1, max_choose + 1):\n            for j in range(min(i, len(row))):\n                if current_dp[i - 1][(j + 1) % k] != -1:\n                    new_sum = current_dp[i - 1][(j + 1) % k] + row[j]\n                    new_mod = new_sum % k\n                    current_dp[i][new_mod] = max(current_dp[i][new_mod], new_sum)\n\n        dp = current_dp\n\n    return max(dp[i][0] for i in range(max_choose + 1))\n\n# Input reading\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_sum_divisible_by_k(n, m, k, matrix))\n```",
    "54": "```python\ndef min_D_to_equalize(n, a):\n    min_a = min(a)\n    max_a = max(a)\n    \n    if max_a == min_a:\n        return 0  # All elements are already equal\n    \n    # The possible target values to equalize to\n    target_values = {min_a, max_a}\n    \n    # Check if we can equalize to any of the target values\n    for target in target_values:\n        D = abs(target - min_a)  # Calculate D based on the minimum value\n        if all(abs(ai - target) <= D for ai in a):\n            return D\n    \n    return -1  # If no valid D found\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_D_to_equalize(n, a))\n```",
    "47": "```python\ndef max_beauty(n, x, a):\n    # Function to calculate maximum subarray sum using Kadane's algorithm\n    def kadane(arr):\n        max_ending_here = max_so_far = 0\n        for value in arr:\n            max_ending_here = max(0, max_ending_here + value)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    # Calculate the beauty of the original array\n    original_beauty = kadane(a)\n\n    # If x is 0, the best we can do is the original beauty\n    if x == 0:\n        return original_beauty\n\n    # Calculate the maximum beauty after multiplying a subarray by x\n    max_increase = 0\n    current_sum = 0\n\n    for i in range(n):\n        current_sum += a[i]\n        # Calculate the potential new sum if we multiply the current subarray by x\n        new_sum = current_sum * x\n        # The increase in beauty would be new_sum - current_sum\n        max_increase = max(max_increase, new_sum - current_sum)\n        # Reset current_sum if it goes negative\n        if current_sum < 0:\n            current_sum = 0\n\n    # The maximum beauty after the operation\n    return max(original_beauty, original_beauty + max_increase)\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_beauty(n, x, a))\n```",
    "44": "```python\ndef minimal_time_to_post_office(d, k, a, b, t):\n    # Time if Vasiliy walks the entire distance\n    min_time = d * b\n    \n    # Calculate the number of full segments Vasiliy can drive\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Time spent driving full segments and repairing\n    time_driving_full_segments = full_segments * (k * a + t)\n    \n    # If there are remaining kilometers to drive\n    if remaining_distance > 0:\n        time_driving_full_segments += remaining_distance * a\n    \n    # If there are full segments, we need to subtract the last repair time\n    if full_segments > 0:\n        time_driving_full_segments -= t\n    \n    # Compare with the time spent walking the remaining distance\n    min_time = min(min_time, time_driving_full_segments + (remaining_distance * b))\n    \n    return min_time\n\n# Read input\nd, k, a, b, t = map(int, input().split())\n# Calculate and print the result\nprint(minimal_time_to_post_office(d, k, a, b, t))\n```",
    "59": "```python\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# We need to check the last x digits of the number\ntarget_remainder = ['0'] * x\ntarget_remainder[y] = '1'\n\n# Count the number of changes needed\nchanges_needed = 0\nfor i in range(x):\n    if number[n - 1 - i] != target_remainder[x - 1 - i]:\n        changes_needed += 1\n\nprint(changes_needed)\n```",
    "55": "```python\ndef can_see_white_sheet(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n    # Check if there is any part of the white sheet that is not covered by the black sheets\n    # Check the four corners of the white sheet\n    corners = [\n        (x1, y1),  # bottom left\n        (x1, y2),  # top left\n        (x2, y1),  # bottom right\n        (x2, y2)   # top right\n    ]\n    \n    for x, y in corners:\n        # Check if the point (x, y) is outside the white sheet\n        if not (x1 < x < x2 and y1 < y < y2):\n            # Check if the point (x, y) is outside both black sheets\n            if not (x3 < x < x4 and y3 < y < y4) and not (x5 < x < x6 and y5 < y < y6):\n                return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Output the result\nprint(can_see_white_sheet(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6))\n```",
    "60": "```python\ndef has_palindrome_subsequence(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        found = False\n        # Use a dictionary to track the last seen index of each number\n        last_seen = {}\n        for i in range(n):\n            if a[i] in last_seen:\n                # Check if we have seen this number before\n                if i - last_seen[a[i]] >= 2:\n                    found = True\n                    break\n            last_seen[a[i]] = i\n        results.append(\"YES\" if found else \"NO\")\n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Get results\nresults = has_palindrome_subsequence(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "57": "```python\ndef fill_gift_list(n, f):\n    # Find the friends who want to give gifts (f_i != 0)\n    givers = set(range(1, n + 1)) - set(f)\n    \n    # Find the friends who are not receiving gifts (f_i = 0)\n    receivers = [i + 1 for i in range(n) if f[i] == 0]\n    \n    # Create a mapping for the final gift list\n    for i in range(len(receivers)):\n        # Assign each receiver a giver, ensuring no one gives a gift to themselves\n        for giver in givers:\n            if giver != receivers[i]:\n                f[receivers[i] - 1] = giver\n                givers.remove(giver)\n                break\n    \n    print(\" \".join(map(str, f)))\n\n# Input reading\nn = int(input())\nf = list(map(int, input().split()))\n\nfill_gift_list(n, f)\n```",
    "63": "```python\ndef min_instability(n, a):\n    a.sort()\n    # The minimum instability after removing one element can be found by considering\n    # removing the smallest or the largest element.\n    instability1 = a[-1] - a[1]  # Remove the smallest element\n    instability2 = a[-2] - a[0]  # Remove the largest element\n    return min(instability1, instability2)\n\nn = int(input())\na = list(map(int, input().split()))\nprint(min_instability(n, a))\n```",
    "67": "```python\nn = int(input())\na = list(map(int, input().split()))\n\ntotal_sum = sum(a)\nnice_indices = []\n\nfor i in range(n):\n    if total_sum - a[i] == a[i]:\n        nice_indices.append(i + 1)  # Store 1-based index\n\nprint(len(nice_indices))\nif nice_indices:\n    print(\" \".join(map(str, nice_indices)))\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        min_ops = float('inf')\n        best_triplet = (a, b, c)\n\n        for A in range(1, a + 1):\n            for B in range(A, c + 1):\n                if B % A == 0:\n                    C = B\n                    while C <= c or C % B == 0:\n                        ops = abs(A - a) + abs(B - b) + abs(C - c)\n                        if ops < min_ops:\n                            min_ops = ops\n                            best_triplet = (A, B, C)\n                        C += B\n\n        results.append((min_ops, best_triplet))\n\n    return results\n\n# Read input\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations(t, test_cases)\n\n# Print output\nfor ops, triplet in results:\n    print(ops)\n    print(*triplet)\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph):\n    visited = {start: 0}\n    queue = deque([start])\n    farthest_node = start\n    max_distance = 0\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > max_distance:\n                    max_distance = visited[neighbor]\n                    farthest_node = neighbor\n                    \n    return farthest_node, max_distance\n\ndef find_max_edges(n, edges):\n    graph = defaultdict(list)\n    \n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Step 1: Find the farthest node from an arbitrary node (1)\n    farthest_from_start, _ = bfs(1, graph)\n    \n    # Step 2: Find the farthest node from the previously found farthest node\n    farthest_from_a, _ = bfs(farthest_from_start, graph)\n    \n    # Step 3: Find the farthest node from the second farthest node\n    farthest_from_b, _ = bfs(farthest_from_a, graph)\n    \n    # The diameter endpoints are farthest_from_start and farthest_from_a\n    # We can take any two nodes from the diameter path and one more node\n    # to maximize the edges covered.\n    \n    # Collect the path from farthest_from_start to farthest_from_a\n    def collect_path(start, end):\n        parent = {start: None}\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in graph[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        return path[::-1]\n    \n    path = collect_path(farthest_from_start, farthest_from_a)\n    \n    # Choose the endpoints of the diameter and one more node\n    a = path[0]\n    b = path[-1]\n    c = path[len(path) // 2]  # Choose a middle node as c\n    \n    # Calculate the number of edges in the union of paths\n    max_edges = len(path) - 1 + (len(graph[a]) - 1) + (len(graph[b]) - 1) - 1\n    \n    return max_edges, a, b, c\n\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\nmax_edges, a, b, c = find_max_edges(n, edges)\nprint(max_edges)\nprint(a, b, c)\n```",
    "65": "```python\ndef min_moves(n, m):\n    if m % n != 0:\n        return -1\n    \n    ratio = m // n\n    count_2 = 0\n    count_3 = 0\n    \n    while ratio % 2 == 0:\n        ratio //= 2\n        count_2 += 1\n    \n    while ratio % 3 == 0:\n        ratio //= 3\n        count_3 += 1\n    \n    if ratio != 1:\n        return -1\n    \n    return count_2 + count_3\n\nn, m = map(int, input().split())\nprint(min_moves(n, m))\n```",
    "58": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nfrom collections import defaultdict\n\n# Count occurrences of each number\ncount = defaultdict(int)\nfor num in a:\n    count[num] += 1\n\n# If any number occurs more than k times, it's impossible\nif any(c > k for c in count.values()):\n    print(\"NO\")\n    exit()\n\n# Prepare to color the elements\ncolor = [0] * n\ncurrent_color = 1\nused_colors = defaultdict(int)\n\nfor i in range(n):\n    num = a[i]\n    # Assign a color to the current number\n    if used_colors[num] < k:\n        color[i] = (used_colors[num] + 1)\n        used_colors[num] += 1\n    else:\n        # If we have used all colors for this number, we need to cycle through colors\n        color[i] = (used_colors[num] % k) + 1\n        used_colors[num] += 1\n\n# Check if we have used all colors at least once\nif len(set(color)) < k:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(\" \".join(map(str, color)))\n```",
    "71": "```python\ndef count_set_bits(a):\n    return bin(a).count('1')\n\na = int(input())\nprint(count_set_bits(a))\n```",
    "66": "```python\ndef minimum_length_string(n, k, t):\n    # Find the longest suffix of t that is also a prefix\n    for i in range(n - 1, -1, -1):\n        if t.startswith(t[i:]):\n            overlap_length = i\n            break\n    \n    # The length of the string s will be the length of t plus (k - 1) times the overlap length\n    overlap = t[overlap_length:]\n    s = t + overlap * (k - 1)\n    \n    return s\n\n# Input reading\nn, k = map(int, input().split())\nt = input().strip()\n\n# Output the result\nprint(minimum_length_string(n, k, t))\n```",
    "73": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmax_height = max(a)\ntotal_bricks_needed = 0\ntotal_bricks_available = 0\n\nfor i in range(n):\n    total_bricks_needed += max_height - a[i]\n    if i > 0 and a[i] == a[i - 1]:\n        total_bricks_available += 1\n\nif total_bricks_needed <= total_bricks_available:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "70": "```python\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Convert start and end times to minutes\nstart_minutes = h1 * 60 + m1\nend_minutes = h2 * 60 + m2\n\n# Calculate the midpoint in minutes\nmidpoint_minutes = (start_minutes + end_minutes) // 2\n\n# Convert back to hours and minutes\nh3 = midpoint_minutes // 60\nm3 = midpoint_minutes % 60\n\n# Print the result in the required format\nprint(f\"{h3:02}:{m3:02}\")\n```",
    "77": "```python\nn = int(input())\ntotal_sum = n * (n + 1) // 2\nprint(total_sum % 2)\n```",
    "61": "```python\nn = int(input())\na = input().strip()\nf = list(map(int, input().split()))\n\n# Convert f to a string for easier manipulation\nf = [str(x) for x in f]\n\n# Initialize the result as the original number\nmax_number = a\n\n# Flag to indicate if we are in a replacement segment\nin_segment = False\nnew_number = []\n\nfor digit in a:\n    original_digit = digit\n    mapped_digit = f[int(digit) - 1]\n    \n    if not in_segment and mapped_digit > original_digit:\n        # Start a new segment\n        in_segment = True\n    \n    if in_segment:\n        # Replace the digit\n        new_number.append(mapped_digit)\n    else:\n        # Keep the original digit\n        new_number.append(original_digit)\n    \n    if in_segment and mapped_digit < original_digit:\n        # End the segment if we find a digit that should not be replaced\n        in_segment = False\n\n# Join the new number and compare with the max_number\nnew_number_str = ''.join(new_number)\nmax_number = max(max_number, new_number_str)\n\nprint(max_number)\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    unique_subsequences = set()\n    \n    # Generate all unique subsequences\n    for i in range(1 << n):\n        subsequence = []\n        for j in range(n):\n            if i & (1 << j):\n                subsequence.append(s[j])\n        unique_subsequences.add(''.join(subsequence))\n    \n    # If we cannot obtain k unique subsequences\n    if len(unique_subsequences) < k:\n        return -1\n    \n    # Calculate costs for unique subsequences\n    costs = []\n    for subseq in unique_subsequences:\n        cost = n - len(subseq)\n        costs.append(cost)\n    \n    # Sort costs and take the minimum k costs\n    costs.sort()\n    return sum(costs[:k])\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    lefts = [l for l, r in segments]\n    rights = [r for l, r in segments]\n\n    max_left = max(lefts)\n    min_right = min(rights)\n\n    # Precompute the second max and second min\n    sorted_lefts = sorted(lefts)\n    sorted_rights = sorted(rights)\n\n    second_max_left = sorted_lefts[-2] if n > 1 else float('-inf')\n    second_min_right = sorted_rights[1] if n > 1 else float('inf')\n\n    max_length = 0\n\n    for i in range(n):\n        l, r = segments[i]\n        if l == max_left:\n            current_left = second_max_left\n        else:\n            current_left = max_left\n        \n        if r == min_right:\n            current_right = second_min_right\n        else:\n            current_right = min_right\n        \n        intersection_length = max(0, current_right - current_left)\n        max_length = max(max_length, intersection_length)\n\n    return max_length\n\n# Input reading\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\nprint(max_intersection_length(n, segments))\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import defaultdict\n    \n    # Count the frequency of each character\n    freq = defaultdict(int)\n    for char in s:\n        freq[char] += 1\n    \n    # Calculate the number of unique subsequences we can form\n    unique_subsequences = 0\n    costs = []\n    \n    # For each unique character, calculate the number of subsequences\n    for count in freq.values():\n        # The number of subsequences formed by this character is 2^count - 1 (excluding the empty subsequence)\n        unique_subsequences += (1 << count) - 1\n        costs.append(count)  # The cost of using this character is its count\n    \n    # If we cannot form at least k unique subsequences\n    if unique_subsequences < k:\n        return -1\n    \n    # Sort costs in descending order\n    costs.sort(reverse=True)\n    \n    total_cost = 0\n    remaining_k = k\n    \n    # We will try to take the largest costs first to minimize the total cost\n    for cost in costs:\n        if remaining_k <= 0:\n            break\n        # The maximum number of subsequences we can take from this character\n        max_subsequences = (1 << cost) - 1\n        \n        if remaining_k > max_subsequences:\n            total_cost += cost * max_subsequences\n            remaining_k -= max_subsequences\n        else:\n            total_cost += cost * remaining_k\n            remaining_k = 0\n    \n    # If we still have remaining k, we need to add more subsequences\n    if remaining_k > 0:\n        total_cost += remaining_k  # Each additional subsequence will cost at least 1\n    \n    return total_cost\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result and print it\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    days = [0] * n\n    exam_days = set()\n    \n    for i in range(m):\n        s, d, c = exams[i]\n        exam_days.add(d - 1)  # Store exam days (0-indexed)\n    \n    # Prepare for each exam\n    for i in range(m):\n        s, d, c = exams[i]\n        prep_days = 0\n        \n        for j in range(s - 1, d - 1):  # s-1 to d-2 (0-indexed)\n            if days[j] == 0 and prep_days < c:  # If it's a rest day and we need more prep days\n                days[j] = i + 1  # Mark as preparing for exam i\n                prep_days += 1\n        \n        if prep_days < c:  # If we couldn't prepare enough days\n            return -1\n    \n    # Mark exam days\n    for i in range(m):\n        d = exams[i][1] - 1  # Exam day (0-indexed)\n        days[d] = m + 1  # Mark as exam day\n    \n    return days\n\n# Input reading\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the schedule\nresult = schedule_exams(n, m, exams)\n\n# Output result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "76": "```python\ndef can_construct_square(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Check for pairs of tiles that can form the symmetric property\n        can_form_symmetric = False\n        tile_dict = {}\n        \n        for tile in tiles:\n            top_left, top_right = tile[0]\n            bottom_left, bottom_right = tile[1]\n            tile_dict[(top_left, top_right, bottom_left, bottom_right)] = True\n            \n            # Check for symmetric pairs\n            if (top_right, top_left, bottom_right, bottom_left) in tile_dict:\n                can_form_symmetric = True\n        \n        if can_form_symmetric:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Example usage:\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        top = tuple(map(int, input().split()))\n        bottom = tuple(map(int, input().split()))\n        tiles.append((top, bottom))\n    test_cases.append((n, m, tiles))\n\nresults = can_construct_square(t, test_cases)\nfor result in results:\n    print(result)\n```",
    "81": "```python\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\n# Sort strings by length\nstrings.sort(key=len)\n\n# Check if the order is valid\nfor i in range(1, n):\n    if strings[i-1] not in strings[i]:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")\n    print(\"\\n\".join(strings))\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Define the food consumption pattern for each day of the week\n    week_pattern = [0, 1, 2, 0, 1, 2, 0]  # 0: fish, 1: rabbit, 2: chicken\n    food_needed = [3] * 7  # To track how many days can be sustained\n    \n    # Calculate the maximum full weeks that can be sustained\n    full_weeks = min(a // 3, b // 2, c // 1)\n    a -= full_weeks * 3\n    b -= full_weeks * 2\n    c -= full_weeks * 1\n    \n    # Start checking from each day of the week\n    max_days_count = full_weeks * 7\n    \n    for start_day in range(7):\n        days_count = 0\n        a_temp, b_temp, c_temp = a, b, c\n        \n        for i in range(7):\n            current_day = (start_day + i) % 7\n            if week_pattern[current_day] == 0:  # fish food\n                if a_temp > 0:\n                    a_temp -= 1\n                    days_count += 1\n                else:\n                    break\n            elif week_pattern[current_day] == 1:  # rabbit stew\n                if b_temp > 0:\n                    b_temp -= 1\n                    days_count += 1\n                else:\n                    break\n            elif week_pattern[current_day] == 2:  # chicken stake\n                if c_temp > 0:\n                    c_temp -= 1\n                    days_count += 1\n                else:\n                    break\n        \n        max_days_count = max(max_days_count, full_weeks * 7 + days_count)\n    \n    return max_days_count\n\n# Read input\na, b, c = map(int, input().split())\n# Print the result\nprint(max_days(a, b, c))\n```",
    "82": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncount = 0\n\n# Solve from the left\nwhile count < n and a[count] <= k:\n    count += 1\n\n# Solve from the right\nwhile count < n and a[n - 1 - (count - (n - count))] <= k:\n    count += 1\n\n# Adjust for double counting if both ends are solvable\nif count > n:\n    count = n\n\nprint(count)\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    if len(graph[1]) < D:\n        print(\"NO\")\n        return\n\n    # Start building the spanning tree\n    spanning_tree_edges = []\n    visited = [False] * (n + 1)\n    visited[1] = True\n    degree = 0\n\n    # Use BFS or DFS to construct the spanning tree\n    queue = deque([1])\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if degree < D and node == 1:\n                    spanning_tree_edges.append((node, neighbor))\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    degree += 1\n                elif node != 1:\n                    spanning_tree_edges.append((node, neighbor))\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n\n                if degree == D and node == 1:\n                    break\n        if degree == D and node == 1:\n            break\n\n    # If we reached the required degree for vertex 1\n    if degree < D:\n        print(\"NO\")\n        return\n\n    # Now we need to ensure we have n-1 edges in the spanning tree\n    while len(spanning_tree_edges) < n - 1:\n        for u in range(1, n + 1):\n            if visited[u]:\n                for v in graph[u]:\n                    if not visited[v]:\n                        spanning_tree_edges.append((u, v))\n                        visited[v] = True\n                        if len(spanning_tree_edges) == n - 1:\n                            break\n            if len(spanning_tree_edges) == n - 1:\n                break\n\n    if len(spanning_tree_edges) != n - 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for u, v in spanning_tree_edges:\n            print(u, v)\n\n# Input reading\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nfind_spanning_tree(n, m, D, edges)\n```",
    "84": "```python\ndef can_color_string(n, s):\n    # Count the frequency of each character\n    from collections import Counter\n    freq = Counter(s)\n    \n    # Check if any character appears more than twice\n    for count in freq.values():\n        if count > 2:\n            print(\"NO\")\n            return\n    \n    # Create a coloring array\n    color = ['0'] * n\n    # Assign colors based on the position of characters\n    for i in range(n):\n        if s[i] in freq:\n            if freq[s[i]] > 0:\n                color[i] = '0'\n                freq[s[i]] -= 1\n            else:\n                color[i] = '1'\n    \n    print(\"YES\")\n    print(''.join(color))\n\n# Read input\nn = int(input().strip())\ns = input().strip()\ncan_color_string(n, s)\n```",
    "78": "```python\ndef mod_inv(a, p):\n    return pow(a, p - 2, p)\n\ndef count_regular_sequences(n, s):\n    MOD = 10**9 + 7\n    m = len(s)\n    \n    # Precompute factorials and inverse factorials\n    fact = [1] * (2 * n + 1)\n    for i in range(2, 2 * n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    \n    inv_fact = [1] * (2 * n + 1)\n    inv_fact[2 * n] = mod_inv(fact[2 * n], MOD)\n    for i in range(2 * n - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    # Check if s can be part of a regular sequence\n    balance = 0\n    min_balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n    \n    if balance < 0 or balance > n or min_balance < 0:\n        return 0\n    \n    # Count the number of ways to place the remaining brackets\n    remaining_open = n - (s.count('('))\n    remaining_close = n - (s.count(')'))\n    \n    # Calculate the number of valid sequences\n    total_ways = (fact[remaining_open + remaining_close] * inv_fact[remaining_open] % MOD) * inv_fact[remaining_close] % MOD\n    \n    return total_ways\n\nn = int(input())\ns = input().strip()\nprint(count_regular_sequences(n, s))\n```",
    "85": "```python\nimport sys\nimport math\n\ndef find_price(A, B):\n    for price in range(1, 10000):  # Arbitrarily large upper limit for price\n        tax_8 = math.floor(price * 0.08)\n        tax_10 = math.floor(price * 0.10)\n        if tax_8 == A and tax_10 == B:\n            return price\n    return -1\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    A, B = map(int, input_data.split())\n    result = find_price(A, B)\n    print(result)\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n    \n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            # Check for red rectangle\n            for red_width in range(1, int(a**0.5) + 1):\n                if a % red_width == 0:\n                    red_height = a // red_width\n                    if red_width <= width and red_height <= height:\n                        # Check for blue rectangle\n                        for blue_width in range(1, int(b**0.5) + 1):\n                            if b % blue_width == 0:\n                                blue_height = b // blue_width\n                                if blue_width <= width and blue_height <= height:\n                                    perimeter = 2 * (width + height)\n                                    min_perimeter = min(min_perimeter, perimeter)\n    \n    return min_perimeter\n\na, b = map(int, input().split())\nprint(minimal_perimeter(a, b))\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    projects.sort(key=lambda x: (x[0], -x[1]))  # Sort by required rating, then by rating change\n    completed = 0\n    \n    while True:\n        progress = False\n        for i in range(len(projects)):\n            a_i, b_i = projects[i]\n            if r >= a_i:  # Can complete this project\n                r += b_i  # Update rating\n                completed += 1\n                projects[i] = (float('inf'), 0)  # Mark as completed\n                progress = True\n                break  # Restart the loop to check from the beginning\n        if not progress:\n            break  # No more projects can be completed\n    \n    return completed\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_projects(n, r, projects))\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    from collections import defaultdict\n\n    # Create a list to store the color for each character\n    colors = [0] * n\n    # Dictionary to track the last position of each character\n    last_position = defaultdict(list)\n\n    # Fill the last_position with indices of each character\n    for i, char in enumerate(s):\n        last_position[char].append(i)\n\n    # Initialize the color counter\n    color_count = 0\n    # A set to track the used colors\n    used_colors = set()\n\n    # Iterate through the string to assign colors\n    for i in range(n):\n        char = s[i]\n        # If the character is already colored, continue\n        if colors[i] != 0:\n            continue\n        \n        # Assign a new color\n        color_count += 1\n        current_color = color_count\n        colors[i] = current_color\n        used_colors.add(current_color)\n\n        # Check the last positions of the current character\n        for pos in last_position[char]:\n            if colors[pos] == 0:\n                colors[pos] = current_color\n\n        # Now we need to ensure that we can swap with different colors\n        for j in range(i + 1, n):\n            if s[j] < s[i] and colors[j] == 0:\n                colors[j] = current_color\n\n    # Output the results\n    print(color_count)\n    print(\" \".join(map(str, colors)))\n\n# Example usage:\nn = int(input())\ns = input().strip()\nmin_colors_to_sort(n, s)\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    moves = float('inf')\n\n    # Check for pairs of digits that can form 25 or 00\n    for target in ['00', '25', '50', '75']:\n        last_digit = target[1]\n        second_last_digit = target[0]\n        \n        # Find the last occurrence of the last_digit\n        last_index = -1\n        for i in range(length - 1, -1, -1):\n            if s[i] == last_digit:\n                last_index = i\n                break\n        \n        if last_index == -1:\n            continue\n        \n        # Now find the second_last_digit before last_index\n        second_last_index = -1\n        for i in range(last_index - 1, -1, -1):\n            if s[i] == second_last_digit:\n                second_last_index = i\n                break\n        \n        if second_last_index == -1:\n            continue\n        \n        # Calculate moves to bring second_last_index to the front of last_index\n        moves_needed = (last_index - second_last_index) + (length - 1 - last_index)\n        moves = min(moves, moves_needed)\n\n    return moves if moves != float('inf') else -1\n\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects by their required rating\n    projects.sort(key=lambda x: x[0])\n    \n    for a, b in projects:\n        if r < a:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_complete_projects(n, r, projects))\n```",
    "92": "```python\nx = float(input().strip())\n\n# We will iterate through possible values for a and b\nfor a in range(1, 11):\n    for b in range(1, 11):\n        if abs(a ** 2 + b ** 2 - x) < 1e-6:\n            print(a, b)\n            break\n```",
    "86": "```python\ndef solve_polycarp(n, k):\n    # Minimum sum of problems that can be solved in k days\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n\n    # Start with the minimum valid sequence\n    a = list(range(1, k + 1))\n    current_sum = sum(a)\n\n    # We need to distribute the remaining problems\n    remaining = n - current_sum\n\n    for i in range(k - 1, -1, -1):\n        # Maximum we can add to a[i] while respecting the constraints\n        max_add = min(remaining, (2 * a[i]) - a[i])\n        if i < k - 1:\n            max_add = min(max_add, (2 * a[i] - a[i + 1]) - 1)\n\n        a[i] += max_add\n        remaining -= max_add\n\n        if remaining <= 0:\n            break\n\n    if sum(a) == n:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n    else:\n        print(\"NO\")\n\n# Example usage:\nn, k = map(int, input().split())\nsolve_polycarp(n, k)\n```",
    "97": "```python\nn = int(input())\nchips = list(map(int, input().split()))\n\neven_count = sum(1 for x in chips if x % 2 == 0)\nodd_count = n - even_count\n\n# The minimum cost is the smaller of the two counts\nprint(min(even_count, odd_count))\n```",
    "98": "```python\ndef min_moves_to_reach_n(N):\n    moves = float('inf')\n    \n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            moves = min(moves, i + j - 2)\n    \n    return moves\n\nN = int(input().strip())\nprint(min_moves_to_reach_n(N))\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1 or (d == 1 and n > 2) or (d == 0 and n > 1):\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    edges = []\n    \n    # Create a path of length d\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n    \n    # Now we have d + 1 vertices in the path\n    current_vertex = d + 2\n    \n    # Attach remaining vertices to the first vertex in the path\n    for i in range(1, n - (d + 1) + 1):\n        if i <= k - 1:\n            edges.append((1, current_vertex))\n            current_vertex += 1\n        else:\n            # Attach to the second vertex in the path\n            edges.append((2, current_vertex))\n            current_vertex += 1\n    \n    for u, v in edges:\n        print(u, v)\n\nn, d, k = map(int, input().split())\nconstruct_tree(n, d, k)\n```",
    "99": "```python\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\n# Maximum wins for Alice\nmax_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n\n# Minimum wins for Alice\n# Calculate losses for Alice\nalice_losses = max(0, b1 - a3) + max(0, b2 - a1) + max(0, b3 - a2)\nmin_wins = n - alice_losses\n\nprint(min_wins, max_wins)\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    p = [0] * n\n    p[0] = 0  # We can start from any arbitrary value, we will adjust later\n\n    # Calculate p based on q\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n\n    # Find the minimum value in p\n    min_p = min(p)\n\n    # Adjust p to make the smallest value 1\n    adjustment = 1 - min_p\n    for i in range(n):\n        p[i] += adjustment\n\n    # Check if p is a valid permutation\n    if len(set(p)) == n and all(1 <= x <= n for x in p):\n        print(\" \".join(map(str, p)))\n    else:\n        print(-1)\n\n# Input reading\nn = int(input())\nq = list(map(int, input().split()))\n\nrestore_permutation(n, q)\n```",
    "94": "```python\na, b, x = map(int, input().split())\n\n# Determine the starting character based on the number of 0s and 1s\nif a > b:\n    start = '0'\nelse:\n    start = '1'\n\n# Create the base pattern\npattern = []\nfor i in range(x + 1):\n    if i % 2 == 0:\n        pattern.append(start)\n    else:\n        pattern.append('1' if start == '0' else '0')\n\n# Count how many 0s and 1s we have used\nused_0s = pattern.count('0')\nused_1s = pattern.count('1')\n\n# Calculate remaining 0s and 1s\nremaining_0s = a - used_0s\nremaining_1s = b - used_1s\n\n# Append remaining 0s and 1s to the pattern\nif remaining_0s > 0:\n    pattern.append('0' * remaining_0s)\nif remaining_1s > 0:\n    pattern.append('1' * remaining_1s)\n\n# Join the pattern into a string\nresult = ''.join(pattern)\n\n# Print the result\nprint(result)\n```",
    "88": "```python\ndef create_palindromic_matrix(n, numbers):\n    from collections import Counter\n    \n    count = Counter(numbers)\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Check for the number of odd occurrences\n    odd_count = sum(1 for v in count.values() if v % 2 != 0)\n    \n    if (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n        return \"NO\"\n    \n    # Fill the matrix\n    half = n // 2\n    center = n // 2 if n % 2 == 1 else None\n    \n    # Fill corners and edges\n    for num, freq in count.items():\n        while freq > 0:\n            if freq >= 4:\n                # Place in corners\n                matrix[0][0] = matrix[0][n-1] = matrix[n-1][0] = matrix[n-1][n-1] = num\n                freq -= 4\n            elif freq >= 2:\n                # Place in edges\n                if n % 2 == 0:\n                    matrix[0][half] = matrix[n-1][half] = num\n                    matrix[half][0] = matrix[half][n-1] = num\n                else:\n                    if center is not None:\n                        matrix[center][center] = num\n                freq -= 2\n            else:\n                # Place in the center if odd\n                if center is not None and freq == 1:\n                    matrix[center][center] = num\n                    freq -= 1\n                break\n    \n    # Fill remaining cells\n    for i in range(half + 1):\n        for j in range(half + 1):\n            if matrix[i][j] == 0:\n                for num, freq in count.items():\n                    if freq > 0:\n                        matrix[i][j] = num\n                        matrix[i][n-1-j] = num\n                        matrix[n-1-i][j] = num\n                        matrix[n-1-i][n-1-j] = num\n                        count[num] -= 4\n                        break\n    \n    return \"YES\", matrix\n\nn = int(input())\nnumbers = list(map(int, input().split()))\n\nresult = create_palindromic_matrix(n, numbers)\n\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for row in result[1]:\n        print(\" \".join(map(str, row)))\n```",
    "90": "```python\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculate the total length of platforms\ntotal_length = sum(c)\n\n# If the maximum jump distance is greater than or equal to n, we can always reach the end\nif d >= n:\n    print(\"YES\")\n    print(\"0 \" * n + str(1))\n    exit()\n\n# Check if we can fit the platforms within the constraints\n# We need to ensure that the gaps between platforms allow for jumping\n# The maximum gap we can have between platforms is d\n# We will place the platforms starting from position 1\n\npositions = []\ncurrent_position = 1\n\nfor i in range(m):\n    positions.append((current_position, current_position + c[i] - 1))\n    current_position += c[i]\n\n# Now we need to check if we can place the platforms with the required gaps\n# The last platform must end at or before n\nif positions[-1][1] > n:\n    print(\"NO\")\n    exit()\n\n# We can place the platforms, now we need to fill the output array\na = [0] * n\n\n# Fill the array with platform indices\nfor index, (start, end) in enumerate(positions):\n    for i in range(start - 1, end):\n        a[i] = index + 1\n\n# Check if we can jump from the last platform to n + 1\nif positions[-1][1] + d < n + 1:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(\" \".join(map(str, a)))\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n    \n    # Create arrays to store the first occurrences of t in s\n    left = [0] * m\n    right = [0] * m\n    \n    # Fill the left array\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n    \n    # Fill the right array\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n    \n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n    \n    # Consider removing from the start to the first character of t\n    max_length = max(max_length, right[0])\n    # Consider removing from the last character of t to the end\n    max_length = max(max_length, n - 1 - left[m - 1])\n    \n    return max_length\n\n# Input reading\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(max_removable_length(s, t))\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Count of each character\n    count_a = count_b = count_c = n\n    \n    # Create a list to build the result string\n    res = []\n    \n    # Function to check if the last two characters form a forbidden substring\n    def is_forbidden():\n        return ''.join(res[-2:]) == s or ''.join(res[-2:]) == t\n    \n    # Try to build the result string\n    for _ in range(3 * n):\n        for char in 'abc':\n            if (char == 'a' and count_a > 0) or (char == 'b' and count_b > 0) or (char == 'c' and count_c > 0):\n                res.append(char)\n                if char == 'a':\n                    count_a -= 1\n                elif char == 'b':\n                    count_b -= 1\n                else:\n                    count_c -= 1\n                \n                if is_forbidden():\n                    res.pop()  # Remove the last character if it forms a forbidden substring\n                    if char == 'a':\n                        count_a += 1\n                    elif char == 'b':\n                        count_b += 1\n                    else:\n                        count_c += 1\n                else:\n                    break\n        else:\n            # If we couldn't add any character, it's impossible\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    print(''.join(res))\n\n# Read input\nn = int(input())\ns = input().strip()\nt = input().strip()\n\ngenerate_string(n, s, t)\n```"
}