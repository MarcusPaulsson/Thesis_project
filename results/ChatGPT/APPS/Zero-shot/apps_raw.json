{
    "2": "```python\nn = int(input())\n\ndef is_lucky_year(year):\n    return str(year).count('0') + len(set(str(year))) <= 2\n\nnext_year = n + 1\nwhile not is_lucky_year(next_year):\n    next_year += 1\n\nprint(next_year - n)\n```",
    "10": "```python\nn = int(input())\n\n# Calculate the maximum days off\nmax_days_off = (n // 7) * 2 + min(2, n % 7)\n\n# Calculate the minimum days off\nif n < 5:\n    min_days_off = 0\nelse:\n    min_days_off = (n // 7) * 2\n\nprint(min_days_off, max_days_off)\n```",
    "7": "```python\ndef days_until_empty(n, m):\n    day = 0\n    total_grains = n\n    \n    while total_grains > 0:\n        day += 1\n        total_grains = min(total_grains + m, n) - day\n        \n    return day\n\nn, m = map(int, input().split())\nprint(days_until_empty(n, m))\n```",
    "1": "```python\ndef digit_sum(n):\n    return sum(int(d) for d in str(n))\n\ndef max_digit_sum(x):\n    max_sum = digit_sum(x)\n    best_number = x\n    \n    str_x = str(x)\n    n = len(str_x)\n    \n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a candidate by reducing the current digit and setting following digits to 9\n        candidate = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        candidate = int(candidate)\n        \n        if candidate > 0:\n            current_sum = digit_sum(candidate)\n            if current_sum > max_sum or (current_sum == max_sum and candidate > best_number):\n                max_sum = current_sum\n                best_number = candidate\n    \n    return best_number\n\nx = int(input().strip())\nprint(max_digit_sum(x))\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    painted_sections = [0] * (n + 1)\n\n    # Calculate the range covered by all painters\n    for l, r in painters:\n        for i in range(l, r + 1):\n            painted_sections[i] += 1\n\n    # For each painter, calculate the coverage without that painter\n    max_paint = 0\n    for i in range(q):\n        # Create a temporary painted sections array\n        temp_painted = painted_sections[:]\n        l, r = painters[i]\n\n        # Remove the coverage of the current painter\n        for j in range(l, r + 1):\n            temp_painted[j] -= 1\n\n        # Count the number of painted sections after removing the painter\n        current_paint = sum(1 for count in temp_painted[1:] if count > 0)\n        max_paint = max(max_paint, current_paint)\n\n    return max_paint\n\n# Input reading\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output the maximum number of painted sections\nprint(max_painted_sections(n, q, painters))\n```",
    "4": "```python\ndef is_lucky(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef minutes_before(hh, mm, x, y):\n    total_minutes = hh * 60 + mm - x * y\n    if total_minutes < 0:\n        total_minutes += 24 * 60\n    return total_minutes // 60, total_minutes % 60\n\nx = int(input().strip())\nhh, mm = map(int, input().strip().split())\n\ny = 0\nwhile True:\n    prev_hh, prev_mm = minutes_before(hh, mm, x, y)\n    if is_lucky(prev_hh, prev_mm):\n        print(y)\n        break\n    y += 1\n```",
    "5": "```python\nn, pos, l, r = map(int, input().split())\n\n# If all tabs are already in the range, no action is needed\nif l <= pos <= r:\n    # Close left and right if needed\n    left_closes = pos - l\n    right_closes = r - pos\n    total_time = max(0, left_closes) + max(0, right_closes)\n    print(total_time)\nelse:\n    # Calculate the number of seconds to close tabs\n    time = 0\n\n    # If we need to close tabs on the left\n    if pos < l:\n        time += (l - pos)  # Move to l\n        time += 1  # Close left tabs\n\n    # If we need to close tabs on the right\n    elif pos > r:\n        time += (pos - r)  # Move to r\n        time += 1  # Close right tabs\n\n    # If we need to close both sides\n    if l > 1:  # If there's something to close on the left\n        time += (l - 1) + 1  # Move to l and close left\n\n    if r < n:  # If there's something to close on the right\n        time += (n - r) + 1  # Move to r and close right\n\n    print(time)\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    \n    for query in queries:\n        n, x = query[0]\n        blows = query[1]\n        \n        min_blow_count = float('inf')\n        possible = False\n        \n        for d, h in blows:\n            if d >= x:\n                min_blow_count = 1\n                possible = True\n                break\n            \n            effective_d = d - h\n            if effective_d > 0:\n                blows_needed = (x - d + effective_d - 1) // effective_d + 1\n                min_blow_count = min(min_blow_count, blows_needed)\n                possible = True\n        \n        results.append(min_blow_count if possible else -1)\n    \n    return results\n\n# Reading input\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append(((n, x), blows))\n\n# Getting results\nresults = min_blows_to_defeat_zmei(t, queries)\n\n# Outputting results\nfor result in results:\n    print(result)\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "8": "```python\ndef min_draws(tiles):\n    def is_koutsu(tiles):\n        return len(set(tiles)) == 1\n\n    def is_shuntsu(tiles):\n        suits = {}\n        for tile in tiles:\n            num, suit = int(tile[0]), tile[1]\n            if suit not in suits:\n                suits[suit] = []\n            suits[suit].append(num)\n        \n        for suit, numbers in suits.items():\n            if len(numbers) >= 3:\n                numbers.sort()\n                for i in range(len(numbers) - 2):\n                    if (numbers[i] + 1 in numbers and\n                        numbers[i] + 2 in numbers):\n                        return True\n        return False\n\n    if is_koutsu(tiles) or is_shuntsu(tiles):\n        return 0\n\n    # Check for possible shuntsu with one draw\n    for tile in tiles:\n        num, suit = int(tile[0]), tile[1]\n        if (num - 1 >= 1 and num + 1 <= 9):\n            if (str(num - 1) + suit not in tiles and\n                str(num + 1) + suit not in tiles):\n                return 1\n\n    # Check for possible shuntsu with two draws\n    for tile in tiles:\n        num, suit = int(tile[0]), tile[1]\n        if (num - 1 >= 1 and\n            str(num - 1) + suit not in tiles):\n            return 2\n        if (num + 1 <= 9 and\n            str(num + 1) + suit not in tiles):\n            return 2\n\n    return 2  # In the worst case, we need to draw 2 tiles\n\ntiles = input().strip().split()\nprint(min_draws(tiles))\n```",
    "17": "```python\nn, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelif t <= n + k:\n    print(n + k - t)\n```",
    "12": "```python\ndef max_beauty_with_one_swap(n, trophies):\n    max_length = 0\n    current_length = 0\n    segments = []\n    \n    # Create a list of lengths of segments of 'G'\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n                max_length = max(max_length, current_length)\n            current_length = 0\n            \n    if current_length > 0:\n        segments.append(current_length)\n        max_length = max(max_length, current_length)\n    \n    # If all trophies are golden\n    if len(segments) == 0:\n        return n\n    \n    # If there's only one segment of golden trophies\n    if len(segments) == 1:\n        return segments[0]\n    \n    # Check for the possibility of merging two segments by swapping one 'S'\n    for i in range(len(segments) - 1):\n        max_length = max(max_length, segments[i] + segments[i + 1])\n    \n    # If we can swap one 'S' to extend a segment by 1\n    if len(segments) > 0:\n        max_length += 1\n    \n    return max_length\n\n# Input reading\nn = int(input().strip())\ntrophies = input().strip()\n\n# Output the result\nprint(max_beauty_with_one_swap(n, trophies))\n```",
    "16": "```python\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\n# Count of opening and closing brackets\nopening = cnt_1 + cnt_2  # \"(\", \"()\" contribute to opening\nclosing = cnt_2 + cnt_4   # \"()\", \"))\" contribute to closing\n\n# Check if we can form a regular bracket sequence\nif opening >= closing and (opening - closing) <= cnt_3:\n    print(1)\nelse:\n    print(0)\n```",
    "14": "```python\ndef is_stack_sortable(n, k, p):\n    remaining = set(range(1, n + 1)) - set(p)\n    s = []\n    b = []\n    idx = 0\n\n    for i in range(k):\n        while s and (not remaining or s[-1] < min(remaining)):\n            b.append(s.pop())\n        if p[i] in remaining:\n            remaining.remove(p[i])\n            s.append(p[i])\n        else:\n            return -1\n\n    while s and (not remaining or s[-1] < min(remaining)):\n        b.append(s.pop())\n\n    if s:\n        return -1\n\n    result = p[:]\n    for num in sorted(remaining, reverse=True):\n        result.append(num)\n\n    return result\n\nn, k = map(int, input().split())\np = list(map(int, input().split()))\nresult = is_stack_sortable(n, k, p)\n\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "0": "```python\ndef max_length_accordion(s):\n    n = len(s)\n    left_bracket_index = -1\n    right_bracket_index = -1\n    \n    for i in range(n):\n        if s[i] == '[':\n            left_bracket_index = i\n            break\n            \n    for i in range(n - 1, -1, -1):\n        if s[i] == ']':\n            right_bracket_index = i\n            break\n            \n    if left_bracket_index == -1 or right_bracket_index == -1 or left_bracket_index >= right_bracket_index:\n        return -1\n    \n    # Now we need to check for colons and vertical bars between the brackets\n    colon_count = 0\n    pipe_count = 0\n    found_first_colon = False\n    \n    for i in range(left_bracket_index + 1, right_bracket_index):\n        if s[i] == ':':\n            if not found_first_colon:\n                found_first_colon = True\n                colon_count += 1\n            else:\n                if pipe_count > 0:\n                    # We found the second colon after some pipes\n                    colon_count += 1\n                    break\n        elif s[i] == '|':\n            if found_first_colon:\n                pipe_count += 1\n    \n    if colon_count < 2:\n        return -1\n    \n    # The length of the accordion is the brackets and the colons plus the pipes\n    return 2 + colon_count + pipe_count\n\n# Read input\ns = input().strip()\n# Calculate and print the result\nprint(max_length_accordion(s))\n```",
    "9": "```python\nd = int(input())\nn, m = map(int, input().split())\nsofas = []\n\nfor i in range(d):\n    x1, y1, x2, y2 = map(int, input().split())\n    sofas.append((x1, y1, x2, y2))\n\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\ndef count_sofas(sofa_index):\n    x1, y1, x2, y2 = sofas[sofa_index]\n    left = right = top = bottom = 0\n    \n    for i in range(d):\n        if i == sofa_index:\n            continue\n        x1_cmp, y1_cmp, x2_cmp, y2_cmp = sofas[i]\n        if x1 == x2:  # vertical sofa\n            if y1 < y1_cmp < y2:  # sofa i is to the right\n                right += 1\n            elif y1_cmp < y1 < y2_cmp:  # sofa i is to the left\n                left += 1\n        else:  # horizontal sofa\n            if x1 < x1_cmp < x2:  # sofa i is below\n                bottom += 1\n            elif x1_cmp < x1 < x2_cmp:  # sofa i is above\n                top += 1\n\n    return left, right, top, bottom\n\nresult = -1\n\nfor i in range(d):\n    left, right, top, bottom = count_sofas(i)\n    if (left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b):\n        if result == -1:\n            result = i + 1  # sofas are 1-indexed\n        else:\n            result = -1  # more than one match found\n\nprint(result)\n```",
    "21": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_index = a.index(1)\nmax_index = a.index(n)\n\n# Calculate the current distance\ncurrent_distance = abs(min_index - max_index)\n\n# Calculate the potential maximum distances after one swap\ndistance1 = abs(min_index - (n - 1))  # Swap min with the last element\ndistance2 = abs(max_index - 0)        # Swap max with the first element\ndistance3 = abs((n - 1) - max_index)  # Swap max with the last element\ndistance4 = abs(min_index - 0)        # Swap min with the first element\n\n# The maximum possible distance after one swap\nmax_distance = max(current_distance, distance1, distance2, distance3, distance4)\n\nprint(max_distance)\n```",
    "18": "```python\ndef lexicographically_minimal_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        # Move character from s to t\n        t.append(char)\n        \n        # While t is not empty and we can pop from t to u\n        while t:\n            # If u is empty or the last character in u is less than or equal to the last in t\n            if not u or t[-1] >= u[-1]:\n                break\n            # Pop from t to u\n            u.append(t.pop())\n    \n    # After processing all characters in s, pop remaining characters from t to u\n    while t:\n        u.append(t.pop())\n    \n    # Convert list u back to string and return\n    return ''.join(u)\n\n# Input\ns = input().strip()\n# Output the result\nprint(lexicographically_minimal_string(s))\n```",
    "19": "```python\ndef check_records(test_cases):\n    results = []\n    for case in test_cases:\n        n = case[0]\n        pairs = case[1]\n        valid = True\n        \n        for i in range(n):\n            p, c = pairs[i]\n            if i > 0:\n                prev_p, prev_c = pairs[i - 1]\n                if p < prev_p or c < prev_c or c > p:\n                    valid = False\n                    break\n                if (p - prev_p) < (c - prev_c):\n                    valid = False\n                    break\n        \n        if valid:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Read input\nT = int(input())\ntest_cases = []\nfor _ in range(T):\n    n = int(input())\n    pairs = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, pairs))\n\n# Check each test case and print results\nresults = check_records(test_cases)\nprint(\"\\n\".join(results))\n```",
    "20": "```python\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome_time(hh, mm):\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return time_str\n\ndef min_minutes_to_palindrome(current_time):\n    hh, mm = map(int, current_time.split(\":\"))\n    minutes = 0\n    while True:\n        palindrome_time = next_palindrome_time(hh, mm)\n        if palindrome_time == f\"{hh:02}:{mm:02}\":\n            return minutes\n        minutes += 1\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n\ncurrent_time = input().strip()\nprint(min_minutes_to_palindrome(current_time))\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a, b):\n    from itertools import permutations\n\n    str_a = str(a)\n    str_b = str(b)\n    \n    # Generate all unique permutations of digits in a\n    perm = sorted(set(permutations(str_a)), reverse=True)\n    \n    for p in perm:\n        num = int(''.join(p))\n        # Check if the permutation is less than or equal to b and has the same length as a\n        if num <= b and len(str(num)) == len(str_a):\n            return num\n            \n# Read input\na = int(input().strip())\nb = int(input().strip())\n\n# Get result and print\nresult = max_permutation_not_exceeding(a, b)\nprint(result)\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror_map = {\n        'A': 'A', 'H': 'H', 'I': 'I', 'M': 'M', 'O': 'O', \n        'T': 'T', 'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X', \n        'Y': 'Y', 'o': 'o', 'v': 'v', 'w': 'w', 'x': 'x'\n    }\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        if s[i] not in mirror_map or s[n - 1 - i] not in mirror_map:\n            return \"NIE\"\n        if mirror_map[s[i]] != s[n - 1 - i]:\n            return \"NIE\"\n    \n    return \"TAK\"\n\ns = input().strip()\nprint(is_s_palindrome(s))\n```",
    "27": "```python\nn = int(input())\ns = input()\n\nmin_operations = n\n\nfor i in range(1, n):\n    if s[:i] == s[i:2*i]:\n        min_operations = min(min_operations, i + (n - 2 * i) + 1)\n\nprint(min(min_operations, n))\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    count_a = n // a\n    count_b = n // b\n    count_ab = n // (a * b // gcd(a, b))  # Using LCM to find common multiples\n\n    # Calculate the maximum chocolates by choosing the best option for overlap\n    red_chocolates = (count_a - count_ab) * p + count_ab * max(p, q)\n    blue_chocolates = (count_b - count_ab) * q + count_ab * max(p, q)\n    \n    return max(red_chocolates, blue_chocolates)\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n# Input reading\nn, a, b, p, q = map(int, input().split())\nprint(max_chocolates(n, a, b, p, q))\n```",
    "13": "```python\nfrom collections import deque, defaultdict\nimport sys\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, k = map(int, data[0].split())\nmain_courses = list(map(int, data[1].split()))\nmain_set = set(main_courses)\n\n# Create the dependency graph and a reverse dependency count\ndependencies = defaultdict(list)\nin_degree = [0] * (n + 1)\n\n# Read the course dependencies\nfor i in range(2, 2 + n):\n    course_info = list(map(int, data[i].split()))\n    t_i = course_info[0]\n    for j in range(1, t_i + 1):\n        dep_course = course_info[j]\n        dependencies[dep_course].append(i - 1)  # i - 2 + 2 = i - 1 (0-indexed)\n        in_degree[i - 1] += 1\n\n# Topological sort using Kahn's algorithm\nqueue = deque()\nfor i in range(n):\n    if in_degree[i] == 0:\n        queue.append(i)\n\norder = []\nwhile queue:\n    current = queue.popleft()\n    order.append(current + 1)  # Store 1-indexed course number\n    for neighbor in dependencies[current + 1]:\n        in_degree[neighbor] -= 1\n        if in_degree[neighbor] == 0:\n            queue.append(neighbor)\n\n# Set of passed courses\npassed_courses = set(order)\n\n# Check if all main courses can be completed\nif not main_set.issubset(passed_courses):\n    print(-1)\nelse:\n    # Collect the minimum courses needed to complete all main courses\n    result = []\n    for course in order:\n        if course in main_set or any(dep in passed_courses for dep in dependencies[course]):\n            result.append(course)\n\n    print(len(result))\n    print(' '.join(map(str, result)))\n```",
    "30": "```python\nm, x = map(int, input().split())\nprint(m // gcd(x, m))\n```",
    "24": "```python\ndef can_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # vertical, horizontal, diagonal \\\n    \n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                # Temporarily place an 'X' in the empty cell\n                board[i][j] = 'X'\n                \n                for dx, dy in directions:\n                    count = 1\n                    \n                    # Check in the positive direction\n                    x, y = i + dx, j + dy\n                    while 0 <= x < 10 and 0 <= y < 10 and board[x][y] == 'X':\n                        count += 1\n                        x += dx\n                        y += dy\n                    \n                    # Check in the negative direction\n                    x, y = i - dx, j - dy\n                    while 0 <= x < 10 and 0 <= y < 10 and board[x][y] == 'X':\n                        count += 1\n                        x -= dx\n                        y -= dy\n                    \n                    if count >= 5:\n                        return 'YES'\n                \n                # Remove the temporary 'X'\n                board[i][j] = '.'\n\n    return 'NO'\n\n\n# Read input\nboard = [input().strip() for _ in range(10)]\nprint(can_win(board))\n```",
    "28": "```python\nn = int(input())\nfiles = [input().split() for _ in range(n)]\nexample_files = [name for name, type_ in files if type_ == '1']\nregular_files = [name for name, type_ in files if type_ == '0']\n\nscript = []\nnew_names = {}\ne = len(example_files)\n\n# Rename example files to 1, 2, ..., e\nfor i in range(e):\n    original_name = example_files[i]\n    new_name = str(i + 1)\n    script.append(f\"move {original_name} {new_name}\")\n    new_names[original_name] = new_name\n\n# Rename regular files to e+1, e+2, ..., n\nfor i in range(len(regular_files)):\n    original_name = regular_files[i]\n    new_name = str(e + i + 1)\n    # We need to move the old name to a new name that doesn't exist yet\n    script.append(f\"move {original_name} {new_name}\")\n    new_names[original_name] = new_name\n\nprint(len(script))\nfor line in script:\n    print(line)\n```",
    "26": "```python\nimport math\n\n# Read input\nx, y, z = map(float, input().split())\n\n# Calculate all the expressions\nexpressions = [\n    (x**(y**z), \"x^y^z\"),\n    (x**(z**y), \"x^z^y\"),\n    ((x**y)**z, \"(x^y)^z\"),\n    ((x**z)**y, \"(x^z)^y\"),\n    (y**(x**z), \"y^x^z\"),\n    (y**(z**x), \"y^z^x\"),\n    ((y**x)**z, \"(y^x)^z\"),\n    ((y**z)**x, \"(y^z)^x\"),\n    (z**(x**y), \"z^x^y\"),\n    (z**(y**x), \"z^y^x\"),\n    ((z**x)**y, \"(z^x)^y\"),\n    ((z**y)**x, \"(z^y)^x\")\n]\n\n# Find maximum value and corresponding expression\nm = max(value for value, _ in expressions)\nc = next(i for i, (value, _) in enumerate(expressions) if value == m)\n\n# Output the corresponding expression\nprint(expressions[c][1])\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    low, high = 1, max(a, b)\n\n    while low < high:\n        mid = (low + high + 1) // 2\n        # Check if we can satisfy the condition with mid as the minimum pieces\n        if (a // mid) + (b // mid) >= n:\n            low = mid\n        else:\n            high = mid - 1\n\n    return low\n\n# Read input\nn, a, b = map(int, input().split())\n# Get the result and print\nprint(max_min_pieces(n, a, b))\n```",
    "25": "```python\ndef create_symmetrical_matrix(n, k):\n    # Maximum number of 1's we can place in a symmetric matrix\n    max_ones = n * (n + 1) // 2\n    if k > max_ones:\n        return -1\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k == 0:\n            break\n        # Fill the diagonal first\n        if k > 0:\n            matrix[i][i] = 1\n            k -= 1\n        \n        # Then fill the upper triangle\n        for j in range(i + 1, n):\n            if k >= 2:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n            if k == 0:\n                break\n    \n    # Check if we have used exactly k ones\n    if k > 0:\n        return -1\n    \n    return matrix\n\n# Read input\nn, k = map(int, input().split())\nresult = create_symmetrical_matrix(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "32": "```python\nn = int(input())\nposition = 0  # Position in kilometers from North Pole (0 at North Pole, 20000 at South Pole)\n\nvalid = True\n\nfor _ in range(n):\n    t, direction = input().split()\n    t = int(t)\n\n    if direction == \"South\":\n        if position == 0 or position + t > 20000:\n            valid = False\n            break\n        position += t\n    elif direction == \"North\":\n        if position == 20000 or position - t < 0:\n            valid = False\n            break\n        position -= t\n    elif direction in [\"West\", \"East\"]:\n        if position == 0 or position == 20000:\n            valid = False\n            break\n\nif valid and position == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "37": "```python\ndef can_break_shield(a, b, c):\n    for x in range(c // a + 1):\n        if (c - a * x) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Input\na, b, c = map(int, input().split())\n# Output\nprint(can_break_shield(a, b, c))\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    diff = abs(sum_first - sum_second)\n    \n    # Calculate the maximum possible changes we can make\n    changes = []\n    \n    if sum_first > sum_second:\n        # We need to reduce the first half or increase the second half\n        changes = [9 - digit for digit in first_half] + second_half\n    else:\n        # We need to reduce the second half or increase the first half\n        changes = first_half + [9 - digit for digit in second_half]\n    \n    # Sort changes in descending order\n    changes.sort(reverse=True)\n\n    replacements = 0\n    for change in changes:\n        diff -= change\n        replacements += 1\n        if diff <= 0:\n            break\n            \n    return replacements\n\n# Read input\nticket = input().strip()\n# Get the result and print it\nprint(min_replacements_to_lucky(ticket))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ns = input().strip()\n\nif not is_palindrome(s):\n    print(len(s))\nelse:\n    # Check for any non-palindrome substring of length > 1\n    if len(set(s)) == 1:\n        print(0)\n    else:\n        print(len(s) - 1)\n```",
    "40": "```python\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if the round is rated\nfor a, b in ratings:\n    if a != b:\n        print(\"rated\")\n        break\nelse:\n    # Check if the round is unrated\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            print(\"unrated\")\n            break\n    else:\n        print(\"maybe\")\n```",
    "36": "```python\ndef hexagonal_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    steps_in_layer = 6\n    moves = 0\n    \n    while moves + steps_in_layer <= n:\n        moves += steps_in_layer\n        layer += 1\n        steps_in_layer += 6\n\n    remaining_moves = n - moves\n    x, y = layer, 0\n\n    if remaining_moves == 0:\n        return (x, y)\n\n    # Directions for hexagonal grid: right, top-right, top-left, left, bottom-left, bottom-right\n    directions = [(1, 0), (0, 1), (-1, 1), (-1, 0), (0, -1), (1, -1)]\n    \n    # Apply the remaining moves in the current layer\n    for i in range(remaining_moves):\n        dx, dy = directions[i % 6]\n        x += dx\n        y += dy\n\n    return (x, y)\n\nn = int(input().strip())\nresult = hexagonal_coordinates(n)\nprint(result[0], result[1])\n```",
    "31": "```python\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef modular_inverse(a, m):\n    m0, x0, x1 = m, 0, 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef birthday_paradox(n, k):\n    mod = 1000003\n    days = 1 << n  # 2^n days\n    if k > days:\n        # If k > days, probability is 1\n        return 1, 1\n    \n    # Calculate the probability of no shared birthdays\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator = (numerator * (days - i)) % mod\n        denominator = (denominator * days) % mod\n\n    # P(at least one shared birthday) = 1 - P(no shared birthdays)\n    P_no_shared = (numerator * modular_inverse(denominator, mod)) % mod\n    P_shared = (1 - P_no_shared + mod) % mod\n\n    # P_shared is in the form of A / B\n    A = P_shared\n    B = 1\n\n    # Now we need to express A / B correctly\n    # B is days^k\n    B = pow(days, k, mod)\n\n    # A is the numerator of the probability\n    A = (B - P_no_shared + mod) % mod\n\n    # Reduce A/B to irreducible form\n    common_gcd = gcd(A, B)\n    A //= common_gcd\n    B //= common_gcd\n\n    return A, B\n\n# Read input\nn, k = map(int, input().split())\nA, B = birthday_paradox(n, k)\nprint(A, B)\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n    \n    m = len(s)\n    \n    # Generate all binary strings of length n\n    all_strings = [''.join(p) for p in product('01', repeat=n)]\n    \n    # Count distinct cyclic strings that contain s\n    distinct_cyclic_strings = set()\n    \n    for t in all_strings:\n        # Check if s is a substring of any cyclic shift of t\n        cyclic = t + t  # Concatenate to simulate cyclic shifts\n        if s in cyclic:\n            distinct_cyclic_strings.add(t)\n    \n    return len(distinct_cyclic_strings)\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Calculate and print the result\nresult = count_cyclic_strings(n, s)\nprint(result)\n```",
    "41": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the distance array with a large value\ndistances = [float('inf')] * n\n\n# First pass: left to right\nfor i in range(n):\n    if a[i] == 0:\n        distances[i] = 0\n    elif i > 0:\n        distances[i] = distances[i - 1] + 1\n\n# Second pass: right to left\nfor i in range(n - 1, -1, -1):\n    if a[i] == 0:\n        distances[i] = 0\n    elif i < n - 1:\n        distances[i] = min(distances[i], distances[i + 1] + 1)\n\nprint(\" \".join(map(str, distances)))\n```",
    "35": "```python\ndef is_valid_flag(n, m, grid):\n    # Check for horizontal stripes\n    def check_horizontal():\n        stripe_height = n // 3\n        if n % 3 != 0:\n            return False\n        colors = set()\n        \n        for i in range(3):\n            color = grid[i * stripe_height][0]\n            colors.add(color)\n            for j in range(stripe_height):\n                if grid[i * stripe_height + j] != color * m:\n                    return False\n        return len(colors) == 3\n\n    # Check for vertical stripes\n    def check_vertical():\n        stripe_width = m // 3\n        if m % 3 != 0:\n            return False\n        colors = set()\n        \n        for i in range(3):\n            color = grid[0][i * stripe_width]\n            colors.add(color)\n            for j in range(stripe_width):\n                for k in range(n):\n                    if grid[k][i * stripe_width + j] != color:\n                        return False\n        return len(colors) == 3\n\n    return check_horizontal() or check_vertical()\n\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\nif is_valid_flag(n, m, grid):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "43": "```python\nimport math\nimport sys\n\ninput = sys.stdin.read\ndata = input().splitlines()\nn = int(data[0])\n\nvectors = []\nfor i in range(1, n + 1):\n    x, y = map(int, data[i].split())\n    angle = math.atan2(y, x)\n    vectors.append((angle, i))\n\n# Sort the vectors by angle\nvectors.sort()\n\n# To handle the circular nature, add the first vector to the end\nvectors.append((vectors[0][0] + 2 * math.pi, vectors[0][1]))\n\nmin_angle = float('inf')\nbest_pair = (0, 0)\n\n# Find the minimum angle between consecutive vectors\nfor i in range(n):\n    angle1, index1 = vectors[i]\n    angle2, index2 = vectors[i + 1]\n    angle_diff = angle2 - angle1\n    if angle_diff < min_angle:\n        min_angle = angle_diff\n        best_pair = (index1, index2)\n\nprint(best_pair[0], best_pair[1])\n```",
    "46": "```python\ndef count_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n    \n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n    \n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n    \n    result = 0\n    for i in range(5):\n        result += count_x[i] * count_y[(5 - i) % 5]\n    \n    return result\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))\n```",
    "44": "```python\ndef min_time_to_post_office(d, k, a, b, t):\n    time = float('inf')\n\n    # Case 1: Walk the entire distance\n    time = min(time, d * b)\n\n    # Case 2: Use the car as much as possible\n    full_cycles = d // k\n    remaining_distance = d % k\n\n    # Calculate time if using the car for full cycles\n    if full_cycles > 0:\n        time_using_car = (full_cycles * k * a) + (full_cycles - 1) * t + (remaining_distance * a if remaining_distance > 0 else 0)\n        time = min(time, time_using_car)\n\n    # Add walking time for remaining distance after using the car\n    time_using_car = (full_cycles * k * a) + (full_cycles * t) + (remaining_distance * b)\n    time = min(time, time_using_car)\n\n    # Add time for using car and then walking\n    if full_cycles > 0:\n        time_using_car_and_walk = (full_cycles * k * a) + (full_cycles - 1) * t + (remaining_distance * b)\n        time = min(time, time_using_car_and_walk)\n\n    return time\n\n# Input\nd, k, a, b, t = map(int, input().split())\n# Output\nprint(min_time_to_post_office(d, k, a, b, t))\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Minimum sum required for the first k positive integers\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        return -1\n    \n    # Calculate the maximum gcd\n    gcd = (n - min_sum) // k + 1\n    # Create the sequence\n    sequence = [(i + gcd) for i in range(1, k + 1)]\n    \n    # If the sum of the sequence is less than n, we need to adjust the last element\n    current_sum = sum(sequence)\n    if current_sum < n:\n        sequence[-1] += n - current_sum\n    \n    return sequence\n\n# Read input\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\n# Output result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "48": "```python\ndef kth_largest_in_multiplication_table(n, m, k):\n    left, right = 1, n * m\n    \n    while left < right:\n        mid = (left + right) // 2\n        count = 0\n        \n        for i in range(1, n + 1):\n            count += min(mid // i, m)\n        \n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left\n\n# Read input\nn, m, k = map(int, input().split())\nprint(kth_largest_in_multiplication_table(n, m, k))\n```",
    "38": "```python\ndef can_coincide(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between consecutive barriers for Kefa and Sasha\n    kefa_intervals = [(kefa_distances[i] - kefa_distances[i - 1]) % L for i in range(1, n)]\n    kefa_intervals.append((kefa_distances[0] + L - kefa_distances[-1]) % L)\n    \n    sasha_intervals = [(sasha_distances[i] - sasha_distances[i - 1]) % L for i in range(1, n)]\n    sasha_intervals.append((sasha_distances[0] + L - sasha_distances[-1]) % L)\n    \n    # Check if kefa_intervals can be rotated to match sasha_intervals\n    double_kefa_intervals = kefa_intervals * 2\n    for i in range(n):\n        if double_kefa_intervals[i:i+n] == sasha_intervals:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Get result and print\nresult = can_coincide(n, L, kefa_distances, sasha_distances)\nprint(result)\n```",
    "51": "```python\nfrom collections import Counter\nfrom math import gcd\n\nn = int(input())\ndivisors = list(map(int, input().split()))\n\n# Count the occurrences of each divisor\ncount = Counter(divisors)\n\n# Get all unique divisors\nunique_divisors = list(count.keys())\n\n# The product x * y is the product of all unique divisors raised to their counts\nx = 1\ny = 1\n\n# For each unique divisor\nfor d in unique_divisors:\n    # If the count is 2, it is a common divisor\n    if count[d] == 2:\n        x *= d\n        y *= d\n    # If the count is 1, assign it to x or y\n    elif count[d] == 1:\n        if x < y:\n            x *= d\n        else:\n            y *= d\n\nprint(x, y)\n```",
    "47": "```python\ndef max_subarray_sum(arr):\n    max_ending_here = max_so_far = 0\n    for x in arr:\n        max_ending_here = max(0, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\ndef max_beauty_with_operation(n, x, a):\n    # Calculate the beauty of the original array\n    original_beauty = max_subarray_sum(a)\n\n    # Calculate the beauty after multiplying a subarray by x\n    max_gain = 0\n    current_sum = 0\n    for i in range(n):\n        current_sum += a[i]\n        # Calculate the gain if we multiply the current prefix and the suffix\n        if i > 0:\n            max_gain = max(max_gain, current_sum * x - max_subarray_sum(a[:i]))\n        if i < n - 1:\n            max_gain = max(max_gain, current_sum * x - max_subarray_sum(a[i + 1:]))\n        \n        # Reset current sum if it goes negative\n        if current_sum < 0:\n            current_sum = 0\n\n    # Calculate the maximum possible beauty\n    return max(original_beauty, original_beauty + max_gain)\n\n# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate and print the maximum beauty\nprint(max_beauty_with_operation(n, x, a))\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef count_reachable(n):\n    reachable = set()\n    current = n\n    \n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    \n    return len(reachable)\n\nn = int(input().strip())\nprint(count_reachable(n))\n```",
    "53": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nleft, right = 0, n - 1\nlast = -1\nsequence = []\nmoves = []\n\nwhile left <= right:\n    if a[left] <= a[right]:\n        if a[left] > last:\n            last = a[left]\n            sequence.append(a[left])\n            moves.append('L')\n            left += 1\n        elif a[right] > last:\n            last = a[right]\n            sequence.append(a[right])\n            moves.append('R')\n            right -= 1\n        else:\n            break\n    else:\n        if a[right] > last:\n            last = a[right]\n            sequence.append(a[right])\n            moves.append('R')\n            right -= 1\n        elif a[left] > last:\n            last = a[left]\n            sequence.append(a[left])\n            moves.append('L')\n            left += 1\n        else:\n            break\n\nprint(len(sequence))\nprint(''.join(moves))\n```",
    "54": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmin_a = min(a)\nmax_a = max(a)\n\nif n == 1:\n    print(0)\nelse:\n    if max_a - min_a > 2 * (max_a - min_a) // 2:\n        print(-1)\n    else:\n        D = (max_a - min_a) // 2\n        print(D)\n```",
    "33": "```python\ndef count_integers(a1, b1, a2, b2, L, R):\n    from math import gcd\n    \n    # Calculate the difference in progressions and their coefficients\n    d1 = a1\n    d2 = a2\n    b_diff = b2 - b1\n    \n    # Calculate the GCD of the two progressions\n    g = gcd(d1, d2)\n    \n    # Check if there exists a solution for the linear combination\n    if b_diff % g != 0:\n        return 0\n    \n    # Find the general solution using the extended Euclidean algorithm\n    def extended_gcd(a, b):\n        if b == 0:\n            return a, 1, 0\n        g, x1, y1 = extended_gcd(b, a % b)\n        x = y1\n        y = x1 - (a // b) * y1\n        return g, x, y\n    \n    _, x0, y0 = extended_gcd(d1, d2)\n    \n    # Scale the solution\n    x0 *= b_diff // g\n    y0 *= b_diff // g\n    \n    # Coefficients for the general solution\n    d1 //= g\n    d2 //= g\n    \n    # Now we can express the integer solutions as:\n    # x = x0 + k * (d2)\n    # y = y0 - k * (d1)\n    \n    # We need x to be in range [L, R]\n    # L <= x0 + k * d2 <= R\n    # => (L - x0) / d2 <= k <= (R - x0) / d2\n    \n    def calc_k_bounds(x0, d, bound):\n        if d > 0:\n            return (bound - x0) // d\n        elif d < 0:\n            return (bound - x0 + d - 1) // d\n        return float('inf')  # d == 0 case, which won't happen here\n    \n    # Calculate k bounds\n    k_start = (L - x0 + (d2 - 1)) // d2 if d2 > 0 else (L - x0) // d2\n    k_end = (R - x0) // d2 if d2 > 0 else (R - x0 + (d2 + 1)) // d2\n    \n    # The total number of valid k's is:\n    count = max(0, k_end - k_start + 1)\n    \n    return count\n\n# Input reading\na1, b1, a2, b2, L, R = map(int, input().split())\nresult = count_integers(a1, b1, a2, b2, L, R)\nprint(result)\n```",
    "49": "```python\ndef find_kth_digit(k):\n    length = 1  # Length of the numbers we are currently considering\n    count = 9   # Count of numbers with the current length\n    start = 1   # Starting number with the current length\n\n    # Determine the length of the number that contains the k-th digit\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    # Determine the actual number that contains the k-th digit\n    start += (k - 1) // length\n    num_str = str(start)\n    \n    # Find the specific digit\n    return num_str[(k - 1) % length]\n\n# Read input\nk = int(input().strip())\n# Output the result\nprint(find_kth_digit(k))\n```",
    "59": "```python\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# Create the target suffix based on y\ntarget_suffix = ['0'] * x\ntarget_suffix[y] = '1'\ntarget_suffix = ''.join(target_suffix)\n\n# Get the current suffix from the number\ncurrent_suffix = number[-x:]\n\n# Calculate the number of operations needed\nmin_operations = sum(1 for i in range(x) if current_suffix[i] != target_suffix[i])\n\nprint(min_operations)\n```",
    "57": "```python\ndef fill_gift_preferences(n, f):\n    # Track who has received a gift\n    gift_received = set(f_i for f_i in f if f_i != 0)\n    \n    # Friends who don't know whom to give the gift to\n    unknown_givers = [i + 1 for i in range(n) if f[i] == 0]\n    \n    # Friends who are not receiving gifts\n    all_friends = set(range(1, n + 1))\n    not_giving_gifts = all_friends - gift_received\n    \n    # Create a list of pairs of unknown givers and not giving gifts\n    result = f[:]\n    \n    for giver in unknown_givers:\n        for receiver in not_giving_gifts:\n            if giver != receiver:  # Ensure no one gives a gift to themselves\n                result[giver - 1] = receiver\n                not_giving_gifts.remove(receiver)  # Remove the receiver from available ones\n                break\n\n    print(\" \".join(map(str, result)))\n\n# Input reading\nn = int(input())\nf = list(map(int, input().split()))\n\nfill_gift_preferences(n, f)\n```",
    "55": "```python\n# Read the coordinates of the white sheet\nx1, y1, x2, y2 = map(int, input().split())\n# Read the coordinates of the first black sheet\nx3, y3, x4, y4 = map(int, input().split())\n# Read the coordinates of the second black sheet\nx5, y5, x6, y6 = map(int, input().split())\n\n# Check if the white sheet is completely covered by the black sheets\ncovered_x_min = max(x3, x5)\ncovered_x_max = min(x4, x6)\ncovered_y_min = max(y3, y5)\ncovered_y_max = min(y4, y6)\n\n# Check if the black sheets together cover the white sheet completely\nif (covered_x_min < covered_x_max) and (covered_y_min < covered_y_max):\n    # Check if the area of the white sheet is inside the area covered by black sheets\n    if (x1 >= covered_x_min and x2 <= covered_x_max and y1 >= covered_y_min and y2 <= covered_y_max):\n        print(\"NO\")\n    else:\n        print(\"YES\")\nelse:\n    print(\"YES\")\n```",
    "58": "```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nfrom collections import defaultdict\n\n# Dictionary to store the indices of each number\nnum_indices = defaultdict(list)\nfor i in range(n):\n    num_indices[a[i]].append(i)\n\n# Check if there are more unique numbers than colors\nif len(num_indices) > k:\n    print(\"NO\")\n    exit()\n\n# Prepare the color assignment\ncolor_assignment = [0] * n\ncurrent_color = 1\n\n# Assign colors\nfor indices in num_indices.values():\n    for index in indices:\n        color_assignment[index] = current_color\n        current_color += 1\n        if current_color > k:\n            current_color = 1\n\n# If we have filled all colors, we can just distribute the remaining colors\nfor i in range(n):\n    if color_assignment[i] == 0:\n        color_assignment[i] = current_color\n        current_color += 1\n        if current_color > k:\n            current_color = 1\n\nprint(\"YES\")\nprint(\" \".join(map(str, color_assignment)))\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_choose = m // 2\n    dp = [[-1] * k for _ in range(n + 1)]\n    dp[0][0] = 0  # Base case: 0 elements chosen, sum is 0\n\n    for i in range(1, n + 1):\n        row = matrix[i - 1]\n        row.sort(reverse=True)  # Sort to choose the largest elements\n        current_dp = dp[i - 1][:]\n        \n        for count in range(1, max_choose + 1):\n            if count > len(row):\n                break\n            current_sum = sum(row[:count])\n            for j in range(k):\n                if current_dp[j] != -1:\n                    new_sum = current_dp[j] + current_sum\n                    new_remainder = new_sum % k\n                    if new_sum > dp[i][new_remainder]:\n                        dp[i][new_remainder] = new_sum\n\n        for j in range(k):\n            dp[i][j] = max(dp[i][j], current_dp[j])\n\n    return dp[n][0] if dp[n][0] != -1 else 0\n\n# Input reading\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print\nresult = max_sum_divisible_by_k(n, m, k, matrix)\nprint(result)\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        min_moves = float('inf')\n        best_triple = (0, 0, 0)\n        \n        for A in range(1, c + 1):\n            if A > a:\n                moves_a = A - a\n            else:\n                moves_a = a - A\n            \n            if A > 0:\n                # B should be a multiple of A\n                B = ((b + A - 1) // A) * A  # smallest multiple of A >= b\n                moves_b = abs(B - b)\n            else:\n                B = 1\n                moves_b = abs(B - b)\n            \n            # C should be a multiple of B\n            C = ((c + B - 1) // B) * B  # smallest multiple of B >= c\n            moves_c = abs(C - c)\n            \n            total_moves = moves_a + moves_b + moves_c\n            \n            if total_moves < min_moves:\n                min_moves = total_moves\n                best_triple = (A, B, C)\n        \n        results.append((min_moves, best_triple))\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Getting results\nresults = min_operations(t, test_cases)\n\n# Output results\nfor res in results:\n    print(res[0])\n    print(*res[1])\n```",
    "63": "```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Sort the array to easily find min and max after removing elements\na.sort()\n\n# Two potential scenarios:\n# 1. Remove the first element (smallest)\n# 2. Remove the last element (largest)\n\n# Instability after removing the first element\ninstability1 = a[-1] - a[1]\n\n# Instability after removing the last element\ninstability2 = a[-2] - a[0]\n\n# The minimum instability after removing one element\nmin_instability = min(instability1, instability2)\n\nprint(min_instability)\n```",
    "61": "```python\nn = int(input())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\n# Convert f to a list where the index represents the digit - 1\nf = [0] + f  # f[0] is unused, we use indices 1 to 9\n\nmax_number = a  # Start with the original number\n\n# We will look for the best segment to replace\nchanged = False\nnew_number = []\n\nfor i in range(n):\n    digit = int(a[i])\n    if f[digit] > digit:\n        # Start replacing\n        new_number.append(str(f[digit]))\n        changed = True\n    elif f[digit] < digit and changed:\n        # Stop replacing if we already started\n        break\n    else:\n        new_number.append(str(digit))\n\n# If we started replacing but didn't stop, we should finalize it\nif changed:\n    max_number = ''.join(new_number) + a[i+1:]\n\n# Output the maximum number\nprint(max(max_number, a))\n```",
    "67": "```python\nn = int(input())\na = list(map(int, input().split()))\n\ntotal_sum = sum(a)\nnice_indices = []\n\nfor i in range(n):\n    remaining_sum = total_sum - a[i]\n    if a[i] == remaining_sum:\n        nice_indices.append(i + 1)  # +1 for 1-based index\n\nprint(len(nice_indices))\nif nice_indices:\n    print(' '.join(map(str, nice_indices)))\n```",
    "65": "```python\ndef transform_moves(n, m):\n    if m % n != 0:\n        return -1\n    \n    ratio = m // n\n    count_2 = 0\n    count_3 = 0\n    \n    while ratio % 2 == 0:\n        ratio //= 2\n        count_2 += 1\n        \n    while ratio % 3 == 0:\n        ratio //= 3\n        count_3 += 1\n        \n    if ratio != 1:\n        return -1\n    \n    return count_2 + count_3\n\nn, m = map(int, input().split())\nprint(transform_moves(n, m))\n```",
    "71": "```python\nimport math\n\na = int(input())\noutput = math.ceil(math.log2(a))\nprint(output)\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    days = [0] * n\n    preparation_days = [0] * m\n    exam_days = set()\n\n    for i, (s, d, c) in enumerate(exams):\n        exam_days.add(d - 1)\n        if preparation_days[i] < c:\n            for j in range(s - 1, d - 1):\n                if preparation_days[i] < c and days[j] == 0:\n                    days[j] = i + 1\n                    preparation_days[i] += 1\n    \n    for i in range(m):\n        if preparation_days[i] < exams[i][2]:\n            return -1\n\n    for i in range(n):\n        if days[i] == 0 and i not in exam_days:\n            days[i] = 0\n        elif i in exam_days:\n            days[i] = m + 1\n\n    return days\n\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\nresult = schedule_exams(n, m, exams)\n\nif result == -1:\n    print(-1)\nelse:\n    print(*result)\n```",
    "60": "```python\ndef has_palindrome_subsequence(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        found = False\n        index_map = {}\n        for i in range(n):\n            if a[i] in index_map:\n                if i - index_map[a[i]] >= 2:\n                    found = True\n                    break\n            index_map[a[i]] = i\n        results.append(\"YES\" if found else \"NO\")\n        \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Get results\nresults = has_palindrome_subsequence(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "70": "```python\n# Read input\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Convert start and end time to total minutes\nstart_minutes = h1 * 60 + m1\nend_minutes = h2 * 60 + m2\n\n# Calculate midpoint in total minutes\nmid_minutes = (start_minutes + end_minutes) // 2\n\n# Convert back to hours and minutes\nh3 = mid_minutes // 60\nm3 = mid_minutes % 60\n\n# Print result in required format\nprint(f\"{h3:02}:{m3:02}\")\n```",
    "73": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nmax_height = max(a)\ntotal_bricks = sum(max_height - height for height in a)\n\nif total_bricks % 2 == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, n):\n    dist = [-1] * (n + 1)\n    dist[start] = 0\n    q = deque([start])\n    farthest_node = start\n    \n    while q:\n        node = q.popleft()\n        for neighbor in graph[node]:\n            if dist[neighbor] == -1:\n                dist[neighbor] = dist[node] + 1\n                q.append(neighbor)\n                if dist[neighbor] > dist[farthest_node]:\n                    farthest_node = neighbor\n    return farthest_node, dist\n\nn = int(input())\ngraph = defaultdict(list)\n\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\n# Find the farthest node from an arbitrary node (1)\nfarthest_from_start, _ = bfs(1, n)\n# Find the farthest node from that farthest node (this gives one endpoint of the diameter)\nfarthest_node, dist_from_first = bfs(farthest_from_start, n)\n# Now find distances from the second farthest node (this gives the other endpoint of the diameter)\n_, dist_from_second = bfs(farthest_node, n)\n\n# The maximum number of edges used in paths among three distinct vertices is the diameter length\nmax_edges = dist_from_first[farthest_node]\n\n# Now we need to choose three vertices a, b, c\n# We can take the two endpoints of the diameter and one more node\na, b = farthest_from_start, farthest_node\n\n# Choose the third vertex with the maximum distance from either of the endpoints\nthird_vertex = -1\nif dist_from_first[b] > dist_from_second[b]:\n    # Take the third vertex from the first distances\n    for i in range(1, n + 1):\n        if i != a and i != b and (third_vertex == -1 or dist_from_first[i] > dist_from_first[third_vertex]):\n            third_vertex = i\nelse:\n    # Take the third vertex from the second distances\n    for i in range(1, n + 1):\n        if i != a and i != b and (third_vertex == -1 or dist_from_second[i] > dist_from_second[third_vertex]):\n            third_vertex = i\n\nprint(max_edges)\nprint(a, b, third_vertex)\n```",
    "77": "```python\ndef min_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nn = int(input())\nprint(min_difference(n))\n```",
    "66": "```python\ndef minimum_length_string(n, k, t):\n    # Find the longest prefix which is also a suffix\n    # This is used to minimize overlaps\n    lps = [0] * n\n    j = 0\n    \n    # Preprocess the pattern to create the lps array\n    for i in range(1, n):\n        while (j > 0 and t[i] != t[j]):\n            j = lps[j - 1]\n        if t[i] == t[j]:\n            j += 1\n            lps[i] = j\n        else:\n            lps[i] = 0\n\n    # Length of the longest prefix which is also a suffix\n    overlap_length = lps[-1]\n    \n    # Calculate the minimum length of the resultant string\n    # Start with the first occurrence of t\n    result = t\n    \n    # Add (k-1) occurrences of the remaining part of t after the overlap\n    result += (t[overlap_length:] * (k - 1))\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the result\nresult = minimum_length_string(n, k, t)\n\n# Print the result\nprint(result)\n```",
    "68": "```python\ndef minimum_cost_to_obtain_set(n, k, s):\n    # Count the number of unique subsequences of the string s\n    unique_chars = set(s)\n    unique_count = len(unique_chars)\n\n    # Calculate the maximum number of unique subsequences\n    max_unique_subsequences = (1 << unique_count) - 1  # 2^unique_count - 1\n    if k > max_unique_subsequences:\n        return -1\n\n    # Generate all subsequences\n    subsequences = set()\n    for i in range(1 << n):\n        subsequence = []\n        for j in range(n):\n            if i & (1 << j):\n                subsequence.append(s[j])\n        subsequences.add(''.join(subsequence))\n\n    subsequences = list(subsequences)\n    subsequences.sort(key=len)  # Sort by length\n\n    total_cost = 0\n    for i in range(k):\n        if i < len(subsequences):\n            total_cost += n - len(subsequences[i])\n        else:\n            return -1\n\n    return total_cost\n\n# Input handling\nn, k = map(int, input().split())\ns = input().strip()\n\n# Calculate the result and print it\nresult = minimum_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    if len(graph[1]) < D:\n        print(\"NO\")\n        return\n    \n    # Degree of vertex 1 should be D\n    tree_edges = []\n    visited = set()\n    visited.add(1)\n    \n    # Start with vertex 1\n    degree_1 = 0\n    queue = deque([1])\n    \n    while queue:\n        node = queue.popleft()\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if degree_1 < D and node == 1:\n                    tree_edges.append((node, neighbor))\n                    degree_1 += 1\n                elif node != 1:\n                    tree_edges.append((node, neighbor))\n                \n                visited.add(neighbor)\n                queue.append(neighbor)\n                \n                if degree_1 >= D and node == 1:\n                    break\n        \n        if degree_1 >= D:\n            break\n\n    if degree_1 < D or len(tree_edges) < n - 1:\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    for u, v in tree_edges:\n        print(u, v)\n\n# Read input\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nfind_spanning_tree(n, m, D, edges)\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    # Unique subsequences set\n    unique_subsequences = set()\n    \n    # Generate all possible subsequences\n    for i in range(1 << n):\n        subsequence = \"\"\n        for j in range(n):\n            if i & (1 << j):\n                subsequence += s[j]\n        unique_subsequences.add(subsequence)\n    \n    # If the number of unique subsequences is less than k, return -1\n    if len(unique_subsequences) < k:\n        return -1\n\n    # List of lengths of all unique subsequences\n    lengths = sorted([len(subseq) for subseq in unique_subsequences])\n    \n    # Calculate minimum cost\n    total_cost = 0\n    for i in range(k):\n        total_cost += n - lengths[i]\n    \n    return total_cost\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get result and print it\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "81": "```python\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\n# Sort strings based on their lengths\nstrings.sort(key=len)\n\n# Check if the arrangement is valid\nfor i in range(1, n):\n    if strings[i-1] not in strings[i]:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")\n    print(\"\\n\".join(strings))\n```",
    "76": "```python\ndef can_construct_symmetric_square(test_cases):\n    results = []\n    for n, m, tiles in test_cases:\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n\n        top_left_values = set()\n        bottom_right_values = set()\n        \n        for tile in tiles:\n            top_left_values.add(tile[0][0])\n            bottom_right_values.add(tile[1][1])\n\n        if top_left_values & bottom_right_values:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        top_row = list(map(int, input().split()))\n        bottom_row = list(map(int, input().split()))\n        tiles.append((top_row, bottom_row))\n    test_cases.append((n, m, tiles))\n\n# Process each test case\nresults = can_construct_symmetric_square(test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "82": "```python\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\nsolved = 0\n\n# Solve from the left\nwhile solved < n and difficulties[solved] <= k:\n    solved += 1\n\n# Solve from the right\nwhile solved < n and difficulties[n - 1 - (solved - (n - solved))] <= k:\n    solved += 1\n\n# Avoid double counting if the leftmost and rightmost problems are solved\nif solved > n:\n    solved = n\n\nprint(solved)\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Days of the week food distribution\n    week_pattern = [0, 1, 0, 2, 0, 1, 2]  # 0: fish, 1: rabbit, 2: chicken\n    food_count = [a, b, c]\n    \n    def can_feed_for_days(start_day, days):\n        food_needed = [0, 0, 0]  # fish, rabbit, chicken\n        \n        for i in range(days):\n            food_needed[week_pattern[(start_day + i) % 7]] += 1\n        \n        return all(food_needed[i] <= food_count[i] for i in range(3))\n\n    max_days_possible = 0\n    \n    for start_day in range(7):\n        left, right = 0, 10**18  # an arbitrary large number\n        while left < right:\n            mid = (left + right + 1) // 2\n            if can_feed_for_days(start_day, mid):\n                left = mid\n            else:\n                right = mid - 1\n        max_days_possible = max(max_days_possible, left)\n    \n    return max_days_possible\n\n# Read input\na, b, c = map(int, input().split())\n# Output the result\nprint(max_days(a, b, c))\n```",
    "78": "```python\nMOD = 10**9 + 7\n\ndef count_regular_sequences(n, s):\n    m = len(s)\n    \n    # Precompute Catalan numbers up to 2n\n    catalan = [0] * (n + 1)\n    catalan[0] = 1\n    for i in range(1, n + 1):\n        catalan[i] = 0\n        for j in range(i):\n            catalan[i] = (catalan[i] + catalan[j] * catalan[i - 1 - j]) % MOD\n    \n    # Function to check if the current string can be a valid prefix/suffix\n    def can_form_prefix(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance\n    \n    # Check balance of the given string s\n    balance = can_form_prefix(s)\n    if balance < 0 or balance > n:\n        return 0\n    \n    # Count valid configurations\n    valid_count = 0\n    for i in range(n + 1):\n        if i >= balance and (n - i) >= 0 and (n - i) + balance >= 0:\n            valid_count = (valid_count + catalan[i - balance] * catalan[n - i]) % MOD\n\n    return valid_count\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output result\nprint(count_regular_sequences(n, s))\n```",
    "85": "```python\nA, B = map(int, input().split())\n\ndef find_price(A, B):\n    for price in range(1, 10000):  # Arbitrary upper limit for price\n        tax_8 = price * 0.08\n        tax_10 = price * 0.10\n        if int(tax_8) == A and int(tax_10) == B:\n            return price\n    return -1\n\nresult = find_price(A, B)\nprint(result)\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    \n    # We need to check for pairs (0, 5) or (2, 5) or (5, 0)\n    target_pairs = ['00', '25', '50', '75']\n    min_moves = float('inf')\n    \n    for pair in target_pairs:\n        first, second = pair\n        \n        # Check if we can find the second digit first\n        pos_second = -1\n        for i in range(length - 1, -1, -1):\n            if s[i] == second:\n                pos_second = i\n                # Now look for the first digit before it\n                for j in range(pos_second - 1, -1, -1):\n                    if s[j] == first:\n                        moves = (pos_second - j) + (length - 1 - pos_second)\n                        min_moves = min(min_moves, moves)\n                        break\n                break\n    \n    return min_moves if min_moves != float('inf') else -1\n\n# Read input\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n\n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            # Check if we can fit a rectangles for both colors\n            for color_tiles in (a, b):\n                for color_width in range(1, int(color_tiles**0.5) + 1):\n                    if color_tiles % color_width == 0:\n                        color_height = color_tiles // color_width\n                        # Check the perimeter of the enclosing rectangle\n                        perimeter = 2 * (width + height)\n                        min_perimeter = min(min_perimeter, perimeter)\n\n                        # Check the other orientation\n                        perimeter = 2 * (color_height + color_width)\n                        min_perimeter = min(min_perimeter, perimeter)\n\n    return min_perimeter\n\na, b = map(int, input().split())\nprint(minimal_perimeter(a, b))\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    from collections import defaultdict\n    \n    # Step 1: Find the positions of each character\n    positions = defaultdict(list)\n    for i, char in enumerate(s):\n        positions[char].append(i)\n    \n    # Step 2: Determine the minimum number of colors needed\n    color = [0] * n\n    next_color = 1\n    last_used = [-1] * 26  # Track the last color used for each character\n    \n    for i, char in enumerate(s):\n        index = ord(char) - ord('a')\n        if last_used[index] == -1:\n            # If this character has not been colored yet\n            color[i] = next_color\n            last_used[index] = next_color\n            next_color += 1\n        else:\n            # If this character has been colored, use the same color\n            color[i] = last_used[index]\n\n    # Output the result\n    print(next_color - 1)\n    print(' '.join(map(str, color)))\n\n# Example input\nn = int(input().strip())\ns = input().strip()\nmin_colors_to_sort(n, s)\n```",
    "72": "```python\ndef maximal_intersection_length(n, segments):\n    left = [0] * n\n    right = [0] * n\n    \n    for i in range(n):\n        left[i] = segments[i][0]\n        right[i] = segments[i][1]\n    \n    max_left = [0] * n\n    min_right = [0] * n\n    \n    max_left[0] = left[0]\n    for i in range(1, n):\n        max_left[i] = max(max_left[i - 1], left[i])\n    \n    min_right[n - 1] = right[n - 1]\n    for i in range(n - 2, -1, -1):\n        min_right[i] = min(min_right[i + 1], right[i])\n    \n    max_length = 0\n    \n    for i in range(n):\n        if i > 0:\n            current_left = max_left[i - 1]\n        else:\n            current_left = left[1]\n        \n        if i < n - 1:\n            current_right = min_right[i + 1]\n        else:\n            current_right = right[n - 2]\n        \n        intersection_length = max(0, current_right - current_left)\n        max_length = max(max_length, intersection_length)\n    \n    return max_length\n\n# Input reading\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(maximal_intersection_length(n, segments))\n```",
    "84": "```python\ndef can_color_sort(s):\n    n = len(s)\n    color = [''] * n\n    last_seen = {}\n    \n    for i in range(n):\n        char = s[i]\n        if char in last_seen:\n            if last_seen[char] == '0':\n                color[i] = '1'\n            else:\n                color[i] = '0'\n        else:\n            color[i] = '0' if i % 2 == 0 else '1'\n        \n        last_seen[char] = color[i]\n    \n    for i in range(n - 1):\n        if s[i] > s[i + 1] and color[i] == color[i + 1]:\n            return \"NO\"\n    \n    return \"YES\", ''.join(color)\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Check if possible to color and sort\nresult = can_color_sort(s)\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    print(result[1])\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects by the required rating a_i\n    projects.sort(key=lambda x: x[0])\n    \n    for a, b in projects:\n        if r < a:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(can_complete_projects(n, r, projects))\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    projects.sort(key=lambda x: (x[0], -x[1]))\n\n    completed_projects = 0\n    current_rating = r\n    \n    while True:\n        progress = False\n        for i in range(len(projects)):\n            a_i, b_i = projects[i]\n            if a_i <= current_rating:\n                if current_rating + b_i >= 0:\n                    current_rating += b_i\n                    completed_projects += 1\n                    projects[i] = (float('inf'), 0)  # Mark as completed\n                    progress = True\n                    break\n        if not progress:\n            break\n            \n    return completed_projects\n\n# Reading input\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Getting the result and printing it\nresult = max_projects(n, r, projects)\nprint(result)\n```",
    "92": "```python\nx = float(input().strip())\n\n# Calculate the two integers a and b\na = int(x * 10) % 10 + 1\nb = int(x * 100) % 10 + 1\n\n# Ensure both a and b are between 1 and 10\nif a < 1:\n    a = 1\nif a > 10:\n    a = 10\nif b < 1:\n    b = 1\nif b > 10:\n    b = 10\n\nprint(a, b)\n```",
    "90": "```python\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\ntotal_length = sum(c)\n\n# Check if we can fit the platforms in such a way that we can reach n+1\nif total_length + (m - 1) * d < n:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    a = [0] * n\n    pos = 0\n\n    for i in range(m):\n        # Place the platform at the current position\n        for j in range(c[i]):\n            a[pos] = i + 1\n            pos += 1\n        # Move to the next position considering the jump distance\n        if i < m - 1:\n            pos += d  # leave space for the next platform\n\n    print(\" \".join(map(str, a)))\n```",
    "86": "```python\ndef solve_problems(n, k):\n    # Minimum sum of problems required: 1 + 2 + 3 + ... + k = k * (k + 1) // 2\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n\n    # Maximum sum of problems we can reach: 1 * 2^(k-1) + 2^(k-1) + 2^(k-2) + ... + 2^0\n    # This is a geometric series with the first term as 1 and ratio as 2.\n    max_sum = (1 << k) - 1  # 2^k - 1\n    if n > max_sum:\n        print(\"NO\")\n        return\n\n    # Now, we need to construct the sequence\n    a = [0] * k\n    # Start with the minimum valid sequence\n    for i in range(k):\n        a[i] = i + 1\n\n    current_sum = min_sum\n    for i in range(k - 1, -1, -1):\n        # While current_sum is less than n, try to increase a[i]\n        while current_sum < n:\n            if a[i] * 2 <= (a[i + 1] if i + 1 < k else float('inf')):  # can double\n                current_sum += a[i]\n                a[i] *= 2\n            else:\n                break\n\n    if current_sum == n:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n    else:\n        print(\"NO\")\n\n# Read input\nn, k = map(int, input().split())\nsolve_problems(n, k)\n```",
    "88": "```python\nn = int(input())\na = list(map(int, input().split()))\n\nfrom collections import Counter\n\ncount = Counter(a)\nmatrix = [[0] * n for _ in range(n)]\n\n# Check for the possibility of forming a palindromic matrix\nodd_count = 0\nfor value, freq in count.items():\n    if freq % 2 != 0:\n        odd_count += 1\n\nif (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n    print(\"NO\")\nelse:\n    # Fill the matrix\n    half_matrix = []\n    for value, freq in count.items():\n        half_matrix.extend([value] * (freq // 2))\n    \n    half_size = len(half_matrix)\n    # Fill the top half of the matrix\n    for i in range(n // 2):\n        for j in range(n // 2):\n            matrix[i][j] = half_matrix[i * (n // 2) + j]\n            matrix[i][n - j - 1] = half_matrix[i * (n // 2) + j]\n            matrix[n - i - 1][j] = half_matrix[i * (n // 2) + j]\n            matrix[n - i - 1][n - j - 1] = half_matrix[i * (n // 2) + j]\n\n    # Fill the center if n is odd\n    if n % 2 == 1:\n        center_value = None\n        for value, freq in count.items():\n            if freq % 2 == 1:\n                center_value = value\n                break\n        for i in range(n):\n            matrix[i][n // 2] = center_value\n            matrix[n // 2][i] = center_value\n\n    print(\"YES\")\n    for row in matrix:\n        print(\" \".join(map(str, row)))\n```",
    "97": "```python\nn = int(input())\nchips = list(map(int, input().split()))\n\neven_count = sum(1 for x in chips if x % 2 == 0)\nodd_count = n - even_count\n\n# The minimum coins required is the smaller group\nmin_coins = min(even_count, odd_count)\nprint(min_coins)\n```",
    "98": "```python\ndef min_moves_to_reach_n(N):\n    moves = float('inf')\n    \n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            moves = min(moves, (i - 1) + (j - 1))\n\n    return moves\n\nN = int(input())\nprint(min_moves_to_reach_n(N))\n```",
    "96": "```python\nn = int(input())\nq = list(map(int, input().split()))\n\n# Initialize p array and calculate the prefix sums\np = [0] * n\np[0] = 0  # Let's assume p_1 = 0 for convenience\n\nfor i in range(1, n):\n    p[i] = p[i - 1] + q[i - 1]\n\n# Normalize p to make it a permutation of 1 to n\nmin_p = min(p)\np = [x - min_p + 1 for x in p]\n\n# Check if p is a valid permutation\nif sorted(p) == list(range(1, n + 1)):\n    print(' '.join(map(str, p)))\nelse:\n    print(-1)\n```",
    "99": "```python\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\n# Maximum wins for Alice\nmax_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n\n# Minimum wins for Alice\n# Calculate Bob's potential wins:\nbob_wins = min(b1, a2) + min(b2, a3) + min(b3, a1)\n\n# Since total rounds are n, Alice's minimum wins will be:\nmin_wins = n - bob_wins\n\nprint(min_wins, max_wins)\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1:  # Check the maximum diameter possible with given degree\n        return \"NO\"\n    \n    if d == 1 and n > 2:      # If diameter is 1, we can only have a 2-vertex tree\n        return \"NO\"\n    \n    edges = []\n    \n    # Create a linear path of length d\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n        \n    # The last vertex added in the path\n    last_vertex = d + 1\n    \n    # Now we need to connect the remaining vertices\n    for i in range(last_vertex + 1, n + 1):\n        # Connect each new vertex to the first vertex in the path\n        edges.append((1, i))\n    \n    # Check if any vertex exceeds the degree k\n    degree_count = [0] * (n + 1)\n    \n    for u, v in edges:\n        degree_count[u] += 1\n        degree_count[v] += 1\n    \n    for i in range(1, n + 1):\n        if degree_count[i] > k:\n            return \"NO\"\n    \n    result = [\"YES\"]\n    for u, v in edges:\n        result.append(f\"{u} {v}\")\n    \n    return \"\\n\".join(result)\n\n# Read input\nn, d, k = map(int, input().split())\n# Output result\nprint(construct_tree(n, d, k))\n```",
    "94": "```python\na, b, x = map(int, input().split())\n\n# Generate the base pattern\nif x % 2 == 1:\n    s = '01' * (x // 2) + '0' * (a - (x // 2 + 1)) + '1' * (b - (x // 2)) if a >= b else '10' * (x // 2) + '1' * (b - (x // 2 + 1)) + '0' * (a - (x // 2))\nelse:\n    s = '01' * (x // 2) + '0' * (a - (x // 2)) + '1' * (b - (x // 2)) if a >= b else '10' * (x // 2) + '1' * (b - (x // 2)) + '0' * (a - (x // 2))\n\n# Adjust the string to fit the counts of '0's and '1's\ns = list(s)\nzeros_needed = a - s.count('0')\nones_needed = b - s.count('1')\n\n# Fill with remaining '0's and '1's\nif zeros_needed > 0:\n    for i in range(len(s)):\n        if s[i] == '0' and zeros_needed > 0:\n            continue\n        if s[i] == '1' and ones_needed > 0:\n            continue\n        if zeros_needed > 0:\n            s[i] = '0'\n            zeros_needed -= 1\n        elif ones_needed > 0:\n            s[i] = '1'\n            ones_needed -= 1\n\nprint(''.join(s))\n```",
    "95": "```python\nn = int(input())\ns = input().strip()\nt = input().strip()\n\n# Create a list of characters\nchars = ['a'] * n + ['b'] * n + ['c'] * n\n\n# Function to check if a string contains substrings s or t\ndef contains_substring(res):\n    return s in res or t in res\n\n# Try to generate a valid string\nfrom itertools import permutations\n\n# Generate all permutations of the string\nfor perm in permutations(chars):\n    res = ''.join(perm)\n    if not contains_substring(res):\n        print(\"YES\")\n        print(res)\n        break\nelse:\n    print(\"NO\")\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n\n    # Precompute the leftmost positions of each character in t\n    left = [0] * m\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n\n    # Precompute the rightmost positions of each character in t\n    right = [0] * m\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n\n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n\n    # Check for the case when we can remove from start to rightmost of t\n    max_length = max(max_length, right[0] + 1)\n\n    # Check for the case when we can remove from leftmost of t to end\n    max_length = max(max_length, n - left[m - 1] - 1)\n\n    return max_length\n\n# Input reading\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(max_removable_length(s, t))\n```"
}