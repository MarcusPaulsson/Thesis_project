{
    "0": "```python\ndef process_test_case(n, words):\n    word_set = set(words)\n    reversals = []\n    \n    for i in range(n):\n        if words[i][::-1] in word_set:\n            reversals.append(i + 1)  # Store 1-based index of the word\n\n    if len(reversals) % 2 == 1:\n        # If odd number of reversals, we can't pair them correctly\n        return -1\n    \n    return len(reversals), reversals\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        words = [data[index + i] for i in range(n)]\n        index += n\n        \n        result = process_test_case(n, words)\n        if result == -1:\n            results.append(\"-1\")\n        else:\n            k, reversals = result\n            results.append(f\"{k}\")\n            if k > 0:\n                results.append(\" \".join(map(str, reversals)))\n    \n    print(\"\\n\".join(results))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
    "1": "```python\ndef max_diagonal_moves(queries):\n    results = []\n    for n, m, k in queries:\n        # Minimum moves required to reach (n, m) from (0, 0)\n        min_moves = max(n, m)\n        # Remaining moves after reaching the destination\n        remaining_moves = k - min_moves\n        \n        # Check if it is possible to reach (n, m) in exactly k moves\n        if remaining_moves < 0 or remaining_moves % 2 != 0:\n            results.append(-1)\n        else:\n            # Maximum diagonal moves possible\n            diagonal_moves = min(n, m)\n            # Additional moves can be made in the same direction, thus\n            # the maximum diagonal moves is min(n, m) + remaining_moves\n            results.append(diagonal_moves + remaining_moves)\n    \n    return results\n\n# Read input\nq = int(input())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Get results and print\nresults = max_diagonal_moves(queries)\nprint(\"\\n\".join(map(str, results)))\n```",
    "2": "```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1].split()))\n        b = list(map(int, data[index + 2].split()))\n        c = list(map(int, data[index + 3].split()))\n        index += 4\n        \n        p = [0] * n\n        \n        for i in range(n):\n            # Choose the first option\n            chosen = a[i]\n            if i > 0 and chosen == p[i - 1]:\n                # If it's the same as the previous one, choose the second option\n                chosen = b[i] if b[i] != p[i - 1] else c[i]\n            p[i] = chosen\n        \n        # Handle the case for the last element to ensure it's not the same as the first\n        if p[n - 1] == p[0]:\n            # If it is the same, we need to change it\n            if n > 1:\n                # Change to either b[n-1] or c[n-1] that is not p[n-2] and p[0]\n                if b[n - 1] != p[n - 2] and b[n - 1] != p[0]:\n                    p[n - 1] = b[n - 1]\n                else:\n                    p[n - 1] = c[n - 1]\n        \n        results.append(' '.join(map(str, p)))\n    \n    print('\\n'.join(results))\n\n# Run the function\nsolve()\n```",
    "3": "```python\ndef max_difference(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, k = case[0], case[1]\n        a = case[2]\n        \n        # If all barrels are empty, the difference is 0\n        if all(amount == 0 for amount in a):\n            results.append(0)\n            continue\n        \n        # Sort the array to find the maximum and minimum easily\n        a.sort()\n        \n        # The maximum possible amount after k pours will be the sum of the largest k+1 barrels\n        max_water = sum(a[-(k + 1):])\n        \n        # The minimum possible amount after k pours will be the sum of the smallest barrel\n        min_water = a[0]\n        \n        # Calculate the difference\n        results.append(max_water - min_water)\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, k, a))\n\n# Get results and print them\nresults = max_difference(t, test_cases)\nfor result in results:\n    print(result)\n```",
    "4": "```python\ndef is_beautiful_permutation(t, test_cases):\n    results = []\n    for n, p in test_cases:\n        beautiful = ['0'] * n\n        max_value = 0\n        for i in range(n):\n            max_value = max(max_value, p[i])\n            if max_value == i + 1:\n                beautiful[i] = '1'\n        results.append(''.join(beautiful))\n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(t):\n    n = int(data[index])\n    p = list(map(int, data[index + 1].split()))\n    test_cases.append((n, p))\n    index += 2\n\n# Get results\nresults = is_beautiful_permutation(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "5": "```python\ndef find_permutations(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, a = case\n        count = {}\n        \n        # Count occurrences of each number\n        for num in a:\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n        \n        # Find valid (l1, l2) pairs\n        valid_pairs = []\n        prefix_set = set()\n        suffix_set = set()\n        \n        for i in range(n):\n            # Update prefix and suffix\n            prefix_set.add(a[i])\n            suffix_set.clear()\n            for j in range(i + 1, n):\n                suffix_set.add(a[j])\n            \n            l1, l2 = i + 1, n - (i + 1)\n            if (len(prefix_set) == l1) and (len(suffix_set) == l2):\n                valid_pairs.append((l1, l2))\n        \n        results.append(valid_pairs)\n    \n    output = []\n    for valid_pairs in results:\n        output.append(str(len(valid_pairs)))\n        for l1, l2 in valid_pairs:\n            output.append(f\"{l1} {l2}\")\n    \n    print(\"\\n\".join(output))\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Function call\nfind_permutations(t, test_cases)\n```",
    "6": "```python\ndef process_test_case(n, m, tracks):\n    # Use a simple strategy: close the last two spots\n    to_close = []\n    \n    # We can safely close the last two spots if n > 1\n    if n > 1:\n        to_close = [n, n-1]\n    \n    # If n is 1, we cannot close any spots\n    k = len(to_close)\n    return k, to_close\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        n, m = map(int, data[index].split())\n        index += m + 1  # Skip the m lines of tracks\n        \n        k, to_close = process_test_case(n, m, [])\n        results.append(f\"{k}\")\n        if k > 0:\n            results.append(\" \".join(map(str, to_close)))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "7": "```python\ndef minimum_coins_to_win(t, test_cases):\n    results = []\n    for case in test_cases:\n        n = case[0]\n        voters = case[1]\n        \n        # Sort voters by the number of required votes to get their vote\n        voters.sort(key=lambda x: (x[0], x[1]))\n        \n        # Initialize a list to track how many voters can be convinced\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0  # No cost to convince 0 voters\n        \n        for m, p in voters:\n            # We go backwards to avoid overwriting results of the current iteration\n            for j in range(n, m, -1):\n                dp[j] = min(dp[j], dp[j - m] + p)\n        \n        # The result for this test case is the minimum cost to convince n voters\n        results.append(min(dp[n], sum(p for _, p in voters)))\n    \n    return results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\nindex = 1\ntest_cases = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    voters = []\n    for _ in range(n):\n        m, p = map(int, data[index].split())\n        voters.append((m, p))\n        index += 1\n    test_cases.append((n, voters))\n\nresults = minimum_coins_to_win(t, test_cases)\n\n# Printing output\nfor result in results:\n    print(result)\n```",
    "8": "```python\ndef max_chess_score(test_cases):\n    results = []\n    \n    for n, k, s in test_cases:\n        # Calculate the initial score\n        score = 0\n        wins = []\n        \n        for i in range(n):\n            if s[i] == 'W':\n                if i == 0 or s[i - 1] == 'L':\n                    score += 1\n                else:\n                    score += 2\n                wins.append(i)\n        \n        # If we can change outcomes\n        if k > 0:\n            # Count the number of segments of losses\n            segments = []\n            last_lost = -1\n            \n            for i in range(n):\n                if s[i] == 'L':\n                    if last_lost == -1 or last_lost + 1 != i:\n                        segments.append(1)\n                    else:\n                        segments[-1] += 1\n                    last_lost = i\n            \n            # Count how many segments of losses we have\n            num_segments = len(segments)\n            \n            # We can change at most k losses\n            # Each segment can turn into wins if we have enough k\n            total_wins = len(wins) + min(num_segments, k)\n            additional_points = 0\n            \n            # Calculate the maximum score possible\n            if total_wins > 0:\n                additional_points = 1 + 2 * (total_wins - 1)\n            \n            score = max(score, additional_points)\n        \n        results.append(score)\n    \n    return results\n\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\n\nfor i in range(t):\n    n, k = map(int, data[i * 2 + 1].split())\n    s = data[i * 2 + 2]\n    test_cases.append((n, k, s))\n\n# Get results\nresults = max_chess_score(test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "9": "```python\ndef alice_score(s):\n    # Count the number of '1's in each segment of consecutive '1's\n    segments = []\n    count = 0\n    for char in s:\n        if char == '1':\n            count += 1\n        else:\n            if count > 0:\n                segments.append(count)\n            count = 0\n    if count > 0:\n        segments.append(count)\n    \n    # Alice's score is the sum of the '1's at even indices (0-based)\n    alice_score = sum(segments[i] for i in range(0, len(segments), 2))\n    return alice_score\n\nT = int(input())\nfor _ in range(T):\n    s = input().strip()\n    print(alice_score(s))\n```",
    "10": "```python\ndef find_max_subsequence(test_cases):\n    results = []\n    \n    for n, p in test_cases:\n        # Initialize the subsequence\n        subsequence = []\n        \n        # Start with the first element\n        subsequence.append(p[0])\n        \n        # Iterate through the permutation\n        for i in range(1, n):\n            if abs(p[i] - subsequence[-1]) > 1:\n                subsequence.append(p[i])\n        \n        # Check if we need at least two elements\n        if len(subsequence) < 2:\n            subsequence.append(p[1])  # Guarantee at least two elements\n        \n        results.append((len(subsequence), subsequence))\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\n\nfor _ in range(t):\n    n = int(input())\n    p = list(map(int, input().split()))\n    test_cases.append((n, p))\n\n# Find results\nresults = find_max_subsequence(test_cases)\n\n# Output results\nfor k, subseq in results:\n    print(k)\n    print(\" \".join(map(str, subseq)))\n```",
    "11": "```python\ndef calculate_area(s):\n    # Count movements in each direction\n    up = s.count('W')\n    down = s.count('S')\n    left = s.count('A')\n    right = s.count('D')\n    \n    # Calculate the width and height of the grid based on movements\n    width = right - left + 1\n    height = down - up + 1\n    \n    return width * height\n\ndef min_grid_area_with_insert(s):\n    # Initial area without any insert\n    initial_area = calculate_area(s)\n    \n    # Check possible areas with one insert\n    possible_areas = [initial_area]\n    \n    for command in 'WASD':\n        # Insert the command and calculate new area\n        new_s = s + command  # can also be inserted at any position, but end is enough\n        new_area = calculate_area(new_s)\n        possible_areas.append(new_area)\n    \n    return min(possible_areas)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    T = int(data[0])\n    results = []\n    \n    for i in range(1, T + 1):\n        s = data[i]\n        min_area = min_grid_area_with_insert(s)\n        results.append(min_area)\n    \n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "12": "```python\ndef can_transform(t, test_cases):\n    results = []\n    for _ in range(t):\n        n = test_cases[_][0]\n        a = test_cases[_][1]\n        b = test_cases[_][2]\n\n        can_increase = can_decrease = False\n\n        for i in range(n):\n            if a[i] == 1:\n                can_increase = True\n            elif a[i] == -1:\n                can_decrease = True\n\n            if can_increase and can_decrease:\n                break\n\n        possible = True\n        for i in range(n):\n            if b[i] > a[i] and not can_increase:\n                possible = False\n                break\n            elif b[i] < a[i] and not can_decrease:\n                possible = False\n                break\n\n        results.append(\"YES\" if possible else \"NO\")\n    \n    return results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\nindex = 1\n\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1].split()))\n    b = list(map(int, data[index + 2].split()))\n    test_cases.append((n, a, b))\n    index += 3\n\n# Getting results\nresults = can_transform(t, test_cases)\n\n# Printing results\nprint(\"\\n\".join(results))\n```",
    "13": "```python\ndef min_days_to_repair(T, test_cases):\n    results = []\n    for n, g, b in test_cases:\n        required_good = (n + 1) // 2  # At least half should be high quality\n        full_cycles = required_good // g\n        remaining_good = required_good % g\n        \n        if remaining_good == 0:\n            total_days = full_cycles * (g + b) - b\n        else:\n            total_days = full_cycles * (g + b) + remaining_good\n            \n        total_days = max(total_days, n)  # Ensure total days is at least n\n        \n        results.append(total_days)\n    \n    return results\n\n# Read input\nT = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(T)]\n\n# Get results\nresults = min_days_to_repair(T, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "14": "```python\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    a1, b1 = map(int, input().split())\n    a2, b2 = map(int, input().split())\n    \n    # Check if we can form a square\n    if (a1 == a2 and b1 + b2 == a1) or (a1 == b2 and b1 + a2 == a1) or (b1 == a2 and a1 + b2 == b1) or (b1 == b2 and a1 + a2 == b1):\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nprint(\"\\n\".join(results))\n```",
    "15": "```python\ndef max_window_area(t, test_cases):\n    results = []\n    for a, b, x, y in test_cases:\n        # Calculate areas of rectangles avoiding the dead pixel\n        area1 = x * b            # Left of the dead pixel\n        area2 = (a - x - 1) * b  # Right of the dead pixel\n        area3 = a * y            # Above the dead pixel\n        area4 = a * (b - y - 1)  # Below the dead pixel\n        \n        # The maximum area possible\n        max_area = max(area1, area2, area3, area4)\n        results.append(max_area)\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = max_window_area(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "16": "```python\ndef max_score(tc, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, (C, T), problems = case\n        max_possible_score = 0\n        \n        # Iterate over all combinations of problems\n        for mask in range(1 << n):\n            current_time = 0\n            current_score = 0\n            s = 1.0\n            \n            # Count how many problems are selected\n            selected_problems = []\n            for i in range(n):\n                if mask & (1 << i):\n                    selected_problems.append(problems[i])\n                    \n            # Calculate the time for training\n            total_problems = len(selected_problems)\n            if total_problems > 0:\n                # Training time\n                training_time = (T - total_problems * 10) / (C + total_problems * 0.9)\n                if training_time < 0:\n                    continue\n                s += C * training_time\n            \n            # Reset current time for problem solving after training\n            current_time = training_time\n            \n            for a_i, p_i in selected_problems:\n                # Time for watching an episode\n                current_time += 10\n                if current_time > T:\n                    break\n                \n                # Update skill after watching the episode\n                s *= 0.9\n                \n                # Time required to solve the problem\n                time_to_solve = a_i / s\n                current_time += time_to_solve\n                \n                if current_time > T:\n                    break\n                \n                # Add the score of the problem\n                current_score += p_i\n            \n            max_possible_score = max(max_possible_score, current_score)\n        \n        results.append(max_possible_score)\n    \n    return results\n\n\n# Read input and process\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nindex = 0\ntc = int(data[index])\nindex += 1\ntest_cases = []\n\nfor _ in range(tc):\n    n = int(data[index])\n    index += 1\n    C, T = map(float, data[index].split())\n    index += 1\n    problems = []\n    for _ in range(n):\n        a_i, p_i = map(int, data[index].split())\n        problems.append((a_i, p_i))\n        index += 1\n    test_cases.append((n, (C, T), problems))\n\nresults = max_score(tc, test_cases)\nfor result in results:\n    print(result)\n```",
    "17": "```python\ndef count_tuples(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        count = 0\n        \n        # Dictionary to count occurrences of pairs\n        pair_count = {}\n        \n        # Iterate through all possible j, l pairs\n        for j in range(1, n - 1):\n            for l in range(j + 1, n):\n                if a[j] == a[l]:  # Only consider pairs where a[j] == a[l]\n                    # Count how many i's can form a valid tuple with this j, l\n                    # Count how many k's can form a valid tuple with this j, l\n                    # We are looking for i < j and k > j\n                    for i in range(j):\n                        if a[i] == a[j]:  # a[i] must equal a[k]\n                            if (a[i], a[j]) in pair_count:\n                                count += pair_count[(a[i], a[j])]\n                    \n                    # Now we add this pair to the pair_count dictionary\n                    if (a[j], a[l]) not in pair_count:\n                        pair_count[(a[j], a[l])] = 0\n                    pair_count[(a[j], a[l])] += 1\n        \n        results.append(count)\n    \n    return results\n\n\n# Input handling\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Get results and print them\nresults = count_tuples(t, test_cases)\nfor result in results:\n    print(result)\n```",
    "18": "```python\nimport math\n\ndef min_square_side_length(n):\n    # The formula derived for the minimum square side length to embed a 2n-gon\n    return math.sqrt(2) * (math.cos(math.pi / (2 * n)) / math.sin(math.pi / (2 * n)))\n\ndef main():\n    T = int(input())\n    results = []\n    for _ in range(T):\n        n = int(input())\n        side_length = min_square_side_length(n)\n        results.append(f\"{side_length:.9f}\")\n\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "19": "```python\ndef min_subscriptions(t, test_cases):\n    results = []\n    for n, k, d, shows in test_cases:\n        min_subs = float('inf')\n        show_count = {}\n        left = 0\n        \n        for right in range(n):\n            show_count[shows[right]] = show_count.get(shows[right], 0) + 1\n            \n            if right - left + 1 > d:\n                show_count[shows[left]] -= 1\n                if show_count[shows[left]] == 0:\n                    del show_count[shows[left]]\n                left += 1\n            \n            if right - left + 1 == d:\n                min_subs = min(min_subs, len(show_count))\n\n        results.append(min_subs)\n\n    return results\n\n# Input reading\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(t):\n    n, k, d = map(int, data[index].split())\n    shows = list(map(int, data[index + 1].split()))\n    test_cases.append((n, k, d, shows))\n    index += 2\n\n# Get results and print\nresults = min_subscriptions(t, test_cases)\nprint(\"\\n\".join(map(str, results)))\n```",
    "20": "```python\ndef can_satisfy_customers(q, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, customers = case\n        current_time = 0\n        current_temp_range = (m, m)  # Initial temperature range\n        \n        for t_i, l_i, h_i in customers:\n            # Time difference between current time and the customer's time\n            time_diff = t_i - current_time\n            \n            # Update the temperature range based on time passed\n            current_temp_range = (\n                current_temp_range[0] - time_diff,  # Cooling\n                current_temp_range[1] + time_diff   # Heating\n            )\n            \n            # Update the current time\n            current_time = t_i\n            \n            # The new temperature range must intersect with the customer's preferred range\n            new_range_start = max(current_temp_range[0], l_i)\n            new_range_end = min(current_temp_range[1], h_i)\n            \n            if new_range_start > new_range_end:  # No intersection\n                results.append(\"NO\")\n                break\n        else:\n            results.append(\"YES\")\n    \n    return results\n\n# Input processing\nq = int(input())\ntest_cases = []\n\nfor _ in range(q):\n    n, m = map(int, input().split())\n    customers = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, m, customers))\n\n# Get the results\nresults = can_satisfy_customers(q, test_cases)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "21": "```python\ndef find_k(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, S = case\n        S_set = set(S)\n        found_k = False\n        min_k = float('inf')\n\n        for k in range(1, 1024):\n            transformed_set = {s ^ k for s in S}\n            if transformed_set == S_set:\n                found_k = True\n                min_k = min(min_k, k)\n\n        results.append(min_k if found_k else -1)\n\n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    S = list(map(int, input().split()))\n    test_cases.append((n, S))\n\n# Get results\nresults = find_k(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "22": "```python\ndef min_digit(x):\n    return min(int(d) for d in str(x))\n\ndef max_digit(x):\n    return max(int(d) for d in str(x))\n\ndef calculate_a_k(a1, k):\n    for _ in range(k):\n        a1 += min_digit(a1) * max_digit(a1)\n    return a1\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    a1, k = map(int, input().split())\n    results.append(calculate_a_k(a1, k))\n\nprint(\"\\n\".join(map(str, results)))\n```",
    "23": "```python\ndef minimum_coins_to_win(test_cases):\n    results = []\n    \n    for voters in test_cases:\n        n = len(voters)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        \n        for m, p in voters:\n            for j in range(n, m - 1, -1):\n                dp[j] = min(dp[j], dp[j - m] + p)\n        \n        answer = min(dp[j] for j in range(n + 1))\n        results.append(answer)\n    \n    return results\n\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    voters = [tuple(map(int, input().split())) for __ in range(n)]\n    test_cases.append(voters)\n\nresults = minimum_coins_to_win(test_cases)\nfor result in results:\n    print(result)\n```",
    "24": "```python\nimport math\n\ndef find_a_b(d):\n    if d < 2:\n        if d == 0:\n            return \"Y 0.000000000 0.000000000\"\n        elif d == 1:\n            return \"N\"\n    else:\n        # Using the quadratic formula solution for x^2 - dx + d = 0\n        discriminant = d ** 2 - 4 * d\n        if discriminant < 0:\n            return \"N\"\n        else:\n            sqrt_discriminant = math.sqrt(discriminant)\n            a = (d + sqrt_discriminant) / 2\n            b = (d - sqrt_discriminant) / 2\n            return f\"Y {a:.9f} {b:.9f}\"\n\nt = int(input())\nfor _ in range(t):\n    d = int(input())\n    print(find_a_b(d))\n```",
    "25": "```python\ndef solve():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        triangles = []\n        adjacency = defaultdict(int)\n        \n        for i in range(n - 2):\n            a, b, c = map(int, data[index].split())\n            triangles.append((a, b, c))\n            adjacency[a] += 1\n            adjacency[b] += 1\n            adjacency[c] += 1\n            index += 1\n        \n        # Find the vertex that appears the most\n        max_vertex = max(adjacency, key=adjacency.get)\n        \n        # Now we find the order of vertices\n        p = []\n        used = set()\n        current = max_vertex\n        \n        # Start the order with the max vertex\n        p.append(current)\n        used.add(current)\n        \n        # Next we need to find neighbors in the triangles\n        for _ in range(n - 1):\n            for a, b, c in triangles:\n                if current in (a, b, c):\n                    for neighbor in (a, b, c):\n                        if neighbor != current and neighbor not in used:\n                            p.append(neighbor)\n                            used.add(neighbor)\n                            current = neighbor\n                            break\n                    else:\n                        continue\n                    break\n        \n        # The order of cutting\n        q = []\n        for i in range(n - 2):\n            q.append(i + 1)\n        \n        results.append(' '.join(map(str, p)))\n        results.append(' '.join(map(str, q)))\n    \n    print('\\n'.join(results))\n\n# Call solve() when the script runs\nif __name__ == \"__main__\":\n    solve()\n```",
    "26": "```python\ndef can_solve_puzzle(n, m):\n    return (n % 2 == 0 and m % 2 == 0) or (n % 2 == 1 and m % 2 == 1)\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    if can_solve_puzzle(n, m):\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nprint(\"\\n\".join(results))\n```",
    "27": "```python\ndef min_moves_to_odd(t, test_cases):\n    results = []\n    \n    for n, a in test_cases:\n        seen = set()\n        moves = 0\n        \n        for number in a:\n            while number % 2 == 0:\n                if number not in seen:\n                    seen.add(number)\n                    moves += 1\n                number //= 2\n        \n        results.append(moves)\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\n\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Processing and output\nresults = min_moves_to_odd(t, test_cases)\nfor result in results:\n    print(result)\n```",
    "28": "```python\ndef can_form_abacaba(s, n):\n    target = \"abacaba\"\n    occurrences = []\n    \n    # Check for potential placements of \"abacaba\"\n    for i in range(n - 6):\n        substring = s[i:i + 7]\n        if all(ss == tt or ss == '?' for ss, tt in zip(substring, target)):\n            occurrences.append(i)\n    \n    # If there are multiple occurrences, we can't have exactly one\n    if len(occurrences) > 1:\n        return \"No\"\n    \n    # If no occurrences, we can replace a '?' with \"abacaba\"\n    if len(occurrences) == 0:\n        # Try to place \"abacaba\" at every possible position\n        for i in range(n - 6):\n            new_s = list(s)\n            for j in range(7):\n                new_s[i + j] = target[j]\n            # Check if this creates exactly one occurrence\n            if new_s.count('a') >= 3 and new_s.count('b') >= 1 and new_s.count('c') >= 1:\n                new_s = ''.join(new_s)\n                # Fill remaining '?' with 'z' or any other letter\n                new_s = new_s.replace('?', 'z')\n                if new_s.count('abacaba') == 1:\n                    return f\"Yes\\n{new_s}\"\n        return \"No\"\n\n    # If exactly one occurrence is found, we need to ensure the rest are handled\n    index = occurrences[0]\n    new_s = list(s)\n    for j in range(7):\n        new_s[index + j] = target[j]\n    new_s = ''.join(new_s)\n    \n    # Replace remaining '?' with 'z' or any other letter\n    new_s = new_s.replace('?', 'z')\n    \n    # Verify that \"abacaba\" occurs exactly once\n    if new_s.count('abacaba') == 1:\n        return f\"Yes\\n{new_s}\"\n    else:\n        return \"No\"\n\nT = int(input())\nresults = []\nfor _ in range(T):\n    n = int(input().strip())\n    s = input().strip()\n    results.append(can_form_abacaba(s, n))\n\nprint(\"\\n\".join(results))\n```",
    "29": "```python\ndef solve():\n    import sys\n    from collections import defaultdict\n    \n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index+n]))\n        index += n\n        \n        # This will hold the last occurrence index of each number\n        last_occurrence = defaultdict(lambda: -1)\n        \n        # This will hold the minimum values for each k\n        k_amazing = [-1] * n\n        \n        # We will iterate through the array to determine the k-amazing numbers\n        for i in range(n):\n            num = a[i]\n            if last_occurrence[num] != -1:\n                # Update the distance between the current and last occurrence\n                distance = i - last_occurrence[num]\n                # We update the k-amazing number only for valid distances\n                if distance <= n:\n                    # The minimum number that can be the k-amazing number\n                    k_amazing[distance-1] = max(k_amazing[distance-1], num)\n            # Update the last occurrence of the current number\n            last_occurrence[num] = i\n        \n        # Handle the numbers in reverse to ensure we propagate the minimum down\n        for k in range(n-2, -1, -1):\n            k_amazing[k] = max(k_amazing[k], k_amazing[k+1])\n        \n        # Collect results\n        for k in range(n):\n            k_amazing[k] = k_amazing[k] if k_amazing[k] != -1 else -1\n        \n        results.append(\" \".join(map(str, k_amazing)))\n    \n    print(\"\\n\".join(results))\n\n# Uncomment the line below to run the solve function\n# solve()\n```"
}