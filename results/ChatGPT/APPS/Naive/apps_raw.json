{
    "7": "```python\ndef find_empty_day(n, m):\n    day = 1\n    grains = n\n\n    while grains > 0:\n        # Add grains to the barn\n        grains += m\n        # Ensure barn does not exceed capacity\n        if grains > n:\n            grains = n\n        \n        # Sparrows eat grains\n        grains -= day\n        day += 1\n\n    return day - 1\n\n# Read input\nn, m = map(int, input().split())\n# Output the day when the barn becomes empty\nprint(find_empty_day(n, m))\n```",
    "2": "```python\ndef next_lucky_year(current_year):\n    # Increment the year until we find a lucky year\n    while True:\n        current_year += 1\n        # Convert the year to string and count non-zero digits\n        if sum(1 for digit in str(current_year) if digit != '0') <= 1:\n            return current_year - (current_year - 1)\n\n# Read input\nn = int(input().strip())\n# Calculate and print the result\nprint(next_lucky_year(n))\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    # Function to calculate painted sections with hired painters\n    def painted_length(active_painters):\n        painted = [0] * (n + 1)\n        for l, r in active_painters:\n            for i in range(l, r + 1):\n                painted[i] = 1\n        return sum(painted)\n\n    max_sections = 0\n\n    # Try excluding each pair of painters\n    for i in range(q):\n        for j in range(i + 1, q):\n            active_painters = [painters[k] for k in range(q) if k != i and k != j]\n            max_sections = max(max_sections, painted_length(active_painters))\n\n    return max_sections\n\n# Input reading\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Calculate and print the maximum number of painted sections\nprint(max_painted_sections(n, q, painters))\n```",
    "5": "```python\ndef min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0  # No tabs need to be closed\n    \n    seconds = 0\n    \n    # Close tabs to the left of l\n    if pos < l:\n        # Move cursor to l\n        seconds += (l - pos) + 1  # Move to l and close\n    elif pos > r:\n        # Move cursor to r\n        seconds += (pos - r) + 1  # Move to r and close\n    else:\n        # Cursor is between l and r\n        if l > 1:\n            seconds += (pos - l) + 1  # Move to l and close\n        seconds += 1  # Close all tabs to the right of r\n        if r < n:\n            seconds += (r - pos) + 1  # Move to r\n    \n    return seconds\n\n# Read input\nn, pos, l, r = map(int, input().split())\nprint(min_seconds_to_close_tabs(n, pos, l, r))\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    \n    for query in queries:\n        n, x = query[0], query[1]\n        blows = query[2]\n        \n        # Find the best blow\n        best_d = 0\n        best_h = 0\n        \n        for d, h in blows:\n            if d > best_d:\n                best_d = d\n                best_h = h\n            elif d == best_d and h < best_h:\n                best_h = h\n        \n        if best_d == 0:\n            results.append(-1)\n            continue\n        \n        blows_needed = 0\n        \n        while x > 0:\n            blows_needed += 1\n            if best_d >= x:\n                x = 0\n            else:\n                x = x - best_d + best_h\n        \n            if x < 0:\n                x = 0\n        \n        results.append(blows_needed)\n    \n    return results\n\n# Reading input\nt = int(input())\nqueries = []\n\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\n# Get results\nresults = min_blows_to_defeat_zmei(t, queries)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "4": "```python\ndef is_lucky_time(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef time_minus_x_minutes(hh, mm, x):\n    mm -= x\n    if mm < 0:\n        mm += 60\n        hh -= 1\n    if hh < 0:\n        hh += 24\n    return hh, mm\n\ndef find_lucky_snooze_count(x, hh, mm):\n    count = 0\n    while not is_lucky_time(hh, mm):\n        count += 1\n        hh, mm = time_minus_x_minutes(hh, mm, x)\n    return count\n\n# Input reading\nx = int(input().strip())\nhh, mm = map(int, input().strip().split())\n\n# Calculate and print the result\nprint(find_lucky_snooze_count(x, hh, mm))\n```",
    "10": "```python\ndef calculate_days_off(n):\n    # Each week consists of 5 work days and 2 days off\n    days_in_week = 7\n    work_days = 5\n    off_days = 2\n    \n    # Calculate total complete weeks in n days\n    complete_weeks = n // days_in_week\n    remaining_days = n % days_in_week\n    \n    # Maximum days off is determined by complete weeks and any remaining days\n    max_days_off = complete_weeks * off_days + min(remaining_days, off_days)\n    \n    # Minimum days off occurs when we consider how the year starts\n    min_days_off = 0 if n <= work_days else 0 if remaining_days <= work_days else off_days\n\n    print(min_days_off, max_days_off)\n\n# Read input\nn = int(input().strip())\ncalculate_days_off(n)\n```",
    "1": "```python\ndef max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n    \n    max_sum = 0\n    result = x\n\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n\n        # Create a new number by reducing the current digit and setting all following digits to '9'\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        new_number = int(new_number)\n\n        if new_number > 0 and new_number <= x:\n            digit_sum = sum(int(d) for d in str(new_number))\n            if (digit_sum > max_sum) or (digit_sum == max_sum and new_number > result):\n                max_sum = digit_sum\n                result = new_number\n\n    # Check the original number itself\n    original_sum = sum(int(d) for d in str_x)\n    if original_sum > max_sum or (original_sum == max_sum and x > result):\n        result = x\n\n    return result\n\nx = int(input())\nprint(max_digit_sum(x))\n```",
    "0": "```python\ndef max_length_acordion(s: str) -> int:\n    n = len(s)\n    \n    # Initialize indices for the first opening bracket and the last closing bracket\n    first_open = -1\n    last_close = -1\n    \n    # Find the first '[' and the last ']'\n    for i in range(n):\n        if s[i] == '[' and first_open == -1:\n            first_open = i\n        if s[i] == ']' and first_open != -1:\n            last_close = i\n    \n    # If we haven't found both brackets, return -1\n    if first_open == -1 or last_close == -1 or last_close <= first_open:\n        return -1\n    \n    # Now we need to find the colons and vertical lines\n    first_colon = -1\n    second_colon = -1\n    vertical_count = 0\n    \n    # Iterate between the first '[' and last ']' to find colons and vertical lines\n    for i in range(first_open + 1, last_close):\n        if s[i] == ':':\n            if first_colon == -1:\n                first_colon = i\n            elif second_colon == -1:\n                second_colon = i\n                break  # We found both colons, no need to continue\n    \n        if s[i] == '|':\n            vertical_count += 1\n    \n    # If we found at least one colon and both colons are in the right order\n    if first_colon != -1 and (second_colon == -1 or second_colon > first_colon):\n        # Calculate the length of the accordion\n        accordion_length = (last_close - first_open + 1) + vertical_count\n        return accordion_length\n    else:\n        return -1\n\n# Read input\ns = input().strip()\n# Output the result\nprint(max_length_acordion(s))\n```",
    "8": "```python\ndef min_tiles_to_draw(tiles):\n    suits = {'m': [], 'p': [], 's': []}\n    \n    for tile in tiles:\n        number = int(tile[0])\n        suit = tile[1]\n        suits[suit].append(number)\n    \n    # Check for koutsu (triplet)\n    for suit in suits:\n        if suits[suit].count(suits[suit][0]) == 3:\n            return 0\n    \n    # Check for shuntsu (sequence)\n    for suit in suits:\n        suit_numbers = sorted(suits[suit])\n        if len(suit_numbers) >= 3:\n            for i in range(len(suit_numbers) - 2):\n                if suit_numbers[i + 1] == suit_numbers[i] + 1 and suit_numbers[i + 2] == suit_numbers[i] + 2:\n                    return 0\n\n    # Check for needed draws to form a shuntsu\n    for suit in suits:\n        if len(suits[suit]) == 2:\n            missing_tiles = set([suits[suit][0] - 1, suits[suit][0], suits[suit][0] + 1,\n                                 suits[suit][1] - 1, suits[suit][1], suits[suit][1] + 1])\n            missing_tiles.discard(suits[suit][0])\n            missing_tiles.discard(suits[suit][1])\n            if any(1 <= tile <= 9 for tile in missing_tiles):\n                return 1\n    \n    # If we only have one tile of one suit, we need two draws to form a shuntsu\n    for suit in suits:\n        if len(suits[suit]) == 1:\n            return 2\n    \n    return 3  # If we have no matching tiles at all, we need at least 3 draws\n\n# Read input\ntiles = input().strip().split()\nprint(min_tiles_to_draw(tiles))\n```",
    "17": "```python\ndef mexican_wave(n, k, t):\n    if t <= k:\n        return t\n    elif t <= n:\n        return k\n    else:\n        return n + k - t\n\n# Input reading\nn, k, t = map(int, input().strip().split())\nprint(mexican_wave(n, k, t))\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    # Count how many tiles can be painted Red\n    count_red = n // a\n    # Count how many tiles can be painted Blue\n    count_blue = n // b\n    # Count how many tiles can be painted both Red and Blue\n    count_both = n // (a * b // gcd(a, b))\n\n    # Calculate total chocolates if we prioritize Red or Blue\n    chocolates_red_priority = (count_red - count_both) * p + (count_blue * q)\n    chocolates_blue_priority = (count_blue - count_both) * q + (count_red * p)\n\n    # Return the maximum of both strategies\n    return max(chocolates_red_priority, chocolates_blue_priority)\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n# Read input values\nn, a, b, p, q = map(int, input().split())\n# Print the maximum number of chocolates\nprint(max_chocolates(n, a, b, p, q))\n```",
    "15": "```python\ndef is_favorite_in_sequence(a, b, c):\n    if c == 0:\n        return a == b\n    elif (b - a) % c == 0 and (b - a) // c >= 0:\n        return True\n    return False\n\n# Read input values\na, b, c = map(int, input().split())\n\n# Check if b is in the sequence and print the result\nif is_favorite_in_sequence(a, b, c):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "16": "```python\ndef can_form_regular_bracket_sequence(cnt1, cnt2, cnt3, cnt4):\n    # Calculate the balance of opening and closing brackets\n    open_needed = cnt1 + cnt2  # Total open brackets available\n    close_needed = cnt2 + cnt4  # Total close brackets available\n\n    # The number of opening brackets must be equal to the number of closing brackets\n    if open_needed != close_needed:\n        return 0\n\n    # The number of extra opening brackets must not exceed the total closing brackets available at any point\n    # This ensures that there are enough closing brackets for every opening bracket\n    if cnt1 > cnt4 + cnt2:\n        return 0\n\n    return 1\n\n# Read input\ncnt1 = int(input().strip())\ncnt2 = int(input().strip())\ncnt3 = int(input().strip())\ncnt4 = int(input().strip())\n\n# Output the result\nprint(can_form_regular_bracket_sequence(cnt1, cnt2, cnt3, cnt4))\n```",
    "14": "```python\ndef is_stack_sortable(p):\n    stack = []\n    b = []\n    for num in p:\n        while stack and (not b or stack[-1] <= b[-1]):\n            b.append(stack.pop())\n        stack.append(num)\n    while stack:\n        b.append(stack.pop())\n    return b == sorted(b)\n\ndef lexicographically_maximal_permutation(n, k, p):\n    used = set(p)\n    remaining = [i for i in range(1, n + 1) if i not in used]\n    remaining.sort(reverse=True)\n\n    result = p[:]  # Start with the given part of the permutation\n    stack = []\n    \n    for num in p:\n        while remaining and (not stack or stack[-1] <= num):\n            stack.append(remaining.pop())\n        stack.append(num)\n    \n    while stack:\n        result.append(stack.pop())\n    \n    if is_stack_sortable(result):\n        return result\n    return -1\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Generate and print the result\nresult = lexicographically_maximal_permutation(n, k, p)\nif result == -1:\n    print(result)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "18": "```python\ndef lexicographically_minimal(s):\n    # Initialize strings t and u\n    t = []\n    u = []\n    \n    # Process characters in the input string\n    for char in s:\n        t.append(char)\n        # Attempt to pop from t to u if possible\n        while t and (not u or t[-1] <= u[-1]):\n            u.append(t.pop())\n    \n    # If there are still characters in t, pop them to u\n    while t:\n        u.append(t.pop())\n    \n    # Join the list u into a string and return\n    return ''.join(u)\n\n# Read input\ns = input().strip()\n# Get the result and print it\nresult = lexicographically_minimal(s)\nprint(result)\n```",
    "19": "```python\ndef is_records_correct(test_cases):\n    results = []\n    \n    for case in test_cases:\n        n = case[0]\n        records = case[1]\n        \n        valid = True\n        prev_p, prev_c = 0, 0\n        \n        for i in range(n):\n            p, c = records[i]\n            \n            if p < prev_p or c < prev_c or c > p:\n                valid = False\n                break\n            \n            if i > 0:\n                if p - prev_p < c - prev_c:\n                    valid = False\n                    break\n            \n            prev_p, prev_c = p, c\n        \n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\n# Input reading\nT = int(input())\ntest_cases = []\n\nfor _ in range(T):\n    n = int(input())\n    records = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, records))\n\n# Getting results\nresults = is_records_correct(test_cases)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    # Calculate the lengths of golden segments\n    segments = []\n    current_length = 0\n    \n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n            \n    if current_length > 0:\n        segments.append(current_length)\n    \n    # If there are no golden trophies\n    if not segments:\n        return 0\n    \n    # Find the maximum length without any swap\n    max_length = max(segments)\n    \n    # If there's only one segment, we cannot swap to increase the length\n    if len(segments) == 1:\n        return max_length\n    \n    # Calculate the maximum possible length with one swap\n    max_with_swap = max_length\n    \n    for i in range(len(segments) - 1):\n        # Consider swapping a silver trophy between two golden segments\n        max_with_swap = max(max_with_swap, segments[i] + segments[i + 1])\n    \n    return min(max_with_swap + 1, n)  # We cannot exceed n\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\n\n# Output the result\nprint(max_beauty_after_swap(n, trophies))\n```",
    "13": "```python\nfrom collections import defaultdict, deque\nimport sys\n\ndef topological_sort(n, dependencies):\n    in_degree = [0] * (n + 1)\n    graph = defaultdict(list)\n\n    # Build the graph and in-degree count\n    for course, deps in dependencies.items():\n        for dep in deps:\n            graph[dep].append(course)\n            in_degree[course] += 1\n\n    # Queue for courses with no prerequisites\n    zero_in_degree = deque()\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            zero_in_degree.append(i)\n\n    order = []\n    while zero_in_degree:\n        course = zero_in_degree.popleft()\n        order.append(course)\n        for next_course in graph[course]:\n            in_degree[next_course] -= 1\n            if in_degree[next_course] == 0:\n                zero_in_degree.append(next_course)\n\n    return order\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, k = map(int, data[0].split())\n    main_courses = list(map(int, data[1].split()))\n    \n    dependencies = defaultdict(list)\n    for i in range(n):\n        line = list(map(int, data[i + 2].split()))\n        t_i = line[0]\n        dependencies[i + 1] = line[1:t_i + 1]\n\n    # Get the topological order of courses\n    order = topological_sort(n, dependencies)\n\n    # Set for fast lookup of main courses\n    main_set = set(main_courses)\n    passed_courses = set()\n    result_order = []\n\n    # Process courses in topological order\n    for course in order:\n        if course in main_set or any(dep in passed_courses for dep in dependencies[course]):\n            result_order.append(course)\n            passed_courses.add(course)\n\n    if not main_set.issubset(passed_courses):\n        print(-1)\n    else:\n        print(len(result_order))\n        print(\" \".join(map(str, result_order)))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "20": "```python\ndef is_palindrome(time_str):\n    return time_str == time_str[::-1]\n\ndef next_palindrome_time(hh, mm):\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return hh, mm\n\ndef minutes_until_palindrome(hh, mm):\n    start_time = (hh, mm)\n    target_time = next_palindrome_time(hh, mm)\n    \n    start_minutes = start_time[0] * 60 + start_time[1]\n    target_minutes = target_time[0] * 60 + target_time[1]\n    \n    return (target_minutes - start_minutes) % (24 * 60)\n\n# Read input\ninput_time = input().strip()\nhh, mm = map(int, input_time.split(':'))\n\n# Get the result\nresult = minutes_until_palindrome(hh, mm)\nprint(result)\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror_chars = {'A': 'A', 'H': 'H', 'I': 'I', 'M': 'M', 'O': 'O', 'T': 'T', \n                    'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X', 'Y': 'Y', \n                    'b': 'd', 'd': 'b', 'p': 'q', 'q': 'p', 'o': 'o', 'v': 'v', 'w': 'w', 'x': 'x'}\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        left_char = s[i]\n        right_char = s[n - 1 - i]\n        \n        if left_char not in mirror_chars or right_char not in mirror_chars:\n            return \"NIE\"\n        \n        if mirror_chars[left_char] != right_char:\n            return \"NIE\"\n    \n    return \"TAK\"\n\ns = input().strip()\nprint(is_s_palindrome(s))\n```",
    "21": "```python\ndef max_distance_after_swap(n, a):\n    min_index = a.index(1)\n    max_index = a.index(n)\n    \n    # Calculate the current distance\n    current_distance = abs(min_index - max_index)\n    \n    # Calculate potential distances after swaps\n    distance1 = abs(min_index - (n - 1))  # swap min with last element\n    distance2 = abs(max_index - 0)        # swap max with first element\n    distance3 = abs(max_index - (n - 1))  # swap max with last element\n    distance4 = abs(min_index - 0)        # swap min with first element\n    \n    # The maximum distance possible after one swap\n    max_distance = max(current_distance, distance1, distance2, distance3, distance4)\n    \n    return max_distance\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_distance_after_swap(n, a))\n```",
    "9": "```python\ndef find_grandpa_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b):\n    # Function to count sofas based on the position relative to the given sofa\n    def count_sofas(pos, sofas):\n        left, right, top, bottom = 0, 0, 0, 0\n        for i, (x1, y1, x2, y2) in enumerate(sofas):\n            if pos == (x1, y1) or pos == (x2, y2):\n                continue\n            if x1 == x2:  # Same row\n                if y1 < y2:  # Sofa is to the right\n                    if pos[1] < y1:  # Count left\n                        left += 1\n                    elif pos[1] > y2:  # Count right\n                        right += 1\n                else:  # Sofa is to the left\n                    if pos[1] < y2:  # Count left\n                        left += 1\n                    elif pos[1] > y1:  # Count right\n                        right += 1\n            else:  # Different rows\n                if y1 == y2:  # Same column\n                    if x1 < x2:  # Sofa is below\n                        if pos[0] < x1:  # Count top\n                            top += 1\n                        elif pos[0] > x2:  # Count bottom\n                            bottom += 1\n                    else:  # Sofa is above\n                        if pos[0] < x2:  # Count top\n                            top += 1\n                        elif pos[0] > x1:  # Count bottom\n                            bottom += 1\n        return left, right, top, bottom\n\n    for i in range(d):\n        pos1 = (sofas[i][0], sofas[i][1])\n        pos2 = (sofas[i][2], sofas[i][3])\n        count1 = count_sofas(pos1, sofas)\n        count2 = count_sofas(pos2, sofas)\n        \n        if count1 == (cnt_l, cnt_r, cnt_t, cnt_b) or count2 == (cnt_l, cnt_r, cnt_t, cnt_b):\n            return i + 1  # Return the 1-based index\n    \n    return -1  # No matching sofa found\n\n# Input reading\nd = int(input())\nn, m = map(int, input().split())\nsofas = [tuple(map(int, input().split())) for _ in range(d)]\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\n# Function call and output the result\nresult = find_grandpa_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b)\nprint(result)\n```",
    "27": "```python\ndef min_operations_to_type_string(n, s):\n    # Initialize the minimum operations to n (typing all characters one by one)\n    min_operations = n\n    \n    # Iterate to find the longest prefix that can be doubled\n    for i in range(1, n):\n        # Check if the prefix can be doubled and still fit within the string\n        if s[:i] == s[i:2*i] and 2*i <= n:\n            # Calculate operations: type prefix + copy + remaining characters\n            operations = i + 1 + (n - 2 * i)\n            min_operations = min(min_operations, operations)\n    \n    return min_operations\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(min_operations_to_type_string(n, s))\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a, b):\n    from itertools import permutations\n\n    # Convert a to a string to work with its digits\n    a_str = str(a)\n    \n    # Generate all unique permutations of the digits of a\n    perm_set = set(permutations(a_str))\n    \n    # Filter permutations to find valid candidates not exceeding b\n    valid_candidates = []\n    for perm in perm_set:\n        # Join the tuple of characters back into a string and convert to int\n        num = int(''.join(perm))\n        if num <= b and str(num)[0] != '0' and len(str(num)) == len(a_str):\n            valid_candidates.append(num)\n    \n    # Return the maximum value found\n    return max(valid_candidates)\n\n# Input reading\na = int(input().strip())\nb = int(input().strip())\n\n# Output the result\nprint(max_permutation_not_exceeding(a, b))\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    # Check for impossible cases\n    if k > n * n or (n % 2 == 0 and k % 2 != 0) or (n % 2 == 1 and k > n * n - (n // 2)):\n        return -1\n\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Fill the matrix\n    for i in range(n):\n        if k <= 0:\n            break\n        # Place a 1 in the diagonal\n        if k > 0:\n            matrix[i][i] = 1\n            k -= 1\n        \n        # Fill the symmetric pairs\n        for j in range(i + 1, n):\n            if k >= 2:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n\n    # If we still have ones left, it means we couldn't place them appropriately\n    if k > 0:\n        return -1\n\n    return matrix\n\n# Read input\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\n# Output result\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # Since GCD(x, m) = 1, the movements of the x-mouse will cover all rooms\n    # except the one where it starts, and it will cycle through all rooms.\n    # The minimum number of traps needed is m - 1.\n    \n    return m - 1\n\n# Read input\nm, x = map(int, input().split())\n# Print the result\nprint(minimum_traps(m, x))\n```",
    "28": "```python\ndef rename_files(n, files):\n    examples = []\n    regulars = []\n    \n    # Separate examples and regular tests\n    for name, typ in files:\n        if typ == '1':\n            examples.append(name)\n        else:\n            regulars.append(name)\n\n    moves = []\n    # Move examples to their new names\n    for i in range(len(examples)):\n        moves.append(f\"move {examples[i]} {i + 1}\")\n    \n    # Move regular tests to their new names\n    for i in range(len(regulars)):\n        moves.append(f\"move {regulars[i]} {len(examples) + i + 1}\")\n\n    # Output the result\n    print(len(moves))\n    for move in moves:\n        print(move)\n\n# Read input\nn = int(input().strip())\nfiles = [input().strip().split() for _ in range(n)]\n\nrename_files(n, files)\n```",
    "33": "```python\ndef count_common_terms(a1, b1, a2, b2, L, R):\n    def get_terms(a, b, start, end):\n        terms = set()\n        k = 0\n        while True:\n            term = a * k + b\n            if term > end:\n                break\n            if term >= start:\n                terms.add(term)\n            k += 1\n        return terms\n\n    terms1 = get_terms(a1, b1, L, R)\n    terms2 = get_terms(a2, b2, L, R)\n\n    common_terms = terms1.intersection(terms2)\n    return len(common_terms)\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n# Calculate and print the result\nprint(count_common_terms(a1, b1, a2, b2, L, R))\n```",
    "31": "```python\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef birthday_paradox(n, k):\n    MOD = 1000003\n    days = 1 << n  # 2^n\n\n    if k > days:\n        return 1, 1  # If more people than days, probability is 1\n\n    # Calculate probability of all k people having distinct birthdays\n    numerator = days\n    denominator = days ** k\n\n    for i in range(k):\n        numerator *= (days - i)\n        numerator %= MOD\n\n    # Probability that at least two people share a birthday\n    A = (denominator - numerator) % MOD\n    B = denominator % MOD\n\n    # Reduce A and B by their GCD\n    common_gcd = gcd(A, B)\n    A //= common_gcd\n    B //= common_gcd\n\n    return A % MOD, B % MOD\n\n# Read input\nn, k = map(int, input().split())\nA, B = birthday_paradox(n, k)\nprint(A, B)\n```",
    "24": "```python\ndef can_win_in_one_move(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # vertical, horizontal, diagonal down-right, diagonal down-left\n\n    def check_win(x, y):\n        for dx, dy in directions:\n            count = 1  # Start with the current move\n            # Check in the positive direction\n            nx, ny = x + dx, y + dy\n            while 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n                nx += dx\n                ny += dy\n            # Check in the negative direction\n            nx, ny = x - dx, y - dy\n            while 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n                nx -= dx\n                ny -= dy\n\n            if count >= 5:\n                return True\n        return False\n\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                board[i][j] = 'X'  # Simulate placing a cross\n                if check_win(i, j):\n                    return \"YES\"\n                board[i][j] = '.'  # Undo the move\n    return \"NO\"\n\n# Read input\nboard = [input().strip() for _ in range(10)]\nprint(can_win_in_one_move(board))\n```",
    "29": "```python\ndef min_replacements_to_lucky_ticket(ticket):\n    # Split the ticket into two halves\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n\n    # Calculate the sums of both halves\n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n\n    # Calculate the difference\n    difference = sum_first - sum_second\n    # If the difference is zero, the ticket is already lucky\n    if difference == 0:\n        return 0\n\n    # We need to make the sums equal, work with the absolute value of difference\n    difference = abs(difference)\n\n    # Create lists of potential changes for both halves\n    first_half_changes = sorted([9 - digit for digit in first_half], reverse=True)\n    second_half_changes = sorted([digit for digit in second_half], reverse=True)\n\n    # Combine changes and sort them in descending order\n    changes = sorted(first_half_changes + second_half_changes, reverse=True)\n\n    # Calculate the minimum number of replacements needed\n    replacements = 0\n    for change in changes:\n        difference -= change\n        replacements += 1\n        if difference <= 0:\n            return replacements\n\n    # If we exhaust all changes and still have a difference, it means we need more changes\n    return replacements\n\n# Input\nticket = input().strip()\n\n# Output\nprint(min_replacements_to_lucky_ticket(ticket))\n```",
    "37": "```python\ndef can_break_shield(a, b, c):\n    for x in range(c // a + 1):\n        if (c - a * x) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Input reading\na, b, c = map(int, input().split())\nprint(can_break_shield(a, b, c))\n```",
    "32": "```python\ndef check_journey(n, journey):\n    position = 0  # 0 represents the North Pole, 20000 represents the South Pole\n\n    for t, direction in journey:\n        if position == 0 and direction != \"South\":\n            return \"NO\"\n        if position == 20000 and direction != \"North\":\n            return \"NO\"\n        \n        if direction == \"North\":\n            position -= t\n        elif direction == \"South\":\n            position += t\n        elif direction == \"West\" or direction == \"East\":\n            # Moving West or East does not change the position on the meridian\n            continue\n\n        # Ensure position does not go below 0 or above 20000\n        if position < 0 or position > 20000:\n            return \"NO\"\n\n    # Final check to ensure Limak ends at the North Pole\n    if position != 0:\n        return \"NO\"\n\n    return \"YES\"\n\n\n# Input reading\nn = int(input())\njourney = [tuple(input().split()) for _ in range(n)]\njourney = [(int(t), dir) for t, dir in journey]\n\n# Check the journey and print the result\nresult = check_journey(n, journey)\nprint(result)\n```",
    "26": "```python\nimport sys\n\ndef calculate_expressions(x, y, z):\n    expressions = [\n        (x ** (y ** z), f\"{x}^{y}^{z}\"),\n        (x ** (z ** y), f\"{x}^{z}^{y}\"),\n        ((x ** y) ** z, f\"( {x}^{y} )^{z}\"),\n        ((x ** z) ** y, f\"( {x}^{z} )^{y}\"),\n        (y ** (x ** z), f\"{y}^{x}^{z}\"),\n        (y ** (z ** x), f\"{y}^{z}^{x}\"),\n        ((y ** x) ** z, f\"( {y}^{x} )^{z}\"),\n        ((y ** z) ** x, f\"( {y}^{z} )^{x}\"),\n        (z ** (x ** y), f\"{z}^{x}^{y}\"),\n        (z ** (y ** x), f\"{z}^{y}^{x}\"),\n        ((z ** x) ** y, f\"( {z}^{x} )^{y}\"),\n        ((z ** y) ** x, f\"( {z}^{y} )^{x}\"),\n    ]\n    return expressions\n\ndef find_max_expression(expressions):\n    max_value = float('-inf')\n    index = -1\n    for i, (value, expr) in enumerate(expressions):\n        if value > max_value:\n            max_value = value\n            index = i\n    return index, expressions[index][1]\n\ndef main():\n    # Read input\n    x, y, z = map(float, sys.stdin.readline().strip().split())\n    \n    # Calculate expressions\n    expressions = calculate_expressions(x, y, z)\n    \n    # Find max expression and its index\n    index, max_expr = find_max_expression(expressions)\n    \n    # Print the result\n    print(max_expr)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "40": "```python\ndef determine_round_status(n, ratings):\n    for a, b in ratings:\n        if a != b:\n            return \"rated\"\n    \n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            return \"unrated\"\n    \n    return \"maybe\"\n\n# Input reading\nn = int(input().strip())\nratings = [tuple(map(int, input().strip().split())) for _ in range(n)]\n\n# Determine and print the result\nresult = determine_round_status(n, ratings)\nprint(result)\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    if not is_palindrome(s):\n        return len(s)\n    \n    # Check if all characters are the same\n    if all(c == s[0] for c in s):\n        return 0\n    \n    # If it's a palindrome but not all characters are the same\n    return len(s) - 1\n\n# Input\ns = input().strip()\n# Output\nprint(longest_non_palindrome_substring(s))\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    def can_distribute(x):\n        plates_for_first_cake = (a + x - 1) // x  # ceiling division\n        plates_for_second_cake = (b + x - 1) // x  # ceiling division\n        return plates_for_first_cake + plates_for_second_cake <= n\n\n    left, right = 1, max(a, b)\n    result = 0\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if can_distribute(mid):\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n\n# Input\nn, a, b = map(int, input().split())\n# Output\nprint(max_min_pieces(n, a, b))\n```",
    "35": "```python\ndef is_valid_flag(n, m, field):\n    # Check if the number of rows is divisible by 3 for horizontal stripes\n    if n % 3 == 0:\n        stripe_height = n // 3\n        colors = set()\n        for i in range(3):\n            stripe = field[i * stripe_height:(i + 1) * stripe_height]\n            # Check if all rows in the stripe are the same and collect the color\n            if all(row == stripe[0] for row in stripe):\n                colors.add(stripe[0][0])\n            else:\n                return \"NO\"\n    # Check if the number of columns is divisible by 3 for vertical stripes\n    elif m % 3 == 0:\n        stripe_width = m // 3\n        colors = set()\n        for i in range(3):\n            stripe = [row[i * stripe_width:(i + 1) * stripe_width] for row in field]\n            # Check if all columns in the stripe are the same and collect the color\n            if all(row == stripe[0] for row in stripe):\n                colors.add(stripe[0][0])\n            else:\n                return \"NO\"\n    else:\n        return \"NO\"\n\n    # Validate the number of unique colors used\n    return \"YES\" if len(colors) == 3 else \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Output result\nprint(is_valid_flag(n, m, field))\n```",
    "42": "```python\ndef count_circular_strings(n, s):\n    from itertools import product\n    \n    # Function to check if s is a substring of any cyclic rotation of t\n    def contains_substring(t):\n        doubled_t = t + t\n        return s in doubled_t\n    \n    # Generate all possible binary strings of length n\n    count = 0\n    for t in product('01', repeat=n):\n        t_str = ''.join(t)\n        if contains_substring(t_str):\n            count += 1\n            \n    return count\n\n# Input\nn = int(input().strip())\ns = input().strip()\n\n# Output\nprint(count_circular_strings(n, s))\n```",
    "41": "```python\ndef nearest_zero_distance(n, array):\n    distances = [float('inf')] * n\n    last_zero_index = -1\n\n    # First pass: from left to right\n    for i in range(n):\n        if array[i] == 0:\n            last_zero_index = i\n            distances[i] = 0\n        elif last_zero_index != -1:\n            distances[i] = i - last_zero_index\n\n    # Second pass: from right to left\n    last_zero_index = -1\n    for i in range(n - 1, -1, -1):\n        if array[i] == 0:\n            last_zero_index = i\n        elif last_zero_index != -1:\n            distances[i] = min(distances[i], last_zero_index - i)\n\n    return distances\n\n# Input reading\nn = int(input().strip())\narray = list(map(int, input().strip().split()))\n\n# Get distances to the nearest zero and print them\nresult = nearest_zero_distance(n, array)\nprint(' '.join(map(str, result)))\n```",
    "36": "```python\ndef get_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 0\n\n    # Determine which layer the move n is in\n    while moves_in_layer <= n:\n        layer += 1\n        moves_in_layer = 3 * layer * (layer + 1)  # Total moves in layer\n\n    layer -= 1\n    moves_in_layer = 3 * layer * (layer + 1)  # Moves in the last complete layer\n    position_in_layer = n - moves_in_layer  # Position in the current layer\n\n    # Calculate the coordinates based on the layer and position\n    x, y = layer, 0  # Starting position for the layer\n\n    if position_in_layer < layer:\n        x -= position_in_layer\n    elif position_in_layer < 2 * layer:\n        x -= layer\n        y += position_in_layer - layer\n    else:\n        x += position_in_layer - 2 * layer\n        y += layer\n\n    return (x, y)\n\nn = int(input().strip())\nx, y = get_coordinates(n)\nprint(x, y)\n```",
    "38": "```python\ndef can_coincide_tracks(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between consecutive barriers for both Kefa and Sasha\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Double the kefa_diffs to account for circular nature of the track\n    kefa_diffs_extended = kefa_diffs + kefa_diffs\n    \n    # Check if sasha_diffs can be found as a contiguous subsequence in kefa_diffs_extended\n    for i in range(n):\n        if kefa_diffs_extended[i:i+n] == sasha_diffs:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_coincide_tracks(n, L, kefa_distances, sasha_distances))\n```",
    "48": "```python\ndef kth_largest_in_multiplication_table(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(x // i, m)\n        return count\n\n    left, right = 1, n * m\n    while left < right:\n        mid = (left + right) // 2\n        if count_less_equal(mid) < k:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return left\n\nn, m, k = map(int, input().split())\nprint(kth_largest_in_multiplication_table(n, m, k))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n    \n    # Determine the range where the k-th digit falls\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n    \n    # Find the exact number containing the k-th digit\n    start += (k - 1) // length\n    num_str = str(start)\n    \n    # Find the exact digit\n    digit_index = (k - 1) % length\n    return num_str[digit_index]\n\n# Input\nk = int(input())\n# Output\nprint(find_kth_digit(k))\n```",
    "44": "```python\ndef minimal_time_to_post_office(d, k, a, b, t):\n    # If d is less than or equal to k, Vasiliy can drive the whole distance without any breaks\n    if d <= k:\n        return d * a\n\n    # Calculate the number of full segments he can drive before needing to walk\n    full_segments = d // k\n    remaining_distance = d % k\n\n    # Calculate time for driving full segments with repairs\n    time_driving = full_segments * (k * a + t)  # time driving + repair time for full segments\n    time_driving -= t  # subtract the last repair time since he doesn't need to repair after reaching the destination\n\n    # Calculate time for the remaining distance\n    time_remaining = remaining_distance * a\n\n    # Calculate time if he decides to walk the entire distance\n    time_walking = d * b\n\n    # Return the minimum time between driving with repairs and walking the entire distance\n    return min(time_driving + time_remaining, time_walking)\n\n# Input reading\nd, k, a, b, t = map(int, input().split())\n# Output the result\nprint(minimal_time_to_post_office(d, k, a, b, t))\n```",
    "46": "```python\ndef count_divisible_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n    \n    # Count how many numbers in range 1 to n give each remainder when divided by 5\n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n    \n    # Count how many numbers in range 1 to m give each remainder when divided by 5\n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n    \n    # Calculate pairs where (x + y) % 5 == 0\n    total_pairs = 0\n    for r in range(5):\n        total_pairs += count_x[r] * count_y[(5 - r) % 5]\n    \n    return total_pairs\n\n# Input reading\nn, m = map(int, input().split())\nresult = count_divisible_pairs(n, m)\nprint(result)\n```",
    "47": "```python\ndef max_beauty_with_subarray(n, x, a):\n    def kadane(arr):\n        max_ending_here = max_so_far = 0\n        for num in arr:\n            max_ending_here = max(0, max_ending_here + num)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    base_beauty = kadane(a)\n\n    if x == 0:\n        return base_beauty\n\n    max_beauty_after_modification = base_beauty\n\n    for start in range(n):\n        current_sum = 0\n        for end in range(start, n):\n            current_sum += a[end]\n            modified_sum = current_sum * x\n            new_beauty = kadane(a[:start] + [modified_sum] + a[end+1:])\n            max_beauty_after_modification = max(max_beauty_after_modification, new_beauty)\n\n    return max_beauty_after_modification\n\n# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the maximum beauty\nresult = max_beauty_with_subarray(n, x, a)\n\n# Print the result\nprint(result)\n```",
    "43": "```python\nimport sys\nimport math\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    angles = []\n    \n    for i in range(n):\n        x, y = vectors[i]\n        angle = math.atan2(y, x)\n        angles.append((angle, i + 1))\n\n    # Sort by angles\n    angles.sort()\n\n    # Add the first angle + 2π to handle the wrap-around case\n    angles.append((angles[0][0] + 2 * math.pi, angles[0][1]))\n\n    min_angle = float('inf')\n    min_pair = (0, 0)\n\n    for i in range(n):\n        angle1, index1 = angles[i]\n        angle2, index2 = angles[i + 1]\n        \n        # Calculate the non-oriented angle\n        current_angle = angle2 - angle1\n        if current_angle < min_angle:\n            min_angle = current_angle\n            min_pair = (index1, index2)\n\n    return min_pair\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    vectors = [tuple(map(int, line.split())) for line in data[1:n + 1]]\n    \n    result = find_min_angle_pair(vectors)\n    print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    from itertools import combinations\n    \n    half_m = m // 2\n    total_max_sum = 0\n    \n    for row in matrix:\n        # Calculate all possible sums for choosing 0 to half_m elements\n        possible_sums = set()\n        for r in range(half_m + 1):\n            for combo in combinations(row, r):\n                possible_sums.add(sum(combo))\n        \n        # Filter sums that are divisible by k and find the maximum\n        max_sum_in_row = max((s for s in possible_sums if s % k == 0), default=0)\n        total_max_sum += max_sum_in_row\n    \n    return total_max_sum\n\n# Input reading\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = max_sum_divisible_by_k(n, m, k, matrix)\nprint(result)\n```",
    "51": "```python\nfrom collections import Counter\nfrom math import gcd\n\n# Function to find the divisors of a number\ndef find_divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return divisors\n\n# Read input\nn = int(input())\ndivisors_list = list(map(int, input().split()))\n\n# Count the occurrences of each divisor\ndivisor_count = Counter(divisors_list)\n\n# Find the potential x and y\npotential_x = 1\npotential_y = 1\n\n# Iterate through the divisors and find x and y\nfor d in divisor_count:\n    if divisor_count[d] == 2:\n        # d is a common divisor, multiply it to both x and y\n        potential_x *= d\n        potential_y *= d\n    elif divisor_count[d] == 1:\n        # d is a unique divisor, assign it to x or y\n        if potential_x < potential_y:\n            potential_x *= d\n        else:\n            potential_y *= d\n\n# Output the results\nprint(potential_x, potential_y)\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_chosen = float('-inf')\n    moves = []\n    \n    while left <= right:\n        if a[left] > last_chosen and (a[right] <= last_chosen or a[left] < a[right]):\n            moves.append('L')\n            last_chosen = a[left]\n            left += 1\n        elif a[right] > last_chosen:\n            moves.append('R')\n            last_chosen = a[right]\n            right -= 1\n        else:\n            break\n\n    print(len(moves))\n    print(''.join(moves))\n\n# Input reading\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\nlongest_increasing_sequence(n, a)\n```",
    "54": "```python\ndef minimum_D(n, a):\n    min_a = min(a)\n    max_a = max(a)\n    \n    if min_a == max_a:\n        return 0\n    \n    # The possible values for D that can balance the elements\n    # D should be (max_a - min_a) / 2\n    D = (max_a - min_a) / 2\n    \n    if (max_a - min_a) % 2 != 0:\n        return -1\n    \n    return int(D)\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(minimum_D(n, a))\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef reachable_count(n):\n    visited = set()\n    queue = [n]\n    \n    while queue:\n        current = queue.pop()\n        if current not in visited:\n            visited.add(current)\n            next_value = f(current)\n            if next_value not in visited:\n                queue.append(next_value)\n            # Also add the next number without applying f\n            if current + 1 not in visited:\n                queue.append(current + 1)\n\n    return len(visited)\n\nn = int(input().strip())\nprint(reachable_count(n))\n```",
    "59": "```python\ndef min_operations_to_remainder(n, x, y, number):\n    # The target remainder in the last x digits\n    target = ['0'] * x\n    target[y] = '1'  # Set the y-th position to 1 for 10^y\n    \n    # Get the current last x digits of the number\n    current = list(number[-x:])\n    \n    # Count the number of differences\n    operations = sum(1 for i in range(x) if current[i] != target[i])\n    \n    return operations\n\n# Read input\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# Get the result\nresult = min_operations_to_remainder(n, x, y, number)\n\n# Print the result\nprint(result)\n```",
    "58": "```python\ndef color_array(n, k, a):\n    from collections import defaultdict\n\n    freq = defaultdict(list)\n\n    # Collect indices of each unique element\n    for index, value in enumerate(a):\n        freq[value].append(index)\n\n    # Check if we can color the array\n    if any(len(indices) > k for indices in freq.values()):\n        print(\"NO\")\n        return\n\n    colors = [0] * n\n    current_color = 1\n\n    # Assign colors\n    for indices in freq.values():\n        for index in indices:\n            colors[index] = current_color\n            current_color += 1\n            if current_color > k:\n                current_color = 1\n\n    print(\"YES\")\n    print(\" \".join(map(str, colors)))\n\n# Example usage\nn, k = map(int, input().split())\na = list(map(int, input().split()))\ncolor_array(n, k, a)\n```",
    "55": "```python\ndef is_white_sheet_visible(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n    # Check if the white sheet is fully covered by both black sheets\n    covered_left = max(x1, x3, x5)\n    covered_right = min(x2, x4, x6)\n    covered_bottom = max(y1, y3, y5)\n    covered_top = min(y2, y4, y6)\n    \n    # Check if there is a visible area left\n    if covered_left < covered_right and covered_bottom < covered_top:\n        return \"NO\"\n    else:\n        return \"YES\"\n\n# Input reading\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Output result\nprint(is_white_sheet_visible(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6))\n```",
    "63": "```python\ndef minimum_instability(n, a):\n    a.sort()\n    # Remove first or last element to minimize instability\n    instability1 = a[-1] - a[1]  # Remove the first element\n    instability2 = a[-2] - a[0]  # Remove the last element\n    return min(instability1, instability2)\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(minimum_instability(n, a))\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Minimum sum of the first k positive integers is k * (k + 1) / 2\n    min_sum = k * (k + 1) // 2\n    \n    if n < min_sum:\n        return -1  # Not enough sum to create the sequence\n    \n    # The maximum GCD we can use is n // k\n    max_gcd = n // k\n    \n    # We will create the sequence using the maximum possible GCD\n    # Start with the first k integers multiplied by max_gcd\n    a = [(i + 1) * max_gcd for i in range(k)]\n    \n    # Calculate the sum of this sequence\n    current_sum = sum(a)\n    \n    # Adjust the last element to make sure the sum equals n\n    a[-1] += (n - current_sum)\n    \n    # If the last element makes the sequence not strictly increasing, we need to check\n    if a[-1] <= a[-2]:\n        return -1\n    \n    return a\n\n# Read input\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\n# Print output\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "50": "```python\ndef dfs(node, parent, depth):\n    farthest_node = (depth, node)\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            farthest_node = max(farthest_node, dfs(neighbor, node, depth + 1))\n    return farthest_node\n\ndef find_farthest(node):\n    return dfs(node, -1, 0)\n\ndef main():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    n = int(data[0])\n    global tree\n    tree = defaultdict(list)\n\n    for i in range(1, n):\n        u, v = map(int, data[i].split())\n        tree[u].append(v)\n        tree[v].append(u)\n\n    # Step 1: Find the farthest node from an arbitrary start point (1)\n    _, farthest_from_start = find_farthest(1)\n\n    # Step 2: Find the farthest node from the previously found farthest node\n    _, farthest_from_far = find_farthest(farthest_from_start)\n\n    # Step 3: Find the path from farthest_from_start to farthest_from_far to get the diameter\n    diameter_path = []\n    def find_path(node, parent, target):\n        if node == target:\n            return True\n        for neighbor in tree[node]:\n            if neighbor != parent and find_path(neighbor, node, target):\n                diameter_path.append(neighbor)\n                return True\n        return False\n\n    find_path(farthest_from_start, -1, farthest_from_far)\n    diameter_path.append(farthest_from_start)\n\n    # The diameter path will have all nodes in the longest path in the tree\n    if len(diameter_path) < 3:\n        print(n - 1)\n        print(1, 2, 3)\n        return\n\n    a = diameter_path[0]\n    b = diameter_path[len(diameter_path) - 1]\n\n    # To maximize edges, we can pick two end points of the diameter and a leaf node\n    leaf_node = -1\n    for neighbor in tree[a]:\n        if neighbor != b:\n            leaf_node = neighbor\n            break\n    \n    if leaf_node == -1:\n        for neighbor in tree[b]:\n            if neighbor != a:\n                leaf_node = neighbor\n                break\n\n    print(len(diameter_path) - 1 + len(tree[leaf_node]))\n    print(a, b, leaf_node)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "57": "```python\ndef fill_gift_preferences(n, f):\n    # Prepare lists to track givers and takers\n    givers = set(range(1, n + 1))  # Set of all friends\n    known_gifts = set()  # Friends who have known gift preferences\n\n    # Identify known gifts and available givers\n    for i in range(n):\n        if f[i] != 0:\n            known_gifts.add(f[i])\n            givers.discard(i + 1)  # Remove giver from available set\n    \n    # Available friends who haven't received gifts yet\n    available_givers = list(givers)\n    giftless_friends = [i + 1 for i in range(n) if f[i] == 0]\n\n    # Assign gifts to those who have 0\n    for i in range(len(giftless_friends)):\n        friend = giftless_friends[i]\n        # We need to assign them a gift from available_givers\n        # Ensure not to assign to themselves\n        for j in range(len(available_givers)):\n            if available_givers[j] != friend:\n                f[friend - 1] = available_givers[j]\n                available_givers.pop(j)  # Remove the assigned giver\n                break\n\n    return f\n\n# Input reading\nn = int(input().strip())\nf = list(map(int, input().strip().split()))\n\n# Fill the preferences\nresult = fill_gift_preferences(n, f)\n\n# Output the result\nprint(\" \".join(map(str, result)))\n```",
    "65": "```python\ndef min_moves_to_transform(n, m):\n    if m % n != 0:\n        return -1\n    \n    ratio = m // n\n    moves = 0\n    \n    while ratio > 1:\n        if ratio % 2 == 0:\n            ratio //= 2\n            moves += 1\n        elif ratio % 3 == 0:\n            ratio //= 3\n            moves += 1\n        else:\n            return -1\n            \n    return moves\n\n# Input\nn, m = map(int, input().split())\n# Output\nprint(min_moves_to_transform(n, m))\n```",
    "60": "```python\ndef has_palindromic_subsequence(test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        found = False\n        # Use a dictionary to track the first occurrence of each number\n        first_occurrence = {}\n        \n        for i in range(n):\n            if a[i] in first_occurrence:\n                # If we have seen this number before, we can form a palindrome\n                if i - first_occurrence[a[i]] > 1:\n                    found = True\n                    break\n            else:\n                first_occurrence[a[i]] = i\n        \n        results.append(\"YES\" if found else \"NO\")\n    \n    return results\n\n# Reading input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Get results and print them\nresults = has_palindromic_subsequence(test_cases)\nfor result in results:\n    print(result)\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Find the longest suffix of t that is also a prefix\n    for i in range(n - 1, -1, -1):\n        if t[:i] == t[n - i:]:\n            overlap_length = i\n            break\n    else:\n        overlap_length = 0\n    \n    # Construct the result string\n    result = t + (t[overlap_length:] * (k - 1))\n    return result\n\n# Read input\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the result and print it\nresult = construct_string(n, k, t)\nprint(result)\n```",
    "71": "```python\ndef count_set_bits(n):\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\n\nif __name__ == \"__main__\":\n    a = int(input().strip())\n    print(count_set_bits(a))\n```",
    "67": "```python\ndef find_nice_indices(n, a):\n    total_sum = sum(a)\n    nice_indices = []\n\n    for i in range(n):\n        # Calculate the sum excluding the current element\n        remaining_sum = total_sum - a[i]\n        # Check if the current element equals the remaining sum\n        if remaining_sum % 2 == 0 and (remaining_sum // 2) in (a[:i] + a[i+1:]):\n            nice_indices.append(i + 1)  # Store index in 1-based format\n    \n    return nice_indices\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Find nice indices\nnice_indices = find_nice_indices(n, a)\n\n# Output results\nprint(len(nice_indices))\nif nice_indices:\n    print(\" \".join(map(str, nice_indices)))\n```",
    "61": "```python\ndef max_possible_number(n, a, f):\n    # Convert the input string to a list for easier modification\n    a_list = list(a)\n    \n    # Flag to check if we have started changing digits\n    started_changing = False\n    \n    # Iterate through each digit in the number\n    for i in range(n):\n        current_digit = int(a_list[i])\n        # Check if we should change this digit\n        if f[current_digit - 1] > current_digit:\n            # If we haven't started changing, start now\n            if not started_changing:\n                started_changing = True\n            # Replace the digit with its mapped value\n            a_list[i] = str(f[current_digit - 1])\n        elif f[current_digit - 1] < current_digit and started_changing:\n            # If we started changing and encounter a digit that would decrease the number, stop changing\n            break\n    \n    # Join the list back into a string and return\n    return ''.join(a_list)\n\n# Input reading\nn = int(input().strip())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\n# Get the result and print it\nresult = max_possible_number(n, a, f)\nprint(result)\n```",
    "70": "```python\ndef calculate_midpoint(h1, m1, h2, m2):\n    # Convert start and end times to total minutes\n    start_minutes = h1 * 60 + m1\n    end_minutes = h2 * 60 + m2\n\n    # Calculate the midpoint in total minutes\n    midpoint_minutes = (start_minutes + end_minutes) // 2\n\n    # Convert back to hours and minutes\n    h3 = midpoint_minutes // 60\n    m3 = midpoint_minutes % 60\n\n    # Return formatted output\n    return f\"{h3:02}:{m3:02}\"\n\n# Input reading\nh1, m1 = map(int, input().strip().split(':'))\nh2, m2 = map(int, input().strip().split(':'))\n\n# Calculate and print the midpoint\nprint(calculate_midpoint(h1, m1, h2, m2))\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    # Initialize the days array with zeros (rest days)\n    days = [0] * n\n    # Track the number of preparation days needed for each exam\n    preparation_needed = [0] * m\n    \n    # Fill in the exam days in the schedule\n    for idx, (s, d, c) in enumerate(exams):\n        days[d - 1] = m + 1  # Exam day is marked with m + 1\n        preparation_needed[idx] = c\n    \n    # Prepare for each exam\n    for idx, (s, d, c) in enumerate(exams):\n        count = 0\n        for day in range(s - 1, d - 1):\n            if days[day] == 0 and count < c:  # Only prepare if it's a rest day\n                days[day] = idx + 1  # Mark the day for this exam's preparation\n                count += 1\n        \n        if count < c:  # Not enough days to prepare for this exam\n            return -1\n    \n    return days\n\n# Input reading\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the schedule\nresult = schedule_exams(n, m, exams)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "77": "```python\ndef min_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nn = int(input())\nprint(min_difference(n))\n```",
    "73": "```python\ndef can_complete_wall(n, heights):\n    max_height = max(heights)\n    total_bricks_needed = sum(max_height - h for h in heights)\n    \n    # Check if the heights can be equalized\n    # We can use the formula for the total difference\n    total_diff = 0\n    for i in range(1, n):\n        if heights[i] < heights[i - 1]:\n            total_diff += heights[i - 1] - heights[i]\n\n    # If the total number of bricks needed is even and we can fill the gaps\n    return \"YES\" if total_bricks_needed % 2 == 0 and total_diff == 0 else \"NO\"\n\n# Input reading\nn = int(input().strip())\nheights = list(map(int, input().strip().split()))\n\n# Output the result\nprint(can_complete_wall(n, heights))\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    # Calculate the maximum number of unique subsequences possible\n    unique_chars = set(s)\n    max_unique_subsequences = 0\n    \n    # Count occurrences of each character\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Generate all possible unique subsequences\n    for count in char_count.values():\n        max_unique_subsequences += (1 << count) - 1  # 2^count - 1 unique subsequences\n    \n    # If the maximum unique subsequences is less than k, it's impossible\n    if max_unique_subsequences < k:\n        return -1\n    \n    # Minimum cost to obtain k unique subsequences\n    total_cost = 0\n    subsequence_count = 0\n    \n    # Start with the largest subsequence (which costs 0)\n    # and decrease the length to create new unique subsequences\n    for length in range(n, 0, -1):\n        if subsequence_count >= k:\n            break\n        # Count how many unique subsequences we can obtain of this length\n        current_subseq_count = (1 << length) - 1  # 2^length - 1\n        available = min(current_subseq_count, k - subsequence_count)\n        \n        # Each subsequence of this length costs (n - length)\n        total_cost += (n - length) * available\n        subsequence_count += available\n    \n    return total_cost\n\n# Input Handling\nn, k = map(int, input().split())\ns = input().strip()\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n    \n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Start with vertex 1\n    if len(graph[1]) < D:\n        print(\"NO\")\n        return\n    \n    # We will store the edges of the spanning tree\n    spanning_tree_edges = []\n    visited = [False] * (n + 1)\n    \n    # Start BFS or DFS from vertex 1\n    queue = deque([1])\n    visited[1] = True\n    degree_count = 0\n    \n    # Use a list to track the children of vertex 1\n    children = []\n    \n    while queue:\n        current = queue.popleft()\n        \n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                \n                # If we are adding edges from vertex 1, track them\n                if current == 1 and degree_count < D:\n                    spanning_tree_edges.append((1, neighbor))\n                    children.append(neighbor)\n                    degree_count += 1\n                elif current != 1:\n                    spanning_tree_edges.append((current, neighbor))\n    \n    # If we did not reach the required degree for vertex 1\n    if degree_count < D:\n        print(\"NO\")\n        return\n    \n    # Ensure the spanning tree is valid (n-1 edges)\n    if len(spanning_tree_edges) != n - 1:\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    for u, v in spanning_tree_edges:\n        print(u, v)\n\n# Example usage:\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nfind_spanning_tree(n, m, D, edges)\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from itertools import combinations\n\n    # Generate all unique subsequences\n    unique_subsequences = set()\n    for i in range(n + 1):\n        for combo in combinations(s, i):\n            unique_subsequences.add(''.join(combo))\n    \n    # Sort subsequences by length, then by lexicographical order\n    sorted_subsequences = sorted(unique_subsequences, key=lambda x: (len(x), x))\n\n    # If the number of unique subsequences is less than k, return -1\n    if len(sorted_subsequences) < k:\n        return -1\n\n    # Calculate the total cost for the first k unique subsequences\n    total_cost = 0\n    for i in range(k):\n        total_cost += n - len(sorted_subsequences[i])\n\n    return total_cost\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output result\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Define the weekly food consumption pattern\n    week_pattern = ['fish', 'rabbit', 'chicken', 'fish', 'chicken', 'rabbit', 'fish']\n    \n    # Map the food types to their available rations\n    food_map = {'fish': a, 'rabbit': b, 'chicken': c}\n    \n    max_days = 0\n    \n    # Try starting on each day of the week\n    for start_day in range(7):\n        current_food = food_map.copy()\n        days = 0\n        \n        # Simulate the days\n        for i in range(7):  # A maximum of 7 days in a week\n            day = (start_day + i) % 7\n            food_type = week_pattern[day]\n            \n            if current_food[food_type] > 0:\n                current_food[food_type] -= 1\n                days += 1\n            else:\n                break\n        \n        max_days = max(max_days, days)\n    \n    return max_days\n\n# Input reading\na, b, c = map(int, input().split())\n# Output the maximum number of days\nprint(max_days(a, b, c))\n```",
    "62": "```python\ndef min_operations(t, cases):\n    results = []\n    \n    for a, b, c in cases:\n        # Initialize the minimum operations and best triplet\n        min_ops = float('inf')\n        best_triplet = (0, 0, 0)\n        \n        # Iterate through possible values of A\n        for A in range(1, a + 1):\n            # B must be a multiple of A, so we can find suitable B\n            B = A\n            while B < b or B % A != 0:\n                B += 1\n            \n            # C must be a multiple of B\n            C = B\n            while C < c or C % B != 0:\n                C += 1\n            \n            # Calculate operations needed to reach A, B, C\n            operations = (abs(a - A) + abs(b - B) + abs(c - C))\n            \n            # Update minimum operations and best triplet found\n            if operations < min_ops:\n                min_ops = operations\n                best_triplet = (A, B, C)\n        \n        results.append((min_ops, best_triplet))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    cases = [tuple(map(int, line.split())) for line in data[1:t + 1]]\n    \n    results = min_operations(t, cases)\n    for ops, (A, B, C) in results:\n        print(ops)\n        print(A, B, C)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n: int) -> int:\n    s = str(n)\n    length = len(s)\n    min_moves = float('inf')\n    \n    # We need to find pairs of digits that form 00, 25, 50, or 75\n    targets = ['00', '25', '50', '75']\n    \n    for target in targets:\n        last_digit = target[1]\n        second_last_digit = target[0]\n        \n        # Find the position of the last digit in the target pair\n        last_digit_pos = -1\n        for i in range(length - 1, -1, -1):\n            if s[i] == last_digit:\n                last_digit_pos = i\n                break\n        \n        if last_digit_pos == -1:\n            continue  # Last digit of target not found, skip\n        \n        # Find the position of the second last digit in the target pair\n        second_last_digit_pos = -1\n        for i in range(last_digit_pos - 1, -1, -1):\n            if s[i] == second_last_digit:\n                second_last_digit_pos = i\n                break\n        \n        if second_last_digit_pos == -1:\n            continue  # Second last digit of target not found, skip\n        \n        # Calculate moves needed to bring these digits together\n        moves = (last_digit_pos - second_last_digit_pos) + (length - 1 - last_digit_pos)\n        min_moves = min(min_moves, moves)\n    \n    return min_moves if min_moves != float('inf') else -1\n\n# Input reading\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    # Initialize lists to keep track of the minimum right endpoint and maximum left endpoint\n    max_l = [0] * n\n    min_r = [0] * n\n    \n    # Fill in the max_l and min_r\n    for i in range(n):\n        l, r = segments[i]\n        max_l[i] = l\n        min_r[i] = r\n    \n    # Precompute the maximum left endpoint and minimum right endpoint excluding each segment\n    left_max = [0] * n\n    right_min = [float('inf')] * n\n    \n    # Calculate prefix maximum of left endpoints\n    for i in range(n):\n        left_max[i] = max(max_l[i], left_max[i - 1] if i > 0 else 0)\n    \n    # Calculate suffix maximum of left endpoints\n    for i in range(n - 1, -1, -1):\n        if i < n - 1:\n            left_max[i] = max(left_max[i], left_max[i + 1])\n    \n    # Calculate prefix minimum of right endpoints\n    for i in range(n):\n        right_min[i] = min(min_r[i], right_min[i - 1] if i > 0 else float('inf'))\n    \n    # Calculate suffix minimum of right endpoints\n    for i in range(n - 1, -1, -1):\n        if i < n - 1:\n            right_min[i] = min(right_min[i], right_min[i + 1])\n    \n    max_length = 0\n    \n    # Now calculate the maximum intersection length by removing one segment\n    for i in range(n):\n        l = left_max[i - 1] if i > 0 else 0\n        r = right_min[i + 1] if i < n - 1 else float('inf')\n        if r >= l:\n            max_length = max(max_length, r - l)\n    \n    return max_length\n\n# Read input\nn = int(input().strip())\nsegments = [tuple(map(int, input().strip().split())) for _ in range(n)]\n\n# Calculate and output the result\nprint(max_intersection_length(n, segments))\n```",
    "80": "```python\ndef minimum_colors_to_sort(n, s):\n    from collections import defaultdict\n\n    last_position = {}\n    colors = [0] * n\n    color_count = 0\n\n    # Step 1: Determine the last position of each character\n    for i in range(n):\n        last_position[s[i]] = i\n\n    # Step 2: Assign colors based on the last known position of characters\n    for i in range(n):\n        if i == 0:\n            color_count += 1\n            colors[i] = color_count\n        else:\n            # If the current character is the same as the previous one, keep the same color\n            if s[i] == s[i - 1]:\n                colors[i] = colors[i - 1]\n            else:\n                # If we encounter a new character, we need to check the last position\n                if last_position[s[i - 1]] < i:\n                    color_count += 1\n                colors[i] = color_count\n\n    return color_count, colors\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Get the result\nres, coloring = minimum_colors_to_sort(n, s)\n\n# Output the result\nprint(res)\nprint(' '.join(map(str, coloring)))\n```",
    "82": "```python\ndef max_problems_solved(n, k, difficulties):\n    left = 0\n    right = n - 1\n    solved = 0\n\n    while left <= right:\n        if difficulties[left] <= k:\n            solved += 1\n            left += 1\n        elif difficulties[right] <= k:\n            solved += 1\n            right -= 1\n        else:\n            break\n\n    return solved\n\n# Input reading\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Output the result\nprint(max_problems_solved(n, k, difficulties))\n```",
    "76": "```python\ndef can_construct_symmetric_square(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        # We need to find pairs of tiles that can form symmetric positions\n        possible = False\n        top_right_left_bottom = {}\n        \n        for tile in tiles:\n            a, b = tile[0]\n            c, d = tile[1]\n            # Store the pair (b, c) as a key to check for symmetry\n            top_right_left_bottom[(b, c)] = (a, d)\n        \n        # Now we need to check if we can find a symmetric pair\n        for (b, c), (a, d) in top_right_left_bottom.items():\n            if (c, b) in top_right_left_bottom:\n                possible = True\n                break\n        \n        results.append(\"YES\" if possible else \"NO\")\n\n    return results\n\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        top = tuple(map(int, input().split()))\n        bottom = tuple(map(int, input().split()))\n        tiles.append((top, bottom))\n    test_cases.append((n, m, tiles))\n\n# Get results\nresults = can_construct_symmetric_square(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "81": "```python\ndef can_reorder_strings(n, strings):\n    # Sort strings by their lengths\n    strings.sort(key=len)\n    \n    # Check if each string is a substring of the next one\n    for i in range(n - 1):\n        if strings[i] not in strings[i + 1]:\n            return False, []\n    \n    return True, strings\n\ndef main():\n    n = int(input().strip())\n    strings = [input().strip() for _ in range(n)]\n    \n    possible, reordered_strings = can_reorder_strings(n, strings)\n    \n    if possible:\n        print(\"YES\")\n        for s in reordered_strings:\n            print(s)\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```",
    "85": "```python\ndef find_price(A, B):\n    for price in range(1, 10001):  # assuming a reasonable upper limit for the price\n        tax_8 = price * 0.08\n        tax_10 = price * 0.10\n        if int(tax_8) == A and int(tax_10) == B:\n            return price\n    return -1\n\nif __name__ == \"__main__\":\n    A, B = map(int, input().split())\n    result = find_price(A, B)\n    print(result)\n```",
    "78": "```python\ndef count_regular_bracket_sequences(n, s):\n    MOD = 10**9 + 7\n    m = len(s)\n    \n    # Precompute the dp array for regular bracket sequences\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case: 0 pairs\n    \n    for i in range(n + 1):\n        for j in range(n + 1):\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i][j - 1]) % MOD  # Add a closing bracket\n            if i < n:\n                dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % MOD  # Add an opening bracket\n\n    # Helper function to check if a sequence is valid\n    def is_valid_sequence(seq):\n        balance = 0\n        for char in seq:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check the balance of the substring s\n    balance_s = 0\n    min_balance_s = 0\n    for char in s:\n        if char == '(':\n            balance_s += 1\n        else:\n            balance_s -= 1\n        min_balance_s = min(min_balance_s, balance_s)\n\n    if balance_s < 0 or balance_s > 0 or (n * 2 - m < 0) or (min_balance_s < 0):\n        return 0\n\n    result = 0\n    for i in range(n - (m - 1) // 2):\n        open_needed = (n - (m - 1) // 2) - i\n        close_needed = n - open_needed\n        if open_needed >= 0 and close_needed >= 0:\n            result = (result + dp[open_needed][close_needed]) % MOD\n\n    return result\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Calculate and print result\nprint(count_regular_bracket_sequences(n, s))\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n\n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            length = total_tiles // width\n            \n            for red_width in range(1, int(a**0.5) + 1):\n                if a % red_width == 0:\n                    red_length = a // red_width\n                    if red_width <= width and red_length <= length:\n                        # Check blue tiles can fit in remaining space\n                        if (width - red_width) * length >= b:\n                            min_perimeter = min(min_perimeter, 2 * (width + length))\n                            \n            for blue_width in range(1, int(b**0.5) + 1):\n                if b % blue_width == 0:\n                    blue_length = b // blue_width\n                    if blue_width <= width and blue_length <= length:\n                        # Check red tiles can fit in remaining space\n                        if (width - blue_width) * length >= a:\n                            min_perimeter = min(min_perimeter, 2 * (width + length))\n\n    return min_perimeter\n\n# Read input\na, b = map(int, input().strip().split())\n# Output the result\nprint(minimal_perimeter(a, b))\n```",
    "84": "```python\ndef can_color_to_sort(n, s):\n    color = ['0'] * n\n    last_seen = {}\n\n    for i in range(n):\n        char = s[i]\n        if char in last_seen:\n            if last_seen[char] == '0':\n                color[i] = '1'\n            else:\n                color[i] = '0'\n        else:\n            last_seen[char] = color[i]\n\n    # Check if the colored string can be sorted\n    colored_pairs = [(s[i], color[i]) for i in range(n)]\n    colored_pairs.sort()\n\n    for i in range(1, n):\n        if colored_pairs[i][0] == colored_pairs[i - 1][0] and colored_pairs[i][1] != colored_pairs[i - 1][1]:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(''.join(color))\n\n# Reading input\nn = int(input().strip())\ns = input().strip()\ncan_color_to_sort(n, s)\n```",
    "92": "```python\nx = float(input().strip())\n\n# Find two integers a and b such that 1 <= a, b <= 10 and a / b is approximately equal to x\nfor a in range(1, 11):\n    for b in range(1, 11):\n        if abs(a / b - x) < 1e-6:\n            print(a, b)\n            break\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects by the required rating, then by the rating change\n    projects.sort(key=lambda x: (x[0], -x[1]))\n\n    for a, b in projects:\n        if r < a:  # Not enough rating to start the project\n            return \"NO\"\n        r += b  # Update rating after completing the project\n        if r < 0:  # Rating should not fall below zero\n            return \"NO\"\n\n    return \"YES\"\n\n# Read input\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if all projects can be completed\nresult = can_complete_projects(n, r, projects)\nprint(result)\n```",
    "86": "```python\ndef solve_problems(n, k):\n    # Minimum sum needed if we follow the rules\n    min_sum = (k * (k + 1)) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n    \n    # Maximum possible sum following the rules\n    # Start with the minimum valid sequence\n    a = list(range(1, k + 1))\n    current_sum = sum(a)\n\n    # Increment the last element while observing the rules\n    for i in range(k - 1, -1, -1):\n        # Maximum we can add to a[i] without breaking the rules\n        max_increment = min(n - current_sum, 2 * a[i] - a[i - 1] if i > 0 else float('inf'))\n        if max_increment > 0:\n            a[i] += max_increment\n            current_sum += max_increment\n        \n        if current_sum == n:\n            break\n\n    if current_sum == n:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n    else:\n        print(\"NO\")\n\n# Input reading\nn, k = map(int, input().split())\nsolve_problems(n, k)\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects based on their required rating\n    projects.sort(key=lambda x: x[0])\n    \n    count = 0\n    current_rating = r\n    \n    # Loop through the sorted projects\n    for a, b in projects:\n        # Check if current rating is sufficient to take on the project\n        if current_rating >= a:\n            count += 1\n            current_rating += b\n            \n            # Ensure rating does not fall below zero\n            if current_rating < 0:\n                break\n            \n    return count\n\n# Read input values\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the maximum number of projects Polycarp can complete\nresult = max_projects(n, r, projects)\nprint(result)\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * k or (d == 1 and n > 2) or (n > k + 1 and d == 1):\n        return \"NO\"\n    \n    edges = []\n    # Create a path of length d\n    for i in range(d):\n        edges.append((i + 1, i + 2))\n    \n    # Number of vertices already used\n    used = d + 1\n    \n    # Now, attach remaining vertices to the first vertex of the path\n    # if we can still add more vertices without exceeding the degree limit\n    if used < n:\n        for i in range(used, n):\n            if len([v for u, v in edges if u == 1]) < k:\n                edges.append((1, i + 1))\n            else:\n                # Find a vertex that can accommodate more connections\n                for j in range(1, used):\n                    if len([v for u, v in edges if u == j]) < k:\n                        edges.append((j, i + 1))\n                        break\n            used += 1\n    \n    result = [\"YES\"]\n    for u, v in edges:\n        result.append(f\"{u} {v}\")\n    \n    return \"\\n\".join(result)\n\n# Read input\nn, d, k = map(int, input().split())\nprint(construct_tree(n, d, k))\n```",
    "98": "```python\ndef min_moves_to_reach_n(N):\n    moves = float('inf')\n    \n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            moves = min(moves, i + j - 2)\n    \n    return moves\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    N = int(input().strip())\n    print(min_moves_to_reach_n(N))\n```",
    "97": "```python\ndef min_coins_to_move_chips(n, positions):\n    # Count the number of chips at even and odd positions\n    even_count = sum(1 for x in positions if x % 2 == 0)\n    odd_count = n - even_count\n    \n    # The minimum cost to move all chips to the same parity (either all even or all odd)\n    return min(even_count, odd_count)\n\n# Read input\nn = int(input())\npositions = list(map(int, input().split()))\n\n# Get the result and print it\nresult = min_coins_to_move_chips(n, positions)\nprint(result)\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Initialize the result string\n    result = []\n    \n    # Determine the primary character based on counts\n    if a > b:\n        primary, secondary = '0', '1'\n        primary_count, secondary_count = a, b\n    else:\n        primary, secondary = '1', '0'\n        primary_count, secondary_count = b, a\n    \n    # Start building the string\n    # We need to alternate at least x times\n    for i in range(x):\n        result.append(primary)\n        result.append(secondary)\n        primary_count -= 1\n        secondary_count -= 1\n    \n    # At this point, we should have used (x + 1) characters\n    # If we have remaining primary characters, append them\n    if primary_count > 0:\n        result.append(primary * primary_count)\n    \n    # If we have remaining secondary characters, append them\n    if secondary_count > 0:\n        result.append(secondary * secondary_count)\n    \n    # Join the list into a string and print\n    print(''.join(result))\n\n# Input reading\na, b, x = map(int, input().split())\nconstruct_binary_string(a, b, x)\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Create a string containing n 'a's, n 'b's, and n 'c's\n    chars = 'a' * n + 'b' * n + 'c' * n\n    \n    # Check if we can create a valid string\n    for i in range(len(chars) - 1):\n        if chars[i:i + 2] == s or chars[i:i + 2] == t:\n            # If we find s or t, we need to rearrange\n            chars = list(chars)  # Convert to a list to manipulate\n            # Swap the last two characters to avoid the substring\n            chars[i], chars[i + 1] = chars[i + 1], chars[i]\n            break\n    else:\n        # If we never found a conflict, just return the string\n        return ''.join(chars)\n    \n    # Check the string again for the presence of s and t\n    if s in ''.join(chars) or t in ''.join(chars):\n        return \"NO\"\n    \n    return \"YES\\n\" + ''.join(chars)\n\n# Read input\nn = int(input().strip())\ns = input().strip()\nt = input().strip()\n\n# Generate and print the result\nresult = generate_string(n, s, t)\nprint(result)\n```",
    "91": "```python\ndef max_removable_length(s: str, t: str) -> int:\n    n, m = len(s), len(t)\n    \n    # Precompute the left and right indices of t in s\n    left = [-1] * m\n    right = [-1] * m\n    \n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n    \n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n    \n    # Calculate maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n    \n    # Check the case for removing from the start or the end\n    max_length = max(max_length, right[0])  # Remove from start to right[0]\n    max_length = max(max_length, n - left[m - 1] - 1)  # Remove from left[m-1] to end\n\n    return max_length\n\n# Input reading\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(max_removable_length(s, t))\n```",
    "90": "```python\ndef can_cross_river(n, m, d, platforms):\n    # Total length of platforms\n    total_length = sum(platforms)\n    \n    # If the maximum jump distance is greater than or equal to the width of the river, it's always possible\n    if d >= n + 1:\n        return True, [0] * n + [1]  # All cells can be platform 1\n\n    # Create an array to represent the river cells\n    river = [0] * n\n    current_position = 0\n\n    # Try placing platforms in a way that maximizes the distance they cover\n    for i in range(m):\n        platform_length = platforms[i]\n        # Place the platform at the furthest possible position\n        river[current_position:current_position + platform_length] = [i + 1] * platform_length\n        current_position += platform_length\n        \n        # Ensure we leave space for the next platform\n        if i < m - 1:\n            current_position += d  # Leave a gap of d cells for the jump\n\n    # If the last platform does not reach the end, fill the remaining cells\n    if current_position < n:\n        river[current_position:] = [0] * (n - current_position)\n\n    # Now check if we can actually jump to the end\n    last_jump_position = 0\n    for pos in range(n):\n        if river[pos] != 0:  # There's a platform here\n            if pos <= last_jump_position + d:  # Can jump to this position\n                last_jump_position = pos + (river[pos] == 0)  # Jump to this platform\n            if last_jump_position >= n:  # We can reach the end\n                return True, river\n\n    return False, []\n\n# Input reading\nn, m, d = map(int, input().split())\nplatforms = list(map(int, input().split()))\n\n# Check if crossing is possible and get the configuration\nis_possible, configuration = can_cross_river(n, m, d, platforms)\n\n# Output the result\nif is_possible:\n    print(\"YES\")\n    print(\" \".join(map(str, configuration)))\nelse:\n    print(\"NO\")\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    # Initialize the permutation array\n    p = [0] * n\n    \n    # Set the first element\n    p[0] = 0\n    \n    # Calculate the prefix sums to find the permutation values\n    for i in range(1, n):\n        p[i] = p[i-1] + q[i-1]\n    \n    # Find the minimum value in p to adjust to make it a valid permutation\n    min_p = min(p)\n    \n    # Adjust the permutation to start from 1\n    adjustment = 1 - min_p\n    for i in range(n):\n        p[i] += adjustment\n    \n    # Check if the adjusted permutation is valid\n    if len(set(p)) != n or any(x < 1 or x > n for x in p):\n        print(-1)\n    else:\n        print(\" \".join(map(str, p)))\n\n# Read input\nn = int(input())\nq = list(map(int, input().split()))\n\n# Restore and print the permutation\nrestore_permutation(n, q)\n```",
    "99": "```python\ndef rock_paper_scissors(n, alice_choices, bob_choices):\n    a1, a2, a3 = alice_choices  # Alice: rock, scissors, paper\n    b1, b2, b3 = bob_choices    # Bob: rock, scissors, paper\n\n    # Maximum wins for Alice\n    max_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n\n    # Minimum wins for Alice\n    # Calculate losses for Alice\n    alice_losses = 0\n    # Bob's rock beats Alice's scissors\n    alice_losses += min(a2, b1)\n    # Bob's scissors beat Alice's paper\n    alice_losses += min(a3, b2)\n    # Bob's paper beats Alice's rock\n    alice_losses += min(a1, b3)\n\n    # Minimum wins for Alice can be calculated as total rounds - losses\n    min_wins = n - alice_losses\n\n    return min_wins, max_wins\n\n# Input reading\nn = int(input())\nalice_choices = list(map(int, input().split()))\nbob_choices = list(map(int, input().split()))\n\n# Calculate results\nmin_wins, max_wins = rock_paper_scissors(n, alice_choices, bob_choices)\n\n# Output results\nprint(min_wins, max_wins)\n```",
    "88": "```python\ndef can_form_palindromic_matrix(n, numbers):\n    from collections import Counter\n    \n    count = Counter(numbers)\n    odd_count = sum(1 for v in count.values() if v % 2 != 0)\n    \n    # For odd n, we can have at most one odd count of elements\n    if n % 2 == 1 and odd_count > 1:\n        return False\n    \n    # For even n, we cannot have any odd count of elements\n    if n % 2 == 0 and odd_count > 0:\n        return False\n    \n    return True\n\ndef fill_palindromic_matrix(n, numbers):\n    from collections import Counter\n    \n    count = Counter(numbers)\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Fill the matrix\n    half_n = (n + 1) // 2  # This is the number of rows/columns we need to fill\n    \n    idx = 0\n    for number, freq in count.items():\n        while freq > 0:\n            if freq >= 4:\n                # Place in corners\n                matrix[idx][idx] = number\n                matrix[idx][n - idx - 1] = number\n                matrix[n - idx - 1][idx] = number\n                matrix[n - idx - 1][n - idx - 1] = number\n                freq -= 4\n            elif freq == 3:\n                # Place in corners and center (only valid if n is odd)\n                if n % 2 == 1:\n                    matrix[idx][idx] = number\n                    matrix[idx][n - idx - 1] = number\n                    matrix[n - idx - 1][idx] = number\n                    matrix[half_n - 1][half_n - 1] = number\n                    freq -= 3\n                else:\n                    break  # Cannot place with 3 in even n\n            elif freq == 2:\n                # Place in one row and one column\n                matrix[idx][idx] = number\n                matrix[idx][n - idx - 1] = number\n                freq -= 2\n            elif freq == 1:\n                # Place in the center if it's an odd n\n                if n % 2 == 1:\n                    matrix[half_n - 1][half_n - 1] = number\n                    freq -= 1\n                break\n            else:\n                break\n        if freq > 0:\n            return False\n        idx += 1\n        if idx == half_n:\n            break\n\n    # Fill remaining spots symmetrically\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                matrix[i][j] = matrix[n - i - 1][j]\n                matrix[i][n - j - 1] = matrix[n - i - 1][n - j - 1]\n\n    return True, matrix\n\nn = int(input().strip())\nnumbers = list(map(int, input().strip().split()))\n\nif can_form_palindromic_matrix(n, numbers):\n    success, matrix = fill_palindromic_matrix(n, numbers)\n    if success:\n        print(\"YES\")\n        for row in matrix:\n            print(\" \".join(map(str, row)))\n    else:\n        print(\"NO\")\nelse:\n    print(\"NO\")\n```"
}