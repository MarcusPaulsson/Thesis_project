{
    "2": "```python\ndef next_lucky_year(current_year):\n    # Increment the year until we find a lucky year\n    while True:\n        current_year += 1\n        # Convert the year to string and count non-zero digits\n        if sum(1 for digit in str(current_year) if digit != '0') <= 1:\n            return current_year - (current_year - 1)\n\n# Read input\nn = int(input().strip())\n# Get the result\nresult = next_lucky_year(n)\n# Print the result\nprint(result)\n```",
    "7": "```python\ndef find_empty_day(n, m):\n    day = 0\n    total_sparrows = 0\n    grains = n\n\n    while grains > 0:\n        day += 1\n        total_sparrows += day\n        \n        # Add grains to the barn\n        grains = min(grains + m, n)\n        \n        # Sparrows eat grains\n        grains -= total_sparrows\n        \n    return day\n\n# Input reading\nn, m = map(int, input().split())\nprint(find_empty_day(n, m))\n```",
    "10": "```python\ndef calculate_days_off(n):\n    # Calculate maximum days off\n    max_days_off = min(n, (n // 7) * 2 + min(2, n % 7))\n    \n    # Calculate minimum days off\n    if n < 5:\n        min_days_off = n  # All days can be days off if less than 5\n    else:\n        min_days_off = (n // 7) * 2  # Full weeks contribute 2 days off\n    \n    print(min_days_off, max_days_off)\n\n# Read input\nn = int(input().strip())\ncalculate_days_off(n)\n```",
    "5": "```python\ndef minimum_seconds(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0  # No tabs to close\n\n    seconds = 0\n\n    # Close tabs to the left of l\n    if l > 1:\n        if pos > l:\n            seconds += (pos - l) + 1  # Move to l and close\n        else:\n            seconds += (l - pos) + 1  # Move to l and close\n    else:\n        seconds += 0  # No tabs to close on the left\n\n    # Close tabs to the right of r\n    if r < n:\n        if pos < r:\n            seconds += (r - pos) + 1  # Move to r and close\n        else:\n            seconds += (pos - r) + 1  # Move to r and close\n\n    return seconds\n\n# Input reading\nn, pos, l, r = map(int, input().split())\nprint(minimum_seconds(n, pos, l, r))\n```",
    "1": "```python\ndef max_digit_sum_number(x):\n    str_x = str(x)\n    n = len(str_x)\n    \n    # Start with the original number\n    max_number = x\n    max_digit_sum = sum(int(d) for d in str_x)\n    \n    # Check numbers by reducing digits\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit and setting all following digits to 9\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        new_number = int(new_number)\n        \n        if new_number > 0:\n            new_digit_sum = sum(int(d) for d in str(new_number))\n            if new_digit_sum > max_digit_sum or (new_digit_sum == max_digit_sum and new_number > max_number):\n                max_number = new_number\n                max_digit_sum = new_digit_sum\n    \n    return max_number\n\n# Input\nx = int(input().strip())\n# Output\nprint(max_digit_sum_number(x))\n```",
    "0": "```python\ndef max_acordion_length(s):\n    # Initialize variables to track the positions of the required characters\n    open_bracket = -1\n    first_colon = -1\n    last_colon = -1\n    close_bracket = -1\n    \n    # Iterate through the string to find the necessary characters\n    for i, char in enumerate(s):\n        if char == '[' and open_bracket == -1:\n            open_bracket = i\n        elif char == ':' and open_bracket != -1 and first_colon == -1:\n            first_colon = i\n        elif char == ':' and first_colon != -1:\n            last_colon = i\n        elif char == ']' and last_colon != -1 and close_bracket == -1:\n            close_bracket = i\n    \n    # Check if we found all necessary parts for an accordion\n    if open_bracket == -1 or first_colon == -1 or last_colon == -1 or close_bracket == -1:\n        return -1\n    \n    # Calculate the number of vertical lines between the colons\n    vertical_lines = last_colon - first_colon - 1\n    \n    # The total length of the accordion\n    accordion_length = 4 + vertical_lines\n    return accordion_length\n\n# Read input\ns = input().strip()\n# Output the result\nprint(max_acordion_length(s))\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    # Create a list to track the coverage of each section\n    coverage = [0] * (n + 1)\n\n    # Function to calculate the number of painted sections\n    def calculate_painted_sections(painter_list):\n        temp_coverage = [0] * (n + 1)\n        for l, r in painter_list:\n            for i in range(l, r + 1):\n                temp_coverage[i] = 1\n        return sum(temp_coverage)\n\n    # Try removing each pair of painters and calculate the painted sections\n    max_sections = 0\n    for i in range(q):\n        for j in range(i + 1, q):\n            # Create a list of painters excluding the i-th and j-th\n            selected_painters = [painters[k] for k in range(q) if k != i and k != j]\n            painted_sections = calculate_painted_sections(selected_painters)\n            max_sections = max(max_sections, painted_sections)\n\n    return max_sections\n\n# Input reading\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output the result\nprint(max_painted_sections(n, q, painters))\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    \n    for query in queries:\n        n, x, blows = query\n        min_blows = float('inf')\n        \n        for d, h in blows:\n            if d >= x:\n                # If we can defeat Zmei Gorynich in one blow\n                min_blows = min(min_blows, 1)\n            else:\n                # Calculate the effective damage after growth\n                effective_damage = d - h\n                if effective_damage > 0:\n                    # Calculate the number of blows needed\n                    blows_needed = (x - d + effective_damage - 1) // effective_damage + 1\n                    min_blows = min(min_blows, blows_needed)\n        \n        results.append(min_blows if min_blows != float('inf') else -1)\n    \n    return results\n\n# Input reading\nt = int(input())\nqueries = []\n\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\n# Get results\nresults = min_blows_to_defeat_zmei(t, queries)\n\n# Output results\nfor result in results:\n    print(result)\n```",
    "15": "```python\ndef is_favorite_in_sequence(a, b, c):\n    if c == 0:\n        return a == b\n    elif c > 0:\n        return a <= b and (b - a) % c == 0\n    else:  # c < 0\n        return a >= b and (a - b) % abs(c) == 0\n\n# Read input\na, b, c = map(int, input().split())\n\n# Check if b appears in the sequence and print result\nif is_favorite_in_sequence(a, b, c):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    # Calculate the number of tiles painted Red\n    red_tiles = n // a\n    # Calculate the number of tiles painted Blue\n    blue_tiles = n // b\n    # Calculate the number of tiles painted both Red and Blue (common multiples)\n    common_tiles = n // (a * b // gcd(a, b))\n    \n    # Calculate the maximum chocolates\n    # We can either paint common tiles Red or Blue, choose the maximum\n    max_chocolates = (red_tiles - common_tiles) * p + (blue_tiles - common_tiles) * q + common_tiles * max(p, q)\n    \n    return max_chocolates\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n# Input reading\nn, a, b, p, q = map(int, input().split())\nprint(max_chocolates(n, a, b, p, q))\n```",
    "17": "```python\ndef standing_spectators(n, k, t):\n    if t <= k:\n        return t\n    elif t <= n:\n        return k\n    else:\n        return n + k - t\n\n# Read input\nn, k, t = map(int, input().split())\n# Output the result\nprint(standing_spectators(n, k, t))\n```",
    "16": "```python\ndef can_form_regular_bracket_sequence(cnt1, cnt2, cnt3, cnt4):\n    # Calculate the total number of opening and closing brackets\n    open_brackets = cnt1 + cnt2\n    close_brackets = cnt2 + cnt3\n    \n    # Check if the number of opening and closing brackets can balance\n    if open_brackets < close_brackets:\n        return 0\n    \n    # Check if the excess closing brackets can be balanced by opening brackets\n    excess_closing = cnt3 - cnt1\n    if excess_closing > 0 and excess_closing > cnt2:\n        return 0\n    \n    return 1\n\n# Read input values\ncnt1 = int(input().strip())\ncnt2 = int(input().strip())\ncnt3 = int(input().strip())\ncnt4 = int(input().strip())\n\n# Output the result\nprint(can_form_regular_bracket_sequence(cnt1, cnt2, cnt3, cnt4))\n```",
    "8": "```python\ndef min_tiles_to_draw(tiles):\n    suits = {'m': [], 'p': [], 's': []}\n    \n    # Parse the tiles into suits\n    for tile in tiles:\n        number = int(tile[0])\n        suit = tile[1]\n        suits[suit].append(number)\n    \n    # Check for existing mentsus\n    def has_koutsu(suit_tiles):\n        return len(suit_tiles) >= 3 and len(set(suit_tiles)) == 1\n    \n    def has_shuntsu(suit_tiles):\n        if len(suit_tiles) < 3:\n            return False\n        suit_tiles = sorted(set(suit_tiles))\n        for i in range(len(suit_tiles) - 2):\n            if suit_tiles[i] + 1 == suit_tiles[i + 1] and suit_tiles[i + 1] + 1 == suit_tiles[i + 2]:\n                return True\n        return False\n    \n    # Check if there's already a mentsu\n    for suit in suits:\n        if has_koutsu(suits[suit]) or has_shuntsu(suits[suit]):\n            return 0\n    \n    # If no mentsu, calculate the minimum tiles needed\n    needed = float('inf')\n    \n    # Check for koutsu possibilities\n    for suit in suits:\n        if len(suits[suit]) == 2:\n            needed = min(needed, 1)  # Need one more tile to form a koutsu\n        elif len(suits[suit]) == 1:\n            needed = min(needed, 2)  # Need two more tiles to form a koutsu\n    \n    # Check for shuntsu possibilities\n    for suit in suits:\n        if len(suits[suit]) == 2:\n            if abs(suits[suit][0] - suits[suit][1]) == 1:\n                needed = min(needed, 1)  # Need one more tile to form a shuntsu\n            else:\n                needed = min(needed, 2)  # Need two more tiles to form a shuntsu\n        elif len(suits[suit]) == 1:\n            needed = min(needed, 2)  # Need two more tiles to form a shuntsu\n    \n    return needed\n\n# Input reading\ntiles = input().strip().split()\nprint(min_tiles_to_draw(tiles))\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    # Find the lengths of contiguous segments of 'G'\n    segments = []\n    current_length = 0\n    \n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n            \n    if current_length > 0:\n        segments.append(current_length)\n    \n    # If there are no golden trophies\n    if not segments:\n        return 0\n    \n    # Calculate the maximum length of 'G' segments\n    max_length = max(segments)\n    \n    # If there is only one segment, no swap can increase its length\n    if len(segments) == 1:\n        return max_length\n    \n    # Check for possible swaps between segments\n    max_possible_length = max_length\n    \n    for i in range(len(segments) - 1):\n        # If we swap a 'S' between two segments of 'G', we can combine them\n        combined_length = segments[i] + segments[i + 1]\n        max_possible_length = max(max_possible_length, combined_length)\n    \n    # If we can swap a 'S' with a 'G' to increase the length of the longest segment\n    max_possible_length = min(max_possible_length + 1, n)\n    \n    return max_possible_length\n\n# Input reading\nn = int(input().strip())\ntrophies = input().strip()\n\n# Output the result\nprint(max_beauty_after_swap(n, trophies))\n```",
    "18": "```python\ndef lexicographically_minimal_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        while t and (not u or t[-1] <= u[-1]):\n            u.append(t.pop())\n    \n    return ''.join(u)\n\n# Read input\ns = input().strip()\n# Get the result\nresult = lexicographically_minimal_string(s)\n# Print the result\nprint(result)\n```",
    "14": "```python\ndef is_stack_sortable(n, k, p):\n    # Create a set of used elements from the first k elements\n    used = set(p)\n    # Initialize the result array with the first k elements\n    result = p[:]\n    \n    # The next available number to use in the permutation\n    next_available = n\n    \n    # A stack to simulate the stack operations\n    stack = []\n    \n    # Iterate through the first k elements\n    for i in range(k):\n        # Push elements onto the stack until we can pop\n        while next_available > 0 and (len(stack) == 0 or stack[-1] < p[i]):\n            if next_available not in used:\n                stack.append(next_available)\n            next_available -= 1\n        \n        # If the stack's top is not equal to the current element, it's not sortable\n        if len(stack) > 0 and stack[-1] == p[i]:\n            stack.pop()\n        elif len(stack) > 0 and stack[-1] > p[i]:\n            return -1\n    \n    # Fill the remaining elements in the result\n    while next_available > 0:\n        if next_available not in used:\n            result.append(next_available)\n        next_available -= 1\n    \n    # Now we need to ensure the result is stack-sortable\n    stack = []\n    for num in result:\n        while stack and stack[-1] < num:\n            stack.pop()\n        stack.append(num)\n    \n    # If the stack is not empty, we can check if we can pop all elements\n    if len(stack) != len(result):\n        return -1\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result\nresult = is_stack_sortable(n, k, p)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "19": "```python\ndef is_records_correct(test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, stats = case\n        valid = True\n        \n        for i in range(n):\n            p_i, c_i = stats[i]\n            \n            if i > 0:\n                p_prev, c_prev = stats[i - 1]\n                \n                if p_i < p_prev or c_i < c_prev or c_i > p_i:\n                    valid = False\n                    break\n                \n                if p_i - p_prev < c_i - c_prev:\n                    valid = False\n                    break\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Read input\nT = int(input())\ntest_cases = []\n\nfor _ in range(T):\n    n = int(input())\n    stats = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, stats))\n\n# Get results and print them\nresults = is_records_correct(test_cases)\nfor result in results:\n    print(result)\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a, b):\n    from itertools import permutations\n\n    # Convert a to string and get its digits\n    a_str = str(a)\n    b_str = str(b)\n\n    # Generate all unique permutations of the digits of a\n    permuted_numbers = set(int(''.join(p)) for p in permutations(a_str))\n\n    # Filter permutations to find the maximum that does not exceed b\n    valid_numbers = [num for num in permuted_numbers if num <= b and len(str(num)) == len(a_str)]\n\n    # Return the maximum valid number\n    return max(valid_numbers)\n\n# Input reading\na = int(input().strip())\nb = int(input().strip())\n\n# Get the result and print it\nresult = max_permutation_not_exceeding(a, b)\nprint(result)\n```",
    "20": "```python\ndef is_palindrome(time_str):\n    return time_str == time_str[::-1]\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return minutes_passed\n\ndef main():\n    current_time = input().strip()\n    hh, mm = map(int, current_time.split(':'))\n    result = next_palindrome_time(hh, mm)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "9": "```python\ndef find_grandpa_sofa(d, n, m, sofas, counts):\n    cnt_l, cnt_r, cnt_t, cnt_b = counts\n    sofas_positions = []\n\n    for i in range(d):\n        x1, y1, x2, y2 = sofas[i]\n        if x1 > x2 or (x1 == x2 and y1 > y2):\n            x1, y1, x2, y2 = x2, y2, x1, y1\n        sofas_positions.append((x1, y1, x2, y2))\n\n    def count_relations(s_index):\n        x1, y1, x2, y2 = sofas_positions[s_index]\n        left = right = top = bottom = 0\n\n        for j in range(d):\n            if j == s_index:\n                continue\n            sx1, sy1, sx2, sy2 = sofas_positions[j]\n            if sx2 < x1:  # sofa j is to the left of sofa s_index\n                left += 1\n            elif sx1 > x2:  # sofa j is to the right of sofa s_index\n                right += 1\n            if sy2 < y1:  # sofa j is above sofa s_index\n                top += 1\n            elif sy1 > y2:  # sofa j is below sofa s_index\n                bottom += 1\n\n        return left, right, top, bottom\n\n    for i in range(d):\n        left, right, top, bottom = count_relations(i)\n        if (left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b):\n            return i + 1  # return 1-based index\n\n    return -1\n\n# Input reading\nd = int(input().strip())\nn, m = map(int, input().strip().split())\nsofas = [tuple(map(int, input().strip().split())) for _ in range(d)]\ncounts = tuple(map(int, input().strip().split()))\n\n# Output the result\nprint(find_grandpa_sofa(d, n, m, sofas, counts))\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # Since GCD(x, m) = 1, the x-mouse will visit all rooms\n    # The number of unique rooms visited is equal to m - 1\n    # We need to place traps in the starting room and the rooms it visits\n    return m - 1\n\n# Read input\nm, x = map(int, input().split())\n# Calculate and print the result\nprint(minimum_traps(m, x))\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    # Check if k is valid for a symmetric matrix\n    if k > n * (n + 1) // 2:\n        return -1\n    \n    # Initialize the matrix with zeros\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Fill the matrix to make it lexicographically maximal\n    for i in range(n):\n        for j in range(i, n):\n            if k > 0:\n                if i == j:  # Diagonal element\n                    matrix[i][j] = 1\n                    k -= 1\n                elif k >= 2:  # Symmetric pair\n                    matrix[i][j] = 1\n                    matrix[j][i] = 1\n                    k -= 2\n    \n    # If there are still ones left to place, return -1\n    if k > 0:\n        return -1\n    \n    return matrix\n\n# Read input\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\n# Output result\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "27": "```python\ndef min_operations(n, s):\n    # Initialize the minimum operations to the length of the string\n    min_ops = n\n    \n    # Check for all possible prefixes\n    for i in range(1, n + 1):\n        prefix = s[:i]\n        # Check if the prefix can be repeated to form the beginning of the string\n        if s.startswith(prefix * (n // i)) and n % i == 0:\n            # Calculate operations: typing the prefix + 1 copy + remaining characters\n            operations = i + 1 + (n - len(prefix * (n // i)))\n            min_ops = min(min_ops, operations)\n    \n    return min_ops\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(min_operations(n, s))\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    # Define a mapping of characters to their mirror counterparts\n    mirror_map = {\n        'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M',\n        'O': 'O', 'p': 'q', 'q': 'p', 'R': 'R', 'S': 'S', 'T': 'T',\n        'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X', 'Y': 'Y', 'o': 'o',\n        'x': 'x'\n    }\n\n    n = len(s)\n    for i in range((n + 1) // 2):\n        left_char = s[i]\n        right_char = s[n - 1 - i]\n        \n        # Check if the characters are mirror images\n        if left_char not in mirror_map or mirror_map[left_char] != right_char:\n            print(\"NIE\")\n            return\n    \n    print(\"TAK\")\n\n# Read input\ns = input().strip()\nis_s_palindrome(s)\n```",
    "26": "```python\ndef calculate_expressions(x, y, z):\n    expressions = [\n        (x ** (y ** z), \"x^y^z\"),\n        (x ** (z ** y), \"x^z^y\"),\n        ((x ** y) ** z, \"(x^y)^z\"),\n        ((x ** z) ** y, \"(x^z)^y\"),\n        (y ** (x ** z), \"y^x^z\"),\n        (y ** (z ** x), \"y^z^x\"),\n        ((y ** x) ** z, \"(y^x)^z\"),\n        ((y ** z) ** x, \"(y^z)^x\"),\n        (z ** (x ** y), \"z^x^y\"),\n        (z ** (y ** x), \"z^y^x\"),\n        ((z ** x) ** y, \"(z^x)^y\"),\n        ((z ** y) ** x, \"(z^y)^x\"),\n    ]\n    return expressions\n\ndef find_max_expression(x, y, z):\n    expressions = calculate_expressions(x, y, z)\n    max_value = max(value for value, _ in expressions)\n    for value, expr in expressions:\n        if value == max_value:\n            return expr\n\n# Read input\nx, y, z = map(float, input().split())\n\n# Find and print the maximum expression\nresult = find_max_expression(x, y, z)\nprint(result)\n```",
    "24": "```python\ndef can_win_in_one_turn(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # vertical, horizontal, diagonal down-right, diagonal down-left\n    n = 10\n\n    def check_win(x, y):\n        for dx, dy in directions:\n            count = 1  # Count the current position\n            # Check in the positive direction\n            for step in range(1, 5):\n                nx, ny = x + step * dx, y + step * dy\n                if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                    count += 1\n                else:\n                    break\n            # Check in the negative direction\n            for step in range(1, 5):\n                nx, ny = x - step * dx, y - step * dy\n                if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                    count += 1\n                else:\n                    break\n            if count >= 5:\n                return True\n        return False\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                board[i][j] = 'X'  # Place a cross\n                if check_win(i, j):\n                    return \"YES\"\n                board[i][j] = '.'  # Undo the move\n    return \"NO\"\n\n# Read input\nboard = [input().strip() for _ in range(10)]\nprint(can_win_in_one_turn(board))\n```",
    "28": "```python\ndef rename_files(n, files):\n    examples = []\n    regulars = []\n    \n    # Separate examples and regular tests\n    for name, type_ in files:\n        if type_ == '1':\n            examples.append(name)\n        else:\n            regulars.append(name)\n    \n    # Prepare the moves\n    moves = []\n    # Move examples to 1, 2, ..., e\n    for i, example in enumerate(examples):\n        moves.append(f\"move {example} {i + 1}\")\n    \n    # Move regular tests to e + 1, e + 2, ..., n\n    for i, regular in enumerate(regulars):\n        moves.append(f\"move {regular} {len(examples) + i + 1}\")\n    \n    # Output the result\n    print(len(moves))\n    for move in moves:\n        print(move)\n\n# Input reading\nn = int(input().strip())\nfiles = [input().strip().split() for _ in range(n)]\n\n# Call the function\nrename_files(n, files)\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef find_courses(n, k, main_courses, dependencies):\n    # Create a graph and in-degree count\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    \n    # Build the graph and in-degree array\n    for i in range(1, n + 1):\n        for dep in dependencies[i - 1]:\n            graph[dep].append(i)\n            in_degree[i] += 1\n    \n    # Queue for courses with no dependencies\n    queue = deque()\n    for course in range(1, n + 1):\n        if in_degree[course] == 0:\n            queue.append(course)\n    \n    # To track the courses we need to take\n    order = []\n    courses_taken = set()\n    \n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        courses_taken.add(course)\n        \n        for next_course in graph[course]:\n            in_degree[next_course] -= 1\n            if in_degree[next_course] == 0:\n                queue.append(next_course)\n    \n    # Check if we can take all main courses\n    if not all(course in courses_taken for course in main_courses):\n        return -1\n    \n    # Collect the necessary courses to take\n    necessary_courses = set(main_courses)\n    for course in main_courses:\n        # Traverse dependencies to find all necessary courses\n        stack = [course]\n        while stack:\n            current = stack.pop()\n            for dep in dependencies[current - 1]:\n                if dep not in necessary_courses:\n                    necessary_courses.add(dep)\n                    stack.append(dep)\n    \n    # Filter the order to only include necessary courses\n    final_order = [course for course in order if course in necessary_courses]\n    \n    return len(final_order), final_order\n\n# Input reading\nn, k = map(int, input().split())\nmain_courses = list(map(int, input().split()))\ndependencies = [list(map(int, input().split()[1:])) for _ in range(n)]\n\n# Find the courses\nresult = find_courses(n, k, main_courses, dependencies)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    m, course_order = result\n    print(m)\n    print(' '.join(map(str, course_order)))\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    # Calculate the difference\n    diff = abs(sum_first - sum_second)\n    \n    # Create a list of possible changes\n    changes = []\n    if sum_first > sum_second:\n        # We need to decrease the first half or increase the second half\n        changes.extend([9 - d for d in first_half])  # Maximize decrease from first half\n        changes.extend([d for d in second_half])     # Maximize increase from second half\n    else:\n        # We need to decrease the second half or increase the first half\n        changes.extend([9 - d for d in second_half]) # Maximize decrease from second half\n        changes.extend([d for d in first_half])      # Maximize increase from first half\n    \n    # Sort changes in descending order\n    changes.sort(reverse=True)\n    \n    # Calculate the minimum number of replacements needed\n    replacements = 0\n    for change in changes:\n        diff -= change\n        replacements += 1\n        if diff <= 0:\n            break\n    \n    return replacements\n\n# Example usage\nticket = input().strip()\nprint(min_replacements_to_lucky(ticket))\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef birthday_paradox(n, k):\n    MOD = 1000003\n\n    if k > (1 << n):\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the probability of no shared birthdays\n    numerator = 1\n    denominator = 1 << n  # 2^n\n\n    for i in range(k):\n        numerator *= (denominator - i)\n        numerator %= MOD\n        denominator *= (1 << n)\n        denominator %= MOD\n\n    # Probability of at least one shared birthday\n    A = (denominator - numerator) % MOD\n    B = denominator % MOD\n\n    # Reduce A/B to irreducible form\n    common_gcd = gcd(A, B)\n    A //= common_gcd\n    B //= common_gcd\n\n    return A % MOD, B % MOD\n\n# Input reading\nn, k = map(int, input().split())\nresult = birthday_paradox(n, k)\nprint(result[0], result[1])\n```",
    "32": "```python\ndef is_valid_journey(n, journey):\n    position = 0  # Start at the North Pole (0 km)\n    \n    for t, direction in journey:\n        if position == 0 and direction != \"South\":\n            return \"NO\"  # At North Pole, can only go South\n        if position == 20000 and direction != \"North\":\n            return \"NO\"  # At South Pole, can only go North\n        \n        if direction == \"South\":\n            position += t\n        elif direction == \"North\":\n            position -= t\n        elif direction == \"East\" or direction == \"West\":\n            # East and West do not change the position in km\n            continue\n        \n        # Check if position goes out of bounds\n        if position < 0 or position > 20000:\n            return \"NO\"\n    \n    # Journey must end at the North Pole\n    return \"YES\" if position == 0 else \"NO\"\n\n# Input reading\nn = int(input())\njourney = [tuple(input().split()) for _ in range(n)]\njourney = [(int(t), direction) for t, direction in journey]\n\n# Output result\nprint(is_valid_journey(n, journey))\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    def can_distribute(x):\n        plates_for_a = (a + x - 1) // x  # Ceiling division\n        plates_for_b = (b + x - 1) // x  # Ceiling division\n        return plates_for_a + plates_for_b <= n\n\n    low, high = 1, max(a, b)\n    result = 0\n\n    while low <= high:\n        mid = (low + high) // 2\n        if can_distribute(mid):\n            result = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return result\n\n# Input reading\nn, a, b = map(int, input().split())\nprint(max_min_pieces(n, a, b))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    \n    # If the entire string is not a palindrome, return its length\n    if not is_palindrome(s):\n        return n\n    \n    # Check for the longest non-palindrome substring\n    for length in range(n - 1, 0, -1):\n        for start in range(n - length + 1):\n            substring = s[start:start + length]\n            if not is_palindrome(substring):\n                return length\n    \n    return 0\n\n# Input\ns = input().strip()\n# Output\nprint(longest_non_palindrome_substring(s))\n```",
    "35": "```python\ndef is_valid_flag(n, m, flag):\n    colors = set()\n    \n    # Check for horizontal stripes\n    stripe_height = n // 3\n    if n % 3 != 0:\n        return \"NO\"\n    \n    for i in range(3):\n        stripe = flag[i * stripe_height:(i + 1) * stripe_height]\n        first_row_color = stripe[0][0]\n        \n        # Check if all rows in the stripe are the same color\n        if any(row != first_row_color * m for row in stripe):\n            return \"NO\"\n        \n        colors.add(first_row_color)\n    \n    return \"YES\" if len(colors) == 3 else \"NO\"\n\ndef main():\n    n, m = map(int, input().split())\n    flag = [input().strip() for _ in range(n)]\n    \n    result = is_valid_flag(n, m, flag)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "40": "```python\ndef determine_round_status(n, ratings):\n    for a, b in ratings:\n        if a != b:\n            return \"rated\"\n    \n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            return \"unrated\"\n    \n    return \"maybe\"\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    ratings = [tuple(map(int, input().strip().split())) for _ in range(n)]\n    result = determine_round_status(n, ratings)\n    print(result)\n```",
    "33": "```python\ndef count_common_integers(a1, b1, a2, b2, L, R):\n    from math import gcd\n\n    # Calculate the step size and the initial offsets\n    step = gcd(a1, a2)\n    \n    # Normalize the offsets\n    b1_mod = (b1 % step + step) % step\n    b2_mod = (b2 % step + step) % step\n\n    # Check if the offsets are compatible\n    if b1_mod != b2_mod:\n        return 0\n\n    # Find the first valid x >= L\n    first_x = max(L, (b1 + (L - b1) // a1 * a1))\n    if (first_x - b1) % a1 != 0:\n        first_x += a1\n\n    # Find the last valid x <= R\n    last_x = min(R, (b1 + (R - b1) // a1 * a1))\n    if (last_x - b1) % a1 != 0:\n        last_x -= a1\n\n    # Count the number of valid integers\n    if first_x > last_x:\n        return 0\n\n    return (last_x - first_x) // step + 1\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n\n# Get the result and print it\nresult = count_common_integers(a1, b1, a2, b2, L, R)\nprint(result)\n```",
    "41": "```python\ndef nearest_zero_distance(n, arr):\n    distances = [float('inf')] * n\n    last_zero_index = -1\n\n    # Forward pass to find distances to the nearest zero on the left\n    for i in range(n):\n        if arr[i] == 0:\n            last_zero_index = i\n            distances[i] = 0\n        elif last_zero_index != -1:\n            distances[i] = i - last_zero_index\n\n    # Backward pass to find distances to the nearest zero on the right\n    last_zero_index = -1\n    for i in range(n - 1, -1, -1):\n        if arr[i] == 0:\n            last_zero_index = i\n        elif last_zero_index != -1:\n            distances[i] = min(distances[i], last_zero_index - i)\n\n    return distances\n\n# Input reading\nn = int(input().strip())\narr = list(map(int, input().strip().split()))\n\n# Get distances and print them\nresult = nearest_zero_distance(n, arr)\nprint(' '.join(map(str, result)))\n```",
    "38": "```python\ndef can_coincide(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between consecutive barriers for Kefa and Sasha\n    kefa_gaps = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    sasha_gaps = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Double the kefa_gaps to account for circular shifts\n    kefa_gaps_doubled = kefa_gaps * 2\n    \n    # Check if sasha_gaps can be found in the doubled kefa_gaps\n    for i in range(n):\n        if kefa_gaps_doubled[i:i + n] == sasha_gaps:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_coincide(n, L, kefa_distances, sasha_distances))\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n\n    # Function to check if s is a substring in any cyclic shift of t\n    def contains_as_substring(t):\n        doubled_t = t + t  # Concatenate to check cyclic shifts\n        return s in doubled_t\n\n    # Generate all binary strings of length n\n    total_count = 0\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if contains_as_substring(t):\n            total_count += 1\n\n    return total_count\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_cyclic_strings(n, s))\n```",
    "36": "```python\ndef hexagon_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 1\n\n    # Determine the layer in which the move n is located\n    while n >= moves_in_layer:\n        n -= moves_in_layer\n        layer += 1\n        moves_in_layer = 6 * layer\n\n    # Calculate the coordinates based on the layer and remaining moves\n    x, y = layer, 0\n    if n > 0:\n        # Move in the hexagonal pattern\n        direction = n // layer\n        steps = n % layer\n\n        if direction == 0:  # Right\n            x += steps\n        elif direction == 1:  # Top-right\n            x += steps\n            y += steps\n        elif direction == 2:  # Top-left\n            x -= steps\n            y += steps\n        elif direction == 3:  # Left\n            x -= steps\n        elif direction == 4:  # Bottom-left\n            x -= steps\n            y -= steps\n        elif direction == 5:  # Bottom-right\n            x += steps\n            y -= steps\n\n    return (x, y)\n\nn = int(input().strip())\nx, y = hexagon_coordinates(n)\nprint(x, y)\n```",
    "44": "```python\ndef minimal_time_to_post_office(d, k, a, b, t):\n    # Calculate the number of full segments Vasiliy can drive\n    full_segments = d // k\n    remaining_distance = d % k\n\n    # Time if he drives all full segments and walks the remaining distance\n    time_using_car = full_segments * (k * a + t) + remaining_distance * a\n    time_using_car -= t  # Remove the last repair time since he doesn't need to repair after the last segment\n\n    # Time if he walks the entire distance\n    time_walking = d * b\n\n    # Calculate the minimum time considering both strategies\n    min_time = min(time_using_car, time_walking)\n\n    # Check if he can drive some distance, repair, and then walk the rest\n    if full_segments > 0:\n        for i in range(full_segments + 1):\n            time = (i * (k * a + t)) + (d - i * k) * b\n            min_time = min(min_time, time)\n\n    return min_time\n\n# Input reading\nd, k, a, b, t = map(int, input().split())\nresult = minimal_time_to_post_office(d, k, a, b, t)\nprint(result)\n```",
    "46": "```python\ndef count_divisible_pairs(n, m):\n    # Count occurrences of each remainder when divided by 5\n    count_x = [0] * 5\n    count_y = [0] * 5\n    \n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n        \n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n        \n    # Calculate the number of valid pairs\n    total_pairs = 0\n    for i in range(5):\n        total_pairs += count_x[i] * count_y[(5 - i) % 5]\n        \n    return total_pairs\n\n# Read input\nn, m = map(int, input().split())\n# Output the result\nprint(count_divisible_pairs(n, m))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n\n    # Determine the range where the k-th digit lies\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    # Find the actual number that contains the k-th digit\n    start += (k - 1) // length\n    num_str = str(start)\n    \n    # Find the specific digit in that number\n    return num_str[(k - 1) % length]\n\n# Input\nk = int(input().strip())\n# Output\nprint(find_kth_digit(k))\n```",
    "51": "```python\nfrom collections import Counter\nimport sys\n\ndef find_x_y(divisors):\n    count = Counter(divisors)\n    x, y = 1, 1\n    \n    for d in count:\n        if count[d] == 2:\n            x *= d\n            y *= d\n        elif count[d] == 1:\n            if x < y:\n                x *= d\n            else:\n                y *= d\n                \n    return x, y\n\nif __name__ == \"__main__\":\n    n = int(sys.stdin.readline().strip())\n    divisors = list(map(int, sys.stdin.readline().strip().split()))\n    \n    x, y = find_x_y(divisors)\n    print(x, y)\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = -1\n    moves = []\n    \n    while left <= right:\n        if a[left] < last_taken and a[right] < last_taken:\n            break\n        \n        if a[left] > last_taken and (a[right] <= last_taken or a[left] < a[right]):\n            moves.append('L')\n            last_taken = a[left]\n            left += 1\n        elif a[right] > last_taken:\n            moves.append('R')\n            last_taken = a[right]\n            right -= 1\n        else:\n            break\n\n    print(len(moves))\n    print(''.join(moves))\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\nlongest_increasing_sequence(n, a)\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef reachable_count(n):\n    reachable = set()\n    current = n\n    \n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n    \n    return len(reachable)\n\nn = int(input().strip())\nprint(reachable_count(n))\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_elements = m // 2\n    dp = [[-1] * k for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        row = sorted(matrix[i - 1], reverse=True)\n        current_dp = dp[i - 1][:]  # Copy previous row\n\n        for j in range(1, max_elements + 1):\n            if j <= len(row):\n                sum_selected = sum(row[:j])\n                for mod in range(k):\n                    if current_dp[mod] != -1:\n                        new_sum = current_dp[mod] + sum_selected\n                        new_mod = new_sum % k\n                        current_dp[new_mod] = max(current_dp[new_mod], new_sum)\n\n        dp[i] = current_dp\n\n    return max(dp[n])\n\n# Input reading\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_sum_divisible_by_k(n, m, k, matrix))\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Minimum sum of first k positive integers is k * (k + 1) // 2\n    min_sum = k * (k + 1) // 2\n    \n    if n < min_sum:\n        return -1\n    \n    # The maximum GCD we can use is n // k\n    max_gcd = n // k\n    \n    # We need to find the largest GCD that allows us to create a valid sequence\n    for g in range(max_gcd, 0, -1):\n        # Calculate the adjusted sum we need to reach\n        adjusted_n = n // g\n        \n        # Check if we can form the sequence with this GCD\n        if adjusted_n >= min_sum:\n            # Create the sequence\n            sequence = [(i + 1) * g for i in range(k)]\n            return sequence\n    \n    return -1\n\n# Input reading\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\n# Output result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "55": "```python\ndef is_white_sheet_visible(white, black1, black2):\n    x1, y1, x2, y2 = white\n    x3, y3, x4, y4 = black1\n    x5, y5, x6, y6 = black2\n\n    # Check if any part of the white sheet is visible\n    visible = (\n        (x2 <= x3 or x4 <= x1 or y2 <= y3 or y4 <= y1) or  # White is completely to the left, right, above, or below black1\n        (x2 <= x5 or x6 <= x1 or y2 <= y5 or y6 <= y1)    # White is completely to the left, right, above, or below black2\n    )\n\n    return \"YES\" if visible else \"NO\"\n\n# Read input\nwhite_sheet = list(map(int, input().split()))\nblack_sheet1 = list(map(int, input().split()))\nblack_sheet2 = list(map(int, input().split()))\n\n# Determine visibility\nresult = is_white_sheet_visible(white_sheet, black_sheet1, black_sheet2)\nprint(result)\n```",
    "54": "```python\ndef minimum_D(n, a):\n    min_a = min(a)\n    max_a = max(a)\n\n    if min_a == max_a:\n        return 0  # All elements are already equal\n\n    # The potential target value to make all elements equal\n    target1 = min_a + (max_a - min_a) // 2\n    target2 = max_a - (max_a - min_a) // 2\n\n    # Calculate the required D for both targets\n    D1 = max(0, target1 - min_a, max_a - target1)\n    D2 = max(0, target2 - min_a, max_a - target2)\n\n    # Check if we can achieve target1 or target2\n    def can_achieve(target):\n        return all(abs(x - target) <= D1 for x in a)\n\n    if can_achieve(target1):\n        return D1\n    elif can_achieve(target2):\n        return D2\n    else:\n        return -1\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(minimum_D(n, a))\n```",
    "47": "```python\ndef max_subarray_sum(arr):\n    max_sum = 0\n    current_sum = 0\n    for num in arr:\n        current_sum += num\n        if current_sum < 0:\n            current_sum = 0\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef max_beauty_with_multiplier(n, x, a):\n    # Calculate the original beauty of the array\n    original_beauty = max_subarray_sum(a)\n    \n    # If x is 0, the best we can do is the original beauty\n    if x == 0:\n        return original_beauty\n    \n    # Calculate the maximum beauty after applying the multiplier\n    max_beauty = original_beauty\n    for i in range(n):\n        for j in range(i, n):\n            # Create a new array with the subarray [i:j] multiplied by x\n            modified_array = a[:i] + [a[k] * x for k in range(i, j + 1)] + a[j + 1:]\n            max_beauty = max(max_beauty, max_subarray_sum(modified_array))\n    \n    return max_beauty\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result and print it\nresult = max_beauty_with_multiplier(n, x, a)\nprint(result)\n```",
    "58": "```python\ndef color_array(n, k, a):\n    from collections import defaultdict\n\n    color_assignment = [0] * n\n    color_used = defaultdict(set)\n    \n    for i in range(n):\n        num = a[i]\n        for color in range(1, k + 1):\n            if num not in color_used[color]:\n                color_assignment[i] = color\n                color_used[color].add(num)\n                break\n        else:\n            print(\"NO\")\n            return\n\n    if len(color_used) < k:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, color_assignment)))\n\n# Input reading\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncolor_array(n, k, a)\n```",
    "63": "```python\ndef min_instability(n, a):\n    a.sort()\n    # Remove the smallest or the largest element\n    instability_remove_min = a[-1] - a[1]  # Remove the smallest element\n    instability_remove_max = a[-2] - a[0]  # Remove the largest element\n    return min(instability_remove_min, instability_remove_max)\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_instability(n, a))\n```",
    "60": "```python\ndef has_palindrome_subsequence(test_cases):\n    results = []\n    for n, a in test_cases:\n        found = False\n        # Use a dictionary to track the first occurrence of each number\n        first_occurrence = {}\n        \n        for i in range(n):\n            if a[i] in first_occurrence:\n                # If we find the same number again, we can form a palindrome\n                if i - first_occurrence[a[i]] >= 2:\n                    found = True\n                    break\n            else:\n                first_occurrence[a[i]] = i\n        \n        results.append(\"YES\" if found else \"NO\")\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Get results and print them\nresults = has_palindrome_subsequence(test_cases)\nprint(\"\\n\".join(results))\n```",
    "61": "```python\ndef max_number_after_replacement(n, a, f):\n    a_list = list(a)\n    modified = False\n\n    for i in range(n):\n        original_digit = int(a_list[i])\n        new_digit = f[original_digit - 1]\n        \n        if new_digit > original_digit:\n            a_list[i] = str(new_digit)\n            modified = True\n        elif modified and new_digit < original_digit:\n            break\n\n    return ''.join(a_list)\n\n# Input reading\nn = int(input().strip())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\n# Get the result and print\nresult = max_number_after_replacement(n, a, f)\nprint(result)\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Find the longest suffix of t that is also a prefix\n    for i in range(1, n):\n        if t[i:] == t[:n - i]:\n            overlap_length = n - i\n            break\n    else:\n        overlap_length = 0\n\n    # Construct the result string\n    result = t + (t[overlap_length:] * (k - 1))\n    return result\n\n# Read input\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the result and print it\nresult = construct_string(n, k, t)\nprint(result)\n```",
    "67": "```python\ndef find_nice_indices(n, a):\n    total_sum = sum(a)\n    nice_indices = []\n\n    for i in range(n):\n        remaining_sum = total_sum - a[i]\n        if remaining_sum == a[i] * 2:\n            nice_indices.append(i + 1)  # Store 1-based index\n\n    return nice_indices\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Finding nice indices\nnice_indices = find_nice_indices(n, a)\n\n# Output results\nprint(len(nice_indices))\nif nice_indices:\n    print(\" \".join(map(str, nice_indices)))\n```",
    "71": "```python\ndef calculate_output(a):\n    return (a - 1).bit_length()\n\nif __name__ == \"__main__\":\n    a = int(input().strip())\n    print(calculate_output(a))\n```",
    "59": "```python\ndef min_operations_to_remainder(n, x, y, number):\n    # Calculate the target pattern based on y\n    target = ['0'] * x\n    target[y] = '1'\n    \n    # Count the number of changes needed\n    changes = 0\n    for i in range(x):\n        if number[n - 1 - i] != target[x - 1 - i]:\n            changes += 1\n            \n    return changes\n\n# Read input\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# Get the result and print it\nresult = min_operations_to_remainder(n, x, y, number)\nprint(result)\n```",
    "50": "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph):\n    visited = [-1] * (n + 1)\n    queue = deque([start])\n    visited[start] = 0\n    farthest_node = start\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if visited[neighbor] == -1:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > visited[farthest_node]:\n                    farthest_node = neighbor\n                    \n    return farthest_node, visited\n\ndef find_max_edges(n, edges):\n    graph = defaultdict(list)\n    \n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # Step 1: Find the farthest node from an arbitrary node (1)\n    farthest_node_from_start, _ = bfs(1, graph)\n    \n    # Step 2: Find the farthest node from the farthest node found in step 1\n    farthest_node, distances = bfs(farthest_node_from_start, graph)\n    \n    # Step 3: Find the farthest node from the second farthest node\n    other_end_node, distances_from_other_end = bfs(farthest_node, graph)\n\n    # Step 4: Find the maximum distance and the nodes at that distance\n    max_distance = max(distances)\n    max_distance_nodes = [i for i in range(1, n + 1) if distances[i] == max_distance]\n\n    # Step 5: Choose three distinct nodes\n    a = farthest_node_from_start\n    b = max_distance_nodes[0]\n    c = max_distance_nodes[1] if len(max_distance_nodes) > 1 else (b % n + 1)\n\n    # The number of edges in the union of paths is the number of edges in the tree\n    # minus the edges in the path between a and b\n    return len(edges), a, b, c\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    edges = [tuple(map(int, line.split())) for line in data[1:n]]\n    \n    result = find_max_edges(n, edges)\n    print(result[0])\n    print(result[1], result[2], result[3])\n```",
    "73": "```python\ndef can_complete_wall(n, heights):\n    max_height = max(heights)\n    total_bricks_needed = 0\n    \n    for height in heights:\n        total_bricks_needed += max_height - height\n    \n    # Check if the total number of bricks needed is even\n    return total_bricks_needed % 2 == 0\n\n# Input reading\nn = int(input())\nheights = list(map(int, input().split()))\n\n# Output result\nif can_complete_wall(n, heights):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    # Initialize the schedule with zeros (rest days)\n    schedule = [0] * n\n    # To keep track of preparation days needed for each exam\n    preparation_needed = [0] * m\n    \n    # Fill the exam days in the schedule\n    for i in range(m):\n        s_i, d_i, c_i = exams[i]\n        schedule[d_i - 1] = m + 1  # Exam day (1-indexed)\n        preparation_needed[i] = c_i\n\n    # Prepare for exams\n    for i in range(m):\n        s_i, d_i, c_i = exams[i]\n        days_prepared = 0\n        \n        for j in range(s_i - 1, d_i - 1):\n            if schedule[j] == 0 and days_prepared < c_i:\n                schedule[j] = i + 1  # Prepare for exam i (1-indexed)\n                days_prepared += 1\n\n        if days_prepared < c_i:\n            return -1  # Not enough preparation days\n\n    return schedule\n\n# Read input\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the schedule\nresult = schedule_exams(n, m, exams)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "70": "```python\ndef midpoint_of_contest(h1, m1, h2, m2):\n    # Convert start and end times to total minutes\n    start_minutes = h1 * 60 + m1\n    end_minutes = h2 * 60 + m2\n    \n    # Calculate the midpoint in total minutes\n    midpoint_minutes = (start_minutes + end_minutes) // 2\n    \n    # Convert back to hours and minutes\n    h3 = midpoint_minutes // 60\n    m3 = midpoint_minutes % 60\n    \n    # Format the output to ensure two digits\n    print(f\"{h3:02}:{m3:02}\")\n\n# Read input\nh1, m1 = map(int, input().strip().split(':'))\nh2, m2 = map(int, input().strip().split(':'))\n\n# Calculate and print the midpoint\nmidpoint_of_contest(h1, m1, h2, m2)\n```",
    "57": "```python\ndef assign_gifts(n, friends):\n    # Create a list to store the final gift assignments\n    final_gifts = friends[:]\n    \n    # Find the friends who want to give gifts (f_i != 0)\n    givers = set(i + 1 for i in range(n) if final_gifts[i] != 0)\n    \n    # Find the friends who are not assigned a gift (f_i == 0)\n    receivers = [i + 1 for i in range(n) if final_gifts[i] == 0]\n    \n    # Find the friends who are already assigned gifts\n    assigned = set(final_gifts) - {0}\n    \n    # Find the friends who are not assigned gifts yet\n    unassigned = set(range(1, n + 1)) - assigned\n    \n    # Create a mapping of unassigned friends to receivers\n    unassigned = list(unassigned)\n    \n    # Fill in the zeros in the final_gifts\n    for i in range(len(receivers)):\n        # Assign the gift to the receiver from the unassigned list\n        final_gifts[receivers[i] - 1] = unassigned[i]\n    \n    # Ensure no one gives a gift to themselves\n    for i in range(n):\n        if final_gifts[i] == i + 1:\n            # Swap with the next friend to avoid self-gifting\n            next_index = (i + 1) % n\n            final_gifts[i], final_gifts[next_index] = final_gifts[next_index], final_gifts[i]\n    \n    return final_gifts\n\n# Input reading\nn = int(input())\nfriends = list(map(int, input().split()))\n\n# Get the result and print it\nresult = assign_gifts(n, friends)\nprint(\" \".join(map(str, result)))\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    # Extract left and right endpoints\n    lefts = [l for l, r in segments]\n    rights = [r for l, r in segments]\n    \n    # Precompute the maximum left and minimum right excluding each segment\n    max_left = [0] * n\n    min_right = [0] * n\n    \n    max_left[0] = lefts[0]\n    for i in range(1, n):\n        max_left[i] = max(max_left[i - 1], lefts[i])\n    \n    min_right[n - 1] = rights[n - 1]\n    for i in range(n - 2, -1, -1):\n        min_right[i] = min(min_right[i + 1], rights[i])\n    \n    # Calculate the maximum intersection length after removing each segment\n    max_length = 0\n    for i in range(n):\n        if i == 0:\n            current_left = max_left[1]\n            current_right = min_right[1]\n        elif i == n - 1:\n            current_left = max_left[n - 2]\n            current_right = min_right[n - 2]\n        else:\n            current_left = max(max_left[i - 1], lefts[i + 1])\n            current_right = min(min_right[i + 1], rights[i - 1])\n        \n        # Calculate the length of the intersection\n        intersection_length = max(0, current_right - current_left)\n        max_length = max(max_length, intersection_length)\n    \n    return max_length\n\n# Read input\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = max_intersection_length(n, segments)\nprint(result)\n```",
    "77": "```python\ndef minimum_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nn = int(input().strip())\nprint(minimum_difference(n))\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import Counter\n    \n    # Count the frequency of each character in the string\n    freq = Counter(s)\n    \n    # Calculate the maximum number of unique subsequences we can form\n    unique_subsequences = 0\n    total_cost = 0\n    \n    # To store the costs of subsequences of different lengths\n    costs = []\n    \n    # Generate all possible subsequences and their costs\n    for length in range(1, n + 1):\n        # Calculate the number of unique subsequences of this length\n        count = sum(1 for c in freq if freq[c] >= length)\n        if count > 0:\n            unique_subsequences += count\n            costs.append((n - length) * count)\n    \n    # If we cannot form at least k unique subsequences\n    if unique_subsequences < k:\n        return -1\n    \n    # Sort costs to minimize total cost\n    costs.sort()\n    \n    # Calculate the minimum cost to obtain exactly k unique subsequences\n    total_cost = sum(costs[:k])\n    \n    return total_cost\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "62": "```python\ndef min_operations_to_divisible_triplet(t, test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        min_operations = float('inf')\n        best_triplet = (0, 0, 0)\n        \n        # Iterate over possible values for A\n        for A in range(1, a + 1):\n            # Calculate the nearest B that is divisible by A\n            if b % A == 0:\n                B = b\n            else:\n                B = (b // A + 1) * A\n            \n            # Calculate the nearest C that is divisible by B\n            if C % B == 0:\n                C = c\n            else:\n                C = (c // B + 1) * B\n            \n            # Calculate operations needed\n            operations = abs(A - a) + abs(B - b) + abs(C - c)\n            \n            if operations < min_operations:\n                min_operations = operations\n                best_triplet = (A, B, C)\n        \n        results.append((min_operations, best_triplet))\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations_to_divisible_triplet(t, test_cases)\n\n# Output results\nfor operations, triplet in results:\n    print(operations)\n    print(*triplet)\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    unique_subsequences = set()\n    \n    # Generate all possible subsequences\n    for i in range(1 << n):\n        subsequence = []\n        for j in range(n):\n            if i & (1 << j):\n                subsequence.append(s[j])\n        unique_subsequences.add(''.join(subsequence))\n    \n    # If we cannot obtain k unique subsequences\n    if len(unique_subsequences) < k:\n        return -1\n    \n    # Calculate costs for each unique subsequence\n    costs = []\n    for subseq in unique_subsequences:\n        cost = n - len(subseq)\n        costs.append(cost)\n    \n    # Sort costs and sum the smallest k costs\n    costs.sort()\n    return sum(costs[:k])\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "81": "```python\ndef can_reorder_strings(strings):\n    # Sort strings by their lengths\n    strings.sort(key=len)\n    \n    # Check if each string is a substring of the next one\n    for i in range(len(strings) - 1):\n        if strings[i] not in strings[i + 1]:\n            return \"NO\"\n    \n    return \"YES\", strings\n\n# Read input\nn = int(input().strip())\nstrings = [input().strip() for _ in range(n)]\n\n# Get the result\nresult = can_reorder_strings(strings)\n\n# Print the result\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for string in result[1]:\n        print(string)\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    # Create a list to store the color assignments\n    colors = [0] * n\n    # Dictionary to track the last position of each character\n    last_position = {}\n    \n    # Count the number of colors needed\n    color_count = 0\n    \n    for i in range(n):\n        char = s[i]\n        if char in last_position:\n            # If the character has appeared before, assign the same color\n            colors[i] = colors[last_position[char]]\n        else:\n            # New character, increment color count and assign a new color\n            color_count += 1\n            colors[i] = color_count\n        \n        # Update the last position of the character\n        last_position[char] = i\n    \n    return color_count, colors\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Get the result\nresult_count, result_colors = min_colors_to_sort(n, s)\n\n# Output the result\nprint(result_count)\nprint(' '.join(map(str, result_colors)))\n```",
    "82": "```python\ndef max_problems_solved(n, k, difficulties):\n    left = 0\n    right = n - 1\n    solved = 0\n\n    while left <= right:\n        if difficulties[left] <= k:\n            solved += 1\n            left += 1\n        elif difficulties[right] <= k:\n            solved += 1\n            right -= 1\n        else:\n            break\n\n    return solved\n\n# Input reading\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Output the result\nprint(max_problems_solved(n, k, difficulties))\n```",
    "84": "```python\ndef can_color_string(n, s):\n    # Count the occurrences of each character\n    from collections import Counter\n    count = Counter(s)\n    \n    # Check if any character appears more than twice\n    if any(v > 2 for v in count.values()):\n        return \"NO\"\n    \n    # Initialize the coloring array\n    coloring = ['0'] * n\n    \n    # We will use two colors: '0' and '1'\n    color = 0\n    \n    # Assign colors based on the character's position\n    for i in range(n):\n        if i > 0 and s[i] == s[i - 1]:\n            coloring[i] = coloring[i - 1]  # Same color as previous\n        else:\n            coloring[i] = str(color)  # Alternate colors\n            color = 1 - color  # Switch color\n    \n    return \"YES\", ''.join(coloring)\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Get the result\nresult = can_color_string(n, s)\n\n# Print the result\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    print(result[1])\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects by their required rating\n    projects.sort(key=lambda x: x[0])\n    \n    completed_projects = 0\n    current_rating = r\n    \n    for a, b in projects:\n        if current_rating >= a:\n            completed_projects += 1\n            current_rating += b\n            if current_rating < 0:\n                break\n    \n    return completed_projects\n\n# Read input\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nresult = max_projects(n, r, projects)\nprint(result)\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n    \n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            # Check rectangles for red tiles\n            for red_width in range(1, int(a**0.5) + 1):\n                if a % red_width == 0:\n                    red_height = a // red_width\n                    if red_width <= width and red_height <= height:\n                        perimeter = 2 * (width + height)\n                        min_perimeter = min(min_perimeter, perimeter)\n            \n            # Check rectangles for blue tiles\n            for blue_width in range(1, int(b**0.5) + 1):\n                if b % blue_width == 0:\n                    blue_height = b // blue_width\n                    if blue_width <= width and blue_height <= height:\n                        perimeter = 2 * (width + height)\n                        min_perimeter = min(min_perimeter, perimeter)\n\n    return min_perimeter\n\n# Input reading\na, b = map(int, input().split())\nprint(minimal_perimeter(a, b))\n```",
    "86": "```python\ndef solve_problems(n, k):\n    # Minimum sum of problems needed to satisfy the conditions\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        return \"NO\"\n\n    # Start with the minimum valid sequence\n    a = list(range(1, k + 1))\n    current_sum = sum(a)\n\n    # Distribute the remaining problems\n    remaining = n - current_sum\n    for i in range(k - 1, -1, -1):\n        # Maximum we can add to a[i] while satisfying the conditions\n        max_add = min(remaining, (2 * a[i]) - a[i])\n        a[i] += max_add\n        remaining -= max_add\n        if remaining <= 0:\n            break\n\n    # Check if we have distributed all problems\n    if sum(a) == n:\n        return \"YES\\n\" + \" \".join(map(str, a))\n    else:\n        return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\nresult = solve_problems(n, k)\nprint(result)\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Define the food consumption pattern for each day of the week\n    week_pattern = [0, 0, 1, 0, 0, 1, 0]  # 0: fish, 1: rabbit, 2: chicken\n    food_needed = [0, 0, 0]  # fish, rabbit, chicken\n    \n    # Calculate the maximum full weeks we can sustain\n    full_weeks = min(a // 3, b // 2, c // 2)\n    a -= full_weeks * 3\n    b -= full_weeks * 2\n    c -= full_weeks * 2\n    \n    # Calculate the remaining days we can sustain after full weeks\n    max_days = full_weeks * 7\n    \n    # Try starting from each day of the week\n    for start_day in range(7):\n        remaining_a, remaining_b, remaining_c = a, b, c\n        days = 0\n        \n        for i in range(7):\n            day = (start_day + i) % 7\n            if day in [0, 3, 6]:  # Fish food days\n                if remaining_a > 0:\n                    remaining_a -= 1\n                    days += 1\n                else:\n                    break\n            elif day in [1, 5]:  # Rabbit stew days\n                if remaining_b > 0:\n                    remaining_b -= 1\n                    days += 1\n                else:\n                    break\n            else:  # Chicken stake days\n                if remaining_c > 0:\n                    remaining_c -= 1\n                    days += 1\n                else:\n                    break\n        \n        max_days = max(max_days, full_weeks * 7 + days)\n    \n    return max_days\n\n# Input reading\na, b, c = map(int, input().split())\nprint(max_days(a, b, c))\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    moves = float('inf')\n\n    # Check for pairs of digits that can form 00, 25, 50, or 75\n    for target in ['00', '25', '50', '75']:\n        last_digit = target[1]\n        first_digit = target[0]\n        \n        # Find the last occurrence of the last_digit\n        last_index = -1\n        for i in range(length - 1, -1, -1):\n            if s[i] == last_digit:\n                last_index = i\n                break\n        \n        if last_index == -1:\n            continue\n        \n        # Now find the first_digit before last_index\n        first_index = -1\n        for i in range(last_index - 1, -1, -1):\n            if s[i] == first_digit:\n                first_index = i\n                break\n        \n        if first_index == -1:\n            continue\n        \n        # Calculate moves to bring first_digit to first_index and last_digit to last_index\n        moves_to_first = last_index - first_index\n        moves_to_last = last_index - first_index - 1\n        \n        total_moves = moves_to_first + moves_to_last\n        moves = min(moves, total_moves)\n\n    return moves if moves != float('inf') else -1\n\n# Input reading\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects by their required rating (a_i)\n    projects.sort(key=lambda x: x[0])\n    \n    for a, b in projects:\n        if r < a:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Check if all projects can be completed\nresult = can_complete_projects(n, r, projects)\nprint(result)\n```",
    "78": "```python\ndef count_regular_sequences(n, s):\n    MOD = 10**9 + 7\n    m = len(s)\n\n    # Precompute Catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1\n    for i in range(1, n + 1):\n        catalan[i] = (catalan[i - 1] * (2 * (2 * i - 1)) % MOD * pow(i + 1, MOD - 2, MOD)) % MOD\n\n    # Check if s can be part of a valid sequence\n    balance = 0\n    min_balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n\n    if balance < 0 or balance > n or min_balance < 0:\n        return 0\n\n    # Count valid sequences with s as a substring\n    total_count = 0\n    for prefix_length in range(max(0, n - (m - 1) - balance), n - balance + 1):\n        suffix_length = n - prefix_length - (m - 1)\n        if suffix_length < 0:\n            continue\n        total_count = (total_count + catalan[prefix_length] * catalan[suffix_length]) % MOD\n\n    return total_count\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_regular_sequences(n, s))\n```",
    "92": "```python\nx = float(input().strip())\n\n# Calculate the integers a and b based on the input x\na = int(x) + 1\nb = int((x - int(x)) * 10) + 1\n\n# Ensure a and b are within the range of 1 to 10\na = min(max(a, 1), 10)\nb = min(max(b, 1), 10)\n\nprint(a, b)\n```",
    "76": "```python\ndef can_construct_symmetric_square(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Check for symmetric pairs\n        pairs = set()\n        for tile in tiles:\n            top_left, top_right = tile[0]\n            bottom_left, bottom_right = tile[1]\n            pairs.add((top_right, bottom_left))\n            pairs.add((bottom_right, top_left))\n        \n        # Check if we can form a symmetric square\n        can_form = False\n        for tile in tiles:\n            top_left, top_right = tile[0]\n            bottom_left, bottom_right = tile[1]\n            if (top_left == bottom_right and top_right == bottom_left):\n                can_form = True\n                break\n        \n        results.append(\"YES\" if can_form else \"NO\")\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        top = tuple(map(int, input().split()))\n        bottom = tuple(map(int, input().split()))\n        tiles.append((top, bottom))\n    test_cases.append((n, m, tiles))\n\n# Process and output results\nresults = can_construct_symmetric_square(t, test_cases)\nfor result in results:\n    print(result)\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Check if we can satisfy the degree condition for vertex 1\n    if len(graph[1]) < D:\n        return \"NO\"\n\n    # Start building the spanning tree\n    spanning_tree_edges = []\n    visited = [False] * (n + 1)\n    visited[1] = True\n    degree_count = 0\n\n    # Use a queue for BFS\n    queue = deque([1])\n    \n    while queue:\n        current = queue.popleft()\n        \n        # If we are at vertex 1, we need to limit the degree to D\n        if current == 1:\n            for neighbor in graph[current]:\n                if degree_count < D:\n                    spanning_tree_edges.append((current, neighbor))\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    degree_count += 1\n                else:\n                    break\n        else:\n            for neighbor in graph[current]:\n                if not visited[neighbor]:\n                    spanning_tree_edges.append((current, neighbor))\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n\n    # Check if we have n-1 edges in the spanning tree\n    if len(spanning_tree_edges) != n - 1:\n        return \"NO\"\n\n    # Return the result\n    result = [\"YES\"]\n    result.extend(f\"{u} {v}\" for u, v in spanning_tree_edges)\n    return \"\\n\".join(result)\n\n# Read input\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the result and print it\nresult = find_spanning_tree(n, m, D, edges)\nprint(result)\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n, m = len(s), len(t)\n    \n    # Create arrays to store the positions of t in s\n    left = [0] * m\n    right = [0] * m\n    \n    # Fill left array\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n    \n    # Fill right array\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n    \n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n    \n    # Check the edges\n    max_length = max(max_length, right[0])  # Remove from start to first character of t\n    max_length = max(max_length, n - 1 - left[m - 1])  # Remove from last character of t to end\n    \n    return max_length\n\n# Input reading\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(max_removable_length(s, t))\n```",
    "97": "```python\ndef min_coins_to_move_chips(n, positions):\n    even_count = sum(1 for x in positions if x % 2 == 0)\n    odd_count = n - even_count\n    return min(even_count, odd_count)\n\n# Input reading\nn = int(input())\npositions = list(map(int, input().split()))\n\n# Output the result\nprint(min_coins_to_move_chips(n, positions))\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    # Initialize the first element of the permutation\n    p = [0] * n\n    p[0] = 0  # We can start from any arbitrary number, we'll adjust later\n\n    # Calculate the permutation based on the differences\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n\n    # Find the minimum value in p to adjust the permutation to start from 1\n    min_p = min(p)\n    adjustment = 1 - min_p\n\n    # Adjust the permutation\n    for i in range(n):\n        p[i] += adjustment\n\n    # Check if the adjusted permutation is valid\n    if len(set(p)) == n and all(1 <= x <= n for x in p):\n        print(\" \".join(map(str, p)))\n    else:\n        print(-1)\n\n# Read input\nn = int(input())\nq = list(map(int, input().split()))\n\n# Restore the permutation\nrestore_permutation(n, q)\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Initialize the string\n    result = []\n    \n    # Determine the starting character based on the counts of a and b\n    if a > b:\n        result.append('0')\n        a -= 1\n    else:\n        result.append('1')\n        b -= 1\n    \n    # We need to create x transitions\n    for _ in range(x):\n        # Alternate between 0 and 1\n        if result[-1] == '0':\n            result.append('1')\n            b -= 1\n        else:\n            result.append('0')\n            a -= 1\n    \n    # Fill the remaining characters with the last character used\n    last_char = result[-1]\n    while a > 0 or b > 0:\n        if last_char == '0' and a > 0:\n            result.append('0')\n            a -= 1\n        elif last_char == '1' and b > 0:\n            result.append('1')\n            b -= 1\n        # Switch last_char if we just added one\n        last_char = result[-1]\n    \n    return ''.join(result)\n\n# Read input\na, b, x = map(int, input().split())\n# Generate and print the binary string\nprint(construct_binary_string(a, b, x))\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1 or d >= n:\n        return \"NO\"\n    \n    edges = []\n    \n    # Create a path of length d\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n    \n    # Now we have d + 1 vertices in the path\n    current_vertex = d + 2\n    \n    # Connect remaining vertices\n    for i in range(1, d + 2):\n        if current_vertex > n:\n            break\n        while len([e for e in edges if e[0] == i or e[1] == i]) < k and current_vertex <= n:\n            edges.append((i, current_vertex))\n            current_vertex += 1\n    \n    if current_vertex <= n:\n        return \"NO\"\n    \n    result = [\"YES\"]\n    result.extend(f\"{u} {v}\" for u, v in edges)\n    return \"\\n\".join(result)\n\n# Input reading\nn, d, k = map(int, input().split())\nprint(construct_tree(n, d, k))\n```",
    "88": "```python\ndef create_palindromic_matrix(n, numbers):\n    from collections import Counter\n    \n    count = Counter(numbers)\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Check for the number of odd occurrences\n    odd_count = sum(1 for v in count.values() if v % 2 != 0)\n    \n    # For odd n, we can have one center element, for even n, we can't have any\n    if (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n        return \"NO\"\n    \n    # Fill the matrix\n    half_n = (n + 1) // 2\n    idx = 0\n    for num, freq in count.items():\n        while freq > 0:\n            if freq >= 4:\n                # Place in corners\n                matrix[idx][idx] = num\n                matrix[idx][n - 1 - idx] = num\n                matrix[n - 1 - idx][idx] = num\n                matrix[n - 1 - idx][n - 1 - idx] = num\n                freq -= 4\n            elif freq >= 2:\n                # Place in sides\n                matrix[idx][idx] = num\n                matrix[idx][n - 1 - idx] = num\n                freq -= 2\n            else:\n                # Place in the center if odd\n                if n % 2 == 1 and idx == half_n - 1 and freq == 1:\n                    matrix[half_n - 1][half_n - 1] = num\n                    freq -= 1\n                else:\n                    break\n            if freq == 0:\n                break\n            if idx < half_n - 1:\n                idx += 1\n            else:\n                idx = 0\n    \n    # Fill the remaining cells\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                matrix[i][j] = matrix[n - 1 - i][j]\n    \n    return \"YES\", matrix\n\nn = int(input())\nnumbers = list(map(int, input().split()))\n\nresult = create_palindromic_matrix(n, numbers)\n\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for row in result[1]:\n        print(\" \".join(map(str, row)))\n```",
    "90": "```python\ndef can_cross_river(n, m, d, c):\n    # Calculate the total length of platforms\n    total_length = sum(c)\n    \n    # If the maximum jump distance is greater than or equal to the river width\n    if d >= n + 1:\n        print(\"YES\")\n        print(\"0 \" + \"0 \" * (n - 1) + str(m))\n        return\n    \n    # Initialize the river representation\n    river = [0] * n\n    current_position = 0\n    \n    # Place platforms in the river\n    for i in range(m):\n        # Check if we can place the platform\n        if current_position + c[i] > n:\n            print(\"NO\")\n            return\n        \n        # Place the platform\n        for j in range(c[i]):\n            river[current_position + j] = i + 1\n        \n        # Move the current position to the end of the current platform\n        current_position += c[i]\n        \n        # Ensure there is enough space for the next jump\n        if i < m - 1:\n            current_position += 1  # Leave at least one cell gap between platforms\n    \n    # Check if we can reach the end\n    last_platform_end = current_position - 1\n    if last_platform_end + d >= n:\n        print(\"YES\")\n        print(\" \".join(map(str, river)))\n    else:\n        print(\"NO\")\n\n# Read input\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Call the function\ncan_cross_river(n, m, d, c)\n```",
    "99": "```python\ndef rock_paper_scissors(n, a, b):\n    a_rock, a_scissors, a_paper = a\n    b_rock, b_scissors, b_paper = b\n\n    # Calculate maximum wins for Alice\n    max_wins = min(a_rock, b_scissors) + min(a_scissors, b_paper) + min(a_paper, b_rock)\n\n    # Calculate minimum wins for Alice\n    # Calculate losses for Alice\n    alice_losses = max(0, b_rock - a_paper) + max(0, b_scissors - a_rock) + max(0, b_paper - a_scissors)\n    min_wins = n - alice_losses\n\n    return min_wins, max_wins\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Get results\nmin_wins, max_wins = rock_paper_scissors(n, a, b)\n\n# Output results\nprint(min_wins, max_wins)\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Create a list of characters with n 'a', n 'b', and n 'c'\n    chars = ['a'] * n + ['b'] * n + ['c'] * n\n    \n    # Function to check if the last two characters form a forbidden substring\n    def is_forbidden(res):\n        return res[-2:] == s or res[-2:] == t\n    \n    # Resultant string\n    res = []\n    \n    # Try to build the result string\n    for char in chars:\n        # If adding the current character would create a forbidden substring\n        while res and is_forbidden(res + [char]):\n            # If we can't add this character, we need to try the next available character\n            if char == 'a':\n                if n > 0:\n                    char = 'b'\n                elif n > 0:\n                    char = 'c'\n                else:\n                    break\n            elif char == 'b':\n                if n > 0:\n                    char = 'a'\n                elif n > 0:\n                    char = 'c'\n                else:\n                    break\n            elif char == 'c':\n                if n > 0:\n                    char = 'a'\n                elif n > 0:\n                    char = 'b'\n                else:\n                    break\n        \n        # If we can add the character, do so\n        if not is_forbidden(res + [char]):\n            res.append(char)\n    \n    # Check if we have a valid result\n    if len(res) == 3 * n:\n        return \"YES\", ''.join(res)\n    else:\n        return \"NO\", \"\"\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\nt = input().strip()\n\n# Generate the string\nresult = generate_string(n, s, t)\n\n# Output the result\nprint(result[0])\nif result[0] == \"YES\":\n    print(result[1])\n```"
}