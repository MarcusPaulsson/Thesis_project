{
    "2": "```python\ndef next_lucky_year(current_year):\n    # Increment the year until we find a lucky year\n    while True:\n        current_year += 1\n        if is_lucky_year(current_year):\n            return current_year - (current_year - 1)\n\ndef is_lucky_year(year):\n    # Convert year to string and count non-zero digits\n    return sum(1 for digit in str(year) if digit != '0') <= 1\n\n# Read input\nn = int(input())\n# Output the result\nprint(next_lucky_year(n))\n```",
    "7": "```python\ndef days_until_empty(n, m):\n    day = 0\n    total_sparrows = 0\n    current_grains = n\n\n    while current_grains > 0:\n        day += 1\n        total_sparrows += day\n        \n        # Add grains to the barn\n        current_grains += m\n        \n        # If the barn exceeds its capacity, it remains full\n        if current_grains > n:\n            current_grains = n\n        \n        # Sparrows eat grains\n        current_grains -= total_sparrows\n        \n    return day\n\n# Input reading\nn, m = map(int, input().split())\nprint(days_until_empty(n, m))\n```",
    "4": "```python\ndef is_lucky_time(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef time_before(hh, mm, minutes):\n    total_minutes = hh * 60 + mm - minutes\n    if total_minutes < 0:\n        total_minutes += 24 * 60\n    return divmod(total_minutes, 60)\n\ndef minimum_snoozes(x, hh, mm):\n    y = 0\n    while True:\n        prev_hh, prev_mm = time_before(hh, mm, x * y)\n        if is_lucky_time(prev_hh, prev_mm):\n            return y\n        y += 1\n\n# Input reading\nx = int(input().strip())\nhh, mm = map(int, input().strip().split())\n\n# Output the result\nprint(minimum_snoozes(x, hh, mm))\n```",
    "6": "```python\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    \n    for query in queries:\n        n, x, blows = query\n        min_blows = float('inf')\n        \n        for d, h in blows:\n            if d >= x:\n                min_blows = min(min_blows, 1)\n            else:\n                effective_heads = d - h\n                if effective_heads > 0:\n                    blows_needed = (x - d + effective_heads - 1) // effective_heads + 1\n                    min_blows = min(min_blows, blows_needed)\n        \n        results.append(min_blows if min_blows != float('inf') else -1)\n    \n    return results\n\n# Example usage:\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\nresults = min_blows_to_defeat_zmei(t, queries)\nfor result in results:\n    print(result)\n```",
    "5": "```python\ndef min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0  # No tabs to close\n\n    seconds = 0\n\n    # Close tabs to the left of l\n    if pos > l:\n        seconds += (pos - l) + 1  # Move to l and close left\n    else:\n        seconds += (l - pos)  # Move to l\n\n    # Close tabs to the right of r\n    if pos < r:\n        seconds += (r - pos) + 1  # Move to r and close right\n    else:\n        seconds += (pos - r)  # Move to r\n\n    return seconds\n\n# Read input\nn, pos, l, r = map(int, input().split())\n# Output the result\nprint(min_seconds_to_close_tabs(n, pos, l, r))\n```",
    "1": "```python\ndef max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n    \n    # Start with the maximum possible number which is x itself\n    max_number = x\n    max_sum = sum(int(d) for d in str_x)\n    \n    # Iterate through each digit to find the best candidate\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit and setting all following digits to 9\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        new_number = int(new_number)\n        \n        if new_number > 0:\n            current_sum = sum(int(d) for d in str(new_number))\n            if current_sum > max_sum or (current_sum == max_sum and new_number > max_number):\n                max_number = new_number\n                max_sum = current_sum\n\n    return max_number\n\nx = int(input())\nprint(max_digit_sum(x))\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    # Create a list to track the painted sections\n    painted = [0] * (n + 1)\n\n    # Function to calculate the number of painted sections\n    def calculate_painted(painters_to_consider):\n        temp_painted = [0] * (n + 1)\n        for l, r in painters_to_consider:\n            for i in range(l, r + 1):\n                temp_painted[i] = 1\n        return sum(temp_painted)\n\n    max_sections = 0\n\n    # Try removing each pair of painters\n    for i in range(q):\n        for j in range(i + 1, q):\n            # Create a list of painters excluding the i-th and j-th\n            painters_to_consider = [painters[k] for k in range(q) if k != i and k != j]\n            # Calculate the number of painted sections with the remaining painters\n            painted_count = calculate_painted(painters_to_consider)\n            max_sections = max(max_sections, painted_count)\n\n    return max_sections\n\n# Input reading\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output the result\nprint(max_painted_sections(n, q, painters))\n```",
    "9": "```python\ndef find_grandpa_sofa(d, n, m, sofas, counts):\n    cnt_l, cnt_r, cnt_t, cnt_b = counts\n    sofas_count = []\n\n    for i in range(d):\n        x1, y1, x2, y2 = sofas[i]\n        left_count = right_count = top_count = bottom_count = 0\n        \n        for j in range(d):\n            if i == j:\n                continue\n            x1_j, y1_j, x2_j, y2_j = sofas[j]\n            if x1 < x1_j:  # Sofa A is to the left of Sofa B\n                left_count += 1\n            if x1_j < x1:  # Sofa B is to the left of Sofa A\n                right_count += 1\n            if y1 < y1_j:  # Sofa A is above Sofa B\n                top_count += 1\n            if y1_j < y1:  # Sofa B is above Sofa A\n                bottom_count += 1\n        \n        if (left_count == cnt_l and right_count == cnt_r and\n                top_count == cnt_t and bottom_count == cnt_b):\n            return i + 1  # Return 1-based index\n\n    return -1\n\n# Input reading\nd = int(input())\nn, m = map(int, input().split())\nsofas = [tuple(map(int, input().split())) for _ in range(d)]\ncounts = tuple(map(int, input().split()))\n\n# Output the result\nprint(find_grandpa_sofa(d, n, m, sofas, counts))\n```",
    "10": "```python\ndef calculate_days_off(n):\n    work_days_per_week = 5\n    days_off_per_week = 2\n    total_days_in_week = work_days_per_week + days_off_per_week\n\n    full_weeks = n // total_days_in_week\n    remaining_days = n % total_days_in_week\n\n    max_days_off = full_weeks * days_off_per_week + min(remaining_days, days_off_per_week)\n    min_days_off = full_weeks * days_off_per_week + (1 if remaining_days > work_days_per_week else 0)\n\n    return min_days_off, max_days_off\n\nn = int(input())\nmin_days_off, max_days_off = calculate_days_off(n)\nprint(min_days_off, max_days_off)\n```",
    "17": "```python\ndef standing_spectators(n, k, t):\n    if t <= k:\n        return t\n    elif t <= n:\n        return k\n    else:\n        return n + k - t\n\n# Input reading\nn, k, t = map(int, input().split())\nprint(standing_spectators(n, k, t))\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    count_a = n // a\n    count_b = n // b\n    count_ab = n // (a * b)  # Tiles that are painted both Red and Blue\n\n    # Calculate the maximum chocolates\n    chocolates_red = count_a * p\n    chocolates_blue = count_b * q\n\n    # Since tiles divisible by both a and b can be painted either color,\n    # we need to choose the better option for those tiles.\n    if p > q:\n        # Paint the overlapping tiles Red\n        chocolates = chocolates_red + (count_b - count_ab) * q\n    else:\n        # Paint the overlapping tiles Blue\n        chocolates = chocolates_blue + (count_a - count_ab) * p\n\n    return chocolates\n\n# Example usage:\n# n, a, b, p, q = map(int, input().split())\n# print(max_chocolates(n, a, b, p, q))\n```",
    "15": "```python\ndef is_favorite_in_sequence(a, b, c):\n    if c == 0:\n        return a == b\n    elif (b - a) % c == 0 and (b - a) // c >= 0:\n        return True\n    return False\n\n# Read input\na, b, c = map(int, input().split())\n\n# Check if b is in the sequence and print the result\nif is_favorite_in_sequence(a, b, c):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "18": "```python\ndef minimal_lexicographic_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        while t:\n            if not u or t[-1] <= u[-1]:\n                u.append(t.pop())\n            else:\n                break\n\n    return ''.join(u)\n\n# Read input\ns = input().strip()\n# Get the result\nresult = minimal_lexicographic_string(s)\n# Print the result\nprint(result)\n```",
    "0": "```python\ndef max_acordion_length(s):\n    # Initialize variables to track the positions of the required characters\n    open_bracket = -1\n    first_colon = -1\n    last_colon = -1\n    close_bracket = -1\n    \n    # Iterate through the string to find the required characters\n    for i, char in enumerate(s):\n        if char == '[' and open_bracket == -1:\n            open_bracket = i\n        elif char == ':' and open_bracket != -1 and first_colon == -1:\n            first_colon = i\n        elif char == ':' and first_colon != -1:\n            last_colon = i\n        elif char == ']' and last_colon != -1 and close_bracket == -1:\n            close_bracket = i\n    \n    # Check if we found all necessary parts of the accordion\n    if open_bracket == -1 or first_colon == -1 or last_colon == -1 or close_bracket == -1:\n        return -1\n    \n    # Calculate the maximum length of the accordion\n    vertical_lines = last_colon - first_colon - 1\n    max_length = 4 + vertical_lines  # 4 for the brackets and colons\n    \n    return max_length\n\n# Read input\ns = input().strip()\n# Output the result\nprint(max_acordion_length(s))\n```",
    "8": "```python\ndef min_tiles_to_draw(tiles):\n    suits = {'m': [], 'p': [], 's': []}\n    \n    # Organize tiles by suit\n    for tile in tiles:\n        number = int(tile[0])\n        suit = tile[1]\n        suits[suit].append(number)\n    \n    # Check for koutsu (triplet)\n    for suit in suits:\n        if len(suits[suit]) == 3 and len(set(suits[suit])) == 1:\n            return 0  # Already has a koutsu\n    \n    # Check for shuntsu (sequence)\n    for suit in suits:\n        numbers = sorted(suits[suit])\n        if len(numbers) >= 3:\n            for i in range(len(numbers) - 2):\n                if numbers[i] + 1 == numbers[i + 1] and numbers[i] + 2 == numbers[i + 2]:\n                    return 0  # Already has a shuntsu\n    \n    # Check for potential shuntsu with one draw\n    for suit in suits:\n        numbers = sorted(suits[suit])\n        for number in numbers:\n            if number - 1 >= 1 and number + 1 <= 9:\n                if (number - 1 in numbers) or (number + 1 in numbers):\n                    return 1  # Can form a shuntsu with one draw\n    \n    # If no mentsu can be formed with one draw, check for two draws\n    for suit in suits:\n        if len(suits[suit]) == 2:\n            if abs(suits[suit][0] - suits[suit][1]) == 1:\n                return 1  # Can form a shuntsu with one draw\n            if (suits[suit][0] == 1 and suits[suit][1] == 2) or (suits[suit][0] == 8 and suits[suit][1] == 9):\n                return 1  # Can form a shuntsu with one draw\n            if (suits[suit][0] == 2 and suits[suit][1] == 3) or (suits[suit][0] == 7 and suits[suit][1] == 8):\n                return 1  # Can form a shuntsu with one draw\n    \n    return 2  # Otherwise, need two draws\n\n# Read input\ntiles = input().strip().split()\n# Output the result\nprint(min_tiles_to_draw(tiles))\n```",
    "16": "```python\ndef can_form_regular_bracket_sequence(cnt1, cnt2, cnt3, cnt4):\n    # Calculate the total number of opening and closing brackets\n    total_open = cnt1 + cnt2\n    total_close = cnt2 + cnt4\n    \n    # Check if the number of opening and closing brackets can balance each other\n    if total_open < total_close:\n        return 0\n    \n    # Calculate the excess closing brackets\n    excess_close = cnt3 + cnt4 - cnt1\n    \n    # If there are more excess closing brackets than opening brackets, it's not possible\n    if excess_close > total_open:\n        return 0\n    \n    return 1\n\n# Read input values\ncnt1 = int(input().strip())\ncnt2 = int(input().strip())\ncnt3 = int(input().strip())\ncnt4 = int(input().strip())\n\n# Output the result\nprint(can_form_regular_bracket_sequence(cnt1, cnt2, cnt3, cnt4))\n```",
    "12": "```python\ndef max_beauty_after_swap(n, trophies):\n    # Find the longest segment of golden trophies\n    max_length = 0\n    current_length = 0\n    segments = []\n\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n                max_length = max(max_length, current_length)\n            current_length = 0\n\n    if current_length > 0:\n        segments.append(current_length)\n        max_length = max(max_length, current_length)\n\n    # If there are no golden trophies\n    if max_length == 0:\n        return 0\n\n    # Calculate the maximum possible length after one swap\n    if len(segments) == 1:\n        return max_length  # Only one segment of golden trophies\n\n    # Check the potential maximum length by swapping\n    max_possible_length = max_length\n    for i in range(len(segments) - 1):\n        # If we swap a silver trophy between two segments of golden trophies\n        max_possible_length = max(max_possible_length, segments[i] + segments[i + 1])\n\n    return max_possible_length\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\nprint(max_beauty_after_swap(n, trophies))\n```",
    "19": "```python\ndef check_records(test_cases):\n    results = []\n    \n    for case in test_cases:\n        n = case[0]\n        records = case[1]\n        \n        valid = True\n        prev_p, prev_c = 0, 0\n        \n        for p, c in records:\n            if p < prev_p or c < prev_c or c > p:\n                valid = False\n                break\n            if p - prev_p < c - prev_c:\n                valid = False\n                break\n            \n            prev_p, prev_c = p, c\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Read input\nT = int(input())\ntest_cases = []\n\nfor _ in range(T):\n    n = int(input())\n    records = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, records))\n\n# Get results\nresults = check_records(test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "20": "```python\ndef is_palindrome(time_str):\n    return time_str == time_str[::-1]\n\ndef next_palindrome_time(hh, mm):\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return time_str\n\ndef minutes_to_palindrome(current_time):\n    hh, mm = map(int, current_time.split(':'))\n    minutes = 0\n    while True:\n        if is_palindrome(f\"{hh:02}:{mm:02}\"):\n            return minutes\n        mm += 1\n        minutes += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n\nif __name__ == \"__main__\":\n    current_time = input().strip()\n    print(minutes_to_palindrome(current_time))\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef find_course_order(n, k, main_courses, dependencies):\n    # Build the graph and in-degree count\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        for dep in dependencies[i - 1]:\n            graph[dep].append(i)\n            in_degree[i] += 1\n    \n    # Queue for courses that can be taken (in-degree 0)\n    queue = deque()\n    for course in range(1, n + 1):\n        if in_degree[course] == 0:\n            queue.append(course)\n    \n    order = []\n    courses_taken = set()\n    \n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        courses_taken.add(course)\n        \n        for next_course in graph[course]:\n            in_degree[next_course] -= 1\n            if in_degree[next_course] == 0:\n                queue.append(next_course)\n    \n    # Check if all main courses can be taken\n    if not all(course in courses_taken for course in main_courses):\n        return -1\n    \n    # Collect all courses needed to take\n    needed_courses = set(main_courses)\n    for course in main_courses:\n        needed_courses.update(get_dependencies(course, graph, courses_taken))\n    \n    # Filter the order to only include needed courses\n    final_order = [course for course in order if course in needed_courses]\n    \n    return len(final_order), final_order\n\ndef get_dependencies(course, graph, courses_taken):\n    dependencies = set()\n    queue = deque([course])\n    \n    while queue:\n        current = queue.popleft()\n        for next_course in graph[current]:\n            if next_course not in courses_taken:\n                dependencies.add(next_course)\n                queue.append(next_course)\n    \n    return dependencies\n\n# Input reading\nn, k = map(int, input().split())\nmain_courses = list(map(int, input().split()))\ndependencies = [list(map(int, input().split()[1:])) for _ in range(n)]\n\n# Find the course order\nresult = find_course_order(n, k, main_courses, dependencies)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    m, order = result\n    print(m)\n    print(' '.join(map(str, order)))\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a, b):\n    from itertools import permutations\n\n    # Convert a to a string to work with its digits\n    str_a = str(a)\n    str_b = str(b)\n\n    # Generate all unique permutations of the digits of a\n    permuted_numbers = set(int(''.join(p)) for p in permutations(str_a))\n\n    # Filter out numbers that exceed b and have the same length as a\n    valid_numbers = [num for num in permuted_numbers if num <= b and len(str(num)) == len(str_a)]\n\n    # Return the maximum valid number\n    return max(valid_numbers)\n\n# Read input\na = int(input().strip())\nb = int(input().strip())\n\n# Get the result and print it\nresult = max_permutation_not_exceeding(a, b)\nprint(result)\n```",
    "21": "```python\ndef max_distance_after_swap(n, a):\n    min_index = a.index(1)\n    max_index = a.index(n)\n\n    # Calculate current distance\n    current_distance = abs(min_index - max_index)\n\n    # Possible new positions after swap\n    new_positions = [\n        (0, max_index),  # Swap min with first element\n        (n - 1, max_index),  # Swap min with last element\n        (min_index, 0),  # Swap max with first element\n        (min_index, n - 1)  # Swap max with last element\n    ]\n\n    max_distance = current_distance\n\n    for new_pos in new_positions:\n        new_min_index, new_max_index = new_pos\n        max_distance = max(max_distance, abs(new_min_index - new_max_index))\n\n    return max_distance\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_distance_after_swap(n, a))\n```",
    "14": "```python\ndef is_stack_sortable(n, k, p):\n    # Create a set for the elements already in p\n    present = set(p)\n    # Initialize the result array with the first k elements\n    result = p[:]\n    \n    # Initialize the next number to be placed in the permutation\n    next_num = n\n    \n    # Initialize a stack to simulate the stack operations\n    stack = []\n    \n    # Iterate through the first k elements\n    for i in range(k):\n        # While the stack is not empty and the top of the stack is less than the next number\n        while stack and stack[-1] < next_num:\n            result.append(stack.pop())\n        \n        # If the current element is not the next number, we need to fill the stack\n        if p[i] < next_num:\n            # Push numbers onto the stack until we reach the current element\n            while next_num > p[i]:\n                if next_num not in present:\n                    stack.append(next_num)\n                next_num -= 1\n        \n        # If the current element is not the next number, it's impossible to sort\n        if p[i] != next_num:\n            return -1\n        \n        # Move to the next number\n        next_num -= 1\n    \n    # After processing the first k elements, we need to empty the stack\n    while stack:\n        result.append(stack.pop())\n    \n    # Check if the result is a valid permutation\n    if len(result) != n or len(set(result)) != n:\n        return -1\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result\nresult = is_stack_sortable(n, k, p)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "22": "```python\ndef is_s_palindrome(s):\n    mirror_chars = {\n        'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M',\n        'O': 'O', 'p': 'q', 'q': 'p', 'T': 'T', 'U': 'U', 'v': 'v',\n        'V': 'V', 'w': 'w', 'X': 'X', 'Y': 'Y', 'o': 'o', 'x': 'x'\n    }\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        if s[i] not in mirror_chars or mirror_chars[s[i]] != s[n - 1 - i]:\n            return \"NIE\"\n    return \"TAK\"\n\ns = input().strip()\nprint(is_s_palindrome(s))\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    if k > n * n or (k % 2 != 0 and n % 2 == 0):\n        return -1\n\n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k <= 0:\n            break\n        # Place 1s on the diagonal\n        if k > 0:\n            matrix[i][i] = 1\n            k -= 1\n        \n        # Place 1s in the upper triangle\n        for j in range(i + 1, n):\n            if k >= 2:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n            \n            if k <= 0:\n                break\n\n    if k > 0:\n        return -1\n\n    return matrix\n\n# Read input\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\n# Output result\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "27": "```python\ndef min_operations(n, s):\n    # Start with the assumption that we will type all characters one by one\n    min_ops = n\n    \n    # Check for possible copy operations\n    for i in range(1, n):\n        # If the prefix of length i is equal to the suffix of length i\n        if s[:i] == s[i:2*i]:\n            # Calculate operations: type i characters, copy, and type the rest\n            min_ops = min(min_ops, i + 1 + (n - 2 * i))\n    \n    return min_ops\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(min_operations(n, s))\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # Since GCD(x, m) = 1, the x-mouse will visit all rooms\n    # except for the room 0, which it will visit only if it starts there.\n    # The number of unique rooms visited is equal to m - 1.\n    \n    # The minimum number of traps needed is m - 1 + 1 (for room 0)\n    return m\n\n# Read input\nm, x = map(int, input().split())\n# Output the result\nprint(minimum_traps(m, x))\n```",
    "26": "```python\ndef calculate_expressions(x, y, z):\n    expressions = [\n        (x ** (y ** z), \"x^y^z\"),\n        (x ** (z ** y), \"x^z^y\"),\n        ((x ** y) ** z, \"(x^y)^z\"),\n        ((x ** z) ** y, \"(x^z)^y\"),\n        (y ** (x ** z), \"y^x^z\"),\n        (y ** (z ** x), \"y^z^x\"),\n        ((y ** x) ** z, \"(y^x)^z\"),\n        ((y ** z) ** x, \"(y^z)^x\"),\n        (z ** (x ** y), \"z^x^y\"),\n        (z ** (y ** x), \"z^y^x\"),\n        ((z ** x) ** y, \"(z^x)^y\"),\n        ((z ** y) ** x, \"(z^y)^x\"),\n    ]\n    \n    max_value = float('-inf')\n    max_index = -1\n    \n    for index, (value, expr) in enumerate(expressions):\n        if value > max_value:\n            max_value = value\n            max_index = index\n            \n    return expressions[max_index][1]\n\n# Read input\nx, y, z = map(float, input().split())\nresult = calculate_expressions(x, y, z)\nprint(result)\n```",
    "24": "```python\ndef can_win_in_one_turn(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # vertical, horizontal, diagonal down-right, diagonal down-left\n    n = 10  # size of the board\n\n    def check_win(x, y):\n        for dx, dy in directions:\n            count = 1  # count the current position\n            # Check in the positive direction\n            for step in range(1, 5):\n                nx, ny = x + step * dx, y + step * dy\n                if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                    count += 1\n                else:\n                    break\n            # Check in the negative direction\n            for step in range(1, 5):\n                nx, ny = x - step * dx, y - step * dy\n                if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                    count += 1\n                else:\n                    break\n            if count >= 5:\n                return True\n        return False\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                board[i][j] = 'X'  # Place a cross\n                if check_win(i, j):\n                    return \"YES\"\n                board[i][j] = '.'  # Revert back\n\n    return \"NO\"\n\n# Input reading\nboard = [input().strip() for _ in range(10)]\nprint(can_win_in_one_turn(board))\n```",
    "28": "```python\ndef rename_files(n, files):\n    examples = []\n    regulars = []\n    \n    for name, type_ in files:\n        if type_ == '1':\n            examples.append(name)\n        else:\n            regulars.append(name)\n    \n    moves = []\n    # Rename examples to 1, 2, ..., e\n    for i in range(len(examples)):\n        moves.append(f\"move {examples[i]} {i + 1}\")\n    \n    # Rename regular tests to e + 1, e + 2, ..., n\n    for i in range(len(regulars)):\n        moves.append(f\"move {regulars[i]} {len(examples) + i + 1}\")\n    \n    return len(moves), moves\n\n# Input reading\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\n# Get the result\nnum_moves, move_commands = rename_files(n, files)\n\n# Output the result\nprint(num_moves)\nfor command in move_commands:\n    print(command)\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    def can_distribute(x):\n        plates_from_a = a // x\n        plates_from_b = b // x\n        return plates_from_a + plates_from_b >= n\n\n    left, right = 1, max(a, b)\n    result = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_distribute(mid):\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n\n# Input reading\nn, a, b = map(int, input().split())\nprint(max_min_pieces(n, a, b))\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef birthday_paradox(n, k):\n    MOD = 1000003\n    days = 1 << n  # 2^n days\n    if k > days:\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the probability of no shared birthdays\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator *= (days - i)\n        denominator *= days\n        numerator %= MOD\n        denominator %= MOD\n\n    # Probability of at least one shared birthday\n    A = (denominator - numerator) % MOD\n    B = denominator\n\n    # Reduce A/B to irreducible form\n    common_divisor = gcd(A, B)\n    A //= common_divisor\n    B //= common_divisor\n\n    return A % MOD, B % MOD\n\n# Read input\nn, k = map(int, input().split())\nresult = birthday_paradox(n, k)\nprint(result[0], result[1])\n```",
    "37": "```python\ndef can_break_shield(a, b, c):\n    for x in range(c // a + 1):\n        if (c - a * x) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Input reading\na, b, c = map(int, input().split())\nprint(can_break_shield(a, b, c))\n```",
    "29": "```python\ndef min_replacements_to_lucky(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    # Calculate the difference\n    diff = abs(sum_first - sum_second)\n    \n    # Create a list of possible changes\n    changes = []\n    \n    if sum_first > sum_second:\n        # We need to decrease the first half or increase the second half\n        changes = [9 - digit for digit in first_half] + [digit for digit in second_half]\n    else:\n        # We need to increase the first half or decrease the second half\n        changes = [digit for digit in first_half] + [9 - digit for digit in second_half]\n    \n    # Sort changes in descending order\n    changes.sort(reverse=True)\n    \n    count = 0\n    for change in changes:\n        diff -= change\n        count += 1\n        if diff <= 0:\n            break\n    \n    return count\n\n# Example usage:\nticket = input().strip()\nprint(min_replacements_to_lucky(ticket))\n```",
    "32": "```python\ndef is_valid_journey(n, journey):\n    position = 0  # Start at the North Pole (0 km)\n    \n    for t, direction in journey:\n        if position == 0 and direction != \"South\":\n            return \"NO\"  # At North Pole, can only move South\n        if position == 20000 and direction != \"North\":\n            return \"NO\"  # At South Pole, can only move North\n        \n        if direction == \"South\":\n            position += t\n        elif direction == \"North\":\n            position -= t\n        elif direction in [\"West\", \"East\"]:\n            # Moving West or East does not change the position in km\n            continue\n        \n        if position < 0 or position > 20000:\n            return \"NO\"  # Out of bounds\n        \n    return \"YES\" if position == 0 else \"NO\"  # Must end at North Pole\n\n# Input reading\nn = int(input())\njourney = [tuple(input().split()) for _ in range(n)]\njourney = [(int(t), dir) for t, dir in journey]\n\n# Output result\nprint(is_valid_journey(n, journey))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    \n    # If the entire string is not a palindrome, return its length\n    if not is_palindrome(s):\n        return n\n    \n    # Check for the longest non-palindrome substring\n    for length in range(n - 1, 0, -1):\n        for start in range(n - length + 1):\n            substring = s[start:start + length]\n            if not is_palindrome(substring):\n                return length\n    \n    return 0\n\n# Read input\ns = input().strip()\n# Output the result\nprint(longest_non_palindrome_substring(s))\n```",
    "36": "```python\ndef get_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 1\n\n    while n >= moves_in_layer:\n        n -= moves_in_layer\n        layer += 1\n        moves_in_layer = 6 * layer\n\n    x, y = layer, 0\n\n    if n == 0:\n        return (x, y)\n\n    directions = [\n        (1, 0),  # right\n        (0, 1),  # top-right\n        (-1, 1), # top-left\n        (-1, 0), # left\n        (0, -1), # bottom-left\n        (1, -1)  # bottom-right\n    ]\n\n    for i in range(n):\n        direction = i % 6\n        x += directions[direction][0]\n        y += directions[direction][1]\n\n    return (x, y)\n\nn = int(input().strip())\nx, y = get_coordinates(n)\nprint(x, y)\n```",
    "38": "```python\ndef can_coincide_tracks(n, L, kefa_distances, sasha_distances):\n    # Calculate the differences between consecutive barriers for both Kefa and Sasha\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Double the kefa_diffs to account for circular nature\n    kefa_diffs_extended = kefa_diffs * 2\n    \n    # Check if sasha_diffs can be found in the extended kefa_diffs\n    for i in range(n):\n        if kefa_diffs_extended[i:i + n] == sasha_diffs:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output result\nprint(can_coincide_tracks(n, L, kefa_distances, sasha_distances))\n```",
    "40": "```python\ndef determine_round_rating(n, ratings):\n    rated = False\n    unrated = False\n    \n    for i in range(n):\n        if ratings[i][0] != ratings[i][1]:\n            rated = True\n            break\n    \n    if rated:\n        print(\"rated\")\n        return\n    \n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            unrated = True\n            break\n    \n    if unrated:\n        print(\"unrated\")\n    else:\n        print(\"maybe\")\n\n# Input reading\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\ndetermine_round_rating(n, ratings)\n```",
    "35": "```python\ndef is_valid_flag(n, m, flag):\n    colors = {'R', 'G', 'B'}\n    \n    # Check for horizontal stripes\n    stripe_height = n // 3\n    if n % 3 != 0 or stripe_height == 0:\n        return \"NO\"\n    \n    used_colors = set()\n    for i in range(3):\n        stripe_color = flag[i * stripe_height][0]\n        if stripe_color not in colors or stripe_color in used_colors:\n            return \"NO\"\n        used_colors.add(stripe_color)\n        for j in range(stripe_height):\n            if flag[i * stripe_height + j] != stripe_color * m:\n                return \"NO\"\n    \n    return \"YES\" if len(used_colors) == 3 else \"NO\"\n\ndef main():\n    n, m = map(int, input().split())\n    flag = [input().strip() for _ in range(n)]\n    \n    # Check for vertical stripes\n    if m % 3 == 0:\n        stripe_width = m // 3\n        used_colors = set()\n        for i in range(3):\n            stripe_color = flag[0][i * stripe_width]\n            if stripe_color not in {'R', 'G', 'B'} or stripe_color in used_colors:\n                print(\"NO\")\n                return\n            used_colors.add(stripe_color)\n            for row in flag:\n                if row[i * stripe_width:(i + 1) * stripe_width] != stripe_color * stripe_width:\n                    print(\"NO\")\n                    return\n        print(\"YES\" if len(used_colors) == 3 else \"NO\")\n    else:\n        print(is_valid_flag(n, m, flag))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from itertools import product\n\n    # Function to check if s is a substring in any cyclic shift of t\n    def contains_as_substring(t, s):\n        doubled_t = t + t  # Create a doubled version of t to check cyclic shifts\n        return s in doubled_t\n\n    # Generate all possible binary strings of length n\n    all_strings = [''.join(p) for p in product('01', repeat=n)]\n    \n    # Count distinct cyclic strings containing s as a substring\n    distinct_cyclic_strings = set()\n    \n    for t in all_strings:\n        if contains_as_substring(t, s):\n            distinct_cyclic_strings.add(t)\n\n    return len(distinct_cyclic_strings)\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_cyclic_strings(n, s))\n```",
    "33": "```python\ndef count_common_ap(a1, b1, a2, b2, L, R):\n    def find_first_valid(start, step, limit):\n        if step == 0:\n            return start if start <= limit else None\n        if start > limit:\n            return None\n        return start + ((limit - start) // step) * step\n\n    def find_last_valid(start, step, limit):\n        if step == 0:\n            return start if start >= limit else None\n        if start < limit:\n            return None\n        return start - ((start - limit) // step) * step\n\n    # Calculate the first and last valid x in the range [L, R]\n    first_x = find_first_valid(b1, a1, R)\n    last_x = find_last_valid(b2, a2, L)\n\n    if first_x is None or last_x is None or first_x > last_x:\n        return 0\n\n    # Now we need to find the common values in the arithmetic sequences\n    # We can express the common values as:\n    # x = a1 * k' + b1 = a2 * l' + b2\n    # Rearranging gives us:\n    # a1 * k' - a2 * l' = b2 - b1\n    # This is a linear Diophantine equation.\n\n    d = b2 - b1\n    step = a2 // gcd(a1, a2)\n\n    # Find the first valid k' for the equation\n    k_start = (d + a2 - 1) // a2 if d > 0 else d // a2\n    k_end = (R - b1) // a1\n\n    if k_start > k_end:\n        return 0\n\n    # Count the number of valid k'\n    count = (k_end - k_start) // step + 1\n    return count\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return abs(x)\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\nresult = count_common_ap(a1, b1, a2, b2, L, R)\nprint(result)\n```",
    "46": "```python\ndef count_divisible_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n\n    # Count occurrences of each remainder when divided by 5 for x\n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n\n    # Count occurrences of each remainder when divided by 5 for y\n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n\n    # Calculate the number of valid pairs\n    result = 0\n    for i in range(5):\n        result += count_x[i] * count_y[(5 - i) % 5]\n\n    return result\n\n# Read input\nn, m = map(int, input().split())\n# Print the result\nprint(count_divisible_pairs(n, m))\n```",
    "44": "```python\ndef minimal_time_to_post_office(d, k, a, b, t):\n    # Calculate the number of full segments Vasiliy can drive\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Time spent driving full segments\n    time_driving_segments = full_segments * (k * a)\n    \n    # Time spent repairing the car after each full segment (except the last one)\n    time_repairing_segments = full_segments * t if full_segments > 0 else 0\n    \n    # Time spent driving the remaining distance\n    time_driving_remaining = remaining_distance * a\n    \n    # Total time if he drives the full distance\n    total_time_driving = time_driving_segments + time_repairing_segments + time_driving_remaining\n    \n    # Total time if he walks the entire distance\n    total_time_walking = d * b\n    \n    # The minimal time will be the minimum of both strategies\n    return min(total_time_driving, total_time_walking)\n\n# Example usage\nd, k, a, b, t = map(int, input().split())\nprint(minimal_time_to_post_office(d, k, a, b, t))\n```",
    "43": "```python\nimport sys\nimport math\n\ndef minimal_angle_pair(vectors):\n    angles = []\n    \n    for i, (x, y) in enumerate(vectors):\n        angle = math.atan2(y, x)\n        angles.append((angle, i + 1))  # Store angle and index (1-based)\n\n    # Sort angles\n    angles.sort()\n\n    # Add the first angle + 2Ï€ to handle the circular nature\n    angles.append((angles[0][0] + 2 * math.pi, angles[0][1]))\n\n    min_angle = float('inf')\n    min_pair = (0, 0)\n\n    # Find the minimal angle between consecutive vectors\n    for i in range(len(angles) - 1):\n        angle1, index1 = angles[i]\n        angle2, index2 = angles[i + 1]\n        angle_diff = angle2 - angle1\n        \n        if angle_diff < min_angle:\n            min_angle = angle_diff\n            min_pair = (index1, index2)\n\n    return min_pair\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    vectors = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n    \n    result = minimal_angle_pair(vectors)\n    print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Minimum sum of first k positive integers\n    min_sum = k * (k + 1) // 2\n    \n    if n < min_sum:\n        return -1\n    \n    # The maximum GCD we can use is n // k\n    max_gcd = n // k\n    \n    # Start with the first k positive integers multiplied by max_gcd\n    sequence = [i * max_gcd for i in range(1, k + 1)]\n    \n    # Calculate the current sum of the sequence\n    current_sum = sum(sequence)\n    \n    # Adjust the last element to match the required sum n\n    sequence[-1] += n - current_sum\n    \n    # Check if the last element is still greater than the previous one\n    if sequence[-1] <= sequence[-2]:\n        return -1\n    \n    return sequence\n\n# Input reading\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\n# Output result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "41": "```python\ndef nearest_zero_distance(n, arr):\n    distances = [float('inf')] * n\n    last_zero_index = -1\n\n    # Forward pass to find distances to the nearest zero on the left\n    for i in range(n):\n        if arr[i] == 0:\n            last_zero_index = i\n            distances[i] = 0\n        elif last_zero_index != -1:\n            distances[i] = i - last_zero_index\n\n    # Backward pass to find distances to the nearest zero on the right\n    last_zero_index = -1\n    for i in range(n - 1, -1, -1):\n        if arr[i] == 0:\n            last_zero_index = i\n        elif last_zero_index != -1:\n            distances[i] = min(distances[i], last_zero_index - i)\n\n    return distances\n\n# Input reading\nn = int(input().strip())\narr = list(map(int, input().strip().split()))\n\n# Get the result and print it\nresult = nearest_zero_distance(n, arr)\nprint(' '.join(map(str, result)))\n```",
    "48": "```python\ndef kth_largest_in_multiplication_table(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(x // i, m)\n        return count\n\n    left, right = 1, n * m\n    while left < right:\n        mid = (left + right) // 2\n        if count_less_equal(mid) < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Input reading\nn, m, k = map(int, input().split())\n# Output the result\nprint(kth_largest_in_multiplication_table(n, m, k))\n```",
    "56": "```python\ndef remove_trailing_zeros(x):\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef reachable_count(n):\n    reachable_numbers = set()\n    current = n\n    \n    while current not in reachable_numbers:\n        reachable_numbers.add(current)\n        current = remove_trailing_zeros(current + 1)\n    \n    return len(reachable_numbers)\n\nn = int(input())\nprint(reachable_count(n))\n```",
    "54": "```python\ndef min_D_to_equalize(n, a):\n    min_a = min(a)\n    max_a = max(a)\n\n    if max_a == min_a:\n        return 0\n\n    # Calculate the possible D values\n    possible_D = (max_a - min_a) // 2\n\n    # Check if we can achieve equality with this D\n    if (max_a - min_a) % 2 == 0:\n        return possible_D\n    else:\n        return -1\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_D_to_equalize(n, a))\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_elements = m // 2\n    dp = [[-1] * k for _ in range(n + 1)]\n    dp[0][0] = 0  # Base case: sum of 0 is divisible by k\n\n    for i in range(1, n + 1):\n        row = sorted(matrix[i - 1], reverse=True)\n        current_dp = dp[i - 1][:]  # Copy previous row dp\n\n        for j in range(1, max_elements + 1):\n            if j > len(row):\n                break\n            \n            current_sum = sum(row[:j])\n            for mod in range(k):\n                if current_dp[mod] != -1:\n                    new_sum = current_dp[mod] + current_sum\n                    new_mod = new_sum % k\n                    current_dp[new_mod] = max(current_dp[new_mod], new_sum)\n\n        dp[i] = current_dp\n\n    return max(dp[n])\n\n# Input reading\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_sum_divisible_by_k(n, m, k, matrix))\n```",
    "59": "```python\ndef min_operations_to_remainder(n, x, y, number):\n    # Calculate the target pattern based on y\n    target = ['0'] * x\n    target[y] = '1'\n    \n    # Count the number of operations needed\n    operations = 0\n    for i in range(x):\n        if number[n - 1 - i] != target[x - 1 - i]:\n            operations += 1\n            \n    return operations\n\n# Input reading\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# Calculate and print the result\nresult = min_operations_to_remainder(n, x, y, number)\nprint(result)\n```",
    "49": "```python\ndef find_kth_digit(k):\n    digit_length = 1\n    count = 9\n    start = 1\n\n    # Determine the range where the k-th digit lies\n    while k > digit_length * count:\n        k -= digit_length * count\n        digit_length += 1\n        count *= 10\n        start *= 10\n\n    # Find the actual number containing the k-th digit\n    start += (k - 1) // digit_length\n    number_str = str(start)\n    \n    # Find the specific digit\n    digit_index = (k - 1) % digit_length\n    return number_str[digit_index]\n\n# Read input\nk = int(input().strip())\n# Output the k-th digit\nprint(find_kth_digit(k))\n```",
    "55": "```python\ndef can_see_white_sheet(white, black1, black2):\n    x1, y1, x2, y2 = white\n    x3, y3, x4, y4 = black1\n    x5, y5, x6, y6 = black2\n\n    # Check if any part of the white sheet is visible\n    visible = (\n        (x2 <= x3 or x4 <= x1 or y2 <= y3 or y4 <= y1) or  # White is completely to the left, right, above or below black1\n        (x2 <= x5 or x6 <= x1 or y2 <= y5 or y6 <= y1)    # White is completely to the left, right, above or below black2\n    )\n    \n    return \"YES\" if visible else \"NO\"\n\n# Read input\nwhite_sheet = list(map(int, input().split()))\nblack_sheet1 = list(map(int, input().split()))\nblack_sheet2 = list(map(int, input().split()))\n\n# Output result\nprint(can_see_white_sheet(white_sheet, black_sheet1, black_sheet2))\n```",
    "47": "```python\ndef max_subarray_sum(arr):\n    max_sum = 0\n    current_sum = 0\n    for num in arr:\n        current_sum += num\n        if current_sum < 0:\n            current_sum = 0\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef max_beauty_with_multiplier(n, x, a):\n    # Calculate the original beauty of the array\n    original_beauty = max_subarray_sum(a)\n    \n    # If x is 0, the best we can do is the original beauty\n    if x == 0:\n        return original_beauty\n    \n    # Calculate the maximum beauty after applying the multiplier\n    max_beauty = original_beauty\n    for i in range(n):\n        # We will consider subarrays starting from index i\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += a[j]\n            # Calculate the beauty if we multiply the subarray a[i:j+1] by x\n            modified_sum = current_sum * x\n            # Calculate the beauty of the remaining parts\n            left_sum = max_subarray_sum(a[:i])\n            right_sum = max_subarray_sum(a[j+1:])\n            total_beauty = left_sum + modified_sum + right_sum\n            max_beauty = max(max_beauty, total_beauty)\n    \n    return max_beauty\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_beauty_with_multiplier(n, x, a))\n```",
    "51": "```python\ndef find_x_y(n, divisors):\n    from collections import Counter\n    \n    # Count the occurrences of each divisor\n    count = Counter(divisors)\n    \n    # The maximum divisor must be either x or y\n    max_divisor = max(count)\n    \n    # Initialize x and y\n    x = max_divisor\n    y = 1\n    \n    # Iterate through the divisors to find y\n    for d in count:\n        if count[d] == 1:  # If the divisor appears only once, it belongs to y\n            y *= d\n        elif count[d] == 2:  # If it appears twice, it belongs to both x and y\n            continue\n    \n    return x, y\n\n# Input reading\nn = int(input())\ndivisors = list(map(int, input().split()))\n\n# Find x and y\nx, y = find_x_y(n, divisors)\n\n# Output the result\nprint(x, y)\n```",
    "58": "```python\ndef color_array(n, k, a):\n    from collections import defaultdict\n    \n    # Dictionary to keep track of the colors assigned to each number\n    color_map = defaultdict(list)\n    result = [0] * n\n    \n    # Assign colors to each element in the array\n    for i in range(n):\n        num = a[i]\n        # Get the current color to assign\n        current_color = len(color_map[num]) % k + 1\n        color_map[num].append(current_color)\n        result[i] = current_color\n    \n    # Check if we have at least one of each color\n    if len(set(result)) < k:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, result)))\n\n# Example usage:\n# n, k = map(int, input().split())\n# a = list(map(int, input().split()))\n# color_array(n, k, a)\n```",
    "57": "```python\ndef fill_gift_preferences(n, f):\n    # Create a list to store the final gift preferences\n    nf = f[:]\n    \n    # Find the friends who have not decided whom to give gifts to\n    undecided = [i + 1 for i in range(n) if f[i] == 0]\n    \n    # Find the friends who are already chosen as gift recipients\n    chosen = set(fi for fi in f if fi != 0)\n    \n    # Find the friends who are not chosen by anyone\n    not_chosen = [i + 1 for i in range(1, n + 1) if i not in chosen]\n    \n    # Fill in the undecided friends\n    for i in range(len(undecided)):\n        giver = undecided[i]\n        receiver = not_chosen[i]\n        \n        # Ensure that the giver does not give a gift to themselves\n        if giver == receiver:\n            # If they are the same, swap with the next one\n            if i + 1 < len(not_chosen):\n                receiver = not_chosen[i + 1]\n                not_chosen[i + 1] = not_chosen[i]  # Swap to maintain the list\n            else:\n                receiver = not_chosen[i - 1]  # Use the previous one if at the end\n        \n        nf[giver - 1] = receiver\n    \n    return nf\n\n# Read input\nn = int(input())\nf = list(map(int, input().split()))\n\n# Get the result\nresult = fill_gift_preferences(n, f)\n\n# Print the result\nprint(' '.join(map(str, result)))\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = -1\n    moves = []\n    \n    while left <= right:\n        if a[left] > last_taken and (a[right] <= last_taken or a[left] < a[right]):\n            moves.append('L')\n            last_taken = a[left]\n            left += 1\n        elif a[right] > last_taken:\n            moves.append('R')\n            last_taken = a[right]\n            right -= 1\n        else:\n            break\n\n    print(len(moves))\n    print(''.join(moves))\n\n# Example usage:\n# n = int(input())\n# a = list(map(int, input().split()))\n# longest_increasing_sequence(n, a)\n```",
    "63": "```python\ndef min_instability(n, a):\n    a.sort()\n    # The minimum instability can be achieved by removing either the first or the last element\n    instability_remove_min = a[-1] - a[1]  # Remove the minimum element\n    instability_remove_max = a[-2] - a[0]  # Remove the maximum element\n    return min(instability_remove_min, instability_remove_max)\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_instability(n, a))\n```",
    "61": "```python\ndef max_number_after_replacement(n, a, f):\n    a_list = list(a)\n    modified = False\n\n    for i in range(n):\n        original_digit = int(a_list[i])\n        new_digit = f[original_digit - 1]\n        \n        if new_digit > original_digit and not modified:\n            # Start replacing\n            modified = True\n            a_list[i] = str(new_digit)\n        elif new_digit < original_digit and modified:\n            # Stop replacing if we encounter a digit that doesn't improve the number\n            break\n        elif modified:\n            # Continue replacing if we are in a modification phase\n            a_list[i] = str(new_digit)\n\n    return ''.join(a_list)\n\n# Input reading\nn = int(input())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\n# Get the result and print it\nresult = max_number_after_replacement(n, a, f)\nprint(result)\n```",
    "60": "```python\ndef has_palindrome_subsequence(test_cases):\n    results = []\n    for n, a in test_cases:\n        found = False\n        # Use a dictionary to track the last seen index of each number\n        last_seen = {}\n        \n        for i in range(n):\n            if a[i] in last_seen:\n                # Check if we can form a palindrome with the current and last seen index\n                if i - last_seen[a[i]] >= 2:\n                    found = True\n                    break\n            last_seen[a[i]] = i\n        \n        results.append(\"YES\" if found else \"NO\")\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Get results and print them\nresults = has_palindrome_subsequence(test_cases)\nfor result in results:\n    print(result)\n```",
    "65": "```python\ndef min_moves_to_transform(n, m):\n    if m % n != 0:\n        return -1\n    \n    ratio = m // n\n    moves = 0\n    \n    while ratio > 1:\n        if ratio % 2 == 0:\n            ratio //= 2\n            moves += 1\n        elif ratio % 3 == 0:\n            ratio //= 3\n            moves += 1\n        else:\n            return -1\n            \n    return moves\n\n# Read input\nn, m = map(int, input().split())\n# Print the result\nprint(min_moves_to_transform(n, m))\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    # Find the longest suffix of t that is also a prefix\n    longest_overlap = 0\n    for i in range(1, n):\n        if t[:n - i] == t[i:]:\n            longest_overlap = n - i\n            break\n            \n    # Construct the result string\n    result = t + (t[longest_overlap:] * (k - 1))\n    return result\n\n# Read input\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the result and print it\nresult = construct_string(n, k, t)\nprint(result)\n```",
    "71": "```python\ndef calculate_output(a):\n    return (a - 1).bit_length()\n\na = int(input())\nprint(calculate_output(a))\n```",
    "62": "```python\ndef min_operations(t, test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        min_moves = float('inf')\n        best_triple = (0, 0, 0)\n\n        # Iterate over possible values for A\n        for A in range(1, a + 1):\n            # Find the closest B that is divisible by A\n            if b % A == 0:\n                B = b\n            else:\n                B = (b // A + 1) * A\n            \n            # Find the closest C that is divisible by B\n            if C % B == 0:\n                C = c\n            else:\n                C = (c // B + 1) * B\n            \n            # Calculate the number of operations needed\n            moves = abs(A - a) + abs(B - b) + abs(C - c)\n            \n            if moves < min_moves:\n                min_moves = moves\n                best_triple = (A, B, C)\n\n        results.append((min_moves, best_triple))\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = min_operations(t, test_cases)\n\n# Output results\nfor moves, (A, B, C) in results:\n    print(moves)\n    print(A, B, C)\n```",
    "67": "```python\ndef find_nice_indices(n, a):\n    total_sum = sum(a)\n    nice_indices = []\n\n    for i in range(n):\n        remaining_sum = total_sum - a[i]\n        if remaining_sum % 2 == 0:\n            target = remaining_sum // 2\n            if target in a[:i] or target in a[i + 1:]:\n                nice_indices.append(i + 1)  # Store 1-based index\n\n    return nice_indices\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Finding nice indices\nnice_indices = find_nice_indices(n, a)\n\n# Output results\nprint(len(nice_indices))\nif nice_indices:\n    print(' '.join(map(str, nice_indices)))\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    days = [0] * n\n    preparation_days = [0] * m\n\n    # Sort exams by their exam day\n    exams = sorted(enumerate(exams), key=lambda x: x[1][1])\n\n    for index, (s, d, c) in exams:\n        # Check if we can allocate preparation days\n        available_days = [i for i in range(s - 1, d - 1) if days[i] == 0]\n        \n        if len(available_days) < c:\n            return -1  # Not enough days to prepare\n        \n        # Allocate preparation days\n        for i in range(c):\n            days[available_days[i]] = index + 1  # Mark preparation for exam index + 1\n\n        # Mark the exam day\n        days[d - 1] = m + 1  # Mark the exam day\n\n    return days\n\n# Input reading\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the schedule\nresult = schedule_exams(n, m, exams)\n\n# Output result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "73": "```python\ndef can_complete_wall(n, heights):\n    max_height = max(heights)\n    total_bricks_needed = 0\n    \n    for height in heights:\n        total_bricks_needed += max_height - height\n    \n    # Check if the total number of bricks needed is even\n    return total_bricks_needed % 2 == 0\n\n# Input reading\nn = int(input())\nheights = list(map(int, input().split()))\n\n# Output result\nif can_complete_wall(n, heights):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "77": "```python\ndef minimum_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nn = int(input())\nprint(minimum_difference(n))\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph):\n    visited = {start: 0}\n    queue = deque([start])\n    farthest_node = start\n    max_distance = 0\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited[neighbor] = visited[node] + 1\n                queue.append(neighbor)\n                if visited[neighbor] > max_distance:\n                    max_distance = visited[neighbor]\n                    farthest_node = neighbor\n                    \n    return farthest_node, max_distance\n\ndef find_max_edges(n, edges):\n    graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Step 1: Find the farthest node from an arbitrary node (node 1)\n    farthest_from_start, _ = bfs(1, graph)\n    \n    # Step 2: Find the farthest node from the previously found farthest node\n    farthest_from_a, diameter_length = bfs(farthest_from_start, graph)\n    \n    # Step 3: Find the path from farthest_from_start to farthest_from_a\n    path = []\n    parent = {farthest_from_start: None}\n    queue = deque([farthest_from_start])\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in parent:\n                parent[neighbor] = node\n                queue.append(neighbor)\n    \n    # Reconstruct the path\n    current = farthest_from_a\n    while current is not None:\n        path.append(current)\n        current = parent[current]\n    \n    path_length = len(path)\n    \n    # Step 4: Choose three distinct vertices\n    if path_length >= 3:\n        a, b, c = path[0], path[path_length // 2], path[-1]\n    else:\n        a, b, c = path[0], path[1], path[2]\n    \n    return diameter_length + 1, a, b, c\n\n# Input reading\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\n# Get the result\nresult = find_max_edges(n, edges)\n\n# Output the result\nprint(result[0])\nprint(result[1], result[2], result[3])\n```",
    "70": "```python\ndef calculate_midpoint(h1, m1, h2, m2):\n    # Convert start and end times to total minutes\n    start_minutes = h1 * 60 + m1\n    end_minutes = h2 * 60 + m2\n    \n    # Calculate midpoint in total minutes\n    midpoint_minutes = (start_minutes + end_minutes) // 2\n    \n    # Convert midpoint back to hours and minutes\n    h3 = midpoint_minutes // 60\n    m3 = midpoint_minutes % 60\n    \n    # Format output to ensure two digits\n    return f\"{h3:02}:{m3:02}\"\n\n# Read input\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Calculate and print the midpoint\nprint(calculate_midpoint(h1, m1, h2, m2))\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n\n    if D >= n:\n        print(\"NO\")\n        return\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    degree = {i: 0 for i in range(1, n + 1)}\n    spanning_tree_edges = []\n    visited = set()\n    \n    # BFS to construct the spanning tree\n    def bfs(start):\n        queue = deque([start])\n        visited.add(start)\n        while queue:\n            node = queue.popleft()\n            if degree[node] < D and node == 1:\n                # Try to connect to D neighbors\n                for neighbor in graph[node]:\n                    if degree[node] < D and neighbor not in visited:\n                        spanning_tree_edges.append((node, neighbor))\n                        degree[node] += 1\n                        degree[neighbor] += 1\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n            else:\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        spanning_tree_edges.append((node, neighbor))\n                        degree[node] += 1\n                        degree[neighbor] += 1\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n\n    bfs(1)\n\n    if degree[1] != D or len(spanning_tree_edges) != n - 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for u, v in spanning_tree_edges:\n            print(u, v)\n\n# Example usage:\n# n, m, D = map(int, input().split())\n# edges = [tuple(map(int, input().split())) for _ in range(m)]\n# find_spanning_tree(n, m, D, edges)\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    left = [0] * n\n    right = [0] * n\n\n    for i in range(n):\n        left[i] = segments[i][0]\n        right[i] = segments[i][1]\n\n    max_left = [0] * n\n    min_right = [0] * n\n\n    max_left[0] = left[0]\n    for i in range(1, n):\n        max_left[i] = max(max_left[i - 1], left[i])\n\n    min_right[n - 1] = right[n - 1]\n    for i in range(n - 2, -1, -1):\n        min_right[i] = min(min_right[i + 1], right[i])\n\n    max_length = 0\n\n    for i in range(n):\n        current_left = max_left[i - 1] if i > 0 else left[1]\n        current_right = min_right[i + 1] if i < n - 1 else right[n - 2]\n        \n        intersection_length = max(0, current_right - current_left)\n        max_length = max(max_length, intersection_length)\n\n    return max_length\n\n# Example usage:\n# n = int(input())\n# segments = [tuple(map(int, input().split())) for _ in range(n)]\n# print(max_intersection_length(n, segments))\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    unique_subsequences = set()\n    \n    # Generate all possible subsequences\n    for i in range(1 << n):\n        subsequence = []\n        for j in range(n):\n            if i & (1 << j):\n                subsequence.append(s[j])\n        unique_subsequences.add(''.join(subsequence))\n    \n    # If we cannot obtain k unique subsequences\n    if len(unique_subsequences) < k:\n        return -1\n    \n    # Calculate the minimum cost\n    costs = []\n    for subseq in unique_subsequences:\n        cost = n - len(subseq)\n        costs.append(cost)\n    \n    costs.sort()\n    \n    return sum(costs[:k])\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "76": "```python\ndef can_construct_symmetric_square(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n        \n        top_left_bottom_right = set()\n        top_right_bottom_left = set()\n        \n        for tile in tiles:\n            top_left, top_right = tile[0]\n            bottom_left, bottom_right = tile[1]\n            top_left_bottom_right.add((top_left, bottom_right))\n            top_right_bottom_left.add((top_right, bottom_left))\n        \n        if top_left_bottom_right & top_right_bottom_left:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Example usage:\n# t = number of test cases\n# test_cases = [(n, m, tiles), ...]\n# where tiles is a list of tuples representing the tile configurations\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Define the food consumption pattern for each day of the week\n    food_pattern = [0, 0, 1, 0, 0, 1, 0]  # 0: fish, 1: rabbit, 2: chicken\n    food_needed = [2, 1, 1]  # fish, rabbit, chicken\n    \n    max_days = 0\n    \n    # Check starting from each day of the week\n    for start_day in range(7):\n        fish = a\n        rabbit = b\n        chicken = c\n        days = 0\n        \n        # Simulate the days of the trip\n        while True:\n            day_of_week = (start_day + days) % 7\n            if food_pattern[day_of_week] == 0:  # Fish food\n                if fish > 0:\n                    fish -= 1\n                else:\n                    break\n            elif food_pattern[day_of_week] == 1:  # Rabbit stew\n                if rabbit > 0:\n                    rabbit -= 1\n                else:\n                    break\n            else:  # Chicken stake\n                if chicken > 0:\n                    chicken -= 1\n                else:\n                    break\n            days += 1\n        \n        max_days = max(max_days, days)\n    \n    return max_days\n\n# Input reading\na, b, c = map(int, input().split())\nprint(max_days(a, b, c))\n```",
    "82": "```python\ndef max_problems_solved(n, k, difficulties):\n    left = 0\n    right = n - 1\n    solved = 0\n\n    while left <= right:\n        if difficulties[left] <= k:\n            solved += 1\n            left += 1\n        elif difficulties[right] <= k:\n            solved += 1\n            right -= 1\n        else:\n            break\n\n    return solved\n\n# Input reading\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Output the result\nprint(max_problems_solved(n, k, difficulties))\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import Counter\n    \n    # Count the frequency of each character in the string\n    freq = Counter(s)\n    \n    # Calculate the total number of unique subsequences\n    unique_subsequences = 0\n    total_cost = 0\n    \n    # For each unique character, calculate the number of subsequences\n    for char, count in freq.items():\n        # Number of subsequences that can be formed with this character\n        # is 2^count - 1 (excluding the empty subsequence)\n        unique_subsequences += (1 << count) - 1  # 2^count - 1\n        total_cost += count * (1 << count) - 1  # Cost of all subsequences\n    \n    # If we cannot form at least k unique subsequences, return -1\n    if unique_subsequences < k:\n        return -1\n    \n    # Calculate the minimum cost to obtain exactly k unique subsequences\n    cost = 0\n    remaining = k\n    \n    # We will use a list to keep track of costs for each unique subsequence length\n    costs = []\n    \n    for char, count in freq.items():\n        for length in range(1, count + 1):\n            # Cost to form subsequences of this length\n            costs.append((n - length, (1 << length) - 1))  # (cost, number of subsequences)\n    \n    # Sort costs by cost ascending\n    costs.sort()\n    \n    for cost, num_subseq in costs:\n        if remaining <= 0:\n            break\n        if num_subseq <= remaining:\n            cost += num_subseq * cost\n            remaining -= num_subseq\n        else:\n            cost += remaining * cost\n            remaining = 0\n    \n    return total_cost\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "81": "```python\ndef can_reorder_strings(n, strings):\n    # Sort strings by length, then lexicographically\n    strings.sort(key=lambda x: (len(x), x))\n    \n    for i in range(1, n):\n        # Check if the previous string is a substring of the current string\n        if strings[i-1] not in strings[i]:\n            return \"NO\"\n    \n    return \"YES\", strings\n\n# Read input\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\n# Get the result\nresult = can_reorder_strings(n, strings)\n\n# Print the result\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for string in result[1]:\n        print(string)\n```",
    "85": "```python\ndef find_price_before_tax(A, B):\n    for price in range(1, 10000):  # Arbitrarily chosen upper limit\n        tax_8 = int(price * 0.08)\n        tax_10 = int(price * 0.10)\n        \n        if tax_8 == A and tax_10 == B:\n            return price\n            \n    return -1\n\nif __name__ == \"__main__\":\n    import sys\n    input_data = sys.stdin.read().strip()\n    A, B = map(int, input_data.split())\n    result = find_price_before_tax(A, B)\n    print(result)\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n\n    for width in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % width == 0:\n            height = total_tiles // width\n            \n            # Check both (width, height) and (height, width)\n            for w, h in [(width, height), (height, width)]:\n                # Check if we can fit red and blue rectangles\n                if (a <= w * h and (a % w == 0 or a % h == 0)) or (b <= w * h and (b % w == 0 or b % h == 0)):\n                    perimeter = 2 * (w + h)\n                    min_perimeter = min(min_perimeter, perimeter)\n\n    return min_perimeter\n\n# Input reading\na, b = map(int, input().split())\nprint(minimal_perimeter(a, b))\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects based on the required rating and then by the rating change\n    projects.sort(key=lambda x: (x[0], x[1]))\n\n    count = 0\n    current_rating = r\n    completed_projects = []\n\n    for a, b in projects:\n        if current_rating >= a:\n            completed_projects.append((a, b))\n            current_rating += b\n            if current_rating < 0:\n                break\n            count += 1\n\n    return count\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_projects(n, r, projects))\n```",
    "84": "```python\ndef can_color_string(n, s):\n    # Create a list to store the color assignments\n    color = ['0'] * n\n    \n    # Create a dictionary to count occurrences of each character\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Check for characters that appear more than twice\n    for count in char_count.values():\n        if count > 2:\n            print(\"NO\")\n            return\n\n    # Assign colors\n    current_color = '0'\n    for i in range(n):\n        if s[i] in char_count and char_count[s[i]] > 0:\n            color[i] = current_color\n            char_count[s[i]] -= 1\n            # Switch color if we have used both colors for this character\n            if char_count[s[i]] == 0:\n                current_color = '1' if current_color == '0' else '0'\n\n    print(\"YES\")\n    print(''.join(color))\n\n# Read input\nn = int(input())\ns = input().strip()\ncan_color_string(n, s)\n```",
    "78": "```python\nMOD = 10**9 + 7\n\ndef count_regular_sequences(n, s):\n    m = len(s)\n    \n    # Precompute the number of valid bracket sequences of length 2*k\n    dp = [0] * (n + 1)\n    dp[0] = 1  # Base case: one way to form an empty sequence\n\n    for k in range(1, n + 1):\n        for j in range(k):\n            dp[k] = (dp[k] + dp[j] * dp[k - 1 - j]) % MOD\n\n    # Check the balance of the substring s\n    balance = 0\n    min_balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n\n    # If the balance is not valid or if it goes negative\n    if balance < 0 or n < (m + min_balance) // 2:\n        return 0\n\n    # Calculate the number of valid sequences containing s\n    total_count = 0\n    for prefix_length in range(n + 1):\n        suffix_length = n - (m - 1) - prefix_length\n        if suffix_length < 0:\n            continue\n        \n        # Calculate the required balance for the prefix\n        prefix_balance = 0\n        for i in range(prefix_length):\n            if i < m:\n                if s[i] == '(':\n                    prefix_balance += 1\n                else:\n                    prefix_balance -= 1\n\n        # Check if we can form a valid sequence\n        if prefix_balance + suffix_length >= 0 and prefix_balance <= n:\n            total_count = (total_count + dp[prefix_length] * dp[suffix_length]) % MOD\n\n    return total_count\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(count_regular_sequences(n, s))\n```",
    "86": "```python\ndef solve_problems(n, k):\n    # Minimum sum required to satisfy the conditions\n    min_sum = k * (k + 1) // 2\n    if n < min_sum:\n        print(\"NO\")\n        return\n    \n    # Start with the minimum valid array\n    a = list(range(1, k + 1))\n    current_sum = sum(a)\n    \n    # Distribute the remaining problems\n    remaining = n - current_sum\n    \n    for i in range(k - 1, -1, -1):\n        # Maximum we can add to a[i] while respecting the constraints\n        max_add = min(remaining, (2 * a[i]) - a[i])\n        a[i] += max_add\n        remaining -= max_add\n        \n        if remaining <= 0:\n            break\n    \n    if remaining > 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n\n# Example usage\nn, k = map(int, input().split())\nsolve_problems(n, k)\n```",
    "92": "```python\nx = float(input().strip())\n\n# Scale x to a range suitable for generating integers between 1 and 10\nscaled_x = x * 10\n\n# Generate two integers based on the scaled value\na = int(scaled_x) % 10 + 1\nb = (int(scaled_x * 2) % 10) + 1\n\nprint(a, b)\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    # Create a list to store the color assignments\n    colors = [0] * n\n    # Dictionary to track the last seen index of each character\n    last_seen = {}\n    # Color counter\n    color_count = 0\n\n    for i in range(n):\n        char = s[i]\n        if char in last_seen:\n            # If the character was seen before, assign the same color\n            colors[i] = colors[last_seen[char]]\n        else:\n            # If it's a new character, increment the color count and assign a new color\n            color_count += 1\n            colors[i] = color_count\n        \n        # Update the last seen index for the character\n        last_seen[char] = i\n\n    return color_count, colors\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult_count, result_colors = min_colors_to_sort(n, s)\n\n# Output the results\nprint(result_count)\nprint(' '.join(map(str, result_colors)))\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects based on the required rating\n    projects.sort(key=lambda x: x[0])\n    \n    for a, b in projects:\n        if r < a:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_complete_projects(n, r, projects))\n```",
    "88": "```python\ndef create_palindromic_matrix(n, numbers):\n    from collections import Counter\n\n    # Count the occurrences of each number\n    count = Counter(numbers)\n    \n    # Check for the number of odd occurrences\n    odd_count = sum(1 for v in count.values() if v % 2 != 0)\n    \n    # For an n x n matrix, we can have at most one number with an odd count\n    if (n % 2 == 0 and odd_count > 0) or (n % 2 == 1 and odd_count > 1):\n        return \"NO\"\n\n    # Prepare the matrix\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Fill the matrix with the numbers\n    half = []\n    center = None\n    \n    for num, freq in count.items():\n        if freq % 2 == 1:\n            center = num  # This will be the center element if n is odd\n        half.extend([num] * (freq // 2))\n    \n    # Create the palindromic structure\n    half_size = len(half)\n    for i in range(n // 2):\n        for j in range(n // 2):\n            matrix[i][j] = half[i * (n // 2) + j]\n            matrix[i][n - j - 1] = matrix[i][j]\n            matrix[n - i - 1][j] = matrix[i][j]\n            matrix[n - i - 1][n - j - 1] = matrix[i][j]\n\n    # If n is odd, place the center element\n    if n % 2 == 1 and center is not None:\n        mid = n // 2\n        matrix[mid][mid] = center\n\n    return \"YES\", matrix\n\n# Input reading\nn = int(input())\nnumbers = list(map(int, input().split()))\n\n# Create the palindromic matrix\nresult = create_palindromic_matrix(n, numbers)\n\n# Output the result\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for row in result[1]:\n        print(\" \".join(map(str, row)))\n```",
    "97": "```python\ndef min_coins_to_move_chips(n, positions):\n    odd_count = sum(1 for x in positions if x % 2 != 0)\n    even_count = n - odd_count\n    return min(odd_count, even_count)\n\n# Input reading\nn = int(input())\npositions = list(map(int, input().split()))\n\n# Output the result\nprint(min_coins_to_move_chips(n, positions))\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    n_str = str(n)\n    length = len(n_str)\n    \n    # Possible endings for a number to be divisible by 25\n    targets = ['00', '25', '50', '75']\n    \n    min_moves = float('inf')\n    \n    for target in targets:\n        # Try to form the target at the end of the number\n        target_len = len(target)\n        j = length - 1\n        \n        # Count moves needed to place the target at the end\n        for i in range(target_len - 1, -1, -1):\n            while j >= 0 and n_str[j] != target[i]:\n                j -= 1\n            if j < 0:\n                break\n            # Count the moves needed to bring this digit to the end\n            min_moves += (length - 1 - j)\n            j -= 1\n        \n        # If we successfully placed all target digits\n        if j >= -1:\n            min_moves = min(min_moves, length - target_len)\n    \n    return min_moves if min_moves != float('inf') else -1\n\n# Input reading\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1:\n        return \"NO\"\n    \n    if d == 0 and n > 1:\n        return \"NO\"\n    \n    if n == 1:\n        return \"YES\\n\"\n    \n    edges = []\n    \n    # Create the main path of length d\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n    \n    # Now we have d + 1 vertices in the path\n    current_vertex = d + 2\n    \n    # Attach remaining vertices to the path\n    for i in range(1, d + 2):\n        while len([e for e in edges if e[0] == i or e[1] == i]) < k and current_vertex <= n:\n            edges.append((i, current_vertex))\n            current_vertex += 1\n    \n    if current_vertex <= n:\n        return \"NO\"\n    \n    result = [\"YES\"]\n    for u, v in edges:\n        result.append(f\"{u} {v}\")\n    \n    return \"\\n\".join(result)\n\n# Read input\nn, d, k = map(int, input().split())\nprint(construct_tree(n, d, k))\n```",
    "90": "```python\ndef can_cross_river(n, m, d, platforms):\n    total_length = sum(platforms)\n    if total_length + (m - 1) > n:\n        return \"NO\"\n\n    result = [0] * n\n    current_position = 0\n\n    for i in range(m):\n        platform_length = platforms[i]\n        # Place the platform at the furthest position we can\n        start_position = current_position + 1\n        end_position = start_position + platform_length - 1\n        \n        # Check if we can place the platform without exceeding the river width\n        if end_position > n:\n            return \"NO\"\n        \n        # Fill the result array with the platform index\n        for j in range(platform_length):\n            result[start_position + j - 1] = i + 1\n        \n        # Update the current position to the end of the current platform\n        current_position = end_position\n\n    return \"YES\\n\" + \" \".join(map(str, result))\n\n# Input reading\nn, m, d = map(int, input().split())\nplatforms = list(map(int, input().split()))\n\n# Output the result\nprint(can_cross_river(n, m, d, platforms))\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Start with the base pattern\n    pattern = []\n    \n    # Determine the starting character based on the larger count\n    if a > b:\n        pattern.append('0')\n        a -= 1\n    else:\n        pattern.append('1')\n        b -= 1\n    \n    # Alternate between 0s and 1s to create the required transitions\n    for _ in range(x):\n        if pattern[-1] == '0':\n            pattern.append('1')\n            b -= 1\n        else:\n            pattern.append('0')\n            a -= 1\n    \n    # Fill the remaining characters with the last used character\n    last_char = pattern[-1]\n    remaining = a if last_char == '0' else b\n    \n    pattern.extend([last_char] * remaining)\n    \n    # Join the list into a string and return\n    return ''.join(pattern)\n\n# Input reading\na, b, x = map(int, input().split())\n# Output the result\nprint(construct_binary_string(a, b, x))\n```",
    "98": "```python\ndef min_moves_to_reach_n(N):\n    moves = float('inf')\n    \n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            moves = min(moves, i + j - 2)\n    \n    return moves\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    N = int(input().strip())\n    print(min_moves_to_reach_n(N))\n```",
    "91": "```python\ndef max_removable_length(s: str, t: str) -> int:\n    n, m = len(s), len(t)\n\n    # Create arrays to store the positions of characters in s that match t\n    left = [0] * m\n    right = [0] * m\n\n    # Fill left array\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n\n    # Fill right array\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n\n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n\n    # Consider removing from the start to the first character of t\n    max_length = max(max_length, right[0])\n    # Consider removing from the last character of t to the end\n    max_length = max(max_length, n - 1 - left[m - 1])\n\n    return max_length\n\n# Example usage:\ns = input().strip()\nt = input().strip()\nprint(max_removable_length(s, t))\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    # Initialize the permutation array\n    p = [0] * n\n    \n    # Start with p[0] as an arbitrary value\n    p[0] = 0\n    \n    # Calculate the values of p based on q\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n    \n    # Normalize the permutation to start from 1\n    min_value = min(p)\n    for i in range(n):\n        p[i] -= min_value - 1\n    \n    # Check if the resulting array is a valid permutation\n    if sorted(p) == list(range(1, n + 1)):\n        print(\" \".join(map(str, p)))\n    else:\n        print(-1)\n\n# Example usage:\nn = int(input())\nq = list(map(int, input().split()))\nrestore_permutation(n, q)\n```",
    "99": "```python\ndef rock_paper_scissors(n, a, b):\n    a_rock, a_scissors, a_paper = a\n    b_rock, b_scissors, b_paper = b\n\n    # Maximum wins for Alice\n    max_wins = min(a_rock, b_scissors) + min(a_scissors, b_paper) + min(a_paper, b_rock)\n\n    # Minimum wins for Alice\n    # Calculate losses for Alice\n    alice_losses = 0\n    alice_losses += max(0, b_rock - a_paper)  # Bob's rock beats Alice's paper\n    alice_losses += max(0, b_scissors - a_rock)  # Bob's scissors beats Alice's rock\n    alice_losses += max(0, b_paper - a_scissors)  # Bob's paper beats Alice's scissors\n\n    min_wins = n - alice_losses\n\n    return min_wins, max_wins\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Get results\nmin_wins, max_wins = rock_paper_scissors(n, a, b)\n\n# Output results\nprint(min_wins, max_wins)\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Count of each character\n    count_a = n\n    count_b = n\n    count_c = n\n    \n    # Create a list to hold the result\n    res = []\n    \n    # Function to append characters while avoiding substrings\n    def append_char(char):\n        nonlocal count_a, count_b, count_c\n        if char == 'a' and count_a > 0:\n            res.append('a')\n            count_a -= 1\n        elif char == 'b' and count_b > 0:\n            res.append('b')\n            count_b -= 1\n        elif char == 'c' and count_c > 0:\n            res.append('c')\n    \n    # Try to build the result string\n    while count_a > 0 or count_b > 0 or count_c > 0:\n        if len(res) >= 1 and ''.join(res[-1:]) == s[0] and count_a > 0:\n            append_char('c' if 'c' in s else 'b')\n        elif len(res) >= 1 and ''.join(res[-1:]) == s[1] and count_a > 0:\n            append_char('c' if 'c' in t else 'a')\n        elif len(res) >= 2 and ''.join(res[-2:]) == s:\n            append_char('c' if 'c' in s else 'b')\n        elif len(res) >= 2 and ''.join(res[-2:]) == t:\n            append_char('a' if 'a' in t else 'b')\n        else:\n            if count_a > 0:\n                append_char('a')\n            elif count_b > 0:\n                append_char('b')\n            elif count_c > 0:\n                append_char('c')\n    \n    # Check if we have formed a valid string\n    result_str = ''.join(res)\n    if s in result_str or t in result_str:\n        return \"NO\"\n    \n    return \"YES\", result_str\n\n# Input reading\nn = int(input())\ns = input().strip()\nt = input().strip()\n\n# Generate the string\nresult = generate_string(n, s, t)\n\n# Output the result\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    print(result[1])\n```"
}