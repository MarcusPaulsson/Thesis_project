{
    "2": "```python\ndef next_lucky_year(current_year):\n    def is_lucky(year):\n        non_zero_digits = [digit for digit in str(year) if digit != '0']\n        return len(non_zero_digits) <= 1\n\n    next_year = current_year + 1\n    while not is_lucky(next_year):\n        next_year += 1\n    \n    return next_year - current_year\n\n# Input\nn = int(input().strip())\n# Output\nprint(next_lucky_year(n))\n```",
    "7": "```python\ndef day_when_barn_empty(n, m):\n    day = 1\n    total_grains = n\n    while total_grains > 0:\n        # Add grains to the barn\n        total_grains += m\n        # If it exceeds the capacity, it remains full\n        if total_grains > n:\n            total_grains = n\n        \n        # Sparrows eat grains\n        total_grains -= day\n        \n        # Move to the next day\n        day += 1\n    \n    return day - 1  # Return the last day before it became empty\n\n# Input reading\nn, m = map(int, input().split())\n# Output the result\nprint(day_when_barn_empty(n, m))\n```",
    "4": "```python\ndef is_lucky_hour(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef time_before(hh, mm, x):\n    total_minutes = hh * 60 + mm\n    while total_minutes >= 0:\n        yield divmod(total_minutes, 60)\n        total_minutes -= x\n\ndef find_lucky_time(x, hh, mm):\n    for presses, (h, m) in enumerate(time_before(hh, mm, x)):\n        if is_lucky_hour(h, m):\n            return presses\n    return -1  # This should never happen as per problem guarantee\n\n# Input reading\nx = int(input().strip())\nhh, mm = map(int, input().strip().split())\n\n# Output the result\nprint(find_lucky_time(x, hh, mm))\n```",
    "1": "```python\ndef max_digit_sum_number(x):\n    str_x = str(x)\n    n = len(str_x)\n    \n    # Initialize the best number and maximum digit sum\n    best_number = x\n    max_digit_sum = sum(int(d) for d in str_x)\n\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a new candidate by reducing the current digit and filling the rest with '9'\n        candidate = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        candidate_int = int(candidate)\n\n        if candidate_int > 0 and candidate_int <= x:\n            candidate_digit_sum = sum(int(d) for d in candidate)\n            if (candidate_digit_sum > max_digit_sum or \n                (candidate_digit_sum == max_digit_sum and candidate_int > best_number)):\n                best_number = candidate_int\n                max_digit_sum = candidate_digit_sum\n\n    return best_number\n\nx = int(input())\nprint(max_digit_sum_number(x))\n```",
    "5": "```python\ndef minimum_seconds(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0  # No tabs need to be closed\n\n    moves = 0\n\n    # If there are tabs to close on the left\n    if l > 1:\n        if pos > l:  # Move cursor to the leftmost tab that needs to remain open\n            moves += (pos - l)  # Move to l\n        moves += 1  # Close tabs to the left of l\n\n    # If there are tabs to close on the right\n    if r < n:\n        if pos < r:  # Move cursor to the rightmost tab that needs to remain open\n            moves += (r - pos)  # Move to r\n        moves += 1  # Close tabs to the right of r\n\n    return moves\n\n# Input\nn, pos, l, r = map(int, input().split())\n# Output\nprint(minimum_seconds(n, pos, l, r))\n```",
    "6": "```python\ndef min_blows_to_defeat(t, queries):\n    results = []\n    \n    for query in queries:\n        n, x, blows = query['n'], query['x'], query['blows']\n        min_blows = float('inf')\n        \n        for d, h in blows:\n            if d >= x:\n                min_blows = min(min_blows, 1)\n                continue\n            \n            # Calculate effective damage and heads produced\n            effective_damage = d - h\n            if effective_damage <= 0:\n                continue\n            \n            # Calculate number of blows required\n            blows_needed = (x - d + effective_damage - 1) // effective_damage + 1\n            min_blows = min(min_blows, blows_needed)\n        \n        results.append(min_blows if min_blows != float('inf') else -1)\n    \n    return results\n\n# Read input\nt = int(input())\nqueries = []\n\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append({'n': n, 'x': x, 'blows': blows})\n\n# Get results\nresults = min_blows_to_defeat(t, queries)\n\n# Print outputs\nfor result in results:\n    print(result)\n```",
    "10": "```python\ndef calculate_days_off(n):\n    # Maximum days off are limited by the number of weekends that can fit in n days\n    full_weeks = n // 7\n    max_days_off = full_weeks * 2 + min(2, n % 7)\n    \n    # Minimum days off occur when we utilize the work days as much as possible\n    if n < 5:\n        min_days_off = n % 7 if n % 7 <= 2 else 0\n    else:\n        min_days_off = max_days_off\n    \n    return min_days_off, max_days_off\n\nn = int(input())\nmin_off, max_off = calculate_days_off(n)\nprint(min_off, max_off)\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    # Create a list to store the coverage for each section\n    covered = [0] * (n + 1)\n    \n    # Count the initial coverage for each section\n    for l, r in painters:\n        for i in range(l, r + 1):\n            covered[i] += 1\n    \n    # Calculate the max painted sections with combinations of excluding two painters\n    max_sections = 0\n    \n    for i in range(q):\n        for j in range(i + 1, q):\n            # Create a temporary coverage list\n            temp_covered = covered[:]\n            \n            # Exclude the i-th and j-th painter\n            l_i, r_i = painters[i]\n            l_j, r_j = painters[j]\n            \n            for index in range(l_i, r_i + 1):\n                temp_covered[index] -= 1\n            for index in range(l_j, r_j + 1):\n                temp_covered[index] -= 1\n            \n            # Count the painted sections\n            painted_sections = sum(1 for x in range(1, n + 1) if temp_covered[x] > 0)\n            max_sections = max(max_sections, painted_sections)\n    \n    return max_sections\n\n# Input reading\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Get the result and print it\nresult = max_painted_sections(n, q, painters)\nprint(result)\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    # Calculate the number of tiles painted Red and Blue\n    count_red = n // a\n    count_blue = n // b\n    count_both = n // (a * b)\n\n    # The actual number of Red and Blue tiles\n    count_red_only = count_red - count_both\n    count_blue_only = count_blue - count_both\n\n    # Calculate total chocolates\n    total_chocolates = (count_red_only * p) + (count_blue_only * q) + (count_both * max(p, q))\n\n    return total_chocolates\n\n# Read input\nn, a, b, p, q = map(int, input().split())\n\n# Get the result\nresult = max_chocolates(n, a, b, p, q)\n\n# Print the result\nprint(result)\n```",
    "15": "```python\na, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "8": "```python\ndef min_draws_to_win(tiles):\n    suits = {'m': [], 'p': [], 's': []}\n    \n    # Parse the input tiles into suits\n    for tile in tiles:\n        number = int(tile[0])\n        suit = tile[1]\n        suits[suit].append(number)\n    \n    # Check for existing mentsus\n    for suit in suits:\n        numbers = sorted(suits[suit])\n        # Check for koutsu\n        if len(set(numbers)) == 1:\n            return 0  # Found a koutsu\n        \n        # Check for shuntsu\n        for i in range(len(numbers) - 2):\n            if numbers[i] + 1 == numbers[i + 1] and numbers[i + 1] + 1 == numbers[i + 2]:\n                return 0  # Found a shuntsu\n\n    # Check for possible shuntsus with one draw\n    for suit in suits:\n        numbers = sorted(suits[suit])\n        if len(numbers) == 3:\n            # Check for gaps in the sequence\n            if (numbers[0] + 1 == numbers[1] and numbers[1] + 1 != numbers[2]) or \\\n               (numbers[0] != numbers[1] and numbers[1] + 1 == numbers[2]) or \\\n               (numbers[0] + 1 != numbers[1] and numbers[1] != numbers[2]):\n                return 1  # Can form a shuntsu with one draw\n        \n        elif len(numbers) == 2:\n            # Check if they can form a shuntsu with one draw\n            if abs(numbers[0] - numbers[1]) == 1:\n                return 1  # Can form a shuntsu with one draw\n            if numbers[0] + 1 == numbers[1] - 1:\n                return 1  # Can draw the missing middle tile\n            \n        elif len(numbers) == 1:\n            # Only one tile, needs two more for a shuntsu\n            return 2  # Need two more different tiles\n\n    return 2  # If no mentsu can be formed\n\n# Read input\ntiles = input().split()\nprint(min_draws_to_win(tiles))\n```",
    "9": "```python\ndef find_grandpa_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b):\n    sofas_positions = []\n    \n    for idx in range(d):\n        x1, y1, x2, y2 = sofas[idx]\n        sofas_positions.append((min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)))\n        \n    for idx in range(d):\n        count_l = count_r = count_t = count_b = 0\n        x1, y1, x2, y2 = sofas_positions[idx]\n\n        for jdx in range(d):\n            if idx == jdx:\n                continue\n            sx1, sy1, sx2, sy2 = sofas_positions[jdx]\n            \n            if sx2 < x1:  # Sofa jdx is to the left of sofa idx\n                count_l += 1\n            elif sx1 > x2:  # Sofa jdx is to the right of sofa idx\n                count_r += 1\n            elif sy2 < y1:  # Sofa jdx is above sofa idx\n                count_t += 1\n            elif sy1 > y2:  # Sofa jdx is below sofa idx\n                count_b += 1\n        \n        if (count_l == cnt_l and count_r == cnt_r and \n                count_t == cnt_t and count_b == cnt_b):\n            return idx + 1  # 1-based index\n\n    return -1\n\n# Input reading\nd = int(input().strip())\nn, m = map(int, input().strip().split())\nsofas = [tuple(map(int, input().strip().split())) for _ in range(d)]\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().strip().split())\n\n# Output the result\nprint(find_grandpa_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b))\n```",
    "0": "```python\ndef max_acordion_length(s):\n    # Initialize variables to find the first and last brackets and colons\n    left_bracket_index = -1\n    right_bracket_index = -1\n    first_colon_index = -1\n    last_colon_index = -1\n    \n    # Iterate through the string to find required characters\n    for i, char in enumerate(s):\n        if char == '[' and left_bracket_index == -1:\n            left_bracket_index = i\n        elif char == ']' and left_bracket_index != -1:\n            right_bracket_index = i\n        elif char == ':' and first_colon_index == -1:\n            first_colon_index = i\n        elif char == ':':\n            last_colon_index = i\n    \n    # Check if we found valid indices for accordion structure\n    if left_bracket_index == -1 or right_bracket_index == -1 or first_colon_index == -1 or last_colon_index == -1:\n        return -1\n    \n    # Ensure that the colons are correctly positioned\n    if first_colon_index >= last_colon_index or left_bracket_index >= first_colon_index or right_bracket_index <= last_colon_index:\n        return -1\n    \n    # Count the number of '|' characters between the colons\n    vertical_lines_count = s[first_colon_index + 1:last_colon_index].count('|')\n    \n    # Calculate the maximum length of the accordion\n    return 4 + vertical_lines_count  # 4 for the brackets and colons, plus the number of '|'\n\n# Input reading\ns = input().strip()\n# Output the result\nprint(max_acordion_length(s))\n```",
    "18": "```python\ndef lexicographically_minimal_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        while t and (not u or t[-1] <= u[-1]):\n            u.append(t.pop())\n    \n    return ''.join(u)\n\n# Read input\ns = input().strip()\n# Get the result\nresult = lexicographically_minimal_string(s)\n# Print the output\nprint(result)\n```",
    "16": "```python\ndef can_form_regular_bracket_sequence(cnt1, cnt2, cnt3, cnt4):\n    # Calculate the number of opening and closing brackets needed\n    open_needed = cnt1 + cnt2\n    close_needed = cnt3 + cnt4\n\n    # Check if the counts match for a valid sequence\n    if open_needed == close_needed:\n        # Check if the number of ')' does not exceed the number of '(' at any point\n        if cnt3 <= cnt1 + cnt2: \n            return 1\n    return 0\n\n# Read inputs\ncnt1 = int(input().strip())\ncnt2 = int(input().strip())\ncnt3 = int(input().strip())\ncnt4 = int(input().strip())\n\n# Output the result\nprint(can_form_regular_bracket_sequence(cnt1, cnt2, cnt3, cnt4))\n```",
    "17": "```python\ndef standing_spectators(n, k, t):\n    if t <= k:\n        return t\n    elif t <= n:\n        return k\n    else:\n        return n + k - t\n\n# Read input\nn, k, t = map(int, input().split())\n# Output the result\nprint(standing_spectators(n, k, t))\n```",
    "20": "```python\ndef is_palindrome(time_str):\n    return time_str == time_str[::-1]\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        if is_palindrome(f\"{hh:02}:{mm:02}\"):\n            return minutes_passed\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n\ndef main():\n    current_time = input().strip()\n    hh, mm = map(int, current_time.split(':'))\n    print(next_palindrome_time(hh, mm))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "14": "```python\ndef is_stack_sortable_and_restore(n, k, p):\n    # Create a set for quick lookup of the first k elements\n    used = set(p)\n    # Initialize the result with the first k elements\n    result = p[:]\n    \n    # The next value we can use to fill the remaining array\n    next_value = n\n    \n    # We will use a stack to keep track of the order of elements\n    stack = []\n    \n    # Check the conditions for stack sortability\n    for i in range(k):\n        # Ensure that the stack is always non-decreasing\n        while stack and stack[-1] < result[i]:\n            stack.pop()\n        \n        # If the top of the stack is greater than the current element,\n        # it means we can't place the current element in a non-decreasing order\n        if stack and stack[-1] > result[i]:\n            return -1\n        \n        # Push the next available values into the stack until we reach the current element\n        while next_value > 0 and next_value > result[i]:\n            if next_value not in used:\n                stack.append(next_value)\n            next_value -= 1\n    \n    # Now we have filled the stack, we need to fill in the remaining values\n    while next_value > 0:\n        if next_value not in used:\n            stack.append(next_value)\n        next_value -= 1\n    \n    # Now we can append the remaining values from the stack\n    while stack:\n        if stack[-1] < result[-1] if result else float('inf'):\n            return -1\n        result.append(stack.pop())\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result\nresult = is_stack_sortable_and_restore(n, k, p)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "12": "```python\ndef max_beauty_with_swap(n, trophies):\n    # Step 1: Calculate the maximum length of golden trophies without any swaps\n    max_length = 0\n    current_length = 0\n    segments = []\n    \n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            segments.append(current_length)\n            max_length = max(max_length, current_length)\n            current_length = 0\n    segments.append(current_length)\n    max_length = max(max_length, current_length)\n    \n    # If there are no silver trophies, return max_length immediately\n    if 'S' not in trophies:\n        return max_length\n    \n    # Step 2: Check for the possibility of increasing the length by one swap\n    max_possible_length = max_length\n    \n    # We need to check adjacent segments of 'G's separated by 'S'\n    for i in range(len(segments) - 1):\n        if segments[i] > 0 and segments[i + 1] > 0:\n            # If there is an S between two segments of Gs\n            combined_length = segments[i] + segments[i + 1]\n            max_possible_length = max(max_possible_length, combined_length + 1)\n    \n    return max_possible_length\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\n\n# Calculate and print the result\nprint(max_beauty_with_swap(n, trophies))\n```",
    "23": "```python\ndef max_permutation_not_exceeding(a, b):\n    from itertools import permutations\n\n    # Convert a to string to handle its digits\n    str_a = str(a)\n    str_b = str(b)\n\n    # Generate all unique permutations of the digits in a\n    perms = set(permutations(str_a))\n\n    # Filter permutations that do not exceed b and do not start with '0'\n    valid_numbers = [\n        int(''.join(p)) for p in perms\n        if (''.join(p)[0] != '0' and int(''.join(p)) <= b)\n    ]\n\n    # Return the maximum valid number\n    return max(valid_numbers)\n\n# Read input\na = int(input().strip())\nb = int(input().strip())\n\n# Get the result\nresult = max_permutation_not_exceeding(a, b)\n\n# Print the result\nprint(result)\n```",
    "22": "```python\ndef is_s_palindrome(s: str) -> str:\n    mirror_chars = {\n        'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M',\n        'O': 'O', 'p': 'q', 'q': 'p', 'T': 'T', 'U': 'U', 'v': 'v',\n        'V': 'V', 'W': 'W', 'X': 'X', 'Y': 'Y', 'o': 'o', 'x': 'x'\n    }\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        left_char = s[i]\n        right_char = s[n - 1 - i]\n        \n        if left_char not in mirror_chars or right_char != mirror_chars[left_char]:\n            return \"NIE\"\n    \n    return \"TAK\"\n\n# Read input\ninput_string = input().strip()\n# Output result\nprint(is_s_palindrome(input_string))\n```",
    "21": "```python\ndef max_distance_after_swap(n, a):\n    min_index = a.index(1)\n    max_index = a.index(n)\n\n    # Calculate current distance\n    current_distance = abs(min_index - max_index)\n\n    # Possible new positions for min (1) and max (n) after swap\n    new_positions = [\n        (0, max_index),        # Swap with first element\n        (n - 1, max_index),    # Swap with last element\n        (min_index, 0),        # Swap with first element\n        (min_index, n - 1)     # Swap with last element\n    ]\n\n    max_distance = current_distance\n\n    for new_pos in new_positions:\n        new_min_index, new_max_index = new_pos\n        if a[new_min_index] == 1 or a[new_max_index] == n:\n            distance = abs(new_min_index - new_max_index)\n            max_distance = max(max_distance, distance)\n\n    return max_distance\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_distance_after_swap(n, a))\n```",
    "19": "```python\ndef check_records(test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, stats = case\n        valid = True\n        \n        for i in range(n):\n            p_i, c_i = stats[i]\n            \n            if i > 0:\n                p_prev, c_prev = stats[i - 1]\n                if p_i < p_prev or c_i < c_prev or (c_i > p_i) or (c_i - c_prev > p_i - p_prev):\n                    valid = False\n                    break\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Input reading\nT = int(input())\ntest_cases = []\n\nfor _ in range(T):\n    n = int(input())\n    stats = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, stats))\n\n# Process and output results\nresults = check_records(test_cases)\nfor result in results:\n    print(result)\n```",
    "13": "```python\nfrom collections import deque, defaultdict\n\ndef main_courses_sequence(n, k, main_courses, dependencies):\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    \n    # Build the graph and compute in-degrees\n    for course_id in range(1, n + 1):\n        for dep in dependencies[course_id - 1]:\n            graph[dep].append(course_id)\n            in_degree[course_id] += 1\n\n    # Queue for courses that can be taken (in-degree of 0)\n    queue = deque()\n    for course_id in range(1, n + 1):\n        if in_degree[course_id] == 0:\n            queue.append(course_id)\n\n    order = []\n    taken_courses = set()\n\n    # Process the courses in topological order\n    while queue:\n        course_id = queue.popleft()\n        order.append(course_id)\n        taken_courses.add(course_id)\n\n        for neighbor in graph[course_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    # Check if we can take all main courses\n    if not all(course in taken_courses for course in main_courses):\n        return -1\n\n    # Find all courses needed to take\n    needed_courses = set(main_courses)\n    for course in main_courses:\n        stack = [course]\n        while stack:\n            curr = stack.pop()\n            for dep in dependencies[curr - 1]:\n                if dep not in needed_courses:\n                    needed_courses.add(dep)\n                    stack.append(dep)\n\n    # Filter the courses to include only the needed ones\n    result = [course for course in order if course in needed_courses]\n    return len(result), result\n\n# Input reading\nn, k = map(int, input().split())\nmain_courses = list(map(int, input().split()))\ndependencies = []\n\nfor _ in range(n):\n    line = list(map(int, input().split()))\n    dependencies.append(line[1:])\n\n# Get the result\nresult = main_courses_sequence(n, k, main_courses, dependencies)\n\n# Output\nif result == -1:\n    print(-1)\nelse:\n    m, course_order = result\n    print(m)\n    print(\" \".join(map(str, course_order)))\n```",
    "25": "```python\ndef create_symmetric_matrix(n, k):\n    # Check if it's possible to place k ones\n    max_ones = n * (n + 1) // 2\n    if k > max_ones:\n        return -1\n\n    # Initialize the matrix with zeros\n    matrix = [[0] * n for _ in range(n)]\n\n    # Fill the matrix symmetrically and lexicographically maximal\n    for i in range(n):\n        if k <= 0:\n            break\n        for j in range(i, n):\n            if k > 0:\n                matrix[i][j] = 1\n                if i != j:\n                    matrix[j][i] = 1\n                k -= 2 if i != j else 1\n\n    return matrix\n\n# Input reading\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\n# Output result\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))\n```",
    "27": "```python\ndef min_operations(n, s):\n    # The default number of operations is to type all characters\n    min_ops = n\n    \n    # Try every possible split point\n    for i in range(1, n):\n        # Check if the prefix (s[:i]) can be doubled to match the beginning of the string\n        if s[:i] == s[i:i+i]:\n            # Calculate operations: type prefix + 1 for copy + remaining characters\n            min_ops = min(min_ops, i + 1 + (n - i - i))\n    \n    return min_ops\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Print the result\nprint(min_operations(n, s))\n```",
    "24": "```python\ndef can_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # vertical, horizontal, diagonal right, diagonal left\n    n = 10\n\n    def check_win(x, y):\n        for dx, dy in directions:\n            count = 1\n\n            # Check in the positive direction\n            nx, ny = x + dx, y + dy\n            while 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                count += 1\n                nx += dx\n                ny += dy\n\n            # Check in the negative direction\n            nx, ny = x - dx, y - dy\n            while 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                count += 1\n                nx -= dx\n                ny -= dy\n\n            if count >= 5:\n                return True\n        return False\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                board[i][j] = 'X'  # Place the cross\n                if check_win(i, j):\n                    return \"YES\"\n                board[i][j] = '.'  # Remove the cross\n\n    return \"NO\"\n\n# Read input\nboard = [input().strip() for _ in range(10)]\nprint(can_win(board))\n```",
    "30": "```python\ndef minimum_traps(m, x):\n    # Since GCD(x, m) = 1, the sequence will visit all the rooms\n    # The number of unique rooms visited is m / GCD(x, m) = m / 1 = m\n    # The number of traps needed is m - 1 (all rooms except room 0)\n    # Plus we need to trap room 0 to ensure catching the mouse when it starts there\n    return m\n\n# Read input\nm, x = map(int, input().split())\n# Calculate and print the result\nprint(minimum_traps(m, x))\n```",
    "26": "```python\nimport math\n\ndef evaluate_expression(x, y, z):\n    expressions = [\n        (x ** (y ** z), \"x^y^z\"),\n        (x ** (z ** y), \"x^z^y\"),\n        ((x ** y) ** z, \"(x^y)^z\"),\n        ((x ** z) ** y, \"(x^z)^y\"),\n        (y ** (x ** z), \"y^x^z\"),\n        (y ** (z ** x), \"y^z^x\"),\n        ((y ** x) ** z, \"(y^x)^z\"),\n        ((y ** z) ** x, \"(y^z)^x\"),\n        (z ** (x ** y), \"z^x^y\"),\n        (z ** (y ** x), \"z^y^x\"),\n        ((z ** x) ** y, \"(z^x)^y\"),\n        ((z ** y) ** x, \"(z^y)^x\")\n    ]\n    \n    max_value = float('-inf')\n    max_expr = None\n    \n    for value, expr in expressions:\n        if value > max_value:\n            max_value = value\n            max_expr = expr\n            \n    return max_expr\n\n# Input\nx, y, z = map(float, input().split())\n\n# Output the expression with the maximum value\nprint(evaluate_expression(x, y, z))\n```",
    "32": "```python\ndef check_journey(n, journey):\n    current_position = 0  # Position in kilometers from the North Pole (0 to 20000)\n\n    for t, direction in journey:\n        if current_position == 0 and direction != \"South\":\n            return \"NO\"\n        if current_position == 20000 and direction != \"North\":\n            return \"NO\"\n\n        if direction == \"South\":\n            current_position += t\n        elif direction == \"North\":\n            current_position -= t\n        elif direction == \"West\" or direction == \"East\":\n            # West and East don't change the North-South position\n            continue\n        \n        # Check if current position is going out of bounds\n        if current_position < 0 or current_position > 20000:\n            return \"NO\"\n    \n    # Final position must be at the North Pole\n    if current_position != 0:\n        return \"NO\"\n\n    return \"YES\"\n\n# Input reading\nn = int(input().strip())\njourney = [tuple(input().strip().split()) for _ in range(n)]\njourney = [(int(t), dir) for t, dir in journey]\n\n# Output the result\nprint(check_journey(n, journey))\n```",
    "28": "```python\ndef rename_files(n, files):\n    examples = []\n    regulars = []\n    \n    # Separate examples and regular tests\n    for file in files:\n        name, type_ = file.split()\n        if type_ == '1':\n            examples.append(name)\n        else:\n            regulars.append(name)\n    \n    # Prepare the moves\n    moves = []\n    \n    # Move examples to 1, 2, ..., e\n    for i, example in enumerate(examples):\n        target_name = str(i + 1)\n        moves.append(f\"move {example} {target_name}\")\n    \n    # Move regulars to e + 1, e + 2, ..., n\n    for i, regular in enumerate(regulars):\n        target_name = str(len(examples) + i + 1)\n        moves.append(f\"move {regular} {target_name}\")\n    \n    # Output the results\n    print(len(moves))\n    print(\"\\n\".join(moves))\n\n# Input processing\nn = int(input().strip())\nfiles = [input().strip() for _ in range(n)]\n\n# Call the function with the input\nrename_files(n, files)\n```",
    "37": "```python\ndef can_break_shield(a, b, c):\n    for x in range(c // a + 1):\n        if (c - a * x) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Input reading\na, b, c = map(int, input().split())\nprint(can_break_shield(a, b, c))\n```",
    "34": "```python\ndef max_min_pieces(n, a, b):\n    def can_distribute(x):\n        plates_from_a = a // x\n        plates_from_b = b // x\n        return plates_from_a + plates_from_b >= n\n\n    left, right = 1, max(a, b)\n    result = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_distribute(mid):\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n\n# Input\nn, a, b = map(int, input().split())\n# Output\nprint(max_min_pieces(n, a, b))\n```",
    "39": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    \n    # If the entire string is not a palindrome, return its length\n    if not is_palindrome(s):\n        return n\n    \n    # If the entire string is a palindrome, check for non-palindrome substrings\n    for i in range(n):\n        for j in range(i + 1, n):\n            substring = s[i:j + 1]\n            if not is_palindrome(substring):\n                return j - i + 1\n    \n    return 0\n\n# Input\ns = input().strip()\n# Output\nprint(longest_non_palindrome_substring(s))\n```",
    "29": "```python\ndef min_replacements_to_lucky_ticket(ticket):\n    first_half = ticket[:3]\n    second_half = ticket[3:]\n\n    sum_first = sum(int(digit) for digit in first_half)\n    sum_second = sum(int(digit) for digit in second_half)\n\n    if sum_first == sum_second:\n        return 0\n\n    # Calculate the difference\n    diff = abs(sum_first - sum_second)\n    \n    # Create a list of possible changes\n    changes = []\n    for digit in first_half:\n        changes.append(9 - int(digit))  # max change if we change this digit to 9\n    for digit in second_half:\n        changes.append(int(digit))  # max change if we change this digit to 0\n    \n    # Sort the changes in descending order\n    changes.sort(reverse=True)\n\n    # Count the minimum number of changes needed\n    replacements = 0\n    for change in changes:\n        diff -= change\n        replacements += 1\n        if diff <= 0:\n            break\n\n    return replacements\n\n# Input reading and function call\nticket = input().strip()\nprint(min_replacements_to_lucky_ticket(ticket))\n```",
    "35": "```python\ndef is_valid_flag(n, m, grid):\n    # Check for horizontal stripes\n    if n % 3 == 0:\n        stripe_height = n // 3\n        colors = set()\n        for i in range(3):\n            stripe = grid[i * stripe_height:(i + 1) * stripe_height]\n            first_color = stripe[0][0]\n            colors.add(first_color)\n            if any(row != first_color * m for row in stripe):\n                return \"NO\"\n        return \"YES\" if len(colors) == 3 else \"NO\"\n\n    # Check for vertical stripes\n    if m % 3 == 0:\n        stripe_width = m // 3\n        colors = set()\n        for i in range(3):\n            stripe = [row[i * stripe_width:(i + 1) * stripe_width] for row in grid]\n            first_color = stripe[0][0]\n            colors.add(first_color)\n            if any(row != first_color * stripe_width for row in stripe):\n                return \"NO\"\n        return \"YES\" if len(colors) == 3 else \"NO\"\n\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output result\nprint(is_valid_flag(n, m, grid))\n```",
    "33": "```python\ndef count_common_ap(a1, b1, a2, b2, L, R):\n    def first_valid(start, step, lower_bound):\n        if start > lower_bound:\n            return start\n        if (lower_bound - start) % step == 0:\n            return lower_bound\n        return start + ((lower_bound - start) // step + 1) * step\n\n    def last_valid(start, step, upper_bound):\n        if start > upper_bound:\n            return -1\n        return start + ((upper_bound - start) // step) * step\n\n    # Calculate the first and last valid x for both sequences\n    x1_start = b1\n    x2_start = b2\n    \n    # Find the first valid x in the range [L, R]\n    x1_first = first_valid(x1_start, a1, L)\n    x2_first = first_valid(x2_start, a2, L)\n\n    # Find the last valid x in the range [L, R]\n    x1_last = last_valid(x1_start, a1, R)\n    x2_last = last_valid(x2_start, a2, R)\n\n    # Initialize the count of common integers\n    count = 0\n\n    # Iterate through the arithmetic sequence of one of the progressions\n    for x in range(x1_first, x1_last + 1, a1):\n        if (x - b2) % a2 == 0 and L <= x <= R:\n            count += 1\n\n    return count\n\n# Input reading\na1, b1, a2, b2, L, R = map(int, input().strip().split())\nresult = count_common_ap(a1, b1, a2, b2, L, R)\nprint(result)\n```",
    "36": "```python\ndef hex_spiral_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    # Determine the layer of the spiral\n    layer = 0\n    while n > 6 * layer * (layer + 1) // 2:\n        layer += 1\n\n    # Calculate the position in the current layer\n    position_in_layer = n - 6 * (layer - 1) * layer // 2\n    side_length = layer\n\n    # Calculate hexagon coordinates based on the layer and position\n    x, y = 0, 0\n    if position_in_layer <= side_length:\n        x = side_length\n        y = position_in_layer - side_length\n    elif position_in_layer <= 2 * side_length:\n        x = side_length - (position_in_layer - side_length)\n        y = side_length\n    elif position_in_layer <= 3 * side_length:\n        x = -side_length\n        y = side_length - (position_in_layer - 2 * side_length)\n    elif position_in_layer <= 4 * side_length:\n        x = -side_length + (position_in_layer - 3 * side_length)\n        y = -side_length\n    elif position_in_layer <= 5 * side_length:\n        x = side_length\n        y = -side_length + (position_in_layer - 4 * side_length)\n    else:\n        x = side_length - (position_in_layer - 5 * side_length)\n        y = side_length\n\n    return (x, y)\n\nn = int(input())\nx, y = hex_spiral_coordinates(n)\nprint(x, y)\n```",
    "38": "```python\ndef can_tracks_coincide(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between barriers for Kefa and Sasha\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Double the Sasha's differences to handle circular matching\n    sasha_diffs_extended = sasha_diffs + sasha_diffs\n\n    # Check if Kefa's differences exist as a contiguous subsequence in the extended Sasha's differences\n    for i in range(n):\n        if kefa_diffs == sasha_diffs_extended[i:i+n]:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input handling\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_distances, sasha_distances))\n```",
    "40": "```python\ndef determine_round_status(n, ratings):\n    # Check if any rating has changed\n    rated = any(a != b for a, b in ratings)\n    if rated:\n        return \"rated\"\n\n    # Check for the order of participants\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            return \"unrated\"\n\n    return \"maybe\"\n\ndef main():\n    n = int(input())\n    ratings = [tuple(map(int, input().split())) for _ in range(n)]\n    result = determine_round_status(n, ratings)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "41": "```python\ndef nearest_zero_distance(n, array):\n    distances = [float('inf')] * n\n    last_zero_index = -1\n\n    # Forward pass to find distances to the nearest zero on the left\n    for i in range(n):\n        if array[i] == 0:\n            last_zero_index = i\n            distances[i] = 0\n        elif last_zero_index != -1:\n            distances[i] = i - last_zero_index\n\n    # Backward pass to find distances to the nearest zero on the right\n    last_zero_index = -1\n    for i in range(n-1, -1, -1):\n        if array[i] == 0:\n            last_zero_index = i\n        elif last_zero_index != -1:\n            distances[i] = min(distances[i], last_zero_index - i)\n\n    return distances\n\n# Input reading\nn = int(input())\narray = list(map(int, input().split()))\n\n# Calculate distances and print the result\nresult = nearest_zero_distance(n, array)\nprint(' '.join(map(str, result)))\n```",
    "42": "```python\ndef count_cyclic_strings(n, s):\n    from collections import defaultdict\n\n    m = len(s)\n    # Create all possible binary strings of length n\n    total_strings = 2 ** n\n\n    # Function to check if a string contains s as a substring\n    def contains_substring(t):\n        t_double = t + t  # To account for cyclic shifts\n        return s in t_double\n\n    # Count valid cyclic strings\n    valid_count = 0\n    for i in range(total_strings):\n        t = bin(i)[2:].zfill(n)  # Get binary representation of length n\n        if contains_substring(t):\n            valid_count += 1\n\n    return valid_count\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(count_cyclic_strings(n, s))\n```",
    "31": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef birthday_probability(n, k):\n    days = 1 << n  # 2^n\n    if k > days:  # More people than days, guaranteed collision\n        return (1, 1)\n    \n    total_ways = days ** k\n    no_collision_ways = 1\n    for i in range(k):\n        no_collision_ways *= (days - i)\n    \n    A = total_ways - no_collision_ways\n    B = total_ways\n    \n    # Reduce A and B\n    common_gcd = gcd(A, B)\n    A //= common_gcd\n    B //= common_gcd\n    \n    # Return A and B modulo 1000003\n    return A % 1000003, B % 1000003\n\n# Read input\nn, k = map(int, input().split())\nresult = birthday_probability(n, k)\nprint(result[0], result[1])\n```",
    "45": "```python\ndef find_sequence(n, k):\n    # Minimum sum required for k distinct positive integers\n    min_sum = k * (k + 1) // 2\n    \n    if n < min_sum:\n        return -1  # Not enough to form k distinct positive integers\n    \n    # Calculate the maximum GCD that can be used\n    g = (n - min_sum) // k + 1\n    \n    # Generate the sequence\n    sequence = [(i + g) for i in range(1, k + 1)]\n    \n    return sequence\n\n# Input reading\nn, k = map(int, input().strip().split())\n\n# Finding the sequence\nresult = find_sequence(n, k)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))\n```",
    "46": "```python\ndef count_divisible_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n    \n    # Count occurrences of each remainder for x from 1 to n\n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n        \n    # Count occurrences of each remainder for y from 1 to m\n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n        \n    # Calculate the number of valid pairs\n    result = 0\n    for k in range(5):\n        result += count_x[k] * count_y[(5 - k) % 5]\n    \n    return result\n\n# Input reading\nn, m = map(int, input().split())\n# Output the result\nprint(count_divisible_pairs(n, m))\n```",
    "44": "```python\ndef min_time_to_post_office(d, k, a, b, t):\n    # If d is less than or equal to k, we can drive the entire distance without repairs\n    if d <= k:\n        return d * a\n    \n    # Calculate the time using only the car and the time using both car and walking\n    full_drive_time = (d // k) * (k * a + t) + (d % k) * a\n    walking_time = d * b\n    \n    # Calculate the minimum time by evaluating combinations of driving and walking\n    min_time = min(full_drive_time, walking_time)\n    \n    # Evaluate the cases where we can drive part of the distance and walk the rest\n    for i in range(d // k + 1):\n        distance_driven = i * k\n        remaining_distance = d - distance_driven\n        \n        # Time spent driving i segments of k km and walking the remaining distance\n        if remaining_distance >= 0:\n            current_time = (i * (k * a + t) - t) + remaining_distance * b\n            min_time = min(min_time, current_time)\n    \n    return min_time\n\n# Input reading\nd, k, a, b, t = map(int, input().strip().split())\nprint(min_time_to_post_office(d, k, a, b, t))\n```",
    "48": "```python\ndef kth_largest_in_multiplication_table(n, m, k):\n    left, right = 1, n * m\n\n    while left < right:\n        mid = (left + right) // 2\n        count = sum(min(mid // i, m) for i in range(1, n + 1))\n\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left\n\n# Read input\nn, m, k = map(int, input().split())\n# Output the k-th largest number\nprint(kth_largest_in_multiplication_table(n, m, k))\n```",
    "49": "```python\ndef find_kth_digit(k):\n    digit_length = 1\n    count = 9\n    start = 1\n    \n    # Determine the range where the k-th digit lies\n    while k > digit_length * count:\n        k -= digit_length * count\n        digit_length += 1\n        count *= 10\n        start *= 10\n    \n    # Find the actual number containing the k-th digit\n    start += (k - 1) // digit_length\n    number_str = str(start)\n    \n    # Find the specific digit in that number\n    digit_index = (k - 1) % digit_length\n    \n    return number_str[digit_index]\n\n# Read input\nk = int(input().strip())\n# Print the k-th digit\nprint(find_kth_digit(k))\n```",
    "56": "```python\ndef f(x):\n    x += 1\n    while x % 10 == 0:\n        x //= 10\n    return x\n\ndef count_reachable(n):\n    reachable = set()\n    current = n\n    \n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n        \n    return len(reachable)\n\nn = int(input().strip())\nprint(count_reachable(n))\n```",
    "51": "```python\nfrom collections import Counter\nimport sys\n\ndef find_x_and_y(divisors):\n    divisor_count = Counter(divisors)\n    \n    # The maximum divisor must be either x or y\n    max_divisor = max(divisor_count)\n    \n    # Find all possible pairs (x, y) using the divisors\n    for d in divisor_count:\n        if divisor_count[d] == 2:\n            # d could be a common divisor\n            x = d * (max_divisor // d)\n            y = max_divisor\n            if all((x % k == 0 or y % k == 0) for k in divisor_count):\n                return x, y\n    \n    # If no common divisor found, return default case\n    return max_divisor, max_divisor\n\n# Input reading\nn = int(input().strip())\ndivisors = list(map(int, input().strip().split()))\n\nx, y = find_x_and_y(divisors)\nprint(x, y)\n```",
    "54": "```python\ndef find_minimum_d(n, a):\n    min_a = min(a)\n    max_a = max(a)\n    \n    # If all elements are the same\n    if min_a == max_a:\n        return 0\n    \n    # Check the case where max_a - min_a can be divided by 2\n    if (max_a - min_a) % 2 == 0:\n        D = (max_a - min_a) // 2\n        return D\n    else:\n        return -1\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result and print it\nresult = find_minimum_d(n, a)\nprint(result)\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left, right = 0, n - 1\n    last_taken = float('-inf')\n    moves = []\n    \n    while left <= right:\n        if a[left] > last_taken and (a[right] <= last_taken or a[left] < a[right]):\n            moves.append('L')\n            last_taken = a[left]\n            left += 1\n        elif a[right] > last_taken:\n            moves.append('R')\n            last_taken = a[right]\n            right -= 1\n        else:\n            break\n\n    print(len(moves))\n    print(''.join(moves))\n\n# Input reading\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\nlongest_increasing_sequence(n, a)\n```",
    "52": "```python\ndef max_sum_divisible_by_k(n, m, k, matrix):\n    max_select = m // 2\n    dp = [[-1] * k for _ in range(max_select + 1)]\n    dp[0][0] = 0\n\n    for row in matrix:\n        new_dp = [dp_row[:] for dp_row in dp]\n        row.sort(reverse=True)\n\n        for num in row[:max_select]:\n            for count in range(max_select - 1, -1, -1):\n                for mod in range(k):\n                    if dp[count][mod] != -1:\n                        new_sum = dp[count][mod] + num\n                        new_mod = new_sum % k\n                        new_dp[count + 1][new_mod] = max(new_dp[count + 1][new_mod], new_sum)\n        dp = new_dp\n\n    return max(dp[count][0] for count in range(max_select + 1) if dp[count][0] != -1)\n\n# Reading input\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Getting the result\nresult = max_sum_divisible_by_k(n, m, k, matrix)\n\n# Printing the output\nprint(result)\n```",
    "43": "```python\nimport sys\nimport math\n\ndef find_min_angle_pair(vectors):\n    angles = []\n    \n    # Calculate angles and their indices\n    for idx, (x, y) in enumerate(vectors):\n        angle = math.atan2(y, x)\n        angles.append((angle, idx + 1))  # store 1-based index\n\n    # Sort angles\n    angles.sort()\n\n    # Add the first angle + 2π to handle the circular nature\n    angles.append((angles[0][0] + 2 * math.pi, angles[0][1]))\n\n    min_angle = float('inf')\n    min_pair = None\n\n    # Compare adjacent angles to find the minimal angle\n    for i in range(len(angles) - 1):\n        angle1, idx1 = angles[i]\n        angle2, idx2 = angles[i + 1]\n        delta_angle = angle2 - angle1\n\n        if delta_angle < min_angle:\n            min_angle = delta_angle\n            min_pair = (idx1, idx2)\n\n    return min_pair\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    n = int(data[0])\n    vectors = [tuple(map(int, line.split())) for line in data[1:n + 1]]\n\n    result = find_min_angle_pair(vectors)\n    print(result[0], result[1])\n```",
    "47": "```python\ndef max_beauty_with_multiplier(n, x, a):\n    # Function to calculate the maximum subarray sum using Kadane's algorithm\n    def kadane(arr):\n        max_sum, current_sum = 0, 0\n        for value in arr:\n            current_sum = max(0, current_sum + value)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n\n    # Calculate the base beauty (maximum sum of any subarray without modification)\n    base_beauty = kadane(a)\n\n    # To store the maximum beauty after multiplying a subarray by x\n    max_beauty = base_beauty\n\n    # Try to find the maximum beauty after multiplying any subarray by x\n    for i in range(n):\n        current_sum = 0  # Sum of the current subarray\n        for j in range(i, n):\n            current_sum += a[j]\n            # Calculate the beauty with the subarray a[i:j+1] multiplied by x\n            modified_sum = current_sum * x\n            new_total = modified_sum + kadane(a[:i]) + kadane(a[j + 1:])\n            max_beauty = max(max_beauty, new_total)\n\n    return max_beauty\n\n# Reading input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Getting the maximum beauty after applying the operation\nresult = max_beauty_with_multiplier(n, x, a)\n\n# Output the result\nprint(result)\n```",
    "50": "```python\nfrom collections import defaultdict, deque\n\ndef bfs(start, graph):\n    visited = {start}\n    queue = deque([start])\n    farthest_node = start\n    max_distance = 0\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                if len(visited) > max_distance:\n                    max_distance = len(visited)\n                    farthest_node = neighbor\n\n    return farthest_node, max_distance\n\ndef find_three_nodes(n, edges):\n    graph = defaultdict(list)\n    \n    # Build the tree\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Find the farthest node from an arbitrary starting point (node 1)\n    farthest_from_start, _ = bfs(1, graph)\n    \n    # Find the farthest node from the previously found node\n    farthest_from_a, _ = bfs(farthest_from_start, graph)\n    \n    # Find the farthest node from the second farthest node\n    farthest_from_b, max_edges = bfs(farthest_from_a, graph)\n    \n    return max_edges, farthest_from_start, farthest_from_b\n\n# Input\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\n# Find the result\nmax_edges, a, b = find_three_nodes(n, edges)\n\n# Output\nprint(max_edges)\nprint(a, b, (b % n) + 1)  # Just to ensure three distinct vertices\n```",
    "57": "```python\ndef fill_gifts(n, f):\n    givers = []\n    receivers = set(range(1, n + 1))\n\n    # Identify the friends who have specific targets and those that do not\n    for i in range(n):\n        if f[i] == 0:\n            givers.append(i + 1)  # Store the 1-based index of friends who don't know\n        else:\n            receivers.discard(f[i])  # Remove the known receivers from the set\n\n    # Now 'givers' contains friends that need to assign gifts\n    # 'receivers' contains friends who can be assigned gifts\n    receivers = list(receivers)\n\n    # Fill in the gifts for those who had 0\n    for i in range(len(givers)):\n        giver = givers[i]\n        receiver = receivers[i]\n        f[giver - 1] = receiver  # Assign the gift\n\n    return f\n\n# Read input\nn = int(input())\nf = list(map(int, input().split()))\n\n# Fill the gift assignments\nresult = fill_gifts(n, f)\n\n# Print the result\nprint(\" \".join(map(str, result)))\n```",
    "60": "```python\ndef has_palindromic_subsequence(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        found = False\n        seen = {}\n        \n        for i in range(n):\n            if a[i] in seen:\n                if i - seen[a[i]] > 1:  # Check distance between occurrences\n                    found = True\n                    break\n            seen[a[i]] = i\n        \n        results.append(\"YES\" if found else \"NO\")\n    \n    return results\n\n# Input reading\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Get results and print them\nresults = has_palindromic_subsequence(t, test_cases)\nprint(\"\\n\".join(results))\n```",
    "58": "```python\ndef color_array(n, k, a):\n    from collections import defaultdict\n    \n    # Track the frequency of each number\n    freq = defaultdict(int)\n    for num in a:\n        freq[num] += 1\n    \n    # If the maximum frequency of any number exceeds the number of colors, it's impossible\n    max_freq = max(freq.values())\n    if max_freq > k:\n        print(\"NO\")\n        return\n    \n    # Prepare to store the coloring result\n    coloring = [0] * n\n    color_used = defaultdict(int)\n    \n    # Assign colors\n    for i in range(n):\n        num = a[i]\n        # Use a color not used for this number yet\n        color_used[num] += 1\n        coloring[i] = color_used[num]\n        \n        # If we exceed the number of colors, reset to 1\n        if color_used[num] > k:\n            color_used[num] = 1\n    \n    print(\"YES\")\n    print(\" \".join(map(str, coloring)))\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Call the function\ncolor_array(n, k, a)\n```",
    "61": "```python\ndef max_transformed_number(n, a, f):\n    a_list = list(a)\n    transformed = False\n\n    for i in range(n):\n        original_digit = int(a_list[i])\n        new_digit = f[original_digit - 1]\n        \n        if new_digit > original_digit and not transformed:\n            # Start transforming\n            transformed = True\n            a_list[i] = str(new_digit)\n        elif new_digit < original_digit and transformed:\n            # Stop transforming if we encounter a digit that would not increase the number\n            break\n        elif transformed:\n            # Continue transforming\n            a_list[i] = str(new_digit)\n\n    return ''.join(a_list)\n\n# Input reading\nn = int(input().strip())\na = input().strip()\nf = list(map(int, input().strip().split()))\n\n# Get the result and print it\nresult = max_transformed_number(n, a, f)\nprint(result)\n```",
    "63": "```python\ndef min_instability(n, a):\n    # Sort the array to easily find the max and min after removing one element\n    a.sort()\n\n    # The instability after removing the first or last element\n    instability_remove_first = a[-1] - a[1]\n    instability_remove_last = a[-2] - a[0]\n\n    # The minimum instability will be the minimum of the two calculated values\n    return min(instability_remove_first, instability_remove_last)\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the minimum possible instability\nprint(min_instability(n, a))\n```",
    "55": "```python\ndef is_white_sheet_visible(white_sheet, black_sheets):\n    x1, y1, x2, y2 = white_sheet\n    x3, y3, x4, y4 = black_sheets[0]\n    x5, y5, x6, y6 = black_sheets[1]\n\n    # Check for any visible point not strictly inside the white sheet\n    # and strictly outside both black sheets.\n    \n    # Conditions for visibility:\n    visible_area = (\n        (x2 < x3) or  # Right of first black sheet\n        (x1 > x4) or  # Left of first black sheet\n        (y2 < y3) or  # Above first black sheet\n        (y1 > y4) or  # Below first black sheet\n        (x2 < x5) or  # Right of second black sheet\n        (x1 > x6) or  # Left of second black sheet\n        (y2 < y5) or  # Above second black sheet\n        (y1 > y6)     # Below second black sheet\n    )\n    \n    return \"YES\" if visible_area else \"NO\"\n\n# Read input\nwhite_sheet = list(map(int, input().split()))\nblack_sheets = [list(map(int, input().split())), list(map(int, input().split()))]\n\n# Output result\nprint(is_white_sheet_visible(white_sheet, black_sheets))\n```",
    "59": "```python\ndef min_operations(n, x, y, number):\n    # The length of the number is n\n    # We need to ensure the last x digits of the number give remainder 10^y\n    \n    # The target pattern\n    target = ['0'] * x\n    target[y] = '1'  # Set the y-th position to 1 as required\n    \n    # Count operations needed\n    operations = 0\n    \n    # We only need to check the last x digits of the number\n    for i in range(x):\n        if number[n - 1 - i] != target[x - 1 - i]:\n            operations += 1\n            \n    return operations\n\n# Input reading\nn, x, y = map(int, input().split())\nnumber = input().strip()\n\n# Calculate and print the result\nresult = min_operations(n, x, y, number)\nprint(result)\n```",
    "65": "```python\ndef min_moves(n, m):\n    if m % n != 0:\n        return -1\n    \n    quotient = m // n\n    moves = 0\n    \n    while quotient > 1:\n        if quotient % 2 == 0:\n            quotient //= 2\n            moves += 1\n        elif quotient % 3 == 0:\n            quotient //= 3\n            moves += 1\n        else:\n            return -1\n            \n    return moves\n\n# Input reading\nn, m = map(int, input().split())\n# Output the result\nprint(min_moves(n, m))\n```",
    "66": "```python\ndef minimum_length_string(n, k, t):\n    # Find the longest prefix which is also a suffix\n    for length in range(n-1, 0, -1):\n        if t[:length] == t[-length:]:\n            overlap_length = length\n            break\n    else:\n        overlap_length = 0\n    \n    # Construct the result string\n    result = t + (t[overlap_length:] * (k - 1))\n    return result\n\n# Input reading\nn, k = map(int, input().split())\nt = input().strip()\n\n# Get the result and print it\nresult = minimum_length_string(n, k, t)\nprint(result)\n```",
    "71": "```python\ndef find_integer(a):\n    return (a - 1).bit_length()\n\nif __name__ == \"__main__\":\n    a = int(input().strip())\n    print(find_integer(a))\n```",
    "62": "```python\ndef min_operations(test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        min_moves = float('inf')\n        best_triplet = (a, b, c)\n        \n        for A in range(1, a + 1):\n            for B in range(A, 10001):\n                if B % A != 0:\n                    continue\n                for C in range(B, 10001):\n                    if C % B == 0:\n                        moves = abs(A - a) + abs(B - b) + abs(C - c)\n                        if moves < min_moves:\n                            min_moves = moves\n                            best_triplet = (A, B, C)\n\n        results.append((min_moves, best_triplet))\n    \n    return results\n\ndef main():\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = min_operations(test_cases)\n    \n    for moves, triplet in results:\n        print(moves)\n        print(*triplet)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "67": "```python\ndef find_nice_indices(n, a):\n    total_sum = sum(a)\n    nice_indices = []\n\n    for i in range(n):\n        if (total_sum - a[i]) == a[i]:\n            nice_indices.append(i + 1)\n        elif (total_sum - a[i]) % 2 == 0:\n            target = (total_sum - a[i]) // 2\n            if target in a and target != a[i]:\n                nice_indices.append(i + 1)\n\n    return nice_indices\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Find nice indices\nnice_indices = find_nice_indices(n, a)\n\n# Output result\nprint(len(nice_indices))\nif nice_indices:\n    print(' '.join(map(str, nice_indices)))\n```",
    "73": "```python\ndef can_complete_wall(n, heights):\n    max_height = max(heights)\n    total_bricks_needed = 0\n    \n    for height in heights:\n        total_bricks_needed += max_height - height\n        \n    return total_bricks_needed % 2 == 0\n\n# Input reading\nn = int(input())\nheights = list(map(int, input().split()))\n\n# Output result\nif can_complete_wall(n, heights):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```",
    "70": "```python\ndef midpoint_of_contest(h1, m1, h2, m2):\n    # Convert start and end times to total minutes\n    start_minutes = h1 * 60 + m1\n    end_minutes = h2 * 60 + m2\n    \n    # Calculate the midpoint in total minutes\n    midpoint_minutes = (start_minutes + end_minutes) // 2\n    \n    # Convert back to hours and minutes\n    h3 = midpoint_minutes // 60\n    m3 = midpoint_minutes % 60\n    \n    # Format the output with leading zeros\n    print(f\"{h3:02}:{m3:02}\")\n\n# Read input\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Calculate and print the midpoint\nmidpoint_of_contest(h1, m1, h2, m2)\n```",
    "77": "```python\ndef minimum_difference(n):\n    total_sum = n * (n + 1) // 2\n    return total_sum % 2\n\nn = int(input().strip())\nprint(minimum_difference(n))\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    left = [0] * n\n    right = [0] * n\n    \n    for i in range(n):\n        left[i], right[i] = segments[i]\n\n    max_l = max(left)\n    min_r = min(right)\n    \n    max_length = 0\n\n    for i in range(n):\n        current_l = max(max_l, left[i])\n        current_r = min(min_r, right[i])\n        \n        if current_r >= current_l:\n            length = current_r - current_l\n        else:\n            length = 0\n        \n        max_length = max(max_length, length)\n        \n        if left[i] == max_l or right[i] == min_r:\n            new_l = max(l for j, l in enumerate(left) if j != i)\n            new_r = min(r for j, r in enumerate(right) if j != i)\n            if new_r >= new_l:\n                length = new_r - new_l\n            else:\n                length = 0\n            \n            max_length = max(max_length, length)\n\n    return max_length\n\nn = int(input().strip())\nsegments = [tuple(map(int, input().strip().split())) for _ in range(n)]\nprint(max_intersection_length(n, segments))\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    # Create a result list initialized with zeros\n    result = [0] * n\n    # To keep track of preparation days needed\n    prepare_needed = [0] * m\n    # To keep track of exam days\n    exam_days = set()\n\n    for idx, (s, d, c) in enumerate(exams):\n        prepare_needed[idx] = c\n        exam_days.add(d)\n\n    # Prepare the days for exams\n    for i in range(n):\n        day = i + 1\n        if day in exam_days:\n            exam_index = next(idx for idx, (s, d, c) in enumerate(exams) if d == day)\n            result[i] = exam_index + 1  # Exams are 1-indexed\n            prepare_needed[exam_index] = max(0, prepare_needed[exam_index] - (day - exams[exam_index][0]))\n        else:\n            for exam_index in range(m):\n                s, d, c = exams[exam_index]\n                if s <= day < d and prepare_needed[exam_index] > 0:\n                    result[i] = exam_index + 1  # Preparing for exam (1-indexed)\n                    prepare_needed[exam_index] -= 1\n                    break\n\n    # Check if all preparation days were satisfied\n    if any(c > 0 for c in prepare_needed):\n        return -1\n\n    return result\n\n# Read input\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the schedule\nresult = schedule_exams(n, m, exams)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n```",
    "68": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    from collections import defaultdict\n    \n    # Count frequency of each character in the string\n    freq = defaultdict(int)\n    for char in s:\n        freq[char] += 1\n    \n    # Calculate all unique subsequences and their costs\n    unique_subsequences = set()\n    total_cost = 0\n    max_possible_subsequences = 0\n    \n    # Generate subsequences using bit masking\n    for i in range(1 << n):\n        subsequence = []\n        for j in range(n):\n            if i & (1 << j):\n                subsequence.append(s[j])\n        subsequence_str = ''.join(subsequence)\n        if subsequence_str not in unique_subsequences:\n            unique_subsequences.add(subsequence_str)\n            cost = n - len(subsequence_str)\n            total_cost += cost\n            max_possible_subsequences += 1\n            \n            if max_possible_subsequences >= k:\n                return total_cost\n    \n    # If we can't create enough unique subsequences\n    if max_possible_subsequences < k:\n        return -1\n    \n    return total_cost\n\n# Read inputs\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result and print it\nresult = min_cost_to_obtain_set(n, k, s)\nprint(result)\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    s = str(n)\n    length = len(s)\n    moves = float('inf')\n\n    # Look for pairs of digits that make the number divisible by 25\n    for i in range(length - 1):\n        for j in range(i + 1, length):\n            if (s[i] == '0' and s[j] == '5') or (s[i] == '5' and s[j] == '0'):\n                # Count moves to bring s[j] to s[i+1] and s[i] to s[i]\n                moves_needed = (j - i) + (i + 1 - j)\n                moves = min(moves, moves_needed)\n\n    if moves == float('inf'):\n        return -1\n    return moves\n\n# Input reading\nn = int(input().strip())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "75": "```python\ndef max_days(a, b, c):\n    # Days of the week food types\n    food_schedule = [0, 0, 1, 2, 0, 1, 2, 0]  # 0: fish, 1: rabbit, 2: chicken\n    max_days = 0\n\n    # Simulate starting from each day of the week\n    for start_day in range(7):\n        fish = a\n        rabbit = b\n        chicken = c\n        days = 0\n        \n        # Continue eating until we run out of food\n        while True:\n            current_food = food_schedule[(start_day + days) % 7]\n            if current_food == 0:\n                if fish > 0:\n                    fish -= 1\n                else:\n                    break\n            elif current_food == 1:\n                if rabbit > 0:\n                    rabbit -= 1\n                else:\n                    break\n            else:  # current_food == 2\n                if chicken > 0:\n                    chicken -= 1\n                else:\n                    break\n            days += 1\n        \n        max_days = max(max_days, days)\n\n    return max_days\n\n# Read input\na, b, c = map(int, input().split())\n# Output the result\nprint(max_days(a, b, c))\n```",
    "76": "```python\ndef can_construct_symmetric_square(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, tiles = case\n        if m % 2 != 0:\n            results.append(\"NO\")\n            continue\n\n        can_form = False\n        for i in range(n):\n            for j in range(n):\n                # Check if tiles i and j can form a symmetric matrix\n                if tiles[i][1][0] == tiles[j][0][0] and tiles[i][1][1] == tiles[j][0][1]:\n                    can_form = True\n                    break\n            if can_form:\n                break\n\n        results.append(\"YES\" if can_form else \"NO\")\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        top = list(map(int, input().split()))\n        bottom = list(map(int, input().split()))\n        tiles.append((top, bottom))\n    test_cases.append((n, m, tiles))\n\n# Get results\nresults = can_construct_symmetric_square(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```",
    "74": "```python\ndef min_cost_to_obtain_set(n, k, s):\n    unique_subsequences = set()\n    \n    # Generate all unique subsequences\n    for i in range(1 << n):\n        subsequence = ''.join(s[j] for j in range(n) if (i & (1 << j)))\n        unique_subsequences.add(subsequence)\n    \n    # Remove the empty subsequence\n    if '' in unique_subsequences:\n        unique_subsequences.remove('')\n    \n    # If the number of unique subsequences is less than k, return -1\n    if len(unique_subsequences) < k:\n        return -1\n    \n    # Calculate costs for each unique subsequence\n    costs = []\n    for subseq in unique_subsequences:\n        cost = n - len(subseq)\n        costs.append(cost)\n    \n    # Sort costs and return the sum of the smallest k costs\n    costs.sort()\n    return sum(costs[:k])\n\n# Input reading\nn, k = map(int, input().strip().split())\ns = input().strip()\n\n# Output the result\nprint(min_cost_to_obtain_set(n, k, s))\n```",
    "81": "```python\ndef can_reorder_strings(strings):\n    # Sort strings by length\n    strings.sort(key=len)\n\n    for i in range(len(strings)):\n        for j in range(i):\n            if strings[j] not in strings[i]:\n                return \"NO\"\n\n    return \"YES\", strings\n\ndef main():\n    n = int(input())\n    strings = [input().strip() for _ in range(n)]\n    \n    result = can_reorder_strings(strings)\n\n    if result == \"NO\":\n        print(result)\n    else:\n        print(result[0])\n        for string in result[1]:\n            print(string)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "82": "```python\ndef max_problems_solved(n, k, difficulties):\n    left = 0\n    right = n - 1\n    solved_count = 0\n\n    while left <= right:\n        if difficulties[left] <= k:\n            solved_count += 1\n            left += 1\n        elif difficulties[right] <= k:\n            solved_count += 1\n            right -= 1\n        else:\n            break\n\n    return solved_count\n\n# Input reading\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = max_problems_solved(n, k, difficulties)\nprint(result)\n```",
    "69": "```python\ndef find_spanning_tree(n, m, D, edges):\n    from collections import defaultdict, deque\n    \n    # Build the adjacency list\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n\n    # Check if the degree of vertex 1 can be exactly D\n    if D > len(graph[1]):\n        return \"NO\"\n\n    # BFS to find a spanning tree with the desired degree\n    spanning_tree_edges = []\n    visited = [False] * (n + 1)\n    visited[1] = True\n    queue = deque([1])\n    degree = 0\n\n    while queue:\n        node = queue.popleft()\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                spanning_tree_edges.append((node, neighbor))\n                queue.append(neighbor)\n\n                # Count the degree for the first vertex\n                if node == 1:\n                    degree += 1\n\n                # If we have reached the desired degree for vertex 1\n                if node == 1 and degree == D:\n                    break\n\n        # If we reached the desired degree, we can stop\n        if degree == D:\n            break\n\n    # If we have not reached the desired degree of vertex 1\n    if degree < D:\n        return \"NO\"\n\n    # Now we need to add more edges if we have less than n-1 edges in the spanning tree\n    if len(spanning_tree_edges) < n - 1:\n        for v, u in edges:\n            if len(spanning_tree_edges) >= n - 1:\n                break\n            if (v, u) not in spanning_tree_edges and (u, v) not in spanning_tree_edges:\n                if visited[v] and visited[u]:\n                    continue\n                spanning_tree_edges.append((v, u))\n                visited[v] = True\n                visited[u] = True\n\n    # Check if we have exactly n-1 edges\n    if len(spanning_tree_edges) != n - 1:\n        return \"NO\"\n\n    result = [\"YES\"]\n    result.extend(f\"{v} {u}\" for v, u in spanning_tree_edges)\n    return \"\\n\".join(result)\n\n# Input reading\nn, m, D = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the result\nresult = find_spanning_tree(n, m, D, edges)\nprint(result)\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    # Sort projects based on the rating needed to complete them\n    projects.sort(key=lambda x: x[0])\n\n    completed_projects = 0\n    current_rating = r\n\n    for a, b in projects:\n        if current_rating >= a:\n            completed_projects += 1\n            current_rating += b\n            # Ensure rating doesn't fall below zero\n            if current_rating < 0:\n                current_rating = 0\n                \n    return completed_projects\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and output the maximum number of projects\nprint(max_projects(n, r, projects))\n```",
    "78": "```python\nMOD = 10**9 + 7\n\ndef count_regular_sequences(n, s):\n    m = len(s)\n    min_balance = 0\n    current_balance = 0\n\n    for char in s:\n        if char == '(':\n            current_balance += 1\n        else:\n            current_balance -= 1\n        min_balance = min(min_balance, current_balance)\n\n    if current_balance + n < 0 or current_balance > n:\n        return 0\n\n    total_open_needed = (n - current_balance) // 2\n    total_close_needed = n - total_open_needed\n\n    if total_open_needed < 0 or total_close_needed < 0:\n        return 0\n\n    if min_balance < 0:\n        return 0\n\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(i + 1):\n            dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % MOD\n            dp[i + 1][j] = (dp[i + 1][j] + dp[i][j] * (j + 1)) % MOD\n\n    return dp[n][0]\n\ndef main():\n    n = int(input().strip())\n    s = input().strip()\n    result = count_regular_sequences(n, s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "83": "```python\ndef minimal_perimeter(a, b):\n    total_tiles = a + b\n    min_perimeter = float('inf')\n\n    for height in range(1, int(total_tiles**0.5) + 1):\n        if total_tiles % height == 0:\n            width = total_tiles // height\n            \n            # Check if we can fit red and blue\n            for w in range(1, width + 1):\n                h_r = (a + w - 1) // w  # Minimum height for red\n                h_b = (b + (width - w) - 1) // (width - w) if (width - w) > 0 else float('inf')\n\n                if h_r + h_b <= height:\n                    perimeter = 2 * (width + height)\n                    min_perimeter = min(min_perimeter, perimeter)\n\n    return min_perimeter\n\n# Read input\na, b = map(int, input().split())\n# Calculate and print the minimal perimeter\nprint(minimal_perimeter(a, b))\n```",
    "85": "```python\ndef find_price_before_tax(A, B):\n    for price in range(1, 10000):  # Arbitrarily high range for price\n        tax_8 = int(price * 0.08)\n        tax_10 = int(price * 0.10)\n        if tax_8 == A and tax_10 == B:\n            return price\n    return -1\n\n# Read input\nA, B = map(int, input().split())\n# Print the result\nprint(find_price_before_tax(A, B))\n```",
    "80": "```python\ndef min_colors_to_sort(n, s):\n    color_count = 1\n    colors = [0] * n\n    last_position = {}\n\n    for i in range(n):\n        char = s[i]\n        if char in last_position:\n            # If the character was seen before, check if we need a new color\n            if last_position[char] != -1:\n                for j in range(last_position[char] + 1, i):\n                    if s[j] < char and colors[j] == 0:\n                        # If we find a character that is less than the current character\n                        # and is not yet colored, we need a new color\n                        color_count += 1\n                        break\n                colors[i] = color_count\n            else:\n                colors[i] = colors[last_position[char]]\n        else:\n            colors[i] = color_count\n        \n        last_position[char] = i\n\n    # Assign colors based on the previous assignments\n    for i in range(n):\n        if colors[i] == 0:\n            colors[i] = color_count\n\n    return color_count, colors\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result\nres, coloring = min_colors_to_sort(n, s)\n\n# Print output\nprint(res)\nprint(' '.join(map(str, coloring)))\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    # Sort projects based on the required rating\n    projects.sort(key=lambda x: x[0])\n    \n    for a, b in projects:\n        if r < a:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_complete_projects(n, r, projects))\n```",
    "84": "```python\ndef can_color_string(n, s):\n    color = ['0'] * n  # Initialize all characters with color '0'\n    \n    # Create a sorted version of the string\n    sorted_s = sorted(s)\n    \n    # Map to keep track of the count of each character\n    count = {}\n    for char in s:\n        count[char] = count.get(char, 0) + 1\n        \n    # Create a position marker for when we should switch colors\n    position = 0\n    for char in sorted(count.keys()):\n        current_count = count[char]\n        # We assign color '0' to the first half and '1' to the second half\n        for i in range(position, position + current_count):\n            if i < n // 2:\n                color[i] = '0'\n            else:\n                color[i] = '1'\n        position += current_count\n    \n    # Check if the resulting coloring can actually sort the string\n    # by comparing the original and the colored version\n    colored_s = ''.join(color)\n    for i in range(1, n):\n        if s[i] < s[i - 1] and colored_s[i] == colored_s[i - 1]:\n            return \"NO\"\n    \n    return \"YES\\n\" + ''.join(color)\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult = can_color_string(n, s)\n\n# Print the result\nprint(result)\n```",
    "86": "```python\ndef solve_polycarp(n, k):\n    # Minimum sum of problems solved in k days\n    min_sum = k * (k + 1) // 2  # This is 1 + 2 + ... + k\n    if n < min_sum:\n        print(\"NO\")\n        return\n    \n    # Maximum sum of problems based on the doubling rule\n    # If we start with 1, 2, ..., k, we can double it to get a maximum\n    max_sum = k * (2 * k + 1) // 2  # This is 1 + 2 + ... + k, then double it\n    if n > max_sum:\n        print(\"NO\")\n        return\n    \n    # We can construct the solution\n    a = list(range(1, k + 1))\n    current_sum = sum(a)\n    \n    # We need to increase the sum to n\n    delta = n - current_sum\n    \n    # We will try to increase the last element as much as we can\n    for i in range(k - 1, -1, -1):\n        max_increase = a[i]  # We can increase a[i] to at most 2 * a[i]\n        increase = min(delta, max_increase)\n        a[i] += increase\n        delta -= increase\n        if delta <= 0:\n            break\n    \n    if delta > 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, a)))\n\n# Example usage:\nsolve_polycarp(26, 6)\nsolve_polycarp(8, 3)\nsolve_polycarp(1, 1)\nsolve_polycarp(9, 4)\nsolve_polycarp(7, 2)\n```",
    "92": "```python\nx = float(input().strip())\n\n# Calculate the integers a and b\na = 1\nb = int(round(x * 10 / a))\n\n# Ensure b is within the range [1, 10]\nwhile b < 1 or b > 10:\n    a += 1\n    b = int(round(x * 10 / a))\n\nprint(a, b)\n```",
    "90": "```python\ndef can_reach_end(n, m, d, c):\n    # Calculate the total length of platforms\n    total_length = sum(c)\n    \n    # If total length of platforms is less than n, check the jump distance\n    if total_length < n:\n        # The maximum position we can reach is determined by d\n        if d <= 1:\n            print(\"NO\")\n            return\n        # If we can jump more than 1 cell, we can fill the gaps\n        # with enough platforms to reach the end\n        print(\"YES\")\n        # Create the river representation\n        river = [0] * n\n        position = 0\n        \n        for i in range(m):\n            for j in range(c[i]):\n                river[position] = i + 1  # 1-indexed platform\n                position += 1\n        \n        print(\" \".join(map(str, river)))\n        return\n\n    # If we can jump beyond the width of the river\n    print(\"YES\")\n    river = [0] * n\n    position = 0\n    \n    for i in range(m):\n        for j in range(c[i]):\n            river[position] = i + 1  # 1-indexed platform\n            position += 1\n    \n    print(\" \".join(map(str, river)))\n\n# Input reading\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\ncan_reach_end(n, m, d, c)\n```",
    "88": "```python\ndef can_form_palindromic_matrix(n, numbers):\n    from collections import Counter\n    \n    count = Counter(numbers)\n    odd_count = 0\n    center_element = None\n    \n    for num, cnt in count.items():\n        if cnt % 2 != 0:\n            odd_count += 1\n            center_element = num\n        if odd_count > 1:\n            return False, []\n    \n    matrix = [[0] * n for _ in range(n)]\n    half_size = (n * n) // 2\n    \n    # Fill the matrix\n    nums = []\n    for num, cnt in count.items():\n        nums.extend([num] * (cnt // 2))\n    \n    if len(nums) < half_size:\n        return False, []\n    \n    idx = 0\n    for i in range(n):\n        for j in range(n):\n            if i < n // 2:\n                if j < n // 2:\n                    matrix[i][j] = nums[idx]\n                    matrix[i][n - j - 1] = nums[idx]\n                    matrix[n - i - 1][j] = nums[idx]\n                    matrix[n - i - 1][n - j - 1] = nums[idx]\n                    idx += 1\n                elif n % 2 == 1 and j == n // 2:\n                    matrix[i][j] = center_element\n\n    return True, matrix\n\nn = int(input().strip())\nnumbers = list(map(int, input().strip().split()))\n\nis_possible, result = can_form_palindromic_matrix(n, numbers)\n\nif is_possible:\n    print(\"YES\")\n    for row in result:\n        print(\" \".join(map(str, row)))\nelse:\n    print(\"NO\")\n```",
    "97": "```python\ndef min_coins_to_move_chips(n, positions):\n    even_count = sum(1 for x in positions if x % 2 == 0)\n    odd_count = n - even_count\n    return min(even_count, odd_count)\n\n# Input reading\nn = int(input())\npositions = list(map(int, input().split()))\n\n# Output the result\nprint(min_coins_to_move_chips(n, positions))\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    # Initialize p with the first element\n    p = [0] * n\n    p[0] = 0  # We will adjust this later\n\n    # Calculate p based on the differences in q\n    for i in range(1, n):\n        p[i] = p[i - 1] + q[i - 1]\n\n    # Find the minimum value in p to normalize the values\n    min_p = min(p)\n\n    # Normalize p so that the smallest value becomes 1\n    for i in range(n):\n        p[i] -= min_p - 1\n\n    # Check if p is a valid permutation\n    if len(set(p)) == n and all(1 <= x <= n for x in p):\n        print(\" \".join(map(str, p)))\n    else:\n        print(-1)\n\n# Read input\nn = int(input())\nq = list(map(int, input().split()))\n\n# Restore the permutation\nrestore_permutation(n, q)\n```",
    "91": "```python\ndef max_removable_length(s, t):\n    n = len(s)\n    m = len(t)\n\n    # Arrays to store the positions of characters in s that match t\n    left = [0] * m\n    right = [0] * m\n\n    # Find the first occurrence of each character of t in s from left to right\n    j = 0\n    for i in range(n):\n        if j < m and s[i] == t[j]:\n            left[j] = i\n            j += 1\n\n    # Find the first occurrence of each character of t in s from right to left\n    j = m - 1\n    for i in range(n - 1, -1, -1):\n        if j >= 0 and s[i] == t[j]:\n            right[j] = i\n            j -= 1\n\n    # Calculate the maximum removable length\n    max_length = 0\n    for i in range(m - 1):\n        max_length = max(max_length, right[i + 1] - left[i] - 1)\n\n    # Check the lengths for removing from the start and end\n    max_length = max(max_length, right[0])  # Remove from start\n    max_length = max(max_length, n - 1 - left[m - 1])  # Remove from end\n\n    return max_length\n\n# Input reading\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(max_removable_length(s, t))\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    # Initialize the counts for 'a', 'b', and 'c'\n    count_a = count_b = count_c = n\n\n    # Create a list to hold the result characters\n    res = []\n\n    # Helper function to check if the last two characters form the substring\n    def ends_with(sub):\n        return len(res) >= 2 and ''.join(res[-2:]) == sub\n\n    # Fill the result while avoiding substrings s and t\n    for _ in range(3 * n):\n        for char in 'abc':\n            if char == 'a' and count_a > 0:\n                if not (ends_with(s) or ends_with(t)):\n                    res.append(char)\n                    count_a -= 1\n                    break\n            elif char == 'b' and count_b > 0:\n                if not (ends_with(s) or ends_with(t)):\n                    res.append(char)\n                    count_b -= 1\n                    break\n            elif char == 'c' and count_c > 0:\n                if not (ends_with(s) or ends_with(t)):\n                    res.append(char)\n                    count_c -= 1\n                    break\n        else:\n            # If we can't add any character, return \"NO\"\n            return \"NO\", \"\"\n\n    return \"YES\", ''.join(res)\n\n\n# Read input values\nn = int(input().strip())\ns = input().strip()\nt = input().strip()\n\n# Generate the result\nresult = generate_string(n, s, t)\n# Print the result\nprint(result[0])\nif result[0] == \"YES\":\n    print(result[1])\n```",
    "99": "```python\ndef rock_paper_scissors(n, a1, a2, a3, b1, b2, b3):\n    # Maximum wins for Alice\n    max_wins = min(a1, b3) + min(a2, b1) + min(a3, b2)\n    \n    # Minimum wins for Alice\n    # Calculate losses for Alice\n    alice_loses = max(0, b1 - a3) + max(0, b2 - a1) + max(0, b3 - a2)\n    min_wins = n - alice_loses\n    \n    return min_wins, max_wins\n\n# Input reading\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\n# Calculate results\nmin_wins, max_wins = rock_paper_scissors(n, a1, a2, a3, b1, b2, b3)\n\n# Output results\nprint(min_wins, max_wins)\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    # Start by determining the base pattern of alternating zeros and ones\n    pattern = []\n    \n    # Determine the starting character based on the greater count\n    if a > b:\n        start_char = '0'\n        switch_char = '1'\n    else:\n        start_char = '1'\n        switch_char = '0'\n    \n    # Calculate how many switches we need\n    switches = min(x, a + b - 1)\n    \n    # Add the alternating pattern\n    for i in range(switches + 1):\n        pattern.append(start_char if i % 2 == 0 else switch_char)\n    \n    # Count the number of zeros and ones used in the alternating pattern\n    used_a = pattern.count('0')\n    used_b = pattern.count('1')\n    \n    # Calculate remaining zeros and ones\n    remaining_a = a - used_a\n    remaining_b = b - used_b\n    \n    # Fill in the remaining zeros or ones as needed\n    if remaining_a > 0:\n        pattern.append('0' * remaining_a)\n    if remaining_b > 0:\n        pattern.append('1' * remaining_b)\n    \n    # Join the pattern to form the final binary string\n    result = ''.join(pattern)\n    \n    # Print the result\n    print(result)\n\n# Read input values\na, b, x = map(int, input().split())\n\n# Construct and print the binary string\nconstruct_binary_string(a, b, x)\n```",
    "98": "```python\ndef min_moves_to_reach_n(N):\n    moves = float('inf')\n    \n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            moves = min(moves, (i - 1) + (j - 1))\n    \n    return moves\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    N = int(input().strip())\n    print(min_moves_to_reach_n(N))\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > 2 * (k - 1) + 1:\n        return \"NO\"\n    \n    if d == 1 and n > 2:\n        return \"NO\"\n    \n    if n == 1:\n        return \"YES\\n\"\n    \n    edges = []\n    \n    # Create the main path for the diameter\n    for i in range(1, d + 1):\n        edges.append((i, i + 1))\n    \n    # Create a list of nodes that are part of the main path\n    last_node = d + 1\n    \n    # For each node in the main path, add remaining nodes\n    for i in range(1, d + 1):\n        if last_node >= n:\n            break\n        while len([x for x, y in edges if x == i]) < k - 1 and last_node < n:\n            edges.append((i, last_node))\n            last_node += 1\n    \n    # If there are still nodes left, we need to attach them\n    if last_node <= n:\n        return \"NO\"\n    \n    result = \"YES\\n\" + \"\\n\".join(f\"{u} {v}\" for u, v in edges)\n    return result\n\n\n# Read input\nn, d, k = map(int, input().split())\n\n# Construct tree and print the result\nprint(construct_tree(n, d, k))\n```"
}