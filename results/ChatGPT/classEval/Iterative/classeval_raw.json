{
    "7": "```python\nclass BalancedBrackets:\n    \"\"\"\n    This is a class that checks for bracket matching.\n    \"\"\"\n\n    def __init__(self, expr):\n        \"\"\"\n        Initializes the class with an expression.\n        :param expr: The expression to check for balanced brackets, str.\n        \"\"\"\n        self.left_brackets = [\"(\", \"{\", \"[\"]\n        self.right_brackets = [\")\", \"}\", \"]\"]\n        self.expr = expr\n\n    def clear_expr(self):\n        \"\"\"\n        Clears the expression of all characters that are not brackets.\n        >>> b = BalancedBrackets(\"a(b)c\")\n        >>> b.clear_expr()\n        >>> b.expr\n        '()'\n        \"\"\"\n        self.expr = ''.join(c for c in self.expr if c in self.left_brackets + self.right_brackets)\n\n    def check_balanced_brackets(self):\n        \"\"\"\n        Checks if the expression has balanced brackets.\n        :return: True if the expression has balanced brackets, False otherwise.\n        >>> b = BalancedBrackets(\"a(b)c\")\n        >>> b.check_balanced_brackets()\n        True\n        \"\"\"\n        self.clear_expr()  # Ensure we are checking the cleared expression\n        stack = []\n        bracket_map = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n        for char in self.expr:\n            if char in self.left_brackets:\n                stack.append(char)\n            elif char in self.right_brackets:\n                if not stack or stack[-1] != bracket_map[char]:\n                    return False\n                stack.pop()\n\n        return len(stack) == 0\n```",
    "11": "```python\nclass BitStatusUtil:\n    \"\"\"\n    This is a utility class that provides methods for manipulating and checking status using bitwise operations.\n    \"\"\"\n\n    @staticmethod\n    def add(states, stat):\n        \"\"\"\n        Add a status to the current status, and check the parameters whether they are legal.\n        :param states: Current status, int.\n        :param stat: Status to be added, int.\n        :return: The status after adding the status, int.\n        \"\"\"\n        BitStatusUtil.check([states, stat])\n        return states | stat\n\n    @staticmethod\n    def has(states, stat):\n        \"\"\"\n        Check if the current status contains the specified status, and check the parameters whether they are legal.\n        :param states: Current status, int.\n        :param stat: Specified status, int.\n        :return: True if the current status contains the specified status, otherwise False, bool.\n        \"\"\"\n        BitStatusUtil.check([states, stat])\n        return (states & stat) == stat\n\n    @staticmethod\n    def remove(states, stat):\n        \"\"\"\n        Remove the specified status from the current status, and check the parameters whether they are legal.\n        :param states: Current status, int.\n        :param stat: Specified status, int.\n        :return: The status after removing the specified status, int.\n        \"\"\"\n        BitStatusUtil.check([states, stat])\n        return states & ~stat\n\n    @staticmethod\n    def check(args):\n        \"\"\"\n        Check if the parameters are legal, args must be greater than or equal to 0 and must be even, \n        if not, raise ValueError.\n        :param args: Parameters to be checked, list.\n        :return: None.\n        \"\"\"\n        for arg in args:\n            if arg < 0:\n                raise ValueError(f\"{arg} is negative\")\n            if arg % 2 != 0:\n                raise ValueError(f\"{arg} not even\")\n```",
    "19": "```python\nclass ChandrasekharSieve:\n    \"\"\"\n    This is a class that uses the Chandrasekhar's Sieve method to find all prime numbers within the range\n    \"\"\"\n\n    def __init__(self, n):\n        \"\"\"\n        Initialize the ChandrasekharSieve class with the given limit.\n        :param n: int, the upper limit for generating prime numbers\n        \"\"\"\n        self.n = n\n        self.primes = self.generate_primes()\n\n    def generate_primes(self):\n        \"\"\"\n        Generate prime numbers up to the specified limit using the Chandrasekhar sieve algorithm.\n        :return: list, a list of prime numbers\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.generate_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n        \"\"\"\n        if self.n < 2:\n            return []\n        \n        sieve = [True] * (self.n + 1)\n        sieve[0], sieve[1] = False, False  # 0 and 1 are not prime numbers\n        \n        for start in range(2, int(self.n**0.5) + 1):\n            if sieve[start]:\n                for multiple in range(start*start, self.n + 1, start):\n                    sieve[multiple] = False\n        \n        return [num for num, is_prime in enumerate(sieve) if is_prime]\n\n    def get_primes(self):\n        \"\"\"\n        Get the list of generated prime numbers.\n        :return: list, a list of prime numbers\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.get_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n        \"\"\"\n        return self.primes\n```",
    "13": "```python\nclass BookManagement:\n    \"\"\"\n    This is a class for managing a book system, which supports adding and removing books from the inventory dict,\n    viewing the inventory, and checking the quantity of a specific book.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the inventory of Book Manager.\n        \"\"\"\n        self.inventory = {}\n\n    def add_book(self, title, quantity=1):\n        \"\"\"\n        Add one or several books to inventory which is sorted by book title.\n        :param title: str, the book title\n        :param quantity: int, default value is 1.\n        \"\"\"\n        if quantity < 1:\n            raise ValueError(\"Quantity must be at least 1.\")\n        \n        if title in self.inventory:\n            self.inventory[title] += quantity\n        else:\n            self.inventory[title] = quantity\n        \n        self.inventory = dict(sorted(self.inventory.items()))\n\n    def remove_book(self, title, quantity):\n        \"\"\"\n        Remove one or several books from inventory which is sorted by book title.\n        Raise exception when input is invalid.\n        :param title: str, the book title\n        :param quantity: int\n        \"\"\"\n        if title not in self.inventory:\n            raise Exception(\"Book does not exist in inventory.\")\n        \n        if quantity <= 0:\n            raise ValueError(\"Quantity must be greater than 0.\")\n        \n        if self.inventory[title] < quantity:\n            raise Exception(\"Not enough quantity to remove.\")\n        \n        self.inventory[title] -= quantity\n        if self.inventory[title] == 0:\n            del self.inventory[title]\n\n    def view_inventory(self):\n        \"\"\"\n        Get the inventory of the Book Management.\n        :return: dictionary, {title(str): quantity(int), ...}\n        \"\"\"\n        return self.inventory\n\n    def view_book_quantity(self, title):\n        \"\"\"\n        Get the quantity of a book.\n        :param title: str, the title of the book.\n        :return: int, the quantity of this book title. Returns 0 when the title does not exist in self.inventory\n        \"\"\"\n        return self.inventory.get(title, 0)\n```",
    "18": "```python\nclass CamelCaseMap:\n    \"\"\"\n    A custom class that allows keys to be in camel case style by converting them from underscore style, providing dictionary-like functionality.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize data to an empty dictionary.\"\"\"\n        self._data = {}\n\n    def __getitem__(self, key):\n        \"\"\"Return the value corresponding to the key.\"\"\"\n        key = self._convert_key(key)\n        return self._data[key]\n\n    def __setitem__(self, key, value):\n        \"\"\"Set the value corresponding to the key to the specified value.\"\"\"\n        key = self._convert_key(key)\n        self._data[key] = value\n\n    def __delitem__(self, key):\n        \"\"\"Delete the value corresponding to the key.\"\"\"\n        key = self._convert_key(key)\n        del self._data[key]\n\n    def __iter__(self):\n        \"\"\"Return an iterator for the keys in camel case format.\"\"\"\n        return iter(self._data)\n\n    def __len__(self):\n        \"\"\"Return the number of items in the map.\"\"\"\n        return len(self._data)\n\n    def _convert_key(self, key):\n        \"\"\"Convert the key string into camel case.\"\"\"\n        if isinstance(key, str):\n            return self._to_camel_case(key)\n        return key\n\n    @staticmethod\n    def _to_camel_case(key):\n        \"\"\"Convert the key string into camel case.\"\"\"\n        parts = key.split('_')\n        return parts[0] + ''.join(part.capitalize() for part in parts[1:])\n\n    def __contains__(self, key):\n        \"\"\"Check if a key exists in the map, considering camel case variations.\"\"\"\n        converted_key = self._convert_key(key)\n        return converted_key in self._data\n```",
    "0": "```python\nimport logging\nimport datetime\n\nclass AccessGatewayFilter:\n    \"\"\"\n    This class is a filter used for accessing gateway filtering, primarily for authentication and access log recording.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def filter(self, request):\n        \"\"\"\n        Filter the incoming request based on certain rules and conditions.\n        :param request: dict, the incoming request details\n        :return: bool, True if the request is allowed, False otherwise\n        \"\"\"\n        if self.is_start_with(request.get('path', '')):\n            return True\n        \n        user_info = self.get_jwt_user(request)\n        if user_info and user_info['user']['level'] >= 3:\n            return True\n        \n        return False\n\n    def is_start_with(self, request_uri):\n        \"\"\"\n        Check if the request URI starts with certain prefixes.\n        Currently, the prefixes being checked are \"/api\" and \"/login\".\n        :param request_uri: str, the URI of the request\n        :return: bool, True if the URI starts with certain prefixes, False otherwise\n        \"\"\"\n        return request_uri.startswith('/api') or request_uri.startswith('/login')\n\n    def get_jwt_user(self, request):\n        \"\"\"\n        Get the user information from the JWT token in the request.\n        :param request: dict, the incoming request details\n        :return: dict or None, the user information if the token is valid, None otherwise\n        \"\"\"\n        auth_header = request.get('headers', {}).get('Authorization')\n        if auth_header and 'user' in auth_header and 'jwt' in auth_header:\n            expected_jwt = f\"{auth_header['user']['name']}{datetime.date.today()}\"\n            if auth_header['jwt'] == expected_jwt:\n                return auth_header\n        return None\n\n    def set_current_user_info_and_log(self, user):\n        \"\"\"\n        Set the current user information and log the access.\n        :param user: dict, the user information\n        :return: None\n        \"\"\"\n        logging.info(f\"User {user['name']} accessed from {user['address']} on {datetime.datetime.now()}\")\n```",
    "15": "```python\nclass BoyerMooreSearch:\n    \"\"\"\n    This is a class that implements the Boyer-Moore algorithm for string searching, which is used to find occurrences of a pattern within a given text.\n    \"\"\"\n\n    def __init__(self, text, pattern):\n        \"\"\"\n        Initializes the BoyerMooreSearch class with the given text and pattern.\n        :param text: The text to be searched, str.\n        :param pattern: The pattern to be searched for, str.\n        \"\"\"\n        self.text = text\n        self.pattern = pattern\n        self.textLen = len(text)\n        self.patLen = len(pattern)\n\n    def match_in_pattern(self, char):\n        \"\"\"\n        Finds the rightmost occurrence of a character in the pattern.\n        :param char: The character to be searched for, str.\n        :return: The index of the rightmost occurrence of the character in the pattern, int.\n        \"\"\"\n        index = -1\n        for i in range(self.patLen):\n            if self.pattern[i] == char:\n                index = i\n        return index\n\n    def mismatch_in_text(self, currentPos):\n        \"\"\"\n        Determines the position of the first mismatch between the pattern and the text.\n        :param currentPos: The current position in the text, int.\n        :return: The position of the first mismatch between the pattern and the text, int, otherwise -1.\n        \"\"\"\n        for i in range(self.patLen):\n            if currentPos + i >= self.textLen or self.text[currentPos + i] != self.pattern[i]:\n                return i if currentPos + i < self.textLen else -1\n        return -1\n\n    def bad_character_heuristic(self):\n        \"\"\"\n        Finds all occurrences of the pattern in the text.\n        :return: A list of all positions of the pattern in the text, list.\n        \"\"\"\n        positions = []\n        textIndex = 0\n        \n        while textIndex <= self.textLen - self.patLen:\n            mismatchIndex = self.mismatch_in_text(textIndex)\n            if mismatchIndex == -1:\n                positions.append(textIndex)\n                textIndex += self.patLen  # Shift the pattern by its length\n            else:\n                char = self.text[textIndex + mismatchIndex]\n                lastOccurrence = self.match_in_pattern(char)\n                shift = mismatchIndex - lastOccurrence if lastOccurrence != -1 else mismatchIndex + 1\n                textIndex += max(1, shift)  # Ensure we move forward at least one position\n            \n        return positions\n```",
    "14": "```python\nimport sqlite3\n\nclass BookManagementDB:\n    \"\"\"\n    This is a database class as a book management system, used to handle the operations of adding, removing, updating, and searching books.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the class by creating a database connection and cursor, \n        and creates the book table if it does not already exist.\n        :param db_name: str, the name of db file\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates the book table in the database if it does not already exist.\n        \"\"\"\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS books (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                title TEXT NOT NULL,\n                author TEXT NOT NULL,\n                available INTEGER NOT NULL DEFAULT 1\n            )\n        ''')\n        self.connection.commit()\n\n    def add_book(self, title, author):\n        \"\"\"\n        Adds a book to the database with the specified title and author, \n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        \"\"\"\n        self.cursor.execute('INSERT INTO books (title, author) VALUES (?, ?)', (title, author))\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        \"\"\"\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute('DELETE FROM books WHERE id = ?', (book_id,))\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        \"\"\"\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute('UPDATE books SET available = 0 WHERE id = ?', (book_id,))\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        \"\"\"\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute('UPDATE books SET available = 1 WHERE id = ?', (book_id,))\n        self.connection.commit()\n\n    def search_books(self):\n        \"\"\"\n        Retrieves all books from the database and returns their information.\n        :return: list[tuple], the information of all books in database\n        \"\"\"\n        self.cursor.execute('SELECT * FROM books')\n        return self.cursor.fetchall()\n\n    def __del__(self):\n        \"\"\"Closes the database connection when the object is destroyed.\"\"\"\n        self.connection.close()\n```",
    "2": "```python\nclass ArgumentParser:\n    \"\"\"\n    A class for parsing command line arguments into a dictionary.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the fields.\n        self.arguments is a dict that stores the args from the command line.\n        self.required is a set that stores the required arguments.\n        self.types is a dict that stores the type of each argument.\n        \"\"\"\n        self.arguments = {}\n        self.required = set()\n        self.types = {}\n\n    def parse_arguments(self, command_string):\n        \"\"\"\n        Parses the given command line argument string and stores the parsed result in\n        specific types in the arguments dictionary. Checks for missing required arguments,\n        returning False with the missing argument names if any, otherwise returns True.\n        :param command_string: str, command line argument string formatted like\n            \"python script.py --arg1=value1 -arg2 value2 --option1 -option2\"\n        :return tuple: (True, None) if parsing is successful, (False, missing_args) if parsing fails,\n            where missing_args is a set of the missing argument names which are str.\n        \"\"\"\n        args = command_string.split()[1:]  # Skip the script name\n        missing_args = set(self.required)\n\n        for arg in args:\n            if '=' in arg:\n                key, value = arg.split('=', 1)  # Split only on the first '='\n            else:\n                key = arg\n                value = True  # For flags\n\n            key = key.lstrip('-')  # Remove leading dashes\n\n            if key in self.types:\n                value = self._convert_type(key, value)\n\n            self.arguments[key] = value\n\n            if key in missing_args:\n                missing_args.remove(key)\n\n        return (len(missing_args) == 0, missing_args if missing_args else None)\n\n    def get_argument(self, key):\n        \"\"\"\n        Retrieves the value of the specified argument from the arguments dictionary.\n        :param key: str, argument name\n        :return: The value of the argument, or None if the argument does not exist.\n        \"\"\"\n        return self.arguments.get(key)\n\n    def add_argument(self, arg, required=False, arg_type=str):\n        \"\"\"\n        Adds an argument to self.types and self.required.\n        If the argument is required, it will be added to the required set.\n        The argument type and name are stored in the types dictionary as key-value pairs.\n        :param arg: str, argument name\n        :param required: bool, whether the argument is required, default is False\n        :param arg_type: type, Argument type, default is str\n        \"\"\"\n        self.types[arg] = arg_type\n        if required:\n            self.required.add(arg)\n\n    def _convert_type(self, arg, value):\n        \"\"\"\n        Try to convert the type of input value by searching in self.types.\n        :param value: str, the input value in command line\n        :return: value converted to the corresponding type in self.types if conversion succeeds,\n            or the input value otherwise.\n        \"\"\"\n        if arg in self.types:\n            try:\n                return self.types[arg](value)\n            except (ValueError, TypeError):\n                pass\n        return value\n```",
    "10": "```python\nclass BinaryDataProcessor:\n    \"\"\"\n    This is a class used to process binary data, including functions such as clearing non-0 or 1 characters,\n    counting binary string information, and converting to corresponding strings based on different encoding methods.\n    \"\"\"\n\n    def __init__(self, binary_string):\n        \"\"\"\n        Initialize the class with a binary string and clean it by removing all non-0 or 1 characters.\n        \"\"\"\n        self.binary_string = binary_string\n        self.clean_non_binary_chars()\n\n    def clean_non_binary_chars(self):\n        \"\"\"\n        Clean the binary string by removing all non-0 or 1 characters.\n        \"\"\"\n        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))\n\n    def calculate_binary_info(self):\n        \"\"\"\n        Calculate the binary string information, including the percentage of 0 and 1, and the total length of the binary string.\n        \"\"\"\n        total_length = len(self.binary_string)\n        if total_length == 0:\n            return {'Zeroes': 0, 'Ones': 0, 'Bit length': 0}\n        count_ones = self.binary_string.count('1')\n        count_zeroes = total_length - count_ones\n        return {\n            'Zeroes': count_zeroes / total_length,\n            'Ones': count_ones / total_length,\n            'Bit length': total_length\n        }\n\n    def convert_to_ascii(self):\n        \"\"\"\n        Convert the binary string to ASCII string.\n        \"\"\"\n        ascii_string = ''\n        for i in range(0, len(self.binary_string), 8):\n            byte = self.binary_string[i:i + 8]\n            if len(byte) == 8:\n                ascii_string += chr(int(byte, 2))\n        return ascii_string\n\n    def convert_to_utf8(self):\n        \"\"\"\n        Convert the binary string to UTF-8 string.\n        \"\"\"\n        return self.convert_to_ascii()  # In this context, ASCII is a subset of UTF-8\n```",
    "16": "```python\nclass Calculator:\n    \"\"\"\n    This is a class for a calculator, capable of performing basic arithmetic calculations \n    on numerical expressions using the operators +, -, *, /, and ^ (exponentiation).\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the operations performed by the five operators '+', '-', '*', '/', '^'\n        \"\"\"\n        self.operators = {\n            '+': lambda x, y: x + y,\n            '-': lambda x, y: x - y,\n            '*': lambda x, y: x * y,\n            '/': lambda x, y: x / y if y != 0 else float('inf'),  # Handle division by zero\n            '^': lambda x, y: x ** y\n        }\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the value of a given expression\n        :param expression: string, given expression\n        :return: If successful, returns the value of the expression; otherwise, returns None\n        \"\"\"\n        if not expression:\n            return None\n\n        def apply_operator(operand_stack, operator_stack):\n            operator = operator_stack.pop()\n            right = operand_stack.pop()\n            left = operand_stack.pop()\n            result = self.operators[operator](left, right)\n            operand_stack.append(result)\n\n        def precedence(operator):\n            if operator in ('+', '-'):\n                return 1\n            elif operator in ('*', '/'):\n                return 2\n            elif operator == '^':\n                return 3\n            return 0\n\n        operand_stack = []\n        operator_stack = []\n        index = 0\n        n = len(expression)\n\n        while index < n:\n            if expression[index].isspace():\n                index += 1\n                continue\n            \n            if expression[index].isdigit():\n                num = 0\n                while index < n and expression[index].isdigit():\n                    num = num * 10 + int(expression[index])\n                    index += 1\n                operand_stack.append(num)\n                continue\n\n            if expression[index] in self.operators:\n                while (operator_stack and \n                       precedence(operator_stack[-1]) >= precedence(expression[index])):\n                    apply_operator(operand_stack, operator_stack)\n                operator_stack.append(expression[index])\n\n            elif expression[index] == '(':\n                operator_stack.append(expression[index])\n\n            elif expression[index] == ')':\n                while operator_stack and operator_stack[-1] != '(':\n                    apply_operator(operand_stack, operator_stack)\n                operator_stack.pop()  # pop the '('\n\n            index += 1\n\n        while operator_stack:\n            apply_operator(operand_stack, operator_stack)\n\n        return operand_stack[0] if operand_stack else None\n\n    def precedence(self, operator):\n        \"\"\"\n        Returns the priority of the specified operator.\n        :param operator: string, given operator\n        :return: int, the priority of the given operator, otherwise return 0\n        \"\"\"\n        if operator in ('+', '-'):\n            return 1\n        elif operator in ('*', '/'):\n            return 2\n        elif operator == '^':\n            return 3\n        return 0\n\n    def apply_operator(self, operand_stack, operator_stack):\n        \"\"\"\n        Use the operator at the top of the operator stack to perform the operation on \n        the two numbers at the top of the operand stack, and store the results at the \n        top of the operand stack.\n        :param operand_stack: list\n        :param operator_stack: list\n        :return: the updated operand_stack and operator_stack\n        \"\"\"\n        operator = operator_stack.pop()\n        right = operand_stack.pop()\n        left = operand_stack.pop()\n        result = self.operators[operator](left, right)\n        operand_stack.append(result)\n        return operand_stack, operator_stack\n```",
    "4": "```python\nclass AssessmentSystem:\n    \"\"\"\n    This is a class for a student assessment system, which supports adding students, adding course scores, \n    calculating GPAs, and other functions for students and courses.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the students dictionary in the assessment system.\n        \"\"\"\n        self.students = {}\n\n    def add_student(self, name, grade, major):\n        \"\"\"\n        Add a new student into the self.students dictionary.\n        :param name: str, student name\n        :param grade: int, student grade\n        :param major: str, student major\n        \"\"\"\n        if name not in self.students:\n            self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}\n\n    def add_course_score(self, name, course, score):\n        \"\"\"\n        Add score of a specific course for the student in self.students.\n        :param name: str, student name\n        :param course: str, course name\n        :param score: int, course score\n        \"\"\"\n        if name in self.students:\n            self.students[name]['courses'][course] = score\n\n    def get_gpa(self, name):\n        \"\"\"\n        Get average grade of one student.\n        :param name: str, student name\n        :return: float or None, average grade if student exists and has courses, or None otherwise\n        \"\"\"\n        if name in self.students:\n            courses = self.students[name]['courses']\n            if courses:\n                return sum(courses.values()) / len(courses)\n        return None\n\n    def get_all_students_with_fail_course(self):\n        \"\"\"\n        Get all students who have any score below 60.\n        :return: list of str, student names\n        \"\"\"\n        return [name for name, details in self.students.items() if any(score < 60 for score in details['courses'].values())]\n\n    def get_course_average(self, course):\n        \"\"\"\n        Get the average score of a specific course.\n        :param course: str, course name\n        :return: float or None, average score of the course if anyone has a score for this course, or None if nobody has records.\n        \"\"\"\n        total_score = 0\n        count = 0\n        for details in self.students.values():\n            if course in details['courses']:\n                total_score += details['courses'][course]\n                count += 1\n        return total_score / count if count > 0 else None\n\n    def get_top_student(self):\n        \"\"\"\n        Calculate every student's GPA with get_gpa method, and find the student with the highest GPA.\n        :return: str, name of student whose GPA is highest\n        \"\"\"\n        top_student = None\n        highest_gpa = -1\n        for name in self.students:\n            gpa = self.get_gpa(name)\n            if gpa is not None and gpa > highest_gpa:\n                highest_gpa = gpa\n                top_student = name\n        return top_student\n```",
    "20": "```python\nfrom datetime import datetime\n\nclass Chat:\n    \"\"\"\n    This is a chat class with the functions of adding users, removing users, sending messages, and obtaining messages.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Chat with an attribute users, which is an empty dictionary.\n        \"\"\"\n        self.users = {}\n\n    def add_user(self, username):\n        \"\"\"\n        Add a new user to the Chat.\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns False, otherwise, returns True.\n        \"\"\"\n        if username in self.users:\n            return False\n        self.users[username] = []\n        return True\n\n    def remove_user(self, username):\n        \"\"\"\n        Remove a user from the Chat.\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns True, otherwise, returns False.\n        \"\"\"\n        if username not in self.users:\n            return False\n        del self.users[username]\n        return True\n\n    def send_message(self, sender, receiver, message):\n        \"\"\"\n        Send a message from a user to another user.\n        :param sender: The sender's name, str.\n        :param receiver: The receiver's name, str.\n        :param message: The message, str.\n        :return: If the sender or the receiver is not in the Chat, returns False, otherwise, returns True.\n        \"\"\"\n        if sender not in self.users or receiver not in self.users:\n            return False\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        msg = {'sender': sender, 'receiver': receiver, 'message': message, 'timestamp': timestamp}\n        self.users[sender].append(msg)\n        self.users[receiver].append(msg)\n        return True\n\n    def get_messages(self, username):\n        \"\"\"\n        Get all the messages of a user from the Chat.\n        :param username: The user's name, str.\n        :return: A list of messages, each message is a dictionary with keys 'sender', 'receiver', 'message', 'timestamp'.\n        \"\"\"\n        return self.users.get(username, [])\n\n# Test cases can be implemented in a separate unittest class as provided in the original code.\n```",
    "17": "```python\nfrom datetime import datetime, timedelta\n\nclass CalendarUtil:\n    \"\"\"\n    A utility class to manage calendar events, schedule appointments, and perform conflict checks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the calendar with an empty list of events.\n        \"\"\"\n        self.events = []\n\n    def add_event(self, event):\n        \"\"\"\n        Add an event to the calendar.\n        :param event: The event to be added to the calendar, dict.\n        \"\"\"\n        if self.is_valid_event(event):\n            self.events.append(event)\n\n    def remove_event(self, event):\n        \"\"\"\n        Remove an event from the calendar.\n        :param event: The event to be removed from the calendar, dict.\n        \"\"\"\n        self.events = [e for e in self.events if e != event]\n\n    def get_events(self, date):\n        \"\"\"\n        Get all events on a given date.\n        :param date: The date to get events for, datetime.\n        :return: A list of events on the given date, list.\n        \"\"\"\n        return [event for event in self.events if event['date'].date() == date.date()]\n\n    def is_available(self, start_time, end_time):\n        \"\"\"\n        Check if the calendar is available for a given time slot.\n        :param start_time: The start time of the time slot, datetime.\n        :param end_time: The end time of the time slot, datetime.\n        :return: True if the calendar is available for the given time slot, False otherwise, bool.\n        \"\"\"\n        for event in self.events:\n            if event['date'].date() == start_time.date():\n                if not (end_time <= event['start_time'] or start_time >= event['end_time']):\n                    return False\n        return True\n\n    def get_available_slots(self, date):\n        \"\"\"\n        Get all available time slots on a given date.\n        :param date: The date to get available time slots for, datetime.\n        :return: A list of available time slots on the given date, list.\n        \"\"\"\n        slots = []\n        start_of_day = datetime(date.year, date.month, date.day, 0, 0)\n        end_of_day = datetime(date.year, date.month, date.day, 23, 59)\n        current_time = start_of_day\n\n        while current_time < end_of_day:\n            next_time = current_time + timedelta(hours=1)\n            if self.is_available(current_time, next_time):\n                slots.append((current_time, next_time))\n            current_time = next_time\n\n        return slots\n\n    def get_upcoming_events(self, num_events):\n        \"\"\"\n        Get the next n upcoming events from the current date.\n        :param num_events: The number of upcoming events to get, int.\n        :return: A list of the next n upcoming events, list.\n        \"\"\"\n        upcoming_events = sorted(self.events, key=lambda x: (x['date'], x['start_time']))\n        return upcoming_events[:num_events]\n\n    def is_valid_event(self, event):\n        \"\"\"\n        Validate the event structure.\n        :param event: The event to be validated, dict.\n        :return: True if valid, False otherwise.\n        \"\"\"\n        required_keys = {'date', 'start_time', 'end_time', 'description'}\n        return all(key in event for key in required_keys) and event['start_time'] < event['end_time']\n```",
    "12": "```python\nimport random\n\nclass BlackjackGame:\n    \"\"\"\n    This is a class representing a game of blackjack, which includes creating a deck, calculating the value of a hand, and determining the winner based on the hand values of the player and dealer.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Blackjack Game with the attribute deck, player_hand, and dealer_hand.\n        While initializing deck attribute, call the create_deck method to generate.\n        The deck stores 52 random order poker with the Jokers removed, format is ['AS', '2S', ...].\n        player_hand is a list which stores player's hand cards.\n        dealer_hand is a list which stores dealer's hand cards.\n        \"\"\"\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n\n    def create_deck(self):\n        \"\"\"\n        Create a deck of 52 cards, which stores 52 random order poker with the Jokers removed.\n        :return: a list of 52 random order poker with the Jokers removed, format is ['AS', '2S', ...].\n        \"\"\"\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n        deck = [rank + suit for suit in suits for rank in ranks]\n        random.shuffle(deck)\n        return deck\n\n    def calculate_hand_value(self, hand):\n        \"\"\"\n        Calculate the value of the poker cards stored in hand list according to the rules of the Blackjack Game.\n        If the card is a digit, its value is added to the total hand value.\n        Value of J, Q, or K is 10, while Aces are worth 11.\n        If the total hand value exceeds 21 and there are Aces present, one Ace is treated as having a value of 1 instead of 11,\n        until the hand value is less than or equal to 21, or all Aces have been counted as value of 1.\n        :param hand: list\n        :return: the value of the poker cards stored in hand list, a number.\n        \"\"\"\n        value = 0\n        aces_count = 0\n\n        for card in hand:\n            rank = card[:-1]  # Get the rank part of the card\n            if rank in ['J', 'Q', 'K']:\n                value += 10\n            elif rank == 'A':\n                value += 11\n                aces_count += 1\n            else:\n                value += int(rank)\n\n        while value > 21 and aces_count:\n            value -= 10\n            aces_count -= 1\n\n        return value\n\n    def check_winner(self, player_hand, dealer_hand):\n        \"\"\"\n        Determines the winner of a game by comparing the hand values of the player and dealer.\n        rule:\n        If both players have hand values that are equal to or less than 21, the winner is the one whose hand value is closer to 21.\n        Otherwise, the winner is the one with the lower hand value.\n        :param player_hand: list\n        :param dealer_hand: list\n        :return: the result of the game, only two certain str: 'Dealer wins' or 'Player wins'\n        \"\"\"\n        player_value = self.calculate_hand_value(player_hand)\n        dealer_value = self.calculate_hand_value(dealer_hand)\n\n        if player_value > 21 and dealer_value > 21:\n            return 'Dealer wins' if dealer_value < player_value else 'Player wins'\n        if player_value > 21:\n            return 'Dealer wins'\n        if dealer_value > 21:\n            return 'Player wins'\n        if player_value > dealer_value:\n            return 'Player wins'\n        else:\n            return 'Dealer wins'\n```",
    "5": "```python\nimport re\nimport unittest\n\nclass AutomaticGuitarSimulator:\n    def __init__(self, text: str) -> None:\n        \"\"\"\n        Initialize the score to be played\n        :param text: str, score to be played\n        \"\"\"\n        self.play_text = text\n\n    def interpret(self, display=False) -> list:\n        \"\"\"\n        Interpret the music score to be played\n        :param display: bool, representing whether to print the interpreted score\n        :return: list of dict, The dict includes two fields, Chord and Tune, which are letters and numbers, respectively.\n                If the input is empty or contains only whitespace, an empty list is returned.\n        \"\"\"\n        if not self.play_text.strip():\n            return []\n\n        # Split the input text into chords and tunes\n        play_list = []\n        matches = re.findall(r'([A-Za-z]+)(\\d+)', self.play_text)\n        for chord, tune in matches:\n            play_list.append({'Chord': chord, 'Tune': tune})\n\n        if display:\n            for item in play_list:\n                print(self.display(item['Chord'], item['Tune']))\n\n        return play_list\n\n    def display(self, key: str, value: str) -> str:\n        \"\"\"\n        Print out chord and play tune with following format: Normal Guitar Playing -- Chord: %s, Play Tune: %s\n        :param key: str, chord\n        :param value: str, play tune\n        :return: str\n        \"\"\"\n        return f\"Normal Guitar Playing -- Chord: {key}, Play Tune: {value}\"\n\n\nclass AutomaticGuitarSimulatorTestInterpret(unittest.TestCase):\n    def test_interpret_1(self):\n        context = AutomaticGuitarSimulator(\"C53231323\")\n        play_list = context.interpret()\n        self.assertEqual(play_list, [{'Chord': 'C', 'Tune': '53231323'}])\n\n    def test_interpret_2(self):\n        context = AutomaticGuitarSimulator(\"F43231323\")\n        play_list = context.interpret()\n        self.assertEqual(play_list, [{'Chord': 'F', 'Tune': '43231323'}])\n\n    def test_interpret_3(self):\n        context = AutomaticGuitarSimulator(\"Em43231323\")\n        play_list = context.interpret()\n        self.assertEqual(play_list, [{'Chord': 'Em', 'Tune': '43231323'}])\n\n    def test_interpret_4(self):\n        context = AutomaticGuitarSimulator(\"G63231323\")\n        play_list = context.interpret()\n        self.assertEqual(play_list, [{'Chord': 'G', 'Tune': '63231323'}])\n\n    def test_interpret_5(self):\n        context = AutomaticGuitarSimulator(\"F43231323 G63231323\")\n        play_list = context.interpret()\n        self.assertEqual(play_list, [{'Chord': 'F', 'Tune': '43231323'}, {'Chord': 'G', 'Tune': '63231323'}])\n\n    def test_interpret_6(self):\n        context = AutomaticGuitarSimulator(\" \")\n        play_list = context.interpret()\n        self.assertEqual(play_list, [])\n\n    def test_interpret_7(self):\n        context = AutomaticGuitarSimulator(\"ABC43231323 DEF63231323\")\n        play_list = context.interpret()\n        self.assertEqual(play_list, [{'Chord': 'ABC', 'Tune': '43231323'}, {'Chord': 'DEF', 'Tune': '63231323'}])\n\n    def test_interpret_8(self):\n        context = AutomaticGuitarSimulator(\"C53231323\")\n        play_list = context.interpret(display=True)\n        self.assertEqual(play_list, [{'Chord': 'C', 'Tune': '53231323'}])\n\n    def test_interpret_9(self):\n        context = AutomaticGuitarSimulator(\"\")\n        play_list = context.interpret()\n        self.assertEqual(play_list, [])\n\n\nclass AutomaticGuitarSimulatorTestDisplay(unittest.TestCase):\n    def test_display_1(self):\n        context = AutomaticGuitarSimulator(\"C53231323 Em43231323\")\n        play_list = context.interpret()\n        result = context.display(play_list[0]['Chord'], play_list[0]['Tune'])\n        self.assertEqual(result, \"Normal Guitar Playing -- Chord: C, Play Tune: 53231323\")\n\n    def test_display_2(self):\n        context = AutomaticGuitarSimulator(\"C53231323 Em43231323\")\n        play_list = context.interpret()\n        result = context.display(play_list[1]['Chord'], play_list[1]['Tune'])\n        self.assertEqual(result, \"Normal Guitar Playing -- Chord: Em, Play Tune: 43231323\")\n\n    def test_display_3(self):\n        context = AutomaticGuitarSimulator(\"F43231323 G63231323\")\n        play_list = context.interpret()\n        result = context.display(play_list[0]['Chord'], play_list[0]['Tune'])\n        self.assertEqual(result, \"Normal Guitar Playing -- Chord: F, Play Tune: 43231323\")\n\n    def test_display_4(self):\n        context = AutomaticGuitarSimulator(\"F43231323 G63231323\")\n        play_list = context.interpret()\n        result = context.display(play_list[1]['Chord'], play_list[1]['Tune'])\n        self.assertEqual(result, \"Normal Guitar Playing -- Chord: G, Play Tune: 63231323\")\n\n    def test_display_5(self):\n        context = AutomaticGuitarSimulator(\"\")\n        result = context.display('', '')\n        self.assertEqual(result, \"Normal Guitar Playing -- Chord: , Play Tune: \")\n\n\nclass AutomaticGuitarSimulatorTest(unittest.TestCase):\n    def test_AutomaticGuitarSimulator(self):\n        context = AutomaticGuitarSimulator(\"C53231323\")\n        play_list = context.interpret()\n        self.assertEqual(play_list, [{'Chord': 'C', 'Tune': '53231323'}])\n\n        context = AutomaticGuitarSimulator(\"C53231323 Em43231323\")\n        play_list = context.interpret()\n        result = context.display(play_list[0]['Chord'], play_list[0]['Tune'])\n        self.assertEqual(result, \"Normal Guitar Playing -- Chord: C, Play Tune: 53231323\")\n\nif __name__ == '__main__':\n    unittest.main()\n```",
    "24": "```python\nclass ComplexCalculator:\n    \"\"\"\n    This is a class that implements addition, subtraction, multiplication, and division operations for complex numbers.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def add(c1, c2):\n        \"\"\"\n        Adds two complex numbers.\n        :param c1: The first complex number, complex.\n        :param c2: The second complex number, complex.\n        :return: The sum of the two complex numbers, complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.add(1+2j, 3+4j)\n        (4+6j)\n        \"\"\"\n        return c1 + c2\n\n    @staticmethod\n    def subtract(c1, c2):\n        \"\"\"\n        Subtracts two complex numbers.\n        :param c1: The first complex number, complex.\n        :param c2: The second complex number, complex.\n        :return: The difference of the two complex numbers, complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.subtract(1+2j, 3+4j)\n        (-2-2j)\n        \"\"\"\n        return c1 - c2\n\n    @staticmethod\n    def multiply(c1, c2):\n        \"\"\"\n        Multiplies two complex numbers.\n        :param c1: The first complex number, complex.\n        :param c2: The second complex number, complex.\n        :return: The product of the two complex numbers, complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.multiply(1+2j, 3+4j)\n        (-5+10j)\n        \"\"\"\n        return c1 * c2\n\n    @staticmethod\n    def divide(c1, c2):\n        \"\"\"\n        Divides two complex numbers.\n        :param c1: The first complex number, complex.\n        :param c2: The second complex number, complex.\n        :return: The quotient of the two complex numbers, complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.divide(1+2j, 3+4j)\n        (0.44+0.08j)\n        \"\"\"\n        if c2 == 0:\n            raise ValueError(\"Cannot divide by zero.\")\n        return c1 / c2\n```",
    "3": "```python\nimport itertools\n\nclass ArrangementCalculator:\n    \"\"\"\n    The ArrangementCalculator class provides permutation calculations and selection operations for a given set of data elements.\n    \"\"\"\n\n    def __init__(self, datas):\n        \"\"\"\n        Initializes the ArrangementCalculator object with a list of datas.\n        :param datas: List, the data elements to be used for arrangements.\n        \"\"\"\n        self.datas = datas\n\n    @staticmethod\n    def count(n, m=None):\n        \"\"\"\n        Counts the number of arrangements by choosing m items from n items (permutations).\n        If m is not provided or n equals m, returns factorial(n).\n        :param n: int, the total number of items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: int, the count of arrangements.\n        >>> ArrangementCalculator.count(5, 3)\n        60\n        \"\"\"\n        if m is None or n == m:\n            return ArrangementCalculator.factorial(n)\n        if m > n:\n            return 0\n        return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n):\n        \"\"\"\n        Counts the total number of all possible arrangements by choosing at least 1 item and at most n items from n items.\n        :param n: int, the total number of items.\n        :return: int, the count of all arrangements.\n        >>> ArrangementCalculator.count_all(4)\n        64\n        \"\"\"\n        total = 0\n        for m in range(1, n + 1):\n            total += ArrangementCalculator.count(n, m)\n        return total\n\n    def select(self, m=None):\n        \"\"\"\n        Generates a list of arrangements by selecting m items from the internal datas.\n        If m is not provided, selects all items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: List, a list of arrangements.\n        >>> ac = ArrangementCalculator([1, 2, 3, 4])\n        >>> ac.select(2)\n        [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n        \"\"\"\n        if m is None:\n            m = len(self.datas)\n        return [list(p) for p in itertools.permutations(self.datas, m)]\n\n    def select_all(self):\n        \"\"\"\n        Generates a list of all arrangements by selecting at least 1 item and at most the number of internal datas.\n        :return: List, a list of all arrangements.\n        >>> ac = ArrangementCalculator([1, 2, 3])\n        >>> ac.select_all()\n        [[1], [2], [3], [1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2], [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n        \"\"\"\n        all_arrangements = []\n        for m in range(1, len(self.datas) + 1):\n            all_arrangements.extend(self.select(m))\n        return all_arrangements\n\n    @staticmethod\n    def factorial(n):\n        \"\"\"\n        Calculates the factorial of a given number.\n        :param n: int, the number to calculate the factorial.\n        :return: int, the factorial of the given number.\n        >>> ArrangementCalculator.factorial(4)\n        24\n        \"\"\"\n        if n < 0:\n            raise ValueError(\"Factorial is not defined for negative numbers.\")\n        if n == 0 or n == 1:\n            return 1\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result\n```",
    "25": "```python\nimport json\nimport os\n\nclass CookiesUtil:\n    \"\"\"\n    Utility class for managing and manipulating Cookies, including methods for retrieving, saving, and setting Cookies data.\n    \"\"\"\n\n    def __init__(self, cookies_file):\n        \"\"\"\n        Initializes the CookiesUtil with the specified cookies file.\n        :param cookies_file: The cookies file to use, str.\n        \"\"\"\n        self.cookies_file = cookies_file\n        self.cookies = self.load_cookies()  # Load cookies during initialization\n\n    def get_cookies(self, response):\n        \"\"\"\n        Gets the cookies from the specified response and saves them to cookies_file.\n        :param response: The response to get cookies from, dict.\n        \"\"\"\n        self.cookies = response.get('cookies', {})\n        self._save_cookies()\n\n    def load_cookies(self):\n        \"\"\"\n        Loads the cookies from the cookies_file to the cookies data.\n        :return: The cookies data, dict.\n        \"\"\"\n        if os.path.exists(self.cookies_file):\n            with open(self.cookies_file, 'r') as f:\n                try:\n                    return json.load(f)\n                except json.JSONDecodeError:  # Handle potential JSON decode errors\n                    return {}\n        return {}\n\n    def _save_cookies(self):\n        \"\"\"\n        Saves the cookies to the cookies_file.\n        :return: True if successful, False otherwise.\n        \"\"\"\n        try:\n            with open(self.cookies_file, 'w') as f:\n                json.dump(self.cookies, f)\n            return True\n        except (IOError, OSError):  # Handle potential file I/O errors\n            return False\n\n    def set_cookies(self, request):\n        \"\"\"\n        Sets the cookies for the given request.\n        :param request: The request dict to set cookies on.\n        \"\"\"\n        request['cookies'] = self.cookies  # Set cookies directly as a dict\n\n# Example test cases included in a separate testing module would validate the functionality.\n```",
    "8": "```python\nclass BankAccount:\n    \"\"\"\n    This class implements a bank account system, which supports depositing money,\n    withdrawing money, viewing balance, and transferring money.\n    \"\"\"\n\n    def __init__(self, balance=0):\n        \"\"\"\n        Initializes a bank account object with an attribute balance. Default value is 0.\n        \"\"\"\n        self.balance = balance\n\n    def deposit(self, amount):\n        \"\"\"\n        Deposits a certain amount into the account, increasing the account balance.\n        Returns the current account balance.\n        Raises ValueError for negative amounts.\n        :param amount: float\n        \"\"\"\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        self.balance += amount\n        return self.balance\n\n    def withdraw(self, amount):\n        \"\"\"\n        Withdraws a certain amount from the account, decreasing the account balance.\n        Returns the current account balance.\n        Raises ValueError for negative amounts or insufficient balance.\n        :param amount: float\n        \"\"\"\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        if amount > self.balance:\n            raise ValueError(\"Insufficient balance.\")\n        self.balance -= amount\n        return self.balance\n\n    def view_balance(self):\n        \"\"\"\n        Returns the account balance.\n        \"\"\"\n        return self.balance\n\n    def transfer(self, other_account, amount):\n        \"\"\"\n        Transfers a certain amount from the current account to another account.\n        Raises ValueError for negative amounts or insufficient balance.\n        :param other_account: BankAccount\n        :param amount: float\n        \"\"\"\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        if amount > self.balance:\n            raise ValueError(\"Insufficient balance.\")\n        self.withdraw(amount)\n        other_account.deposit(amount)\n\n\n# Test cases\nimport unittest\n\nclass BankAccountTestDeposit(unittest.TestCase):\n    # Tests for deposit method\n    def test_deposit(self):\n        account1 = BankAccount()\n        ret = account1.deposit(1000)\n        self.assertEqual(ret, 1000)\n\n    def test_deposit_multiple(self):\n        account1 = BankAccount()\n        account1.deposit(1000)\n        ret = account1.deposit(2000)\n        self.assertEqual(ret, 3000)\n\n    def test_deposit_negative(self):\n        account1 = BankAccount()\n        with self.assertRaises(ValueError) as context:\n            account1.deposit(-1000)\n        self.assertEqual(str(context.exception), \"Invalid amount\")\n\n    def test_deposit_zero(self):\n        account1 = BankAccount()\n        ret = account1.deposit(0)\n        self.assertEqual(ret, 0)\n\nclass BankAccountTestWithdraw(unittest.TestCase):\n    # Tests for withdraw method\n    def test_withdraw(self):\n        account1 = BankAccount(1000)\n        ret = account1.withdraw(200)\n        self.assertEqual(ret, 800)\n\n    def test_withdraw_insufficient(self):\n        account1 = BankAccount(500)\n        with self.assertRaises(ValueError) as context:\n            account1.withdraw(1000)\n        self.assertEqual(str(context.exception), \"Insufficient balance.\")\n\n    def test_withdraw_negative(self):\n        account1 = BankAccount()\n        with self.assertRaises(ValueError) as context:\n            account1.withdraw(-1000)\n        self.assertEqual(str(context.exception), \"Invalid amount\")\n\nclass BankAccountTestViewBalance(unittest.TestCase):\n    # Tests for view_balance method\n    def test_view_balance(self):\n        account1 = BankAccount()\n        self.assertEqual(account1.view_balance(), 0)\n\n    def test_view_balance_with_balance(self):\n        account1 = BankAccount(1000)\n        self.assertEqual(account1.view_balance(), 1000)\n\nclass BankAccountTestTransfer(unittest.TestCase):\n    # Tests for transfer method\n    def test_transfer(self):\n        account1 = BankAccount(800)\n        account2 = BankAccount(1000)\n        account1.transfer(account2, 300)\n        self.assertEqual(account1.view_balance(), 500)\n        self.assertEqual(account2.view_balance(), 1300)\n\n    def test_transfer_insufficient(self):\n        account1 = BankAccount(500)\n        account2 = BankAccount()\n        with self.assertRaises(ValueError) as context:\n            account1.transfer(account2, 600)\n        self.assertEqual(str(context.exception), \"Insufficient balance.\")\n\n    def test_transfer_negative(self):\n        account1 = BankAccount(500)\n        account2 = BankAccount()\n        with self.assertRaises(ValueError) as context:\n            account1.transfer(account2, -600)\n        self.assertEqual(str(context.exception), \"Invalid amount\")\n\nclass BankAccountTest(unittest.TestCase):\n    # Tests for a sequence of operations\n    def test_sequence_operations(self):\n        account1 = BankAccount()\n        account2 = BankAccount()\n        account1.deposit(1000)\n        account1.withdraw(200)\n        account1.transfer(account2, 300)\n        self.assertEqual(account1.view_balance(), 500)\n        self.assertEqual(account2.view_balance(), 300)\n\nif __name__ == \"__main__\":\n    unittest.main()\n```",
    "22": "```python\nclass ClassRegistrationSystem:\n    \"\"\"\n    This is a class as a class registration system, allowing to register students, register them for classes, retrieve students by major,\n    get a list of all majors, and determine the most popular class within a specific major.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the registration system with the attribute students and students_registration_classes.\n        students is a list of student dictionaries, each student dictionary has the key of name and major.\n        students_registration_classes is a dictionary, key is the student name, value is a list of class names\n        \"\"\"\n        self.students = []\n        self.students_registration_classes = {}\n\n    def register_student(self, student):\n        \"\"\"\n        Register a student to the system. If the student is already registered, return 0; otherwise, add the student to the list and return 1.\n        :param student: dict\n        :return: int\n        \"\"\"\n        if student in self.students:\n            return 0\n        else:\n            self.students.append(student)\n            return 1\n\n    def register_class(self, student_name, class_name):\n        \"\"\"\n        Register a class for a student and return the updated list of classes that the student has registered for.\n        :param student_name: str\n        :param class_name: str\n        :return: list\n        \"\"\"\n        if student_name not in self.students_registration_classes:\n            self.students_registration_classes[student_name] = []\n        if class_name not in self.students_registration_classes[student_name]:\n            self.students_registration_classes[student_name].append(class_name)\n        return self.students_registration_classes[student_name]\n\n    def get_students_by_major(self, major):\n        \"\"\"\n        Get all students in the specified major.\n        :param major: str\n        :return: list\n        \"\"\"\n        return [student[\"name\"] for student in self.students if student[\"major\"] == major]\n\n    def get_all_major(self):\n        \"\"\"\n        Get a list of all majors in the system.\n        :return: list\n        \"\"\"\n        return list(set(student[\"major\"] for student in self.students))\n\n    def get_most_popular_class_in_major(self, major):\n        \"\"\"\n        Get the class with the highest enrollment in the specified major.\n        :param major: str\n        :return: str or None\n        \"\"\"\n        class_count = {}\n        for student in self.students:\n            if student[\"major\"] == major:\n                student_classes = self.students_registration_classes.get(student[\"name\"], [])\n                for class_name in student_classes:\n                    class_count[class_name] = class_count.get(class_name, 0) + 1\n        if not class_count:\n            return None\n        return max(class_count, key=class_count.get)\n```",
    "6": "```python\nclass AvgPartition:\n    \"\"\"\n    This class partitions the given list into different blocks by specifying the number of partitions,\n    with each block having a uniformly distributed length.\n    \"\"\"\n\n    def __init__(self, lst, limit):\n        \"\"\"\n        Initialize the class with the given list and the number of partitions, and check if the number of partitions is greater than 0.\n        \"\"\"\n        self.lst = lst\n        self.limit = limit\n        if limit <= 0:\n            raise ValueError(\"The number of partitions must be greater than 0.\")\n\n    def setNum(self):\n        \"\"\"\n        Calculate the size of each block and the remainder of the division.\n        :return: the size of each block and the remainder of the division, tuple.\n        >>> a = AvgPartition([1, 2, 3, 4], 2)\n        >>> a.setNum()\n        (2, 0)\n        \"\"\"\n        block_size = len(self.lst) // self.limit\n        remainder = len(self.lst) % self.limit\n        return block_size, remainder\n\n    def get(self, index):\n        \"\"\"\n        Calculate the corresponding block based on the index of the partition.\n        :param index: the index of the partition, int.\n        :return: the corresponding block, list.\n        >>> a = AvgPartition([1, 2, 3, 4], 2)\n        >>> a.get(0)\n        [1, 2]\n        >>> a.get(1)\n        [3, 4]\n        \"\"\"\n        if index < 0 or index >= self.limit:\n            raise IndexError(\"Partition index out of range.\")\n        \n        block_size, remainder = self.setNum()\n        start = index * block_size + min(index, remainder)\n        end = start + block_size + (1 if index < remainder else 0)\n        return self.lst[start:end]\n\n\nimport unittest\n\nclass AvgPartitionTestSetNum(unittest.TestCase):\n    def test_setNum(self):\n        a = AvgPartition([1, 2, 3, 4], 2)\n        self.assertEqual(a.setNum(), (2, 0))\n\n    def test_setNum_2(self):\n        a = AvgPartition([1, 2, 3, 4, 5], 2)\n        self.assertEqual(a.setNum(), (2, 1))\n\n    def test_setNum_3(self):\n        a = AvgPartition([1, 2, 3, 4, 5], 3)\n        self.assertEqual(a.setNum(), (1, 2))\n\n    def test_setNum_4(self):\n        a = AvgPartition([1, 2, 3, 4, 5], 4)\n        self.assertEqual(a.setNum(), (1, 1))\n\n    def test_setNum_5(self):\n        a = AvgPartition([1, 2, 3, 4, 5], 5)\n        self.assertEqual(a.setNum(), (1, 0))\n\nclass AvgPartitionTestGet(unittest.TestCase):\n\n    def test_get(self):\n        a = AvgPartition([1, 2, 3, 4], 2)\n        self.assertEqual(a.get(0), [1, 2])\n\n    def test_get_2(self):\n        a = AvgPartition([1, 2, 3, 4], 2)\n        self.assertEqual(a.get(1), [3, 4])\n\n    def test_get_3(self):\n        a = AvgPartition([1, 2, 3, 4, 5], 2)\n        self.assertEqual(a.get(0), [1, 2, 3])\n\n    def test_get_4(self):\n        a = AvgPartition([1, 2, 3, 4, 5], 2)\n        self.assertEqual(a.get(1), [4, 5])\n\n    def test_get_5(self):\n        a = AvgPartition([1, 2, 3, 4, 5], 3)\n        self.assertEqual(a.get(0), [1, 2])\n\n    def test_get_index_out_of_range(self):\n        a = AvgPartition([1, 2, 3, 4], 2)\n        with self.assertRaises(IndexError):\n            a.get(2)\n\nclass AvgPartitionTestMain(unittest.TestCase):\n    def test_main(self):\n        a = AvgPartition([1, 2, 3, 4], 2)\n        self.assertEqual(a.setNum(), (2, 0))\n        self.assertEqual(a.get(0), [1, 2])\n\nif __name__ == \"__main__\":\n    unittest.main()\n```",
    "29": "```python\nfrom collections import Counter\n\nclass DataStatistics:\n    \"\"\"\n    This is a class for performing data statistics, supporting to calculate the mean, median, and mode of a given data set.\n    \"\"\"\n\n    def mean(self, data):\n        \"\"\"\n        Calculate the average value of a group of data, accurate to two digits after the decimal separator.\n        :param data: list, data list\n        :return: float, the mean value\n        \"\"\"\n        if not data:\n            raise ValueError(\"Data list cannot be empty.\")\n        return round(sum(data) / len(data), 2)\n\n    def median(self, data):\n        \"\"\"\n        Calculate the median of a group of data, accurate to two digits after the decimal separator.\n        :param data: list, data list\n        :return: float, the median value\n        \"\"\"\n        if not data:\n            raise ValueError(\"Data list cannot be empty.\")\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        mid = n // 2\n        if n % 2 == 0:\n            return round((sorted_data[mid - 1] + sorted_data[mid]) / 2, 2)\n        else:\n            return round(sorted_data[mid], 2)\n\n    def mode(self, data):\n        \"\"\"\n        Calculate the mode of a set of data.\n        :param data: list, data list\n        :return: list, the modes\n        \"\"\"\n        if not data:\n            raise ValueError(\"Data list cannot be empty.\")\n        count = Counter(data)\n        max_count = max(count.values())\n        modes = [num for num, freq in count.items() if freq == max_count]\n        return modes if len(modes) < len(data) else list(set(data))\n```",
    "9": "```python\nclass BigNumCalculator:\n    \"\"\"\n    This is a class that implements big number calculations, including adding, subtracting, and multiplying.\n    \"\"\"\n\n    @staticmethod\n    def add(num1, num2):\n        \"\"\"\n        Adds two big numbers.\n        :param num1: The first number to add, str.\n        :param num2: The second number to add, str.\n        :return: The sum of the two numbers, str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.add(\"12345678901234567890\", \"98765432109876543210\")\n        '111111111011111111100'\n        \"\"\"\n        return str(int(num1) + int(num2))\n\n    @staticmethod\n    def subtract(num1, num2):\n        \"\"\"\n        Subtracts two big numbers.\n        :param num1: The first number to subtract, str.\n        :param num2: The second number to subtract, str.\n        :return: The difference of the two numbers, str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.subtract(\"12345678901234567890\", \"98765432109876543210\")\n        '-86419753208641975320'\n        \"\"\"\n        return str(int(num1) - int(num2))\n\n    @staticmethod\n    def multiply(num1, num2):\n        \"\"\"\n        Multiplies two big numbers.\n        :param num1: The first number to multiply, str.\n        :param num2: The second number to multiply, str.\n        :return: The product of the two numbers, str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.multiply(\"12345678901234567890\", \"98765432109876543210\")\n        '1219326311370217952237463801111263526900'\n        \"\"\"\n        return str(int(num1) * int(num2))\n\n\nimport unittest\n\nclass BigNumCalculatorTestAdd(unittest.TestCase):\n    def test_add(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.add(\"12345678901234567890\", \"98765432109876543210\"), \"111111111011111111100\")\n\n    def test_add_2(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.add(\"123456789012345678922\", \"98765432109876543210\"), \"222222221122222222132\")\n\n    def test_add_3(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.add(\"123456789012345678934\", \"98765432109876543210\"), \"222222221122222222144\")\n\n    def test_add_4(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.add(\"123456789012345678946\", \"98765432109876543210\"), \"222222221122222222156\")\n\n    def test_add_5(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.add(\"123456789012345678958\", \"98765432109876543210\"), \"222222221122222222168\")\n\nclass BigNumCalculatorTestSubtract(unittest.TestCase):\n    def test_subtract(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.subtract(\"12345678901234567890\", \"98765432109876543210\"), \"-86419753208641975320\")\n\n    def test_subtract_2(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.subtract(\"123456789012345678922\", \"98765432109876543210\"), \"24691356902469135712\")\n\n    def test_subtract_3(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.subtract(\"123456789012345678934\", \"98765432109876543\"), \"123358023580235802391\")\n\n    def test_subtract_4(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.subtract(\"12345678901234567\", \"98765432109876543210\"), \"-98753086430975308643\")\n\n    def test_subtract_5(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.subtract(\"923456789\", \"187654321\"), \"735802468\")\n\nclass BigNumCalculatorTestMultiply(unittest.TestCase):\n    def test_multiply(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.multiply(\"12345678901234567890\", \"98765432109876543210\"), \"1219326311370217952237463801111263526900\")\n\n    def test_multiply_2(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.multiply(\"123456789012345678922\", \"98765432109876543210\"), \"12193263113702179524547477517529919219620\")\n\n    def test_multiply_3(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.multiply(\"123456789012345678934\", \"98765432109876543\"), \"12193263113702179499806737010255845162\")\n\n    def test_multiply_4(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.multiply(\"12345678901234567\", \"98765432109876543210\"), \"1219326311370217864336229223321140070\")\n\n    def test_multiply_5(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.multiply(\"923456789\", \"187654321\"), \"173290656712635269\")\n\n    def test_multiply_6(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.multiply(\"000000001\", \"000000001\"), \"1\")\n\nclass BigNumCalculatorTestMain(unittest.TestCase):\n    def test_main(self):\n        bigNum = BigNumCalculator()\n        self.assertEqual(bigNum.add(\"12345678901234567890\", \"98765432109876543210\"), \"111111111011111111100\")\n        self.assertEqual(bigNum.subtract(\"12345678901234567890\", \"98765432109876543210\"), \"-86419753208641975320\")\n        self.assertEqual(bigNum.multiply(\"12345678901234567890\", \"98765432109876543210\"), \"1219326311370217952237463801111263526900\")\n\nif __name__ == '__main__':\n    unittest.main()\n```",
    "21": "```python\nfrom datetime import datetime\n\nclass Classroom:\n    \"\"\"\n    This is a class representing a classroom, capable of adding and removing courses,\n    checking availability at a given time, and detecting conflicts when scheduling new courses.\n    \"\"\"\n\n    def __init__(self, id):\n        \"\"\"\n        Initialize the classroom management system.\n        :param id: int, the id of classroom\n        \"\"\"\n        self.id = id\n        self.courses = []\n\n    def add_course(self, course):\n        \"\"\"\n        Add course to self.courses list if the course wasn't already in it.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        \"\"\"\n        if not any(existing_course['name'] == course['name'] and \n                   existing_course['start_time'] == course['start_time'] and \n                   existing_course['end_time'] == course['end_time'] for existing_course in self.courses):\n            self.courses.append(course)\n\n    def remove_course(self, course):\n        \"\"\"\n        Remove course from self.courses list if the course is present.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        \"\"\"\n        self.courses = [existing_course for existing_course in self.courses if not (\n            existing_course['name'] == course['name'] and \n            existing_course['start_time'] == course['start_time'] and \n            existing_course['end_time'] == course['end_time'])]\n\n    def is_free_at(self, check_time):\n        \"\"\"\n        Check if the classroom is free at the given check_time.\n        :param check_time: str, the time to be checked\n        :return: True if the check_time does not conflict with any course time, else False.\n        \"\"\"\n        check_time = datetime.strptime(check_time, '%H:%M').time()\n        for course in self.courses:\n            start_time = datetime.strptime(course['start_time'], '%H:%M').time()\n            end_time = datetime.strptime(course['end_time'], '%H:%M').time()\n            if start_time < check_time < end_time:\n                return False\n        return True\n\n    def check_course_conflict(self, new_course):\n        \"\"\"\n        Before adding a new course, check if the new course time conflicts with any other course.\n        :param new_course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        :return: False if the new course time conflicts (including boundary times) with other courses, else True.\n        \"\"\"\n        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M').time()\n        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M').time()\n        for course in self.courses:\n            start_time = datetime.strptime(course['start_time'], '%H:%M').time()\n            end_time = datetime.strptime(course['end_time'], '%H:%M').time()\n            if not (new_end_time <= start_time or new_start_time >= end_time):\n                return False\n        return True\n```",
    "26": "```python\nimport csv\nimport os\n\nclass CSVProcessor:\n    \"\"\"\n    This class processes CSV files, including reading, writing, and specific operations on CSV data.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_csv(self, file_name):\n        \"\"\"\n        Reads a CSV file and returns the title and data.\n        :param file_name: str, name of the CSV file\n        :return: (list, list), first row is title, the rest is data\n        \"\"\"\n        try:\n            with open(file_name, mode='r', newline='') as f:\n                reader = csv.reader(f)\n                title = next(reader)\n                data = [row for row in reader]\n            return title, data\n        except FileNotFoundError:\n            print(f\"File '{file_name}' not found.\")\n            return [], []\n        except Exception as e:\n            print(f\"An error occurred while reading the file: {e}\")\n            return [], []\n\n    def write_csv(self, data, file_name):\n        \"\"\"\n        Writes data into a CSV file.\n        :param data: list of lists, data to write\n        :param file_name: str, name of the CSV file\n        :return: int, 1 if successful, 0 otherwise\n        \"\"\"\n        try:\n            with open(file_name, mode='w', newline='') as f:\n                writer = csv.writer(f)\n                writer.writerows(data)\n            return 1\n        except Exception as e:\n            print(f\"An error occurred while writing to the file: {e}\")\n            return 0\n\n    def process_csv_data(self, N, save_file_name):\n        \"\"\"\n        Processes a CSV file to retain only the N-th column (0-indexed), capitalizes the data,\n        and saves it into a new CSV file.\n        :param N: int, the N-th column (0-indexed)\n        :param save_file_name: str, the name of the file to be processed\n        :return: int, 1 if successful, 0 otherwise\n        \"\"\"\n        try:\n            title, data = self.read_csv(save_file_name)\n            if not title or not data:  # Check if read was successful\n                return 0\n\n            new_data = [[row[N].upper()] for row in data if len(row) > N]\n            new_file_name = f\"{os.path.splitext(save_file_name)[0]}_process.csv\"\n            self.write_csv([title], new_file_name)\n            self.write_csv(new_data, new_file_name)\n            return 1\n        except IndexError:\n            print(f\"Column index {N} is out of range.\")\n            return 0\n        except Exception as e:\n            print(f\"An error occurred during processing: {e}\")\n            return 0\n```",
    "23": "```python\nimport math\nfrom typing import List\n\nclass CombinationCalculator:\n    \"\"\"\n    This is a class that provides methods to calculate the number of combinations for a specific count, \n    calculate all possible combinations, and generate combinations with a specified number of elements.\n    \"\"\"\n\n    def __init__(self, datas: List[str]):\n        \"\"\"\n        Initialize the calculator with a list of data.\n        \"\"\"\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        \"\"\"\n        Calculate the number of combinations for a specific count.\n        :param n: The total number of elements, int.\n        :param m: The number of elements in each combination, int.\n        :return: The number of combinations, int.\n        \"\"\"\n        if m > n or m < 0:\n            return 0\n        return math.comb(n, m)\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"\n        Calculate the number of all possible combinations.\n        :param n: The total number of elements, int.\n        :return: The number of all possible combinations, int.\n        If the number of combinations is greater than 2^63-1, return float(\"inf\").\n        \"\"\"\n        if n < 0:\n            return False\n        total = (1 << n) - 1  # 2^n - 1\n        return total if total <= 2**63 - 1 else float(\"inf\")\n\n    def select(self, m: int) -> List[List[str]]:\n        \"\"\"\n        Generate combinations with a specified number of elements.\n        :param m: The number of elements in each combination, int.\n        :return: A list of combinations, List[List[str]].\n        \"\"\"\n        result = []\n        self._select(0, [None] * m, 0, result)\n        return result\n\n    def select_all(self) -> List[List[str]]:\n        \"\"\"\n        Generate all possible combinations of selecting elements from the given data list,\n        and it uses the select method.\n        :return: A list of combinations, List[List[str]].\n        \"\"\"\n        result = []\n        for m in range(len(self.datas) + 1):\n            result.extend(self.select(m))\n        return result\n\n    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        \"\"\"\n        Generate combinations with a specified number of elements by recursion.\n        :param dataIndex: The index of the data to be selected, int.\n        :param resultList: The list of elements in the combination, List[str].\n        :param resultIndex: The index of the element in the combination, int.\n        :param result: The list of combinations, List[List[str]].\n        :return: None.\n        \"\"\"\n        if resultIndex == len(resultList):\n            result.append(resultList.copy())\n            return\n        if dataIndex >= len(self.datas):\n            return\n        \n        # Include the current element\n        resultList[resultIndex] = self.datas[dataIndex]\n        self._select(dataIndex + 1, resultList, resultIndex + 1, result)\n\n        # Exclude the current element\n        self._select(dataIndex + 1, resultList, resultIndex, result)\n```",
    "1": "```python\nimport math\n\nclass AreaCalculator:\n    \"\"\"\n    This is a class for calculating the area of different shapes, including circle, sphere, cylinder, sector and annulus.\n    \"\"\"\n    \n    def __init__(self, radius):\n        \"\"\"\n        Initialize the radius for shapes.\n        :param radius: float\n        \"\"\"\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        \"\"\"\n        Calculate the area of a circle based on self.radius.\n        :return: area of circle, float\n        \"\"\"\n        return math.pi * (self.radius ** 2)\n\n    def calculate_sphere_area(self):\n        \"\"\"\n        Calculate the surface area of a sphere based on self.radius.\n        :return: area of sphere, float\n        \"\"\"\n        return 4 * math.pi * (self.radius ** 2)\n\n    def calculate_cylinder_area(self, height):\n        \"\"\"\n        Calculate the surface area of a cylinder based on self.radius and height.\n        :param height: height of cylinder, float\n        :return: area of cylinder, float\n        \"\"\"\n        return 2 * math.pi * self.radius * (self.radius + height)\n\n    def calculate_sector_area(self, angle):\n        \"\"\"\n        Calculate the area of a sector based on self.radius and angle in radians.\n        :param angle: angle of sector in radians, float\n        :return: area of sector, float\n        \"\"\"\n        return 0.5 * self.radius ** 2 * angle\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        \"\"\"\n        Calculate the area of an annulus based on inner_radius and outer_radius.\n        :param inner_radius: inner radius of annulus, float\n        :param outer_radius: outer radius of annulus, float\n        :return: area of annulus, float\n        \"\"\"\n        if outer_radius < inner_radius:\n            raise ValueError(\"Outer radius must be greater than inner radius.\")\n        return math.pi * (outer_radius ** 2 - inner_radius ** 2)\n```\n\n```python\nimport unittest\n\nclass AreaCalculatorTestCalculateCircleArea(unittest.TestCase):\n    def test_calculate_circle_area(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(12.57, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_circle_area_2(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(19.63, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_circle_area_3(self):\n        areaCalculator = AreaCalculator(2000)\n        self.assertAlmostEqual(12566370.61, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_circle_area_4(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(0, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_circle_area_5(self):\n        areaCalculator = AreaCalculator(0.1)\n        self.assertAlmostEqual(0.0314, areaCalculator.calculate_circle_area(), delta=0.01)\n\n\nclass AreaCalculatorTestCalculateSphereArea(unittest.TestCase):\n    def test_calculate_sphere_area(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(50.27, areaCalculator.calculate_sphere_area(), delta=0.01)\n\n    def test_calculate_sphere_area_2(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(78.54, areaCalculator.calculate_sphere_area(), delta=0.01)\n\n    def test_calculate_sphere_area_3(self):\n        areaCalculator = AreaCalculator(2000)\n        self.assertAlmostEqual(50265482.46, areaCalculator.calculate_sphere_area(), delta=0.01)\n\n    def test_calculate_sphere_area_4(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(0, areaCalculator.calculate_sphere_area(), delta=0.01)\n\n    def test_calculate_sphere_area_5(self):\n        areaCalculator = AreaCalculator(0.1)\n        self.assertAlmostEqual(0.1257, areaCalculator.calculate_sphere_area(), delta=0.01)\n\n\nclass AreaCalculatorTestCalculateCylinderArea(unittest.TestCase):\n    def test_calculate_cylinder_area(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(50.27, areaCalculator.calculate_cylinder_area(2), delta=0.01)\n\n    def test_calculate_cylinder_area_2(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(25.13, areaCalculator.calculate_cylinder_area(0), delta=0.01)\n\n    def test_calculate_cylinder_area_3(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(0, areaCalculator.calculate_cylinder_area(2000), delta=0.01)\n\n    def test_calculate_cylinder_area_4(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(70.68, areaCalculator.calculate_cylinder_area(2), delta=0.01)\n\n    def test_calculate_cylinder_area_5(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(62.83, areaCalculator.calculate_cylinder_area(1.5), delta=0.01)\n\n\nclass AreaCalculatorTestCalculateSectorArea(unittest.TestCase):\n    def test_calculate_sector_area(self):\n        areaCalculator = AreaCalculator(1.5)\n        self.assertAlmostEqual(3.53, areaCalculator.calculate_sector_area(math.pi), delta=0.01)\n\n    def test_calculate_sector_area_2(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(3.14, areaCalculator.calculate_sector_area(math.pi/2), delta=0.01)\n\n    def test_calculate_sector_area_3(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(0, areaCalculator.calculate_sector_area(0), delta=0.01)\n\n    def test_calculate_sector_area_4(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(12.57, areaCalculator.calculate_sector_area(2 * math.pi), delta=0.01)\n\n    def test_calculate_sector_area_5(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(0, areaCalculator.calculate_sector_area(math.pi), delta=0.01)\n\n\nclass AreaCalculatorTestCalculateAnnulusArea(unittest.TestCase):\n    def test_calculate_annulus_area(self):\n        areaCalculator = AreaCalculator(0)  # Radius is not used for annulus\n        self.assertAlmostEqual(25.13, areaCalculator.calculate_annulus_area(1, 3), delta=0.01)\n\n    def test_calculate_annulus_area_2(self):\n        areaCalculator = AreaCalculator(2.5)  # Radius is not used for annulus\n        self.assertAlmostEqual(0, areaCalculator.calculate_annulus_area(3, 3), delta=0.01)\n\n    def test_calculate_annulus_area_3(self):\n        areaCalculator = AreaCalculator(2000)  # Radius is not used for annulus\n        self.assertAlmostEqual(3.14, areaCalculator.calculate_annulus_area(0, 1), delta=0.01)\n\n    def test_calculate_annulus_area_4(self):\n        areaCalculator = AreaCalculator(0)  # Radius is not used for annulus\n        self.assertAlmostEqual(25.13, areaCalculator.calculate_annulus_area(1, 3), delta=0.01)\n\n    def test_calculate_annulus_area_5(self):\n        areaCalculator = AreaCalculator(2.5)  # Radius is not used for annulus\n        self.assertAlmostEqual(25.13, areaCalculator.calculate_annulus_area(1, 3), delta=0.01)\n\n\nclass AreaCalculatorTestCalculateMain(unittest.TestCase):\n    def test_main(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(12.57, areaCalculator.calculate_circle_area(), delta=0.01)\n        self.assertAlmostEqual(50.27, areaCalculator.calculate_sphere_area(), delta=0.01)\n        self.assertAlmostEqual(50.27, areaCalculator.calculate_cylinder_area(2), delta=0.01)\n        self.assertAlmostEqual(6.28, areaCalculator.calculate_sector_area(math.pi), delta=0.01)\n        self.assertAlmostEqual(25.13, areaCalculator.calculate_annulus_area(1, 3), delta=0.01)\n\nif __name__ == '__main__':\n    unittest.main()\n```",
    "30": "```python\nimport numpy as np\n\nclass DataStatistics2:\n    \"\"\"\n    This is a class for performing data statistics, supporting to get the sum, minimum, maximum, variance, standard deviation, and correlation of a given dataset.\n    \"\"\"\n\n    def __init__(self, data):\n        \"\"\"\n        Initialize Data List\n        :param data: list or np.ndarray\n        \"\"\"\n        self.data = np.array(data)\n\n    def get_sum(self):\n        \"\"\"\n        Calculate the sum of data\n        :return: float\n        \"\"\"\n        return np.sum(self.data)\n\n    def get_min(self):\n        \"\"\"\n        Calculate the minimum value in the data\n        :return: float\n        \"\"\"\n        return np.min(self.data)\n\n    def get_max(self):\n        \"\"\"\n        Calculate the maximum value in the data\n        :return: float\n        \"\"\"\n        return np.max(self.data)\n\n    def get_variance(self):\n        \"\"\"\n        Calculate variance, accurate to two digits after the decimal separator\n        :return: float\n        \"\"\"\n        return round(np.var(self.data, ddof=1), 2)\n\n    def get_std_deviation(self):\n        \"\"\"\n        Calculate standard deviation, accurate to two digits after the decimal separator\n        :return: float\n        \"\"\"\n        return round(np.std(self.data, ddof=1), 2)\n\n    def get_correlation(self):\n        \"\"\"\n        Calculate correlation\n        :return: float\n        \"\"\"\n        if self.data.ndim > 1 and self.data.shape[1] > 1:\n            return float(np.corrcoef(self.data, rowvar=False)[0, 1])\n        else:\n            return 1.0  # Correlation is 1 for single variable data\n```",
    "27": "```python\nclass CurrencyConverter:\n    \"\"\"\n    This is a class for currency conversion, which supports converting amounts between different currencies, \n    retrieving supported currencies, adding new currency rates, and updating existing currency rates.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the exchange rate of the US dollar against various currencies.\n        \"\"\"\n        self.rates = {\n            'USD': 1.0,\n            'EUR': 0.85,\n            'GBP': 0.72,\n            'JPY': 110.15,\n            'CAD': 1.23,\n            'AUD': 1.34,\n            'CNY': 6.40,\n        }\n\n    def convert(self, amount, from_currency, to_currency):\n        \"\"\"\n        Convert the value of a given currency to another currency type.\n        :param amount: float, The value of a given currency.\n        :param from_currency: string, source currency type.\n        :param to_currency: string, target currency type.\n        :return: float, value converted to another currency type or False if currencies are unsupported.\n        \"\"\"\n        if from_currency not in self.rates or to_currency not in self.rates:\n            return False\n        # Convert amount to USD first\n        amount_in_usd = amount / self.rates[from_currency]\n        # Convert USD to target currency\n        return amount_in_usd * self.rates[to_currency]\n\n    def get_supported_currencies(self):\n        \"\"\"\n        Returns a list of supported currency types.\n        :return: list, All supported currency types.\n        \"\"\"\n        return list(self.rates.keys())\n\n    def add_currency_rate(self, currency, rate):\n        \"\"\"\n        Add a new supported currency type; return False if the currency type is already in the support list.\n        :param currency: string, currency type to be added.\n        :param rate: float, exchange rate for this type of currency.\n        :return: If successful, returns None; if unsuccessful, returns False.\n        \"\"\"\n        if currency in self.rates:\n            return False\n        self.rates[currency] = rate\n\n    def update_currency_rate(self, currency, new_rate):\n        \"\"\"\n        Update the exchange rate for a certain currency.\n        :param currency: string\n        :param new_rate: float\n        :return: If successful, returns None; if unsuccessful, returns False.\n        \"\"\"\n        if currency not in self.rates:\n            return False\n        self.rates[currency] = new_rate\n```",
    "28": "```python\nimport sqlite3\n\nclass DatabaseProcessor:\n    \"\"\"\n    This is a class for processing a database, supporting to create tables, insert data into the database, \n    search for data based on name, and delete data from the database.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor.\n        \"\"\"\n        self.database_name = database_name\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        Make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER.\n        \n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table.\n        :param key2: str, the name of the second column in the table.\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.execute(f'''\n                CREATE TABLE IF NOT EXISTS {table_name} (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    {key1} TEXT,\n                    {key2} INTEGER\n                )\n            ''')\n            conn.commit()\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        \n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            for row in data:\n                cursor.execute(f'''\n                    INSERT INTO {table_name} ({', '.join(row.keys())})\n                    VALUES ({', '.join(['?'] * len(row))})\n                ''', tuple(row.values()))\n            conn.commit()\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        \n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list, a list of tuples representing the rows with matching name, if any; otherwise, returns None.\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.execute(f'SELECT * FROM {table_name} WHERE {table_name.split(\"_\")[0]} = ?', (name,))\n            results = cursor.fetchall()\n            return results if results else None\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        \n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the name to match for deletion.\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.execute(f'DELETE FROM {table_name} WHERE {table_name.split(\"_\")[0]} = ?', (name,))\n            conn.commit()\n```",
    "33": "```python\nclass DiscountStrategy:\n    \"\"\"\n    This class allows the use of different discount strategies based on shopping credit or shopping cart in a supermarket.\n    \"\"\"\n\n    def __init__(self, customer, cart, promotion=None):\n        \"\"\"\n        Initialize the DiscountStrategy with customer information, a cart of items, and an optional promotion.\n        :param customer: dict, customer information\n        :param cart: list of dicts, a cart of items with details\n        :param promotion: function, optional promotion applied to the order\n        \"\"\"\n        self.customer = customer\n        self.cart = cart\n        self.promotion = promotion\n\n    def total(self):\n        \"\"\"\n        Calculate the total cost of items in the cart.\n        :return: float, total cost of items\n        \"\"\"\n        return sum(item['quantity'] * item['price'] for item in self.cart)\n\n    def due(self):\n        \"\"\"\n        Calculate the final amount to be paid after applying the discount.\n        :return: float, final amount to be paid\n        \"\"\"\n        total_amount = self.total()\n        if self.promotion:\n            discount = self.promotion(self)\n            return max(total_amount - discount, 0)  # Ensure due amount is not negative\n        return total_amount\n\n    @staticmethod\n    def FidelityPromo(order):\n        \"\"\"\n        Calculate the discount based on the fidelity points of the customer.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        \"\"\"\n        if order.customer.get('fidelity', 0) >= 1000:\n            return order.total() * 0.05\n        return 0.0\n\n    @staticmethod\n    def BulkItemPromo(order):\n        \"\"\"\n        Calculate the discount based on bulk item quantity in the order.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        \"\"\"\n        return sum(\n            item['quantity'] * item['price'] * 0.10 \n            for item in order.cart if item['quantity'] >= 20\n        )\n\n    @staticmethod\n    def LargeOrderPromo(order):\n        \"\"\"\n        Calculate the discount based on the number of different products in the order.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        \"\"\"\n        if len(order.cart) >= 10:\n            return order.total() * 0.07\n        return 0.0\n```",
    "36": "```python\nfrom datetime import datetime\n\nclass EmailClient:\n    \"\"\"\n    This is a class that serves as an email client, implementing functions such as checking emails, \n    determining whether there is sufficient space, and cleaning up space.\n    \"\"\"\n\n    def __init__(self, addr: str, capacity: float) -> None:\n        \"\"\"\n        Initializes the EmailClient class with the email address and the capacity of the email box.\n        :param addr: The email address, str.\n        :param capacity: The capacity of the email box, float.\n        \"\"\"\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox = []\n\n    def send_to(self, recv, content: str, size: float) -> bool:\n        \"\"\"\n        Sends an email to the given email address.\n        :param recv: The email address of the receiver, EmailClient.\n        :param content: The content of the email, str.\n        :param size: The size of the email, float.\n        :return: True if the email is sent successfully, False if the receiver's email box is full.\n        \"\"\"\n        if recv.is_full_with_one_more_email(size):\n            return False\n        \n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        email = {\n            'sender': self.addr,\n            'receiver': recv.addr,\n            'content': content,\n            'size': size,\n            'time': timestamp,\n            'state': 'unread'\n        }\n        recv.inbox.append(email)\n        return True\n\n    def fetch(self) -> dict:\n        \"\"\"\n        Retrieves the first unread email in the email box and marks it as read.\n        :return: The first unread email in the email box, dict.\n        \"\"\"\n        for email in self.inbox:\n            if email['state'] == 'unread':\n                email['state'] = 'read'\n                return email\n        return None\n\n    def is_full_with_one_more_email(self, size: float) -> bool:\n        \"\"\"\n        Determines whether the email box is full after adding an email of the given size.\n        :param size: The size of the email, float.\n        :return: True if the email box is full, False otherwise.\n        \"\"\"\n        return self.get_occupied_size() + size > self.capacity\n\n    def get_occupied_size(self) -> float:\n        \"\"\"\n        Gets the total size of the emails in the email box.\n        :return: The total size of the emails in the email box, float.\n        \"\"\"\n        return sum(email['size'] for email in self.inbox)\n\n    def clear_inbox(self, size: float) -> None:\n        \"\"\"\n        Clears the email box by deleting the oldest emails until the email box has enough space \n        to accommodate the given size.\n        :param size: The size of the email, float.\n        \"\"\"\n        while self.get_occupied_size() + size > self.capacity and self.inbox:\n            self.inbox.pop(0)\n```",
    "37": "```python\nclass EncryptionUtils:\n    \"\"\"\n    This is a class that provides methods for encryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the class with a key.\n        :param key: The key to use for encryption, str.\n        \"\"\"\n        self.key = key.lower()  # Ensure key is in lowercase for Vigenere cipher\n\n    def caesar_cipher(self, plaintext, shift):\n        \"\"\"\n        Encrypts the plaintext using the Caesar cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :param shift: The number of characters to shift each character in the plaintext, int.\n        :return: The ciphertext, str.\n        \"\"\"\n        result = []\n        shift %= 26  # Normalize shift to the range 0-25\n        for char in plaintext:\n            if char.isalpha():\n                shift_base = ord('A') if char.isupper() else ord('a')\n                result.append(chr((ord(char) - shift_base + shift) % 26 + shift_base))\n            else:\n                result.append(char)\n        return ''.join(result)\n\n    def vigenere_cipher(self, plaintext):\n        \"\"\"\n        Encrypts the plaintext using the Vigenere cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :return: The ciphertext, str.\n        \"\"\"\n        result = []\n        key_length = len(self.key)\n        key_index = 0\n\n        for char in plaintext:\n            if char.isalpha():\n                shift_base = ord('A') if char.isupper() else ord('a')\n                key_char = self.key[key_index % key_length]\n                shift = ord(key_char) - ord('a')\n                result.append(chr((ord(char) - shift_base + shift) % 26 + shift_base))\n                key_index += 1\n            else:\n                result.append(char)\n\n        return ''.join(result)\n\n    def rail_fence_cipher(self, plain_text, rails):\n        \"\"\"\n        Encrypts the plaintext using the Rail Fence cipher.\n        :param plain_text: The plaintext to encrypt, str.\n        :param rails: The number of rails to use, int.\n        :return: The ciphertext, str.\n        \"\"\"\n        if rails <= 1:\n            return plain_text\n\n        rail = [['\\n' for _ in range(len(plain_text))] for _ in range(rails)]\n        direction_down = False\n        row, col = 0, 0\n\n        for char in plain_text:\n            if row == 0 or row == rails - 1:\n                direction_down = not direction_down\n\n            rail[row][col] = char\n            col += 1\n\n            if direction_down:\n                row += 1\n            else:\n                row -= 1\n\n        result = []\n        for r in rail:\n            for char in r:\n                if char != '\\n':\n                    result.append(char)\n\n        return ''.join(result)\n```",
    "31": "```python\nimport math\nfrom statistics import mean, pstdev\n\nclass DataStatistics4:\n    \"\"\"\n    This is a class that performs advanced mathematical calculations and statistics,\n    including correlation coefficient, skewness, kurtosis, and probability density function (PDF) for a normal distribution.\n    \"\"\"\n\n    @staticmethod\n    def correlation_coefficient(data1, data2):\n        \"\"\"\n        Calculate the correlation coefficient of two sets of data.\n        :param data1: The first set of data, list.\n        :param data2: The second set of data, list.\n        :return: The correlation coefficient, float.\n        \"\"\"\n        if len(data1) != len(data2) or len(data1) == 0:\n            raise ValueError(\"Input lists must have the same non-zero length.\")\n        \n        mean1 = mean(data1)\n        mean2 = mean(data2)\n        numerator = sum((x - mean1) * (y - mean2) for x, y in zip(data1, data2))\n        denominator = math.sqrt(sum((x - mean1) ** 2 for x in data1) * sum((y - mean2) ** 2 for y in data2))\n        \n        if denominator == 0:\n            return 0  # Handle case of constant data\n        return numerator / denominator\n\n    @staticmethod\n    def skewness(data):\n        \"\"\"\n        Calculate the skewness of a set of data.\n        :param data: The input data list, list.\n        :return: The skewness, float.\n        \"\"\"\n        n = len(data)\n        if n < 2:\n            return float('nan')  # Not enough data to calculate skewness\n        \n        mean_data = mean(data)\n        std_dev = pstdev(data)\n        \n        if std_dev == 0:\n            return float('nan')  # Handle case of constant data\n        \n        skewness = sum((x - mean_data) ** 3 for x in data) / (n * std_dev ** 3)\n        return skewness\n\n    @staticmethod\n    def kurtosis(data):\n        \"\"\"\n        Calculate the kurtosis of a set of data.\n        :param data: The input data list, list.\n        :return: The kurtosis, float.\n        \"\"\"\n        n = len(data)\n        if n < 2:\n            return float('nan')  # Not enough data to calculate kurtosis\n        \n        mean_data = mean(data)\n        std_dev = pstdev(data)\n        \n        if std_dev == 0:\n            return float('nan')  # Handle case of constant data\n        \n        kurtosis = sum((x - mean_data) ** 4 for x in data) / (n * std_dev ** 4) - 3\n        return kurtosis\n\n    @staticmethod\n    def pdf(data, mu, sigma):\n        \"\"\"\n        Calculate the probability density function (PDF) of a set of data under a normal distribution.\n        :param data: The input data list, list.\n        :param mu: The mean of the normal distribution, float.\n        :param sigma: The standard deviation of the normal distribution, float.\n        :return: The probability density function (PDF), list.\n        \"\"\"\n        if sigma <= 0:\n            raise ValueError(\"Standard deviation must be positive.\")\n        \n        pdf_values = [(1 / (sigma * math.sqrt(2 * math.pi))) * \n                      math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n        return pdf_values\n```",
    "38": "```python\nimport openpyxl\n\n\nclass ExcelProcessor:\n    \"\"\"\n    A class for processing Excel files, including reading and writing data, and performing specific operations.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_excel(self, file_name):\n        \"\"\"\n        Read data from an Excel file.\n        :param file_name: str, Excel file name to read.\n        :return: list of tuples, Data in Excel.\n        \"\"\"\n        if not file_name:\n            print(\"File name is empty.\")\n            return None\n\n        try:\n            workbook = openpyxl.load_workbook(file_name)\n            sheet = workbook.active\n            data = [tuple(row) for row in sheet.iter_rows(values_only=True)]\n            return data\n        except Exception as e:\n            print(f\"Error reading {file_name}: {e}\")\n            return None\n\n    def write_excel(self, data, file_name):\n        \"\"\"\n        Write data to the specified Excel file.\n        :param data: list of tuples, Data to be written.\n        :param file_name: str, Excel file name to write to.\n        :return: int, 1 for success, 0 for failure.\n        \"\"\"\n        if not file_name or not data:\n            print(\"File name or data to write is empty.\")\n            return 0\n\n        try:\n            workbook = openpyxl.Workbook()\n            sheet = workbook.active\n            for row in data:\n                sheet.append(row)\n            workbook.save(file_name)\n            return 1\n        except Exception as e:\n            print(f\"Error writing to {file_name}: {e}\")\n            return 0\n\n    def process_excel_data(self, N, save_file_name):\n        \"\"\"\n        Change the specified column in the Excel file to uppercase.\n        :param N: int, The serial number of the column to change.\n        :param save_file_name: str, source file name.\n        :return: (int, str), Status of write operation and the saved file name.\n        \"\"\"\n        data = self.read_excel(save_file_name)\n        if data is None or N >= len(data[0]):\n            return 0, \"\"\n\n        new_data = []\n        for row in data:\n            new_row = list(row) + [row[N].upper() if isinstance(row[N], str) else row[N]]\n            new_data.append(tuple(new_row))\n\n        output_file_name = f\"processed_{save_file_name}\"\n        success = self.write_excel(new_data, output_file_name)\n        return success, output_file_name\n```",
    "43": "```python\nclass HRManagementSystem:\n    \"\"\"\n    This is a class representing a personnel management system that implements functions such as adding, deleting, querying, and updating employees.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the HRManagementSystem with an attribute employees, which is an empty dictionary.\n        \"\"\"\n        self.employees = {}\n\n    def add_employee(self, employee_id: int, name: str, position: str, department: str, salary: int) -> bool:\n        \"\"\"\n        Add a new employee to the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :param name: The employee's name, str.\n        :param position: The employee's position, str.\n        :param department: The employee's department, str.\n        :param salary: The employee's salary, int.\n        :return: If the employee is already in the HRManagementSystem, returns False, otherwise, returns True.\n        \"\"\"\n        if employee_id in self.employees:\n            return False\n        self.employees[employee_id] = {\n            'name': name,\n            'position': position,\n            'department': department,\n            'salary': salary\n        }\n        return True\n\n    def remove_employee(self, employee_id: int) -> bool:\n        \"\"\"\n        Remove an employee from the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :return: If the employee is already in the HRManagementSystem, returns True, otherwise, returns False.\n        \"\"\"\n        return self.employees.pop(employee_id, None) is not None\n\n    def update_employee(self, employee_id: int, employee_info: dict) -> bool:\n        \"\"\"\n        Update an employee's information in the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :param employee_info: The employee's information, dict.\n        :return: If the employee is already in the HRManagementSystem, returns True, otherwise, returns False.\n        \"\"\"\n        if employee_id not in self.employees:\n            return False\n        self.employees[employee_id].update(employee_info)\n        return True\n\n    def get_employee(self, employee_id: int):\n        \"\"\"\n        Get an employee's information from the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :return: If the employee is already in the HRManagementSystem, returns the employee's information, otherwise, returns None.\n        \"\"\"\n        return self.employees.get(employee_id)\n\n    def list_employees(self) -> dict:\n        \"\"\"\n        List all employees' information in the HRManagementSystem.\n        :return: A dictionary of all employees' information, including their IDs.\n        \"\"\"\n        return {employee_id: {**{'employee_ID': employee_id}, **info} for employee_id, info in self.employees.items()}\n```",
    "47": "```python\nclass IPAddress:\n    \"\"\"\n    This is a class to process IP Address, including validating, getting the octets and obtaining the binary representation of a valid IP address.\n    \"\"\"\n\n    def __init__(self, ip_address):\n        \"\"\"\n        Initialize the IP address to the specified address\n        :param ip_address: string\n        \"\"\"\n        self.ip_address = ip_address\n\n    def is_valid(self):\n        \"\"\"\n        Judge whether the IP address is valid, that is, whether the IP address is composed of four decimal digits separated by '.'. \n        Each digit is greater than or equal to 0 and less than or equal to 255.\n        :return: bool\n        \"\"\"\n        octets = self.ip_address.split('.')\n        if len(octets) != 4:\n            return False\n        for octet in octets:\n            if not octet.isdigit() or not (0 <= int(octet) <= 255):\n                return False\n        return True\n\n    def get_octets(self):\n        \"\"\"\n        If the IP address is valid, the list of four decimal numbers separated by \".\" constituting the IP address is returned; \n        otherwise, an empty list is returned.\n        :return: list\n        \"\"\"\n        return self.ip_address.split('.') if self.is_valid() else []\n\n    def get_binary(self):\n        \"\"\"\n        If the IP address is valid, return the binary form of the IP address; otherwise, return an empty string.\n        :return: string\n        \"\"\"\n        if self.is_valid():\n            return '.'.join(f\"{int(octet):08b}\" for octet in self.ip_address.split('.'))\n        return ''\n```",
    "41": "```python\nclass GomokuGame:\n    \"\"\"\n    This class is an implementation of a Gomoku game, supporting making moves, checking for a winner,\n    and checking if there are five consecutive symbols on the game board.\n    \"\"\"\n\n    def __init__(self, board_size):\n        \"\"\"\n        Initializes the game with a given board size.\n        It initializes the board with empty spaces and sets the current player symbol as 'X'.\n        \"\"\"\n        self.board_size = board_size\n        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Makes a move at the given row and column.\n        If the move is valid, it places the current player's symbol on the board\n        and changes the current player to the other player.\n        :param row: int, the row index of this move\n        :param col: int, the column index\n        :return: True if the move is valid, or False otherwise.\n        \"\"\"\n        if not (0 <= row < self.board_size) or not (0 <= col < self.board_size):\n            return False\n        if self.board[row][col] != ' ':\n            return False\n        \n        self.board[row][col] = self.current_player\n        self.current_player = 'O' if self.current_player == 'X' else 'X'\n        return True\n\n    def check_winner(self):\n        \"\"\"\n        Checks if there is a winner by looking for five in a row in all directions (horizontal, vertical, diagonal).\n        :return: the symbol of the winning player (either 'X' or 'O') if there is a winner, or None otherwise.\n        \"\"\"\n        for row in range(self.board_size):\n            for col in range(self.board_size):\n                if self.board[row][col] != ' ':\n                    if (self._check_five_in_a_row(row, col, (0, 1)) or  # Horizontal\n                        self._check_five_in_a_row(row, col, (1, 0)) or  # Vertical\n                        self._check_five_in_a_row(row, col, (1, 1)) or  # Diagonal \\\n                        self._check_five_in_a_row(row, col, (1, -1)):   # Diagonal /\n                        return self.board[row][col]\n        return None\n\n    def _check_five_in_a_row(self, row, col, direction):\n        \"\"\"\n        Checks if there are five consecutive symbols of the same player in a row starting from a given cell in a given direction.\n        :param row: int, row of the given cell\n        :param col: int, column of the given cell\n        :param direction: tuple, (int, int), named as (dx, dy).\n        :return: True if there are five consecutive symbols of the same player, and False otherwise.\n        \"\"\"\n        count = 0\n        current_symbol = self.board[row][col]\n        dx, dy = direction\n        \n        for i in range(5):\n            new_row = row + i * dx\n            new_col = col + i * dy\n            if 0 <= new_row < self.board_size and 0 <= new_col < self.board_size:\n                if self.board[new_row][new_col] == current_symbol:\n                    count += 1\n                else:\n                    break\n            else:\n                break\n        \n        return count == 5\n```",
    "40": "```python\nclass FitnessTracker:\n    \"\"\"\n    This is a class as fitness tracker that implements to calculate BMI (Body Mass Index) and calorie intake\n    based on the user's height, weight, age, and sex.\n    \"\"\"\n\n    def __init__(self, height, weight, age, sex) -> None:\n        \"\"\"\n        Initialize the class with height, weight, age, and sex, and calculate the BMI standard based on sex.\n        Male standard is 20-25, female is 19-24.\n        \"\"\"\n        self.height = height\n        self.weight = weight\n        self.age = age\n        self.sex = sex.lower()\n        self.BMI_std = {\n            \"male\": [20, 25],\n            \"female\": [19, 24]\n        }\n\n    def get_BMI(self) -> float:\n        \"\"\"\n        Calculate the BMI based on the height and weight.\n        :return: BMI, which is the weight divided by the square of height, float.\n        \"\"\"\n        bmi = self.weight / (self.height ** 2)\n        return round(bmi, 2)\n\n    def condition_judge(self) -> int:\n        \"\"\"\n        Judge the condition of the user based on the BMI standard.\n        :return: 1 if the user is too fat, -1 if the user is too thin, 0 if the user is normal, int.\n        \"\"\"\n        bmi = self.get_BMI()\n        if self.sex == \"male\":\n            if bmi < self.BMI_std[\"male\"][0]:\n                return -1\n            elif bmi > self.BMI_std[\"male\"][1]:\n                return 1\n            else:\n                return 0\n        elif self.sex == \"female\":\n            if bmi < self.BMI_std[\"female\"][0]:\n                return -1\n            elif bmi > self.BMI_std[\"female\"][1]:\n                return 1\n            else:\n                return 0\n        else:\n            raise ValueError(\"Invalid sex. Please use 'male' or 'female'.\")\n\n    def calculate_calorie_intake(self) -> float:\n        \"\"\"\n        Calculate the calorie intake based on the user's condition and BMR (Basal Metabolic Rate),\n        BMR is calculated based on the user's height, weight, age, and sex.\n        Male: BMR = 10 * weight + 6.25 * height * 100 - 5 * age + 5\n        Female: BMR = 10 * weight + 6.25 * height * 100 - 5 * age - 161\n        The calorie intake is adjusted based on the user's condition.\n        :return: calorie intake, float.\n        \"\"\"\n        bmr = (10 * self.weight) + (6.25 * self.height * 100) - (5 * self.age) + (5 if self.sex == \"male\" else -161)\n\n        condition = self.condition_judge()\n        if condition == 1:  # too fat\n            calorie_intake = bmr * 1.2\n        elif condition == -1:  # too thin\n            calorie_intake = bmr * 1.6\n        else:  # normal\n            calorie_intake = bmr * 1.4\n\n        return round(calorie_intake, 2)\n```",
    "32": "```python\nclass DecryptionUtils:\n    \"\"\"\n    This is a class that provides methods for decryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the decryption utility with a key.\n        :param key: The key to use for decryption, str.\n        \"\"\"\n        self.key = key.lower()  # Ensure key is in lowercase for consistency\n\n    def caesar_decipher(self, ciphertext, shift):\n        \"\"\"\n        Deciphers the given ciphertext using the Caesar cipher.\n        :param ciphertext: The ciphertext to decipher, str.\n        :param shift: The shift to use for decryption, int.\n        :return: The deciphered plaintext, str.\n        >>> d = DecryptionUtils('key')\n        >>> d.caesar_decipher('ifmmp', 1)\n        'hello'\n        \"\"\"\n        shift = shift % 26  # Normalize shift\n        plaintext = []\n        for char in ciphertext:\n            if char.isalpha():\n                base = ord('a') if char.islower() else ord('A')\n                shifted = (ord(char) - base - shift) % 26 + base\n                plaintext.append(chr(shifted))\n            else:\n                plaintext.append(char)\n        return ''.join(plaintext)\n\n    def vigenere_decipher(self, ciphertext):\n        \"\"\"\n        Deciphers the given ciphertext using the Vigenere cipher.\n        :param ciphertext: The ciphertext to decipher, str.\n        :return: The deciphered plaintext, str.\n        >>> d = DecryptionUtils('key')\n        >>> d.vigenere_decipher('ifmmp')\n        'ybocl'\n        \"\"\"\n        plaintext = []\n        key_length = len(self.key)\n        key_as_int = [ord(i) - ord('a') for i in self.key]\n        ciphertext_int = [ord(i) - ord('a') for i in ciphertext.lower() if i.isalpha()]\n\n        for i, char in enumerate(ciphertext):\n            if char.isalpha():\n                value = (ciphertext_int[i] - key_as_int[i % key_length]) % 26\n                plaintext.append(chr(value + ord('a')))\n            else:\n                plaintext.append(char)\n\n        return ''.join(plaintext)\n\n    def rail_fence_decipher(self, encrypted_text, rails):\n        \"\"\"\n        Deciphers the given ciphertext using the Rail Fence cipher.\n        :param encrypted_text: The ciphertext to decipher, str.\n        :param rails: The number of rails to use for decryption, int.\n        :return: The deciphered plaintext, str.\n        >>> d = DecryptionUtils('key')\n        >>> d.rail_fence_decipher('Hoo!el,Wrdl l', 3)\n        'Hello, World!'\n        \"\"\"\n        if rails <= 0:\n            return encrypted_text\n\n        n = len(encrypted_text)\n        rail = [['\\n' for _ in range(n)] for _ in range(rails)]\n        \n        dir_down = None\n        row, col = 0, 0\n\n        for i in range(n):\n            if row == 0:\n                dir_down = True\n            if row == rails - 1:\n                dir_down = False\n\n            rail[row][col] = encrypted_text[i]\n            col += 1\n\n            row += 1 if dir_down else -1\n\n        result = []\n        for i in range(rails):\n            for j in range(n):\n                if rail[i][j] != '\\n':\n                    result.append(rail[i][j])\n\n        return ''.join(result)\n```",
    "35": "```python\nclass EightPuzzle:\n    \"\"\"\n    This class is an implementation of the classic 8-puzzle game, including methods for finding the blank tile, making moves,\n    getting possible moves, and solving the puzzle using a breadth-first search algorithm.\n    \"\"\"\n\n    def __init__(self, initial_state):\n        \"\"\"\n        Initialize the initial state of Eight Puzzle Game, stores in attribute self.initial_state.\n        Set the goal state of this game, stores in self.goal_state. The size is 3x3.\n        :param initial_state: a 3x3 list of integers, stores the initial state\n        \"\"\"\n        self.initial_state = initial_state\n        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n    def find_blank(self, state):\n        \"\"\"\n        Find the blank position (0) in the current state.\n        :param state: a 3x3 list of integers, stores the current state.\n        :return: tuple (i, j) representing the coordinates of the blank block, or None if not found.\n        \"\"\"\n        for i in range(3):\n            for j in range(3):\n                if state[i][j] == 0:\n                    return i, j\n        return None\n\n    def move(self, state, direction):\n        \"\"\"\n        Move the blank block in the specified direction.\n        :param state: a 3x3 list of integers, stores the state before moving.\n        :param direction: str, one of 'up', 'down', 'left', 'right'\n        :return: new_state: a 3x3 list of integers, stores the state after moving.\n        \"\"\"\n        blank_i, blank_j = self.find_blank(state)\n        new_state = [row[:] for row in state]  # Create a copy of the current state\n\n        if direction == 'up' and blank_i > 0:\n            new_state[blank_i][blank_j], new_state[blank_i - 1][blank_j] = new_state[blank_i - 1][blank_j], new_state[blank_i][blank_j]\n        elif direction == 'down' and blank_i < 2:\n            new_state[blank_i][blank_j], new_state[blank_i + 1][blank_j] = new_state[blank_i + 1][blank_j], new_state[blank_i][blank_j]\n        elif direction == 'left' and blank_j > 0:\n            new_state[blank_i][blank_j], new_state[blank_i][blank_j - 1] = new_state[blank_i][blank_j - 1], new_state[blank_i][blank_j]\n        elif direction == 'right' and blank_j < 2:\n            new_state[blank_i][blank_j], new_state[blank_i][blank_j + 1] = new_state[blank_i][blank_j + 1], new_state[blank_i][blank_j]\n\n        return new_state\n\n    def get_possible_moves(self, state):\n        \"\"\"\n        Get all possible moving directions based on the current state.\n        :param state: a 3x3 list of integers, stores the current state.\n        :return: list of str, possible moving directions.\n        \"\"\"\n        blank_i, blank_j = self.find_blank(state)\n        moves = []\n\n        if blank_i > 0:\n            moves.append('up')\n        if blank_i < 2:\n            moves.append('down')\n        if blank_j > 0:\n            moves.append('left')\n        if blank_j < 2:\n            moves.append('right')\n\n        return moves\n\n    def solve(self):\n        \"\"\"\n        Use BFS algorithm to find the path from the initial state to the goal state.\n        :return: list of str, the solution to reach the goal state.\n        \"\"\"\n        from collections import deque\n\n        open_list = deque([(self.initial_state, [])])\n        visited = set()\n        visited.add(tuple(map(tuple, self.initial_state)))\n\n        while open_list:\n            current_state, path = open_list.popleft()\n\n            if current_state == self.goal_state:\n                return path\n\n            possible_moves = self.get_possible_moves(current_state)\n\n            for move_direction in possible_moves:\n                new_state = self.move(current_state, move_direction)\n                state_tuple = tuple(map(tuple, new_state))\n\n                if state_tuple not in visited:\n                    visited.add(state_tuple)\n                    open_list.append((new_state, path + [move_direction]))\n\n        return None\n```",
    "34": "```python\nfrom docx import Document\nfrom docx.shared import Pt\nfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENT\n\n\nclass DocFileHandler:\n    \"\"\"\n    This is a class that handles Word documents and provides functionalities for reading, writing, and modifying the content of Word documents.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initializes the DocFileHandler object with the specified file path.\n        :param file_path: str, the path to the Word document file.\n        \"\"\"\n        self.file_path = file_path\n\n    def read_text(self):\n        \"\"\"\n        Reads the content of a Word document and returns it as a string.\n        :return: str, the content of the Word document.\n        \"\"\"\n        try:\n            doc = Document(self.file_path)\n            text = [para.text for para in doc.paragraphs]\n            return '\\n'.join(text)\n        except Exception as e:\n            print(f\"Error reading document: {e}\")\n            return \"\"\n\n    def write_text(self, content, font_size=12, alignment='left'):\n        \"\"\"\n        Writes the specified content to a Word document.\n        :param content: str, the text content to write.\n        :param font_size: int, optional, the font size of the text (default is 12).\n        :param alignment: str, optional, the alignment of the text ('left', 'center', or 'right'; default is 'left').\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n        try:\n            doc = Document()\n            p = doc.add_paragraph(content)\n            run = p.runs[0]\n            run.font.size = Pt(font_size)\n            p.alignment = self._get_alignment_value(alignment)\n            doc.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error writing document: {e}\")\n            return False\n\n    def add_heading(self, heading, level=1):\n        \"\"\"\n        Adds a heading to the Word document.\n        :param heading: str, the text of the heading.\n        :param level: int, optional, the level of the heading (1, 2, 3, etc.; default is 1).\n        :return: bool, True if the heading is successfully added, False otherwise.\n        \"\"\"\n        try:\n            doc = Document(self.file_path)\n            doc.add_heading(heading, level=level)\n            doc.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error adding heading: {e}\")\n            return False\n\n    def add_table(self, data):\n        \"\"\"\n        Adds a table to the Word document with the specified data.\n        :param data: list of lists, the data to populate the table.\n        :return: bool, True if the table is successfully added, False otherwise.\n        \"\"\"\n        try:\n            doc = Document(self.file_path)\n            table = doc.add_table(rows=len(data), cols=len(data[0]))\n            for i, row in enumerate(data):\n                for j, cell in enumerate(row):\n                    table.cell(i, j).text = cell\n            doc.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error adding table: {e}\")\n            return False\n\n    def _get_alignment_value(self, alignment):\n        \"\"\"\n        Returns the alignment value corresponding to the given alignment string.\n        :param alignment: str, the alignment string ('left', 'center', or 'right').\n        :return: int, the alignment value.\n        \"\"\"\n        if alignment == 'center':\n            return WD_PARAGRAPH_ALIGNMENT.CENTER\n        elif alignment == 'right':\n            return WD_PARAGRAPH_ALIGNMENT.RIGHT\n        else:\n            return WD_PARAGRAPH_ALIGNMENT.LEFT\n```",
    "45": "```python\nfrom PIL import Image, ImageEnhance, ImageChops\nimport os\n\nclass ImageProcessor:\n    \"\"\"\n    This is a class to process images, including loading, saving, resizing, rotating, and adjusting the brightness of images.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize self.image\n        \"\"\"\n        self.image = None\n\n    def load_image(self, image_path):\n        \"\"\"\n        Open an image using PIL.\n        :param image_path: str, path of the image to be loaded\n        \"\"\"\n        try:\n            self.image = Image.open(image_path)\n        except Exception as e:\n            raise ValueError(f\"Error loading image: {e}\")\n\n    def save_image(self, save_path):\n        \"\"\"\n        Save the image to a specified path if the image is loaded.\n        :param save_path: str, path where the image will be saved\n        \"\"\"\n        if self.image is None:\n            raise ValueError(\"No image loaded to save.\")\n        self.image.save(save_path)\n\n    def resize_image(self, width, height):\n        \"\"\"\n        Resize the loaded image to the specified dimensions.\n        :param width: int, target width of the image\n        :param height: int, target height of the image\n        \"\"\"\n        if self.image is None:\n            raise ValueError(\"No image loaded to resize.\")\n        self.image = self.image.resize((width, height))\n\n    def rotate_image(self, degrees):\n        \"\"\"\n        Rotate the loaded image by a specified number of degrees.\n        :param degrees: float, degrees to rotate the image\n        \"\"\"\n        if self.image is None:\n            raise ValueError(\"No image loaded to rotate.\")\n        self.image = self.image.rotate(degrees, expand=True)\n\n    def adjust_brightness(self, factor):\n        \"\"\"\n        Adjust the brightness of the loaded image.\n        :param factor: float, brightness factor. 0.0 gives a black image, 1.0 gives the original image.\n        \"\"\"\n        if self.image is None:\n            raise ValueError(\"No image loaded to adjust brightness.\")\n        if factor < 0:\n            raise ValueError(\"Brightness factor must be non-negative.\")\n        enhancer = ImageEnhance.Brightness(self.image)\n        self.image = enhancer.enhance(factor)\n```",
    "50": "```python\nimport json\nimport os\n\nclass JSONProcessor:\n    \"\"\"\n    This is a class to process JSON files, including reading and writing JSON files, as well as processing JSON data by removing a specified key from the JSON object.\n    \"\"\"\n\n    def read_json(self, file_path):\n        \"\"\"\n        Read a JSON file and return the data.\n        :param file_path: str, the path of the JSON file.\n        :return: dict, the data from the JSON file if read successfully, \n                or return -1 if an error occurs during the reading process,\n                return 0 if the file does not exist.\n        \"\"\"\n        if not os.path.isfile(file_path):\n            return 0\n        \n        try:\n            with open(file_path, 'r') as file:\n                return json.load(file)\n        except (json.JSONDecodeError, OSError):\n            return -1\n\n    def write_json(self, data, file_path):\n        \"\"\"\n        Write data to a JSON file and save it to the given path.\n        :param data: dict, the data to be written to the JSON file.\n        :param file_path: str, the path of the JSON file.\n        :return: 1 if the writing process is successful, \n                or -1 if an error occurs during the writing process.\n        \"\"\"\n        if not isinstance(data, dict):\n            return -1\n        \n        try:\n            with open(file_path, 'w') as file:\n                json.dump(data, file, ensure_ascii=False, indent=4)\n            return 1\n        except (OSError, TypeError):\n            return -1\n\n    def process_json(self, file_path, remove_key):\n        \"\"\"\n        Read a JSON file and process the data by removing a specified key and rewrite the modified data back to the file.\n        :param file_path: str, the path of the JSON file.\n        :param remove_key: str, the key to be removed.\n        :return: 1 if the specified key is successfully removed and the data is written back,\n                0 if the file does not exist or the specified key does not exist in the data.\n        \"\"\"\n        data = self.read_json(file_path)\n        if data in (0, -1) or remove_key not in data:\n            return 0\n        \n        data.pop(remove_key, None)\n        return self.write_json(data, file_path)\n```",
    "39": "```python\nfrom collections import deque\nfrom decimal import Decimal\n\nclass ExpressionCalculator:\n    \"\"\"\n    This is a class in Python that can perform calculations with basic arithmetic operations, including addition, subtraction, multiplication, division, and modulo.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the expression calculator\n        \"\"\"\n        self.postfix_stack = deque()\n        self.operat_priority = {\n            '+': 1,\n            '-': 1,\n            '*': 2,\n            '/': 2,\n            '%': 2,\n            '(': 0\n        }\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the result of the given infix expression\n        :param expression: string, the infix expression to be calculated\n        :return: float, the calculated result\n        \"\"\"\n        self.prepare(expression)\n        stack = []\n        for token in self.postfix_stack:\n            if not self.is_operator(token):\n                stack.append(Decimal(token))\n            else:\n                second_value = stack.pop()\n                first_value = stack.pop()\n                result = self._calculate(first_value, second_value, token)\n                stack.append(result)\n        return float(stack[0]) if stack else 0.0\n\n    def prepare(self, expression):\n        \"\"\"\n        Prepare the infix expression for conversion to postfix notation\n        :param expression: string, the infix expression to be prepared\n        \"\"\"\n        self.postfix_stack.clear()\n        output = []\n        operators = []\n        expression = self.transform(expression)\n        for char in expression:\n            if char.isdigit() or (char == '-' and (not output or output[-1] in '(*')):\n                output.append(char)\n            elif self.is_operator(char):\n                while (operators and operators[-1] != '(' and\n                       self.compare(char, operators[-1])):\n                    output.append(operators.pop())\n                operators.append(char)\n            elif char == '(':\n                operators.append(char)\n            elif char == ')':\n                while operators and operators[-1] != '(':\n                    output.append(operators.pop())\n                operators.pop()  # discard the '('\n        while operators:\n            output.append(operators.pop())\n        self.postfix_stack = deque(output)\n\n    @staticmethod\n    def is_operator(c):\n        \"\"\"\n        Check if a character is an operator in {'+', '-', '*', '/', '(', ')', '%'}\n        :param c: string, the character to be checked\n        :return: bool, True if the character is an operator, False otherwise\n        \"\"\"\n        return c in {'+', '-', '*', '/', '%', '(', ')'}\n\n    def compare(self, cur, peek):\n        \"\"\"\n        Compare the precedence of two operators\n        :param cur: string, the current operator\n        :param peek: string, the operator at the top of the operator stack\n        :return: bool, True if the current operator has higher or equal precedence, False otherwise\n        \"\"\"\n        return self.operat_priority[cur] <= self.operat_priority[peek]\n\n    @staticmethod\n    def _calculate(first_value, second_value, current_op):\n        \"\"\"\n        Perform the mathematical calculation based on the given operands and operator\n        :param first_value: Decimal, the first operand\n        :param second_value: Decimal, the second operand\n        :param current_op: string, the operator\n        :return: Decimal, the calculated result\n        \"\"\"\n        if current_op == '+':\n            return first_value + second_value\n        elif current_op == '-':\n            return first_value - second_value\n        elif current_op == '*':\n            return first_value * second_value\n        elif current_op == '/':\n            if second_value == 0:\n                raise ZeroDivisionError(\"Division by zero is not allowed.\")\n            return first_value / second_value\n        elif current_op == '%':\n            return first_value % second_value\n        else:\n            raise ValueError(\"Invalid operator\")\n\n    @staticmethod\n    def transform(expression):\n        \"\"\"\n        Transform the infix expression to a format suitable for conversion\n        :param expression: string, the infix expression to be transformed\n        :return: string, the transformed expression\n        \"\"\"\n        return expression.replace(\" \", \"\")\n```",
    "42": "```python\nclass Hotel:\n    \"\"\"\n    A class representing a hotel management system for managing bookings, check-ins, check-outs, and room availability.\n    \"\"\"\n\n    def __init__(self, name, rooms):\n        \"\"\"\n        Initialize the hotel with a name and the available room types.\n        :param name: str, the name of the hotel\n        :param rooms: dict, available rooms with room types as keys and counts as values\n        \"\"\"\n        self.name = name\n        self.available_rooms = rooms\n        self.booked_rooms = {}\n\n    def book_room(self, room_type, room_number, name):\n        \"\"\"\n        Attempt to book a specified number of rooms of a certain type for a guest.\n        :param room_type: str, the type of room to book\n        :param room_number: int, the number of rooms to book\n        :param name: str, the name of the guest\n        :return: str or int or bool, result of the booking attempt\n        \"\"\"\n        if room_type not in self.available_rooms:\n            return False\n        \n        available_count = self.available_rooms[room_type]\n        \n        if room_number <= available_count:\n            self.available_rooms[room_type] -= room_number\n            if room_type not in self.booked_rooms:\n                self.booked_rooms[room_type] = {}\n            if name not in self.booked_rooms[room_type]:\n                self.booked_rooms[room_type][name] = 0\n            self.booked_rooms[room_type][name] += room_number\n            return 'Success!'\n        elif available_count > 0:\n            return available_count\n        else:\n            return False\n\n    def check_in(self, room_type, room_number, name):\n        \"\"\"\n        Check in a guest for a booked room.\n        :param room_type: str, the type of room\n        :param room_number: int, the number of rooms to check in\n        :param name: str, the name of the guest\n        :return: bool, True if check-in is successful, False otherwise\n        \"\"\"\n        if room_type not in self.booked_rooms or name not in self.booked_rooms[room_type]:\n            return False\n        \n        booked_count = self.booked_rooms[room_type][name]\n        \n        if room_number > booked_count:\n            return False\n        \n        self.booked_rooms[room_type][name] -= room_number\n        if self.booked_rooms[room_type][name] == 0:\n            del self.booked_rooms[room_type][name]\n        \n        return True\n\n    def check_out(self, room_type, room_number):\n        \"\"\"\n        Check out a number of rooms, updating availability.\n        :param room_type: str, the type of room\n        :param room_number: int, the number of rooms to check out\n        \"\"\"\n        if room_type not in self.available_rooms:\n            self.available_rooms[room_type] = 0\n        self.available_rooms[room_type] += room_number\n\n    def get_available_rooms(self, room_type):\n        \"\"\"\n        Get the count of available rooms of a specific type.\n        :param room_type: str, the type of room to check\n        :return: int, the count of available rooms\n        \"\"\"\n        return self.available_rooms.get(room_type, 0)\n```",
    "51": "```python\nimport numpy as np\n\nclass KappaCalculator:\n    \"\"\"\n    A class to calculate Cohen's and Fleiss' kappa coefficients.\n    \"\"\"\n\n    @staticmethod\n    def kappa(testData, k):\n        \"\"\"\n        Calculate Cohen's kappa value of a k-dimensional matrix.\n        \n        :param testData: The k-dimensional matrix for which to calculate Cohen's kappa value.\n        :param k: int, Matrix dimension.\n        :return: float, the Cohen's kappa value of the matrix.\n        \n        >>> KappaCalculator.kappa([[2, 1, 1], [1, 2, 1], [1, 1, 2]], 3)\n        0.25\n        \"\"\"\n        testData = np.array(testData)\n        n = np.sum(testData)\n        total_agreement = np.sum(np.diag(testData))\n        expected_agreement = np.sum(np.sum(testData, axis=0) ** 2) / (n ** 2)\n        observed_agreement = total_agreement / n\n        \n        # Avoid division by zero\n        if expected_agreement == 1:\n            return 1.0 if observed_agreement == expected_agreement else 0.0\n        \n        kappa_value = (observed_agreement - expected_agreement) / (1 - expected_agreement)\n        return kappa_value\n\n    @staticmethod\n    def fleiss_kappa(testData, N, k, n):\n        \"\"\"\n        Calculate Fleiss' kappa value of an N * k matrix.\n        \n        :param testData: Input data matrix, N * k.\n        :param N: int, Number of samples.\n        :param k: int, Number of categories.\n        :param n: int, Number of raters.\n        :return: float, Fleiss' kappa value.\n        \n        >>> KappaCalculator.fleiss_kappa([[0, 0, 0, 0, 14],\n        >>>                                  [0, 2, 6, 4, 2],\n        >>>                                  [0, 0, 3, 5, 6],\n        >>>                                  [0, 3, 9, 2, 0],\n        >>>                                  [2, 2, 8, 1, 1],\n        >>>                                  [7, 7, 0, 0, 0],\n        >>>                                  [3, 2, 6, 3, 0],\n        >>>                                  [2, 5, 3, 2, 2],\n        >>>                                  [6, 5, 2, 1, 0],\n        >>>                                  [0, 2, 2, 3, 7]], 10, 5, 14)\n        0.20993070442195522\n        \"\"\"\n        testData = np.array(testData)\n        p = np.sum(testData, axis=0) / (N * n)\n        P_e = np.sum(p ** 2)\n        P = np.sum(np.diag(np.dot(testData, testData.T))) / (n * (n - 1))\n        \n        # Avoid division by zero\n        if P_e == 1:\n            return 1.0 if P == P_e else 0.0\n        \n        fleiss_kappa_value = (P - P_e) / (1 - P_e)\n        return fleiss_kappa_value\n```",
    "62": "```python\nclass NLPDataProcessor:\n    \"\"\"\n    The class processes NLP data by removing stop words from a list of strings using a pre-defined stop word list.\n    \"\"\"\n\n    @staticmethod\n    def construct_stop_word_list():\n        \"\"\"\n        Construct a stop word list including 'a', 'an', 'the'.\n        :return: a list of stop words\n        >>> NLPDataProcessor.construct_stop_word_list()\n        ['a', 'an', 'the']\n        \"\"\"\n        return ['a', 'an', 'the']\n\n    @staticmethod\n    def remove_stop_words(string_list, stop_word_list):\n        \"\"\"\n        Remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :param stop_word_list: a list of stop words\n        :return: a list of words without stop words\n        >>> NLPDataProcessor.remove_stop_words(['This is a test.'], ['a', 'an', 'the'])\n        [['This', 'is', 'test.']]\n        \"\"\"\n        words_list = []\n        for string in string_list:\n            words = string.split()\n            filtered_words = [word for word in words if word.lower() not in stop_word_list]\n            words_list.append(filtered_words)\n        return words_list\n\n    def process(self, string_list):\n        \"\"\"\n        Construct a stop word list including 'a', 'an', 'the', and remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :return: a list of words without stop words\n        >>> NLPDataProcessor().process(['This is a test.'])\n        [['This', 'is', 'test.']]\n        \"\"\"\n        stop_word_list = self.construct_stop_word_list()\n        return self.remove_stop_words(string_list, stop_word_list)\n```",
    "53": "```python\nimport re\nimport unittest\n\nclass LongestWord:\n    \"\"\"\n    A class that allows adding words to a list and finding the longest word in a given sentence\n    by comparing the words with those in the word list. Words are strictly case sensitive.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize an empty list of words.\"\"\"\n        self.word_list = []\n\n    def add_word(self, word):\n        \"\"\"\n        Append the input word into self.word_list.\n        :param word: str, input word\n        \"\"\"\n        if isinstance(word, str):\n            self.word_list.append(word)\n\n    def find_longest_word(self, sentence):\n        \"\"\"\n        Remove punctuation marks and split a sentence into a list of words. \n        Find the longest word that is in self.word_list.\n        :param sentence: a sentence str\n        :return str: the longest word found in self.word_list or '' if self.word_list is empty.\n        \"\"\"\n        if not self.word_list:\n            return ''\n        \n        # Remove punctuation and split the sentence into words\n        words = re.findall(r'\\b\\w+\\b', sentence)\n        longest = ''\n        \n        for word in words:\n            if word in self.word_list and len(word) > len(longest):\n                longest = word\n        \n        return longest\n\n\nclass LongestWordTestAddWord(unittest.TestCase):\n    def test_add_word_1(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"hello\")\n        self.assertEqual(['hello'], longestWord.word_list)\n\n    def test_add_word_2(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"hello\")\n        longestWord.add_word(\"world\")\n        self.assertEqual(['hello', 'world'], longestWord.word_list)\n\n    def test_add_word_3(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"hello\")\n        longestWord.add_word(\"world\")\n        longestWord.add_word(\"!\")\n        self.assertEqual(['hello', 'world', '!'], longestWord.word_list)\n\n    def test_add_word_4(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"hello\")\n        longestWord.add_word(\"world\")\n        longestWord.add_word(\"!\")\n        longestWord.add_word(\"!\")\n        self.assertEqual(['hello', 'world', '!', '!'], longestWord.word_list)\n\n    def test_add_word_5(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"hello\")\n        longestWord.add_word(\"world\")\n        longestWord.add_word(\"!\")\n        longestWord.add_word(\"!\")\n        longestWord.add_word(\"!\")\n        self.assertEqual(['hello', 'world', '!', '!', '!'], longestWord.word_list)\n\n\nclass LongestWordTestFindLongestWord(unittest.TestCase):\n    def test_find_longest_word_1(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"a\")\n        sentence = 'I am a student.'\n        self.assertEqual('a', longestWord.find_longest_word(sentence))\n\n    def test_find_longest_word_2(self):\n        longestWord = LongestWord()\n        sentence = 'I am a student.'\n        self.assertEqual('', longestWord.find_longest_word(sentence))\n\n    def test_find_longest_word_3(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"student\")\n        sentence = 'I am a student.'\n        self.assertEqual('student', longestWord.find_longest_word(sentence))\n\n    def test_find_longest_word_4(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"apple\")\n        sentence = 'Apple is red.'\n        self.assertEqual('apple', longestWord.find_longest_word(sentence))\n\n    def test_find_longest_word_5(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"apple\")\n        longestWord.add_word(\"red\")\n        sentence = 'Apple is red.'\n        self.assertEqual('apple', longestWord.find_longest_word(sentence))\n\nif __name__ == \"__main__\":\n    unittest.main()\n```",
    "57": "```python\nimport numpy as np\n\n\nclass MetricsCalculator2:\n    \"\"\"\n    The class provides to calculate Mean Reciprocal Rank (MRR) and Mean Average Precision (MAP) based on input data,\n    where MRR measures the ranking quality and MAP measures the average precision.\n    \"\"\"\n\n    @staticmethod\n    def mrr(data):\n        \"\"\"\n        Compute the MRR of the input data. MRR is a widely used evaluation index. It is the mean of reciprocal rank.\n        :param data: the data must be a list of tuples, where each tuple contains (actual result, ground truth num).\n        1 stands for a correct answer, 0 stands for a wrong answer.\n        :return: A tuple of the mean MRR value and a list of reciprocal ranks for each input.\n        \"\"\"\n        if not isinstance(data, (list, tuple)):\n            raise ValueError(\"Input data must be a list or tuple.\")\n\n        if isinstance(data, tuple):\n            data = [data]\n\n        reciprocal_ranks = []\n        for actual, total in data:\n            if total <= 0:\n                reciprocal_ranks.append(0.0)\n                continue\n\n            rank = next((i + 1 for i, value in enumerate(actual) if value == 1), None)\n            reciprocal_ranks.append(1 / rank if rank is not None else 0.0)\n\n        mrr_value = np.mean(reciprocal_ranks) if reciprocal_ranks else 0.0\n        return mrr_value, reciprocal_ranks\n\n    @staticmethod\n    def map(data):\n        \"\"\"\n        Compute the MAP of the input data. MAP is a widely used evaluation index. It is the mean of AP (average precision).\n        :param data: the data must be a list of tuples, where each tuple contains (actual result, ground truth num).\n        1 stands for a correct answer, 0 stands for a wrong answer.\n        :return: A tuple of the mean MAP value and a list of average precisions for each input.\n        \"\"\"\n        if not isinstance(data, (list, tuple)):\n            raise ValueError(\"Input data must be a list or tuple.\")\n\n        if isinstance(data, tuple):\n            data = [data]\n\n        average_precisions = []\n        for actual, total in data:\n            if total <= 0:\n                average_precisions.append(0.0)\n                continue\n\n            relevant_count = 0\n            precision_sum = 0.0\n            for i, value in enumerate(actual):\n                if value == 1:\n                    relevant_count += 1\n                    precision_sum += relevant_count / (i + 1)\n\n            ap_value = precision_sum / relevant_count if relevant_count > 0 else 0.0\n            average_precisions.append(ap_value)\n\n        map_value = np.mean(average_precisions) if average_precisions else 0.0\n        return map_value, average_precisions\n```",
    "56": "```python\nclass MetricsCalculator:\n    \"\"\"\n    The class calculates precision, recall, F1 score, and accuracy based on predicted and true labels.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the number of all four samples to 0\n        \"\"\"\n        self.reset_metrics()\n\n    def reset_metrics(self):\n        \"\"\"Reset all metrics to zero.\"\"\"\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n    def update(self, predicted_labels, true_labels):\n        \"\"\"\n        Update the number of all four samples (true_positives, false_positives, false_negatives, true_negatives)\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: None\n        \"\"\"\n        self.reset_metrics()  # Reset metrics before updating\n        for pred, true in zip(predicted_labels, true_labels):\n            if pred == 1 and true == 1:\n                self.true_positives += 1\n            elif pred == 1 and true == 0:\n                self.false_positives += 1\n            elif pred == 0 and true == 1:\n                self.false_negatives += 1\n            elif pred == 0 and true == 0:\n                self.true_negatives += 1\n\n    def precision(self):\n        \"\"\"\n        Calculate precision\n        :return: float\n        \"\"\"\n        if self.true_positives + self.false_positives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_positives)\n\n    def recall(self):\n        \"\"\"\n        Calculate recall\n        :return: float\n        \"\"\"\n        if self.true_positives + self.false_negatives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_negatives)\n\n    def f1_score(self):\n        \"\"\"\n        Calculate f1 score, which is the harmonic mean of precision and recall\n        :return: float\n        \"\"\"\n        precision_val = self.precision()\n        recall_val = self.recall()\n        if precision_val + recall_val == 0:\n            return 0.0\n        return 2 * (precision_val * recall_val) / (precision_val + recall_val)\n\n    def accuracy(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate accuracy\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        \"\"\"\n        total = len(predicted_labels)\n        if total == 0:\n            return 0.0\n        correct_predictions = sum(p == t for p, t in zip(predicted_labels, true_labels))\n        return correct_predictions / total\n```",
    "60": "```python\nimport sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information,\n    searching for movie information by customer name, and deleting movie information by ticket ID.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.\n        Fields include ID of type int, movie name of type str, theater name of type str,\n        seat number of type str, and customer name of type str.\n        :return: None\n        \"\"\"\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS tickets (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                movie_name TEXT NOT NULL,\n                theater_name TEXT NOT NULL,\n                seat_number TEXT NOT NULL,\n                customer_name TEXT NOT NULL\n            )\n        ''')\n        self.connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        self.cursor.execute('''\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n            VALUES (?, ?, ?, ?)\n        ''', (movie_name, theater_name, seat_number, customer_name))\n        self.connection.commit()\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        \"\"\"\n        self.cursor.execute('''\n            SELECT * FROM tickets WHERE customer_name = ?\n        ''', (customer_name,))\n        return self.cursor.fetchall()\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"\n        self.cursor.execute('''\n            DELETE FROM tickets WHERE id = ?\n        ''', (ticket_id,))\n        self.connection.commit()\n\n    def close(self):\n        \"\"\"Closes the database connection.\"\"\"\n        self.connection.close()\n```\n",
    "59": "```python\nfrom datetime import datetime\nimport numpy as np\n\nclass MovieBookingSystem:\n    \"\"\"\n    This class represents a movie booking system, which allows adding movies, booking tickets,\n    and checking the available movies within a given time range.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the movie booking system with an empty list of movies.\n        \"\"\"\n        self.movies = []\n\n    def add_movie(self, name, price, start_time, end_time, n):\n        \"\"\"\n        Add a new movie to the system.\n        :param name: str, movie name\n        :param price: float, price for one ticket\n        :param start_time: str, movie start time in 'HH:MM' format\n        :param end_time: str, movie end time in 'HH:MM' format\n        :param n: int, the size of seats (n*n)\n        \"\"\"\n        start_time_dt = datetime.strptime(start_time, '%H:%M')\n        end_time_dt = datetime.strptime(end_time, '%H:%M')\n\n        if end_time_dt <= start_time_dt:\n            raise ValueError(\"End time must be after start time.\")\n\n        seats = np.zeros((n, n), dtype=int)\n        self.movies.append({\n            'name': name,\n            'price': price,\n            'start_time': start_time_dt,\n            'end_time': end_time_dt,\n            'seats': seats\n        })\n\n    def book_ticket(self, name, seats_to_book):\n        \"\"\"\n        Book tickets for a movie. Update the seats status if booking is successful.\n        :param name: str, movie name\n        :param seats_to_book: list of tuples, representing seats to book [(row1, col1), (row2, col2), ...]\n        :return: str, booking status message.\n        \"\"\"\n        for movie in self.movies:\n            if movie['name'].lower() == name.lower():\n                for row, col in seats_to_book:\n                    if 0 <= row < movie['seats'].shape[0] and 0 <= col < movie['seats'].shape[1]:\n                        if movie['seats'][row][col] == 0:\n                            movie['seats'][row][col] = 1\n                        else:\n                            return 'Booking failed.'\n                    else:\n                        return 'Invalid seat position.'\n                return 'Booking success.'\n        return 'Movie not found.'\n\n    def available_movies(self, start_time, end_time):\n        \"\"\"\n        Get a list of available movies within the specified time range.\n        :param start_time: str, start time in 'HH:MM' format\n        :param end_time: str, end time in 'HH:MM' format\n        :return: list of str, names of available movies\n        \"\"\"\n        start_time_dt = datetime.strptime(start_time, '%H:%M')\n        end_time_dt = datetime.strptime(end_time, '%H:%M')\n\n        available = []\n        for movie in self.movies:\n            if movie['start_time'] >= start_time_dt and movie['end_time'] <= end_time_dt:\n                available.append(movie['name'])\n        return available\n```",
    "46": "```python\nclass Interpolation:\n    \"\"\"\n    This is a class that implements the Linear interpolation operation of one-dimensional and two-dimensional data.\n    \"\"\"\n\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        \"\"\"\n        Linear interpolation of one-dimensional data.\n        :param x: The x-coordinate of the data point, list.\n        :param y: The y-coordinate of the data point, list.\n        :param x_interp: The x-coordinate of the interpolation point, list.\n        :return: The y-coordinate of the interpolation point, list.\n        >>> interpolation = Interpolation()\n        >>> interpolation.interpolate_1d([1, 2, 3], [1, 2, 3], [1.5, 2.5])\n        [1.5, 2.5]\n        \"\"\"\n        if not x_interp or not x or not y or len(x) != len(y):\n            return []\n\n        y_interp = []\n        for xi in x_interp:\n            if xi < x[0]:\n                # Extrapolate before the first point\n                y_interp.append(y[0] + (y[1] - y[0]) * ((xi - x[0]) / (x[1] - x[0])))\n            elif xi > x[-1]:\n                # Extrapolate after the last point\n                y_interp.append(y[-1] + (y[-1] - y[-2]) * ((xi - x[-1]) / (x[-1] - x[-2])))\n            else:\n                for i in range(len(x) - 1):\n                    if x[i] <= xi <= x[i + 1]:\n                        y_interp.append(y[i] + (y[i + 1] - y[i]) * ((xi - x[i]) / (x[i + 1] - x[i])))\n                        break\n        return y_interp\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        \"\"\"\n        Linear interpolation of two-dimensional data.\n        :param x: The x-coordinate of the data point, list.\n        :param y: The y-coordinate of the data point, list.\n        :param z: The z-coordinate of the data point, list.\n        :param x_interp: The x-coordinate of the interpolation point, list.\n        :param y_interp: The y-coordinate of the interpolation point, list.\n        :return: The z-coordinate of the interpolation point, list.\n        >>> interpolation = Interpolation()\n        >>> interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1.5, 2.5], [1.5, 2.5])\n        [3.0, 7.0]\n        \"\"\"\n        if not x_interp or not y_interp or not x or not y or not z or len(x) != len(z[0]) or len(y) != len(z):\n            return []\n\n        z_interp = []\n        for xi, yi in zip(x_interp, y_interp):\n            if xi < x[0] or xi > x[-1] or yi < y[0] or yi > y[-1]:\n                z_interp.append(None)\n                continue\n            \n            # Perform bilinear interpolation\n            for i in range(len(x) - 1):\n                for j in range(len(y) - 1):\n                    if x[i] <= xi <= x[i + 1] and y[j] <= yi <= y[j + 1]:\n                        q11 = z[j][i]\n                        q21 = z[j][i + 1]\n                        q12 = z[j + 1][i]\n                        q22 = z[j + 1][i + 1]\n\n                        z_interp_value = (q11 * (x[i + 1] - xi) * (y[j + 1] - yi) +\n                                          q21 * (xi - x[i]) * (y[j + 1] - yi) +\n                                          q12 * (x[i + 1] - xi) * (yi - y[j]) +\n                                          q22 * (xi - x[i]) * (yi - y[j])) / \\\n                                          ((x[i + 1] - x[i]) * (y[j + 1] - y[j]))\n                        z_interp.append(z_interp_value)\n                        break\n                else:\n                    continue\n                break\n        return z_interp\n```",
    "48": "```python\nimport socket\nimport re\n\n\nclass IpUtil:\n    \"\"\"\n    This is a utility class for handling IP addresses, including validation and hostname retrieval.\n    \"\"\"\n\n    @staticmethod\n    def is_valid_ipv4(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv4 address.\n        :param ip_address: string, the IP address to check\n        :return: bool, True if the IP address is valid, False otherwise\n        >>> IpUtil.is_valid_ipv4('192.168.0.123')\n        True\n        >>> IpUtil.is_valid_ipv4('256.0.0.0')\n        False\n        \"\"\"\n        pattern = r'^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){2}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'\n        return re.match(pattern, ip_address) is not None\n\n    @staticmethod\n    def is_valid_ipv6(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv6 address.\n        :param ip_address: string, the IP address to check\n        :return: bool, True if the IP address is valid, False otherwise\n        >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:0000:0000:8a2e:0370:7334')\n        True\n        >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:::8a2e:0370:7334')\n        False\n        \"\"\"\n        try:\n            socket.inet_pton(socket.AF_INET6, ip_address)\n            return True\n        except socket.error:\n            return False\n\n    @staticmethod\n    def get_hostname(ip_address):\n        \"\"\"\n        Get the hostname associated with the given IP address.\n        :param ip_address: string, the IP address to get the hostname for\n        :return: string or None, the hostname associated with the IP address or None if not found\n        >>> IpUtil.get_hostname('110.242.68.3')\n        'www.baidu.com'  # Note: This may vary depending on current DNS records\n        >>> IpUtil.get_hostname('10.0.0.1')\n        \"\"\"\n        try:\n            return socket.gethostbyaddr(ip_address)[0]\n        except socket.herror:\n            return None\n\n\n# Unit tests\nimport unittest\n\nclass IpUtilTestIsValidIpv4(unittest.TestCase):\n    def test_is_valid_ipv4_1(self):\n        result = IpUtil.is_valid_ipv4('192.168.0.123')\n        self.assertEqual(result, True)\n\n    def test_is_valid_ipv4_2(self):\n        result = IpUtil.is_valid_ipv4('10.10.10.10')\n        self.assertEqual(result, True)\n\n    def test_is_valid_ipv4_3(self):\n        result = IpUtil.is_valid_ipv4('0.0.0.0')\n        self.assertEqual(result, True)\n\n    def test_is_valid_ipv4_4(self):\n        result = IpUtil.is_valid_ipv4('abc.168.0.123')\n        self.assertEqual(result, False)\n\n    def test_is_valid_ipv4_5(self):\n        result = IpUtil.is_valid_ipv4('256.0.0.0')\n        self.assertEqual(result, False)\n\n\nclass IpUtilTestIsValidIpv6(unittest.TestCase):\n    def test_is_valid_ipv6_1(self):\n        result = IpUtil.is_valid_ipv6('2001:0db8:85a3:0000:0000:8a2e:0370:7334')\n        self.assertEqual(result, True)\n\n    def test_is_valid_ipv6_2(self):\n        result = IpUtil.is_valid_ipv6('2001:0db8:85a3:::8a2e:0370:7334')\n        self.assertEqual(result, False)\n\n    def test_is_valid_ipv6_3(self):\n        result = IpUtil.is_valid_ipv6('2001:0db8:85a3:2001:llll:8a2e:0370:7334')\n        self.assertEqual(result, False)\n\n    def test_is_valid_ipv6_4(self):\n        result = IpUtil.is_valid_ipv6('2001:0db8:85a3:llll:llll:8a2e:0370:7334')\n        self.assertEqual(result, False)\n\n    def test_is_valid_ipv6_5(self):\n        result = IpUtil.is_valid_ipv6('2001:0db8:85a3::llll:8a2e:0370:7334')\n        self.assertEqual(result, False)\n\n\nclass IpUtilTestGetHostname(unittest.TestCase):\n    def test_get_hostname_1(self):\n        result = IpUtil.get_hostname('110.242.68.3')\n        self.assertEqual(result, None)\n\n    def test_get_hostname_2(self):\n        result = IpUtil.get_hostname('10.0.0.1')\n        self.assertEqual(result, None)\n\n    def test_get_hostname_3(self):\n        result = IpUtil.get_hostname('0.0.0.0')\n        self.assertEqual(result, socket.gethostname())  # Localhost\n\n    def test_get_hostname_4(self):\n        result = IpUtil.get_hostname('0.0.0.1')\n        self.assertEqual(result, None)\n\n    def test_get_hostname_5(self):\n        result = IpUtil.get_hostname('0.0.0.2')\n        self.assertEqual(result, None)\n\n\nclass IpUtilTest(unittest.TestCase):\n    def test_IpUtil(self):\n        result = IpUtil.is_valid_ipv4('192.168.0.123')\n        self.assertEqual(result, True)\n\n        result = IpUtil.is_valid_ipv6('2001:0db8:85a3:0000:0000:8a2e:0370:7334')\n        self.assertEqual(result, True)\n\n        result = IpUtil.get_hostname('110.242.68.3')\n        self.assertEqual(result, None)\n```",
    "63": "```python\nimport re\nfrom collections import Counter\n\nclass NLPDataProcessor2:\n    \"\"\"\n    The class processes NLP data by extracting words from a list of strings, calculating the frequency of each word, and returning the top 5 most frequent words.\n    \"\"\"\n\n    def process_data(self, string_list):\n        \"\"\"\n        Keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words.\n        :param string_list: a list of strings\n        :return: words_list: a list of words lists\n        \"\"\"\n        words_list = []\n        for string in string_list:\n            # Keep only letters and spaces\n            cleaned_string = re.sub(r'[^a-zA-Z\\s]', '', string).lower()\n            words = cleaned_string.split()\n            words_list.append(words)\n        return words_list\n\n    def calculate_word_frequency(self, words_list):\n        \"\"\"\n        Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.\n        :param words_list: a list of words lists\n        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency\n        \"\"\"\n        word_count = Counter()\n        for words in words_list:\n            word_count.update(words)\n        return dict(word_count.most_common(5))\n\n    def process(self, string_list):\n        \"\"\"\n        Keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words. \n        Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.\n        :param string_list: a list of strings\n        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency\n        \"\"\"\n        words_list = self.process_data(string_list)\n        return self.calculate_word_frequency(words_list)\n```",
    "49": "```python\nclass JobMarketplace:\n    \"\"\"\n    This is a class that provides functionalities to publish positions, remove positions, submit resumes,\n    withdraw resumes, search for positions, and obtain candidate information.\n    \"\"\"\n\n    def __init__(self):\n        self.job_listings = []\n        self.resumes = []\n\n    def post_job(self, job_title, company, requirements):\n        \"\"\"\n        This function is used to publish positions and add the position information to the job_listings list.\n        :param job_title: The title of the position, str.\n        :param company: The company of the position, str.\n        :param requirements: The requirements of the position, list.\n        :return: None\n        \"\"\"\n        self.job_listings.append({\n            'job_title': job_title,\n            'company': company,\n            'requirements': requirements\n        })\n\n    def remove_job(self, job):\n        \"\"\"\n        This function is used to remove positions and remove the position information from the job_listings list.\n        :param job: The position information to be removed, dict.\n        :return: None\n        \"\"\"\n        try:\n            self.job_listings.remove(job)\n        except ValueError:\n            print(\"Job not found in listings.\")\n\n    def submit_resume(self, name, skills, experience):\n        \"\"\"\n        This function is used to submit resumes and add the resume information to the resumes list.\n        :param name: The name of the resume, str.\n        :param skills: The skills of the resume, list.\n        :param experience: The experience of the resume, str.\n        :return: None\n        \"\"\"\n        self.resumes.append({\n            'name': name,\n            'skills': skills,\n            'experience': experience\n        })\n\n    def withdraw_resume(self, resume):\n        \"\"\"\n        This function is used to withdraw resumes and remove the resume information from the resumes list.\n        :param resume: The resume information to be removed, dict.\n        :return: None\n        \"\"\"\n        try:\n            self.resumes.remove(resume)\n        except ValueError:\n            print(\"Resume not found in submissions.\")\n\n    def search_jobs(self, criteria):\n        \"\"\"\n        This function is used to search for positions and return the position information that meets the requirements.\n        :param criteria: The requirements of the position, str.\n        :return: The position information that meets the requirements, list.\n        \"\"\"\n        return [job for job in self.job_listings if any(skill in job['requirements'] for skill in criteria)]\n\n    def get_job_applicants(self, job):\n        \"\"\"\n        This function is used to obtain candidate information and return the candidate information that meets the\n        requirements by calling the matches_requirements function.\n        :param job: The position information, dict.\n        :return: The candidate information that meets the requirements, list.\n        \"\"\"\n        return [resume for resume in self.resumes if self.matches_requirements(resume, job['requirements'])]\n\n    def matches_requirements(self, resume, requirements):\n        \"\"\"\n        This function checks if a resume matches the job requirements.\n        :param resume: The resume information, dict.\n        :param requirements: The job requirements, list.\n        :return: True if the resume matches the requirements, False otherwise.\n        \"\"\"\n        return all(skill in resume['skills'] for skill in requirements)\n```",
    "54": "```python\nimport random\n\nclass MahjongConnect:\n    \"\"\"\n    MahjongConnect is a class representing a game board for Mahjong Connect with features like creating the board, checking valid moves, finding paths, removing icons, and checking if the game is over.\n    \"\"\"\n\n    def __init__(self, BOARD_SIZE, ICONS):\n        \"\"\"\n        Initialize the board size and the icon list, create the game board.\n        :param BOARD_SIZE: list of two integers, representing the number of rows and columns of the game board.\n        :param ICONS: list of strings, representing the icons.\n        \"\"\"\n        if not isinstance(BOARD_SIZE, (list, tuple)) or len(BOARD_SIZE) != 2:\n            raise ValueError(\"BOARD_SIZE must be a list or tuple of two integers.\")\n        if not all(isinstance(i, int) and i > 0 for i in BOARD_SIZE):\n            raise ValueError(\"BOARD_SIZE must contain positive integers.\")\n        self.BOARD_SIZE = BOARD_SIZE\n        self.ICONS = ICONS\n        self.board = self.create_board()\n\n    def create_board(self):\n        \"\"\"\n        Create the game board with the given board size and icons.\n        :return: 2-dimensional list representing the game board.\n        \"\"\"\n        rows, cols = self.BOARD_SIZE\n        num_icons = len(self.ICONS)\n        total_icons = (rows * cols) // 2\n        if total_icons > num_icons:\n            icons_list = (self.ICONS * (total_icons // num_icons + 1))[:total_icons]\n        else:\n            icons_list = self.ICONS[:total_icons]\n        icons_list = icons_list * 2  # Each icon appears twice\n        random.shuffle(icons_list)\n        return [icons_list[i * cols:(i + 1) * cols] for i in range(rows)]\n\n    def is_valid_move(self, pos1, pos2):\n        \"\"\"\n        Check if the move of two icons is valid.\n        :param pos1: position tuple (x, y) of the first icon.\n        :param pos2: position tuple (x, y) of the second icon.\n        :return: True or False, representing whether the move is valid.\n        \"\"\"\n        if pos1 == pos2:\n            return False\n        if not self._is_position_valid(pos1) or not self._is_position_valid(pos2):\n            return False\n        if self.board[pos1[0]][pos1[1]] != self.board[pos2[0]][pos2[1]]:\n            return False\n        return self.has_path(pos1, pos2)\n\n    def _is_position_valid(self, pos):\n        x, y = pos\n        return 0 <= x < self.BOARD_SIZE[0] and 0 <= y < self.BOARD_SIZE[1]\n\n    def has_path(self, pos1, pos2):\n        \"\"\"\n        Check if there is a path between two icons.\n        :param pos1: position tuple (x, y) of the first icon.\n        :param pos2: position tuple (x, y) of the second icon.\n        :return: True or False, representing whether there is a path.\n        \"\"\"\n        visited = set()\n        return self._has_path_dfs(pos1[0], pos1[1], pos2[0], pos2[1], visited)\n\n    def _has_path_dfs(self, x1, y1, x2, y2, visited):\n        if (x1, y1) in visited:\n            return False\n        visited.add((x1, y1))\n        if (x1, y1) == (x2, y2):\n            return True\n        \n        # Directions for moving in the grid\n        directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n        \n        for dx, dy in directions:\n            nx, ny = x1 + dx, y1 + dy\n            while self._is_position_valid((nx, ny)):\n                if self.board[nx][ny] == ' ':\n                    if self._has_path_dfs(nx, ny, x2, y2, visited):\n                        return True\n                elif (nx, ny) == (x2, y2):\n                    return True\n                else:\n                    break  # Hit a wall\n                nx += dx\n                ny += dy\n\n        return False\n\n    def remove_icons(self, pos1, pos2):\n        \"\"\"\n        Remove the connected icons on the game board.\n        :param pos1: position tuple (x, y) of the first icon to be removed.\n        :param pos2: position tuple (x, y) of the second icon to be removed.\n        \"\"\"\n        self.board[pos1[0]][pos1[1]] = ' '\n        self.board[pos2[0]][pos2[1]] = ' '\n\n    def is_game_over(self):\n        \"\"\"\n        Check if the game is over.\n        :return: True or False, representing whether the game is over.\n        \"\"\"\n        for row in self.board:\n            if any(icon != ' ' for icon in row):\n                return False\n        return True\n```",
    "61": "```python\nimport random\n\nclass MusicPlayer:\n    \"\"\"\n    This is a class as a music player that provides functionalities to play, stop, add songs, remove songs, set volume, shuffle, and switch to the next or previous song.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the music player with an empty playlist, no current song, and a default volume of 50.\n        \"\"\"\n        self.playlist = []\n        self.current_song_index = None\n        self.volume = 50\n\n    def add_song(self, song):\n        \"\"\"\n        Adds a song to the playlist.\n        :param song: The song to add to the playlist, str.\n        \"\"\"\n        self.playlist.append(song)\n\n    def remove_song(self, song):\n        \"\"\"\n        Removes a song from the playlist.\n        :param song: The song to remove from the playlist, str.\n        \"\"\"\n        if song in self.playlist:\n            self.playlist.remove(song)\n            # Adjust current song index if necessary\n            if self.current_song_index is not None and self.playlist:\n                if self.current_song_index >= len(self.playlist):\n                    self.current_song_index = len(self.playlist) - 1\n\n    def play(self):\n        \"\"\"\n        Plays the current song in the playlist.\n        :return: The current song in the playlist, or False if there is no current song.\n        \"\"\"\n        if self.current_song_index is not None and 0 <= self.current_song_index < len(self.playlist):\n            return self.playlist[self.current_song_index]\n        return False\n\n    def stop(self):\n        \"\"\"\n        Stops the current song in the playlist.\n        :return: True if the current song was stopped, False if there was no current song.\n        \"\"\"\n        if self.current_song_index is not None:\n            self.current_song_index = None\n            return True\n        return False\n\n    def switch_song(self):\n        \"\"\"\n        Switches to the next song in the playlist.\n        :return: True if the next song was switched to, False if there was no next song.\n        \"\"\"\n        if self.playlist:\n            if self.current_song_index is None:\n                self.current_song_index = 0\n            elif self.current_song_index < len(self.playlist) - 1:\n                self.current_song_index += 1\n            else:\n                return False\n            return True\n        return False\n\n    def previous_song(self):\n        \"\"\"\n        Switches to the previous song in the playlist.\n        :return: True if the previous song was switched to, False if there was no previous song.\n        \"\"\"\n        if self.playlist and self.current_song_index is not None and self.current_song_index > 0:\n            self.current_song_index -= 1\n            return True\n        return False\n\n    def set_volume(self, volume):\n        \"\"\"\n        Sets the volume of the music player, if the volume is between 0 and 100 is valid.\n        :param volume: The volume to set the music player to, int.\n        :return: True if the volume was set, False if the volume was invalid.\n        \"\"\"\n        if 0 <= volume <= 100:\n            self.volume = volume\n            return True\n        return False\n\n    def shuffle(self):\n        \"\"\"\n        Shuffles the playlist.\n        :return: True if the playlist was shuffled, False if the playlist was empty.\n        \"\"\"\n        if self.playlist:\n            random.shuffle(self.playlist)\n            # Reset the current song index after shuffling\n            self.current_song_index = 0\n            return True\n        return False\n```",
    "58": "```python\nimport random\n\nclass MinesweeperGame:\n    \"\"\"\n    This is a class that implements mine sweeping games including minesweeping and winning judgment.\n    \"\"\"\n\n    def __init__(self, n, k) -> None:\n        \"\"\"\n        Initializes the MinesweeperGame class with the size of the board and the number of mines.\n        :param n: The size of the board, int.\n        :param k: The number of mines, int.\n        \"\"\"\n        if n <= 0 or k < 0 or k > n * n:\n            raise ValueError(\"Invalid board size or number of mines.\")\n        \n        self.n = n\n        self.k = k\n        self.minesweeper_map = self.generate_mine_sweeper_map()\n        self.player_map = self.generate_player_map()\n        self.score = 0\n\n    def generate_mine_sweeper_map(self):\n        \"\"\"\n        Generates a minesweeper map with the given size of the board and the number of mines.\n        :return: The minesweeper map, list.\n        \"\"\"\n        board = [[0 for _ in range(self.n)] for _ in range(self.n)]\n        mines = set()\n\n        while len(mines) < self.k:\n            x = random.randint(0, self.n - 1)\n            y = random.randint(0, self.n - 1)\n            if (x, y) not in mines:\n                mines.add((x, y))\n                board[x][y] = 'X'\n        \n        for x, y in mines:\n            for dx in range(-1, 2):\n                for dy in range(-1, 2):\n                    if 0 <= x + dx < self.n and 0 <= y + dy < self.n and board[x + dx][y + dy] != 'X':\n                        board[x + dx][y + dy] += 1\n\n        return board\n\n    def generate_player_map(self):\n        \"\"\"\n        Generates a player map with the given size of the board.\n        :return: The player map, list.\n        \"\"\"\n        return [['-' for _ in range(self.n)] for _ in range(self.n)]\n\n    def check_won(self):\n        \"\"\"\n        Checks whether the player has won the game.\n        :return: True if the player has won the game, False otherwise.\n        \"\"\"\n        for i in range(self.n):\n            for j in range(self.n):\n                if self.player_map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':\n                    return False\n        return True\n\n    def sweep(self, x, y):\n        \"\"\"\n        Sweeps the given position.\n        :param x: The x coordinate of the position, int.\n        :param y: The y coordinate of the position, int.\n        :return: True if the player has won the game, False if hit a mine, else returns the updated player map.\n        \"\"\"\n        if self.minesweeper_map[x][y] == 'X':\n            return False\n        \n        self.player_map[x][y] = self.minesweeper_map[x][y]\n        self.score += 1\n        \n        if self.check_won():\n            return True\n        \n        return self.player_map\n```",
    "69": "```python\nimport PyPDF2\nimport os\n\nclass PDFHandler:\n    \"\"\"\n    The class allows merging multiple PDF files into one and extracting text from PDFs using PyPDF2 library.\n    \"\"\"\n\n    def __init__(self, filepaths):\n        \"\"\"\n        Takes a list of file paths (filepaths) as a parameter.\n        It creates a list named readers using PyPDF2, where each reader opens a file from the given paths.\n        \"\"\"\n        self.filepaths = filepaths\n        self.readers = [self._open_pdf(fp) for fp in filepaths]\n\n    def _open_pdf(self, filepath):\n        \"\"\"\n        Helper method to open a PDF file and return a PdfFileReader object.\n        :param filepath: str, path to the PDF file\n        :return: PdfFileReader object\n        \"\"\"\n        try:\n            return PyPDF2.PdfReader(filepath)\n        except Exception as e:\n            raise ValueError(f\"Error opening {filepath}: {e}\")\n\n    def merge_pdfs(self, output_filepath):\n        \"\"\"\n        Merge PDF files in self.readers to one pdf and save it to disk.\n        :param output_filepath: str, output file path to save to\n        :return: str, confirmation message if successfully merged\n        \"\"\"\n        pdf_writer = PyPDF2.PdfWriter()\n        for reader in self.readers:\n            for page_num in range(len(reader.pages)):\n                pdf_writer.add_page(reader.pages[page_num])\n        \n        with open(output_filepath, 'wb') as out_file:\n            pdf_writer.write(out_file)\n        \n        return f\"Merged PDFs saved at {output_filepath}\"\n\n    def extract_text_from_pdfs(self):\n        \"\"\"\n        Extract text from PDF files in self.readers.\n        :return: list of str, each element is the text of one PDF file\n        \"\"\"\n        pdf_texts = []\n        for reader in self.readers:\n            text = ''\n            for page_num in range(len(reader.pages)):\n                text += reader.pages[page_num].extract_text() or ''\n            pdf_texts.append(text)\n        return pdf_texts\n```",
    "44": "```python\nimport re\nfrom bs4 import BeautifulSoup\nimport unittest\n\nclass HtmlUtil:\n    \"\"\"\n    This is a class as util for HTML, supporting formatting and extracting code from HTML text, including cleaning up the text and converting certain elements into specific marks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a series of labels.\n        \"\"\"\n        self.SPACE_MARK = '-SPACE-'\n        self.JSON_MARK = '-JSON-'\n        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'\n        self.URL_MARK = '-URL-'\n        self.NUMBER_MARK = '-NUMBER-'\n        self.TRACE_MARK = '-TRACE-'\n        self.COMMAND_MARK = '-COMMAND-'\n        self.COMMENT_MARK = '-COMMENT-'\n        self.CODE_MARK = '-CODE-'\n\n    @staticmethod\n    def __format_line_feed(text):\n        \"\"\"\n        Replace consecutive line breaks with a single line break.\n        :param text: string with consecutive line breaks.\n        :return: string, replaced text with single line break.\n        \"\"\"\n        return re.sub(r'\\n+', '\\n', text)\n\n    def format_line_html_text(self, html_text):\n        \"\"\"\n        Get the HTML text without the code, and add the code tag -CODE- where the code is.\n        :param html_text: string.\n        :return: string.\n        \"\"\"\n        soup = BeautifulSoup(html_text, 'html.parser')\n        for code in soup.find_all(['pre', 'code']):\n            code.insert_before(self.CODE_MARK)\n            code.insert_before('\\n')\n            code.insert_after('\\n')\n            code.unwrap()\n        formatted_text = self.__format_line_feed(soup.get_text())\n        return formatted_text.strip()\n\n    def extract_code_from_html_text(self, html_text):\n        \"\"\"\n        Extract codes from the HTML body.\n        :param html_text: string, HTML text.\n        :return: list of code.\n        \"\"\"\n        soup = BeautifulSoup(html_text, 'html.parser')\n        codes = [code.get_text() for code in soup.find_all(['pre', 'code'])]\n        return codes\n\n\nclass HtmlUtilTestFormatLineFeed(unittest.TestCase):\n    def test_format_line_feed_1(self):\n        self.assertEqual(HtmlUtil._HtmlUtil__format_line_feed('aaa\\n\\n\\n'), 'aaa\\n')\n\n    def test_format_line_feed_2(self):\n        self.assertEqual(HtmlUtil._HtmlUtil__format_line_feed('aaa\\n\\n\\n\\n'), 'aaa\\n')\n\n    def test_format_line_feed_3(self):\n        self.assertEqual(HtmlUtil._HtmlUtil__format_line_feed('aaa\\n\\n\\nbbb\\n\\n'), 'aaa\\nbbb\\n')\n\n    def test_format_line_feed_4(self):\n        self.assertEqual(HtmlUtil._HtmlUtil__format_line_feed('ccc\\n\\n\\n'), 'ccc\\n')\n\n    def test_format_line_feed_5(self):\n        self.assertEqual(HtmlUtil._HtmlUtil__format_line_feed(''), '')\n\n\nclass HtmlUtilTestFormatLineHtmlText(unittest.TestCase):\n    def test_format_line_html_text_1(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''\n        <html>\n        <body>\n        <h1>Title</h1>\n        <p>This is a paragraph.</p>\n        <pre>print('Hello, world!')</pre>\n        <p>Another paragraph.</p>\n        <pre><code>for i in range(5):\n        print(i)</code></pre>\n        </body>\n        </html>\n        ''')\n        self.assertEqual(res, '''\nTitle\nThis is a paragraph.\n-CODE-\nAnother paragraph.\n-CODE-\n''')\n\n    def test_format_line_html_text_2(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''\n        <html>\n        <body>\n        <h1>Title2</h1>\n        <p>This is a paragraph.</p>\n        <pre>print('Hello, world!')</pre>\n        <p>Another paragraph.</p>\n        <pre><code>for i in range(5):\n        print(i)</code></pre>\n        </body>\n        </html>\n        ''')\n        self.assertEqual(res, '''\nTitle2\nThis is a paragraph.\n-CODE-\nAnother paragraph.\n-CODE-\n''')\n\n    def test_format_line_html_text_3(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''\n        <html>\n        <body>\n        <h1>Title3</h1>\n        <p>This is a paragraph.</p>\n        <pre>print('Hello, world!')</pre>\n        <p>Another paragraph.</p>\n        <pre><code>for i in range(5):\n        print(i)</code></pre>\n        </body>\n        </html>\n        ''')\n        self.assertEqual(res, '''\nTitle3\nThis is a paragraph.\n-CODE-\nAnother paragraph.\n-CODE-\n''')\n\n    def test_format_line_html_text_4(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''\n        <html>\n        <body>\n        <h1>Title4</h1>\n        <p>This is a paragraph.</p>\n        <pre>print('Hello, world!')</pre>\n        <p>Another paragraph.</p>\n        <pre><code>for i in range(5):\n        print(i)</code></pre>\n        </body>\n        </html>\n        ''')\n        self.assertEqual(res, '''\nTitle4\nThis is a paragraph.\n-CODE-\nAnother paragraph.\n-CODE-\n''')\n\n    def test_format_line_html_text_5(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''\n        <html>\n        <body>\n        <h1>Title5</h1>\n        <p>This is a paragraph.</p>\n        <pre>print('Hello, world!')</pre>\n        <p>Another paragraph.</p>\n        <pre><code>for i in range(5):\n        print(i)</code></pre>\n        </body>\n        </html>\n        ''')\n        self.assertEqual(res, '''\nTitle5\nThis is a paragraph.\n-CODE-\nAnother paragraph.\n-CODE-\n''')\n\n    def test_format_line_html_text_6(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('')\n        self.assertEqual(res, '')\n\n    def test_format_line_html_text_7(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''<ul><li>Item 1!</li></ul>''')\n        self.assertEqual(res, '''Item 1!''')\n\n    def test_format_line_html_text_8(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''<ul><li></li></ul>''')\n        self.assertEqual(res, '')\n\n    def test_format_line_html_text_9(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''<p>Some sentence here.</p>''')\n        self.assertEqual(res, 'Some sentence here.')\n\n    def test_format_line_html_text_10(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''<p>Some paragraph here</p><code>Code block</code>''')\n        self.assertEqual(res, '''Some paragraph hereCode block''')\n\n    def test_format_line_html_text_11(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''<p>Some paragraph here</p><div>Some text here</div>''')\n        self.assertEqual(res, '''Some paragraph hereSome text here''')\n\n    def test_format_line_html_text_12(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''<ul><li>Item 1</li></ul>''')\n        self.assertEqual(res, '''Item 1''')\n\n\nclass HtmlUtilTestExtractCodeFromHtmlText(unittest.TestCase):\n    def test_extract_code_from_html_text_1(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.extract_code_from_html_text('''\n                <html>\n                <body>\n                <h1>Title</h1>\n                <p>This is a paragraph.</p>\n                <pre>print('Hello, world!')</pre>\n                <p>Another paragraph.</p>\n                <pre><code>for i in range(5):\n                print(i)</code></pre>\n                </body>\n                </html>\n                ''')\n        self.assertEqual(res, [\"print('Hello, world!')\", 'for i in range(5):\\n                print(i)'])\n\n    def test_extract_code_from_html_text_2(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.extract_code_from_html_text('''\n                <html>\n                <body>\n                <h1>Title</h1>\n                <p>This is a paragraph.</p>\n                <pre>print('Hello, world!')</pre>\n                <p>Another paragraph.</p>\n                <pre><code>for i in range(4):\n                print(i)</code></pre>\n                </body>\n                </html>\n                ''')\n        self.assertEqual(res, [\"print('Hello, world!')\", 'for i in range(4):\\n                print(i)'])\n\n    def test_extract_code_from_html_text_3(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.extract_code_from_html_text('''\n                <html>\n                <body>\n                <h1>Title</h1>\n                <p>This is a paragraph.</p>\n                <pre>print('Hello, world!')</pre>\n                <p>Another paragraph.</p>\n                <pre><code>for i in range(3):\n                print(i)</code></pre>\n                </body>\n                </html>\n                ''')\n        self.assertEqual(res, [\"print('Hello, world!')\", 'for i in range(3):\\n                print(i)'])\n\n    def test_extract_code_from_html_text_4(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.extract_code_from_html_text('''\n                <html>\n                <body>\n                <h1>Title</h1>\n                <p>This is a paragraph.</p>\n                <pre>print('Hello, world!')</pre>\n                <p>Another paragraph.</p>\n                <pre><code>for i in range(2):\n                print(i)</code></pre>\n                </body>\n                </html>\n                ''')\n        self.assertEqual(res, [\"print('Hello, world!')\", 'for i in range(2):\\n                print(i)'])\n\n    def test_extract_code_from_html_text_5(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.extract_code_from_html_text(\"\")\n        self.assertEqual(res, [])\n\n\nclass HtmlUtilTest(unittest.TestCase):\n    def test_htmlutil(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''\n        <html>\n        <body>\n        <h1>Title</h1>\n        <p>This is a paragraph.</p>\n        <pre>print('Hello, world!')</pre>\n        <p>Another paragraph.</p>\n        <pre><code>for i in range(5):\n        print(i)</code></pre>\n        </body>\n        </html>\n        ''')\n        self.assertEqual(res, '''\nTitle\nThis is a paragraph.\n-CODE-\nAnother paragraph.\n-CODE-\n''')\n        res = htmlutil.extract_code_from_html_text('''\n                <html>\n                <body>\n                <h1>Title</h1>\n                <p>This is a paragraph.</p>\n                <pre>print('Hello, world!')</pre>\n                <p>Another",
    "68": "```python\nclass PageUtil:\n    \"\"\"\n    PageUtil class is a versatile utility for handling pagination and search functionalities in an efficient and convenient manner.\n    \"\"\"\n\n    def __init__(self, data, page_size):\n        \"\"\"\n        Initialize the PageUtil object with the given data and page size.\n        :param data: list, the data to be paginated\n        :param page_size: int, the number of items per page\n        \"\"\"\n        self.data = data\n        self.page_size = page_size\n        self.total_items = len(data)\n        self.total_pages = (self.total_items + page_size - 1) // page_size\n\n    def get_page(self, page_number):\n        \"\"\"\n        Retrieve a specific page of data.\n        :param page_number: int, the page number to fetch\n        :return: list, the data on the specified page\n        \"\"\"\n        if page_number < 1 or page_number > self.total_pages:\n            return []\n        start_index = (page_number - 1) * self.page_size\n        end_index = start_index + self.page_size\n        return self.data[start_index:end_index]\n\n    def get_page_info(self, page_number):\n        \"\"\"\n        Retrieve information about a specific page.\n        :param page_number: int, the page number to fetch information about\n        :return: dict, containing page information such as current page number, total pages, etc.\n        \"\"\"\n        if page_number < 1 or page_number > self.total_pages:\n            return {}\n        \n        current_page_data = self.get_page(page_number)\n        return {\n            \"current_page\": page_number,\n            \"per_page\": self.page_size,\n            \"total_pages\": self.total_pages,\n            \"total_items\": self.total_items,\n            \"has_previous\": page_number > 1,\n            \"has_next\": page_number < self.total_pages,\n            \"data\": current_page_data\n        }\n\n    def search(self, keyword):\n        \"\"\"\n        Search for items in the data that contain the given keyword.\n        :param keyword: str, the keyword to search for\n        :return: dict, containing search information such as total results and matching items\n        \"\"\"\n        results = [item for item in self.data if keyword in str(item)]\n        total_results = len(results)\n        total_pages = (total_results + self.page_size - 1) // self.page_size if total_results > 0 else 0\n        return {\n            \"keyword\": keyword,\n            \"total_results\": total_results,\n            \"total_pages\": total_pages,\n            \"results\": results\n        }\n```",
    "55": "```python\nclass Manacher:\n    \"\"\"\n    This is a class that implements the Manacher algorithm to find the longest palindromic substring in a given string.\n    \"\"\"\n\n    def __init__(self, input_string: str) -> None:\n        \"\"\"\n        Initializes the Manacher class with the given input_string.\n        :param input_string: The input_string to be searched, str.\n        \"\"\"\n        self.input_string = input_string\n\n    def palindromic_length(self, center: int, diff: int, string: str) -> int:\n        \"\"\"\n        Recursively calculates the length of the palindromic substring based on a given center, difference value, and input string.\n        :param center: The center of the palindromic substring, int.\n        :param diff: The difference between the center and the current position, int.\n        :param string: The string to be searched, str.\n        :return: The length of the palindromic substring, int.\n        \"\"\"\n        left = center - diff\n        right = center + diff\n        \n        if left < 0 or right >= len(string):\n            return 0\n        if string[left] == string[right]:\n            return 1 + self.palindromic_length(center, diff + 1, string)\n        else:\n            return 0\n\n    def palindromic_string(self) -> str:\n        \"\"\"\n        Finds the longest palindromic substring in the given string.\n        :return: The longest palindromic substring, str.\n        \"\"\"\n        transformed_string = \"|\" + \"|\".join(self.input_string) + \"|\"\n        max_len = 0\n        center_index = 0\n        \n        for i in range(len(transformed_string)):\n            length = self.palindromic_length(i, 0, transformed_string)\n            if length > max_len:\n                max_len = length\n                center_index = i\n            \n        start_index = (center_index - max_len) // 2  # Adjust to original string indices\n        return self.input_string[start_index:start_index + max_len]\n\n# Unit tests\nimport unittest\n\nclass ManacherTestPalindromicLength(unittest.TestCase):\n    def test_palindromic_length(self):\n        manacher = Manacher('ababa')\n        self.assertEqual(manacher.palindromic_length(2, 1, 'a|b|a|b|a'), 2)\n\n    def test_palindromic_length_2(self):\n        manacher = Manacher('ababaxse')\n        self.assertEqual(manacher.palindromic_length(2, 1, 'a|b|a|b|a|x|s|e'), 2)\n\n    def test_palindromic_length_3(self):\n        manacher = Manacher('ababax')\n        self.assertEqual(manacher.palindromic_length(2, 3, 'a|b|a|b|a|x'), 0)\n\n    def test_palindromic_length_4(self):\n        manacher = Manacher('ababax')\n        self.assertEqual(manacher.palindromic_length(9, 2, 'a|b|a|b|a|x'), 0)\n\n    def test_palindromic_length_5(self):\n        manacher = Manacher('ababax')\n        self.assertEqual(manacher.palindromic_length(4, 1, 'a|b|a|b|a|x'), 4)\n\nclass ManacherTestPalindromicString(unittest.TestCase):\n    def test_palindromic_string(self):\n        manacher = Manacher('ababaxse')\n        self.assertEqual(manacher.palindromic_string(), 'ababa')\n\n    def test_palindromic_string_2(self):\n        manacher = Manacher('ababax')\n        self.assertEqual(manacher.palindromic_string(), 'ababa')\n\n    def test_palindromic_string_3(self):\n        manacher = Manacher('ababax')\n        self.assertEqual(manacher.palindromic_string(), 'ababa')\n\n    def test_palindromic_string_4(self):\n        manacher = Manacher('ababaxssss')\n        self.assertEqual(manacher.palindromic_string(), 'ababa')\n\n    def test_palindromic_string_5(self):\n        manacher = Manacher('abab')\n        self.assertEqual(manacher.palindromic_string(), 'aba')\n\nclass ManacherTestMain(unittest.TestCase):\n    def test_main(self):\n        manacher = Manacher('ababa')\n        self.assertEqual(manacher.palindromic_length(2, 1, 'a|b|a|b|a'), 2)\n        self.assertEqual(manacher.palindromic_string(), 'ababa')\n\nif __name__ == '__main__':\n    unittest.main()\n```",
    "70": "```python\nclass PersonRequest:\n    \"\"\"\n    This class validates input personal information data and sets invalid fields to None based on specific rules.\n    \"\"\"\n\n    def __init__(self, name: str, sex: str, phoneNumber: str):\n        \"\"\"\n        Initialize PersonRequest object with the provided information.\n        :param name: str, the name of the person\n        :param sex: str, the sex of the person\n        :param phoneNumber: str, the phone number of the person\n        \"\"\"\n        self.name = self._validate_name(name)\n        self.sex = self._validate_sex(sex)\n        self.phoneNumber = self._validate_phone_number(phoneNumber)\n\n    def _validate_name(self, name: str) -> str:\n        \"\"\"\n        Validate the name and return it. If name is empty or exceeds 33 characters in length, set to None.\n        :param name: str, the name to validate\n        :return: str, the validated name or None if invalid\n        \"\"\"\n        if not name or len(name) > 33:\n            return None\n        return name\n\n    def _validate_sex(self, sex: str) -> str:\n        \"\"\"\n        Validate the sex and return it. If sex is not Man, Woman, or UGM, set to None.\n        :param sex: str, the sex to validate\n        :return: str, the validated sex or None if invalid\n        \"\"\"\n        if sex not in [\"Man\", \"Woman\", \"UGM\"]:\n            return None\n        return sex\n\n    def _validate_phone_number(self, phoneNumber: str) -> str:\n        \"\"\"\n        Validate the phone number and return it. If phoneNumber is empty or not an 11 digit number, set to None.\n        :param phoneNumber: str, the phone number to validate\n        :return: str, the validated phone number or None if invalid\n        \"\"\"\n        if not phoneNumber or len(phoneNumber) != 11 or not phoneNumber.isdigit():\n            return None\n        return phoneNumber\n```",
    "67": "```python\nclass Order:\n    \"\"\"\n    The class manages restaurant orders by allowing the addition of dishes, calculation of the total cost, and checkout.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the order management system.\n        self.menu stores the dishes of restaurant inventory.\n        self.selected_dishes stores the dishes selected by the customer.\n        self.sales stores the sales of each dish.\n        \"\"\"\n        self.menu = []\n        self.selected_dishes = []\n        self.sales = {}\n\n    def add_dish(self, dish):\n        \"\"\"\n        Check the self.menu and add into self.selected_dishes if the dish count is valid.\n        If the dish has successfully been added, change the count in self.menu.\n        :param dish: dict, the information of dish. dish = {\"dish\": dish name, \"count\": count, price: price}\n        :return: True if successfully added, or False otherwise.\n        \"\"\"\n        for menu_dish in self.menu:\n            if menu_dish['dish'] == dish['dish']:\n                if menu_dish['count'] >= dish['count']:\n                    menu_dish['count'] -= dish['count']\n                    self.selected_dishes.append({\"dish\": dish['dish'], \"count\": dish['count'], \"price\": dish['price']})\n                    return True\n                else:\n                    return False\n        return False\n\n    def calculate_total(self):\n        \"\"\"\n        Calculate the total price of dishes that have been ordered. \n        Multiply the count, price, and sales.\n        :return: float, the final total price.\n        \"\"\"\n        total = 0\n        for selected in self.selected_dishes:\n            dish_name = selected['dish']\n            price = selected['price']\n            count = selected['count']\n            total += price * count * self.sales.get(dish_name, 1)\n        return total\n\n    def checkout(self):\n        \"\"\"\n        Check out the dishes ordered. If the self.selected_dishes is not empty, invoke the calculate_total\n        method to check out.\n        :return: False if the self.selected_dishes is empty, or total (return value of calculate_total) otherwise.\n        \"\"\"\n        if not self.selected_dishes:\n            return False\n        total = self.calculate_total()\n        self.selected_dishes.clear()  # Clear selected dishes after checkout\n        return total\n```",
    "73": "```python\nclass RPGCharacter:\n    \"\"\"\n    The class represents a role-playing game character, which allows to attack other characters, heal, gain experience, level up, and check if the character is alive.\n    \"\"\"\n\n    def __init__(self, name, hp, attack_power, defense, level=1):\n        \"\"\"\n        Initialize an RPG character object.\n        :param name: str, the name of the character.\n        :param hp: int, The health points of the character.\n        :param attack_power: int, the attack power of the character.\n        :param defense: int, the defense points of the character.\n        :param level: int, the level of the character. Default is 1.\n        \"\"\"\n        self.name = name\n        self.hp = hp\n        self.attack_power = attack_power\n        self.defense = defense\n        self.level = level\n        self.exp = 0\n\n    def attack(self, other_character):\n        \"\"\"\n        Attack another character. The damage caused needs to offset the defense value.\n        :param other_character: RPGCharacter, The character being attacked.\n        \"\"\"\n        damage = max(0, self.attack_power - other_character.defense)\n        other_character.hp = max(0, other_character.hp - damage)\n\n    def heal(self):\n        \"\"\"\n        Heal the character with 10 hp and the max hp is 100.\n        :return: int, the current health points after healing.\n        \"\"\"\n        self.hp = min(100, self.hp + 10)\n        return self.hp\n\n    def gain_exp(self, amount):\n        \"\"\"\n        Gain experience points for the character and level up when the exp has reached the values that are 100 times the current level.\n        The experience that overflows should be used to calculate the next level up until exhausted.\n        :param amount: int, the amount of experience points to gain.\n        \"\"\"\n        self.exp += amount\n        while self.exp >= 100 * self.level and self.level < 100:\n            self.exp -= 100 * self.level\n            self.level_up()\n\n    def level_up(self):\n        \"\"\"\n        Level up the character and return to zero experience points, increase hp by 20 points, attack power and defense points by 5 points.\n        Max level is 100.\n        :return: tuple[int, int, int, int], the new level, health points, attack power, and defense points after leveling up.\n        \"\"\"\n        if self.level < 100:\n            self.level += 1\n            self.hp = min(100, self.hp + 20)\n            self.attack_power += 5\n            self.defense += 5\n        return self.level, self.hp, self.attack_power, self.defense\n\n    def is_alive(self):\n        \"\"\"\n        Check if player is alive.\n        :return: True if the hp is larger than 0, or False otherwise.\n        \"\"\"\n        return self.hp > 0\n```",
    "64": "```python\nclass NumberConverter:\n    \"\"\"\n    The class allows to convert decimal to binary, octal, and hexadecimal respectively and contrarily.\n    \"\"\"\n\n    @staticmethod\n    def decimal_to_binary(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to binary format.\n        :param decimal_num: int, decimal number\n        :return: str, the binary representation of an integer.\n        >>> NumberConverter.decimal_to_binary(42423)\n        '1010010110110111'\n        \"\"\"\n        if not isinstance(decimal_num, int) or decimal_num < 0:\n            raise ValueError(\"Input must be a non-negative integer.\")\n        return bin(decimal_num)[2:]\n\n    @staticmethod\n    def binary_to_decimal(binary_num):\n        \"\"\"\n        Convert a number from binary format to decimal format.\n        :param binary_num: str, binary number\n        :return: int, the decimal representation of binary number str.\n        >>> NumberConverter.binary_to_decimal('1010010110110111')\n        42423\n        \"\"\"\n        if not isinstance(binary_num, str) or not all(c in '01' for c in binary_num):\n            raise ValueError(\"Input must be a binary string.\")\n        return int(binary_num, 2)\n\n    @staticmethod\n    def decimal_to_octal(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to octal format.\n        :param decimal_num: int, decimal number\n        :return: str, the octal representation of an integer.\n        >>> NumberConverter.decimal_to_octal(42423)\n        '122667'\n        \"\"\"\n        if not isinstance(decimal_num, int) or decimal_num < 0:\n            raise ValueError(\"Input must be a non-negative integer.\")\n        return oct(decimal_num)[2:]\n\n    @staticmethod\n    def octal_to_decimal(octal_num):\n        \"\"\"\n        Convert a number from octal format to decimal format.\n        :param octal_num: str, octal num\n        :return: int, the decimal representation of octal number str.\n        >>> NumberConverter.octal_to_decimal('122667')\n        42423\n        \"\"\"\n        if not isinstance(octal_num, str) or not all(c in '01234567' for c in octal_num):\n            raise ValueError(\"Input must be an octal string.\")\n        return int(octal_num, 8)\n\n    @staticmethod\n    def decimal_to_hex(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to hex format.\n        :param decimal_num: int, decimal number\n        :return: str, the hex representation of an integer.\n        >>> NumberConverter.decimal_to_hex(42423)\n        'a5b7'\n        \"\"\"\n        if not isinstance(decimal_num, int) or decimal_num < 0:\n            raise ValueError(\"Input must be a non-negative integer.\")\n        return hex(decimal_num)[2:]\n\n    @staticmethod\n    def hex_to_decimal(hex_num):\n        \"\"\"\n        Convert a number from hex format to decimal format.\n        :param hex_num: str, hex num\n        :return: int, the decimal representation of hex number str.\n        >>> NumberConverter.hex_to_decimal('a5b7')\n        42423\n        \"\"\"\n        if not isinstance(hex_num, str) or not all(c in '0123456789abcdefABCDEF' for c in hex_num):\n            raise ValueError(\"Input must be a hexadecimal string.\")\n        return int(hex_num, 16)\n```",
    "74": "```python\nclass Server:\n    \"\"\"\n    This is a class that acts as a server, which handles a whitelist, message sending and receiving, and information display.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the whitelist as an empty list, and initialize the sending and receiving information as empty dictionaries.\n        \"\"\"\n        self.white_list = []\n        self.send_struct = {}\n        self.receive_struct = {}\n\n    def add_white_list(self, addr):\n        \"\"\"\n        Add an address to the whitelist and do nothing if it already exists.\n        :param addr: int, address to be added\n        :return: new whitelist if added, False if the address already exists\n        \"\"\"\n        if addr not in self.white_list:\n            self.white_list.append(addr)\n            return self.white_list\n        return False\n\n    def del_white_list(self, addr):\n        \"\"\"\n        Remove an address from the whitelist and do nothing if it does not exist.\n        :param addr: int, address to be deleted\n        :return: new whitelist if deleted, False if the address does not exist\n        \"\"\"\n        if addr in self.white_list:\n            self.white_list.remove(addr)\n            return self.white_list\n        return False\n\n    def recv(self, info):\n        \"\"\"\n        Receive information containing address and content. If the address is on the whitelist, receive the content; otherwise, do not receive it.\n        :param info: dict, information dictionary containing address and content\n        :return: content of the information if successfully received, otherwise False\n        \"\"\"\n        if isinstance(info, dict) and 'addr' in info and 'content' in info:\n            if info['addr'] in self.white_list:\n                self.receive_struct = info\n                return info['content']\n        return False\n\n    def send(self, info):\n        \"\"\"\n        Send information containing address and content.\n        :param info: dict, information dictionary containing address and content\n        :return: None if successfully sent, or a string indicating an error message if the structure is incorrect\n        \"\"\"\n        if isinstance(info, dict) and 'addr' in info and 'content' in info:\n            self.send_struct = info\n        else:\n            return \"info structure is not correct\"\n\n    def show(self, type):\n        \"\"\"\n        Returns struct of the specified type.\n        :param type: string, the type of struct to be returned, which can be 'send' or 'receive'\n        :return: corresponding struct if type is valid, otherwise False\n        \"\"\"\n        if type == 'send':\n            return self.send_struct\n        elif type == 'receive':\n            return self.receive_struct\n        return False\n```",
    "75": "```python\nclass ShoppingCart:\n    \"\"\"\n    The class manages items, their prices, quantities, and allows to add, remove, view items, and calculate the total price.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the items representing the shopping list as an empty dictionary\n        \"\"\"\n        self.items = {}\n\n    def add_item(self, item: str, price: float, quantity: int = 1) -> None:\n        \"\"\"\n        Add item information to the shopping list items, including price and quantity. The default quantity is 1.\n        :param item: string, Item to be added\n        :param price: float, The price of the item\n        :param quantity: int, The number of items, defaults to 1\n        \"\"\"\n        if quantity < 1:\n            raise ValueError(\"Quantity must be at least 1\")\n        if item in self.items:\n            self.items[item][\"quantity\"] += quantity\n        else:\n            self.items[item] = {\"price\": price, \"quantity\": quantity}\n\n    def remove_item(self, item: str, quantity: int = 1) -> None:\n        \"\"\"\n        Subtract the specified quantity of item from the shopping list items.\n        :param item: string, Item to be subtracted in quantity\n        :param quantity: int, Quantity to be subtracted\n        \"\"\"\n        if quantity < 1:\n            raise ValueError(\"Quantity must be at least 1\")\n        if item in self.items:\n            self.items[item][\"quantity\"] -= quantity\n            if self.items[item][\"quantity\"] <= 0:\n                del self.items[item]\n\n    def view_items(self) -> dict:\n        \"\"\"\n        Return the current shopping list items.\n        :return: dict, the current shopping list items\n        \"\"\"\n        return self.items\n\n    def total_price(self) -> float:\n        \"\"\"\n        Calculate the total price of all items in the shopping list, which is the quantity of each item multiplied by the price.\n        :return: float, the total price of all items in the shopping list\n        \"\"\"\n        total = sum(item[\"price\"] * item[\"quantity\"] for item in self.items.values())\n        return total\n```",
    "78": "```python\nimport re\n\nclass SplitSentence:\n    \"\"\"\n    The class allows to split sentences, count words in a sentence, and process a text file to find the maximum word count.\n    \"\"\"\n\n    def split_sentences(self, sentences_string):\n        \"\"\"\n        Split a string into a list of sentences. Sentences end with . or ? and with a space after that. \n        Please note that Mr. also end with . but are not sentences.\n        \n        :param sentences_string: string, string to split\n        :return: list, split sentence list\n        \"\"\"\n        pattern = r'(?<!\\bMr)(?<!\\b[A-Z]\\.)(?<!\\b[A-Z]\\.[A-Z]\\.)[.?\\n]+(?=\\s)'\n        sentences = re.split(pattern, sentences_string)\n        return [s.strip() for s in sentences if s.strip()]\n\n    def count_words(self, sentence):\n        \"\"\"\n        Count the number of words in a sentence. Note that words are separated by spaces and that \n        punctuation marks and numbers are not counted as words.\n        \n        :param sentence: string, sentence to be counted, where words are separated by spaces\n        :return: int, number of words in the sentence\n        \"\"\"\n        words = re.findall(r'\\b[a-zA-Z]+\\b', sentence)\n        return len(words)\n\n    def process_text_file(self, sentences_string):\n        \"\"\"\n        Given a text, return the number of words in the longest sentence\n        \n        :param sentences_string: string, undivided long sentence\n        :return: int, the number of words in the longest sentence\n        \"\"\"\n        sentences = self.split_sentences(sentences_string)\n        if not sentences:  # Handle case with no sentences\n            return 0\n        max_word_count = max(self.count_words(sentence) for sentence in sentences)\n        return max_word_count\n```",
    "76": "```python\nclass SignInSystem:\n    \"\"\"\n    This is a class for a sign-in system, including adding users, signing in/out, checking sign-in status, \n    and retrieving signed-in/not signed-in users.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the sign-in system.\n        \"\"\"\n        self.users = {}\n\n    def add_user(self, username):\n        \"\"\"\n        Add a user to the sign-in system if the user wasn't in the self.users.\n        And the initial state is False.\n        :param username: str, the username to be added.\n        :return: bool, True if the user is added successfully, False if the user already exists.\n        \"\"\"\n        if username not in self.users:\n            self.users[username] = False\n            return True\n        return False\n\n    def sign_in(self, username):\n        \"\"\"\n        Sign in a user if the user is in the self.users and change the state to True.\n        :param username: str, the username to be signed in.\n        :return: bool, True if the user is signed in successfully, False if the user does not exist.\n        \"\"\"\n        if username in self.users:\n            self.users[username] = True\n            return True\n        return False\n\n    def check_sign_in(self, username):\n        \"\"\"\n        Check if a user is signed in.\n        :param username: str, the username to be checked.\n        :return: bool, True if the user is signed in, False if the user does not exist or is not signed in.\n        \"\"\"\n        return self.users.get(username, False)\n\n    def all_signed_in(self):\n        \"\"\"\n        Check if all users are signed in.\n        :return: bool, True if all users are signed in, False otherwise.\n        \"\"\"\n        return all(self.users.values())\n\n    def all_not_signed_in(self):\n        \"\"\"\n        Get a list of usernames that are not signed in.\n        :return: list[str], a list of usernames that are not signed in.\n        \"\"\"\n        return [username for username, signed_in in self.users.items() if not signed_in]\n```",
    "66": "```python\nimport re\nimport unittest\n\nclass NumericEntityUnescaper:\n    \"\"\"\n    This is a class that provides functionality to replace numeric entities with their corresponding characters in a given string.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def replace(self, string):\n        \"\"\"\n        Replaces numeric character references (HTML entities) in the input string with their corresponding Unicode characters.\n        :param string: str, the input string containing numeric character references.\n        :return: str, the input string with numeric character references replaced with their corresponding Unicode characters.\n        >>> unescaper = NumericEntityUnescaper()\n        >>> unescaper.replace(\"&#65;&#66;&#67;\")\n        'ABC'\n        \"\"\"\n        def replace_entity(match):\n            entity = match.group(0)\n            try:\n                if entity.startswith(\"&#X\") or entity.startswith(\"&#x\"):\n                    code_point = int(entity[3:-1], 16)\n                else:\n                    code_point = int(entity[2:-1])\n                return chr(code_point)\n            except (ValueError, IndexError):\n                return entity  # Return the original if conversion fails\n\n        return re.sub(r'&#X?[0-9a-fA-F]+;', replace_entity, string)\n\n    @staticmethod\n    def is_hex_char(char):\n        \"\"\"\n        Determines whether a given character is a hexadecimal digit.\n        :param char: str, the character to check.\n        :return: bool, True if the character is a hexadecimal digit, False otherwise.\n        >>> NumericEntityUnescaper.is_hex_char('a')\n        True\n        \"\"\"\n        return char in '0123456789abcdefABCDEF'\n\n\nclass NumericEntityUnescaperTestReplace(unittest.TestCase):\n    def test_replace_1(self):\n        unescaper = NumericEntityUnescaper()\n        res = unescaper.replace(\"&#65;&#66;&#67;\")\n        self.assertEqual(res, \"ABC\")\n\n    def test_replace_2(self):\n        unescaper = NumericEntityUnescaper()\n        res = unescaper.replace(\"&#65;&#65;&#65;\")\n        self.assertEqual(res, \"AAA\")\n\n    def test_replace_3(self):\n        unescaper = NumericEntityUnescaper()\n        res = unescaper.replace(\"&#66;&#66;&#66;\")\n        self.assertEqual(res, \"BBB\")\n\n    def test_replace_4(self):\n        unescaper = NumericEntityUnescaper()\n        res = unescaper.replace(\"&#67;&#67;&#67;\")\n        self.assertEqual(res, \"CCC\")\n\n    def test_replace_5(self):\n        unescaper = NumericEntityUnescaper()\n        res = unescaper.replace(\"\")\n        self.assertEqual(res, \"\")\n\n    def test_replace_6(self):\n        unescaper = NumericEntityUnescaper()\n        res = unescaper.replace(\"&#\")\n        self.assertEqual(res, \"\")\n\n    def test_replace_7(self):\n        unescaper = NumericEntityUnescaper()\n        res = unescaper.replace(\"&#X65;&#66;&#67;\")\n        self.assertEqual(res, \"eBC\")\n\n    def test_replace_8(self):\n        unescaper = NumericEntityUnescaper()\n        res = unescaper.replace(\"&#???;&#66;&#67;\")\n        self.assertEqual(res, \"&#???;BC\")\n\n    def test_replace_9(self):\n        unescaper = NumericEntityUnescaper()\n        res = unescaper.replace(\"&#67;&#67;&#67;;\")\n        self.assertEqual(res, \"CCC\")\n\n    def test_replace_10(self):\n        unescaper = NumericEntityUnescaper()\n        res = unescaper.replace(\"&#X\")\n        self.assertEqual(res, \"\")\n\n    def test_replace_11(self):\n        unescaper = NumericEntityUnescaper()\n        res = unescaper.replace(\"&#c1d;&#66;&#67;\")\n        self.assertEqual(res, \"\")\n\n\nclass NumericEntityUnescaperTestIsHexChar(unittest.TestCase):\n    def test_is_hex_char_1(self):\n        unescaper = NumericEntityUnescaper()\n        res = unescaper.is_hex_char('0')\n        self.assertEqual(res, True)\n\n    def test_is_hex_char_2(self):\n        unescaper = NumericEntityUnescaper()\n        res = unescaper.is_hex_char('F')\n        self.assertEqual(res, True)\n\n    def test_is_hex_char_3(self):\n        unescaper = NumericEntityUnescaper()\n        res = unescaper.is_hex_char('G')\n        self.assertEqual(res, False)\n\n    def test_is_hex_char_4(self):\n        unescaper = NumericEntityUnescaper()\n        res = unescaper.is_hex_char('X')\n        self.assertEqual(res, False)\n\n    def test_is_hex_char_5(self):\n        unescaper = NumericEntityUnescaper()\n        res = unescaper.is_hex_char('Z')\n        self.assertEqual(res, False)\n\n\nclass UnescaperTest(unittest.TestCase):\n    def test_numericentityunescaper(self):\n        unescaper = NumericEntityUnescaper()\n        res = unescaper.replace(\"&#65;&#66;&#67;\")\n        self.assertEqual(res, \"ABC\")\n\n        res = unescaper.is_hex_char('0')\n        self.assertEqual(res, True)\n\nif __name__ == '__main__':\n    unittest.main()\n```",
    "81": "```python\nimport math\nfrom collections import Counter\n\nclass Statistics3:\n    \"\"\"\n    A class for calculating statistical indicators such as median, mode, correlation, mean, standard deviation, and Z-score.\n    \"\"\"\n\n    @staticmethod\n    def median(data):\n        if not data:\n            return None\n        data.sort()\n        n = len(data)\n        mid = n // 2\n        return (data[mid - 1] + data[mid]) / 2.0 if n % 2 == 0 else data[mid]\n\n    @staticmethod\n    def mode(data):\n        if not data:\n            return []\n        frequency = Counter(data)\n        max_freq = max(frequency.values())\n        return [x for x, freq in frequency.items() if freq == max_freq]\n\n    @staticmethod\n    def correlation(x, y):\n        if len(x) != len(y) or len(x) == 0:\n            return None\n        n = len(x)\n        mean_x = Statistics3.mean(x)\n        mean_y = Statistics3.mean(y)\n        numerator = sum((x[i] - mean_x) * (y[i] - mean_y) for i in range(n))\n        denominator_x = math.sqrt(sum((x[i] - mean_x) ** 2 for i in range(n)))\n        denominator_y = math.sqrt(sum((y[i] - mean_y) ** 2 for i in range(n)))\n        return None if denominator_x == 0 or denominator_y == 0 else numerator / (denominator_x * denominator_y)\n\n    @staticmethod\n    def mean(data):\n        return None if not data else sum(data) / len(data)\n\n    @staticmethod\n    def correlation_matrix(data):\n        if not data or len(data) == 0 or not all(len(row) == len(data[0]) for row in data):\n            return [[None] * len(data[0]) for _ in range(len(data))]\n        n = len(data)\n        matrix = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                matrix[i][j] = Statistics3.correlation(data[i], data[j])\n        return matrix\n\n    @staticmethod\n    def standard_deviation(data):\n        if not data:\n            return None\n        mean_value = Statistics3.mean(data)\n        variance = sum((x - mean_value) ** 2 for x in data) / len(data)\n        return math.sqrt(variance)\n\n    @staticmethod\n    def z_score(data):\n        if not data or len(set(data)) == 1:\n            return None\n        mean_value = Statistics3.mean(data)\n        std_dev = Statistics3.standard_deviation(data)\n        return [(x - mean_value) / std_dev for x in data]\n```",
    "77": "```python\nimport random\n\nclass Snake:\n    \"\"\"\n    The class is a snake game, which allows the snake to move and eat food, \n    and also enables resetting and generating a random food position.\n    \"\"\"\n\n    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):\n        \"\"\"\n        Initialize the length of the snake, screen width, screen height, \n        block size, snake head position, score, and food position.\n        :param SCREEN_WIDTH: int\n        :param SCREEN_HEIGHT: int\n        :param BLOCK_SIZE: int, Size of moving units\n        :param food_position: tuple, representing the position (x, y) of food.\n        \"\"\"\n        self.length = 1\n        self.SCREEN_WIDTH = SCREEN_WIDTH\n        self.SCREEN_HEIGHT = SCREEN_HEIGHT\n        self.BLOCK_SIZE = BLOCK_SIZE\n        self.positions = [(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)]\n        self.score = 0\n        self.food_position = food_position\n\n    def move(self, direction):\n        \"\"\"\n        Move the snake in the specified direction. If the new position of \n        the snake's head is equal to the position of the food, then eat \n        the food; If the position of the snake's head is equal to the \n        position of its body, then start over, otherwise, do not grow the snake.\n        :param direction: tuple, representing the direction of movement (x, y).\n        :return: None\n        \"\"\"\n        new_head_x = self.positions[0][0] + direction[0] * self.BLOCK_SIZE\n        new_head_y = self.positions[0][1] + direction[1] * self.BLOCK_SIZE\n        new_head = (new_head_x, new_head_y)\n\n        if new_head == self.food_position:\n            self.eat_food()\n        elif new_head in self.positions:\n            self.reset()\n        else:\n            self.length += 1\n\n        self.positions.insert(0, new_head)\n        if len(self.positions) > self.length:\n            self.positions.pop()\n\n    def random_food_position(self):\n        \"\"\"\n        Randomly generate a new food position, but don't place it on the snake.\n        :return: None\n        \"\"\"\n        while True:\n            new_food_position = (\n                random.randint(0, (self.SCREEN_WIDTH // self.BLOCK_SIZE) - 1) * self.BLOCK_SIZE,\n                random.randint(0, (self.SCREEN_HEIGHT // self.BLOCK_SIZE) - 1) * self.BLOCK_SIZE\n            )\n            if new_food_position not in self.positions:\n                self.food_position = new_food_position\n                break\n\n    def reset(self):\n        \"\"\"\n        Reset the snake to its initial state. Set the length to 1, the \n        snake head position to ((SCREEN_WIDTH//2), (SCREEN_HEIGHT//2)), \n        the score to 0, and randomly generate new food position.\n        :return: None\n        \"\"\"\n        self.length = 1\n        self.positions = [(self.SCREEN_WIDTH // 2, self.SCREEN_HEIGHT // 2)]\n        self.score = 0\n        self.random_food_position()\n\n    def eat_food(self):\n        \"\"\"\n        Increase the length of the snake by 1 and increase the score by 100. \n        Randomly generate a new food position, but don't place it on the snake.\n        :return: None\n        \"\"\"\n        self.length += 1\n        self.score += 100\n        self.random_food_position()\n```",
    "84": "```python\nimport json\nimport re\nimport os\n\nclass TextFileProcessor:\n    \"\"\"\n    The class handles reading, writing, and processing text files. It can read the file as JSON, read the raw text, write content to the file, and process the file by removing non-alphabetic characters.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initialize the file path.\n        :param file_path: str\n        \"\"\"\n        self.file_path = file_path\n\n    def read_file_as_json(self):\n        \"\"\"\n        Read the self.file_path file as json format.\n        Raises a JSONDecodeError if the file content doesn't conform to JSON format.\n        :return: dict if the file is stored as json format, or str/int/float according to the file content otherwise.\n        \"\"\"\n        with open(self.file_path, 'r') as file:\n            content = file.read()\n            return json.loads(content)\n\n    def read_file(self):\n        \"\"\"\n        Read and return the content of self.file_path file.\n        :return: str - content of the file.\n        \"\"\"\n        with open(self.file_path, 'r') as file:\n            return file.read()\n\n    def write_file(self, content):\n        \"\"\"\n        Write content into the self.file_path file, overwriting if the file already exists.\n        :param content: str - content to write to the file.\n        \"\"\"\n        with open(self.file_path, 'w') as file:\n            file.write(content)\n\n    def process_file(self):\n        \"\"\"\n        Read the self.file_path file and filter out non-alphabetic characters from the content string.\n        Overwrite the processed data into the same self.file_path file.\n        :return: str - processed content with only alphabetic characters.\n        \"\"\"\n        content = self.read_file()\n        processed_content = ''.join(re.findall(r'[A-Za-z]', content))\n        self.write_file(processed_content)\n        return processed_content\n\n    def __del__(self):\n        \"\"\"\n        Cleanup any resources if necessary, such as closing file handles.\n        \"\"\"\n        pass  # No explicit resources to clean up; files are handled in context managers.\n```",
    "80": "```python\nclass SQLQueryBuilder:\n    \"\"\"\n    This class provides to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements. \n    \"\"\"\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in database.\n        :param columns: list of str, ['col1', 'col2'] or str.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return query: str, the SQL query statement.\n        \"\"\"\n        if isinstance(columns, list):\n            columns_str = \", \".join(columns)\n        else:\n            columns_str = columns\n        \n        query = f\"SELECT {columns_str} FROM {table}\"\n        \n        if where:\n            conditions = \" AND \".join([f\"{key}='{value}'\" for key, value in where.items()])\n            query += f\" WHERE {conditions}\"\n        \n        return query\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to be inserted in database.\n        :param data: dict, the key and value in SQL insert statement\n        :return query: str, the SQL insert statement.\n        \"\"\"\n        columns = \", \".join(data.keys())\n        values = \", \".join([f\"'{value}'\" for value in data.values()])\n        return f\"INSERT INTO {table} ({columns}) VALUES ({values})\"\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table that will be executed with DELETE operation in database.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return query: str, the SQL delete statement.\n        \"\"\"\n        query = f\"DELETE FROM {table}\"\n        \n        if where:\n            conditions = \" AND \".join([f\"{key}='{value}'\" for key, value in where.items()])\n            query += f\" WHERE {conditions}\"\n        \n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table that will be executed with UPDATE operation in database.\n        :param data: dict, the key and value in SQL update statement.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return query: str, the SQL update statement.\n        \"\"\"\n        set_clause = \", \".join([f\"{key}='{value}'\" for key, value in data.items()])\n        query = f\"UPDATE {table} SET {set_clause}\"\n        \n        if where:\n            conditions = \" AND \".join([f\"{key}='{value}'\" for key, value in where.items()])\n            query += f\" WHERE {conditions}\"\n        \n        return query\n```",
    "71": "```python\nclass PushBoxGame:\n    \"\"\"\n    This class implements a functionality of a sokoban game, where the player needs to move boxes to designated targets in order to win.\n    \"\"\"\n\n    def __init__(self, game_map):\n        \"\"\"\n        Initialize the push box game with the map and various attributes.\n        :param game_map: list[str], the map of the push box game, represented as a list of strings. \n            Each character on the map represents a different element, including the following:\n            - '#' represents a wall that neither the player nor the box can pass through;\n            - 'O' represents the initial position of the player;\n            - 'G' represents the target position;\n            - 'X' represents the initial position of the box.\n        >>> map = [\"#####\", \"#O  #\", \"# X #\", \"#  G#\", \"#####\"]   \n        >>> game = PushBoxGame(map)                \n        \"\"\"\n        self.map = game_map\n        self.player_row, self.player_col = self._find_player()\n        self.targets = self._find_targets()\n        self.boxes = self._find_boxes()\n        self.target_count = len(self.targets)\n        self.is_game_over = False\n\n    def _find_player(self):\n        for r, row in enumerate(self.map):\n            for c, char in enumerate(row):\n                if char == 'O':\n                    return r, c\n        return None, None\n\n    def _find_targets(self):\n        return [(r, c) for r, row in enumerate(self.map) for c, char in enumerate(row) if char == 'G']\n\n    def _find_boxes(self):\n        return [(r, c) for r, row in enumerate(self.map) for c, char in enumerate(row) if char == 'X']\n\n    def check_win(self):\n        \"\"\"\n        Check if the game is won. The game is won when all the boxes are placed on target positions.\n        And update the value of self.is_game_over.\n        :return: True if all the boxes are placed on target positions, or False otherwise.\n        >>> game = PushBoxGame([\"#####\", \"#O  #\", \"# X #\", \"#  G#\", \"#####\"]) \n        >>> game.check_win()\n        False\n        \"\"\"\n        self.is_game_over = all(box in self.targets for box in self.boxes)\n        return self.is_game_over\n\n    def move(self, direction):\n        \"\"\"\n        Move the player based on the specified direction and check if the game is won.\n        :param direction: str, the direction of the player's movement. \n            It can be 'w', 's', 'a', or 'd' representing up, down, left, or right respectively.\n\n        :return: True if the game is won, False otherwise.\n        >>> game = PushBoxGame([\"#####\", \"#O  #\", \"# X #\", \"#  G#\", \"#####\"])       \n        >>> game.print_map()\n        # # # # # \n        # O     #\n        #   X   #\n        #     G #\n        # # # # #\n        >>> game.move('d')\n        False\n        >>> game.move('s')   \n        False\n        >>> game.move('a')   \n        False\n        >>> game.move('s') \n        False\n        >>> game.move('d') \n        True\n        \"\"\"\n        moves = {\n            'w': (-1, 0),\n            's': (1, 0),\n            'a': (0, -1),\n            'd': (0, 1)\n        }\n\n        if direction in moves:\n            dr, dc = moves[direction]\n            new_player_row = self.player_row + dr\n            new_player_col = self.player_col + dc\n            \n            if self._is_valid_move(new_player_row, new_player_col):\n                if (new_player_row, new_player_col) in self.boxes:\n                    new_box_row = new_player_row + dr\n                    new_box_col = new_player_col + dc\n                    if self._is_valid_move(new_box_row, new_box_col) and (new_box_row, new_box_col) not in self.boxes:\n                        self.boxes.remove((new_player_row, new_player_col))\n                        self.boxes.append((new_box_row, new_box_col))\n                self.player_row, self.player_col = new_player_row, new_player_col\n\n        return self.check_win()\n\n    def _is_valid_move(self, row, col):\n        return 0 <= row < len(self.map) and 0 <= col < len(self.map[0]) and self.map[row][col] != '#'\n\n    def print_map(self):\n        for r in range(len(self.map)):\n            row = list(self.map[r])\n            if (r, self.player_col) == (self.player_row, self.player_col):\n                row[self.player_col] = 'O'\n            for box in self.boxes:\n                if box[0] == r:\n                    row[box[1]] = 'X'\n            print(\"\".join(row))\n```",
    "65": "```python\nclass NumberWordFormatter:\n    \"\"\"\n    This is a class that provides to convert numbers into their corresponding English word representation, \n    including handling the conversion of both the integer and decimal parts, and incorporating appropriate connectors and units.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize NumberWordFormatter object.\n        \"\"\"\n        self.NUMBER = [\"\", \"ONE\", \"TWO\", \"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\"]\n        self.NUMBER_TEEN = [\"TEN\", \"ELEVEN\", \"TWELVE\", \"THIRTEEN\", \"FOURTEEN\", \"FIFTEEN\", \"SIXTEEN\", \"SEVENTEEN\",\n                            \"EIGHTEEN\", \"NINETEEN\"]\n        self.NUMBER_TEN = [\"TEN\", \"TWENTY\", \"THIRTY\", \"FORTY\", \"FIFTY\", \"SIXTY\", \"SEVENTY\", \"EIGHTY\", \"NINETY\"]\n        self.NUMBER_MORE = [\"\", \"THOUSAND\", \"MILLION\", \"BILLION\"]\n\n    def format(self, x):\n        \"\"\"\n        Converts a number into words format\n        :param x: int or float, the number to be converted into words format\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.format(123456)\n        \"ONE HUNDRED AND TWENTY THREE THOUSAND FOUR HUNDRED AND FIFTY SIX ONLY\"\n        \"\"\"\n        if x is None:\n            return \"\"\n        if isinstance(x, float):\n            integer_part = int(x)\n            decimal_part = round((x - integer_part) * 100)\n            return f\"{self.format_integer(integer_part)} AND CENTS {self.trans_two(str(decimal_part).zfill(2))} ONLY\"\n        return f\"{self.format_integer(int(x))} ONLY\"\n\n    def format_string(self, x):\n        \"\"\"\n        Converts a string representation of a number into words format\n        :param x: str, the string representation of a number\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.format_string(\"123456\")\n        \"ONE HUNDRED AND TWENTY THREE THOUSAND FOUR HUNDRED AND FIFTY SIX ONLY\"\n        \"\"\"\n        try:\n            return self.format(float(x))\n        except ValueError:\n            return \"\"\n\n    def trans_two(self, s):\n        \"\"\"\n        Converts a two-digit number into words format\n        :param s: str, the two-digit number\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.trans_two(\"23\")\n        \"TWENTY THREE\"\n        \"\"\"\n        num = int(s)\n        if 10 <= num < 20:\n            return self.NUMBER_TEEN[num - 10]\n        elif num >= 20:\n            return self.NUMBER_TEN[num // 10 - 1] + (f\" {self.NUMBER[num % 10]}\" if num % 10 != 0 else \"\")\n        return self.NUMBER[num]\n\n    def trans_three(self, s):\n        \"\"\"\n        Converts a three-digit number into words format\n        :param s: str, the three-digit number\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.trans_three(\"123\")\n        \"ONE HUNDRED AND TWENTY THREE\"\n        \"\"\"\n        num = int(s)\n        if num == 0:\n            return \"\"\n        elif num < 100:\n            return self.trans_two(s)\n        else:\n            return self.NUMBER[num // 100] + \" HUNDRED\" + (f\" AND {self.trans_two(str(num % 100).zfill(2))}\" if num % 100 != 0 else \"\")\n\n    def parse_more(self, i):\n        \"\"\"\n        Parses the thousand/million/billion suffix based on the index\n        :param i: int, the index representing the magnitude (thousand, million, billion)\n        :return: str, the corresponding suffix for the magnitude\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.parse_more(1)\n        \"THOUSAND\"\n        \"\"\"\n        return self.NUMBER_MORE[i]\n    \n    def format_integer(self, num):\n        \"\"\"\n        Converts an integer number into words format by breaking it down into chunks\n        :param num: int, the integer number\n        :return: str, the number in words format\n        \"\"\"\n        if num == 0:\n            return \"ZERO\"\n        \n        parts = []\n        chunk_index = 0\n        \n        while num > 0:\n            chunk = num % 1000\n            if chunk > 0:\n                prefix = self.trans_three(str(chunk).zfill(3))\n                if chunk_index > 0:\n                    prefix += f\" {self.parse_more(chunk_index)}\"\n                parts.append(prefix)\n            num //= 1000\n            chunk_index += 1\n            \n        return ' AND '.join(reversed(parts))\n```",
    "89": "```python\nimport random\n\nclass TwentyFourPointGame:\n    \"\"\"\n    This is a game of twenty-four points, which generates four numbers and checks whether the player's expression equals 24.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.nums = self._generate_cards()\n\n    def _generate_cards(self):\n        \"\"\"\n        Generate random numbers between 1 and 9 for the cards.\n        \"\"\"\n        return [random.randint(1, 9) for _ in range(4)]\n\n    def get_my_cards(self):\n        \"\"\"\n        Get a list of four random numbers between 1 and 9 representing the player's cards.\n        :return: list of integers, representing the player's cards\n        >>> game = TwentyFourPointGame()\n        >>> game.get_my_cards()\n        [2, 3, 5, 7]  # Example output\n        \"\"\"\n        return self.nums\n\n    def answer(self, expression: str) -> bool:\n        \"\"\"\n        Check if a given mathematical expression using the cards can evaluate to 24.\n        :param expression: string, mathematical expression using the cards\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        >>> game = TwentyFourPointGame()\n        >>> game.nums = [4, 3, 6, 6]\n        >>> ans = \"4*3+6+6\"\n        >>> ret = game.answer(ans)\n        True\n        \"\"\"\n        return self.evaluate_expression(expression)\n\n    def evaluate_expression(self, expression: str) -> bool:\n        \"\"\"\n        Evaluate a mathematical expression and check if the result is 24.\n        :param expression: string, mathematical expression\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        >>> game = TwentyFourPointGame()\n        >>> nums = [4, 3, 6, 6]\n        >>> ans = \"4*3+6+6\"\n        >>> ret = game.evaluate_expression(ans)\n        True\n        \"\"\"\n        try:\n            # Check if the expression uses only the allowed numbers\n            allowed_numbers = set(map(str, self.nums))\n            if not all(char in allowed_numbers or char in \"+-*/()\" for char in expression if not char.isdigit()):\n                return False\n            \n            # Evaluate the expression and check if it equals 24\n            return eval(expression) == 24\n        except (SyntaxError, NameError, ZeroDivisionError):\n            return False\n```",
    "79": "```python\nclass SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        fields = fields or ['*']\n        if isinstance(fields, list):\n            fields = ', '.join(fields)\n        query = f\"SELECT {fields} FROM {self.table_name}\"\n        if condition:\n            query += f\" WHERE {condition}\"\n        query += \";\"\n        return query\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        fields = ', '.join(data.keys())\n        values = ', '.join([f\"'{v}'\" for v in data.values()])\n        return f\"INSERT INTO {self.table_name} ({fields}) VALUES ({values});\"\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and values are new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        set_clause = ', '.join([f\"{k} = '{v}'\" for k, v in data.items()])\n        return f\"UPDATE {self.table_name} SET {set_clause} WHERE {condition};\"\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        return f\"DELETE FROM {self.table_name} WHERE {condition};\"\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        return f\"SELECT * FROM {self.table_name} WHERE age < {age} AND gender = 'female';\"\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        return f\"SELECT * FROM {self.table_name} WHERE age BETWEEN {min_age} AND {max_age};\"\n```",
    "86": "```python\nclass TicTacToe:\n    \"\"\"\n    The class represents a game of Tic-Tac-Toe and its functions include making a move on the board, checking for a winner, and determining if the board is full.\n    \"\"\"\n\n    def __init__(self, N=3):\n        \"\"\"\n        Initialize a NxN game board with all empty spaces and current symbol player, default is 'X'.\n        \"\"\"\n        self.N = N\n        self.board = [[' ' for _ in range(N)] for _ in range(N)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Place the current player's mark at the specified position on the board and switch the mark.\n        :param row: int, the row index of the position\n        :param col: int, the column index of the position\n        :return: bool, indicating whether the move was successful or not\n        \"\"\"\n        if 0 <= row < self.N and 0 <= col < self.N and self.board[row][col] == ' ':\n            self.board[row][col] = self.current_player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        return False\n\n    def check_winner(self):\n        \"\"\"\n        Check if there is a winner on the board in rows, columns and diagonals.\n        :return: str or None, the mark of the winner ('X' or 'O'), or None if there is no winner yet\n        \"\"\"\n        # Check rows\n        for row in self.board:\n            if row.count(row[0]) == self.N and row[0] != ' ':\n                return row[0]\n        \n        # Check columns\n        for col in range(self.N):\n            if all(self.board[row][col] == self.board[0][col] for row in range(self.N)) and self.board[0][col] != ' ':\n                return self.board[0][col]\n        \n        # Check diagonals\n        if all(self.board[i][i] == self.board[0][0] for i in range(self.N)) and self.board[0][0] != ' ':\n            return self.board[0][0]\n        if all(self.board[i][self.N-1-i] == self.board[0][self.N-1] for i in range(self.N)) and self.board[0][self.N-1] != ' ':\n            return self.board[0][self.N-1]\n\n        return None\n\n    def is_board_full(self):\n        \"\"\"\n        Check if the game board is completely filled.\n        :return: bool, indicating whether the game board is full or not\n        \"\"\"\n        return all(cell != ' ' for row in self.board for cell in row)\n```",
    "72": "```python\nimport re\n\nclass RegexUtils:\n    \"\"\"\n    The class provides methods to match, find all occurrences, split, and substitute text using regular expressions.\n    It also includes predefined patterns for validating phone numbers and extracting email addresses.\n    \"\"\"\n\n    def match(self, pattern, text):\n        \"\"\"\n        Check if the text matches the regular expression.\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to match\n        :return: bool, True if the text matches the pattern, False otherwise\n        \"\"\"\n        return re.fullmatch(pattern, text) is not None\n\n    def findall(self, pattern, text):\n        \"\"\"\n        Find all matching substrings and return a list of all matching substrings.\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to match\n        :return: list of string, List of all matching substrings\n        \"\"\"\n        return re.findall(pattern, text)\n\n    def split(self, pattern, text):\n        \"\"\"\n        Split text based on regular expression patterns and return a list of substrings.\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to be split\n        :return: list of string, List of substrings after splitting\n        \"\"\"\n        return re.split(pattern, text)\n\n    def sub(self, pattern, replacement, text):\n        \"\"\"\n        Replace the substring matched by a regular expression with the specified string.\n        :param pattern: string, Regular expression pattern\n        :param replacement: string, Text to replace with\n        :param text: string, Text to be replaced\n        :return: string, Text after replacement\n        \"\"\"\n        return re.sub(pattern, replacement, text)\n\n    def generate_email_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match email addresses.\n        :return: string, Regular expression patterns that match email addresses\n        \"\"\"\n        return r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n\n    def generate_phone_number_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match phone numbers.\n        :return: string, Regular expression patterns that match phone numbers\n        \"\"\"\n        return r'\\b\\d{3}-\\d{3}-\\d{4}\\b'\n\n    def generate_split_sentences_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match the middle characters of two sentences.\n        :return: string, Regular expression patterns that match the middle characters of two sentences\n        \"\"\"\n        return r'[.!?][\\s]+(?=[A-Z])'\n\n    def split_sentences(self, text):\n        \"\"\"\n        Split the text into a list of sentences.\n        :param text: Text to be split\n        :return: list of string, Split Text List\n        \"\"\"\n        return re.split(r'(?<=[.!?]) +', text)\n\n    def validate_phone_number(self, phone_number):\n        \"\"\"\n        Verify if the phone number is valid.\n        :param phone_number: Phone number to be verified\n        :return: bool, True if the phone number is valid, False otherwise\n        \"\"\"\n        return self.match(self.generate_phone_number_pattern(), phone_number)\n\n    def extract_email(self, text):\n        \"\"\"\n        Extract all email addresses from the text.\n        :param text: string, input text\n        :return: list of string, All extracted email addresses\n        \"\"\"\n        return self.findall(self.generate_email_pattern(), text)\n```",
    "90": "```python\nfrom urllib.parse import urlparse, parse_qs\n\nclass URLHandler:\n    \"\"\"\n    The class supports handling URLs, including extracting the scheme, host, path, query parameters, and fragment.\n    \"\"\"\n\n    def __init__(self, url):\n        \"\"\"\n        Initialize URLHandler with a URL.\n        :param url: str, the URL to be parsed\n        \"\"\"\n        self.url = url\n        self.parsed_url = urlparse(url)\n\n    def get_scheme(self):\n        \"\"\"\n        Get the scheme of the URL.\n        :return: str or None, the scheme of the URL or None if not present.\n        \"\"\"\n        return self.parsed_url.scheme or None\n\n    def get_host(self):\n        \"\"\"\n        Get the host domain name of the URL.\n        :return: str or None, the host domain name or None if not present.\n        \"\"\"\n        return self.parsed_url.hostname or None\n\n    def get_path(self):\n        \"\"\"\n        Get the resource path of the URL, including query and fragment.\n        :return: str or None, the resource path or None if not present.\n        \"\"\"\n        path = self.parsed_url.path\n        query = f'?{self.parsed_url.query}' if self.parsed_url.query else ''\n        fragment = f'#{self.parsed_url.fragment}' if self.parsed_url.fragment else ''\n        return path + query + fragment if path or query or fragment else None\n\n    def get_query_params(self):\n        \"\"\"\n        Get the query parameters of the URL as a dictionary.\n        :return: dict or None, the query parameters or None if not present.\n        \"\"\"\n        return {k: v[0] for k, v in parse_qs(self.parsed_url.query).items()} if self.parsed_url.query else None\n\n    def get_fragment(self):\n        \"\"\"\n        Get the fragment of the URL.\n        :return: str or None, the fragment or None if not present.\n        \"\"\"\n        return self.parsed_url.fragment or None\n```",
    "52": "```python\nimport nltk\nfrom nltk.stem import WordNetLemmatizer\nfrom nltk import pos_tag, word_tokenize\nimport string\n\nnltk.download('averaged_perceptron_tagger')\nnltk.download('punkt')\nnltk.download('wordnet')\n\nclass Lemmatization:\n    \"\"\"\n    This is a class about Lemmatization, which utilizes the nltk library to perform lemmatization and part-of-speech tagging on sentences, as well as remove punctuation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Creates a WordNetLemmatizer object and stores it in the self.lemmatizer member variable.\n        \"\"\"\n        self.lemmatizer = WordNetLemmatizer()\n\n    def lemmatize_sentence(self, sentence):\n        \"\"\"\n        Remove punctuations of the sentence and tokenizes the input sentence, mark the part of speech tag of each word,\n        lemmatizes the words with different parameters based on their parts of speech, and stores in a list.\n        :param sentence: a sentence str\n        :return: a list of words which have been lemmatized.\n        \"\"\"\n        sentence = self.remove_punctuation(sentence)\n        tokens = word_tokenize(sentence)\n        pos_tags = self.get_pos_tag(sentence)\n        lemmatized_words = []\n\n        for token, pos in zip(tokens, pos_tags):\n            if pos.startswith('VB'):\n                lemmatized_words.append(self.lemmatizer.lemmatize(token, pos='v'))\n            elif pos.startswith('NN'):\n                lemmatized_words.append(self.lemmatizer.lemmatize(token, pos='n'))\n            elif pos.startswith('JJ'):\n                lemmatized_words.append(self.lemmatizer.lemmatize(token, pos='a'))\n            else:\n                lemmatized_words.append(token)\n\n        return lemmatized_words\n\n    def get_pos_tag(self, sentence):\n        \"\"\"\n        Tokenizes the input sentence and marks the part of speech tag of each word.\n        :param sentence: a sentence str\n        :return: list, part of speech tag of each word in the sentence.\n        \"\"\"\n        sentence = self.remove_punctuation(sentence)\n        tokens = word_tokenize(sentence)\n        return [tag for word, tag in pos_tag(tokens)]\n\n    def remove_punctuation(self, sentence):\n        \"\"\"\n        Removes punctuation from the input text.\n        :param sentence: a sentence str\n        :return: str, sentence without any punctuation\n        \"\"\"\n        return sentence.translate(str.maketrans('', '', string.punctuation))\n\n\n# Test cases\nimport unittest\n\nclass LemmatizationTestLemmatizeSentence(unittest.TestCase):\n    def test_lemmatize_sentence_1(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.lemmatize_sentence(\"I am running in a race.\")\n        expected = ['I', 'be', 'run', 'in', 'a', 'race']\n        self.assertEqual(result, expected)\n\n    def test_lemmatize_sentence_2(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.lemmatize_sentence(\"Until the beating, Cantanco's eyesight had been weak, but adequate.\")\n        expected = ['Until', 'the', 'beating', 'Cantancos', 'eyesight', 'have', 'be', 'weak', 'but', 'adequate']\n        self.assertEqual(result, expected)\n\n    def test_lemmatize_sentence_3(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.lemmatize_sentence(\"The dog's barked at the mailman.\")\n        expected = ['The', 'dog', 'bark', 'at', 'the', 'mailman']\n        self.assertEqual(result, expected)\n\n    def test_lemmatize_sentence_4(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.lemmatize_sentence(\"He was running and eating at same time.\")\n        expected = ['He', 'be', 'run', 'and', 'eat', 'at', 'same', 'time']\n        self.assertEqual(result, expected)\n\n    def test_lemmatize_sentence_5(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.lemmatize_sentence(\"I was taking a ride in the car.\")\n        expected = ['I', 'be', 'take', 'a', 'ride', 'in', 'the', 'car']\n        self.assertEqual(result, expected)\n\nclass LemmatizationTestGetPosTag(unittest.TestCase):\n    def test_get_pos_tag_1(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.get_pos_tag(\"I am running in a race.\")\n        expected = ['PRP', 'VBP', 'VBG', 'IN', 'DT', 'NN']\n        self.assertEqual(result, expected)\n\n    def test_get_pos_tag_2(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.get_pos_tag(\"Cantanco's eyesight had been weak, but adequate.\")\n        expected = ['NNP', 'NN', 'VBD', 'VBN', 'JJ', 'CC', 'JJ']\n        self.assertEqual(result, expected)\n\n    def test_get_pos_tag_3(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.get_pos_tag(\"The dog's barked at the mailman.\")\n        expected = ['DT', 'NNS', 'VBD', 'IN', 'DT', 'NN']\n        self.assertEqual(result, expected)\n\n    def test_get_pos_tag_4(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.get_pos_tag(\"He was running and eating at same time.\")\n        expected = ['PRP', 'VBD', 'VBG', 'CC', 'VBG', 'IN', 'JJ', 'NN']\n        self.assertEqual(result, expected)\n\n    def test_get_pos_tag_5(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.get_pos_tag(\"I was taking a ride in the car.\")\n        expected = ['PRP', 'VBD', 'VBG', 'DT', 'NN', 'IN', 'DT', 'NN']\n        self.assertEqual(result, expected)\n\nclass LemmatizationTestRemovePunctuation(unittest.TestCase):\n    def test_remove_punctuation_1(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.remove_punctuation(\"I am running in a race.\")\n        expected = \"I am running in a race\"\n        self.assertEqual(result, expected)\n\n    def test_remove_punctuation_2(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.remove_punctuation(\"Until the beating, Cantanco's eyesight had been weak, but adequate.\")\n        expected = 'Until the beating Cantancos eyesight had been weak but adequate'\n        self.assertEqual(result, expected)\n\n    def test_remove_punctuation_3(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.remove_punctuation(\"The dog's barked at the mailman!!!\")\n        expected = 'The dogs barked at the mailman'\n        self.assertEqual(result, expected)\n\n    def test_remove_punctuation_4(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.remove_punctuation(\"He was running and eating at same time... \")\n        expected = 'He was running and eating at same time '\n        self.assertEqual(result, expected)\n\n    def test_remove_punctuation_5(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.remove_punctuation(\"Is this a test? I hope it is...\")\n        expected = 'Is this a test I hope it is'\n        self.assertEqual(result, expected)\n\nif __name__ == \"__main__\":\n    unittest.main()\n```",
    "88": "```python\nfrom math import pi, factorial as math_factorial, fabs\n\nclass TriCalculator:\n    \"\"\"\n    The class allows to calculate trigonometric values, including cosine, sine, and tangent, using Taylor series approximations.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def cos(self, x):\n        \"\"\"\n        Calculate the cos value of the x-degree angle\n        :param x: float\n        :return: float\n        \"\"\"\n        return self.taylor(x, 50)  # 50 terms for approximation\n\n    def factorial(self, a):\n        \"\"\"\n        Calculate the factorial of a\n        :param a: int\n        :return: int\n        \"\"\"\n        if a < 0:\n            raise ValueError(\"Factorial is not defined for negative numbers\")\n        return 1 if a == 0 else math_factorial(a)\n\n    def taylor(self, x, n):\n        \"\"\"\n        Finding the n-order Taylor expansion value of cos (x/180 * pi)\n        :param x: int\n        :param n: int\n        :return: float\n        \"\"\"\n        x_rad = x * (pi / 180)  # Convert degrees to radians\n        cos_value = 0.0\n        for i in range(n):\n            term = ((-1) ** i) * (x_rad ** (2 * i)) / self.factorial(2 * i)\n            cos_value += term\n        return cos_value\n\n    def sin(self, x):\n        \"\"\"\n        Calculate the sin value of the x-degree angle\n        :param x: float\n        :return: float\n        \"\"\"\n        return self.taylor_sine(x, 50)  # 50 terms for approximation\n\n    def taylor_sine(self, x, n):\n        \"\"\"\n        Finding the n-order Taylor expansion value of sin (x/180 * pi)\n        :param x: int\n        :param n: int\n        :return: float\n        \"\"\"\n        x_rad = x * (pi / 180)  # Convert degrees to radians\n        sin_value = 0.0\n        for i in range(n):\n            term = ((-1) ** i) * (x_rad ** (2 * i + 1)) / self.factorial(2 * i + 1)\n            sin_value += term\n        return sin_value\n\n    def tan(self, x):\n        \"\"\"\n        Calculate the tan value of the x-degree angle\n        :param x: float\n        :return: float\n        \"\"\"\n        sin_value = self.sin(x)\n        cos_value = self.cos(x)\n        if fabs(cos_value) < 1e-10:  # Check for division by zero\n            return False\n        return sin_value / cos_value\n```",
    "91": "```python\nimport urllib.parse\n\nclass UrlPath:\n    \"\"\"\n    A utility for encapsulating and manipulating the path component of a URL,\n    including adding nodes, parsing path strings, and building path strings with optional encoding.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the UrlPath object with an empty list of segments and a flag indicating the presence of an end tag.\n        \"\"\"\n        self.segments = []\n        self.with_end_tag = False\n\n    def add(self, segment):\n        \"\"\"\n        Adds a segment to the list of segments in the UrlPath.\n        :param segment: str, the segment to add.\n        \"\"\"\n        if isinstance(segment, str):\n            self.segments.append(segment)\n\n    def parse(self, path, charset='utf-8'):\n        \"\"\"\n        Parses a given path string and populates the list of segments in the UrlPath.\n        :param path: str, the path string to parse.\n        :param charset: str, the character encoding of the path string (default is 'utf-8').\n        \"\"\"\n        fixed_path = self.fix_path(path)\n        self.segments = fixed_path.split('/') if fixed_path else []\n        self.with_end_tag = path.endswith('/')\n\n    @staticmethod\n    def fix_path(path):\n        \"\"\"\n        Fixes the given path string by removing leading and trailing slashes.\n        :param path: str, the path string to fix.\n        :return: str, the fixed path string.\n        \"\"\"\n        return path.strip('/')\n\n\nimport unittest\n\nclass UrlPathTestAdd(unittest.TestCase):\n    def test_add_1(self):\n        url_path = UrlPath()\n        url_path.add('foo')\n        url_path.add('bar')\n        self.assertEqual(url_path.segments, ['foo', 'bar'])\n\n    def test_add_2(self):\n        url_path = UrlPath()\n        url_path.add('aaa')\n        url_path.add('bbb')\n        self.assertEqual(url_path.segments, ['aaa', 'bbb'])\n\n    def test_add_3(self):\n        url_path = UrlPath()\n        url_path.add('123')\n        self.assertEqual(url_path.segments, ['123'])\n\n    def test_add_4(self):\n        url_path = UrlPath()\n        url_path.add('ddd')\n        self.assertEqual(url_path.segments, ['ddd'])\n\n    def test_add_5(self):\n        url_path = UrlPath()\n        url_path.add('eee')\n        self.assertEqual(url_path.segments, ['eee'])\n\n\nclass UrlPathTestParse(unittest.TestCase):\n    def test_parse_1(self):\n        url_path = UrlPath()\n        url_path.parse('/foo/bar/', 'utf-8')\n        self.assertEqual(url_path.segments, ['foo', 'bar'])\n        self.assertEqual(url_path.with_end_tag, True)\n\n    def test_parse_2(self):\n        url_path = UrlPath()\n        url_path.parse('aaa/bbb', 'utf-8')\n        self.assertEqual(url_path.segments, ['aaa', 'bbb'])\n        self.assertEqual(url_path.with_end_tag, False)\n\n    def test_parse_3(self):\n        url_path = UrlPath()\n        url_path.parse('/123/456/', 'utf-8')\n        self.assertEqual(url_path.segments, ['123', '456'])\n        self.assertEqual(url_path.with_end_tag, True)\n\n    def test_parse_4(self):\n        url_path = UrlPath()\n        url_path.parse('/123/456/789', 'utf-8')\n        self.assertEqual(url_path.segments, ['123', '456', '789'])\n        self.assertEqual(url_path.with_end_tag, False)\n\n    def test_parse_5(self):\n        url_path = UrlPath()\n        url_path.parse('/foo/bar', 'utf-8')\n        self.assertEqual(url_path.segments, ['foo', 'bar'])\n        self.assertEqual(url_path.with_end_tag, False)\n\n    def test_parse_6(self):\n        url_path = UrlPath()\n        url_path.parse('', 'utf-8')\n        self.assertEqual(url_path.segments, [])\n        self.assertEqual(url_path.with_end_tag, False)\n\n    def test_parse_7(self):\n        url_path = UrlPath()\n        url_path.parse('//', 'utf-8')\n        self.assertEqual(url_path.segments, [])\n        self.assertEqual(url_path.with_end_tag, True)\n\n\nclass UrlPathTestFixPath(unittest.TestCase):\n    def test_fix_path_1(self):\n        fixed_path = UrlPath.fix_path('/foo/bar/')\n        self.assertEqual(fixed_path, 'foo/bar')\n\n    def test_fix_path_2(self):\n        fixed_path = UrlPath.fix_path('/aaa/bbb/')\n        self.assertEqual(fixed_path, 'aaa/bbb')\n\n    def test_fix_path_3(self):\n        fixed_path = UrlPath.fix_path('/a/b/')\n        self.assertEqual(fixed_path, 'a/b')\n\n    def test_fix_path_4(self):\n        fixed_path = UrlPath.fix_path('/111/222/')\n        self.assertEqual(fixed_path, '111/222')\n\n    def test_fix_path_5(self):\n        fixed_path = UrlPath.fix_path('/a/')\n        self.assertEqual(fixed_path, 'a')\n\n    def test_fix_path_6(self):\n        fixed_path = UrlPath.fix_path('')\n        self.assertEqual(fixed_path, '')\n\n\nclass UrlPathTest(unittest.TestCase):\n    def test_urlpath(self):\n        url_path = UrlPath()\n        url_path.add('foo')\n        url_path.add('bar')\n        self.assertEqual(url_path.segments, ['foo', 'bar'])\n\n        url_path = UrlPath()\n        url_path.parse('/foo/bar/', 'utf-8')\n        self.assertEqual(url_path.segments, ['foo', 'bar'])\n        self.assertEqual(url_path.with_end_tag, True)\n\n        fixed_path = UrlPath.fix_path('/foo/bar/')\n        self.assertEqual(fixed_path, 'foo/bar')\n```",
    "97": "```python\nclass Words2Numbers:\n    \"\"\"\n    The class provides a text-to-number conversion utility, allowing conversion of written numbers (in words) to their numerical representation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the word lists and dictionaries required for conversion\n        \"\"\"\n        self.numwords = {}\n        self.units = [\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\n            \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n            \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\",\n        ]\n        self.tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        self.scales = [\"hundred\", \"thousand\", \"million\", \"billion\", \"trillion\"]\n\n        self.numwords[\"and\"] = (1, 0)\n        for idx, word in enumerate(self.units):\n            self.numwords[word] = (1, idx)\n        for idx, word in enumerate(self.tens):\n            self.numwords[word] = (1, idx * 10)\n        for idx, word in enumerate(self.scales):\n            self.numwords[word] = (10 ** (idx * 3), 0)\n\n        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}\n        self.ordinal_endings = [('ieth', 'y'), ('th', '')]\n\n    def text2int(self, textnum):\n        \"\"\"\n        Convert the word string to the corresponding integer string\n        :param textnum: string, the word string to be converted\n        :return: string, the final converted integer string\n        \"\"\"\n        textnum = textnum.replace(\"-\", \" \")\n        parts = textnum.split()\n        current = result = 0\n\n        for part in parts:\n            if part in self.numwords:\n                scale, increment = self.numwords[part]\n                current += increment\n                if scale > 1:\n                    current *= scale\n                    result += current\n                    current = 0\n            else:\n                raise ValueError(f\"Invalid input: '{part}' is not a valid number word.\")\n\n        return str(result + current)\n\n    def is_valid_input(self, textnum):\n        \"\"\"\n        Check if the input text contains only valid words that can be converted into numbers.\n        :param textnum: The input text containing words representing numbers.\n        :return: True if input is valid, False otherwise.\n        \"\"\"\n        textnum = textnum.replace(\"-\", \" \")\n        parts = textnum.split()\n        \n        for part in parts:\n            if part not in self.numwords:\n                return False\n        return True\n```",
    "93": "```python\nimport numpy as np\n\nclass VectorUtil:\n    \"\"\"\n    The class provides vector operations, including calculating similarity, cosine similarities, average similarity, and IDF weights.\n    \"\"\"\n\n    @staticmethod\n    def similarity(vector_1, vector_2):\n        \"\"\"\n        Compute the cosine similarity between one vector and another vector.\n        :param vector_1: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :param vector_2: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :return: float, Contains cosine distance between `vector_1` and `vector_2`\n        \"\"\"\n        norm_1 = np.linalg.norm(vector_1)\n        norm_2 = np.linalg.norm(vector_2)\n        if norm_1 == 0 or norm_2 == 0:\n            return 0.0\n        return np.dot(vector_1, vector_2) / (norm_1 * norm_2)\n\n    @staticmethod\n    def cosine_similarities(vector_1, vectors_all):\n        \"\"\"\n        Compute cosine similarities between one vector and a set of other vectors.\n        :param vector_1: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :param vectors_all: list of numpy.ndarray, For each row in vectors_all, distance from vector_1 is computed, expected shape (num_vectors, dim).\n        :return: numpy.ndarray, Contains cosine distance between `vector_1` and each row in `vectors_all`, shape (num_vectors,).\n        \"\"\"\n        return np.array([VectorUtil.similarity(vector_1, vector) for vector in vectors_all])\n\n    @staticmethod\n    def n_similarity(vector_list_1, vector_list_2):\n        \"\"\"\n        Compute cosine similarity between two sets of vectors.\n        :param vector_list_1: list of numpy vector\n        :param vector_list_2: list of numpy vector\n        :return: float, Average similarities between vector_list_1 and vector_list_2.\n        \"\"\"\n        if not vector_list_1 or not vector_list_2:\n            return 0.0\n        similarities = [VectorUtil.similarity(v1, v2) for v1 in vector_list_1 for v2 in vector_list_2]\n        return np.mean(similarities) if similarities else 0.0\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num, number_dict):\n        \"\"\"\n        Calculate log(total_num+1/count+1) for each count in number_dict\n        :param total_num: int\n        :param number_dict: dict\n        :return: dict\n        \"\"\"\n        return {key: np.log((total_num + 1) / (count + 1)) for key, count in number_dict.items()}\n```",
    "99": "```python\nimport zipfile\nimport os\n\n\nclass ZipFileProcessor:\n    \"\"\"\n    This is a compressed file processing class that provides the ability to read and decompress compressed files.\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize file name.\n        :param file_name: string\n        \"\"\"\n        self.file_name = file_name\n\n    def read_zip_file(self):\n        \"\"\"\n        Get open file object.\n        :return: If successful, returns the open file object; otherwise, returns None.\n        \"\"\"\n        if not self.file_name or not os.path.exists(self.file_name):\n            return None\n        try:\n            return zipfile.ZipFile(self.file_name, 'r')\n        except (zipfile.BadZipFile, FileNotFoundError, OSError):\n            return None\n\n    def extract_all(self, output_path):\n        \"\"\"\n        Extract all zip files and place them in the specified path.\n        :param output_path: string, The location of the extracted file.\n        :return: True or False, representing whether the extraction operation was successful.\n        \"\"\"\n        if not self.file_name or not os.path.exists(self.file_name) or not output_path:\n            return False\n\n        os.makedirs(output_path, exist_ok=True)\n\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_ref:\n                zip_ref.extractall(output_path)\n            return True\n        except (zipfile.BadZipFile, FileNotFoundError, OSError):\n            return False\n\n    def extract_file(self, file_name, output_path):\n        \"\"\"\n        Extract the file with the specified name from the zip file and place it in the specified path.\n        :param file_name: string, The name of the file to be uncompressed.\n        :param output_path: string, The location of the extracted file.\n        :return: True or False, representing whether the extraction operation was successful.\n        \"\"\"\n        if not self.file_name or not os.path.exists(self.file_name) or not file_name or not output_path:\n            return False\n\n        os.makedirs(output_path, exist_ok=True)\n\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_ref:\n                zip_ref.extract(file_name, output_path)\n            return True\n        except (zipfile.BadZipFile, FileNotFoundError, KeyError, OSError):\n            return False\n\n    def create_zip_file(self, files, output_file_name):\n        \"\"\"\n        Compress the specified file list into a zip file and place it in the specified path.\n        :param files: list of string, List of files to compress.\n        :param output_file_name: string, Specified output path.\n        :return: True or False, representing whether the compression operation was successful.\n        \"\"\"\n        if not files or not output_file_name:\n            return False\n\n        try:\n            with zipfile.ZipFile(output_file_name, 'w') as zip_ref:\n                for file in files:\n                    if os.path.exists(file):\n                        zip_ref.write(file, os.path.basename(file))\n            return True\n        except (FileNotFoundError, OSError):\n            return False\n```",
    "95": "```python\nclass Warehouse:\n    \"\"\"\n    The class manages inventory and orders, including adding products, updating product quantities, retrieving product quantities, creating orders, changing order statuses, and tracking orders.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize two fields.\n        self.inventory is a dict that stores the products.\n        self.inventory = {Product ID: Product}\n        self.orders is a dict that stores the products in an order.\n        self.orders = {Order ID: Order}\n        \"\"\"\n        self.inventory = {}  # Product ID: Product\n        self.orders = {}  # Order ID: Order\n\n    def add_product(self, product_id, name, quantity):\n        \"\"\"\n        Add product to inventory, increasing the quantity if it already exists.\n        :param product_id: int\n        :param name: str, product name\n        :param quantity: int, product quantity\n        \"\"\"\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be positive.\")\n        if product_id in self.inventory:\n            self.inventory[product_id]['quantity'] += quantity\n        else:\n            self.inventory[product_id] = {'name': name, 'quantity': quantity}\n\n    def update_product_quantity(self, product_id, quantity):\n        \"\"\"\n        Update the quantity of a product in inventory.\n        :param product_id: int\n        :param quantity: int, amount to add (can be negative)\n        \"\"\"\n        if product_id in self.inventory:\n            self.inventory[product_id]['quantity'] += quantity\n            if self.inventory[product_id]['quantity'] <= 0:\n                del self.inventory[product_id]\n        else:\n            raise KeyError(\"Product ID not found in inventory.\")\n\n    def get_product_quantity(self, product_id):\n        \"\"\"\n        Get the quantity of a specific product by product_id.\n        :param product_id: int\n        :return: int or False\n        \"\"\"\n        return self.inventory[product_id]['quantity'] if product_id in self.inventory else False\n\n    def create_order(self, order_id, product_id, quantity):\n        \"\"\"\n        Create an order which includes the information of product, like id and quantity.\n        The default value of status is 'Shipped'.\n        :param order_id: int\n        :param product_id: int\n        :param quantity: int, the quantity of product that is selected.\n        :return: False if product_id is not in inventory or the quantity is not adequate.\n        \"\"\"\n        if product_id in self.inventory and self.inventory[product_id]['quantity'] >= quantity:\n            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}\n            self.update_product_quantity(product_id, -quantity)\n        else:\n            return False\n\n    def change_order_status(self, order_id, status):\n        \"\"\"\n        Change the status of an order if the input order_id is in self.orders.\n        :param order_id: int\n        :param status: str, the state that is going to change to\n        :return: False if the order_id is not in self.orders.\n        \"\"\"\n        if order_id in self.orders:\n            self.orders[order_id]['status'] = status\n        else:\n            return False\n\n    def track_order(self, order_id):\n        \"\"\"\n        Get the status of a specific order.\n        :param order_id: int\n        :return: str or False\n        \"\"\"\n        return self.orders[order_id]['status'] if order_id in self.orders else False\n```"
}