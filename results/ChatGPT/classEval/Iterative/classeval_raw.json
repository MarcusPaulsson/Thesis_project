{
    "7": "```python\nclass BalancedBrackets:\n    \"\"\"\n    This is a class that checks for bracket matching.\n    \"\"\"\n\n    def __init__(self, expr):\n        \"\"\"\n        Initializes the class with an expression.\n        :param expr: The expression to check for balanced brackets, str.\n        \"\"\"\n        self.stack = []\n        self.bracket_map = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n        self.expr = expr\n\n    def clear_expr(self):\n        \"\"\"\n        Clears the expression of all characters that are not brackets.\n        >>> b = BalancedBrackets(\"a(b)c\")\n        >>> b.clear_expr()\n        >>> b.expr\n        '()'\n        \"\"\"\n        self.expr = ''.join(char for char in self.expr if char in self.bracket_map or char in self.bracket_map.values())\n\n    def check_balanced_brackets(self):\n        \"\"\"\n        Checks if the expression has balanced brackets.\n        :return: True if the expression has balanced brackets, False otherwise.\n        >>> b = BalancedBrackets(\"a(b)c\")\n        >>> b.check_balanced_brackets()\n        True\n        >>> b = BalancedBrackets(\"a(b{c)d}e\")\n        >>> b.check_balanced_brackets()\n        True\n        >>> b = BalancedBrackets(\"a(b[c}d)e\")\n        >>> b.check_balanced_brackets()\n        False\n        \"\"\"\n        self.clear_expr()\n        for char in self.expr:\n            if char in self.bracket_map.values():\n                self.stack.append(char)\n            elif char in self.bracket_map.keys():\n                if not self.stack or self.stack.pop() != self.bracket_map[char]:\n                    return False\n        return len(self.stack) == 0\n```",
    "6": "```python\nclass AvgPartition:\n    \"\"\"\n    This class partitions a given list into uniformly distributed blocks based on the specified number of partitions.\n    \"\"\"\n\n    def __init__(self, lst, limit):\n        \"\"\"\n        Initialize the class with the given list and number of partitions.\n        Raise ValueError if the number of partitions is less than or equal to 0.\n        \"\"\"\n        if limit <= 0:\n            raise ValueError(\"The number of partitions must be greater than 0.\")\n        \n        self.lst = lst\n        self.limit = limit\n\n    def set_num(self):\n        \"\"\"\n        Calculate the size of each block and the remainder of the division.\n        :return: tuple containing the size of each block and the remainder.\n        \n        >>> a = AvgPartition([1, 2, 3, 4], 2)\n        >>> a.set_num()\n        (2, 0)\n        \"\"\"\n        block_size = len(self.lst) // self.limit\n        remainder = len(self.lst) % self.limit\n        return block_size, remainder\n\n    def get(self, index):\n        \"\"\"\n        Retrieve the block corresponding to the given partition index.\n        :param index: index of the partition, int.\n        :return: the corresponding block, list.\n        \n        >>> a = AvgPartition([1, 2, 3, 4], 2)\n        >>> a.get(0)\n        [1, 2]\n        >>> a.get(1)\n        [3, 4]\n        \"\"\"\n        if index < 0 or index >= self.limit:\n            raise IndexError(\"Partition index out of range.\")\n        \n        block_size, remainder = self.set_num()\n        start = index * block_size + min(index, remainder)\n        end = start + block_size + (1 if index < remainder else 0)\n        return self.lst[start:end]\n```",
    "8": "```python\nclass BankAccount:\n    \"\"\"\n    A class representing a bank account system, supporting deposit, withdrawal, balance viewing, and money transfer.\n    \"\"\"\n\n    def __init__(self, balance=0):\n        \"\"\"\n        Initializes a bank account object with a specified balance (default is 0).\n        :param balance: int\n        \"\"\"\n        if balance < 0:\n            raise ValueError(\"Initial balance cannot be negative.\")\n        self.balance = balance\n\n    def deposit(self, amount):\n        \"\"\"\n        Deposits a certain amount into the account, increasing the account balance.\n        Returns the current account balance.\n        Raises ValueError for negative amounts.\n        :param amount: int\n        \"\"\"\n        if amount < 0:\n            raise ValueError(\"Invalid amount. Must be non-negative.\")\n        self.balance += amount\n        return self.balance\n\n    def withdraw(self, amount):\n        \"\"\"\n        Withdraws a certain amount from the account, decreasing the account balance.\n        Returns the current account balance.\n        Raises ValueError for negative amounts or insufficient balance.\n        :param amount: int\n        \"\"\"\n        if amount < 0:\n            raise ValueError(\"Invalid amount. Must be non-negative.\")\n        if amount > self.balance:\n            raise ValueError(\"Insufficient balance.\")\n        self.balance -= amount\n        return self.balance\n\n    def view_balance(self):\n        \"\"\"\n        Returns the current account balance.\n        \"\"\"\n        return self.balance\n\n    def transfer(self, other_account, amount):\n        \"\"\"\n        Transfers a specified amount from the current account to another account.\n        Raises ValueError for invalid transfer amounts.\n        :param other_account: BankAccount\n        :param amount: int\n        \"\"\"\n        if not isinstance(other_account, BankAccount):\n            raise ValueError(\"The recipient must be a BankAccount instance.\")\n        if amount < 0:\n            raise ValueError(\"Invalid amount. Must be non-negative.\")\n        self.withdraw(amount)\n        other_account.deposit(amount)\n```",
    "9": "```python\nclass BigNumCalculator:\n    \"\"\"\n    This class implements big number calculations, including addition, subtraction, and multiplication.\n    \"\"\"\n\n    @staticmethod\n    def add(num1: str, num2: str) -> str:\n        \"\"\"\n        Adds two big numbers.\n        :param num1: The first number to add, str.\n        :param num2: The second number to add, str.\n        :return: The sum of the two numbers, str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.add(\"12345678901234567890\", \"98765432109876543210\")\n        '111111111011111111100'\n        \"\"\"\n        return str(int(num1) + int(num2))\n\n    @staticmethod\n    def subtract(num1: str, num2: str) -> str:\n        \"\"\"\n        Subtracts two big numbers.\n        :param num1: The first number to subtract, str.\n        :param num2: The second number to subtract, str.\n        :return: The difference of the two numbers, str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.subtract(\"12345678901234567890\", \"98765432109876543210\")\n        '-86419753208641975320'\n        \"\"\"\n        return str(int(num1) - int(num2))\n\n    @staticmethod\n    def multiply(num1: str, num2: str) -> str:\n        \"\"\"\n        Multiplies two big numbers.\n        :param num1: The first number to multiply, str.\n        :param num2: The second number to multiply, str.\n        :return: The product of the two numbers, str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.multiply(\"12345678901234567890\", \"98765432109876543210\")\n        '1219326311370217952237463801111263526900'\n        \"\"\"\n        return str(int(num1) * int(num2))\n```",
    "5": "```python\nclass AutomaticGuitarSimulator:\n    def __init__(self, text: str) -> None:\n        \"\"\"\n        Initialize the score to be played\n        :param text: str, score to be played\n        \"\"\"\n        self.play_text = text.strip() if text else \"\"\n\n    def interpret(self, display: bool = False) -> list:\n        \"\"\"\n        Interpret the music score to be played\n        :param display: bool, representing whether to print the interpreted score\n        :return: list of dict, with fields 'Chord' and 'Tune'. If the input is empty, returns an empty list.\n        >>> context = AutomaticGuitarSimulator(\"C53231323 Em43231323 F43231323 G63231323\")\n        >>> play_list = context.interpret(display=False)\n        [{'Chord': 'C', 'Tune': '53231323'}, {'Chord': 'Em', 'Tune': '43231323'}, {'Chord': 'F', 'Tune': '43231323'}, {'Chord': 'G', 'Tune': '63231323'}]\n        \"\"\"\n        if not self.play_text:\n            return []\n\n        chords = self.play_text.split()\n        interpreted_score = []\n\n        for chord in chords:\n            if len(chord) > 1:\n                # Separate chord and tune\n                interpreted_score.append({'Chord': chord[:-8], 'Tune': chord[-8:]})\n\n        if display:\n            for item in interpreted_score:\n                self.display(item['Chord'], item['Tune'])\n\n        return interpreted_score\n\n    def display(self, key: str, value: str) -> None:\n        \"\"\"\n        Print out chord and play tune with following format: Normal Guitar Playing -- Chord: %s, Play Tune: %s\n        :param key: str, chord\n        :param value: str, play tune\n        \"\"\"\n        print(f\"Normal Guitar Playing -- Chord: {key}, Play Tune: {value}\")\n```",
    "0": "```python\nimport logging\nimport datetime\n\nclass AccessGatewayFilter:\n    \"\"\"\n    This class is a filter used for accessing gateway filtering, primarily for authentication and access log recording.\n    \"\"\"\n\n    def __init__(self):\n        self.allowed_paths = [\"/api\", \"/login\"]\n        logging.basicConfig(level=logging.INFO)\n\n    def filter(self, request):\n        \"\"\"\n        Filter the incoming request based on certain rules and conditions.\n        :param request: dict, the incoming request details\n        :return: bool, True if the request is allowed, False otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.filter({'path': '/login', 'method': 'POST'})\n        True\n        >>> filter.filter({'path': '/api/data', 'method': 'GET'})\n        True\n        >>> filter.filter({'path': '/other', 'method': 'GET'})\n        False\n        \"\"\"\n        method = request.get('method', '').upper()\n        path = request.get('path', '')\n\n        if method == 'POST' and path in self.allowed_paths:\n            return True\n        return self.is_start_with(path)\n\n    def is_start_with(self, request_uri):\n        \"\"\"\n        Check if the request URI starts with certain prefixes.\n        :param request_uri: str, the URI of the request\n        :return: bool, True if the URI starts with certain prefixes, False otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.is_start_with('/api/data')\n        True\n        >>> filter.is_start_with('/login/test')\n        True\n        >>> filter.is_start_with('/other/path')\n        False\n        \"\"\"\n        return any(request_uri.startswith(prefix) for prefix in self.allowed_paths)\n\n    def get_jwt_user(self, request):\n        \"\"\"\n        Get the user information from the JWT token in the request.\n        :param request: dict, the incoming request details\n        :return: dict or None, the user information if the token is valid, None otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.get_jwt_user({'headers': {'Authorization': {'user': {'name': 'user1'}, 'jwt': 'token'}}})\n        {'name': 'user1'}\n        >>> filter.get_jwt_user({'headers': {}})\n        None\n        \"\"\"\n        auth_header = request.get('headers', {}).get('Authorization', {})\n        return auth_header.get('user', None)\n\n    def set_current_user_info_and_log(self, user):\n        \"\"\"\n        Set the current user information and log the access.\n        :param user: dict, the user information\n        :return: None\n        >>> filter = AccessGatewayFilter()\n        >>> filter.set_current_user_info_and_log({'name': 'user1', 'address': '127.0.0.1'})\n        \"\"\"\n        if user and 'name' in user and 'address' in user:\n            logging.info(f\"User Access: {user['name']} from {user['address']} at {datetime.datetime.now()}\")\n        else:\n            logging.warning(\"Invalid user information provided for logging.\")\n```",
    "4": "```python\nclass AssessmentSystem:\n    \"\"\"\n    This is a class representing a student assessment system, which supports adding students, \n    adding course scores, calculating GPA, and other functions for students and courses.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the students dictionary in the assessment system.\n        \"\"\"\n        self.students = {}\n\n    def add_student(self, name, grade, major):\n        \"\"\"\n        Add a new student to the self.students dictionary.\n        \n        :param name: str, student name\n        :param grade: int, student grade\n        :param major: str, student major\n        \"\"\"\n        if name in self.students:\n            raise ValueError(f\"Student '{name}' already exists.\")\n        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}\n\n    def add_course_score(self, name, course, score):\n        \"\"\"\n        Add the score of a specific course for a student in self.students.\n        \n        :param name: str, student name\n        :param course: str, course name\n        :param score: int, course score\n        \"\"\"\n        if name not in self.students:\n            raise ValueError(f\"Student '{name}' does not exist.\")\n        if not (0 <= score <= 100):\n            raise ValueError(\"Score must be between 0 and 100.\")\n        self.students[name]['courses'][course] = score\n\n    def get_gpa(self, name):\n        \"\"\"\n        Get the average grade of one student.\n        \n        :param name: str, student name\n        :return: float or None, average grade if student has courses, otherwise None\n        \"\"\"\n        if name in self.students:\n            courses = self.students[name]['courses']\n            if courses:\n                return sum(courses.values()) / len(courses)\n        return None\n\n    def get_all_students_with_fail_course(self):\n        \"\"\"\n        Get all students who have any score below 60.\n        \n        :return: list of str, student names\n        \"\"\"\n        return [name for name, data in self.students.items() if any(score < 60 for score in data['courses'].values())]\n\n    def get_course_average(self, course):\n        \"\"\"\n        Get the average score of a specific course.\n        \n        :param course: str, course name\n        :return: float or None, average score of this course if anyone has a score, otherwise None\n        \"\"\"\n        total_score = 0\n        count = 0\n        for student in self.students.values():\n            if course in student['courses']:\n                total_score += student['courses'][course]\n                count += 1\n        return total_score / count if count > 0 else None\n\n    def get_top_student(self):\n        \"\"\"\n        Calculate every student's GPA with the get_gpa method, and find the student with the highest GPA.\n        \n        :return: str, name of the student whose GPA is highest\n        \"\"\"\n        top_student = None\n        highest_gpa = -1\n        for student in self.students:\n            gpa = self.get_gpa(student)\n            if gpa is not None and gpa > highest_gpa:\n                highest_gpa = gpa\n                top_student = student\n        return top_student\n```",
    "1": "```python\nimport math\n\nclass AreaCalculator:\n    \"\"\"\n    This class calculates the area of various shapes, including a circle, sphere, cylinder, sector, and annulus.\n    \"\"\"\n\n    def __init__(self, radius):\n        \"\"\"\n        Initialize the radius for shapes.\n        :param radius: float, the radius of the shapes\n        \"\"\"\n        if radius < 0:\n            raise ValueError(\"Radius must be a non-negative value.\")\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        \"\"\"\n        Calculate the area of a circle based on self.radius.\n        :return: area of circle, float\n        >>> area_calculator = AreaCalculator(2)\n        >>> area_calculator.calculate_circle_area()\n        12.566370614359172\n        \"\"\"\n        return math.pi * self.radius ** 2\n\n    def calculate_sphere_area(self):\n        \"\"\"\n        Calculate the surface area of a sphere based on self.radius.\n        :return: surface area of sphere, float\n        >>> area_calculator = AreaCalculator(2)\n        >>> area_calculator.calculate_sphere_area()\n        50.26548245743669\n        \"\"\"\n        return 4 * math.pi * self.radius ** 2\n\n    def calculate_cylinder_area(self, height):\n        \"\"\"\n        Calculate the surface area of a cylinder based on self.radius and height.\n        :param height: float, height of the cylinder\n        :return: surface area of cylinder, float\n        >>> area_calculator = AreaCalculator(2)\n        >>> area_calculator.calculate_cylinder_area(3)\n        62.83185307179586\n        \"\"\"\n        if height < 0:\n            raise ValueError(\"Height must be a non-negative value.\")\n        return 2 * math.pi * self.radius * (self.radius + height)\n\n    def calculate_sector_area(self, angle):\n        \"\"\"\n        Calculate the area of a sector based on self.radius and angle in radians.\n        :param angle: float, angle of the sector in radians\n        :return: area of sector, float\n        >>> area_calculator = AreaCalculator(2)\n        >>> area_calculator.calculate_sector_area(math.pi)\n        6.283185307179586\n        \"\"\"\n        if angle < 0:\n            raise ValueError(\"Angle must be a non-negative value.\")\n        return 0.5 * self.radius ** 2 * angle\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        \"\"\"\n        Calculate the area of an annulus based on inner_radius and outer_radius.\n        :param inner_radius: float, inner radius of the annulus\n        :param outer_radius: float, outer radius of the annulus\n        :return: area of annulus, float\n        >>> area_calculator = AreaCalculator(2)\n        >>> area_calculator.calculate_annulus_area(1, 3)\n        12.566370614359172\n        \"\"\"\n        if inner_radius < 0 or outer_radius < 0:\n            raise ValueError(\"Both inner and outer radii must be non-negative values.\")\n        if inner_radius >= outer_radius:\n            raise ValueError(\"Outer radius must be greater than inner radius.\")\n        return math.pi * (outer_radius ** 2 - inner_radius ** 2)\n```",
    "2": "```python\nclass ArgumentParser:\n    \"\"\"\n    A class for parsing command line arguments into a dictionary.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the parser with empty arguments, required arguments, and types.\n        \"\"\"\n        self.arguments = {}\n        self.required = set()\n        self.types = {}\n\n    def parse_arguments(self, command_string):\n        \"\"\"\n        Parses the command line arguments and stores them in the arguments dictionary.\n        Checks for missing required arguments and returns their names if any are missing.\n\n        :param command_string: str, command line argument string\n        :return: tuple (bool, set or None)\n        \"\"\"\n        parts = command_string.split()\n        if len(parts) < 2:\n            return False, self.required\n\n        for part in parts[2:]:  # Skip the first two parts (script name)\n            if '=' in part:\n                arg, value = part.split('=', 1)\n            else:\n                arg = part\n                value = True  # Boolean flag\n\n            arg = arg.lstrip('-')\n\n            # Store the argument value with type conversion\n            self.arguments[arg] = self._convert_type(arg, value)\n\n        missing_args = self.required - self.arguments.keys()\n        return (True, None) if not missing_args else (False, missing_args)\n\n    def get_argument(self, key):\n        \"\"\"\n        Retrieves the value of the specified argument.\n\n        :param key: str, argument name\n        :return: The value of the argument, or None if not found.\n        \"\"\"\n        return self.arguments.get(key)\n\n    def add_argument(self, arg, required=False, arg_type=str):\n        \"\"\"\n        Adds an argument to the parser's expected arguments.\n\n        :param arg: str, argument name\n        :param required: bool, whether the argument is required\n        :param arg_type: type, expected type of the argument\n        \"\"\"\n        self.types[arg] = arg_type\n        if required:\n            self.required.add(arg)\n\n    def _convert_type(self, arg, value):\n        \"\"\"\n        Converts the value to the expected type if applicable.\n\n        :param arg: str, argument name\n        :param value: str, value to convert\n        :return: converted value or original value if conversion fails\n        \"\"\"\n        if arg in self.types:\n            try:\n                return self.types[arg](value)\n            except ValueError:\n                return value  # Return original value if conversion fails\n        return value\n```",
    "10": "```python\nclass BinaryDataProcessor:\n    \"\"\"\n    This class processes binary data, providing methods to clean non-binary characters,\n    calculate binary string information, and convert binary strings to ASCII or UTF-8.\n    \"\"\"\n\n    def __init__(self, binary_string):\n        \"\"\"\n        Initialize the class with a binary string and clean it by removing all non-binary characters.\n        \"\"\"\n        self.binary_string = binary_string\n        self.clean_non_binary_chars()\n\n    def clean_non_binary_chars(self):\n        \"\"\"\n        Clean the binary string by removing all non-binary characters (i.e., characters other than '0' or '1').\n        \"\"\"\n        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))\n\n    def calculate_binary_info(self):\n        \"\"\"\n        Calculate and return information about the binary string, including the percentage of 0s and 1s,\n        and the total length of the binary string.\n        \"\"\"\n        total_length = len(self.binary_string)\n        if total_length == 0:\n            return {'Zeroes': 0.0, 'Ones': 0.0, 'Bit length': 0}\n        \n        count_ones = self.binary_string.count('1')\n        count_zeroes = total_length - count_ones\n        return {\n            'Zeroes': round(count_zeroes / total_length, 3),\n            'Ones': round(count_ones / total_length, 3),\n            'Bit length': total_length\n        }\n\n    def convert_to_ascii(self):\n        \"\"\"\n        Convert the binary string to an ASCII string. Each byte (8 bits) in the binary string is converted to its\n        corresponding ASCII character.\n        \"\"\"\n        ascii_chars = [\n            chr(int(self.binary_string[i:i + 8], 2))\n            for i in range(0, len(self.binary_string), 8)\n            if i + 8 <= len(self.binary_string)\n        ]\n        return ''.join(ascii_chars)\n\n    def convert_to_utf8(self):\n        \"\"\"\n        Convert the binary string to a UTF-8 string. For this example, UTF-8 conversion is compatible with ASCII.\n        \"\"\"\n        return self.convert_to_ascii()\n```",
    "13": "```python\nclass BookManagement:\n    \"\"\"\n    A class to manage a book inventory system, allowing for the addition and removal of books,\n    viewing the inventory, and checking the quantity of a specific book.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the inventory of the Book Manager.\n        \"\"\"\n        self.inventory = {}\n\n    def add_book(self, title: str, quantity: int = 1):\n        \"\"\"\n        Add one or several copies of a book to the inventory, sorted by book title.\n        \n        :param title: str, the book title\n        :param quantity: int, default value is 1 (must be a positive integer)\n        :raises ValueError: if title is not a string or quantity is not a positive integer\n        \"\"\"\n        if not isinstance(title, str) or not isinstance(quantity, int) or quantity < 1:\n            raise ValueError(\"Invalid input: title must be a string and quantity must be a positive integer.\")\n        \n        self.inventory[title] = self.inventory.get(title, 0) + quantity\n        self.inventory = dict(sorted(self.inventory.items()))\n\n    def remove_book(self, title: str, quantity: int):\n        \"\"\"\n        Remove one or several copies of a book from the inventory, sorted by book title.\n        \n        :param title: str, the book title\n        :param quantity: int, the number of copies to remove\n        :raises ValueError: if title is not found or if there are not enough books to remove\n        \"\"\"\n        if not isinstance(title, str) or not isinstance(quantity, int) or quantity < 1:\n            raise ValueError(\"Invalid input: title must be a string and quantity must be a positive integer.\")\n        \n        if title not in self.inventory:\n            raise ValueError(\"Book not found in inventory.\")\n\n        if self.inventory[title] < quantity:\n            raise ValueError(\"Not enough books to remove.\")\n\n        self.inventory[title] -= quantity\n\n        if self.inventory[title] == 0:\n            del self.inventory[title]\n\n        self.inventory = dict(sorted(self.inventory.items()))\n\n    def view_inventory(self) -> dict:\n        \"\"\"\n        Get the inventory of the Book Management.\n        \n        :return: dictionary, {title(str): quantity(int), ...}\n        \"\"\"\n        return self.inventory\n\n    def view_book_quantity(self, title: str) -> int:\n        \"\"\"\n        Get the quantity of a specific book in the inventory.\n        \n        :param title: str, the title of the book\n        :return: int, the quantity of the specified book title (returns 0 if not found)\n        \"\"\"\n        return self.inventory.get(title, 0)\n```",
    "11": "```python\nclass BitStatusUtil:\n    \"\"\"\n    This is a utility class that provides methods for manipulating and checking status using bitwise operations.\n    \"\"\"\n\n    @staticmethod\n    def add(states, stat):\n        \"\"\"\n        Add a status to the current status, and check the parameters whether they are legal.\n        :param states: Current status, int.\n        :param stat: Status to be added, int.\n        :return: The status after adding the status, int.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.add(2, 4)\n        6\n        \"\"\"\n        BitStatusUtil.check([states, stat])\n        return states | stat\n\n    @staticmethod\n    def has(states, stat):\n        \"\"\"\n        Check if the current status contains the specified status, and check the parameters whether they are legal.\n        :param states: Current status, int.\n        :param stat: Specified status, int.\n        :return: True if the current status contains the specified status, otherwise False, bool.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.has(6, 2)\n        True\n        \"\"\"\n        BitStatusUtil.check([states, stat])\n        return (states & stat) == stat\n\n    @staticmethod\n    def remove(states, stat):\n        \"\"\"\n        Remove the specified status from the current status, and check the parameters whether they are legal.\n        :param states: Current status, int.\n        :param stat: Specified status, int.\n        :return: The status after removing the specified status, int.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.remove(6, 2)\n        4\n        \"\"\"\n        BitStatusUtil.check([states, stat])\n        return states & ~stat\n\n    @staticmethod\n    def check(args):\n        \"\"\"\n        Check if the parameters are legal. Args must be greater than or equal to 0 and must be even. If not, raise ValueError.\n        :param args: Parameters to be checked, list.\n        :return: None.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.check([2, 3, 4])\n        Traceback (most recent call last):\n        ...\n        ValueError: 3 not even\n        \"\"\"\n        for arg in args:\n            if arg < 0:\n                raise ValueError(f\"{arg} must be >= 0\")\n            if arg % 2 != 0:\n                raise ValueError(f\"{arg} not even\")\n```",
    "12": "```python\nimport random\n\nclass BlackjackGame:\n    \"\"\"\n    This class represents a game of blackjack, including deck creation, hand value calculation, and winner determination.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the Blackjack Game with attributes deck, player_hand, and dealer_hand.\n        Calls the create_deck method to generate the deck.\n        \"\"\"\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n\n    def create_deck(self):\n        \"\"\"\n        Creates a deck of 52 cards, removing Jokers.\n        :return: A shuffled list of 52 cards (format: ['AS', '2S', ...]).\n        \"\"\"\n        suits = ['S', 'H', 'D', 'C']\n        ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']\n        deck = [rank + suit for suit in suits for rank in ranks]\n        random.shuffle(deck)\n        return deck\n\n    def calculate_hand_value(self, hand):\n        \"\"\"\n        Calculates the value of the poker cards in a hand according to Blackjack rules.\n        :param hand: List of cards.\n        :return: The total value of the hand.\n        \"\"\"\n        value = 0\n        aces_count = 0\n        \n        for card in hand:\n            rank = card[:-1]  # Get the rank part of the card\n            if rank in ['J', 'Q', 'K']:\n                value += 10\n            elif rank == 'A':\n                value += 11\n                aces_count += 1\n            else:\n                value += int(rank)\n\n        # Adjust for Aces if value exceeds 21\n        while value > 21 and aces_count:\n            value -= 10\n            aces_count -= 1\n        \n        return value\n\n    def check_winner(self, player_hand, dealer_hand):\n        \"\"\"\n        Determines the winner by comparing the hand values of the player and dealer.\n        :param player_hand: List of player's cards.\n        :param dealer_hand: List of dealer's cards.\n        :return: A string indicating the result: 'Dealer wins' or 'Player wins'.\n        \"\"\"\n        player_value = self.calculate_hand_value(player_hand)\n        dealer_value = self.calculate_hand_value(dealer_hand)\n\n        if player_value > 21:\n            return 'Dealer wins'\n        elif dealer_value > 21:\n            return 'Player wins'\n        elif player_value > dealer_value:\n            return 'Player wins'\n        else:\n            return 'Dealer wins'\n```",
    "3": "```python\nimport itertools\n\nclass ArrangementCalculator:\n    \"\"\"\n    The ArrangementCalculator class provides permutation calculations and selection operations for a given set of data elements.\n    \"\"\"\n\n    def __init__(self, datas):\n        \"\"\"\n        Initializes the ArrangementCalculator object with a list of datas.\n        :param datas: List, the data elements to be used for arrangements.\n        \"\"\"\n        if not isinstance(datas, list):\n            raise ValueError(\"datas must be a list\")\n        self.datas = datas\n\n    @staticmethod\n    def count(n, m=None):\n        \"\"\"\n        Counts the number of arrangements by choosing m items from n items (permutations).\n        If m is not provided or n equals m, returns factorial(n).\n        :param n: int, the total number of items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: int, the count of arrangements.\n        >>> ArrangementCalculator.count(5, 3)\n        60\n        \"\"\"\n        if n < 0 or (m is not None and (m < 0 or m > n)):\n            raise ValueError(\"Invalid values for n or m\")\n        \n        if m is None or n == m:\n            return ArrangementCalculator.factorial(n)\n        else:\n            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n):\n        \"\"\"\n        Counts the total number of all possible arrangements by choosing at least 1 item and at most n items from n items.\n        :param n: int, the total number of items.\n        :return: int, the count of all arrangements.\n        >>> ArrangementCalculator.count_all(4)\n        64\n        \"\"\"\n        if n < 0:\n            raise ValueError(\"n must be non-negative\")\n        return sum(ArrangementCalculator.count(n, m) for m in range(1, n + 1))\n\n    def select(self, m=None):\n        \"\"\"\n        Generates a list of arrangements by selecting m items from the internal datas.\n        If m is not provided, selects all items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: List, a list of arrangements.\n        >>> ac = ArrangementCalculator([1, 2, 3, 4])\n        >>> ac.select(2)\n        [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n        \"\"\"\n        if m is None:\n            m = len(self.datas)\n        if m < 0 or m > len(self.datas):\n            raise ValueError(\"Invalid value for m\")\n        return [list(p) for p in itertools.permutations(self.datas, m)]\n\n    def select_all(self):\n        \"\"\"\n        Generates a list of all arrangements by selecting at least 1 item and at most the number of internal datas.\n        :return: List, a list of all arrangements.\n        >>> ac = ArrangementCalculator([1, 2, 3])\n        >>> ac.select_all()\n        [[1], [2], [3], [1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2], [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n        \"\"\"\n        return [arrangement for m in range(1, len(self.datas) + 1) for arrangement in self.select(m)]\n\n    @staticmethod\n    def factorial(n):\n        \"\"\"\n        Calculates the factorial of a given number.\n        :param n: int, the number to calculate the factorial.\n        :return: int, the factorial of the given number.\n        >>> ArrangementCalculator.factorial(4)\n        24\n        \"\"\"\n        if n < 0:\n            raise ValueError(\"n must be non-negative\")\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result\n```",
    "18": "```python\nclass CamelCaseMap:\n    \"\"\"\n    This is a custom class that allows keys to be in camel case style by converting them from underscore style, which provides dictionary-like functionality.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize data to an empty dictionary\n        \"\"\"\n        self._data = {}\n\n    def __getitem__(self, key):\n        \"\"\"\n        Return the value corresponding to the key\n        :param key: str\n        :return: The value corresponding to the key\n        \"\"\"\n        converted_key = self._convert_key(key)\n        if converted_key not in self._data:\n            raise KeyError(f\"Key '{converted_key}' not found.\")\n        return self._data[converted_key]\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Set the value corresponding to the key to the specified value\n        :param key: str\n        :param value: The specified value\n        \"\"\"\n        self._data[self._convert_key(key)] = value\n\n    def __delitem__(self, key):\n        \"\"\"\n        Delete the value corresponding to the key\n        :param key: str\n        \"\"\"\n        converted_key = self._convert_key(key)\n        if converted_key not in self._data:\n            raise KeyError(f\"Key '{converted_key}' not found.\")\n        del self._data[converted_key]\n\n    def __iter__(self):\n        \"\"\"\n        Return an iterator over the keys of the data\n        :return: Iterator\n        \"\"\"\n        return iter(self._data)\n\n    def __len__(self):\n        \"\"\"\n        Return the number of items in the data\n        :return: int, length of data\n        \"\"\"\n        return len(self._data)\n\n    def _convert_key(self, key):\n        \"\"\"\n        Convert key string into camel case\n        :param key: str\n        :return: converted key string\n        \"\"\"\n        return self._to_camel_case(key)\n\n    @staticmethod\n    def _to_camel_case(key):\n        \"\"\"\n        Convert key string into camel case\n        :param key: str\n        :return: converted key string\n        \"\"\"\n        components = key.split('_')\n        return components[0] + ''.join(x.title() for x in components[1:])\n```",
    "15": "```python\nclass BoyerMooreSearch:\n    \"\"\"\n    This class implements the Boyer-Moore algorithm for string searching, which is used to find occurrences of a pattern within a given text.\n    \"\"\"\n\n    def __init__(self, text, pattern):\n        \"\"\"\n        Initializes the BoyerMooreSearch class with the given text and pattern.\n        :param text: The text to be searched, str.\n        :param pattern: The pattern to be searched for, str.\n        \"\"\"\n        self.text = text\n        self.pattern = pattern\n        self.textLen = len(text)\n        self.patLen = len(pattern)\n        self.badChar = self.bad_character_heuristic()\n\n    def match_in_pattern(self, char):\n        \"\"\"\n        Finds the rightmost occurrence of a character in the pattern.\n        :param char: The character to be searched for, str.\n        :return: The index of the rightmost occurrence of the character in the pattern, int.\n        \"\"\"\n        for i in range(self.patLen - 1, -1, -1):\n            if self.pattern[i] == char:\n                return i\n        return -1\n\n    def mismatch_in_text(self, currentPos):\n        \"\"\"\n        Determines the position of the first mismatch between the pattern and the text.\n        :param currentPos: The current position in the text, int.\n        :return: The position of the first mismatch between the pattern and the text, int, otherwise -1.\n        \"\"\"\n        for i in range(self.patLen - 1, -1, -1):\n            if currentPos + i >= self.textLen or self.text[currentPos + i] != self.pattern[i]:\n                return i\n        return -1\n\n    def bad_character_heuristic(self):\n        \"\"\"\n        Finds all occurrences of the pattern in the text using the bad character heuristic.\n        :return: A list of all positions of the pattern in the text, list.\n        \"\"\"\n        positions = []\n        skip = 0\n        \n        while skip <= self.textLen - self.patLen:\n            mismatch_index = self.mismatch_in_text(skip)\n            if mismatch_index == -1:\n                positions.append(skip)\n                skip += self.patLen - self.match_in_pattern(self.text[skip + self.patLen - 1]) if skip + self.patLen < self.textLen else 1\n            else:\n                char_index = self.match_in_pattern(self.text[skip + mismatch_index])\n                skip += max(1, mismatch_index - char_index)\n        \n        return positions\n```",
    "14": "```python\nimport sqlite3\nfrom contextlib import closing\n\nclass BookManagementDB:\n    \"\"\"\n    This is a database class for a book management system, used to handle the operations of adding, removing, updating, and searching books.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the class by creating a database connection,\n        and creates the book table if it does not already exist.\n        :param db_name: str, the name of the database file\n        \"\"\"\n        self.db_name = db_name\n        with closing(self.connect()) as conn:\n            self.create_table(conn)\n\n    def connect(self):\n        \"\"\"\n        Establishes and returns a new database connection.\n        :return: sqlite3.Connection\n        \"\"\"\n        return sqlite3.connect(self.db_name)\n\n    def create_table(self, conn):\n        \"\"\"\n        Creates the book table in the database if it does not already exist.\n        :param conn: sqlite3.Connection, the database connection\n        \"\"\"\n        with conn:\n            conn.execute('''\n                CREATE TABLE IF NOT EXISTS books (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    title TEXT NOT NULL,\n                    author TEXT NOT NULL,\n                    available INTEGER NOT NULL DEFAULT 1\n                )\n            ''')\n\n    def add_book(self, title, author):\n        \"\"\"\n        Adds a book to the database with the specified title and author,\n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        \"\"\"\n        with closing(self.connect()) as conn:\n            with conn:\n                conn.execute('''\n                    INSERT INTO books (title, author) \n                    VALUES (?, ?)\n                ''', (title, author))\n\n    def remove_book(self, book_id):\n        \"\"\"\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        with closing(self.connect()) as conn:\n            with conn:\n                conn.execute('''\n                    DELETE FROM books WHERE id = ?\n                ''', (book_id,))\n\n    def borrow_book(self, book_id):\n        \"\"\"\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        with closing(self.connect()) as conn:\n            with conn:\n                conn.execute('''\n                    UPDATE books SET available = 0 WHERE id = ?\n                ''', (book_id,))\n\n    def return_book(self, book_id):\n        \"\"\"\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        with closing(self.connect()) as conn:\n            with conn:\n                conn.execute('''\n                    UPDATE books SET available = 1 WHERE id = ?\n                ''', (book_id,))\n\n    def search_books(self):\n        \"\"\"\n        Retrieves all books from the database and returns their information.\n        :return: list[tuple], the information of all books in the database\n        \"\"\"\n        with closing(self.connect()) as conn:\n            cursor = conn.execute('SELECT * FROM books')\n            return cursor.fetchall()\n\n    def close(self):\n        \"\"\"\n        Closes the database connection. This method is not strictly necessary\n        since we are using context managers, but it can be used if needed.\n        \"\"\"\n        pass\n```",
    "16": "```python\nclass Calculator:\n    \"\"\"\n    A class for a calculator capable of performing basic arithmetic calculations on numerical expressions\n    using the operators +, -, *, /, and ^ (exponentiation).\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the operations performed by the operators '+', '-', '*', '/', '^'.\n        \"\"\"\n        self.operators = {\n            '+': lambda x, y: x + y,\n            '-': lambda x, y: x - y,\n            '*': lambda x, y: x * y,\n            '/': lambda x, y: x / y if y != 0 else float('inf'),  # Handle division by zero\n            '^': lambda x, y: x ** y\n        }\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the value of a given expression.\n        :param expression: string, given expression\n        :return: If successful, returns the value of the expression; otherwise, returns None\n        >>> calculator = Calculator()\n        >>> calculator.calculate('1+2-3')\n        0.0\n        >>> calculator.calculate('2/0')\n        inf\n        \"\"\"\n        tokens = self.tokenize(expression)\n        operand_stack = []\n        operator_stack = []\n\n        for token in tokens:\n            if self.is_number(token):\n                operand_stack.append(float(token))\n            else:\n                while (operator_stack and\n                       self.precedence(operator_stack[-1]) >= self.precedence(token)):\n                    self.apply_operator(operand_stack, operator_stack)\n                operator_stack.append(token)\n\n        while operator_stack:\n            self.apply_operator(operand_stack, operator_stack)\n\n        return operand_stack[0] if operand_stack else None\n\n    def tokenize(self, expression):\n        \"\"\"\n        Tokenizes the input expression into numbers and operators.\n        :param expression: string, the expression to tokenize\n        :return: list of tokens\n        \"\"\"\n        tokens = []\n        num = ''\n        for char in expression:\n            if char in self.operators or char in '()':\n                if num:\n                    tokens.append(num)\n                    num = ''\n                tokens.append(char)\n            else:\n                num += char\n        if num:\n            tokens.append(num)\n        return tokens\n\n    def precedence(self, operator):\n        \"\"\"\n        Returns the priority of the specified operator.\n        :param operator: string, given operator\n        :return: int, the priority of the given operator; returns 0 if the operator is unknown\n        >>> calculator = Calculator()\n        >>> calculator.precedence('+')\n        1\n        >>> calculator.precedence('^')\n        3\n        \"\"\"\n        return {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}.get(operator, 0)\n\n    def apply_operator(self, operand_stack, operator_stack):\n        \"\"\"\n        Use the operator at the top of the operator stack to perform the operation on the two numbers at the top\n        of the operand stack and store the result at the top of the operand stack.\n        :param operand_stack: list\n        :param operator_stack: list\n        \"\"\"\n        operator = operator_stack.pop()\n        right_operand = operand_stack.pop()\n        left_operand = operand_stack.pop()\n        result = self.operators[operator](left_operand, right_operand)\n        operand_stack.append(result)\n\n    def is_number(self, token):\n        \"\"\"\n        Check if the token is a number.\n        :param token: string, token to check\n        :return: bool, True if token is a number, otherwise False\n        \"\"\"\n        try:\n            float(token)\n            return True\n        except ValueError:\n            return False\n```",
    "19": "```python\nclass ChandrasekharSieve:\n    \"\"\"\n    This is a class that uses the Chandrasekhar's Sieve method to find all prime numbers within the range.\n    \"\"\"\n\n    def __init__(self, n):\n        \"\"\"\n        Initialize the ChandrasekharSieve class with the given limit.\n        :param n: int, the upper limit for generating prime numbers\n        :raises ValueError: if n is less than 2\n        \"\"\"\n        if n < 2:\n            raise ValueError(\"The upper limit must be at least 2.\")\n        self.n = n\n        self.primes = self.generate_primes()\n\n    def generate_primes(self):\n        \"\"\"\n        Generate prime numbers up to the specified limit using the Chandrasekhar sieve algorithm.\n        :return: list, a list of prime numbers\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.generate_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n        \"\"\"\n        is_prime = [True] * (self.n + 1)\n        is_prime[0], is_prime[1] = False, False\n        \n        for i in range(2, int(self.n**0.5) + 1):\n            if is_prime[i]:\n                for j in range(i * i, self.n + 1, i):\n                    is_prime[j] = False\n        \n        return [i for i in range(self.n + 1) if is_prime[i]]\n\n    def get_primes(self):\n        \"\"\"\n        Get the list of generated prime numbers.\n        :return: list, a list of prime numbers\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.get_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n        \"\"\"\n        return self.primes\n```",
    "17": "```python\nfrom datetime import datetime, timedelta\n\nclass CalendarUtil:\n    \"\"\"\n    A class that provides functionalities to manage calendar events, schedule appointments, and perform conflict checks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the calendar with an empty list of events.\n        \"\"\"\n        self.events = []\n\n    def add_event(self, event):\n        \"\"\"\n        Add an event to the calendar.\n        :param event: The event to be added to the calendar, dict.\n        \"\"\"\n        if 'date' not in event or 'start_time' not in event or 'end_time' not in event:\n            raise ValueError(\"Event must contain 'date', 'start_time', and 'end_time'.\")\n        if event['start_time'] >= event['end_time']:\n            raise ValueError(\"Event start time must be before end time.\")\n        if not self.is_available(event['start_time'], event['end_time']):\n            raise ValueError(\"Event time conflicts with existing events.\")\n        \n        self.events.append(event)\n\n    def remove_event(self, event):\n        \"\"\"\n        Remove an event from the calendar.\n        :param event: The event to be removed from the calendar, dict.\n        \"\"\"\n        if event in self.events:\n            self.events.remove(event)\n\n    def get_events(self, date):\n        \"\"\"\n        Get all events on a given date.\n        :param date: The date to get events for, datetime.\n        :return: A list of events on the given date, list.\n        \"\"\"\n        return [event for event in self.events if event['date'].date() == date.date()]\n\n    def is_available(self, start_time, end_time):\n        \"\"\"\n        Check if the calendar is available for a given time slot.\n        :param start_time: The start time of the time slot, datetime.\n        :param end_time: The end time of the time slot, datetime.\n        :return: True if the calendar is available for the given time slot, False otherwise, bool.\n        \"\"\"\n        return all(not (event['start_time'] < end_time and event['end_time'] > start_time) for event in self.events)\n\n    def get_available_slots(self, date):\n        \"\"\"\n        Get all available time slots on a given date.\n        :param date: The date to get available time slots for, datetime.\n        :return: A list of available time slots on the given date, list.\n        \"\"\"\n        day_start = datetime.combine(date.date(), datetime.min.time())\n        day_end = datetime.combine(date.date(), datetime.max.time())\n        occupied_slots = [(event['start_time'], event['end_time']) for event in self.events if event['date'].date() == date.date()]\n        available_slots = []\n\n        if not occupied_slots:\n            return [(day_start, day_end)]\n\n        occupied_slots.sort()\n        current_start = day_start\n\n        for start, end in occupied_slots:\n            if current_start < start:\n                available_slots.append((current_start, start))\n            current_start = max(current_start, end)\n\n        if current_start < day_end:\n            available_slots.append((current_start, day_end))\n\n        return available_slots\n\n    def get_upcoming_events(self, num_events):\n        \"\"\"\n        Get the next n upcoming events.\n        :param num_events: The number of upcoming events to get, int.\n        :return: A list of the next n upcoming events, list.\n        \"\"\"\n        now = datetime.now()\n        upcoming_events = [event for event in self.events if event['start_time'] >= now]\n        upcoming_events.sort(key=lambda x: x['start_time'])\n        return upcoming_events[:num_events]\n```",
    "20": "```python\nfrom datetime import datetime\n\nclass Chat:\n    \"\"\"\n    This is a chat class with the functions of adding users, removing users, sending messages, and obtaining messages.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Chat with an attribute users, which is an empty dictionary.\n        \"\"\"\n        self.users = {}\n\n    def add_user(self, username):\n        \"\"\"\n        Add a new user to the Chat.\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns False, otherwise, returns True.\n        \"\"\"\n        if not isinstance(username, str) or not username.strip():\n            raise ValueError(\"Username must be a non-empty string.\")\n        \n        if username in self.users:\n            return False\n        self.users[username] = []\n        return True\n\n    def remove_user(self, username):\n        \"\"\"\n        Remove a user from the Chat.\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns True, otherwise, returns False.\n        \"\"\"\n        if username in self.users:\n            del self.users[username]\n            return True\n        return False\n\n    def send_message(self, sender, receiver, message):\n        \"\"\"\n        Send a message from a user to another user.\n        :param sender: The sender's name, str.\n        :param receiver: The receiver's name, str.\n        :param message: The message, str.\n        :return: If the sender or the receiver is not in the Chat, returns False, otherwise, returns True.\n        \"\"\"\n        if sender not in self.users or receiver not in self.users:\n            return False\n        if not isinstance(message, str) or not message.strip():\n            raise ValueError(\"Message must be a non-empty string.\")\n        \n        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n        self.users[receiver].append({\n            'sender': sender,\n            'receiver': receiver,\n            'message': message,\n            'timestamp': timestamp,\n        })\n        return True\n\n    def get_messages(self, username):\n        \"\"\"\n        Get all the messages of a user from the Chat.\n        :param username: The user's name, str.\n        :return: A list of messages, each message is a dictionary with keys 'sender', 'receiver', 'message', 'timestamp'.\n        \"\"\"\n        if username not in self.users:\n            return []\n        return self.users[username]\n```",
    "24": "```python\nclass ComplexCalculator:\n    \"\"\"\n    This is a class that implements addition, subtraction, multiplication, and division operations for complex numbers.\n    \"\"\"\n\n    @staticmethod\n    def add(c1, c2):\n        \"\"\"\n        Adds two complex numbers.\n        :param c1: The first complex number, complex.\n        :param c2: The second complex number, complex.\n        :return: The sum of the two complex numbers, complex.\n        >>> ComplexCalculator.add(1+2j, 3+4j)\n        (4+6j)\n        \"\"\"\n        return c1 + c2\n\n    @staticmethod\n    def subtract(c1, c2):\n        \"\"\"\n        Subtracts two complex numbers.\n        :param c1: The first complex number, complex.\n        :param c2: The second complex number, complex.\n        :return: The difference of the two complex numbers, complex.\n        >>> ComplexCalculator.subtract(1+2j, 3+4j)\n        (-2-2j)\n        \"\"\"\n        return c1 - c2\n\n    @staticmethod\n    def multiply(c1, c2):\n        \"\"\"\n        Multiplies two complex numbers.\n        :param c1: The first complex number, complex.\n        :param c2: The second complex number, complex.\n        :return: The product of the two complex numbers, complex.\n        >>> ComplexCalculator.multiply(1+2j, 3+4j)\n        (-5+10j)\n        \"\"\"\n        return c1 * c2\n\n    @staticmethod\n    def divide(c1, c2):\n        \"\"\"\n        Divides two complex numbers.\n        :param c1: The first complex number, complex.\n        :param c2: The second complex number, complex.\n        :return: The quotient of the two complex numbers, complex.\n        :raises ZeroDivisionError: if c2 is zero.\n        >>> ComplexCalculator.divide(1+2j, 3+4j)\n        (0.44+0.08j)\n        \"\"\"\n        if c2 == 0:\n            raise ZeroDivisionError(\"Cannot divide by zero.\")\n        return c1 / c2\n```",
    "25": "```python\nimport json\nimport os\n\nclass CookiesUtil:\n    \"\"\"\n    A utility class for managing and manipulating cookies, including methods for retrieving, saving, and setting cookies data.\n    \"\"\"\n\n    def __init__(self, cookies_file):\n        \"\"\"\n        Initializes the CookiesUtil with the specified cookies file.\n        :param cookies_file: The path to the cookies file, str.\n        \"\"\"\n        self.cookies_file = cookies_file\n        self.cookies = self.load_cookies()\n\n    def get_cookies(self, response):\n        \"\"\"\n        Gets the cookies from the specified response and saves them to the cookies file.\n        :param response: The response to get cookies from, dict.\n        \"\"\"\n        self.cookies = response.get('cookies', {})\n        self._save_cookies()\n\n    def load_cookies(self):\n        \"\"\"\n        Loads the cookies from the cookies file into the cookies data.\n        :return: The cookies data, dict.\n        \"\"\"\n        if not os.path.exists(self.cookies_file):\n            return {}\n\n        try:\n            with open(self.cookies_file, 'r') as f:\n                return json.load(f)\n        except (json.JSONDecodeError, IOError):\n            return {}\n\n    def _save_cookies(self):\n        \"\"\"\n        Saves the cookies to the cookies file.\n        :return: True if successful, False otherwise.\n        \"\"\"\n        try:\n            with open(self.cookies_file, 'w') as f:\n                json.dump(self.cookies, f, indent=4)\n            return True\n        except IOError:\n            return False\n```",
    "21": "```python\nfrom datetime import datetime\n\nclass Classroom:\n    \"\"\"\n    This is a class representing a classroom, capable of adding and removing courses, checking availability at a given time,\n    and detecting conflicts when scheduling new courses.\n    \"\"\"\n\n    def __init__(self, id):\n        \"\"\"\n        Initialize the classroom management system.\n        :param id: int, the id of classroom\n        \"\"\"\n        self.id = id\n        self.courses = []\n\n    def add_course(self, course):\n        \"\"\"\n        Add course to self.courses list if the course wasn't in it and it does not conflict with existing courses.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        \"\"\"\n        if course not in self.courses and self.check_course_conflict(course):\n            self.courses.append(course)\n\n    def remove_course(self, course):\n        \"\"\"\n        Remove course from self.courses list if the course is present.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        \"\"\"\n        if course in self.courses:\n            self.courses.remove(course)\n\n    def is_free_at(self, check_time):\n        \"\"\"\n        Check if the classroom is free at the given time.\n        :param check_time: str, the time to be checked in '%H:%M' format\n        :return: True if the check_time does not conflict with any course times, otherwise False.\n        \"\"\"\n        check_time = datetime.strptime(check_time, '%H:%M')\n        for course in self.courses:\n            start_time = datetime.strptime(course['start_time'], '%H:%M')\n            end_time = datetime.strptime(course['end_time'], '%H:%M')\n            if start_time < check_time < end_time:\n                return False\n        return True\n\n    def check_course_conflict(self, new_course):\n        \"\"\"\n        Check if the new course conflicts with any existing courses.\n        :param new_course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        :return: False if the new course time conflicts with other courses, otherwise True.\n        \"\"\"\n        new_start = datetime.strptime(new_course['start_time'], '%H:%M')\n        new_end = datetime.strptime(new_course['end_time'], '%H:%M')\n        for course in self.courses:\n            start_time = datetime.strptime(course['start_time'], '%H:%M')\n            end_time = datetime.strptime(course['end_time'], '%H:%M')\n            if new_start < end_time and new_end > start_time:\n                return False\n        return True\n```",
    "22": "```python\nclass ClassRegistrationSystem:\n    \"\"\"\n    A class registration system that allows registering students, enrolling them in classes, retrieving students by major,\n    getting a list of all majors, and determining the most popular class within a specific major.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the registration system with lists and dictionaries to track students and their registered classes.\n        \"\"\"\n        self.students = []\n        self.students_registration_classes = {}\n\n    def register_student(self, student):\n        \"\"\"\n        Registers a student in the system. If the student is already registered, returns 0, else returns 1.\n        \n        :param student: dict with keys 'name' and 'major'\n        :return: 1 if registered successfully, 0 if the student is already registered\n        \"\"\"\n        if any(existing_student['name'] == student['name'] for existing_student in self.students):\n            return 0\n        self.students.append(student)\n        self.students_registration_classes[student['name']] = []\n        return 1\n\n    def register_class(self, student_name, class_name):\n        \"\"\"\n        Registers a class for a student.\n        \n        :param student_name: str\n        :param class_name: str\n        :return: list of class names that the student has registered\n        \"\"\"\n        if student_name not in self.students_registration_classes:\n            self.students_registration_classes[student_name] = []\n        self.students_registration_classes[student_name].append(class_name)\n        return self.students_registration_classes[student_name]\n\n    def get_students_by_major(self, major):\n        \"\"\"\n        Retrieves all students in a specific major.\n        \n        :param major: str\n        :return: list of student names\n        \"\"\"\n        return [student['name'] for student in self.students if student['major'] == major]\n\n    def get_all_majors(self):\n        \"\"\"\n        Retrieves all unique majors in the system.\n        \n        :return: list of majors\n        \"\"\"\n        return list(set(student['major'] for student in self.students))\n\n    def get_most_popular_class_in_major(self, major):\n        \"\"\"\n        Determines the class with the highest enrollment in a specific major.\n        \n        :param major: str\n        :return: name of the most popular class or None if no classes are registered\n        \"\"\"\n        class_enrollment = {}\n        for student in self.students:\n            if student['major'] == major:\n                for class_name in self.students_registration_classes[student['name']]:\n                    class_enrollment[class_name] = class_enrollment.get(class_name, 0) + 1\n        return max(class_enrollment, key=class_enrollment.get) if class_enrollment else None\n```",
    "23": "```python\nimport math\nfrom typing import List\n\nclass CombinationCalculator:\n    \"\"\"\n    This is a class that provides methods to calculate the number of combinations for a specific count,\n    calculate all possible combinations, and generate combinations with a specified number of elements.\n    \"\"\"\n\n    def __init__(self, datas: List[str]):\n        \"\"\"\n        Initialize the calculator with a list of data.\n        \"\"\"\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        \"\"\"\n        Calculate the number of combinations for a specific count.\n        :param n: The total number of elements, int.\n        :param m: The number of elements in each combination, int.\n        :return: The number of combinations, int.\n        >>> CombinationCalculator.count(4, 2)\n        6\n        \"\"\"\n        if m > n or m < 0:\n            return 0\n        return math.comb(n, m)\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"\n        Calculate the number of all possible combinations.\n        :param n: The total number of elements, int.\n        :return: The number of all possible combinations, int. If the number of combinations is greater than 2^63-1, return float(\"inf\").\n        >>> CombinationCalculator.count_all(4)\n        15\n        \"\"\"\n        total_combinations = 0\n        for m in range(1, n + 1):\n            total_combinations += CombinationCalculator.count(n, m)\n            if total_combinations > 2**63 - 1:\n                return float(\"inf\")\n        return total_combinations\n\n    def select(self, m: int) -> List[List[str]]:\n        \"\"\"\n        Generate combinations with a specified number of elements.\n        :param m: The number of elements in each combination, int.\n        :return: A list of combinations, List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select(2)\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n        \"\"\"\n        if m < 0 or m > len(self.datas):\n            return []\n        result = []\n        self._select(0, [None] * m, 0, result)\n        return result\n\n    def select_all(self) -> List[List[str]]:\n        \"\"\"\n        Generate all possible combinations of selecting elements from the given data list, and it uses the select method.\n        :return: A list of combinations, List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select_all()\n        [['A'], ['B'], ['C'], ['D'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D'], ['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']]\n        \"\"\"\n        result = []\n        for m in range(1, len(self.datas) + 1):\n            result.extend(self.select(m))\n        return result\n\n    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        \"\"\"\n        Generate combinations with a specified number of elements by recursion.\n        :param dataIndex: The index of the data to be selected, int.\n        :param resultList: The list of elements in the combination, List[str].\n        :param resultIndex: The index of the element in the combination, int.\n        :param result: The list of combinations, List[List[str]].\n        :return: None.\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> result = []\n        >>> calc._select(0, [None] * 2, 0, result)\n        >>> result\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n        \"\"\"\n        if resultIndex == len(resultList):\n            result.append(resultList.copy())\n            return\n        \n        for i in range(dataIndex, len(self.datas)):\n            resultList[resultIndex] = self.datas[i]\n            self._select(i + 1, resultList, resultIndex + 1, result)\n```",
    "26": "```python\nimport csv\nimport os\n\nclass CSVProcessor:\n    \"\"\"\n    A class for processing CSV files, including reading and writing CSV data,\n    as well as performing specific operations and saving the results to a new CSV file.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_csv(self, file_name):\n        \"\"\"\n        Read the CSV file specified by file_name and return the title and data.\n        \n        :param file_name: str, name of the CSV file\n        :return: tuple (list, list), where the first element is the title and the second is the data\n        \"\"\"\n        try:\n            with open(file_name, mode='r', newline='', encoding='utf-8') as file:\n                reader = csv.reader(file)\n                title = next(reader)\n                data = [row for row in reader]\n            return title, data\n        except FileNotFoundError:\n            print(f\"Error: The file '{file_name}' was not found.\")\n            return [], []\n        except Exception as e:\n            print(f\"An error occurred while reading the CSV file: {e}\")\n            return [], []\n\n    def write_csv(self, data, file_name):\n        \"\"\"\n        Write data into a CSV file.\n        \n        :param data: list of lists, data to be written to the CSV file\n        :param file_name: str, name of the CSV file\n        :return: int, if successful return 1, otherwise return 0\n        \"\"\"\n        try:\n            with open(file_name, mode='w', newline='', encoding='utf-8') as file:\n                writer = csv.writer(file)\n                writer.writerows(data)\n            return 1\n        except Exception as e:\n            print(f\"An error occurred while writing to the CSV file: {e}\")\n            return 0\n\n    def process_csv_data(self, N, save_file_name):\n        \"\"\"\n        Read a CSV file, capitalize the N-th column data, and save it to a new CSV file.\n        \n        :param N: int, the N-th column (0-indexed)\n        :param save_file_name: str, the name of the file that needs to be processed\n        :return: int, if successful return 1, otherwise return 0\n        \"\"\"\n        try:\n            title, data = self.read_csv(save_file_name)\n            if not data or N >= len(title):\n                print(\"Error: No data to process or invalid column index.\")\n                return 0\n            \n            new_data = [[row[N].upper()] for row in data if len(row) > N]\n            new_file_name = os.path.splitext(save_file_name)[0] + '_process.csv'\n            self.write_csv([title], new_file_name)\n            self.write_csv(new_data, new_file_name)\n            return 1\n        except Exception as e:\n            print(f\"An error occurred during processing: {e}\")\n            return 0\n```",
    "27": "```python\nclass CurrencyConverter:\n    \"\"\"\n    A class for currency conversion that supports converting amounts between different currencies,\n    retrieving supported currencies, adding new currency rates, and updating existing currency rates.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the exchange rates of various currencies against the US dollar.\n        \"\"\"\n        self.rates = {\n            'USD': 1.0,\n            'EUR': 0.85,\n            'GBP': 0.72,\n            'JPY': 110.15,\n            'CAD': 1.23,\n            'AUD': 1.34,\n            'CNY': 6.40,\n        }\n\n    def convert(self, amount, from_currency, to_currency):\n        \"\"\"\n        Convert an amount from one currency to another.\n\n        :param amount: float, The amount of the source currency.\n        :param from_currency: str, The source currency type.\n        :param to_currency: str, The target currency type.\n        :return: float, The amount converted to the target currency.\n        :raises ValueError: If either currency is not supported.\n        \"\"\"\n        if from_currency not in self.rates or to_currency not in self.rates:\n            raise ValueError(\"Unsupported currency\")\n\n        # Convert amount to USD first\n        amount_in_usd = amount / self.rates[from_currency]\n        # Convert USD to target currency\n        converted_amount = amount_in_usd * self.rates[to_currency]\n        return converted_amount\n\n    def get_supported_currencies(self):\n        \"\"\"\n        Returns a list of supported currency types.\n\n        :return: list, All supported currency types.\n        \"\"\"\n        return list(self.rates.keys())\n\n    def add_currency_rate(self, currency, rate):\n        \"\"\"\n        Add a new supported currency type.\n\n        :param currency: str, The currency type to be added.\n        :param rate: float, The exchange rate for this currency type.\n        :return: None if successful, False if unsuccessful.\n        \"\"\"\n        if currency in self.rates:\n            return False\n        self.rates[currency] = rate\n        return None\n\n    def update_currency_rate(self, currency, new_rate):\n        \"\"\"\n        Update the exchange rate for a specific currency.\n\n        :param currency: str, The currency type.\n        :param new_rate: float, The new exchange rate.\n        :return: None if successful, False if unsuccessful.\n        \"\"\"\n        if currency not in self.rates:\n            return False\n        self.rates[currency] = new_rate\n        return None\n```",
    "29": "```python\nfrom collections import Counter\n\nclass DataStatistics:\n    \"\"\"\n    This is a class for performing data statistics, supporting the calculation of mean, median, and mode of a given data set.\n    \"\"\"\n\n    def mean(self, data):\n        \"\"\"\n        Calculate the average value of a group of data, accurate to two digits after the decimal separator.\n        :param data: list, data list\n        :return: float, the mean value\n        >>> ds = DataStatistics()\n        >>> ds.mean([1, 2, 3, 4, 5])\n        3.0\n        >>> ds.mean([])\n        0.0\n        \"\"\"\n        if not data:\n            return 0.0\n        return round(sum(data) / len(data), 2)\n\n    def median(self, data):\n        \"\"\"\n        Calculate the median of a group of data, accurate to two digits after the decimal separator.\n        :param data: list, data list\n        :return: float, the median value\n        >>> ds = DataStatistics()\n        >>> ds.median([2, 5, 1, 3, 4])\n        3.0\n        >>> ds.median([])\n        0.0\n        \"\"\"\n        if not data:\n            return 0.0\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        mid = n // 2\n        median_value = (sorted_data[mid - 1] + sorted_data[mid]) / 2 if n % 2 == 0 else sorted_data[mid]\n        return round(median_value, 2)\n\n    def mode(self, data):\n        \"\"\"\n        Calculate the mode of a set of data.\n        :param data: list, data list\n        :return: list, the mode(s)\n        >>> ds = DataStatistics()\n        >>> ds.mode([2, 2, 3, 3, 4])\n        [2, 3]\n        >>> ds.mode([])\n        []\n        \"\"\"\n        if not data:\n            return []\n        count = Counter(data)\n        max_count = max(count.values())\n        mode_values = [key for key, value in count.items() if value == max_count]\n        return mode_values if len(mode_values) < len(data) else []\n```",
    "30": "```python\nimport numpy as np\n\nclass DataStatistics:\n    \"\"\"\n    A class for performing statistical analysis on a dataset, including methods to calculate\n    sum, minimum, maximum, variance, standard deviation, and correlation.\n    \"\"\"\n\n    def __init__(self, data):\n        \"\"\"\n        Initialize the DataStatistics class with a dataset.\n        \n        :param data: list or array-like\n        :raises ValueError: if data is empty or not numeric\n        \"\"\"\n        if not data or not all(isinstance(x, (int, float)) for x in data):\n            raise ValueError(\"Data must be a non-empty list of numeric values.\")\n        self.data = np.array(data)\n\n    def get_sum(self):\n        \"\"\"\n        Calculate the sum of the dataset.\n        \n        :return: float\n        \"\"\"\n        return np.sum(self.data)\n\n    def get_min(self):\n        \"\"\"\n        Calculate the minimum value in the dataset.\n        \n        :return: float\n        \"\"\"\n        return np.min(self.data)\n\n    def get_max(self):\n        \"\"\"\n        Calculate the maximum value in the dataset.\n        \n        :return: float\n        \"\"\"\n        return np.max(self.data)\n\n    def get_variance(self):\n        \"\"\"\n        Calculate the sample variance of the dataset, rounded to two decimal places.\n        \n        :return: float\n        \"\"\"\n        return round(np.var(self.data, ddof=1), 2)\n\n    def get_std_deviation(self):\n        \"\"\"\n        Calculate the sample standard deviation of the dataset, rounded to two decimal places.\n        \n        :return: float\n        \"\"\"\n        return round(np.std(self.data, ddof=1), 2)\n\n    def get_correlation(self, other_data):\n        \"\"\"\n        Calculate the correlation coefficient with another dataset.\n        \n        :param other_data: list or array-like\n        :return: float\n        :raises ValueError: if other_data is empty or not of the same length as the data\n        \"\"\"\n        if not other_data or len(other_data) != len(self.data):\n            raise ValueError(\"Other data must be a non-empty list of the same length as the dataset.\")\n        \n        other_data = np.array(other_data)\n        return np.corrcoef(self.data, other_data)[0, 1]\n```",
    "31": "```python\nimport math\nfrom statistics import mean, stdev\n\nclass DataStatistics4:\n    \"\"\"\n    This is a class that performs advanced mathematical calculations and statistics,\n    including correlation coefficient, skewness, kurtosis, and probability density function (PDF) \n    for a normal distribution.\n    \"\"\"\n\n    @staticmethod\n    def correlation_coefficient(data1, data2):\n        \"\"\"\n        Calculate the correlation coefficient of two sets of data.\n        :param data1: The first set of data, list.\n        :param data2: The second set of data, list.\n        :return: The correlation coefficient, float.\n        \"\"\"\n        if len(data1) != len(data2) or len(data1) == 0:\n            raise ValueError(\"Input lists must be of the same non-zero length.\")\n        \n        n = len(data1)\n        mean1 = mean(data1)\n        mean2 = mean(data2)\n        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))\n        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n)) * \n                                 sum((data2[i] - mean2) ** 2 for i in range(n)))\n        return numerator / denominator if denominator != 0 else 0.0\n\n    @staticmethod\n    def skewness(data):\n        \"\"\"\n        Calculate the skewness of a set of data.\n        :param data: The input data list, list.\n        :return: The skewness, float.\n        \"\"\"\n        n = len(data)\n        if n < 3:\n            raise ValueError(\"Skewness requires at least three data points.\")\n        \n        mean_data = mean(data)\n        stdev_data = stdev(data)\n        skew = (n / ((n - 1) * (n - 2))) * sum(((x - mean_data) / stdev_data) ** 3 for x in data)\n        return skew\n\n    @staticmethod\n    def kurtosis(data):\n        \"\"\"\n        Calculate the kurtosis of a set of data.\n        :param data: The input data list, list.\n        :return: The kurtosis, float.\n        \"\"\"\n        n = len(data)\n        if n < 4:\n            raise ValueError(\"Kurtosis requires at least four data points.\")\n        \n        mean_data = mean(data)\n        stdev_data = stdev(data)\n        kurt = (n * (n + 1) * sum(((x - mean_data) / stdev_data) ** 4 for x in data) - \n               3 * (n - 1) ** 2) / ((n - 1) * (n - 2) * (n - 3))\n        return kurt\n\n    @staticmethod\n    def pdf(data, mu, sigma):\n        \"\"\"\n        Calculate the probability density function (PDF) of a set of data under a normal distribution.\n        :param data: The input data list, list.\n        :param mu: The mean of the normal distribution, float.\n        :param sigma: The standard deviation of the normal distribution, float.\n        :return: The probability density function (PDF), list.\n        \"\"\"\n        if sigma <= 0:\n            raise ValueError(\"Standard deviation must be positive.\")\n        \n        return [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n```",
    "28": "```python\nimport sqlite3\nfrom contextlib import closing\n\nclass DatabaseProcessor:\n    \"\"\"\n    A class for processing a SQLite database, supporting creating tables, inserting data,\n    searching for data by name, and deleting data from the database.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize the database processor with the specified database name.\n        \"\"\"\n        self.database_name = database_name\n\n    def __enter__(self):\n        \"\"\"Enable use of 'with' statement for automatic resource management.\"\"\"\n        self.connection = sqlite3.connect(self.database_name)\n        self.cursor = self.connection.cursor()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Ensure the database connection is closed properly.\"\"\"\n        self.close()\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table.\n        :param key2: str, the name of the second column in the table.\n        \"\"\"\n        self.cursor.execute(f\"\"\"\n            CREATE TABLE IF NOT EXISTS {table_name} (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                {key1} TEXT,\n                {key2} INTEGER\n            )\n        \"\"\")\n        self.connection.commit()\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        \"\"\"\n        if not data:\n            return\n\n        columns = data[0].keys()\n        placeholders = ', '.join('?' * len(columns))\n        self.cursor.executemany(f\"\"\"\n            INSERT INTO {table_name} ({', '.join(columns)})\n            VALUES ({placeholders})\n        \"\"\", [tuple(entry.values()) for entry in data])\n        self.connection.commit()\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list, a list of tuples representing the rows with matching name, or an empty list if none found.\n        \"\"\"\n        self.cursor.execute(f\"SELECT * FROM {table_name} WHERE name = ?\", (name,))\n        return self.cursor.fetchall() or []\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the name to match for deletion.\n        \"\"\"\n        self.cursor.execute(f\"DELETE FROM {table_name} WHERE name = ?\", (name,))\n        self.connection.commit()\n\n    def close(self):\n        \"\"\"Close the database connection.\"\"\"\n        if self.connection:\n            self.connection.close()\n```\n",
    "33": "```python\nclass DiscountStrategy:\n    \"\"\"\n    This class allows for different discount strategies based on shopping credit or shopping cart in a supermarket.\n    \"\"\"\n\n    def __init__(self, customer, cart, promotion=None):\n        \"\"\"\n        Initialize the DiscountStrategy with customer information, a cart of items, and an optional promotion.\n        :param customer: dict, customer information\n        :param cart: list of dicts, a cart of items with details\n        :param promotion: function, optional promotion applied to the order\n        \"\"\"\n        self.customer = customer\n        self.cart = cart\n        self.promotion = promotion\n\n    def total(self):\n        \"\"\"\n        Calculate the total cost of items in the cart.\n        :return: float, total cost of items\n        \"\"\"\n        return sum(item['quantity'] * item['price'] for item in self.cart)\n\n    def due(self):\n        \"\"\"\n        Calculate the final amount to be paid after applying the discount.\n        :return: float, final amount to be paid\n        \"\"\"\n        total_cost = self.total()\n        discount = self.promotion(self) if self.promotion else 0\n        return total_cost - discount\n\n    @staticmethod\n    def FidelityPromo(order):\n        \"\"\"\n        Calculate the discount based on the fidelity points of the customer. \n        Customers with over 1000 points can enjoy a 5% discount on the entire order.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        \"\"\"\n        return order.total() * 0.05 if order.customer.get('fidelity', 0) >= 1000 else 0.0\n\n    @staticmethod\n    def BulkItemPromo(order):\n        \"\"\"\n        Calculate the discount based on bulk item quantity in the order. \n        If the quantity of a single item reaches 20 or more, each item will enjoy a 10% discount.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        \"\"\"\n        return sum(item['quantity'] * item['price'] * 0.10 for item in order.cart if item['quantity'] >= 20)\n\n    @staticmethod\n    def LargeOrderPromo(order):\n        \"\"\"\n        Calculate the discount based on the number of different products in the order. \n        If the quantity of different products in the order reaches 10 or more, the entire order will enjoy a 7% discount.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        \"\"\"\n        return order.total() * 0.07 if len(order.cart) >= 10 else 0.0\n```",
    "32": "```python\nclass DecryptionUtils:\n    \"\"\"\n    This class provides methods for decryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the decryption utility with a key.\n        :param key: The key to use for decryption, str.\n        \"\"\"\n        self.key = key.lower()  # Normalize the key to lowercase for consistency\n\n    def caesar_decipher(self, ciphertext, shift):\n        \"\"\"\n        Deciphers the given ciphertext using the Caesar cipher.\n        :param ciphertext: The ciphertext to decipher, str.\n        :param shift: The shift to use for decryption, int.\n        :return: The deciphered plaintext, str.\n        >>> d = DecryptionUtils('key')\n        >>> d.caesar_decipher('ifmmp', 1)\n        'hello'\n        \"\"\"\n        plaintext = []\n        for char in ciphertext:\n            if char.isalpha():\n                base = ord('a') if char.islower() else ord('A')\n                new_char = chr((ord(char) - base - shift) % 26 + base)\n                plaintext.append(new_char)\n            else:\n                plaintext.append(char)\n        return ''.join(plaintext)\n\n    def vigenere_decipher(self, ciphertext):\n        \"\"\"\n        Deciphers the given ciphertext using the Vigenere cipher.\n        :param ciphertext: The ciphertext to decipher, str.\n        :return: The deciphered plaintext, str.\n        >>> d = DecryptionUtils('key')\n        >>> d.vigenere_decipher('ifmmp')\n        'hello'\n        \"\"\"\n        plaintext = []\n        key_length = len(self.key)\n        key_index = 0\n\n        for char in ciphertext:\n            if char.isalpha():\n                shift = (ord(self.key[key_index]) - ord('a')) % 26\n                base = ord('a') if char.islower() else ord('A')\n                new_char = chr((ord(char) - base - shift) % 26 + base)\n                plaintext.append(new_char)\n                key_index = (key_index + 1) % key_length  # Only increment for letters\n            else:\n                plaintext.append(char)\n        return ''.join(plaintext)\n\n    def rail_fence_decipher(self, encrypted_text, rails):\n        \"\"\"\n        Deciphers the given ciphertext using the Rail Fence cipher.\n        :param encrypted_text: The ciphertext to decipher, str.\n        :param rails: The number of rails to use for decryption, int.\n        :return: The deciphered plaintext, str.\n        >>> d = DecryptionUtils('key')\n        >>> d.rail_fence_decipher('Hoo!el,Wrdl l', 3)\n        'Hello, World!'\n        \"\"\"\n        if rails <= 0:\n            raise ValueError(\"Number of rails must be greater than 0\")\n\n        length = len(encrypted_text)\n        rail = [['' for _ in range(length)] for _ in range(rails)]\n        dir_down = False\n        row, col = 0, 0\n\n        for i in range(length):\n            if row == 0 or row == rails - 1:\n                dir_down = not dir_down\n            rail[row][col] = encrypted_text[i]\n            col += 1\n            row += 1 if dir_down else -1\n\n        result = []\n        for i in range(rails):\n            for j in range(length):\n                if rail[i][j] != '':\n                    result.append(rail[i][j])\n\n        return ''.join(result)\n```",
    "35": "```python\nclass EightPuzzle:\n    \"\"\"\n    This class is an implementation of the classic 8-puzzle game, including methods for finding the blank tile, \n    making moves, getting possible moves, and solving the puzzle using a breadth-first search algorithm.\n    \"\"\"\n\n    def __init__(self, initial_state):\n        \"\"\"\n        Initialize the initial state of the Eight Puzzle Game, stored in attribute self.initial_state.\n        Set the goal state of this game, stored in self.goal_state.\n        \n        :param initial_state: a 3x3 list of integers representing the initial state\n        \"\"\"\n        self.initial_state = initial_state\n        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n    def find_blank(self, state):\n        \"\"\"\n        Find the blank position (0) in the current state.\n        \n        :param state: a 3x3 list of integers representing the current state\n        :return: tuple (i, j) representing the coordinates of the blank tile\n        \"\"\"\n        for i in range(3):\n            for j in range(3):\n                if state[i][j] == 0:\n                    return i, j\n\n    def move(self, state, direction):\n        \"\"\"\n        Move the blank tile in the specified direction.\n        \n        :param state: a 3x3 list of integers representing the current state\n        :param direction: str, direction to move ('up', 'down', 'left', 'right')\n        :return: new_state: a 3x3 list of integers representing the state after moving\n        \"\"\"\n        i, j = self.find_blank(state)\n        new_state = [row[:] for row in state]  # Create a copy of the state\n        \n        if direction == 'up' and i > 0:\n            new_state[i][j], new_state[i - 1][j] = new_state[i - 1][j], new_state[i][j]\n        elif direction == 'down' and i < 2:\n            new_state[i][j], new_state[i + 1][j] = new_state[i + 1][j], new_state[i][j]\n        elif direction == 'left' and j > 0:\n            new_state[i][j], new_state[i][j - 1] = new_state[i][j - 1], new_state[i][j]\n        elif direction == 'right' and j < 2:\n            new_state[i][j], new_state[i][j + 1] = new_state[i][j + 1], new_state[i][j]\n        \n        return new_state\n\n    def get_possible_moves(self, state):\n        \"\"\"\n        Get all possible moves from the current state.\n        \n        :param state: a 3x3 list of integers representing the current state\n        :return: list of str representing possible moving directions\n        \"\"\"\n        moves = []\n        i, j = self.find_blank(state)\n\n        if i > 0: moves.append('up')\n        if i < 2: moves.append('down')\n        if j > 0: moves.append('left')\n        if j < 2: moves.append('right')\n        \n        return moves\n\n    def solve(self):\n        \"\"\"\n        Use BFS algorithm to find the path solution from the initial state to the goal state.\n        \n        :return: list of str representing the solution path to the goal state\n        \"\"\"\n        from collections import deque\n\n        open_list = deque([(self.initial_state, [])])\n        visited = set()\n        visited.add(tuple(map(tuple, self.initial_state)))\n\n        while open_list:\n            current_state, path = open_list.popleft()\n\n            if current_state == self.goal_state:\n                return path\n\n            possible_moves = self.get_possible_moves(current_state)\n            for move_direction in possible_moves:\n                new_state = self.move(current_state, move_direction)\n                state_tuple = tuple(map(tuple, new_state))\n\n                if state_tuple not in visited:\n                    visited.add(state_tuple)\n                    open_list.append((new_state, path + [move_direction]))\n\n        return []\n```",
    "34": "```python\nfrom docx import Document\nfrom docx.shared import Pt\nfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENT\nimport os\n\nclass DocFileHandler:\n    \"\"\"\n    This class handles Word documents and provides functionalities for reading, writing, and modifying the content of Word documents.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initializes the DocFileHandler object with the specified file path.\n        :param file_path: str, the path to the Word document file.\n        \"\"\"\n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f\"The file {file_path} does not exist.\")\n        self.file_path = file_path\n        self.document = Document(file_path)\n\n    def read_text(self):\n        \"\"\"\n        Reads the content of a Word document and returns it as a string.\n        :return: str, the content of the Word document.\n        \"\"\"\n        return '\\n'.join(paragraph.text for paragraph in self.document.paragraphs)\n\n    def write_text(self, content, font_size=12, alignment='left'):\n        \"\"\"\n        Writes the specified content to a Word document.\n        :param content: str, the text content to write.\n        :param font_size: int, optional, the font size of the text (default is 12).\n        :param alignment: str, optional, the alignment of the text ('left', 'center', or 'right'; default is 'left').\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n        try:\n            paragraph = self.document.add_paragraph(content)\n            run = paragraph.runs[0]\n            run.font.size = Pt(font_size)\n            paragraph.alignment = self._get_alignment_value(alignment)\n            return True\n        except Exception as e:\n            print(f\"Error writing text: {e}\")\n            return False\n\n    def add_heading(self, heading, level=1):\n        \"\"\"\n        Adds a heading to the Word document.\n        :param heading: str, the text of the heading.\n        :param level: int, optional, the level of the heading (1, 2, 3, etc.; default is 1).\n        :return: bool, True if the heading is successfully added, False otherwise.\n        \"\"\"\n        try:\n            self.document.add_heading(heading, level=level)\n            return True\n        except Exception as e:\n            print(f\"Error adding heading: {e}\")\n            return False\n\n    def add_table(self, data):\n        \"\"\"\n        Adds a table to the Word document with the specified data.\n        :param data: list of lists, the data to populate the table.\n        :return: bool, True if the table is successfully added, False otherwise.\n        \"\"\"\n        if not data or not all(isinstance(row, list) for row in data):\n            print(\"Invalid data format for table. Must be a list of lists.\")\n            return False\n\n        try:\n            table = self.document.add_table(rows=len(data), cols=len(data[0]))\n            for row_idx, row in enumerate(data):\n                for col_idx, cell_data in enumerate(row):\n                    table.cell(row_idx, col_idx).text = str(cell_data)\n            return True\n        except Exception as e:\n            print(f\"Error adding table: {e}\")\n            return False\n\n    def _get_alignment_value(self, alignment):\n        \"\"\"\n        Returns the alignment value corresponding to the given alignment string.\n        :param alignment: str, the alignment string ('left', 'center', or 'right').\n        :return: int, the alignment value.\n        \"\"\"\n        alignment_map = {\n            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,\n            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT,\n            'left': WD_PARAGRAPH_ALIGNMENT.LEFT\n        }\n        return alignment_map.get(alignment, WD_PARAGRAPH_ALIGNMENT.LEFT)\n\n    def save(self):\n        \"\"\"\n        Saves the document to the specified file path.\n        \"\"\"\n        try:\n            self.document.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error saving document: {e}\")\n            return False\n```",
    "36": "```python\nfrom datetime import datetime\n\nclass EmailClient:\n    \"\"\"\n    This is a class that serves as an email client, implementing functions such as checking emails, determining whether there is sufficient space, and cleaning up space.\n    \"\"\"\n\n    def __init__(self, addr: str, capacity: float) -> None:\n        \"\"\"\n        Initializes the EmailClient class with the email address and the capacity of the email box.\n        :param addr: The email address, str.\n        :param capacity: The capacity of the email box, float.\n        \"\"\"\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox = []\n\n    def send_to(self, recv, content: str, size: float) -> bool:\n        \"\"\"\n        Sends an email to the given email address.\n        :param recv: The email address of the receiver, EmailClient instance.\n        :param content: The content of the email, str.\n        :param size: The size of the email, float.\n        :return: True if the email is sent successfully, False if the receiver's email box is full.\n        \"\"\"\n        if recv.is_full_with_one_more_email(size):\n            return False\n        \n        email = {\n            'sender': self.addr,\n            'receiver': recv.addr,\n            'content': content,\n            'size': size,\n            'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n            'state': 'unread'\n        }\n        recv.inbox.append(email)\n        return True\n\n    def fetch(self) -> dict:\n        \"\"\"\n        Retrieves the first unread email in the email box and marks it as read.\n        :return: The first unread email in the email box, dict or None if no unread emails exist.\n        \"\"\"\n        for email in self.inbox:\n            if email['state'] == 'unread':\n                email['state'] = 'read'\n                return email\n        return None\n\n    def is_full_with_one_more_email(self, size: float) -> bool:\n        \"\"\"\n        Determines whether the email box is full after adding an email of the given size.\n        :param size: The size of the email, float.\n        :return: True if the email box is full, False otherwise.\n        \"\"\"\n        return self.get_occupied_size() + size > self.capacity\n\n    def get_occupied_size(self) -> float:\n        \"\"\"\n        Gets the total size of the emails in the email box.\n        :return: The total size of the emails in the email box, float.\n        \"\"\"\n        return sum(email['size'] for email in self.inbox)\n\n    def clear_inbox(self, size: float) -> None:\n        \"\"\"\n        Clears the email box by deleting the oldest emails until the email box has enough space to accommodate the given size.\n        :param size: The size of the email, float.\n        \"\"\"\n        while self.is_full_with_one_more_email(size):\n            if self.inbox:\n                self.inbox.pop(0)\n            else:\n                break\n```",
    "38": "```python\nimport openpyxl\n\n\nclass ExcelProcessor:\n    \"\"\"\n    A class for processing Excel files, including reading, writing, and modifying Excel data.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_excel(self, file_name):\n        \"\"\"\n        Read data from an Excel file.\n        \n        :param file_name: str, path to the Excel file to read.\n        :return: list of tuples, data from the Excel file.\n        \"\"\"\n        try:\n            wb = openpyxl.load_workbook(file_name)\n            sheet = wb.active\n            data = [row for row in sheet.iter_rows(values_only=True)]\n            return data\n        except FileNotFoundError:\n            print(f\"Error: The file '{file_name}' was not found.\")\n            return []\n        except Exception as e:\n            print(f\"An error occurred while reading the file: {e}\")\n            return []\n\n    def write_excel(self, data, file_name):\n        \"\"\"\n        Write data to an Excel file.\n        \n        :param data: list of tuples, data to write to the Excel file.\n        :param file_name: str, path to the Excel file to write to.\n        :return: bool, True if writing was successful, False otherwise.\n        \"\"\"\n        try:\n            wb = openpyxl.Workbook()\n            sheet = wb.active\n            for row in data:\n                sheet.append(row)\n            wb.save(file_name)\n            return True\n        except Exception as e:\n            print(f\"Error writing to file: {e}\")\n            return False\n\n    def process_excel_data(self, N, source_file_name):\n        \"\"\"\n        Modify a specified column in the Excel file to uppercase.\n        \n        :param N: int, the index of the column to change (0-based).\n        :param source_file_name: str, path to the source Excel file.\n        :return: (bool, str), True if processing was successful, along with the name of the saved file.\n        \"\"\"\n        data = self.read_excel(source_file_name)\n        if not data:\n            return False, source_file_name\n        \n        modified_data = []\n        for row in data:\n            modified_row = list(row)\n            if N < len(modified_row):\n                modified_row[N] = str(modified_row[N]).upper()\n            modified_data.append(tuple(modified_row))\n        \n        output_file_name = f\"processed_{source_file_name}\"\n        success = self.write_excel(modified_data, output_file_name)\n        return success, output_file_name\n```",
    "37": "```python\nclass EncryptionUtils:\n    \"\"\"\n    This is a class that provides methods for encryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the class with a key.\n        :param key: The key to use for encryption, str.\n        \"\"\"\n        if not isinstance(key, str) or not key.isalpha():\n            raise ValueError(\"Key must be a string containing only alphabetic characters.\")\n        self.key = key\n\n    def caesar_cipher(self, plaintext, shift):\n        \"\"\"\n        Encrypts the plaintext using the Caesar cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :param shift: The number of characters to shift each character in the plaintext, int.\n        :return: The ciphertext, str.\n        \"\"\"\n        if not isinstance(shift, int):\n            raise ValueError(\"Shift must be an integer.\")\n        \n        ciphertext = ''\n        for char in plaintext:\n            if char.isalpha():\n                shift_base = ord('a') if char.islower() else ord('A')\n                shifted_char = chr((ord(char) - shift_base + shift) % 26 + shift_base)\n                ciphertext += shifted_char\n            else:\n                ciphertext += char\n        return ciphertext\n\n    def vigenere_cipher(self, plaintext):\n        \"\"\"\n        Encrypts the plaintext using the Vigenere cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :return: The ciphertext, str.\n        \"\"\"\n        ciphertext = ''\n        key_length = len(self.key)\n        key_index = 0\n\n        for char in plaintext:\n            if char.isalpha():\n                shift_base = ord('a') if char.islower() else ord('A')\n                key_char = self.key[key_index % key_length].lower()\n                key_shift = ord(key_char) - ord('a')\n                shifted_char = chr((ord(char) - shift_base + key_shift) % 26 + shift_base)\n                ciphertext += shifted_char\n                \n                key_index += 1  # Only increment key_index for alphabetic characters\n            else:\n                ciphertext += char\n        return ciphertext\n\n    def rail_fence_cipher(self, plaintext, rails):\n        \"\"\"\n        Encrypts the plaintext using the Rail Fence cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :param rails: The number of rails for the Rail Fence cipher, int.\n        :return: The ciphertext, str.\n        \"\"\"\n        if not isinstance(rails, int) or rails <= 0:\n            raise ValueError(\"Rails must be a positive integer.\")\n\n        rail = [['\\n' for _ in range(len(plaintext))] for _ in range(rails)]\n        row, col = 0, 0\n        dir_down = True\n\n        for char in plaintext:\n            if row == 0:\n                dir_down = True\n            if row == rails - 1:\n                dir_down = False\n\n            rail[row][col] = char\n            col += 1\n\n            if dir_down:\n                row += 1\n            else:\n                row -= 1\n\n        ciphertext = ''.join([''.join(r) for r in rail]).replace('\\n', '')\n        return ciphertext\n```",
    "40": "```python\nclass FitnessTracker:\n    \"\"\"\n    A fitness tracker class that calculates BMI (Body Mass Index) and calorie intake based on the user's height, weight, age, and sex.\n    \"\"\"\n\n    BMI_STANDARD = {\n        \"male\": (20, 25),\n        \"female\": (19, 24)\n    }\n\n    def __init__(self, height: float, weight: float, age: int, sex: str) -> None:\n        \"\"\"\n        Initialize the class with height, weight, age, and sex.\n        \"\"\"\n        self.height = height\n        self.weight = weight\n        self.age = age\n        self.sex = sex.lower()\n        if self.sex not in self.BMI_STANDARD:\n            raise ValueError(\"Sex must be 'male' or 'female'.\")\n\n    def get_BMI(self) -> float:\n        \"\"\"\n        Calculate the BMI based on height and weight.\n        :return: BMI as a float.\n        \"\"\"\n        return self.weight / (self.height ** 2)\n\n    def condition_judge(self) -> int:\n        \"\"\"\n        Judge the user's condition based on BMI standards.\n        :return: 1 if overweight, -1 if underweight, 0 if normal.\n        \"\"\"\n        bmi = self.get_BMI()\n        lower_bound, upper_bound = self.BMI_STANDARD[self.sex]\n        if bmi < lower_bound:\n            return -1\n        elif bmi > upper_bound:\n            return 1\n        return 0\n\n    def calculate_calorie_intake(self) -> float:\n        \"\"\"\n        Calculate the calorie intake based on the user's condition and BMR (Basal Metabolic Rate).\n        :return: Calorie intake as a float.\n        \"\"\"\n        if self.sex == \"male\":\n            bmr = 10 * self.weight + 6.25 * self.height * 100 - 5 * self.age + 5\n        else:\n            bmr = 10 * self.weight + 6.25 * self.height * 100 - 5 * self.age - 161\n        \n        condition = self.condition_judge()\n        if condition == 1:  # overweight\n            calorie_intake = bmr * 1.2\n        elif condition == -1:  # underweight\n            calorie_intake = bmr * 1.6\n        else:  # normal\n            calorie_intake = bmr * 1.4\n        \n        return calorie_intake\n```",
    "39": "```python\nfrom collections import deque\nfrom decimal import Decimal\n\nclass ExpressionCalculator:\n    \"\"\"\n    This class performs calculations with basic arithmetic operations,\n    including addition, subtraction, multiplication, division, and modulo.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the expression calculator.\n        \"\"\"\n        self.postfix_stack = deque()\n        self.operator_priority = {'+': 1, '-': 1, '*': 2, '/': 2, '%': 2}\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the result of the given postfix expression.\n        :param expression: string, the postfix expression to be calculated\n        :return: float, the calculated result\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.calculate(\"2 3 4 * +\")\n        14.0\n        \"\"\"\n        stack = []\n        tokens = expression.split()\n        for token in tokens:\n            if self.is_number(token):\n                stack.append(Decimal(token))\n            elif self.is_operator(token):\n                second_value = stack.pop()\n                first_value = stack.pop()\n                result = self._calculate(first_value, second_value, token)\n                stack.append(result)\n            else:\n                raise ValueError(f\"Invalid token: {token}\")\n        return float(stack.pop())\n\n    def prepare(self, expression):\n        \"\"\"\n        Prepare the infix expression for conversion to postfix notation.\n        :param expression: string, the infix expression to be prepared\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.prepare(\"2 + 3 * 4\")\n        expression_calculator.postfix_stack = ['2', '3', '4', '*', '+']\n        \"\"\"\n        output = []\n        operator_stack = []\n        tokens = self.transform(expression).split()\n\n        for token in tokens:\n            if self.is_number(token):\n                output.append(token)\n            elif self.is_operator(token):\n                while (operator_stack and operator_stack[-1] in self.operator_priority and\n                       self.compare(token, operator_stack[-1])):\n                    output.append(operator_stack.pop())\n                operator_stack.append(token)\n            else:\n                raise ValueError(f\"Invalid token: {token}\")\n\n        while operator_stack:\n            output.append(operator_stack.pop())\n\n        self.postfix_stack = output\n\n    @staticmethod\n    def is_operator(c):\n        \"\"\"\n        Check if a character is an operator in {'+', '-', '*', '/', '%'}.\n        :param c: string, the character to be checked\n        :return: bool, True if the character is an operator, False otherwise\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.is_operator(\"+\")\n        True\n        \"\"\"\n        return c in {'+', '-', '*', '/', '%'}\n\n    @staticmethod\n    def is_number(c):\n        \"\"\"\n        Check if the token is a number.\n        :param c: string, the token to be checked\n        :return: bool, True if the token is a number, False otherwise\n        \"\"\"\n        try:\n            Decimal(c)\n            return True\n        except (ValueError, InvalidOperation):\n            return False\n\n    def compare(self, cur, peek):\n        \"\"\"\n        Compare the precedence of two operators.\n        :param cur: string, the current operator\n        :param peek: string, the operator at the top of the operator stack\n        :return: bool, True if the current operator has higher or equal precedence, False otherwise\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.compare(\"+\", \"-\")\n        True\n        \"\"\"\n        return self.operator_priority[cur] <= self.operator_priority[peek]\n\n    @staticmethod\n    def _calculate(first_value, second_value, current_op):\n        \"\"\"\n        Perform the mathematical calculation based on the given operands and operator.\n        :param first_value: decimal.Decimal, the first operand\n        :param second_value: decimal.Decimal, the second operand\n        :param current_op: string, the operator\n        :return: decimal.Decimal, the calculated result\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator._calculate(Decimal(\"2\"), Decimal(\"3\"), \"+\")\n        Decimal('5')\n        \"\"\"\n        if current_op == '+':\n            return first_value + second_value\n        elif current_op == '-':\n            return first_value - second_value\n        elif current_op == '*':\n            return first_value * second_value\n        elif current_op == '/':\n            if second_value == 0:\n                raise ZeroDivisionError(\"Division by zero is undefined.\")\n            return first_value / second_value\n        elif current_op == '%':\n            return first_value % second_value\n        else:\n            raise ValueError(f\"Invalid operator: {current_op}\")\n\n    @staticmethod\n    def transform(expression):\n        \"\"\"\n        Transform the infix expression to a format suitable for conversion.\n        :param expression: string, the infix expression to be transformed\n        :return: string, the transformed expression\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.transform(\"2 + 3 * 4\")\n        \"2+3*4\"\n        \"\"\"\n        return ''.join(expression.split())\n```",
    "44": "```python\nimport re\nfrom bs4 import BeautifulSoup\n\nclass HtmlUtil:\n    \"\"\"\n    A utility class for formatting and extracting code from HTML text.\n    It includes methods for cleaning up the text and converting certain elements into specific markers.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a series of markers.\n        \"\"\"\n        self.SPACE_MARK = '-SPACE-'\n        self.JSON_MARK = '-JSON-'\n        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'\n        self.URL_MARK = '-URL-'\n        self.NUMBER_MARK = '-NUMBER-'\n        self.TRACE_MARK = '-TRACE-'\n        self.COMMAND_MARK = '-COMMAND-'\n        self.COMMENT_MARK = '-COMMENT-'\n        self.CODE_MARK = '-CODE-'\n\n    @staticmethod\n    def __format_line_feed(text):\n        \"\"\"\n        Replace consecutive line breaks with a single line break and strip leading/trailing whitespace.\n        \n        :param text: string with consecutive line breaks\n        :return: string, replaced text with single line break\n        \"\"\"\n        return re.sub(r'\\n+', '\\n', text).strip()\n\n    def format_line_html_text(self, html_text):\n        \"\"\"\n        Get the HTML text without the code, adding the CODE_MARK where the code is.\n        \n        :param html_text: string\n        :return: formatted string with -CODE- markers\n        \"\"\"\n        soup = BeautifulSoup(html_text, 'html.parser')\n        \n        for code in soup.find_all(['pre', 'code']):\n            code.insert_before(self.CODE_MARK)\n            code.insert_after(self.CODE_MARK)\n            code.unwrap()\n        \n        formatted_text = soup.get_text(separator='\\n')\n        return self.__format_line_feed(formatted_text)\n\n    def extract_code_from_html_text(self, html_text):\n        \"\"\"\n        Extract codes from the HTML body.\n        \n        :param html_text: string, HTML text\n        :return: list of extracted code snippets\n        \"\"\"\n        soup = BeautifulSoup(html_text, 'html.parser')\n        codes = [code.get_text(strip=True) for code in soup.find_all(['pre', 'code'])]\n        return codes\n``` \n\n### Improvements made:\n1. **Documentation**: Improved docstrings for clarity and added parameter and return type descriptions.\n2. **Static Method**: Kept `__format_line_feed` as a static method since it doesn't depend on instance variables.\n3. **Code Formatting**: Cleaned up formatting and removed unnecessary comments.\n4. **List Comprehension in Code Extraction**: Added `strip=True` to `get_text()` to remove leading/trailing whitespace from extracted code snippets.\n5. **Removed Unused Imports**: Removed the import of `string` and `gensim` as they were not being used.",
    "43": "```python\nclass HRManagementSystem:\n    \"\"\"\n    A personnel management system that implements functions for adding, deleting, querying, and updating employees.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the HRManagementSystem with an attribute employees, which is an empty dictionary.\n        \"\"\"\n        self.employees = {}\n\n    def add_employee(self, employee_id: int, name: str, position: str, department: str, salary: float) -> bool:\n        \"\"\"\n        Add a new employee to the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :param name: The employee's name, str.\n        :param position: The employee's position, str.\n        :param department: The employee's department, str.\n        :param salary: The employee's salary, float.\n        :return: If the employee is already in the HRManagementSystem, returns False, otherwise, returns True.\n        \"\"\"\n        if employee_id in self.employees:\n            return False\n        self.employees[employee_id] = {\n            'name': name,\n            'position': position,\n            'department': department,\n            'salary': salary\n        }\n        return True\n\n    def remove_employee(self, employee_id: int) -> bool:\n        \"\"\"\n        Remove an employee from the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :return: If the employee exists, returns True, otherwise, returns False.\n        \"\"\"\n        return self.employees.pop(employee_id, None) is not None\n\n    def update_employee(self, employee_id: int, employee_info: dict) -> bool:\n        \"\"\"\n        Update an employee's information in the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :param employee_info: The employee's information, dict.\n        :return: If the employee exists, returns True, otherwise, returns False.\n        \"\"\"\n        if employee_id in self.employees:\n            self.employees[employee_id].update(employee_info)\n            return True\n        return False\n\n    def get_employee(self, employee_id: int) -> dict:\n        \"\"\"\n        Get an employee's information from the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :return: The employee's information if exists, otherwise None.\n        \"\"\"\n        return self.employees.get(employee_id)\n\n    def list_employees(self) -> dict:\n        \"\"\"\n        List all employees' information in the HRManagementSystem.\n        :return: A dictionary of all employees' information.\n        \"\"\"\n        return {employee_id: {'employee_ID': employee_id, **info} for employee_id, info in self.employees.items()}\n```",
    "47": "```python\nclass IPAddress:\n    \"\"\"\n    This is a class to process IP Address, including validating, getting the octets, and obtaining the binary representation of a valid IP address.\n    \"\"\"\n\n    def __init__(self, ip_address):\n        \"\"\"\n        Initialize the IP address to the specified address\n        :param ip_address: str\n        \"\"\"\n        self.ip_address = ip_address\n\n    def is_valid(self):\n        \"\"\"\n        Judge whether the IP address is valid, that is, whether the IP address is composed of four decimal digits separated by '.'. \n        Each digit is greater than or equal to 0 and less than or equal to 255.\n        \n        :return: bool\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.is_valid()\n        True\n        >>> ipaddress = IPAddress(\"256.100.50.25\")\n        >>> ipaddress.is_valid()\n        False\n        \"\"\"\n        octets = self.ip_address.split('.')\n        if len(octets) != 4:\n            return False\n        for octet in octets:\n            if not octet.isdigit() or not (0 <= int(octet) <= 255):\n                return False\n        return True\n\n    def get_octets(self):\n        \"\"\"\n        If the IP address is valid, the list of four decimal numbers separated by \".\" constituting the IP address is returned; \n        otherwise, an empty list is returned.\n        \n        :return: list\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.get_octets()\n        ['10', '10', '10', '10']\n        >>> ipaddress = IPAddress(\"256.100.50.25\")\n        >>> ipaddress.get_octets()\n        []\n        \"\"\"\n        return self.ip_address.split('.') if self.is_valid() else []\n\n    def get_binary(self):\n        \"\"\"\n        If the IP address is valid, return the binary form of the IP address; otherwise, return an empty string.\n        \n        :return: str\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.get_binary()\n        '00001010.00001010.00001010.00001010'\n        >>> ipaddress = IPAddress(\"256.100.50.25\")\n        >>> ipaddress.get_binary()\n        ''\n        \"\"\"\n        if self.is_valid():\n            return '.'.join(format(int(octet), '08b') for octet in self.get_octets())\n        return ''\n```",
    "48": "```python\nimport socket\nimport re\n\n\nclass IpUtil:\n    \"\"\"\n    A utility class for IP address operations, including validation, hostname retrieval, and obtaining local IP addresses.\n    \"\"\"\n\n    @staticmethod\n    def is_valid_ipv4(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv4 address.\n        :param ip_address: string, the IP address to check\n        :return: bool, True if the IP address is valid, False otherwise\n        >>> IpUtil.is_valid_ipv4('192.168.0.123')\n        True\n        >>> IpUtil.is_valid_ipv4('256.0.0.0')\n        False\n        \"\"\"\n        pattern = re.compile(r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$')\n        return bool(pattern.match(ip_address))\n\n    @staticmethod\n    def is_valid_ipv6(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv6 address.\n        :param ip_address: string, the IP address to check\n        :return: bool, True if the IP address is valid, False otherwise\n        >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:0000:0000:8a2e:0370:7334')\n        True\n        >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:::8a2e:0370:7334')\n        False\n        \"\"\"\n        try:\n            socket.inet_pton(socket.AF_INET6, ip_address)\n            return True\n        except socket.error:\n            return False\n\n    @staticmethod\n    def get_hostname(ip_address):\n        \"\"\"\n        Get the hostname associated with the given IP address.\n        :param ip_address: string, the IP address to get the hostname for\n        :return: string or None, the hostname associated with the IP address, or None if not resolvable\n        >>> IpUtil.get_hostname('110.242.68.3')\n        'www.baidu.com'  # Output may vary based on DNS\n        >>> IpUtil.get_hostname('10.0.0.1')\n        None\n        \"\"\"\n        try:\n            return socket.gethostbyaddr(ip_address)[0]\n        except (socket.herror, socket.gaierror):\n            return None\n\n    @staticmethod\n    def get_local_ip():\n        \"\"\"\n        Retrieve the local IP address of the machine.\n        :return: string, the local IP address\n        \"\"\"\n        try:\n            hostname = socket.gethostname()\n            local_ip = socket.gethostbyname(hostname)\n            return local_ip\n        except socket.error:\n            return None\n```",
    "45": "```python\nfrom PIL import Image, ImageEnhance\nimport os\n\nclass ImageProcessor:\n    \"\"\"\n    A class to process images, including loading, saving, resizing,\n    rotating, and adjusting the brightness of images.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize self.image to None.\n        \"\"\"\n        self.image = None\n\n    def load_image(self, image_path):\n        \"\"\"\n        Load an image from the specified path.\n        :param image_path: str, path of the image to be loaded.\n        :raises FileNotFoundError: If the image file does not exist.\n        :raises IOError: If the image cannot be opened.\n        \"\"\"\n        if not os.path.isfile(image_path):\n            raise FileNotFoundError(f\"The file {image_path} does not exist.\")\n        \n        try:\n            self.image = Image.open(image_path)\n        except IOError as e:\n            raise IOError(f\"Unable to open image file {image_path}: {e}\")\n\n    def save_image(self, save_path):\n        \"\"\"\n        Save the loaded image to the specified path.\n        :param save_path: str, path where the image will be saved.\n        :raises ValueError: If there is no image to save.\n        \"\"\"\n        if self.image is None:\n            raise ValueError(\"No image loaded. Please load an image before saving.\")\n        \n        self.image.save(save_path)\n\n    def resize_image(self, width, height):\n        \"\"\"\n        Resize the loaded image to the specified width and height.\n        :param width: int, target width of the image.\n        :param height: int, target height of the image.\n        :raises ValueError: If there is no image loaded.\n        \"\"\"\n        if self.image is None:\n            raise ValueError(\"No image loaded. Please load an image before resizing.\")\n        \n        self.image = self.image.resize((width, height))\n\n    def rotate_image(self, degrees):\n        \"\"\"\n        Rotate the loaded image by the specified degrees.\n        :param degrees: float, degrees to rotate the image.\n        :raises ValueError: If there is no image loaded.\n        \"\"\"\n        if self.image is None:\n            raise ValueError(\"No image loaded. Please load an image before rotating.\")\n        \n        self.image = self.image.rotate(degrees)\n\n    def adjust_brightness(self, factor):\n        \"\"\"\n        Adjust the brightness of the loaded image.\n        :param factor: float, brightness factor (0.0 for black, 1.0 for original).\n        :raises ValueError: If there is no image loaded.\n        \"\"\"\n        if self.image is None:\n            raise ValueError(\"No image loaded. Please load an image before adjusting brightness.\")\n        \n        enhancer = ImageEnhance.Brightness(self.image)\n        self.image = enhancer.enhance(factor)\n```",
    "46": "```python\nimport numpy as np\nfrom scipy.interpolate import griddata\n\nclass Interpolation:\n    \"\"\"\n    This class implements linear interpolation for one-dimensional and two-dimensional data.\n    \"\"\"\n\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        \"\"\"\n        Linear interpolation of one-dimensional data.\n\n        :param x: The x-coordinates of the data points, list or array-like.\n        :param y: The y-coordinates of the data points, list or array-like.\n        :param x_interp: The x-coordinates of the interpolation points, list or array-like.\n        :return: The y-coordinates of the interpolation points, list.\n        \"\"\"\n        if len(x) != len(y):\n            raise ValueError(\"x and y must be of the same length.\")\n        if not np.all(np.diff(x) > 0):\n            raise ValueError(\"x values must be in strictly increasing order.\")\n        \n        return list(np.interp(x_interp, x, y))\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        \"\"\"\n        Linear interpolation of two-dimensional data.\n\n        :param x: The x-coordinates of the data points, list or array-like.\n        :param y: The y-coordinates of the data points, list or array-like.\n        :param z: The z-coordinates of the data points, 2D list or array-like.\n        :param x_interp: The x-coordinates of the interpolation points, list or array-like.\n        :param y_interp: The y-coordinates of the interpolation points, list or array-like.\n        :return: The z-coordinates of the interpolation points, list.\n        \"\"\"\n        if len(x) != len(y) or len(y) != len(z):\n            raise ValueError(\"x, y, and z must be of compatible dimensions.\")\n        if not np.all(np.diff(x) > 0) or not np.all(np.diff(y) > 0):\n            raise ValueError(\"x and y values must be in strictly increasing order.\")\n        \n        points = np.array(list(zip(x, y)))\n        z_flat = np.array(z).flatten()\n        grid_x, grid_y = np.meshgrid(x, y)\n        \n        return list(griddata(points, z_flat, (x_interp, y_interp), method='linear'))\n```",
    "41": "```python\nclass GomokuGame:\n    \"\"\"\n    This class implements a Gomoku game, supporting moves, winner checking,\n    and verifying five consecutive symbols on the game board.\n    \"\"\"\n\n    def __init__(self, board_size):\n        \"\"\"\n        Initializes the game with a given board size.\n        The board is initialized with empty spaces, and the current player symbol is set to 'X'.\n        \"\"\"\n        self.board_size = board_size\n        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]\n        self.current_player = 'X'\n        self.move_count = 0\n\n    def make_move(self, row, col):\n        \"\"\"\n        Makes a move at the given row and column.\n        If the move is valid, it places the current player's symbol on the board\n        and switches the current player.\n        :param row: int, the row index of this move\n        :param col: int, the column index\n        :return: True if the move is valid, or False otherwise.\n        \"\"\"\n        if self._is_valid_move(row, col):\n            self.board[row][col] = self.current_player\n            self.move_count += 1\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        return False\n\n    def _is_valid_move(self, row, col):\n        \"\"\"\n        Validates the move by checking if the cell is within bounds and empty.\n        :param row: int, the row index\n        :param col: int, the column index\n        :return: True if the move is valid, otherwise False.\n        \"\"\"\n        return 0 <= row < self.board_size and 0 <= col < self.board_size and self.board[row][col] == ' '\n\n    def check_winner(self):\n        \"\"\"\n        Checks if there is a winner by searching for five in a row in all directions.\n        :return: the symbol of the winning player ('X' or 'O') if there is a winner, or None otherwise.\n        \"\"\"\n        for row in range(self.board_size):\n            for col in range(self.board_size):\n                if self.board[row][col] != ' ':\n                    if (self._check_five_in_a_row(row, col, (0, 1)) or  # Horizontal\n                        self._check_five_in_a_row(row, col, (1, 0)) or  # Vertical\n                        self._check_five_in_a_row(row, col, (1, 1)) or  # Diagonal /\n                        self._check_five_in_a_row(row, col, (1, -1))):  # Diagonal \\\n                        return self.board[row][col]\n        return None\n\n    def _check_five_in_a_row(self, row, col, direction):\n        \"\"\"\n        Checks for five consecutive symbols from a given cell in a specified direction.\n        :param row: int, row of the given cell\n        :param col: int, column of the given cell\n        :param direction: tuple, (dx, dy). Direction to check for consecutive symbols.\n        :return: True if five consecutive symbols are found, otherwise False.\n        \"\"\"\n        dx, dy = direction\n        count = 0\n        player_symbol = self.board[row][col]\n\n        for i in range(5):\n            new_row = row + i * dx\n            new_col = col + i * dy\n            if 0 <= new_row < self.board_size and 0 <= new_col < self.board_size:\n                if self.board[new_row][new_col] == player_symbol:\n                    count += 1\n                else:\n                    break\n            else:\n                break\n\n        return count == 5\n```",
    "42": "```python\nclass Hotel:\n    \"\"\"\n    This class represents a hotel management system, managing the booking, check-in, check-out, and availability of rooms in a hotel with different room types.\n    \"\"\"\n\n    def __init__(self, name, rooms):\n        \"\"\"\n        Initialize the hotel management system.\n        :param name: str, the hotel name.\n        :param rooms: dict, available rooms by type.\n        \"\"\"\n        self.name = name\n        self.available_rooms = rooms\n        self.booked_rooms = {}\n\n    def book_room(self, room_type, room_number, name):\n        \"\"\"\n        Book rooms of a specified type if available.\n        :param room_type: str, type of room to book.\n        :param room_number: int, number of rooms to book.\n        :param name: str, guest name.\n        :return: str or int or bool, result of the booking attempt.\n        \"\"\"\n        if room_type not in self.available_rooms:\n            return False\n\n        if self.available_rooms[room_type] >= room_number:\n            self.available_rooms[room_type] -= room_number\n            if room_type not in self.booked_rooms:\n                self.booked_rooms[room_type] = {}\n            self.booked_rooms[room_type][name] = self.booked_rooms[room_type].get(name, 0) + room_number\n            return 'Success!'\n        else:\n            return self.available_rooms[room_type] if self.available_rooms[room_type] > 0 else False\n\n    def check_in(self, room_type, room_number, name):\n        \"\"\"\n        Check in a guest if they have a booking.\n        :param room_type: str, type of room to check in.\n        :param room_number: int, number of rooms to check in.\n        :param name: str, guest name.\n        :return: bool, whether check-in was successful.\n        \"\"\"\n        if room_type not in self.booked_rooms or name not in self.booked_rooms[room_type] or self.booked_rooms[room_type][name] < room_number:\n            return False\n\n        if self.booked_rooms[room_type][name] == room_number:\n            del self.booked_rooms[room_type][name]\n        else:\n            self.booked_rooms[room_type][name] -= room_number\n\n        return True\n\n    def check_out(self, room_type, room_number):\n        \"\"\"\n        Check out rooms, updating availability.\n        :param room_type: str, type of room to check out.\n        :param room_number: int, number of rooms to check out.\n        \"\"\"\n        if room_type in self.available_rooms:\n            self.available_rooms[room_type] += room_number\n        else:\n            self.available_rooms[room_type] = room_number\n\n    def get_available_rooms(self, room_type):\n        \"\"\"\n        Get the number of available rooms of a specific type.\n        :param room_type: str, type of room to check.\n        :return: int, number of available rooms.\n        \"\"\"\n        return self.available_rooms.get(room_type, 0)\n```",
    "50": "```python\nimport json\nimport os\n\nclass JSONProcessor:\n    \"\"\"\n    A class to process JSON files, including reading, writing, and modifying JSON data by removing a specified key.\n    \"\"\"\n\n    def read_json(self, file_path):\n        \"\"\"\n        Read a JSON file and return the data.\n        \n        :param file_path: str, the path of the JSON file.\n        :return: dict or None, the data from the JSON file if read successfully, \n                 None if the file does not exist, or raises an error if reading fails.\n        \"\"\"\n        if not os.path.isfile(file_path):\n            return None\n        \n        try:\n            with open(file_path, 'r') as f:\n                return json.load(f)\n        except json.JSONDecodeError as e:\n            raise ValueError(f\"Error reading JSON: {e}\")\n\n    def write_json(self, data, file_path):\n        \"\"\"\n        Write data to a JSON file and save it to the given path.\n\n        :param data: dict, the data to be written to the JSON file.\n        :param file_path: str, the path of the JSON file.\n        :return: bool, True if the writing process is successful, raises an error if writing fails.\n        \"\"\"\n        try:\n            with open(file_path, 'w') as f:\n                json.dump(data, f, indent=4)\n            return True\n        except IOError as e:\n            raise IOError(f\"Error writing JSON: {e}\")\n\n    def process_json(self, file_path, remove_key):\n        \"\"\"\n        Read a JSON file and process the data by removing a specified key and rewrite the modified data back to the file.\n\n        :param file_path: str, the path of the JSON file.\n        :param remove_key: str, the key to be removed.\n        :return: bool, True if the specified key is successfully removed and the data is written back, \n                      raises an error if the file does not exist or the specified key does not exist in the data.\n        \"\"\"\n        data = self.read_json(file_path)\n        if data is None:\n            raise FileNotFoundError(f\"{file_path} does not exist.\")\n        \n        if remove_key not in data:\n            raise KeyError(f\"{remove_key} does not exist in the JSON data.\")\n        \n        del data[remove_key]\n        self.write_json(data, file_path)\n        return True\n```",
    "49": "```python\nclass JobMarketplace:\n    \"\"\"\n    This class provides functionalities to publish positions, remove positions, submit resumes, withdraw resumes,\n    search for positions, and obtain candidate information.\n    \"\"\"\n\n    def __init__(self):\n        self.job_listings = []\n        self.resumes = []\n\n    def post_job(self, job_title, company, requirements):\n        \"\"\"\n        Publish a job position and add the information to the job_listings list.\n        \n        :param job_title: The title of the position, str.\n        :param company: The company of the position, str.\n        :param requirements: The requirements of the position, list.\n        :return: None\n        \"\"\"\n        job = {\n            'job_title': job_title,\n            'company': company,\n            'requirements': requirements\n        }\n        self.job_listings.append(job)\n\n    def remove_job(self, job):\n        \"\"\"\n        Remove a job position from the job_listings list.\n        \n        :param job: The position information to be removed, dict.\n        :return: None\n        \"\"\"\n        if job in self.job_listings:\n            self.job_listings.remove(job)\n\n    def submit_resume(self, name, skills, experience):\n        \"\"\"\n        Submit a resume and add the information to the resumes list.\n        \n        :param name: The name of the resume, str.\n        :param skills: The skills of the resume, list.\n        :param experience: The experience of the resume, str.\n        :return: None\n        \"\"\"\n        resume = {\n            'name': name,\n            'skills': skills,\n            'experience': experience\n        }\n        self.resumes.append(resume)\n\n    def withdraw_resume(self, resume):\n        \"\"\"\n        Withdraw a resume from the resumes list.\n        \n        :param resume: The resume information to be removed, dict.\n        :return: None\n        \"\"\"\n        if resume in self.resumes:\n            self.resumes.remove(resume)\n\n    def search_jobs(self, criteria):\n        \"\"\"\n        Search for job positions that meet the requirements.\n        \n        :param criteria: The requirements of the position, str.\n        :return: The position information that meets the requirements, list.\n        \"\"\"\n        return [job for job in self.job_listings if any(req in criteria for req in job['requirements'])]\n\n    def get_job_applicants(self, job):\n        \"\"\"\n        Obtain candidate information that meets the requirements of the job.\n        \n        :param job: The position information, dict.\n        :return: The candidate information that meets the requirements, list.\n        \"\"\"\n        applicants = []\n        for resume in self.resumes:\n            if all(req in resume['skills'] for req in job['requirements']):\n                applicants.append(resume)\n        return applicants\n```",
    "53": "```python\nimport re\n\nclass LongestWord:\n    \"\"\"\n    A class that allows adding words to a list and finding the longest word in a given sentence \n    by comparing the words with those in the word list.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize an empty list of words.\"\"\"\n        self.word_list = set()  # Use a set for faster lookups\n\n    def add_word(self, word: str):\n        \"\"\"\n        Append the input word into self.word_list.\n        \n        :param word: str, input word\n        \"\"\"\n        if isinstance(word, str) and word:  # Ensure the word is a non-empty string\n            self.word_list.add(word)\n\n    def find_longest_word(self, sentence: str) -> str:\n        \"\"\"\n        Remove punctuation marks and split a sentence into a list of words. \n        Find the longest word that is in the self.word_list.\n        Words are strictly case sensitive.\n\n        :param sentence: str, a sentence\n        :return: str, the longest word found in self.word_list or '' if self.word_list is empty.\n        \"\"\"\n        if not self.word_list:\n            return ''\n        \n        # Remove punctuation and split the sentence into words\n        words = re.findall(r'\\b\\w+\\b', sentence)\n\n        # Find the longest word that is in the word_list\n        longest = max((word for word in words if word in self.word_list), key=len, default='')\n\n        return longest\n```",
    "57": "```python\nimport numpy as np\n\nclass MetricsCalculator:\n    \"\"\"\n    The class provides methods to calculate Mean Reciprocal Rank (MRR) and Mean Average Precision (MAP) based on input data,\n    where MRR measures the ranking quality and MAP measures the average precision.\n    \"\"\"\n\n    @staticmethod\n    def mrr(data):\n        \"\"\"\n        Compute the MRR of the input data.\n        :param data: A tuple or a list of tuples, where each tuple contains the actual results (list of 0s and 1s) and the total number of ground truths.\n        :return: A tuple containing the mean MRR and a list of MRR scores for each input.\n        \"\"\"\n        if isinstance(data, tuple):\n            data = [data]\n        \n        mrr_scores = []\n        \n        for actual_results, _ in data:\n            if not actual_results:\n                mrr_scores.append(0.0)\n                continue\n            \n            reciprocal_rank = next((1 / (idx + 1) for idx, value in enumerate(actual_results) if value == 1), 0.0)\n            mrr_scores.append(reciprocal_rank)\n\n        return np.mean(mrr_scores), mrr_scores\n\n    @staticmethod\n    def map(data):\n        \"\"\"\n        Compute the MAP of the input data.\n        :param data: A tuple or a list of tuples, where each tuple contains the actual results (list of 0s and 1s) and the total number of ground truths.\n        :return: A tuple containing the mean MAP and a list of MAP scores for each input.\n        \"\"\"\n        if isinstance(data, tuple):\n            data = [data]\n        \n        map_scores = []\n        \n        for actual_results, ground_truth_num in data:\n            if not actual_results or ground_truth_num == 0:\n                map_scores.append(0.0)\n                continue\n            \n            relevant_count = 0\n            precision_at_k = []\n\n            for idx, value in enumerate(actual_results):\n                if value == 1:\n                    relevant_count += 1\n                    precision_at_k.append(relevant_count / (idx + 1))\n            \n            average_precision = np.mean(precision_at_k) if precision_at_k else 0.0\n            map_scores.append(average_precision)\n\n        return np.mean(map_scores), map_scores\n```",
    "55": "```python\nclass Manacher:\n    \"\"\"\n    This class implements the Manacher algorithm to find the longest palindromic substring in a given string.\n    \"\"\"\n\n    def __init__(self, input_string: str) -> None:\n        \"\"\"\n        Initializes the Manacher class with the given input_string.\n        :param input_string: The input_string to be searched, str.\n        \"\"\"\n        self.input_string = input_string\n        self.processed_string = self.preprocess_string(input_string)\n        self.palindrome_lengths = [0] * len(self.processed_string)\n        self.center = 0\n        self.right_boundary = 0\n        self.longest_palindrome = ''\n\n    def preprocess_string(self, string: str) -> str:\n        \"\"\"\n        Preprocesses the input string to insert delimiters for easier palindrome detection.\n        :param string: The original string, str.\n        :return: The processed string with delimiters, str.\n        \"\"\"\n        return '|' + '|'.join(string) + '|'\n\n    def palindromic_string(self) -> str:\n        \"\"\"\n        Finds the longest palindromic substring in the given string.\n        :return: The longest palindromic substring, str.\n        \"\"\"\n        for i in range(len(self.processed_string)):\n            mirror = 2 * self.center - i\n            \n            if i < self.right_boundary:\n                self.palindrome_lengths[i] = min(self.right_boundary - i, self.palindrome_lengths[mirror])\n            \n            # Attempt to expand palindrome centered at i\n            a, b = i + (1 + self.palindrome_lengths[i]), i - (1 + self.palindrome_lengths[i])\n            while a < len(self.processed_string) and b >= 0 and self.processed_string[a] == self.processed_string[b]:\n                self.palindrome_lengths[i] += 1\n                a += 1\n                b -= 1\n            \n            # Update center and right boundary\n            if i + self.palindrome_lengths[i] > self.right_boundary:\n                self.center = i\n                self.right_boundary = i + self.palindrome_lengths[i]\n                \n            # Track the longest palindrome\n            if self.palindrome_lengths[i] > len(self.longest_palindrome):\n                start = (i - self.palindrome_lengths[i]) // 2\n                self.longest_palindrome = self.input_string[start:start + self.palindrome_lengths[i]]\n\n        return self.longest_palindrome\n```",
    "51": "```python\nimport numpy as np\n\nclass KappaCalculator:\n    \"\"\"\n    This class calculates Cohen's and Fleiss' kappa coefficients.\n    \"\"\"\n\n    @staticmethod\n    def kappa(testData):\n        \"\"\"\n        Calculate Cohen's kappa value of a square matrix.\n        :param testData: 2D list or numpy array, the confusion matrix\n        :return: float, Cohen's kappa value\n        >>> KappaCalculator.kappa([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n        0.25\n        \"\"\"\n        testData = np.array(testData)\n        n = np.sum(testData)\n        p0 = np.trace(testData) / n  # observed agreement\n        pe = np.sum(np.square(np.sum(testData, axis=0))) / (n**2)  # expected agreement\n        return (p0 - pe) / (1 - pe) if (1 - pe) != 0 else 0.0\n\n    @staticmethod\n    def fleiss_kappa(testData):\n        \"\"\"\n        Calculate Fleiss' kappa value of an N x k matrix.\n        :param testData: 2D list or numpy array, N x k matrix of ratings\n        :return: float, Fleiss' kappa value\n        >>> KappaCalculator.fleiss_kappa([[0, 0, 0, 0, 14],\n        >>>                                 [0, 2, 6, 4, 2],\n        >>>                                 [0, 0, 3, 5, 6],\n        >>>                                 [0, 3, 9, 2, 0],\n        >>>                                 [2, 2, 8, 1, 1],\n        >>>                                 [7, 7, 0, 0, 0],\n        >>>                                 [3, 2, 6, 3, 0],\n        >>>                                 [2, 5, 3, 2, 2],\n        >>>                                 [6, 5, 2, 1, 0],\n        >>>                                 [0, 2, 2, 3, 7]], 10)\n        0.20993070442195522\n        \"\"\"\n        testData = np.array(testData)\n        N, k = testData.shape\n        n = np.sum(testData, axis=1)  # total ratings for each sample\n        p = np.sum(testData, axis=0) / np.sum(testData)  # proportion of ratings for each category\n        P = np.sum((n / np.sum(testData))**2)  # observed agreement\n        Pe = np.sum(p**2)  # expected agreement\n        return (P - Pe) / (1 - Pe) if (1 - Pe) != 0 else 0.0\n```",
    "52": "```python\nimport nltk\nfrom nltk.stem import WordNetLemmatizer\nfrom nltk import pos_tag, word_tokenize\nimport string\n\n# Download required NLTK resources\nnltk.download('averaged_perceptron_tagger', quiet=True)\nnltk.download('punkt', quiet=True)\nnltk.download('wordnet', quiet=True)\n\nclass Lemmatization:\n    \"\"\"\n    A class for performing lemmatization and part-of-speech tagging on sentences, as well as removing punctuation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the WordNetLemmatizer object.\n        \"\"\"\n        self.lemmatizer = WordNetLemmatizer()\n\n    def lemmatize_sentence(self, sentence):\n        \"\"\"\n        Lemmatizes the words in the input sentence based on their part of speech.\n        :param sentence: A sentence string\n        :return: A list of lemmatized words.\n        \"\"\"\n        # Remove punctuation and tokenize the sentence\n        words = word_tokenize(self.remove_punctuation(sentence))\n        # Get part of speech tags\n        pos_tags = self.get_pos_tags(words)\n        \n        lemmatized_words = [\n            self.lemmatizer.lemmatize(word, pos=self.get_wordnet_pos(tag))\n            for word, tag in zip(words, pos_tags)\n        ]\n        \n        return lemmatized_words\n\n    def get_pos_tags(self, words):\n        \"\"\"\n        Gets the part of speech tags for a list of words.\n        :param words: A list of words\n        :return: A list of part of speech tags.\n        \"\"\"\n        return [tag for _, tag in pos_tag(words)]\n\n    def get_wordnet_pos(self, tag):\n        \"\"\"\n        Converts POS tag to a format compatible with WordNetLemmatizer.\n        :param tag: A part of speech tag\n        :return: A WordNet-compatible POS tag.\n        \"\"\"\n        if tag.startswith('VB'):\n            return 'v'\n        elif tag.startswith('N'):\n            return 'n'\n        elif tag.startswith('J'):\n            return 'a'\n        elif tag.startswith('R'):\n            return 'r'\n        else:\n            return 'n'  # Default to noun if no match\n\n    def remove_punctuation(self, sentence):\n        \"\"\"\n        Removes punctuation from the input text.\n        :param sentence: A sentence string\n        :return: A string without punctuation.\n        \"\"\"\n        return sentence.translate(str.maketrans('', '', string.punctuation))\n```",
    "58": "```python\nimport random\n\nclass MinesweeperGame:\n    \"\"\"\n    This is a class that implements mine sweeping games including minesweeping and winning judgment.\n    \"\"\"\n\n    def __init__(self, n, k) -> None:\n        \"\"\"\n        Initializes the MinesweeperGame class with the size of the board and the number of mines.\n        :param n: The size of the board, int.\n        :param k: The number of mines, int.\n        :raises ValueError: If the number of mines exceeds the number of available cells.\n        \"\"\"\n        if k > n * n:\n            raise ValueError(\"Number of mines cannot exceed the number of cells in the board.\")\n        self.n = n\n        self.k = k\n        self.minesweeper_map = self.generate_mine_sweeper_map()\n        self.player_map = self.generate_player_map()\n        \n    def generate_mine_sweeper_map(self):\n        \"\"\"\n        Generates a minesweeper map with the given size of the board and the number of mines.\n        :return: The minesweeper map, list.\n        \"\"\"\n        board = [[0 for _ in range(self.n)] for _ in range(self.n)]\n        mines = random.sample(range(self.n * self.n), self.k)\n\n        for mine in mines:\n            x, y = divmod(mine, self.n)\n            board[x][y] = 'X'\n            for i in range(max(0, x - 1), min(self.n, x + 2)):\n                for j in range(max(0, y - 1), min(self.n, y + 2)):\n                    if board[i][j] != 'X':\n                        board[i][j] += 1\n        return board\n\n    def generate_player_map(self):\n        \"\"\"\n        Generates a player map with the given size of the board.\n        :return: The player map, list.\n        \"\"\"\n        return [['-' for _ in range(self.n)] for _ in range(self.n)]\n\n    def check_won(self):\n        \"\"\"\n        Checks whether the player has won the game.\n        :return: True if the player has won the game, False otherwise.\n        \"\"\"\n        for i in range(self.n):\n            for j in range(self.n):\n                if self.player_map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':\n                    return False\n        return True\n\n    def sweep(self, x, y):\n        \"\"\"\n        Sweeps the given position.\n        :param x: The x coordinate of the position, int.\n        :param y: The y coordinate of the position, int.\n        :return: \"Game Over\" if the player hits a mine, True if the player has won the game, otherwise the player map.\n        :raises IndexError: If the coordinates are out of bounds.\n        \"\"\"\n        if not (0 <= x < self.n) or not (0 <= y < self.n):\n            raise IndexError(\"Coordinates out of bounds.\")\n        \n        if self.minesweeper_map[x][y] == 'X':\n            return \"Game Over\"\n        \n        self.player_map[x][y] = self.minesweeper_map[x][y]\n        \n        if self.check_won():\n            return True\n        \n        return self.player_map\n```",
    "62": "```python\nclass NLPDataProcessor:\n    \"\"\"\n    The class processes NLP data by removing stop words from a list of strings using a pre-defined stop word list.\n    \"\"\"\n\n    @staticmethod\n    def construct_stop_word_list():\n        \"\"\"\n        Construct a stop word list including 'a', 'an', 'the'.\n        :return: a set of stop words for efficient lookup\n        >>> NLPDataProcessor.construct_stop_word_list()\n        {'a', 'an', 'the'}\n        \"\"\"\n        return {'a', 'an', 'the'}\n\n    @staticmethod\n    def remove_stop_words(string_list, stop_word_list):\n        \"\"\"\n        Remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :param stop_word_list: a set of stop words\n        :return: a list of lists containing words without stop words\n        >>> NLPDataProcessor.remove_stop_words(['This is a test.'], NLPDataProcessor.construct_stop_word_list())\n        [['This', 'is', 'test.']]\n        \"\"\"\n        processed_list = []\n        for string in string_list:\n            words = string.split()\n            filtered_words = [word for word in words if word.lower() not in stop_word_list]\n            processed_list.append(filtered_words)\n        return processed_list\n\n    @classmethod\n    def process(cls, string_list):\n        \"\"\"\n        Construct a stop word list including 'a', 'an', 'the', and remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :return: a list of lists containing words without stop words\n        >>> NLPDataProcessor.process(['This is a test.'])\n        [['This', 'is', 'test.']]\n        \"\"\"\n        stop_word_list = cls.construct_stop_word_list()\n        return cls.remove_stop_words(string_list, stop_word_list)\n```",
    "56": "```python\nclass MetricsCalculator:\n    \"\"\"\n    The class calculates precision, recall, F1 score, and accuracy based on predicted and true labels.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the count of true positives, false positives, false negatives, and true negatives to 0.\n        \"\"\"\n        self.reset()\n\n    def reset(self):\n        \"\"\"Reset the metrics counters to zero.\"\"\"\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n    def update(self, predicted_labels, true_labels):\n        \"\"\"\n        Update the counts of true positives, false positives, false negatives, and true negatives based on the predictions and true labels.\n        \n        :param predicted_labels: list of predicted results\n        :param true_labels: list of true labels\n        :return: None\n        \"\"\"\n        if len(predicted_labels) != len(true_labels):\n            raise ValueError(\"Length of predicted_labels and true_labels must be the same.\")\n\n        self.reset()  # Reset counts before updating\n        for predicted, true in zip(predicted_labels, true_labels):\n            if predicted == 1 and true == 1:\n                self.true_positives += 1\n            elif predicted == 1 and true == 0:\n                self.false_positives += 1\n            elif predicted == 0 and true == 1:\n                self.false_negatives += 1\n            elif predicted == 0 and true == 0:\n                self.true_negatives += 1\n\n    def precision(self):\n        \"\"\"\n        Calculate precision.\n        \n        :return: float\n        \"\"\"\n        total_positive_predictions = self.true_positives + self.false_positives\n        return self.true_positives / total_positive_predictions if total_positive_predictions > 0 else 0.0\n\n    def recall(self):\n        \"\"\"\n        Calculate recall.\n        \n        :return: float\n        \"\"\"\n        total_actual_positives = self.true_positives + self.false_negatives\n        return self.true_positives / total_actual_positives if total_actual_positives > 0 else 0.0\n\n    def f1_score(self):\n        \"\"\"\n        Calculate F1 score, which is the harmonic mean of precision and recall.\n        \n        :return: float\n        \"\"\"\n        p = self.precision()\n        r = self.recall()\n        return 2 * (p * r) / (p + r) if (p + r) > 0 else 0.0\n\n    def accuracy(self):\n        \"\"\"\n        Calculate accuracy.\n        \n        :return: float\n        \"\"\"\n        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives\n        return (self.true_positives + self.true_negatives) / total if total > 0 else 0.0\n```",
    "63": "```python\nimport re\nfrom collections import Counter\n\nclass NLPDataProcessor:\n    \"\"\"\n    The class processes NLP data by extracting words from a list of strings, calculating the frequency of each word,\n    and returning the top 5 most frequent words.\n    \"\"\"\n\n    def process_data(self, string_list):\n        \"\"\"\n        Cleans the input strings by removing non-alphabetic characters and converting to lower case.\n        \n        :param string_list: List of strings to process\n        :return: List of lists, where each inner list contains the words from the corresponding string\n        \"\"\"\n        words_list = []\n        for string in string_list:\n            cleaned_string = re.sub(r'[^a-zA-Z\\s]', '', string).lower()\n            words = cleaned_string.split()\n            words_list.append(words)\n        return words_list\n\n    def calculate_word_frequency(self, words_list):\n        \"\"\"\n        Calculates the frequency of words in the provided list of lists of words.\n        \n        :param words_list: List of lists containing words\n        :return: Dictionary of the top 5 most common words and their frequencies\n        \"\"\"\n        word_counter = Counter()\n        for words in words_list:\n            word_counter.update(words)\n        return dict(word_counter.most_common(5))\n\n    def process(self, string_list):\n        \"\"\"\n        Processes the input strings to return the top 5 most frequent words.\n        \n        :param string_list: List of strings to process\n        :return: Dictionary of the top 5 most common words and their frequencies\n        \"\"\"\n        words_list = self.process_data(string_list)\n        return self.calculate_word_frequency(words_list)\n```",
    "60": "```python\nimport sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This class handles movie ticket database operations, including inserting, searching, and deleting ticket information.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.\n        :return: None\n        \"\"\"\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS tickets (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                movie_name TEXT NOT NULL,\n                theater_name TEXT NOT NULL,\n                seat_number TEXT NOT NULL,\n                customer_name TEXT NOT NULL\n            )\n        ''')\n        self.connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        self.cursor.execute('''\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n            VALUES (?, ?, ?, ?)\n        ''', (movie_name, theater_name, seat_number, customer_name))\n        self.connection.commit()\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        \"\"\"\n        self.cursor.execute('''\n            SELECT * FROM tickets WHERE customer_name = ?\n        ''', (customer_name,))\n        return self.cursor.fetchall()\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"\n        self.cursor.execute('''\n            DELETE FROM tickets WHERE id = ?\n        ''', (ticket_id,))\n        self.connection.commit()\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        :return: None\n        \"\"\"\n        self.connection.close()\n\n    def __del__(self):\n        \"\"\"\n        Ensures the database connection is closed when the object is deleted.\n        \"\"\"\n        self.close()\n```",
    "66": "```python\nimport re\n\nclass NumericEntityUnescaper:\n    \"\"\"\n    This class provides functionality to replace numeric entities with their corresponding characters in a given string.\n    \"\"\"\n\n    def replace(self, string):\n        \"\"\"\n        Replaces numeric character references (HTML entities) in the input string with their corresponding Unicode characters.\n        :param string: str, the input string containing numeric character references.\n        :return: str, the input string with numeric character references replaced with their corresponding Unicode characters.\n        >>> unescaper = NumericEntityUnescaper()\n        >>> unescaper.replace(\"&#65;&#66;&#67;\")\n        'ABC'\n        \"\"\"\n        if not isinstance(string, str):\n            raise ValueError(\"Input must be a string.\")\n\n        def replace_entity(match):\n            code_point = int(match.group(1))\n            if code_point < 0 or code_point > 0x10FFFF:\n                return match.group(0)  # Return the original entity if out of valid Unicode range\n            return chr(code_point)\n\n        return re.sub(r'&#(\\d+);', replace_entity, string)\n\n    @staticmethod\n    def is_hex_char(char):\n        \"\"\"\n        Determines whether a given character is a hexadecimal digit.\n        :param char: str, the character to check.\n        :return: bool, True if the character is a hexadecimal digit, False otherwise.\n        >>> NumericEntityUnescaper.is_hex_char('a')\n        True\n        >>> NumericEntityUnescaper.is_hex_char('g')\n        False\n        \"\"\"\n        return len(char) == 1 and char.lower() in '0123456789abcdef'\n```",
    "61": "```python\nimport random\n\nclass MusicPlayer:\n    \"\"\"\n    A music player class that allows playing, stopping, adding/removing songs, \n    setting volume, shuffling, and switching between songs.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the music player with an empty playlist, no current song, and a default volume of 50.\n        \"\"\"\n        self.playlist = []\n        self.current_song_index = -1\n        self.volume = 50\n\n    def add_song(self, song):\n        \"\"\"\n        Adds a song to the playlist.\n        :param song: The song to add to the playlist, str.\n        \"\"\"\n        if isinstance(song, str) and song not in self.playlist:\n            self.playlist.append(song)\n\n    def remove_song(self, song):\n        \"\"\"\n        Removes a song from the playlist.\n        :param song: The song to remove from the playlist, str.\n        \"\"\"\n        if song in self.playlist:\n            self.playlist.remove(song)\n\n    def play(self):\n        \"\"\"\n        Plays the current song in the playlist.\n        :return: The current song in the playlist, or None if there is no current song.\n        \"\"\"\n        if 0 <= self.current_song_index < len(self.playlist):\n            return self.playlist[self.current_song_index]\n        return None\n\n    def stop(self):\n        \"\"\"\n        Stops the current song in the playlist.\n        :return: True if the current song was stopped, False if there was no current song.\n        \"\"\"\n        if self.current_song_index >= 0:\n            self.current_song_index = -1\n            return True\n        return False\n\n    def switch_song(self):\n        \"\"\"\n        Switches to the next song in the playlist.\n        :return: True if the next song was switched to, False if there was no next song.\n        \"\"\"\n        if self.playlist:\n            self.current_song_index = (self.current_song_index + 1) % len(self.playlist)\n            return True\n        return False\n\n    def previous_song(self):\n        \"\"\"\n        Switches to the previous song in the playlist.\n        :return: True if the previous song was switched to, False if there was no previous song.\n        \"\"\"\n        if self.playlist:\n            self.current_song_index = (self.current_song_index - 1) % len(self.playlist)\n            return True\n        return False\n\n    def set_volume(self, volume):\n        \"\"\"\n        Sets the volume of the music player, if the volume is between 0 and 100 is valid.\n        :param volume: The volume to set the music player to, int.\n        :return: True if the volume was set, False if the volume was invalid.\n        \"\"\"\n        if 0 <= volume <= 100:\n            self.volume = volume\n            return True\n        return False\n\n    def shuffle(self):\n        \"\"\"\n        Shuffles the playlist.\n        :return: True if the playlist was shuffled, False if the playlist was empty.\n        \"\"\"\n        if self.playlist:\n            random.shuffle(self.playlist)\n            return True\n        return False\n```",
    "59": "```python\nfrom datetime import datetime\nimport numpy as np\n\nclass MovieBookingSystem:\n    \"\"\"\n    A class representing a movie booking system, allowing the addition of movies,\n    booking of tickets, and checking available movies within a specified time range.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize an empty list to hold movie information.\n        \"\"\"\n        self.movies = []\n\n    def add_movie(self, name, price, start_time, end_time, n):\n        \"\"\"\n        Add a new movie to the system.\n        :param name: str, movie name\n        :param price: float, price for one ticket\n        :param start_time: str, start time in HH:MM format\n        :param end_time: str, end time in HH:MM format\n        :param n: int, the size of seats (n*n)\n        \"\"\"\n        start_time = datetime.strptime(start_time, '%H:%M')\n        end_time = datetime.strptime(end_time, '%H:%M')\n\n        if start_time >= end_time:\n            raise ValueError(\"End time must be after start time.\")\n\n        if any(movie['name'].lower() == name.lower() for movie in self.movies):\n            raise ValueError(\"Movie already exists.\")\n\n        seats = np.zeros((n, n), dtype=int)  # Using int for seat status (0: available, 1: booked)\n        self.movies.append({\n            'name': name,\n            'price': price,\n            'start_time': start_time,\n            'end_time': end_time,\n            'seats': seats\n        })\n\n    def book_ticket(self, name, seats_to_book):\n        \"\"\"\n        Book tickets for a movie.\n        :param name: str, movie name\n        :param seats_to_book: list of tuples, representing seats to book [(row1, col1), (row2, col2), ...]\n        :return: str, booking status message\n        \"\"\"\n        movie = next((m for m in self.movies if m['name'].lower() == name.lower()), None)\n        if not movie:\n            return \"Movie not found.\"\n        \n        seats = movie['seats']\n        for row, col in seats_to_book:\n            if row < 0 or row >= seats.shape[0] or col < 0 or col >= seats.shape[1]:\n                return \"Booking failed: Invalid seat selection.\"\n            if seats[row, col] == 1:\n                return \"Booking failed: Seat already booked.\"\n        \n        for row, col in seats_to_book:\n            seats[row, col] = 1\n        \n        return \"Booking success.\"\n\n    def available_movies(self, start_time, end_time):\n        \"\"\"\n        Get a list of available movies within the specified time range.\n        :param start_time: str, start time in HH:MM format\n        :param end_time: str, end time in HH:MM format\n        :return: list of str, names of available movies\n        \"\"\"\n        start_time = datetime.strptime(start_time, '%H:%M')\n        end_time = datetime.strptime(end_time, '%H:%M')\n\n        return [\n            movie['name'] for movie in self.movies\n            if movie['start_time'] >= start_time and movie['end_time'] <= end_time\n        ]\n```",
    "64": "```python\nclass NumberConverter:\n    \"\"\"\n    The class allows to convert decimal to binary, octal, and hexadecimal respectively and contrarily.\n    \"\"\"\n\n    @staticmethod\n    def decimal_to_binary(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to binary format.\n        :param decimal_num: int, decimal number\n        :return: str, the binary representation of an integer.\n        >>> NumberConverter.decimal_to_binary(42423)\n        '1010010110110111'\n        \"\"\"\n        if not isinstance(decimal_num, int) or decimal_num < 0:\n            raise ValueError(\"Input must be a non-negative integer.\")\n        return bin(decimal_num)[2:]\n\n    @staticmethod\n    def binary_to_decimal(binary_num):\n        \"\"\"\n        Convert a number from binary format to decimal format.\n        :param binary_num: str, binary number\n        :return: int, the decimal representation of binary number str.\n        >>> NumberConverter.binary_to_decimal('1010010110110111')\n        42423\n        \"\"\"\n        if not isinstance(binary_num, str) or not all(bit in '01' for bit in binary_num):\n            raise ValueError(\"Input must be a binary string.\")\n        return int(binary_num, 2)\n\n    @staticmethod\n    def decimal_to_octal(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to octal format.\n        :param decimal_num: int, decimal number\n        :return: str, the octal representation of an integer.\n        >>> NumberConverter.decimal_to_octal(42423)\n        '122667'\n        \"\"\"\n        if not isinstance(decimal_num, int) or decimal_num < 0:\n            raise ValueError(\"Input must be a non-negative integer.\")\n        return oct(decimal_num)[2:]\n\n    @staticmethod\n    def octal_to_decimal(octal_num):\n        \"\"\"\n        Convert a number from octal format to decimal format.\n        :param octal_num: str, octal num\n        :return: int, the decimal representation of octal number str.\n        >>> NumberConverter.octal_to_decimal('122667')\n        42423\n        \"\"\"\n        if not isinstance(octal_num, str) or not all(digit in '01234567' for digit in octal_num):\n            raise ValueError(\"Input must be an octal string.\")\n        return int(octal_num, 8)\n\n    @staticmethod\n    def decimal_to_hex(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to hex format.\n        :param decimal_num: int, decimal number\n        :return: str, the hex representation of an integer.\n        >>> NumberConverter.decimal_to_hex(42423)\n        'a5b7'\n        \"\"\"\n        if not isinstance(decimal_num, int) or decimal_num < 0:\n            raise ValueError(\"Input must be a non-negative integer.\")\n        return hex(decimal_num)[2:]\n\n    @staticmethod\n    def hex_to_decimal(hex_num):\n        \"\"\"\n        Convert a number from hex format to decimal format.\n        :param hex_num: str, hex num\n        :return: int, the decimal representation of hex number str.\n        >>> NumberConverter.hex_to_decimal('a5b7')\n        42423\n        \"\"\"\n        if not isinstance(hex_num, str) or not all(char in '0123456789abcdefABCDEF' for char in hex_num):\n            raise ValueError(\"Input must be a hexadecimal string.\")\n        return int(hex_num, 16)\n```",
    "54": "```python\nimport random\n\nclass MahjongConnect:\n    \"\"\"\n    MahjongConnect is a class representing a game board for Mahjong Connect with features like creating the board, checking valid moves, finding paths, removing icons, and checking if the game is over.\n    \"\"\"\n\n    def __init__(self, board_size, icons):\n        \"\"\"\n        Initialize the board size and the icon list, create the game board.\n        :param board_size: list of two integer numbers, representing the number of rows and columns of the game board\n        :param icons: list of string, representing the icons\n        \"\"\"\n        self.board_size = board_size\n        self.icons = icons\n        self.board = self.create_board()\n\n    def create_board(self):\n        \"\"\"\n        Create the game board with the given board size and icons.\n        :return: 2-dimensional list, the game board\n        \"\"\"\n        num_icons = len(self.icons)\n        total_icons = self.board_size[0] * self.board_size[1]\n        \n        # Ensure there are pairs of icons\n        icons_to_use = (self.icons * (total_icons // num_icons) + self.icons[:total_icons % num_icons]) * 2\n        random.shuffle(icons_to_use)\n        \n        board = [icons_to_use[i * self.board_size[1]:(i + 1) * self.board_size[1]] for i in range(self.board_size[0])]\n        return board\n\n    def is_valid_move(self, pos1, pos2):\n        \"\"\"\n        Check if the move of two icons is valid.\n        :param pos1: position tuple(x, y) of the first icon\n        :param pos2: position tuple(x, y) of the second icon\n        :return: True or False, representing whether the move of two icons is valid\n        \"\"\"\n        if pos1 == pos2:\n            return False\n        if not self._is_within_bounds(pos1) or not self._is_within_bounds(pos2):\n            return False\n        if self.board[pos1[0]][pos1[1]] != self.board[pos2[0]][pos2[1]]:\n            return False\n        return self.has_path(pos1, pos2)\n\n    def _is_within_bounds(self, pos):\n        return 0 <= pos[0] < self.board_size[0] and 0 <= pos[1] < self.board_size[1]\n\n    def has_path(self, pos1, pos2):\n        \"\"\"\n        Check if there is a path between two icons.\n        :param pos1: position tuple(x, y) of the first icon\n        :param pos2: position tuple(x, y) of the second icon\n        :return: True or False, representing whether there is a path between two icons\n        \"\"\"\n        visited = set()\n        return self._find_path(pos1, pos2, visited)\n\n    def _find_path(self, current, target, visited):\n        if current in visited:\n            return False\n        if current == target:\n            return True\n        \n        visited.add(current)\n        x, y = current\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        \n        for dx, dy in directions:\n            next_pos = (x + dx, y + dy)\n            if self._is_within_bounds(next_pos) and (self.board[next_pos[0]][next_pos[1]] == ' ' or next_pos == target):\n                if self._find_path(next_pos, target, visited):\n                    return True\n        \n        return False\n\n    def remove_icons(self, pos1, pos2):\n        \"\"\"\n        Remove the connected icons on the game board.\n        :param pos1: position tuple(x, y) of the first icon to be removed\n        :param pos2: position tuple(x, y) of the second icon to be removed\n        \"\"\"\n        self.board[pos1[0]][pos1[1]] = ' '\n        self.board[pos2[0]][pos2[1]] = ' '\n\n    def is_game_over(self):\n        \"\"\"\n        Check if the game is over.\n        :return: True or False, representing whether the game is over\n        \"\"\"\n        return all(icon == ' ' for row in self.board for icon in row)\n```",
    "70": "```python\nclass PersonRequest:\n    \"\"\"\n    This class validates input personal information data and sets invalid fields to None based on specific rules.\n    \"\"\"\n\n    VALID_SEXES = {\"Man\", \"Woman\", \"UGM\"}\n\n    def __init__(self, name: str, sex: str, phone_number: str):\n        \"\"\"\n        Initialize PersonRequest object with the provided information.\n        :param name: str, the name of the person\n        :param sex: str, the sex of the person\n        :param phone_number: str, the phone number of the person\n        \"\"\"\n        self.name = self._validate_name(name)\n        self.sex = self._validate_sex(sex)\n        self.phone_number = self._validate_phone_number(phone_number)\n\n    def _validate_name(self, name: str) -> str:\n        \"\"\"\n        Validate the name and return it. If name is empty or exceeds 33 characters in length, set to None.\n        :param name: str, the name to validate\n        :return: str, the validated name or None if invalid\n        \"\"\"\n        return name if name and len(name) <= 33 else None\n\n    def _validate_sex(self, sex: str) -> str:\n        \"\"\"\n        Validate the sex and return it. If sex is not Man, Woman, or UGM, set to None.\n        :param sex: str, the sex to validate\n        :return: str, the validated sex or None if invalid\n        \"\"\"\n        return sex if sex in self.VALID_SEXES else None\n\n    def _validate_phone_number(self, phone_number: str) -> str:\n        \"\"\"\n        Validate the phone number and return it. If phone_number is empty or not an 11 digit number, set to None.\n        :param phone_number: str, the phone number to validate\n        :return: str, the validated phone number or None if invalid\n        \"\"\"\n        return phone_number if phone_number.isdigit() and len(phone_number) == 11 else None\n```",
    "69": "```python\nimport PyPDF2\nfrom typing import List\n\nclass PDFHandler:\n    \"\"\"\n    The class allows merging multiple PDF files into one and extracting text from PDFs using PyPDF2 library.\n    \"\"\"\n\n    def __init__(self, filepaths: List[str]):\n        \"\"\"\n        Initializes PDFHandler with a list of file paths.\n        Creates a list of PdfReader objects for the provided file paths.\n        \n        :param filepaths: List of PDF file paths to be handled.\n        \"\"\"\n        self.filepaths = filepaths\n        self.readers = [PyPDF2.PdfReader(fp) for fp in filepaths]\n\n    def merge_pdfs(self, output_filepath: str) -> str:\n        \"\"\"\n        Merges multiple PDF files into one and saves it to disk.\n        \n        :param output_filepath: str, output file path to save the merged PDF\n        :return: str, message indicating the location of the saved merged PDF\n        \"\"\"\n        writer = PyPDF2.PdfWriter()\n\n        for reader in self.readers:\n            for page in reader.pages:\n                writer.add_page(page)\n\n        with open(output_filepath, 'wb') as out_file:\n            writer.write(out_file)\n\n        return f\"Merged PDFs saved at {output_filepath}\"\n\n    def extract_text_from_pdfs(self) -> List[str]:\n        \"\"\"\n        Extracts text from each PDF file and returns a list of text content.\n        \n        :return: List of strings, each containing the text of one PDF file\n        \"\"\"\n        pdf_texts = []\n        \n        for reader in self.readers:\n            text = \"\"\n            for page in reader.pages:\n                page_text = page.extract_text()\n                if page_text:  # Check if text extraction is successful\n                    text += page_text\n            pdf_texts.append(text)\n\n        return pdf_texts\n```",
    "67": "```python\nclass Order:\n    \"\"\"\n    The class manages restaurant orders by allowing the addition of dishes, calculation of the total cost, and checkout.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the order management system.\n        self.menu stores the dishes of restaurant inventory.\n        menu = [{\"dish\": dish name, \"price\": price, \"count\": count}, ...]\n        self.selected_dishes stores the dishes selected by customer.\n        selected_dish = {\"dish\": dish name, \"count\": count, price: price}\n        self.sales stores the sales of each dish.\n        sales = {dish name: sales}\n        \"\"\"\n        self.menu = []\n        self.selected_dishes = []\n        self.sales = {}\n\n    def add_dish(self, dish):\n        \"\"\"\n        Check the self.menu and add into self.selected_dishes if the dish count is valid.\n        And if the dish has successfully been added, change the count in self.menu.\n        :param dish: dict, the information of dish. dish = {\"dish\": dish name, \"count\": count, price: price}\n        :return: True if successfully added, or False otherwise.\n        \"\"\"\n        for menu_item in self.menu:\n            if menu_item[\"dish\"] == dish[\"dish\"]:\n                if menu_item[\"count\"] >= dish[\"count\"]:\n                    menu_item[\"count\"] -= dish[\"count\"]\n                    selected_dish = {\"dish\": dish[\"dish\"], \"count\": dish[\"count\"], \"price\": dish[\"price\"]}\n                    self.selected_dishes.append(selected_dish)\n                    return True\n                else:\n                    return False\n        return False\n\n    def calculate_total(self):\n        \"\"\"\n        Calculate the total price of dishes that have been ordered. Multiply the count, price and sales.\n        :return total: float, the final total price.\n        \"\"\"\n        total = 0\n        for selected in self.selected_dishes:\n            dish_name = selected[\"dish\"]\n            price_multiplier = self.sales.get(dish_name, 1)\n            total += selected[\"count\"] * selected[\"price\"] * price_multiplier\n        return total\n\n    def checkout(self):\n        \"\"\"\n        Check out the dishes ordered. If the self.selected_dishes is not empty,\n        invoke the calculate_total method to check out.\n        :return: False if the self.selected_dishes is empty, or total (return value of calculate_total) otherwise.\n        \"\"\"\n        if not self.selected_dishes:\n            return False\n        return self.calculate_total()\n```",
    "72": "```python\nimport re\n\nclass RegexUtils:\n    \"\"\"\n    The class provides methods to match, find all occurrences, split, and substitute text using regular expressions. \n    It also includes predefined patterns for validating phone numbers and extracting email addresses.\n    \"\"\"\n\n    def match(self, pattern, text):\n        \"\"\"\n        Check if the text matches the regular expression\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to match\n        :return: True or False, representing whether the text matches the regular expression or not\n        \"\"\"\n        return bool(re.fullmatch(pattern, text))\n\n    def findall(self, pattern, text):\n        \"\"\"\n        Find all matching substrings and return a list of all matching substrings\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to match\n        :return: list of string, List of all matching substrings\n        \"\"\"\n        return re.findall(pattern, text)\n\n    def split(self, pattern, text):\n        \"\"\"\n        Split text based on regular expression patterns and return a list of substrings\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to be split\n        :return: list of string, List of substrings after splitting\n        \"\"\"\n        return re.split(pattern, text)\n\n    def sub(self, pattern, replacement, text):\n        \"\"\"\n        Replace the substring matched by a regular expression with the specified string\n        :param pattern: string, Regular expression pattern\n        :param replacement: Text to replace with\n        :param text: string, Text to be replaced\n        :return: string, Text after replacement\n        \"\"\"\n        return re.sub(pattern, replacement, text)\n\n    def generate_email_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match email addresses\n        :return: string, regular expression patterns that match email addresses\n        \"\"\"\n        return r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n\n    def generate_phone_number_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match phone numbers\n        :return: string, regular expression patterns that match phone numbers\n        \"\"\"\n        return r'\\b\\d{3}-\\d{3}-\\d{4}\\b'\n\n    def generate_split_sentences_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match the end of sentences\n        :return: string, regular expression patterns that match the end of sentences\n        \"\"\"\n        return r'[.!?][\\s]+(?=[A-Z])'\n\n    def split_sentences(self, text):\n        \"\"\"\n        Split the text into a list of sentences without punctuation except the last sentence\n        :param text: Text to be split\n        :return: Split Text List\n        \"\"\"\n        sentences = re.split(self.generate_split_sentences_pattern(), text)\n        return [sentence.strip() for sentence in sentences if sentence.strip()]\n\n    def validate_phone_number(self, phone_number):\n        \"\"\"\n        Verify if the phone number is valid\n        :param phone_number: Phone number to be verified\n        :return: True or False, indicating whether the phone number is valid\n        \"\"\"\n        pattern = self.generate_phone_number_pattern()\n        return bool(re.fullmatch(pattern, phone_number))\n\n    def extract_email(self, text):\n        \"\"\"\n        Extract all email addresses from the text\n        :param text: string, input text\n        :return: list of string, All extracted email addresses\n        \"\"\"\n        pattern = self.generate_email_pattern()\n        return re.findall(pattern, text)\n```",
    "68": "```python\nclass PageUtil:\n    \"\"\"\n    PageUtil class is a versatile utility for handling pagination and search functionalities in an efficient and convenient manner.\n    \"\"\"\n\n    def __init__(self, data, page_size):\n        \"\"\"\n        Initialize the PageUtil object with the given data and page size.\n        :param data: list, the data to be paginated\n        :param page_size: int, the number of items per page\n        \"\"\"\n        if not isinstance(data, list):\n            raise ValueError(\"Data must be a list.\")\n        if not isinstance(page_size, int) or page_size <= 0:\n            raise ValueError(\"Page size must be a positive integer.\")\n\n        self.data = data\n        self.page_size = page_size\n        self.total_items = len(data)\n        self.total_pages = (self.total_items + page_size - 1) // page_size\n\n    def get_page(self, page_number):\n        \"\"\"\n        Retrieve a specific page of data.\n        :param page_number: int, the page number to fetch\n        :return: list, the data on the specified page\n        >>> page_util = PageUtil([1, 2, 3, 4], 1)\n        >>> page_util.get_page(1)\n        [1]\n        \"\"\"\n        if page_number < 1 or page_number > self.total_pages:\n            return []\n        start_index = (page_number - 1) * self.page_size\n        return self.data[start_index:start_index + self.page_size]\n\n    def get_page_info(self, page_number):\n        \"\"\"\n        Retrieve information about a specific page.\n        :param page_number: int, the page number to fetch information about\n        :return: dict, containing page information such as current page number, total pages, etc.\n        >>> page_util = PageUtil([1, 2, 3, 4], 1)\n        >>> page_util.get_page_info(1)\n        {'current_page': 1, 'per_page': 1, 'total_pages': 4, 'total_items': 4, 'has_previous': False, 'has_next': True, 'data': [1]}\n        \"\"\"\n        if page_number < 1 or page_number > self.total_pages:\n            return {}\n\n        page_data = self.get_page(page_number)\n        return {\n            \"current_page\": page_number,\n            \"per_page\": self.page_size,\n            \"total_pages\": self.total_pages,\n            \"total_items\": self.total_items,\n            \"has_previous\": page_number > 1,\n            \"has_next\": page_number < self.total_pages,\n            \"data\": page_data\n        }\n\n    def search(self, keyword):\n        \"\"\"\n        Search for items in the data that contain the given keyword.\n        :param keyword: str, the keyword to search for\n        :return: dict, containing search information such as total results and matching items\n        >>> page_util = PageUtil([1, 2, 3, 4], 1)\n        >>> page_util.search(\"1\")\n        {'keyword': '1', 'total_results': 1, 'total_pages': 1, 'results': [1]}\n        \"\"\"\n        if not isinstance(keyword, str):\n            raise ValueError(\"Keyword must be a string.\")\n\n        results = [item for item in self.data if str(item).find(keyword) != -1]\n        total_results = len(results)\n        total_pages = (total_results + self.page_size - 1) // self.page_size\n\n        return {\n            \"keyword\": keyword,\n            \"total_results\": total_results,\n            \"total_pages\": total_pages,\n            \"results\": results\n        }\n```",
    "73": "```python\nclass RPGCharacter:\n    \"\"\"\n    The class represents a role-playing game character, which allows to attack other characters, heal, gain experience, level up, and check if the character is alive.\n    \"\"\"\n\n    MAX_HP = 100\n    MAX_LEVEL = 100\n\n    def __init__(self, name, hp, attack_power, defense, level=1):\n        \"\"\"\n        Initialize an RPG character object.\n        :param name: str, the name of the character.\n        :param hp: int, the health points of the character.\n        :param attack_power: int, the attack power of the character.\n        :param defense: int, the defense points of the character.\n        :param level: int, the level of the character. Default is 1.\n        \"\"\"\n        self.name = name\n        self.hp = min(hp, self.MAX_HP)  # Ensure initial HP does not exceed max HP\n        self.attack_power = attack_power\n        self.defense = defense\n        self.level = min(level, self.MAX_LEVEL)  # Ensure level does not exceed max level\n        self.exp = 0\n\n    def attack(self, other_character):\n        \"\"\"\n        Attack another character. The damage caused needs to offset the defense value.\n        :param other_character: RPGCharacter, The character being attacked.\n        \"\"\"\n        if not isinstance(other_character, RPGCharacter):\n            raise ValueError(\"other_character must be an instance of RPGCharacter\")\n        \n        damage = max(0, self.attack_power - other_character.defense)\n        other_character.hp = max(0, other_character.hp - damage)\n\n    def heal(self):\n        \"\"\"\n        Heal the character with 10 hp and the max hp is 100.\n        :return: int, the current health points after healing.\n        \"\"\"\n        self.hp = min(self.MAX_HP, self.hp + 10)\n        return self.hp\n\n    def gain_exp(self, amount):\n        \"\"\"\n        Gain experience points for the character and level up when the exp has reached the values that is 100 times the current level.\n        The experience that overflows should be used to calculate the next level up until exhausted.\n        :param amount: int, the amount of experience points to gain.\n        \"\"\"\n        self.exp += amount\n        while self.exp >= 100 * self.level and self.level < self.MAX_LEVEL:\n            self.exp -= 100 * self.level\n            self.level_up()\n\n    def level_up(self):\n        \"\"\"\n        Level up the character and return to zero experience points, increase hp by 20 points, attack power and defense points by 5 points.\n        Max level is 100.\n        :return: tuple[int, int, int, int], the new level, health points, attack power, and defense points after leveling up.\n        \"\"\"\n        if self.level < self.MAX_LEVEL:\n            self.level += 1\n            self.hp = min(self.MAX_HP, self.hp + 20)  # Ensure HP does not exceed max HP\n            self.attack_power += 5\n            self.defense += 5\n        return (self.level, self.hp, self.attack_power, self.defense)\n\n    def is_alive(self):\n        \"\"\"\n        Check if player is alive.\n        :return: True if the hp is larger than 0, or False otherwise.\n        \"\"\"\n        return self.hp > 0\n```",
    "65": "```python\nclass NumberWordFormatter:\n    \"\"\"\n    This is a class that converts numbers into their corresponding English word representation, \n    handling both integer and decimal parts, and incorporating appropriate connectors and units.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize NumberWordFormatter object.\n        \"\"\"\n        self.NUMBER = [\"\", \"ONE\", \"TWO\", \"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\"]\n        self.NUMBER_TEEN = [\"TEN\", \"ELEVEN\", \"TWELVE\", \"THIRTEEN\", \"FOURTEEN\", \"FIFTEEN\", \"SIXTEEN\", \"SEVENTEEN\",\n                            \"EIGHTEEN\", \"NINETEEN\"]\n        self.NUMBER_TEN = [\"TEN\", \"TWENTY\", \"THIRTY\", \"FORTY\", \"FIFTY\", \"SIXTY\", \"SEVENTY\", \"EIGHTY\", \"NINETY\"]\n        self.NUMBER_MORE = [\"\", \"THOUSAND\", \"MILLION\", \"BILLION\"]\n\n    def format(self, x):\n        \"\"\"\n        Converts a number into words format.\n        :param x: int or float, the number to be converted into words format\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.format(123456)\n        \"ONE HUNDRED AND TWENTY THREE THOUSAND FOUR HUNDRED AND FIFTY SIX ONLY\"\n        \"\"\"\n        if isinstance(x, float):\n            integer_part = int(x)\n            decimal_part = int(round((x - integer_part) * 100))\n            return self.format_integer(integer_part) + \" POINT \" + self.format_integer(decimal_part)\n        elif isinstance(x, int):\n            return self.format_integer(x)\n        else:\n            raise ValueError(\"Input must be an integer or float.\")\n\n    def format_string(self, x):\n        \"\"\"\n        Converts a string representation of a number into words format.\n        :param x: str, the string representation of a number\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.format_string(\"123456\")\n        \"ONE HUNDRED AND TWENTY THREE THOUSAND FOUR HUNDRED AND FIFTY SIX ONLY\"\n        \"\"\"\n        return self.format(int(x))\n\n    def trans_two(self, s):\n        \"\"\"\n        Converts a two-digit number into words format.\n        :param s: str, the two-digit number\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.trans_two(\"23\")\n        \"TWENTY THREE\"\n        \"\"\"\n        num = int(s)\n        if num < 10:\n            return self.NUMBER[num]\n        elif 10 <= num < 20:\n            return self.NUMBER_TEEN[num - 10]\n        else:\n            ten = num // 10\n            one = num % 10\n            return self.NUMBER_TEN[ten - 1] + (\" \" + self.NUMBER[one] if one > 0 else \"\")\n\n    def trans_three(self, s):\n        \"\"\"\n        Converts a three-digit number into words format.\n        :param s: str, the three-digit number\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.trans_three(\"123\")\n        \"ONE HUNDRED AND TWENTY THREE\"\n        \"\"\"\n        num = int(s)\n        hundred = num // 100\n        rest = num % 100\n        result = self.NUMBER[hundred] + \" HUNDRED\"\n        if rest > 0:\n            result += \" AND \" + self.trans_two(f\"{rest:02d}\")\n        return result.strip()\n\n    def format_integer(self, num):\n        \"\"\"\n        Converts an integer part of a number into words format.\n        :param num: int, the integer part of the number\n        :return: str, the integer in words format\n        \"\"\"\n        if num == 0:\n            return \"ZERO\"\n        words = []\n        index = 0\n        while num > 0:\n            part = num % 1000\n            if part > 0:\n                words.append(self.trans_three(f\"{part:03d}\") + (\" \" + self.NUMBER_MORE[index] if index > 0 else \"\"))\n            num //= 1000\n            index += 1\n        return \" AND \".join(reversed(words)).strip() + \" ONLY\"\n```",
    "75": "```python\nclass ShoppingCart:\n    \"\"\"\n    The class manages items, their prices, quantities, and allows for adding, removing, viewing items, and calculating the total price.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the items representing the shopping list as an empty dictionary.\n        \"\"\"\n        self.items = {}\n\n    def add_item(self, item: str, price: float, quantity: int = 1) -> None:\n        \"\"\"\n        Add item information to the shopping list items, including price and quantity. The default quantity is 1.\n        :param item: string, Item to be added.\n        :param price: float, The price of the item.\n        :param quantity: int, The number of items, defaults to 1.\n        :return: None\n        \"\"\"\n        if item in self.items:\n            self.items[item]['quantity'] += quantity\n        else:\n            self.items[item] = {'price': price, 'quantity': quantity}\n\n    def remove_item(self, item: str, quantity: int = 1) -> None:\n        \"\"\"\n        Subtract the specified quantity of item from the shopping list items.\n        :param item: string, Item to be subtracted in quantity.\n        :param quantity: int, Quantity to be subtracted.\n        :return: None\n        \"\"\"\n        if item in self.items:\n            if self.items[item]['quantity'] <= quantity:\n                del self.items[item]\n            else:\n                self.items[item]['quantity'] -= quantity\n\n    def view_items(self) -> dict:\n        \"\"\"\n        Return the current shopping list items.\n        :return: dict, the current shopping list items.\n        \"\"\"\n        return self.items\n\n    def total_price(self) -> float:\n        \"\"\"\n        Calculate the total price of all items in the shopping list, which is the quantity of each item multiplied by the price.\n        :return: float, the total price of all items in the shopping list.\n        \"\"\"\n        return sum(item['price'] * item['quantity'] for item in self.items.values())\n```",
    "76": "```python\nclass SignInSystem:\n    \"\"\"\n    A class representing a sign-in system, including functionalities for adding users, \n    signing in/out, checking sign-in status, and retrieving signed-in/not signed-in users.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the sign-in system.\n        \"\"\"\n        self.users = {}\n\n    def add_user(self, username: str) -> bool:\n        \"\"\"\n        Add a user to the sign-in system if the user doesn't already exist.\n        The initial sign-in state is set to False.\n        \n        :param username: str, the username to be added.\n        :return: bool, True if the user is added successfully, False if the user already exists.\n        \"\"\"\n        if username in self.users:\n            return False\n        self.users[username] = False\n        return True\n\n    def sign_in(self, username: str) -> bool:\n        \"\"\"\n        Sign in a user if they exist in the users list and are not already signed in.\n        \n        :param username: str, the username to be signed in.\n        :return: bool, True if the user is signed in successfully, False if the user does not exist or is already signed in.\n        \"\"\"\n        if username in self.users and not self.users[username]:\n            self.users[username] = True\n            return True\n        return False\n\n    def check_sign_in(self, username: str) -> bool:\n        \"\"\"\n        Check if a user is signed in.\n        \n        :param username: str, the username to be checked.\n        :return: bool, True if the user is signed in, False if the user does not exist or is not signed in.\n        \"\"\"\n        return self.users.get(username, False)\n\n    def all_signed_in(self) -> bool:\n        \"\"\"\n        Check if all users are signed in.\n        \n        :return: bool, True if all users are signed in, False otherwise.\n        \"\"\"\n        return all(self.users.values())\n\n    def all_not_signed_in(self) -> list[str]:\n        \"\"\"\n        Get a list of usernames that are not signed in.\n        \n        :return: list[str], a list of usernames that are not signed in.\n        \"\"\"\n        return [username for username, signed_in in self.users.items() if not signed_in]\n```",
    "78": "```python\nimport re\n\nclass SplitSentence:\n    \"\"\"\n    The class allows to split sentences, count words in a sentence, and process a text to find the maximum word count of sentences.\n    \"\"\"\n\n    def split_sentences(self, sentences_string):\n        \"\"\"\n        Split a string into a list of sentences. Sentences end with . or ? and with a space after that. \n        Note that Mr. also ends with . but is not treated as a sentence end.\n        \n        :param sentences_string: str, string to split\n        :return: list, split sentence list\n        >>> ss = SplitSentence()\n        >>> ss.split_sentences(\"aaa aaaa. bb bbbb bbb? cccc cccc. dd ddd?\")\n        ['aaa aaaa.', 'bb bbbb bbb?', 'cccc cccc.', 'dd ddd?']\n        \"\"\"\n        return re.split(r'(?<!Mr)\\. |\\? ', sentences_string.strip())\n\n    def count_words(self, sentence):\n        \"\"\"\n        Count the number of words in a sentence. Words are defined as sequences of alphabetic characters.\n        \n        :param sentence: str, sentence to be counted\n        :return: int, number of words in the sentence\n        >>> ss = SplitSentence()\n        >>> ss.count_words(\"abc def\")\n        2\n        \"\"\"\n        words = re.findall(r'\\b[a-zA-Z]+\\b', sentence)\n        return len(words)\n\n    def process_text_file(self, sentences_string):\n        \"\"\"\n        Given a text, return the number of words in the longest sentence.\n        \n        :param sentences_string: str, undivided long sentence\n        :return: int, the number of words in the longest sentence\n        >>> ss = SplitSentence()\n        >>> ss.process_text_file(\"aaa aaaa. bb bbbb bbb? cccc ccccccc cc ccc. dd ddd?\")\n        4\n        \"\"\"\n        sentences = self.split_sentences(sentences_string)\n        # Use max with a default value of 0 to handle empty input\n        max_words = max((self.count_words(sentence) for sentence in sentences), default=0)\n        return max_words\n```",
    "74": "```python\nclass Server:\n    \"\"\"\n    This is a class that acts as a server, which handles a whitelist, message sending and receiving, and information display.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the whitelist as an empty set for faster lookups, and initialize the sending and receiving information as empty dictionaries.\n        \"\"\"\n        self.white_list = set()\n        self.send_struct = {}\n        self.receive_struct = {}\n\n    def add_white_list(self, addr):\n        \"\"\"\n        Add an address to the whitelist and do nothing if it already exists.\n        :param addr: int, address to be added\n        :return: new whitelist or False if the address already exists\n        \"\"\"\n        if addr not in self.white_list:\n            self.white_list.add(addr)\n            return list(self.white_list)\n        return False\n\n    def del_white_list(self, addr):\n        \"\"\"\n        Remove an address from the whitelist and do nothing if it does not exist.\n        :param addr: int, address to be deleted\n        :return: new whitelist or False if the address does not exist\n        \"\"\"\n        if addr in self.white_list:\n            self.white_list.remove(addr)\n            return list(self.white_list)\n        return False\n\n    def recv(self, info):\n        \"\"\"\n        Receive information containing address and content. If the address is on the whitelist, receive the content; otherwise, do not receive it.\n        :param info: dict, information dictionary containing address and content\n        :return: content if successfully received, otherwise False\n        \"\"\"\n        addr = info.get(\"addr\")\n        if addr in self.white_list:\n            self.receive_struct[addr] = info['content']\n            return info['content']\n        return False\n\n    def send(self, info):\n        \"\"\"\n        Send information containing address and content.\n        :param info: dict, information dictionary containing address and content\n        :return: None if successfully sent, otherwise an error message\n        \"\"\"\n        addr = info.get(\"addr\")\n        if addr in self.white_list:\n            self.send_struct = info\n        else:\n            return 'Error: Address not in whitelist'\n\n    def show(self, struct_type):\n        \"\"\"\n        Returns struct of the specified type.\n        :param struct_type: string, the type of struct to be returned, which can be 'send' or 'receive'\n        :return: corresponding struct if valid, otherwise False\n        \"\"\"\n        if struct_type == 'send':\n            return self.send_struct\n        elif struct_type == 'receive':\n            return self.receive_struct\n        return False\n```",
    "77": "```python\nimport random\n\nclass Snake:\n    \"\"\"\n    The class is for a snake game that allows the snake to move, eat food, and reset the game.\n    \"\"\"\n\n    def __init__(self, screen_width, screen_height, block_size):\n        \"\"\"\n        Initialize the snake with its properties.\n        :param screen_width: int - width of the game screen\n        :param screen_height: int - height of the game screen\n        :param block_size: int - size of each block the snake moves\n        \"\"\"\n        self.length = 1\n        self.screen_width = screen_width\n        self.screen_height = screen_height\n        self.block_size = block_size\n        self.positions = [(screen_width // 2, screen_height // 2)]\n        self.score = 0\n        self.food_position = self.random_food_position()\n\n    def move(self, direction):\n        \"\"\"\n        Move the snake in the specified direction.\n        :param direction: tuple - (x, y) direction of movement\n        \"\"\"\n        new_head = (self.positions[0][0] + direction[0] * self.block_size, \n                     self.positions[0][1] + direction[1] * self.block_size)\n\n        # Check if the snake has eaten food\n        if new_head == self.food_position:\n            self.eat_food()\n        else:\n            # Move the snake\n            self.positions.insert(0, new_head)\n            if len(self.positions) > self.length:\n                self.positions.pop()\n\n        # Check for collision with itself\n        if new_head in self.positions[1:]:\n            self.reset()\n\n    def random_food_position(self):\n        \"\"\"\n        Generate a new food position that does not overlap with the snake.\n        :return: tuple - new food position (x, y)\n        \"\"\"\n        while True:\n            x = random.randint(0, (self.screen_width // self.block_size) - 1) * self.block_size\n            y = random.randint(0, (self.screen_height // self.block_size) - 1) * self.block_size\n            if (x, y) not in self.positions:\n                return (x, y)\n\n    def reset(self):\n        \"\"\"\n        Reset the game state.\n        \"\"\"\n        self.length = 1\n        self.positions = [(self.screen_width // 2, self.screen_height // 2)]\n        self.score = 0\n        self.food_position = self.random_food_position()\n\n    def eat_food(self):\n        \"\"\"\n        Handle the logic for eating food.\n        \"\"\"\n        self.length += 1\n        self.score += 100\n        self.food_position = self.random_food_position()\n```",
    "71": "```python\nclass PushBoxGame:\n    \"\"\"\n    This class implements a functionality of a sokoban game, where the player needs to move boxes to designated targets in order to win.\n    \"\"\"\n\n    def __init__(self, game_map):\n        \"\"\"\n        Initialize the push box game with the map and various attributes.\n        :param game_map: list[str], the map of the push box game, represented as a list of strings.\n            Each character on the map represents a different element, including the following:\n            - '#' represents a wall that neither the player nor the box can pass through;\n            - 'O' represents the initial position of the player;\n            - 'G' represents the target position;\n            - 'X' represents the initial position of the box.\n        \"\"\"\n        self.map = game_map\n        self.player_row = 0\n        self.player_col = 0\n        self.targets = []\n        self.boxes = []\n        self.target_count = 0\n        self.is_game_over = False\n        self.init_game()\n\n    def init_game(self):\n        \"\"\"\n        Initialize the game by setting the positions of the player, targets, and boxes based on the map.\n        \"\"\"\n        for r, row in enumerate(self.map):\n            for c, char in enumerate(row):\n                if char == 'O':\n                    self.player_row, self.player_col = r, c\n                elif char == 'G':\n                    self.targets.append((r, c))\n                elif char == 'X':\n                    self.boxes.append((r, c))\n\n    def check_win(self):\n        \"\"\"\n        Check if the game is won. The game is won when all the boxes are placed on target positions.\n        And update the value of self.is_game_over.\n        :return: True if all the boxes are placed on target positions, or False otherwise.\n        \"\"\"\n        self.is_game_over = all(box in self.targets for box in self.boxes)\n        return self.is_game_over\n\n    def move(self, direction):\n        \"\"\"\n        Move the player based on the specified direction and check if the game is won.\n        :param direction: str, the direction of the player's movement.\n            It can be 'w', 's', 'a', or 'd' representing up, down, left, or right respectively.\n        :return: True if the game is won, False otherwise.\n        \"\"\"\n        directions = {'w': (-1, 0), 's': (1, 0), 'a': (0, -1), 'd': (0, 1)}\n        if direction not in directions:\n            return False\n\n        dr, dc = directions[direction]\n        new_player_row = self.player_row + dr\n        new_player_col = self.player_col + dc\n\n        # Check for walls or out of bounds\n        if (0 <= new_player_row < len(self.map) and \n            0 <= new_player_col < len(self.map[0]) and \n            self.map[new_player_row][new_player_col] != '#'):\n            if (new_player_row, new_player_col) in self.boxes:\n                new_box_row = new_player_row + dr\n                new_box_col = new_player_col + dc\n                if (0 <= new_box_row < len(self.map) and \n                    0 <= new_box_col < len(self.map[0]) and \n                    self.map[new_box_row][new_box_col] != '#' and \n                    (new_box_row, new_box_col) not in self.boxes):\n                    # Move the box\n                    box_index = self.boxes.index((new_player_row, new_player_col))\n                    self.boxes[box_index] = (new_box_row, new_box_col)\n                else:\n                    return False  # Wall or another box in the way\n            # Move the player\n            self.player_row = new_player_row\n            self.player_col = new_player_col\n\n            # Check if the game is won\n            return self.check_win()\n        return False  # Wall or out of bounds\n\n    def print_map(self):\n        \"\"\"\n        Print the current state of the map.\n        \"\"\"\n        display_map = []\n        for r in range(len(self.map)):\n            row = list(self.map[r])\n            if (r, self.player_col) == (self.player_row, self.player_col):\n                row[self.player_col] = 'O'\n            for box in self.boxes:\n                if (r, box[1]) == box:\n                    row[box[1]] = 'X'\n            display_map.append(''.join(row))\n        print('\\n'.join(display_map))\n```",
    "79": "```python\nclass SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        fields_str = ', '.join(fields) if fields else '*'\n        condition_str = f' WHERE {condition}' if condition else ''\n        return f'SELECT {fields_str} FROM {self.table_name}{condition_str};'\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        keys = ', '.join(data.keys())\n        values = ', '.join(self._format_value(value) for value in data.values())\n        return f\"INSERT INTO {self.table_name} ({keys}) VALUES ({values});\"\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and values are new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        set_str = ', '.join(f\"{key} = {self._format_value(value)}\" for key, value in data.items())\n        return f\"UPDATE {self.table_name} SET {set_str} WHERE {condition};\"\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        return f'DELETE FROM {self.table_name} WHERE {condition};'\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        return f\"SELECT * FROM {self.table_name} WHERE age < {age} AND gender = 'female';\"\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        return f'SELECT * FROM {self.table_name} WHERE age BETWEEN {min_age} AND {max_age};'\n\n    def _format_value(self, value):\n        \"\"\"\n        Formats a value for SQL insertion, handling strings and other types appropriately.\n        :param value: The value to format.\n        :return: str. The formatted value.\n        \"\"\"\n        if isinstance(value, str):\n            return f\"'{value}'\"\n        elif value is None:\n            return 'NULL'\n        return str(value)\n```",
    "83": "```python\nimport sqlite3\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This class performs database operations, including inserting, searching, and deleting student information.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n        self.connection = sqlite3.connect(self.database_name)\n        self.cursor = self.connection.cursor()\n        self.create_student_table()\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.\n        \"\"\"\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS students (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                name TEXT NOT NULL,\n                age INTEGER,\n                gender TEXT,\n                grade INTEGER\n            )\n        ''')\n        self.connection.commit()\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n        \"\"\"\n        if not all(key in student_data for key in ['name', 'age', 'gender', 'grade']):\n            raise ValueError(\"Missing student data fields.\")\n        \n        self.cursor.execute('''\n            INSERT INTO students (name, age, gender, grade) \n            VALUES (?, ?, ?, ?)''', \n            (student_data['name'], student_data['age'], student_data['gender'], student_data['grade'])\n        )\n        self.connection.commit()\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n        \"\"\"\n        self.cursor.execute('''\n            SELECT * FROM students WHERE name = ?''', (name,))\n        return self.cursor.fetchall()\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        \"\"\"\n        self.cursor.execute('''\n            DELETE FROM students WHERE name = ?''', (name,))\n        self.connection.commit()\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        self.connection.close()\n```",
    "84": "```python\nimport json\nimport re\nimport os\n\nclass TextFileProcessor:\n    \"\"\"\n    The class handles reading, writing, and processing text files. It can read the file as JSON,\n    read the raw text, write content to the file, and process the file by removing non-alphabetic characters.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initialize the file path.\n        :param file_path: str\n        \"\"\"\n        if not isinstance(file_path, str):\n            raise ValueError(\"File path must be a string.\")\n        self.file_path = file_path\n\n    def read_file_as_json(self):\n        \"\"\"\n        Read the self.file_path file as json format.\n        If the file content doesn't obey json format, it raises a JSONDecodeError.\n        :return: dict if the file is stored as json format, or raises an error otherwise.\n        \"\"\"\n        if not os.path.exists(self.file_path):\n            raise FileNotFoundError(f\"No such file: '{self.file_path}'\")\n        with open(self.file_path, 'r') as file:\n            return json.load(file)\n\n    def read_file(self):\n        \"\"\"\n        Read and return the content of self.file_path file.\n        :return: the same return as the read() method\n        \"\"\"\n        if not os.path.exists(self.file_path):\n            raise FileNotFoundError(f\"No such file: '{self.file_path}'\")\n        with open(self.file_path, 'r') as file:\n            return file.read()\n\n    def write_file(self, content):\n        \"\"\"\n        Write content into the self.file_path file, overwriting if the file already exists.\n        :param content: str\n        \"\"\"\n        if not isinstance(content, str):\n            raise ValueError(\"Content must be a string.\")\n        with open(self.file_path, 'w') as file:\n            file.write(content)\n\n    def process_file(self):\n        \"\"\"\n        Read the self.file_path file and filter out non-alphabetic characters from the content string.\n        Overwrite the processed data into the same self.file_path file.\n        :return: the processed content string\n        \"\"\"\n        content = self.read_file()\n        processed_content = ''.join(re.findall(r'[a-zA-Z]', content))\n        self.write_file(processed_content)\n        return processed_content\n```",
    "81": "```python\nimport math\nfrom collections import Counter\n\nclass Statistics3:\n    \"\"\"\n    A class that implements methods for calculating indicators such as median, mode, correlation matrix, and Z-score in statistics.\n    \"\"\"\n\n    @staticmethod\n    def median(data):\n        \"\"\"\n        Calculates the median of the given list.\n        :param data: The given list, list.\n        :return: The median of the given list, float.\n        \"\"\"\n        if not data:\n            raise ValueError(\"The data list cannot be empty.\")\n        data = sorted(data)\n        n = len(data)\n        mid = n // 2\n        return (data[mid - 1] + data[mid]) / 2 if n % 2 == 0 else data[mid]\n\n    @staticmethod\n    def mode(data):\n        \"\"\"\n        Calculates the mode of the given list.\n        :param data: The given list, list.\n        :return: The mode of the given list, list.\n        \"\"\"\n        if not data:\n            raise ValueError(\"The data list cannot be empty.\")\n        count = Counter(data)\n        max_count = max(count.values())\n        modes = [key for key, value in count.items() if value == max_count]\n        return modes if len(modes) < len(data) else []\n\n    @staticmethod\n    def mean(data):\n        \"\"\"\n        Calculates the mean of the given list.\n        :param data: The given list, list.\n        :return: The mean of the given list, float.\n        \"\"\"\n        if not data:\n            raise ValueError(\"The data list cannot be empty.\")\n        return sum(data) / len(data)\n\n    @staticmethod\n    def standard_deviation(data):\n        \"\"\"\n        Calculates the standard deviation of the given list.\n        :param data: The given list, list.\n        :return: The standard deviation of the given list, float.\n        \"\"\"\n        if not data:\n            raise ValueError(\"The data list cannot be empty.\")\n        mean_value = Statistics3.mean(data)\n        variance = sum((x - mean_value) ** 2 for x in data) / len(data)\n        return math.sqrt(variance)\n\n    @staticmethod\n    def z_score(data):\n        \"\"\"\n        Calculates the z-score of the given list.\n        :param data: The given list, list.\n        :return: The z-score of the given list, list.\n        \"\"\"\n        if not data:\n            raise ValueError(\"The data list cannot be empty.\")\n        mean_value = Statistics3.mean(data)\n        std_dev = Statistics3.standard_deviation(data)\n        return [(x - mean_value) / std_dev for x in data]\n\n    @staticmethod\n    def correlation(x, y):\n        \"\"\"\n        Calculates the correlation of the given lists.\n        :param x: The first list, list.\n        :param y: The second list, list.\n        :return: The correlation of the given lists, float.\n        \"\"\"\n        if len(x) != len(y):\n            raise ValueError(\"The two lists must have the same length.\")\n        n = len(x)\n        mean_x = Statistics3.mean(x)\n        mean_y = Statistics3.mean(y)\n        numerator = sum((x[i] - mean_x) * (y[i] - mean_y) for i in range(n))\n        denominator_x = math.sqrt(sum((x[i] - mean_x) ** 2 for i in range(n)))\n        denominator_y = math.sqrt(sum((y[i] - mean_y) ** 2 for i in range(n)))\n        return numerator / (denominator_x * denominator_y) if denominator_x and denominator_y else 0\n\n    @staticmethod\n    def correlation_matrix(data):\n        \"\"\"\n        Calculates the correlation matrix of the given list of lists.\n        :param data: The given list of lists, list.\n        :return: The correlation matrix, list of lists.\n        \"\"\"\n        if not data or any(len(row) != len(data[0]) for row in data):\n            raise ValueError(\"All rows must have the same length and data must not be empty.\")\n        n = len(data)\n        return [[Statistics3.correlation(data[i], data[j]) for j in range(n)] for i in range(n)]\n```",
    "80": "```python\nclass SQLQueryBuilder:\n    \"\"\"\n    This class provides methods to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements. \n    \"\"\"\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in database.\n        :param columns: list of str, ['col1', 'col2'] or '*' for all columns.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return: str, the SQL query statement.\n        \"\"\"\n        columns_str = ', '.join(columns) if isinstance(columns, (list, tuple)) else columns\n        query = f\"SELECT {columns_str} FROM {table}\"\n        if where:\n            conditions = ' AND '.join([f\"{key}='{value}'\" for key, value in where.items()])\n            query += f\" WHERE {conditions}\"\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to be inserted into in the database.\n        :param data: dict, the key and value in SQL insert statement.\n        :return: str, the SQL insert statement.\n        \"\"\"\n        columns = ', '.join(data.keys())\n        values = ', '.join([f\"'{value}'\" for value in data.values()])\n        query = f\"INSERT INTO {table} ({columns}) VALUES ({values})\"\n        return query\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table that will be executed with DELETE operation in the database.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return: str, the SQL delete statement.\n        \"\"\"\n        query = f\"DELETE FROM {table}\"\n        if where:\n            conditions = ' AND '.join([f\"{key}='{value}'\" for key, value in where.items()])\n            query += f\" WHERE {conditions}\"\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table that will be executed with UPDATE operation in the database.\n        :param data: dict, the key and value in SQL update statement.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return: str, the SQL update statement.\n        \"\"\"\n        set_clause = ', '.join([f\"{key}='{value}'\" for key, value in data.items()])\n        query = f\"UPDATE {table} SET {set_clause}\"\n        if where:\n            conditions = ' AND '.join([f\"{key}='{value}'\" for key, value in where.items()])\n            query += f\" WHERE {conditions}\"\n        return query\n```",
    "85": "```python\nimport time\n\nclass Thermostat:\n    \"\"\"\n    The class manages temperature control, including setting and retrieving the target temperature,\n    adjusting the mode, and simulating temperature operation.\n    \"\"\"\n\n    VALID_MODES = {'heat', 'cool'}\n\n    def __init__(self, current_temperature: float, target_temperature: float, mode: str):\n        \"\"\"\n        Initialize instances of the Thermostat class.\n        :param current_temperature: float\n        :param target_temperature: float\n        :param mode: str, the working mode\n        \"\"\"\n        self.current_temperature = current_temperature\n        self.target_temperature = target_temperature\n        self.mode = mode if mode in self.VALID_MODES else 'cool'  # Default to 'cool' if invalid mode\n\n    def get_target_temperature(self) -> float:\n        \"\"\"Get the target temperature.\"\"\"\n        return self.target_temperature\n\n    def set_target_temperature(self, temperature: float) -> None:\n        \"\"\"Set the target temperature.\"\"\"\n        self.target_temperature = temperature\n\n    def get_mode(self) -> str:\n        \"\"\"Get the current working mode.\"\"\"\n        return self.mode\n\n    def set_mode(self, mode: str) -> None:\n        \"\"\"Set the current working mode.\"\"\"\n        if mode in self.VALID_MODES:\n            self.mode = mode\n\n    def auto_set_mode(self) -> None:\n        \"\"\"Automatically set the operating mode based on temperature comparison.\"\"\"\n        self.mode = 'heat' if self.current_temperature < self.target_temperature else 'cool'\n\n    def auto_check_conflict(self) -> bool:\n        \"\"\"\n        Check for conflicts between the current mode and temperatures.\n        Return True if there's no conflict, False otherwise.\n        \"\"\"\n        conflict = (self.current_temperature < self.target_temperature and self.mode == 'cool') or \\\n                   (self.current_temperature > self.target_temperature and self.mode == 'heat')\n\n        if conflict:\n            self.auto_set_mode()\n        return not conflict\n\n    def simulate_operation(self) -> int:\n        \"\"\"Simulate the thermostat operation until the target temperature is reached.\"\"\"\n        self.auto_set_mode()\n        start_time = time.time()\n\n        while abs(self.current_temperature - self.target_temperature) > 0.01:  # Allow for small precision\n            if self.mode == 'heat':\n                self.current_temperature += 1  # Simulating heating\n            else:\n                self.current_temperature -= 1  # Simulating cooling\n\n            time.sleep(0.1)  # Simulate time delay\n\n            # Check for conflicts and auto-adjust if necessary\n            self.auto_check_conflict()\n\n        return int(time.time() - start_time)\n```",
    "86": "```python\nclass TicTacToe:\n    \"\"\"\n    Represents a game of Tic-Tac-Toe. Includes methods for making a move, checking for a winner, and determining if the board is full.\n    \"\"\"\n\n    def __init__(self, N=3):\n        \"\"\"\n        Initializes an N x N game board with all empty spaces. The current player is set to 'X'.\n        :param N: int, size of the Tic-Tac-Toe board (default is 3)\n        \"\"\"\n        self.N = N\n        self.board = [[' ' for _ in range(N)] for _ in range(N)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Places the current player's mark at the specified position on the board and switches the player.\n        :param row: int, the row index of the position\n        :param col: int, the column index of the position\n        :return: bool, indicating whether the move was successful or not\n        \"\"\"\n        if 0 <= row < self.N and 0 <= col < self.N and self.board[row][col] == ' ':\n            self.board[row][col] = self.current_player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        return False\n\n    def check_winner(self):\n        \"\"\"\n        Checks if there is a winner on the board in rows, columns, and diagonals.\n        :return: str or None, the mark of the winner ('X' or 'O'), or None if there is no winner yet\n        \"\"\"\n        # Check rows\n        for row in self.board:\n            if row.count(row[0]) == self.N and row[0] != ' ':\n                return row[0]\n\n        # Check columns\n        for col in range(self.N):\n            if all(self.board[row][col] == self.board[0][col] and self.board[0][col] != ' ' for row in range(self.N)):\n                return self.board[0][col]\n\n        # Check diagonals\n        if all(self.board[i][i] == self.board[0][0] and self.board[0][0] != ' ' for i in range(self.N)):\n            return self.board[0][0]\n        if all(self.board[i][self.N - 1 - i] == self.board[0][self.N - 1] and self.board[0][self.N - 1] != ' ' for i in range(self.N)):\n            return self.board[0][self.N - 1]\n\n        return None\n\n    def is_board_full(self):\n        \"\"\"\n        Checks if the game board is completely filled.\n        :return: bool, indicating whether the game board is full or not\n        \"\"\"\n        return all(cell != ' ' for row in self.board for cell in row)\n```",
    "89": "```python\nimport random\n\nclass TwentyFourPointGame:\n    \"\"\"\n    This is a game of twenty-four points, which generates four numbers and checks whether the player's expression evaluates to 24.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.nums = self._generate_cards()\n\n    def _generate_cards(self) -> list:\n        \"\"\"\n        Generate four random numbers between 1 and 9 for the cards.\n        :return: list of integers, representing the player's cards\n        \"\"\"\n        return [random.randint(1, 9) for _ in range(4)]\n\n    def get_my_cards(self) -> list:\n        \"\"\"\n        Get a list of four random numbers between 1 and 9 representing the player's cards.\n        :return: list of integers, representing the player's cards\n        >>> game = TwentyFourPointGame()\n        >>> len(game.get_my_cards()) == 4\n        True\n        \"\"\"\n        return self.nums\n\n    def answer(self, expression: str) -> bool:\n        \"\"\"\n        Check if a given mathematical expression using the cards can evaluate to 24.\n        :param expression: string, mathematical expression using the cards\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        >>> game = TwentyFourPointGame()\n        >>> game.nums = [4, 3, 6, 6]\n        >>> ans = \"4*3+6+6\"\n        >>> game.answer(ans)\n        True\n        \"\"\"\n        return self.evaluate_expression(expression)\n\n    def evaluate_expression(self, expression: str) -> bool:\n        \"\"\"\n        Evaluate a mathematical expression and check if the result is 24.\n        :param expression: string, mathematical expression\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        >>> game = TwentyFourPointGame()\n        >>> game.nums = [4, 3, 6, 6]\n        >>> ans = \"4*3+6+6\"\n        >>> game.evaluate_expression(ans)\n        True\n        \"\"\"\n        try:\n            result = eval(expression)\n            return result == 24\n        except (SyntaxError, NameError, ZeroDivisionError):\n            return False\n```",
    "88": "```python\nfrom math import pi\n\nclass TriCalculator:\n    \"\"\"\n    The class allows to calculate trigonometric values, including cosine, sine, and tangent, using Taylor series approximations.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def cos(self, x):\n        \"\"\"\n        Calculate the cos value of the x-degree angle.\n        :param x: float\n        :return: float\n        >>> tricalculator = TriCalculator()\n        >>> tricalculator.cos(60)\n        0.5\n        \"\"\"\n        return self.taylor_cos(x, 50)\n\n    def factorial(self, a):\n        \"\"\"\n        Calculate the factorial of a non-negative integer a.\n        :param a: int\n        :return: int\n        >>> tricalculator = TriCalculator()\n        >>> tricalculator.factorial(5)\n        120\n        \"\"\"\n        if a < 0:\n            raise ValueError(\"Factorial is not defined for negative numbers.\")\n        if a == 0 or a == 1:\n            return 1\n        result = 1\n        for i in range(2, a + 1):\n            result *= i\n        return result\n\n    def taylor_cos(self, x, n):\n        \"\"\"\n        Finding the n-order Taylor expansion value of cos (x/180 * pi).\n        :param x: int\n        :param n: int\n        :return: float\n        >>> tricalculator = TriCalculator()\n        >>> tricalculator.taylor_cos(60, 50)\n        0.5000000000000001\n        \"\"\"\n        radians = x * (pi / 180)\n        cos_value = 0\n        for i in range(n):\n            sign = (-1) ** i\n            cos_value += sign * (radians ** (2 * i)) / self.factorial(2 * i)\n        return cos_value\n\n    def sin(self, x):\n        \"\"\"\n        Calculate the sin value of the x-degree angle.\n        :param x: float\n        :return: float\n        >>> tricalculator = TriCalculator()\n        >>> tricalculator.sin(30)\n        0.5\n        \"\"\"\n        return self.taylor_sin(x, 50)\n\n    def taylor_sin(self, x, n):\n        \"\"\"\n        Finding the n-order Taylor expansion value of sin (x/180 * pi).\n        :param x: int\n        :param n: int\n        :return: float\n        >>> tricalculator = TriCalculator()\n        >>> tricalculator.taylor_sin(30, 50)\n        0.49999999999999994\n        \"\"\"\n        radians = x * (pi / 180)\n        sin_value = 0\n        for i in range(n):\n            sign = (-1) ** i\n            sin_value += sign * (radians ** (2 * i + 1)) / self.factorial(2 * i + 1)\n        return sin_value\n\n    def tan(self, x):\n        \"\"\"\n        Calculate the tan value of the x-degree angle.\n        :param x: float\n        :return: float\n        >>> tricalculator = TriCalculator()\n        >>> tricalculator.tan(45)\n        1.0\n        \"\"\"\n        sin_value = self.sin(x)\n        cos_value = self.cos(x)\n        if cos_value == 0:\n            raise ValueError(\"Tangent is undefined for angles that result in cos being 0.\")\n        return sin_value / cos_value\n```",
    "91": "```python\nimport urllib.parse\n\nclass UrlPath:\n    \"\"\"\n    A utility class for encapsulating and manipulating the path component of a URL,\n    including adding segments, parsing path strings, and building path strings \n    with optional encoding.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the UrlPath object with an empty list of segments.\n        \"\"\"\n        self.segments = []\n\n    def add(self, segment):\n        \"\"\"\n        Adds a segment to the list of segments in the UrlPath.\n        :param segment: str, the segment to add. Must be a non-empty string.\n        :raises ValueError: if segment is an empty string.\n        \"\"\"\n        if not segment:\n            raise ValueError(\"Segment cannot be an empty string.\")\n        self.segments.append(segment)\n\n    def parse(self, path, charset='utf-8'):\n        \"\"\"\n        Parses a given path string and populates the list of segments in the UrlPath.\n        :param path: str, the path string to parse.\n        :param charset: str, the character encoding of the path string (default is 'utf-8').\n        \"\"\"\n        fixed_path = self.fix_path(path)\n        self.segments = [urllib.parse.unquote(segment, encoding=charset) \n                         for segment in fixed_path.split('/') if segment]\n\n    @staticmethod\n    def fix_path(path):\n        \"\"\"\n        Fixes the given path string by removing leading and trailing slashes.\n        :param path: str, the path string to fix.\n        :return: str, the fixed path string.\n        \"\"\"\n        return path.strip('/')\n\n    def build(self):\n        \"\"\"\n        Constructs the complete path string from the segments, adding leading and \n        trailing slashes if necessary.\n        :return: str, the constructed path string.\n        \"\"\"\n        return '/' + '/'.join(self.segments) + ('/' if self.segments else '')\n\n    def clear(self):\n        \"\"\"\n        Clears all segments in the UrlPath.\n        \"\"\"\n        self.segments.clear()\n\n    def __repr__(self):\n        \"\"\"\n        Returns a string representation of the UrlPath object.\n        \"\"\"\n        return f\"UrlPath(segments={self.segments})\"\n```",
    "82": "```python\nclass StockPortfolioTracker:\n    \"\"\"\n    A class to track a stock portfolio, allowing for adding, removing, buying, and selling stocks, \n    calculating the total value of the portfolio, and obtaining a summary of the portfolio.\n    \"\"\"\n\n    def __init__(self, cash_balance):\n        \"\"\"\n        Initialize the StockPortfolioTracker class with a cash balance and an empty portfolio.\n        :param cash_balance: Initial cash balance, float.\n        \"\"\"\n        self.portfolio = []\n        self.cash_balance = cash_balance\n\n    def add_stock(self, stock):\n        \"\"\"\n        Add a stock to the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\".\n        \"\"\"\n        if self.validate_stock(stock):\n            self.portfolio.append(stock)\n\n    def remove_stock(self, stock):\n        \"\"\"\n        Remove a stock from the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\".\n        :return: True if the stock was removed, False otherwise.\n        \"\"\"\n        for s in self.portfolio:\n            if s['name'] == stock['name'] and s['price'] == stock['price'] and s['quantity'] == stock['quantity']:\n                self.portfolio.remove(s)\n                return True\n        return False\n\n    def buy_stock(self, stock):\n        \"\"\"\n        Buy a stock and add it to the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\".\n        :return: True if the stock was bought successfully, False if the cash balance is not enough.\n        \"\"\"\n        total_cost = stock['price'] * stock['quantity']\n        if total_cost <= self.cash_balance and self.validate_stock(stock):\n            self.cash_balance -= total_cost\n            self.add_stock(stock)\n            return True\n        return False\n\n    def sell_stock(self, stock):\n        \"\"\"\n        Sell a stock and remove it from the portfolio, adding the cash to the cash balance.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\".\n        :return: True if the stock was sold successfully, False if the quantity of the stock is not enough.\n        \"\"\"\n        for s in self.portfolio:\n            if s['name'] == stock['name'] and s['quantity'] >= stock['quantity']:\n                total_sale = s['price'] * stock['quantity']\n                self.cash_balance += total_sale\n                s['quantity'] -= stock['quantity']\n                if s['quantity'] == 0:\n                    self.remove_stock(s)\n                return True\n        return False\n\n    def calculate_portfolio_value(self):\n        \"\"\"\n        Calculate the total value of the portfolio.\n        :return: the total value of the portfolio, float.\n        \"\"\"\n        return sum(s['price'] * s['quantity'] for s in self.portfolio)\n\n    def get_portfolio_summary(self):\n        \"\"\"\n        Get a summary of the portfolio.\n        :return: a tuple of the total value of the portfolio and a list of dictionaries with keys \"name\" and \"value\".\n        \"\"\"\n        total_value = self.calculate_portfolio_value()\n        summary = [{'name': s['name'], 'value': s['price'] * s['quantity']} for s in self.portfolio]\n        return total_value, summary\n\n    def get_stock_value(self, stock):\n        \"\"\"\n        Get the value of a stock.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\".\n        :return: the value of the stock, float.\n        \"\"\"\n        return stock['price'] * stock['quantity']\n\n    def validate_stock(self, stock):\n        \"\"\"\n        Validate stock dictionary format.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\".\n        :return: True if valid, False otherwise.\n        \"\"\"\n        return all(key in stock for key in [\"name\", \"price\", \"quantity\"]) and isinstance(stock['quantity'], int) and stock['quantity'] > 0\n```",
    "87": "```python\nimport datetime\n\nclass TimeUtils:\n    \"\"\"\n    A utility class for handling time and date operations including\n    getting the current time and date, adding seconds to a datetime,\n    converting between strings and datetime objects, calculating time \n    differences, and formatting datetime objects.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize TimeUtils and get the current datetime.\n        \"\"\"\n        self.current_datetime = datetime.datetime.now()\n\n    def get_current_time(self):\n        \"\"\"\n        Return the current time in the format '%H:%M:%S'.\n        :return: string\n        \"\"\"\n        return self.current_datetime.strftime('%H:%M:%S')\n\n    def get_current_date(self):\n        \"\"\"\n        Return the current date in the format '%Y-%m-%d'.\n        :return: string\n        \"\"\"\n        return self.current_datetime.strftime('%Y-%m-%d')\n\n    def add_seconds(self, seconds):\n        \"\"\"\n        Add the specified number of seconds to the current time.\n        :param seconds: int, number of seconds to add\n        :return: string, time after adding the specified number of seconds in the format '%H:%M:%S'\n        \"\"\"\n        new_time = self.current_datetime + datetime.timedelta(seconds=seconds)\n        return new_time.strftime('%H:%M:%S')\n\n    @staticmethod\n    def string_to_datetime(string):\n        \"\"\"\n        Convert a time string to a datetime instance.\n        :param string: string, the time string in format '%Y-%m-%d %H:%M:%S'\n        :return: datetime instance\n        \"\"\"\n        return datetime.datetime.strptime(string, \"%Y-%m-%d %H:%M:%S\")\n\n    @staticmethod\n    def datetime_to_string(dt):\n        \"\"\"\n        Convert a datetime instance to a string.\n        :param dt: datetime instance to convert\n        :return: string, converted time string in format '%Y-%m-%d %H:%M:%S'\n        \"\"\"\n        return dt.strftime('%Y-%m-%d %H:%M:%S')\n\n    def get_minutes(self, string_time1, string_time2):\n        \"\"\"\n        Calculate the number of minutes between two times.\n        :param string_time1: string, first time in format '%Y-%m-%d %H:%M:%S'\n        :param string_time2: string, second time in format '%Y-%m-%d %H:%M:%S'\n        :return: int, the number of minutes between the two times\n        \"\"\"\n        dt1 = self.string_to_datetime(string_time1)\n        dt2 = self.string_to_datetime(string_time2)\n        delta = dt2 - dt1\n        return round(delta.total_seconds() / 60)\n\n    @staticmethod\n    def get_format_time(year, month, day, hour, minute, second):\n        \"\"\"\n        Get formatted time string.\n        :param year: int\n        :param month: int\n        :param day: int\n        :param hour: int\n        :param minute: int\n        :param second: int\n        :return: string, formatted time string in \"YYYY-MM-DD HH:MM:SS\" format\n        \"\"\"\n        return f\"{year:04d}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:02d}\"\n```",
    "90": "```python\nfrom urllib.parse import urlparse, parse_qs\n\nclass URLHandler:\n    \"\"\"\n    The class supports handling URLs, including extracting the scheme, host, path, query parameters, and fragment.\n    \"\"\"\n\n    def __init__(self, url):\n        \"\"\"\n        Initialize URLHandler with the given URL.\n        :param url: str, the URL to be parsed\n        \"\"\"\n        self.url = url\n        self.parsed_url = urlparse(url)\n\n    def get_scheme(self):\n        \"\"\"\n        Get the scheme of the URL.\n        :return: str, the scheme of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_scheme()\n        'https'\n        \"\"\"\n        return self.parsed_url.scheme\n\n    def get_host(self):\n        \"\"\"\n        Get the host domain name of the URL.\n        :return: str, the host domain name of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_host()\n        'www.baidu.com'\n        \"\"\"\n        return self.parsed_url.hostname\n\n    def get_path(self):\n        \"\"\"\n        Get the path of the URL, including query and fragment if present.\n        :return: str, the path of the resource in the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_path()\n        '/s'\n        \"\"\"\n        return self.parsed_url.path\n\n    def get_full_path(self):\n        \"\"\"\n        Get the full path of the URL, including query and fragment.\n        :return: str, the full path of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_full_path()\n        '/s?wd=aaa&rsv_spt=1#page'\n        \"\"\"\n        full_path = self.parsed_url.path\n        if self.parsed_url.query:\n            full_path += '?' + self.parsed_url.query\n        if self.parsed_url.fragment:\n            full_path += '#' + self.parsed_url.fragment\n        return full_path\n\n    def get_query_params(self):\n        \"\"\"\n        Get the query parameters of the URL.\n        :return: dict, the request parameters of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_query_params()\n        {'wd': ['aaa'], 'rsv_spt': ['1']}\n        \"\"\"\n        return parse_qs(self.parsed_url.query)\n\n    def get_fragment(self):\n        \"\"\"\n        Get the fragment of the URL.\n        :return: str, the fragment after '#' of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_fragment()\n        'page'\n        \"\"\"\n        return self.parsed_url.fragment\n```",
    "92": "```python\nimport sqlite3\nfrom contextlib import closing\n\nclass UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information, \n    searching user information, deleting user information, and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.db_name = db_name\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates the \"users\" table if it does not exist.\n        \"\"\"\n        with closing(self.connect()) as conn:\n            cursor = conn.cursor()\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS users (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    username TEXT UNIQUE NOT NULL,\n                    password TEXT NOT NULL\n                )\n            ''')\n            conn.commit()\n\n    def connect(self):\n        \"\"\"\n        Establish a new database connection.\n        :return: sqlite3.Connection\n        \"\"\"\n        return sqlite3.connect(self.db_name)\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        \"\"\"\n        with closing(self.connect()) as conn:\n            cursor = conn.cursor()\n            try:\n                cursor.execute('''\n                    INSERT INTO users (username, password)\n                    VALUES (?, ?)\n                ''', (username, password))\n                conn.commit()\n            except sqlite3.IntegrityError:\n                print(f\"User '{username}' already exists.\")\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return: list of tuples, the rows from the \"users\" table that match the search criteria.\n        \"\"\"\n        with closing(self.connect()) as conn:\n            cursor = conn.cursor()\n            cursor.execute('''\n                SELECT * FROM users WHERE username = ?\n            ''', (username,))\n            return cursor.fetchall()\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        \"\"\"\n        with closing(self.connect()) as conn:\n            cursor = conn.cursor()\n            cursor.execute('''\n                DELETE FROM users WHERE username = ?\n            ''', (username,))\n            conn.commit()\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct.\n        :param username: str, the username of the user to validate.\n        :param password: str, the password of the user to validate.\n        :return: bool, representing whether the user can log in correctly.\n        \"\"\"\n        with closing(self.connect()) as conn:\n            cursor = conn.cursor()\n            cursor.execute('''\n                SELECT * FROM users WHERE username = ? AND password = ?\n            ''', (username, password))\n            return cursor.fetchone() is not None\n\n    def close(self):\n        \"\"\"\n        Closes the database connection. (Not needed with context management)\n        \"\"\"\n        pass\n```",
    "93": "```python\nimport numpy as np\n\nclass VectorUtil:\n    \"\"\"\n    The class provides vector operations, including calculating similarity, cosine similarities, average similarity, and IDF weights.\n    \"\"\"\n\n    @staticmethod\n    def similarity(vector_1, vector_2):\n        \"\"\"\n        Compute the cosine similarity between one vector and another vector.\n        :param vector_1: numpy.ndarray, expected shape (dim,).\n        :param vector_2: numpy.ndarray, expected shape (dim,).\n        :return: float, cosine similarity between `vector_1` and `vector_2`.\n        >>> vector_1 = np.array([1, 1])\n        >>> vector_2 = np.array([1, 0])\n        >>> VectorUtil.similarity(vector_1, vector_2)\n        0.7071067811865475\n        \"\"\"\n        norm_1 = np.linalg.norm(vector_1)\n        norm_2 = np.linalg.norm(vector_2)\n        if norm_1 == 0 or norm_2 == 0:\n            return 0.0\n        return np.dot(vector_1, vector_2) / (norm_1 * norm_2)\n\n    @staticmethod\n    def cosine_similarities(vector_1, vectors_all):\n        \"\"\"\n        Compute cosine similarities between one vector and a set of other vectors.\n        :param vector_1: numpy.ndarray, expected shape (dim,).\n        :param vectors_all: list of numpy.ndarray, expected shape (num_vectors, dim).\n        :return: numpy.ndarray, cosine similarities between `vector_1` and each row in `vectors_all`.\n        >>> vector1 = np.array([1, 2, 3])\n        >>> vectors_all = [np.array([4, 5, 6]), np.array([7, 8, 9])]\n        >>> VectorUtil.cosine_similarities(vector1, vectors_all)\n        array([0.97463185, 0.95941195])\n        \"\"\"\n        return np.array([VectorUtil.similarity(vector_1, vector) for vector in vectors_all])\n\n    @staticmethod\n    def n_similarity(vector_list_1, vector_list_2):\n        \"\"\"\n        Compute average cosine similarity between two sets of vectors.\n        :param vector_list_1: list of numpy.ndarray.\n        :param vector_list_2: list of numpy.ndarray.\n        :return: float, average cosine similarity between vector_list_1 and vector_list_2.\n        >>> vector_list1 = [np.array([1, 2, 3]), np.array([4, 5, 6])]\n        >>> vector_list2 = [np.array([7, 8, 9]), np.array([10, 11, 12])]\n        >>> VectorUtil.n_similarity(vector_list1, vector_list2)\n        0.9897287473881233\n        \"\"\"\n        similarities = [VectorUtil.similarity(v1, v2) for v1 in vector_list_1 for v2 in vector_list_2]\n        return np.mean(similarities) if similarities else 0.0\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num, number_dict):\n        \"\"\"\n        Calculate log((total_num + 1) / (count + 1)) for each count in number_dict.\n        :param total_num: int, total number of documents.\n        :param number_dict: dict, counts of documents containing each term.\n        :return: dict, IDF weights for each term.\n        >>> num_dict = {'key1': 1, 'key2': 2}\n        >>> VectorUtil.compute_idf_weight_dict(3, num_dict)\n        {'key1': 1.0986122886681098, 'key2': 0.8109302162163288}\n        \"\"\"\n        return {key: np.log((total_num + 1) / (count + 1)) for key, count in number_dict.items()}\n```",
    "94": "```python\nclass VendingMachine:\n    \"\"\"\n    A class to simulate a vending machine, including adding products, inserting coins, purchasing products, \n    viewing balance, replenishing product inventory, and displaying product information.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the vending machine's inventory and balance.\n        \"\"\"\n        self.inventory = {}\n        self.balance = 0.0\n\n    def add_item(self, item_name, price, quantity):\n        \"\"\"\n        Adds a product to the vending machine's inventory.\n        :param item_name: The name of the product to be added, str.\n        :param price: The price of the product to be added, float.\n        :param quantity: The quantity of the product to be added, int.\n        :return: None\n        \"\"\"\n        if price <= 0:\n            raise ValueError(\"Price must be greater than zero.\")\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be greater than zero.\")\n        self.inventory[item_name] = {'price': price, 'quantity': quantity}\n\n    def insert_coin(self, amount):\n        \"\"\"\n        Inserts coins into the vending machine.\n        :param amount: The amount of coins to be inserted, float.\n        :return: The balance of the vending machine after the coins are inserted, float.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError(\"Inserted amount must be greater than zero.\")\n        self.balance += amount\n        return self.balance\n\n    def purchase_item(self, item_name):\n        \"\"\"\n        Purchases a product from the vending machine.\n        :param item_name: The name of the product to be purchased, str.\n        :return: If successful, returns the balance of the vending machine after the product is purchased, float, otherwise returns False.\n        \"\"\"\n        if item_name in self.inventory:\n            item_info = self.inventory[item_name]\n            if item_info['quantity'] > 0:\n                if self.balance >= item_info['price']:\n                    self.balance -= item_info['price']\n                    item_info['quantity'] -= 1\n                    return self.balance\n                return False  # Not enough balance\n            return False  # Out of stock\n        return False  # Item does not exist\n\n    def restock_item(self, item_name, quantity):\n        \"\"\"\n        Replenishes the inventory of a product already in the vending machine.\n        :param item_name: The name of the product to be replenished, str.\n        :param quantity: The quantity of the product to be replenished, int.\n        :return: If the product is already in the vending machine, returns True, otherwise returns False.\n        \"\"\"\n        if item_name in self.inventory and quantity > 0:\n            self.inventory[item_name]['quantity'] += quantity\n            return True\n        return False\n\n    def display_items(self):\n        \"\"\"\n        Displays the products in the vending machine.\n        :return: If the vending machine is empty, returns False, otherwise returns a string of the products in the vending machine.\n        \"\"\"\n        if not self.inventory:\n            return False\n        return ', '.join(f\"{item} - ${info['price']:.2f} [{info['quantity']}]\" for item, info in self.inventory.items())\n```",
    "96": "```python\nclass WeatherSystem:\n    \"\"\"\n    This class represents a weather system that provides functionality to query weather information for a specific city \n    and convert temperature units between Celsius and Fahrenheit.\n    \"\"\"\n\n    def __init__(self, city: str) -> None:\n        \"\"\"\n        Initialize the weather system with a city name.\n        :param city: The name of the city.\n        \"\"\"\n        self.city = city\n        self.temperature = None\n        self.weather = None\n\n    def query(self, weather_list: dict, tmp_units: str = 'celsius') -> tuple:\n        \"\"\"\n        Query the weather system for the weather and temperature of the city,\n        and convert the temperature units based on the input parameter.\n        \n        :param weather_list: A dictionary of weather information for different cities.\n        :param tmp_units: The temperature units to convert to, either 'celsius' or 'fahrenheit'.\n        :return: The temperature and weather of the city as a tuple.\n\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weather_list = {'New York': {'weather': 'sunny', 'temperature': 27},\n        ...                  'Beijing': {'weather': 'cloudy', 'temperature': 23}}\n        >>> weatherSystem.query(weather_list)\n        (27, 'sunny')\n        \"\"\"\n        if self.city not in weather_list:\n            raise ValueError(\"City not found in the weather list.\")\n        \n        self.weather = weather_list[self.city]['weather']\n        self.temperature = weather_list[self.city]['temperature']\n        \n        if tmp_units == 'fahrenheit':\n            self.temperature = self.celsius_to_fahrenheit(self.temperature)\n        \n        return self.temperature, self.weather\n\n    def set_city(self, city: str) -> None:\n        \"\"\"\n        Set the city of the weather system.\n        \n        :param city: The city to set.\n        \"\"\"\n        self.city = city\n\n    @staticmethod\n    def celsius_to_fahrenheit(celsius: float) -> float:\n        \"\"\"\n        Convert the temperature from Celsius to Fahrenheit.\n        \n        :param celsius: Temperature in Celsius.\n        :return: The temperature in Fahrenheit.\n        \n        >>> WeatherSystem.celsius_to_fahrenheit(27)\n        80.6\n        \"\"\"\n        return (celsius * 9/5) + 32\n\n    @staticmethod\n    def fahrenheit_to_celsius(fahrenheit: float) -> float:\n        \"\"\"\n        Convert the temperature from Fahrenheit to Celsius.\n        \n        :param fahrenheit: Temperature in Fahrenheit.\n        :return: The temperature in Celsius.\n        \n        >>> WeatherSystem.fahrenheit_to_celsius(80.6)\n        27.0\n        \"\"\"\n        return (fahrenheit - 32) * 5/9\n```",
    "98": "```python\nimport xml.etree.ElementTree as ET\nimport os\n\n\nclass XMLProcessor:\n    \"\"\"\n    A class to handle XML files, including reading, writing, processing, and finding elements in an XML file.\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize the XMLProcessor object with the given file name.\n        :param file_name: string, the name of the XML file to be processed.\n        \"\"\"\n        self.file_name = file_name\n        self.root = None\n\n    def read_xml(self):\n        \"\"\"\n        Reads the XML file and returns the root element.\n        :return: Element, the root element of the XML file, or None if an error occurs.\n        \"\"\"\n        if not os.path.exists(self.file_name):\n            print(f\"File {self.file_name} not found.\")\n            return None\n        \n        try:\n            tree = ET.parse(self.file_name)\n            self.root = tree.getroot()\n            return self.root\n        except ET.ParseError as e:\n            print(f\"Error parsing XML: {e}\")\n            return None\n\n    def write_xml(self, file_name):\n        \"\"\"\n        Writes the XML data to the specified file.\n        :param file_name: string, the name of the file to write the XML data.\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n        if self.root is None:\n            print(\"No XML data to write.\")\n            return False\n        \n        try:\n            tree = ET.ElementTree(self.root)\n            tree.write(file_name, encoding='utf-8', xml_declaration=True)\n            return True\n        except Exception as e:\n            print(f\"Error writing XML: {e}\")\n            return False\n\n    def process_xml_data(self, file_name):\n        \"\"\"\n        Modifies the data in XML elements and writes the updated XML data to a new file.\n        :param file_name: string, the name of the file to write the modified XML data.\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n        if self.root is None:\n            print(\"No XML data to process.\")\n            return False\n        \n        # Example processing: change all text to uppercase\n        for elem in self.root.iter():\n            if elem.text:\n                elem.text = elem.text.upper()\n        \n        return self.write_xml(file_name)\n\n    def find_element(self, element_name):\n        \"\"\"\n        Finds the XML elements with the specified name.\n        :param element_name: string, the name of the elements to find.\n        :return: list, a list of found elements with the specified name.\n        \"\"\"\n        if self.root is None:\n            print(\"No XML data loaded.\")\n            return []\n        \n        return self.root.findall('.//' + element_name)\n```",
    "99": "```python\nimport zipfile\nimport os\n\n\nclass ZipFileProcessor:\n    \"\"\"\n    A class to process zip files, providing functionality to read, extract, and create zip files.\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize with the zip file name.\n        \n        :param file_name: str, name of the zip file.\n        \"\"\"\n        self.file_name = file_name\n\n    def _is_valid_zip(self):\n        \"\"\"Check if the given file is a valid zip file.\"\"\"\n        return os.path.isfile(self.file_name) and zipfile.is_zipfile(self.file_name)\n\n    def read_zip_file(self):\n        \"\"\"\n        Open and return the zip file object if valid; otherwise, return None.\n        \n        :return: zipfile.ZipFile or None\n        \"\"\"\n        if self._is_valid_zip():\n            return zipfile.ZipFile(self.file_name, 'r')\n        return None\n\n    def extract_all(self, output_path):\n        \"\"\"\n        Extract all contents of the zip file to the specified output path.\n        \n        :param output_path: str, directory where files will be extracted.\n        :return: bool, True if extraction is successful, otherwise False.\n        \"\"\"\n        if not os.path.exists(output_path):\n            os.makedirs(output_path)\n\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_ref:\n                zip_ref.extractall(output_path)\n            return True\n        except (FileNotFoundError, zipfile.BadZipFile, PermissionError) as e:\n            print(f\"Error extracting zip file: {e}\")\n            return False\n\n    def extract_file(self, file_name, output_path):\n        \"\"\"\n        Extract a specific file from the zip file to the specified output path.\n        \n        :param file_name: str, name of the file to be extracted.\n        :param output_path: str, directory where the file will be extracted.\n        :return: bool, True if extraction is successful, otherwise False.\n        \"\"\"\n        if not os.path.exists(output_path):\n            os.makedirs(output_path)\n\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_ref:\n                zip_ref.extract(file_name, output_path)\n            return True\n        except (FileNotFoundError, zipfile.BadZipFile, KeyError, PermissionError) as e:\n            print(f\"Error extracting file '{file_name}': {e}\")\n            return False\n\n    def create_zip_file(self, files, output_file_name):\n        \"\"\"\n        Create a zip file containing the specified list of files.\n        \n        :param files: list of str, list of file paths to compress.\n        :param output_file_name: str, path where the output zip file will be created.\n        :return: bool, True if compression is successful, otherwise False.\n        \"\"\"\n        try:\n            with zipfile.ZipFile(output_file_name, 'w') as zip_ref:\n                for file in files:\n                    if os.path.isfile(file):\n                        zip_ref.write(file, os.path.basename(file))\n                    else:\n                        print(f\"File '{file}' not found, skipping.\")\n            return True\n        except (IOError, PermissionError) as e:\n            print(f\"Error creating zip file: {e}\")\n            return False\n```",
    "97": "```python\nclass Words2Numbers:\n    \"\"\"\n    The class provides a text-to-number conversion utility, allowing conversion of written numbers (in words) to their numerical representation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the word lists and dictionaries required for conversion\n        \"\"\"\n        self.numwords = {}\n        self.units = [\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\n            \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n            \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\",\n        ]\n        self.tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        self.scales = [\"hundred\", \"thousand\", \"million\", \"billion\", \"trillion\"]\n\n        self.numwords[\"and\"] = (1, 0)\n        for idx, word in enumerate(self.units):\n            self.numwords[word] = (1, idx)\n        for idx, word in enumerate(self.tens):\n            self.numwords[word] = (1, idx * 10)\n        for idx, word in enumerate(self.scales):\n            self.numwords[word] = (10 ** (idx * 3), 0)\n\n        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}\n        self.ordinal_endings = [('ieth', 'y'), ('th', '')]\n\n    def text2int(self, textnum):\n        \"\"\"\n        Convert the word string to the corresponding integer string\n        :param textnum: string, the word string to be converted\n        :return: string, the final converted integer string\n        >>> w2n = Words2Numbers()\n        >>> w2n.text2int(\"thirty-two\")\n        \"32\"\n        \"\"\"\n        textnum = textnum.replace(\"-\", \" \")  # Handle hyphenated words\n        current = result = 0\n\n        for word in textnum.split():\n            if word not in self.numwords:\n                raise ValueError(f\"Invalid word: {word}\")\n            scale, increment = self.numwords[word]\n            current += increment\n            if scale > 1:\n                current *= scale\n                result += current\n                current = 0\n\n        return str(result + current)\n\n    def is_valid_input(self, textnum):\n        \"\"\"\n        Check if the input text contains only valid words that can be converted into numbers.\n        :param textnum: The input text containing words representing numbers.\n        :return: True if input is valid, False otherwise.\n        >>> w2n = Words2Numbers()\n        >>> w2n.is_valid_input(\"thirty-two\")\n        True\n        \"\"\"\n        for word in textnum.replace(\"-\", \" \").split():\n            if word not in self.numwords and word not in self.ordinal_words:\n                return False\n        return True\n```",
    "95": "```python\nclass Warehouse:\n    \"\"\"\n    The class manages inventory and orders, including adding products, updating product quantities,\n    retrieving product quantities, creating orders, changing order statuses, and tracking orders.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize two fields.\n        self.inventory is a dict that stores the products.\n        self.inventory = {Product ID: Product}\n        self.orders is a dict that stores the products in an order.\n        self.orders = {Order ID: Order}\n        \"\"\"\n        self.inventory = {}  # Product ID: Product\n        self.orders = {}  # Order ID: Order\n\n    def add_product(self, product_id, name, quantity):\n        \"\"\"\n        Add product to inventory or update the quantity if it already exists.\n        :param product_id: int\n        :param name: str, product name\n        :param quantity: int, product quantity\n        \"\"\"\n        if quantity < 0:\n            raise ValueError(\"Quantity cannot be negative.\")\n        \n        if product_id in self.inventory:\n            self.inventory[product_id]['quantity'] += quantity\n        else:\n            self.inventory[product_id] = {'name': name, 'quantity': quantity}\n\n    def update_product_quantity(self, product_id, quantity):\n        \"\"\"\n        Update the quantity of a product in inventory based on product_id.\n        :param product_id: int\n        :param quantity: int, quantity to add (can be negative to remove)\n        \"\"\"\n        if product_id not in self.inventory:\n            raise ValueError(\"Product ID does not exist in inventory.\")\n        \n        if self.inventory[product_id]['quantity'] + quantity < 0:\n            raise ValueError(\"Insufficient quantity in inventory.\")\n        \n        self.inventory[product_id]['quantity'] += quantity\n\n    def get_product_quantity(self, product_id):\n        \"\"\"\n        Get the quantity of a specific product by product_id.\n        :param product_id: int\n        :return: int quantity of product or None if not found\n        \"\"\"\n        return self.inventory.get(product_id, {}).get('quantity')\n\n    def create_order(self, order_id, product_id, quantity):\n        \"\"\"\n        Create an order which includes the information of product, like id and quantity.\n        :param order_id: int\n        :param product_id: int\n        :param quantity: int, quantity of product to order\n        :return: bool indicating success of order creation\n        \"\"\"\n        if product_id not in self.inventory or self.inventory[product_id]['quantity'] < quantity:\n            return False\n        \n        self.orders[order_id] = {\n            'product_id': product_id,\n            'quantity': quantity,\n            'status': 'Shipped'\n        }\n        self.update_product_quantity(product_id, -quantity)\n        return True\n\n    def change_order_status(self, order_id, status):\n        \"\"\"\n        Change the status of an order if the input order_id is in self.orders.\n        :param order_id: int\n        :param status: str, the state to change to\n        :return: bool indicating success of status change\n        \"\"\"\n        if order_id in self.orders:\n            self.orders[order_id]['status'] = status\n            return True\n        return False\n\n    def track_order(self, order_id):\n        \"\"\"\n        Get the status of a specific order.\n        :param order_id: int\n        :return: str status of the order or None if not found\n        \"\"\"\n        return self.orders.get(order_id, {}).get('status')\n```"
}