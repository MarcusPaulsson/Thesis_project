{
    "30": "```python\nimport numpy as np\n\nclass DataStatistics2:\n    \"\"\"\n    This is a class for performing data statistics, supporting to get the sum, minimum, maximum, variance, standard deviation, and correlation of a given dataset.\n    \"\"\"\n\n    def __init__(self, data):\n        \"\"\"\n        Initialize Data List\n        :param data:list\n        \"\"\"\n        self.data = np.array(data)\n\n    def get_sum(self):\n        \"\"\"\n        Calculate the sum of data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_sum()\n        10\n        \"\"\"\n        return np.sum(self.data)\n\n    def get_min(self):\n        \"\"\"\n        Calculate the minimum value in the data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_min()\n        1\n        \"\"\"\n        return np.min(self.data)\n\n    def get_max(self):\n        \"\"\"\n        Calculate the maximum value in the data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_max()\n        4\n        \"\"\"\n        return np.max(self.data)\n\n    def get_variance(self):\n        \"\"\"\n        Calculate variance, accurate to two digits after the Decimal separator\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_variance()\n        1.25\n        \"\"\"\n        return round(np.var(self.data, ddof=1), 2)\n\n    def get_std_deviation(self):\n        \"\"\"\n        Calculate standard deviation, accurate to two digits after the Decimal separator\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_std_deviation()\n        1.12\n        \"\"\"\n        return round(np.std(self.data, ddof=1), 2)\n\n    def get_correlation(self):\n        \"\"\"\n        Calculate correlation\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_correlation()\n        1.0\n        \"\"\"\n        if self.data.ndim == 1:\n            return 1.0  # Correlation of a single variable with itself is 1\n        else:\n            return np.corrcoef(self.data.T)[0, 1]\n```",
    "31": "```python\nimport math\nfrom statistics import mean, stdev\n\nclass DataStatistics4:\n    \"\"\"\n    This is a class that performs advanced mathematical calculations and statistics, including correlation coefficient, skewness, kurtosis, and probability density function (PDF) for a normal distribution.\n    \"\"\"\n\n    @staticmethod\n    def correlation_coefficient(data1, data2):\n        \"\"\"\n        Calculate the correlation coefficient of two sets of data.\n        :param data1: The first set of data, list.\n        :param data2: The second set of data, list.\n        :return: The correlation coefficient, float.\n        >>> DataStatistics4.correlation_coefficient([1, 2, 3], [4, 5, 6])\n        0.9999999999999998\n        \"\"\"\n        n = len(data1)\n        mean1 = mean(data1)\n        mean2 = mean(data2)\n        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))\n        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n)) * sum((data2[i] - mean2) ** 2 for i in range(n)))\n        return numerator / denominator if denominator != 0 else 0\n\n    @staticmethod\n    def skewness(data):\n        \"\"\"\n        Calculate the skewness of a set of data.\n        :param data: The input data list, list.\n        :return: The skewness, float.\n        >>> DataStatistics4.skewness([1, 2, 5])\n        2.3760224064818463\n        \"\"\"\n        n = len(data)\n        mean_data = mean(data)\n        stdev_data = stdev(data)\n        skew = (sum((x - mean_data) ** 3 for x in data) / n) / (stdev_data ** 3)\n        return skew\n\n    @staticmethod\n    def kurtosis(data):\n        \"\"\"\n        Calculate the kurtosis of a set of data.\n        :param data: The input data list, list.\n        :return: The kurtosis, float.\n        >>> DataStatistics4.kurtosis([1, 20,100])\n        -1.5000000000000007\n        \"\"\"\n        n = len(data)\n        mean_data = mean(data)\n        stdev_data = stdev(data)\n        kurt = (sum((x - mean_data) ** 4 for x in data) / n) / (stdev_data ** 4) - 3\n        return kurt\n\n    @staticmethod\n    def pdf(data, mu, sigma):\n        \"\"\"\n        Calculate the probability density function (PDF) of a set of data under a normal distribution.\n        :param data: The input data list, list.\n        :param mu: The mean of the normal distribution, float.\n        :param sigma: The standard deviation of the normal distribution, float.\n        :return: The probability density function (PDF), list.\n        >>> DataStatistics4.pdf([1, 2, 3], 1, 1)\n        [0.3989422804014327, 0.24197072451914337, 0.05399096651318806]\n        \"\"\"\n        pdf_values = [(1 / (math.sqrt(2 * math.pi) * sigma)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n        return pdf_values\n```",
    "32": "```python\nclass DecryptionUtils:\n    \"\"\"\n    This is a class that provides methods for decryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the decryption utility with a key.\n        :param key: The key to use for decryption,str.\n        \"\"\"\n        self.key = key\n\n    def caesar_decipher(self, ciphertext, shift):\n        \"\"\"\n        Deciphers the given ciphertext using the Caesar cipher\n        :param ciphertext: The ciphertext to decipher,str.\n        :param shift: The shift to use for decryption,int.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.caesar_decipher('ifmmp', 1)\n        'hello'\n        \"\"\"\n        plaintext = ''\n        for char in ciphertext:\n            if char.isalpha():\n                shift_amount = 65 if char.isupper() else 97\n                plaintext += chr((ord(char) - shift_amount - shift) % 26 + shift_amount)\n            else:\n                plaintext += char\n        return plaintext\n\n    def vigenere_decipher(self, ciphertext):\n        \"\"\"\n        Deciphers the given ciphertext using the Vigenere cipher\n        :param ciphertext: The ciphertext to decipher,str.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.vigenere_decipher('ifmmp')\n        'ybocl'\n        \"\"\"\n        plaintext = ''\n        key_length = len(self.key)\n        key_as_int = [ord(i) - 97 for i in self.key.lower()]\n        ciphertext_int = [ord(i) - 97 for i in ciphertext.lower()]\n        \n        for i in range(len(ciphertext_int)):\n            value = (ciphertext_int[i] - key_as_int[i % key_length]) % 26\n            plaintext += chr(value + 97)\n        \n        return plaintext\n\n    def rail_fence_decipher(self, encrypted_text, rails):\n        \"\"\"\n        Deciphers the given ciphertext using the Rail Fence cipher\n        :param encrypted_text: The ciphertext to decipher,str.\n        :param rails: The number of rails to use for decryption,int.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.rail_fence_decipher('Hoo!el,Wrdl l', 3)\n        'Hello, World!'\n        \"\"\"\n        length = len(encrypted_text)\n        rail = [['\\n' for _ in range(length)] for _ in range(rails)]\n        \n        dir_down = None\n        row, col = 0, 0\n        \n        for i in range(length):\n            if row == 0:\n                dir_down = True\n            if row == rails - 1:\n                dir_down = False\n                \n            rail[row][col] = '*'\n            col += 1\n            \n            if dir_down:\n                row += 1\n            else:\n                row -= 1\n        \n        index = 0\n        for i in range(rails):\n            for j in range(length):\n                if (rail[i][j] == '*' and index < length):\n                    rail[i][j] = encrypted_text[index]\n                    index += 1\n        \n        result = []\n        row, col = 0, 0\n        \n        for i in range(length):\n            if row == 0:\n                dir_down = True\n            if row == rails - 1:\n                dir_down = False\n                \n            if rail[row][col] != '\\n':\n                result.append(rail[row][col])\n                col += 1\n            \n            if dir_down:\n                row += 1\n            else:\n                row -= 1\n                \n        return ''.join(result)\n```",
    "33": "```python\nclass DiscountStrategy:\n    \"\"\"\n    This is a class that allows to use different discount strategy based on shopping credit or shopping cart in supermarket.\n    \"\"\"\n\n    def __init__(self, customer, cart, promotion=None):\n        \"\"\"\n        Initialize the DiscountStrategy with customer information, a cart of items, and an optional promotion.\n        :param customer: dict, customer information\n        :param cart: list of dicts, a cart of items with details\n        :param promotion: function, optional promotion applied to the order\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]\n        >>> DiscountStrategy(customer, cart, DiscountStrategy.FidelityPromo)\n        \"\"\"\n        self.customer = customer\n        self.cart = cart\n        self.promotion = promotion\n        self._total = self.total()\n\n    def total(self):\n        \"\"\"\n        Calculate the total cost of items in the cart.\n        :return: float, total cost of items\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]\n        >>> ds = DiscountStrategy(customer, cart)\n        >>> ds.total()\n        329.0\n        \"\"\"\n        return sum(item['quantity'] * item['price'] for item in self.cart)\n\n    def due(self):\n        \"\"\"\n        Calculate the final amount to be paid after applying the discount.\n        :return: float, final amount to be paid\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]\n        >>> ds = DiscountStrategy(customer, cart, DiscountStrategy.FidelityPromo)\n        >>> ds.due()\n        312.55\n        \"\"\"\n        discount = self.promotion(self) if self.promotion else 0\n        return self._total - discount\n\n    @staticmethod\n    def FidelityPromo(order):\n        \"\"\"\n        Calculate the discount based on the fidelity points of the customer. Customers with over 1000 points can enjoy a 5% discount on the entire order.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]\n        >>> order = DiscountStrategy(customer, cart, DiscountStrategy.FidelityPromo)\n        >>> DiscountStrategy.FidelityPromo(order)\n        16.45\n        \"\"\"\n        if order.customer['fidelity'] >= 1000:\n            return order.total() * 0.05\n        return 0\n\n    @staticmethod\n    def BulkItemPromo(order):\n        \"\"\"\n        Calculate the discount based on bulk item quantity in the order. In the same order, if the quantity of a single item reaches 20 or more, each item will enjoy a 10% discount.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 20, 'price': 23.5}]\n        >>> order = DiscountStrategy(customer, cart, DiscountStrategy.BulkItemPromo)\n        >>> DiscountStrategy.BulkItemPromo(order)\n        47.0\n        \"\"\"\n        discount = 0\n        for item in order.cart:\n            if item['quantity'] >= 20:\n                discount += item['quantity'] * item['price'] * 0.10\n        return discount\n\n    @staticmethod\n    def LargeOrderPromo(order):\n        \"\"\"\n        Calculate the discount based on the number of different products in the order. If the quantity of different products in the order reaches 10 or more, the entire order will enjoy a 7% discount.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]\n        >>> order = DiscountStrategy(customer, cart, DiscountStrategy.LargeOrderPromo)\n        >>> DiscountStrategy.LargeOrderPromo(order)\n        0.0\n        \"\"\"\n        if len(order.cart) >= 10:\n            return order.total() * 0.07\n        return 0\n```",
    "34": "```python\nfrom docx import Document\nfrom docx.shared import Pt\nfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENT\n\n\nclass DocFileHandler:\n    \"\"\"\n    This is a class that handles Word documents and provides functionalities for reading, writing, and modifying the content of Word documents.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initializes the DocFileHandler object with the specified file path.\n        :param file_path: str, the path to the Word document file.\n        \"\"\"\n        self.file_path = file_path\n        self.document = Document()\n\n    def read_text(self):\n        \"\"\"\n        Reads the content of a Word document and returns it as a string.\n        :return: str, the content of the Word document.\n        \"\"\"\n        try:\n            self.document = Document(self.file_path)\n            content = []\n            for paragraph in self.document.paragraphs:\n                content.append(paragraph.text)\n            return '\\n'.join(content)\n        except Exception as e:\n            print(f\"Error reading document: {e}\")\n            return \"\"\n\n    def write_text(self, content, font_size=12, alignment='left'):\n        \"\"\"\n        Writes the specified content to a Word document.\n        :param content: str, the text content to write.\n        :param font_size: int, optional, the font size of the text (default is 12).\n        :param alignment: str, optional, the alignment of the text ('left', 'center', or 'right'; default is 'left').\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n        try:\n            paragraph = self.document.add_paragraph(content)\n            run = paragraph.runs[0]\n            run.font.size = Pt(font_size)\n            paragraph.alignment = self._get_alignment_value(alignment)\n            self.document.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error writing to document: {e}\")\n            return False\n\n    def add_heading(self, heading, level=1):\n        \"\"\"\n        Adds a heading to the Word document.\n        :param heading: str, the text of the heading.\n        :param level: int, optional, the level of the heading (1, 2, 3, etc.; default is 1).\n        :return: bool, True if the heading is successfully added, False otherwise.\n        \"\"\"\n        try:\n            self.document.add_heading(heading, level=level)\n            self.document.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error adding heading: {e}\")\n            return False\n\n    def add_table(self, data):\n        \"\"\"\n        Adds a table to the Word document with the specified data.\n        :param data: list of lists, the data to populate the table.\n        :return: bool, True if the table is successfully added, False otherwise.\n        \"\"\"\n        try:\n            table = self.document.add_table(rows=len(data), cols=len(data[0]))\n            for i, row in enumerate(data):\n                for j, cell in enumerate(row):\n                    table.cell(i, j).text = str(cell)\n            self.document.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error adding table: {e}\")\n            return False\n\n    def _get_alignment_value(self, alignment):\n        \"\"\"\n        Returns the alignment value corresponding to the given alignment string.\n        :param alignment: str, the alignment string ('left', 'center', or 'right').\n        :return: int, the alignment value.\n        \"\"\"\n        if alignment == 'center':\n            return WD_PARAGRAPH_ALIGNMENT.CENTER\n        elif alignment == 'right':\n            return WD_PARAGRAPH_ALIGNMENT.RIGHT\n        else:\n            return WD_PARAGRAPH_ALIGNMENT.LEFT\n```",
    "35": "```python\nclass EightPuzzle:\n    def __init__(self, initial_state):\n        self.initial_state = initial_state\n        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n    def find_blank(self, state):\n        for i in range(3):\n            for j in range(3):\n                if state[i][j] == 0:\n                    return i, j\n\n    def move(self, state, direction):\n        i, j = self.find_blank(state)\n        new_state = [row[:] for row in state]  # Create a copy of the state\n\n        if direction == 'up' and i > 0:\n            new_state[i][j], new_state[i - 1][j] = new_state[i - 1][j], new_state[i][j]\n        elif direction == 'down' and i < 2:\n            new_state[i][j], new_state[i + 1][j] = new_state[i + 1][j], new_state[i][j]\n        elif direction == 'left' and j > 0:\n            new_state[i][j], new_state[i][j - 1] = new_state[i][j - 1], new_state[i][j]\n        elif direction == 'right' and j < 2:\n            new_state[i][j], new_state[i][j + 1] = new_state[i][j + 1], new_state[i][j]\n\n        return new_state\n\n    def get_possible_moves(self, state):\n        moves = []\n        i, j = self.find_blank(state)\n\n        if i > 0: moves.append('up')\n        if i < 2: moves.append('down')\n        if j > 0: moves.append('left')\n        if j < 2: moves.append('right')\n\n        return moves\n\n    def solve(self):\n        from collections import deque\n\n        open_list = deque([(self.initial_state, [])])\n        visited = set()\n        visited.add(tuple(map(tuple, self.initial_state)))\n\n        while open_list:\n            current_state, path = open_list.popleft()\n\n            if current_state == self.goal_state:\n                return path\n\n            possible_moves = self.get_possible_moves(current_state)\n\n            for move_direction in possible_moves:\n                new_state = self.move(current_state, move_direction)\n                new_state_tuple = tuple(map(tuple, new_state))\n\n                if new_state_tuple not in visited:\n                    visited.add(new_state_tuple)\n                    open_list.append((new_state, path + [move_direction]))\n\n        return None  # Return None if no solution found\n```",
    "36": "```python\nfrom datetime import datetime\n\nclass EmailClient:\n    \"\"\"\n    This is a class that serves as an email client, implementing functions such as checking emails, determining whether there is sufficient space, and cleaning up space\n    \"\"\"\n\n    def __init__(self, addr, capacity) -> None:\n        \"\"\"\n        Initializes the EmailClient class with the email address and the capacity of the email box.\n        :param addr: The email address, str.\n        :param capacity: The capacity of the email box, float.\n        \"\"\"\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox = []\n\n    def send_to(self, recv, content, size):\n        \"\"\"\n        Sends an email to the given email address.\n        :param recv: The email address of the receiver, str.\n        :param content: The content of the email, str.\n        :param size: The size of the email, float.\n        :return: True if the email is sent successfully, False if the receiver's email box is full.\n        \"\"\"\n        if recv.is_full_with_one_more_email(size):\n            return False\n        email = {\n            'sender': self.addr,\n            'receiver': recv.addr,\n            'content': content,\n            'size': size,\n            'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n            'state': 'unread'\n        }\n        recv.inbox.append(email)\n        return True\n\n    def fetch(self):\n        \"\"\"\n        Retrieves the first unread email in the email box and marks it as read.\n        :return: The first unread email in the email box, dict.\n        \"\"\"\n        for email in self.inbox:\n            if email['state'] == 'unread':\n                email['state'] = 'read'\n                return email\n        return None\n\n    def is_full_with_one_more_email(self, size):\n        \"\"\"\n        Determines whether the email box is full after adding an email of the given size.\n        :param size: The size of the email, float.\n        :return: True if the email box is full, False otherwise.\n        \"\"\"\n        return self.get_occupied_size() + size > self.capacity\n\n    def get_occupied_size(self):\n        \"\"\"\n        Gets the total size of the emails in the email box.\n        :return: The total size of the emails in the email box, float.\n        \"\"\"\n        return sum(email['size'] for email in self.inbox)\n\n    def clear_inbox(self, size):\n        \"\"\"\n        Clears the email box by deleting the oldest emails until the email box has enough space to accommodate the given size.\n        :param size: The size of the email, float.\n        \"\"\"\n        while self.get_occupied_size() + size > self.capacity and self.inbox:\n            self.inbox.pop(0)  # Remove the oldest email\n```",
    "37": "```python\nclass EncryptionUtils:\n    \"\"\"\n    This is a class that provides methods for encryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the class with a key.\n        :param key: The key to use for encryption, str.\n        \"\"\"\n        self.key = key\n\n    def caesar_cipher(self, plaintext, shift):\n        \"\"\"\n        Encrypts the plaintext using the Caesar cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :param shift: The number of characters to shift each character in the plaintext, int.\n        :return: The ciphertext, str.\n        >>> e = EncryptionUtils(\"key\")\n        >>> e.caesar_cipher(\"abc\", 1)\n        'bcd'\n        \"\"\"\n        result = \"\"\n        for char in plaintext:\n            if char.isalpha():\n                shift_base = ord('a') if char.islower() else ord('A')\n                result += chr((ord(char) - shift_base + shift) % 26 + shift_base)\n            else:\n                result += char\n        return result\n\n    def vigenere_cipher(self, plaintext):\n        \"\"\"\n        Encrypts the plaintext using the Vigenere cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :return: The ciphertext, str.\n        >>> e = EncryptionUtils(\"key\")\n        >>> e.vigenere_cipher(\"abc\")\n        'kfa'\n        \"\"\"\n        ciphertext = []\n        key_length = len(self.key)\n        for i, char in enumerate(plaintext):\n            if char.isalpha():\n                shift_base = ord('a') if char.islower() else ord('A')\n                key_char = self.key[i % key_length].lower()\n                shift = ord(key_char) - ord('a')\n                ciphertext.append(chr((ord(char) - shift_base + shift) % 26 + shift_base))\n            else:\n                ciphertext.append(char)\n        return ''.join(ciphertext)\n\n    def rail_fence_cipher(self, plaintext, rails):\n        \"\"\"\n        Encrypts the plaintext using the Rail Fence cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :param rails: The number of rails, int.\n        :return: The ciphertext, str.\n        >>> e = EncryptionUtils(\"key\")\n        >>> e.rail_fence_cipher(\"abc\", 2)\n        'acb'\n        \"\"\"\n        if rails <= 1:\n            return plaintext\n\n        rail = [['\\n' for _ in range(len(plaintext))]\n                for _ in range(rails)]\n        \n        dir_down = None\n        row, col = 0, 0\n\n        for char in plaintext:\n            if row == 0:\n                dir_down = True\n            if row == rails - 1:\n                dir_down = False\n\n            rail[row][col] = char\n            col += 1\n\n            if dir_down:\n                row += 1\n            else:\n                row -= 1\n\n        result = []\n        for r in rail:\n            for c in r:\n                if c != '\\n':\n                    result.append(c)\n        return ''.join(result)\n```",
    "38": "```python\nimport openpyxl\n\n\nclass ExcelProcessor:\n    \"\"\"\n    This is a class for processing excel files, including reading and writing excel data, as well as processing specific operations and saving as a new excel file.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_excel(self, file_name):\n        \"\"\"\n        Reading data from Excel files\n        :param file_name: str, Excel file name to read\n        :return: list of data, Data in Excel\n        \"\"\"\n        workbook = openpyxl.load_workbook(file_name)\n        sheet = workbook.active\n        data = []\n        for row in sheet.iter_rows(values_only=True):\n            data.append(row)\n        return data\n\n    def write_excel(self, data, file_name):\n        \"\"\"\n        Write data to the specified Excel file\n        :param data: list, Data to be written\n        :param file_name: str, Excel file name to write to\n        :return: 0 or 1, 1 represents successful writing, 0 represents failed writing\n        \"\"\"\n        try:\n            workbook = openpyxl.Workbook()\n            sheet = workbook.active\n            for row in data:\n                sheet.append(row)\n            workbook.save(file_name)\n            return 1\n        except Exception:\n            return 0\n\n    def process_excel_data(self, N, save_file_name):\n        \"\"\"\n        Change the specified column in the Excel file to uppercase\n        :param N: int, The serial number of the column that want to change\n        :param save_file_name: str, source file name\n        :return: (int, str), The former is the return value of write_excel, while the latter is the saved file name of the processed data\n        \"\"\"\n        data = self.read_excel(save_file_name)\n        for i in range(1, len(data)):  # Skip header\n            if len(data[i]) > N:\n                data[i] = list(data[i])  # Convert tuple to list to modify\n                data[i][N] = str(data[i][N]).upper()  # Change to uppercase\n        output_file_name = f'processed_{save_file_name}'\n        success = self.write_excel(data, output_file_name)\n        return success, output_file_name\n```",
    "39": "```python\nfrom collections import deque\n\nclass ExpressionCalculator:\n    \"\"\"\n    This is a class in Python that can perform calculations with basic arithmetic operations, including addition, subtraction, multiplication, division, and modulo.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the expression calculator\n        \"\"\"\n        self.postfix_stack = deque()\n        self.operat_priority = {'+': 1, '-': 1, '*': 2, '/': 2, '%': 2}\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the result of the given postfix expression\n        :param expression: string, the postfix expression to be calculated\n        :return: float, the calculated result\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.calculate(\"2 3 4 * +\")\n        14.0\n        \"\"\"\n        stack = []\n        tokens = expression.split()\n        for token in tokens:\n            if token.isdigit():\n                stack.append(float(token))\n            else:\n                second = stack.pop()\n                first = stack.pop()\n                result = self._calculate(first, second, token)\n                stack.append(result)\n        return stack[0]\n\n    def prepare(self, expression):\n        \"\"\"\n        Prepare the infix expression for conversion to postfix notation\n        :param expression: string, the infix expression to be prepared\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.prepare(\"2+3*4\")\n        expression_calculator.postfix_stack = ['2', '3', '4', '*', '+']\n        \"\"\"\n        output = []\n        stack = []\n        tokens = list(expression.replace(\" \", \"\"))\n        for token in tokens:\n            if token.isdigit():\n                output.append(token)\n            elif self.is_operator(token):\n                while (stack and stack[-1] != '(' and\n                       self.compare(token, stack[-1])):\n                    output.append(stack.pop())\n                stack.append(token)\n            elif token == '(':\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    output.append(stack.pop())\n                stack.pop()  # Pop the '('\n        while stack:\n            output.append(stack.pop())\n        self.postfix_stack = output\n\n    @staticmethod\n    def is_operator(c):\n        \"\"\"\n        Check if a character is an operator in {'+', '-', '*', '/', '(', ')', '%'}\n        :param c: string, the character to be checked\n        :return: bool, True if the character is an operator, False otherwise\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.is_operator(\"+\")\n        True\n        \"\"\"\n        return c in {'+', '-', '*', '/', '(', ')', '%'}\n\n    def compare(self, cur, peek):\n        \"\"\"\n        Compare the precedence of two operators\n        :param cur: string, the current operator\n        :param peek: string, the operator at the top of the operator stack\n        :return: bool, True if the current operator has higher or equal precedence, False otherwise\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.compare(\"+\", \"-\")\n        True\n        \"\"\"\n        return self.operat_priority[cur] <= self.operat_priority[peek]\n\n    @staticmethod\n    def _calculate(first_value, second_value, current_op):\n        \"\"\"\n        Perform the mathematical calculation based on the given operands and operator\n        :param first_value: float, the first operand\n        :param second_value: float, the second operand\n        :param current_op: string, the operator\n        :return: float, the calculated result\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator._calculate(2, 3, \"+\")\n        5.0\n        \"\"\"\n        if current_op == '+':\n            return first_value + second_value\n        elif current_op == '-':\n            return first_value - second_value\n        elif current_op == '*':\n            return first_value * second_value\n        elif current_op == '/':\n            return first_value / second_value\n        elif current_op == '%':\n            return first_value % second_value\n\n    @staticmethod\n    def transform(expression):\n        \"\"\"\n        Transform the infix expression to a format suitable for conversion\n        :param expression: string, the infix expression to be transformed\n        :return: string, the transformed expression\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.transform(\"2 + 3 * 4\")\n        \"2+3*4\"\n        \"\"\"\n        return expression.replace(\" \", \"\")\n```"
}