{
    "5": "```python\nclass AutomaticGuitarSimulator:\n    def __init__(self, text: str) -> None:\n        \"\"\"\n        Initialize the score to be played.\n        :param text: str, score to be played\n        \"\"\"\n        self.play_text = text\n\n    def interpret(self, display: bool = False) -> list[dict]:\n        \"\"\"\n        Interpret the music score to be played.\n        :param display: bool, representing whether to print the interpreted score\n        :return: list of dict, each dict contains 'Chord' and 'Tune'. \n                 If the input is empty or contains only whitespace, an empty list is returned.\n        \"\"\"\n        if not self.play_text.strip():\n            return []\n\n        play_list = []\n        for part in self.play_text.split():\n            chord, tune = self._separate_chord_and_tune(part)\n            play_list.append({'Chord': chord, 'Tune': tune})\n\n            if display:\n                print(self.display(chord, tune))\n\n        return play_list\n\n    def _separate_chord_and_tune(self, part: str) -> tuple[str, str]:\n        \"\"\"\n        Separate the chord (letters) from the tune (numbers).\n        :param part: str, the part of the score to be separated\n        :return: tuple of (chord, tune)\n        \"\"\"\n        chord = ''.join(filter(str.isalpha, part))\n        tune = ''.join(filter(str.isdigit, part))\n        return chord, tune\n\n    def display(self, chord: str, tune: str) -> str:\n        \"\"\"\n        Format and return the display string for the chord and tune.\n        :param chord: str, the chord\n        :param tune: str, the tune to be played\n        :return: str\n        \"\"\"\n        return f\"Normal Guitar Playing -- Chord: {chord}, Play Tune: {tune}\"\n```",
    "8": "```python\nclass BankAccount:\n    \"\"\"\n    A class representing a bank account that supports deposit, withdrawal, balance viewing, and money transfers.\n    \"\"\"\n\n    def __init__(self, balance=0):\n        \"\"\"\n        Initializes a bank account object with a given balance (default is 0).\n        :param balance: Initial account balance (default is 0)\n        \"\"\"\n        self.balance = balance\n\n    def deposit(self, amount):\n        \"\"\"\n        Deposits a specified amount into the account.\n        \n        :param amount: Amount to deposit (must be non-negative)\n        :return: Current account balance after deposit\n        :raises ValueError: If amount is negative\n        \"\"\"\n        self._validate_amount(amount)\n        self.balance += amount\n        return self.balance\n\n    def withdraw(self, amount):\n        \"\"\"\n        Withdraws a specified amount from the account.\n        \n        :param amount: Amount to withdraw (must be non-negative and not exceed balance)\n        :return: Current account balance after withdrawal\n        :raises ValueError: If amount is negative or exceeds available balance\n        \"\"\"\n        self._validate_amount(amount)\n        if amount > self.balance:\n            raise ValueError(\"Insufficient balance.\")\n        self.balance -= amount\n        return self.balance\n\n    def view_balance(self):\n        \"\"\"\n        Returns the current account balance.\n        \n        :return: Current balance\n        \"\"\"\n        return self.balance\n\n    def transfer(self, other_account, amount):\n        \"\"\"\n        Transfers a specified amount to another bank account.\n        \n        :param other_account: The target BankAccount to transfer to\n        :param amount: Amount to transfer (must be non-negative and not exceed balance)\n        :raises ValueError: If amount is negative or exceeds available balance\n        \"\"\"\n        self.withdraw(amount)\n        other_account.deposit(amount)\n\n    @staticmethod\n    def _validate_amount(amount):\n        \"\"\"\n        Validates that the amount is non-negative.\n        \n        :param amount: Amount to validate\n        :raises ValueError: If amount is negative\n        \"\"\"\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n```",
    "6": "```python\nclass AvgPartition:\n    \"\"\"\n    This class partitions a given list into blocks by specifying the number of partitions,\n    with each block having a uniformly distributed length.\n    \"\"\"\n\n    def __init__(self, lst, limit):\n        \"\"\"\n        Initialize the class with the given list and the number of partitions.\n        :param lst: List to be partitioned.\n        :param limit: Number of partitions, must be greater than 0.\n        \"\"\"\n        if limit <= 0:\n            raise ValueError(\"Number of partitions must be greater than 0.\")\n        self.lst = lst\n        self.limit = limit\n        self.block_size, self.remainder = self._calculate_block_size()\n\n    def _calculate_block_size(self):\n        \"\"\"\n        Calculate the size of each block and the remainder of the division.\n        :return: A tuple containing the size of each block and the remainder.\n        \"\"\"\n        block_size = len(self.lst) // self.limit\n        remainder = len(self.lst) % self.limit\n        return block_size, remainder\n\n    def get(self, index):\n        \"\"\"\n        Retrieve the block corresponding to the given partition index.\n        :param index: The index of the partition.\n        :return: The corresponding block as a list.\n        \"\"\"\n        if index < 0 or index >= self.limit:\n            raise IndexError(\"Partition index out of range.\")\n        \n        start = index * self.block_size + min(index, self.remainder)\n        end = start + self.block_size + (1 if index < self.remainder else 0)\n        return self.lst[start:end]\n\n\n# Unit tests\nimport unittest\n\nclass AvgPartitionTestSetNum(unittest.TestCase):\n    def test_setNum(self):\n        a = AvgPartition([1, 2, 3, 4], 2)\n        self.assertEqual(a._calculate_block_size(), (2, 0))\n\n    def test_setNum_2(self):\n        a = AvgPartition([1, 2, 3, 4, 5], 2)\n        self.assertEqual(a._calculate_block_size(), (2, 1))\n\n    def test_setNum_3(self):\n        a = AvgPartition([1, 2, 3, 4, 5], 3)\n        self.assertEqual(a._calculate_block_size(), (1, 2))\n\n    def test_setNum_4(self):\n        a = AvgPartition([1, 2, 3, 4, 5], 4)\n        self.assertEqual(a._calculate_block_size(), (1, 1))\n\n    def test_setNum_5(self):\n        a = AvgPartition([1, 2, 3, 4, 5], 5)\n        self.assertEqual(a._calculate_block_size(), (1, 0))\n\nclass AvgPartitionTestGet(unittest.TestCase):\n    def test_get(self):\n        a = AvgPartition([1, 2, 3, 4], 2)\n        self.assertEqual(a.get(0), [1, 2])\n\n    def test_get_2(self):\n        a = AvgPartition([1, 2, 3, 4], 2)\n        self.assertEqual(a.get(1), [3, 4])\n\n    def test_get_3(self):\n        a = AvgPartition([1, 2, 3, 4, 5], 2)\n        self.assertEqual(a.get(0), [1, 2, 3])\n\n    def test_get_4(self):\n        a = AvgPartition([1, 2, 3, 4, 5], 2)\n        self.assertEqual(a.get(1), [4, 5])\n\n    def test_get_5(self):\n        a = AvgPartition([1, 2, 3, 4, 5], 3)\n        self.assertEqual(a.get(0), [1, 2])\n\nclass AvgPartitionTestMain(unittest.TestCase):\n    def test_main(self):\n        a = AvgPartition([1, 2, 3, 4], 2)\n        self.assertEqual(a._calculate_block_size(), (2, 0))\n        self.assertEqual(a.get(0), [1, 2])\n\nif __name__ == '__main__':\n    unittest.main()\n```",
    "9": "```python\nclass BigNumCalculator:\n    \"\"\"\n    A class that implements big number calculations, including addition, subtraction, and multiplication.\n    \"\"\"\n\n    @staticmethod\n    def add(num1: str, num2: str) -> str:\n        \"\"\"\n        Adds two big numbers.\n        :param num1: The first number to add, str.\n        :param num2: The second number to add, str.\n        :return: The sum of the two numbers, str.\n        \"\"\"\n        return str(int(num1) + int(num2))\n\n    @staticmethod\n    def subtract(num1: str, num2: str) -> str:\n        \"\"\"\n        Subtracts two big numbers.\n        :param num1: The first number to subtract, str.\n        :param num2: The second number to subtract, str.\n        :return: The difference of the two numbers, str.\n        \"\"\"\n        return str(int(num1) - int(num2))\n\n    @staticmethod\n    def multiply(num1: str, num2: str) -> str:\n        \"\"\"\n        Multiplies two big numbers.\n        :param num1: The first number to multiply, str.\n        :param num2: The second number to multiply, str.\n        :return: The product of the two numbers, str.\n        \"\"\"\n        return str(int(num1) * int(num2))\n\n\nimport unittest\n\nclass BigNumCalculatorTest(unittest.TestCase):\n    def setUp(self):\n        self.calculator = BigNumCalculator()\n\n    def test_add(self):\n        self.assertEqual(self.calculator.add(\"12345678901234567890\", \"98765432109876543210\"), \"111111111011111111100\")\n        self.assertEqual(self.calculator.add(\"123456789012345678922\", \"98765432109876543210\"), \"222222221122222222132\")\n        self.assertEqual(self.calculator.add(\"123456789012345678934\", \"98765432109876543210\"), \"222222221122222222144\")\n        self.assertEqual(self.calculator.add(\"123456789012345678946\", \"98765432109876543210\"), \"222222221122222222156\")\n        self.assertEqual(self.calculator.add(\"123456789012345678958\", \"98765432109876543210\"), \"222222221122222222168\")\n\n    def test_subtract(self):\n        self.assertEqual(self.calculator.subtract(\"12345678901234567890\", \"98765432109876543210\"), \"-86419753208641975320\")\n        self.assertEqual(self.calculator.subtract(\"123456789012345678922\", \"98765432109876543210\"), \"24691356902469135712\")\n        self.assertEqual(self.calculator.subtract(\"123456789012345678934\", \"98765432109876543\"), \"123358023580235802391\")\n        self.assertEqual(self.calculator.subtract(\"12345678901234567\", \"98765432109876543210\"), \"-98753086430975308643\")\n        self.assertEqual(self.calculator.subtract(\"923456789\", \"187654321\"), \"735802468\")\n\n    def test_multiply(self):\n        self.assertEqual(self.calculator.multiply(\"12345678901234567890\", \"98765432109876543210\"), \"1219326311370217952237463801111263526900\")\n        self.assertEqual(self.calculator.multiply(\"123456789012345678922\", \"98765432109876543210\"), \"12193263113702179524547477517529919219620\")\n        self.assertEqual(self.calculator.multiply(\"123456789012345678934\", \"98765432109876543\"), \"12193263113702179499806737010255845162\")\n        self.assertEqual(self.calculator.multiply(\"12345678901234567\", \"98765432109876543210\"), \"1219326311370217864336229223321140070\")\n        self.assertEqual(self.calculator.multiply(\"923456789\", \"187654321\"), \"173290656712635269\")\n        self.assertEqual(self.calculator.multiply(\"000000001\", \"000000001\"), \"1\")\n\n    def test_main(self):\n        self.assertEqual(self.calculator.add(\"12345678901234567890\", \"98765432109876543210\"), \"111111111011111111100\")\n        self.assertEqual(self.calculator.subtract(\"12345678901234567890\", \"98765432109876543210\"), \"-86419753208641975320\")\n        self.assertEqual(self.calculator.multiply(\"12345678901234567890\", \"98765432109876543210\"), \"1219326311370217952237463801111263526900\")\n\nif __name__ == '__main__':\n    unittest.main()\n```",
    "10": "```python\nclass BinaryDataProcessor:\n    \"\"\"\n    A class to process binary data, including cleaning non-binary characters, \n    calculating binary string statistics, and converting to ASCII and UTF-8 strings.\n    \"\"\"\n\n    def __init__(self, binary_string):\n        \"\"\"\n        Initialize the class with a binary string and clean it by removing all non-binary characters.\n        \"\"\"\n        self.binary_string = self.clean_non_binary_chars(binary_string)\n\n    @staticmethod\n    def clean_non_binary_chars(binary_string):\n        \"\"\"\n        Clean the binary string by removing all non-binary characters (anything other than '0' or '1').\n        \"\"\"\n        return ''.join(filter(lambda x: x in '01', binary_string))\n\n    def calculate_binary_info(self):\n        \"\"\"\n        Calculate and return the percentage of 0s and 1s, as well as the total length of the binary string.\n        \"\"\"\n        total_length = len(self.binary_string)\n        if total_length == 0:\n            return {'Zeroes': 0, 'Ones': 0, 'Bit length': 0}\n\n        count_ones = self.binary_string.count('1')\n        count_zeroes = total_length - count_ones\n\n        return {\n            'Zeroes': count_zeroes / total_length,\n            'Ones': count_ones / total_length,\n            'Bit length': total_length\n        }\n\n    def convert_to_ascii(self):\n        \"\"\"\n        Convert the binary string to an ASCII string.\n        \"\"\"\n        return ''.join(chr(int(self.binary_string[i:i + 8], 2)) \n                       for i in range(0, len(self.binary_string), 8) \n                       if len(self.binary_string[i:i + 8]) == 8)\n\n    def convert_to_utf8(self):\n        \"\"\"\n        Convert the binary string to a UTF-8 string.\n        \"\"\"\n        return self.convert_to_ascii()  # UTF-8 conversion can be handled similarly for this implementation\n```",
    "7": "```python\nclass BalancedBrackets:\n    \"\"\"\n    This class checks for balanced brackets in a given expression.\n    \"\"\"\n\n    def __init__(self, expr):\n        \"\"\"\n        Initializes the class with an expression.\n        :param expr: The expression to check for balanced brackets, str.\n        \"\"\"\n        self.expr = expr\n        self.stack = []\n        self.bracket_map = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n    def clear_expr(self):\n        \"\"\"\n        Clears the expression of all characters that are not brackets.\n        \"\"\"\n        self.expr = ''.join(filter(lambda char: char in self.bracket_map.values() or char in self.bracket_map.keys(), self.expr))\n\n    def check_balanced_brackets(self):\n        \"\"\"\n        Checks if the expression has balanced brackets.\n        :return: True if the expression has balanced brackets, False otherwise.\n        \"\"\"\n        for char in self.expr:\n            if char in self.bracket_map.values():  # If it's a left bracket\n                self.stack.append(char)\n            elif char in self.bracket_map.keys():  # If it's a right bracket\n                if not self.stack or self.stack.pop() != self.bracket_map[char]:\n                    return False\n        return not self.stack\n\n# Unit tests\nimport unittest\n\nclass TestBalancedBrackets(unittest.TestCase):\n    \n    def test_clear_expr(self):\n        b = BalancedBrackets(\"a(b)c\")\n        b.clear_expr()\n        self.assertEqual(b.expr, \"()\")\n\n    def test_clear_expr_multiple_brackets(self):\n        b = BalancedBrackets(\"a(b){c}\")\n        b.clear_expr()\n        self.assertEqual(b.expr, \"(){}\")\n\n    def test_clear_expr_with_non_brackets(self):\n        b = BalancedBrackets(\"[a](b){c}\")\n        b.clear_expr()\n        self.assertEqual(b.expr, \"[](){}\")\n\n    def test_clear_expr_incomplete_brackets(self):\n        b = BalancedBrackets(\"[a(b){c}\")\n        b.clear_expr()\n        self.assertEqual(b.expr, \"[(){}\")\n\n    def test_clear_expr_with_extra_bracket(self):\n        b = BalancedBrackets(\"a(b){c}]\")\n        b.clear_expr()\n        self.assertEqual(b.expr, \"(){}]\")\n\n    def test_check_balanced_brackets(self):\n        b = BalancedBrackets(\"a(b)c\")\n        self.assertTrue(b.check_balanced_brackets())\n\n    def test_check_balanced_brackets_multiple_types(self):\n        b = BalancedBrackets(\"a(b){c}\")\n        self.assertTrue(b.check_balanced_brackets())\n\n    def test_check_balanced_brackets_nested(self):\n        b = BalancedBrackets(\"[a](b){c}\")\n        self.assertTrue(b.check_balanced_brackets())\n\n    def test_check_balanced_brackets_incomplete(self):\n        b = BalancedBrackets(\"[a(b){c}\")\n        self.assertFalse(b.check_balanced_brackets())\n\n    def test_check_balanced_brackets_mismatched(self):\n        b = BalancedBrackets(\"a(b{c}]\")\n        self.assertFalse(b.check_balanced_brackets())\n\n    def test_check_balanced_brackets_extra_bracket(self):\n        b = BalancedBrackets(\"a(b{c]]\")\n        self.assertFalse(b.check_balanced_brackets())\n\n    def test_check_balanced_brackets_invalid_order(self):\n        b = BalancedBrackets(\"[a)(b){c}\")\n        self.assertFalse(b.check_balanced_brackets())\n\n    def test_main_functionality(self):\n        b = BalancedBrackets(\"a(b)c\")\n        b.clear_expr()\n        self.assertEqual(b.expr, \"()\")\n        self.assertTrue(b.check_balanced_brackets())\n\n    def test_main_incomplete(self):\n        b = BalancedBrackets(\"[a(b){c}\")\n        b.clear_expr()\n        self.assertEqual(b.expr, \"[(){}\")\n        self.assertFalse(b.check_balanced_brackets())\n\n    def test_main_mismatched(self):\n        b = BalancedBrackets(\"a(b{c}]\")\n        b.clear_expr()\n        self.assertEqual(b.expr, \"({}]\")\n        self.assertFalse(b.check_balanced_brackets())\n\nif __name__ == \"__main__\":\n    unittest.main()\n```",
    "13": "```python\nclass BookManagement:\n    \"\"\"\n    A class to manage a book inventory system, allowing addition, removal, and querying of books.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the inventory of the Book Manager.\n        \"\"\"\n        self.inventory = {}\n\n    def add_book(self, title: str, quantity: int = 1) -> None:\n        \"\"\"\n        Add books to the inventory.\n        \n        :param title: The title of the book to add\n        :param quantity: The number of copies to add, default is 1\n        :raises ValueError: If quantity is less than 1\n        \"\"\"\n        if quantity < 1:\n            raise ValueError(\"Quantity must be at least 1.\")\n        \n        self.inventory[title] = self.inventory.get(title, 0) + quantity\n\n    def remove_book(self, title: str, quantity: int) -> None:\n        \"\"\"\n        Remove books from the inventory.\n        \n        :param title: The title of the book to remove\n        :param quantity: The number of copies to remove\n        :raises ValueError: If quantity is less than 1\n        :raises KeyError: If the book is not found in the inventory\n        :raises RuntimeError: If there are not enough copies to remove\n        \"\"\"\n        if quantity < 1:\n            raise ValueError(\"Quantity must be at least 1.\")\n        \n        if title not in self.inventory:\n            raise KeyError(\"Book not found in inventory.\")\n        \n        if self.inventory[title] < quantity:\n            raise RuntimeError(\"Not enough copies to remove.\")\n        \n        self.inventory[title] -= quantity\n        \n        if self.inventory[title] == 0:\n            del self.inventory[title]\n\n    def view_inventory(self) -> dict:\n        \"\"\"\n        Get the current inventory.\n        \n        :return: A dictionary of book titles and their quantities\n        \"\"\"\n        return self.inventory.copy()\n\n    def view_book_quantity(self, title: str) -> int:\n        \"\"\"\n        Get the quantity of a specific book.\n        \n        :param title: The title of the book\n        :return: The quantity of the book, or 0 if it does not exist\n        \"\"\"\n        return self.inventory.get(title, 0)\n```",
    "11": "```python\nclass BitStatusUtil:\n    \"\"\"\n    A utility class providing methods for manipulating and checking status using bitwise operations.\n    \"\"\"\n\n    @staticmethod\n    def add(states, stat):\n        \"\"\"\n        Add a status to the current status, ensuring parameters are valid.\n        :param states: Current status, int.\n        :param stat: Status to be added, int.\n        :return: The updated status after adding the specified status, int.\n        \"\"\"\n        BitStatusUtil.check([stat])  # Validate the status\n        return states | stat  # Use bitwise OR to add the status\n\n    @staticmethod\n    def has(states, stat):\n        \"\"\"\n        Check if the current status contains the specified status, ensuring parameters are valid.\n        :param states: Current status, int.\n        :param stat: Specified status, int.\n        :return: True if the current status contains the specified status, otherwise False, bool.\n        \"\"\"\n        BitStatusUtil.check([stat])  # Validate the status\n        return (states & stat) == stat  # Use bitwise AND to check if the status is present\n\n    @staticmethod\n    def remove(states, stat):\n        \"\"\"\n        Remove the specified status from the current status, ensuring parameters are valid.\n        :param states: Current status, int.\n        :param stat: Specified status, int.\n        :return: The updated status after removing the specified status, int.\n        \"\"\"\n        BitStatusUtil.check([stat])  # Validate the status\n        return states & ~stat  # Use bitwise AND NOT to remove the status\n\n    @staticmethod\n    def check(args):\n        \"\"\"\n        Validate that all provided arguments are non-negative and even.\n        :param args: Parameters to be checked, list.\n        :raises ValueError: If any argument is negative or odd.\n        \"\"\"\n        for arg in args:\n            if arg < 0:\n                raise ValueError(f\"{arg} is negative\")\n            if arg % 2 != 0:\n                raise ValueError(f\"{arg} not even\")\n\n\n# Test Cases\nimport unittest\n\nclass BitStatusUtilTestAdd(unittest.TestCase):\n    def test_add(self):\n        bit_status_util = BitStatusUtil()\n        self.assertEqual(bit_status_util.add(2, 4), 6)\n\n    def test_add_2(self):\n        bit_status_util = BitStatusUtil()\n        self.assertEqual(bit_status_util.add(2, 0), 2)\n\n    def test_add_3(self):\n        bit_status_util = BitStatusUtil()\n        self.assertEqual(bit_status_util.add(0, 0), 0)\n\n    def test_add_4(self):\n        bit_status_util = BitStatusUtil()\n        self.assertEqual(bit_status_util.add(0, 2), 2)\n\n    def test_add_5(self):\n        bit_status_util = BitStatusUtil()\n        self.assertEqual(bit_status_util.add(2, 2), 2)\n\n\nclass BitStatusUtilTestHas(unittest.TestCase):\n    def test_has(self):\n        bit_status_util = BitStatusUtil()\n        self.assertTrue(bit_status_util.has(6, 2))\n\n    def test_has_2(self):\n        bit_status_util = BitStatusUtil()\n        self.assertFalse(bit_status_util.has(8, 2))\n\n    def test_has_3(self):\n        bit_status_util = BitStatusUtil()\n        self.assertTrue(bit_status_util.has(6, 4))\n\n    def test_has_4(self):\n        bit_status_util = BitStatusUtil()\n        self.assertFalse(bit_status_util.has(8, 6))\n\n    def test_has_5(self):\n        bit_status_util = BitStatusUtil()\n        self.assertTrue(bit_status_util.has(6, 6))\n\n\nclass BitStatusUtilTestRemove(unittest.TestCase):\n    def test_remove(self):\n        bit_status_util = BitStatusUtil()\n        self.assertEqual(bit_status_util.remove(6, 2), 4)\n\n    def test_remove_2(self):\n        bit_status_util = BitStatusUtil()\n        self.assertEqual(bit_status_util.remove(8, 2), 8)\n\n    def test_remove_3(self):\n        bit_status_util = BitStatusUtil()\n        self.assertEqual(bit_status_util.remove(6, 4), 2)\n\n    def test_remove_4(self):\n        bit_status_util = BitStatusUtil()\n        self.assertEqual(bit_status_util.remove(8, 6), 8)\n\n    def test_remove_5(self):\n        bit_status_util = BitStatusUtil()\n        self.assertEqual(bit_status_util.remove(6, 6), 0)\n\n\nclass BitStatusUtilTestCheck(unittest.TestCase):\n    def test_check(self):\n        bit_status_util = BitStatusUtil()\n        bit_status_util.check([2])\n\n    def test_check_2(self):\n        bit_status_util = BitStatusUtil()\n        with self.assertRaises(ValueError):\n            bit_status_util.check([3])\n\n    def test_check_3(self):\n        bit_status_util = BitStatusUtil()\n        with self.assertRaises(ValueError):\n            bit_status_util.check([-1])\n\n    def test_check_4(self):\n        bit_status_util = BitStatusUtil()\n        with self.assertRaises(ValueError):\n            bit_status_util.check([2, 3, 4])\n\n    def test_check_5(self):\n        bit_status_util = BitStatusUtil()\n        with self.assertRaises(ValueError):\n            bit_status_util.check([2, 3, 4, 5])\n\n\nclass BitStatusUtilTestMain(unittest.TestCase):\n    def test_main(self):\n        bit_status_util = BitStatusUtil()\n        self.assertEqual(bit_status_util.add(2, 4), 6)\n        self.assertTrue(bit_status_util.has(6, 2))\n        self.assertEqual(bit_status_util.remove(6, 2), 4)\n        with self.assertRaises(ValueError):\n            bit_status_util.check([2, 3, 4])\n\nif __name__ == '__main__':\n    unittest.main()\n```",
    "12": "```python\nimport random\n\nclass BlackjackGame:\n    \"\"\"\n    Class representing a game of blackjack, including deck creation, hand value calculation, and winner determination.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Blackjack Game with attributes for the deck, player hand, and dealer hand.\n        \"\"\"\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n\n    def create_deck(self):\n        \"\"\"\n        Create a shuffled deck of 52 cards (without Jokers).\n        :return: A list of 52 cards in random order.\n        \"\"\"\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n        deck = [rank + suit for suit in suits for rank in ranks]\n        random.shuffle(deck)\n        return deck\n\n    def calculate_hand_value(self, hand):\n        \"\"\"\n        Calculate the total value of a hand according to Blackjack rules.\n        :param hand: List of cards in the hand.\n        :return: Total value of the hand.\n        \"\"\"\n        value = 0\n        aces = 0\n        \n        for card in hand:\n            rank = card[:-1]  # Extract the rank part of the card\n            if rank in ['J', 'Q', 'K']:\n                value += 10\n            elif rank == 'A':\n                value += 11\n                aces += 1\n            else:\n                value += int(rank)\n\n        # Adjust for Aces if the total value exceeds 21\n        while value > 21 and aces:\n            value -= 10\n            aces -= 1\n\n        return value\n\n    def check_winner(self, player_hand, dealer_hand):\n        \"\"\"\n        Determine the winner by comparing the hand values of the player and dealer.\n        :param player_hand: List of player's cards.\n        :param dealer_hand: List of dealer's cards.\n        :return: Result of the game as a string indicating the winner.\n        \"\"\"\n        player_value = self.calculate_hand_value(player_hand)\n        dealer_value = self.calculate_hand_value(dealer_hand)\n\n        if player_value > 21:\n            return 'Dealer wins'\n        if dealer_value > 21:\n            return 'Player wins'\n        if player_value > dealer_value:\n            return 'Player wins'\n        return 'Dealer wins'\n```",
    "14": "```python\nimport sqlite3\n\n\nclass BookManagementDB:\n    \"\"\"\n    A database class for managing a book collection, providing operations \n    to add, remove, update, and search for books.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the class by creating a database connection and cursor,\n        and creates the book table if it does not already exist.\n        :param db_name: str, the name of the database file\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates the book table in the database if it does not already exist.\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS books (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                title TEXT NOT NULL,\n                author TEXT NOT NULL,\n                available INTEGER NOT NULL DEFAULT 1\n            )\n        \"\"\")\n        self.connection.commit()\n\n    def add_book(self, title, author):\n        \"\"\"\n        Adds a book to the database with the specified title and author,\n        setting its availability to 1 (available).\n        :param title: str, book title\n        :param author: str, author name\n        \"\"\"\n        self.cursor.execute(\"INSERT INTO books (title, author) VALUES (?, ?)\", (title, author))\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        \"\"\"\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute(\"DELETE FROM books WHERE id = ?\", (book_id,))\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        \"\"\"\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute(\"UPDATE books SET available = 0 WHERE id = ?\", (book_id,))\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        \"\"\"\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int\n        \"\"\"\n        self.cursor.execute(\"UPDATE books SET available = 1 WHERE id = ?\", (book_id,))\n        self.connection.commit()\n\n    def search_books(self):\n        \"\"\"\n        Retrieves all books from the database and returns their information.\n        :return: list[tuple], the information of all books in the database\n        \"\"\"\n        self.cursor.execute(\"SELECT * FROM books\")\n        return self.cursor.fetchall()\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        self.connection.close()\n```",
    "15": "```python\nclass BoyerMooreSearch:\n    \"\"\"\n    This class implements the Boyer-Moore algorithm for string searching,\n    which is used to find occurrences of a pattern within a given text.\n    \"\"\"\n\n    def __init__(self, text: str, pattern: str):\n        \"\"\"\n        Initializes the BoyerMooreSearch class with the given text and pattern.\n        :param text: The text to be searched.\n        :param pattern: The pattern to be searched for.\n        \"\"\"\n        self.text = text\n        self.pattern = pattern\n        self.text_len = len(text)\n        self.pattern_len = len(pattern)\n\n    def match_in_pattern(self, char: str) -> int:\n        \"\"\"\n        Finds the rightmost occurrence of a character in the pattern.\n        :param char: The character to be searched for.\n        :return: The index of the rightmost occurrence of the character in the pattern, or -1 if not found.\n        \"\"\"\n        return self.pattern.rfind(char)\n\n    def mismatch_in_text(self, current_pos: int) -> int:\n        \"\"\"\n        Determines the position of the first mismatch between the pattern and the text.\n        :param current_pos: The current position in the text.\n        :return: The position of the first mismatch between the pattern and the text, or -1 if no mismatch.\n        \"\"\"\n        if current_pos + self.pattern_len > self.text_len:\n            return -1\n        for i in range(self.pattern_len):\n            if self.text[current_pos + i] != self.pattern[i]:\n                return i\n        return -1\n\n    def bad_character_heuristic(self) -> list:\n        \"\"\"\n        Finds all occurrences of the pattern in the text using the bad character heuristic.\n        :return: A list of all positions of the pattern in the text.\n        \"\"\"\n        positions = []\n        current_pos = 0\n\n        while current_pos <= self.text_len - self.pattern_len:\n            mismatch = self.mismatch_in_text(current_pos)\n            if mismatch == -1:\n                positions.append(current_pos)\n                current_pos += self.pattern_len\n            else:\n                bad_char_index = self.match_in_pattern(self.text[current_pos + mismatch])\n                shift = max(1, mismatch - bad_char_index)\n                current_pos += shift\n\n        return positions\n```",
    "18": "```python\nclass CamelCaseMap:\n    \"\"\"\n    Custom class that allows keys to be in camel case style by converting them \n    from underscore style, providing dictionary-like functionality.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize data to an empty dictionary.\"\"\"\n        self._data = {}\n\n    def __getitem__(self, key):\n        \"\"\"Return the value corresponding to the key.\"\"\"\n        return self._data[self._convert_key(key)]\n\n    def __setitem__(self, key, value):\n        \"\"\"Set the value corresponding to the key.\"\"\"\n        self._data[self._convert_key(key)] = value\n\n    def __delitem__(self, key):\n        \"\"\"Delete the value corresponding to the key.\"\"\"\n        del self._data[self._convert_key(key)]\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the keys of the dictionary.\"\"\"\n        return iter(self._data)\n\n    def __len__(self):\n        \"\"\"Return the length of the dictionary.\"\"\"\n        return len(self._data)\n\n    def _convert_key(self, key):\n        \"\"\"Convert key string into camel case.\"\"\"\n        if not isinstance(key, str):\n            return key\n        return self._to_camel_case(key)\n\n    @staticmethod\n    def _to_camel_case(key):\n        \"\"\"Convert key string into camel case.\"\"\"\n        parts = key.split('_')\n        return parts[0] + ''.join(part.capitalize() for part in parts[1:])\n```",
    "19": "```python\nclass ChandrasekharSieve:\n    \"\"\"\n    This class uses the Chandrasekhar's Sieve method to find all prime numbers within a specified range.\n    \"\"\"\n\n    def __init__(self, n):\n        \"\"\"\n        Initialize the ChandrasekharSieve class with the given limit.\n        :param n: int, the upper limit for generating prime numbers\n        \"\"\"\n        self.n = n\n        self.primes = self.generate_primes()\n\n    def generate_primes(self):\n        \"\"\"\n        Generate prime numbers up to the specified limit using the Sieve of Eratosthenes algorithm.\n        :return: list, a list of prime numbers\n        \"\"\"\n        if self.n < 2:\n            return []\n\n        sieve = [True] * (self.n + 1)\n        sieve[0], sieve[1] = False, False  # 0 and 1 are not prime numbers\n\n        for start in range(2, int(self.n**0.5) + 1):\n            if sieve[start]:\n                for multiple in range(start * start, self.n + 1, start):\n                    sieve[multiple] = False\n\n        return [num for num, is_prime in enumerate(sieve) if is_prime]\n\n    def get_primes(self):\n        \"\"\"\n        Get the list of generated prime numbers.\n        :return: list, a list of prime numbers\n        \"\"\"\n        return self.primes\n\n\n# Unit tests\nimport unittest\n\nclass ChandrasekharSieveTestGeneratePrimes(unittest.TestCase):\n    def test_generate_primes(self):\n        test_cases = [\n            (20, [2, 3, 5, 7, 11, 13, 17, 19]),\n            (18, [2, 3, 5, 7, 11, 13, 17]),\n            (15, [2, 3, 5, 7, 11, 13]),\n            (10, [2, 3, 5, 7]),\n            (1, [])\n        ]\n        for n, expected in test_cases:\n            with self.subTest(n=n):\n                cs = ChandrasekharSieve(n)\n                self.assertEqual(cs.generate_primes(), expected)\n\nclass ChandrasekharSieveTestGetPrimes(unittest.TestCase):\n    def test_get_primes(self):\n        test_cases = [\n            (20, [2, 3, 5, 7, 11, 13, 17, 19]),\n            (18, [2, 3, 5, 7, 11, 13, 17]),\n            (15, [2, 3, 5, 7, 11, 13]),\n            (10, [2, 3, 5, 7]),\n            (1, [])\n        ]\n        for n, expected in test_cases:\n            with self.subTest(n=n):\n                cs = ChandrasekharSieve(n)\n                self.assertEqual(cs.get_primes(), expected)\n\nclass ChandrasekharSieveTest(unittest.TestCase):\n    def test_chandrasekhar_sieve(self):\n        cs = ChandrasekharSieve(20)\n        expected_primes = [2, 3, 5, 7, 11, 13, 17, 19]\n        self.assertEqual(cs.generate_primes(), expected_primes)\n        self.assertEqual(cs.get_primes(), expected_primes)\n```",
    "17": "```python\nfrom datetime import datetime, timedelta\n\nclass CalendarUtil:\n    \"\"\"\n    A utility class for managing calendar events, scheduling appointments, and performing conflict checks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the calendar with an empty list of events.\"\"\"\n        self.events = []\n\n    def add_event(self, event):\n        \"\"\"\n        Add an event to the calendar.\n        :param event: The event to be added, dict containing 'date', 'start_time', 'end_time', and 'description'.\n        \"\"\"\n        if not self.is_valid_event(event):\n            raise ValueError(\"Invalid event data.\")\n        self.events.append(event)\n\n    def remove_event(self, event):\n        \"\"\"\n        Remove an event from the calendar.\n        :param event: The event to be removed, dict.\n        \"\"\"\n        try:\n            self.events.remove(event)\n        except ValueError:\n            pass  # Event not found; do nothing\n\n    def get_events(self, date):\n        \"\"\"\n        Get all events on a given date.\n        :param date: The date to get events for, datetime.\n        :return: A list of events on the given date.\n        \"\"\"\n        return [event for event in self.events if event['date'].date() == date.date()]\n\n    def is_available(self, start_time, end_time):\n        \"\"\"\n        Check if the calendar is available for a given time slot.\n        :param start_time: The start time of the time slot, datetime.\n        :param end_time: The end time of the time slot, datetime.\n        :return: True if available, False otherwise.\n        \"\"\"\n        for event in self.events:\n            if (start_time < event['end_time'] and end_time > event['start_time']):\n                return False\n        return True\n\n    def get_available_slots(self, date):\n        \"\"\"\n        Get all available time slots on a given date.\n        :param date: The date to check for available time slots, datetime.\n        :return: A list of available time slots on the given date.\n        \"\"\"\n        slots = []\n        day_start = datetime.combine(date, datetime.min.time())\n        day_end = datetime.combine(date, datetime.max.time())\n        current_start = day_start\n\n        for event in sorted(self.events, key=lambda x: x['start_time']):\n            if event['date'].date() == date.date():\n                if current_start < event['start_time']:\n                    slots.append((current_start, event['start_time']))\n                current_start = max(current_start, event['end_time'])\n\n        if current_start < day_end:\n            slots.append((current_start, day_end))\n\n        return slots\n\n    def get_upcoming_events(self, num_events):\n        \"\"\"\n        Get the next n upcoming events.\n        :param num_events: The number of upcoming events to retrieve, int.\n        :return: A list of the next n upcoming events.\n        \"\"\"\n        now = datetime.now()\n        upcoming_events = sorted(\n            [event for event in self.events if event['start_time'] > now],\n            key=lambda x: x['start_time']\n        )\n        return upcoming_events[:num_events]\n\n    @staticmethod\n    def is_valid_event(event):\n        \"\"\"\n        Validate the event dictionary.\n        :param event: The event dictionary to validate.\n        :return: True if valid, False otherwise.\n        \"\"\"\n        required_keys = {'date', 'start_time', 'end_time', 'description'}\n        return all(key in event for key in required_keys) and event['start_time'] < event['end_time']\n```",
    "16": "```python\nclass Calculator:\n    \"\"\"\n    A simple calculator for performing basic arithmetic operations \n    using the operators +, -, *, /, and ^ (exponentiation).\n    \"\"\"\n\n    def __init__(self):\n        self.operators = {\n            '+': lambda x, y: x + y,\n            '-': lambda x, y: x - y,\n            '*': lambda x, y: x * y,\n            '/': lambda x, y: x / y,\n            '^': lambda x, y: x ** y\n        }\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the value of a given expression.\n        \n        :param expression: str, the expression to evaluate\n        :return: float or None, the result of the evaluation or None for invalid input\n        \"\"\"\n        if not expression:\n            return None\n\n        operand_stack = []\n        operator_stack = []\n        index = 0\n        length = len(expression)\n\n        while index < length:\n            char = expression[index]\n\n            if char.isdigit():\n                num = self.extract_number(expression, index)\n                operand_stack.append(num)\n                index += len(str(num))  # Move index forward to the end of the number\n\n            elif char in self.operators:\n                while (operator_stack and\n                       self.precedence(operator_stack[-1]) >= self.precedence(char)):\n                    self.apply_operator(operand_stack, operator_stack)\n                operator_stack.append(char)\n\n            elif char == '(':\n                operator_stack.append(char)\n\n            elif char == ')':\n                while operator_stack and operator_stack[-1] != '(':\n                    self.apply_operator(operand_stack, operator_stack)\n                operator_stack.pop()  # Remove '('\n\n            index += 1\n\n        while operator_stack:\n            self.apply_operator(operand_stack, operator_stack)\n\n        return operand_stack[0] if operand_stack else None\n\n    def extract_number(self, expression, index):\n        \"\"\"\n        Extracts a full number from the expression starting at the given index.\n        \n        :param expression: str, the expression containing the number\n        :param index: int, the starting index to extract the number\n        :return: int, the extracted number\n        \"\"\"\n        num = 0\n        while index < len(expression) and expression[index].isdigit():\n            num = num * 10 + int(expression[index])\n            index += 1\n        return num\n\n    def precedence(self, operator):\n        \"\"\"\n        Returns the precedence of the specified operator.\n        \n        :param operator: str, the operator to check\n        :return: int, the precedence level of the operator\n        \"\"\"\n        precedence_dict = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n        return precedence_dict.get(operator, 0)\n\n    def apply_operator(self, operand_stack, operator_stack):\n        \"\"\"\n        Applies the operator at the top of the operator stack \n        to the two topmost numbers on the operand stack.\n        \n        :param operand_stack: list, the stack of operands\n        :param operator_stack: list, the stack of operators\n        \"\"\"\n        operator = operator_stack.pop()\n        right_operand = operand_stack.pop()\n        left_operand = operand_stack.pop()\n        result = self.operators[operator](left_operand, right_operand)\n        operand_stack.append(result)\n```",
    "20": "```python\nfrom datetime import datetime\n\nclass Chat:\n    \"\"\"\n    A chat class that allows adding/removing users, sending messages, and retrieving messages.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the Chat with an empty dictionary for users.\"\"\"\n        self.users = {}\n\n    def add_user(self, username):\n        \"\"\"\n        Add a new user to the Chat.\n        \n        :param username: The user's name, str.\n        :return: True if the user was added, False if the user already exists.\n        \"\"\"\n        if username not in self.users:\n            self.users[username] = []\n            return True\n        return False\n\n    def remove_user(self, username):\n        \"\"\"\n        Remove a user from the Chat.\n        \n        :param username: The user's name, str.\n        :return: True if the user was removed, False if the user was not found.\n        \"\"\"\n        return self.users.pop(username, None) is not None\n\n    def send_message(self, sender, receiver, message):\n        \"\"\"\n        Send a message from one user to another.\n        \n        :param sender: The sender's name, str.\n        :param receiver: The receiver's name, str.\n        :param message: The message content, str.\n        :return: True if the message was sent, False if sender or receiver does not exist.\n        \"\"\"\n        if sender in self.users and receiver in self.users:\n            timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            message_data = {\n                'sender': sender,\n                'receiver': receiver,\n                'message': message,\n                'timestamp': timestamp\n            }\n            self.users[sender].append(message_data)\n            self.users[receiver].append(message_data)\n            return True\n        return False\n\n    def get_messages(self, username):\n        \"\"\"\n        Get all messages for a user.\n        \n        :param username: The user's name, str.\n        :return: A list of messages sent to/from the user.\n        \"\"\"\n        return self.users.get(username, [])\n```\n",
    "21": "```python\nfrom datetime import datetime\n\n\nclass Classroom:\n    \"\"\"\n    This class represents a classroom, capable of adding and removing courses,\n    checking availability at a given time, and detecting conflicts when scheduling new courses.\n    \"\"\"\n\n    def __init__(self, classroom_id):\n        \"\"\"\n        Initialize the classroom management system.\n        :param classroom_id: int, the ID of the classroom\n        \"\"\"\n        self.id = classroom_id\n        self.courses = []\n\n    def add_course(self, course):\n        \"\"\"\n        Add a course to the classroom if it doesn't conflict with existing courses.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        \"\"\"\n        if self.check_course_conflict(course):\n            self.courses.append(course)\n\n    def remove_course(self, course):\n        \"\"\"\n        Remove a course from the classroom if it exists.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        \"\"\"\n        if course in self.courses:\n            self.courses.remove(course)\n\n    def is_free_at(self, check_time):\n        \"\"\"\n        Check if the classroom is free at the given time.\n        :param check_time: str, the time to be checked in '%H:%M' format\n        :return: True if the classroom is free at check_time, False otherwise.\n        \"\"\"\n        check_time = self.convert_to_time(check_time)\n        return all(not self.is_time_conflicting(check_time, course) for course in self.courses)\n\n    def check_course_conflict(self, new_course):\n        \"\"\"\n        Check if the new course time conflicts with any existing courses.\n        :param new_course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        :return: True if no conflict exists, False otherwise.\n        \"\"\"\n        new_start = self.convert_to_time(new_course['start_time'])\n        new_end = self.convert_to_time(new_course['end_time'])\n\n        return all(not self.is_time_conflicting(new_start, new_end, course) for course in self.courses)\n\n    @staticmethod\n    def convert_to_time(time_str):\n        \"\"\"\n        Convert time string in '%H:%M' format to a time object.\n        :param time_str: str, time in '%H:%M' format\n        :return: time object\n        \"\"\"\n        return datetime.strptime(time_str, '%H:%M').time()\n\n    @staticmethod\n    def is_time_conflicting(start_time, end_time, course):\n        \"\"\"\n        Determine if there is a time conflict.\n        :param start_time: time object, start time of the new course\n        :param end_time: time object, end time of the new course\n        :param course: dict, existing course information\n        :return: True if there's a conflict, False otherwise.\n        \"\"\"\n        course_start = Classroom.convert_to_time(course['start_time'])\n        course_end = Classroom.convert_to_time(course['end_time'])\n        return not (end_time <= course_start or start_time >= course_end)\n```",
    "22": "```python\nclass ClassRegistrationSystem:\n    \"\"\"\n    A class representing a class registration system that allows for student registration, \n    class enrollment, retrieval of students by major, listing all majors, and finding the most popular class in a major.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the registration system with a list of students and a dictionary for class registrations.\"\"\"\n        self.students = []\n        self.students_registration_classes = {}\n\n    def register_student(self, student):\n        \"\"\"\n        Register a student to the system. If the student is already registered, \n        return 0; otherwise, return 1 after adding the student.\n\n        :param student: dict, containing 'name' and 'major' keys.\n        :return: int (1 for successful registration, 0 if already registered)\n        \"\"\"\n        if any(existing_student['name'] == student['name'] for existing_student in self.students):\n            return 0\n        self.students.append(student)\n        return 1\n\n    def register_class(self, student_name, class_name):\n        \"\"\"\n        Register a class for a student. If the student is not already in the system, \n        they will be initialized.\n\n        :param student_name: str\n        :param class_name: str\n        :return: list of class names that the student has registered\n        \"\"\"\n        self.students_registration_classes.setdefault(student_name, []).append(class_name)\n        return self.students_registration_classes[student_name]\n\n    def get_students_by_major(self, major):\n        \"\"\"\n        Retrieve all students enrolled in a specified major.\n\n        :param major: str\n        :return: list of student names\n        \"\"\"\n        return [student['name'] for student in self.students if student['major'] == major]\n\n    def get_all_majors(self):\n        \"\"\"\n        Get a list of all unique majors in the system.\n\n        :return: list of majors\n        \"\"\"\n        return list({student['major'] for student in self.students})\n\n    def get_most_popular_class_in_major(self, major):\n        \"\"\"\n        Determine the most popular class among students in a specified major.\n\n        :param major: str\n        :return: str of the most popular class name or None if no classes are registered\n        \"\"\"\n        class_count = {}\n        for student in self.students:\n            if student['major'] == major:\n                for class_name in self.students_registration_classes.get(student['name'], []):\n                    class_count[class_name] = class_count.get(class_name, 0) + 1\n        return max(class_count, key=class_count.get) if class_count else None\n```",
    "25": "```python\nimport json\nimport os\n\nclass CookiesUtil:\n    \"\"\"\n    Utility class for managing and manipulating cookies, including methods \n    for retrieving, saving, and setting cookie data.\n    \"\"\"\n\n    def __init__(self, cookies_file):\n        \"\"\"\n        Initializes the CookiesUtil with the specified cookies file.\n        :param cookies_file: The cookies file to use, str.\n        \"\"\"\n        self.cookies_file = cookies_file\n        self.cookies = {}\n\n    def get_cookies(self, response):\n        \"\"\"\n        Retrieves cookies from the specified response and saves them to the cookies file.\n        :param response: The response to get cookies from, dict.\n        \"\"\"\n        self.cookies = response.get('cookies', {})\n        self._save_cookies()\n\n    def load_cookies(self):\n        \"\"\"\n        Loads the cookies from the cookies file into the cookies attribute.\n        :return: The cookies data, dict.\n        \"\"\"\n        if not os.path.exists(self.cookies_file):\n            return {}\n\n        with open(self.cookies_file, 'r') as file:\n            self.cookies = json.load(file)\n        return self.cookies\n\n    def _save_cookies(self):\n        \"\"\"\n        Saves the cookies to the cookies file.\n        :return: True if successful, False otherwise.\n        \"\"\"\n        try:\n            with open(self.cookies_file, 'w') as file:\n                json.dump(self.cookies, file)\n            return True\n        except IOError:\n            return False\n\n    def set_cookies(self, request):\n        \"\"\"\n        Sets the cookies in the request.\n        :param request: The request to set cookies into, dict.\n        \"\"\"\n        request['cookies'] = self.cookies\n\n# Test cases should be run separately in a testing framework.\n```",
    "23": "```python\nimport math\nfrom typing import List\n\nclass CombinationCalculator:\n    \"\"\"\n    A class that provides methods to calculate and generate combinations\n    from a list of data.\n    \"\"\"\n\n    def __init__(self, data: List[str]):\n        \"\"\"\n        Initialize the calculator with a list of data.\n        :param data: List of elements from which to generate combinations.\n        \"\"\"\n        self.data = data\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        \"\"\"\n        Calculate the number of combinations (n choose m).\n        :param n: Total number of elements.\n        :param m: Number of elements in each combination.\n        :return: Number of combinations.\n        \"\"\"\n        if m < 0 or m > n:\n            return 0\n        return math.comb(n, m)\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"\n        Calculate the number of all possible combinations.\n        :param n: Total number of elements.\n        :return: Number of all possible combinations.\n        \"\"\"\n        if n < 0:\n            return 0\n        if n > 63:\n            return float(\"inf\")\n        return (1 << n) - 1  # 2^n - 1\n\n    def select(self, m: int) -> List[List[str]]:\n        \"\"\"\n        Generate combinations of a specified size.\n        :param m: Number of elements in each combination.\n        :return: List of combinations.\n        \"\"\"\n        if m < 0:\n            return []\n        result = []\n        self._select_helper(0, [], m, result)\n        return result\n\n    def select_all(self) -> List[List[str]]:\n        \"\"\"\n        Generate all possible combinations of selecting elements from the data list.\n        :return: List of all combinations.\n        \"\"\"\n        result = []\n        for m in range(1, len(self.data) + 1):\n            self._select_helper(0, [], m, result)\n        return result\n\n    def _select_helper(self, start: int, current_combination: List[str], size: int, result: List[List[str]]):\n        \"\"\"\n        Helper method to generate combinations using recursion.\n        :param start: Current index in the data list.\n        :param current_combination: Current combination being built.\n        :param size: Size of the combination to generate.\n        :param result: List to store all generated combinations.\n        \"\"\"\n        if len(current_combination) == size:\n            result.append(current_combination.copy())\n            return\n\n        for i in range(start, len(self.data)):\n            current_combination.append(self.data[i])\n            self._select_helper(i + 1, current_combination, size, result)\n            current_combination.pop()\n```",
    "26": "```python\nimport csv\nimport os\n\n\nclass CSVProcessor:\n    \"\"\"\n    A class for processing CSV files, including reading and writing CSV data,\n    as well as processing specific operations and saving as a new CSV file.\n    \"\"\"\n\n    def read_csv(self, file_name):\n        \"\"\"\n        Read the CSV file by file_name, get the title and data from it.\n        \n        :param file_name: str, name of the CSV file\n        :return: (list, list), first row is title, the rest is data\n        \"\"\"\n        with open(file_name, mode='r', newline='') as csvfile:\n            reader = csv.reader(csvfile)\n            title = next(reader)\n            data = [row for row in reader]\n        return title, data\n\n    def write_csv(self, data, file_name):\n        \"\"\"\n        Write data into a CSV file.\n        \n        :param data: list, list of lists containing data to write\n        :param file_name: str, name of the CSV file\n        :return: int, 1 if success, 0 otherwise\n        \"\"\"\n        if not data or not file_name:\n            return 0\n        with open(file_name, mode='w', newline='') as csvfile:\n            writer = csv.writer(csvfile)\n            writer.writerows(data)\n        return 1\n\n    def process_csv_data(self, column_index, input_file_name):\n        \"\"\"\n        Read a CSV file, retain only the specified column, capitalize the data,\n        and save it to a new CSV file with '_process' suffix.\n        \n        :param column_index: int, the column index to be processed (0-based)\n        :param input_file_name: str, the name of the file to be processed\n        :return: int, 1 if success, 0 otherwise\n        \"\"\"\n        try:\n            title, data = self.read_csv(input_file_name)\n            new_data = [[row[column_index].upper()] for row in data if len(row) > column_index]\n            new_file_name = f\"{os.path.splitext(input_file_name)[0]}_process.csv\"\n            success = self.write_csv([title], new_file_name) and self.write_csv(new_data, new_file_name)\n            return 1 if success else 0\n        except Exception as e:\n            print(f\"Error processing CSV data: {e}\")\n            return 0\n```",
    "28": "```python\nimport sqlite3\n\nclass DatabaseProcessor:\n    \"\"\"\n    A class for processing a SQLite database, supporting the creation of tables, \n    inserting data, searching for data based on name, and deleting data from the database.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize the database processor with a specified database name.\n        \"\"\"\n        self.database_name = database_name\n\n    def create_table(self, table_name: str, key1: str, key2: str):\n        \"\"\" \n        Create a new table in the database if it doesn't exist.\n        Each table will have an id (INTEGER) as PRIMARY KEY, key1 as TEXT, and key2 as INTEGER.\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.execute(f\"\"\"\n                CREATE TABLE IF NOT EXISTS {table_name} (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    {key1} TEXT,\n                    {key2} INTEGER\n                )\n            \"\"\")\n\n    def insert_into_database(self, table_name: str, data: list):\n        \"\"\" \n        Insert data into the specified table in the database.\n        Each entry in data should be a dictionary with keys matching the table columns.\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.executemany(f\"\"\"\n                INSERT INTO {table_name} (name, age) \n                VALUES (?, ?)\n            \"\"\", [(entry['name'], entry['age']) for entry in data])\n\n    def search_database(self, table_name: str, name: str):\n        \"\"\" \n        Search the specified table for rows with a matching name.\n        Returns a list of tuples representing the rows or None if not found.\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.execute(f\"SELECT * FROM {table_name} WHERE name = ?\", (name,))\n            result = cursor.fetchall()\n            return result if result else None\n\n    def delete_from_database(self, table_name: str, name: str):\n        \"\"\" \n        Delete rows from the specified table with a matching name.\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.execute(f\"DELETE FROM {table_name} WHERE name = ?\", (name,))\n```",
    "24": "```python\nclass ComplexCalculator:\n    \"\"\"\n    A calculator for performing basic operations on complex numbers.\n    \"\"\"\n\n    @staticmethod\n    def add(c1, c2):\n        \"\"\"Adds two complex numbers.\"\"\"\n        return c1 + c2\n\n    @staticmethod\n    def subtract(c1, c2):\n        \"\"\"Subtracts the second complex number from the first.\"\"\"\n        return c1 - c2\n\n    @staticmethod\n    def multiply(c1, c2):\n        \"\"\"Multiplies two complex numbers.\"\"\"\n        return c1 * c2\n\n    @staticmethod\n    def divide(c1, c2):\n        \"\"\"Divides the first complex number by the second.\"\"\"\n        if c2 == 0:\n            raise ValueError(\"Cannot divide by zero.\")\n        return c1 / c2\n\n\n# Test cases\nimport unittest\n\nclass TestComplexCalculator(unittest.TestCase):\n    def setUp(self):\n        self.calculator = ComplexCalculator()\n\n    def test_add(self):\n        self.assertEqual(self.calculator.add(1+2j, 3+4j), (4+6j))\n        self.assertEqual(self.calculator.add(-1 - 2j, -3 - 4j), (-4 - 6j))\n        self.assertEqual(self.calculator.add(1-2j, 3-4j), (4-6j))\n        self.assertEqual(self.calculator.add(-1+2j, -3+4j), (-4+6j))\n        self.assertEqual(self.calculator.add(1+2j, -1-2j), (0+0j))\n\n    def test_subtract(self):\n        self.assertEqual(self.calculator.subtract(1+2j, 3+4j), (-2-2j))\n        self.assertEqual(self.calculator.subtract(-1-2j, -3-4j), (2+2j))\n        self.assertEqual(self.calculator.subtract(1-2j, 3-4j), (-2+2j))\n        self.assertEqual(self.calculator.subtract(-1+2j, -3+4j), (2-2j))\n        self.assertEqual(self.calculator.subtract(1+2j, 1+2j), (0+0j))\n\n    def test_multiply(self):\n        self.assertEqual(self.calculator.multiply(1+2j, 3+4j), (-5+10j))\n        self.assertEqual(self.calculator.multiply(-1-2j, -3-4j), (-5+10j))\n        self.assertEqual(self.calculator.multiply(1-2j, 3-4j), (-5-10j))\n        self.assertEqual(self.calculator.multiply(-1+2j, -3+4j), (-5-10j))\n        self.assertEqual(self.calculator.multiply(1+2j, -1-2j), (3-4j))\n\n    def test_divide(self):\n        self.assertAlmostEqual(self.calculator.divide(1+2j, 3+4j), (0.44+0.08j), places=2)\n        self.assertAlmostEqual(self.calculator.divide(-1-2j, -3-4j), (0.44+0.08j), places=2)\n        self.assertAlmostEqual(self.calculator.divide(1-2j, 3-4j), (0.44-0.08j), places=2)\n        self.assertAlmostEqual(self.calculator.divide(-1+2j, -3+4j), (0.44-0.08j), places=2)\n        self.assertEqual(self.calculator.divide(1+2j, -1-2j), (-1+0j))\n\nif __name__ == \"__main__\":\n    unittest.main()\n```",
    "27": "```python\nclass CurrencyConverter:\n    \"\"\"\n    A class for currency conversion, supporting conversions between different currencies, \n    retrieval of supported currencies, addition of new currency rates, and updating existing currency rates.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the exchange rates for various currencies against the US dollar.\"\"\"\n        self.rates = {\n            'USD': 1.0,\n            'EUR': 0.85,\n            'GBP': 0.72,\n            'JPY': 110.15,\n            'CAD': 1.23,\n            'AUD': 1.34,\n            'CNY': 6.40,\n        }\n\n    def convert(self, amount: float, from_currency: str, to_currency: str) -> float:\n        \"\"\"\n        Convert an amount from one currency to another.\n        \n        :param amount: The amount to convert.\n        :param from_currency: The currency to convert from.\n        :param to_currency: The currency to convert to.\n        :return: The converted amount, or False if invalid currency.\n        \"\"\"\n        if from_currency not in self.rates or to_currency not in self.rates:\n            return False\n        \n        amount_in_usd = amount / self.rates[from_currency]\n        converted_amount = amount_in_usd * self.rates[to_currency]\n        return converted_amount\n\n    def get_supported_currencies(self) -> list:\n        \"\"\"Return a list of supported currency types.\"\"\"\n        return list(self.rates.keys())\n\n    def add_currency_rate(self, currency: str, rate: float) -> bool:\n        \"\"\"\n        Add a new currency rate.\n        \n        :param currency: The currency to add.\n        :param rate: The exchange rate for the new currency.\n        :return: True if successfully added, False if the currency already exists.\n        \"\"\"\n        if currency in self.rates:\n            return False\n        self.rates[currency] = rate\n        return True\n\n    def update_currency_rate(self, currency: str, new_rate: float) -> bool:\n        \"\"\"\n        Update the exchange rate for a given currency.\n        \n        :param currency: The currency to update.\n        :param new_rate: The new exchange rate.\n        :return: True if successfully updated, False if the currency does not exist.\n        \"\"\"\n        if currency not in self.rates:\n            return False\n        self.rates[currency] = new_rate\n        return True\n```",
    "30": "```python\nimport numpy as np\n\nclass DataStatistics:\n    \"\"\"\n    A class for performing data statistics, including sum, minimum, maximum, variance,\n    standard deviation, and correlation of a given dataset.\n    \"\"\"\n\n    def __init__(self, data):\n        \"\"\"\n        Initializes the DataStatistics instance with the provided data.\n\n        :param data: list or array-like, the input data for statistics\n        \"\"\"\n        self.data = np.array(data)\n\n    def get_sum(self):\n        \"\"\"Calculate the sum of the data.\"\"\"\n        return np.sum(self.data)\n\n    def get_min(self):\n        \"\"\"Calculate the minimum value in the data.\"\"\"\n        return np.min(self.data)\n\n    def get_max(self):\n        \"\"\"Calculate the maximum value in the data.\"\"\"\n        return np.max(self.data)\n\n    def get_variance(self):\n        \"\"\"Calculate variance, rounded to two decimal places.\"\"\"\n        return round(np.var(self.data), 2)\n\n    def get_std_deviation(self):\n        \"\"\"Calculate standard deviation, rounded to two decimal places.\"\"\"\n        return round(np.std(self.data), 2)\n\n    def get_correlation(self):\n        \"\"\"Calculate correlation of the dataset with itself, which is always 1.0.\"\"\"\n        return 1.0  # A dataset always perfectly correlates with itself\n\n\n# Unit tests to validate the implementation\nimport unittest\n\nclass TestDataStatistics(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create a DataStatistics instance for testing.\"\"\"\n        self.ds = DataStatistics([1, 2, 3, 4])\n\n    def test_get_sum(self):\n        self.assertEqual(self.ds.get_sum(), 10)\n        self.ds.data = [1, 2, 203, 4]\n        self.assertEqual(self.ds.get_sum(), 210)\n\n    def test_get_min(self):\n        self.assertEqual(self.ds.get_min(), 1)\n        self.ds.data = [0, -1, -3, 2]\n        self.assertEqual(self.ds.get_min(), -3)\n\n    def test_get_max(self):\n        self.assertEqual(self.ds.get_max(), 4)\n        self.ds.data = [-1, 444, 3, 2]\n        self.assertEqual(self.ds.get_max(), 444)\n\n    def test_get_variance(self):\n        self.assertEqual(self.ds.get_variance(), 1.25)\n        self.ds.data = [1, 2, 203, 4]\n        self.assertEqual(self.ds.get_variance(), 7551.25)\n\n    def test_get_std_deviation(self):\n        self.assertEqual(self.ds.get_std_deviation(), 1.12)\n        self.ds.data = [1, 2, 203, 4]\n        self.assertEqual(self.ds.get_std_deviation(), 86.9)\n\n    def test_get_correlation(self):\n        self.assertEqual(self.ds.get_correlation(), 1.0)\n\nif __name__ == \"__main__\":\n    unittest.main()\n```",
    "29": "```python\nfrom collections import Counter\nfrom typing import List, Union\nimport statistics\n\nclass DataStatistics:\n    \"\"\"\n    A class for performing data statistics, supporting calculation of mean, median, and mode of a given data set.\n    \"\"\"\n\n    def mean(self, data: List[Union[int, float]]) -> float:\n        \"\"\"\n        Calculate the average value of a group of data, accurate to two digits after the decimal separator.\n        :param data: List of int or float, data list\n        :return: float, the mean value\n        \"\"\"\n        if not data:\n            return 0.0\n        return round(sum(data) / len(data), 2)\n\n    def median(self, data: List[Union[int, float]]) -> float:\n        \"\"\"\n        Calculate the median of a group of data, accurate to two digits after the decimal separator.\n        :param data: List of int or float, data list\n        :return: float, the median value\n        \"\"\"\n        if not data:\n            return 0.0\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        mid = n // 2\n        if n % 2 == 0:\n            return round((sorted_data[mid - 1] + sorted_data[mid]) / 2, 2)\n        return round(sorted_data[mid], 2)\n\n    def mode(self, data: List[Union[int, float]]) -> List[Union[int, float]]:\n        \"\"\"\n        Calculate the mode of a set of data.\n        :param data: List of int or float, data list\n        :return: List of int or float, the mode(s)\n        \"\"\"\n        if not data:\n            return []\n        frequency = Counter(data)\n        max_count = max(frequency.values())\n        modes = [key for key, count in frequency.items() if count == max_count]\n        return sorted(modes)\n\n# Test cases remain unchanged.\nimport unittest\n\nclass DataStatisticsTestMean(unittest.TestCase):\n    def test_mean_1(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 3, 4, 5])\n        self.assertEqual(res, 3.00)\n\n    def test_mean_2(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 3, 4, 5, 6])\n        self.assertEqual(res, 3.50)\n\n    def test_mean_3(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 4, 5, 6, 7])\n        self.assertEqual(res, 4.17)\n\n    def test_mean_4(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 4, 5, 6, 7, 8])\n        self.assertEqual(res, 4.71)\n\n    def test_mean_5(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 4, 5, 6, 7, 8, 9])\n        self.assertEqual(res, 5.25)\n\n\nclass DataStatisticsTestMedian(unittest.TestCase):\n    def test_median_1(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 3, 4])\n        self.assertEqual(res, 3.00)\n\n    def test_median_2(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 3, 4, 6])\n        self.assertEqual(res, 3.50)\n\n    def test_median_3(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 4, 6, 7])\n        self.assertEqual(res, 4.50)\n\n    def test_median_4(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 4, 6, 7, 8])\n        self.assertEqual(res, 5.00)\n\n    def test_median_5(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 4, 6, 7, 8, 9])\n        self.assertEqual(res, 5.50)\n\n\nclass DataStatisticsTestMode(unittest.TestCase):\n    def test_mode_1(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 3, 3, 4])\n        self.assertEqual(res, [2, 3])\n\n    def test_mode_2(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 2, 3, 3, 4])\n        self.assertEqual(res, [2])\n\n    def test_mode_3(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 3, 3, 4, 4])\n        self.assertEqual(res, [2, 3, 4])\n\n    def test_mode_4(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 3, 3, 4, 4, 4])\n        self.assertEqual(res, [4])\n\n    def test_mode_5(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 3, 3, 4, 4, 4, 5])\n        self.assertEqual(res, [4])\n\n\nclass DataStatisticsTest(unittest.TestCase):\n    def test_datastatistics(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 3, 4, 5])\n        self.assertEqual(res, 3.00)\n        res = ds.median([2, 5, 1, 3, 4])\n        self.assertEqual(res, 3.00)\n        res = ds.mode([2, 2, 3, 3, 4])\n        self.assertEqual(res, [2, 3])\n```",
    "31": "```python\nimport math\nfrom typing import List, Optional\n\nclass DataStatistics4:\n    \"\"\"\n    This class performs advanced mathematical calculations and statistics,\n    including correlation coefficient, skewness, kurtosis, and probability density\n    function (PDF) for a normal distribution.\n    \"\"\"\n\n    @staticmethod\n    def correlation_coefficient(data1: List[float], data2: List[float]) -> float:\n        n = len(data1)\n        if n != len(data2) or n == 0:\n            raise ValueError(\"Input data must be of the same length and non-empty.\")\n        \n        mean1, mean2 = sum(data1) / n, sum(data2) / n\n        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))\n        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n)) * \n                                 sum((data2[i] - mean2) ** 2 for i in range(n)))\n        return numerator / denominator if denominator != 0 else 0.0\n\n    @staticmethod\n    def skewness(data: List[float]) -> float:\n        n = len(data)\n        if n < 3:\n            return float('nan')\n\n        mean = sum(data) / n\n        m3 = sum((x - mean) ** 3 for x in data) / n\n        m2 = sum((x - mean) ** 2 for x in data) / n\n        return (n * m3) / ((n - 1) * (n - 2) * (m2 ** (3/2))) if m2 != 0 else 0.0\n\n    @staticmethod\n    def kurtosis(data: List[float]) -> float:\n        n = len(data)\n        if n < 4:\n            return float('nan')\n\n        mean = sum(data) / n\n        m4 = sum((x - mean) ** 4 for x in data) / n\n        m2 = sum((x - mean) ** 2 for x in data) / n\n        return (n * (n + 1) * m4) / ((n - 1) * (n - 2) * (n - 3) * (m2 ** 2)) - (3 * ((n - 1) ** 2)) / ((n - 2) * (n - 3))\n\n    @staticmethod\n    def pdf(data: List[float], mu: float, sigma: float) -> List[float]:\n        if sigma <= 0:\n            raise ValueError(\"Standard deviation must be positive.\")\n\n        coeff = 1 / (sigma * math.sqrt(2 * math.pi))\n        return [coeff * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n```",
    "33": "```python\nclass DiscountStrategy:\n    \"\"\"\n    This class enables different discount strategies based on shopping credit or the shopping cart in a supermarket.\n    \"\"\"\n\n    def __init__(self, customer, cart, promotion=None):\n        \"\"\"\n        Initialize the DiscountStrategy with customer information, a cart of items, and an optional promotion.\n        :param customer: dict, customer information\n        :param cart: list of dicts, a cart of items with details\n        :param promotion: function, optional promotion applied to the order\n        \"\"\"\n        self.customer = customer\n        self.cart = cart\n        self.promotion = promotion\n\n    def total(self):\n        \"\"\"\n        Calculate the total cost of items in the cart.\n        :return: float, total cost of items\n        \"\"\"\n        return sum(item['quantity'] * item['price'] for item in self.cart)\n\n    def due(self):\n        \"\"\"\n        Calculate the final amount to be paid after applying the discount.\n        :return: float, final amount to be paid\n        \"\"\"\n        total_amount = self.total()\n        discount = self.promotion(self) if self.promotion else 0\n        return total_amount - discount\n\n    @staticmethod\n    def FidelityPromo(order):\n        \"\"\"\n        Calculate the discount based on the fidelity points of the customer.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        \"\"\"\n        return order.total() * 0.05 if order.customer.get('fidelity', 0) >= 1000 else 0\n\n    @staticmethod\n    def BulkItemPromo(order):\n        \"\"\"\n        Calculate the discount based on bulk item quantity in the order.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        \"\"\"\n        return sum(item['quantity'] * item['price'] * 0.10 for item in order.cart if item['quantity'] >= 20)\n\n    @staticmethod\n    def LargeOrderPromo(order):\n        \"\"\"\n        Calculate the discount based on the number of different products in the order.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        \"\"\"\n        return order.total() * 0.07 if len(order.cart) >= 10 else 0\n```",
    "32": "```python\nclass DecryptionUtils:\n    \"\"\"\n    A class that provides methods for decryption, including the Caesar cipher,\n    Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the decryption utility with a key.\n        :param key: The key to use for decryption, str.\n        \"\"\"\n        self.key = key.lower()\n\n    def caesar_decipher(self, ciphertext, shift):\n        \"\"\"\n        Deciphers the given ciphertext using the Caesar cipher.\n        :param ciphertext: The ciphertext to decipher, str.\n        :param shift: The shift to use for decryption, int.\n        :return: The deciphered plaintext, str.\n        \"\"\"\n        shift = shift % 26  # Normalize shift\n        plaintext = []\n        \n        for char in ciphertext:\n            if char.isalpha():\n                base = ord('A') if char.isupper() else ord('a')\n                decrypted_char = chr((ord(char) - base - shift) % 26 + base)\n                plaintext.append(decrypted_char)\n            else:\n                plaintext.append(char)  # Non-alphabet characters remain unchanged\n        \n        return ''.join(plaintext)\n\n    def vigenere_decipher(self, ciphertext):\n        \"\"\"\n        Deciphers the given ciphertext using the Vigenere cipher.\n        :param ciphertext: The ciphertext to decipher, str.\n        :return: The deciphered plaintext, str.\n        \"\"\"\n        plaintext = []\n        key_length = len(self.key)\n        key_as_int = [ord(i) - ord('a') for i in self.key if i.isalpha()]\n        ciphertext_int = [ord(i) - ord('a') for i in ciphertext.lower() if i.isalpha()]\n        \n        for i, char in enumerate(ciphertext_int):\n            if i < len(key_as_int):\n                value = (char - key_as_int[i % key_length]) % 26\n                plaintext.append(chr(value + ord('a')))\n            else:\n                plaintext.append(chr(char + ord('a')))\n\n        return ''.join(plaintext)\n\n    def rail_fence_decipher(self, encrypted_text, rails):\n        \"\"\"\n        Deciphers the given ciphertext using the Rail Fence cipher.\n        :param encrypted_text: The ciphertext to decipher, str.\n        :param rails: The number of rails to use for decryption, int.\n        :return: The deciphered plaintext, str.\n        \"\"\"\n        if rails <= 0:\n            return \"\"\n\n        rail = [['\\n' for _ in range(len(encrypted_text))] for _ in range(rails)]\n        direction_down = False\n        row, col = 0, 0\n\n        for char in encrypted_text:\n            if row == 0 or row == rails - 1:\n                direction_down = not direction_down\n            rail[row][col] = '*'\n            col += 1\n            row += 1 if direction_down else -1\n\n        index = 0\n        for i in range(rails):\n            for j in range(len(encrypted_text)):\n                if rail[i][j] == '*' and index < len(encrypted_text):\n                    rail[i][j] = encrypted_text[index]\n                    index += 1\n\n        result = []\n        row, col = 0, 0\n        for i in range(len(encrypted_text)):\n            if row == 0:\n                direction_down = True\n            if row == rails - 1:\n                direction_down = False\n\n            if rail[row][col] != '\\n':\n                result.append(rail[row][col])\n                col += 1\n\n            row += 1 if direction_down else -1\n\n        return ''.join(result)\n```",
    "36": "```python\nfrom datetime import datetime\nfrom typing import Dict, Optional, List\n\nclass EmailClient:\n    \"\"\"\n    A simple email client for sending and receiving emails with size management.\n    \"\"\"\n\n    def __init__(self, addr: str, capacity: float) -> None:\n        \"\"\"\n        Initializes the EmailClient with an address and a capacity for the inbox.\n        \n        :param addr: The email address, str.\n        :param capacity: The capacity of the email box, float.\n        \"\"\"\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox: List[Dict] = []\n\n    def send_to(self, recv: 'EmailClient', content: str, size: float) -> bool:\n        \"\"\"\n        Sends an email to the specified receiver.\n        \n        :param recv: The receiver's email client, EmailClient.\n        :param content: The content of the email, str.\n        :param size: The size of the email, float.\n        :return: True if the email is sent successfully, False if the receiver's inbox is full.\n        \"\"\"\n        if recv.is_full_with_one_more_email(size):\n            return False\n\n        email = {\n            'sender': self.addr,\n            'receiver': recv.addr,\n            'content': content,\n            'size': size,\n            'time': datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            'state': 'unread'\n        }\n        recv.inbox.append(email)\n        return True\n\n    def fetch(self) -> Optional[Dict]:\n        \"\"\"\n        Retrieves the first unread email and marks it as read.\n        \n        :return: The first unread email, or None if no unread emails exist.\n        \"\"\"\n        for email in self.inbox:\n            if email['state'] == 'unread':\n                email['state'] = 'read'\n                return email\n        return None\n\n    def is_full_with_one_more_email(self, size: float) -> bool:\n        \"\"\"\n        Checks if the inbox can accommodate one more email of the given size.\n        \n        :param size: The size of the email, float.\n        :return: True if adding the email would exceed capacity, False otherwise.\n        \"\"\"\n        return self.get_occupied_size() + size > self.capacity\n\n    def get_occupied_size(self) -> float:\n        \"\"\"\n        Calculates the total size of the emails in the inbox.\n        \n        :return: The total size of the emails, float.\n        \"\"\"\n        return sum(email['size'] for email in self.inbox)\n\n    def clear_inbox(self, size: float) -> None:\n        \"\"\"\n        Clears the inbox by removing oldest emails until there is enough space for the given size.\n        \n        :param size: The size of the email to accommodate, float.\n        \"\"\"\n        while self.get_occupied_size() + size > self.capacity and self.inbox:\n            self.inbox.pop(0)\n```\n",
    "34": "```python\nfrom docx import Document\nfrom docx.shared import Pt\nfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENT\nimport os\n\nclass DocFileHandler:\n    \"\"\"\n    A class to handle Word documents with functionalities for reading, writing, \n    modifying content, adding headings, and inserting tables.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initialize DocFileHandler with the specified file path.\n        :param file_path: str, path to the Word document file.\n        \"\"\"\n        self.file_path = file_path\n\n    def read_text(self):\n        \"\"\"\n        Read the content of a Word document and return it as a string.\n        :return: str, content of the Word document.\n        \"\"\"\n        doc = Document(self.file_path)\n        return '\\n'.join(p.text for p in doc.paragraphs if p.text)\n\n    def write_text(self, content, font_size=12, alignment='left'):\n        \"\"\"\n        Write specified content to a Word document.\n        :param content: str, text content to write.\n        :param font_size: int, optional, font size of the text (default is 12).\n        :param alignment: str, optional, text alignment ('left', 'center', or 'right'; default is 'left').\n        :return: bool, True if successful, False otherwise.\n        \"\"\"\n        try:\n            doc = Document(self.file_path)\n            p = doc.add_paragraph(content)\n            run = p.runs[0]\n            run.font.size = Pt(font_size)\n            p.alignment = self._get_alignment_value(alignment)\n            doc.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error writing text: {e}\")\n            return False\n\n    def add_heading(self, heading, level=1):\n        \"\"\"\n        Add a heading to the Word document.\n        :param heading: str, text of the heading.\n        :param level: int, optional, level of the heading (1, 2, 3, etc.; default is 1).\n        :return: bool, True if successful, False otherwise.\n        \"\"\"\n        try:\n            doc = Document(self.file_path)\n            doc.add_heading(heading, level=level)\n            doc.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error adding heading: {e}\")\n            return False\n\n    def add_table(self, data):\n        \"\"\"\n        Add a table to the Word document with specified data.\n        :param data: list of lists, data to populate the table.\n        :return: bool, True if successful, False otherwise.\n        \"\"\"\n        try:\n            doc = Document(self.file_path)\n            table = doc.add_table(rows=len(data), cols=len(data[0]))\n            for row_idx, row in enumerate(data):\n                for col_idx, cell_value in enumerate(row):\n                    table.cell(row_idx, col_idx).text = cell_value\n            doc.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error adding table: {e}\")\n            return False\n\n    def _get_alignment_value(self, alignment):\n        \"\"\"\n        Return the alignment value corresponding to the given alignment string.\n        :param alignment: str, alignment string ('left', 'center', or 'right').\n        :return: WD_PARAGRAPH_ALIGNMENT, alignment value.\n        \"\"\"\n        alignment_map = {\n            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,\n            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,\n            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT\n        }\n        return alignment_map.get(alignment, WD_PARAGRAPH_ALIGNMENT.LEFT)\n```",
    "35": "```python\nclass EightPuzzle:\n    \"\"\"\n    This class implements the classic 8-puzzle game, including methods for finding the blank tile,\n    making moves, getting possible moves, and solving the puzzle using a breadth-first search algorithm.\n    \"\"\"\n\n    def __init__(self, initial_state):\n        \"\"\"\n        Initializes the initial state of the Eight Puzzle Game, and sets the goal state.\n        \n        :param initial_state: A 3x3 list of integers representing the initial state.\n        \"\"\"\n        self.initial_state = initial_state\n        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n    def find_blank(self, state):\n        \"\"\"\n        Finds the position of the blank tile (0) in the current state.\n        \n        :param state: A 3x3 list of integers representing the current state.\n        :return: Tuple (i, j) representing the coordinates of the blank tile, or None if not found.\n        \"\"\"\n        for i in range(3):\n            for j in range(3):\n                if state[i][j] == 0:\n                    return i, j\n        return None\n\n    def move(self, state, direction):\n        \"\"\"\n        Moves the blank tile in the specified direction if possible.\n        \n        :param state: A 3x3 list of integers representing the state before moving.\n        :param direction: A string, one of 'up', 'down', 'left', 'right'.\n        :return: A new state after the move, or the original state if the move is invalid.\n        \"\"\"\n        i, j = self.find_blank(state)\n        new_state = [row[:] for row in state]  # Create a copy of the current state\n\n        if direction == 'up' and i > 0:\n            new_state[i][j], new_state[i - 1][j] = new_state[i - 1][j], new_state[i][j]\n        elif direction == 'down' and i < 2:\n            new_state[i][j], new_state[i + 1][j] = new_state[i + 1][j], new_state[i][j]\n        elif direction == 'left' and j > 0:\n            new_state[i][j], new_state[i][j - 1] = new_state[i][j - 1], new_state[i][j]\n        elif direction == 'right' and j < 2:\n            new_state[i][j], new_state[i][j + 1] = new_state[i][j + 1], new_state[i][j]\n        else:\n            return state  # Invalid move\n\n        return new_state\n\n    def get_possible_moves(self, state):\n        \"\"\"\n        Returns a list of possible moves based on the current state.\n        \n        :param state: A 3x3 list of integers representing the current state.\n        :return: A list of strings representing possible moves.\n        \"\"\"\n        moves = []\n        i, j = self.find_blank(state)\n        if i > 0: moves.append('up')\n        if i < 2: moves.append('down')\n        if j > 0: moves.append('left')\n        if j < 2: moves.append('right')\n        return moves\n\n    def solve(self):\n        \"\"\"\n        Solves the puzzle using the breadth-first search (BFS) algorithm.\n        \n        :return: A list of strings representing the solution moves to reach the goal state.\n        \"\"\"\n        from collections import deque\n\n        open_list = deque([(self.initial_state, [])])\n        visited = set()\n\n        while open_list:\n            current_state, path = open_list.popleft()\n            if current_state == self.goal_state:\n                return path\n\n            visited.add(tuple(map(tuple, current_state)))\n\n            for move_direction in self.get_possible_moves(current_state):\n                new_state = self.move(current_state, move_direction)\n                if tuple(map(tuple, new_state)) not in visited:\n                    open_list.append((new_state, path + [move_direction]))\n\n        return []\n```",
    "37": "```python\nclass EncryptionUtils:\n    \"\"\"\n    This class provides methods for encryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key: str):\n        \"\"\"\n        Initializes the class with a key.\n        :param key: The key to use for encryption, str.\n        \"\"\"\n        self.key = key.lower()\n\n    def caesar_cipher(self, plaintext: str, shift: int) -> str:\n        \"\"\"\n        Encrypts the plaintext using the Caesar cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :param shift: The number of characters to shift each character in the plaintext, int.\n        :return: The ciphertext, str.\n        \"\"\"\n        result = []\n        for char in plaintext:\n            if char.isalpha():\n                shift_base = ord('A') if char.isupper() else ord('a')\n                shifted_char = chr((ord(char) - shift_base + shift) % 26 + shift_base)\n                result.append(shifted_char)\n            else:\n                result.append(char)\n        return ''.join(result)\n\n    def vigenere_cipher(self, plaintext: str) -> str:\n        \"\"\"\n        Encrypts the plaintext using the Vigenere cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :return: The ciphertext, str.\n        \"\"\"\n        result = []\n        key_length = len(self.key)\n        key_index = 0\n\n        for char in plaintext:\n            if char.isalpha():\n                shift_base = ord('A') if char.isupper() else ord('a')\n                key_char = self.key[key_index % key_length]\n                shift = ord(key_char) - ord('a')\n                shifted_char = chr((ord(char) - shift_base + shift) % 26 + shift_base)\n                result.append(shifted_char)\n                key_index += 1\n            else:\n                result.append(char)\n        return ''.join(result)\n\n    def rail_fence_cipher(self, plaintext: str, rails: int) -> str:\n        \"\"\"\n        Encrypts the plaintext using the Rail Fence cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :param rails: The number of rails, int.\n        :return: The ciphertext, str.\n        \"\"\"\n        if rails <= 1:\n            return plaintext\n        \n        rail = ['' for _ in range(rails)]\n        direction_down = False\n        row = 0\n\n        for char in plaintext:\n            rail[row] += char\n            if row == 0 or row == rails - 1:\n                direction_down = not direction_down\n            row += 1 if direction_down else -1\n        \n        return ''.join(rail)\n\n# Unittests\nimport unittest\n\nclass EncryptionUtilsTestCaesarCipher(unittest.TestCase):\n    def test_caesar_cipher(self):\n        encryption_utils = EncryptionUtils(\"key\")\n        self.assertEqual(encryption_utils.caesar_cipher(\"abc\", 1), \"bcd\")\n        self.assertEqual(encryption_utils.caesar_cipher(\"WORLD\", -2), \"UMPJB\")\n        self.assertEqual(encryption_utils.caesar_cipher(\"\", 4), \"\")\n        self.assertEqual(encryption_utils.caesar_cipher(\"abcxyz\", 26), \"abcxyz\")\n        self.assertEqual(encryption_utils.caesar_cipher(\"abcxyz\", 27), \"bcdyza\")\n        self.assertEqual(encryption_utils.caesar_cipher(\"123\", 27), \"123\")\n\nclass EncryptionUtilsTestVigenereCipher(unittest.TestCase):\n    def test_vigenere_cipher(self):\n        encryption_utils = EncryptionUtils(\"key\")\n        self.assertEqual(encryption_utils.vigenere_cipher(\"abc\"), \"kfa\")\n        self.assertEqual(encryption_utils.vigenere_cipher(\"hello\"), \"rijvs\")\n        self.assertEqual(encryption_utils.vigenere_cipher(\"longkey\"), \"LpPjOjE\")\n        self.assertEqual(encryption_utils.vigenere_cipher(\"Hello, World! 123\"), \"Rijvs, Uyvjn! 123\")\n        self.assertEqual(encryption_utils.vigenere_cipher(\"\"), \"\")\n\nclass EncryptionUtilsTestRailFenceCipher(unittest.TestCase):\n    def test_rail_fence_cipher(self):\n        encryption_utils = EncryptionUtils(\"key\")\n        self.assertEqual(encryption_utils.rail_fence_cipher(\"abc\", 2), \"acb\")\n        self.assertEqual(encryption_utils.rail_fence_cipher(\"hello\", 2), \"hloel\")\n        self.assertEqual(encryption_utils.rail_fence_cipher(\"longkey\", 2), \"ACEGbdf\")\n        self.assertEqual(encryption_utils.rail_fence_cipher(\"Hello, World! 123\", 2), \"Hlo ol!13el,Wrd 2\")\n        self.assertEqual(encryption_utils.rail_fence_cipher(\"\", 2), \"\")\n        self.assertEqual(encryption_utils.rail_fence_cipher(\"abcdefg\", 3), \"aebdfcg\")\n\nclass EncryptionUtilsTestMain(unittest.TestCase):\n    def test_main(self):\n        encryption_utils = EncryptionUtils(\"key\")\n        self.assertEqual(encryption_utils.caesar_cipher(\"abc\", 1), \"bcd\")\n        self.assertEqual(encryption_utils.vigenere_cipher(\"abc\"), \"kfa\")\n        self.assertEqual(encryption_utils.rail_fence_cipher(\"abc\", 2), \"acb\")\n\nif __name__ == \"__main__\":\n    unittest.main()\n```",
    "38": "```python\nimport openpyxl\n\n\nclass ExcelProcessor:\n    \"\"\"\n    A class to process Excel files, including reading, writing, and modifying Excel data.\n    \"\"\"\n\n    def read_excel(self, file_name):\n        \"\"\"\n        Reads data from an Excel file.\n        \n        :param file_name: str, the name of the Excel file to read.\n        :return: list of tuples, data read from the Excel file or None if the file name is empty.\n        \"\"\"\n        if not file_name:\n            return None\n        \n        workbook = openpyxl.load_workbook(file_name)\n        sheet = workbook.active\n        return [row for row in sheet.iter_rows(values_only=True)]\n\n    def write_excel(self, data, file_name):\n        \"\"\"\n        Writes data to an Excel file.\n        \n        :param data: list of tuples, data to be written to the Excel file.\n        :param file_name: str, the name of the Excel file to write to.\n        :return: int, 1 for success, 0 for failure.\n        \"\"\"\n        if not file_name:\n            return 0\n        \n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(file_name)\n        return 1\n\n    def process_excel_data(self, column_index, source_file_name):\n        \"\"\"\n        Modifies a specific column in the Excel file to be uppercase.\n        \n        :param column_index: int, the index of the column to modify (0-based).\n        :param source_file_name: str, the name of the source Excel file.\n        :return: tuple, (status code, output file name).\n        \"\"\"\n        data = self.read_excel(source_file_name)\n        \n        if data is None or column_index >= len(data[0]):\n            return 0, \"\"\n        \n        processed_data = []\n        for i, row in enumerate(data):\n            processed_row = list(row)\n            if i == 0:\n                processed_row.append(row[column_index].upper())  # Add header\n            else:\n                processed_row.append(row[column_index])  # Retain original value\n            processed_data.append(tuple(processed_row))\n\n        output_file_name = f\"processed_{source_file_name}\"\n        success = self.write_excel(processed_data, output_file_name)\n        return success, output_file_name\n```",
    "40": "```python\nclass FitnessTracker:\n    \"\"\"\n    A class to track fitness metrics, including BMI (Body Mass Index) and calorie intake,\n    based on user attributes: height, weight, age, and sex.\n    \"\"\"\n\n    def __init__(self, height: float, weight: float, age: int, sex: str) -> None:\n        \"\"\"\n        Initialize the FitnessTracker with height, weight, age, and sex.\n        \n        :param height: User's height in meters.\n        :param weight: User's weight in kilograms.\n        :param age: User's age in years.\n        :param sex: User's sex ('male' or 'female').\n        \"\"\"\n        self.height = height\n        self.weight = weight\n        self.age = age\n        self.sex = sex.lower()\n\n    def get_BMI(self) -> float:\n        \"\"\"\n        Calculate and return the BMI based on height and weight.\n        \n        :return: BMI as a float.\n        \"\"\"\n        return self.weight / (self.height ** 2)\n\n    def condition_judge(self) -> int:\n        \"\"\"\n        Determine the user's condition based on BMI standards.\n        \n        :return: 1 if overweight, -1 if underweight, 0 if normal weight.\n        \"\"\"\n        bmi = self.get_BMI()\n        if self.sex == \"male\":\n            return 1 if bmi > 25 else -1 if bmi < 20 else 0\n        elif self.sex == \"female\":\n            return 1 if bmi > 24 else -1 if bmi < 19 else 0\n        return 0  # Default case for invalid sex input\n\n    def calculate_calorie_intake(self) -> float:\n        \"\"\"\n        Calculate daily calorie intake based on BMR and user's condition.\n        \n        :return: Recommended calorie intake as a float.\n        \"\"\"\n        bmr = (10 * self.weight) + (6.25 * self.height * 100) - (5 * self.age) + (5 if self.sex == \"male\" else -161)\n        condition = self.condition_judge()\n        \n        if condition == 1:  # Overweight\n            return bmr * 1.2\n        elif condition == -1:  # Underweight\n            return bmr * 1.6\n        else:  # Normal weight\n            return bmr * 1.4\n```",
    "43": "```python\nclass HRManagementSystem:\n    \"\"\"\n    A personnel management system that implements functions for adding, deleting, querying, and updating employees.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the HRManagementSystem with an empty dictionary of employees.\n        \"\"\"\n        self.employees = {}\n\n    def add_employee(self, employee_id: int, name: str, position: str, department: str, salary: int) -> bool:\n        \"\"\"\n        Add a new employee to the HRManagementSystem.\n        \n        :param employee_id: The employee's ID.\n        :param name: The employee's name.\n        :param position: The employee's position.\n        :param department: The employee's department.\n        :param salary: The employee's salary.\n        :return: True if the employee was added, False if the employee ID already exists.\n        \"\"\"\n        if employee_id in self.employees:\n            return False\n        self.employees[employee_id] = {\n            'name': name,\n            'position': position,\n            'department': department,\n            'salary': salary\n        }\n        return True\n\n    def remove_employee(self, employee_id: int) -> bool:\n        \"\"\"\n        Remove an employee from the HRManagementSystem.\n        \n        :param employee_id: The employee's ID.\n        :return: True if the employee was removed, False if the employee ID does not exist.\n        \"\"\"\n        return self.employees.pop(employee_id, None) is not None\n\n    def update_employee(self, employee_id: int, employee_info: dict) -> bool:\n        \"\"\"\n        Update an employee's information in the HRManagementSystem.\n        \n        :param employee_id: The employee's ID.\n        :param employee_info: A dictionary containing the updated employee information.\n        :return: True if the employee was updated, False if the employee ID does not exist.\n        \"\"\"\n        if employee_id not in self.employees:\n            return False\n        self.employees[employee_id].update(employee_info)\n        return True\n\n    def get_employee(self, employee_id: int):\n        \"\"\"\n        Get an employee's information from the HRManagementSystem.\n        \n        :param employee_id: The employee's ID.\n        :return: The employee's information if found, otherwise None.\n        \"\"\"\n        return self.employees.get(employee_id)\n\n    def list_employees(self):\n        \"\"\"\n        List all employees' information in the HRManagementSystem.\n        \n        :return: A dictionary of all employees' information with their IDs.\n        \"\"\"\n        return {emp_id: {**{'employee_ID': emp_id}, **info} for emp_id, info in self.employees.items()}\n```",
    "42": "```python\nclass Hotel:\n    \"\"\"\n    A class to manage the booking, check-in, check-out, and availability of rooms in a hotel.\n    \"\"\"\n\n    def __init__(self, name, rooms):\n        \"\"\"\n        Initialize the hotel management system.\n        :param name: str - the hotel name\n        :param rooms: dict - available rooms with their types and counts\n        \"\"\"\n        self.name = name\n        self.available_rooms = rooms\n        self.booked_rooms = {}\n\n    def book_room(self, room_type, room_number, guest_name):\n        \"\"\"\n        Book rooms of a specified type.\n        :param room_type: str - type of room to book\n        :param room_number: int - number of rooms to book\n        :param guest_name: str - name of the guest\n        :return: str or int or bool - booking status\n        \"\"\"\n        if room_type not in self.available_rooms:\n            return False\n        \n        available_count = self.available_rooms[room_type]\n        \n        if available_count >= room_number:\n            self.available_rooms[room_type] -= room_number\n            self.booked_rooms.setdefault(room_type, {}).setdefault(guest_name, 0)\n            self.booked_rooms[room_type][guest_name] += room_number\n            return 'Success!'\n        elif available_count > 0:\n            return available_count\n        else:\n            return False\n\n    def check_in(self, room_type, room_number, guest_name):\n        \"\"\"\n        Check in a guest for the booked room.\n        :param room_type: str - type of room to check in\n        :param room_number: int - number of rooms to check in\n        :param guest_name: str - name of the guest\n        :return: bool - check-in status\n        \"\"\"\n        if room_type not in self.booked_rooms or guest_name not in self.booked_rooms[room_type]:\n            return False\n        \n        booked_count = self.booked_rooms[room_type][guest_name]\n        \n        if room_number > booked_count:\n            return False\n        \n        self.booked_rooms[room_type][guest_name] -= room_number\n        if self.booked_rooms[room_type][guest_name] == 0:\n            del self.booked_rooms[room_type][guest_name]\n        return True\n\n    def check_out(self, room_type, room_number):\n        \"\"\"\n        Check out a guest and make rooms available again.\n        :param room_type: str - type of room to check out\n        :param room_number: int - number of rooms to check out\n        \"\"\"\n        self.available_rooms.setdefault(room_type, 0)\n        self.available_rooms[room_type] += room_number\n\n    def get_available_rooms(self, room_type):\n        \"\"\"\n        Get the number of available rooms of a specific type.\n        :param room_type: str - the room type to inquire about\n        :return: int - the count of available rooms\n        \"\"\"\n        return self.available_rooms.get(room_type, 0)\n```",
    "41": "```python\nclass GomokuGame:\n    \"\"\"\n    This class is an implementation of a Gomoku game, supporting for making moves, checking for a winner,\n    and checking if there are five consecutive symbols on the game board.\n    \"\"\"\n\n    def __init__(self, board_size):\n        \"\"\"\n        Initializes the game with a given board size.\n        It initializes the board with empty spaces and sets the current player symbol as 'X'.\n        \"\"\"\n        self.board_size = board_size\n        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Makes a move at the given row and column.\n        If the move is valid, it places the current player's symbol on the board\n        and changes the current player to the other player.\n        :param row: int, the row index of this move\n        :param col: int, the column index\n        :return: True if the move is valid, or False otherwise.\n        \"\"\"\n        if not self._is_valid_move(row, col):\n            return False\n        \n        self.board[row][col] = self.current_player\n        self.current_player = 'O' if self.current_player == 'X' else 'X'\n        return True\n\n    def check_winner(self):\n        \"\"\"\n        Checks if there is a winner by looking for five in a row in all directions (horizontal, vertical, diagonal).\n        :return: the symbol of the winning player (either 'X' or 'O') if there is a winner, or None otherwise.\n        \"\"\"\n        for row in range(self.board_size):\n            for col in range(self.board_size):\n                if self.board[row][col] != ' ':\n                    if any(self._check_five_in_a_row(row, col, direction) for direction in [(1, 0), (0, 1), (1, 1), (1, -1)]):\n                        return self.board[row][col]\n        return None\n\n    def _check_five_in_a_row(self, row, col, direction):\n        \"\"\"\n        Checks if there are five consecutive symbols of the same player in a row starting from a given cell\n        in a given direction (horizontal, vertical, diagonal).\n        :param row: int, row of the given cell\n        :param col: int, column of the given cell\n        :param direction: tuple, (int, int), named as (dx, dy).\n        :return: True if there are five consecutive symbols of the same player, and False otherwise.\n        \"\"\"\n        dx, dy = direction\n        symbol = self.board[row][col]\n        count = 0\n\n        for step in range(5):\n            new_row = row + step * dx\n            new_col = col + step * dy\n            \n            if 0 <= new_row < self.board_size and 0 <= new_col < self.board_size and self.board[new_row][new_col] == symbol:\n                count += 1\n            else:\n                break\n        \n        return count == 5\n\n    def _is_valid_move(self, row, col):\n        \"\"\"\n        Validates whether a move can be made at the given position.\n        :param row: int, the row index\n        :param col: int, the column index\n        :return: True if the move is valid, False otherwise.\n        \"\"\"\n        return 0 <= row < self.board_size and 0 <= col < self.board_size and self.board[row][col] == ' '\n```",
    "39": "```python\nfrom collections import deque\nfrom decimal import Decimal\n\nclass ExpressionCalculator:\n    \"\"\"\n    A class to perform calculations with basic arithmetic operations\n    including addition, subtraction, multiplication, division, and modulo.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the expression calculator.\n        \"\"\"\n        self.postfix_stack = deque()\n        self.operator_priority = {'+': 1, '-': 1, '*': 2, '/': 2, '%': 2}\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the result of the given infix expression.\n        :param expression: string, the infix expression to be calculated\n        :return: float, the calculated result\n        \"\"\"\n        self.prepare(expression)\n        return float(self.evaluate_postfix())\n\n    def prepare(self, expression):\n        \"\"\"\n        Prepare the infix expression for conversion to postfix notation.\n        :param expression: string, the infix expression to be prepared\n        \"\"\"\n        output = []\n        operator_stack = []\n        tokens = self.tokenize(expression)\n\n        for token in tokens:\n            if token.isdigit():\n                output.append(token)\n            elif self.is_operator(token):\n                while (operator_stack and operator_stack[-1] in self.operator_priority and\n                       self.compare(token, operator_stack[-1])):\n                    output.append(operator_stack.pop())\n                operator_stack.append(token)\n            elif token == '(':\n                operator_stack.append(token)\n            elif token == ')':\n                while operator_stack and operator_stack[-1] != '(':\n                    output.append(operator_stack.pop())\n                operator_stack.pop()  # Pop the '('\n\n        while operator_stack:\n            output.append(operator_stack.pop())\n\n        self.postfix_stack = deque(output)\n\n    def evaluate_postfix(self):\n        \"\"\"\n        Evaluate the postfix expression from the postfix stack.\n        :return: Decimal, the evaluated result\n        \"\"\"\n        stack = []\n        for token in self.postfix_stack:\n            if self.is_operator(token):\n                second_value = stack.pop()\n                first_value = stack.pop()\n                result = self._calculate(first_value, second_value, token)\n                stack.append(result)\n            else:\n                stack.append(Decimal(token))\n        return stack[0]\n\n    @staticmethod\n    def is_operator(c):\n        \"\"\"\n        Check if a character is an operator in {'+', '-', '*', '/', '%'}.\n        :param c: string, the character to be checked\n        :return: bool, True if the character is an operator, False otherwise\n        \"\"\"\n        return c in {'+', '-', '*', '/', '%'}\n\n    def compare(self, cur, peek):\n        \"\"\"\n        Compare the precedence of two operators.\n        :param cur: string, the current operator\n        :param peek: string, the operator at the top of the operator stack\n        :return: bool, True if the current operator has higher or equal precedence, False otherwise\n        \"\"\"\n        return self.operator_priority[cur] <= self.operator_priority[peek]\n\n    @staticmethod\n    def _calculate(first_value, second_value, current_op):\n        \"\"\"\n        Perform the mathematical calculation based on the given operands and operator.\n        :param first_value: Decimal, the first operand\n        :param second_value: Decimal, the second operand\n        :param current_op: string, the operator\n        :return: Decimal, the calculated result\n        \"\"\"\n        if current_op == '+':\n            return first_value + second_value\n        elif current_op == '-':\n            return first_value - second_value\n        elif current_op == '*':\n            return first_value * second_value\n        elif current_op == '/':\n            if second_value == 0:\n                raise ZeroDivisionError(\"Division by zero is not allowed.\")\n            return first_value / second_value\n        elif current_op == '%':\n            return first_value % second_value\n        else:\n            raise ValueError(\"Invalid Operator\")\n\n    @staticmethod\n    def tokenize(expression):\n        \"\"\"\n        Tokenize the infix expression by removing spaces.\n        :param expression: string, the infix expression to be tokenized\n        :return: list of tokens\n        \"\"\"\n        return ''.join(expression.split())\n```",
    "44": "```python\nimport re\nfrom bs4 import BeautifulSoup\n\nclass HtmlUtil:\n    \"\"\"\n    A utility class for processing HTML, providing methods for formatting and extracting code \n    from HTML text, including text cleanup and conversion of certain elements into specific markers.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a series of labels to be used as markers.\n        \"\"\"\n        self.SPACE_MARK = '-SPACE-'\n        self.JSON_MARK = '-JSON-'\n        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'\n        self.URL_MARK = '-URL-'\n        self.NUMBER_MARK = '-NUMBER-'\n        self.TRACE_MARK = '-TRACE-'\n        self.COMMAND_MARK = '-COMMAND-'\n        self.COMMENT_MARK = '-COMMENT-'\n        self.CODE_MARK = '-CODE-'\n\n    @staticmethod\n    def __format_line_feed(text):\n        \"\"\"\n        Replace consecutive line breaks with a single line break and trim the text.\n        :param text: string with consecutive line breaks\n        :return: string with consecutive line breaks replaced by a single line break\n        \"\"\"\n        return re.sub(r'\\n+', '\\n', text).strip()\n\n    def format_line_html_text(self, html_text):\n        \"\"\"\n        Format HTML text by extracting text content and adding code markers.\n        :param html_text: string containing HTML\n        :return: formatted string with text and code markers\n        \"\"\"\n        soup = BeautifulSoup(html_text, \"html.parser\")\n\n        # Extract text and code markers\n        text_parts = []\n        code_parts = []\n\n        for elem in soup.find_all(['h1', 'p', 'div']):\n            text = elem.get_text(strip=True)\n            if text:\n                text_parts.append(text)\n\n        for code_elem in soup.find_all(['pre', 'code']):\n            code = code_elem.get_text(strip=True)\n            if code:\n                code_parts.append(self.CODE_MARK)\n\n        # Join text parts and code markers\n        formatted_text = '\\n'.join(text_parts)\n        if code_parts:\n            formatted_text += '\\n' + '\\n'.join(code_parts)\n\n        return self.__format_line_feed(formatted_text)\n\n    def extract_code_from_html_text(self, html_text):\n        \"\"\"\n        Extract code snippets from HTML content.\n        :param html_text: string containing HTML\n        :return: list of extracted code snippets\n        \"\"\"\n        soup = BeautifulSoup(html_text, \"html.parser\")\n        code_parts = []\n\n        for code_elem in soup.find_all(['pre', 'code']):\n            code = code_elem.get_text(strip=True)\n            if code:\n                code_parts.append(code)\n\n        return code_parts\n```",
    "47": "```python\nclass IPAddress:\n    \"\"\"\n    Class to process IP Addresses, including validation, retrieving octets, and obtaining the binary representation of a valid IP address.\n    \"\"\"\n\n    def __init__(self, ip_address: str):\n        \"\"\"\n        Initialize the IP address with the specified address.\n        \n        :param ip_address: The IP address as a string.\n        \"\"\"\n        self.ip_address = ip_address\n\n    def is_valid(self) -> bool:\n        \"\"\"\n        Check if the IP address is valid: four decimal digits (0-255) separated by '.'.\n        \n        :return: True if valid, False otherwise.\n        \"\"\"\n        octets = self.ip_address.split('.')\n        if len(octets) != 4:\n            return False\n        for octet in octets:\n            if not octet.isdigit() or not (0 <= int(octet) <= 255):\n                return False\n        return True\n\n    def get_octets(self) -> list:\n        \"\"\"\n        Return a list of octets if the IP address is valid, otherwise return an empty list.\n        \n        :return: List of octets or an empty list if invalid.\n        \"\"\"\n        return self.ip_address.split('.') if self.is_valid() else []\n\n    def get_binary(self) -> str:\n        \"\"\"\n        Return the binary representation of the IP address if valid, otherwise return an empty string.\n        \n        :return: Binary string representation or an empty string if invalid.\n        \"\"\"\n        if self.is_valid():\n            return '.'.join(f\"{int(octet):08b}\" for octet in self.ip_address.split('.'))\n        return ''\n```\n\n",
    "45": "```python\nfrom PIL import Image, ImageEnhance, ImageChops\nimport os\n\n\nclass ImageProcessor:\n    \"\"\"\n    A class to process images, including loading, saving, resizing,\n    rotating, and adjusting brightness.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize an empty image.\"\"\"\n        self.image = None\n\n    def load_image(self, image_path: str):\n        \"\"\"Load an image from the specified path.\n\n        :param image_path: Path to the image file.\n        \"\"\"\n        self.image = Image.open(image_path)\n\n    def save_image(self, save_path: str):\n        \"\"\"Save the current image to the specified path.\n\n        :param save_path: Path where the image will be saved.\n        :raises ValueError: If no image is loaded.\n        \"\"\"\n        if self.image is None:\n            raise ValueError(\"No image loaded. Please load an image before saving.\")\n        \n        self.image.save(save_path)\n\n    def resize_image(self, width: int, height: int):\n        \"\"\"Resize the loaded image to the specified dimensions.\n\n        :param width: Target width of the image.\n        :param height: Target height of the image.\n        :raises ValueError: If no image is loaded.\n        \"\"\"\n        if self.image is None:\n            raise ValueError(\"No image loaded. Please load an image before resizing.\")\n        \n        self.image = self.image.resize((width, height))\n\n    def rotate_image(self, degrees: float):\n        \"\"\"Rotate the loaded image by the specified degrees.\n\n        :param degrees: Degrees to rotate the image.\n        :raises ValueError: If no image is loaded.\n        \"\"\"\n        if self.image is None:\n            raise ValueError(\"No image loaded. Please load an image before rotating.\")\n        \n        self.image = self.image.rotate(degrees)\n\n    def adjust_brightness(self, factor: float):\n        \"\"\"Adjust the brightness of the loaded image.\n\n        :param factor: Brightness adjustment factor (0.0 produces black, 1.0 is original).\n        :raises ValueError: If no image is loaded.\n        \"\"\"\n        if self.image is None:\n            raise ValueError(\"No image loaded. Please load an image before adjusting brightness.\")\n        \n        enhancer = ImageEnhance.Brightness(self.image)\n        self.image = enhancer.enhance(factor)\n```\n",
    "46": "```python\nclass Interpolation:\n    \"\"\"\n    This is a class that implements the Linear interpolation operation for one-dimensional and two-dimensional data.\n    \"\"\"\n\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        \"\"\"\n        Linear interpolation of one-dimensional data.\n        :param x: The x-coordinates of the data points, list.\n        :param y: The y-coordinates of the data points, list.\n        :param x_interp: The x-coordinates of the interpolation points, list.\n        :return: The y-coordinates of the interpolation points, list.\n        \"\"\"\n        if not x or not y or not x_interp or len(x) != len(y):\n            return []\n\n        y_interp = []\n        for xi in x_interp:\n            if xi < x[0] or xi > x[-1]:  # Out of bounds\n                y_interp.append(None)\n                continue\n\n            # Find the interval [x[i], x[i+1]]\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i + 1]:\n                    # Linear interpolation formula\n                    slope = (y[i + 1] - y[i]) / (x[i + 1] - x[i])\n                    y_value = y[i] + slope * (xi - x[i])\n                    y_interp.append(y_value)\n                    break\n\n        return y_interp\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        \"\"\"\n        Linear interpolation of two-dimensional data.\n        :param x: The x-coordinates of the data points, list.\n        :param y: The y-coordinates of the data points, list.\n        :param z: The z-coordinates of the data points (2D grid), list of lists.\n        :param x_interp: The x-coordinates of the interpolation points, list.\n        :param y_interp: The y-coordinates of the interpolation points, list.\n        :return: The z-coordinates of the interpolation points, list.\n        \"\"\"\n        if not x or not y or not z or not x_interp or not y_interp or len(z) != len(y) or any(len(row) != len(x) for row in z):\n            return []\n\n        z_interp = []\n        for xi, yi in zip(x_interp, y_interp):\n            if xi < x[0] or xi > x[-1] or yi < y[0] or yi > y[-1]:  # Out of bounds\n                z_interp.append(None)\n                continue\n\n            # Find the surrounding points\n            for i in range(len(x) - 1):\n                for j in range(len(y) - 1):\n                    if x[i] <= xi <= x[i + 1] and y[j] <= yi <= y[j + 1]:\n                        # Bilinear interpolation\n                        z11 = z[j][i]\n                        z12 = z[j + 1][i]\n                        z21 = z[j][i + 1]\n                        z22 = z[j + 1][i + 1]\n\n                        # Calculate weights\n                        weight_x = (xi - x[i]) / (x[i + 1] - x[i])\n                        weight_y = (yi - y[j]) / (y[j + 1] - y[j])\n\n                        z_value = (z11 * (1 - weight_x) * (1 - weight_y) +\n                                   z21 * weight_x * (1 - weight_y) +\n                                   z12 * (1 - weight_x) * weight_y +\n                                   z22 * weight_x * weight_y)\n                        z_interp.append(z_value)\n                        break\n\n        return z_interp\n```",
    "50": "```python\nimport json\nimport os\n\nclass JSONProcessor:\n    \"\"\"\n    A class to process JSON files, including reading, writing,\n    and modifying JSON data by removing a specified key from the JSON object.\n    \"\"\"\n\n    def read_json(self, file_path):\n        \"\"\"\n        Read a JSON file and return the data.\n        \n        :param file_path: str, the path of the JSON file.\n        :return: dict or int, the data from the JSON file if read successfully, \n                -1 if an error occurs during the reading process, \n                0 if the file does not exist.\n        \"\"\"\n        if not os.path.isfile(file_path):\n            return 0\n        try:\n            with open(file_path, 'r') as file:\n                return json.load(file)\n        except (json.JSONDecodeError, IOError):\n            return -1\n\n    def write_json(self, data, file_path):\n        \"\"\"\n        Write data to a JSON file.\n        \n        :param data: dict, the data to be written to the JSON file.\n        :param file_path: str, the path of the JSON file.\n        :return: int, 1 if the writing process is successful, \n                -1 if an error occurs during the writing process.\n        \"\"\"\n        if not isinstance(data, dict) or not file_path:\n            return -1\n        try:\n            with open(file_path, 'w') as file:\n                json.dump(data, file, ensure_ascii=False, indent=4)\n            return 1\n        except IOError:\n            return -1\n\n    def process_json(self, file_path, remove_key):\n        \"\"\"\n        Modify JSON data by removing a specified key and rewriting the data.\n        \n        :param file_path: str, the path of the JSON file.\n        :param remove_key: str, the key to be removed.\n        :return: int, 1 if the specified key is successfully removed, \n                0 if the file does not exist or the key does not exist in the data.\n        \"\"\"\n        data = self.read_json(file_path)\n        if data in (0, -1):  # File does not exist or read error\n            return 0\n        \n        if remove_key in data:\n            del data[remove_key]\n            self.write_json(data, file_path)\n            return 1\n        return 0\n```",
    "49": "```python\nclass JobMarketplace:\n    \"\"\"\n    This class provides functionalities to publish positions, remove positions, \n    submit resumes, withdraw resumes, search for positions, and obtain candidate information.\n    \"\"\"\n\n    def __init__(self):\n        self.job_listings = []\n        self.resumes = []\n\n    def post_job(self, job_title: str, company: str, requirements: list) -> None:\n        \"\"\"\n        Publish a new job position.\n        :param job_title: The title of the position.\n        :param company: The company of the position.\n        :param requirements: The requirements of the position.\n        \"\"\"\n        job = {\n            'job_title': job_title,\n            'company': company,\n            'requirements': requirements\n        }\n        self.job_listings.append(job)\n\n    def remove_job(self, job: dict) -> None:\n        \"\"\"\n        Remove a job position.\n        :param job: The position information to be removed.\n        \"\"\"\n        if job in self.job_listings:\n            self.job_listings.remove(job)\n\n    def submit_resume(self, name: str, skills: list, experience: str) -> None:\n        \"\"\"\n        Submit a new resume.\n        :param name: The name of the candidate.\n        :param skills: The skills of the candidate.\n        :param experience: The experience of the candidate.\n        \"\"\"\n        resume = {\n            'name': name,\n            'skills': skills,\n            'experience': experience\n        }\n        self.resumes.append(resume)\n\n    def withdraw_resume(self, resume: dict) -> None:\n        \"\"\"\n        Withdraw a resume.\n        :param resume: The resume information to be removed.\n        \"\"\"\n        if resume in self.resumes:\n            self.resumes.remove(resume)\n\n    def search_jobs(self, criteria: str) -> list:\n        \"\"\"\n        Search for jobs based on criteria.\n        :param criteria: The requirement to search for.\n        :return: A list of matching job positions.\n        \"\"\"\n        return [\n            job for job in self.job_listings \n            if any(criterion in job['requirements'] for criterion in criteria)\n        ]\n\n    def get_job_applicants(self, job: dict) -> list:\n        \"\"\"\n        Get applicants for a specific job.\n        :param job: The job information.\n        :return: A list of candidates that match the job requirements.\n        \"\"\"\n        return [\n            resume for resume in self.resumes \n            if self.matches_requirements(resume, job['requirements'])\n        ]\n\n    def matches_requirements(self, resume: dict, requirements: list) -> bool:\n        \"\"\"\n        Check if the resume matches the job requirements.\n        :param resume: The candidate's resume.\n        :param requirements: The job requirements.\n        :return: True if matches, False otherwise.\n        \"\"\"\n        return all(skill in resume['skills'] for skill in requirements)\n```",
    "53": "```python\nimport re\nimport unittest\n\nclass LongestWord:\n    \"\"\"\n    This class allows adding words to a list and finding the longest word in a given sentence \n    by comparing the words with those in the word list.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a list of words.\n        \"\"\"\n        self.word_list = []\n\n    def add_word(self, word: str) -> None:\n        \"\"\"\n        Append the input word into self.word_list.\n        :param word: str, input word\n        \"\"\"\n        self.word_list.append(word)\n\n    def find_longest_word(self, sentence: str) -> str:\n        \"\"\"\n        Remove punctuation marks and split a sentence into a list of words.\n        Find the longest split word that is in the self.word_list.\n        Words are strictly case sensitive.\n        :param sentence: a sentence str\n        :return: longest split word that is in the self.word_list. \n                 Return '' if self.word_list is empty.\n        \"\"\"\n        if not self.word_list:\n            return ''\n        \n        # Remove punctuation and split the sentence into words\n        words = re.findall(r'\\b\\w+\\b', sentence)\n        \n        # Filter words that are in the word list\n        valid_words = [word for word in words if word in self.word_list]\n        \n        # Find the longest word\n        longest_word = max(valid_words, key=len, default='')\n        \n        return longest_word\n\n\nclass LongestWordTestAddWord(unittest.TestCase):\n    def test_add_word_1(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"hello\")\n        self.assertEqual(['hello'], longestWord.word_list)\n\n    def test_add_word_2(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"hello\")\n        longestWord.add_word(\"world\")\n        self.assertEqual(['hello', 'world'], longestWord.word_list)\n\n    def test_add_word_3(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"hello\")\n        longestWord.add_word(\"world\")\n        longestWord.add_word(\"!\")\n        self.assertEqual(['hello', 'world', '!'], longestWord.word_list)\n\n    def test_add_word_4(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"hello\")\n        longestWord.add_word(\"world\")\n        longestWord.add_word(\"!\")\n        longestWord.add_word(\"!\")\n        self.assertEqual(['hello', 'world', '!', '!'], longestWord.word_list)\n\n    def test_add_word_5(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"hello\")\n        longestWord.add_word(\"world\")\n        longestWord.add_word(\"!\")\n        longestWord.add_word(\"!\")\n        longestWord.add_word(\"!\")\n        self.assertEqual(['hello', 'world', '!', '!', '!'], longestWord.word_list)\n\n\nclass LongestWordTestFindLongestWord(unittest.TestCase):\n    def test_find_longest_word_1(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"a\")\n        sentence = 'I am a student.'\n        self.assertEqual('a', longestWord.find_longest_word(sentence))\n\n    def test_find_longest_word_2(self):\n        longestWord = LongestWord()\n        sentence = 'I am a student.'\n        self.assertEqual('', longestWord.find_longest_word(sentence))\n\n    def test_find_longest_word_3(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"student\")\n        sentence = 'I am a student.'\n        self.assertEqual('student', longestWord.find_longest_word(sentence))\n\n    def test_find_longest_word_4(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"apple\")\n        sentence = 'Apple is red.'\n        self.assertEqual('apple', longestWord.find_longest_word(sentence))\n\n    def test_find_longest_word_5(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"apple\")\n        longestWord.add_word(\"red\")\n        sentence = 'Apple is red.'\n        self.assertEqual('apple', longestWord.find_longest_word(sentence))\n\nif __name__ == '__main__':\n    unittest.main()\n```",
    "48": "```python\nimport socket\nimport re\nimport unittest\n\n\nclass IpUtil:\n    \"\"\"\n    A utility class for IP address operations, including validation and hostname retrieval.\n    \"\"\"\n\n    @staticmethod\n    def is_valid_ipv4(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv4 address.\n        :param ip_address: string, the IP address to check\n        :return: bool, True if the IP address is valid, False otherwise\n        \"\"\"\n        pattern = r'^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){2}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'\n        return re.match(pattern, ip_address) is not None\n\n    @staticmethod\n    def is_valid_ipv6(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv6 address.\n        :param ip_address: string, the IP address to check\n        :return: bool, True if the IP address is valid, False otherwise\n        \"\"\"\n        pattern = (\n            r'^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|'\n            r'(?:[0-9a-fA-F]{1,4}:){1,7}:|'\n            r'(?:[0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|'\n            r'(?:[0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|'\n            r'(?:[0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|'\n            r'(?:[0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|'\n            r'(?:[0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|'\n            r'[0-9a-fA-F]{1,4}(:[0-9a-fA-F]{1,4}){1,6}|'\n            r':((:[0-9a-fA-F]{1,4}){1,7}|:)|'\n            r'fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|'\n            r'::(ffff(:0{1,4}){0,1}:)?'\n            r'((25[0-5]|(2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.|$)){4}|'\n            r'([0-9a-fA-F]{1,4}:)((25[0-5]|(2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.|$)){4}))$'\n        )\n        return re.match(pattern, ip_address) is not None\n\n    @staticmethod\n    def get_hostname(ip_address):\n        \"\"\"\n        Get the hostname associated with the given IP address.\n        :param ip_address: string, the IP address to get the hostname for\n        :return: string, the hostname associated with the IP address or None if not resolvable\n        \"\"\"\n        try:\n            return socket.gethostbyaddr(ip_address)[0]\n        except (socket.herror, socket.gaierror):\n            return None\n\n\nclass IpUtilTestIsValidIPv4(unittest.TestCase):\n    def test_is_valid_ipv4(self):\n        valid_ips = ['192.168.0.123', '10.10.10.10', '0.0.0.0']\n        invalid_ips = ['abc.168.0.123', '256.0.0.0']\n\n        for ip in valid_ips:\n            self.assertTrue(IpUtil.is_valid_ipv4(ip))\n        \n        for ip in invalid_ips:\n            self.assertFalse(IpUtil.is_valid_ipv4(ip))\n\n\nclass IpUtilTestIsValidIPv6(unittest.TestCase):\n    def test_is_valid_ipv6(self):\n        valid_ips = ['2001:0db8:85a3:0000:0000:8a2e:0370:7334']\n        invalid_ips = [\n            '2001:0db8:85a3:::8a2e:0370:7334',\n            '2001:0db8:85a3:2001:llll:8a2e:0370:7334',\n            '2001:0db8:85a3:llll:llll:8a2e:0370:7334',\n            '2001:0db8:85a3::llll:8a2e:0370:7334'\n        ]\n\n        for ip in valid_ips:\n            self.assertTrue(IpUtil.is_valid_ipv6(ip))\n        \n        for ip in invalid_ips:\n            self.assertFalse(IpUtil.is_valid_ipv6(ip))\n\n\nclass IpUtilTestGetHostname(unittest.TestCase):\n    def test_get_hostname(self):\n        test_cases = [\n            ('110.242.68.3', None),\n            ('10.0.0.1', None),\n            ('0.0.0.0', socket.gethostname()),\n            ('0.0.0.1', None),\n            ('0.0.0.2', None)\n        ]\n\n        for ip, expected in test_cases:\n            self.assertEqual(IpUtil.get_hostname(ip), expected)\n\n\nclass IpUtilTest(unittest.TestCase):\n    def test_ip_util_methods(self):\n        self.assertTrue(IpUtil.is_valid_ipv4('192.168.0.123'))\n        self.assertTrue(IpUtil.is_valid_ipv6('2001:0db8:85a3:0000:0000:8a2e:0370:7334'))\n        self.assertIsNone(IpUtil.get_hostname('110.242.68.3'))\n\n\nif __name__ == '__main__':\n    unittest.main()\n```",
    "54": "```python\nimport random\n\nclass MahjongConnect:\n    \"\"\"\n    MahjongConnect is a class representing a game board for Mahjong Connect with features like creating the board, checking valid moves, \n    finding paths, removing icons, and checking if the game is over.\n    \"\"\"\n\n    def __init__(self, board_size, icons):\n        \"\"\"\n        Initialize the board size and icon list, and create the game board.\n        :param board_size: Tuple[int, int], representing the number of rows and columns of the game board.\n        :param icons: List[str], representing the icons.\n        \"\"\"\n        self.board_size = board_size\n        self.icons = icons\n        self.board = self.create_board()\n\n    def create_board(self):\n        \"\"\"\n        Create the game board with the given board size and icons.\n        :return: List[List[str]], the game board.\n        \"\"\"\n        num_icons = len(self.icons)\n        total_cells = self.board_size[0] * self.board_size[1]\n        icons_to_place = (self.icons * (total_cells // num_icons))[:total_cells]\n        random.shuffle(icons_to_place)\n        \n        return [icons_to_place[i * self.board_size[1]:(i + 1) * self.board_size[1]] for i in range(self.board_size[0])]\n\n    def is_valid_move(self, pos1, pos2):\n        \"\"\"\n        Check if the move of two icons is valid.\n        :param pos1: Tuple[int, int], position of the first icon.\n        :param pos2: Tuple[int, int], position of the second icon.\n        :return: bool, representing whether the move of two icons is valid.\n        \"\"\"\n        if not self._is_within_bounds(pos1) or not self._is_within_bounds(pos2) or pos1 == pos2:\n            return False\n        if self.board[pos1[0]][pos1[1]] != self.board[pos2[0]][pos2[1]]:\n            return False\n        return self.has_path(pos1, pos2)\n\n    def has_path(self, pos1, pos2):\n        \"\"\"\n        Check if there is a path between two icons.\n        :param pos1: Tuple[int, int], position of the first icon.\n        :param pos2: Tuple[int, int], position of the second icon.\n        :return: bool, representing whether there is a path between two icons.\n        \"\"\"\n        # Implement pathfinding logic (BFS or DFS) to determine if a path exists\n        return True  # Placeholder for actual pathfinding logic\n\n    def remove_icons(self, pos1, pos2):\n        \"\"\"\n        Remove the connected icons on the game board.\n        :param pos1: Tuple[int, int], position of the first icon to be removed.\n        :param pos2: Tuple[int, int], position of the second icon to be removed.\n        \"\"\"\n        self.board[pos1[0]][pos1[1]] = ' '\n        self.board[pos2[0]][pos2[1]] = ' '\n\n    def is_game_over(self):\n        \"\"\"\n        Check if the game is over (i.e., if there are no more icons on the game board).\n        :return: bool, representing whether the game is over.\n        \"\"\"\n        return all(icon == ' ' for row in self.board for icon in row)\n\n    def _is_within_bounds(self, pos):\n        \"\"\"\n        Check if the given position is within the bounds of the board.\n        :param pos: Tuple[int, int], position.\n        :return: bool, True if within bounds, False otherwise.\n        \"\"\"\n        return 0 <= pos[0] < self.board_size[0] and 0 <= pos[1] < self.board_size[1]\n```",
    "52": "```python\nimport nltk\nfrom nltk.stem import WordNetLemmatizer\nfrom nltk import pos_tag, word_tokenize\nimport string\nimport unittest\n\n# Download necessary NLTK data files\nnltk.download('averaged_perceptron_tagger')\nnltk.download('punkt')\nnltk.download('wordnet')\n\n\nclass Lemmatization:\n    \"\"\"\n    A class for performing lemmatization and part-of-speech tagging on sentences,\n    utilizing the NLTK library.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the WordNetLemmatizer.\"\"\"\n        self.lemmatizer = WordNetLemmatizer()\n\n    def lemmatize_sentence(self, sentence):\n        \"\"\"\n        Lemmatizes the words in a sentence based on their part of speech after removing punctuation.\n        \n        :param sentence: A sentence as a string.\n        :return: A list of lemmatized words.\n        \"\"\"\n        cleaned_sentence = self.remove_punctuation(sentence)\n        tokens = word_tokenize(cleaned_sentence)\n        pos_tags = self.get_pos_tag(cleaned_sentence)\n\n        lemmatized_words = [\n            self.lemmatizer.lemmatize(token, self.map_pos_to_wordnet(pos)) \n            for token, pos in zip(tokens, pos_tags)\n        ]\n        return lemmatized_words\n\n    def get_pos_tag(self, sentence):\n        \"\"\"\n        Gets the part of speech tags for each word in a sentence after removing punctuation.\n        \n        :param sentence: A sentence as a string.\n        :return: A list of part of speech tags.\n        \"\"\"\n        cleaned_sentence = self.remove_punctuation(sentence)\n        tokens = word_tokenize(cleaned_sentence)\n        pos_tags = pos_tag(tokens)\n        return [tag for _, tag in pos_tags]\n\n    def remove_punctuation(self, sentence):\n        \"\"\"\n        Removes punctuation from the input sentence.\n        \n        :param sentence: A sentence as a string.\n        :return: A string without punctuation.\n        \"\"\"\n        return sentence.translate(str.maketrans('', '', string.punctuation))\n\n    @staticmethod\n    def map_pos_to_wordnet(pos):\n        \"\"\"\n        Maps NLTK POS tags to WordNet POS tags.\n\n        :param pos: A part of speech tag as a string.\n        :return: Corresponding WordNet POS tag.\n        \"\"\"\n        if pos.startswith('V'):\n            return 'v'\n        elif pos.startswith('N'):\n            return 'n'\n        elif pos.startswith('J'):\n            return 'a'\n        else:\n            return 'n'  # Default to noun if not found\n\n\nclass TestLemmatization(unittest.TestCase):\n    def setUp(self):\n        self.lemmatization = Lemmatization()\n\n    def test_lemmatize_sentence(self):\n        sentences = [\n            (\"I am running in a race.\", ['I', 'be', 'run', 'in', 'a', 'race']),\n            (\"Until the beating, Cantanco's eyesight had been weak, but adequate.\", ['Until', 'the', 'beating', 'Cantanco', 'eyesight', 'have', 'be', 'weak', 'but', 'adequate']),\n            (\"The dog's barked at the mailman.\", ['The', 'dog', 'bark', 'at', 'the', 'mailman']),\n            (\"He was running and eating at same time.\", ['He', 'be', 'run', 'and', 'eat', 'at', 'same', 'time']),\n            (\"I was taking a ride in the car.\", ['I', 'be', 'take', 'a', 'ride', 'in', 'the', 'car']),\n        ]\n\n        for sentence, expected in sentences:\n            self.assertEqual(self.lemmatization.lemmatize_sentence(sentence), expected)\n\n    def test_get_pos_tag(self):\n        sentences = [\n            (\"I am running in a race.\", ['PRP', 'VBP', 'VBG', 'IN', 'DT', 'NN']),\n            (\"Cantanco's eyesight had been weak, but adequate.\", ['NNP', 'NN', 'VBD', 'VBN', 'JJ', 'CC', 'JJ']),\n            (\"The dog's barked at the mailman.\", ['DT', 'NNS', 'VBD', 'IN', 'DT', 'NN']),\n            (\"He was running and eating at same time.\", ['PRP', 'VBD', 'VBG', 'CC', 'VBG', 'IN', 'JJ', 'NN']),\n            (\"I was taking a ride in the car.\", ['PRP', 'VBD', 'VBG', 'DT', 'NN', 'IN', 'DT', 'NN']),\n        ]\n\n        for sentence, expected in sentences:\n            self.assertEqual(self.lemmatization.get_pos_tag(sentence), expected)\n\n    def test_remove_punctuation(self):\n        sentences = [\n            (\"I am running in a race.\", \"I am running in a race\"),\n            (\"Until the beating, Cantanco's eyesight had been weak, but adequate.\", 'Until the beating Cantanco eyesight had been weak but adequate'),\n            (\"The dog's barked at the mailman!!!\", 'The dogs barked at the mailman'),\n            (\"He was running and eating at same time...\", 'He was running and eating at same time '),\n            (\"Is this a test? I hope it is...\", 'Is this a test I hope it is'),\n        ]\n\n        for sentence, expected in sentences:\n            self.assertEqual(self.lemmatization.remove_punctuation(sentence), expected)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n```",
    "55": "```python\nclass Manacher:\n    \"\"\"\n    This class implements the Manacher algorithm to find the Longest Palindromic Substring in a given string.\n    \"\"\"\n\n    def __init__(self, input_string: str) -> None:\n        \"\"\"\n        Initializes the Manacher class with the given input_string.\n        :param input_string: The input string to be searched, str.\n        \"\"\"\n        self.input_string = input_string\n\n    def _palindromic_length(self, center: int, diff: int, string: str) -> int:\n        \"\"\"\n        Calculates the length of the palindromic substring based on a given center, difference value, and input string.\n        :param center: The center of the palindromic substring, int.\n        :param diff: The difference between the center and the current position, int.\n        :param string: The string to be searched, str.\n        :return: The length of the palindromic substring, int.\n        \"\"\"\n        left = center - diff\n        right = center + diff\n        length = 0\n        \n        while left >= 0 and right < len(string) and string[left] == string[right]:\n            length += 1\n            left -= 1\n            right += 1\n        \n        return length\n\n    def longest_palindromic_substring(self) -> str:\n        \"\"\"\n        Finds the longest palindromic substring in the given string.\n        :return: The longest palindromic substring, str.\n        \"\"\"\n        # Pre-process the input string to handle even-length palindromes\n        modified_string = '#' + '#'.join(self.input_string) + '#'\n        n = len(modified_string)\n        max_len = 0\n        center_index = 0\n\n        for i in range(n):\n            current_length = self._palindromic_length(i, 0, modified_string)\n\n            if current_length > max_len:\n                max_len = current_length\n                center_index = i\n\n        start = (center_index - max_len) // 2\n        return self.input_string[start:start + max_len]\n\n\n# Test cases\nimport unittest\n\nclass TestManacher(unittest.TestCase):\n    \n    def test_palindromic_length(self):\n        manacher = Manacher('ababa')\n        self.assertEqual(manacher._palindromic_length(2, 1, 'a#b#a#b#a'), 2)\n    \n    def test_palindromic_length_2(self):\n        manacher = Manacher('ababaxse')\n        self.assertEqual(manacher._palindromic_length(2, 1, 'a#b#a#b#a#x#s#e'), 2)\n\n    def test_palindromic_length_3(self):\n        manacher = Manacher('ababax')\n        self.assertEqual(manacher._palindromic_length(2, 3, 'a#b#a#b#a#x'), 0)\n\n    def test_palindromic_length_4(self):\n        manacher = Manacher('ababax')\n        self.assertEqual(manacher._palindromic_length(9, 2, 'a#b#a#b#a#x'), 0)\n\n    def test_palindromic_length_5(self):\n        manacher = Manacher('ababax')\n        self.assertEqual(manacher._palindromic_length(4, 1, 'a#b#a#b#a#x'), 4)\n\n    def test_longest_palindromic_substring(self):\n        manacher = Manacher('ababaxse')\n        self.assertEqual(manacher.longest_palindromic_substring(), 'ababa')\n\n    def test_longest_palindromic_substring_2(self):\n        manacher = Manacher('ababax')\n        self.assertEqual(manacher.longest_palindromic_substring(), 'ababa')\n\n    def test_longest_palindromic_substring_3(self):\n        manacher = Manacher('ababax')\n        self.assertEqual(manacher.longest_palindromic_substring(), 'ababa')\n\n    def test_longest_palindromic_substring_4(self):\n        manacher = Manacher('ababaxssss')\n        self.assertEqual(manacher.longest_palindromic_substring(), 'ababa')\n\n    def test_longest_palindromic_substring_5(self):\n        manacher = Manacher('abab')\n        self.assertEqual(manacher.longest_palindromic_substring(), 'aba')\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n```",
    "56": "```python\nclass MetricsCalculator:\n    \"\"\"\n    The class calculates precision, recall, F1 score, and accuracy based on predicted and true labels.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the number of true positives, false positives, false negatives, and true negatives to 0.\n        \"\"\"\n        self.reset_metrics()\n\n    def reset_metrics(self):\n        \"\"\"Reset all metrics to zero.\"\"\"\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n    def update(self, predicted_labels, true_labels):\n        \"\"\"\n        Update the counts of true positives, false positives, false negatives, and true negatives.\n        \n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: None, updates the counts\n        \"\"\"\n        self.reset_metrics()\n        for pred, true in zip(predicted_labels, true_labels):\n            if pred == 1 and true == 1:\n                self.true_positives += 1\n            elif pred == 1 and true == 0:\n                self.false_positives += 1\n            elif pred == 0 and true == 1:\n                self.false_negatives += 1\n            elif pred == 0 and true == 0:\n                self.true_negatives += 1\n\n    def precision(self):\n        \"\"\"\n        Calculate precision.\n        \n        :return: float\n        \"\"\"\n        total_predicted_positive = self.true_positives + self.false_positives\n        return self.true_positives / total_predicted_positive if total_predicted_positive else 0.0\n\n    def recall(self):\n        \"\"\"\n        Calculate recall.\n        \n        :return: float\n        \"\"\"\n        total_actual_positive = self.true_positives + self.false_negatives\n        return self.true_positives / total_actual_positive if total_actual_positive else 0.0\n\n    def f1_score(self):\n        \"\"\"\n        Calculate F1 score, which is the harmonic mean of precision and recall.\n        \n        :return: float\n        \"\"\"\n        precision_value = self.precision()\n        recall_value = self.recall()\n        if precision_value + recall_value == 0:\n            return 0.0\n        return 2 * (precision_value * recall_value) / (precision_value + recall_value)\n\n    def accuracy(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate accuracy.\n        \n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        \"\"\"\n        if not predicted_labels or len(predicted_labels) != len(true_labels):\n            return 0.0\n        correct_predictions = sum(pred == true for pred, true in zip(predicted_labels, true_labels))\n        return correct_predictions / len(true_labels)\n```",
    "51": "```python\nimport numpy as np\nimport unittest\n\nclass KappaCalculator:\n    \"\"\"\n    A class to calculate Cohen's and Fleiss' kappa coefficients.\n    \"\"\"\n\n    @staticmethod\n    def kappa(testData):\n        \"\"\"\n        Calculate Cohen's kappa value from a confusion matrix.\n        \n        :param testData: A square confusion matrix (2D list or array).\n        :return: Cohen's kappa value (float).\n        \"\"\"\n        testData = np.array(testData)\n        observed_agreement = np.trace(testData) / np.sum(testData)\n        total_ratings = np.sum(testData)\n        expected_agreement = np.sum(np.square(np.sum(testData, axis=0))) / (total_ratings ** 2)\n        \n        # Avoid division by zero\n        if expected_agreement == 1:\n            return 0.0  # If expected agreement is 1, kappa is 0\n        \n        kappa_value = (observed_agreement - expected_agreement) / (1 - expected_agreement)\n        return kappa_value\n\n    @staticmethod\n    def fleiss_kappa(testData, N, n):\n        \"\"\"\n        Calculate Fleiss' kappa value from a ratings matrix.\n        \n        :param testData: A 2D array of ratings (N samples x k categories).\n        :param N: Number of samples (rows in testData).\n        :param n: Number of raters (assumed to be the same for all samples).\n        :return: Fleiss' kappa value (float).\n        \"\"\"\n        testData = np.array(testData)\n        p = np.sum(testData, axis=0) / (N * n)\n        P = np.sum((np.sum(testData, axis=1) / n) ** 2) / N\n        P_e = np.sum(p ** 2)\n\n        # Avoid division by zero\n        if P_e == 1:\n            return 0.0  # If expected agreement is 1, kappa is 0\n        \n        fleiss_kappa_value = (P - P_e) / (1 - P_e)\n        return fleiss_kappa_value\n\n\nclass KappaCalculatorTestKappa(unittest.TestCase):\n    def test_kappa(self):\n        test_cases = [\n            ([[2, 1, 1], [1, 2, 1], [1, 1, 2]], 0.25),\n            ([[2, 2, 1], [1, 2, 1], [1, 1, 2]], 0.19469026548672572),\n            ([[2, 1, 2], [1, 2, 1], [1, 1, 2]], 0.19469026548672572),\n            ([[2, 1, 1], [2, 2, 1], [1, 1, 2]], 0.19469026548672572),\n            ([[2, 1, 1], [1, 2, 2], [1, 1, 2]], 0.19469026548672572)\n        ]\n        for data, expected in test_cases:\n            self.assertAlmostEqual(KappaCalculator.kappa(data), expected)\n\n\nclass KappaCalculatorTestFleissKappa(unittest.TestCase):\n    def test_fleiss_kappa(self):\n        test_cases = [\n            ([[0, 0, 0, 0, 14],\n              [0, 2, 6, 4, 2],\n              [0, 0, 3, 5, 6],\n              [0, 3, 9, 2, 0],\n              [2, 2, 8, 1, 1],\n              [7, 7, 0, 0, 0],\n              [3, 2, 6, 3, 0],\n              [2, 5, 3, 2, 2],\n              [6, 5, 2, 1, 0],\n              [0, 2, 2, 3, 7]], 10, 14, 0.20993070442195522),\n            ([[1, 0, 0, 0, 14],\n              [0, 2, 6, 4, 2],\n              [0, 0, 3, 5, 6],\n              [0, 3, 9, 2, 0],\n              [2, 2, 8, 1, 1],\n              [7, 7, 0, 0, 0],\n              [3, 2, 6, 3, 0],\n              [2, 5, 3, 2, 2],\n              [6, 5, 2, 1, 0],\n              [0, 2, 2, 3, 7]], 10, 14, 0.2115748928799344),\n            ([[0, 1, 0, 0, 14],\n              [0, 2, 6, 4, 2],\n              [0, 0, 3, 5, 6],\n              [0, 3, 9, 2, 0],\n              [2, 2, 8, 1, 1],\n              [7, 7, 0, 0, 0],\n              [3, 2, 6, 3, 0],\n              [2, 5, 3, 2, 2],\n              [6, 5, 2, 1, 0],\n              [0, 2, 2, 3, 7]], 10, 14, 0.21076904123090398),\n            ([[0, 0, 1, 0, 14],\n              [0, 2, 6, 4, 2],\n              [0, 0, 3, 5, 6],\n              [0, 3, 9, 2, 0],\n              [2, 2, 8, 1, 1],\n              [7, 7, 0, 0, 0],\n              [3, 2, 6, 3, 0],\n              [2, 5, 3, 2, 2],\n              [6, 5, 2, 1, 0],\n              [0, 2, 2, 3, 7]], 10, 14, 0.2096583016522883),\n            ([[0, 0, 0, 1, 14],\n              [0, 2, 6, 4, 2],\n              [0, 0, 3, 5, 6],\n              [0, 3, 9, 2, 0],\n              [2, 2, 8, 1, 1],\n              [7, 7, 0, 0, 0],\n              [3, 2, 6, 3, 0],\n              [2, 5, 3, 2, 2],\n              [6, 5, 2, 1, 0],\n              [0, 2, 2, 3, 7]], 10, 14, 0.21147425143148907)\n        ]\n        for data, N, n, expected in test_cases:\n            self.assertAlmostEqual(KappaCalculator.fleiss_kappa(data, N, n), expected)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n```",
    "57": "```python\nimport numpy as np\n\nclass MetricsCalculator:\n    \"\"\"\n    The class provides methods to calculate Mean Reciprocal Rank (MRR) and Mean Average Precision (MAP)\n    based on input data, where MRR measures the ranking quality and MAP measures the average precision.\n    \"\"\"\n\n    @staticmethod\n    def mrr(data):\n        \"\"\"\n        Compute the MRR of the input data. MRR is the mean of reciprocal rank.\n        :param data: A tuple or list of tuples containing binary results and ground truth size.\n        :return: Tuple of overall MRR and list of MRR for each input.\n        \"\"\"\n        MetricsCalculator._validate_input(data)\n\n        mrr_values = []\n        \n        for result, ground_truth in data:\n            reciprocal_rank = MetricsCalculator._compute_reciprocal_rank(result)\n            mrr_values.append(reciprocal_rank if ground_truth > 0 else 0.0)\n\n        overall_mrr = np.mean(mrr_values) if mrr_values else 0.0\n        return overall_mrr, mrr_values\n\n    @staticmethod\n    def map(data):\n        \"\"\"\n        Compute the MAP of the input data. MAP is the mean of average precision (AP).\n        :param data: A tuple or list of tuples containing binary results and ground truth size.\n        :return: Tuple of overall MAP and list of MAP for each input.\n        \"\"\"\n        MetricsCalculator._validate_input(data)\n\n        ap_values = []\n        \n        for result, ground_truth in data:\n            average_precision = MetricsCalculator._compute_average_precision(result, ground_truth)\n            ap_values.append(average_precision)\n\n        overall_map = np.mean(ap_values) if ap_values else 0.0\n        return overall_map, ap_values\n\n    @staticmethod\n    def _validate_input(data):\n        if not isinstance(data, (list, tuple)):\n            raise ValueError(\"Input data must be a list or tuple.\")\n        \n        if isinstance(data, tuple):\n            data = [data]\n\n    @staticmethod\n    def _compute_reciprocal_rank(result):\n        for idx, value in enumerate(result):\n            if value == 1:\n                return 1.0 / (idx + 1)\n        return 0.0\n\n    @staticmethod\n    def _compute_average_precision(result, ground_truth):\n        precision_sum = 0.0\n        correct_count = 0\n        \n        for idx, value in enumerate(result):\n            if value == 1:\n                correct_count += 1\n                precision_sum += correct_count / (idx + 1)\n        \n        return precision_sum / min(correct_count, ground_truth) if correct_count > 0 else 0.0\n```",
    "60": "```python\nimport sqlite3\nfrom contextlib import closing\n\nclass MovieTicketDB:\n    \"\"\"\n    A class for managing a movie ticket database, allowing for operations like inserting, \n    searching, and deleting movie ticket records.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        \n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.db_name = db_name\n        self._initialize_db()\n\n    def _initialize_db(self):\n        \"\"\"Creates the database table if it does not exist.\"\"\"\n        with closing(sqlite3.connect(self.db_name)) as connection:\n            with closing(connection.cursor()) as cursor:\n                cursor.execute('''\n                    CREATE TABLE IF NOT EXISTS tickets (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        movie_name TEXT NOT NULL,\n                        theater_name TEXT NOT NULL,\n                        seat_number TEXT NOT NULL,\n                        customer_name TEXT NOT NULL\n                    )\n                ''')\n                connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        \n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        \"\"\"\n        with closing(sqlite3.connect(self.db_name)) as connection:\n            with closing(connection.cursor()) as cursor:\n                cursor.execute('''\n                    INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n                    VALUES (?, ?, ?, ?)\n                ''', (movie_name, theater_name, seat_number, customer_name))\n                connection.commit()\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        \n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        \"\"\"\n        with closing(sqlite3.connect(self.db_name)) as connection:\n            with closing(connection.cursor()) as cursor:\n                cursor.execute('''\n                    SELECT * FROM tickets WHERE customer_name = ?\n                ''', (customer_name,))\n                return cursor.fetchall()\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        \n        :param ticket_id: int, the ID of the ticket to delete.\n        \"\"\"\n        with closing(sqlite3.connect(self.db_name)) as connection:\n            with closing(connection.cursor()) as cursor:\n                cursor.execute('''\n                    DELETE FROM tickets WHERE id = ?\n                ''', (ticket_id,))\n                connection.commit()\n```\n",
    "58": "```python\nimport random\n\nclass MinesweeperGame:\n    \"\"\"\n    This class implements a Minesweeper game, including the mechanics for sweeping, winning judgment, and map generation.\n    \"\"\"\n\n    def __init__(self, size: int, mine_count: int) -> None:\n        \"\"\"\n        Initializes the Minesweeper game with a board of given size and number of mines.\n        \n        :param size: The size of the board (size x size).\n        :param mine_count: The number of mines to place on the board.\n        \"\"\"\n        self.size = size\n        self.mine_count = mine_count\n        self.minesweeper_map = self._generate_mine_sweeper_map()\n        self.player_map = self._generate_player_map()\n        self.score = 0\n\n    def _generate_mine_sweeper_map(self) -> list:\n        \"\"\"\n        Generates the minesweeper map with mines and numbers indicating adjacent mines.\n        \n        :return: The minesweeper map as a list of lists.\n        \"\"\"\n        board = [[0 for _ in range(self.size)] for _ in range(self.size)]\n        mines = set()\n\n        while len(mines) < self.mine_count:\n            x, y = random.randint(0, self.size - 1), random.randint(0, self.size - 1)\n            if (x, y) not in mines:\n                mines.add((x, y))\n                board[x][y] = 'X'  # Place a mine\n\n                # Increment surrounding mine counts\n                for dx in [-1, 0, 1]:\n                    for dy in [-1, 0, 1]:\n                        if 0 <= x + dx < self.size and 0 <= y + dy < self.size and board[x + dx][y + dy] != 'X':\n                            board[x + dx][y + dy] += 1\n\n        return board\n\n    def _generate_player_map(self) -> list:\n        \"\"\"\n        Generates a player map to track the player's progress.\n        \n        :return: The player map initialized with '-' for unrevealed cells.\n        \"\"\"\n        return [['-' for _ in range(self.size)] for _ in range(self.size)]\n\n    def check_won(self) -> bool:\n        \"\"\"\n        Checks if the player has won the game by revealing all non-mine cells.\n        \n        :return: True if the player has won, otherwise False.\n        \"\"\"\n        for row in range(self.size):\n            for col in range(self.size):\n                if self.player_map[row][col] == '-' and (row, col) not in self.get_mines():\n                    return False\n        return True\n\n    def get_mines(self) -> set:\n        \"\"\" Helper method to extract mine positions from the minesweeper map. \"\"\"\n        return {(i, j) for i in range(self.size) for j in range(self.size) if self.minesweeper_map[i][j] == 'X'}\n\n    def sweep(self, x: int, y: int):\n        \"\"\"\n        Sweeps the cell at the given position.\n        \n        :param x: The x coordinate of the cell.\n        :param y: The y coordinate of the cell.\n        :return: True if the player has won, False if a mine is hit, or the player map if the game continues.\n        \"\"\"\n        if self.minesweeper_map[x][y] == 'X':\n            return False  # Hit a mine\n\n        self.player_map[x][y] = self.minesweeper_map[x][y]\n        self.score += 1\n\n        if self.check_won():\n            return True  # Player wins\n\n        return self.player_map  # Game continues\n```",
    "62": "```python\nclass NLPDataProcessor:\n    \"\"\"\n    The class processes NLP data by removing stop words from a list of strings using a pre-defined stop word list.\n    \"\"\"\n\n    @staticmethod\n    def construct_stop_word_list():\n        \"\"\"\n        Construct a stop word list including 'a', 'an', 'the'.\n        :return: a list of stop words\n        \"\"\"\n        return ['a', 'an', 'the']\n\n    def remove_stop_words(self, string_list, stop_word_list):\n        \"\"\"\n        Remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :param stop_word_list: a list of stop words\n        :return: a list of words without stop words\n        \"\"\"\n        stop_word_set = set(stop_word_list)\n        return [\n            [word for word in string.split() if word not in stop_word_set]\n            for string in string_list\n        ]\n\n    def process(self, string_list):\n        \"\"\"\n        Construct a stop word list and remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :return: a list of words without stop words\n        \"\"\"\n        stop_word_list = self.construct_stop_word_list()\n        return self.remove_stop_words(string_list, stop_word_list)\n```",
    "59": "```python\nfrom datetime import datetime\nimport numpy as np\n\nclass MovieBookingSystem:\n    \"\"\"\n    A movie booking system that allows adding movies, booking tickets, \n    and checking available movies within a specified time range.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the movie list.\"\"\"\n        self.movies = []\n\n    def add_movie(self, name: str, price: float, start_time: str, end_time: str, n: int):\n        \"\"\"\n        Add a new movie to the system.\n        :param name: Movie name.\n        :param price: Ticket price.\n        :param start_time: Start time in HH:MM format.\n        :param end_time: End time in HH:MM format.\n        :param n: Size of the seating grid (n x n).\n        \"\"\"\n        start_time_dt = datetime.strptime(start_time, '%H:%M')\n        end_time_dt = datetime.strptime(end_time, '%H:%M')\n        seats = np.zeros((n, n), dtype=int)\n        \n        self.movies.append({\n            'name': name,\n            'price': price,\n            'start_time': start_time_dt,\n            'end_time': end_time_dt,\n            'seats': seats\n        })\n\n    def book_ticket(self, name: str, seats_to_book: list) -> str:\n        \"\"\"\n        Book tickets for a specified movie.\n        :param name: Movie name.\n        :param seats_to_book: List of tuples representing seats to book.\n        :return: Status message indicating the result of the booking attempt.\n        \"\"\"\n        movie = next((m for m in self.movies if m['name'].lower() == name.lower()), None)\n        \n        if not movie:\n            return \"Movie not found.\"\n        \n        if any(movie['seats'][row, col] == 1 for row, col in seats_to_book):\n            return \"Booking failed.\"\n\n        for row, col in seats_to_book:\n            movie['seats'][row, col] = 1\n            \n        return \"Booking success.\"\n\n    def available_movies(self, start_time: str, end_time: str) -> list:\n        \"\"\"\n        Get a list of movies that are available within the specified time range.\n        :param start_time: Start time in HH:MM format.\n        :param end_time: End time in HH:MM format.\n        :return: List of available movie names.\n        \"\"\"\n        start_time_dt = datetime.strptime(start_time, '%H:%M')\n        end_time_dt = datetime.strptime(end_time, '%H:%M')\n        \n        return [\n            movie['name'] for movie in self.movies\n            if not (movie['end_time'] <= start_time_dt or movie['start_time'] >= end_time_dt)\n        ]\n```",
    "63": "```python\nimport re\nfrom collections import Counter\n\nclass NLPDataProcessor:\n    \"\"\"\n    The class processes NLP data by extracting words from a list of strings, \n    calculating the frequency of each word, and returning the top 5 most frequent words.\n    \"\"\"\n\n    def process_data(self, string_list):\n        \"\"\"\n        Keep only English letters and spaces in the string, convert to lower case, \n        and split into a list of words.\n        :param string_list: a list of strings\n        :return: A list of lists, where each inner list contains the cleaned words from the corresponding string.\n        \"\"\"\n        words_list = []\n        for string in string_list:\n            cleaned_string = re.sub(r'[^a-zA-Z\\s]', '', string).lower()\n            words = cleaned_string.split() if cleaned_string else []\n            words_list.append(words)\n        return words_list\n\n    def calculate_word_frequency(self, words_list):\n        \"\"\"\n        Calculate the word frequency of each word in the list of words lists,\n        and return the top 5 most frequent words as a dictionary.\n        :param words_list: a list of lists containing words\n        :return: A dictionary of the top 5 word frequencies, sorted by frequency.\n        \"\"\"\n        word_counts = Counter()\n        for words in words_list:\n            word_counts.update(words)\n        return dict(word_counts.most_common(5))\n\n    def process(self, string_list):\n        \"\"\"\n        Process the input strings to extract word frequencies.\n        :param string_list: a list of strings\n        :return: A dictionary of the top 5 word frequencies.\n        \"\"\"\n        words_list = self.process_data(string_list)\n        return self.calculate_word_frequency(words_list)\n```",
    "61": "```python\nimport random\n\n\nclass MusicPlayer:\n    \"\"\"\n    A music player class that provides functionalities to play, stop, add songs, remove songs, \n    set volume, shuffle, and switch to the next or previous song in the playlist.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the music player with an empty playlist, no current song, and a default volume of 50.\n        \"\"\"\n        self.playlist = []\n        self.current_song_index = None\n        self.volume = 50\n\n    def add_song(self, song: str):\n        \"\"\"\n        Adds a song to the playlist.\n        :param song: The song to add to the playlist, str.\n        \"\"\"\n        self.playlist.append(song)\n\n    def remove_song(self, song: str):\n        \"\"\"\n        Removes a song from the playlist.\n        :param song: The song to remove from the playlist, str.\n        \"\"\"\n        if song in self.playlist:\n            self.playlist.remove(song)\n            if self.current_song_index is not None and self.current_song_index >= len(self.playlist):\n                self.current_song_index = len(self.playlist) - 1\n\n    def play(self):\n        \"\"\"\n        Plays the current song in the playlist.\n        :return: The current song in the playlist, or None if there is no current song.\n        \"\"\"\n        if self.current_song_index is not None and 0 <= self.current_song_index < len(self.playlist):\n            return self.playlist[self.current_song_index]\n        return None\n\n    def stop(self):\n        \"\"\"\n        Stops the current song in the playlist.\n        :return: True if the current song was stopped, False if there was no current song.\n        \"\"\"\n        if self.current_song_index is not None:\n            self.current_song_index = None\n            return True\n        return False\n\n    def switch_song(self):\n        \"\"\"\n        Switches to the next song in the playlist.\n        :return: True if the next song was switched to, False if there was no next song.\n        \"\"\"\n        if self.playlist:\n            if self.current_song_index is None:\n                self.current_song_index = 0\n            else:\n                self.current_song_index = (self.current_song_index + 1) % len(self.playlist)\n            return True\n        return False\n\n    def previous_song(self):\n        \"\"\"\n        Switches to the previous song in the playlist.\n        :return: True if the previous song was switched to, False if there was no previous song.\n        \"\"\"\n        if self.playlist:\n            if self.current_song_index is None:\n                self.current_song_index = len(self.playlist) - 1\n            else:\n                self.current_song_index = (self.current_song_index - 1) % len(self.playlist)\n            return True\n        return False\n\n    def set_volume(self, volume: int) -> bool:\n        \"\"\"\n        Sets the volume of the music player, if the volume is between 0 and 100 is valid.\n        :param volume: The volume to set the music player to, int.\n        :return: True if the volume was set, False if the volume was invalid.\n        \"\"\"\n        if 0 <= volume <= 100:\n            self.volume = volume\n            return True\n        return False\n\n    def shuffle(self) -> bool:\n        \"\"\"\n        Shuffles the playlist.\n        :return: True if the playlist was shuffled, False if the playlist was empty.\n        \"\"\"\n        if self.playlist:\n            random.shuffle(self.playlist)\n            return True\n        return False\n```",
    "64": "```python\nclass NumberConverter:\n    \"\"\"\n    The class allows converting decimal to binary, octal, and hexadecimal formats and vice versa.\n    \"\"\"\n\n    @staticmethod\n    def decimal_to_binary(decimal_num: int) -> str:\n        \"\"\"\n        Convert a number from decimal format to binary format.\n        :param decimal_num: int, decimal number\n        :return: str, the binary representation of an integer.\n        >>> NumberConverter.decimal_to_binary(42423)\n        '1010010110110111'\n        \"\"\"\n        return bin(decimal_num)[2:]\n\n    @staticmethod\n    def binary_to_decimal(binary_num: str) -> int:\n        \"\"\"\n        Convert a number from binary format to decimal format.\n        :param binary_num: str, binary number\n        :return: int, the decimal representation of binary number str.\n        >>> NumberConverter.binary_to_decimal('1010010110110111')\n        42423\n        \"\"\"\n        return int(binary_num, 2)\n\n    @staticmethod\n    def decimal_to_octal(decimal_num: int) -> str:\n        \"\"\"\n        Convert a number from decimal format to octal format.\n        :param decimal_num: int, decimal number\n        :return: str, the octal representation of an integer.\n        >>> NumberConverter.decimal_to_octal(42423)\n        '122667'\n        \"\"\"\n        return oct(decimal_num)[2:]\n\n    @staticmethod\n    def octal_to_decimal(octal_num: str) -> int:\n        \"\"\"\n        Convert a number from octal format to decimal format.\n        :param octal_num: str, octal number\n        :return: int, the decimal representation of octal number str.\n        >>> NumberConverter.octal_to_decimal('122667')\n        42423\n        \"\"\"\n        return int(octal_num, 8)\n\n    @staticmethod\n    def decimal_to_hex(decimal_num: int) -> str:\n        \"\"\"\n        Convert a number from decimal format to hexadecimal format.\n        :param decimal_num: int, decimal number\n        :return: str, the hex representation of an integer.\n        >>> NumberConverter.decimal_to_hex(42423)\n        'a5b7'\n        \"\"\"\n        return hex(decimal_num)[2:]\n\n    @staticmethod\n    def hex_to_decimal(hex_num: str) -> int:\n        \"\"\"\n        Convert a number from hexadecimal format to decimal format.\n        :param hex_num: str, hex number\n        :return: int, the decimal representation of hex number str.\n        >>> NumberConverter.hex_to_decimal('a5b7')\n        42423\n        \"\"\"\n        return int(hex_num, 16)\n```",
    "66": "```python\nimport re\nimport unittest\n\nclass NumericEntityUnescaper:\n    \"\"\"\n    Class to replace numeric entities with their corresponding characters in a given string.\n    \"\"\"\n\n    def replace(self, string):\n        \"\"\"\n        Replaces numeric character references (HTML entities) in the input string \n        with their corresponding Unicode characters.\n\n        :param string: str, the input string containing numeric character references.\n        :return: str, the input string with numeric character references replaced.\n        \"\"\"\n        def replace_entity(match):\n            entity = match.group(0)\n            is_hex = entity.startswith(\"&#X\") or entity.startswith(\"&#x\")\n            number_str = entity[3:-1]  # Extract number part\n            \n            # Validate and convert the number\n            try:\n                code_point = int(number_str, 16) if is_hex else int(number_str)\n                return chr(code_point) if 0 <= code_point <= 0x10FFFF else entity\n            except ValueError:\n                return entity  # Return original if conversion fails\n\n        regex = r'&#X?[0-9a-fA-F]+;'\n        return re.sub(regex, replace_entity, string)\n\n    @staticmethod\n    def is_hex_char(char):\n        \"\"\"\n        Determines if a character is a hexadecimal digit.\n\n        :param char: str, the character to check.\n        :return: bool, True if the character is a hexadecimal digit, False otherwise.\n        \"\"\"\n        return char.lower() in '0123456789abcdef'\n\n\nclass NumericEntityUnescaperTestReplace(unittest.TestCase):\n    def setUp(self):\n        self.unescaper = NumericEntityUnescaper()\n\n    def test_replace_valid(self):\n        self.assertEqual(self.unescaper.replace(\"&#65;&#66;&#67;\"), \"ABC\")\n        self.assertEqual(self.unescaper.replace(\"&#X65;&#66;&#67;\"), \"eBC\")\n    \n    def test_replace_repeated(self):\n        self.assertEqual(self.unescaper.replace(\"&#65;&#65;&#65;\"), \"AAA\")\n        self.assertEqual(self.unescaper.replace(\"&#66;&#66;&#66;\"), \"BBB\")\n        self.assertEqual(self.unescaper.replace(\"&#67;&#67;&#67;\"), \"CCC\")\n\n    def test_replace_empty(self):\n        self.assertEqual(self.unescaper.replace(\"\"), \"\")\n        self.assertEqual(self.unescaper.replace(\"&#\"), \"\")\n        self.assertEqual(self.unescaper.replace(\"&#X\"), \"\")\n        \n    def test_replace_invalid(self):\n        self.assertEqual(self.unescaper.replace(\"&#???;&#66;&#67;\"), \"&#???;BC\")\n        self.assertEqual(self.unescaper.replace(\"&#c1d;&#66;&#67;\"), \"\")\n        self.assertEqual(self.unescaper.replace(\"&#67;&#67;&#67;;\"), \"CCC\")\n\n\nclass NumericEntityUnescaperTestIsHexChar(unittest.TestCase):\n    def test_is_hex_char(self):\n        unescaper = NumericEntityUnescaper()\n        self.assertTrue(unescaper.is_hex_char('0'))\n        self.assertTrue(unescaper.is_hex_char('F'))\n        self.assertFalse(unescaper.is_hex_char('G'))\n        self.assertFalse(unescaper.is_hex_char('X'))\n        self.assertFalse(unescaper.is_hex_char('Z'))\n\n\nif __name__ == '__main__':\n    unittest.main()\n```",
    "67": "```python\nclass Order:\n    \"\"\"\n    The class manages restaurant orders by allowing the addition of dishes, calculation of the total cost, and checkout.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the order management system. \n        - self.menu stores the dishes of restaurant inventory.\n        - self.selected_dishes stores the dishes selected by customer.\n        - self.sales stores the sales multiplier for each dish.\n        \"\"\"\n        self.menu = []\n        self.selected_dishes = []\n        self.sales = {}\n\n    def add_dish(self, dish):\n        \"\"\"\n        Add a dish to the selected dishes if the count is available in the menu.\n        \n        :param dish: dict, the information of dish. \n                     dish = {\"dish\": dish name, \"count\": count, \"price\": price}\n        :return: True if successfully added, or False otherwise.\n        \"\"\"\n        for menu_dish in self.menu:\n            if menu_dish[\"dish\"] == dish[\"dish\"]:\n                if menu_dish[\"count\"] >= dish[\"count\"]:\n                    menu_dish[\"count\"] -= dish[\"count\"]\n                    self.selected_dishes.append(dish)\n                    return True\n                return False\n        return False\n\n    def calculate_total(self):\n        \"\"\"\n        Calculate the total price of dishes that have been ordered.\n        \n        :return: float, the final total price.\n        \"\"\"\n        total = sum(selected[\"price\"] * self.sales.get(selected[\"dish\"], 1) * selected[\"count\"]\n                     for selected in self.selected_dishes)\n        return total\n\n    def checkout(self):\n        \"\"\"\n        Check out the dishes ordered. If the selected dishes are not empty, calculate the total.\n        \n        :return: False if the selected dishes are empty, or total (return value of calculate_total) otherwise.\n        \"\"\"\n        if not self.selected_dishes:\n            return False\n        total = self.calculate_total()\n        self.selected_dishes.clear()  # Clear the selected dishes after checkout\n        return total\n```",
    "65": "```python\nclass NumberWordFormatter:\n    \"\"\"\n    A class that converts numbers into their corresponding English word representation,\n    handling both integer and decimal parts, and incorporating appropriate connectors and units.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize NumberWordFormatter object.\n        \"\"\"\n        self.units = [\"\", \"ONE\", \"TWO\", \"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\"]\n        self.teens = [\"TEN\", \"ELEVEN\", \"TWELVE\", \"THIRTEEN\", \"FOURTEEN\", \"FIFTEEN\", \"SIXTEEN\", \"SEVENTEEN\",\n                      \"EIGHTEEN\", \"NINETEEN\"]\n        self.tens = [\"\", \"\", \"TWENTY\", \"THIRTY\", \"FORTY\", \"FIFTY\", \"SIXTY\", \"SEVENTY\", \"EIGHTY\", \"NINETY\"]\n        self.magnitudes = [\"\", \"THOUSAND\", \"MILLION\", \"BILLION\"]\n\n    def format(self, x):\n        \"\"\"\n        Converts a number into words format.\n        :param x: int or float, the number to be converted into words format\n        :return: str, the number in words format\n        \"\"\"\n        if x is None:\n            return \"\"\n        elif x == 0:\n            return \"ZERO ONLY\"\n        \n        integer_part = int(x)\n        decimal_part = round((x - integer_part) * 100)\n\n        words = self.format_integer(integer_part)\n        if decimal_part > 0:\n            words += f\" AND CENTS {self.trans_two(str(decimal_part))} ONLY\"\n        else:\n            words += \" ONLY\"\n        return words\n\n    def format_string(self, x):\n        \"\"\"\n        Converts a string representation of a number into words format.\n        :param x: str, the string representation of a number\n        :return: str, the number in words format\n        \"\"\"\n        return self.format(float(x))\n\n    def trans_two(self, s):\n        \"\"\"\n        Converts a two-digit number into words format.\n        :param s: str, the two-digit number\n        :return: str, the number in words format\n        \"\"\"\n        n = int(s)\n        if n < 10:\n            return self.units[n]\n        elif n < 20:\n            return self.teens[n - 10]\n        else:\n            return self.tens[n // 10] + ('' if n % 10 == 0 else ' ' + self.units[n % 10])\n\n    def trans_three(self, s):\n        \"\"\"\n        Converts a three-digit number into words format.\n        :param s: str, the three-digit number\n        :return: str, the number in words format\n        \"\"\"\n        n = int(s)\n        if n == 0:\n            return \"\"\n        elif n < 100:\n            return self.trans_two(s)\n        else:\n            return self.units[n // 100] + \" HUNDRED\" + ('' if n % 100 == 0 else ' AND ' + self.trans_two(str(n % 100)))\n\n    def format_integer(self, n):\n        \"\"\"\n        Formats an integer into words.\n        :param n: int, the integer to be converted\n        :return: str, the number in words format\n        \"\"\"\n        if n == 0:\n            return \"ZERO\"\n\n        parts = []\n        magnitude_index = 0\n\n        while n > 0:\n            if n % 1000 != 0:\n                part = self.trans_three(str(n % 1000))\n                if magnitude_index > 0:\n                    part += \" \" + self.magnitudes[magnitude_index]\n                parts.append(part)\n            n //= 1000\n            magnitude_index += 1\n\n        return ' '.join(reversed(parts)).strip()\n```",
    "68": "```python\nclass PageUtil:\n    \"\"\"\n    PageUtil class is a versatile utility for handling pagination and search functionalities in an efficient and convenient manner.\n    \"\"\"\n\n    def __init__(self, data, page_size):\n        \"\"\"\n        Initialize the PageUtil object with the given data and page size.\n        :param data: list, the data to be paginated\n        :param page_size: int, the number of items per page\n        \"\"\"\n        self.data = data\n        self.page_size = page_size\n        self.total_items = len(data)\n        self.total_pages = (self.total_items + page_size - 1) // page_size\n\n    def get_page(self, page_number):\n        \"\"\"\n        Retrieve a specific page of data.\n        :param page_number: int, the page number to fetch\n        :return: list, the data on the specified page\n        \"\"\"\n        if not (1 <= page_number <= self.total_pages):\n            return []\n\n        start_index = (page_number - 1) * self.page_size\n        end_index = start_index + self.page_size\n        return self.data[start_index:end_index]\n\n    def get_page_info(self, page_number):\n        \"\"\"\n        Retrieve information about a specific page.\n        :param page_number: int, the page number to fetch information about\n        :return: dict, containing page information such as current page number, total pages, etc.\n        \"\"\"\n        if not (1 <= page_number <= self.total_pages):\n            return {}\n\n        return {\n            \"current_page\": page_number,\n            \"per_page\": self.page_size,\n            \"total_pages\": self.total_pages,\n            \"total_items\": self.total_items,\n            \"has_previous\": page_number > 1,\n            \"has_next\": page_number < self.total_pages,\n            \"data\": self.get_page(page_number)\n        }\n\n    def search(self, keyword):\n        \"\"\"\n        Search for items in the data that contain the given keyword.\n        :param keyword: str, the keyword to search for\n        :return: dict, containing search information such as total results and matching items\n        \"\"\"\n        results = [item for item in self.data if keyword in str(item)]\n        total_results = len(results)\n        total_pages = (total_results + self.page_size - 1) // self.page_size\n\n        return {\n            \"keyword\": keyword,\n            \"total_results\": total_results,\n            \"total_pages\": total_pages,\n            \"results\": results\n        }\n```",
    "70": "```python\nclass PersonRequest:\n    \"\"\"\n    This class validates input personal information data and sets invalid fields to None based on specific rules.\n    \"\"\"\n\n    VALID_SEXES = {\"Man\", \"Woman\", \"UGM\"}\n\n    def __init__(self, name: str, sex: str, phone_number: str):\n        \"\"\"\n        Initialize PersonRequest object with the provided information.\n        :param name: str, the name of the person\n        :param sex: str, the sex of the person\n        :param phone_number: str, the phone number of the person\n        \"\"\"\n        self.name = self._validate_name(name)\n        self.sex = self._validate_sex(sex)\n        self.phone_number = self._validate_phone_number(phone_number)\n\n    def _validate_name(self, name: str) -> str:\n        \"\"\"\n        Validate the name and return it. If name is empty or exceeds 33 characters in length, set to None.\n        :param name: str, the name to validate\n        :return: str, the validated name or None if invalid\n        \"\"\"\n        if name and len(name) <= 33:\n            return name\n        return None\n\n    def _validate_sex(self, sex: str) -> str:\n        \"\"\"\n        Validate the sex and return it. If sex is not Man, Woman, or UGM, set to None.\n        :param sex: str, the sex to validate\n        :return: str, the validated sex or None if invalid\n        \"\"\"\n        return sex if sex in self.VALID_SEXES else None\n\n    def _validate_phone_number(self, phone_number: str) -> str:\n        \"\"\"\n        Validate the phone number and return it. If phone_number is empty or not an 11 digit number, set to None.\n        :param phone_number: str, the phone number to validate\n        :return: str, the validated phone number or None if invalid\n        \"\"\"\n        return phone_number if phone_number.isdigit() and len(phone_number) == 11 else None\n```",
    "69": "```python\nimport PyPDF2\nimport os\nimport unittest\nfrom reportlab.pdfgen import canvas\n\nclass PDFHandler:\n    \"\"\"\n    The class allows merging multiple PDF files into one and extracting text from PDFs using PyPDF2 library.\n    \"\"\"\n\n    def __init__(self, filepaths):\n        \"\"\"\n        Initializes the PDFHandler with a list of file paths and creates PdfFileReader objects for each file.\n        :param filepaths: list of str, paths to the PDF files\n        \"\"\"\n        self.filepaths = filepaths\n        self.readers = [self._open_pdf(fp) for fp in filepaths]\n\n    @staticmethod\n    def _open_pdf(filepath):\n        \"\"\"Open a PDF file and return a PdfFileReader object.\"\"\"\n        return PyPDF2.PdfFileReader(open(filepath, 'rb'))\n\n    def merge_pdfs(self, output_filepath):\n        \"\"\"\n        Merge the PDFs stored in self.readers into a single PDF and save to disk.\n        \n        :param output_filepath: str, output file path to save to\n        :return: str, confirmation message\n        \"\"\"\n        merger = PyPDF2.PdfFileMerger()\n        for reader in self.readers:\n            merger.append(reader)\n\n        with open(output_filepath, 'wb') as output_file:\n            merger.write(output_file)\n\n        merger.close()\n        return f\"Merged PDFs saved at {output_filepath}\"\n\n    def extract_text_from_pdfs(self):\n        \"\"\"\n        Extract text from PDF files in self.readers.\n        \n        :return: list of str, each element is the text of one PDF file\n        \"\"\"\n        pdf_texts = []\n        for reader in self.readers:\n            text = \"\"\n            for page in range(reader.getNumPages()):\n                text += reader.getPage(page).extract_text() + \"\\n\"\n            pdf_texts.append(text)\n        return pdf_texts\n\n\nclass TestPDFHandler(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.test_files = [\"test1.pdf\", \"test2.pdf\"]\n        cls.test_text = [\"This is a test1.\", \"This is a test2.\"]\n        for i, text in enumerate(cls.test_text):\n            c = canvas.Canvas(cls.test_files[i])\n            c.drawString(100, 100, text)\n            c.showPage()\n            c.save()\n\n    @classmethod\n    def tearDownClass(cls):\n        for filename in cls.test_files:\n            os.remove(filename)\n        if os.path.exists(\"merged.pdf\"):\n            os.remove(\"merged.pdf\")\n\n    def test_merge_pdfs(self):\n        handler = PDFHandler(self.test_files)\n        result = handler.merge_pdfs(\"merged.pdf\")\n        self.assertEqual(\"Merged PDFs saved at merged.pdf\", result)\n        self.assertTrue(os.path.exists(\"merged.pdf\"))\n\n    def test_extract_text_from_pdfs(self):\n        handler = PDFHandler(self.test_files)\n        result = handler.extract_text_from_pdfs()\n        self.assertEqual(result, [\"This is a test1.\\n\", \"This is a test2.\\n\"])\n\n    def test_main(self):\n        handler = PDFHandler(self.test_files)\n        merge_result = handler.merge_pdfs(\"merged.pdf\")\n        self.assertEqual(\"Merged PDFs saved at merged.pdf\", merge_result)\n        self.assertTrue(os.path.exists(\"merged.pdf\"))\n\n        extract_result = handler.extract_text_from_pdfs()\n        self.assertEqual(extract_result, [\"This is a test1.\\n\", \"This is a test2.\\n\"])\n```",
    "72": "```python\nimport re\n\nclass RegexUtils:\n    \"\"\"\n    A utility class for performing various operations using regular expressions, including matching, finding,\n    splitting, and substituting text. It includes predefined patterns for validating phone numbers and extracting\n    email addresses.\n    \"\"\"\n\n    @staticmethod\n    def match(pattern, text):\n        \"\"\"\n        Check if the text fully matches the regular expression pattern.\n        \n        :param pattern: str, Regular expression pattern\n        :param text: str, Text to match\n        :return: bool, True if the text fully matches the pattern, otherwise False\n        \"\"\"\n        return bool(re.fullmatch(pattern, text))\n\n    @staticmethod\n    def findall(pattern, text):\n        \"\"\"\n        Find all occurrences of the pattern in the text and return them as a list.\n        \n        :param pattern: str, Regular expression pattern\n        :param text: str, Text to search\n        :return: list of str, List of all matching substrings\n        \"\"\"\n        return re.findall(pattern, text)\n\n    @staticmethod\n    def split(pattern, text):\n        \"\"\"\n        Split the text by the occurrences of the pattern.\n        \n        :param pattern: str, Regular expression pattern\n        :param text: str, Text to split\n        :return: list of str, List of substrings after splitting\n        \"\"\"\n        return re.split(pattern, text)\n\n    @staticmethod\n    def sub(pattern, replacement, text):\n        \"\"\"\n        Replace occurrences of the pattern in the text with the specified replacement.\n        \n        :param pattern: str, Regular expression pattern\n        :param replacement: str, Text to replace with\n        :param text: str, Text to be modified\n        :return: str, Text after replacement\n        \"\"\"\n        return re.sub(pattern, replacement, text)\n\n    @staticmethod\n    def generate_email_pattern():\n        \"\"\"\n        Generate a regex pattern for matching email addresses.\n        \n        :return: str, Regex pattern for email addresses\n        \"\"\"\n        return r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n\n    @staticmethod\n    def generate_phone_number_pattern():\n        \"\"\"\n        Generate a regex pattern for matching phone numbers in the format xxx-xxx-xxxx.\n        \n        :return: str, Regex pattern for phone numbers\n        \"\"\"\n        return r'\\b\\d{3}-\\d{3}-\\d{4}\\b'\n\n    @staticmethod\n    def generate_split_sentences_pattern():\n        \"\"\"\n        Generate a regex pattern for splitting sentences based on punctuation.\n        \n        :return: str, Regex pattern for splitting sentences\n        \"\"\"\n        return r'[.!?][\\s]+(?=[A-Z])'\n\n    @staticmethod\n    def split_sentences(text):\n        \"\"\"\n        Split the text into a list of sentences.\n        \n        :param text: str, Text to be split into sentences\n        :return: List of str, Sentences from the text\n        \"\"\"\n        sentences = re.split(RegexUtils.generate_split_sentences_pattern(), text)\n        return [s.strip() for s in sentences if s.strip()]\n\n    @staticmethod\n    def validate_phone_number(phone_number):\n        \"\"\"\n        Validate if the provided phone number matches the expected format.\n        \n        :param phone_number: str, Phone number to validate\n        :return: bool, True if the phone number is valid, otherwise False\n        \"\"\"\n        pattern = RegexUtils.generate_phone_number_pattern()\n        return RegexUtils.match(pattern, phone_number)\n\n    @staticmethod\n    def extract_email(text):\n        \"\"\"\n        Extract all email addresses from the provided text.\n        \n        :param text: str, Input text to extract emails from\n        :return: list of str, List of extracted email addresses\n        \"\"\"\n        pattern = RegexUtils.generate_email_pattern()\n        return RegexUtils.findall(pattern, text)\n```",
    "71": "```python\nclass PushBoxGame:\n    \"\"\"\n    This class implements the functionality of a Sokoban game, where the player needs to move boxes to designated targets to win.\n    \"\"\"\n\n    WALL = '#'\n    PLAYER = 'O'\n    TARGET = 'G'\n    BOX = 'X'\n    \n    def __init__(self, game_map):\n        \"\"\"\n        Initialize the push box game with the map and various attributes.\n        :param game_map: list[str], the map of the push box game, represented as a list of strings. \n        \"\"\"\n        self.map = game_map\n        self.player_row, self.player_col = self.find_player()\n        self.targets = self.find_targets()\n        self.boxes = self.find_boxes()\n        self.is_game_over = False\n\n    def find_player(self):\n        \"\"\"Finds the player's initial position.\"\"\"\n        for row, line in enumerate(self.map):\n            if self.PLAYER in line:\n                return row, line.index(self.PLAYER)\n        raise ValueError(\"Player not found on the map.\")\n\n    def find_targets(self):\n        \"\"\"Finds all target positions.\"\"\"\n        return [(row, col) for row in range(len(self.map)) \n                for col in range(len(self.map[row])) \n                if self.map[row][col] == self.TARGET]\n\n    def find_boxes(self):\n        \"\"\"Finds all box positions.\"\"\"\n        return [(row, col) for row in range(len(self.map)) \n                for col in range(len(self.map[row])) \n                if self.map[row][col] == self.BOX]\n\n    def check_win(self):\n        \"\"\"\n        Check if the game is won. The game is won when all the boxes are placed on target positions.\n        \"\"\"\n        return all(box in self.targets for box in self.boxes)\n\n    def move(self, direction):\n        \"\"\"\n        Move the player based on the specified direction and check if the game is won.\n        :param direction: str, the direction of the player's movement.\n        :return: True if the game is won, False otherwise.\n        \"\"\"\n        delta = {'w': (-1, 0), 's': (1, 0), 'a': (0, -1), 'd': (0, 1)}\n        if direction not in delta:\n            return False\n\n        new_row, new_col = self.player_row + delta[direction][0], self.player_col + delta[direction][1]\n\n        if self.is_valid_move(new_row, new_col):\n            self.player_row, self.player_col = new_row, new_col\n            if (new_row, new_col) in self.boxes:\n                box_new_row = new_row + delta[direction][0]\n                box_new_col = new_col + delta[direction][1]\n                if self.is_valid_move(box_new_row, box_new_col):\n                    self.move_box(new_row, new_col, box_new_row, box_new_col)\n\n            self.is_game_over = self.check_win()\n            return self.is_game_over\n        return False\n\n    def move_box(self, box_row, box_col, new_box_row, new_box_col):\n        \"\"\"Moves the box to a new position.\"\"\"\n        self.boxes.remove((box_row, box_col))\n        self.boxes.append((new_box_row, new_box_col))\n\n    def is_valid_move(self, row, col):\n        \"\"\"Checks if the move is valid (not out of bounds and not hitting walls).\"\"\"\n        return (0 <= row < len(self.map) and \n                0 <= col < len(self.map[row]) and \n                self.map[row][col] != self.WALL)\n```",
    "73": "```python\nclass RPGCharacter:\n    \"\"\"\n    Represents a role-playing game character capable of attacking, healing, gaining experience,\n    leveling up, and checking if the character is alive.\n    \"\"\"\n\n    MAX_HP = 100\n    MAX_LEVEL = 100\n    EXP_PER_LEVEL = 100\n\n    def __init__(self, name, hp, attack_power, defense, level=1):\n        \"\"\"\n        Initialize an RPG character object.\n        :param name: str, the name of the character.\n        :param hp: int, initial health points of the character.\n        :param attack_power: int, attack power of the character.\n        :param defense: int, defense points of the character.\n        :param level: int, level of the character, default is 1.\n        \"\"\"\n        self.name = name\n        self.hp = hp\n        self.attack_power = attack_power\n        self.defense = defense\n        self.level = level\n        self.exp = 0\n\n    def attack(self, other_character):\n        \"\"\"\n        Attack another character, calculating damage based on defense.\n        :param other_character: RPGCharacter, the character being attacked.\n        \"\"\"\n        damage = max(0, self.attack_power - other_character.defense)\n        other_character.hp = max(0, other_character.hp - damage)\n\n    def heal(self):\n        \"\"\"\n        Heal the character by 10 HP with a maximum HP cap of 100.\n        :return: int, the current health points after healing.\n        \"\"\"\n        self.hp = min(self.MAX_HP, self.hp + 10)\n        return self.hp\n\n    def gain_exp(self, amount):\n        \"\"\"\n        Gain experience points and level up when the experience exceeds threshold.\n        :param amount: int, the amount of experience points to gain.\n        \"\"\"\n        self.exp += amount\n        while self.exp >= self.EXP_PER_LEVEL * self.level and self.level < self.MAX_LEVEL:\n            self.level_up()\n\n    def level_up(self):\n        \"\"\"\n        Level up the character, resetting experience and increasing stats.\n        :return: tuple[int, int, int, int], new level, health points, attack power, defense points after leveling up.\n        \"\"\"\n        if self.level < self.MAX_LEVEL:\n            self.level += 1\n            self.hp = min(self.MAX_HP, self.hp + 20)\n            self.attack_power += 5\n            self.defense += 5\n            self.exp = 0\n        return self.level, self.hp, self.attack_power, self.defense\n\n    def is_alive(self):\n        \"\"\"\n        Check if the character is alive.\n        :return: True if health points are greater than 0, False otherwise.\n        \"\"\"\n        return self.hp > 0\n```",
    "74": "```python\nclass Server:\n    \"\"\"\n    Server class that manages a whitelist, handles message sending and receiving, and displays information.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the server with an empty whitelist and structures for sending and receiving messages.\n        \"\"\"\n        self.white_list = set()  # Use a set for O(1) average time complexity for lookups\n        self.send_struct = {}\n        self.receive_struct = {}\n\n    def add_white_list(self, addr):\n        \"\"\"\n        Add an address to the whitelist if it does not already exist.\n        :param addr: int, address to be added\n        :return: updated whitelist or False if the address already exists\n        \"\"\"\n        if addr in self.white_list:\n            return False\n        self.white_list.add(addr)\n        return list(self.white_list)\n\n    def del_white_list(self, addr):\n        \"\"\"\n        Remove an address from the whitelist if it exists.\n        :param addr: int, address to be deleted\n        :return: updated whitelist or False if the address does not exist\n        \"\"\"\n        if addr not in self.white_list:\n            return False\n        self.white_list.remove(addr)\n        return list(self.white_list)\n\n    def recv(self, info):\n        \"\"\"\n        Receive information if the address is on the whitelist.\n        :param info: dict, information containing 'addr' and 'content'\n        :return: content of the information if received, False if not on whitelist, or -1 for invalid input\n        \"\"\"\n        if not isinstance(info, dict) or 'addr' not in info or 'content' not in info:\n            return -1\n\n        addr = info['addr']\n        content = info['content']\n\n        if addr not in self.white_list:\n            return False\n\n        self.receive_struct = info\n        return content\n\n    def send(self, info):\n        \"\"\"\n        Send information containing address and content.\n        :param info: dict, information containing 'addr' and 'content'\n        :return: None if sent successfully, error message if input structure is incorrect\n        \"\"\"\n        if not isinstance(info, dict) or 'addr' not in info or 'content' not in info:\n            return \"info structure is not correct\"\n\n        self.send_struct = info\n\n    def show(self, struct_type):\n        \"\"\"\n        Returns the structure of the specified type ('send' or 'receive').\n        :param struct_type: string, type of struct to be returned\n        :return: corresponding struct or False if type is invalid\n        \"\"\"\n        if struct_type == 'send':\n            return self.send_struct\n        elif struct_type == 'receive':\n            return self.receive_struct\n        return False\n```",
    "76": "```python\nclass SignInSystem:\n    \"\"\"\n    A sign-in system that allows adding users, signing in/out,\n    checking sign-in status, and retrieving lists of signed-in or not signed-in users.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the sign-in system with an empty user dictionary.\"\"\"\n        self.users = {}\n\n    def add_user(self, username: str) -> bool:\n        \"\"\"\n        Add a user to the sign-in system if the user does not already exist.\n        The initial sign-in state for a new user is False.\n\n        :param username: The username to be added.\n        :return: True if the user is added successfully, False if the user already exists.\n        \"\"\"\n        if username not in self.users:\n            self.users[username] = False\n            return True\n        return False\n\n    def sign_in(self, username: str) -> bool:\n        \"\"\"\n        Sign in a user if the user exists in the system and change their state to signed in (True).\n\n        :param username: The username to be signed in.\n        :return: True if the user is signed in successfully, False if the user does not exist.\n        \"\"\"\n        if username in self.users:\n            self.users[username] = True\n            return True\n        return False\n\n    def check_sign_in(self, username: str) -> bool:\n        \"\"\"\n        Check if a user is signed in.\n\n        :param username: The username to be checked.\n        :return: True if the user is signed in, False if the user does not exist or is not signed in.\n        \"\"\"\n        return self.users.get(username, False)\n\n    def all_signed_in(self) -> bool:\n        \"\"\"\n        Check if all users are signed in.\n\n        :return: True if all users are signed in, False otherwise.\n        \"\"\"\n        return all(self.users.values())\n\n    def all_not_signed_in(self) -> list[str]:\n        \"\"\"\n        Get a list of usernames that are not signed in.\n\n        :return: A list of usernames that are not signed in.\n        \"\"\"\n        return [username for username, signed_in in self.users.items() if not signed_in]\n```",
    "75": "```python\nclass ShoppingCart:\n    \"\"\"\n    The class manages items, their prices, quantities, and allows for adding, removing, viewing items, and calculating the total price.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the items representing the shopping list as an empty dictionary.\n        \"\"\"\n        self.items = {}\n\n    def add_item(self, item: str, price: float, quantity: int = 1) -> None:\n        \"\"\"\n        Add item information to the shopping list items, including price and quantity.\n        \n        :param item: str, Item to be added\n        :param price: float, The price of the item\n        :param quantity: int, The number of items, defaults to 1\n        :return: None\n        \"\"\"\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be positive.\")\n        if item in self.items:\n            self.items[item]['quantity'] += quantity\n        else:\n            self.items[item] = {'price': price, 'quantity': quantity}\n\n    def remove_item(self, item: str, quantity: int = 1) -> None:\n        \"\"\"\n        Subtract the specified quantity of item from the shopping list items.\n        \n        :param item: str, Item to be subtracted in quantity\n        :param quantity: int, Quantity to be subtracted\n        :return: None\n        \"\"\"\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be positive.\")\n        if item in self.items:\n            self.items[item]['quantity'] -= quantity\n            if self.items[item]['quantity'] <= 0:\n                del self.items[item]\n\n    def view_items(self) -> dict:\n        \"\"\"\n        Return the current shopping list items.\n        \n        :return: dict, the current shopping list items\n        \"\"\"\n        return self.items\n\n    def total_price(self) -> float:\n        \"\"\"\n        Calculate the total price of all items in the shopping list.\n        \n        :return: float, the total price of all items in the shopping list\n        \"\"\"\n        return sum(item['price'] * item['quantity'] for item in self.items.values())\n```",
    "77": "```python\nimport random\n\nclass Snake:\n    \"\"\"\n    The class implements a snake game, allowing the snake to move, eat food,\n    reset, and generate a random food position.\n    \"\"\"\n\n    def __init__(self, screen_width, screen_height, block_size, food_position):\n        \"\"\"\n        Initializes the snake with its properties.\n        :param screen_width: int\n        :param screen_height: int\n        :param block_size: int, Size of moving units\n        :param food_position: tuple, representing the position (x, y) of food.\n        \"\"\"\n        self.length = 1\n        self.screen_width = screen_width\n        self.screen_height = screen_height\n        self.block_size = block_size\n        self.positions = [(screen_width // 2, screen_height // 2)]\n        self.score = 0\n        self.food_position = food_position\n        self.random_food_position()\n\n    def move(self, direction):\n        \"\"\"\n        Move the snake in the specified direction.\n        :param direction: tuple, representing the direction of movement (x, y).\n        \"\"\"\n        new_head = (self.positions[0][0] + direction[0] * self.block_size,\n                     self.positions[0][1] + direction[1] * self.block_size)\n\n        # Check if the snake has eaten the food\n        if new_head == self.food_position:\n            self.eat_food()\n        else:\n            self.positions.insert(0, new_head)  # Add new head position\n            if len(self.positions) > self.length:\n                self.positions.pop()  # Remove the tail of the snake\n\n        # Check if the snake has collided with itself\n        if new_head in self.positions[1:]:\n            self.reset()\n\n    def random_food_position(self):\n        \"\"\"\n        Randomly generate a new food position, ensuring it does not overlap with the snake.\n        \"\"\"\n        while True:\n            x = random.randint(0, (self.screen_width // self.block_size) - 1) * self.block_size\n            y = random.randint(0, (self.screen_height // self.block_size) - 1) * self.block_size\n            self.food_position = (x, y)\n            if self.food_position not in self.positions:\n                break\n\n    def reset(self):\n        \"\"\"\n        Reset the snake to its initial state.\n        \"\"\"\n        self.length = 1\n        self.positions = [(self.screen_width // 2, self.screen_height // 2)]\n        self.score = 0\n        self.random_food_position()\n\n    def eat_food(self):\n        \"\"\"\n        Increase the length of the snake by 1 and increase the score by 100.\n        \"\"\"\n        self.length += 1\n        self.score += 100\n        self.random_food_position()\n```",
    "78": "```python\nimport re\n\nclass SplitSentence:\n    \"\"\"\n    The class allows to split sentences, count words in a sentence, and process a text to find the maximum word count.\n    \"\"\"\n\n    def split_sentences(self, sentences_string):\n        \"\"\"\n        Split a string into a list of sentences. Sentences end with . or ? and have a space after that. \n        'Mr.' also ends with . but is not treated as a sentence.\n        \n        :param sentences_string: str, string to split\n        :return: list, list of split sentences\n        \"\"\"\n        sentences = re.split(r'(?<!Mr)(?<![A-Z]\\.)[.?\\s]+', sentences_string.strip())\n        return [s.strip() for s in sentences if s.strip()]\n\n    def count_words(self, sentence):\n        \"\"\"\n        Count the number of words in a sentence. Words are separated by spaces and punctuation marks/numbers are not counted.\n        \n        :param sentence: str, sentence to be counted\n        :return: int, number of words in the sentence\n        \"\"\"\n        words = re.findall(r'\\b[a-zA-Z]+\\b', sentence)\n        return len(words)\n\n    def process_text_file(self, sentences_string):\n        \"\"\"\n        Given a text, return the number of words in the longest sentence.\n        \n        :param sentences_string: str, undivided long sentence\n        :return: int, number of words in the longest sentence\n        \"\"\"\n        sentences = self.split_sentences(sentences_string)\n        return max((self.count_words(sentence) for sentence in sentences), default=0)\n\n# Unit tests\nimport unittest\n\nclass SplitSentenceTestSplitSentences(unittest.TestCase):\n    def test_split_sentences(self):\n        ss = SplitSentence()\n        cases = [\n            (\"aaa aaaa. bb bbbb bbb? cccc cccc. dd ddd?\", ['aaa aaaa.', 'bb bbbb bbb?', 'cccc cccc.', 'dd ddd?']),\n            (\"Who is Mr. Smith? He is a teacher.\", ['Who is Mr. Smith?', 'He is a teacher.']),\n            (\"Who is A.B.C.? He is a teacher.\", ['Who is A.B.C.?', 'He is a teacher.']),\n            (\"aaa aaaa. bb bbbb bbb? cccc cccc.\", ['aaa aaaa.', 'bb bbbb bbb?', 'cccc cccc.']),\n            (\"aaa aaaa. bb bbbb bbb?\", ['aaa aaaa.', 'bb bbbb bbb?'])\n        ]\n        for input_text, expected in cases:\n            self.assertEqual(ss.split_sentences(input_text), expected)\n\nclass SplitSentenceTestCountWords(unittest.TestCase):\n    def test_count_words(self):\n        ss = SplitSentence()\n        cases = [\n            (\"abc def\", 2),\n            (\"abc def 1\", 2),\n            (\"abc 1\", 1),\n            (\"abc def bbb1\", 3),\n            (\"abc def 111\", 2)\n        ]\n        for input_text, expected in cases:\n            self.assertEqual(ss.count_words(input_text), expected)\n\nclass SplitSentenceTestProcessTextFile(unittest.TestCase):\n    def test_process_text_file(self):\n        ss = SplitSentence()\n        cases = [\n            (\"aaa aaaa. bb bbbb bbb? cccc ccccccc cc ccc. dd ddd?\", 4),\n            (\"Mr. Smith is a teacher. Yes.\", 5),\n            (\"Mr. Smith is a teacher. Yes 1 2 3 4 5 6.\", 5),\n            (\"aaa aaaa. bb bbbb bbb? cccc ccccccc cc ccc.\", 4),\n            (\"aaa aaaa. bb bbbb bbb?\", 3)\n        ]\n        for input_text, expected in cases:\n            self.assertEqual(ss.process_text_file(input_text), expected)\n\nclass SplitSentenceTest(unittest.TestCase):\n    def test_complete_functionality(self):\n        ss = SplitSentence()\n        self.assertEqual(ss.split_sentences(\"aaa aaaa. bb bbbb bbb? cccc cccc. dd ddd?\"),\n                         ['aaa aaaa.', 'bb bbbb bbb?', 'cccc cccc.', 'dd ddd?'])\n        self.assertEqual(ss.count_words(\"abc def\"), 2)\n        self.assertEqual(ss.process_text_file(\"aaa aaaa. bb bbbb bbb? cccc ccccccc cc ccc. dd ddd?\"), 4)\n\nif __name__ == \"__main__\":\n    unittest.main()\n```",
    "83": "```python\nimport sqlite3\nfrom contextlib import closing\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    A class for managing student records in a SQLite database.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n        self.create_student_table()\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist.\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            with closing(conn.cursor()) as cursor:\n                cursor.execute('''\n                    CREATE TABLE IF NOT EXISTS students (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        name TEXT NOT NULL,\n                        age INTEGER NOT NULL,\n                        gender TEXT NOT NULL,\n                        grade INTEGER NOT NULL\n                    )\n                ''')\n                conn.commit()\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary with student's information (name, age, gender, grade).\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            with closing(conn.cursor()) as cursor:\n                cursor.execute('''\n                    INSERT INTO students (name, age, gender, grade)\n                    VALUES (?, ?, ?, ?)\n                ''', (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))\n                conn.commit()\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for students by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows that match the search criteria.\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            with closing(conn.cursor()) as cursor:\n                cursor.execute('SELECT * FROM students WHERE name=?', (name,))\n                return cursor.fetchall()\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            with closing(conn.cursor()) as cursor:\n                cursor.execute('DELETE FROM students WHERE name=?', (name,))\n                conn.commit()\n```",
    "81": "```python\nimport math\nfrom collections import Counter\n\nclass Statistics3:\n    \"\"\"\n    This class implements methods for calculating statistical indicators \n    such as median, mode, correlation matrix, mean, standard deviation, and Z-score.\n    \"\"\"\n\n    @staticmethod\n    def median(data):\n        \"\"\"\n        Calculates the median of the given list.\n        :param data: List of numbers.\n        :return: Median value as float or None if data is empty.\n        \"\"\"\n        if not data:\n            return None\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        mid = n // 2\n        return (sorted_data[mid - 1] + sorted_data[mid]) / 2 if n % 2 == 0 else sorted_data[mid]\n\n    @staticmethod\n    def mode(data):\n        \"\"\"\n        Calculates the mode of the given list.\n        :param data: List of numbers.\n        :return: List of modes.\n        \"\"\"\n        if not data:\n            return []\n        frequency = Counter(data)\n        max_freq = max(frequency.values())\n        return [value for value, count in frequency.items() if count == max_freq]\n\n    @staticmethod\n    def mean(data):\n        \"\"\"\n        Calculates the mean of the given list.\n        :param data: List of numbers.\n        :return: Mean value as float or None if data is empty.\n        \"\"\"\n        if not data:\n            return None\n        return sum(data) / len(data)\n\n    @staticmethod\n    def standard_deviation(data):\n        \"\"\"\n        Calculates the standard deviation of the given list.\n        :param data: List of numbers.\n        :return: Standard deviation as float or None if data is empty.\n        \"\"\"\n        if not data:\n            return None\n        mean_value = Statistics3.mean(data)\n        variance = sum((x - mean_value) ** 2 for x in data) / len(data)\n        return math.sqrt(variance)\n\n    @staticmethod\n    def z_score(data):\n        \"\"\"\n        Calculates the Z-score of the given list.\n        :param data: List of numbers.\n        :return: List of Z-scores or None if data is empty or has one element.\n        \"\"\"\n        if not data or len(data) == 1:\n            return None\n        mean_value = Statistics3.mean(data)\n        std_dev = Statistics3.standard_deviation(data)\n        return [(x - mean_value) / std_dev for x in data]\n\n    @staticmethod\n    def correlation(x, y):\n        \"\"\"\n        Calculates the correlation coefficient between two lists.\n        :param x: First list of numbers.\n        :param y: Second list of numbers.\n        :return: Correlation coefficient as float or None if lists have different lengths or are empty.\n        \"\"\"\n        if len(x) != len(y) or len(x) == 0:\n            return None\n        mean_x = Statistics3.mean(x)\n        mean_y = Statistics3.mean(y)\n        \n        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))\n        denominator = math.sqrt(sum((xi - mean_x) ** 2 for xi in x) * sum((yi - mean_y) ** 2 for yi in y))\n        \n        return numerator / denominator if denominator != 0 else None\n\n    @staticmethod\n    def correlation_matrix(data):\n        \"\"\"\n        Calculates the correlation matrix for a 2D list.\n        :param data: List of lists of numbers.\n        :return: 2D list representing the correlation matrix.\n        \"\"\"\n        if not data or not data[0]:\n            return [[None] * len(data[0])] * len(data[0])\n        \n        n = len(data[0])\n        corr_matrix = [[None] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                corr_matrix[i][j] = Statistics3.correlation([row[i] for row in data], [row[j] for row in data])\n        return corr_matrix\n```",
    "82": "```python\nclass StockPortfolioTracker:\n    \"\"\"\n    A class to track a stock portfolio, allowing for adding, removing, buying, and selling stocks,\n    as well as calculating the total portfolio value and generating a summary of the portfolio.\n    \"\"\"\n\n    def __init__(self, cash_balance):\n        \"\"\"\n        Initialize the StockPortfolioTracker with a cash balance and an empty portfolio.\n        :param cash_balance: Initial cash balance, float.\n        \"\"\"\n        self.portfolio = []\n        self.cash_balance = cash_balance\n\n    def add_stock(self, stock):\n        \"\"\"\n        Add a stock to the portfolio, or increase the quantity if it already exists.\n        :param stock: A dictionary containing 'name', 'price', and 'quantity'.\n        \"\"\"\n        for item in self.portfolio:\n            if item['name'] == stock['name']:\n                item['quantity'] += stock['quantity']\n                return\n        self.portfolio.append(stock)\n\n    def remove_stock(self, stock):\n        \"\"\"\n        Remove a stock from the portfolio if it matches the name and quantity.\n        :param stock: A dictionary containing 'name', 'price', and 'quantity'.\n        :return: True if the stock was removed, False otherwise.\n        \"\"\"\n        for item in self.portfolio:\n            if item['name'] == stock['name'] and item['quantity'] == stock['quantity']:\n                self.portfolio.remove(item)\n                return True\n        return False\n\n    def buy_stock(self, stock):\n        \"\"\"\n        Buy a stock and add it to the portfolio.\n        :param stock: A dictionary containing 'name', 'price', and 'quantity'.\n        :return: True if the stock was bought successfully, False if insufficient cash.\n        \"\"\"\n        total_cost = stock['price'] * stock['quantity']\n        if total_cost > self.cash_balance:\n            return False\n        self.cash_balance -= total_cost\n        self.add_stock(stock)\n        return True\n\n    def sell_stock(self, stock):\n        \"\"\"\n        Sell a stock from the portfolio and update cash balance.\n        :param stock: A dictionary containing 'name', 'price', and 'quantity'.\n        :return: True if the stock was sold successfully, False if insufficient quantity.\n        \"\"\"\n        for item in self.portfolio:\n            if item['name'] == stock['name']:\n                if item['quantity'] >= stock['quantity']:\n                    total_sale = stock['price'] * stock['quantity']\n                    self.cash_balance += total_sale\n                    item['quantity'] -= stock['quantity']\n                    if item['quantity'] == 0:\n                        self.portfolio.remove(item)\n                    return True\n        return False\n\n    def calculate_portfolio_value(self):\n        \"\"\"\n        Calculate the total value of the portfolio including cash balance.\n        :return: Total portfolio value, float.\n        \"\"\"\n        total_value = self.cash_balance\n        for item in self.portfolio:\n            total_value += item['price'] * item['quantity']\n        return total_value\n\n    def get_portfolio_summary(self):\n        \"\"\"\n        Get a summary of the portfolio including total value and individual stock values.\n        :return: A tuple of total value and a list of stock summary dictionaries.\n        \"\"\"\n        total_value = self.calculate_portfolio_value()\n        summary = [{'name': item['name'], 'value': item['price'] * item['quantity']} for item in self.portfolio]\n        return total_value, summary\n\n    def get_stock_value(self, stock):\n        \"\"\"\n        Calculate the value of a specific stock.\n        :param stock: A dictionary containing 'name', 'price', and 'quantity'.\n        :return: Value of the stock, float.\n        \"\"\"\n        return stock['price'] * stock['quantity']\n```",
    "79": "```python\nclass SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, \n    such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        fields_str = ', '.join(fields) if fields else '*'\n        query = f\"SELECT {fields_str} FROM {self.table_name}\"\n        if condition:\n            query += f\" WHERE {condition}\"\n        return query + \";\"\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form \n                     where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        fields = ', '.join(data.keys())\n        values = ', '.join(f\"'{value}'\" for value in data.values())\n        return f\"INSERT INTO {self.table_name} ({fields}) VALUES ({values});\"\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form \n                     where keys are field names and values are new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        set_clause = ', '.join(f\"{key} = '{value}'\" for key, value in data.items())\n        return f\"UPDATE {self.table_name} SET {set_clause} WHERE {condition};\"\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        return f\"DELETE FROM {self.table_name} WHERE {condition};\"\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        return f\"SELECT * FROM {self.table_name} WHERE age < {age} AND gender = 'female';\"\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        return f\"SELECT * FROM {self.table_name} WHERE age BETWEEN {min_age} AND {max_age};\"\n```",
    "80": "```python\nclass SQLQueryBuilder:\n    \"\"\"\n    This class provides methods to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements.\n    \"\"\"\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in database.\n        :param columns: list of str or str, ['col1', 'col2'] or '*'.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return: str, the SQL query statement.\n        \"\"\"\n        column_string = ', '.join(columns) if isinstance(columns, list) else columns\n        query = f\"SELECT {column_string} FROM {table}\"\n        if where:\n            conditions = ' AND '.join([f\"{key}='{value}'\" for key, value in where.items()])\n            query += f\" WHERE {conditions}\"\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to be inserted in database.\n        :param data: dict, the key and value in SQL insert statement.\n        :return: str, the SQL insert statement.\n        \"\"\"\n        columns = ', '.join(data.keys())\n        values = ', '.join([f\"'{value}'\" for value in data.values()])\n        return f\"INSERT INTO {table} ({columns}) VALUES ({values})\"\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table that will be executed with DELETE operation in database.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return: str, the SQL delete statement.\n        \"\"\"\n        query = f\"DELETE FROM {table}\"\n        if where:\n            conditions = ' AND '.join([f\"{key}='{value}'\" for key, value in where.items()])\n            query += f\" WHERE {conditions}\"\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table that will be executed with UPDATE operation in database.\n        :param data: dict, the key and value in SQL update statement.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return: str, the SQL update statement.\n        \"\"\"\n        set_clause = ', '.join([f\"{key}='{value}'\" for key, value in data.items()])\n        query = f\"UPDATE {table} SET {set_clause}\"\n        if where:\n            conditions = ' AND '.join([f\"{key}='{value}'\" for key, value in where.items()])\n            query += f\" WHERE {conditions}\"\n        return query\n```",
    "84": "```python\nimport json\nimport re\nfrom typing import Union\n\nclass TextFileProcessor:\n    \"\"\"\n    The class handles reading, writing, and processing text files. \n    It can read the file as JSON, read the raw text, write content \n    to the file, and process the file by removing non-alphabetic characters.\n    \"\"\"\n\n    def __init__(self, file_path: str):\n        \"\"\"\n        Initialize the file path.\n        :param file_path: str\n        \"\"\"\n        self.file_path = file_path\n\n    def read_file_as_json(self) -> Union[dict, str, int, float]:\n        \"\"\"\n        Read the self.file_path file as JSON format.\n        If the file content doesn't obey JSON format, an error will be raised.\n        :return: dict if the file is stored as JSON format, or str/int/float if otherwise.\n        \"\"\"\n        with open(self.file_path, 'r') as f:\n            content = f.read()\n            return json.loads(content)\n\n    def read_file(self) -> str:\n        \"\"\"\n        Read and return the content of self.file_path file.\n        :return: str\n        \"\"\"\n        with open(self.file_path, 'r') as f:\n            return f.read()\n\n    def write_file(self, content: str) -> None:\n        \"\"\"\n        Write content into the self.file_path file, overwriting if the file already exists.\n        :param content: str\n        \"\"\"\n        with open(self.file_path, 'w') as f:\n            f.write(content)\n\n    def process_file(self) -> str:\n        \"\"\"\n        Read the self.file_path file and filter out non-alphabetic characters from the content string.\n        Overwrite the processed data into the same self.file_path file.\n        :return: str of processed content\n        \"\"\"\n        content = self.read_file()\n        processed_content = re.sub(r'[^a-zA-Z]', '', content)\n        self.write_file(processed_content)\n        return processed_content\n```",
    "85": "```python\nimport time\n\nclass Thermostat:\n    \"\"\"\n    The class manages temperature control, including setting and retrieving the target temperature, adjusting the mode, and simulating temperature operation.\n    \"\"\"\n\n    VALID_MODES = {'heat', 'cool'}\n\n    def __init__(self, current_temperature: float, target_temperature: float, mode: str):\n        \"\"\"\n        Initialize instances of the Thermostat class.\n        :param current_temperature: float\n        :param target_temperature: float\n        :param mode: str, the work mode\n        \"\"\"\n        self.current_temperature = current_temperature\n        self.target_temperature = target_temperature\n        self.set_mode(mode)\n\n    def get_target_temperature(self) -> float:\n        \"\"\"Return the target temperature.\"\"\"\n        return self.target_temperature\n\n    def set_target_temperature(self, temperature: float) -> None:\n        \"\"\"Set the target temperature.\"\"\"\n        self.target_temperature = temperature\n\n    def get_mode(self) -> str:\n        \"\"\"Return the current work mode.\"\"\"\n        return self.mode\n\n    def set_mode(self, mode: str) -> bool:\n        \"\"\"Set the current work mode if valid.\"\"\"\n        if mode in self.VALID_MODES:\n            self.mode = mode\n            return True\n        return False\n\n    def auto_set_mode(self) -> None:\n        \"\"\"Automatically set the operating mode based on current and target temperatures.\"\"\"\n        self.mode = 'heat' if self.current_temperature < self.target_temperature else 'cool'\n\n    def auto_check_conflict(self) -> bool:\n        \"\"\"\n        Check for conflicts between the operating mode and temperature relationship.\n        Adjust mode if there is a conflict.\n        :return: True if no conflict, False otherwise.\n        \"\"\"\n        conflict = (self.current_temperature < self.target_temperature and self.mode == 'cool') or \\\n                   (self.current_temperature > self.target_temperature and self.mode == 'heat')\n        if conflict:\n            self.auto_set_mode()\n            return False\n        return True\n\n    def simulate_operation(self) -> int:\n        \"\"\"Simulate the operation of the thermostat until the target temperature is reached.\"\"\"\n        self.auto_set_mode()\n        time_taken = 0\n        step = 0.1 if self.mode == 'heat' else -0.1\n\n        while abs(self.current_temperature - self.target_temperature) > 0.1:\n            self.current_temperature += step\n            time.sleep(0.1)  # Simulate time delay for each adjustment\n            time_taken += 1\n\n        return time_taken\n```",
    "88": "```python\nfrom math import pi\n\nclass TriCalculator:\n    \"\"\"\n    The class allows calculating trigonometric values, including cosine, sine, and tangent, using Taylor series approximations.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def cos(self, x):\n        \"\"\"\n        Calculate the cos value of the x-degree angle.\n        :param x: float\n        :return: float\n        \"\"\"\n        return self._taylor_series(x, 50, is_cos=True)\n\n    def factorial(self, n):\n        \"\"\"\n        Calculate the factorial of n.\n        :param n: int\n        :return: int\n        :raises ValueError: If n is negative.\n        \"\"\"\n        if n < 0:\n            raise ValueError(\"Factorial is not defined for negative numbers.\")\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result\n\n    def _taylor_series(self, x, n, is_cos=False):\n        \"\"\"\n        Calculate the n-order Taylor series expansion for cosine or sine.\n        :param x: int\n        :param n: int\n        :param is_cos: bool, True for cosine, False for sine\n        :return: float\n        \"\"\"\n        radians = x * (pi / 180)\n        series_value = 0\n        for i in range(n):\n            if is_cos:\n                term = ((-1) ** i) * (radians ** (2 * i)) / self.factorial(2 * i)\n            else:\n                term = ((-1) ** i) * (radians ** (2 * i + 1)) / self.factorial(2 * i + 1)\n            series_value += term\n        return series_value\n\n    def sin(self, x):\n        \"\"\"\n        Calculate the sin value of the x-degree angle.\n        :param x: float\n        :return: float\n        \"\"\"\n        return self._taylor_series(x, 50, is_cos=False)\n\n    def tan(self, x):\n        \"\"\"\n        Calculate the tan value of the x-degree angle.\n        :param x: float\n        :return: float or bool, False if tangent is undefined\n        \"\"\"\n        if x % 180 == 90:\n            return False  # tan is undefined for 90 + k*180 degrees\n        return self.sin(x) / self.cos(x)\n```",
    "87": "```python\nimport datetime\n\nclass TimeUtils:\n    \"\"\"\n    A utility class for handling various time-related operations, including\n    getting the current date and time, adding seconds, converting between\n    strings and datetime objects, calculating time differences in minutes,\n    and formatting datetime objects.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the TimeUtils instance and store the current datetime.\n        \"\"\"\n        self.current_datetime = datetime.datetime.now()\n\n    def get_current_time(self) -> str:\n        \"\"\"\n        Return the current time formatted as '%H:%M:%S'.\n        :return: Current time as a string\n        \"\"\"\n        return self.current_datetime.strftime(\"%H:%M:%S\")\n\n    def get_current_date(self) -> str:\n        \"\"\"\n        Return the current date formatted as '%Y-%m-%d'.\n        :return: Current date as a string\n        \"\"\"\n        return self.current_datetime.strftime(\"%Y-%m-%d\")\n\n    def add_seconds(self, seconds: int) -> str:\n        \"\"\"\n        Add a specified number of seconds to the current time and return the\n        new time formatted as '%H:%M:%S'.\n        :param seconds: Number of seconds to add\n        :return: New time as a string\n        \"\"\"\n        new_time = self.current_datetime + datetime.timedelta(seconds=seconds)\n        return new_time.strftime(\"%H:%M:%S\")\n\n    def string_to_datetime(self, time_string: str) -> datetime.datetime:\n        \"\"\"\n        Convert a formatted time string to a datetime instance.\n        :param time_string: Time string to convert\n        :return: Corresponding datetime instance\n        \"\"\"\n        return datetime.datetime.strptime(time_string, '%Y-%m-%d %H:%M:%S')\n\n    def datetime_to_string(self, dt: datetime.datetime) -> str:\n        \"\"\"\n        Convert a datetime instance to a formatted string.\n        :param dt: Datetime instance to convert\n        :return: Formatted time string\n        \"\"\"\n        return dt.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    def get_minutes(self, time_string1: str, time_string2: str) -> int:\n        \"\"\"\n        Calculate the number of minutes between two time strings.\n        :param time_string1: First time string\n        :param time_string2: Second time string\n        :return: Number of minutes between the two times\n        \"\"\"\n        dt1 = self.string_to_datetime(time_string1)\n        dt2 = self.string_to_datetime(time_string2)\n        return round((dt2 - dt1).total_seconds() / 60)\n\n    def get_format_time(self, year: int, month: int, day: int, hour: int, minute: int, second: int) -> str:\n        \"\"\"\n        Get a formatted time string from individual date and time components.\n        :param year: Year\n        :param month: Month\n        :param day: Day\n        :param hour: Hour\n        :param minute: Minute\n        :param second: Second\n        :return: Formatted time string\n        \"\"\"\n        return datetime.datetime(year, month, day, hour, minute, second).strftime(\"%Y-%m-%d %H:%M:%S\")\n```\n",
    "86": "```python\nclass TicTacToe:\n    \"\"\"\n    The class represents a game of Tic-Tac-Toe and its functions include making a move on the board, \n    checking for a winner, and determining if the board is full.\n    \"\"\"\n\n    def __init__(self, size=3):\n        \"\"\"\n        Initialize a game board of given size with all empty spaces and set the current player to 'X'.\n        :param size: int, the dimension of the game board (size x size)\n        \"\"\"\n        self.size = size\n        self.board = [[' ' for _ in range(size)] for _ in range(size)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Place the current player's mark at the specified position on the board and switch the mark.\n        :param row: int, the row index of the position\n        :param col: int, the column index of the position\n        :return: bool, indicating whether the move was successful or not\n        \"\"\"\n        if self.is_valid_move(row, col):\n            self.board[row][col] = self.current_player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        return False\n\n    def is_valid_move(self, row, col):\n        \"\"\"\n        Check if the proposed move is valid.\n        :param row: int, the row index of the position\n        :param col: int, the column index of the position\n        :return: bool, indicating whether the move is valid\n        \"\"\"\n        return 0 <= row < self.size and 0 <= col < self.size and self.board[row][col] == ' '\n\n    def check_winner(self):\n        \"\"\"\n        Check if there is a winner on the board in rows, columns, and diagonals.\n        :return: str or None, the mark of the winner ('X' or 'O'), or None if there is no winner yet\n        \"\"\"\n        for i in range(self.size):\n            # Check rows\n            if self.all_equal(self.board[i]):\n                return self.board[i][0]\n            # Check columns\n            if self.all_equal([self.board[j][i] for j in range(self.size)]):\n                return self.board[0][i]\n\n        # Check diagonals\n        if self.all_equal([self.board[i][i] for i in range(self.size)]):\n            return self.board[0][0]\n        if self.all_equal([self.board[i][self.size - 1 - i] for i in range(self.size)]):\n            return self.board[0][self.size - 1]\n\n        return None\n\n    def all_equal(self, lst):\n        \"\"\"\n        Check if all elements in the list are the same and not empty.\n        :param lst: list, the list to check\n        :return: bool, indicating whether all elements are equal and not empty\n        \"\"\"\n        return lst[0] != ' ' and all(x == lst[0] for x in lst)\n\n    def is_board_full(self):\n        \"\"\"\n        Check if the game board is completely filled.\n        :return: bool, indicating whether the game board is full or not\n        \"\"\"\n        return all(cell != ' ' for row in self.board for cell in row)\n```",
    "90": "```python\nfrom urllib.parse import urlparse, parse_qs\n\nclass URLHandler:\n    \"\"\"\n    A class for handling URLs, allowing extraction of scheme, host, path, query parameters, and fragment.\n    \"\"\"\n\n    def __init__(self, url):\n        \"\"\"\n        Initialize the URLHandler with the provided URL.\n        \n        :param url: The URL to be parsed.\n        \"\"\"\n        self.parsed_url = urlparse(url)\n\n    def get_scheme(self):\n        \"\"\"\n        Get the scheme of the URL.\n        \n        :return: str or None - the scheme of the URL.\n        \"\"\"\n        return self.parsed_url.scheme or None\n\n    def get_host(self):\n        \"\"\"\n        Get the host domain name of the URL.\n        \n        :return: str or None - the host domain name of the URL.\n        \"\"\"\n        return self.parsed_url.hostname or None\n\n    def get_path(self):\n        \"\"\"\n        Get the path of the resource in the URL.\n        \n        :return: str or None - the path of the resource of the URL.\n        \"\"\"\n        return self.parsed_url.path or None\n\n    def get_query_params(self):\n        \"\"\"\n        Get the query parameters from the URL.\n        \n        :return: dict or None - the query parameters of the URL.\n        \"\"\"\n        query_params = parse_qs(self.parsed_url.query)\n        return {k: v[0] for k, v in query_params.items()} if query_params else None\n\n    def get_fragment(self):\n        \"\"\"\n        Get the fragment of the URL.\n        \n        :return: str or None - the fragment after '#' of the URL.\n        \"\"\"\n        return self.parsed_url.fragment or None\n```",
    "91": "```python\nimport urllib.parse\n\nclass UrlPath:\n    \"\"\"\n    A utility class for encapsulating and manipulating the path component of a URL, \n    including adding segments, parsing path strings, and building path strings with optional encoding.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the UrlPath object with an empty list of segments and a flag \n        indicating the presence of an end tag.\n        \"\"\"\n        self.segments = []\n        self.with_end_tag = False\n\n    def add(self, segment: str):\n        \"\"\"\n        Adds a segment to the list of segments in the UrlPath.\n        :param segment: str, the segment to add.\n        \"\"\"\n        self.segments.append(segment)\n\n    def parse(self, path: str, charset: str):\n        \"\"\"\n        Parses a given path string and populates the list of segments in the UrlPath.\n        :param path: str, the path string to parse.\n        :param charset: str, the character encoding of the path string.\n        \"\"\"\n        decoded_path = urllib.parse.unquote(path, encoding=charset)\n        stripped_path = self.fix_path(decoded_path)\n        self.segments = stripped_path.split('/')\n        self.with_end_tag = path.endswith('/')\n\n    @staticmethod\n    def fix_path(path: str) -> str:\n        \"\"\"\n        Fixes the given path string by removing leading and trailing slashes.\n        :param path: str, the path string to fix.\n        :return: str, the fixed path string.\n        \"\"\"\n        return path.strip('/')\n\n# Unit tests can be run with a testing framework like unittest.\n```",
    "89": "```python\nimport random\nimport re\nimport unittest\n\nclass TwentyFourPointGame:\n    \"\"\"\n    This is a game of twenty-four points, which generates four numbers\n    and checks whether a player's expression evaluates to 24.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.nums = []\n\n    def _generate_cards(self):\n        \"\"\"\n        Generate four unique random numbers between 1 and 9 for the cards.\n        \"\"\"\n        self.nums = random.sample(range(1, 10), 4)\n\n    def get_my_cards(self):\n        \"\"\"\n        Get a list of four random numbers between 1 and 9 representing the player's cards.\n        :return: list of integers, representing the player's cards\n        \"\"\"\n        self._generate_cards()\n        return self.nums\n\n    def answer(self, expression: str) -> bool:\n        \"\"\"\n        Check if a given mathematical expression using the cards can evaluate to 24.\n        :param expression: string, mathematical expression using the cards\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        \"\"\"\n        if self._is_valid_expression(expression):\n            return self.evaluate_expression(expression)\n        return False\n\n    def evaluate_expression(self, expression: str) -> bool:\n        \"\"\"\n        Evaluate a mathematical expression and check if the result is 24.\n        :param expression: string, mathematical expression\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        \"\"\"\n        try:\n            result = eval(expression)\n            return result == 24\n        except (SyntaxError, NameError, ZeroDivisionError):\n            return False\n\n    def _is_valid_expression(self, expression: str) -> bool:\n        \"\"\"\n        Check if the expression is valid and only contains allowed numbers and operators.\n        :param expression: string, mathematical expression\n        :return: bool, True if the expression is valid, False otherwise\n        \"\"\"\n        allowed_chars = set(\"0123456789+-*/() \")\n        return (all(char in allowed_chars for char in expression) and\n                all(num in map(str, self.nums) for num in re.findall(r'\\d+', expression)))\n\n# Unit tests\nclass TwentyFourPointGameTest(unittest.TestCase):\n    def setUp(self):\n        self.game = TwentyFourPointGame()\n\n    def test_get_my_cards(self):\n        cards = self.game.get_my_cards()\n        self.assertEqual(len(cards), 4)\n        for card in cards:\n            self.assertIn(card, range(1, 10))\n\n    def test_answer_valid_expression(self):\n        self.game.nums = [4, 3, 6, 6]\n        result = self.game.answer('4*3+6+6')\n        self.assertTrue(result)\n\n    def test_answer_invalid_expression(self):\n        result = self.game.answer('1+1+1+1')\n        self.assertFalse(result)\n\n    def test_answer_invalid_syntax(self):\n        result = self.game.answer('1+')\n        self.assertFalse(result)\n\n    def test_answer_invalid_characters(self):\n        result = self.game.answer('abc')\n        self.assertFalse(result)\n\n    def test_answer_exceeding_numbers(self):\n        self.game.nums = [1, 1, 1, 1]\n        result = self.game.answer('1+1+1+2')\n        self.assertFalse(result)\n\n    def test_evaluate_expression(self):\n        result = self.game.evaluate_expression('4*3+6+6')\n        self.assertTrue(result)\n\n    def test_evaluate_expression_invalid(self):\n        result = self.game.evaluate_expression('1+1+1+1')\n        self.assertFalse(result)\n\n    def test_evaluate_expression_invalid_syntax(self):\n        result = self.game.evaluate_expression('1+')\n        self.assertFalse(result)\n\n    def test_evaluate_expression_invalid_characters(self):\n        result = self.game.evaluate_expression('abc')\n        self.assertFalse(result)\n\nif __name__ == \"__main__\":\n    unittest.main()\n```",
    "93": "```python\nimport numpy as np\n\nclass VectorUtil:\n    \"\"\"\n    The class provides vector operations, including calculating similarity,\n    cosine similarities, average similarity, and IDF weights.\n    \"\"\"\n\n    @staticmethod\n    def similarity(vector_1: np.ndarray, vector_2: np.ndarray) -> float:\n        \"\"\"\n        Compute the cosine similarity between two vectors.\n        \n        :param vector_1: numpy.ndarray, expected shape (dim,).\n        :param vector_2: numpy.ndarray, expected shape (dim,).\n        :return: float, cosine similarity between `vector_1` and `vector_2`.\n        \"\"\"\n        dot_product = np.dot(vector_1, vector_2)\n        norm_a = np.linalg.norm(vector_1)\n        norm_b = np.linalg.norm(vector_2)\n        return dot_product / (norm_a * norm_b) if norm_a and norm_b else 0.0\n\n    @staticmethod\n    def cosine_similarities(vector_1: np.ndarray, vectors_all: list) -> np.ndarray:\n        \"\"\"\n        Compute cosine similarities between one vector and a set of other vectors.\n        \n        :param vector_1: numpy.ndarray, expected shape (dim,).\n        :param vectors_all: list of numpy.ndarray, expected shape (num_vectors, dim).\n        :return: numpy.ndarray, cosine similarities between `vector_1` and each vector in `vectors_all`.\n        \"\"\"\n        return np.array([VectorUtil.similarity(vector_1, vector) for vector in vectors_all])\n\n    @staticmethod\n    def n_similarity(vector_list_1: list, vector_list_2: list) -> float:\n        \"\"\"\n        Compute the average cosine similarity between two sets of vectors.\n        \n        :param vector_list_1: list of numpy.ndarray.\n        :param vector_list_2: list of numpy.ndarray.\n        :return: float, average similarity between vectors in `vector_list_1` and `vector_list_2`.\n        \"\"\"\n        if not vector_list_1 or not vector_list_2:\n            return 0.0\n        similarities = [VectorUtil.similarity(v1, v2) for v1 in vector_list_1 for v2 in vector_list_2]\n        return np.mean(similarities) if similarities else 0.0\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num: int, number_dict: dict) -> dict:\n        \"\"\"\n        Calculate IDF weights for each count in number_dict.\n        \n        :param total_num: int, total number of documents.\n        :param number_dict: dict, contains counts for each key.\n        :return: dict, IDF weights for each key in number_dict.\n        \"\"\"\n        return {key: np.log((total_num + 1) / (count + 1)) for key, count in number_dict.items()}\n```",
    "92": "```python\nimport sqlite3\nfrom contextlib import closing\n\nclass UserLoginDB:\n    \"\"\"\n    A database management class for user login verification,\n    providing functions for inserting, searching, deleting users,\n    and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.db_name = db_name\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"Creates the users table if it does not exist.\"\"\"\n        with closing(self._get_connection()) as connection:\n            cursor = connection.cursor()\n            cursor.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    username TEXT PRIMARY KEY,\n                    password TEXT\n                )\n            \"\"\")\n            connection.commit()\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        \"\"\"\n        with closing(self._get_connection()) as connection:\n            cursor = connection.cursor()\n            cursor.execute(\"INSERT INTO users (username, password) VALUES (?, ?)\", (username, password))\n            connection.commit()\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return: list of tuples, the rows from the \"users\" table that match the search criteria.\n        \"\"\"\n        with closing(self._get_connection()) as connection:\n            cursor = connection.cursor()\n            cursor.execute(\"SELECT username, password FROM users WHERE username = ?\", (username,))\n            return cursor.fetchall()\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        \"\"\"\n        with closing(self._get_connection()) as connection:\n            cursor = connection.cursor()\n            cursor.execute(\"DELETE FROM users WHERE username = ?\", (username,))\n            connection.commit()\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Validates the user's login credentials.\n        :param username: str, the username of the user to validate.\n        :param password: str, the password of the user to validate.\n        :return: bool, whether the user can log in correctly.\n        \"\"\"\n        with closing(self._get_connection()) as connection:\n            cursor = connection.cursor()\n            cursor.execute(\"SELECT password FROM users WHERE username = ?\", (username,))\n            result = cursor.fetchone()\n            return result is not None and result[0] == password\n\n    def _get_connection(self):\n        \"\"\"Establishes a new database connection.\"\"\"\n        return sqlite3.connect(self.db_name)\n\n    def close(self):\n        \"\"\"Closes the database connection.\"\"\"\n        # No need for explicit close here as we use context manager.\n        pass\n```",
    "96": "```python\nclass WeatherSystem:\n    \"\"\"\n    A class representing a weather system that provides functionality to query weather information for a specific city \n    and convert temperature units between Celsius and Fahrenheit.\n    \"\"\"\n\n    def __init__(self, city: str) -> None:\n        \"\"\"\n        Initialize the weather system with a city name.\n        \"\"\"\n        self.city = city\n        self.temperature = None\n        self.weather = None\n\n    def query(self, weather_list: dict, tmp_units: str = 'celsius') -> tuple:\n        \"\"\"\n        Query the weather system for the weather and temperature of the city, and convert the temperature units based on the input parameter.\n        \n        :param weather_list: A dictionary of weather information for different cities.\n        :param tmp_units: The temperature units to convert to, default is 'celsius'.\n        :return: A tuple of (temperature, weather) or False if the city is not found.\n        \"\"\"\n        city_weather = weather_list.get(self.city)\n\n        if city_weather is None:\n            return False\n\n        temperature = city_weather['temperature']\n        if city_weather['temperature units'] != tmp_units:\n            temperature = self.convert_temperature(temperature, city_weather['temperature units'], tmp_units)\n\n        return temperature, city_weather['weather']\n\n    def set_city(self, city: str) -> None:\n        \"\"\"\n        Set the city for the weather system.\n        \n        :param city: The city to set.\n        \"\"\"\n        self.city = city\n\n    def convert_temperature(self, temperature: float, from_unit: str, to_unit: str) -> float:\n        \"\"\"\n        Convert temperature between Celsius and Fahrenheit.\n        \n        :param temperature: The temperature to convert.\n        :param from_unit: The current unit of the temperature.\n        :param to_unit: The unit to convert to.\n        :return: The converted temperature.\n        \"\"\"\n        if from_unit == to_unit:\n            return temperature\n        \n        if from_unit == 'celsius':\n            return (temperature * 9 / 5) + 32  # Celsius to Fahrenheit\n        elif from_unit == 'fahrenheit':\n            return (temperature - 32) * 5 / 9  # Fahrenheit to Celsius\n\n        raise ValueError(\"Invalid temperature unit provided\")\n\n# Note: The unittest cases provided in the original code can be used to test this implementation.\n```",
    "94": "```python\nclass VendingMachine:\n    \"\"\"\n    A class to simulate a vending machine, including adding products, \n    inserting coins, purchasing products, viewing balance, replenishing product \n    inventory, and displaying product information.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the vending machine's inventory and balance.\"\"\"\n        self.inventory = {}\n        self.balance = 0.0\n\n    def add_item(self, item_name: str, price: float, quantity: int):\n        \"\"\"\n        Adds a product to the vending machine's inventory.\n        :param item_name: The name of the product to be added.\n        :param price: The price of the product to be added.\n        :param quantity: The quantity of the product to be added.\n        \"\"\"\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be greater than zero.\")\n        if item_name in self.inventory:\n            self.inventory[item_name]['quantity'] += quantity\n        else:\n            self.inventory[item_name] = {'price': price, 'quantity': quantity}\n\n    def insert_coin(self, amount: float) -> float:\n        \"\"\"\n        Inserts coins into the vending machine.\n        :param amount: The amount of coins to be inserted.\n        :return: The balance of the vending machine after the coins are inserted.\n        \"\"\"\n        if amount <= 0:\n            raise ValueError(\"Inserted amount must be greater than zero.\")\n        self.balance += amount\n        return self.balance\n\n    def purchase_item(self, item_name: str):\n        \"\"\"\n        Purchases a product from the vending machine.\n        :param item_name: The name of the product to be purchased.\n        :return: If successful, returns the balance after the purchase, otherwise returns False.\n        \"\"\"\n        if item_name not in self.inventory:\n            return False\n        \n        item = self.inventory[item_name]\n        if item['quantity'] > 0 and self.balance >= item['price']:\n            item['quantity'] -= 1\n            self.balance -= item['price']\n            return self.balance\n        return False\n\n    def restock_item(self, item_name: str, quantity: int) -> bool:\n        \"\"\"\n        Replenishes the inventory of a product already in the vending machine.\n        :param item_name: The name of the product to be replenished.\n        :param quantity: The quantity of the product to be replenished.\n        :return: If the product is already in the vending machine, returns True, otherwise, returns False.\n        \"\"\"\n        if quantity <= 0:\n            raise ValueError(\"Restock quantity must be greater than zero.\")\n        \n        if item_name in self.inventory:\n            self.inventory[item_name]['quantity'] += quantity\n            return True\n        return False\n\n    def display_items(self) -> str:\n        \"\"\"\n        Displays the products in the vending machine.\n        :return: If the vending machine is empty, returns False, otherwise returns a formatted string of products.\n        \"\"\"\n        if not self.inventory:\n            return False\n        return \"\\n\".join(f\"{item} - ${details['price']:.2f} [{details['quantity']}]\" \n                         for item, details in self.inventory.items())\n```",
    "95": "```python\nclass Warehouse:\n    \"\"\"\n    The class manages inventory and orders, including adding products, updating product quantities,\n    retrieving product quantities, creating orders, changing order statuses, and tracking orders.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize inventory and orders as empty dictionaries.\"\"\"\n        self.inventory = {}  # Product ID: Product\n        self.orders = {}  # Order ID: Order\n\n    def add_product(self, product_id: int, name: str, quantity: int) -> None:\n        \"\"\"\n        Add a product to the inventory or increase its quantity if it already exists.\n        :param product_id: int\n        :param name: str, product name\n        :param quantity: int, product quantity\n        \"\"\"\n        if product_id in self.inventory:\n            self.inventory[product_id]['quantity'] += quantity\n        else:\n            self.inventory[product_id] = {'name': name, 'quantity': quantity}\n\n    def update_product_quantity(self, product_id: int, quantity: int) -> None:\n        \"\"\"\n        Update the quantity of a product in inventory.\n        :param product_id: int\n        :param quantity: int, the quantity to add (can be negative)\n        \"\"\"\n        if product_id in self.inventory:\n            self.inventory[product_id]['quantity'] += quantity\n            if self.inventory[product_id]['quantity'] <= 0:\n                del self.inventory[product_id]\n\n    def get_product_quantity(self, product_id: int) -> int or bool:\n        \"\"\"\n        Get the quantity of a specific product by product_id.\n        :param product_id: int\n        :return: the quantity if the product_id is in inventory, otherwise False.\n        \"\"\"\n        return self.inventory.get(product_id, {}).get('quantity', False)\n\n    def create_order(self, order_id: int, product_id: int, quantity: int) -> bool:\n        \"\"\"\n        Create an order for a product if available in sufficient quantity.\n        :param order_id: int\n        :param product_id: int\n        :param quantity: int, the quantity of product selected.\n        :return: False if product_id is not in inventory or quantity is not adequate, otherwise None.\n        \"\"\"\n        if product_id not in self.inventory or self.inventory[product_id]['quantity'] < quantity:\n            return False\n\n        self.orders[order_id] = {\n            'product_id': product_id,\n            'quantity': quantity,\n            'status': 'Shipped'\n        }\n        self.update_product_quantity(product_id, -quantity)\n\n    def change_order_status(self, order_id: int, status: str) -> bool:\n        \"\"\"\n        Change the status of an order if the order_id exists.\n        :param order_id: int\n        :param status: str, the new status to set\n        :return: False if the order_id is not in self.orders, otherwise None.\n        \"\"\"\n        if order_id in self.orders:\n            self.orders[order_id]['status'] = status\n            return True\n        return False\n\n    def track_order(self, order_id: int) -> str or bool:\n        \"\"\"\n        Get the status of a specific order.\n        :param order_id: int\n        :return: the status if order_id is in self.orders, otherwise False.\n        \"\"\"\n        return self.orders.get(order_id, {}).get('status', False)\n```",
    "97": "```python\nclass Words2Numbers:\n    \"\"\"\n    The class provides a text-to-number conversion utility, allowing conversion of written numbers (in words) to their numerical representation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the word lists and dictionaries required for conversion.\n        \"\"\"\n        self.numwords = {}\n        self.units = [\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\n            \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n            \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\",\n        ]\n        self.tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        self.scales = [\"hundred\", \"thousand\", \"million\", \"billion\", \"trillion\"]\n\n        self.numwords[\"and\"] = (1, 0)\n        self._initialize_numwords()\n        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}\n        self.ordinal_endings = [('ieth', 'y'), ('th', '')]\n\n    def _initialize_numwords(self):\n        for idx, word in enumerate(self.units):\n            self.numwords[word] = (1, idx)\n        for idx, word in enumerate(self.tens):\n            self.numwords[word] = (1, idx * 10)\n        for idx, word in enumerate(self.scales):\n            self.numwords[word] = (10 ** (idx * 3), 0)\n\n    def text2int(self, textnum):\n        \"\"\"\n        Convert the word string to the corresponding integer string.\n        :param textnum: string, the word string to be converted.\n        :return: string, the final converted integer string.\n        \"\"\"\n        if not self.is_valid_input(textnum):\n            return \"\"\n\n        textnum = textnum.replace(\"-\", \" \")  # Handle hyphenated words\n        current = result = 0\n\n        for word in textnum.split():\n            if word in self.numwords:\n                scale, increment = self.numwords[word]\n                current += increment\n\n                if scale > 1:\n                    current *= scale\n                    result += current\n                    current = 0\n            else:\n                raise ValueError(f\"Invalid word found: {word}\")\n\n        return str(result + current)\n\n    def is_valid_input(self, textnum):\n        \"\"\"\n        Check if the input text contains only valid words that can be converted into numbers.\n        :param textnum: The input text containing words representing numbers.\n        :return: True if input is valid, False otherwise.\n        \"\"\"\n        valid_words = set(self.numwords.keys())\n        for word in textnum.replace(\"-\", \" \").split():\n            if word not in valid_words:\n                return False\n        return True\n```",
    "98": "```python\nimport xml.etree.ElementTree as ET\nimport os\n\n\nclass XMLProcessor:\n    \"\"\"\n    A class to handle XML files, including reading, writing, processing, and finding elements in an XML file.\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize the XMLProcessor object with the given file name.\n        :param file_name: str, the name of the XML file to be processed.\n        \"\"\"\n        self.file_name = file_name\n        self.root = None\n\n    def read_xml(self):\n        \"\"\"\n        Reads the XML file and returns the root element.\n        :return: Element, the root element of the XML file or None if the file name is empty.\n        \"\"\"\n        if not self.file_name:\n            return None\n        \n        try:\n            tree = ET.parse(self.file_name)\n            self.root = tree.getroot()\n            return self.root\n        except (ET.ParseError, FileNotFoundError):\n            return None\n\n    def write_xml(self, file_name):\n        \"\"\"\n        Writes the XML data to the specified file.\n        :param file_name: str, the name of the file to write the XML data.\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n        if not file_name or self.root is None:\n            return False\n        \n        try:\n            tree = ET.ElementTree(self.root)\n            tree.write(file_name)\n            return True\n        except Exception:\n            return False\n\n    def process_xml_data(self, file_name):\n        \"\"\"\n        Modifies the data in XML elements and writes the updated XML data to a new file.\n        :param file_name: str, the name of the file to write the modified XML data.\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n        if not file_name or self.root is None:\n            return False\n        \n        for item in self.root.findall('item'):\n            item.text = item.text.upper()\n\n        return self.write_xml(file_name)\n\n    def find_element(self, element_name):\n        \"\"\"\n        Finds the XML elements with the specified name.\n        :param element_name: str, the name of the elements to find.\n        :return: list, a list of found elements with the specified name or an empty list if root is None.\n        \"\"\"\n        if self.root is None:\n            return []\n        \n        return self.root.findall(element_name)\n```",
    "99": "```python\nimport zipfile\nimport os\n\n\nclass ZipFileProcessor:\n    \"\"\"\n    A class to process ZIP files, providing functionalities for reading,\n    extracting, and creating ZIP files.\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize with the path to the ZIP file.\n        :param file_name: str - The ZIP file path.\n        \"\"\"\n        self.file_name = file_name\n\n    def _validate_zip_file(self):\n        \"\"\"Check if the ZIP file exists and is valid.\"\"\"\n        return os.path.exists(self.file_name) and zipfile.is_zipfile(self.file_name)\n\n    def read_zip_file(self):\n        \"\"\"\n        Open the ZIP file and return the file object.\n        :return: zipfile.ZipFile or None if the file is invalid.\n        \"\"\"\n        if not self._validate_zip_file():\n            return None\n        try:\n            return zipfile.ZipFile(self.file_name, 'r')\n        except zipfile.BadZipFile:\n            return None\n\n    def extract_all(self, output_path):\n        \"\"\"\n        Extract all files from the ZIP file to the specified output path.\n        :param output_path: str - The directory where files will be extracted.\n        :return: bool - True if extraction is successful, False otherwise.\n        \"\"\"\n        if not self._validate_zip_file() or not output_path:\n            return False\n        os.makedirs(output_path, exist_ok=True)\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_ref:\n                zip_ref.extractall(output_path)\n            return True\n        except Exception:\n            return False\n\n    def extract_file(self, file_name, output_path):\n        \"\"\"\n        Extract a specific file from the ZIP file to the specified output path.\n        :param file_name: str - The name of the file to extract.\n        :param output_path: str - The directory where the file will be extracted.\n        :return: bool - True if extraction is successful, False otherwise.\n        \"\"\"\n        if not self._validate_zip_file() or not file_name or not output_path:\n            return False\n        os.makedirs(output_path, exist_ok=True)\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_ref:\n                zip_ref.extract(file_name, output_path)\n            return True\n        except (KeyError, zipfile.BadZipFile):\n            return False\n\n    def create_zip_file(self, files, output_file_name):\n        \"\"\"\n        Create a ZIP file from a list of files.\n        :param files: list of str - The files to compress.\n        :param output_file_name: str - The name of the output ZIP file.\n        :return: bool - True if creation is successful, False otherwise.\n        \"\"\"\n        if not files or not output_file_name:\n            return False\n        try:\n            with zipfile.ZipFile(output_file_name, 'w') as zip_ref:\n                for file in files:\n                    zip_ref.write(file, os.path.basename(file))\n            return True\n        except Exception:\n            return False\n```"
}