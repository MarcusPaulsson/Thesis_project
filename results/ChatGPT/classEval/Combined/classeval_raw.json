{
    "9": "```python\nclass BigNumCalculator:\n    \"\"\"\n    A class that implements big number calculations, including addition, subtraction, and multiplication.\n    \"\"\"\n\n    @staticmethod\n    def add(num1: str, num2: str) -> str:\n        \"\"\"\n        Adds two big numbers represented as strings.\n        \n        :param num1: The first number to add, str.\n        :param num2: The second number to add, str.\n        :return: The sum of the two numbers, str.\n        \"\"\"\n        return str(int(num1) + int(num2))\n\n    @staticmethod\n    def subtract(num1: str, num2: str) -> str:\n        \"\"\"\n        Subtracts two big numbers represented as strings.\n        \n        :param num1: The first number to subtract, str.\n        :param num2: The second number to subtract, str.\n        :return: The difference of the two numbers, str.\n        \"\"\"\n        return str(int(num1) - int(num2))\n\n    @staticmethod\n    def multiply(num1: str, num2: str) -> str:\n        \"\"\"\n        Multiplies two big numbers represented as strings.\n        \n        :param num1: The first number to multiply, str.\n        :param num2: The second number to multiply, str.\n        :return: The product of the two numbers, str.\n        \"\"\"\n        return str(int(num1) * int(num2))\n```",
    "6": "```python\nclass AvgPartition:\n    \"\"\"\n    This class partitions a given list into blocks of approximately equal size based on the specified number of partitions.\n    \"\"\"\n\n    def __init__(self, lst, limit):\n        \"\"\"\n        Initialize the class with the given list and the number of partitions.\n        \n        :param lst: List to be partitioned.\n        :param limit: Number of partitions (must be greater than 0).\n        \"\"\"\n        if limit <= 0:\n            raise ValueError(\"Number of partitions must be greater than 0.\")\n        self.lst = lst\n        self.limit = limit\n\n    def _calculate_block_size(self):\n        \"\"\"\n        Calculate the size of each block and the remainder of the division.\n        \n        :return: Tuple containing the size of each block and the remainder.\n        \"\"\"\n        block_size = len(self.lst) // self.limit\n        remainder = len(self.lst) % self.limit\n        return block_size, remainder\n\n    def get(self, index):\n        \"\"\"\n        Retrieve the block corresponding to the specified partition index.\n        \n        :param index: The index of the partition (0-based).\n        :return: The corresponding block as a list.\n        \"\"\"\n        if index < 0 or index >= self.limit:\n            raise IndexError(\"Partition index out of range.\")\n        \n        block_size, remainder = self._calculate_block_size()\n        start = index * block_size + min(index, remainder)\n        end = start + block_size + (1 if index < remainder else 0)\n        return self.lst[start:end]\n```",
    "7": "```python\nclass BalancedBrackets:\n    \"\"\"\n    A class to check for balanced brackets in an expression.\n    \"\"\"\n\n    def __init__(self, expr):\n        \"\"\"\n        Initializes the class with an expression.\n        \n        :param expr: The expression to check for balanced brackets, str.\n        \"\"\"\n        self.expr = expr\n        self.left_brackets = {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n        self.right_brackets = {\")\", \"}\", \"]\"}\n        self.stack = []\n\n    def clear_expr(self):\n        \"\"\"\n        Clears the expression of all characters that are not brackets.\n        \"\"\"\n        self.expr = ''.join(char for char in self.expr if char in self.left_brackets or char in self.right_brackets)\n\n    def check_balanced_brackets(self):\n        \"\"\"\n        Checks if the expression has balanced brackets.\n        \n        :return: True if the expression has balanced brackets, False otherwise.\n        \"\"\"\n        self.clear_expr()  # Ensure we are checking only brackets\n        self.stack.clear()  # Clear the stack for a fresh check\n\n        for char in self.expr:\n            if char in self.left_brackets:\n                self.stack.append(char)\n            elif char in self.right_brackets:\n                if not self.stack or self.left_brackets[self.stack.pop()] != char:\n                    return False\n        return not self.stack\n```",
    "5": "```python\nclass AutomaticGuitarSimulator:\n    def __init__(self, text: str) -> None:\n        \"\"\"\n        Initialize the score to be played.\n        \n        :param text: str, score to be played\n        \"\"\"\n        self.play_text = text.strip()\n\n    def interpret(self, display: bool = False) -> list:\n        \"\"\"\n        Interpret the music score to be played.\n        \n        :param display: bool, representing whether to print the interpreted score\n        :return: list of dict, each dict includes 'Chord' and 'Tune'.\n        If the input is empty or contains only whitespace, an empty list is returned.\n        \"\"\"\n        if not self.play_text:\n            return []\n\n        chords = self.play_text.split()\n        play_list = []\n\n        for chord in chords:\n            if chord:  # Ensure the chord is not empty\n                chord_name = ''.join(filter(str.isalpha, chord))\n                tune = ''.join(filter(str.isdigit, chord))\n                play_list.append({'Chord': chord_name, 'Tune': tune})\n\n                if display:\n                    print(self.display(chord_name, tune))\n\n        return play_list\n\n    def display(self, chord: str, tune: str) -> str:\n        \"\"\"\n        Format and return the chord and play tune.\n        \n        :param chord: str, chord name\n        :param tune: str, play tune\n        :return: str formatted message\n        \"\"\"\n        return f\"Normal Guitar Playing -- Chord: {chord}, Play Tune: {tune}\"\n```",
    "1": "```python\nimport math\n\nclass AreaCalculator:\n    \"\"\"\n    A class for calculating the area of different shapes, including circle, sphere, cylinder, sector, and annulus.\n    \"\"\"\n\n    def __init__(self, radius):\n        \"\"\"\n        Initialize the radius for shapes.\n        :param radius: float\n        \"\"\"\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        \"\"\"\n        Calculate the area of a circle based on self.radius.\n        :return: area of circle, float\n        \"\"\"\n        return math.pi * self.radius ** 2\n\n    def calculate_sphere_area(self):\n        \"\"\"\n        Calculate the surface area of a sphere based on self.radius.\n        :return: area of sphere, float\n        \"\"\"\n        return 4 * math.pi * self.radius ** 2\n\n    def calculate_cylinder_area(self, height):\n        \"\"\"\n        Calculate the surface area of a cylinder based on self.radius and height.\n        :param height: height of cylinder, float\n        :return: area of cylinder, float\n        \"\"\"\n        base_area = self.calculate_circle_area()\n        lateral_area = 2 * math.pi * self.radius * height\n        return 2 * base_area + lateral_area\n\n    def calculate_sector_area(self, angle):\n        \"\"\"\n        Calculate the area of a sector based on self.radius and angle.\n        :param angle: angle of sector in radians, float\n        :return: area of sector, float\n        \"\"\"\n        return 0.5 * self.radius ** 2 * angle\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        \"\"\"\n        Calculate the area of an annulus based on inner_radius and outer_radius.\n        :param inner_radius: inner radius of annulus, float\n        :param outer_radius: outer radius of annulus, float\n        :return: area of annulus, float\n        \"\"\"\n        outer_area = AreaCalculator(outer_radius).calculate_circle_area()\n        inner_area = AreaCalculator(inner_radius).calculate_circle_area()\n        return outer_area - inner_area\n```",
    "8": "```python\nclass BankAccount:\n    \"\"\"\n    A class representing a bank account system, which supports depositing money, withdrawing money, viewing balance, and transferring money.\n    \"\"\"\n\n    def __init__(self, balance=0):\n        \"\"\"\n        Initializes a bank account object with an attribute balance. Default value is 0.\n        :param balance: Initial balance of the account.\n        \"\"\"\n        self.balance = balance\n\n    def deposit(self, amount):\n        \"\"\"\n        Deposits a certain amount into the account, increasing the account balance.\n        :param amount: Amount to deposit (must be non-negative).\n        :return: Current account balance after deposit.\n        :raises ValueError: If amount is negative.\n        \"\"\"\n        self._validate_amount(amount)\n        self.balance += amount\n        return self.balance\n\n    def withdraw(self, amount):\n        \"\"\"\n        Withdraws a certain amount from the account, decreasing the account balance.\n        :param amount: Amount to withdraw (must be non-negative and not greater than balance).\n        :return: Current account balance after withdrawal.\n        :raises ValueError: If amount is negative or exceeds the current balance.\n        \"\"\"\n        self._validate_amount(amount)\n        if amount > self.balance:\n            raise ValueError(\"Insufficient balance.\")\n        self.balance -= amount\n        return self.balance\n\n    def view_balance(self):\n        \"\"\"\n        Returns the current account balance.\n        :return: Current account balance.\n        \"\"\"\n        return self.balance\n\n    def transfer(self, other_account, amount):\n        \"\"\"\n        Transfers a certain amount from the current account to another account.\n        :param other_account: BankAccount instance to transfer money to.\n        :param amount: Amount to transfer (must be non-negative and not greater than balance).\n        :raises ValueError: If amount is negative or exceeds the current balance.\n        \"\"\"\n        self.withdraw(amount)\n        other_account.deposit(amount)\n\n    def _validate_amount(self, amount):\n        \"\"\"\n        Validates the amount for deposit and withdrawal.\n        :param amount: Amount to validate.\n        :raises ValueError: If amount is negative.\n        \"\"\"\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n```",
    "3": "```python\nimport itertools\nimport math\n\nclass ArrangementCalculator:\n    \"\"\"\n    The ArrangementCalculator class provides permutation calculations and selection operations for a given set of data elements.\n    \"\"\"\n\n    def __init__(self, datas):\n        \"\"\"\n        Initializes the ArrangementCalculator object with a list of data elements.\n        :param datas: List, the data elements to be used for arrangements.\n        \"\"\"\n        self.datas = datas\n\n    @staticmethod\n    def count(n, m=None):\n        \"\"\"\n        Counts the number of arrangements by choosing m items from n items (permutations).\n        If m is not provided or n equals m, returns factorial(n).\n        :param n: int, the total number of items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: int, the count of arrangements.\n        \"\"\"\n        if m is None or n == m:\n            return ArrangementCalculator.factorial(n)\n        return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n):\n        \"\"\"\n        Counts the total number of all possible arrangements by choosing at least 1 item and at most n items from n items.\n        :param n: int, the total number of items.\n        :return: int, the count of all arrangements.\n        \"\"\"\n        return sum(ArrangementCalculator.count(n, m) for m in range(1, n + 1))\n\n    def select(self, m=None):\n        \"\"\"\n        Generates a list of arrangements by selecting m items from the internal data.\n        If m is not provided, selects all items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: List, a list of arrangements.\n        \"\"\"\n        m = m if m is not None else len(self.datas)\n        return [list(p) for p in itertools.permutations(self.datas, m)]\n\n    def select_all(self):\n        \"\"\"\n        Generates a list of all arrangements by selecting at least 1 item and at most the number of internal data.\n        :return: List, a list of all arrangements.\n        \"\"\"\n        return [arrangement for m in range(1, len(self.datas) + 1) for arrangement in self.select(m)]\n\n    @staticmethod\n    def factorial(n):\n        \"\"\"\n        Calculates the factorial of a given number.\n        :param n: int, the number to calculate the factorial.\n        :return: int, the factorial of the given number.\n        \"\"\"\n        return math.factorial(n)\n```",
    "0": "```python\nimport logging\nimport datetime\n\nclass AccessGatewayFilter:\n    \"\"\"\n    This class is a filter used for accessing gateway filtering, primarily for authentication and access log recording.\n    \"\"\"\n\n    def __init__(self):\n        self.allowed_methods = {'GET', 'POST'}\n        self.valid_prefixes = ['/api', '/login']\n\n    def filter(self, request):\n        \"\"\"\n        Filter the incoming request based on certain rules and conditions.\n        :param request: dict, the incoming request details\n        :return: bool or None, True if the request is allowed, False if denied, None if user level is insufficient\n        \"\"\"\n        if not self._is_start_with(request['path']):\n            return False\n\n        if request['method'] not in self.allowed_methods:\n            return False\n\n        user = self._get_jwt_user(request)\n        if user is None:\n            return False\n\n        if user.get('level', 0) < 3:\n            return None\n\n        self._set_current_user_info_and_log(user)\n        return True\n\n    def _is_start_with(self, request_uri):\n        \"\"\"\n        Check if the request URI starts with certain prefixes.\n        :param request_uri: str, the URI of the request\n        :return: bool, True if the URI starts with certain prefixes, False otherwise\n        \"\"\"\n        return any(request_uri.startswith(prefix) for prefix in self.valid_prefixes)\n\n    def _get_jwt_user(self, request):\n        \"\"\"\n        Get the user information from the JWT token in the request.\n        :param request: dict, the incoming request details\n        :return: dict or None, the user information if the token is valid, None otherwise\n        \"\"\"\n        auth_header = request.get('headers', {}).get('Authorization', {})\n        user_info = auth_header.get('user')\n        jwt_token = auth_header.get('jwt')\n\n        if user_info and self._is_jwt_valid(jwt_token, user_info['name']):\n            return user_info\n        return None\n\n    def _is_jwt_valid(self, jwt_token, username):\n        \"\"\"\n        Validate the JWT token.\n        :param jwt_token: str, the JWT token\n        :param username: str, the username to validate against\n        :return: bool, True if the JWT is valid, False otherwise\n        \"\"\"\n        expected_token = f\"{username}{datetime.date.today()}\"\n        return jwt_token == expected_token\n\n    def _set_current_user_info_and_log(self, user):\n        \"\"\"\n        Set the current user information and log the access.\n        :param user: dict, the user information\n        :return: None\n        \"\"\"\n        logging.info(f\"User accessed: {user['name']} from {user.get('address', 'unknown')}\")\n```",
    "4": "```python\nclass AssessmentSystem:\n    \"\"\"\n    A student assessment system that supports adding students, adding course scores, \n    calculating GPA, and other functions for students and courses.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the students dictionary in the assessment system.\"\"\"\n        self.students = {}\n\n    def add_student(self, name: str, grade: int, major: str) -> None:\n        \"\"\"\n        Add a new student to the students dictionary.\n        \n        :param name: str, student name\n        :param grade: int, student grade\n        :param major: str, student major\n        \"\"\"\n        self.students[name] = {\n            'name': name,\n            'grade': grade,\n            'major': major,\n            'courses': {}\n        }\n\n    def add_course_score(self, name: str, course: str, score: int) -> None:\n        \"\"\"\n        Add a score for a specific course for a student.\n        \n        :param name: str, student name\n        :param course: str, course name\n        :param score: int, course score\n        \"\"\"\n        if name in self.students:\n            self.students[name]['courses'][course] = score\n\n    def get_gpa(self, name: str) -> float:\n        \"\"\"\n        Calculate the average grade (GPA) of a student.\n        \n        :param name: str, student name\n        :return: float or None\n        \"\"\"\n        if name in self.students:\n            courses = self.students[name]['courses']\n            if courses:\n                return sum(courses.values()) / len(courses)\n        return None\n\n    def get_all_students_with_fail_course(self) -> list:\n        \"\"\"\n        Get all students who have any score below 60.\n        \n        :return: list of str, student names\n        \"\"\"\n        return [name for name, data in self.students.items() if any(score < 60 for score in data['courses'].values())]\n\n    def get_course_average(self, course: str) -> float:\n        \"\"\"\n        Get the average score of a specific course.\n        \n        :param course: str, course name\n        :return: float or None\n        \"\"\"\n        total_score = 0\n        count = 0\n        for student in self.students.values():\n            score = student['courses'].get(course)\n            if score is not None:\n                total_score += score\n                count += 1\n        return total_score / count if count > 0 else None\n\n    def get_top_student(self) -> str:\n        \"\"\"\n        Find the student with the highest GPA.\n        \n        :return: str, name of the student with the highest GPA\n        \"\"\"\n        top_student = None\n        highest_gpa = -1\n        for name in self.students:\n            gpa = self.get_gpa(name)\n            if gpa is not None and gpa > highest_gpa:\n                highest_gpa = gpa\n                top_student = name\n        return top_student\n```",
    "2": "```python\nclass ArgumentParser:\n    \"\"\"\n    A class for parsing command line arguments into a dictionary.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the fields:\n        - self.arguments: a dict that stores the parsed command line arguments.\n        - self.required: a set that stores the names of required arguments.\n        - self.types: a dict that stores the expected types for each argument.\n        \"\"\"\n        self.arguments = {}\n        self.required = set()\n        self.types = {}\n\n    def parse_arguments(self, command_string):\n        \"\"\"\n        Parses the given command line argument string and stores the parsed results in the arguments dictionary.\n        Checks for missing required arguments and returns a tuple indicating success and any missing arguments.\n        \n        :param command_string: str, command line argument string formatted like \"python script.py --arg1=value1 -arg2 value2 --option1 -option2\"\n        :return: tuple (bool, set or None) indicating success and missing arguments if any.\n        \"\"\"\n        args = command_string.split()[1:]  # Skip the script name\n        missing_args = set()\n\n        for arg in args:\n            key, value = self._parse_arg(arg)\n            self.arguments[key] = self._convert_type(key, value)\n\n        for req in self.required:\n            if req not in self.arguments:\n                missing_args.add(req)\n\n        return (not missing_args, missing_args if missing_args else None)\n\n    def get_argument(self, key):\n        \"\"\"\n        Retrieves the value of the specified argument from the arguments dictionary.\n        \n        :param key: str, argument name\n        :return: The value of the argument, or None if the argument does not exist.\n        \"\"\"\n        return self.arguments.get(key)\n\n    def add_argument(self, arg, required=False, arg_type=str):\n        \"\"\"\n        Adds an argument to the parser, specifying if it is required and its expected type.\n        \n        :param arg: str, argument name\n        :param required: bool, whether the argument is required, default is False\n        :param arg_type: type, expected type of the argument, default is str\n        \"\"\"\n        self.types[arg] = arg_type\n        if required:\n            self.required.add(arg)\n\n    def _convert_type(self, arg, value):\n        \"\"\"\n        Converts the input value to the expected type based on the argument's type.\n        \n        :param arg: str, the argument name\n        :param value: str, the input value from the command line\n        :return: converted value if successful, or the original value otherwise\n        \"\"\"\n        if arg in self.types:\n            try:\n                return self.types[arg](value)\n            except ValueError:\n                pass\n        return value\n\n    def _parse_arg(self, arg):\n        \"\"\"\n        Parses a single argument string into a key and value.\n        \n        :param arg: str, the argument string\n        :return: tuple (str, str) containing the key and value\n        \"\"\"\n        if '=' in arg:\n            key, value = arg.split('=', 1)\n        else:\n            key = arg\n            value = True  # Treat flags as True\n\n        key = key.lstrip('-')  # Remove leading dashes\n        return key, value\n```",
    "11": "```python\nclass BitStatusUtil:\n    \"\"\"\n    A utility class for manipulating and checking status using bitwise operations.\n    \"\"\"\n\n    @staticmethod\n    def add(states: int, stat: int) -> int:\n        \"\"\"\n        Add a status to the current status after validating the parameters.\n        \n        :param states: Current status, int.\n        :param stat: Status to be added, int.\n        :return: The status after adding the status, int.\n        \"\"\"\n        BitStatusUtil._validate_parameters(states, stat)\n        return states | stat\n\n    @staticmethod\n    def has(states: int, stat: int) -> bool:\n        \"\"\"\n        Check if the current status contains the specified status after validating the parameters.\n        \n        :param states: Current status, int.\n        :param stat: Specified status, int.\n        :return: True if the current status contains the specified status, otherwise False.\n        \"\"\"\n        BitStatusUtil._validate_parameters(states, stat)\n        return (states & stat) == stat\n\n    @staticmethod\n    def remove(states: int, stat: int) -> int:\n        \"\"\"\n        Remove the specified status from the current status after validating the parameters.\n        \n        :param states: Current status, int.\n        :param stat: Specified status, int.\n        :return: The status after removing the specified status, int.\n        \"\"\"\n        BitStatusUtil._validate_parameters(states, stat)\n        return states & ~stat\n\n    @staticmethod\n    def _validate_parameters(*args: int) -> None:\n        \"\"\"\n        Validate that all parameters are non-negative and even.\n        \n        :param args: Parameters to be checked.\n        :raises ValueError: If any parameter is negative or odd.\n        \"\"\"\n        for arg in args:\n            if arg < 0:\n                raise ValueError(f\"{arg} must be non-negative\")\n            if arg % 2 != 0:\n                raise ValueError(f\"{arg} is not even\")\n```",
    "13": "```python\nclass BookManagement:\n    \"\"\"\n    A class to manage a book inventory system, supporting adding and removing books,\n    viewing the inventory, and checking the quantity of specific books.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the inventory of the Book Manager.\n        \"\"\"\n        self.inventory = {}\n\n    def add_book(self, title: str, quantity: int = 1) -> None:\n        \"\"\"\n        Add one or several books to the inventory.\n        \n        :param title: str, the book title\n        :param quantity: int, the number of books to add (default is 1)\n        :raises ValueError: if quantity is less than 1\n        \"\"\"\n        if quantity < 1:\n            raise ValueError(\"Quantity must be at least 1.\")\n        \n        self.inventory[title] = self.inventory.get(title, 0) + quantity\n\n    def remove_book(self, title: str, quantity: int) -> None:\n        \"\"\"\n        Remove one or several books from the inventory.\n        \n        :param title: str, the book title\n        :param quantity: int, the number of books to remove\n        :raises ValueError: if the book is not found or if the quantity is invalid\n        \"\"\"\n        if title not in self.inventory:\n            raise ValueError(\"Book not found in inventory.\")\n        \n        if quantity < 1 or quantity > self.inventory[title]:\n            raise ValueError(\"Invalid quantity for removal.\")\n        \n        self.inventory[title] -= quantity\n        \n        if self.inventory[title] == 0:\n            del self.inventory[title]\n\n    def view_inventory(self) -> dict:\n        \"\"\"\n        Get the current inventory of the Book Management.\n        \n        :return: dict, {title(str): quantity(int), ...}\n        \"\"\"\n        return self.inventory\n\n    def view_book_quantity(self, title: str) -> int:\n        \"\"\"\n        Get the quantity of a specific book.\n        \n        :param title: str, the title of the book\n        :return: int, the quantity of the book; returns 0 if the title does not exist\n        \"\"\"\n        return self.inventory.get(title, 0)\n```",
    "10": "```python\nclass BinaryDataProcessor:\n    \"\"\"\n    A class to process binary data, including functions to clean non-binary characters,\n    calculate binary string information, and convert to ASCII and UTF-8 strings.\n    \"\"\"\n\n    def __init__(self, binary_string):\n        \"\"\"\n        Initialize the class with a binary string and clean it by removing all non-binary characters.\n        \"\"\"\n        self.binary_string = self.clean_non_binary_chars(binary_string)\n\n    @staticmethod\n    def clean_non_binary_chars(binary_string):\n        \"\"\"\n        Clean the binary string by removing all non-binary characters (anything other than '0' or '1').\n        \n        :param binary_string: The input binary string to clean.\n        :return: A cleaned binary string containing only '0' and '1'.\n        \"\"\"\n        return ''.join(filter(lambda x: x in '01', binary_string))\n\n    def calculate_binary_info(self):\n        \"\"\"\n        Calculate the binary string information, including the percentage of 0s and 1s,\n        and the total length of the binary string.\n        \n        :return: A dictionary containing the percentage of zeroes, ones, and the bit length.\n        \"\"\"\n        total_length = len(self.binary_string)\n        if total_length == 0:\n            return {'Zeroes': 0, 'Ones': 0, 'Bit length': 0}\n\n        count_ones = self.binary_string.count('1')\n        count_zeroes = total_length - count_ones\n\n        return {\n            'Zeroes': count_zeroes / total_length,\n            'Ones': count_ones / total_length,\n            'Bit length': total_length\n        }\n\n    def convert_to_ascii(self):\n        \"\"\"\n        Convert the binary string to an ASCII string.\n        \n        :return: The corresponding ASCII string.\n        \"\"\"\n        return ''.join(chr(int(self.binary_string[i:i + 8], 2)) for i in range(0, len(self.binary_string), 8))\n\n    def convert_to_utf8(self):\n        \"\"\"\n        Convert the binary string to a UTF-8 string.\n        \n        :return: The corresponding UTF-8 string.\n        \"\"\"\n        return self.convert_to_ascii()  # UTF-8 is compatible with ASCII for the basic character set\n```",
    "19": "```python\nclass ChandrasekharSieve:\n    \"\"\"\n    This class implements the Chandrasekhar's Sieve method to find all prime numbers up to a specified limit.\n    \"\"\"\n\n    def __init__(self, n):\n        \"\"\"\n        Initialize the ChandrasekharSieve class with the given limit.\n        \n        :param n: int, the upper limit for generating prime numbers\n        \"\"\"\n        self.n = n\n        self.primes = self._generate_primes()\n\n    def _generate_primes(self):\n        \"\"\"\n        Generate prime numbers up to the specified limit using the Sieve of Eratosthenes algorithm.\n        \n        :return: list, a list of prime numbers\n        \"\"\"\n        if self.n < 2:\n            return []\n\n        sieve = [True] * (self.n + 1)\n        sieve[0] = sieve[1] = False  # 0 and 1 are not prime numbers\n\n        for start in range(2, int(self.n**0.5) + 1):\n            if sieve[start]:\n                for multiple in range(start * start, self.n + 1, start):\n                    sieve[multiple] = False\n\n        return [num for num, is_prime in enumerate(sieve) if is_prime]\n\n    def get_primes(self):\n        \"\"\"\n        Retrieve the list of generated prime numbers.\n        \n        :return: list, a list of prime numbers\n        \"\"\"\n        return self.primes\n```",
    "15": "```python\nclass BoyerMooreSearch:\n    \"\"\"\n    This class implements the Boyer-Moore algorithm for string searching,\n    which is used to find occurrences of a pattern within a given text.\n    \"\"\"\n\n    def __init__(self, text: str, pattern: str):\n        \"\"\"\n        Initializes the BoyerMooreSearch class with the given text and pattern.\n        :param text: The text to be searched.\n        :param pattern: The pattern to be searched for.\n        \"\"\"\n        self.text = text\n        self.pattern = pattern\n        self.text_len = len(text)\n        self.pattern_len = len(pattern)\n\n    def match_in_pattern(self, char: str) -> int:\n        \"\"\"\n        Finds the rightmost occurrence of a character in the pattern.\n        :param char: The character to be searched for.\n        :return: The index of the rightmost occurrence of the character in the pattern, or -1 if not found.\n        \"\"\"\n        return self.pattern.rfind(char)\n\n    def mismatch_in_text(self, current_pos: int) -> int:\n        \"\"\"\n        Determines the position of the first mismatch between the pattern and the text.\n        :param current_pos: The current position in the text.\n        :return: The position of the first mismatch between the pattern and the text, or -1 if no mismatch.\n        \"\"\"\n        if current_pos + self.pattern_len > self.text_len:\n            return -1\n        \n        for i in range(self.pattern_len):\n            if self.pattern[self.pattern_len - 1 - i] != self.text[current_pos + self.pattern_len - 1 - i]:\n                return current_pos + self.pattern_len - 1 - i\n        return -1\n\n    def bad_character_heuristic(self) -> list:\n        \"\"\"\n        Finds all occurrences of the pattern in the text using the bad character heuristic.\n        :return: A list of all positions of the pattern in the text.\n        \"\"\"\n        positions = []\n        text_index = 0\n\n        while text_index <= self.text_len - self.pattern_len:\n            mismatch_index = self.mismatch_in_text(text_index)\n\n            if mismatch_index == -1:\n                positions.append(text_index)\n                text_index += 1\n            else:\n                bad_char_index = self.match_in_pattern(self.text[mismatch_index])\n                shift = max(1, mismatch_index - text_index + 1 - bad_char_index)\n                text_index += shift\n\n        return positions\n```",
    "18": "```python\nclass CamelCaseMap:\n    \"\"\"\n    A custom class that allows keys to be in camel case style by converting them from underscore style,\n    providing dictionary-like functionality.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize data to an empty dictionary.\"\"\"\n        self._data = {}\n\n    def __getitem__(self, key):\n        \"\"\"Return the value corresponding to the key.\"\"\"\n        key = self._convert_key(key)\n        return self._data.get(key)\n\n    def __setitem__(self, key, value):\n        \"\"\"Set the value corresponding to the key to the specified value.\"\"\"\n        key = self._convert_key(key)\n        self._data[key] = value\n\n    def __delitem__(self, key):\n        \"\"\"Delete the value corresponding to the key.\"\"\"\n        key = self._convert_key(key)\n        self._data.pop(key, None)  # Safely remove the key if it exists\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the keys in camel case.\"\"\"\n        return (self._to_camel_case(key) for key in self._data.keys())\n\n    def __len__(self):\n        \"\"\"Return the length of the data.\"\"\"\n        return len(self._data)\n\n    def _convert_key(self, key):\n        \"\"\"Convert key string into camel case if it's a string.\"\"\"\n        if isinstance(key, str):\n            return self._to_camel_case(key)\n        return key\n\n    @staticmethod\n    def _to_camel_case(key):\n        \"\"\"Convert key string into camel case.\"\"\"\n        parts = key.split('_')\n        return parts[0] + ''.join(part.capitalize() for part in parts[1:])\n```",
    "14": "```python\nimport sqlite3\n\nclass BookManagementDB:\n    \"\"\"\n    A database class for a book management system, handling operations for adding, removing, updating, and searching books.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the class by creating a database connection and cursor, \n        and creates the book table if it does not already exist.\n        :param db_name: str, the name of the database file\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates the book table in the database if it does not already exist.\n        \"\"\"\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS books (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                title TEXT NOT NULL,\n                author TEXT NOT NULL,\n                available INTEGER NOT NULL DEFAULT 1\n            )\n        ''')\n        self.connection.commit()\n\n    def add_book(self, title: str, author: str) -> None:\n        \"\"\"\n        Adds a book to the database with the specified title and author, \n        setting its availability to 1 (available).\n        :param title: str, book title\n        :param author: str, author name\n        \"\"\"\n        self.cursor.execute('''\n            INSERT INTO books (title, author) VALUES (?, ?)\n        ''', (title, author))\n        self.connection.commit()\n\n    def remove_book(self, book_id: int) -> None:\n        \"\"\"\n        Removes a book from the database based on the given book ID.\n        :param book_id: int, the ID of the book to remove\n        \"\"\"\n        self.cursor.execute('''\n            DELETE FROM books WHERE id = ?\n        ''', (book_id,))\n        self.connection.commit()\n\n    def borrow_book(self, book_id: int) -> None:\n        \"\"\"\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int, the ID of the book to borrow\n        \"\"\"\n        self.cursor.execute('''\n            UPDATE books SET available = 0 WHERE id = ?\n        ''', (book_id,))\n        self.connection.commit()\n\n    def return_book(self, book_id: int) -> None:\n        \"\"\"\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int, the ID of the book to return\n        \"\"\"\n        self.cursor.execute('''\n            UPDATE books SET available = 1 WHERE id = ?\n        ''', (book_id,))\n        self.connection.commit()\n\n    def search_books(self) -> list:\n        \"\"\"\n        Retrieves all books from the database and returns their information.\n        :return: list[tuple], the information of all books in the database\n        \"\"\"\n        self.cursor.execute('''\n            SELECT * FROM books\n        ''')\n        return self.cursor.fetchall()\n\n    def close(self) -> None:\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        self.connection.close()\n```",
    "12": "```python\nimport random\n\nclass BlackjackGame:\n    \"\"\"\n    A class representing a game of blackjack, which includes creating a deck, calculating the value of a hand, \n    and determining the winner based on the hand values of the player and dealer.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Blackjack Game with a deck, player_hand, and dealer_hand.\n        The deck stores 52 cards in random order, with Jokers removed.\n        \"\"\"\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n\n    def create_deck(self):\n        \"\"\"\n        Create a deck of 52 cards without Jokers.\n        :return: a shuffled list of 52 cards in the format ['AS', '2S', ...].\n        \"\"\"\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n        deck = [rank + suit for suit in suits for rank in ranks]\n        random.shuffle(deck)\n        return deck\n\n    def calculate_hand_value(self, hand):\n        \"\"\"\n        Calculate the value of the cards in the hand according to Blackjack rules.\n        :param hand: list of cards\n        :return: the total value of the hand\n        \"\"\"\n        value = 0\n        aces_count = 0\n\n        for card in hand:\n            rank = card[:-1]  # Get the rank part of the card\n            if rank in ['J', 'Q', 'K']:\n                value += 10\n            elif rank == 'A':\n                value += 11\n                aces_count += 1\n            else:\n                value += int(rank)\n\n        # Adjust for Aces if value exceeds 21\n        while value > 21 and aces_count:\n            value -= 10\n            aces_count -= 1\n\n        return value\n\n    def check_winner(self, player_hand, dealer_hand):\n        \"\"\"\n        Determine the winner by comparing the hand values of the player and dealer.\n        :param player_hand: list of player's cards\n        :param dealer_hand: list of dealer's cards\n        :return: a string indicating the winner ('Dealer wins' or 'Player wins')\n        \"\"\"\n        player_value = self.calculate_hand_value(player_hand)\n        dealer_value = self.calculate_hand_value(dealer_hand)\n\n        if player_value > 21:\n            return 'Dealer wins'\n        if dealer_value > 21:\n            return 'Player wins'\n        \n        if player_value > dealer_value:\n            return 'Player wins'\n        else:\n            return 'Dealer wins'\n```",
    "20": "```python\nfrom datetime import datetime\n\nclass Chat:\n    \"\"\"\n    A chat class that allows adding/removing users, sending messages, and retrieving messages.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the Chat with an empty user dictionary.\"\"\"\n        self.users = {}\n\n    def add_user(self, username: str) -> bool:\n        \"\"\"\n        Add a new user to the Chat.\n        \n        :param username: The user's name.\n        :return: True if the user was added, False if the user already exists.\n        \"\"\"\n        if username in self.users:\n            return False\n        self.users[username] = []\n        return True\n\n    def remove_user(self, username: str) -> bool:\n        \"\"\"\n        Remove a user from the Chat.\n        \n        :param username: The user's name.\n        :return: True if the user was removed, False if the user does not exist.\n        \"\"\"\n        return self.users.pop(username, None) is not None\n\n    def send_message(self, sender: str, receiver: str, message: str) -> bool:\n        \"\"\"\n        Send a message from one user to another.\n        \n        :param sender: The sender's name.\n        :param receiver: The receiver's name.\n        :param message: The message content.\n        :return: True if the message was sent, False if either user does not exist.\n        \"\"\"\n        if sender not in self.users or receiver not in self.users:\n            return False\n        \n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        message_data = {\n            'sender': sender,\n            'receiver': receiver,\n            'message': message,\n            'timestamp': timestamp\n        }\n        \n        self.users[sender].append(message_data)\n        self.users[receiver].append(message_data)\n        return True\n\n    def get_messages(self, username: str):\n        \"\"\"\n        Retrieve all messages for a user.\n        \n        :param username: The user's name.\n        :return: A list of messages sent to/from the user.\n        \"\"\"\n        return self.users.get(username, [])\n```",
    "16": "```python\nclass Calculator:\n    \"\"\"\n    A simple calculator class that performs basic arithmetic operations\n    on numerical expressions using the operators +, -, *, /, and ^ (exponentiation).\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the operations for the five operators: '+', '-', '*', '/', '^'.\n        \"\"\"\n        self.operators = {\n            '+': lambda x, y: x + y,\n            '-': lambda x, y: x - y,\n            '*': lambda x, y: x * y,\n            '/': lambda x, y: x / y if y != 0 else float('inf'),  # Handle division by zero\n            '^': lambda x, y: x ** y\n        }\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculates the value of a given arithmetic expression.\n        \n        :param expression: str, the arithmetic expression to evaluate\n        :return: float, the result of the expression or None if invalid\n        \"\"\"\n        if not expression:\n            return None\n        \n        operand_stack = []\n        operator_stack = []\n        i = 0\n\n        while i < len(expression):\n            char = expression[i]\n\n            if char.isdigit():\n                num = self._parse_number(expression, i)\n                operand_stack.append(num)\n                i += len(str(num))  # Move index forward by the length of the number\n                continue\n            \n            if char in self.operators:\n                while (operator_stack and \n                       self.precedence(operator_stack[-1]) >= self.precedence(char)):\n                    self._apply_operator(operand_stack, operator_stack)\n                operator_stack.append(char)\n\n            elif char == '(':\n                operator_stack.append(char)\n\n            elif char == ')':\n                while operator_stack and operator_stack[-1] != '(':\n                    self._apply_operator(operand_stack, operator_stack)\n                operator_stack.pop()  # Remove the '('\n\n            i += 1\n\n        while operator_stack:\n            self._apply_operator(operand_stack, operator_stack)\n\n        return operand_stack[0] if operand_stack else None\n\n    def _parse_number(self, expression, index):\n        \"\"\"\n        Parses a number from the expression starting at the given index.\n        \n        :param expression: str, the expression to parse\n        :param index: int, the starting index for parsing\n        :return: int, the parsed number\n        \"\"\"\n        num = 0\n        while index < len(expression) and expression[index].isdigit():\n            num = num * 10 + int(expression[index])\n            index += 1\n        return num\n\n    def precedence(self, operator):\n        \"\"\"\n        Returns the precedence of the specified operator.\n        \n        :param operator: str, the operator to evaluate\n        :return: int, the precedence of the operator\n        \"\"\"\n        precedence_map = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n        return precedence_map.get(operator, 0)\n\n    def _apply_operator(self, operand_stack, operator_stack):\n        \"\"\"\n        Applies the operator at the top of the operator stack to the top two operands\n        on the operand stack and pushes the result back onto the operand stack.\n        \n        :param operand_stack: list, the stack of operands\n        :param operator_stack: list, the stack of operators\n        \"\"\"\n        operator = operator_stack.pop()\n        right_operand = operand_stack.pop()\n        left_operand = operand_stack.pop()\n        result = self.operators[operator](left_operand, right_operand)\n        operand_stack.append(result)\n```",
    "17": "```python\nfrom datetime import datetime, timedelta\n\nclass CalendarUtil:\n    \"\"\"\n    A utility class for managing calendar events, scheduling appointments, and performing conflict checks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the calendar with an empty list of events.\n        \"\"\"\n        self.events = []\n\n    def add_event(self, event):\n        \"\"\"\n        Adds an event to the calendar.\n        :param event: The event to be added, expected to be a dictionary with 'date', 'start_time', 'end_time', and 'description'.\n        \"\"\"\n        self.events.append(event)\n\n    def remove_event(self, event):\n        \"\"\"\n        Removes an event from the calendar.\n        :param event: The event to be removed, expected to be a dictionary.\n        \"\"\"\n        self.events = [e for e in self.events if e != event]\n\n    def get_events(self, date):\n        \"\"\"\n        Retrieves all events on a given date.\n        :param date: The date to get events for, expected to be a datetime object.\n        :return: A list of events on the given date.\n        \"\"\"\n        return [event for event in self.events if event['date'].date() == date.date()]\n\n    def is_available(self, start_time, end_time):\n        \"\"\"\n        Checks if the calendar is available for a given time slot.\n        :param start_time: The start time of the time slot, expected to be a datetime object.\n        :param end_time: The end time of the time slot, expected to be a datetime object.\n        :return: True if the calendar is available for the given time slot, False otherwise.\n        \"\"\"\n        return all(not (event['start_time'] < end_time and event['end_time'] > start_time) for event in self.events)\n\n    def get_available_slots(self, date):\n        \"\"\"\n        Retrieves all available time slots on a given date.\n        :param date: The date to get available time slots for, expected to be a datetime object.\n        :return: A list of available time slots on the given date.\n        \"\"\"\n        slots = []\n        start_of_day = datetime.combine(date, datetime.min.time())\n        end_of_day = datetime.combine(date, datetime.max.time())\n        current_time = start_of_day\n\n        for event in sorted(self.events, key=lambda x: x['start_time']):\n            if current_time < event['start_time']:\n                slots.append((current_time, event['start_time']))\n            current_time = max(current_time, event['end_time'])\n\n        if current_time < end_of_day:\n            slots.append((current_time, end_of_day))\n\n        return slots\n\n    def get_upcoming_events(self, num_events):\n        \"\"\"\n        Retrieves the next n upcoming events from the current date.\n        :param num_events: The number of upcoming events to retrieve, expected to be an integer.\n        :return: A list of the next n upcoming events from the current date.\n        \"\"\"\n        now = datetime.now()\n        upcoming_events = [event for event in self.events if event['start_time'] > now]\n        return sorted(upcoming_events, key=lambda x: x['start_time'])[:num_events]\n```",
    "24": "```python\nclass ComplexCalculator:\n    \"\"\"\n    A class that implements addition, subtraction, multiplication, and division operations for complex numbers.\n    \"\"\"\n\n    @staticmethod\n    def add(c1: complex, c2: complex) -> complex:\n        \"\"\"\n        Adds two complex numbers.\n        \n        :param c1: The first complex number.\n        :param c2: The second complex number.\n        :return: The sum of the two complex numbers.\n        \"\"\"\n        return c1 + c2\n\n    @staticmethod\n    def subtract(c1: complex, c2: complex) -> complex:\n        \"\"\"\n        Subtracts two complex numbers.\n        \n        :param c1: The first complex number.\n        :param c2: The second complex number.\n        :return: The difference of the two complex numbers.\n        \"\"\"\n        return c1 - c2\n\n    @staticmethod\n    def multiply(c1: complex, c2: complex) -> complex:\n        \"\"\"\n        Multiplies two complex numbers.\n        \n        :param c1: The first complex number.\n        :param c2: The second complex number.\n        :return: The product of the two complex numbers.\n        \"\"\"\n        return c1 * c2\n\n    @staticmethod\n    def divide(c1: complex, c2: complex) -> complex:\n        \"\"\"\n        Divides two complex numbers.\n        \n        :param c1: The first complex number.\n        :param c2: The second complex number.\n        :return: The quotient of the two complex numbers.\n        :raises ValueError: If the second complex number is zero.\n        \"\"\"\n        if c2 == 0:\n            raise ValueError(\"Cannot divide by zero.\")\n        return c1 / c2\n```",
    "25": "```python\nimport json\nimport os\n\nclass CookiesUtil:\n    \"\"\"\n    A utility class for managing and manipulating cookies, including methods for retrieving, saving, and setting cookies data.\n    \"\"\"\n\n    def __init__(self, cookies_file):\n        \"\"\"\n        Initializes the CookiesUtil with the specified cookies file.\n        :param cookies_file: The cookies file to use, str.\n        \"\"\"\n        self.cookies_file = cookies_file\n        self.cookies = {}\n\n    def get_cookies(self, response):\n        \"\"\"\n        Gets the cookies from the specified response and saves it to cookies_file.\n        :param response: The response to get cookies from, dict.\n        \"\"\"\n        self.cookies = response.get('cookies', {})\n        self._save_cookies()\n\n    def load_cookies(self):\n        \"\"\"\n        Loads the cookies from the cookies_file to the cookies data.\n        :return: The cookies data, dict.\n        \"\"\"\n        if os.path.exists(self.cookies_file):\n            with open(self.cookies_file, 'r') as file:\n                self.cookies = json.load(file)\n        return self.cookies\n\n    def _save_cookies(self):\n        \"\"\"\n        Saves the cookies to the cookies_file, and returns True if successful, False otherwise.\n        :return: True if successful, False otherwise.\n        \"\"\"\n        try:\n            with open(self.cookies_file, 'w') as file:\n                json.dump(self.cookies, file)\n            return True\n        except (IOError, json.JSONDecodeError):\n            return False\n\n    def set_cookies(self, request):\n        \"\"\"\n        Sets the cookies in the request.\n        :param request: The request to set cookies in, dict.\n        \"\"\"\n        request['cookies'] = self.cookies\n```",
    "22": "```python\nclass ClassRegistrationSystem:\n    \"\"\"\n    A class registration system that allows registering students, enrolling them in classes,\n    retrieving students by major, listing all majors, and determining the most popular class\n    within a specific major.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the registration system with a list of students and a dictionary for class registrations.\n        \"\"\"\n        self.students = []\n        self.students_registration_classes = {}\n\n    def register_student(self, student):\n        \"\"\"\n        Registers a student in the system. Returns 0 if the student is already registered, otherwise returns 1.\n        \n        :param student: dict with 'name' and 'major' keys\n        :return: int\n        \"\"\"\n        if any(existing_student['name'] == student['name'] for existing_student in self.students):\n            return 0\n        self.students.append(student)\n        return 1\n\n    def register_class(self, student_name, class_name):\n        \"\"\"\n        Registers a class for a student. If the student is not registered, they are added to the system.\n        \n        :param student_name: str\n        :param class_name: str\n        :return: list of class names that the student has registered\n        \"\"\"\n        if student_name not in self.students_registration_classes:\n            self.students_registration_classes[student_name] = []\n        self.students_registration_classes[student_name].append(class_name)\n        return self.students_registration_classes[student_name]\n\n    def get_students_by_major(self, major):\n        \"\"\"\n        Retrieves all students in a specified major.\n        \n        :param major: str\n        :return: list of student names\n        \"\"\"\n        return [student['name'] for student in self.students if student['major'] == major]\n\n    def get_all_major(self):\n        \"\"\"\n        Retrieves a list of all unique majors in the system.\n        \n        :return: list of majors\n        \"\"\"\n        return list({student['major'] for student in self.students})\n\n    def get_most_popular_class_in_major(self, major):\n        \"\"\"\n        Determines the class with the highest enrollment in a specified major.\n        \n        :param major: str\n        :return: str of the most popular class in this major, or None if no classes are registered\n        \"\"\"\n        class_count = {}\n        for student in self.students:\n            if student['major'] == major:\n                for class_name in self.students_registration_classes.get(student['name'], []):\n                    class_count[class_name] = class_count.get(class_name, 0) + 1\n        return max(class_count, key=class_count.get) if class_count else None\n```",
    "21": "```python\nfrom datetime import datetime\n\nclass Classroom:\n    \"\"\"\n    This class represents a classroom, capable of adding and removing courses, checking availability at a given time,\n    and detecting conflicts when scheduling new courses.\n    \"\"\"\n\n    def __init__(self, id):\n        \"\"\"\n        Initialize the classroom management system.\n        :param id: int, the id of the classroom\n        \"\"\"\n        self.id = id\n        self.courses = []\n\n    def add_course(self, course):\n        \"\"\"\n        Add a course to the classroom if it does not conflict with existing courses.\n        :param course: dict, information of the course, including 'start_time', 'end_time', and 'name'\n        \"\"\"\n        if not self.check_course_conflict(course):\n            self.courses.append(course)\n\n    def remove_course(self, course):\n        \"\"\"\n        Remove a course from the classroom if it exists.\n        :param course: dict, information of the course, including 'start_time', 'end_time', and 'name'\n        \"\"\"\n        if course in self.courses:\n            self.courses.remove(course)\n\n    def is_free_at(self, check_time):\n        \"\"\"\n        Check if the classroom is free at the given time.\n        :param check_time: str, the time to be checked in 'HH:MM' format\n        :return: True if the classroom is free at check_time, False otherwise\n        \"\"\"\n        check_time = self._parse_time(check_time)\n        return all(not self._is_time_conflicting(check_time, course) for course in self.courses)\n\n    def check_course_conflict(self, new_course):\n        \"\"\"\n        Check if the new course time conflicts with existing courses.\n        :param new_course: dict, information of the course, including 'start_time', 'end_time', and 'name'\n        :return: True if there is no conflict, False otherwise\n        \"\"\"\n        new_start = self._parse_time(new_course['start_time'])\n        new_end = self._parse_time(new_course['end_time'])\n        \n        return all(self._is_time_conflicting(new_start, new_end, course) for course in self.courses)\n\n    def _parse_time(self, time_str):\n        \"\"\"\n        Parse a time string into a time object.\n        :param time_str: str, time in 'HH:MM' format\n        :return: time object\n        \"\"\"\n        return datetime.strptime(time_str, '%H:%M').time()\n\n    def _is_time_conflicting(self, new_start, new_end, course):\n        \"\"\"\n        Check if the new course time conflicts with an existing course.\n        :param new_start: time object, start time of the new course\n        :param new_end: time object, end time of the new course\n        :param course: dict, existing course information\n        :return: True if there is a conflict, False otherwise\n        \"\"\"\n        start_time = self._parse_time(course['start_time'])\n        end_time = self._parse_time(course['end_time'])\n        return not (new_end <= start_time or new_start >= end_time)\n```",
    "23": "```python\nimport math\nfrom typing import List\n\nclass CombinationCalculator:\n    \"\"\"\n    A class that provides methods to calculate combinations and generate combinations from a list of data.\n    \"\"\"\n\n    def __init__(self, datas: List[str]):\n        \"\"\"\n        Initialize the calculator with a list of data.\n        :param datas: List of strings to generate combinations from.\n        \"\"\"\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        \"\"\"\n        Calculate the number of combinations of n items taken m at a time.\n        :param n: Total number of elements.\n        :param m: Number of elements in each combination.\n        :return: The number of combinations.\n        \"\"\"\n        if m < 0 or m > n:\n            return 0\n        return math.factorial(n) // (math.factorial(m) * math.factorial(n - m))\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"\n        Calculate the number of all possible combinations from n elements.\n        :param n: Total number of elements.\n        :return: The number of all possible combinations.\n        \"\"\"\n        if n < 0:\n            return False\n        if n > 63:\n            return float(\"inf\")\n        return (1 << n) - 1  # 2^n - 1\n\n    def select(self, m: int) -> List[List[str]]:\n        \"\"\"\n        Generate combinations with a specified number of elements.\n        :param m: The number of elements in each combination.\n        :return: A list of combinations.\n        \"\"\"\n        if m < 0 or m > len(self.datas):\n            return []\n        result = []\n        self._select(0, [None] * m, 0, result)\n        return result\n\n    def select_all(self) -> List[List[str]]:\n        \"\"\"\n        Generate all possible combinations of selecting elements from the given data list.\n        :return: A list of combinations.\n        \"\"\"\n        result = []\n        for m in range(1, len(self.datas) + 1):\n            result.extend(self.select(m))\n        return result\n\n    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        \"\"\"\n        Generate combinations recursively.\n        :param dataIndex: The index of the data to be selected.\n        :param resultList: The current combination being built.\n        :param resultIndex: The index of the current position in the combination.\n        :param result: The list of all combinations generated.\n        \"\"\"\n        if resultIndex == len(resultList):\n            result.append(resultList.copy())\n            return\n        \n        for i in range(dataIndex, len(self.datas)):\n            resultList[resultIndex] = self.datas[i]\n            self._select(i + 1, resultList, resultIndex + 1, result)\n```",
    "27": "```python\nclass CurrencyConverter:\n    \"\"\"\n    A class for currency conversion, supporting conversion between different currencies,\n    retrieving supported currencies, adding new currency rates, and updating existing currency rates.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the exchange rates for various currencies against the US dollar.\n        \"\"\"\n        self.rates = {\n            'USD': 1.0,\n            'EUR': 0.85,\n            'GBP': 0.72,\n            'JPY': 110.15,\n            'CAD': 1.23,\n            'AUD': 1.34,\n            'CNY': 6.40,\n        }\n\n    def convert(self, amount, from_currency, to_currency):\n        \"\"\"\n        Convert the value of a given currency to another currency type.\n\n        :param amount: float, The value of a given currency\n        :param from_currency: string, source currency type\n        :param to_currency: string, target currency type\n        :return: float, value converted to another currency type or False if currencies are unsupported\n        \"\"\"\n        if from_currency not in self.rates or to_currency not in self.rates:\n            return False\n\n        # Convert amount to USD first\n        amount_in_usd = amount / self.rates[from_currency]\n        # Convert USD to the target currency\n        converted_amount = amount_in_usd * self.rates[to_currency]\n        return converted_amount\n\n    def get_supported_currencies(self):\n        \"\"\"\n        Returns a list of supported currency types.\n\n        :return: list, All supported currency types\n        \"\"\"\n        return list(self.rates.keys())\n\n    def add_currency_rate(self, currency, rate):\n        \"\"\"\n        Add a new supported currency type. Return False if the currency type is already in the support list.\n\n        :param currency: string, currency type to be added\n        :param rate: float, exchange rate for this type of currency\n        :return: None if successful; False if unsuccessful\n        \"\"\"\n        if currency in self.rates:\n            return False\n        self.rates[currency] = rate\n\n    def update_currency_rate(self, currency, new_rate):\n        \"\"\"\n        Update the exchange rate for a certain currency.\n\n        :param currency: string\n        :param new_rate: float\n        :return: None if successful; False if unsuccessful\n        \"\"\"\n        if currency not in self.rates:\n            return False\n        self.rates[currency] = new_rate\n```",
    "30": "```python\nimport numpy as np\n\nclass DataStatistics:\n    \"\"\"\n    A class for performing basic statistical calculations on a dataset.\n    Supports sum, minimum, maximum, variance, standard deviation, and correlation.\n    \"\"\"\n\n    def __init__(self, data):\n        \"\"\"\n        Initialize the DataStatistics object with a dataset.\n        \n        :param data: list or array-like, the dataset to analyze\n        \"\"\"\n        self.data = np.array(data)\n\n    def get_sum(self):\n        \"\"\"\n        Calculate the sum of the dataset.\n        \n        :return: float, the sum of the data\n        \"\"\"\n        return np.sum(self.data)\n\n    def get_min(self):\n        \"\"\"\n        Calculate the minimum value in the dataset.\n        \n        :return: float, the minimum value\n        \"\"\"\n        return np.min(self.data)\n\n    def get_max(self):\n        \"\"\"\n        Calculate the maximum value in the dataset.\n        \n        :return: float, the maximum value\n        \"\"\"\n        return np.max(self.data)\n\n    def get_variance(self):\n        \"\"\"\n        Calculate the sample variance of the dataset, rounded to two decimal places.\n        \n        :return: float, the variance of the data\n        \"\"\"\n        return round(np.var(self.data, ddof=1), 2)\n\n    def get_std_deviation(self):\n        \"\"\"\n        Calculate the sample standard deviation of the dataset, rounded to two decimal places.\n        \n        :return: float, the standard deviation of the data\n        \"\"\"\n        return round(np.std(self.data, ddof=1), 2)\n\n    def get_correlation(self):\n        \"\"\"\n        Calculate the correlation of the dataset with itself (always 1.0).\n        \n        :return: float, the correlation coefficient\n        \"\"\"\n        return 1.0  # Correlation of a dataset with itself is always 1.0\n```",
    "29": "```python\nfrom collections import Counter\nfrom typing import List, Union\n\nclass DataStatistics:\n    \"\"\"\n    A class for performing data statistics, supporting the calculation of mean, median, and mode of a given data set.\n    \"\"\"\n\n    def mean(self, data: List[Union[int, float]]) -> float:\n        \"\"\"\n        Calculate the average value of a group of data, accurate to two digits after the decimal separator.\n        \n        :param data: List of numerical data\n        :return: Mean value as a float\n        \"\"\"\n        if not data:\n            return 0.0\n        return round(sum(data) / len(data), 2)\n\n    def median(self, data: List[Union[int, float]]) -> float:\n        \"\"\"\n        Calculate the median of a group of data, accurate to two digits after the decimal separator.\n        \n        :param data: List of numerical data\n        :return: Median value as a float\n        \"\"\"\n        if not data:\n            return 0.0\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        mid = n // 2\n        if n % 2 == 0:\n            return round((sorted_data[mid - 1] + sorted_data[mid]) / 2, 2)\n        return round(sorted_data[mid], 2)\n\n    def mode(self, data: List[Union[int, float]]) -> List[Union[int, float]]:\n        \"\"\"\n        Calculate the mode of a set of data.\n        \n        :param data: List of numerical data\n        :return: List of mode(s)\n        \"\"\"\n        if not data:\n            return []\n        frequency = Counter(data)\n        max_count = max(frequency.values())\n        return [num for num, count in frequency.items() if count == max_count]\n```",
    "26": "```python\nimport csv\nimport os\n\nclass CSVProcessor:\n    \"\"\"\n    A class for processing CSV files, including reading, writing, and processing specific operations.\n    \"\"\"\n\n    def read_csv(self, file_name):\n        \"\"\"\n        Read a CSV file and return the title and data.\n        \n        :param file_name: str, name of the CSV file\n        :return: tuple (list, list), first row is title, the rest is data\n        \"\"\"\n        try:\n            with open(file_name, mode='r', newline='', encoding='utf-8') as file:\n                reader = csv.reader(file)\n                title = next(reader)\n                data = list(reader)\n            return title, data\n        except Exception as e:\n            print(f\"Error reading {file_name}: {e}\")\n            return [], []\n\n    def write_csv(self, data, file_name):\n        \"\"\"\n        Write data into a CSV file.\n        \n        :param data: list of lists, data to write\n        :param file_name: str, name of the CSV file\n        :return: int, 1 if success, 0 otherwise\n        \"\"\"\n        if not data or not file_name:\n            return 0\n        \n        try:\n            with open(file_name, mode='w', newline='', encoding='utf-8') as file:\n                writer = csv.writer(file)\n                writer.writerows(data)\n            return 1\n        except Exception as e:\n            print(f\"Error writing to {file_name}: {e}\")\n            return 0\n\n    def process_csv_data(self, N, save_file_name):\n        \"\"\"\n        Process a CSV file to retain only the N-th column, capitalizing the values.\n        \n        :param N: int, the N-th column (0-indexed)\n        :param save_file_name: str, the name of the file to be processed\n        :return: int, 1 if success, 0 otherwise\n        \"\"\"\n        title, data = self.read_csv(save_file_name)\n        if not title or not data or N >= len(title):\n            return 0\n        \n        processed_data = [[row[N].upper()] for row in data]\n        new_file_name = f\"{os.path.splitext(save_file_name)[0]}_process.csv\"\n        \n        if self.write_csv([title], new_file_name) == 1:\n            return self.write_csv(processed_data, new_file_name)\n        \n        return 0\n```",
    "28": "```python\nimport sqlite3\n\nclass DatabaseProcessor:\n    \"\"\"\n    A class for processing a SQLite database, supporting table creation, data insertion, \n    searching, and deletion.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize the DatabaseProcessor with the specified database name.\n        \n        :param database_name: str, the name of the SQLite database file.\n        \"\"\"\n        self.database_name = database_name\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        \n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table (TEXT).\n        :param key2: str, the name of the second column in the table (INTEGER).\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.execute(f\"\"\"\n                CREATE TABLE IF NOT EXISTS {table_name} (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    {key1} TEXT,\n                    {key2} INTEGER\n                )\n            \"\"\")\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        \n        :param table_name: str, the name of the table to insert data into.\n        :param data: list of dicts, where each dict represents a row of data.\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            for entry in data:\n                cursor.execute(f\"\"\"\n                    INSERT INTO {table_name} ({', '.join(entry.keys())}) \n                    VALUES ({', '.join(['?' for _ in entry])})\n                \"\"\", tuple(entry.values()))\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table for rows with a matching name.\n        \n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list of tuples representing the rows with matching name, or None if not found.\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.execute(f\"SELECT * FROM {table_name} WHERE {name}=?\", (name,))\n            result = cursor.fetchall()\n            return result if result else None\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table with a matching name.\n        \n        :param table_name: str, the name of the table to delete from.\n        :param name: str, the name to match for deletion.\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.execute(f\"DELETE FROM {table_name} WHERE name=?\", (name,))\n```",
    "31": "```python\nimport math\nfrom statistics import mean, stdev\n\nclass DataStatistics:\n    \"\"\"\n    A class that performs advanced mathematical calculations and statistics, \n    including correlation coefficient, skewness, kurtosis, and probability density function (PDF) \n    for a normal distribution.\n    \"\"\"\n\n    @staticmethod\n    def correlation_coefficient(data1, data2):\n        \"\"\"\n        Calculate the correlation coefficient of two sets of data.\n        \n        :param data1: The first set of data, list.\n        :param data2: The second set of data, list.\n        :return: The correlation coefficient, float.\n        :raises ValueError: If the lengths of data1 and data2 are not equal.\n        \"\"\"\n        if len(data1) != len(data2):\n            raise ValueError(\"Data sets must have the same length.\")\n        \n        n = len(data1)\n        mean1, mean2 = mean(data1), mean(data2)\n        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))\n        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n)) * \n                                 sum((data2[i] - mean2) ** 2 for i in range(n)))\n        return numerator / denominator if denominator != 0 else 0.0\n\n    @staticmethod\n    def skewness(data):\n        \"\"\"\n        Calculate the skewness of a set of data.\n        \n        :param data: The input data list, list.\n        :return: The skewness, float.\n        \"\"\"\n        n = len(data)\n        if n < 3:\n            return float('nan')\n\n        mean_value = mean(data)\n        std_dev = stdev(data)\n        skew = (sum((x - mean_value) ** 3 for x in data) / n) / (std_dev ** 3)\n        return skew\n\n    @staticmethod\n    def kurtosis(data):\n        \"\"\"\n        Calculate the kurtosis of a set of data.\n        \n        :param data: The input data list, list.\n        :return: The kurtosis, float.\n        \"\"\"\n        n = len(data)\n        if n < 4:\n            return float('nan')\n\n        mean_value = mean(data)\n        std_dev = stdev(data)\n        kurt = (sum((x - mean_value) ** 4 for x in data) / n) / (std_dev ** 4) - 3\n        return kurt\n\n    @staticmethod\n    def pdf(data, mu, sigma):\n        \"\"\"\n        Calculate the probability density function (PDF) of a set of data under a normal distribution.\n        \n        :param data: The input data list, list.\n        :param mu: The mean of the normal distribution, float.\n        :param sigma: The standard deviation of the normal distribution, float.\n        :return: The probability density function (PDF), list.\n        \"\"\"\n        coefficient = 1 / (sigma * math.sqrt(2 * math.pi))\n        return [coefficient * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n```",
    "33": "```python\nclass DiscountStrategy:\n    \"\"\"\n    This class allows the use of different discount strategies based on shopping credit or shopping cart in a supermarket.\n    \"\"\"\n\n    def __init__(self, customer, cart, promotion=None):\n        \"\"\"\n        Initialize the DiscountStrategy with customer information, a cart of items, and an optional promotion.\n        :param customer: dict, customer information\n        :param cart: list of dicts, a cart of items with details\n        :param promotion: function, optional promotion applied to the order\n        \"\"\"\n        self.customer = customer\n        self.cart = cart\n        self.promotion = promotion\n\n    def total(self):\n        \"\"\"\n        Calculate the total cost of items in the cart.\n        :return: float, total cost of items\n        \"\"\"\n        return sum(item['quantity'] * item['price'] for item in self.cart)\n\n    def due(self):\n        \"\"\"\n        Calculate the final amount to be paid after applying the discount.\n        :return: float, final amount to be paid\n        \"\"\"\n        total_cost = self.total()\n        discount = self.promotion(self) if self.promotion else 0\n        return total_cost - discount\n\n    @staticmethod\n    def FidelityPromo(order):\n        \"\"\"\n        Calculate the discount based on the fidelity points of the customer.\n        Customers with over 1000 points can enjoy a 5% discount on the entire order.\n        :param order: DiscountStrategy, the order to apply the discount to\n        :return: float, discount amount\n        \"\"\"\n        return order.total() * 0.05 if order.customer.get('fidelity', 0) >= 1000 else 0\n\n    @staticmethod\n    def BulkItemPromo(order):\n        \"\"\"\n        Calculate the discount based on bulk item quantity in the order.\n        If the quantity of a single item reaches 20 or more, each item will enjoy a 10% discount.\n        :param order: DiscountStrategy, the order to apply the discount to\n        :return: float, discount amount\n        \"\"\"\n        return sum(item['quantity'] * item['price'] * 0.10 for item in order.cart if item['quantity'] >= 20)\n\n    @staticmethod\n    def LargeOrderPromo(order):\n        \"\"\"\n        Calculate the discount based on the number of different products in the order.\n        If the quantity of different products in the order reaches 10 or more, the entire order will enjoy a 7% discount.\n        :param order: DiscountStrategy, the order to apply the discount to\n        :return: float, discount amount\n        \"\"\"\n        return order.total() * 0.07 if len(order.cart) >= 10 else 0\n```",
    "32": "```python\nclass DecryptionUtils:\n    \"\"\"\n    A class that provides methods for decryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key: str):\n        \"\"\"\n        Initializes the decryption utility with a key.\n        :param key: The key to use for decryption.\n        \"\"\"\n        self.key = key.lower()  # Normalize key to lowercase for consistency\n\n    def caesar_decipher(self, ciphertext: str, shift: int) -> str:\n        \"\"\"\n        Deciphers the given ciphertext using the Caesar cipher.\n        :param ciphertext: The ciphertext to decipher.\n        :param shift: The shift to use for decryption.\n        :return: The deciphered plaintext.\n        \"\"\"\n        shift %= 26  # Normalize shift to be within 0-25\n        plaintext = []\n\n        for char in ciphertext:\n            if char.isalpha():\n                base = ord('A') if char.isupper() else ord('a')\n                deciphered_char = chr((ord(char) - base - shift) % 26 + base)\n                plaintext.append(deciphered_char)\n            else:\n                plaintext.append(char)\n\n        return ''.join(plaintext)\n\n    def vigenere_decipher(self, ciphertext: str) -> str:\n        \"\"\"\n        Deciphers the given ciphertext using the Vigenere cipher.\n        :param ciphertext: The ciphertext to decipher.\n        :return: The deciphered plaintext.\n        \"\"\"\n        plaintext = []\n        key_length = len(self.key)\n        key_as_int = [ord(i) - ord('a') for i in self.key]\n        ciphertext_int = [ord(i) - ord('a') for i in ciphertext.lower() if i.isalpha()]\n\n        for i in range(len(ciphertext_int)):\n            value = (ciphertext_int[i] - key_as_int[i % key_length]) % 26\n            plaintext.append(chr(value + ord('a')))\n\n        return ''.join(plaintext)\n\n    def rail_fence_decipher(self, encrypted_text: str, rails: int) -> str:\n        \"\"\"\n        Deciphers the given ciphertext using the Rail Fence cipher.\n        :param encrypted_text: The ciphertext to decipher.\n        :param rails: The number of rails to use for decryption.\n        :return: The deciphered plaintext.\n        \"\"\"\n        if rails <= 0:\n            raise ValueError(\"Number of rails must be greater than zero.\")\n\n        rail = [['\\n' for _ in range(len(encrypted_text))] for _ in range(rails)]\n        dir_down = True\n        row, col = 0, 0\n\n        for char in encrypted_text:\n            if row == 0:\n                dir_down = True\n            if row == rails - 1:\n                dir_down = False\n\n            rail[row][col] = '*'\n            col += 1\n\n            row += 1 if dir_down else -1\n\n        index = 0\n        for i in range(rails):\n            for j in range(len(encrypted_text)):\n                if rail[i][j] == '*' and index < len(encrypted_text):\n                    rail[i][j] = encrypted_text[index]\n                    index += 1\n\n        result = []\n        row, col = 0, 0\n\n        for _ in range(len(encrypted_text)):\n            if row == 0:\n                dir_down = True\n            if row == rails - 1:\n                dir_down = False\n\n            if rail[row][col] != '*':\n                result.append(rail[row][col])\n                col += 1\n\n            row += 1 if dir_down else -1\n\n        return ''.join(result)\n```",
    "34": "```python\nfrom docx import Document\nfrom docx.shared import Pt\nfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENT\n\n\nclass DocFileHandler:\n    \"\"\"\n    This class handles Word documents and provides functionalities for reading, writing, and modifying the content of Word documents.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initializes the DocFileHandler object with the specified file path.\n        :param file_path: str, the path to the Word document file.\n        \"\"\"\n        self.file_path = file_path\n\n    def read_text(self):\n        \"\"\"\n        Reads the content of a Word document and returns it as a string.\n        :return: str, the content of the Word document.\n        \"\"\"\n        doc = Document(self.file_path)\n        return '\\n'.join(para.text for para in doc.paragraphs)\n\n    def write_text(self, content, font_size=12, alignment='left'):\n        \"\"\"\n        Writes the specified content to a Word document.\n        :param content: str, the text content to write.\n        :param font_size: int, optional, the font size of the text (default is 12).\n        :param alignment: str, optional, the alignment of the text ('left', 'center', or 'right'; default is 'left').\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n        try:\n            doc = Document()\n            paragraph = doc.add_paragraph(content)\n            run = paragraph.runs[0]\n            run.font.size = Pt(font_size)\n            paragraph.alignment = self._get_alignment_value(alignment)\n            doc.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error writing text: {e}\")\n            return False\n\n    def add_heading(self, heading, level=1):\n        \"\"\"\n        Adds a heading to the Word document.\n        :param heading: str, the text of the heading.\n        :param level: int, optional, the level of the heading (1, 2, 3, etc.; default is 1).\n        :return: bool, True if the heading is successfully added, False otherwise.\n        \"\"\"\n        try:\n            doc = Document(self.file_path)\n            doc.add_heading(heading, level=level)\n            doc.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error adding heading: {e}\")\n            return False\n\n    def add_table(self, data):\n        \"\"\"\n        Adds a table to the Word document with the specified data.\n        :param data: list of lists, the data to populate the table.\n        :return: bool, True if the table is successfully added, False otherwise.\n        \"\"\"\n        try:\n            doc = Document(self.file_path)\n            table = doc.add_table(rows=len(data), cols=len(data[0]))\n            for row_idx, row_data in enumerate(data):\n                for col_idx, cell_data in enumerate(row_data):\n                    table.cell(row_idx, col_idx).text = str(cell_data)\n            doc.save(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error adding table: {e}\")\n            return False\n\n    def _get_alignment_value(self, alignment):\n        \"\"\"\n        Returns the alignment value corresponding to the given alignment string.\n        :param alignment: str, the alignment string ('left', 'center', or 'right').\n        :return: int, the alignment value.\n        \"\"\"\n        alignment_map = {\n            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,\n            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,\n            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT\n        }\n        return alignment_map.get(alignment, WD_PARAGRAPH_ALIGNMENT.LEFT)\n```",
    "37": "```python\nclass EncryptionUtils:\n    \"\"\"\n    This class provides methods for encryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key: str):\n        \"\"\"\n        Initializes the class with a key.\n        :param key: The key to use for encryption, str.\n        \"\"\"\n        self.key = key.lower()  # Store the key in lowercase for consistent processing\n\n    def caesar_cipher(self, plaintext: str, shift: int) -> str:\n        \"\"\"\n        Encrypts the plaintext using the Caesar cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :param shift: The number of characters to shift each character in the plaintext, int.\n        :return: The ciphertext, str.\n        \"\"\"\n        shift %= 26  # Normalize shift to be within 0-25\n        ciphertext = []\n\n        for char in plaintext:\n            if char.isalpha():\n                base = ord('A') if char.isupper() else ord('a')\n                new_char = chr((ord(char) - base + shift) % 26 + base)\n                ciphertext.append(new_char)\n            else:\n                ciphertext.append(char)\n\n        return ''.join(ciphertext)\n\n    def vigenere_cipher(self, plaintext: str) -> str:\n        \"\"\"\n        Encrypts the plaintext using the Vigenere cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :return: The ciphertext, str.\n        \"\"\"\n        ciphertext = []\n        key_length = len(self.key)\n        key_index = 0\n\n        for char in plaintext:\n            if char.isalpha():\n                base = ord('A') if char.isupper() else ord('a')\n                key_char = self.key[key_index % key_length]\n                shift = ord(key_char) - ord('a')\n                new_char = chr((ord(char) - base + shift) % 26 + base)\n                ciphertext.append(new_char)\n                key_index += 1\n            else:\n                ciphertext.append(char)\n\n        return ''.join(ciphertext)\n\n    def rail_fence_cipher(self, plaintext: str, rails: int) -> str:\n        \"\"\"\n        Encrypts the plaintext using the Rail Fence cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :param rails: The number of rails to use, int.\n        :return: The ciphertext, str.\n        \"\"\"\n        if rails <= 1:\n            return plaintext\n\n        rail = [''] * rails\n        direction_down = False\n        row = 0\n\n        for char in plaintext:\n            rail[row] += char\n            if row == 0 or row == rails - 1:\n                direction_down = not direction_down\n            row += 1 if direction_down else -1\n\n        return ''.join(rail)\n```",
    "38": "```python\nimport openpyxl\n\n\nclass ExcelProcessor:\n    \"\"\"\n    This class processes Excel files, including reading and writing data,\n    as well as performing specific operations and saving as a new Excel file.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_excel(self, file_name):\n        \"\"\"\n        Reads data from an Excel file.\n        \n        :param file_name: str, Excel file name to read\n        :return: list of tuples, Data in Excel or None if file_name is empty\n        \"\"\"\n        if not file_name:\n            return None\n        \n        workbook = openpyxl.load_workbook(file_name, data_only=True)\n        sheet = workbook.active\n        data = [tuple(cell.value for cell in row) for row in sheet.iter_rows(values_only=True)]\n        workbook.close()\n        return data\n\n    def write_excel(self, data, file_name):\n        \"\"\"\n        Writes data to the specified Excel file.\n        \n        :param data: list of tuples, Data to be written\n        :param file_name: str, Excel file name to write to\n        :return: int, 1 for success, 0 for failure\n        \"\"\"\n        if not file_name or not data:\n            return 0\n        \n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(file_name)\n        workbook.close()\n        return 1\n\n    def process_excel_data(self, column_index, source_file_name):\n        \"\"\"\n        Changes the specified column in the Excel file to uppercase.\n        \n        :param column_index: int, The serial number of the column to change\n        :param source_file_name: str, source file name\n        :return: (int, str), The first is the return value of write_excel,\n                 while the second is the saved file name of the processed data\n        \"\"\"\n        data = self.read_excel(source_file_name)\n        if data is None or column_index < 0 or column_index >= len(data[0]):\n            return 0, \"\"\n\n        processed_data = []\n        header = data[0] + (data[0][column_index].upper(),)\n        processed_data.append(header)\n\n        for row in data[1:]:\n            new_row = list(row) + (row[column_index],)\n            processed_data.append(new_row)\n\n        output_file_name = f\"processed_{source_file_name}\"\n        success = self.write_excel(processed_data, output_file_name)\n        return success, output_file_name\n```",
    "36": "```python\nfrom datetime import datetime\nfrom typing import List, Dict, Optional\n\nclass EmailClient:\n    \"\"\"\n    A class representing an email client that can send and receive emails,\n    check inbox capacity, and manage stored emails.\n    \"\"\"\n\n    def __init__(self, addr: str, capacity: float) -> None:\n        \"\"\"\n        Initializes the EmailClient with an email address and a storage capacity.\n        \n        :param addr: The email address.\n        :param capacity: The maximum capacity of the inbox in bytes.\n        \"\"\"\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox: List[Dict] = []\n\n    def send_to(self, recv: 'EmailClient', content: str, size: float) -> bool:\n        \"\"\"\n        Sends an email to another EmailClient instance.\n        \n        :param recv: The recipient EmailClient.\n        :param content: The content of the email.\n        :param size: The size of the email in bytes.\n        :return: True if the email is sent successfully, False if the recipient's inbox is full.\n        \"\"\"\n        if recv.is_full_with_one_more_email(size):\n            return False\n        \n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        email = {\n            'sender': self.addr,\n            'receiver': recv.addr,\n            'content': content,\n            'size': size,\n            'time': timestamp,\n            'state': 'unread'\n        }\n        recv.inbox.append(email)\n        return True\n\n    def fetch(self) -> Optional[Dict]:\n        \"\"\"\n        Retrieves the first unread email from the inbox and marks it as read.\n        \n        :return: The first unread email if available, otherwise None.\n        \"\"\"\n        for email in self.inbox:\n            if email['state'] == 'unread':\n                email['state'] = 'read'\n                return email\n        return None\n\n    def is_full_with_one_more_email(self, size: float) -> bool:\n        \"\"\"\n        Checks if adding an email of a given size would exceed the inbox capacity.\n        \n        :param size: The size of the email to be added.\n        :return: True if the inbox would be full, False otherwise.\n        \"\"\"\n        return self.get_occupied_size() + size > self.capacity\n\n    def get_occupied_size(self) -> float:\n        \"\"\"\n        Calculates the total size of all emails in the inbox.\n        \n        :return: The total size of emails in bytes.\n        \"\"\"\n        return sum(email['size'] for email in self.inbox)\n\n    def clear_inbox(self, size: float) -> None:\n        \"\"\"\n        Clears the inbox by removing the oldest emails until there is enough space for a new email.\n        \n        :param size: The size of the email to accommodate.\n        \"\"\"\n        while self.is_full_with_one_more_email(size) and self.inbox:\n            self.inbox.pop(0)  # Remove the oldest email\n```",
    "39": "```python\nfrom collections import deque\nfrom decimal import Decimal\n\nclass ExpressionCalculator:\n    \"\"\"\n    A class to perform calculations with basic arithmetic operations, including addition, subtraction,\n    multiplication, division, and modulo.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the expression calculator.\n        \"\"\"\n        self.postfix_stack = deque()\n        self.operator_priority = {'+': 1, '-': 1, '*': 2, '/': 2, '%': 2}\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the result of the given infix expression.\n        :param expression: string, the infix expression to be calculated\n        :return: float, the calculated result\n        \"\"\"\n        self.prepare(expression)\n        stack = []\n        for token in self.postfix_stack:\n            if self.is_operator(token):\n                second_value = stack.pop()\n                first_value = stack.pop()\n                result = self._calculate(first_value, second_value, token)\n                stack.append(result)\n            else:\n                stack.append(Decimal(token))\n        return float(stack.pop())\n\n    def prepare(self, expression):\n        \"\"\"\n        Prepare the infix expression for conversion to postfix notation.\n        :param expression: string, the infix expression to be prepared\n        \"\"\"\n        self.postfix_stack.clear()\n        output = []\n        operators = []\n        tokens = self.transform(expression).split()\n\n        for token in tokens:\n            if self.is_number(token):\n                output.append(token)\n            elif self.is_operator(token):\n                while (operators and operators[-1] in self.operator_priority and\n                       self.compare(token, operators[-1])):\n                    output.append(operators.pop())\n                operators.append(token)\n            elif token == '(':\n                operators.append(token)\n            elif token == ')':\n                while operators and operators[-1] != '(':\n                    output.append(operators.pop())\n                operators.pop()  # Remove the '('\n\n        while operators:\n            output.append(operators.pop())\n\n        self.postfix_stack = deque(output)\n\n    @staticmethod\n    def is_operator(c):\n        \"\"\"\n        Check if a character is an operator.\n        :param c: string, the character to be checked\n        :return: bool, True if the character is an operator, False otherwise\n        \"\"\"\n        return c in {'+', '-', '*', '/', '%'}\n\n    def compare(self, cur, peek):\n        \"\"\"\n        Compare the precedence of two operators.\n        :param cur: string, the current operator\n        :param peek: string, the operator at the top of the operator stack\n        :return: bool, True if the current operator has higher or equal precedence, False otherwise\n        \"\"\"\n        return self.operator_priority[cur] <= self.operator_priority[peek]\n\n    @staticmethod\n    def _calculate(first_value, second_value, current_op):\n        \"\"\"\n        Perform the mathematical calculation based on the given operands and operator.\n        :param first_value: string, the first operand\n        :param second_value: string, the second operand\n        :param current_op: string, the operator\n        :return: decimal.Decimal, the calculated result\n        \"\"\"\n        first_value = Decimal(first_value)\n        second_value = Decimal(second_value)\n        operations = {\n            '+': first_value + second_value,\n            '-': first_value - second_value,\n            '*': first_value * second_value,\n            '/': first_value / second_value,\n            '%': first_value % second_value\n        }\n        return operations.get(current_op, ValueError(f\"Invalid operator: {current_op}\"))\n\n    @staticmethod\n    def transform(expression):\n        \"\"\"\n        Transform the infix expression to a format suitable for conversion.\n        :param expression: string, the infix expression to be transformed\n        :return: string, the transformed expression\n        \"\"\"\n        return expression.replace(\" \", \"\")\n\n    @staticmethod\n    def is_number(token):\n        \"\"\"\n        Check if the token is a valid number (integer or decimal).\n        :param token: string, the token to check\n        :return: bool, True if the token is a number, False otherwise\n        \"\"\"\n        try:\n            Decimal(token)\n            return True\n        except (ValueError, InvalidOperation):\n            return False\n```",
    "35": "```python\nclass EightPuzzle:\n    \"\"\"\n    This class implements the classic 8-puzzle game, including methods for finding the blank tile,\n    making moves, getting possible moves, and solving the puzzle using a breadth-first search algorithm.\n    \"\"\"\n\n    def __init__(self, initial_state):\n        \"\"\"\n        Initialize the initial state of the Eight Puzzle Game and set the goal state.\n        :param initial_state: a 3x3 list of integers representing the initial state\n        \"\"\"\n        self.initial_state = initial_state\n        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n    def find_blank(self, state):\n        \"\"\"\n        Find the blank position (0) in the current state.\n        :param state: a 3x3 list of integers representing the current state\n        :return: tuple (i, j) representing the coordinates of the blank tile, or None if not found\n        \"\"\"\n        for i in range(3):\n            for j in range(3):\n                if state[i][j] == 0:\n                    return i, j\n        return None\n\n    def move(self, state, direction):\n        \"\"\"\n        Move the blank tile in the specified direction.\n        :param state: a 3x3 list of integers representing the current state\n        :param direction: str, one of 'up', 'down', 'left', 'right'\n        :return: new_state: a 3x3 list of integers representing the new state after the move\n        \"\"\"\n        blank_pos = self.find_blank(state)\n        if blank_pos is None:\n            return state\n        \n        i, j = blank_pos\n        new_state = [row[:] for row in state]  # Create a copy of the current state\n\n        if direction == 'up' and i > 0:\n            new_state[i][j], new_state[i - 1][j] = new_state[i - 1][j], new_state[i][j]\n        elif direction == 'down' and i < 2:\n            new_state[i][j], new_state[i + 1][j] = new_state[i + 1][j], new_state[i][j]\n        elif direction == 'left' and j > 0:\n            new_state[i][j], new_state[i][j - 1] = new_state[i][j - 1], new_state[i][j]\n        elif direction == 'right' and j < 2:\n            new_state[i][j], new_state[i][j + 1] = new_state[i][j + 1], new_state[i][j]\n\n        return new_state\n\n    def get_possible_moves(self, state):\n        \"\"\"\n        Get all possible moves for the current state.\n        :param state: a 3x3 list of integers representing the current state\n        :return: list of str representing possible moves\n        \"\"\"\n        moves = []\n        blank_pos = self.find_blank(state)\n        if blank_pos is None:\n            return moves\n        \n        i, j = blank_pos\n\n        if i > 0: moves.append('up')\n        if i < 2: moves.append('down')\n        if j > 0: moves.append('left')\n        if j < 2: moves.append('right')\n\n        return moves\n\n    def solve(self):\n        \"\"\"\n        Solve the puzzle using BFS algorithm.\n        :return: list of str representing the solution path to the goal state\n        \"\"\"\n        from collections import deque\n\n        open_list = deque([(self.initial_state, [])])\n        visited = {tuple(map(tuple, self.initial_state))}\n\n        while open_list:\n            current_state, path = open_list.popleft()\n\n            if current_state == self.goal_state:\n                return path\n\n            for move_direction in self.get_possible_moves(current_state):\n                new_state = self.move(current_state, move_direction)\n                state_tuple = tuple(map(tuple, new_state))\n\n                if state_tuple not in visited:\n                    visited.add(state_tuple)\n                    open_list.append((new_state, path + [move_direction]))\n\n        return []\n```",
    "40": "```python\nclass FitnessTracker:\n    \"\"\"\n    A class to track fitness metrics including BMI (Body Mass Index) and calorie intake based on user's height, weight, age, and sex.\n    \"\"\"\n\n    def __init__(self, height: float, weight: float, age: int, sex: str) -> None:\n        \"\"\"\n        Initialize the class with height, weight, age, and sex.\n        :param height: User's height in meters.\n        :param weight: User's weight in kilograms.\n        :param age: User's age in years.\n        :param sex: User's sex, either 'male' or 'female'.\n        \"\"\"\n        self.height = height\n        self.weight = weight\n        self.age = age\n        self.sex = sex.lower()\n        self.validate_inputs()\n\n    def validate_inputs(self) -> None:\n        \"\"\"Validate the input parameters.\"\"\"\n        if self.sex not in {\"male\", \"female\"}:\n            raise ValueError(\"Sex must be 'male' or 'female'.\")\n\n    def get_bmi(self) -> float:\n        \"\"\"\n        Calculate the BMI based on the height and weight.\n        :return: BMI as a float.\n        \"\"\"\n        return self.weight / (self.height ** 2)\n\n    def condition_judge(self) -> int:\n        \"\"\"\n        Judge the user's condition based on BMI standards.\n        :return: 1 if overweight, -1 if underweight, 0 if normal weight.\n        \"\"\"\n        bmi = self.get_bmi()\n        if self.sex == \"male\":\n            if bmi < 20:\n                return -1\n            elif bmi > 25:\n                return 1\n            return 0\n        else:  # self.sex == \"female\"\n            if bmi < 19:\n                return -1\n            elif bmi > 24:\n                return 1\n            return 0\n\n    def calculate_calorie_intake(self) -> float:\n        \"\"\"\n        Calculate the calorie intake based on the user's condition and BMR (Basal Metabolic Rate).\n        :return: Calorie intake as a float.\n        \"\"\"\n        bmr = self.calculate_bmr()\n        condition = self.condition_judge()\n\n        if condition == 1:  # Overweight\n            return bmr * 1.2\n        elif condition == -1:  # Underweight\n            return bmr * 1.6\n        return bmr * 1.4  # Normal weight\n\n    def calculate_bmr(self) -> float:\n        \"\"\"\n        Calculate the Basal Metabolic Rate (BMR) based on user's height, weight, age, and sex.\n        :return: BMR as a float.\n        \"\"\"\n        if self.sex == \"male\":\n            return 10 * self.weight + 6.25 * self.height * 100 - 5 * self.age + 5\n        return 10 * self.weight + 6.25 * self.height * 100 - 5 * self.age - 161\n```",
    "44": "```python\nimport re\nfrom bs4 import BeautifulSoup\n\nclass HtmlUtil:\n    \"\"\"\n    A utility class for formatting and extracting code from HTML text,\n    including cleaning up the text and converting certain elements into specific markers.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a series of labels.\n        \"\"\"\n        self.CODE_MARK = '-CODE-'\n\n    @staticmethod\n    def _format_line_feed(text):\n        \"\"\"\n        Replace consecutive line breaks with a single line break.\n        :param text: string with consecutive line breaks\n        :return: string, replaced text with single line break\n        \"\"\"\n        return re.sub(r'\\n+', '\\n', text).strip()\n\n    def format_line_html_text(self, html_text):\n        \"\"\"\n        Get the HTML text without the code, and add the code tag -CODE- where the code is.\n        :param html_text: string\n        :return: string\n        \"\"\"\n        soup = BeautifulSoup(html_text, 'html.parser')\n        text_parts = []\n\n        for element in soup.body.find_all(['h1', 'p', 'pre']):\n            if element.name in ['h1', 'p']:\n                text_parts.append(element.get_text(strip=True))\n            elif element.name == 'pre':\n                text_parts.append(self.CODE_MARK)\n\n        return self._format_line_feed('\\n'.join(text_parts))\n\n    def extract_code_from_html_text(self, html_text):\n        \"\"\"\n        Extract codes from the HTML body.\n        :param html_text: string, HTML text\n        :return: list of code\n        \"\"\"\n        soup = BeautifulSoup(html_text, 'html.parser')\n        code_snippets = []\n\n        for code in soup.find_all(['pre', 'code']):\n            code_snippets.append(code.get_text(strip=True))\n\n        return code_snippets\n```",
    "41": "```python\nclass GomokuGame:\n    \"\"\"\n    This class implements a Gomoku game, supporting moves, winner checks, and five consecutive symbols on the game board.\n    \"\"\"\n\n    def __init__(self, board_size):\n        \"\"\"\n        Initializes the game with a given board size.\n        It initializes the board with empty spaces and sets the current player symbol as 'X'.\n        \"\"\"\n        self.board_size = board_size\n        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Makes a move at the given row and column.\n        If the move is valid, it places the current player's symbol on the board\n        and changes the current player to the other player.\n        \n        :param row: int, the row index of this move\n        :param col: int, the column index\n        :return: True if the move is valid, False otherwise.\n        \"\"\"\n        if self._is_valid_move(row, col):\n            self.board[row][col] = self.current_player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        return False\n\n    def check_winner(self):\n        \"\"\"\n        Checks if there is a winner by looking for five in a row in all directions (horizontal, vertical, diagonal).\n        \n        :return: the symbol of the winning player (either 'X' or 'O') if there is a winner, None otherwise.\n        \"\"\"\n        for row in range(self.board_size):\n            for col in range(self.board_size):\n                if self.board[row][col] != ' ':\n                    if any(self._check_five_in_a_row(row, col, direction) for direction in [(1, 0), (0, 1), (1, 1), (1, -1)]):\n                        return self.board[row][col]\n        return None\n\n    def _check_five_in_a_row(self, row, col, direction):\n        \"\"\"\n        Checks if there are five consecutive symbols of the same player in a row starting from a given cell in a given direction.\n        \n        :param row: int, row of the given cell\n        :param col: int, column of the given cell\n        :param direction: tuple, (int, int), named as (dx, dy).\n        :return: True if there are five consecutive symbols of the same player, False otherwise.\n        \"\"\"\n        dx, dy = direction\n        count = 0\n        player_symbol = self.board[row][col]\n\n        for step in range(5):\n            new_row = row + step * dx\n            new_col = col + step * dy\n            if 0 <= new_row < self.board_size and 0 <= new_col < self.board_size:\n                if self.board[new_row][new_col] == player_symbol:\n                    count += 1\n                else:\n                    break\n            else:\n                break\n\n        return count == 5\n\n    def _is_valid_move(self, row, col):\n        \"\"\"\n        Checks if the move is valid (i.e., within bounds and on an empty cell).\n        \n        :param row: int, the row index of the move\n        :param col: int, the column index of the move\n        :return: True if the move is valid, False otherwise.\n        \"\"\"\n        return 0 <= row < self.board_size and 0 <= col < self.board_size and self.board[row][col] == ' '\n```",
    "47": "```python\nclass IPAddress:\n    \"\"\"\n    A class to process IP Addresses, including validation, retrieving octets, and obtaining the binary representation of a valid IP address.\n    \"\"\"\n\n    def __init__(self, ip_address: str):\n        \"\"\"\n        Initialize the IP address to the specified address.\n        :param ip_address: string\n        \"\"\"\n        self.ip_address = ip_address\n\n    def is_valid(self) -> bool:\n        \"\"\"\n        Validate the IP address format. It should consist of four decimal digits (0-255) separated by '.'.\n        :return: bool\n        \"\"\"\n        octets = self.ip_address.split('.')\n        if len(octets) != 4:\n            return False\n        for octet in octets:\n            if not octet.isdigit() or not (0 <= int(octet) <= 255):\n                return False\n        return True\n\n    def get_octets(self) -> list:\n        \"\"\"\n        Return a list of the four decimal numbers constituting the IP address if valid; otherwise, return an empty list.\n        :return: list\n        \"\"\"\n        return self.ip_address.split('.') if self.is_valid() else []\n\n    def get_binary(self) -> str:\n        \"\"\"\n        Return the binary representation of the IP address if valid; otherwise, return an empty string.\n        :return: string\n        \"\"\"\n        if self.is_valid():\n            return '.'.join(format(int(octet), '08b') for octet in self.get_octets())\n        return ''\n```",
    "45": "```python\nfrom PIL import Image, ImageEnhance\n\nclass ImageProcessor:\n    \"\"\"\n    A class to process images, including loading, saving, resizing, rotating, and adjusting brightness.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the image processor with no image loaded.\"\"\"\n        self.image = None\n\n    def load_image(self, image_path: str) -> None:\n        \"\"\"\n        Load an image from the specified path.\n        \n        :param image_path: str, path of the image to load.\n        \"\"\"\n        self.image = Image.open(image_path)\n\n    def save_image(self, save_path: str) -> None:\n        \"\"\"\n        Save the currently loaded image to the specified path.\n        \n        :param save_path: str, the path where the image will be saved.\n        \"\"\"\n        if self.image is not None:\n            self.image.save(save_path)\n\n    def resize_image(self, width: int, height: int) -> None:\n        \"\"\"\n        Resize the currently loaded image to the specified dimensions.\n        \n        :param width: int, the target width of the image.\n        :param height: int, the target height of the image.\n        \"\"\"\n        if self.image is not None:\n            self.image = self.image.resize((width, height))\n\n    def rotate_image(self, degrees: float) -> None:\n        \"\"\"\n        Rotate the currently loaded image by the specified degrees.\n        \n        :param degrees: float, the degrees to rotate the image.\n        \"\"\"\n        if self.image is not None:\n            self.image = self.image.rotate(degrees)\n\n    def adjust_brightness(self, factor: float) -> None:\n        \"\"\"\n        Adjust the brightness of the currently loaded image.\n        \n        :param factor: float, brightness factor (0.0 for black, 1.0 for original).\n        \"\"\"\n        if self.image is not None:\n            enhancer = ImageEnhance.Brightness(self.image)\n            self.image = enhancer.enhance(factor)\n```",
    "43": "```python\nclass HRManagementSystem:\n    \"\"\"\n    A personnel management system that implements functions such as adding, deleting, querying, and updating employees.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the HRManagementSystem with an empty dictionary for employees.\"\"\"\n        self.employees = {}\n\n    def add_employee(self, employee_id: int, name: str, position: str, department: str, salary: int) -> bool:\n        \"\"\"\n        Add a new employee to the HRManagementSystem.\n        \n        :param employee_id: The employee's id.\n        :param name: The employee's name.\n        :param position: The employee's position.\n        :param department: The employee's department.\n        :param salary: The employee's salary.\n        :return: True if the employee was added, False if the employee already exists.\n        \"\"\"\n        if employee_id in self.employees:\n            return False\n        self.employees[employee_id] = {\n            'name': name,\n            'position': position,\n            'department': department,\n            'salary': salary\n        }\n        return True\n\n    def remove_employee(self, employee_id: int) -> bool:\n        \"\"\"\n        Remove an employee from the HRManagementSystem.\n        \n        :param employee_id: The employee's id.\n        :return: True if the employee was removed, False if the employee does not exist.\n        \"\"\"\n        return self.employees.pop(employee_id, None) is not None\n\n    def update_employee(self, employee_id: int, employee_info: dict) -> bool:\n        \"\"\"\n        Update an employee's information in the HRManagementSystem.\n        \n        :param employee_id: The employee's id.\n        :param employee_info: A dictionary containing the employee's updated information.\n        :return: True if the employee was updated, False if the employee does not exist.\n        \"\"\"\n        if employee_id not in self.employees:\n            return False\n        self.employees[employee_id].update(employee_info)\n        return True\n\n    def get_employee(self, employee_id: int) -> dict:\n        \"\"\"\n        Get an employee's information from the HRManagementSystem.\n        \n        :param employee_id: The employee's id.\n        :return: The employee's information if found, otherwise None.\n        \"\"\"\n        return self.employees.get(employee_id)\n\n    def list_employees(self) -> dict:\n        \"\"\"\n        List all employees' information in the HRManagementSystem.\n        \n        :return: A dictionary of all employees' information with their IDs.\n        \"\"\"\n        return {emp_id: {**info, 'employee_ID': emp_id} for emp_id, info in self.employees.items()}\n```",
    "42": "```python\nclass Hotel:\n    \"\"\"\n    A class to manage hotel bookings, check-ins, check-outs, and room availability.\n    \"\"\"\n\n    def __init__(self, name, rooms):\n        \"\"\"\n        Initialize the hotel management system.\n        \n        :param name: str, the hotel name.\n        :param rooms: dict, available rooms in the hotel.\n        \"\"\"\n        self.name = name\n        self.available_rooms = rooms\n        self.booked_rooms = {}\n\n    def book_room(self, room_type, room_number, guest_name):\n        \"\"\"\n        Book a specified number of rooms for a guest.\n\n        :param room_type: str, type of room to book.\n        :param room_number: int, number of rooms to book.\n        :param guest_name: str, guest name.\n        :return: str or int or bool, booking status.\n        \"\"\"\n        if room_type not in self.available_rooms:\n            return False\n\n        available_count = self.available_rooms[room_type]\n\n        if room_number <= available_count:\n            self.available_rooms[room_type] -= room_number\n            self.booked_rooms.setdefault(room_type, {}).setdefault(guest_name, 0)\n            self.booked_rooms[room_type][guest_name] += room_number\n            return 'Success!'\n        else:\n            return available_count if available_count > 0 else False\n\n    def check_in(self, room_type, room_number, guest_name):\n        \"\"\"\n        Check in a guest for a specified number of rooms.\n\n        :param room_type: str, type of room to check in.\n        :param room_number: int, number of rooms to check in.\n        :param guest_name: str, guest name.\n        :return: bool, check-in status.\n        \"\"\"\n        if room_type not in self.booked_rooms or guest_name not in self.booked_rooms[room_type]:\n            return False\n\n        booked_count = self.booked_rooms[room_type][guest_name]\n\n        if room_number > booked_count:\n            return False\n\n        if room_number == booked_count:\n            del self.booked_rooms[room_type][guest_name]\n        else:\n            self.booked_rooms[room_type][guest_name] -= room_number\n\n        return True\n\n    def check_out(self, room_type, room_number):\n        \"\"\"\n        Check out a specified number of rooms.\n\n        :param room_type: str, type of room to check out.\n        :param room_number: int, number of rooms to check out.\n        \"\"\"\n        self.available_rooms[room_type] = self.available_rooms.get(room_type, 0) + room_number\n\n    def get_available_rooms(self, room_type):\n        \"\"\"\n        Get the number of available rooms of a specified type.\n\n        :param room_type: str, type of room to check.\n        :return: int, number of available rooms.\n        \"\"\"\n        return self.available_rooms.get(room_type, 0)\n```",
    "53": "```python\nimport re\n\nclass LongestWord:\n    \"\"\"\n    This class allows adding words to a list and finding the longest word in a given sentence \n    by comparing the words with those in the word list.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a list of words.\n        \"\"\"\n        self.word_list = []\n\n    def add_word(self, word: str):\n        \"\"\"\n        Append the input word into self.word_list.\n        :param word: str, input word\n        \"\"\"\n        if isinstance(word, str):\n            self.word_list.append(word)\n\n    def find_longest_word(self, sentence: str) -> str:\n        \"\"\"\n        Remove punctuation marks and split a sentence into a list of words. \n        Find the longest split word that is in the self.word_list.\n        Words are strictly case sensitive.\n        :param sentence: a sentence str\n        :return: str, longest split word that is in the self.word_list. \n                 Returns '' if self.word_list is empty.\n        \"\"\"\n        if not self.word_list:\n            return ''\n\n        # Remove punctuation and split the sentence into words\n        words = re.findall(r'\\b\\w+\\b', sentence)\n        longest_word = max((word for word in words if word in self.word_list), \n                           key=len, default='')\n\n        return longest_word\n```",
    "50": "```python\nimport json\nimport os\n\nclass JSONProcessor:\n    \"\"\"\n    This class processes JSON files, including reading, writing, and modifying JSON data.\n    \"\"\"\n\n    def read_json(self, file_path):\n        \"\"\"\n        Read a JSON file and return the data.\n\n        :param file_path: str, the path of the JSON file.\n        :return: dict or int, the data from the JSON file if read successfully, \n                -1 if an error occurs during the reading process, \n                0 if the file does not exist.\n        \"\"\"\n        if not os.path.isfile(file_path):\n            return 0\n        \n        try:\n            with open(file_path, 'r') as file:\n                return json.load(file)\n        except (json.JSONDecodeError, IOError):\n            return -1\n\n    def write_json(self, data, file_path):\n        \"\"\"\n        Write data to a JSON file and save it to the given path.\n\n        :param data: dict, the data to be written to the JSON file.\n        :param file_path: str, the path of the JSON file.\n        :return: int, 1 if the writing process is successful, \n                -1 if an error occurs during the writing process.\n        \"\"\"\n        if not isinstance(data, dict):\n            return -1\n        \n        try:\n            with open(file_path, 'w') as file:\n                json.dump(data, file, ensure_ascii=False, indent=4)\n            return 1\n        except (IOError, TypeError):\n            return -1\n\n    def process_json(self, file_path, remove_key):\n        \"\"\"\n        Read a JSON file and process the data by removing a specified key \n        and rewrite the modified data back to the file.\n\n        :param file_path: str, the path of the JSON file.\n        :param remove_key: str, the key to be removed.\n        :return: int, 1 if the specified key is successfully removed and \n                the data is written back, \n                0 if the file does not exist or the specified key does not exist in the data.\n        \"\"\"\n        data = self.read_json(file_path)\n        if data == 0:\n            return 0\n        \n        if isinstance(data, dict) and remove_key in data:\n            del data[remove_key]\n            return self.write_json(data, file_path)\n        \n        return 0\n```",
    "46": "```python\nclass Interpolation:\n    \"\"\"\n    A class that implements linear interpolation for one-dimensional and two-dimensional data.\n    \"\"\"\n\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        \"\"\"\n        Performs linear interpolation for one-dimensional data.\n\n        :param x: List of x-coordinates of the data points.\n        :param y: List of y-coordinates of the data points.\n        :param x_interp: List of x-coordinates for interpolation.\n        :return: List of interpolated y-coordinates.\n        \"\"\"\n        if not x or not y or not x_interp or len(x) != len(y):\n            return []\n\n        y_interp = []\n        for xi in x_interp:\n            if xi < x[0]:\n                # Extrapolate to the left\n                slope = (y[1] - y[0]) / (x[1] - x[0])\n                y_interp.append(y[0] + slope * (xi - x[0]))\n            elif xi > x[-1]:\n                # Extrapolate to the right\n                slope = (y[-1] - y[-2]) / (x[-1] - x[-2])\n                y_interp.append(y[-1] + slope * (xi - x[-1]))\n            else:\n                # Interpolate\n                for i in range(len(x) - 1):\n                    if x[i] <= xi <= x[i + 1]:\n                        slope = (y[i + 1] - y[i]) / (x[i + 1] - x[i])\n                        y_interp.append(y[i] + slope * (xi - x[i]))\n                        break\n\n        return y_interp\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        \"\"\"\n        Performs linear interpolation for two-dimensional data.\n\n        :param x: List of x-coordinates of the data points.\n        :param y: List of y-coordinates of the data points.\n        :param z: 2D list of z-coordinates of the data points.\n        :param x_interp: List of x-coordinates for interpolation.\n        :param y_interp: List of y-coordinates for interpolation.\n        :return: List of interpolated z-coordinates.\n        \"\"\"\n        if not x or not y or not z or not x_interp or not y_interp or len(x) != len(z[0]) or len(y) != len(z):\n            return []\n\n        z_interp = []\n        for xi, yi in zip(x_interp, y_interp):\n            if xi < x[0] or xi > x[-1] or yi < y[0] or yi > y[-1]:\n                z_interp.append(None)  # Out of bounds\n                continue\n\n            # Find the surrounding points for bilinear interpolation\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i + 1]:\n                    for j in range(len(y) - 1):\n                        if y[j] <= yi <= y[j + 1]:\n                            z11 = z[j][i]\n                            z12 = z[j + 1][i]\n                            z21 = z[j][i + 1]\n                            z22 = z[j + 1][i + 1]\n\n                            # Calculate weights\n                            weight_x = (xi - x[i]) / (x[i + 1] - x[i])\n                            weight_y = (yi - y[j]) / (y[j + 1] - y[j])\n\n                            # Perform bilinear interpolation\n                            z_interp_value = (z11 * (1 - weight_x) * (1 - weight_y) +\n                                              z21 * weight_x * (1 - weight_y) +\n                                              z12 * (1 - weight_x) * weight_y +\n                                              z22 * weight_x * weight_y)\n                            z_interp.append(z_interp_value)\n                            break\n                    break\n\n        return z_interp\n```",
    "51": "```python\nimport numpy as np\n\nclass KappaCalculator:\n    \"\"\"\n    This class calculates Cohen's and Fleiss' kappa coefficients.\n    \"\"\"\n\n    @staticmethod\n    def kappa(confusion_matrix):\n        \"\"\"\n        Calculate Cohen's kappa value from a confusion matrix.\n        \n        :param confusion_matrix: A square matrix representing the confusion matrix.\n        :return: float, the Cohen's kappa value.\n        \"\"\"\n        total = np.sum(confusion_matrix)\n        observed_agreement = np.sum(np.diag(confusion_matrix)) / total\n        expected_agreement = np.sum(np.sum(confusion_matrix, axis=0) ** 2) / (total ** 2)\n        \n        if expected_agreement == 1:\n            return 1.0  # Perfect agreement\n        if expected_agreement == 0:\n            return 0.0  # No agreement\n        \n        kappa_value = (observed_agreement - expected_agreement) / (1 - expected_agreement)\n        return kappa_value\n\n    @staticmethod\n    def fleiss_kappa(data_matrix, num_samples, num_categories, num_raters):\n        \"\"\"\n        Calculate Fleiss' kappa value from a data matrix.\n        \n        :param data_matrix: Input data matrix, shape (num_samples, num_categories).\n        :param num_samples: int, Number of samples.\n        :param num_categories: int, Number of categories.\n        :param num_raters: int, Number of raters.\n        :return: float, Fleiss' kappa value.\n        \"\"\"\n        p = np.sum(data_matrix, axis=0) / (num_samples * num_raters)\n        P_e = np.sum(p ** 2)\n        \n        P_o = np.sum(np.sum(data_matrix ** 2, axis=1) - num_raters) / (num_samples * num_raters * (num_raters - 1))\n        \n        if P_e == 1:\n            return 1.0  # Perfect agreement\n        if P_e == 0:\n            return 0.0  # No agreement\n        \n        fleiss_kappa_value = (P_o - P_e) / (1 - P_e)\n        return fleiss_kappa_value\n```",
    "52": "```python\nimport nltk\nfrom nltk.stem import WordNetLemmatizer\nfrom nltk import pos_tag, word_tokenize\nimport string\n\nnltk.download('averaged_perceptron_tagger')\nnltk.download('punkt')\nnltk.download('wordnet')\n\nclass Lemmatization:\n    \"\"\"\n    This class performs lemmatization and part-of-speech tagging on sentences, as well as removing punctuation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the WordNetLemmatizer.\n        \"\"\"\n        self.lemmatizer = WordNetLemmatizer()\n\n    def lemmatize_sentence(self, sentence):\n        \"\"\"\n        Lemmatizes the words in the input sentence based on their part of speech.\n        :param sentence: A sentence string.\n        :return: A list of lemmatized words.\n        \"\"\"\n        cleaned_sentence = self.remove_punctuation(sentence)\n        tokens = word_tokenize(cleaned_sentence)\n        pos_tags = self.get_pos_tag(tokens)\n\n        lemmatized_words = [\n            self.lemmatizer.lemmatize(token, self.get_wordnet_pos(pos)) \n            for token, pos in zip(tokens, pos_tags)\n        ]\n\n        return lemmatized_words\n\n    def get_pos_tag(self, tokens):\n        \"\"\"\n        Gets the part of speech tags for each word in the input tokens.\n        :param tokens: A list of word tokens.\n        :return: A list of part of speech tags.\n        \"\"\"\n        return [tag for _, tag in pos_tag(tokens)]\n\n    def remove_punctuation(self, sentence):\n        \"\"\"\n        Removes punctuation from the input text.\n        :param sentence: A sentence string.\n        :return: A string without punctuation.\n        \"\"\"\n        return sentence.translate(str.maketrans('', '', string.punctuation))\n\n    @staticmethod\n    def get_wordnet_pos(treebank_tag):\n        \"\"\"\n        Converts treebank tags to WordNet POS tags.\n        :param treebank_tag: A treebank part of speech tag.\n        :return: Corresponding WordNet POS tag.\n        \"\"\"\n        if treebank_tag.startswith('J'):\n            return 'a'  # Adjective\n        elif treebank_tag.startswith('V'):\n            return 'v'  # Verb\n        elif treebank_tag.startswith('N'):\n            return 'n'  # Noun\n        elif treebank_tag.startswith('R'):\n            return 'r'  # Adverb\n        else:\n            return 'n'  # Default to noun if no match\n```",
    "48": "```python\nimport socket\nimport re\n\n\nclass IpUtil:\n    \"\"\"\n    A utility class for IP address operations, including validation and hostname retrieval.\n    \"\"\"\n\n    @staticmethod\n    def is_valid_ipv4(ip_address: str) -> bool:\n        \"\"\"\n        Check if the given IP address is a valid IPv4 address.\n        :param ip_address: string, the IP address to check\n        :return: bool, True if the IP address is valid, False otherwise\n        \"\"\"\n        pattern = r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'\n        return bool(re.match(pattern, ip_address))\n\n    @staticmethod\n    def is_valid_ipv6(ip_address: str) -> bool:\n        \"\"\"\n        Check if the given IP address is a valid IPv6 address.\n        :param ip_address: string, the IP address to check\n        :return: bool, True if the IP address is valid, False otherwise\n        \"\"\"\n        pattern = (\n            r'^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|'\n            r'(?:[0-9a-fA-F]{1,4}:){1,7}:|'\n            r'(?:[0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|'\n            r'(?:[0-9a-fA-F]{1,4}:){1,5}(?::[0-9a-fA-F]{1,4}){1,2}|'\n            r'(?:[0-9a-fA-F]{1,4}:){1,4}(?::[0-9a-fA-F]{1,4}){1,3}|'\n            r'(?:[0-9a-fA-F]{1,4}:){1,3}(?::[0-9a-fA-F]{1,4}){1,4}|'\n            r'(?:[0-9a-fA-F]{1,4}:){1,2}(?::[0-9a-fA-F]{1,4}){1,5}|'\n            r'[0-9a-fA-F]{1,4}:(?::[0-9a-fA-F]{1,4}){1,6}|'\n            r':(?::[0-9a-fA-F]{1,4}){1,7}|::|'\n            r'(?:[0-9a-fA-F]{1,4}:){1,6}:$'\n        )\n        return bool(re.match(pattern, ip_address))\n\n    @staticmethod\n    def get_hostname(ip_address: str) -> str:\n        \"\"\"\n        Get the hostname associated with the given IP address.\n        :param ip_address: string, the IP address to get the hostname for\n        :return: string, the hostname associated with the IP address or None if not resolvable\n        \"\"\"\n        try:\n            return socket.gethostbyaddr(ip_address)[0]\n        except socket.herror:\n            return None\n```",
    "55": "```python\nclass Manacher:\n    \"\"\"\n    This class implements the Manacher algorithm to find the longest palindromic substring in a given string.\n    \"\"\"\n\n    def __init__(self, input_string: str) -> None:\n        \"\"\"\n        Initializes the Manacher class with the given input_string.\n        :param input_string: The input string to be searched.\n        \"\"\"\n        self.input_string = input_string\n        self.processed_string = self._preprocess_string(input_string)\n        self.palindrome_lengths = [0] * len(self.processed_string)\n\n    def _preprocess_string(self, string: str) -> str:\n        \"\"\"\n        Preprocesses the input string to insert separators for uniform palindrome length calculation.\n        :param string: The original input string.\n        :return: The processed string with separators.\n        \"\"\"\n        return '|' + '|'.join(string) + '|'\n\n    def _expand_around_center(self, center: int, diff: int) -> int:\n        \"\"\"\n        Expands around the given center and difference to find the length of the palindromic substring.\n        :param center: The center of the palindromic substring.\n        :param diff: The difference between the center and the current position.\n        :return: The length of the palindromic substring.\n        \"\"\"\n        left = center - diff\n        right = center + diff\n        while left >= 0 and right < len(self.processed_string) and self.processed_string[left] == self.processed_string[right]:\n            left -= 1\n            right += 1\n        return (right - left - 1) // 2\n\n    def find_longest_palindromic_substring(self) -> str:\n        \"\"\"\n        Finds the longest palindromic substring in the given string.\n        :return: The longest palindromic substring.\n        \"\"\"\n        max_length = 0\n        start_index = 0\n\n        for i in range(len(self.processed_string)):\n            length = self._expand_around_center(i, 0)\n            self.palindrome_lengths[i] = length\n\n            if length > max_length:\n                max_length = length\n                start_index = i - length\n\n        # Extract the longest palindromic substring from the original string\n        start = (start_index - max_length) // 2\n        return self.input_string[start:start + max_length]\n```",
    "54": "```python\nimport random\n\nclass MahjongConnect:\n    \"\"\"\n    MahjongConnect is a class representing a game board for Mahjong Connect with features like creating the board, checking valid moves, finding paths, removing icons, and checking if the game is over.\n    \"\"\"\n\n    def __init__(self, board_size, icons):\n        \"\"\"\n        Initialize the board size and the icon list, create the game board.\n        :param board_size: list of two integer numbers, representing the number of rows and columns of the game board\n        :param icons: list of string, representing the icons\n        \"\"\"\n        self.board_size = board_size\n        self.icons = icons\n        self.board = self.create_board()\n\n    def create_board(self):\n        \"\"\"\n        Create the game board with the given board size and icons.\n        :return: 2-dimensional list, the game board\n        \"\"\"\n        rows, cols = self.board_size\n        total_icons = rows * cols // 2\n        selected_icons = random.sample(self.icons, total_icons)\n        icons = selected_icons * 2  # Duplicate icons for pairs\n        random.shuffle(icons)  # Shuffle icons for random placement\n\n        return [icons[i * cols:(i + 1) * cols] for i in range(rows)]\n\n    def is_valid_move(self, pos1, pos2):\n        \"\"\"\n        Check if the move of two icons is valid.\n        :param pos1: position tuple(x, y) of the first icon\n        :param pos2: position tuple(x, y) of the second icon\n        :return: True or False, representing whether the move of two icons is valid\n        \"\"\"\n        if pos1 == pos2:\n            return False\n        if not self._is_within_bounds(pos1) or not self._is_within_bounds(pos2):\n            return False\n        if self.board[pos1[0]][pos1[1]] != self.board[pos2[0]][pos2[1]]:\n            return False\n        return self.has_path(pos1, pos2)\n\n    def has_path(self, pos1, pos2):\n        \"\"\"\n        Check if there is a path between two icons.\n        :param pos1: position tuple(x, y) of the first icon\n        :param pos2: position tuple(x, y) of the second icon\n        :return: True or False, representing whether there is a path between two icons\n        \"\"\"\n        # Implement pathfinding logic here (e.g., BFS or DFS)\n        return True  # Placeholder for actual pathfinding logic\n\n    def remove_icons(self, pos1, pos2):\n        \"\"\"\n        Remove the connected icons on the game board.\n        :param pos1: position tuple(x, y) of the first icon to be removed\n        :param pos2: position tuple(x, y) of the second icon to be removed\n        \"\"\"\n        self.board[pos1[0]][pos1[1]] = ' '\n        self.board[pos2[0]][pos2[1]] = ' '\n\n    def is_game_over(self):\n        \"\"\"\n        Check if the game is over (i.e., if there are no more icons on the game board).\n        :return: True or False, representing whether the game is over\n        \"\"\"\n        return all(icon == ' ' for row in self.board for icon in row)\n\n    def _is_within_bounds(self, pos):\n        \"\"\"\n        Check if the position is within the bounds of the board.\n        :param pos: position tuple(x, y)\n        :return: True if within bounds, False otherwise\n        \"\"\"\n        x, y = pos\n        return 0 <= x < self.board_size[0] and 0 <= y < self.board_size[1]\n```",
    "62": "```python\nclass NLPDataProcessor:\n    \"\"\"\n    The class processes NLP data by removing stop words from a list of strings using a pre-defined stop word list.\n    \"\"\"\n\n    @staticmethod\n    def construct_stop_word_list():\n        \"\"\"\n        Construct a stop word list including 'a', 'an', 'the'.\n        :return: a list of stop words\n        \"\"\"\n        return ['a', 'an', 'the']\n\n    def remove_stop_words(self, string_list, stop_word_list):\n        \"\"\"\n        Remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :param stop_word_list: a list of stop words\n        :return: a list of lists containing words without stop words\n        \"\"\"\n        stop_word_set = set(word.lower() for word in stop_word_list)\n        return [\n            [word for word in string.split() if word.lower() not in stop_word_set]\n            for string in string_list\n        ]\n\n    def process(self, string_list):\n        \"\"\"\n        Construct a stop word list and remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :return: a list of lists containing words without stop words\n        \"\"\"\n        stop_word_list = self.construct_stop_word_list()\n        return self.remove_stop_words(string_list, stop_word_list)\n```",
    "56": "```python\nclass MetricsCalculator:\n    \"\"\"\n    The class calculates precision, recall, F1 score, and accuracy based on predicted and true labels.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the counts for true positives, false positives, false negatives, and true negatives to 0.\n        \"\"\"\n        self.reset_metrics()\n\n    def reset_metrics(self):\n        \"\"\"Reset all metrics to zero.\"\"\"\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n    def update(self, predicted_labels, true_labels):\n        \"\"\"\n        Update the counts of true positives, false positives, false negatives, and true negatives.\n        \n        :param predicted_labels: list of predicted results (0 or 1)\n        :param true_labels: list of true labels (0 or 1)\n        \"\"\"\n        self.reset_metrics()  # Reset metrics before updating\n        for predicted, true in zip(predicted_labels, true_labels):\n            if predicted == 1 and true == 1:\n                self.true_positives += 1\n            elif predicted == 1 and true == 0:\n                self.false_positives += 1\n            elif predicted == 0 and true == 1:\n                self.false_negatives += 1\n            elif predicted == 0 and true == 0:\n                self.true_negatives += 1\n\n    def precision(self):\n        \"\"\"\n        Calculate precision based on the current counts.\n        \n        :return: float precision value\n        \"\"\"\n        total_predicted_positive = self.true_positives + self.false_positives\n        return self.true_positives / total_predicted_positive if total_predicted_positive > 0 else 0.0\n\n    def recall(self):\n        \"\"\"\n        Calculate recall based on the current counts.\n        \n        :return: float recall value\n        \"\"\"\n        total_actual_positive = self.true_positives + self.false_negatives\n        return self.true_positives / total_actual_positive if total_actual_positive > 0 else 0.0\n\n    def f1_score(self):\n        \"\"\"\n        Calculate F1 score, which is the harmonic mean of precision and recall.\n        \n        :return: float F1 score\n        \"\"\"\n        precision_value = self.precision()\n        recall_value = self.recall()\n        return (2 * precision_value * recall_value / (precision_value + recall_value)) if (precision_value + recall_value) > 0 else 0.0\n\n    def accuracy(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate accuracy based on predicted and true labels.\n        \n        :param predicted_labels: list of predicted results (0 or 1)\n        :param true_labels: list of true labels (0 or 1)\n        :return: float accuracy value\n        \"\"\"\n        if not predicted_labels or not true_labels:\n            return 0.0\n        correct_predictions = sum(p == t for p, t in zip(predicted_labels, true_labels))\n        return correct_predictions / len(true_labels)\n```",
    "57": "```python\nimport numpy as np\n\n\nclass MetricsCalculator:\n    \"\"\"\n    The class provides methods to calculate Mean Reciprocal Rank (MRR) and Mean Average Precision (MAP) based on input data.\n    MRR measures the ranking quality, while MAP measures the average precision.\n    \"\"\"\n\n    @staticmethod\n    def mrr(data):\n        \"\"\"\n        Compute the MRR of the input data. MRR is the mean of reciprocal rank.\n        :param data: A tuple or list of tuples where each tuple contains (actual results, ground truth count).\n        :return: A tuple containing the MRR and a list of reciprocal ranks for each input.\n        \"\"\"\n        if not isinstance(data, (list, tuple)):\n            raise ValueError(\"Input data must be a list or tuple.\")\n\n        if isinstance(data, tuple):\n            data = [data]\n\n        reciprocal_ranks = []\n        for actual, ground_truth_count in data:\n            if ground_truth_count == 0:\n                reciprocal_ranks.append(0.0)\n                continue\n            \n            rank = next((i + 1 for i, value in enumerate(actual) if value == 1), None)\n            reciprocal_rank = 1 / rank if rank is not None else 0.0\n            reciprocal_ranks.append(reciprocal_rank)\n\n        mrr_value = np.mean(reciprocal_ranks) if reciprocal_ranks else 0.0\n        return mrr_value, reciprocal_ranks\n\n    @staticmethod\n    def map(data):\n        \"\"\"\n        Compute the MAP of the input data. MAP is the mean of average precision (AP).\n        :param data: A tuple or list of tuples where each tuple contains (actual results, ground truth count).\n        :return: A tuple containing the MAP and a list of average precision for each input.\n        \"\"\"\n        if not isinstance(data, (list, tuple)):\n            raise ValueError(\"Input data must be a list or tuple.\")\n\n        if isinstance(data, tuple):\n            data = [data]\n\n        average_precisions = []\n        for actual, ground_truth_count in data:\n            if ground_truth_count == 0:\n                average_precisions.append(0.0)\n                continue\n            \n            correct_count = 0\n            precision_sum = 0.0\n            \n            for i, value in enumerate(actual):\n                if value == 1:\n                    correct_count += 1\n                    precision_sum += correct_count / (i + 1)\n\n            average_precision = precision_sum / ground_truth_count if ground_truth_count > 0 else 0.0\n            average_precisions.append(average_precision)\n\n        map_value = np.mean(average_precisions) if average_precisions else 0.0\n        return map_value, average_precisions\n```",
    "49": "```python\nclass JobMarketplace:\n    \"\"\"\n    A class that provides functionalities to publish positions, remove positions, submit resumes, withdraw resumes,\n    search for positions, and obtain candidate information.\n    \"\"\"\n\n    def __init__(self):\n        self.job_listings = []\n        self.resumes = []\n\n    def post_job(self, job_title: str, company: str, requirements: list):\n        \"\"\"\n        Publish a job position and add it to the job_listings.\n        \n        :param job_title: The title of the position.\n        :param company: The company offering the position.\n        :param requirements: The skills required for the position.\n        \"\"\"\n        job = {\n            'job_title': job_title,\n            'company': company,\n            'requirements': requirements\n        }\n        self.job_listings.append(job)\n\n    def remove_job(self, job: dict):\n        \"\"\"\n        Remove a job position from the job_listings.\n        \n        :param job: The job information to be removed.\n        \"\"\"\n        self.job_listings = [j for j in self.job_listings if j != job]\n\n    def submit_resume(self, name: str, skills: list, experience: str):\n        \"\"\"\n        Submit a resume and add it to the resumes list.\n        \n        :param name: The name of the candidate.\n        :param skills: The skills of the candidate.\n        :param experience: The experience of the candidate.\n        \"\"\"\n        resume = {\n            'name': name,\n            'skills': skills,\n            'experience': experience\n        }\n        self.resumes.append(resume)\n\n    def withdraw_resume(self, resume: dict):\n        \"\"\"\n        Withdraw a resume and remove it from the resumes list.\n        \n        :param resume: The resume information to be removed.\n        \"\"\"\n        self.resumes = [r for r in self.resumes if r != resume]\n\n    def search_jobs(self, criteria: str):\n        \"\"\"\n        Search for job positions that match the given criteria.\n        \n        :param criteria: The skill or requirement to search for.\n        :return: A list of job positions that match the criteria.\n        \"\"\"\n        return [job for job in self.job_listings if criteria in job['requirements']]\n\n    def get_job_applicants(self, job: dict):\n        \"\"\"\n        Get candidates who match the requirements of a specific job.\n        \n        :param job: The job information.\n        :return: A list of candidates who meet the job requirements.\n        \"\"\"\n        return [resume for resume in self.resumes if self.matches_requirements(resume, job['requirements'])]\n\n    def matches_requirements(self, resume: dict, requirements: list) -> bool:\n        \"\"\"\n        Check if a resume matches the job requirements.\n        \n        :param resume: The resume information.\n        :param requirements: The job requirements.\n        :return: True if the resume matches the requirements, False otherwise.\n        \"\"\"\n        return all(skill in resume['skills'] for skill in requirements)\n```",
    "63": "```python\nimport re\nfrom collections import Counter\n\nclass NLPDataProcessor:\n    \"\"\"\n    The class processes NLP data by extracting words from a list of strings, calculating the frequency of each word, \n    and returning the top 5 most frequent words.\n    \"\"\"\n\n    def process_data(self, string_list):\n        \"\"\"\n        Keep only English letters and spaces in the string, convert to lower case, and split into a list of words.\n        :param string_list: a list of strings\n        :return: words_list: a list of words lists\n        \"\"\"\n        words_list = [\n            re.sub(r'[^a-zA-Z\\s]', '', string).lower().split()\n            for string in string_list\n        ]\n        return words_list\n\n    def calculate_word_frequency(self, words_list):\n        \"\"\"\n        Calculate the word frequency of each word in the list of words lists, and return the top 5 most common words.\n        :param words_list: a list of words lists\n        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency\n        \"\"\"\n        word_counter = Counter(word for words in words_list for word in words)\n        return dict(word_counter.most_common(5))\n\n    def process(self, string_list):\n        \"\"\"\n        Process the input strings to extract words and calculate their frequencies.\n        :param string_list: a list of strings\n        :return: top 5 word frequency dictionary\n        \"\"\"\n        words_list = self.process_data(string_list)\n        return self.calculate_word_frequency(words_list)\n```",
    "60": "```python\nimport sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This class handles movie ticket database operations, including inserting, searching, and deleting ticket information.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.\n        :return: None\n        \"\"\"\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS tickets (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                movie_name TEXT NOT NULL,\n                theater_name TEXT NOT NULL,\n                seat_number TEXT NOT NULL,\n                customer_name TEXT NOT NULL\n            )\n        ''')\n        self.connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        self.cursor.execute('''\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n            VALUES (?, ?, ?, ?)\n        ''', (movie_name, theater_name, seat_number, customer_name))\n        self.connection.commit()\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        \"\"\"\n        self.cursor.execute('''\n            SELECT * FROM tickets WHERE customer_name = ?\n        ''', (customer_name,))\n        return self.cursor.fetchall()\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"\n        self.cursor.execute('''\n            DELETE FROM tickets WHERE id = ?\n        ''', (ticket_id,))\n        self.connection.commit()\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        :return: None\n        \"\"\"\n        self.connection.close()\n```",
    "58": "```python\nimport random\n\nclass MinesweeperGame:\n    \"\"\"\n    This class implements a Minesweeper game, including mine placement, sweeping, and win checking.\n    \"\"\"\n\n    def __init__(self, n: int, k: int) -> None:\n        \"\"\"\n        Initializes the MinesweeperGame class with the size of the board and the number of mines.\n        :param n: The size of the board (n x n).\n        :param k: The number of mines.\n        \"\"\"\n        self.n = n\n        self.k = k\n        self.minesweeper_map = self._generate_mine_sweeper_map()\n        self.player_map = self._generate_player_map()\n        self.score = 0\n\n    def _generate_mine_sweeper_map(self) -> list:\n        \"\"\"\n        Generates a minesweeper map with the specified size and number of mines.\n        :return: The minesweeper map as a 2D list.\n        \"\"\"\n        board = [['0' for _ in range(self.n)] for _ in range(self.n)]\n        mines = set()\n\n        while len(mines) < self.k:\n            x, y = random.randint(0, self.n - 1), random.randint(0, self.n - 1)\n            if (x, y) not in mines:\n                mines.add((x, y))\n                board[x][y] = 'X'\n                self._update_adjacent_cells(board, x, y)\n\n        return board\n\n    def _update_adjacent_cells(self, board: list, x: int, y: int) -> None:\n        \"\"\"\n        Updates the adjacent cells around a mine.\n        :param board: The current minesweeper board.\n        :param x: The x coordinate of the mine.\n        :param y: The y coordinate of the mine.\n        \"\"\"\n        for i in range(max(0, x - 1), min(self.n, x + 2)):\n            for j in range(max(0, y - 1), min(self.n, y + 2)):\n                if board[i][j] != 'X':\n                    board[i][j] = str(int(board[i][j]) + 1)\n\n    def _generate_player_map(self) -> list:\n        \"\"\"\n        Generates a player map with the specified size.\n        :return: The player map as a 2D list.\n        \"\"\"\n        return [['-' for _ in range(self.n)] for _ in range(self.n)]\n\n    def check_won(self) -> bool:\n        \"\"\"\n        Checks whether the player has won the game.\n        :return: True if the player has won, False otherwise.\n        \"\"\"\n        for i in range(self.n):\n            for j in range(self.n):\n                if self.player_map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':\n                    return False\n        return True\n\n    def sweep(self, x: int, y: int):\n        \"\"\"\n        Sweeps the specified position.\n        :param x: The x coordinate of the position.\n        :param y: The y coordinate of the position.\n        :return: True if the player has won, False if a mine was hit, or the current player map if the game continues.\n        \"\"\"\n        if self.minesweeper_map[x][y] == 'X':\n            return False  # Hit a mine\n\n        self.player_map[x][y] = self.minesweeper_map[x][y]\n        self.score += 1\n\n        if self.check_won():\n            return True\n\n        return self.player_map\n```",
    "66": "```python\nimport re\n\nclass NumericEntityUnescaper:\n    \"\"\"\n    This class provides functionality to replace numeric entities with their corresponding characters in a given string.\n    \"\"\"\n\n    def replace(self, string: str) -> str:\n        \"\"\"\n        Replaces numeric character references (HTML entities) in the input string with their corresponding Unicode characters.\n        \n        :param string: str, the input string containing numeric character references.\n        :return: str, the input string with numeric character references replaced with their corresponding Unicode characters.\n        \"\"\"\n        def replace_entity(match):\n            entity = match.group(0)\n            try:\n                if entity.startswith(\"&#X\") or entity.startswith(\"&#x\"):\n                    code_point = int(entity[3:-1], 16)\n                else:\n                    code_point = int(entity[2:-1])\n                return chr(code_point)\n            except (ValueError, IndexError):\n                return entity  # Return the original entity if it cannot be converted\n\n        return re.sub(r'&#[Xx]?[0-9a-fA-F]+;|&#\\d+;', replace_entity, string)\n\n    @staticmethod\n    def is_hex_char(char: str) -> bool:\n        \"\"\"\n        Determines whether a given character is a hexadecimal digit.\n        \n        :param char: str, the character to check.\n        :return: bool, True if the character is a hexadecimal digit, False otherwise.\n        \"\"\"\n        return char.lower() in '0123456789abcdef'\n```",
    "59": "```python\nfrom datetime import datetime\nimport numpy as np\n\nclass MovieBookingSystem:\n    \"\"\"\n    A class representing a movie booking system, which allows adding movies, booking tickets,\n    and checking available movies within a given time range.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the movie booking system with an empty movie list.\"\"\"\n        self.movies = []\n\n    def add_movie(self, name: str, price: float, start_time: str, end_time: str, n: int):\n        \"\"\"\n        Add a new movie to the system.\n        \n        :param name: str, movie name\n        :param price: float, price for one ticket\n        :param start_time: str, start time in HH:MM format\n        :param end_time: str, end time in HH:MM format\n        :param n: int, the size of seats (n x n)\n        \"\"\"\n        start_time_dt = self._parse_time(start_time)\n        end_time_dt = self._parse_time(end_time)\n\n        if start_time_dt >= end_time_dt:\n            raise ValueError(\"End time must be after start time.\")\n\n        seats = np.zeros((n, n), dtype=int)\n\n        movie = {\n            'name': name,\n            'price': price,\n            'start_time': start_time_dt,\n            'end_time': end_time_dt,\n            'seats': seats\n        }\n        self.movies.append(movie)\n\n    def book_ticket(self, name: str, seats_to_book: list):\n        \"\"\"\n        Book tickets for a movie. Update the seats if booking is successful.\n        \n        :param name: str, movie name\n        :param seats_to_book: list of tuples, representing seats to book [(row1, col1), (row2, col2), ...]\n        :return: str, booking status message\n        \"\"\"\n        movie = self._find_movie(name)\n        if not movie:\n            return 'Movie not found.'\n\n        if not self._are_seats_available(movie['seats'], seats_to_book):\n            return 'Booking failed.'\n\n        self._book_seats(movie['seats'], seats_to_book)\n        return 'Booking success.'\n\n    def available_movies(self, start_time: str, end_time: str):\n        \"\"\"\n        Get a list of available movies within the specified time range.\n        \n        :param start_time: str, start time in HH:MM format\n        :param end_time: str, end time in HH:MM format\n        :return: list of str, names of available movies\n        \"\"\"\n        start_time_dt = self._parse_time(start_time)\n        end_time_dt = self._parse_time(end_time)\n        return [\n            movie['name'] for movie in self.movies\n            if movie['start_time'] >= start_time_dt and movie['end_time'] <= end_time_dt\n        ]\n\n    def _find_movie(self, name: str):\n        \"\"\"Helper method to find a movie by name.\"\"\"\n        return next((movie for movie in self.movies if movie['name'].lower() == name.lower()), None)\n\n    def _parse_time(self, time_str: str) -> datetime:\n        \"\"\"Convert a time string in HH:MM format to a datetime object.\"\"\"\n        return datetime.strptime(time_str, '%H:%M')\n\n    def _are_seats_available(self, seats: np.ndarray, seats_to_book: list) -> bool:\n        \"\"\"Check if the requested seats are available.\"\"\"\n        return all(seats[row, col] == 0 for row, col in seats_to_book)\n\n    def _book_seats(self, seats: np.ndarray, seats_to_book: list):\n        \"\"\"Mark the requested seats as booked.\"\"\"\n        for row, col in seats_to_book:\n            seats[row, col] = 1\n```",
    "68": "```python\nclass PageUtil:\n    \"\"\"\n    PageUtil class is a versatile utility for handling pagination and search functionalities in an efficient and convenient manner.\n    \"\"\"\n\n    def __init__(self, data, page_size):\n        \"\"\"\n        Initialize the PageUtil object with the given data and page size.\n        :param data: list, the data to be paginated\n        :param page_size: int, the number of items per page\n        \"\"\"\n        self.data = data\n        self.page_size = page_size\n        self.total_items = len(data)\n        self.total_pages = (self.total_items + page_size - 1) // page_size\n\n    def get_page(self, page_number):\n        \"\"\"\n        Retrieve a specific page of data.\n        :param page_number: int, the page number to fetch\n        :return: list, the data on the specified page\n        \"\"\"\n        if not self._is_valid_page_number(page_number):\n            return []\n        \n        start_index = (page_number - 1) * self.page_size\n        end_index = start_index + self.page_size\n        return self.data[start_index:end_index]\n\n    def get_page_info(self, page_number):\n        \"\"\"\n        Retrieve information about a specific page.\n        :param page_number: int, the page number to fetch information about\n        :return: dict, containing page information such as current page number, total pages, etc.\n        \"\"\"\n        if not self._is_valid_page_number(page_number):\n            return {}\n\n        page_data = self.get_page(page_number)\n        return {\n            \"current_page\": page_number,\n            \"per_page\": self.page_size,\n            \"total_pages\": self.total_pages,\n            \"total_items\": self.total_items,\n            \"has_previous\": page_number > 1,\n            \"has_next\": page_number < self.total_pages,\n            \"data\": page_data\n        }\n\n    def search(self, keyword):\n        \"\"\"\n        Search for items in the data that contain the given keyword.\n        :param keyword: str, the keyword to search for\n        :return: dict, containing search information such as total results and matching items\n        \"\"\"\n        results = [item for item in self.data if keyword in str(item)]\n        total_results = len(results)\n        total_pages = (total_results + self.page_size - 1) // self.page_size\n\n        return {\n            \"keyword\": keyword,\n            \"total_results\": total_results,\n            \"total_pages\": total_pages,\n            \"results\": results\n        }\n\n    def _is_valid_page_number(self, page_number):\n        \"\"\"\n        Check if the provided page number is valid.\n        :param page_number: int, the page number to validate\n        :return: bool, True if valid, False otherwise\n        \"\"\"\n        return 1 <= page_number <= self.total_pages\n```",
    "69": "```python\nimport PyPDF2\n\nclass PDFHandler:\n    \"\"\"\n    The class allows merging multiple PDF files into one and extracting text from PDFs using PyPDF2 library.\n    \"\"\"\n\n    def __init__(self, filepaths):\n        \"\"\"\n        Initializes the PDFHandler with a list of file paths.\n        :param filepaths: list of str, paths to PDF files\n        \"\"\"\n        self.filepaths = filepaths\n        self.readers = self._initialize_readers(filepaths)\n\n    def _initialize_readers(self, filepaths):\n        \"\"\"\n        Creates a list of PdfFileReader objects for each file.\n        :param filepaths: list of str, paths to PDF files\n        :return: list of PdfFileReader objects\n        \"\"\"\n        readers = []\n        for fp in filepaths:\n            try:\n                reader = PyPDF2.PdfFileReader(fp)\n                readers.append(reader)\n            except Exception as e:\n                print(f\"Error reading {fp}: {e}\")\n        return readers\n\n    def merge_pdfs(self, output_filepath):\n        \"\"\"\n        Merges multiple PDF files into a single PDF file.\n        :param output_filepath: str, output file path to save the merged PDF\n        :return: str, confirmation message if successfully merged\n        \"\"\"\n        merger = PyPDF2.PdfFileMerger()\n        for reader in self.readers:\n            merger.append(reader)\n        merger.write(output_filepath)\n        merger.close()\n        return f\"Merged PDFs saved at {output_filepath}\"\n\n    def extract_text_from_pdfs(self):\n        \"\"\"\n        Extracts text from each PDF file.\n        :return: list of str, each element is the text of one PDF file\n        \"\"\"\n        pdf_texts = []\n        for reader in self.readers:\n            text = self._extract_text_from_reader(reader)\n            pdf_texts.append(text)\n        return pdf_texts\n\n    def _extract_text_from_reader(self, reader):\n        \"\"\"\n        Extracts text from a single PdfFileReader object.\n        :param reader: PdfFileReader object\n        :return: str, extracted text\n        \"\"\"\n        text = \"\"\n        for page in range(reader.numPages):\n            text += reader.getPage(page).extractText()\n        return text\n```",
    "67": "```python\nclass Order:\n    \"\"\"\n    The class manages restaurant orders by allowing the addition of dishes, calculation of the total cost, and checkout.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the order management system.\n        self.menu stores the dishes of restaurant inventory.\n        self.selected_dishes stores the dishes selected by customer.\n        self.sales stores the sales of each dish.\n        \"\"\"\n        self.menu = []\n        self.selected_dishes = []\n        self.sales = {}\n\n    def add_dish(self, dish):\n        \"\"\"\n        Add a dish to the selected dishes if the count is valid.\n        If the dish has been successfully added, update the count in the menu.\n        \n        :param dish: dict, the information of dish. \n                     dish = {\"dish\": dish name, \"count\": count, \"price\": price}\n        :return: True if successfully added, or False otherwise.\n        \"\"\"\n        for menu_item in self.menu:\n            if menu_item[\"dish\"] == dish[\"dish\"]:\n                if menu_item[\"count\"] >= dish[\"count\"]:\n                    menu_item[\"count\"] -= dish[\"count\"]\n                    self.selected_dishes.append(dish)\n                    return True\n                break\n        return False\n\n    def calculate_total(self):\n        \"\"\"\n        Calculate the total price of dishes that have been ordered.\n        \n        :return: float, the final total price.\n        \"\"\"\n        total = 0.0\n        for selected in self.selected_dishes:\n            discount = self.sales.get(selected[\"dish\"], 1)\n            total += selected[\"price\"] * selected[\"count\"] * discount\n        return total\n\n    def checkout(self):\n        \"\"\"\n        Check out the dishes ordered. If the selected dishes are not empty, calculate the total.\n        \n        :return: False if the selected dishes are empty, or the total otherwise.\n        \"\"\"\n        if not self.selected_dishes:\n            return False\n        total = self.calculate_total()\n        self.selected_dishes.clear()  # Clear selected dishes after checkout\n        return total\n```",
    "70": "```python\nclass PersonRequest:\n    \"\"\"\n    This class validates input personal information data and sets invalid fields to None based on specific rules.\n    \"\"\"\n\n    VALID_SEXES = {\"Man\", \"Woman\", \"UGM\"}\n\n    def __init__(self, name: str, sex: str, phone_number: str):\n        \"\"\"\n        Initialize PersonRequest object with the provided information.\n        :param name: str, the name of the person\n        :param sex: str, the sex of the person\n        :param phone_number: str, the phone number of the person\n        \"\"\"\n        self.name = self._validate_name(name)\n        self.sex = self._validate_sex(sex)\n        self.phone_number = self._validate_phone_number(phone_number)\n\n    def _validate_name(self, name: str) -> str:\n        \"\"\"\n        Validate the name and return it. If name is empty or exceeds 33 characters in length, set to None.\n        :param name: str, the name to validate\n        :return: str, the validated name or None if invalid\n        \"\"\"\n        return name if name and len(name) <= 33 else None\n\n    def _validate_sex(self, sex: str) -> str:\n        \"\"\"\n        Validate the sex and return it. If sex is not Man, Woman, or UGM, set to None.\n        :param sex: str, the sex to validate\n        :return: str, the validated sex or None if invalid\n        \"\"\"\n        return sex if sex in self.VALID_SEXES else None\n\n    def _validate_phone_number(self, phone_number: str) -> str:\n        \"\"\"\n        Validate the phone number and return it. If phone_number is empty or not an 11 digit number, set to None.\n        :param phone_number: str, the phone number to validate\n        :return: str, the validated phone number or None if invalid\n        \"\"\"\n        return phone_number if phone_number.isdigit() and len(phone_number) == 11 else None\n```",
    "65": "```python\nclass NumberWordFormatter:\n    \"\"\"\n    A class to convert numbers into their corresponding English word representation,\n    handling both integer and decimal parts with appropriate connectors and units.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the NumberWordFormatter object with number representations.\n        \"\"\"\n        self.units = [\"\", \"ONE\", \"TWO\", \"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\"]\n        self.teens = [\"TEN\", \"ELEVEN\", \"TWELVE\", \"THIRTEEN\", \"FOURTEEN\", \"FIFTEEN\", \"SIXTEEN\", \"SEVENTEEN\",\n                      \"EIGHTEEN\", \"NINETEEN\"]\n        self.tens = [\"\", \"\", \"TWENTY\", \"THIRTY\", \"FORTY\", \"FIFTY\", \"SIXTY\", \"SEVENTY\", \"EIGHTY\", \"NINETY\"]\n        self.scales = [\"\", \"THOUSAND\", \"MILLION\", \"BILLION\"]\n\n    def format(self, number):\n        \"\"\"\n        Converts a number (int or float) into words format.\n        :param number: int or float, the number to be converted into words format\n        :return: str, the number in words format\n        \"\"\"\n        if number is None:\n            return \"\"\n        \n        if isinstance(number, float):\n            integer_part = int(number)\n            decimal_part = int(round((number - integer_part) * 100))\n            return f\"{self._convert_integer(integer_part)} AND CENTS {self._convert_two_digits(decimal_part)} ONLY\"\n        \n        return f\"{self._convert_integer(int(number))} ONLY\"\n\n    def format_string(self, number_str):\n        \"\"\"\n        Converts a string representation of a number into words format.\n        :param number_str: str, the string representation of a number\n        :return: str, the number in words format\n        \"\"\"\n        return self.format(float(number_str))\n\n    def _convert_two_digits(self, num):\n        \"\"\"\n        Converts a two-digit number into words format.\n        :param num: int, the two-digit number\n        :return: str, the number in words format\n        \"\"\"\n        if num < 10:\n            return self.units[num]\n        elif num < 20:\n            return self.teens[num - 10]\n        else:\n            ten = num // 10\n            one = num % 10\n            return f\"{self.tens[ten]} {self.units[one]}\".strip()\n\n    def _convert_three_digits(self, num):\n        \"\"\"\n        Converts a three-digit number into words format.\n        :param num: int, the three-digit number\n        :return: str, the number in words format\n        \"\"\"\n        hundred = num // 100\n        remainder = num % 100\n        if hundred == 0:\n            return self._convert_two_digits(remainder)\n        return f\"{self.units[hundred]} HUNDRED AND {self._convert_two_digits(remainder)}\".strip()\n\n    def _convert_integer(self, num):\n        \"\"\"\n        Converts an integer number into words format.\n        :param num: int, the integer number to be converted\n        :return: str, the number in words format\n        \"\"\"\n        if num == 0:\n            return \"ZERO\"\n        \n        parts = []\n        scale_index = 0\n        \n        while num > 0:\n            if num % 1000 != 0:\n                parts.append(f\"{self._convert_three_digits(num % 1000)} {self.scales[scale_index]}\".strip())\n            num //= 1000\n            scale_index += 1\n        \n        return ' AND '.join(reversed(parts)).strip()\n```",
    "64": "```python\nclass NumberConverter:\n    \"\"\"\n    The class allows converting decimal to binary, octal, and hexadecimal formats, and vice versa.\n    \"\"\"\n\n    @staticmethod\n    def decimal_to_binary(decimal_num: int) -> str:\n        \"\"\"\n        Convert a number from decimal format to binary format.\n        :param decimal_num: int, decimal number\n        :return: str, the binary representation of an integer.\n        \"\"\"\n        return bin(decimal_num)[2:]\n\n    @staticmethod\n    def binary_to_decimal(binary_num: str) -> int:\n        \"\"\"\n        Convert a number from binary format to decimal format.\n        :param binary_num: str, binary number\n        :return: int, the decimal representation of binary number str.\n        \"\"\"\n        return int(binary_num, 2)\n\n    @staticmethod\n    def decimal_to_octal(decimal_num: int) -> str:\n        \"\"\"\n        Convert a number from decimal format to octal format.\n        :param decimal_num: int, decimal number\n        :return: str, the octal representation of an integer.\n        \"\"\"\n        return oct(decimal_num)[2:]\n\n    @staticmethod\n    def octal_to_decimal(octal_num: str) -> int:\n        \"\"\"\n        Convert a number from octal format to decimal format.\n        :param octal_num: str, octal number\n        :return: int, the decimal representation of octal number str.\n        \"\"\"\n        return int(octal_num, 8)\n\n    @staticmethod\n    def decimal_to_hex(decimal_num: int) -> str:\n        \"\"\"\n        Convert a number from decimal format to hexadecimal format.\n        :param decimal_num: int, decimal number\n        :return: str, the hexadecimal representation of an integer.\n        \"\"\"\n        return hex(decimal_num)[2:]\n\n    @staticmethod\n    def hex_to_decimal(hex_num: str) -> int:\n        \"\"\"\n        Convert a number from hexadecimal format to decimal format.\n        :param hex_num: str, hexadecimal number\n        :return: int, the decimal representation of hex number str.\n        \"\"\"\n        return int(hex_num, 16)\n```",
    "72": "```python\nimport re\n\nclass RegexUtils:\n    \"\"\"\n    A utility class for performing various operations using regular expressions,\n    including matching, finding occurrences, splitting text, and substituting text.\n    It also provides predefined patterns for validating phone numbers and extracting email addresses.\n    \"\"\"\n\n    @staticmethod\n    def match(pattern, text):\n        \"\"\"Check if the text matches the regular expression.\"\"\"\n        return bool(re.fullmatch(pattern, text))\n\n    @staticmethod\n    def findall(pattern, text):\n        \"\"\"Find all matching substrings and return a list of them.\"\"\"\n        return re.findall(pattern, text)\n\n    @staticmethod\n    def split(pattern, text):\n        \"\"\"Split text based on regular expression patterns and return a list of substrings.\"\"\"\n        return re.split(pattern, text)\n\n    @staticmethod\n    def sub(pattern, replacement, text):\n        \"\"\"Replace the substring matched by a regular expression with the specified string.\"\"\"\n        return re.sub(pattern, replacement, text)\n\n    @staticmethod\n    def generate_email_pattern():\n        \"\"\"Generate a regular expression pattern that matches email addresses.\"\"\"\n        return r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n\n    @staticmethod\n    def generate_phone_number_pattern():\n        \"\"\"Generate a regular expression pattern that matches phone numbers.\"\"\"\n        return r'\\b\\d{3}-\\d{3}-\\d{4}\\b'\n\n    @staticmethod\n    def generate_split_sentences_pattern():\n        \"\"\"Generate a regular expression pattern that matches sentence boundaries.\"\"\"\n        return r'[.!?][\\s]+(?=[A-Z])'\n\n    @staticmethod\n    def split_sentences(text):\n        \"\"\"Split the text into a list of sentences.\"\"\"\n        return re.split(RegexUtils.generate_split_sentences_pattern(), text)\n\n    @staticmethod\n    def validate_phone_number(phone_number):\n        \"\"\"Verify if the phone number is valid.\"\"\"\n        return RegexUtils.match(RegexUtils.generate_phone_number_pattern(), phone_number)\n\n    @staticmethod\n    def extract_email(text):\n        \"\"\"Extract all email addresses from the text.\"\"\"\n        return RegexUtils.findall(RegexUtils.generate_email_pattern(), text)\n```",
    "75": "```python\nclass ShoppingCart:\n    \"\"\"\n    The class manages items, their prices, quantities, and allows adding, removing, viewing items, and calculating the total price.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the shopping cart as an empty dictionary.\n        \"\"\"\n        self.items = {}\n\n    def add_item(self, item: str, price: float, quantity: int = 1) -> None:\n        \"\"\"\n        Add item information to the shopping cart, including price and quantity.\n        \n        :param item: str, Item to be added\n        :param price: float, The price of the item\n        :param quantity: int, The number of items to add, defaults to 1\n        \"\"\"\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be a positive integer.\")\n        \n        if item in self.items:\n            self.items[item]['quantity'] += quantity\n        else:\n            self.items[item] = {'price': price, 'quantity': quantity}\n\n    def remove_item(self, item: str, quantity: int = 1) -> None:\n        \"\"\"\n        Subtract the specified quantity of an item from the shopping cart.\n        \n        :param item: str, Item to be removed\n        :param quantity: int, Quantity to be removed, defaults to 1\n        \"\"\"\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be a positive integer.\")\n        \n        if item in self.items:\n            self.items[item]['quantity'] -= quantity\n            if self.items[item]['quantity'] <= 0:\n                del self.items[item]\n\n    def view_items(self) -> dict:\n        \"\"\"\n        Return the current items in the shopping cart.\n        \n        :return: dict, the current items in the shopping cart\n        \"\"\"\n        return self.items\n\n    def total_price(self) -> float:\n        \"\"\"\n        Calculate the total price of all items in the shopping cart.\n        \n        :return: float, the total price of all items in the shopping cart\n        \"\"\"\n        return sum(item['price'] * item['quantity'] for item in self.items.values())\n```",
    "61": "```python\nimport random\n\nclass MusicPlayer:\n    \"\"\"\n    A music player class that allows playing, stopping, adding/removing songs, setting volume, shuffling, \n    and switching to the next or previous song.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the music player with an empty playlist, no current song, and a default volume of 50.\n        \"\"\"\n        self.playlist = []\n        self.current_song_index = -1\n        self.volume = 50\n\n    def add_song(self, song: str):\n        \"\"\"\n        Adds a song to the playlist.\n        :param song: The song to add to the playlist, str.\n        \"\"\"\n        self.playlist.append(song)\n\n    def remove_song(self, song: str):\n        \"\"\"\n        Removes a song from the playlist.\n        :param song: The song to remove from the playlist, str.\n        \"\"\"\n        if song in self.playlist:\n            self.playlist.remove(song)\n            # Adjust current song index if necessary\n            if self.current_song_index >= len(self.playlist):\n                self.current_song_index = len(self.playlist) - 1\n\n    def play(self):\n        \"\"\"\n        Plays the current song in the playlist.\n        :return: The current song in the playlist, or None if there is no current song.\n        \"\"\"\n        if self.playlist and self.current_song_index != -1:\n            return self.playlist[self.current_song_index]\n        return None\n\n    def stop(self):\n        \"\"\"\n        Stops the current song in the playlist.\n        :return: True if the current song was stopped, False if there was no current song.\n        \"\"\"\n        if self.current_song_index != -1:\n            self.current_song_index = -1\n            return True\n        return False\n\n    def switch_song(self):\n        \"\"\"\n        Switches to the next song in the playlist.\n        :return: True if the next song was switched to, False if there was no next song.\n        \"\"\"\n        if self.playlist:\n            self.current_song_index = (self.current_song_index + 1) % len(self.playlist)\n            return True\n        return False\n\n    def previous_song(self):\n        \"\"\"\n        Switches to the previous song in the playlist.\n        :return: True if the previous song was switched to, False if there was no previous song.\n        \"\"\"\n        if self.playlist:\n            self.current_song_index = (self.current_song_index - 1) % len(self.playlist)\n            return True\n        return False\n\n    def set_volume(self, volume: int):\n        \"\"\"\n        Sets the volume of the music player, if the volume is between 0 and 100 is valid.\n        :param volume: The volume to set the music player to, int.\n        :return: True if the volume was set, False if the volume was invalid.\n        \"\"\"\n        if 0 <= volume <= 100:\n            self.volume = volume\n            return True\n        return False\n\n    def shuffle(self):\n        \"\"\"\n        Shuffles the playlist.\n        :return: True if the playlist was shuffled, False if the playlist was empty.\n        \"\"\"\n        if self.playlist:\n            random.shuffle(self.playlist)\n            return True\n        return False\n```",
    "71": "```python\nclass PushBoxGame:\n    \"\"\"\n    This class implements the functionality of a Sokoban game, where the player needs to move boxes to designated targets to win.\n    \"\"\"\n\n    def __init__(self, game_map):\n        \"\"\"\n        Initialize the push box game with the map and various attributes.\n        :param game_map: list[str], the map of the push box game, represented as a list of strings. \n            Each character on the map represents a different element:\n            - '#' represents a wall;\n            - 'O' represents the player's initial position;\n            - 'G' represents a target position;\n            - 'X' represents a box.\n        \"\"\"\n        self.map = game_map\n        self.player_row, self.player_col = self.find_player()\n        self.targets = self.find_targets()\n        self.boxes = self.find_boxes()\n        self.is_game_over = False\n\n    def find_player(self):\n        \"\"\"Find the player's initial position on the map.\"\"\"\n        for row in range(len(self.map)):\n            for col in range(len(self.map[row])):\n                if self.map[row][col] == 'O':\n                    return row, col\n        raise ValueError(\"Player not found on the map.\")\n\n    def find_targets(self):\n        \"\"\"Find all target positions on the map.\"\"\"\n        return [(row, col) for row in range(len(self.map)) for col in range(len(self.map[row])) if self.map[row][col] == 'G']\n\n    def find_boxes(self):\n        \"\"\"Find all box positions on the map.\"\"\"\n        return [(row, col) for row in range(len(self.map)) for col in range(len(self.map[row])) if self.map[row][col] == 'X']\n\n    def check_win(self):\n        \"\"\"Check if the game is won. The game is won when all boxes are placed on target positions.\"\"\"\n        return all(box in self.targets for box in self.boxes)\n\n    def move(self, direction):\n        \"\"\"\n        Move the player based on the specified direction and check if the game is won.\n        :param direction: str, the direction of the player's movement ('w', 's', 'a', 'd').\n        :return: True if the game is won, False otherwise.\n        \"\"\"\n        delta = {'w': (-1, 0), 's': (1, 0), 'a': (0, -1), 'd': (0, 1)}\n\n        if direction not in delta:\n            return False\n\n        new_row = self.player_row + delta[direction][0]\n        new_col = self.player_col + delta[direction][1]\n\n        if self.is_move_valid(new_row, new_col):\n            self.player_row, self.player_col = new_row, new_col\n            self.check_box_move(new_row, new_col)\n            self.is_game_over = self.check_win()\n            return self.is_game_over\n        return False\n\n    def is_move_valid(self, new_row, new_col):\n        \"\"\"Check if the move is valid (not hitting a wall or moving out of bounds).\"\"\"\n        return (0 <= new_row < len(self.map) and\n                0 <= new_col < len(self.map[new_row]) and\n                self.map[new_row][new_col] != '#')\n\n    def check_box_move(self, new_row, new_col):\n        \"\"\"Check if the player is pushing a box and move the box if possible.\"\"\"\n        if (new_row, new_col) in self.boxes:\n            box_new_row = new_row + (new_row - self.player_row)\n            box_new_col = new_col + (new_col - self.player_col)\n\n            if self.is_move_valid(box_new_row, box_new_col) and (box_new_row, box_new_col) not in self.boxes:\n                self.boxes.remove((new_row, new_col))\n                self.boxes.append((box_new_row, box_new_col))\n```",
    "76": "```python\nclass SignInSystem:\n    \"\"\"\n    A class representing a sign-in system that manages user sign-in status.\n    It allows adding users, signing them in/out, checking their sign-in status,\n    and retrieving lists of signed-in and not signed-in users.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the sign-in system with an empty user dictionary.\"\"\"\n        self.users = {}\n\n    def add_user(self, username: str) -> bool:\n        \"\"\"\n        Add a user to the sign-in system if they do not already exist.\n        The initial sign-in state is set to False (not signed in).\n        \n        :param username: str, the username to be added.\n        :return: bool, True if the user is added successfully, False if the user already exists.\n        \"\"\"\n        if username in self.users:\n            return False\n        self.users[username] = False\n        return True\n\n    def sign_in(self, username: str) -> bool:\n        \"\"\"\n        Sign in a user if they exist in the system and change their state to True.\n        \n        :param username: str, the username to be signed in.\n        :return: bool, True if the user is signed in successfully, False if the user does not exist.\n        \"\"\"\n        if username not in self.users:\n            return False\n        self.users[username] = True\n        return True\n\n    def check_sign_in(self, username: str) -> bool:\n        \"\"\"\n        Check if a user is signed in.\n        \n        :param username: str, the username to be checked.\n        :return: bool, True if the user is signed in, False if the user does not exist or is not signed in.\n        \"\"\"\n        return self.users.get(username, False)\n\n    def all_signed_in(self) -> bool:\n        \"\"\"\n        Check if all users are signed in.\n        \n        :return: bool, True if all users are signed in, False otherwise.\n        \"\"\"\n        return all(self.users.values())\n\n    def all_not_signed_in(self) -> list[str]:\n        \"\"\"\n        Get a list of usernames that are not signed in.\n        \n        :return: list[str], a list of usernames that are not signed in.\n        \"\"\"\n        return [username for username, signed_in in self.users.items() if not signed_in]\n```",
    "74": "```python\nclass Server:\n    \"\"\"\n    A class representing a server that manages a whitelist, handles message sending and receiving, and displays information.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the server with an empty whitelist and structures for sending and receiving messages.\n        \"\"\"\n        self.white_list = set()  # Using a set for O(1) average time complexity for add/remove operations\n        self.send_struct = {}\n        self.receive_struct = {}\n\n    def add_white_list(self, addr):\n        \"\"\"\n        Add an address to the whitelist if it does not already exist.\n        \n        :param addr: int, address to be added\n        :return: updated whitelist or False if the address already exists\n        \"\"\"\n        if addr not in self.white_list:\n            self.white_list.add(addr)\n            return list(self.white_list)\n        return False\n\n    def del_white_list(self, addr):\n        \"\"\"\n        Remove an address from the whitelist if it exists.\n        \n        :param addr: int, address to be deleted\n        :return: updated whitelist or False if the address does not exist\n        \"\"\"\n        if addr in self.white_list:\n            self.white_list.remove(addr)\n            return list(self.white_list)\n        return False\n\n    def recv(self, info):\n        \"\"\"\n        Receive information containing address and content. Only accept if the address is in the whitelist.\n        \n        :param info: dict, information dictionary containing address and content\n        :return: content if successfully received, otherwise False\n        \"\"\"\n        if isinstance(info, dict) and 'addr' in info and 'content' in info:\n            addr = info['addr']\n            if addr in self.white_list:\n                self.receive_struct = info\n                return info['content']\n        return False\n\n    def send(self, info):\n        \"\"\"\n        Send information containing address and content.\n        \n        :param info: dict, information dictionary containing address and content\n        :return: None if successfully sent, otherwise an error message\n        \"\"\"\n        if isinstance(info, dict) and 'addr' in info and 'content' in info:\n            self.send_struct = info\n            return\n        return \"info structure is not correct\"\n\n    def show(self, type):\n        \"\"\"\n        Returns the structure of the specified type.\n        \n        :param type: string, the type of struct to be returned, can be 'send' or 'receive'\n        :return: corresponding struct or False if type is invalid\n        \"\"\"\n        if type == 'send':\n            return self.send_struct\n        elif type == 'receive':\n            return self.receive_struct\n        return False\n```",
    "73": "```python\nclass RPGCharacter:\n    \"\"\"\n    Represents a role-playing game character capable of attacking, healing, gaining experience, leveling up, and checking if alive.\n    \"\"\"\n\n    MAX_HP = 100\n    LEVEL_UP_EXP_MULTIPLIER = 100\n    HP_INCREASE_PER_LEVEL = 20\n    ATTACK_POWER_INCREASE_PER_LEVEL = 5\n    DEFENSE_INCREASE_PER_LEVEL = 5\n    MAX_LEVEL = 100\n\n    def __init__(self, name, hp, attack_power, defense, level=1):\n        \"\"\"\n        Initialize an RPG character object.\n        :param name: str, the name of the character.\n        :param hp: int, initial health points of the character.\n        :param attack_power: int, initial attack power of the character.\n        :param defense: int, initial defense points of the character.\n        :param level: int, initial level of the character. Default is 1.\n        \"\"\"\n        self.name = name\n        self.hp = min(hp, self.MAX_HP)  # Ensure HP does not exceed MAX_HP\n        self.attack_power = attack_power\n        self.defense = defense\n        self.level = min(level, self.MAX_LEVEL)  # Ensure level does not exceed MAX_LEVEL\n        self.exp = 0\n\n    def attack(self, other_character):\n        \"\"\"\n        Attack another character, calculating damage based on attack power and defense.\n        :param other_character: RPGCharacter, the character being attacked.\n        \"\"\"\n        damage = max(0, self.attack_power - other_character.defense)\n        other_character.hp = max(0, other_character.hp - damage)\n\n    def heal(self):\n        \"\"\"\n        Heal the character by 10 HP, not exceeding MAX_HP.\n        :return: int, current health points after healing.\n        \"\"\"\n        self.hp = min(self.MAX_HP, self.hp + 10)\n        return self.hp\n\n    def gain_exp(self, amount):\n        \"\"\"\n        Gain experience points and level up if enough experience is accumulated.\n        :param amount: int, the amount of experience points to gain.\n        \"\"\"\n        self.exp += amount\n        while self.exp >= self.LEVEL_UP_EXP_MULTIPLIER * self.level and self.level < self.MAX_LEVEL:\n            self.exp -= self.LEVEL_UP_EXP_MULTIPLIER * self.level\n            self.level_up()\n\n    def level_up(self):\n        \"\"\"\n        Level up the character, increasing HP, attack power, and defense.\n        :return: tuple[int, int, int, int], the new level, health points, attack power, and defense after leveling up.\n        \"\"\"\n        if self.level < self.MAX_LEVEL:\n            self.level += 1\n            self.hp = min(self.MAX_HP, self.hp + self.HP_INCREASE_PER_LEVEL)\n            self.attack_power += self.ATTACK_POWER_INCREASE_PER_LEVEL\n            self.defense += self.DEFENSE_INCREASE_PER_LEVEL\n        self.exp = 0\n        return self.level, self.hp, self.attack_power, self.defense\n\n    def is_alive(self):\n        \"\"\"\n        Check if the character is alive.\n        :return: True if HP is greater than 0, False otherwise.\n        \"\"\"\n        return self.hp > 0\n```",
    "77": "```python\nimport random\n\nclass Snake:\n    \"\"\"\n    The class represents a snake game, allowing the snake to move, eat food, reset, and generate a random food position.\n    \"\"\"\n\n    def __init__(self, screen_width, screen_height, block_size, food_position):\n        \"\"\"\n        Initialize the snake's attributes.\n        :param screen_width: int\n        :param screen_height: int\n        :param block_size: int, size of moving units\n        :param food_position: tuple, representing the position (x, y) of food.\n        \"\"\"\n        self.length = 1\n        self.screen_width = screen_width\n        self.screen_height = screen_height\n        self.block_size = block_size\n        self.positions = [(screen_width // 2, screen_height // 2)]\n        self.score = 0\n        self.food_position = food_position\n        self.random_food_position()\n\n    def move(self, direction):\n        \"\"\"\n        Move the snake in the specified direction.\n        :param direction: tuple, representing the direction of movement (x, y).\n        \"\"\"\n        new_head = (self.positions[0][0] + direction[0] * self.block_size,\n                     self.positions[0][1] + direction[1] * self.block_size)\n\n        if new_head == self.food_position:\n            self.eat_food()\n        elif new_head in self.positions or not self.is_within_bounds(new_head):\n            self.reset()\n        else:\n            self.positions.insert(0, new_head)\n            if len(self.positions) > self.length:\n                self.positions.pop()\n\n    def random_food_position(self):\n        \"\"\"\n        Randomly generate a new food position, ensuring it does not overlap with the snake.\n        \"\"\"\n        while True:\n            new_food_position = (random.randint(0, (self.screen_width // self.block_size) - 1) * self.block_size,\n                                 random.randint(0, (self.screen_height // self.block_size) - 1) * self.block_size)\n            if new_food_position not in self.positions:\n                self.food_position = new_food_position\n                break\n\n    def reset(self):\n        \"\"\"\n        Reset the snake to its initial state.\n        \"\"\"\n        self.length = 1\n        self.positions = [(self.screen_width // 2, self.screen_height // 2)]\n        self.score = 0\n        self.random_food_position()\n\n    def eat_food(self):\n        \"\"\"\n        Increase the length of the snake and the score, and generate a new food position.\n        \"\"\"\n        self.length += 1\n        self.score += 100\n        self.random_food_position()\n\n    def is_within_bounds(self, position):\n        \"\"\"\n        Check if the given position is within the game boundaries.\n        :param position: tuple, representing the position (x, y).\n        :return: bool\n        \"\"\"\n        x, y = position\n        return 0 <= x < self.screen_width and 0 <= y < self.screen_height\n```",
    "78": "```python\nimport re\n\nclass SplitSentence:\n    \"\"\"\n    The class allows to split sentences, count words in a sentence, and process a text to find the maximum word count.\n    \"\"\"\n\n    def split_sentences(self, sentences_string):\n        \"\"\"\n        Split a string into a list of sentences. Sentences end with . or ? and are followed by a space. \n        Note that abbreviations like Mr. do not count as sentence endings.\n        \n        :param sentences_string: str, string to split\n        :return: list, split sentence list\n        \"\"\"\n        pattern = r'(?<!\\bMr\\.)(?<!\\b[A-Z]\\.)(?<!\\b[A-Z]\\.[A-Z]\\.)[.?\\n]+(?=\\s|$)'\n        return [sentence.strip() for sentence in re.split(pattern, sentences_string) if sentence.strip()]\n\n    def count_words(self, sentence):\n        \"\"\"\n        Count the number of words in a sentence. Words are separated by spaces, \n        and punctuation marks and numbers are not counted as words.\n        \n        :param sentence: str, sentence to be counted\n        :return: int, number of words in the sentence\n        \"\"\"\n        words = re.findall(r'\\b[a-zA-Z]+\\b', sentence)\n        return len(words)\n\n    def process_text_file(self, sentences_string):\n        \"\"\"\n        Given a text, return the number of words in the longest sentence.\n        \n        :param sentences_string: str, undivided long sentence\n        :return: int, the number of words in the longest sentence\n        \"\"\"\n        sentences = self.split_sentences(sentences_string)\n        return max((self.count_words(sentence) for sentence in sentences), default=0)\n```",
    "79": "```python\nclass SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        fields_part = ', '.join(fields) if fields else '*'\n        condition_part = f' WHERE {condition}' if condition else ''\n        return f'SELECT {fields_part} FROM {self.table_name}{condition_part};'\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        fields = ', '.join(data.keys())\n        values = ', '.join(f\"'{value}'\" for value in data.values())\n        return f\"INSERT INTO {self.table_name} ({fields}) VALUES ({values});\"\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and values are new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        set_clause = ', '.join(f\"{key} = '{value}'\" for key, value in data.items())\n        return f\"UPDATE {self.table_name} SET {set_clause} WHERE {condition};\"\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        return f\"DELETE FROM {self.table_name} WHERE {condition};\"\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        return f\"SELECT * FROM {self.table_name} WHERE age < {age} AND gender = 'female';\"\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        return f\"SELECT * FROM {self.table_name} WHERE age BETWEEN {min_age} AND {max_age};\"\n```",
    "81": "```python\nimport math\nfrom collections import Counter\n\nclass Statistics3:\n    \"\"\"\n    A class that implements methods for calculating statistical indicators such as median, mode, correlation, \n    correlation matrix, standard deviation, and Z-score.\n    \"\"\"\n\n    @staticmethod\n    def median(data):\n        \"\"\"Calculates the median of the given list.\"\"\"\n        if not data:\n            return None\n        sorted_data = sorted(data)\n        mid = len(sorted_data) // 2\n        return (sorted_data[mid - 1] + sorted_data[mid]) / 2 if len(sorted_data) % 2 == 0 else sorted_data[mid]\n\n    @staticmethod\n    def mode(data):\n        \"\"\"Calculates the mode of the given list.\"\"\"\n        if not data:\n            return []\n        frequency = Counter(data)\n        max_count = max(frequency.values())\n        return [num for num, count in frequency.items() if count == max_count]\n\n    @staticmethod\n    def mean(data):\n        \"\"\"Calculates the mean of the given list.\"\"\"\n        return sum(data) / len(data) if data else None\n\n    @staticmethod\n    def standard_deviation(data):\n        \"\"\"Calculates the standard deviation of the given list.\"\"\"\n        if not data:\n            return None\n        mean_value = Statistics3.mean(data)\n        variance = sum((xi - mean_value) ** 2 for xi in data) / len(data)\n        return math.sqrt(variance)\n\n    @staticmethod\n    def z_score(data):\n        \"\"\"Calculates the Z-score of the given list.\"\"\"\n        if not data or len(set(data)) == 1:\n            return None\n        mean_value = Statistics3.mean(data)\n        std_dev = Statistics3.standard_deviation(data)\n        return [(xi - mean_value) / std_dev for xi in data]\n\n    @staticmethod\n    def correlation(x, y):\n        \"\"\"Calculates the correlation coefficient between two lists.\"\"\"\n        if len(x) != len(y) or len(x) < 2:\n            return None\n        mean_x, mean_y = Statistics3.mean(x), Statistics3.mean(y)\n        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))\n        denominator = math.sqrt(sum((xi - mean_x) ** 2 for xi in x) * sum((yi - mean_y) ** 2 for yi in y))\n        return numerator / denominator if denominator != 0 else None\n\n    @staticmethod\n    def correlation_matrix(data):\n        \"\"\"Calculates the correlation matrix for a list of lists.\"\"\"\n        if not data or not all(len(row) == len(data[0]) for row in data):\n            return [[None] * len(data[0]) for _ in range(len(data[0]))]\n        return [[Statistics3.correlation(row_i, row_j) for row_j in zip(*data)] for row_i in zip(*data)]\n```",
    "84": "```python\nimport json\nimport re\n\nclass TextFileProcessor:\n    \"\"\"\n    The class handles reading, writing, and processing text files. It can read the file as JSON, read the raw text, write content to the file, and process the file by removing non-alphabetic characters.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initialize the file path.\n        :param file_path: str\n        \"\"\"\n        self.file_path = file_path\n\n    def read_file_as_json(self):\n        \"\"\"\n        Read the self.file_path file as JSON format.\n        If the file content doesn't obey JSON format, an error will be raised.\n        :return: dict if the file is stored as JSON format, or str/int/float according to the file content otherwise.\n        \"\"\"\n        with open(self.file_path, 'r') as file:\n            content = file.read()\n            return json.loads(content)\n\n    def read_file(self):\n        \"\"\"\n        Read and return the content of self.file_path file.\n        :return: str\n        \"\"\"\n        with open(self.file_path, 'r') as file:\n            return file.read()\n\n    def write_file(self, content):\n        \"\"\"\n        Write content into the self.file_path file, overwriting if the file already exists.\n        :param content: str\n        \"\"\"\n        with open(self.file_path, 'w') as file:\n            file.write(content)\n\n    def process_file(self):\n        \"\"\"\n        Read the self.file_path file and filter out non-alphabetic characters from the content string.\n        Overwrite the processed data into the same self.file_path file.\n        :return: str\n        \"\"\"\n        content = self.read_file()\n        processed_content = re.sub(r'[^a-zA-Z]', '', content)\n        self.write_file(processed_content)\n        return processed_content\n```",
    "80": "```python\nclass SQLQueryBuilder:\n    \"\"\"\n    This class provides methods to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements.\n    \"\"\"\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in the database.\n        :param columns: list of str or str, the columns to select.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return: str, the SQL query statement.\n        \"\"\"\n        column_str = ', '.join(columns) if isinstance(columns, list) else columns\n        query = f\"SELECT {column_str} FROM {table}\"\n        if where:\n            conditions = ' AND '.join(f\"{key}='{value}'\" for key, value in where.items())\n            query += f\" WHERE {conditions}\"\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to be inserted into in the database.\n        :param data: dict, the key and value in SQL insert statement.\n        :return: str, the SQL insert statement.\n        \"\"\"\n        columns = ', '.join(data.keys())\n        values = ', '.join(f\"'{value}'\" for value in data.values())\n        return f\"INSERT INTO {table} ({columns}) VALUES ({values})\"\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table that will be executed with DELETE operation in the database.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return: str, the SQL delete statement.\n        \"\"\"\n        query = f\"DELETE FROM {table}\"\n        if where:\n            conditions = ' AND '.join(f\"{key}='{value}'\" for key, value in where.items())\n            query += f\" WHERE {conditions}\"\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table that will be executed with UPDATE operation in the database.\n        :param data: dict, the key and value in SQL update statement.\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return: str, the SQL update statement.\n        \"\"\"\n        set_clause = ', '.join(f\"{key}='{value}'\" for key, value in data.items())\n        query = f\"UPDATE {table} SET {set_clause}\"\n        if where:\n            conditions = ' AND '.join(f\"{key}='{value}'\" for key, value in where.items())\n            query += f\" WHERE {conditions}\"\n        return query\n```",
    "85": "```python\nimport time\n\nclass Thermostat:\n    \"\"\"\n    The class manages temperature control, including setting and retrieving the target temperature, adjusting the mode, and simulating temperature operation.\n    \"\"\"\n\n    VALID_MODES = {'heat', 'cool'}\n\n    def __init__(self, current_temperature: float, target_temperature: float, mode: str):\n        \"\"\"\n        Initialize instances of the Thermostat class.\n        :param current_temperature: float\n        :param target_temperature: float\n        :param mode: str, the work mode\n        \"\"\"\n        self.current_temperature = current_temperature\n        self.target_temperature = target_temperature\n        self.mode = mode if mode in self.VALID_MODES else 'cool'\n\n    def get_target_temperature(self) -> float:\n        \"\"\"Return the target temperature.\"\"\"\n        return self.target_temperature\n\n    def set_target_temperature(self, temperature: float) -> None:\n        \"\"\"Set the target temperature.\"\"\"\n        self.target_temperature = temperature\n\n    def get_mode(self) -> str:\n        \"\"\"Return the current work mode.\"\"\"\n        return self.mode\n\n    def set_mode(self, mode: str) -> bool:\n        \"\"\"Set the current work mode if valid.\"\"\"\n        if mode in self.VALID_MODES:\n            self.mode = mode\n            return True\n        return False\n\n    def auto_set_mode(self) -> None:\n        \"\"\"Automatically set the operating mode based on current and target temperatures.\"\"\"\n        self.mode = 'heat' if self.current_temperature < self.target_temperature else 'cool'\n\n    def auto_check_conflict(self) -> bool:\n        \"\"\"\n        Check for conflicts between the mode and temperature relationship.\n        :return: True if there is no conflict, False otherwise\n        \"\"\"\n        conflict = (self.current_temperature < self.target_temperature and self.mode == 'cool') or \\\n                   (self.current_temperature > self.target_temperature and self.mode == 'heat')\n        if conflict:\n            self.auto_set_mode()\n        return not conflict\n\n    def simulate_operation(self) -> int:\n        \"\"\"\n        Simulate the operation of the thermostat until the target temperature is reached.\n        :return: int, the time it took to complete the simulation\n        \"\"\"\n        self.auto_set_mode()\n        time_taken = 0\n\n        while abs(self.current_temperature - self.target_temperature) >= 1:\n            self.current_temperature += 1 if self.mode == 'heat' else -1\n            time.sleep(1)  # Simulate time passing\n            time_taken += 1\n\n        self.current_temperature = self.target_temperature  # Ensure we end exactly at the target\n        return time_taken\n```",
    "88": "```python\nfrom math import pi\n\nclass TriCalculator:\n    \"\"\"\n    The class allows to calculate trigonometric values, including cosine, sine, and tangent, using Taylor series approximations.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def cos(self, x):\n        \"\"\"\n        Calculate the cosine value of the x-degree angle.\n        :param x: float\n        :return: float\n        \"\"\"\n        return self._taylor_cos(x, 50)\n\n    def factorial(self, n):\n        \"\"\"\n        Calculate the factorial of n.\n        :param n: int\n        :return: int\n        \"\"\"\n        if n < 0:\n            raise ValueError(\"Factorial is not defined for negative numbers.\")\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result\n\n    def _taylor_cos(self, x, n):\n        \"\"\"\n        Calculate the n-order Taylor expansion value of cos(x) where x is in radians.\n        :param x: float\n        :param n: int\n        :return: float\n        \"\"\"\n        radians = x * (pi / 180)\n        cos_value = sum(((-1) ** i) * (radians ** (2 * i)) / self.factorial(2 * i) for i in range(n))\n        return cos_value\n\n    def sin(self, x):\n        \"\"\"\n        Calculate the sine value of the x-degree angle.\n        :param x: float\n        :return: float\n        \"\"\"\n        return self._taylor_sin(x, 50)\n\n    def _taylor_sin(self, x, n):\n        \"\"\"\n        Calculate the n-order Taylor expansion value of sin(x) where x is in radians.\n        :param x: float\n        :param n: int\n        :return: float\n        \"\"\"\n        radians = x * (pi / 180)\n        sin_value = sum(((-1) ** i) * (radians ** (2 * i + 1)) / self.factorial(2 * i + 1) for i in range(n))\n        return sin_value\n\n    def tan(self, x):\n        \"\"\"\n        Calculate the tangent value of the x-degree angle.\n        :param x: float\n        :return: float or bool\n        \"\"\"\n        if x % 180 == 90:\n            return False  # Undefined for odd multiples of 90 degrees\n        return self.sin(x) / self.cos(x)\n```",
    "86": "```python\nclass TicTacToe:\n    \"\"\"\n    The class represents a game of Tic-Tac-Toe and its functions include making a move on the board,\n    checking for a winner, and determining if the board is full.\n    \"\"\"\n\n    def __init__(self, size=3):\n        \"\"\"\n        Initialize a game board with specified size and set the current player to 'X'.\n        :param size: int, the size of the board (default is 3 for a 3x3 board)\n        \"\"\"\n        self.size = size\n        self.board = [[' ' for _ in range(size)] for _ in range(size)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Place the current player's mark at the specified position on the board and switch the player.\n        :param row: int, the row index of the position\n        :param col: int, the column index of the position\n        :return: bool, indicating whether the move was successful or not\n        \"\"\"\n        if self.is_valid_move(row, col):\n            self.board[row][col] = self.current_player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        return False\n\n    def is_valid_move(self, row, col):\n        \"\"\"\n        Check if the move is valid (i.e., within bounds and on an empty cell).\n        :param row: int, the row index of the position\n        :param col: int, the column index of the position\n        :return: bool, indicating whether the move is valid\n        \"\"\"\n        return 0 <= row < self.size and 0 <= col < self.size and self.board[row][col] == ' '\n\n    def check_winner(self):\n        \"\"\"\n        Check if there is a winner on the board in rows, columns, and diagonals.\n        :return: str or None, the mark of the winner ('X' or 'O'), or None if there is no winner yet\n        \"\"\"\n        lines = self.board + list(map(list, zip(*self.board)))  # rows + columns\n        lines.append([self.board[i][i] for i in range(self.size)])  # main diagonal\n        lines.append([self.board[i][self.size - 1 - i] for i in range(self.size)])  # secondary diagonal\n\n        for line in lines:\n            if line[0] != ' ' and all(cell == line[0] for cell in line):\n                return line[0]\n        return None\n\n    def is_board_full(self):\n        \"\"\"\n        Check if the game board is completely filled.\n        :return: bool, indicating whether the game board is full or not\n        \"\"\"\n        return all(cell != ' ' for row in self.board for cell in row)\n```",
    "87": "```python\nimport datetime\n\nclass TimeUtils:\n    \"\"\"\n    A utility class for handling various time and date operations.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the TimeUtils instance with the current datetime.\n        \"\"\"\n        self.current_datetime = datetime.datetime.now()\n\n    def get_current_time(self) -> str:\n        \"\"\"\n        Return the current time in the format of '%H:%M:%S'.\n        :return: string\n        \"\"\"\n        return self.current_datetime.strftime('%H:%M:%S')\n\n    def get_current_date(self) -> str:\n        \"\"\"\n        Return the current date in the format of \"%Y-%m-%d\".\n        :return: string\n        \"\"\"\n        return self.current_datetime.strftime('%Y-%m-%d')\n\n    def add_seconds(self, seconds: int) -> str:\n        \"\"\"\n        Add the specified number of seconds to the current time.\n        :param seconds: int, number of seconds to add\n        :return: string, time after adding the specified number of seconds in the format '%H:%M:%S'\n        \"\"\"\n        new_time = self.current_datetime + datetime.timedelta(seconds=seconds)\n        return new_time.strftime('%H:%M:%S')\n\n    @staticmethod\n    def string_to_datetime(time_string: str) -> datetime.datetime:\n        \"\"\"\n        Convert the time string to a datetime instance.\n        :param time_string: string, string before converting format\n        :return: datetime instance\n        \"\"\"\n        return datetime.datetime.strptime(time_string, '%Y-%m-%d %H:%M:%S')\n\n    @staticmethod\n    def datetime_to_string(dt: datetime.datetime) -> str:\n        \"\"\"\n        Convert a datetime instance to a string.\n        :param dt: the datetime instance to convert\n        :return: string, converted time string\n        \"\"\"\n        return dt.strftime('%Y-%m-%d %H:%M:%S')\n\n    def get_minutes(self, time_string1: str, time_string2: str) -> int:\n        \"\"\"\n        Calculate how many minutes have passed between two times, and round the results to the nearest minute.\n        :param time_string1: string, first time string\n        :param time_string2: string, second time string\n        :return: int, the number of minutes between two times, rounded off\n        \"\"\"\n        dt1 = self.string_to_datetime(time_string1)\n        dt2 = self.string_to_datetime(time_string2)\n        return round((dt2 - dt1).total_seconds() / 60)\n\n    @staticmethod\n    def get_format_time(year: int, month: int, day: int, hour: int, minute: int, second: int) -> str:\n        \"\"\"\n        Get formatted time.\n        :param year: int\n        :param month: int\n        :param day: int\n        :param hour: int\n        :param minute: int\n        :param second: int\n        :return: formatted time string\n        \"\"\"\n        dt = datetime.datetime(year, month, day, hour, minute, second)\n        return dt.strftime('%Y-%m-%d %H:%M:%S')\n```",
    "82": "```python\nclass StockPortfolioTracker:\n    \"\"\"\n    A class to track a stock portfolio, allowing for adding, removing, buying, and selling stocks,\n    as well as calculating the total portfolio value and obtaining a summary.\n    \"\"\"\n\n    def __init__(self, cash_balance):\n        \"\"\"\n        Initialize the StockPortfolioTracker with a cash balance and an empty portfolio.\n        :param cash_balance: Initial cash balance for the portfolio.\n        \"\"\"\n        self.portfolio = []\n        self.cash_balance = cash_balance\n\n    def add_stock(self, stock):\n        \"\"\"\n        Add a stock to the portfolio or update the quantity if it already exists.\n        :param stock: A dictionary with keys \"name\", \"price\", and \"quantity\".\n        \"\"\"\n        for existing_stock in self.portfolio:\n            if existing_stock['name'] == stock['name']:\n                existing_stock['quantity'] += stock['quantity']\n                return\n        self.portfolio.append(stock)\n\n    def remove_stock(self, stock):\n        \"\"\"\n        Remove a specified quantity of a stock from the portfolio.\n        :param stock: A dictionary with keys \"name\", \"price\", and \"quantity\".\n        :return: True if the stock was removed successfully, False otherwise.\n        \"\"\"\n        for existing_stock in self.portfolio:\n            if existing_stock['name'] == stock['name']:\n                if existing_stock['quantity'] >= stock['quantity']:\n                    existing_stock['quantity'] -= stock['quantity']\n                    if existing_stock['quantity'] == 0:\n                        self.portfolio.remove(existing_stock)\n                    return True\n                break\n        return False\n\n    def buy_stock(self, stock):\n        \"\"\"\n        Buy a stock and add it to the portfolio if sufficient cash is available.\n        :param stock: A dictionary with keys \"name\", \"price\", and \"quantity\".\n        :return: True if the stock was bought successfully, False if insufficient funds.\n        \"\"\"\n        total_cost = stock['price'] * stock['quantity']\n        if total_cost > self.cash_balance:\n            return False\n        self.cash_balance -= total_cost\n        self.add_stock(stock)\n        return True\n\n    def sell_stock(self, stock):\n        \"\"\"\n        Sell a specified quantity of a stock and add the cash to the cash balance.\n        :param stock: A dictionary with keys \"name\", \"price\", and \"quantity\".\n        :return: True if the stock was sold successfully, False if insufficient quantity.\n        \"\"\"\n        for existing_stock in self.portfolio:\n            if existing_stock['name'] == stock['name']:\n                if existing_stock['quantity'] >= stock['quantity']:\n                    total_sale = stock['price'] * stock['quantity']\n                    self.cash_balance += total_sale\n                    existing_stock['quantity'] -= stock['quantity']\n                    if existing_stock['quantity'] == 0:\n                        self.portfolio.remove(existing_stock)\n                    return True\n                break\n        return False\n\n    def calculate_portfolio_value(self):\n        \"\"\"\n        Calculate the total value of the portfolio, including cash and stock values.\n        :return: The total value of the portfolio as a float.\n        \"\"\"\n        total_value = self.cash_balance\n        for stock in self.portfolio:\n            total_value += stock['price'] * stock['quantity']\n        return total_value\n\n    def get_portfolio_summary(self):\n        \"\"\"\n        Get a summary of the portfolio, including total value and individual stock values.\n        :return: A tuple of the total value of the portfolio and a list of stock values.\n        \"\"\"\n        total_value = self.calculate_portfolio_value()\n        summary = [{'name': stock['name'], 'value': stock['price'] * stock['quantity']} for stock in self.portfolio]\n        return total_value, summary\n\n    def get_stock_value(self, stock):\n        \"\"\"\n        Get the value of a specific stock based on its price and quantity.\n        :param stock: A dictionary with keys \"name\", \"price\", and \"quantity\".\n        :return: The value of the stock as a float.\n        \"\"\"\n        return stock['price'] * stock['quantity']\n```",
    "91": "```python\nimport urllib.parse\n\nclass UrlPath:\n    \"\"\"\n    A utility class for encapsulating and manipulating the path component of a URL,\n    including adding segments, parsing path strings, and building path strings with optional encoding.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the UrlPath object with an empty list of segments and a flag indicating the presence of an end tag.\n        \"\"\"\n        self.segments = []\n        self.with_end_tag = False\n\n    def add(self, segment: str):\n        \"\"\"\n        Adds a segment to the list of segments in the UrlPath.\n        :param segment: str, the segment to add.\n        \"\"\"\n        if segment:\n            self.segments.append(segment)\n\n    def parse(self, path: str, charset: str):\n        \"\"\"\n        Parses a given path string and populates the list of segments in the UrlPath.\n        :param path: str, the path string to parse.\n        :param charset: str, the character encoding of the path string.\n        \"\"\"\n        decoded_path = urllib.parse.unquote(path, encoding=charset)\n        cleaned_path = self.fix_path(decoded_path)\n        self.segments = cleaned_path.split('/') if cleaned_path else []\n        self.with_end_tag = path.endswith('/')\n\n    @staticmethod\n    def fix_path(path: str) -> str:\n        \"\"\"\n        Fixes the given path string by removing leading and trailing slashes.\n        :param path: str, the path string to fix.\n        :return: str, the fixed path string.\n        \"\"\"\n        return path.strip('/')\n```",
    "90": "```python\nfrom urllib.parse import urlparse, parse_qs\n\nclass URLHandler:\n    \"\"\"\n    A class to handle URLs, including extracting the scheme, host, path, query parameters, and fragment.\n    \"\"\"\n\n    def __init__(self, url):\n        \"\"\"\n        Initialize the URLHandler with a URL.\n        \n        :param url: The URL to be parsed.\n        \"\"\"\n        self.url = url\n        self.parsed_url = urlparse(url)\n\n    def get_scheme(self):\n        \"\"\"\n        Get the scheme of the URL.\n        \n        :return: The scheme of the URL as a string, or None if not present.\n        \"\"\"\n        return self.parsed_url.scheme or None\n\n    def get_host(self):\n        \"\"\"\n        Get the host domain name of the URL.\n        \n        :return: The host domain name as a string, or None if not present.\n        \"\"\"\n        return self.parsed_url.hostname or None\n\n    def get_path(self):\n        \"\"\"\n        Get the path of the resource in the URL.\n        \n        :return: The path as a string, or None if not present.\n        \"\"\"\n        return self.parsed_url.path or None\n\n    def get_query_params(self):\n        \"\"\"\n        Get the query parameters from the URL.\n        \n        :return: A dictionary of query parameters, or None if there are no query parameters.\n        \"\"\"\n        query_params = parse_qs(self.parsed_url.query)\n        return {k: v[0] for k, v in query_params.items()} if query_params else None\n\n    def get_fragment(self):\n        \"\"\"\n        Get the fragment of the URL after the '#' character.\n        \n        :return: The fragment as a string, or None if not present.\n        \"\"\"\n        return self.parsed_url.fragment or None\n```",
    "89": "```python\nimport random\n\nclass TwentyFourPointGame:\n    \"\"\"\n    This is a game of twenty-four points, which generates four numbers and checks whether the player's expression is equal to 24.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.nums = []\n\n    def _generate_cards(self) -> None:\n        \"\"\"\n        Generate random numbers between 1 and 9 for the cards.\n        \"\"\"\n        self.nums = [random.randint(1, 9) for _ in range(4)]\n\n    def get_my_cards(self) -> list[int]:\n        \"\"\"\n        Get a list of four random numbers between 1 and 9 representing the player's cards.\n        :return: list of integers, representing the player's cards\n        \"\"\"\n        self._generate_cards()\n        return self.nums\n\n    def answer(self, expression: str) -> bool:\n        \"\"\"\n        Check if a given mathematical expression using the cards can evaluate to 24.\n        :param expression: string, mathematical expression using the cards\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        \"\"\"\n        if self._is_valid_expression(expression):\n            return self.evaluate_expression(expression)\n        return False\n\n    def evaluate_expression(self, expression: str) -> bool:\n        \"\"\"\n        Evaluate a mathematical expression and check if the result is 24.\n        :param expression: string, mathematical expression\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        \"\"\"\n        try:\n            return eval(expression) == 24\n        except (SyntaxError, NameError, ZeroDivisionError):\n            return False\n\n    def _is_valid_expression(self, expression: str) -> bool:\n        \"\"\"\n        Check if the expression is valid and uses only the numbers from the player's cards.\n        :param expression: string, mathematical expression\n        :return: bool, True if valid, False otherwise\n        \"\"\"\n        allowed_numbers = set(map(str, self.nums))\n        tokens = expression.replace('+', ' ').replace('-', ' ').replace('*', ' ').replace('/', ' ').split()\n        return all(token in allowed_numbers for token in tokens)\n```",
    "83": "```python\nimport sqlite3\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This class handles database operations for student information,\n    including inserting, searching, and deleting student records.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n        self.create_student_table()\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.\n        :return: None\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS students (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    name TEXT NOT NULL,\n                    age INTEGER NOT NULL,\n                    gender TEXT NOT NULL,\n                    grade INTEGER NOT NULL\n                )\n            ''')\n            conn.commit()\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n        :return: None\n        \"\"\"\n        self._execute_query('''\n            INSERT INTO students (name, age, gender, grade)\n            VALUES (?, ?, ?, ?)\n        ''', (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n        \"\"\"\n        return self._fetch_query('SELECT * FROM students WHERE name=?', (name,))\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        \"\"\"\n        self._execute_query('DELETE FROM students WHERE name=?', (name,))\n\n    def _execute_query(self, query, params):\n        \"\"\"\n        Executes a query that modifies the database (INSERT, UPDATE, DELETE).\n        :param query: str, the SQL query to execute.\n        :param params: tuple, the parameters to bind to the query.\n        :return: None\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            conn.commit()\n\n    def _fetch_query(self, query, params):\n        \"\"\"\n        Executes a query that retrieves data from the database.\n        :param query: str, the SQL query to execute.\n        :param params: tuple, the parameters to bind to the query.\n        :return: list of tuples, the result of the query.\n        \"\"\"\n        with sqlite3.connect(self.database_name) as conn:\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            return cursor.fetchall()\n```",
    "92": "```python\nimport sqlite3\n\nclass UserLoginDB:\n    \"\"\"\n    A database management class for user login verification, providing functions for inserting, searching,\n    deleting user information, and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"\n        Creates the \"users\" table if it does not exist.\n        \"\"\"\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS users (\n            username TEXT PRIMARY KEY,\n            password TEXT NOT NULL\n        )\n        \"\"\"\n        self.cursor.execute(create_table_query)\n        self.connection.commit()\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        \"\"\"\n        try:\n            insert_query = \"INSERT INTO users (username, password) VALUES (?, ?)\"\n            self.cursor.execute(insert_query, (username, password))\n            self.connection.commit()\n        except sqlite3.IntegrityError:\n            print(f\"User '{username}' already exists.\")\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for a user in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return: tuple or None, the row from the \"users\" table that matches the search criteria.\n        \"\"\"\n        search_query = \"SELECT username, password FROM users WHERE username = ?\"\n        self.cursor.execute(search_query, (username,))\n        return self.cursor.fetchone()\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        \"\"\"\n        delete_query = \"DELETE FROM users WHERE username = ?\"\n        self.cursor.execute(delete_query, (username,))\n        self.connection.commit()\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Validates user login by checking if the user exists and if the password is correct.\n        :param username: str, the username of the user to validate.\n        :param password: str, the password of the user to validate.\n        :return: bool, True if the user can log in, False otherwise.\n        \"\"\"\n        user = self.search_user_by_username(username)\n        return user is not None and user[1] == password\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        self.connection.close()\n```",
    "93": "```python\nimport numpy as np\n\nclass VectorUtil:\n    \"\"\"\n    The class provides vector operations, including calculating similarity, cosine similarities, average similarity, and IDF weights.\n    \"\"\"\n\n    @staticmethod\n    def similarity(vector_1: np.ndarray, vector_2: np.ndarray) -> float:\n        \"\"\"\n        Compute the cosine similarity between two vectors.\n        :param vector_1: numpy.ndarray, expected shape (dim,).\n        :param vector_2: numpy.ndarray, expected shape (dim,).\n        :return: float, Cosine similarity between `vector_1` and `vector_2`.\n        \"\"\"\n        dot_product = np.dot(vector_1, vector_2)\n        norm_a = np.linalg.norm(vector_1)\n        norm_b = np.linalg.norm(vector_2)\n        return dot_product / (norm_a * norm_b) if norm_a and norm_b else 0.0\n\n    @staticmethod\n    def cosine_similarities(vector_1: np.ndarray, vectors_all: list) -> np.ndarray:\n        \"\"\"\n        Compute cosine similarities between one vector and a set of other vectors.\n        :param vector_1: numpy.ndarray, expected shape (dim,).\n        :param vectors_all: list of numpy.ndarray, expected shape (num_vectors, dim).\n        :return: numpy.ndarray, Contains cosine similarity between `vector_1` and each vector in `vectors_all`.\n        \"\"\"\n        return np.array([VectorUtil.similarity(vector_1, vector) for vector in vectors_all])\n\n    @staticmethod\n    def n_similarity(vector_list_1: list, vector_list_2: list) -> float:\n        \"\"\"\n        Compute average cosine similarity between two sets of vectors.\n        :param vector_list_1: list of numpy.ndarray\n        :param vector_list_2: list of numpy.ndarray\n        :return: float, Average similarities between vector_list_1 and vector_list_2.\n        \"\"\"\n        if not vector_list_1 or not vector_list_2:\n            return 0.0\n        \n        similarities = [VectorUtil.similarity(v1, v2) for v1 in vector_list_1 for v2 in vector_list_2]\n        return np.mean(similarities)\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num: int, number_dict: dict) -> dict:\n        \"\"\"\n        Calculate IDF weights for each count in number_dict.\n        :param total_num: int, total number of documents.\n        :param number_dict: dict, counts of occurrences for each key.\n        :return: dict, IDF weights for each key in number_dict.\n        \"\"\"\n        return {key: np.log((total_num + 1) / (count + 1)) for key, count in number_dict.items()}\n```",
    "97": "```python\nclass Words2Numbers:\n    \"\"\"\n    The class provides a text-to-number conversion utility, allowing conversion of written numbers (in words) to their numerical representation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the word lists and dictionaries required for conversion\n        \"\"\"\n        self.numwords = self._initialize_numwords()\n        self.ordinal_words = {\n            'first': 1, 'second': 2, 'third': 3, 'fifth': 5,\n            'eighth': 8, 'ninth': 9, 'twelfth': 12\n        }\n\n    def _initialize_numwords(self):\n        \"\"\"\n        Initialize the number words mapping.\n        :return: A dictionary mapping words to their numeric values.\n        \"\"\"\n        numwords = {}\n        units = [\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\n            \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n            \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\",\n        ]\n        tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        scales = [\"hundred\", \"thousand\", \"million\", \"billion\", \"trillion\"]\n\n        numwords[\"and\"] = (1, 0)\n        for idx, word in enumerate(units):\n            numwords[word] = (1, idx)\n        for idx, word in enumerate(tens):\n            numwords[word] = (1, idx * 10)\n        for idx, word in enumerate(scales):\n            numwords[word] = (10 ** (idx * 3 or 2), 0)\n\n        return numwords\n\n    def text2int(self, textnum):\n        \"\"\"\n        Convert the word string to the corresponding integer string.\n        :param textnum: string, the word string to be converted\n        :return: string, the final converted integer string\n        \"\"\"\n        if not self.is_valid_input(textnum):\n            raise ValueError(\"Invalid input for conversion.\")\n\n        textnum = textnum.replace(\"-\", \" \")\n        parts = textnum.split()\n        current = result = 0\n\n        for part in parts:\n            if part in self.numwords:\n                scale, increment = self.numwords[part]\n                current += increment\n                if scale > 1:\n                    current *= scale\n                    result += current\n                    current = 0\n            elif part in self.ordinal_words:\n                current += self.ordinal_words[part]\n\n        return str(result + current)\n\n    def is_valid_input(self, textnum):\n        \"\"\"\n        Check if the input text contains only valid words that can be converted into numbers.\n        :param textnum: The input text containing words representing numbers.\n        :return: True if input is valid, False otherwise.\n        \"\"\"\n        words = textnum.replace(\"-\", \" \").split()\n        return all(word in self.numwords or word in self.ordinal_words for word in words)\n```",
    "96": "```python\nclass WeatherSystem:\n    \"\"\"\n    A class representing a weather system that provides functionality to query weather information for a specific city \n    and convert temperature units between Celsius and Fahrenheit.\n    \"\"\"\n\n    def __init__(self, city: str) -> None:\n        \"\"\"\n        Initialize the weather system with a city name.\n        :param city: The name of the city.\n        \"\"\"\n        self.city = city\n        self.temperature = None\n        self.weather = None\n\n    def query(self, weather_list: dict, tmp_units: str = 'celsius') -> tuple:\n        \"\"\"\n        Query the weather system for the weather and temperature of the city, and convert the temperature units based on the input parameter.\n        :param weather_list: A dictionary of weather information for different cities.\n        :param tmp_units: The temperature units to convert to ('celsius' or 'fahrenheit').\n        :return: A tuple containing the temperature and weather of the city, or False if the city is not found.\n        \"\"\"\n        city_weather = weather_list.get(self.city)\n        if city_weather is None:\n            return False\n\n        self.weather = city_weather['weather']\n        self.temperature = city_weather['temperature']\n\n        if tmp_units.lower() == 'fahrenheit':\n            self.temperature = self.celsius_to_fahrenheit(self.temperature)\n\n        return self.temperature, self.weather\n\n    def set_city(self, city: str) -> None:\n        \"\"\"\n        Set the city of the weather system.\n        :param city: The city to set.\n        \"\"\"\n        self.city = city\n\n    @staticmethod\n    def celsius_to_fahrenheit(celsius: float) -> float:\n        \"\"\"\n        Convert the temperature from Celsius to Fahrenheit.\n        :param celsius: The temperature in Celsius.\n        :return: The temperature in Fahrenheit.\n        \"\"\"\n        return (celsius * 9/5) + 32\n\n    @staticmethod\n    def fahrenheit_to_celsius(fahrenheit: float) -> float:\n        \"\"\"\n        Convert the temperature from Fahrenheit to Celsius.\n        :param fahrenheit: The temperature in Fahrenheit.\n        :return: The temperature in Celsius.\n        \"\"\"\n        return (fahrenheit - 32) * 5/9\n```",
    "95": "```python\nclass Warehouse:\n    \"\"\"\n    The class manages inventory and orders, including adding products, updating product quantities,\n    retrieving product quantities, creating orders, changing order statuses, and tracking orders.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize inventory and orders.\"\"\"\n        self.inventory = {}  # Product ID: Product\n        self.orders = {}  # Order ID: Order\n\n    def add_product(self, product_id, name, quantity):\n        \"\"\"\n        Add product to inventory or update quantity if it already exists.\n        :param product_id: int\n        :param name: str, product name\n        :param quantity: int, product quantity\n        \"\"\"\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be positive.\")\n        \n        if product_id in self.inventory:\n            self.inventory[product_id]['quantity'] += quantity\n        else:\n            self.inventory[product_id] = {'name': name, 'quantity': quantity}\n\n    def update_product_quantity(self, product_id, quantity):\n        \"\"\"\n        Update the quantity of the product in inventory based on product_id.\n        :param product_id: int\n        :param quantity: int, quantity to add (can be negative)\n        \"\"\"\n        if product_id not in self.inventory:\n            raise KeyError(\"Product ID not found in inventory.\")\n        \n        new_quantity = self.inventory[product_id]['quantity'] + quantity\n        if new_quantity <= 0:\n            del self.inventory[product_id]\n        else:\n            self.inventory[product_id]['quantity'] = new_quantity\n\n    def get_product_quantity(self, product_id):\n        \"\"\"\n        Get the quantity of a specific product by product_id.\n        :param product_id: int\n        :return: int if the product_id is in inventory, otherwise None\n        \"\"\"\n        return self.inventory[product_id]['quantity'] if product_id in self.inventory else None\n\n    def create_order(self, order_id, product_id, quantity):\n        \"\"\"\n        Create an order which includes the information of the product, like id and quantity.\n        The default value of status is 'Shipped'.\n        :param order_id: int\n        :param product_id: int\n        :param quantity: int, the quantity of product that is selected\n        :return: False if product_id is not in inventory or the quantity is not adequate\n        \"\"\"\n        if product_id not in self.inventory or self.inventory[product_id]['quantity'] < quantity:\n            return False\n        \n        self.orders[order_id] = {\n            'product_id': product_id,\n            'quantity': quantity,\n            'status': 'Shipped'\n        }\n        self.update_product_quantity(product_id, -quantity)\n\n    def change_order_status(self, order_id, status):\n        \"\"\"\n        Change the status of the order if the input order_id is in self.orders.\n        :param order_id: int\n        :param status: str, the state that is going to change to\n        :return: False if the order_id is not in self.orders\n        \"\"\"\n        if order_id not in self.orders:\n            return False\n        \n        self.orders[order_id]['status'] = status\n\n    def track_order(self, order_id):\n        \"\"\"\n        Get the status of a specific order.\n        :param order_id: int\n        :return: str if the order_id is in self.orders, otherwise None\n        \"\"\"\n        return self.orders[order_id]['status'] if order_id in self.orders else None\n```",
    "98": "```python\nimport xml.etree.ElementTree as ET\n\n\nclass XMLProcessor:\n    \"\"\"\n    A class to handle XML files, including reading, writing, processing, and finding elements in an XML file.\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize the XMLProcessor object with the given file name.\n        :param file_name: string, the name of the XML file to be processed.\n        \"\"\"\n        self.file_name = file_name\n        self.root = None\n\n    def read_xml(self):\n        \"\"\"\n        Reads the XML file and returns the root element.\n        :return: Element, the root element of the XML file, or None if an error occurs.\n        \"\"\"\n        if not self.file_name:\n            return None\n        try:\n            tree = ET.parse(self.file_name)\n            self.root = tree.getroot()\n            return self.root\n        except (ET.ParseError, FileNotFoundError):\n            return None\n\n    def write_xml(self, file_name):\n        \"\"\"\n        Writes the XML data to the specified file.\n        :param file_name: string, the name of the file to write the XML data.\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n        if not self.root or not file_name:\n            return False\n        try:\n            tree = ET.ElementTree(self.root)\n            tree.write(file_name, encoding='utf-8', xml_declaration=True)\n            return True\n        except Exception:\n            return False\n\n    def process_xml_data(self, file_name):\n        \"\"\"\n        Modifies the data in XML elements and writes the updated XML data to a new file.\n        :param file_name: string, the name of the file to write the modified XML data.\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n        if not self.root or not file_name:\n            return False\n        for item in self.root.findall('item'):\n            if item.text is not None:\n                item.text = item.text.upper()\n        return self.write_xml(file_name)\n\n    def find_element(self, element_name):\n        \"\"\"\n        Finds the XML elements with the specified name.\n        :param element_name: string, the name of the elements to find.\n        :return: list, a list of found elements with the specified name.\n        \"\"\"\n        if not self.root:\n            return []\n        return self.root.findall(element_name)\n```",
    "94": "```python\nclass VendingMachine:\n    \"\"\"\n    A class to simulate a vending machine, including adding products, inserting coins, purchasing products, \n    viewing balance, replenishing product inventory, and displaying product information.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the vending machine's inventory and balance.\"\"\"\n        self.inventory = {}\n        self.balance = 0.0\n\n    def add_item(self, item_name: str, price: float, quantity: int) -> None:\n        \"\"\"\n        Adds a product to the vending machine's inventory.\n        \n        :param item_name: The name of the product to be added.\n        :param price: The price of the product to be added.\n        :param quantity: The quantity of the product to be added.\n        \"\"\"\n        if item_name in self.inventory:\n            self.inventory[item_name]['quantity'] += quantity\n        else:\n            self.inventory[item_name] = {'price': price, 'quantity': quantity}\n\n    def insert_coin(self, amount: float) -> float:\n        \"\"\"\n        Inserts coins into the vending machine.\n        \n        :param amount: The amount of coins to be inserted.\n        :return: The updated balance of the vending machine.\n        \"\"\"\n        self.balance += amount\n        return self.balance\n\n    def purchase_item(self, item_name: str) -> float or bool:\n        \"\"\"\n        Purchases a product from the vending machine and returns the balance after the purchase.\n        \n        :param item_name: The name of the product to be purchased.\n        :return: The updated balance if successful, otherwise False.\n        \"\"\"\n        if item_name in self.inventory:\n            item = self.inventory[item_name]\n            if item['quantity'] > 0 and self.balance >= item['price']:\n                item['quantity'] -= 1\n                self.balance -= item['price']\n                return self.balance\n        return False\n\n    def restock_item(self, item_name: str, quantity: int) -> bool:\n        \"\"\"\n        Replenishes the inventory of a product already in the vending machine.\n        \n        :param item_name: The name of the product to be replenished.\n        :param quantity: The quantity of the product to be replenished.\n        :return: True if the product was restocked, otherwise False.\n        \"\"\"\n        if item_name in self.inventory:\n            self.inventory[item_name]['quantity'] += quantity\n            return True\n        return False\n\n    def display_items(self) -> str or bool:\n        \"\"\"\n        Displays the products in the vending machine.\n        \n        :return: A string of the products in the vending machine or False if empty.\n        \"\"\"\n        if not self.inventory:\n            return False\n        return '\\n'.join(f\"{name} - ${item['price']:.2f} [{item['quantity']}]\" for name, item in self.inventory.items())\n```",
    "99": "```python\nimport zipfile\nimport os\n\n\nclass ZipFileProcessor:\n    \"\"\"\n    A class to handle zip file operations including reading, extracting, and creating zip files.\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize the ZipFileProcessor with the specified zip file name.\n        \n        :param file_name: str, the name of the zip file to process\n        \"\"\"\n        self.file_name = file_name\n\n    def _is_valid(self):\n        \"\"\"Check if the file name is valid.\"\"\"\n        return bool(self.file_name)\n\n    def read_zip_file(self):\n        \"\"\"\n        Open and return the zip file object.\n        \n        :return: zipfile.ZipFile or None if the file cannot be opened\n        \"\"\"\n        if not self._is_valid():\n            return None\n        try:\n            return zipfile.ZipFile(self.file_name, 'r')\n        except (FileNotFoundError, zipfile.BadZipFile):\n            return None\n\n    def extract_all(self, output_path):\n        \"\"\"\n        Extract all files from the zip file to the specified output path.\n        \n        :param output_path: str, the directory where files will be extracted\n        :return: bool, True if extraction was successful, False otherwise\n        \"\"\"\n        if not self._is_valid() or not output_path:\n            return False\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_ref:\n                zip_ref.extractall(output_path)\n            return True\n        except (FileNotFoundError, zipfile.BadZipFile):\n            return False\n\n    def extract_file(self, file_name, output_path):\n        \"\"\"\n        Extract a specific file from the zip file to the specified output path.\n        \n        :param file_name: str, the name of the file to extract\n        :param output_path: str, the directory where the file will be extracted\n        :return: bool, True if extraction was successful, False otherwise\n        \"\"\"\n        if not self._is_valid() or not file_name or not output_path:\n            return False\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_ref:\n                zip_ref.extract(file_name, output_path)\n            return True\n        except (FileNotFoundError, zipfile.BadZipFile, KeyError):\n            return False\n\n    def create_zip_file(self, files, output_file_name):\n        \"\"\"\n        Create a zip file containing the specified list of files.\n        \n        :param files: list of str, the files to include in the zip\n        :param output_file_name: str, the name of the output zip file\n        :return: bool, True if the zip file was created successfully, False otherwise\n        \"\"\"\n        if not files or not output_file_name:\n            return False\n        try:\n            with zipfile.ZipFile(output_file_name, 'w') as zip_ref:\n                for file in files:\n                    zip_ref.write(file, os.path.basename(file))\n            return True\n        except Exception:\n            return False\n```"
}