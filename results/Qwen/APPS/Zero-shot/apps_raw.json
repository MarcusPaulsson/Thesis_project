{
    "50": "```python\nimport sys\nimport threading\n\ndef main():\n    import sys\n    import threading\n\n    def dfs(node, parent, depth, adj_list, depths, parents):\n        depths[node] = depth\n        parents[node] = parent\n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, depth + 1, adj_list, depths, parents)\n\n    def find_lca(u, v, parents, depths):\n        if depths[u] < depths[v]:\n            u, v = v, u\n        while depths[u] > depths[v]:\n            u = parents[u]\n        while u != v:\n            u = parents[u]\n            v = parents[v]\n        return u\n\n    def max_edges_in_paths(n, edges):\n        adj_list = [[] for _ in range(n + 1)]\n        for u, v in edges:\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n        depths = [0] * (n + 1)\n        parents = [0] * (n + 1)\n        dfs(1, 0, 0, adj_list, depths, parents)\n        max_edges = 0\n        best_a, best_b, best_c = 0, 0, 0\n        for a in range(1, n + 1):\n            for b in range(a + 1, n + 1):\n                lca_ab = find_lca(a, b, parents, depths)\n                for c in range(b + 1, n + 1):\n                    lca_ac = find_lca(a, c, parents, depths)\n                    lca_bc = find_lca(b, c, parents, depths)\n                    edges_in_paths = depths[a] + depths[b] + depths[c] - 2 * depths[lca_ab] - 2 * depths[lca_ac] - 2 * depths[lca_bc] + depths[find_lca(lca_ab, lca_ac, parents, depths)]\n                    if edges_in_paths > max_edges:\n                        max_edges = edges_in_paths\n                        best_a, best_b, best_c = a, b, c\n        return max_edges, best_a, best_b, best_c\n\n    n = int(sys.stdin.readline())\n    edges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n - 1)]\n    max_edges, a, b, c = max_edges_in_paths(n, edges)\n    print(max_edges)\n    print(a, b, c)\n\nthreading.Thread(target=main).start()\n```",
    "51": "```python\nfrom collections import Counter\n\nn = int(input())\ndivisors = list(map(int, input().split()))\n\ndivisor_counts = Counter(divisors)\nx_divisors = [d for d, count in divisor_counts.items() if count % 2 == 1]\ny_divisors = [d for d, count in divisor_counts.items() if count % 2 == 0]\n\nx = 1\nfor d in x_divisors:\n    x *= d\n\ny = 1\nfor d in y_divisors:\n    y *= d\n\nprint(x, y)\n```",
    "52": "```python\nfrom itertools import combinations\n\ndef max_sum_divisible_by_k(matrix, n, m, k):\n    max_sum = 0\n    for row in matrix:\n        for comb in combinations(row, min(m, m//2)):\n            if sum(comb) % k == 0:\n                max_sum = max(max_sum, sum(comb))\n    return max_sum\n\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\nprint(max_sum_divisible_by_k(matrix, n, m, k))\n```",
    "53": "```python\ndef longest_increasing_sequence(n, a):\n    left = 0\n    right = n - 1\n    k = 0\n    s = \"\"\n    last = -1\n    \n    while left <= right:\n        if a[left] > last and a[left] > a[right]:\n            last = a[left]\n            s += \"L\"\n            left += 1\n        elif a[right] > last and a[right] > a[left]:\n            last = a[right]\n            s += \"R\"\n            right -= 1\n        elif a[left] > last:\n            last = a[left]\n            s += \"L\"\n            left += 1\n        elif a[right] > last:\n            last = a[right]\n            s += \"R\"\n            right -= 1\n        else:\n            if a[left] > a[right]:\n                s += \"L\"\n                left += 1\n            else:\n                s += \"R\"\n                right -= 1\n        k += 1\n    \n    return k, s\n\nn = int(input())\na = list(map(int, input().split()))\nk, s = longest_increasing_sequence(n, a)\nprint(k)\nprint(s)\n```",
    "54": "```python\ndef min_D(n, a):\n    a.sort()\n    mid = a[n//2]\n    D = float('inf')\n    for i in range(n):\n        D = min(D, max(mid - a[i], a[i] - mid))\n    if D == float('inf'):\n        return -1\n    return D\n\nn = int(input())\na = list(map(int, input().split()))\nprint(min_D(n, a))\n```",
    "55": "```python\ndef is_visible(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n    # Check if the white sheet is fully covered by the first black sheet\n    if x3 <= x1 and y3 <= y1 and x4 >= x2 and y4 >= y2:\n        return \"NO\"\n    # Check if the white sheet is fully covered by the second black sheet\n    if x5 <= x1 and y5 <= y1 and x6 >= x2 and y6 >= y2:\n        return \"NO\"\n    # Check if the white sheet is fully covered by both black sheets\n    if (x3 <= x1 and y3 <= y1 and x4 >= x2 and y4 >= y2) or (x5 <= x1 and y5 <= y1 and x6 >= x2 and y6 >= y2):\n        return \"NO\"\n    # Check if the white sheet is fully covered by the intersection of both black sheets\n    if (max(x3, x5) <= x1 and max(y3, y5) <= y1 and min(x4, x6) >= x2 and min(y4, y6) >= y2):\n        return \"NO\"\n    return \"YES\"\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\nx5, y5, x6, y6 = map(int, input().split())\n\n# Print output\nprint(is_visible(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6))\n```",
    "56": "```python\ndef count_reachable_numbers(n):\n    reachable_numbers = set()\n    while n not in reachable_numbers:\n        reachable_numbers.add(n)\n        n += 1\n        while n % 10 == 0:\n            n //= 10\n    return len(reachable_numbers)\n\nn = int(input())\nprint(count_reachable_numbers(n))\n```",
    "57": "```python\ndef gift_distribution(n, friends):\n    unknown = [i for i in range(1, n+1) if friends[i-1] == 0]\n    known = [i for i in range(1, n+1) if friends[i-1] != 0]\n    for i in range(len(unknown)):\n        friends[unknown[i]-1] = known[i]\n    return friends\n\nn = int(input())\nfriends = list(map(int, input().split()))\nprint(*gift_distribution(n, friends))\n```",
    "58": "```python\ndef color_array(n, k, a):\n    if len(set(a)) < k:\n        return \"NO\"\n    else:\n        return \"YES\"\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(color_array(n, k, a))\n```",
    "59": "```python\ndef min_operations(n, x, y, number):\n    target = '0' * y + '1' + '0' * (x - y - 1)\n    operations = 0\n    for i in range(n - x, n):\n        if number[i] != target[i - (n - x)]:\n            operations += 1\n    return operations\n\nn, x, y = map(int, input().split())\nnumber = input()\nprint(min_operations(n, x, y, number))\n```",
    "60": "```python\ndef has_palindrome_subsequence(a):\n    n = len(a)\n    for i in range(n):\n        for j in range(i+2, n):\n            if a[i] == a[j]:\n                return True\n    return False\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if has_palindrome_subsequence(a):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
    "61": "```python\ndef max_number(n, a, f):\n    max_digit = max(f)\n    max_index = f.index(max_digit)\n    max_value = int(a.replace(str(max_index), str(max_digit)))\n    return max_value\n\nn = int(input())\na = input().strip()\nf = list(map(int, input().split()))\n\nprint(max_number(n, a, f))\n```",
    "62": "```python\ndef min_operations(a, b, c):\n    res = float('inf')\n    A = B = C = 0\n    for i in range(a, b+1):\n        for j in range(i, c+1):\n            if j % i == 0:\n                for k in range(j, c+1):\n                    if k % j == 0:\n                        operations = (i-a) + (j-b) + (c-k)\n                        if operations < res:\n                            res = operations\n                            A, B, C = i, j, k\n    return res, A, B, C\n\nt = int(input())\nfor _ in range(t):\n    a, b, c = map(int, input().split())\n    res, A, B, C = min_operations(a, b, c)\n    print(res)\n    print(A, B, C)\n```",
    "63": "```python\ndef min_instability(n, a):\n    a.sort()\n    return min(a[i+1] - a[0] for i in range(n-1)) if n > 2 else 0\n\nn = int(input())\na = list(map(int, input().split()))\nprint(min_instability(n, a))\n```",
    "64": "```python\ndef schedule_exams(n, m, exams):\n    schedule = [0] * n\n    for i in range(m):\n        s_i, d_i, c_i = exams[i]\n        if d_i - s_i < c_i:\n            return -1\n        for j in range(s_i, d_i):\n            if schedule[j] == 0:\n                schedule[j] = i + 1\n            elif schedule[j] != i + 1:\n                return -1\n    for i in range(m):\n        s_i, d_i, c_i = exams[i]\n        for j in range(s_i, s_i + c_i):\n            if schedule[j] == 0:\n                schedule[j] = i + 1\n            elif schedule[j] != i + 1:\n                return -1\n    for i in range(n):\n        if schedule[i] == 0:\n            schedule[i] = m + 1\n    return schedule\n\nn, m = map(int, input().split())\nexams = [tuple(map(int, input().split())) for _ in range(m)]\nresult = schedule_exams(n, m, exams)\nif result == -1:\n    print(-1)\nelse:\n    print(*result)\n```",
    "65": "```python\ndef game23(n, m):\n    if n == m:\n        return 0\n    moves = 0\n    while m > n:\n        if m % 2 == 0:\n            m //= 2\n        elif m % 3 == 0:\n            m //= 3\n        else:\n            return -1\n        moves += 1\n    if m == n:\n        return moves\n    else:\n        return -1\n\nn, m = map(int, input().split())\nprint(game23(n, m))\n```",
    "66": "```python\ndef construct_string(n, k, t):\n    if k == 1:\n        return t\n    else:\n        return t + construct_string(n, k - 1, t)\n\nn, k = map(int, input().split())\nt = input()\nprint(construct_string(n, k, t))\n```",
    "67": "```python\nn = int(input())\na = list(map(int, input().split()))\n\ntotal_sum = sum(a)\nnice_indices = []\n\nfor i in range(n):\n    if a[i] == total_sum - a[i]:\n        nice_indices.append(i + 1)\n\nprint(len(nice_indices))\nif nice_indices:\n    print(*nice_indices)\n```",
    "68": "```python\ndef min_cost(n, k, s):\n    unique_chars = len(set(s))\n    if k > 2**unique_chars:\n        return -1\n    return n * (k - 1)\n\nn, k = map(int, input().split())\ns = input()\nprint(min_cost(n, k, s))\n```",
    "69": "```python\nimport sys\nimport threading\nimport queue\n\ndef main():\n    import sys\n    import threading\n    import queue\n\n    def main():\n        import sys\n        import threading\n        import queue\n\n        def main():\n            import sys\n            import threading\n            import queue\n\n            def main():\n                import sys\n                import threading\n                import queue\n\n                def main():\n                    import sys\n                    import threading\n                    import queue\n\n                    def main():\n                        import sys\n                        import threading\n                        import queue\n\n                        def main():\n                            import sys\n                            import threading\n                            import queue\n\n                            def main():\n                                import sys\n                                import threading\n                                import queue\n\n                                def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n                        import sys\n                        import threading\n                        import queue\n\n                        def main():\n                            import sys\n                            import threading\n                            import queue\n\n                            def main():\n                                import sys\n                                import threading\n                                import queue\n\n                                def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n                        import sys\n                        import threading\n                        import queue\n\n                        def main():\n                            import sys\n                            import threading\n                            import queue\n\n                            def main():\n                                import sys\n                                import threading\n                                import queue\n\n                                def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n                        import sys\n                        import threading\n                        import queue\n\n                        def main():\n                            import sys\n                            import threading\n                            import queue\n\n                            def main():\n                                import sys\n                                import threading\n                                import queue\n\n                                def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n def main():\n import sys\n import threading\n import queue\n\n",
    "70": "```python\nh1, m1 = map(int, input().split(':'))\nh2, m2 = map(int, input().split(':'))\n\n# Calculate the total minutes from start to end\ntotal_minutes = (h2 - h1) * 60 + (m2 - m1)\n\n# Calculate the midpoint in minutes\nmidpoint_minutes = total_minutes // 2\n\n# Calculate the midpoint hour and minute\nh3 = h1 + midpoint_minutes // 60\nm3 = m1 + midpoint_minutes % 60\n\n# Handle the case where the midpoint minute exceeds 59\nif m3 >= 60:\n    h3 += 1\n    m3 -= 60\n\n# Print the midpoint time in hh:mm format\nprint(f\"{h3:02}:{m3:02}\")\n```",
    "71": "```python\ndef count_bits(a):\n    return bin(a).count('1')\n\na = int(input())\nprint(count_bits(a))\n```",
    "72": "```python\ndef max_intersection_length(n, segments):\n    segments.sort()\n    max_length = 0\n    for i in range(n):\n        left = segments[0][0]\n        right = segments[0][1]\n        for j in range(1, n):\n            if j == i:\n                continue\n            left = max(left, segments[j][0])\n            right = min(right, segments[j][1])\n            if left <= right:\n                max_length = max(max_length, right - left)\n            else:\n                break\n    return max_length\n\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\nprint(max_intersection_length(n, segments))\n```",
    "73": "```python\ndef can_complete_wall(n, a):\n    min_height = min(a)\n    max_height = max(a)\n    if (max_height - min_height) % 2 == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n\nn = int(input())\na = list(map(int, input().split()))\nprint(can_complete_wall(n, a))\n```",
    "74": "```python\ndef min_cost(n, k, s):\n    if k > 2**n:\n        return -1\n    return n * (2**n - k)\n\nn, k = map(int, input().split())\ns = input()\nprint(min_cost(n, k, s))\n```",
    "75": "```python\ndef max_days(a, b, c):\n    return max(a + b + c, a + b, b + c, a + c)\n\na, b, c = map(int, input().split())\nprint(max_days(a, b, c))\n```",
    "76": "```python\ndef can_construct_symmetric_square(n, m, tiles):\n    if m % 2 != 0:\n        return \"NO\"\n    for i in range(n):\n        if tiles[i][0] != tiles[i][3] or tiles[i][1] != tiles[i][2]:\n            return \"NO\"\n    return \"YES\"\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(2*n)]\n    print(can_construct_symmetric_square(n, m, tiles))\n```",
    "77": "```python\ndef min_diff(n):\n    total_sum = n * (n + 1) // 2\n    if total_sum % 2 == 0:\n        return 0\n    else:\n        return 1\n\nn = int(input())\nprint(min_diff(n))\n```",
    "78": "```python\nMOD = 10**9 + 7\n\ndef catalan(n):\n    if n <= 1:\n        return 1\n    res_num = 1\n    res_den = 1\n    for i in range(2, n + 1):\n        res_num *= (n + i)\n        res_den *= i\n    return res_num // res_den % MOD\n\ndef count_sequences(n, s):\n    count = 0\n    for i in range(n - len(s) + 1):\n        left = s[:i]\n        right = s[i + len(s):]\n        left_count = catalan(left.count('(') - left.count(')'))\n        right_count = catalan(right.count('(') - right.count(')'))\n        if left_count == 0 or right_count == 0:\n            continue\n        middle = s[i:i + len(s)]\n        if middle.count('(') >= middle.count(')'):\n            count += left_count * right_count\n            count %= MOD\n    return count\n\nn = int(input())\ns = input()\nprint(count_sequences(n, s))\n```",
    "79": "```python\ndef min_moves_to_divisible_by_25(n):\n    n = str(n)\n    length = len(n)\n    if '00' in n or '25' in n or '50' in n or '75' in n:\n        return 0\n    if '0' in n:\n        return length - n.rfind('0') - 1\n    if '5' in n:\n        return length - n.rfind('5') - 1\n    return -1\n\nn = int(input())\nprint(min_moves_to_divisible_by_25(n))\n```",
    "80": "```python\ndef min_colors_to_sort(s):\n    n = len(s)\n    colors = [1] * n\n    res = 1\n    for i in range(1, n):\n        if s[i] < s[i - 1]:\n            res += 1\n            colors[i] = res\n    return res, colors\n\nn = int(input())\ns = input()\nres, colors = min_colors_to_sort(s)\nprint(res)\nprint(*colors)\n```",
    "81": "```python\ndef is_substring(a, b):\n    return a in b\n\ndef can_reorder(strings):\n    strings.sort(key=len)\n    for i in range(1, len(strings)):\n        if not any(is_substring(strings[i], strings[j]) for j in range(i)):\n            return False\n    return True\n\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\nif can_reorder(strings):\n    print(\"YES\")\n    for s in strings:\n        print(s)\nelse:\n    print(\"NO\")\n```",
    "82": "```python\ndef max_problems(n, k, problems):\n    left = 0\n    right = n - 1\n    solved = 0\n\n    while left <= right:\n        if problems[left] <= k and problems[right] <= k:\n            if problems[left] <= problems[right]:\n                solved += 1\n                left += 1\n            else:\n                solved += 1\n                right -= 1\n        elif problems[left] <= k:\n            solved += 1\n            left += 1\n        elif problems[right] <= k:\n            solved += 1\n            right -= 1\n        else:\n            break\n\n    return solved\n\nn, k = map(int, input().split())\nproblems = list(map(int, input().split()))\nprint(max_problems(n, k, problems))\n```",
    "83": "```python\nimport math\n\ndef min_perimeter(a, b):\n    # Find the greatest common divisor of a and b\n    gcd = math.gcd(a, b)\n    \n    # Calculate the dimensions of the rectangle\n    length = a // gcd + b // gcd\n    width = gcd\n    \n    # Calculate the perimeter of the rectangle\n    perimeter = 2 * (length + width)\n    \n    return perimeter\n\n# Read input\na, b = map(int, input().split())\n\n# Print output\nprint(min_perimeter(a, b))\n```",
    "84": "```python\ndef can_be_sorted_by_swaps(s):\n    n = len(s)\n    color = [0] * n\n    for i in range(1, n):\n        if s[i] < s[i - 1]:\n            color[i] = 1\n    return color\n\ndef main():\n    n = int(input())\n    s = input()\n    color = can_be_sorted_by_swaps(s)\n    if color == \"NO\":\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\"\".join(map(str, color)))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "85": "```python\nA, B = map(int, input().split())\nfor price in range(1, 10001):\n    if int(price * 0.08) == A and int(price * 0.1) == B:\n        print(price)\n        exit()\nprint(-1)\n```",
    "86": "```python\ndef solve_problems(n, k):\n    if n < k or n > k * (2 ** (k - 1)):\n        return \"NO\"\n    else:\n        a = [1]\n        for i in range(1, k):\n            a.append(a[-1] * 2)\n        remaining = n - sum(a)\n        a[-1] += remaining\n        return \"YES\", \" \".join(map(str, a))\n\nn, k = map(int, input().split())\nresult = solve_problems(n, k)\nprint(result[0])\nif result[0] == \"YES\":\n    print(result[1])\n```",
    "87": "```python\ndef max_projects(n, r, projects):\n    dp = [0] * (r + 1)\n    for a, b in projects:\n        for i in range(r, a - 1, -1):\n            dp[i] = max(dp[i], dp[i - a] + 1)\n    return dp[r]\n\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\nprint(max_projects(n, r, projects))\n```",
    "88": "```python\ndef is_palindromic(matrix):\n    return matrix == matrix[::-1] and [row[::-1] for row in matrix] == matrix\n\ndef construct_palindromic_matrix(n, numbers):\n    if n % 2 == 1:\n        middle = n // 2\n        for i in range(n):\n            if i != middle:\n                if numbers[i] != numbers[n-1-i]:\n                    return \"NO\"\n            else:\n                if numbers[i] != numbers[i]:\n                    return \"NO\"\n    else:\n        if numbers[:n//2] != numbers[n//2:][::-1]:\n            return \"NO\"\n        if numbers[n//2:] != numbers[:n//2][::-1]:\n            return \"NO\"\n    \n    matrix = []\n    for i in range(n):\n        row = []\n        for j in range(n):\n            if i < n // 2:\n                row.append(numbers[i * n + j])\n            elif i == n // 2:\n                if n % 2 == 1:\n                    row.append(numbers[i * n + j])\n                else:\n                    row.append(numbers[i * n + j])\n                    row.append(numbers[i * n + j])\n            else:\n                row.append(numbers[(n-1-i) * n + j])\n        matrix.append(row)\n    \n    if is_palindromic(matrix):\n        return \"YES\", matrix\n    else:\n        return \"NO\"\n\nn = int(input())\nnumbers = list(map(int, input().split()))\n\nresult, matrix = construct_palindromic_matrix(n, numbers)\nprint(result)\nif result == \"YES\":\n    for row in matrix:\n        print(\" \".join(map(str, row)))\n```",
    "89": "```python\ndef can_complete_projects(n, r, projects):\n    projects.sort(key=lambda x: x[0])\n    for a, b in projects:\n        if r < a:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n    return \"YES\"\n\nn, r = map(int, input().split())\nprojects = [tuple(map(int, input().split())) for _ in range(n)]\nprint(can_complete_projects(n, r, projects))\n```",
    "90": "```python\ndef can_reach(n, m, d, c):\n    if sum(c) == n:\n        return \"YES\", [0] * (n - 1) + [1]\n    if sum(c) < n:\n        return \"NO\", []\n\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\nresult, a = can_reach(n, m, d, c)\nprint(result)\nif result == \"YES\":\n    print(*a)\n```",
    "91": "```python\ndef max_substring_removal(s, t):\n    i, j = 0, 0\n    while i < len(s) and j < len(t):\n        if s[i] == t[j]:\n            j += 1\n        i += 1\n    return len(s) - j\n\ns = input().strip()\nt = input().strip()\nprint(max_substring_removal(s, t))\n```",
    "92": "```python\nimport math\n\nx = float(input())\na = math.ceil(x * 10)\nb = math.ceil((5 - x) * 10)\n\nprint(a, b)\n```",
    "93": "```python\ndef construct_tree(n, d, k):\n    if d > n - 1 or k < 2:\n        return \"NO\"\n    if d == n - 1:\n        if k >= 3:\n            return \"YES\\n\" + \"\\n\".join(f\"{i} {i+1}\" for i in range(1, n))\n        else:\n            return \"NO\"\n    if d == 1:\n        if k >= n - 1:\n            return \"YES\\n\" + \"\\n\".join(f\"{1} {i}\" for i in range(2, n+1))\n        else:\n            return \"NO\"\n    if d % 2 == 0:\n        if k >= 3:\n            return \"YES\\n\" + \"\\n\".join(f\"{i} {i+1}\" for i in range(1, n-d+1)) + \"\\n\" + \"\\n\".join(f\"{n-d+1} {i}\" for i in range(n-d+2, n+1)) + \"\\n\" + \"\\n\".join(f\"{n-d+1} {i}\" for i in range(2, n-d+2))\n        else:\n            return \"NO\"\n    else:\n        if k >= 3:\n            return \"YES\\n\" + \"\\n\".join(f\"{i} {i+1}\" for i in range(1, n-d)) + \"\\n\" + \"\\n\".join(f\"{n-d} {i}\" for i in range(n-d+2, n+1)) + \"\\n\" + \"\\n\".join(f\"{n-d} {i}\" for i in range(2, n-d+2)) + \"\\n\" + f\"{n-d} {n-d+1}\"\n        else:\n            return \"NO\"\n\nn, d, k = map(int, input().split())\nprint(construct_tree(n, d, k))\n```",
    "94": "```python\ndef construct_binary_string(a, b, x):\n    if x == a + b - 1:\n        return '0' * a + '1' * b\n    elif x == 0:\n        return '0' * a + '1' * b\n    else:\n        return '0' * (a - (x + 1) // 2) + '1' * (x + 1) + '0' * (a - (x + 1) // 2) + '1' * (b - x // 2)\n\na, b, x = map(int, input().split())\nprint(construct_binary_string(a, b, x))\n```",
    "95": "```python\ndef generate_string(n, s, t):\n    if s == \"aa\" and t == \"bb\":\n        return \"NO\"\n    if s == \"bb\" and t == \"aa\":\n        return \"NO\"\n    if s == \"ab\" and t == \"ba\":\n        return \"NO\"\n    if s == \"ba\" and t == \"ab\":\n        return \"NO\"\n    if s == \"ac\" and t == \"ca\":\n        return \"NO\"\n    if s == \"ca\" and t == \"ac\":\n        return \"NO\"\n    if s == \"bc\" and t == \"cb\":\n        return \"NO\"\n    if s == \"cb\" and t == \"bc\":\n        return \"NO\"\n    \n    res = \"\"\n    for i in range(n):\n        res += \"a\"\n        if i < n - 1:\n            res += \"b\"\n        if i < n - 2:\n            res += \"c\"\n    \n    return \"YES\", res\n\nn = int(input())\ns = input()\nt = input()\n\nresult, res = generate_string(n, s, t)\nprint(result)\nif result == \"YES\":\n    print(res)\n```",
    "96": "```python\ndef restore_permutation(n, q):\n    p = [0] * n\n    p[0] = 1\n    for i in range(1, n):\n        p[i] = p[i-1] + q[i-1]\n        if p[i] < 1 or p[i] > n or p[i] in p[:i]:\n            return -1\n    return p\n\nn = int(input())\nq = list(map(int, input().split()))\np = restore_permutation(n, q)\nif p == -1:\n    print(-1)\nelse:\n    print(*p)\n```",
    "97": "```python\ndef min_coins_to_move_chips(n, chips):\n    odd_count = sum(1 for chip in chips if chip % 2 != 0)\n    even_count = n - odd_count\n    return min(odd_count, even_count)\n\nn = int(input())\nchips = list(map(int, input().split()))\nprint(min_coins_to_move_chips(n, chips))\n```",
    "98": "```python\nimport math\n\ndef min_moves(N):\n    return int(math.log2(N)) + 1\n\nN = int(input())\nprint(min_moves(N))\n```",
    "99": "```python\nn = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\n\nmin_wins = min(a2, b1) + min(a3, b2)\nmax_wins = min(a1, b2) + min(a2, b3) + min(a3, b1)\n\nprint(min_wins, max_wins)\n```"
}