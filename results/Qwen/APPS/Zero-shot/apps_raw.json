{
    "0": "```python\ndef max_accordion_length(s):\n    max_length = -1\n    for i in range(len(s)):\n        if s[i] == '[':\n            for j in range(i+1, len(s)):\n                if s[j] == ']':\n                    for k in range(i+1, j):\n                        if s[k] == ':' and s[k+1] == ':' and all(c == '|' for c in s[k+2:j]):\n                            max_length = max(max_length, j-i+1)\n    return max_length\n\ns = input().strip()\nprint(max_accordion_length(s))\n```",
    "1": "```python\ndef max_digit_sum(x):\n    x = str(x)\n    n = len(x)\n    max_sum = sum(map(int, x))\n    max_num = int(x)\n    \n    for i in range(1, 10**n):\n        num = str(i)\n        if len(num) > n:\n            break\n        if num.count('0') > 0:\n            continue\n        digit_sum = sum(map(int, num))\n        if digit_sum > max_sum or (digit_sum == max_sum and int(num) > max_num):\n            max_sum = digit_sum\n            max_num = int(num)\n    \n    return max_num\n\nx = int(input())\nprint(max_digit_sum(x))\n```",
    "2": "```python\ndef next_lucky_year(n):\n    n += 1\n    while True:\n        if len([int(digit) for digit in str(n) if int(digit) != 0]) <= 1:\n            return n - 1\n        n += 1\n\nn = int(input())\nprint(next_lucky_year(n))\n```",
    "3": "```python\ndef max_painted_sections(n, q, painters):\n    painters.sort(key=lambda x: x[0])\n    max_painted = 0\n    for i in range(q-2):\n        for j in range(i+1, q-1):\n            for k in range(j+1, q):\n                painted = max(painters[i][1], painters[j][1], painters[k][1]) - min(painters[i][0], painters[j][0], painters[k][0]) + 1\n                max_painted = max(max_painted, painted)\n    return max_painted\n\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\nprint(max_painted_sections(n, q, painters))\n```",
    "4": "```python\ndef find_lucky_time(x, hh, mm):\n    y = 0\n    while True:\n        current_time = hh * 60 + mm - x * y\n        if current_time < 0:\n            current_time += 24 * 60\n        if '7' in str(current_time // 60).zfill(2) + str(current_time % 60).zfill(2):\n            return y\n        y += 1\n\nx = int(input())\nhh, mm = map(int, input().split())\nprint(find_lucky_time(x, hh, mm))\n```",
    "5": "```python\nn, pos, l, r = map(int, input().split())\nprint(max(pos - l, r - pos) + (n - r - 1) + (l - 1))\n```",
    "6": "```python\ndef min_blow_to_defeat_zmei(n, x, blows):\n    blows.sort(key=lambda blow: blow[0] - blow[1])\n    blow_count = 0\n    for blow in blows:\n        if x == 0:\n            return blow_count\n        heads_cut = min(blow[0], x)\n        x -= heads_cut\n        x += blow[1]\n        blow_count += 1\n    return -1 if x > 0 else blow_count\n\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = []\n    for _ in range(n):\n        d, h = map(int, input().split())\n        blows.append((d, h))\n    queries.append((n, x, blows))\n\nfor n, x, blows in queries:\n    print(min_blow_to_defeat_zmei(n, x, blows))\n```",
    "7": "```python\nimport math\n\ndef find_empty_day(n, m):\n    day = 0\n    while n > 0:\n        day += 1\n        n = n + m - day\n    return day\n\nn, m = map(int, input().split())\nprint(find_empty_day(n, m))\n```",
    "8": "```python\ndef min_extra_tiles(tiles):\n    suits = {'m': 0, 'p': 0, 's': 0}\n    numbers = [0] * 9\n    for tile in tiles:\n        suits[tile[1]] += 1\n        numbers[int(tile[0]) - 1] += 1\n    extra_tiles = 0\n    for i in range(9):\n        if numbers[i] < 3:\n            extra_tiles += 3 - numbers[i]\n    return extra_tiles\n\ntiles = input().split()\nprint(min_extra_tiles(tiles))\n```",
    "9": "```python\ndef find_grandpa_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b):\n    for i, (x1, y1, x2, y2) in enumerate(sofas, start=1):\n        left = sum(x1 == x and y1 > y2 for x, y1, x2, y in sofas)\n        right = sum(x1 == x and y1 < y2 for x, y1, x2, y in sofas)\n        top = sum(y1 == y and x1 > x2 for x1, y, x2, y2 in sofas)\n        bottom = sum(y1 == y and x1 < x2 for x1, y, x2, y2 in sofas)\n        if left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b:\n            return i\n    return -1\n\n# Read input\nd = int(input())\nn, m = map(int, input().split())\nsofas = [tuple(map(int, input().split())) for _ in range(d)]\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\n# Find Grandpa Maks's sofa\nprint(find_grandpa_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b))\n```",
    "10": "```python\nn = int(input())\nmin_days_off = n // 7 * 2\nmax_days_off = (n // 7 + 1) * 2\nprint(min_days_off, max_days_off)\n```",
    "11": "```python\ndef max_chocolates(n, a, b, p, q):\n    lcm = (a * b) // gcd(a, b)\n    red_tiles = n // a\n    blue_tiles = n // b\n    both_tiles = n // lcm\n    return max(red_tiles * p, blue_tiles * q)\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\nn, a, b, p, q = map(int, input().split())\nprint(max_chocolates(n, a, b, p, q))\n```",
    "12": "```python\ndef max_beauty(n, trophies):\n    max_golden = trophies.count('G')\n    if max_golden == n or max_golden == 0:\n        return max_golden\n\n    golden_indices = [i for i in range(n) if trophies[i] == 'G']\n    max_length = 0\n\n    for i in range(len(golden_indices)):\n        for j in range(i + 1, len(golden_indices)):\n            if golden_indices[j] - golden_indices[i] - 1 == j - i - 1:\n                max_length = max(max_length, golden_indices[j] - golden_indices[i] + 1)\n\n    for i in range(n):\n        if trophies[i] == 'S':\n            for j in range(n):\n                if trophies[j] == 'G':\n                    temp_trophies = list(trophies)\n                    temp_trophies[i], temp_trophies[j] = temp_trophies[j], temp_trophies[i]\n                    temp_golden_indices = [k for k in range(n) if temp_trophies[k] == 'G']\n                    temp_max_length = 0\n\n                    for k in range(len(temp_golden_indices)):\n                        for l in range(k + 1, len(temp_golden_indices)):\n                            if temp_golden_indices[l] - temp_golden_indices[k] - 1 == l - k - 1:\n                                temp_max_length = max(temp_max_length, temp_golden_indices[l] - temp_golden_indices[k] + 1)\n\n                    max_length = max(max_length, temp_max_length)\n\n    return max_length\n\nn = int(input())\ntrophies = input()\nprint(max_beauty(n, trophies))\n```",
    "13": "```python\nfrom collections import defaultdict, deque\n\ndef main():\n    n, k = map(int, input().split())\n    main_courses = set(map(int, input().split()))\n    dependencies = defaultdict(list)\n    for i in range(1, n+1):\n        t, *deps = map(int, input().split())\n        dependencies[i] = deps\n\n    # Topological sort\n    in_degree = [0] * (n+1)\n    for i in range(1, n+1):\n        for dep in dependencies[i]:\n            in_degree[dep] += 1\n\n    queue = deque([i for i in range(1, n+1) if in_degree[i] == 0])\n    order = []\n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        for dep in dependencies[course]:\n            in_degree[dep] -= 1\n            if in_degree[dep] == 0:\n                queue.append(dep)\n\n    # Check if all main courses are in the order\n    if len(order) < n or not main_courses.issubset(set(order)):\n        print(-1)\n    else:\n        print(len(order))\n        print(*order)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "14": "```python\ndef restore_permutation(n, k, p):\n    if k == 1:\n        return p + list(range(n, 1, -1))\n    if p[k-1] > p[k-2]:\n        return p + list(range(n, k, -1)) + [k-1]\n    else:\n        return -1\n\nn, k = map(int, input().split())\np = list(map(int, input().split()))\nprint(restore_permutation(n, k, p))\n```"
}