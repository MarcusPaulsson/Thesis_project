{
    "0": "```python\ndef print_board(board):\n    \"\"\"Prints the Tic-Tac-Toe board.\"\"\"\n    print(\"-------------\")\n    for i in range(3):\n        print(\"|\", board[i * 3], \"|\", board[i * 3 + 1], \"|\", board[i * 3 + 2], \"|\")\n        print(\"-------------\")\n\n\ndef check_win(board, player):\n    \"\"\"Checks if the player has won the game.\"\"\"\n    # Check rows\n    for i in range(3):\n        if board[i * 3] == board[i * 3 + 1] == board[i * 3 + 2] == player:\n            return True\n\n    # Check columns\n    for i in range(3):\n        if board[i] == board[i + 3] == board[i + 6] == player:\n            return True\n\n    # Check diagonals\n    if board[0] == board[4] == board[8] == player:\n        return True\n    if board[2] == board[4] == board[6] == player:\n        return True\n\n    return False\n\n\ndef check_tie(board):\n    \"\"\"Checks if the game is a tie.\"\"\"\n    return all(square != \" \" for square in board)\n\n\ndef get_player_move(board, player):\n    \"\"\"Gets the player's move and validates it.\"\"\"\n    while True:\n        try:\n            move = int(input(f\"Player {player}, enter your move (1-9): \")) - 1\n            if 0 <= move <= 8 and board[move] == \" \":\n                return move\n            else:\n                print(\"Invalid move. Please try again.\")\n        except ValueError:\n            print(\"Invalid input. Please enter a number between 1 and 9.\")\n\n\ndef play_tic_tac_toe():\n    \"\"\"Plays a game of Tic-Tac-Toe.\"\"\"\n    board = [\" \"] * 9\n    current_player = \"X\"\n    game_over = False\n\n    print(\"Welcome to Tic-Tac-Toe!\")\n    print_board(board)\n\n    while not game_over:\n        move = get_player_move(board, current_player)\n        board[move] = current_player\n        print_board(board)\n\n        if check_win(board, current_player):\n            print(f\"Player {current_player} wins!\")\n            game_over = True\n        elif check_tie(board):\n            print(\"It's a tie!\")\n            game_over = True\n        else:\n            current_player = \"O\" if current_player == \"X\" else \"X\"\n\n\nif __name__ == \"__main__\":\n    play_tic_tac_toe()\n```\n",
    "1": "```python\nimport random\n\ndef choose_word():\n    \"\"\"Chooses a random word from a predefined list.\"\"\"\n    words = [\"python\", \"programming\", \"hangman\", \"computer\", \"algorithm\", \"developer\", \"science\", \"mathematics\", \"engineering\", \"technology\"]\n    return random.choice(words)\n\ndef display_word(word, guessed_letters):\n    \"\"\"Displays the word with correctly guessed letters and underscores for unguessed letters.\"\"\"\n    display = \"\"\n    for letter in word:\n        if letter in guessed_letters:\n            display += letter + \" \"\n        else:\n            display += \"_ \"\n    return display.strip()\n\ndef get_guess(guessed_letters):\n    \"\"\"Prompts the user for a letter guess and validates the input.\"\"\"\n    while True:\n        guess = input(\"Guess a letter: \").lower()\n        if len(guess) != 1:\n            print(\"Please enter a single letter.\")\n        elif not guess.isalpha():\n            print(\"Please enter a letter from the alphabet.\")\n        elif guess in guessed_letters:\n            print(\"You already guessed that letter.\")\n        else:\n            return guess\n\ndef play_hangman():\n    \"\"\"Main function to play the Hangman game.\"\"\"\n    word_to_guess = choose_word()\n    guessed_letters = set()\n    lives = 6\n    word_display = display_word(word_to_guess, guessed_letters)\n\n    print(\"Welcome to Hangman!\")\n    print(word_display)\n    print(f\"You have {lives} lives.\")\n\n    while lives > 0 and \"_\" in word_display:\n        guess = get_guess(guessed_letters)\n        guessed_letters.add(guess)\n\n        if guess in word_to_guess:\n            print(\"Correct guess!\")\n            word_display = display_word(word_to_guess, guessed_letters)\n            print(word_display)\n        else:\n            lives -= 1\n            print(f\"Incorrect guess. You have {lives} lives left.\")\n            print(word_display)\n\n        print(f\"Guessed letters: {', '.join(sorted(guessed_letters))}\")\n\n\n    if \"_\" not in word_display:\n        print(\"Congratulations! You guessed the word:\", word_to_guess)\n    else:\n        print(\"You ran out of lives. The word was:\", word_to_guess)\n\nif __name__ == \"__main__\":\n    play_hangman()\n```",
    "2": "```python\nimport random\n\ndef get_player_choice():\n    \"\"\"Gets the player's choice (rock, paper, or scissors).\"\"\"\n    while True:\n        choice = input(\"Choose rock, paper, or scissors: \").lower()\n        if choice in [\"rock\", \"paper\", \"scissors\"]:\n            return choice\n        else:\n            print(\"Invalid choice. Please try again.\")\n\ndef get_computer_choice():\n    \"\"\"Generates a random choice for the computer.\"\"\"\n    return random.choice([\"rock\", \"paper\", \"scissors\"])\n\ndef determine_winner(player_choice, computer_choice):\n    \"\"\"Determines the winner of the game.\"\"\"\n    print(f\"You chose: {player_choice}\")\n    print(f\"The computer chose: {computer_choice}\")\n\n    if player_choice == computer_choice:\n        return \"It's a tie!\"\n    elif (player_choice == \"rock\" and computer_choice == \"scissors\") or \\\n         (player_choice == \"paper\" and computer_choice == \"rock\") or \\\n         (player_choice == \"scissors\" and computer_choice == \"paper\"):\n        return \"You win!\"\n    else:\n        return \"You lose!\"\n\ndef play_game():\n    \"\"\"Plays a single round of Rock-Paper-Scissors.\"\"\"\n    player_choice = get_player_choice()\n    computer_choice = get_computer_choice()\n    result = determine_winner(player_choice, computer_choice)\n    print(result)\n\ndef main():\n    \"\"\"Main function to run the game.\"\"\"\n    print(\"Welcome to Rock-Paper-Scissors!\")\n\n    while True:\n        play_game()\n        play_again = input(\"Play again? (yes/no): \").lower()\n        if play_again != \"yes\":\n            print(\"Thanks for playing!\")\n            break\n\nif __name__ == \"__main__\":\n    main()\n```",
    "3": "```python\nimport random\nimport time\nimport os\n\nclass SnakeGame:\n    def __init__(self, width=20, height=10):\n        self.width = width\n        self.height = height\n        self.snake = [(width // 2, height // 2)]  # Snake starts in the middle\n        self.direction = \"RIGHT\"  # Initial direction\n        self.food = self.create_food()\n        self.score = 0\n        self.game_over = False\n\n    def create_food(self):\n        \"\"\"Creates food at a random empty location.\"\"\"\n        while True:\n            x = random.randint(0, self.width - 1)\n            y = random.randint(0, self.height - 1)\n            if (x, y) not in self.snake:\n                return (x, y)\n\n    def move(self):\n        \"\"\"Moves the snake based on the current direction.\"\"\"\n        head_x, head_y = self.snake[0]\n\n        if self.direction == \"UP\":\n            new_head = (head_x, (head_y - 1) % self.height)  # Wrap around\n        elif self.direction == \"DOWN\":\n            new_head = (head_x, (head_y + 1) % self.height)\n        elif self.direction == \"LEFT\":\n            new_head = ((head_x - 1) % self.width, head_y)\n        elif self.direction == \"RIGHT\":\n            new_head = ((head_x + 1) % self.width, head_y)\n\n        if new_head in self.snake:\n            self.game_over = True\n            return\n\n        self.snake.insert(0, new_head)  # Add new head\n\n        if new_head == self.food:\n            self.score += 1\n            self.food = self.create_food()\n        else:\n            self.snake.pop()  # Remove tail\n\n    def change_direction(self, new_direction):\n        \"\"\"Changes the snake's direction, preventing immediate 180-degree turns.\"\"\"\n        if new_direction == \"UP\" and self.direction != \"DOWN\":\n            self.direction = \"UP\"\n        elif new_direction == \"DOWN\" and self.direction != \"UP\":\n            self.direction = \"DOWN\"\n        elif new_direction == \"LEFT\" and self.direction != \"RIGHT\":\n            self.direction = \"LEFT\"\n        elif new_direction == \"RIGHT\" and self.direction != \"LEFT\":\n            self.direction = \"RIGHT\"\n\n    def draw(self):\n        \"\"\"Draws the game board in the console.\"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear the console\n\n        for y in range(self.height):\n            for x in range(self.width):\n                if (x, y) == self.food:\n                    print(\"F\", end=\"\")  # Food\n                elif (x, y) in self.snake:\n                    print(\"S\", end=\"\")  # Snake\n                else:\n                    print(\".\", end=\"\")  # Empty space\n            print()  # New line at the end of each row\n\n        print(f\"Score: {self.score}\")\n\n    def play(self):\n        \"\"\"Main game loop.\"\"\"\n        while not self.game_over:\n            self.draw()\n            self.move()\n\n            if self.game_over:\n                ",
    "4": "```python\nimport random\n\nclass Minesweeper:\n    def __init__(self, rows, cols, mines):\n        self.rows = rows\n        self.cols = cols\n        self.mines = mines\n        self.board = [[' ' for _ in range(cols)] for _ in range(rows)]\n        self.revealed = [[False for _ in range(cols)] for _ in range(rows)]\n        self.flagged = [[False for _ in range(cols)] for _ in range(rows)]\n        self.mine_locations = []\n        self.game_over = False\n        self.first_move = True\n\n    def print_board(self):\n        print(\"   \" + \" \".join(str(i) for i in range(self.cols)))\n        print(\"  \" + \"-\" * (self.cols * 2 + 1))\n        for i in range(self.rows):\n            row_str = str(i) + \" |\"\n            for j in range(self.cols):\n                if self.flagged[i][j]:\n                    row_str += \"F \"\n                elif self.revealed[i][j]:\n                    row_str += str(self.board[i][j]) + \" \"\n                else:\n                    row_str += \". \"\n            print(row_str)\n        print(\"  \" + \"-\" * (self.cols * 2 + 1))\n\n    def place_mines(self, initial_row, initial_col):\n        mines_placed = 0\n        while mines_placed < self.mines:\n            row = random.randint(0, self.rows - 1)\n            col = random.randint(0, self.cols - 1)\n            if (row, col) not in self.mine_locations and (row, col) != (initial_row, initial_col):\n                self.mine_locations.append((row, col))\n                mines_placed += 1\n\n        for row, col in self.mine_locations:\n            self.board[row][col] = '*'\n\n    def calculate_neighboring_mines(self):\n        for row in range(self.rows):\n            for col in range(self.cols):\n                if self.board[row][col] != '*':\n                    count = 0\n                    for i in range(max(0, row - 1), min(self.rows, row + 2)):\n                        for j in range(max(0, col - 1), min(self.cols, col + 2)):\n                            if (i, j) in self.mine_locations:\n                                count += 1\n                    self.board[row][col] = count if count > 0 else ' '\n\n    def reveal(self, row, col):\n        if not (0 <= row < self.rows and 0 <= col < self.cols):\n            return\n\n        if self.revealed[row][col] or self.flagged[row][col]:\n            return\n\n        self.revealed[row][col] = True\n\n        if self.board[row][col] == '*':\n            self.game_over = True\n            return\n\n        if self.board[row][col] == ' ':\n            for i in range(max(0, row - 1), min(self.rows, row + 2)):\n                for j in range(max(0, col - 1), min(self.cols, col + 2)):\n                    self.reveal(i, j)\n\n    def check_",
    "5": "```python\nimport random\n\ndef generate_secret_code(length=4, digits=6):\n    \"\"\"Generates a random secret code for Mastermind.\"\"\"\n    return [random.randint(1, digits) for _ in range(length)]\n\ndef get_user_guess(length=4, digits=6):\n    \"\"\"Gets a valid guess from the user.\"\"\"\n    while True:\n        try:\n            guess_str = input(f\"Enter your guess ({length} digits, 1-{digits}, separated by spaces): \")\n            guess = [int(x) for x in guess_str.split()]\n            if len(guess) != length:\n                print(f\"Invalid guess length.  Please enter {length} digits.\")\n            elif any(not (1 <= x <= digits) for x in guess):\n                print(f\"Invalid digit.  Please use digits between 1 and {digits}.\")\n            else:\n                return guess\n        except ValueError:\n            print(\"Invalid input.  Please enter numbers separated by spaces.\")\n\ndef evaluate_guess(secret_code, guess):\n    \"\"\"Evaluates a guess and returns the number of correct positions and correct digits.\"\"\"\n    correct_position = 0\n    correct_digit = 0\n    temp_secret = secret_code[:]  # Create a copy to avoid modifying original\n    temp_guess = guess[:]\n\n    # First, find correct positions (exact matches)\n    for i in range(len(secret_code)):\n        if temp_secret[i] == temp_guess[i]:\n            correct_position += 1\n            temp_secret[i] = None  # Mark as matched\n            temp_guess[i] = None  # Mark as matched\n\n    # Then, find correct digits in the wrong positions\n    for i in range(len(secret_code)):\n        if temp_guess[i] is not None:  # Skip already matched positions\n            for j in range(len(secret_code)):\n                if temp_secret[j] is not None and temp_secret[j] == temp_guess[i]:\n                    correct_digit += 1\n                    temp_secret[j] = None  # Mark as matched\n                    break\n\n    return correct_position, correct_digit\n\ndef play_mastermind(code_length=4, num_digits=6, max_guesses=10):\n    \"\"\"Plays the Mastermind game.\"\"\"\n    secret_code = generate_secret_code(code_length, num_digits)\n    guesses_left = max_guesses\n\n    print(\"Welcome to Mastermind!\")\n    print(f\"I've generated a secret code with {code_length} digits, each between 1 and {num_digits}.\")\n    print(f\"You have {max_guesses} guesses to crack the code.\")\n\n    while guesses_left > 0:\n        print(f\"\\nGuesses remaining: {guesses_left}\")\n        guess = get_user_guess(code_length, num_digits)\n        correct_position, correct_digit = evaluate_guess(secret_code, guess)\n\n        print(f\"Correct position: {correct_position}\")\n        print(f\"Correct digit: {correct_digit}\")\n\n        if correct_position == code_length:\n            print(\"\\nCongratulations! You cracked the code!\")\n            return\n\n        guesses_left -= 1\n\n    print(\"\\nYou ran out of guesses.\")\n    print(f\"The secret code was: {secret_code}\")\n\n\nif __name__ == \"__main__\":\n    play_mastermind()\n```",
    "6": "```python\nimport random\n\ndef create_board(size):\n    \"\"\"Creates a board of the given size, initialized with empty cells.\"\"\"\n    return [['.' for _ in range(size)] for _ in range(size)]\n\ndef print_board(board, show_ships=False):\n    \"\"\"Prints the board to the console.\"\"\"\n    size = len(board)\n    print(\"  \" + \" \".join(str(i) for i in range(size)))\n    for i in range(size):\n        row_str = str(i) + \" \"\n        for j in range(size):\n            if show_ships or board[i][j] != 'S':\n                row_str += board[i][j] + \" \"\n            else:\n                row_str += \". \"\n        print(row_str)\n\ndef place_ship(board, ship_length):\n    \"\"\"Places a ship of the given length randomly on the board.\"\"\"\n    size = len(board)\n    while True:\n        orientation = random.choice(['horizontal', 'vertical'])\n        if orientation == 'horizontal':\n            row = random.randint(0, size - 1)\n            col = random.randint(0, size - ship_length)\n            if all(board[row][col + i] == '.' for i in range(ship_length)):\n                for i in range(ship_length):\n                    board[row][col + i] = 'S'\n                return\n        else:  # orientation == 'vertical'\n            row = random.randint(0, size - ship_length)\n            col = random.randint(0, size - 1)\n            if all(board[row + i][col] == '.' for i in range(ship_length)):\n                for i in range(ship_length):\n                    board[row + i][col] = 'S'\n                return\n\ndef get_player_move(size):\n    \"\"\"Gets the player's move from the console.\"\"\"\n    while True:\n        try:\n            move_str = input(\"Enter your move (row col): \")\n            row, col = map(int, move_str.split())\n            if 0 <= row < size and 0 <= col < size:\n                return row, col\n            else:\n                print(\"Invalid coordinates. Try again.\")\n        except ValueError:\n            print(\"Invalid input.  Enter row and column numbers separated by a space.\")\n\ndef process_move(board, row, col):\n    \"\"\"Processes the player's move and updates the board.\"\"\"\n    if board[row][col] == 'S':\n        board[row][col] = 'H'  # Hit\n        print(\"Hit!\")\n        return True\n    elif board[row][col] == '.':\n        board[row][col] = 'M'  # Miss\n        print(\"Miss!\")\n        return False\n    else:\n        print(\"You already targeted that location.\")\n        return False\n\ndef check_win(board):\n    \"\"\"Checks if all ships have been sunk.\"\"\"\n    return all('S' not in row for row in board)\n\ndef play_battleship(board_size=8, ship_lengths=[5, 4, 3, 2]):\n    \"\"\"Plays a game of Battleship.\"\"\"\n    player_board = create_board(board_size)\n    computer_board = create_board(board_size)\n\n    # Place ships on the computer's board\n    for ship_length in ship_lengths:\n        place_ship(computer_board, ship",
    "7": "```python\nimport argparse\nimport time\nimport random\nimport os\n\nclass GameOfLife:\n    def __init__(self, width, height, initial_state=None, density=0.3):\n        self.width = width\n        self.height = height\n        self.grid = self.create_grid(initial_state, density)\n\n    def create_grid(self, initial_state, density):\n        if initial_state:\n            if len(initial_state) != self.height or any(len(row) != self.width for row in initial_state):\n                raise ValueError(\"Initial state dimensions do not match specified width and height.\")\n            return [list(row) for row in initial_state] # Ensure it's mutable\n\n        grid = []\n        for _ in range(self.height):\n            row = [1 if random.random() < density else 0 for _ in range(self.width)]\n            grid.append(row)\n        return grid\n\n    def get_neighbors(self, x, y):\n        neighbors = []\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                if i == 0 and j == 0:\n                    continue\n                nx = (x + i) % self.width  # Toroidal boundary conditions\n                ny = (y + j) % self.height\n                neighbors.append(self.grid[ny][nx])\n        return neighbors\n\n    def update_cell(self, x, y):\n        neighbors = self.get_neighbors(x, y)\n        alive_neighbors = sum(neighbors)\n        cell_state = self.grid[y][x]\n\n        if cell_state == 1:  # Alive\n            if alive_neighbors < 2 or alive_neighbors > 3:\n                return 0  # Dies\n            else:\n                return 1  # Survives\n        else:  # Dead\n            if alive_neighbors == 3:\n                return 1  # Becomes alive\n            else:\n                return 0  # Remains dead\n\n    def update_grid(self):\n        new_grid = []\n        for y in range(self.height):\n            new_row = []\n            for x in range(self.width):\n                new_row.append(self.update_cell(x, y))\n            new_grid.append(new_row)\n        self.grid = new_grid\n\n    def display_grid(self):\n        os.system('cls' if os.name == 'nt' else 'clear') # Clear the screen\n        for row in self.grid:\n            print(\"\".join(['#' if cell == 1 else ' ' for cell in row]))\n\n    def run(self, generations, delay=0.1):\n        for _ in range(generations):\n            self.display_grid()\n            self.update_grid()\n            time.sleep(delay)\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Conway's Game of Life\")\n    parser.add_argument(\"--width\", type=int, default=60, help=\"Width of the grid\")\n    parser.add_argument(\"--height\", type=int, default=30, help=\"Height of the grid\")\n    parser.add_argument(\"--generations\", type=int, default=100, help=\"Number of generations to simulate\")\n    parser.add_argument(\"--delay\", type=float, default=0.1, help=\"Delay between generations (in seconds)\")\n    parser",
    "8": "```python\ndef create_board(rows=6, cols=7):\n    \"\"\"Creates an empty Connect Four board.\"\"\"\n    return [[' ' for _ in range(cols)] for _ in range(rows)]\n\ndef print_board(board):\n    \"\"\"Prints the Connect Four board to the console.\"\"\"\n    for row in reversed(board):\n        print('|' + '|'.join(row) + '|')\n    print('+' + '+'.join(str(i) for i in range(len(board[0]))) + '+')\n\ndef is_valid_move(board, col):\n    \"\"\"Checks if a move is valid in the given column.\"\"\"\n    return 0 <= col < len(board[0]) and board[0][col] == ' '\n\ndef drop_piece(board, col, player):\n    \"\"\"Drops a piece into the specified column for the given player.\"\"\"\n    for row in range(len(board)):\n        if board[row][col] == ' ':\n            board[row][col] = player\n            return\n\ndef check_win(board, player):\n    \"\"\"Checks if the given player has won the game.\"\"\"\n    # Check horizontal\n    for row in range(len(board)):\n        for col in range(len(board[0]) - 3):\n            if board[row][col] == player and \\\n               board[row][col+1] == player and \\\n               board[row][col+2] == player and \\\n               board[row][col+3] == player:\n                return True\n\n    # Check vertical\n    for row in range(len(board) - 3):\n        for col in range(len(board[0])):\n            if board[row][col] == player and \\\n               board[row+1][col] == player and \\\n               board[row+2][col] == player and \\\n               board[row+3][col] == player:\n                return True\n\n    # Check positively sloped diagonals\n    for row in range(len(board) - 3):\n        for col in range(len(board[0]) - 3):\n            if board[row][col] == player and \\\n               board[row+1][col+1] == player and \\\n               board[row+2][col+2] == player and \\\n               board[row+3][col+3] == player:\n                return True\n\n    # Check negatively sloped diagonals\n    for row in range(3, len(board)):\n        for col in range(len(board[0]) - 3):\n            if board[row][col] == player and \\\n               board[row-1][col+1] == player and \\\n               board[row-2][col+2] == player and \\\n               board[row-3][col+3] == player:\n                return True\n\n    return False\n\ndef is_board_full(board):\n    \"\"\"Checks if the board is full.\"\"\"\n    for col in range(len(board[0])):\n        if board[len(board)-1][col] == ' ':\n            return False\n    return True\n\ndef get_player_move(board, player):\n    \"\"\"Gets a valid move from the player.\"\"\"\n    while True:\n        try:\n            col = int(input(f\"Player {player}, enter column (0-{len(board[0])-1}): \"))\n            if is_valid_move(board, col):\n                return col\n            else:\n                print(\"Invalid move. Try again.\")\n        except ValueError:\n            print",
    "9": "```python\nimport random\n\ndef calculate_hand_value(hand):\n    \"\"\"Calculates the value of a hand in Blackjack.  Aces can be 1 or 11.\"\"\"\n    ace_count = hand.count('A')\n    total = 0\n    for card in hand:\n        if card.isdigit():\n            total += int(card)\n        elif card in ('J', 'Q', 'K'):\n            total += 10\n        elif card == 'A':\n            total += 11\n    while total > 21 and ace_count > 0:\n        total -= 10\n        ace_count -= 1\n    return total\n\ndef deal_card(deck):\n    \"\"\"Deals one card from the deck.\"\"\"\n    return deck.pop()\n\ndef create_deck():\n    \"\"\"Creates a standard 52-card deck.\"\"\"\n    suits = ['H', 'D', 'C', 'S']  # Hearts, Diamonds, Clubs, Spades (not used for value)\n    ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']\n    deck = [rank for rank in ranks for suit in suits]\n    random.shuffle(deck)\n    return deck\n\ndef display_hand(hand, hidden=False):\n    \"\"\"Displays a hand of cards.  If hidden is True, only shows the first card.\"\"\"\n    if hidden:\n        print(\"[Hidden]\", end=\" \")\n        for i in range(1, len(hand)):\n            print(hand[i], end=\" \")\n    else:\n        for card in hand:\n            print(card, end=\" \")\n    print()\n\ndef play_blackjack():\n    \"\"\"Plays a game of Blackjack.\"\"\"\n\n    deck = create_deck()\n    player_hand = []\n    dealer_hand = []\n\n    # Deal initial hands\n    for _ in range(2):\n        player_hand.append(deal_card(deck))\n        dealer_hand.append(deal_card(deck))\n\n    # Player's turn\n    print(\"Your hand:\")\n    display_hand(player_hand)\n    print(\"Dealer's hand:\")\n    display_hand(dealer_hand, hidden=True)  # Hide the dealer's first card\n\n    while calculate_hand_value(player_hand) < 21:\n        action = input(\"Hit or stand? (h/s): \").lower()\n        if action == 'h':\n            player_hand.append(deal_card(deck))\n            print(\"Your hand:\")\n            display_hand(player_hand)\n            if calculate_hand_value(player_hand) > 21:\n                print(\"Bust!\")\n                return \"dealer\"  # Dealer wins\n        elif action == 's':\n            break\n        else:\n            print(\"Invalid action. Please enter 'h' or 's'.\")\n\n    # Dealer's turn\n    print(\"\\nDealer's hand:\")\n    display_hand(dealer_hand)\n\n    if calculate_hand_value(player_hand) <= 21:\n        while calculate_hand_value(dealer_hand) < 17:\n            dealer_hand.append(deal_card(deck))\n            print(\"Dealer hits.\")\n            print(\"Dealer's hand:\")\n            display_hand(dealer_hand)\n            if calculate_hand_value(dealer_hand) > 21:\n                print(\"Dealer busts!\")",
    "10": "```python\nimport random\n\ndef play_hammurabi():\n    \"\"\"Plays the game Hammurabi.\"\"\"\n\n    year = 1\n    population = 100\n    grain_stores = 2800\n    acres_owned = 1000\n    bushels_per_acre = 3\n    rats_ate = 200\n    starved = 0\n    immigrants = 0\n\n    print(\"Congratulations, you are the newly appointed ruler of ancient Sumeria!\")\n    print(\"Your reign will last for 10 years, and you will be judged by how well\")\n    print(\"you manage the kingdom. Good luck!\")\n\n    while year <= 10:\n        print(\"\\n-------------------- Year {} --------------------\".format(year))\n        print(\"You are in year {} of your ten year rule.\".format(year))\n        print(\"Population is now {}.\".format(population))\n        print(\"You own {} acres of land.\".format(acres_owned))\n        print(\"You have {} bushels of grain in store.\".format(grain_stores))\n        print(\"Land is worth {} bushels per acre.\".format(bushels_per_acre))\n\n        # Ask how many acres to buy/sell\n        while True:\n            try:\n                acres_to_buy_sell = int(input(\"How many acres do you wish to buy/sell? (Enter a negative number to sell): \"))\n                if acres_to_buy_sell == 0:\n                    break  # No buying or selling\n                elif acres_to_buy_sell > 0:  # Buying\n                    if grain_stores >= acres_to_buy_sell * bushels_per_acre:\n                        grain_stores -= acres_to_buy_sell * bushels_per_acre\n                        acres_owned += acres_to_buy_sell\n                        break\n                    else:\n                        print(\"O Great Hammurabi, we do not have enough grain to buy that much land.\")\n                else:  # Selling\n                    acres_to_sell = abs(acres_to_buy_sell)\n                    if acres_owned >= acres_to_sell:\n                        grain_stores += acres_to_sell * bushels_per_acre\n                        acres_owned -= acres_to_sell\n                        break\n                    else:\n                        print(\"O Great Hammurabi, we do not have enough land to sell.\")\n\n            except ValueError:\n                print(\"Invalid input. Please enter an integer.\")\n\n        # Ask how much grain to feed the people\n        while True:\n            try:\n                grain_to_feed = int(input(\"How much grain do you wish to feed your people? \"))\n                if grain_to_feed <= grain_stores:\n                    grain_stores -= grain_to_feed\n                    break\n                else:\n                    print(\"O Great Hammurabi, we do not have that much grain to feed the people.\")\n            except ValueError:\n                print(\"Invalid input. Please enter an integer.\")\n\n        # Ask how many acres to plant\n        while True:\n            try:\n                acres_to_plant = int(input(\"How many acres do you wish to plant with grain? \"))\n                if acres_to_plant <= acres_owned and acres_to_plant <= grain_stores and acres_to_plant <= population * 10:\n                    grain_stores -= acres_to_plant\n                    break\n                elif acres_to_plant > acres_owned:\n                    print(\"O Great Hammurabi, we do not have that much land.\")\n                elif acres_to_plant > grain_stores:\n                    print",
    "11": "```python\nimport random\n\nclass LightsOut:\n    \"\"\"\n    A class representing the Lights Out game.\n    \"\"\"\n\n    def __init__(self, size=5, initial_state=None):\n        \"\"\"\n        Initializes the game board.\n\n        Args:\n            size (int): The size of the board (size x size).\n            initial_state (list): An optional initial state for the board.\n                                  If None, a random initial state is generated.\n        \"\"\"\n        self.size = size\n        if initial_state is None:\n            self.board = self.generate_random_board()\n        else:\n            self.board = initial_state\n        self.move_count = 0\n\n    def generate_random_board(self):\n        \"\"\"\n        Generates a random initial board state.\n        \"\"\"\n        return [[random.choice([True, False]) for _ in range(self.size)] for _ in range(self.size)]\n\n    def print_board(self):\n        \"\"\"\n        Prints the current state of the board.\n        \"\"\"\n        for row in self.board:\n            print(\" \".join([\"*\" if cell else \".\" for cell in row]))\n\n    def toggle_cell(self, row, col):\n        \"\"\"\n        Toggles the state of a cell (True to False, False to True).\n\n        Args:\n            row (int): The row index of the cell.\n            col (int): The column index of the cell.\n        \"\"\"\n        if 0 <= row < self.size and 0 <= col < self.size:\n            self.board[row][col] = not self.board[row][col]\n\n    def make_move(self, row, col):\n        \"\"\"\n        Makes a move by toggling the selected cell and its neighbors.\n\n        Args:\n            row (int): The row index of the move.\n            col (int): The column index of the move.\n        \"\"\"\n        self.toggle_cell(row, col)\n        self.toggle_cell(row - 1, col)  # Up\n        self.toggle_cell(row + 1, col)  # Down\n        self.toggle_cell(row, col - 1)  # Left\n        self.toggle_cell(row, col + 1)  # Right\n        self.move_count += 1\n\n    def is_solved(self):\n        \"\"\"\n        Checks if the game is solved (all lights are off).\n        \"\"\"\n        return all(not cell for row in self.board for cell in row)\n\n    def play(self):\n        \"\"\"\n        Starts the game loop.\n        \"\"\"\n        print(\"Welcome to Lights Out!\")\n        self.print_board()\n\n        while not self.is_solved():\n            try:\n                row, col = map(int, input(\"Enter row and column (e.g., 0 0): \").split())\n                if 0 <= row < self.size and 0 <= col < self.size:\n                    self.make_move(row, col)\n                    self.print_board()\n                    print(f\"Move count: {self.move_count}\")\n                else:\n                    print(\"Invalid move. Row and column must be between 0 and\", self.size - 1)\n            except ValueError:\n                print(\"Invalid input. Please enter two integers separated by a space.\")\n\n        print(\"Congratulations! You solved the puzzle in\", self.move_count, \"moves.\")\n\n\nif __name__ == \"__main__\":\n    game",
    "12": "```python\nimport time\nimport random\nimport os\n\ndef clear_screen():\n    \"\"\"Clears the terminal screen.\"\"\"\n    os.system('cls' if os.name == 'nt' else 'clear')\n\nclass Paddle:\n    def __init__(self, x, height, char=\"#\"):\n        self.x = x\n        self.y = 0  # Paddle is centered vertically initially\n        self.height = height\n        self.char = char\n\n    def move_up(self, board_height):\n        self.y = max(0, self.y - 1)\n\n    def move_down(self, board_height):\n        self.y = min(board_height - self.height, self.y + 1)\n\n    def get_coords(self):\n        return [(self.x, self.y + i) for i in range(self.height)]\n\nclass Ball:\n    def __init__(self, x, y, dx, dy, char=\"O\"):\n        self.x = x\n        self.y = y\n        self.dx = dx\n        self.dy = dy\n        self.char = char\n\n    def move(self):\n        self.x += self.dx\n        self.y += self.dy\n\n    def bounce_off_wall(self):\n        self.dy *= -1\n\n    def bounce_off_paddle(self):\n        self.dx *= -1\n\nclass PongGame:\n    def __init__(self, width=60, height=20, paddle_height=5, ball_speed=1):\n        self.width = width\n        self.height = height\n        self.paddle_height = paddle_height\n        self.ball_speed = ball_speed  #Controls how often ball moves\n\n        self.paddle1 = Paddle(1, self.paddle_height)\n        self.paddle2 = Paddle(self.width - 2, self.paddle_height)\n        self.ball = Ball(self.width // 2, self.height // 2, random.choice([-1, 1]), random.choice([-1, 1]))\n\n        self.score1 = 0\n        self.score2 = 0\n        self.game_over = False\n        self.last_ball_move_time = time.time() #used to control ball speed\n\n    def draw_board(self):\n        \"\"\"Draws the game board with paddles and ball.\"\"\"\n        board = [[' ' for _ in range(self.width)] for _ in range(self.height)]\n\n        # Draw paddles\n        for x, y in self.paddle1.get_coords():\n            board[y][x] = self.paddle1.char\n        for x, y in self.paddle2.get_coords():\n            board[y][x] = self.paddle2.char\n\n        # Draw ball\n        board[self.ball.y][self.ball.x] = self.ball.char\n\n        # Draw score\n        score_str = f\"Player 1: {self.score1}  |  Player 2: {self.score2}\"\n        score_x = (self.width - len(score_str)) // 2\n        for i, char in enumerate(score_str):\n            board[0][score_x + i] = char\n\n        # Draw borders\n        for i in range(self.width):\n            board[0][i] = board[self.height - 1][i] = '-'\n        for i in range(self.height):\n",
    "13": "```python\nimport random\nimport os\nimport sys\nimport time\n\nclass Tetris:\n    def __init__(self, width=10, height=20):\n        self.width = width\n        self.height = height\n        self.board = [['.' for _ in range(width)] for _ in range(height)]\n        self.current_piece = None\n        self.next_piece = self.get_random_piece()\n        self.current_x = 0\n        self.current_y = 0\n        self.score = 0\n        self.game_over = False\n        self.level = 1\n        self.lines_cleared = 0\n        self.speed = 1  # Blocks per second\n\n        self.pieces = {\n            \"I\": [[(0, 0), (0, 1), (0, 2), (0, 3)], \"cyan\"],\n            \"J\": [[(0, 0), (1, 0), (1, 1), (1, 2)], \"blue\"],\n            \"L\": [[(0, 2), (1, 0), (1, 1), (1, 2)], \"orange\"],\n            \"O\": [[(0, 0), (0, 1), (1, 0), (1, 1)], \"yellow\"],\n            \"S\": [[(0, 1), (0, 2), (1, 0), (1, 1)], \"green\"],\n            \"T\": [[(0, 1), (1, 0), (1, 1), (1, 2)], \"purple\"],\n            \"Z\": [[(0, 0), (0, 1), (1, 1), (1, 2)], \"red\"],\n        }\n\n    def get_random_piece(self):\n        return random.choice(list(self.pieces.keys()))\n\n    def spawn_piece(self):\n        self.current_piece = self.next_piece\n        self.next_piece = self.get_random_piece()\n        self.current_x = self.width // 2 - 2 if self.current_piece == \"I\" else self.width // 2 - 1\n        self.current_y = 0\n\n        if not self.is_valid_position(self.current_piece, self.current_x, self.current_y):\n            self.game_over = True\n            return False\n\n        return True\n\n    def is_valid_position(self, piece, x, y, rotation=0):\n        piece_shape = self.rotate_piece(piece, rotation)\n        for px, py in piece_shape:\n            board_x = x + px\n            board_y = y + py\n            if (\n                board_x < 0\n                or board_x >= self.width\n                or board_y >= self.height\n                or (board_y >= 0 and self.board[board_y][board_x] != '.')\n            ):\n                return False\n        return True\n\n    def rotate_piece(self, piece, rotation):\n        shape = self.pieces[piece][0]\n        rotated_shape = []\n        for x, y in shape:\n            if piece == \"O\":  # O piece doesn't rotate\n                rotated_shape.append((x, y))\n            else:\n                for _ in range(rotation):\n                    x, y = -y, x\n                rotated_shape.append((",
    "14": "```python\nimport math\nimport random\nimport time\n\nclass Point:\n    \"\"\"Represents a 2D point.\"\"\"\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return f\"({self.x}, {self.y})\"\n\nclass Vector:\n    \"\"\"Represents a 2D vector.\"\"\"\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return f\"({self.x}, {self.y})\"\n    \n    def magnitude(self):\n        return math.sqrt(self.x**2 + self.y**2)\n\n    def normalize(self):\n        mag = self.magnitude()\n        if mag > 0:\n            return Vector(self.x / mag, self.y / mag)\n        else:\n            return Vector(0, 0)\n    \n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __mul__(self, scalar):\n        return Vector(self.x * scalar, self.y * scalar)\n\nclass GameObject:\n    \"\"\"Base class for game objects.\"\"\"\n    def __init__(self, position, velocity, radius):\n        self.position = position\n        self.velocity = velocity\n        self.radius = radius\n\n    def update(self, dt):\n        self.position.x += self.velocity.x * dt\n        self.position.y += self.velocity.y * dt\n\n    def collides_with(self, other):\n        distance = math.sqrt((self.position.x - other.position.x)**2 + (self.position.y - other.position.y)**2)\n        return distance < self.radius + other.radius\n\n    def __str__(self):\n       return f\"Position: {self.position}, Velocity: {self.velocity}, Radius: {self.radius}\"\n\n\nclass Asteroid(GameObject):\n    \"\"\"Represents an asteroid.\"\"\"\n    def __init__(self, position, velocity, radius):\n        super().__init__(position, velocity, radius)\n\n    def split(self):\n        \"\"\"Splits the asteroid into two smaller asteroids.\"\"\"\n        if self.radius > 10:  # Minimum size for splitting\n            new_radius = self.radius / 2\n            angle1 = random.uniform(0, 2 * math.pi)\n            angle2 = random.uniform(0, 2 * math.pi)\n\n            # Create new velocities for the smaller asteroids\n            new_velocity1 = Vector(self.velocity.x + math.cos(angle1) * 50, self.velocity.y + math.sin(angle1) * 50)\n            new_velocity2 = Vector(self.velocity.x + math.cos(angle2) * 50, self.velocity.y + math.sin(angle2) * 50)\n\n            # Create new positions for the smaller asteroids (slightly offset)\n            new_position1 = Point(self.position.x + math.cos(angle1) * self.radius, self.position.y + math.sin(angle1) * self.radius)\n            new_position2 = Point(self.position.x - math.cos(angle2) * self.radius, self.position.y - math.sin(angle2) * self.radius)\n\n            return [Asteroid(new",
    "15": "```python\nimport random\nimport time\n\nclass Boggle:\n    def __init__(self, size=4, dictionary_file=\"dictionary.txt\"):\n        self.size = size\n        self.board = self.generate_board()\n        self.dictionary = self.load_dictionary(dictionary_file)\n        self.found_words = set()\n        self.start_time = 0\n        self.end_time = 0\n\n    def generate_board(self):\n        \"\"\"Generates a random Boggle board.\"\"\"\n        dice = [\n            \"RIFOBX\", \"IFEHSE\", \"VHLORW\", \"LNZNRD\", \"DISTRU\",\n            \"IEASIF\", \"UIHMQU\", \"MJOQAB\", \"AEGAEE\", \"PRRSYI\",\n            \"BBLJOA\", \"EHISPN\", \"VETIGN\", \"ANEDVZ\", \"PCSMTU\", \"BALYET\"\n        ]\n        board = [['' for _ in range(self.size)] for _ in range(self.size)]\n        for i in range(self.size):\n            for j in range(self.size):\n                board[i][j] = random.choice(dice[i * self.size + j])\n        return board\n\n    def load_dictionary(self, filename):\n        \"\"\"Loads a dictionary from a file.\"\"\"\n        try:\n            with open(filename, \"r\") as f:\n                words = set(word.strip().upper() for word in f)\n            return words\n        except FileNotFoundError:\n            print(f\"Dictionary file not found: {filename}\")\n            return set()\n\n    def display_board(self):\n        \"\"\"Displays the Boggle board.\"\"\"\n        print(\"Boggle Board:\")\n        for row in self.board:\n            print(\" \".join(row))\n        print()\n\n    def is_valid_move(self, row, col, visited):\n        \"\"\"Checks if a move is valid.\"\"\"\n        return (0 <= row < self.size and\n                0 <= col < self.size and\n                (row, col) not in visited)\n\n    def find_words_recursive(self, row, col, current_word, visited):\n        \"\"\"Recursively searches for words on the board.\"\"\"\n        current_word += self.board[row][col]\n        if len(current_word) >= 3 and current_word in self.dictionary and current_word not in self.found_words:\n            self.found_words.add(current_word)\n\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                new_row = row + dr\n                new_col = col + dc\n                if self.is_valid_move(new_row, new_col, visited):\n                    new_visited = visited.copy()\n                    new_visited.add((row, col))\n                    self.find_words_recursive(new_row, new_col, current_word, new_visited)\n\n    def find_all_words(self):\n        \"\"\"Finds all valid words on the board.\"\"\"\n        for row in range(self.size):\n            for col in range(self.size):\n                self.find_words_recursive(row, col, \"\", set())\n\n    def play(self, time_limit=60):\n        \"\"\"Plays a game of Boggle.\"\"\"\n        self.start_time",
    "16": "```python\nimport random\nimport time\nimport os\n\nclass PacMan:\n    def __init__(self, width=15, height=10):\n        self.width = width\n        self.height = height\n        self.grid = [[' ' for _ in range(width)] for _ in range(height)]\n        self.pacman_x = width // 2\n        self.pacman_y = height // 2\n        self.ghost_x = 1\n        self.ghost_y = 1\n        self.food = 0\n        self.game_over = False\n        self.score = 0\n\n        # Initialize food\n        for y in range(height):\n            for x in range(width):\n                if random.random() < 0.8:  # Adjust density as needed\n                    self.grid[y][x] = '.'\n                    self.food += 1\n        self.grid[self.pacman_y][self.pacman_x] = 'P'\n        self.grid[self.ghost_y][self.ghost_x] = 'G'\n\n    def print_grid(self):\n        os.system('cls' if os.name == 'nt' else 'clear')  # Clear screen\n        for row in self.grid:\n            print(''.join(row))\n        print(f\"Score: {self.score}\")\n\n    def move_pacman(self, direction):\n        new_x = self.pacman_x\n        new_y = self.pacman_y\n\n        if direction == 'up':\n            new_y -= 1\n        elif direction == 'down':\n            new_y += 1\n        elif direction == 'left':\n            new_x -= 1\n        elif direction == 'right':\n            new_x += 1\n        else:\n            return  # Invalid direction\n\n        if 0 <= new_x < self.width and 0 <= new_y < self.height:\n            if self.grid[new_y][new_x] == '.':\n                self.food -= 1\n                self.score += 10\n            elif self.grid[new_y][new_x] == 'G':\n                self.game_over = True\n                return\n\n            self.grid[self.pacman_y][self.pacman_x] = ' '\n            self.pacman_x = new_x\n            self.pacman_y = new_y\n            self.grid[self.pacman_y][self.pacman_x] = 'P'\n\n    def move_ghost(self):\n        possible_moves = []\n        if self.ghost_x > 0:\n            possible_moves.append('left')\n        if self.ghost_x < self.width - 1:\n            possible_moves.append('right')\n        if self.ghost_y > 0:\n            possible_moves.append('up')\n        if self.ghost_y < self.height - 1:\n            possible_moves.append('down')\n\n        if not possible_moves:\n            return\n\n        direction = random.choice(possible_moves)\n        new_x = self.ghost_x\n        new_y = self.ghost_y\n\n        if direction == 'up':\n            new_y -= 1\n        elif direction == 'down':\n            new_y += 1\n        elif direction == 'left':\n            new_x -= 1\n        elif direction == 'right':\n",
    "17": "```python\nimport time\nimport random\nimport os\n\nclass Dinosaur:\n    def __init__(self):\n        self.x = 0\n        self.y = 0\n        self.height = 2\n        self.width = 3\n        self.is_jumping = False\n        self.jump_height = 5\n        self.jump_velocity = 2\n        self.position = 0  # 0: grounded, >0: jumping\n\n    def jump(self):\n        if not self.is_jumping:\n            self.is_jumping = True\n            self.position = self.jump_height\n\n    def update(self):\n        if self.is_jumping:\n            self.position -= self.jump_velocity\n            if self.position <= 0:\n                self.position = 0\n                self.is_jumping = False\n\n    def draw(self):\n        dino_display = []\n        for i in range(self.height):\n            dino_display.append([' '] * self.width)\n\n        if self.position == 0:\n            dino_display[0][0] = 'O'\n            dino_display[0][1] = '='\n            dino_display[0][2] = '='\n            dino_display[1][1] = '|'\n            dino_display[1][2] = '\\\\'\n        else:\n            dino_display[0][0] = 'O'\n            dino_display[0][1] = '='\n            dino_display[0][2] = '='\n            dino_display[1][1] = '|'\n            dino_display[1][2] = '\\\\'\n\n        return dino_display\n\nclass Obstacle:\n    def __init__(self, x, height, width):\n        self.x = x\n        self.y = 0\n        self.height = height\n        self.width = width\n\n    def move(self, speed):\n        self.x -= speed\n\n    def draw(self):\n        obstacle_display = []\n        for i in range(self.height):\n            obstacle_display.append(['#'] * self.width)\n        return obstacle_display\n\n\nclass Game:\n    def __init__(self, width=60, height=10):\n        self.width = width\n        self.height = height\n        self.dinosaur = Dinosaur()\n        self.obstacles = []\n        self.score = 0\n        self.speed = 1\n        self.game_over = False\n        self.obstacle_spawn_rate = 0.02\n\n    def generate_obstacle(self):\n        if random.random() < self.obstacle_spawn_rate:\n            obstacle_height = random.randint(1, 3)\n            obstacle_width = random.randint(1, 3)\n            x = self.width - 1\n            self.obstacles.append(Obstacle(x, obstacle_height, obstacle_width))\n\n    def update(self):\n        self.dinosaur.update()\n        for obstacle in self.obstacles:\n            obstacle.move(self.speed)\n\n        # Remove obstacles that are off-screen\n        self.obstacles = [obstacle for obstacle in self.obstacles if obstacle.x + obstacle.width > 0]\n\n        # Collision detection\n        for obstacle in self.obstacles:\n            if self.check_collision(obstacle):\n                self.game_over = True\n                break\n\n        self.score += 1\n        if"
}