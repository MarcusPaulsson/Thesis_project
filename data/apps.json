{"id": 0, "question": "Polycarp has $n$ different binary words. A word called binary if it contains only characters '0' and '1'. For example, these words are binary: \"0001\", \"11\", \"0\" and \"0011100\".\n\nPolycarp wants to offer his set of $n$ binary words to play a game \"words\". In this game, players name words and each next word (starting from the second) must start with the last character of the previous word. The first word can be any. For example, these sequence of words can be named during the game: \"0101\", \"1\", \"10\", \"00\", \"00001\".\n\nWord reversal is the operation of reversing the order of the characters. For example, the word \"0111\" after the reversal becomes \"1110\", the word \"11010\" after the reversal becomes \"01011\".\n\nProbably, Polycarp has such a set of words that there is no way to put them in the order correspondent to the game rules. In this situation, he wants to reverse some words from his set so that:  the final set of $n$ words still contains different words (i.e. all words are unique);  there is a way to put all words of the final set of words in the order so that the final sequence of $n$ words is consistent with the game rules. \n\nPolycarp wants to reverse minimal number of words. Please, help him.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases in the input. Then $t$ test cases follow.\n\nThe first line of a test case contains one integer $n$ ($1 \\le n \\le 2\\cdot10^5$) \u2014 the number of words in the Polycarp's set. Next $n$ lines contain these words. All of $n$ words aren't empty and contains only characters '0' and '1'. The sum of word lengths doesn't exceed $4\\cdot10^6$. All words are different.\n\nGuaranteed, that the sum of $n$ for all test cases in the input doesn't exceed $2\\cdot10^5$. Also, guaranteed that the sum of word lengths for all test cases in the input doesn't exceed $4\\cdot10^6$.\n\n\n-----Output-----\n\nPrint answer for all of $t$ test cases in the order they appear.\n\nIf there is no answer for the test case, print -1. Otherwise, the first line of the output should contain $k$ ($0 \\le k \\le n$) \u2014 the minimal number of words in the set which should be reversed. The second line of the output should contain $k$ distinct integers \u2014 the indexes of the words in the set which should be reversed. Words are numerated from $1$ to $n$ in the order they appear. If $k=0$ you can skip this line (or you can print an empty line). If there are many answers you can print any of them.\n\n\n-----Example-----\nInput\n4\n4\n0001\n1000\n0011\n0111\n3\n010\n101\n0\n2\n00000\n00001\n4\n01\n001\n0001\n00001\n\nOutput\n1\n3 \n-1\n0\n\n2\n1 2", "solutions": "[\"for _ in range(int(input())):\\n    n = int(input())\\n    mass = []\\n    zo = 0\\n    oz = 0\\n    zz = 0\\n    oo = 0\\n    ozs = []\\n    zos = []\\n    ozss = set()\\n    zoss = set()\\n    for j in range(n):\\n        k = input()\\n        mass.append(k)\\n        if k[0] == '0' and k[-1] == '1':\\n            zoss.add(k)\\n            zos.append(j + 1)\\n            zo += 1\\n        elif k[0] == '1' and k[-1] == '0':\\n            ozss.add(k)\\n            ozs.append(j + 1)\\n            oz += 1\\n        elif k[0] == '0' and k[-1] == '0':\\n            zz += 1\\n        else:\\n            oo += 1\\n    if zz and oo and not oz and not zo:\\n        print(-1)\\n        continue\\n    else:\\n        if zo > oz:\\n            print((zo - oz) // 2)\\n            ans = []\\n            need = (zo - oz) // 2\\n            i = 0\\n            while need:\\n                zzz = mass[zos[i] - 1][len(mass[zos[i] - 1]) - 1:: -1]\\n                if zzz not in ozss:\\n                    ans.append(zos[i])\\n                    need -= 1\\n                i += 1\\n            print(*ans)\\n        else:\\n            print((oz - zo) // 2)\\n            ans = []\\n            need = (oz - zo) // 2\\n            i = 0\\n            while need:\\n                zzz = mass[ozs[i] - 1][len(mass[ozs[i] - 1]) - 1:: -1]\\n                if zzz not in zoss:\\n                    ans.append(ozs[i])\\n                    need -= 1\\n                i += 1\\n            print(*ans)\\n\", \"k = int(input())\\nfor i in range(k):\\n    is_t = set()\\n    a = dict()\\n    a['00'] = []\\n    a['11'] = []\\n    a['01'] = []\\n    a['10'] = []    \\n    n = int(input())\\n    s = []\\n    for i in range(n):\\n        b = input()\\n        a[b[0] + b[-1]].append(i)\\n        s.append(b)\\n        is_t.add(b)\\n    c = len(a['10'])\\n    d = len(a['01'])\\n    if c + d == 0:\\n        if len(a['00']) == 0 or len(a['11']) == 0:\\n            print(0)\\n        else:\\n            print(-1)\\n    elif c > d:\\n        ans = []\\n        i = 0\\n        m = (d + c) // 2\\n        while d != m and i < len(a['10']):\\n            s1 = s[a['10'][i]]\\n            if s1[::-1] not in is_t:\\n                d += 1\\n                ans.append(a['10'][i] + 1)\\n            i += 1\\n        if d != m:\\n            print(-1)\\n        else:\\n            print(len(ans))\\n            print(*ans)\\n    else:\\n        ans = []\\n        i = 0\\n        m = (d + c) // 2\\n        while c != m and i < len(a['01']):\\n            s1 = s[a['01'][i]]\\n            if s1[::-1] not in is_t:\\n                c += 1\\n                ans.append(a['01'][i] + 1)\\n            i += 1\\n        if c != m:\\n            print(-1)\\n        else:\\n            print(len(ans))\\n            print(*ans)\\n\", \"N = int(input())\\n\\ndef ceildiv(x, y):\\n    if x % y == 0:\\n        return x // y\\n    else:\\n        return x // y + 1\\n\\nfor _ in range(N):\\n    doms = []\\n    oc, zc = 0, 0\\n    n = int(input())\\n\\n    used = set()\\n    fulls = dict()\\n\\n    for i in range(n):\\n        d = input()\\n        used.add(d)\\n        if d[0] != d[-1]:\\n            fulls[i] = d\\n            doms.append((i, (d[0], d[-1])))\\n        else:\\n            if d[0] == '0':\\n                zc = 1\\n            else:\\n                oc = 1\\n\\n    if len(doms) == 0:\\n        if zc == 1 and oc == 1:\\n            print(-1)\\n        else:\\n            print(0)\\n    else:\\n        # print(doms)\\n\\n        _01 = 0\\n        _10 = 0\\n\\n        _01_indexes = []\\n        _10_indexes = []\\n\\n\\n        for dom in doms:\\n            if dom[1] == ('0', '1'):\\n                _01 += 1\\n                _01_indexes.append(dom[0])\\n            else:\\n                _10 += 1\\n                _10_indexes.append(dom[0])\\n\\n        if _10 < _01:\\n            _01, _10 = _10, _01\\n            _01_indexes, _10_indexes = _10_indexes, _01_indexes\\n\\n        _10_indexes = [x for x in _10_indexes if fulls[x][::-1] not in used] \\n\\n        need = ceildiv(_10-_01-1, 2)\\n        if len(_10_indexes) >= need:\\n            print(need)\\n            print( ' '.join(list([str(x+1) for x in _10_indexes[:need]])) )\\n        else:\\n            print(-1)\\n\\n    # print(\\\"===\\\")\\n        # print(ceil(abs(doms.count(('0', '1')) - doms.count(('1', '0'))) - 1, 2))\\n\\n\", \"t=int(input())\\nfor _ in range(t):\\n    n=int(input())\\n    k={\\\"01\\\":0,\\\"00\\\":0,\\\"11\\\":0,\\\"10\\\":0}\\n    ab=[]\\n    ba=[]\\n    a=[]\\n    ra=set()\\n    rb=set()\\n    for i in range(n):\\n        s=input()\\n        ts=s[0]+s[-1]\\n        k[ts]+=1\\n        if ts==\\\"01\\\":\\n            ab.append([str(i+1),s])\\n            ra.add(s)\\n        if ts==\\\"10\\\":\\n            ba.append([str(i+1),s])\\n            rb.add(s)\\n    if k[\\\"01\\\"]==0 and k[\\\"10\\\"]==0 and k[\\\"00\\\"]>0 and k[\\\"11\\\"]>0:\\n        ans=-1\\n    else:\\n        if k[\\\"01\\\"]==k[\\\"10\\\"] or k[\\\"01\\\"]==k[\\\"10\\\"]+1 or k[\\\"01\\\"]==k[\\\"10\\\"]-1:\\n            ans=0\\n        else:\\n            m=(k[\\\"01\\\"]+k[\\\"10\\\"])//2 if (k[\\\"01\\\"]+k[\\\"10\\\"])%2==0 else (k[\\\"01\\\"]+k[\\\"10\\\"])//2+1\\n            if k[\\\"01\\\"]>m:\\n                ans=k[\\\"01\\\"]-m\\n                for i in range(len(ab)):\\n                    psp=ab[i][1]\\n                    nn=list(psp)\\n                    nn.reverse()\\n                    psp=\\\"\\\".join(nn)\\n                    c1=len(rb)\\n                    rb.add(psp)\\n                    c2=len(rb)\\n                    if c1!=c2:\\n                        a.append(ab[i][0])\\n                if len(a)>=ans:\\n                    a=a[:ans]\\n                else:\\n                    ans=-1\\n            else:\\n                ans=k[\\\"10\\\"]-m\\n                for i in range(len(ba)):\\n                    psp=ba[i][1]\\n                    nn=list(psp)\\n                    nn.reverse()\\n                    psp=\\\"\\\".join(nn)\\n                    c1=len(ra)\\n                    ra.add(psp)\\n                    c2=len(ra)\\n                    if c1!=c2:\\n                        a.append(ba[i][0])\\n                if len(a)>=ans:\\n                    a=a[:ans]\\n                else:\\n                    ans=-1\\n    print(ans)\\n    if ans>0:\\n        print(\\\" \\\".join(a))\\n\", \"t=int(input())\\nfor i in range(t):\\n    n=int(input())\\n    i0,i1=[],[]\\n    l0,l1=[],[]\\n    h0,h1=False,False\\n    for i in range(n):\\n        t=input()\\n        if t[0]=='0' and t[-1]=='1':\\n            i0.append(i)\\n            l0.append(t)\\n        elif t[0]=='1' and t[-1]=='0':\\n            i1.append(i)\\n            l1.append(t)\\n        elif t[0]==t[-1]=='1':\\n            h1=True\\n        elif t[0]==t[-1]=='0':\\n            h0=True\\n    c0,c1=len(l0),len(l1)\\n    req,sl=0,[]\\n    s0=set(l0)\\n    s1=set(l1)\\n    if c0>0 or c1>0:\\n        if c0-c1>1:\\n            req=(c0-c1)//2\\n            sel=0\\n            sl=[]\\n            for tt in range(len(l0)):\\n                t=l0[tt]\\n                if not t[::-1] in s1:\\n                    req-=1\\n                    sl.append(i0[tt]+1)\\n                if req==0:\\n                    break\\n        elif c1-c0>1:\\n            req=(c1-c0)//2\\n            sel=0\\n            sl=[]\\n            for tt in range(len(l1)):\\n                t=l1[tt]\\n                if not t[::-1] in s0:\\n                    req-=1\\n                    sl.append(i1[tt]+1)\\n                if req==0:\\n                    break\\n        if req>0:\\n            print(-1)\\n        else:\\n            print(len(sl))\\n            print(*sl)\\n    else:\\n        if h0 and h1:\\n            print(-1)\\n        else:\\n            print(0)\\n            print(*[])\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n4\\n0001\\n1000\\n0011\\n0111\\n3\\n010\\n101\\n0\\n2\\n00000\\n00001\\n4\\n01\\n001\\n0001\\n00001\\n\"\n  ],\n  \"outputs\": [\n    \"1\\n3 \\n-1\\n0\\n\\n2\\n1 2 \\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1259/D", "starter_code": ""}
{"id": 1, "question": "Mikhail walks on a Cartesian plane. He starts at the point $(0, 0)$, and in one move he can go to any of eight adjacent points. For example, if Mikhail is currently at the point $(0, 0)$, he can go to any of the following points in one move:   $(1, 0)$;  $(1, 1)$;  $(0, 1)$;  $(-1, 1)$;  $(-1, 0)$;  $(-1, -1)$;  $(0, -1)$;  $(1, -1)$. \n\nIf Mikhail goes from the point $(x1, y1)$ to the point $(x2, y2)$ in one move, and $x1 \\ne x2$ and $y1 \\ne y2$, then such a move is called a diagonal move.\n\nMikhail has $q$ queries. For the $i$-th query Mikhail's target is to go to the point $(n_i, m_i)$ from the point $(0, 0)$ in exactly $k_i$ moves. Among all possible movements he want to choose one with the maximum number of diagonal moves. Your task is to find the maximum number of diagonal moves or find that it is impossible to go from the point $(0, 0)$ to the point $(n_i, m_i)$ in $k_i$ moves.\n\nNote that Mikhail can visit any point any number of times (even the destination point!).\n\n\n-----Input-----\n\nThe first line of the input contains one integer $q$ ($1 \\le q \\le 10^4$) \u2014 the number of queries.\n\nThen $q$ lines follow. The $i$-th of these $q$ lines contains three integers $n_i$, $m_i$ and $k_i$ ($1 \\le n_i, m_i, k_i \\le 10^{18}$) \u2014 $x$-coordinate of the destination point of the query, $y$-coordinate of the destination point of the query and the number of moves in the query, correspondingly.\n\n\n-----Output-----\n\nPrint $q$ integers. The $i$-th integer should be equal to -1 if Mikhail cannot go from the point $(0, 0)$ to the point $(n_i, m_i)$ in exactly $k_i$ moves described above. Otherwise the $i$-th integer should be equal to the the maximum number of diagonal moves among all possible movements.\n\n\n-----Example-----\nInput\n3\n2 2 3\n4 3 7\n10 1 9\n\nOutput\n1\n6\n-1\n\n\n\n-----Note-----\n\nOne of the possible answers to the first test case: $(0, 0) \\to (1, 0) \\to (1, 1) \\to (2, 2)$.\n\nOne of the possible answers to the second test case: $(0, 0) \\to (0, 1) \\to (1, 2) \\to (0, 3) \\to (1, 4) \\to (2, 3) \\to (3, 2) \\to (4, 3)$.\n\nIn the third test case Mikhail cannot reach the point $(10, 1)$ in 9 moves.", "solutions": "[\"q=int(input())\\n\\nfor e in range(q):\\n    x,y,k=list(map(int,input().split()))\\n    x,y=abs(x),abs(y)\\n    x,y=max(x,y),min(x,y)\\n    \\n    if(x%2!=k%2):\\n        k-=1\\n        y-=1\\n    \\n    \\n    if(x>k):\\n        print(-1)\\n        continue\\n    if((x-y)%2):\\n        k-=1\\n        x-=1\\n    print(k)\\n    \\n    \\n    \\n\", \"#      \\nimport collections, atexit, math, sys, bisect \\n\\nsys.setrecursionlimit(1000000)\\ndef getIntList():\\n    return list(map(int, input().split()))    \\n\\ntry :\\n    #raise ModuleNotFoundError\\n    import numpy\\n    def dprint(*args, **kwargs):\\n        print(*args, **kwargs, file=sys.stderr)\\n    dprint('debug mode')\\nexcept ModuleNotFoundError:\\n    def dprint(*args, **kwargs):\\n        pass\\n\\n\\n\\ninId = 0\\noutId = 0\\nif inId>0:\\n    dprint('use input', inId)\\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\\u6807\\u51c6\\u8f93\\u51fa\\u91cd\\u5b9a\\u5411\\u81f3\\u6587\\u4ef6\\nif outId>0:\\n    dprint('use output', outId)\\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\\u6807\\u51c6\\u8f93\\u51fa\\u91cd\\u5b9a\\u5411\\u81f3\\u6587\\u4ef6\\n    atexit.register(lambda :sys.stdout.close())     #idle \\u4e2d\\u4e0d\\u4f1a\\u6267\\u884c atexit\\n    \\nQ, = getIntList()\\nfor _ in range(Q):\\n    N, M, K  = getIntList()\\n    if max(N,M) >K:\\n        print(-1)\\n        continue\\n    r = K\\n    if N%2!= K%2:\\n        r-=1\\n    if M%2!= K%2:\\n        r-=1\\n    print(r)\\n\\n\\n\\n\\n\\n\\n\", \"q = int(input())\\nfor i in range(q):\\n    x, y, k = list(map(int, input().split()))\\n    if x > y: x, y = y, x\\n    m = y\\n    d = y\\n    if (y - x) % 2 == 1:\\n        d -= 1\\n    if k < m:\\n        print(-1)\\n        continue\\n    r = k - m\\n    if r % 2 != 0:\\n        r -= 1\\n        if d != m:\\n            d += 1\\n        else:\\n            d -= 1\\n    d += r\\n    print(d)\\n\", \"q = int(input())\\notvet = []\\nfor i in range(q):\\n    g = input().split()\\n    n = int(g[0])\\n    m = int(g[1])\\n    k = int(g[2])\\n    if n < 0:\\n        n = -n\\n    if m < 0:\\n        m = -m\\n    if m > k or n > k:\\n        otvet.append(-1)\\n    elif m % 2 == k % 2 and n % 2 == k % 2:\\n        otvet.append(k)\\n    elif m % 2 == k % 2 or n % 2 == k % 2:\\n        otvet.append(k - 1)\\n    else:\\n        otvet.append(k - 2)\\nfor i in otvet:\\n    print(i)\\n\", \"q = int(input())\\nfor i in range(q):\\n    a, b, k = list(map(int, input().split()))\\n    if a < b:\\n        a, b, = b, a\\n    if a > k:\\n        print(-1)\\n    elif a % 2 == b % 2 != k % 2:\\n        print(k - 2)\\n    elif (a + b) % 2 != 0:\\n        print(k - 1)\\n    else:\\n        print(k)\\n\", \"q = int(input())\\nfor i in range(q):\\n    n, m, k = list(map(int, input().split()))\\n    m, n = abs(m), abs(n)\\n    mx = max(m, n)\\n    remaining = k - mx\\n    if remaining < 0:\\n        print(-1)\\n    elif m == n == 0:\\n        if k == 1:\\n            print(-1)\\n        elif k % 2:\\n            print(k - 1)\\n        else:\\n            print(k)\\n    elif abs(m - n) % 2 == 0:\\n        if remaining % 2 == 0:\\n            print(k)\\n        else:\\n            print(k - 2)\\n    else:\\n        if not remaining:\\n            print(k - 1)\\n        elif remaining % 2 == 0:\\n            print(k - 1)\\n        else:\\n            print(k - 1)\\n\", \"from collections import deque\\nfrom sys import stdin\\nlines = deque(line.strip() for line in stdin.readlines())\\n\\ndef nextline():\\n    return lines.popleft()\\n\\ndef types(cast, sep=None):\\n    return tuple(cast(x) for x in strs(sep=sep))\\n\\ndef ints(sep=None):\\n    return types(int, sep=sep)\\n\\ndef strs(sep=None):\\n    return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep))\\n\\ndef main():\\n    # lines will now contain all of the input's lines in a list\\n    T = int(nextline())\\n    for testCase in range(1, T + 1):\\n        n, m, k = ints()\\n        min_k = max(n, m)\\n        if min_k > k:\\n            print(-1)\\n            continue\\n        if (n - m) % 2 == 0:\\n            if k % 2 == n % 2:\\n                print(k)\\n                continue\\n            print(k - 2)\\n            continue\\n        print(k - 1)\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"\\n\\nq = int(input())\\n\\nfor _ in range(q):\\n    n, m, k = list(map(int, input().split()))\\n    if max([n, m]) > k:\\n        print(-1)\\n    else:\\n        if (n + m) % 2 == 0:\\n            if max([n, m]) % 2 != k % 2:\\n                print(k - 2)\\n            else:\\n                print(k)\\n        else:\\n            print((k - 1));\\n\", \"import math\\n\\nq = int(input())\\n\\nfor i in range(q):\\n    x, y, k = map(int, input().split())\\n    if x > k or y > k:\\n        print(-1)\\n    else:\\n        if (x+y)%2 == 0:\\n            if (k-max(x,y)) % 2 == 0:\\n                print(k)\\n            else:\\n                print(k - 2)\\n        else:\\n            if (k-max(x,y)) % 2 == 0:\\n                print(k-1)\\n            else:\\n                print(k-1)\", \"q = int(input())\\n\\nfor _ in range(q):\\n    n, m, k = list(map(int, input().split()))\\n    if k == 0:\\n        if n == 0 and m == 0:\\n            print(0)\\n        else:\\n            print(-1)\\n    elif k == 1:\\n        if max(abs(n), abs(m)) != 1:\\n            print(-1)\\n        elif abs(n) == abs(m) == 1:\\n            print(1)\\n        else:\\n            print(0)\\n    else:\\n        if max(abs(n), abs(m)) > k:\\n            print(-1)\\n        elif abs(n) == abs(m):\\n            if (k - abs(n)) % 2 == 0:\\n                print(k)\\n            else:\\n                print(k - 2)\\n        elif (max(abs(n), abs(m)) - min(abs(n), abs(m))) % 2 == 0:\\n            if (k - max(abs(n), abs(m))) % 2 == 0:\\n                print(k)\\n            else:\\n                print(k - 2)\\n        else:\\n            print(k - 1)\\n\\n\\n\\n\", \"\\nimport sys\\n#sys.stdin=open(\\\"data.txt\\\")\\ninput=sys.stdin.readline\\n\\nfor _ in range(int(input())):\\n    n,m,k=list(map(int,input().split()))\\n    n=abs(n)\\n    m=abs(m)\\n    if max(n,m)>k:\\n        print(\\\"-1\\\")\\n    else:\\n        # you can't 0 0 1 me :D\\n        bad1=((n+k)%2==1)\\n        bad2=((m+k)%2==1)\\n        print(k-bad1-bad2)\\n\", \"USE_STDIO = False\\n\\nif not USE_STDIO:\\n    try: import mypc\\n    except: pass\\n\\ndef main():\\n    q,  = list(map(int, input().split(' ')))\\n    for _ in range(q):\\n        n, m, k = list(map(int, input().split(' ')))\\n        if n > k or m > k:\\n            print(-1)\\n        elif (n - m) % 2:\\n            print(k - 1)\\n        elif (n - k) % 2:\\n            print(k - 2)\\n        else:\\n            print(k)\\n\\ndef __starting_point():\\n    main()\\n\\n\\n\\n\\n__starting_point()\", \"q=int(input())\\n\\nQ=[list(map(int,input().split())) for i in range(q)]\\n\\nfor n,m,k in Q:\\n    if n>k or m>k:\\n        print(-1)\\n        continue\\n\\n    x=max(n,m)-min(n,m)\\n    y=k-max(n,m)\\n\\n    if x%2==0 and y%2==0:\\n        print(k)\\n    elif x%2==0 and y%2==1:\\n        print(k-2)\\n    elif x%2==1 and y%2==0:\\n        print(k-1)\\n    elif x%2==1 and y%2==1:\\n        print(k-1)\\n\", \"n = int(input())\\nfor i in range(n):\\n    a, b, c = [int(el) for el in input().split()]\\n    if ( a > c or b > c):\\n        print(-1)\\n    else:\\n        if (a% 2 + b % 2 == 1):\\n            print(c - 1)\\n        elif (a%2 == b%2 == c%2):\\n            print(c)\\n        else:\\n            print(c - 2)\\n\", \"Q = int(input())\\nsrc = [tuple(map(int,input().split())) for i in range(Q)]\\nans = []\\nfor x,y,k in src:\\n    d = max(x,y)\\n    if (x+y)%2:\\n        ans.append(-1 if d > k else k-1)\\n    else:\\n        if d > k:\\n            ans.append(-1)\\n        else:\\n            ans.append(k-2 if (d+k)%2 else k)\\n\\nprint(*ans,sep='\\\\n')\\n\", \"def m():\\n\\t[x, y, k] = [int(i) for i in input().split()]\\n\\td=min(x, y)\\n\\tx-=d\\n\\ty-=d\\n\\tk-=d\\n\\t\\n\\tif k-x-y<0:\\n\\t\\tprint(-1)\\n\\telse:\\n\\t\\tx+=y\\n\\t\\tif x%2 > 0 and k%2>0:\\n\\t\\t\\tprint(d+k-1)\\n\\t\\telif x%2 >0:\\n\\t\\t\\tprint(d+k-1)\\n\\t\\telif k%2>0:\\n\\t\\t\\tprint(d+k-2)\\n\\t\\telse:\\n\\t\\t\\tprint(d+k)\\n\\t\\t\\t\\n\\t\\t\\n\\t\\t\\t\\n\\t\\nn=int(input())\\nfor i in range(n):\\n\\tm()\", \"q = int(input())\\n\\nfor i in range(q):\\n    (x, y, k) = list(map(int, input().split()))\\n\\n    if max(x, y) > k:\\n        print(-1)\\n    elif x == y and k == x + 1:\\n        print(k - 2)\\n        continue\\n    elif x % 2 == 1 and y % 2 == 1 and k % 2 == 0:\\n        print(k - 2)\\n        continue\\n    elif x % 2 == 0 and y % 2 == 0 and k % 2 == 1:\\n        print(k - 2)\\n        continue\\n    elif (x + y) % 2 == 0:\\n        print(k)\\n    else:\\n        print(k - 1)\\n\", \"n = int(input())\\nfor q in range(n):\\n    x, y, k = list(map(int, input().split()))\\n    if max(x, y) > k:\\n        print(-1)\\n    else:\\n        if 0 == (x + y) % 2:\\n            if k % 2 == max(x, y) % 2:\\n                print(k)\\n            else:\\n                print(k - 2)\\n        else:\\n            print(k - 1)\\n\", \"def go():\\n    n = int(input())\\n    for i in range(n):\\n        a, b, d = [int(i) for i in input().split(' ')]\\n        if a > d or b > d:\\n            print(-1)\\n        elif a % 2 == b % 2:\\n            if a % 2 == d % 2:\\n                print(d)\\n            else:\\n                print(d - 2)\\n        else:\\n            if a % 2 == b % 2:\\n                if d % 2 == a % 2:\\n                    print(d)\\n                else:\\n                    print(d - 2)\\n            else:\\n                print(d - 1)\\ngo()\\n\", \"q = int(input())\\n\\nfor i in range(q):\\n    n, m, k = map(int, input().split())\\n    p = min(m, n)\\n    r = max(n, m) - p\\n    if (p+r) > k:\\n        print(-1)\\n    elif r % 2 == 1:\\n        print(k - 1)\\n    elif (k - p) % 2 == 0:\\n        print(k)\\n    else:\\n        print(k - 2)\", \"q = int(input())\\nfor i in range(q):\\n\\tn, m, k = map(int, input().split())\\n\\tost = max(n, m) - min(n, m)\\n\\tplus = 0\\n\\tif ost % 2 != 0:\\n\\t\\tplus = 1\\n\\t\\tost -= 1\\n\\tmini = min(n, m) + ost + plus\\n\\t#print('mini: ' + str(mini))\\n\\tif k < mini:\\n\\t\\tprint(-1)\\n\\telif (k - mini) % 2 == 0 or plus == 1:\\n\\t\\tprint(k - plus)\\n\\telse:\\n\\t\\tprint(k - plus - 2)\\t\", \"q=int(input())\\n\\nfor i in range(q):\\n\\tn,m,k=list(map(int,input().split()))\\n\\n\\tif n>k or m>k:\\n\\t\\tprint(-1)\\n\\n\\telse:\\n\\t\\tif n%2==0 and m%2==0:\\n\\t\\t\\tif k%2==0:\\n\\t\\t\\t\\tprint(k)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tprint(k-2)\\n\\n\\t\\telif (n%2==0 and m%2==1) or (n%2==1 and m%2==0):\\n\\t\\t\\tprint(k-1)\\n\\n\\t\\telif n%2==1 and m%2==1:\\n\\t\\t\\tif k%2==0:\\n\\t\\t\\t\\tprint(k-2)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tprint(k)\\n\", \"q=int(input())\\nfor i in range(q):\\n    n, m, k = map(int, input().split())\\n    ans=max(n,m)\\n    diff=k-ans\\n    if diff<0:\\n        print(-1)\\n    else:\\n        if (n%2==0 and m%2==0) or (n%2!=0 and m%2!=0):\\n            if diff%2==0:\\n                ans+=diff\\n            else:\\n                ans+=diff-2\\n        else:\\n            ans+=diff-1\\n        print(ans)\", \"\\\"\\\"\\\"\\nKA      YM        KA        AS      KA  ASKA      YASK        KA         SKAYMA   \\nKA    KA         SKAY        SK    SK   AS AY    AY SK       SKAY       AS    AS  \\nKA  AS          AS  YM        KA  AS    AS  YM  KA  SK      AS  YM      AS        \\nKAYM           MA    MA        AYMA     AS   MASK   SK     MA    MA      SKAYMA   \\nKA  AS        YMASKAYMAS        YM      AS    AS    SK    YMASKAYMAS          AS  \\nKA    KA     AY        SK       YM      AS          SK   AY        SK   AS    AS  \\nKA      YM  KA          KA      YM      AS          SK  KA          KA   SKAYMA   \\n\\\"\\\"\\\"\\nn=int(input())\\nfor i in range(n):\\n\\tx,y,k=map(int,input().split())\\n\\tx,y=abs(x),abs(y)\\n\\tmin_moves=max(x,y)\\n\\tif min_moves>k:\\n\\t\\tprint(-1)\\n\\telse:\\n\\t\\tans=min(x,y)\\n\\t\\tx-=ans\\n\\t\\ty-=ans\\n\\t\\tp=max(x,y)\\n\\t\\tk-=ans\\n\\t\\tif k==p and p%2==0:\\n\\t\\t\\tprint(ans+k)\\n\\t\\telif k==p and p%2==1:\\n\\t\\t\\tprint(ans+k-1)\\n\\t\\telif p%2==0 and k%2==0:\\n\\t\\t\\tprint(ans+k)\\n\\t\\telif p%2==0 and k%2==1:\\n\\t\\t\\tprint(ans+k-2)\\n\\t\\telif p%2==1:\\n\\t\\t\\tprint(ans+k-1)\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n2 2 3\\n4 3 7\\n10 1 9\\n\"\n  ],\n  \"outputs\": [\n    \"1\\n6\\n-1\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1036/B", "starter_code": ""}
{"id": 2, "question": "You are given three sequences: $a_1, a_2, \\ldots, a_n$; $b_1, b_2, \\ldots, b_n$; $c_1, c_2, \\ldots, c_n$.\n\nFor each $i$, $a_i \\neq b_i$, $a_i \\neq c_i$, $b_i \\neq c_i$.\n\nFind a sequence $p_1, p_2, \\ldots, p_n$, that satisfy the following conditions:\n\n\n\n $p_i \\in \\{a_i, b_i, c_i\\}$\n\n $p_i \\neq p_{(i \\mod n) + 1}$.\n\nIn other words, for each element, you need to choose one of the three possible values, such that no two adjacent elements (where we consider elements $i,i+1$ adjacent for $i<n$ and also elements $1$ and $n$) will have equal value.\n\nIt can be proved that in the given constraints solution always exists. You don't need to minimize/maximize anything, you need to find any proper sequence.\n\n\n-----Input-----\n\nThe first line of input contains one integer $t$ ($1 \\leq t \\leq 100$): the number of test cases.\n\nThe first line of each test case contains one integer $n$ ($3 \\leq n \\leq 100$): the number of elements in the given sequences.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 100$).\n\nThe third line contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\leq b_i \\leq 100$).\n\nThe fourth line contains $n$ integers $c_1, c_2, \\ldots, c_n$ ($1 \\leq c_i \\leq 100$).\n\nIt is guaranteed that $a_i \\neq b_i$, $a_i \\neq c_i$, $b_i \\neq c_i$ for all $i$.\n\n\n-----Output-----\n\nFor each test case, print $n$ integers: $p_1, p_2, \\ldots, p_n$ ($p_i \\in \\{a_i, b_i, c_i\\}$, $p_i \\neq p_{i \\mod n + 1}$).\n\nIf there are several solutions, you can print any.\n\n\n-----Example-----\nInput\n5\n3\n1 1 1\n2 2 2\n3 3 3\n4\n1 2 1 2\n2 1 2 1\n3 4 3 4\n7\n1 3 3 1 1 1 1\n2 4 4 3 2 2 4\n4 2 2 2 4 4 2\n3\n1 2 1\n2 3 3\n3 1 2\n10\n1 1 1 2 2 2 3 3 3 1\n2 2 2 3 3 3 1 1 1 2\n3 3 3 1 1 1 2 2 2 3\n\nOutput\n1 2 3\n1 2 1 2\n1 3 4 3 2 4 2\n1 3 2\n1 2 3 1 2 3 1 2 3 2\n\n\n\n-----Note-----\n\nIn the first test case $p = [1, 2, 3]$.\n\nIt is a correct answer, because:\n\n  $p_1 = 1 = a_1$, $p_2 = 2 = b_2$, $p_3 = 3 = c_3$  $p_1 \\neq p_2 $, $p_2 \\neq p_3 $, $p_3 \\neq p_1$ \n\nAll possible correct answers to this test case are: $[1, 2, 3]$, $[1, 3, 2]$, $[2, 1, 3]$, $[2, 3, 1]$, $[3, 1, 2]$, $[3, 2, 1]$.\n\nIn the second test case $p = [1, 2, 1, 2]$.\n\nIn this sequence $p_1 = a_1$, $p_2 = a_2$, $p_3 = a_3$, $p_4 = a_4$. Also we can see, that no two adjacent elements of the sequence are equal.\n\nIn the third test case $p = [1, 3, 4, 3, 2, 4, 2]$.\n\nIn this sequence $p_1 = a_1$, $p_2 = a_2$, $p_3 = b_3$, $p_4 = b_4$, $p_5 = b_5$, $p_6 = c_6$, $p_7 = c_7$. Also we can see, that no two adjacent elements of the sequence are equal.", "solutions": "[\"import sys\\nimport random\\nfrom fractions import Fraction\\nfrom math import *\\n \\ndef input():\\n    return sys.stdin.readline().strip()\\n \\ndef iinput():\\n    return int(input())\\n\\ndef finput():\\n    return float(input())\\n\\ndef tinput():\\n    return input().split()\\n\\ndef linput():\\n    return list(input())\\n \\ndef rinput():\\n    return list(map(int, tinput()))\\n\\ndef fiinput():\\n    return list(map(float, tinput()))\\n \\ndef rlinput():\\n    return list(map(int, input().split()))\\ndef trinput():\\n    return tuple(rinput())\\n\\ndef srlinput():\\n    return sorted(list(map(int, input().split())))\\n\\ndef NOYES(fl):\\n    if fl:\\n        print(\\\"NO\\\")\\n    else:\\n        print(\\\"YES\\\")\\ndef YESNO(fl):\\n    if fl:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n    \\ndef main():\\n    n = iinput()\\n    #k = iinput() \\n    #m = iinput() \\n    #n = int(sys.stdin.readline().strip()) \\n    #n, k = rinput()\\n    #n, m = rinput()\\n    #m, k = rinput()\\n    #n, k, m = rinput()\\n    #n, m, k = rinput()\\n    #k, n, m = rinput()\\n    #k, m, n = rinput() \\n    #m, k, n = rinput()\\n    #m, n, k = rinput()\\n    q = [rlinput(), rlinput(), rlinput()]\\n    #q = linput()\\n    ans = q[0].copy()\\n    for i in range(1, n):\\n        if ans[i] == ans[i - 1]:\\n            ans[i] = q[1][i]\\n        if i == n - 1:\\n            o = 0\\n            while q[o][i] == ans[n - 2] or q[o][i] == ans[0]:\\n                o += 1\\n            ans[i] = q[o][i]\\n    print(*ans)\\n\\n        \\n\\n            \\n        \\n    \\n                \\n    \\n    \\n    \\n            \\n    \\n        \\n    \\n\\nfor i in range(iinput()):\\n    main()\\n\", \"for _ in range(int(input())):\\n  n=int(input())\\n  a=list(map(int,input().split()))\\n  b=list(map(int,input().split()))\\n  c=list(map(int,input().split()))\\n  p=a\\n  for i in range(n):\\n    if p[i]==p[(i+1)%n]:\\n      if p[i]!=b[i] and p[(i-1)%n]!=b[i]:p[i]=b[i]\\n      else:p[i]=c[i]\\n  print(*p)\", \"for __ in range(int(input())):\\n    n = int(input())\\n    ar1 = list(map(int, input().split()))\\n    ar2 = list(map(int, input().split()))\\n    ar3 = list(map(int, input().split()))\\n    ans = [ar1[0]]\\n    for i in range(1, n - 1):\\n        if ar1[i] != ans[-1]:\\n            ans.append(ar1[i])\\n        elif ar2[i] != ans[-1]:\\n            ans.append(ar2[i])\\n        elif ar3[i] != ans[-1]:\\n            ans.append(ar3[i])\\n    if ar1[-1] != ans[-1] and ar1[-1] != ans[0]:\\n        ans.append(ar1[-1])\\n    elif ar2[-1] != ans[-1] and ar2[-1] != ans[0]:\\n        ans.append(ar2[-1])\\n    elif ar3[-1] != ans[-1] and ar3[-1] != ans[0]:\\n        ans.append(ar3[-1])\\n    print(*ans)\", \"T = int(input())\\n\\nfor t in range(T):\\n    N = int(input())\\n    A = [int(_) for _ in input().split()]\\n    B = [int(_) for _ in input().split()]\\n    C = [int(_) for _ in input().split()]\\n\\n    R = []\\n\\n    for i in range(N):\\n        if i == 0:\\n            R.append(A[i])\\n            continue\\n        if i == N-1:\\n            if A[i] != R[0] and A[i] != R[-1]:\\n                R.append(A[i])\\n            elif B[i] != R[0] and B[i] != R[-1]:\\n                R.append(B[i])\\n            else:\\n                R.append(C[i])\\n            continue\\n\\n        if A[i] != R[-1]:\\n            R.append(A[i])\\n        else:\\n            R.append(B[i])\\n\\n    print(' '.join(map(str, R)))\\n\", \"gans = []\\nfor _ in range(int(input())):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    b = list(map(int, input().split()))\\n    c = list(map(int, input().split()))\\n    ans = [a[0]]\\n    for i in range(1, n - 1):\\n        if a[i] != ans[i - 1]:\\n            ans.append(a[i])\\n        else:\\n            ans.append(b[i])\\n    if a[-1] != ans[-1] and a[-1] != ans[0]:\\n        ans.append(a[-1])\\n    elif b[-1] != ans[-1] and b[-1] != ans[0]:\\n        ans.append(b[-1])\\n    else:\\n        ans.append(c[-1])\\n    gans.append(' '.join(map(str, ans)))\\nprint('\\\\n'.join(gans))\\n\", \"from math import *\\nfrom bisect import *\\nfrom collections import *\\nfrom random import *\\nfrom decimal import *\\nimport sys\\ninput=sys.stdin.readline\\ndef inp():\\n    return int(input())\\ndef st():\\n    return input().rstrip('\\\\n')\\ndef lis():\\n    return list(map(int,input().split()))\\ndef ma():\\n    return list(map(int,input().split()))\\nt=inp()\\nwhile(t):\\n    t-=1\\n    n=inp()\\n    a=lis()\\n    b=lis()\\n    c=lis()\\n    r=[a[0]]\\n    for i in range(1,n):\\n        if(i==n-1):\\n            if(a[i]!=r[0] and a[i]!=r[-1]):\\n                r.append(a[i])\\n                continue\\n            if(b[i]!=r[0] and b[i]!=r[-1]):\\n                r.append(b[i])\\n                continue\\n            if(c[i]!=r[0] and c[i]!=r[-1]):\\n                r.append(c[i])\\n                continue\\n        if(a[i]!=r[-1]):\\n            r.append(a[i])\\n            continue\\n        if(b[i]!=r[-1]):\\n            r.append(b[i])\\n            continue\\n        if(c[i]!=r[-1]):\\n            r.append(c[i])\\n            continue\\n    print(*r)\\n        \\n        \\n        \\n\"]", "input_output": "{\n  \"inputs\": [\n    \"5\\n3\\n1 1 1\\n2 2 2\\n3 3 3\\n4\\n1 2 1 2\\n2 1 2 1\\n3 4 3 4\\n7\\n1 3 3 1 1 1 1\\n2 4 4 3 2 2 4\\n4 2 2 2 4 4 2\\n3\\n1 2 1\\n2 3 3\\n3 1 2\\n10\\n1 1 1 2 2 2 3 3 3 1\\n2 2 2 3 3 3 1 1 1 2\\n3 3 3 1 1 1 2 2 2 3\\n\"\n  ],\n  \"outputs\": [\n    \"1 2 3\\n1 2 1 2\\n1 3 4 1 2 1 4\\n1 2 3\\n1 2 1 2 3 2 3 1 3 2\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1408/A", "starter_code": ""}
{"id": 3, "question": "You have $n$ barrels lined up in a row, numbered from left to right from one. Initially, the $i$-th barrel contains $a_i$ liters of water.\n\nYou can pour water from one barrel to another. In one act of pouring, you can choose two different barrels $x$ and $y$ (the $x$-th barrel shouldn't be empty) and pour any possible amount of water from barrel $x$ to barrel $y$ (possibly, all water). You may assume that barrels have infinite capacity, so you can pour any amount of water in each of them. \n\nCalculate the maximum possible difference between the maximum and the minimum amount of water in the barrels, if you can pour water at most $k$ times.\n\nSome examples:   if you have four barrels, each containing $5$ liters of water, and $k = 1$, you may pour $5$ liters from the second barrel into the fourth, so the amounts of water in the barrels are $[5, 0, 5, 10]$, and the difference between the maximum and the minimum is $10$;  if all barrels are empty, you can't make any operation, so the difference between the maximum and the minimum amount is still $0$. \n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le k < n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of barrels and the number of pourings you can make.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0 \\le a_i \\le 10^{9}$), where $a_i$ is the initial amount of water the $i$-th barrel has.\n\nIt's guaranteed that the total sum of $n$ over test cases doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, print the maximum possible difference between the maximum and the minimum amount of water in the barrels, if you can pour water at most $k$ times.\n\n\n-----Example-----\nInput\n2\n4 1\n5 5 5 5\n3 2\n0 0 0\n\nOutput\n10\n0", "solutions": "[\"def solve():\\n    n, k = map(int,input().split())\\n    lst = list(map(int,input().split()))\\n    lst.sort()\\n    ans = 0\\n    for i in range(n - k - 1, n):\\n        ans += lst[i]\\n    print(ans)\\nfor i in range(int(input())):\\n    solve()\", \"t=int(input())\\nfor i in range(t):\\n    n,k=[int(i) for i in input().split()]\\n    a=[int(i) for i in input().split()]\\n    a.sort(reverse=True)\\n    print(sum(a[:k+1]))\", \"# map(int, input().split())\\nrw = int(input())\\nfor wewq in range(rw):\\n    n, k = list(map(int, input().split()))\\n    a = list(map(int, input().split()))\\n    a.sort()\\n    a.reverse()\\n    f = 0\\n    for i in range(k + 1):\\n        f += a[i]\\n    print(f)\\n\", \"t=int(input())\\nfor you in range(t):\\n    l=input().split()\\n    n=int(l[0])\\n    k=int(l[1])\\n    l=input().split()\\n    li=[int(i) for i in l]\\n    if(k==0):\\n        print(max(li)-min(li))\\n        continue\\n    z=0\\n    li.sort()\\n    li.reverse()\\n    for i in range(k+1):\\n        z+=li[i]\\n    print(z)\\n\", \"for _ in range (int(input())):\\n    n,k=map(int,input().split())\\n    a=list(map(int,input().split()))\\n    a.sort(reverse=True)\\n    for i in range (1,k+1):\\n        a[0]+=a[i]\\n        a[i]=0\\n    print(a[0]-a[1])\", \"for __ in range(int(input())):\\n    n, k = list(map(int, input().split()))\\n    ar = list(map(int, input().split()))\\n    ar.sort(reverse=True)\\n    ans = 0\\n    for i in range(min(n, k + 1)):\\n        ans += ar[i]\\n    print(ans)\", \"import sys, math\\nimport io, os\\n#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\\nfrom bisect import bisect_left as bl, bisect_right as br, insort\\nfrom heapq import heapify, heappush, heappop\\nfrom collections import defaultdict as dd, deque, Counter\\n#from itertools import permutations,combinations\\ndef data(): return sys.stdin.readline().strip()\\ndef mdata(): return list(map(int, data().split()))\\ndef outl(var) : sys.stdout.write('\\\\n'.join(map(str, var))+'\\\\n')\\ndef out(var) : sys.stdout.write(str(var)+'\\\\n')\\n#from decimal import Decimal\\n#from fractions import Fraction\\n#sys.setrecursionlimit(100000)\\nINF = float('inf')\\nmod=10**9+7\\n\\n\\nfor t in range(int(data())):\\n    n,k=mdata()\\n    a=sorted(mdata(),reverse=True)\\n    s=sum(a[:k+1])\\n    out(s)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nt = int(input())\\nfor i in range(t):\\n    n,k = map(int,input().split())\\n    a = list(map(int,input().split()))\\n    a.sort()\\n    a.reverse()\\n    cum = [a[0]]\\n    for i in range(n-1):\\n        cum.append(cum[i]+a[i+1])\\n    cum.append(cum[-1])\\n    print(cum[k])\", \"t = int(input())\\nfor _ in range(t):\\n    #n = int(input())\\n    n, k=map(int, input().split())\\n    a = list(map(int, input().split()))\\n    a.sort()\\n    s=0\\n    for i in range(k+1):\\n        s+=a[n-1-i]\\n    print(s)\", \"def main():\\n    N, K = list(map(int, input().split()))\\n    *A, = list(map(int, input().split()))\\n    \\n    A.sort()\\n    print(A[-1] + sum(A[-K-1:-1]))\\n\\ndef __starting_point():\\n    for __ in [0]*int(input()):\\n        main()\\n\\n__starting_point()\", \"import sys\\nimport random\\n# import numpy as np\\nimport math\\nimport copy\\nfrom heapq import heappush, heappop, heapify\\nfrom functools import cmp_to_key\\nfrom bisect import bisect_left, bisect_right\\nfrom collections import defaultdict, deque, Counter\\n# sys.setrecursionlimit(1000000)\\n# input aliases\\ninput = sys.stdin.readline\\ngetS = lambda: input().strip()\\ngetN = lambda: int(input())\\ngetList = lambda: list(map(int, input().split()))\\ngetZList = lambda: [int(x) - 1 for x in input().split()]\\n\\nINF = float(\\\"inf\\\")\\n\\nMOD = 10 ** 9 + 7\\ndivide = lambda x: pow(x, MOD-2, MOD)\\n\\ndef judge(at, ax, ay, bt, bx, by):\\n    if abs(at - bt) >= abs(ax - bx) + abs(ay - by):\\n        return True\\n    else:\\n        return False\\n\\n\\ndef solve():\\n    n, k = getList()\\n    li = getList()\\n\\n    if k >= n:\\n        print(sum(li))\\n        return\\n\\n    li.sort(reverse=True)\\n    print(sum(li[:k+1]))\\n\\n    return\\n\\ndef main():\\n    n = getN()\\n    for _ in range(n):\\n        solve()\\n\\n    return\\ndef __starting_point():\\n    main()\\n    # solve()\\n\\n__starting_point()\", \"from sys import stdin\\nt = int(stdin.readline())\\nfor _ in range(t):\\n    n, k = tuple(int(x) for x in stdin.readline().split())\\n    lst = sorted(int(x) for x in stdin.readline().split())\\n    print(sum(lst[-k-1:]))\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n,k = [int(x) for x in input().split()]\\n    l = [int(x) for x in input().split()]\\n    l.sort()\\n    l.reverse()\\n    print(sum(l[:min(k+1,n)]))\", \"for _ in range(int(input())):\\n\\tn, k = list(map(int, input().split()))\\n\\tA = list(map(int, input().split()))\\n\\n\\tA.sort(reverse=True)\\n\\tif k == 0:\\n\\t\\tprint(max(A) - min(A))\\n\\telse:\\n\\t\\tprint(A[0] + sum(A[1:k+1]))\\n\", \"n = int(input())\\n\\nfor _ in range(n):\\n    n, k = list(map(int, input().split()))\\n    arr = list(map(int, input().split()))\\n    arr.sort(reverse=True)\\n\\n    print(sum(arr[:k+1]))\\n\", \"\\\"\\\"\\\"T=int(input())\\nfor _ in range(0,T):\\n    n=int(input())\\n    a,b=map(int,input().split())\\n    s=input()\\n    s=[int(x) for x in input().split()]\\n    for i in range(0,len(s)):\\n        a,b=map(int,input().split())\\\"\\\"\\\"\\n\\n\\nT=int(input())\\nfor _ in range(0,T):\\n    n,k=list(map(int,input().split()))\\n    s=[int(x) for x in input().split()]\\n    s.sort()\\n    s=s[::-1]\\n    for i in range(1,min(k+1,len(s))):\\n        s[0]+=s[i]\\n\\n    print(s[0])\\n\", \"t=int(input())\\nwhile t:\\n\\tt-=1\\n\\tn,k=list(map(int,input().split()))\\n\\ta=[int(i) for i in input().split()]\\n\\ta.sort()\\n\\tans=0\\n\\ta.reverse()\\n\\tfor i in range(k+1):\\n\\t\\tans+=a[i]\\n\\t\\t\\n\\tprint(ans)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"2\\n4 1\\n5 5 5 5\\n3 2\\n0 0 0\\n\"\n  ],\n  \"outputs\": [\n    \"10\\n0\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1430/B", "starter_code": ""}
{"id": 4, "question": "You are given a permutation $p=[p_1, p_2, \\ldots, p_n]$ of integers from $1$ to $n$. Let's call the number $m$ ($1 \\le m \\le n$) beautiful, if there exists two indices $l, r$ ($1 \\le l \\le r \\le n$), such that the numbers $[p_l, p_{l+1}, \\ldots, p_r]$ is a permutation of numbers $1, 2, \\ldots, m$.\n\nFor example, let $p = [4, 5, 1, 3, 2, 6]$. In this case, the numbers $1, 3, 5, 6$ are beautiful and $2, 4$ are not. It is because:  if $l = 3$ and $r = 3$ we will have a permutation $[1]$ for $m = 1$;  if $l = 3$ and $r = 5$ we will have a permutation $[1, 3, 2]$ for $m = 3$;  if $l = 1$ and $r = 5$ we will have a permutation $[4, 5, 1, 3, 2]$ for $m = 5$;  if $l = 1$ and $r = 6$ we will have a permutation $[4, 5, 1, 3, 2, 6]$ for $m = 6$;  it is impossible to take some $l$ and $r$, such that $[p_l, p_{l+1}, \\ldots, p_r]$ is a permutation of numbers $1, 2, \\ldots, m$ for $m = 2$ and for $m = 4$. \n\nYou are given a permutation $p=[p_1, p_2, \\ldots, p_n]$. For all $m$ ($1 \\le m \\le n$) determine if it is a beautiful number or not.\n\n\n-----Input-----\n\nThe first line contains the only integer $t$ ($1 \\le t \\le 1000$) \u00a0\u2014 the number of test cases in the input. The next lines contain the description of test cases.\n\nThe first line of a test case contains a number $n$ ($1 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the length of the given permutation $p$. The next line contains $n$ integers $p_1, p_2, \\ldots, p_n$ ($1 \\le p_i \\le n$, all $p_i$ are different)\u00a0\u2014 the given permutation $p$.\n\nIt is guaranteed, that the sum of $n$ from all test cases in the input doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nPrint $t$ lines\u00a0\u2014 the answers to test cases in the order they are given in the input. \n\nThe answer to a test case is the string of length $n$, there the $i$-th character is equal to $1$ if $i$ is a beautiful number and is equal to $0$ if $i$ is not a beautiful number.\n\n\n-----Example-----\nInput\n3\n6\n4 5 1 3 2 6\n5\n5 3 1 2 4\n4\n1 4 3 2\n\nOutput\n101011\n11111\n1001\n\n\n\n-----Note-----\n\nThe first test case is described in the problem statement.\n\nIn the second test case all numbers from $1$ to $5$ are beautiful:  if $l = 3$ and $r = 3$ we will have a permutation $[1]$ for $m = 1$;  if $l = 3$ and $r = 4$ we will have a permutation $[1, 2]$ for $m = 2$;  if $l = 2$ and $r = 4$ we will have a permutation $[3, 1, 2]$ for $m = 3$;  if $l = 2$ and $r = 5$ we will have a permutation $[3, 1, 2, 4]$ for $m = 4$;  if $l = 1$ and $r = 5$ we will have a permutation $[5, 3, 1, 2, 4]$ for $m = 5$.", "solutions": "[\"for _ in range(int(input())):\\n    input()\\n    nums = [int(x) for x in input().split()]\\n    new_ar = list(zip(nums,[i for i in range(len(nums))]))\\n    new_ar.sort()\\n    \\n    maxx = new_ar[0][1]\\n    minn = new_ar[0][1]\\n    s=\\\"1\\\"\\n    for j in range(1,len(new_ar)):\\n        if(new_ar[j][1]>maxx):\\n            maxx = new_ar[j][1]\\n        if(new_ar[j][1]<minn):\\n            minn = new_ar[j][1]\\n        if(maxx-minn<j+1):\\n            s+=\\\"1\\\"\\n        else:\\n            s+=\\\"0\\\"\\n        \\n    print(s)\", \"import sys\\ndef I():\\n        return sys.stdin.readline().rstrip()\\n\\nfor _ in range(int(I())):\\n    n = int(I())\\n    l = list(map(int,I().split()))\\n    r = list(range(n))\\n    r.sort(key=lambda x: l[x])\\n    mn, mx = None, None\\n    for i in range(n):\\n        if mn is None:\\n            mn = mx = r[ i ]\\n        else:\\n            mn = min( mn, r[ i ] )\\n            mx = max( mx, r[ i ] )\\n        l[ i ] = '1' if mx - mn == i else '0'\\n    print(\\\"\\\".join(l))\\n\", \"from sys import stdin\\ndef rl():\\n    return [int(w) for w in stdin.readline().split()]\\n\\nk, = rl()\\nfor _ in range(k):\\n    n, = rl()\\n    p = rl()\\n\\n    q = [0] * n\\n    for i, x in enumerate(p):\\n        q[x-1] = i\\n\\n    l = r = q[0]\\n    m = []\\n    for k, i in enumerate(q):\\n        if i < l:\\n            l = i\\n        elif i > r:\\n            r = i\\n        m.append('1' if r - l == k else '0')\\n    print(''.join(m))\\n\", \"# @author \\n\\nimport sys\\n\\nclass BBeautifulNumbers:\\n    def solve(self):\\n        for _ in range(int(input())):\\n            n = int(input())\\n            p = [int(_) - 1 for _ in input().split()]\\n\\n            mn_index = [float('inf')] * n\\n            mx_index = [-float('inf')] * n\\n            prev = [0] * n\\n            for i in range(n):\\n                prev[p[i]] = i\\n            # print(prev)\\n            for i in range(n):\\n                mn_index[i] = min(mn_index[i - 1], prev[i])\\n                mx_index[i] = max(mx_index[i - 1], prev[i])\\n\\n            ans = ['0'] * n\\n            # print(mn_index, mx_index)\\n            for i in range(n):\\n                l, r = mn_index[i], mx_index[i]\\n                ans[i] = '1' if r - l + 1 == i + 1 else '0'\\n\\n            print(''.join(ans))\\n\\nsolver = BBeautifulNumbers()\\ninput = sys.stdin.readline\\n\\nsolver.solve()\\n\", \"def f(L):\\n    n=len(L)\\n    M=[0]*(len(L)+1)\\n    for i in range(len(L)):\\n        M[L[i]]=i\\n    s=[0]*len(L)\\n    s[0]=1\\n    sumof=M[1]\\n    mx=M[1]\\n    mi=M[1]\\n    for i in range(2,n):\\n        k=M[i]\\n        if k>mx:mx=k\\n        if k<mi:mi=k\\n        sumof+=k\\n        if sumof==(mx*(mx+1))//2-((mi-1)*mi)//2:\\n            s[i-1]=1\\n    s[n-1]=1\\n    return s\\nfor i in ' '*int(input()):\\n    n=int(input())\\n    s=f(list(map(int,input().split())))\\n    for i in s:print(i,end='')\\n    print()\", \"t=int(input())\\nfor _ in range(t):\\n    n=int(input())\\n    a=list(map(int,input().split()))\\n    pos=[0 for i in range(n+1)]\\n    for i in range(n):\\n        pos[a[i]]=i\\n    ans=[-1 for i in range(n)]\\n    ans[0]=1\\n    l,r=pos[1],pos[1]\\n    for i in range(2,n+1):\\n        l=min(l,pos[i])\\n        r=max(r,pos[i])\\n        if r-l==i-1:\\n            ans[i-1]=1\\n        else:\\n            ans[i-1]=0\\n    print(\\\"\\\".join(map(str,ans)))\", \"t = int(input())\\n\\nfor t_i in range(t):\\n    n = int(input())\\n    P = input().split()\\n    l, r = -1, -1\\n    for i in range(n):\\n        P[i] = int(P[i])\\n        if P[i] == 1:\\n            l = i\\n            r = i\\n    max_seen = 1\\n    beaut = ['1']\\n    for _ in range(n - 1):\\n        if l == 0:\\n            l_cand = 10**8\\n        else:\\n            l_cand = P[l - 1]\\n        if r == n - 1:\\n            r_cand = 10**8\\n        else:\\n            r_cand = P[r + 1]\\n        if r_cand > l_cand:\\n            l -= 1\\n            max_seen = max(l_cand, max_seen)\\n        else:\\n            r += 1\\n            max_seen = max(r_cand, max_seen)\\n        beaut.append('1' if max_seen == r - l + 1 else '0')\\n    print(''.join(beaut))\\n            \\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    a = list(map(int,input().split()))\\n    d = {}\\n    for i in range(n):\\n        d[a[i]] = i\\n\\n    ans = ''\\n    mn = 200001\\n    mx = -1\\n    for i in range(1,n+1):\\n        if(mn > d[i]):\\n            mn = d[i]\\n        if(mx < d[i]):\\n            mx = d[i]\\n\\n        \\n        if(mx - mn + 1 > i):\\n            ans += '0'\\n\\n        else:\\n            ans += '1'\\n\\n\\n    print(ans)\\n\", \"from math import *\\nfrom collections import *\\nimport sys\\nsys.setrecursionlimit(10**9)\\n\\nt = int(input())\\nfor y in range(t):\\n\\tn = int(input())\\n\\ta = list(map(int,input().split()))\\n\\tans = ['1']\\n\\tle = 1\\n\\tl = a.index(1)\\n\\tl -= 1\\n\\tr = l + 2\\n\\tm = 1\\n\\twhile(le < n):\\n\\t\\tif(l != -1 and r != n):\\n\\t\\t\\tif(a[l] > a[r]):\\n\\t\\t\\t\\tm = max(m,a[r])\\n\\t\\t\\t\\tr += 1\\n\\t\\t\\t\\tif(m == le+1):\\n\\t\\t\\t\\t\\tans.append('1')\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans.append('0')\\n\\t\\t\\telse:\\n\\t\\t\\t\\tm = max(m,a[l])\\n\\t\\t\\t\\tl -= 1\\n\\t\\t\\t\\tif(m == le+1):\\n\\t\\t\\t\\t\\tans.append('1')\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans.append('0')\\n\\t\\telif(l != -1):\\n\\t\\t\\tm = max(m,a[l])\\n\\t\\t\\tl -= 1\\n\\t\\t\\tif(m == le+1):\\n\\t\\t\\t\\tans.append('1')\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans.append('0')\\n\\t\\telse:\\n\\t\\t\\tm = max(m,a[r])\\n\\t\\t\\tr += 1\\n\\t\\t\\tif(m == le+1):\\n\\t\\t\\t\\tans.append('1')\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans.append('0')\\n\\t\\tle += 1\\n\\tprint(\\\"\\\".join(ans))\\n\\n\\n\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    pos = [0]*(n+1)\\n    for i, x in enumerate(a):\\n        pos[x] = i\\n\\n    used = [0, 1] + [0]*n\\n    ans = [0]*n\\n    l, r = pos[1], pos[1]\\n    count = 1\\n\\n    for x in range(1, n+1):\\n        if not used[x]:\\n            if pos[x] < l:\\n                while not used[x]:\\n                    l -= 1\\n                    used[a[l]] = 1\\n                    count += 1\\n            else:\\n                while not used[x]:\\n                    r += 1\\n                    used[a[r]] = 1\\n                    count += 1\\n\\n        if count == x:\\n            ans[x-1] = 1\\n\\n    print(*ans, sep='')\", \"def mi():\\n    return map(int, input().split())\\n\\n'''\\n3\\n6\\n4 5 1 3 2 6\\n5\\n5 3 1 2 4\\n4\\n1 4 3 2\\n3\\n6\\n4 5 1 3 2 6\\n5\\n5 3 1 2 4\\n4\\n1 4 3 2\\n'''\\nfor _ in range(int(input())):\\n    n = int(input())\\n    a = list(mi())\\n    t = a.index(1)\\n    dist = [0]*(n+1)\\n    dic = [0]*n\\n    for i in range(n):\\n        dist[a[i]] = abs(t-i)\\n        dic[i] = [a[i], i]\\n    dic.sort()\\n    lm = dic[0][1]\\n    rm = dic[0][1]\\n    print (1, end = '')\\n    for i in range(1, n):\\n        if (dic[i][1]<lm):\\n            lm = dic[i][1]\\n        if (dic[i][1]>rm):\\n            rm = dic[i][1]\\n        if rm-lm<i+1:\\n            print (1, end = '')\\n        else:\\n            print (0, end = '')\\n    print()\", \"from sys import stdin\\ninput = stdin.readline\\n\\n\\nt = int(input())\\n\\nfor _ in range(t):\\n\\n    n = int(input())\\n    a = list(map(int,input().split()))\\n\\n    start = 0\\n    for i,v in enumerate(a):\\n        if v == 1:\\n            start = i\\n            break\\n    ans = [0]*-~n\\n    ans[n-1] = 1\\n    mx = 1\\n    l = start\\n    r = start\\n\\n    def move(x):\\n        nonlocal l,r,mx\\n        if x:\\n            mx = max(a[r+1],mx)\\n            r += 1\\n        else:\\n            mx = max(a[l-1],mx)\\n            l -= 1\\n\\n\\n    while mx < n:\\n        if mx == r-l+1:\\n            ans[mx-1] = 1\\n        if l == 0:\\n            move(1)\\n        elif r == n-1:\\n            move(0)\\n        else:\\n            if a[l-1] > a[r+1]:\\n                move(1)\\n            else:\\n                move(0)\\n\\n    print(\\\"\\\".join(map(str,ans[:n])))\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\", \"#!/usr/bin/env python3\\nfrom itertools import combinations\\nimport sys\\ninput = sys.stdin.readline\\nINF = 10**9\\n\\nt = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    a = [INF] + [int(item) for item in input().split()] + [INF]\\n    ans = [1]\\n    l = r = a.index(1)\\n    max_val = 1\\n    for i in range(2, n+1):\\n        if i == max(max_val, a[l-1]):\\n            ans.append(1)\\n            l -= 1\\n            max_val = i\\n        elif i == max(max_val, a[r+1]):\\n            ans.append(1)\\n            r += 1\\n            max_val = i\\n        elif a[l-1] < a[r+1]:\\n            ans.append(0)\\n            max_val = max(max_val, a[l-1])\\n            l -= 1\\n        else:\\n            ans.append(0)\\n            max_val = max(max_val, a[r+1])\\n            r += 1\\n    print(\\\"\\\".join([str(item) for item in ans]))\", \"for j in range(int(input())):\\n    n = int(input())\\n    c = list(map(int,input().split()))\\n    index = [0]*n\\n    for i in range(n):\\n        index[c[i]-1]=i\\n    ma = 0\\n    mi = n\\n    ans = ['0']*n\\n    # print(index)\\n    for k in range(n):\\n        ma = max(index[k],ma)\\n        mi = min(index[k],mi)\\n        #print(k,mr,index[k]-index[0])\\n        if ma-mi<=k:\\n            ans[k]='1'\\n    print(''.join(ans))\", \"q=int(input())\\nfor t in range(q):\\n    n=int(input())\\n    a=list(map(int,input().split()))\\n    ma=1\\n    ans='1'\\n    uk1=a.index(1)\\n    uk2=uk1\\n    while uk2-uk1+1!=n:\\n        if uk2==n-1:\\n            uk1-=1\\n            ma=max(ma,a[uk1])\\n            if ma==uk2-uk1+1:\\n                ans=ans+'1'\\n            else:\\n                ans=ans+'0'\\n        else:\\n            if uk1==0:\\n                uk2+=1\\n                ma=max(ma,a[uk2])\\n                if ma == uk2 - uk1 + 1:\\n                    ans = ans + '1'\\n                else:\\n                    ans=ans+'0'\\n            else:\\n                if a[uk1-1]<a[uk2+1]:\\n                    uk1 -= 1\\n                    ma = max(ma, a[uk1])\\n                    if ma == uk2 - uk1 + 1:\\n                        ans = ans + '1'\\n                    else:\\n                        ans = ans + '0'\\n                else:\\n                    uk2 += 1\\n                    ma = max(ma, a[uk2])\\n                    if ma == uk2 - uk1 + 1:\\n                        ans = ans + '1'\\n                    else:\\n                        ans = ans + '0'\\n    print(ans)\", \"\\nlpn = int(input())\\n\\nfor loop in range(lpn):\\n\\n    n = int(input())\\n    p = list(map(int,input().split()))\\n\\n    for i in range(n):\\n\\n        if p[i] == 1:\\n            oneind = i\\n            break\\n\\n    l = oneind\\n    r = oneind\\n    nmax = 1\\n    ans = [0] * n\\n    ans[0] = 1\\n\\n    for i in range(n-1):\\n\\n        if l == 0 or( r != n-1 and p[l-1] > p[r+1]):\\n            r += 1\\n            nmax = max(nmax,p[r])\\n            if i+2 == nmax:\\n                ans[i+1] = 1 \\n        else:\\n            l -= 1\\n            nmax = max(nmax,p[l])\\n\\n            if i+2 == nmax:\\n                ans[i+1] = 1 \\n            \\n    print(\\\"\\\".join(map(str,ans)))\\n\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    a = [int(i) for i in input().split()]\\n    ans = ['0'] * n\\n    ans[0] = '1'\\n    ans[-1] = '1'\\n    l = 0\\n    r = n - 1\\n    now = n\\n    while (r - l) > 1:\\n        if a[r] > now:\\n            r -= 1\\n            continue\\n        if a[l] > now:\\n            l += 1\\n            continue\\n        if (r - l + 1) == now:\\n            ans[r - l] = '1'\\n        now -= 1\\n    if (r - l  + 1) == now:\\n        ans[r - l] = '1'\\n    print(''.join(ans))\\n\\n\\n\", \"# https://codeforces.com/contest/1265/problem/B\\n\\ndef main():\\n    n = int(input())\\n    p = list(map(int, input().split()))\\n    idx = [0] * n\\n    for i in range(n):\\n        idx[p[i]-1] = i\\n    ans = ''\\n    left = n\\n    right = 0\\n    for i in range(n):\\n        left = min(left, idx[i])\\n        right = max(right, idx[i])\\n        if right - left == i:\\n            ans += '1'\\n        else:\\n            ans += '0'\\n    return ans\\n\\nt = int(input())\\nfor i in range(t):\\n    print(main())\\n\", \"def f():\\n    n = int(input())\\n    A = [int(s) for s in input().split()]\\n    ans = [0]*n\\n    ans[0] = 1\\n    ans[n-1] = 1\\n    i = 0\\n    j = n-1\\n    outMin = n+1\\n    while j>i:\\n        if A[i] > A[j]:\\n            if A[i] < outMin:\\n                outMin = A[i]\\n            i += 1\\n        else:\\n            if A[j] < outMin:\\n                outMin = A[j]\\n            j -= 1\\n        if j-i == outMin-2:\\n            ans[j-i] = 1\\n    print(''.join(str(i) for i in ans))\\n\\n\\nt = int(input())\\nfor i in range(t):\\n    f()\", \"n = int(input())\\nfor _ in range(n):\\n    k = int(input())\\n    pos = [0] * k\\n    arr = list(map(int, input().split(' ')))\\n    for i in range(k):\\n        pos[arr[i] - 1] = i\\n\\n    #print(pos)\\n\\n    left, right = [0] * k, [0] * k\\n    left[0], right[0] = pos[0], pos[0]\\n    for i in range(1, k):\\n        left[i] = min(left[i - 1], pos[i])\\n        right[i] = max(right[i - 1], pos[i])\\n\\n    #print(left)\\n    #print(right)\\n    for i in range(k):\\n        if right[i] - left[i] == i:\\n            print(1, end=\\\"\\\")\\n        else:\\n            print(0, end=\\\"\\\")\\n    print()\", \"for kkk in range(int(input())):\\n\\tn = int(input())\\n\\tl = list(map(int, input().split()))\\n\\td = {}\\n\\tfor i in range(n):\\n\\t\\td[l[i]] = i\\n\\tans = [\\\"0\\\" for i in range(n+1)]\\n\\tans[1] = \\\"1\\\"\\n\\tposleft = d[1]\\n\\tposright = d[1]\\n\\tfor j in range(2, n+1):\\n\\t\\tif(d[j]==posleft-1 or d[j]==posright+1):\\n\\t\\t\\tif(ans[j-1]==\\\"1\\\"):\\n\\t\\t\\t\\tans[j] = \\\"1\\\"\\n\\t\\telif(d[j]<posright and d[j]>posleft):\\n\\t\\t\\tif(posright - posleft + 1 == j):\\n\\t\\t\\t\\tans[j] = \\\"1\\\"\\n\\t\\tif(d[j]<posleft):\\n\\t\\t\\tposleft = d[j]\\n\\t\\tif(d[j]>posright):\\n\\t\\t\\tposright = d[j]\\n\\tprint(''.join(ans[1:]))\", \"import sys\\nimport math\\nimport bisect\\n \\n \\nsys.setrecursionlimit(1000000000)\\ndef input():\\n    return sys.stdin.readline().strip()\\n \\ndef iinput():\\n    return int(input())\\n \\ndef finput():\\n    return float(input())\\n \\ndef tinput():\\n    return input().split()\\n \\ndef rinput():\\n    return map(int, tinput())\\n \\ndef rlinput():\\n    return list(rinput())\\n\\ndef main():\\n    n = iinput()\\n    c = rlinput()\\n    q, res, w, e = [0] * n, ['0'] * n, 0, n\\n    for i in range(n):\\n        q[c[i] - 1] = i\\n    for i in range(n):\\n        w = max(q[i], w)\\n        e = min(q[i], e)\\n        if w <= i + e:\\n            res[i] = '1'\\n    print(''.join(res))\\n        \\nfor j in range(int(input())):\\n    main()\", \"from math import floor, ceil\\n\\nt = int(input())\\n\\nfor _ in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    pos = dict()\\n    for p, i in enumerate(a):\\n        pos[i] = p\\n    minpos = [None] + [pos[1]] + [None]*(n-1)\\n    maxpos = [None] + [pos[1]] + [None]*(n-1)\\n\\n    for i in range(2, n+1):\\n        minpos[i] = min(minpos[i-1], pos[i])\\n        maxpos[i] = max(maxpos[i-1], pos[i])\\n\\n\\n    good = ['0']*n \\n    for i in range(1, n+1):\\n        if maxpos[i] - minpos[i] + 1 == i:\\n            good[i-1] = '1'\\n\\n    print(''.join(good))\\n\\n     \\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n6\\n4 5 1 3 2 6\\n5\\n5 3 1 2 4\\n4\\n1 4 3 2\\n\"\n  ],\n  \"outputs\": [\n    \"101011\\n11111\\n1001\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1265/B", "starter_code": ""}
{"id": 5, "question": "The sequence of $m$ integers is called the permutation if it contains all integers from $1$ to $m$ exactly once. The number $m$ is called the length of the permutation.\n\nDreamoon has two permutations $p_1$ and $p_2$ of non-zero lengths $l_1$ and $l_2$.\n\nNow Dreamoon concatenates these two permutations into another sequence $a$ of length $l_1 + l_2$. First $l_1$ elements of $a$ is the permutation $p_1$ and next $l_2$ elements of $a$ is the permutation $p_2$. \n\nYou are given the sequence $a$, and you need to find two permutations $p_1$ and $p_2$. If there are several possible ways to restore them, you should find all of them. (Note that it is also possible that there will be no ways.)\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10\\,000$) denoting the number of test cases in the input.\n\nEach test case contains two lines. The first line contains one integer $n$ ($2 \\leq n \\leq 200\\,000$): the length of $a$. The second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq n-1$).\n\nThe total sum of $n$ is less than $200\\,000$.\n\n\n-----Output-----\n\nFor each test case, the first line of output should contain one integer $k$: the number of ways to divide $a$ into permutations $p_1$ and $p_2$.\n\nEach of the next $k$ lines should contain two integers $l_1$ and $l_2$ ($1 \\leq l_1, l_2 \\leq n, l_1 + l_2 = n$), denoting, that it is possible to divide $a$ into two permutations of length $l_1$ and $l_2$ ($p_1$ is the first $l_1$ elements of $a$, and $p_2$ is the last $l_2$ elements of $a$). You can print solutions in any order.\n\n\n-----Example-----\nInput\n6\n5\n1 4 3 2 1\n6\n2 4 1 3 2 1\n4\n2 1 1 3\n4\n1 3 3 1\n12\n2 1 3 4 5 6 7 8 9 1 10 2\n3\n1 1 1\n\nOutput\n2\n1 4\n4 1\n1\n4 2\n0\n0\n1\n2 10\n0\n\n\n\n-----Note-----\n\nIn the first example, two possible ways to divide $a$ into permutations are $\\{1\\} + \\{4, 3, 2, 1\\}$ and $\\{1,4,3,2\\} + \\{1\\}$.\n\nIn the second example, the only way to divide $a$ into permutations is $\\{2,4,1,3\\} + \\{2,1\\}$.\n\nIn the third example, there are no possible ways.", "solutions": "[\"def possible(a):\\n    ans = set()\\n    s = set()\\n    lmax = 0\\n    for i in range(len(a)):\\n        lmax = max(lmax, a[i])\\n        s.add(a[i])\\n        if lmax == i + 1 and len(s) == i + 1:\\n            ans.add(i + 1)\\n    return ans\\n\\n\\nt = int(input())\\nfor case_num in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split(' ')))\\n    left = possible(a)\\n    a.reverse()\\n    right = possible(a)\\n    ans = []\\n    for l in left:\\n        if n - l in right:\\n            ans.append(l)\\n    print(len(ans))\\n    for l in ans:\\n        print(l, n - l)\\n\", \"import sys\\ninput=sys.stdin.readline\\nt=int(input())\\nfor _ in range(t):\\n    n=int(input())\\n    aa=list(map(int,input().split()))\\n    ss=set()\\n    \\n    st=0\\n    ind=1\\n    pre=[0 for i in range(n)]\\n    for i in range(n):\\n        if aa[i] in ss:\\n            break\\n        ss.add(aa[i])\\n        while ind<=len(ss):\\n            if ind in ss:\\n                ind+=1\\n            else:\\n                break\\n        if len(ss)!=ind-1:\\n            pre[i]=0\\n        else:\\n            pre[i]=ind\\n    ind=1\\n   # print(pre)\\n    ss=set()\\n    suff=[0 for i in range(n)]\\n    for i in range(n-1,-1,-1):\\n        if aa[i] in ss:\\n            break\\n        ss.add(aa[i])\\n        while ind<=len(ss):\\n            if ind in ss:\\n                ind+=1\\n            else:\\n                break\\n        if len(ss)!=ind-1:\\n            suff[i]=0\\n        else:\\n            suff[i]=ind\\n    tot=0\\n    ans=[]\\n    for i in range(n-1):\\n        if pre[i]>0 and suff[i+1]>0:\\n            tot+=1\\n            ans.append([i+1,n-i-1])\\n    print(tot)\\n    for i in ans:\\n        print(i[0],i[1])\\n        \\n\\n\", \"# @author \\n\\nimport sys\\n\\nclass BDreamoonLikesPermutations:\\n    def solve(self):\\n        for _ in range(int(input())):\\n            \\n            def is_perm(a):\\n                return len(set(a)) == len(a) and min(a) == 1 and max(a) == len(a)\\n            \\n            n = int(input())\\n            a = [int(_) for _ in input().split()]\\n            done = set()\\n            ans = set()\\n            i = 0\\n            for i in range(n):\\n                if a[i] in done:\\n                    break\\n                done.add(a[i])\\n            \\n            if is_perm(a[:i]) and is_perm(a[i:]):\\n                ans.add((i, n - i))\\n\\n            done = set()\\n            for i in range(n - 1, -1, -1):\\n                if a[i] in done:\\n                    break\\n                done.add(a[i])\\n\\n            if is_perm(a[:i + 1]) and is_perm(a[i + 1:]):\\n                ans.add((i + 1, n - i - 1))\\n\\n            print(len(ans))\\n            for sol in ans:\\n                print(*sol)\\n\\nsolver = BDreamoonLikesPermutations()\\ninput = sys.stdin.readline\\n\\nsolver.solve()\\n\", \"def readIntArray():\\n    return list(map(int,input().split()))\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    a = readIntArray()\\n    mp = {}\\n    for val in a:\\n        if val not in mp:\\n            mp[val] = 0\\n        mp[val] += 1\\n    l1 = max(a)\\n    l2 = n - l1\\n    if l2 <= 0:\\n        print(0)\\n        continue\\n    good = True\\n    for i in range(1, l2 + 1):\\n        if i not in mp or mp[i] != 2:\\n            good = False\\n            break\\n    for i in range(l2 + 1, l1 + 1):\\n        if i not in mp or mp[i] != 1:\\n            good = False\\n            break\\n    if not good:\\n        print(0)\\n        continue\\n    mp = {}\\n    ans = set()\\n    cur = 0\\n    st = set()\\n    used = set()\\n    for i in range(n):\\n        if a[i] in used:\\n            break\\n        st.add(a[i])\\n        used.add(a[i])\\n        while cur + 1 in st:\\n            st.remove(cur + 1)\\n            cur += 1\\n        if cur == l1 or cur == l2 and len(st) == 0:\\n            ans.add((cur, n - cur))\\n    print(len(ans))\\n    for val in ans:\\n        print(val[0], val[1])\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    a = [int(x) for x in input().split()]\\n    mx = max(a)\\n    sols = []\\n    if mx < n:\\n        l1 = list(sorted(a[:mx]))\\n        l2 = list(sorted(a[mx:]))\\n        rl1 = list(range(1, mx+1))\\n        rl2 = list(range(1, n-mx+1))\\n        if l1 == rl1 and l2 == rl2:\\n            sols.append((mx, n - mx))\\n        l1 = list(sorted(a[:n-mx]))\\n        l2 = list(sorted(a[n-mx:]))\\n        if mx*2 != n and l1 == rl2 and l2 == rl1:\\n            sols.append((n-mx, mx))\\n    print(len(sols))\\n    for p in sols:\\n        print(*p)\\n\", \"from collections import deque\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    liste = list(map(int, input().split()))\\n    vis = [0 for i in range(n)]\\n    can = [0 for i in range(n)]\\n    can2 = [0 for i in range(n)]\\n    maxi = 0\\n    for i in range(1, n):\\n        if (vis[liste[i-1]]):\\n            break\\n        vis[liste[i-1]] = 1\\n        maxi = max(maxi, liste[i-1])\\n        if (maxi == i):\\n            can[maxi] = 1\\n    liste = liste[::-1]\\n    maxi = 0\\n    vis = [0 for i in range(n)]\\n    for i in range(1, n):\\n        if (vis[liste[i-1]]):\\n            break\\n        vis[liste[i-1]] = 1\\n        maxi = max(maxi, liste[i-1])\\n        if (maxi == i):\\n            can2[maxi] = 1\\n    count = 0\\n    for i in range(1, n):\\n        if (can[i] and can2[n-i]):\\n            count += 1\\n    print(count)\\n    for i in range(1, n):\\n        if (can[i] and can2[n-i]):\\n            print(i, n-i)\", \"for _ in range(int(input())):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    dpF = [0 for i in range(n)]\\n    dpB = [0 for i in range(n)]\\n    noRep = 1\\n    r = {}\\n    m = 0\\n    for i in range(n):\\n        if r.get(a[i]) == None:\\n            r[a[i]] = 1\\n            m = max(m, a[i])\\n            if m == i + 1:\\n                dpF[i] = 1\\n        else:\\n            break\\n    r = {}\\n    m = 0\\n    for i in range(n - 1, -1, -1):\\n        if r.get(a[i]) == None:\\n            r[a[i]] = 1\\n            m = max(m, a[i])\\n            if m == n - i:\\n                dpB[i] = 1\\n        else:\\n            break\\n    # print(dpF)\\n    # print(dpB)\\n    ans = 0\\n    ansList = []\\n    for i in range(n - 1):\\n        if dpF[i] == 1 and dpB[i + 1] == 1:\\n            ans += 1\\n            ansList.append([i + 1, n - i - 1])\\n    print(ans)\\n    for i in ansList:\\n        print(i[0], i[1])\", \"from math import *\\n\\nmod = 1000000007\\n\\nfor zz in range(int(input())):\\n    n = int(input())\\n    a = [int(i) for i in input().split()]\\n    ans = []\\n    cs = set()\\n    d = {}\\n    c = 0\\n    for i in range(n):\\n        if a[i] not in d:\\n            c += 1\\n            d[a[i]] = 0\\n        d[a[i]] += 1\\n    mv = 0\\n    m = [0] * n\\n    m[-1] = a[-1]\\n    for i in range(n - 2, -1, -1):\\n        m[i] = max(m[i + 1], a[i])\\n\\n    for i in range(n):\\n        mv = max(a[i], mv)\\n        if a[i] in cs:\\n            break\\n        cs.add(a[i])\\n        d[a[i]] -= 1\\n        if d[a[i]] <= 0:\\n            c -= 1\\n        if mv == i + 1 and c == n - i - 1 and m[i + 1] == n - i - 1:\\n            ans.append(i)\\n    print(len(ans))\\n    for i in ans:\\n        print(i + 1, n - i - 1)\\n\", \"def per(X):\\n    S=set(X)\\n    if not len(X)==len(S):\\n        return False\\n    for i in range(1,len(X)+1):\\n        if i not in S: return False\\n    return True\\nfor y in range(int(input())):\\n    n=int(input())\\n    L=list(map(int,input().split()))\\n    m=max(L)\\n    r=[]\\n    if n!=m:\\n        if per(L[:m]) and per(L[m:]):\\n            r.append((m,n-m))\\n        if per(L[-m:]) and per(L[:-m]):\\n            r.append((n-m,m))\\n    r=list(set(r))\\n    print(len(r))\\n    for a,b in r:\\n        print(a,b)\", \"import sys\\ninput = sys.stdin.readline\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    seen = [False] * (n+1)\\n    ans = set()\\n    for i, x in enumerate(a):\\n        if seen[x]:\\n            if sorted(a[:i]) == list(range(1, i+1)) and sorted(a[i:]) == list(range(1, n-i+1)):\\n                ans.add((i, n-i))\\n            break\\n        seen[x] = True\\n    seen = [False] * (n+1)\\n    for i, x in list(enumerate(a))[::-1]:\\n        if seen[x]:\\n            if sorted(a[:i+1]) == list(range(1, i+2)) and sorted(a[i+1:]) == list(range(1, n-i)):\\n                ans.add((i+1, n-i-1))\\n            break\\n        seen[x] = True\\n    print(len(ans))\\n    for l1, l2 in ans:\\n        print(l1, l2)\\n\\n\", \"import sys\\ninput=sys.stdin.readline\\nt=int(input())\\nfor _ in range(t):\\n    n=int(input())\\n    arr=list(map(int,input().split()))\\n    d=dict()\\n    demand=1\\n    pre=[0]*n\\n    post=[0]*n\\n    for i in range(n):\\n        d[arr[i]]=1\\n        if(demand in d):\\n            while(demand in d):\\n                demand+=1\\n            pre[i]=demand-1\\n    d2=dict()\\n    #print(pre)\\n    demand=1\\n    for i in range(n-1,-1,-1):\\n        d2[arr[i]]=1\\n        if(demand in d2):\\n            while(demand in d2):\\n                demand+=1\\n            post[i]=demand-1\\n    #print(post)\\n    l=[]\\n    for i in range(1,n):\\n        if(post[i]+pre[i-1]==n):\\n            l+=[[pre[i-1],post[i]]]\\n    print(len(l))\\n    for i in l:\\n        print(*i)\\n    \\n            \\n\", \"import heapq, sys\\n\\n\\ndef ps(l):\\n    n = len(l)\\n    nxt = 1\\n    heap = []\\n    ans = []\\n    for i in range(n):\\n        heapq.heappush(heap, l[i])\\n        while heap and heap[0] == nxt:\\n            nxt += 1\\n            heapq.heappop(heap)\\n        if not heap:\\n            ans.append(i)\\n    return ans\\n\\n\\nfor q in range(int(sys.stdin.readline())):\\n    n = int(sys.stdin.readline())\\n    d = [int(i) for i in sys.stdin.readline().split()]\\n    st = set(ps(d))\\n    # print(st)\\n    d.reverse()\\n    anss = []\\n    ap = ps(d)\\n    # print(ap)\\n    for a in ap:\\n        b = n-2-a\\n        if b in st:\\n            anss.append(str(b+1)+' '+ str(n - b - 1) + '\\\\n')\\n    sys.stdout.write(str(len(anss)) + '\\\\n')\\n    sys.stdout.write(''.join(anss))\\n\\n\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"6\\n5\\n1 4 3 2 1\\n6\\n2 4 1 3 2 1\\n4\\n2 1 1 3\\n4\\n1 3 3 1\\n12\\n2 1 3 4 5 6 7 8 9 1 10 2\\n3\\n1 1 1\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n1 4\\n4 1\\n1\\n4 2\\n0\\n0\\n1\\n2 10\\n0\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1330/B", "starter_code": ""}
{"id": 6, "question": "Arthur owns a ski resort on a mountain. There are $n$ landing spots on the mountain numbered from $1$ to $n$ from the top to the foot of the mountain. The spots are connected with one-directional ski tracks. All tracks go towards the foot of the mountain, so there are no directed cycles formed by the tracks. There are at most two tracks leaving each spot, but many tracks may enter the same spot.\n\nA skier can start skiing from one spot and stop in another spot if there is a sequence of tracks that lead from the starting spot and end in the ending spot. Unfortunately, recently there were many accidents, because the structure of the resort allows a skier to go through dangerous paths, by reaching high speed and endangering himself and the other customers. Here, a path is called dangerous, if it consists of at least two tracks.\n\nArthur wants to secure his customers by closing some of the spots in a way that there are no dangerous paths in the resort. When a spot is closed, all tracks entering and leaving that spot become unusable. \n\nFormally, after closing some of the spots, there should not be a path that consists of two or more tracks.\n\nArthur doesn't want to close too many spots. He will be happy to find any way to close at most $\\frac{4}{7}n$ spots so that the remaining part is safe. Help him find any suitable way to do so.\n\n\n-----Input-----\n\nThe first line contains a single positive integer $T$\u00a0\u2014 the number of test cases. $T$ test case description follows.\n\nThe first line of each description contains two integers $n$ and $m$ ($1 \\leq n \\leq 2 \\cdot 10^5$)\u00a0\u2014 the number of landing spots and tracks respectively.\n\nThe following $m$ lines describe the tracks. Each of these lines contains two integers $x$ and $y$ ($1 \\leq x < y \\leq n$)\u00a0\u2014 indices of the starting and finishing spots for the respective track. It is guaranteed that at most two tracks start at each spot. There may be tracks in which starting and finishing spots both coincide.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, print a single integer $k$ ($0 \\leq k \\leq \\frac{4}{7}n$)\u00a0\u2014 the number of spots to be closed. In the next line, print $k$ distinct integers\u00a0\u2014 indices of all spots to be closed, in any order.\n\nIf there are several answers, you may output any of them. Note that you don't have to minimize $k$. It can be shown that a suitable answer always exists.\n\n\n-----Example-----\nInput\n2\n4 6\n1 2\n1 3\n2 3\n2 4\n3 4\n3 4\n7 6\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n\nOutput\n2\n3 4 \n4\n4 5 6 7 \n\n\n\n-----Note-----\n\nIn the first sample case, closing any two spots is suitable.\n\nIn the second sample case, closing only the spot $1$ is also suitable.", "solutions": "[\"import sys\\ninput = sys.stdin.readline\\nfor f in range(int(input())):\\n    n,m=list(map(int,input().split()))\\n    neig=[0]*n\\n    for i in range(n):\\n        neig[i]=[0]\\n    \\n    for i in range(m):\\n        a,b=list(map(int,input().split()))\\n        a-=1\\n        b-=1\\n        neig[a][0]+=1\\n        neig[a].append(b)\\n    lev=[1]*n\\n    for i in range(n):\\n        for j in range(1,neig[i][0]+1):\\n            x=lev[i]+1\\n            if x==4:\\n                x=1\\n            lev[neig[i][j]]=max(lev[neig[i][j]],x)\\n    sol=0\\n    s=[]\\n    for i in range(n):\\n        if lev[i]==3:\\n            sol+=1\\n            s.append(i+1)\\n    print(sol)\\n    print(*s)\\n    \\n\", \"import sys\\ninput = sys.stdin.readline\\nfrom heapq import heapify,heappush,heappop\\nt = int(input())\\nfor _ in range(t):\\n  n,m = map(int,input().split())\\n  ab = [list(map(int,input().split())) for i in range(m)]\\n  go = [[] for i in range(n+1)]\\n  come = [[] for i in range(n+1)]\\n  for a,b in ab:\\n    go[a].append(b)\\n    come[b].append(a)\\n  exist = [1]*(n+1)\\n  flg = [10]*(n+1)\\n  for i in range(1,n+1):\\n    if flg[i] == 10:\\n      flg[i] = 2\\n    if flg[i] == 0:\\n      exist[i] = 0\\n    if go[i]:\\n      if flg[i] == 0:\\n        for j in go[i]:\\n          flg[j] = min(flg[j],2)\\n      else:\\n        for j in go[i]:\\n          flg[j] = min(flg[j],flg[i]-1)\\n  print(exist.count(0))\\n  ansls = []\\n  for i in range(1,n+1):\\n    if exist[i] == 0:\\n      ansls.append(i)\\n  print(*ansls)\", \"import sys\\n\\nT = int(sys.stdin.readline().strip())\\nfor t in range (0, T):\\n    n, m = list(map(int, sys.stdin.readline().strip().split()))\\n    P = [[] for i in range (0, n)]\\n    G = [0] * n\\n    for i in range (0, m):\\n        x, y = list(map(int, sys.stdin.readline().strip().split()))\\n        x, y = x-1, y-1\\n        P[y].append(x)\\n    ans = []\\n    for i in range (0, n):\\n        for j in P[i]:\\n            for k in P[j]:\\n                if G[j] == 0 and G[k] == 0:\\n                    if G[i] == 0:\\n                        ans.append(str(i+1))\\n                        G[i] = 1\\n                    \\n    print(len(ans))\\n    print(\\\" \\\".join(ans))\\n\", \"import sys\\ninputr = lambda: sys.stdin.readline().rstrip('\\\\n')\\ninput = sys.stdin.readline\\n\\nfor _ in range(int(input())):\\n\\tn, m = list(map(int, input().split()))\\n\\n\\n\\tadj = [[] for _ in range(n)]\\n\\n\\tfor _ in range(m):\\n\\t\\ta, b = list(map(int, input().split()))\\n\\t\\ta -= 1\\n\\t\\tb -= 1\\n\\t\\tadj[a].append(b)\\n\\n\\tLP = [0] * n\\n\\n\\tfor i in range(n):\\n\\t\\tif LP[i] < 2:\\n\\t\\t\\tfor j in adj[i]:\\n\\t\\t\\t\\tLP[j] = max(LP[j], LP[i] + 1)\\n\\n\\tr = [i+1 for i in range(n) if LP[i] >= 2]\\n\\n\\tprint(len(r))\\n\\tprint(' '.join(map(str, r)))\\n\\n\\tassert 7 * len(r) <= 4 * n\\n\\n\", \"import sys\\ninputr = lambda: sys.stdin.readline().rstrip('\\\\n')\\ninput = sys.stdin.readline\\n\\nfor _ in range(int(input())):\\n\\tn, m = list(map(int, input().split()))\\n\\tadj = [[] for _ in range(n)]\\n\\n\\tfor _ in range(m):\\n\\t\\ta, b = list(map(int, input().split()))\\n\\t\\ta -= 1\\n\\t\\tb -= 1\\n\\t\\tadj[a].append(b)\\n\\n\\tLP = [0] * n\\n\\tr = []\\n\\n\\tfor i in range(n):\\n\\t\\tif LP[i] < 2:\\n\\t\\t\\tfor j in adj[i]:\\n\\t\\t\\t\\tLP[j] = max(LP[j], LP[i] + 1)\\n\\t\\telse:\\n\\t\\t\\tr.append(str(i+1))\\n\\n\\tprint(len(r))\\n\\tprint(*r)\\n\\n\\tassert 7 * len(r) <= 4 * n\\n\\n\", \"#!/usr/bin/env python3\\nimport sys\\ninput = sys.stdin.readline\\nfrom collections import deque\\n\\nclass DirectedGraph:\\n    def __init__(self, adj):\\n        self.n = len(adj)\\n        self.adj = adj\\n        self.is_asyclic = False\\n        self.max_path_len = None\\n\\n    def topological_sort(self):\\n        indegree = [0] * self.n\\n        for vs in self.adj:\\n            for dest in vs:\\n                indegree[dest] += 1\\n        zero_v = []\\n        for v, indeg in enumerate(indegree):\\n            if indeg == 0:\\n                zero_v.append(v)\\n        max_path_len = 1\\n        tp_sorted = []\\n        to_be_added = []\\n        while True:\\n            while zero_v:\\n                v = zero_v.pop()\\n                tp_sorted.append(v)\\n                for dest in self.adj[v]:\\n                    indegree[dest] -= 1\\n                    if indegree[dest] == 0:\\n                        to_be_added.append(dest)\\n            if len(to_be_added) > 0:\\n                zero_v.extend(to_be_added)\\n                to_be_added = []\\n                max_path_len += 1\\n            else:\\n                break\\n        if len(tp_sorted) == self.n:\\n            self.is_asyclic = True\\n            self.max_path_len = max_path_len\\n            return tp_sorted\\n        else:\\n            self.is_asyclic = False\\n            return None\\n\\nt = int(input())\\nfor case in range(t):\\n    n, m = map(int, input().split())\\n    forward = [[] for _ in range(n)]\\n    backward = [[] for _ in range(n)]\\n\\n    seen = set()\\n    for _ in range(m):\\n        u, v = map(int, input().split())\\n        u -= 1; v -= 1\\n        if (u, v) in seen:\\n            continue\\n        seen.add((u, v))\\n        forward[u].append(v)\\n        backward[v].append(u)\\n    \\n    DG = DirectedGraph(forward)\\n    tps = DG.topological_sort()\\n    state = [-1] * n\\n    state[0] = 0\\n    for v in tps:\\n        if len(backward[v]) == 0:\\n            state[v] = 0\\n        for pv in backward[v]:\\n            state[v] = max(state[v], (state[pv] + 1) % 3)\\n    \\n    ans = []\\n    for i, color in enumerate(state):\\n        if color == 2:\\n            ans.append(i + 1)\\n    print(len(ans))\\n    print(*ans)\", \"import sys\\ndef rs(): return sys.stdin.readline().rstrip()\\ndef ri(): return int(sys.stdin.readline())\\ndef ria(): return list(map(int, sys.stdin.readline().split()))\\ndef ws(s): sys.stdout.write(s + '\\\\n')\\ndef wi(n): sys.stdout.write(str(n) + '\\\\n')\\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\\\n')\\n\\n\\ndef solve(n, m, g):\\n    dp = [0] * n\\n    ans = []\\n    for i in range(n):\\n        for w in g[i]:\\n            dp[i] = max(dp[i], dp[w] + 1)\\n        if dp[i] >= 2:\\n            dp[i] = -1\\n            ans.append(i+1)\\n    wi(len(ans))\\n    wia(ans)\\n\\n\\ndef main():\\n    for _ in range(ri()):\\n        n, m = ria()\\n        g = [[] for i in range(n)]\\n        for __ in range(m):\\n            u, v = ria()\\n            g[v-1].append(u-1)\\n        solve(n, m, g)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\"]", "input_output": "{\n  \"inputs\": [\n    \"2\\n4 6\\n1 2\\n1 3\\n2 3\\n2 4\\n3 4\\n3 4\\n7 6\\n1 2\\n1 3\\n2 4\\n2 5\\n3 6\\n3 7\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n3 4 \\n4\\n4 5 6 7 \\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1368/E", "starter_code": ""}
{"id": 7, "question": "The only difference between easy and hard versions is constraints.\n\nNow elections are held in Berland and you want to win them. More precisely, you want everyone to vote for you.\n\nThere are $n$ voters, and two ways to convince each of them to vote for you. The first way to convince the $i$-th voter is to pay him $p_i$ coins. The second way is to make $m_i$ other voters vote for you, and the $i$-th voter will vote for free.\n\nMoreover, the process of such voting takes place in several steps. For example, if there are five voters with $m_1 = 1$, $m_2 = 2$, $m_3 = 2$, $m_4 = 4$, $m_5 = 5$, then you can buy the vote of the fifth voter, and eventually everyone will vote for you. Set of people voting for you will change as follows: ${5} \\rightarrow {1, 5} \\rightarrow {1, 2, 3, 5} \\rightarrow {1, 2, 3, 4, 5}$.\n\nCalculate the minimum number of coins you have to spend so that everyone votes for you.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 2 \\cdot 10^5$) \u2014 the number of test cases.\n\nThe first line of each test case contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of voters.\n\nThe next $n$ lines contains the description of voters. $i$-th line contains two integers $m_i$ and $p_i$ ($1 \\le p_i \\le 10^9, 0 \\le m_i < n$).\n\nIt is guaranteed that the sum of all $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case print one integer \u2014 the minimum number of coins you have to spend so that everyone votes for you.\n\n\n-----Example-----\nInput\n3\n3\n1 5\n2 10\n2 8\n7\n0 1\n3 1\n1 1\n6 1\n1 1\n4 1\n4 1\n6\n2 6\n2 3\n2 8\n2 7\n4 4\n5 5\n\nOutput\n8\n0\n7\n\n\n\n-----Note-----\n\nIn the first test case you have to buy vote of the third voter. Then the set of people voting for you will change as follows: ${3} \\rightarrow {1, 3} \\rightarrow {1, 2, 3}$.\n\nIn the second example you don't need to buy votes. The set of people voting for you will change as follows: ${1} \\rightarrow {1, 3, 5} \\rightarrow {1, 2, 3, 5} \\rightarrow {1, 2, 3, 5, 6, 7} \\rightarrow {1, 2, 3, 4, 5, 6, 7}$.\n\nIn the third test case you have to buy votes of the second and the fifth voters. Then the set of people voting for you will change as follows: ${2, 5} \\rightarrow {1, 2, 3, 4, 5} \\rightarrow {1, 2, 3, 4, 5, 6}$.", "solutions": "[\"import sys\\ndef I():\\n    return sys.stdin.readline().rstrip()\\n\\nclass Heap:\\n    def __init__( self ):\\n        self.l = [ -1 ]\\n        self.n = 0\\n    def n( self ):\\n        return self.n\\n    def top( self ):\\n        return self.l[ 1 ]\\n    def ins( self, x ):\\n        self.l.append( x )\\n        n = len( self.l ) - 1\\n        i = n\\n        while i > 1:\\n            j = i // 2\\n            if self.l[ j ] > self.l[ i ]:\\n                self.l[ j ], self.l[ i ] = self.l[ i ], self.l[ j ]\\n                i = j\\n            else:\\n                break\\n    def pop( self ):\\n        r = self.l[ 1 ]\\n        l = self.l.pop()\\n        n = len( self.l ) - 1\\n        if n:\\n            self.l[ 1 ] = l\\n            i = 1\\n            while True:\\n                j = i * 2\\n                k = j + 1\\n                if k < len( self.l ) and self.l[ i ] > max( self.l[ j ], self.l[ k ] ):\\n                    if self.l[ j ] == min( self.l[ j ], self.l[ k ] ):\\n                        self.l[ i ], self.l[ j ] = self.l[ j ], self.l[ i ]\\n                        i = j\\n                    else:\\n                        self.l[ i ], self.l[ k ] = self.l[ k ], self.l[ i ]\\n                        i = k\\n                elif k < len( self.l ) and self.l[ i ] > self.l[ k ]:\\n                    self.l[ i ], self.l[ k ] = self.l[ k ], self.l[ i ]\\n                    i = k\\n                elif j < len( self.l ) and self.l[ i ] > self.l[ j ]:\\n                    self.l[ i ], self.l[ j ] = self.l[ j ], self.l[ i ]\\n                    i = j\\n                else:\\n                    break\\n        return r\\n\\nt = int( I() )\\nfor _ in range( t ):\\n    n = int( I() )\\n    voter = [ list( map( int, I().split() ) ) for _ in range( n ) ]\\n    h = Heap()\\n    d = {}\\n    for m, p in voter:\\n        if m not in d:\\n            d[ m ] = []\\n        d[ m ].append( p )\\n    need = {}\\n    c = 0\\n    sk = sorted( d.keys() )\\n    for m in sk:\\n        need[ m ] = max( 0, m - c )\\n        c += len( d[ m ] )\\n    c = 0\\n    ans = 0\\n    for m in sk[::-1]:\\n        for p in d[ m ]:\\n            h.ins( p )\\n        while c < need[ m ]:\\n            c += 1\\n            ans += h.pop()\\n    print( ans )\\n\", \"import heapq\\nimport sys\\ninput = sys.stdin.readline\\n\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    info = [list(map(int, input().split())) for i in range(n)]\\n    info = sorted(info)\\n    cnt = [0] * n\\n    for i in range(n):\\n        ind = info[i][0]\\n        cnt[ind] += 1\\n    ruiseki_cnt = [0] * (n+1)\\n    for i in range(n):\\n        ruiseki_cnt[i+1] = ruiseki_cnt[i] + cnt[i]\\n    # print(cnt)\\n    # print(ruiseki_cnt)\\n    need = [0] * n\\n    for i in range(1,n):\\n        if cnt[i] != 0 and i > ruiseki_cnt[i]:\\n            need[i] = min(i - ruiseki_cnt[i], i)\\n    # print(need)\\n    info = sorted(info, reverse = True)\\n    #print(info)\\n\\n    num = n - 1\\n    pos = 0\\n    q = []\\n    used_cnt = 0\\n    ans = 0\\n    while True:\\n        if num == -1:\\n            break\\n        while True:\\n            if pos < n and info[pos][0] >= num:\\n                heapq.heappush(q, info[pos][1])\\n                pos += 1\\n            else:\\n                break\\n        if need[num] - used_cnt > 0:\\n            tmp = need[num] - used_cnt\\n            for _ in range(tmp):\\n                ans += heapq.heappop(q)\\n            used_cnt += tmp\\n        num -= 1\\n    print(ans)\", \"import sys\\ninput = sys.stdin.readline\\n\\nimport heapq\\nfrom itertools import accumulate\\n\\nt=int(input())\\n\\nfor test in range(t):\\n    n=int(input())\\n    M=[[] for i in range(n)]\\n    MCOUNT=[0]*(n)\\n\\n    for i in range(n):\\n        m,p=list(map(int,input().split()))\\n        M[m].append(p)\\n        MCOUNT[m]+=1\\n\\n    #print(M)\\n    #print(MCOUNT)\\n\\n    ACC=list(accumulate(MCOUNT))\\n\\n    #print(ACC)\\n    HQ=[]\\n    ANS=0\\n    use=0\\n\\n    for i in range(n-1,-1,-1):\\n        for j in M[i]:\\n            heapq.heappush(HQ,j)\\n\\n        #print(HQ)\\n            \\n        while ACC[i-1]+use<i:\\n            x=heapq.heappop(HQ)\\n            ANS+=x\\n            use+=1\\n\\n\\n\\n    print(ANS)\\n            \\n            \\n        \\n        \\n        \\n\\n    \\n\\n    \\n\", \"import sys\\nfrom heapq import heappop, heappush\\n\\nreader = (line.rstrip() for line in sys.stdin)\\ninput = reader.__next__\\n \\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    mp = []\\n    for i in range(n):\\n        mi, pi = list(map(int, input().split()))\\n        mp.append((mi, pi))\\n    mp.sort()\\n    \\n    prices = []\\n    cost = 0\\n    bribed = 0\\n    i = n - 1\\n    while i >= 0:\\n        currM = mp[i][0]\\n        heappush(prices, mp[i][1])\\n        while i >= 1 and mp[i-1][0] == currM:\\n            i -= 1\\n            heappush(prices, mp[i][1])\\n        already = i + bribed\\n        for k in range(max(0, currM - already)):\\n            cost += heappop(prices)\\n            bribed += 1\\n        i -= 1\\n    \\n    print(cost)\\n\", \"import sys\\ninput = sys.stdin.readline\\nimport heapq as hq\\nt = int(input())\\nfor _ in range(t):\\n  n = int(input())\\n  vt = [list(map(int,input().split())) for i in range(n)]\\n  vt.sort(reverse=True)\\n  q = []\\n  hq.heapify(q)\\n  ans = 0\\n  cnt = 0\\n  for i in range(n):\\n    hq.heappush(q,vt[i][1])\\n    if vt[i][0] >= n-i+cnt:\\n      ans += hq.heappop(q)\\n      cnt += 1\\n  print(ans)\", \"import sys\\nimport heapq as hq\\n\\nreadline = sys.stdin.readline\\nread = sys.stdin.read\\nns = lambda: readline().rstrip()\\nni = lambda: int(readline().rstrip())\\nnm = lambda: map(int, readline().split())\\nnl = lambda: list(map(int, readline().split()))\\nprn = lambda x: print(*x, sep='\\\\n')\\n\\ndef solve():\\n    n = ni()\\n    vot = [tuple(nm()) for _ in range(n)]\\n    vot.sort(key = lambda x: (-x[0], x[1]))\\n    q = list()\\n    c = 0\\n    cost = 0\\n    for i in range(n):\\n        hq.heappush(q, vot[i][1])\\n        while n - i - 1 + c < vot[i][0]:\\n            cost += hq.heappop(q)\\n            c += 1\\n    print(cost)\\n    return\\n\\n\\n# solve()\\n\\nT = ni()\\nfor _ in range(T):\\n    solve()\\n\", \"import sys\\nimport heapq as hp\\n#sys.stdin = open('in', 'r')\\nt = int(sys.stdin.readline())\\nfor ti in range(t):\\n    n = int(sys.stdin.readline())\\n    a = [tuple(map(int, sys.stdin.readline().split())) for i in range(n)]\\n    a.sort(key = lambda x: (x[0], -x[1]))\\n    c = 0\\n    h = []\\n    res = 0\\n    for i in range(n-1,-1,-1):\\n        hp.heappush(h, a[i][1])\\n        while c + i < a[i][0]:\\n            res += hp.heappop(h)\\n            c += 1\\n    print(res)\\n\\n\\n#sys.stdout.write('YES\\\\n')\\n#sys.stdout.write(f'{res}\\\\n')\\n#sys.stdout.write(f'{y1} {x1} {y2} {x2}\\\\n')\\n\", \"import sys\\nfrom heapq import *\\n#sys.stdin = open('in', 'r')\\nt = int(sys.stdin.readline())\\nfor ti in range(t):\\n    n = int(sys.stdin.readline())\\n    a = [tuple(map(int, sys.stdin.readline().split())) for i in range(n)]\\n    a.sort(key = lambda x: (x[0], -x[1]))\\n    c = 0\\n    h = []\\n    res = 0\\n    for i in range(n-1,-1,-1):\\n        heappush(h, a[i][1])\\n        while c + i < a[i][0]:\\n            res += heappop(h)\\n            c += 1\\n    print(res)\\n\\n\\n#sys.stdout.write('YES\\\\n')\\n#sys.stdout.write(f'{res}\\\\n')\\n#sys.stdout.write(f'{y1} {x1} {y2} {x2}\\\\n')\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n3\\n1 5\\n2 10\\n2 8\\n7\\n0 1\\n3 1\\n1 1\\n6 1\\n1 1\\n4 1\\n4 1\\n6\\n2 6\\n2 3\\n2 8\\n2 7\\n4 4\\n5 5\\n\"\n  ],\n  \"outputs\": [\n    \"8\\n0\\n7\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1251/E2", "starter_code": ""}
{"id": 8, "question": "You like playing chess tournaments online.\n\nIn your last tournament you played $n$ games. For the sake of this problem, each chess game is either won or lost (no draws). When you lose a game you get $0$ points. When you win you get $1$ or $2$ points: if you have won also the previous game you get $2$ points, otherwise you get $1$ point. If you win the very first game of the tournament you get $1$ point (since there is not a \"previous game\").\n\nThe outcomes of the $n$ games are represented by a string $s$ of length $n$: the $i$-th character of $s$ is W if you have won the $i$-th game, while it is L if you have lost the $i$-th game.\n\nAfter the tournament, you notice a bug on the website that allows you to change the outcome of at most $k$ of your games (meaning that at most $k$ times you can change some symbol L to W, or W to L). Since your only goal is to improve your chess rating, you decide to cheat and use the bug.\n\nCompute the maximum score you can get by cheating in the optimal way.\n\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains an integer $t$ ($1\\le t \\le 20,000$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each testcase contains two integers $n, k$ ($1\\le n\\le 100,000$, $0\\le k\\le n$) \u2013 the number of games played and the number of outcomes that you can change.\n\nThe second line contains a string $s$ of length $n$ containing only the characters W and L. If you have won the $i$-th game then $s_i=\\,$W, if you have lost the $i$-th game then $s_i=\\,$L.\n\nIt is guaranteed that the sum of $n$ over all testcases does not exceed $200,000$.\n\n\n-----Output-----\n\nFor each testcase, print a single integer \u2013 the maximum score you can get by cheating in the optimal way.\n\n\n-----Example-----\nInput\n8\n5 2\nWLWLL\n6 5\nLLLWWL\n7 1\nLWLWLWL\n15 5\nWWWLLLWWWLLLWWW\n40 7\nLLWLWLWWWLWLLWLWWWLWLLWLLWLLLLWLLWWWLWWL\n1 0\nL\n1 1\nL\n6 1\nWLLWLW\n\nOutput\n7\n11\n6\n26\n46\n0\n1\n6\n\n\n\n-----Note-----\n\nExplanation of the first testcase. Before changing any outcome, the score is $2$. Indeed, you won the first game, so you got $1$ point, and you won also the third, so you got another $1$ point (and not $2$ because you lost the second game).\n\nAn optimal way to cheat is to change the outcomes of the second and fourth game. Doing so, you end up winning the first four games (the string of the outcomes becomes WWWWL). Hence, the new score is $7=1+2+2+2$: $1$ point for the first game and $2$ points for the second, third and fourth game.\n\nExplanation of the second testcase. Before changing any outcome, the score is $3$. Indeed, you won the fourth game, so you got $1$ point, and you won also the fifth game, so you got $2$ more points (since you won also the previous game).\n\nAn optimal way to cheat is to change the outcomes of the first, second, third and sixth game. Doing so, you end up winning all games (the string of the outcomes becomes WWWWWW). Hence, the new score is $11 = 1+2+2+2+2+2$: $1$ point for the first game and $2$ points for all the other games.", "solutions": "[\"import sys\\ninput = sys.stdin.readline\\n\\ndef main():\\n    n, k = map(int, input().split())\\n    string = input().strip()\\n    if \\\"W\\\" not in string:\\n        ans = min(n, k) * 2 - 1\\n        print(max(ans, 0))\\n        return\\n        \\n    L_s = []\\n    cnt = 0\\n    bef = string[0]\\n    ans = 0\\n    for s in string:\\n        if s == bef:\\n            cnt += 1\\n        else:\\n            if bef == \\\"L\\\":\\n                L_s.append(cnt)\\n            else:\\n                ans += cnt * 2 - 1\\n            cnt = 1\\n        bef = s\\n    if bef == \\\"W\\\":\\n        ans += cnt * 2 - 1\\n        cnt = 0\\n        \\n    if string[0] == \\\"L\\\" and L_s:\\n        cnt += L_s[0]\\n        L_s = L_s[1:]\\n    L_s.sort()\\n    for l in L_s:\\n        if k >= l:\\n            ans += l * 2 + 1\\n            k -= l\\n        else:\\n            ans += k * 2\\n            k = 0\\n            \\n    ans += 2 * min(k, cnt)\\n    print(ans)\\n    \\n    \\n    \\nfor _ in range(int(input())):\\n    main()\", \"import sys\\n\\ninput = sys.stdin.readline\\n\\nfor _ in range(int(input())):\\n    n,k = map(int,input().split())\\n    s = input()\\n    s = [s[i] for i in range(n)]\\n\\n    base = s.count(\\\"W\\\")\\n    if base == 0:\\n        if k:\\n            print(2*k-1)\\n        else:\\n            print(0)\\n    elif base+k>=n:\\n        print(2*n-1)\\n    else:\\n        interval = []\\n        while s and s[-1]==\\\"L\\\":\\n            s.pop()\\n        s = s[::-1]\\n        while s and s[-1]==\\\"L\\\":\\n            s.pop()\\n\\n        while s:\\n            if s[-1]==\\\"W\\\":\\n                while s and s[-1]==\\\"W\\\":\\n                    s.pop()\\n            else:\\n                tmp = 0\\n                while s and s[-1]==\\\"L\\\":\\n                    s.pop()\\n                    tmp += 1\\n                interval.append(tmp)\\n        interval.sort(reverse=True)\\n        K = k\\n        while interval and k:\\n            if k>=interval[-1]:\\n                k -= interval.pop()\\n            else:\\n                break\\n        print(2*(base+K)-1-len(interval))\", \"import sys\\ninput = sys.stdin.readline\\n\\n\\ndef compress(string):\\n    string = string + \\\"#\\\"\\n    n = len(string)\\n    begin, end, cnt = 0, 1, 1\\n    ans = []\\n    while end < n:\\n        if string[begin] == string[end]:\\n            end, cnt = end + 1, cnt + 1\\n        else:\\n            ans.append((string[begin], cnt))\\n            begin, end, cnt = end, end + 1, 1\\n    return ans\\n\\n\\nt = int(input())\\nfor _ in range(t):\\n    n, k = map(int, input().split())\\n    s = input()[:-1]\\n    \\n    s = compress(s)\\n\\n    \\n    w_groups = 0\\n    w_cnt = 0\\n    l_cnt = 0\\n    li = []\\n    for i, (char, cnt) in enumerate(s):\\n        if char == \\\"W\\\":\\n            w_groups += 1\\n            w_cnt += cnt\\n        if char == \\\"L\\\":\\n            l_cnt += cnt\\n            if 1 <= i < len(s) - 1:\\n                li.append(cnt)\\n\\n    if w_cnt == 0:\\n        print(max(min(k, l_cnt) * 2 - 1, 0))\\n        continue\\n        \\n    ans = w_cnt * 2 - w_groups\\n    ans += min(k, l_cnt) * 2\\n\\n    li.sort()\\n    for val in li:\\n        if k >= val:\\n            ans += 1\\n            k -= val\\n    print(ans)\", \"for _ in range(int(input())):\\n    n, k = list(map(int, input().split()))\\n    s = input()\\n    k = min(k, s.count(\\\"L\\\"))\\n    arr = []\\n    cur = 0\\n    sc = 0\\n    se = False\\n    if s[0] == \\\"W\\\":\\n        sc += 1\\n    for e in s:\\n        if e == \\\"L\\\":\\n            cur += 1\\n        else:\\n            if cur > 0 and se:\\n                arr.append(cur)\\n            se = True\\n            cur = 0\\n    for i in range(1, n):\\n        if s[i] == \\\"W\\\":\\n            if s[i-1] == \\\"W\\\":\\n                sc += 2\\n            else:\\n                sc += 1 \\n    arr.sort() \\n    arr.reverse()\\n    #print(arr, sc)\\n    while len(arr) > 0 and arr[-1] <= k:\\n        k -= arr[-1]\\n        sc += arr[-1]*2+1\\n        arr.pop()\\n    #print(k)\\n    sc += k*2\\n    if k > 0 and s.count(\\\"W\\\") == 0:\\n        sc -= 1\\n    print(sc)\\n\", \"from sys import stdin\\n\\nt = int(stdin.readline())\\nfor i in range(t):\\n    n, k = tuple(int(x) for x in stdin.readline().split())\\n    line = 'L' * (k+1) + stdin.readline()[:-1] + 'L' * (k+1)\\n    score = 0\\n    flag = False\\n    for char in line:\\n        if char == 'W':\\n            if flag:\\n                score += 2\\n            else:\\n                score += 1\\n                flag = True\\n        else:\\n            flag = False\\n            \\n    seq = sorted(len(x) for x in line.split('W'))\\n\\n    if len(seq) == 1:\\n        if k == 0:\\n            print(0)\\n        else:\\n            print(2*k-1)\\n        continue\\n    for item in seq:\\n        if item == 0:\\n            continue\\n        if k - item >= 0:\\n            k -= item\\n            score += 2 * (item-1) + 3\\n        elif k > 0:\\n            score += 2 * k\\n            break\\n        else:\\n            break\\n    print(min(score, 2*n-1))\\n    \\n\", \"from sys import stdin\\n\\\"\\\"\\\"\\nn=int(stdin.readline().strip())\\nn,m=map(int,stdin.readline().strip().split())\\ns=list(map(int,stdin.readline().strip().split()))\\ns=stdin.readline().strip()\\n\\\"\\\"\\\"\\nT=int(stdin.readline().strip())\\nfor caso in range(T):\\n    n,k=list(map(int,stdin.readline().strip().split()))\\n    s=list(stdin.readline().strip())\\n    aux=[]\\n    last=-1\\n    for i in range(n):\\n        if i>0 and s[i]=='L' and s[i-1]=='W':\\n            last=i\\n        if i<n-1 and s[i]=='L' and s[i+1]=='W' and last!=-1:\\n            aux.append([i-last,last,i])\\n    aux.sort()\\n    for i in aux:\\n        for j in range(i[1],i[2]+1):\\n            if k>0:\\n                s[j]='W'\\n                k-=1\\n    ini=-1\\n    fin=n\\n    for i in range(n):\\n        if s[i]=='W':\\n            ini=i-1\\n            break\\n    for i in range(n-1,-1,-1):\\n        if s[i]=='W':\\n            fin=i+1\\n            break\\n    for i in range(ini,-1,-1):\\n        if k>0:\\n            s[i]='W'\\n            k-=1\\n    for i in range(fin,n):\\n        if k>0:\\n            s[i]='W'\\n            k-=1\\n    ans=0\\n    if ini==-1 and fin==n:\\n        for i in range(n):\\n            if k>0:\\n                s[i]='W'\\n                k-=1\\n    for i in range(n):\\n        if s[i]=='W':\\n            if i>0 and s[i-1]=='W':\\n                ans+=2\\n            else:\\n                ans+=1\\n    print(ans)\\n            \\n        \\n        \\n\\n\", \"for _ in range(int(input())):\\n    n, k = list(map(int, input().split()))\\n    inp = input().lower()\\n    k = min(k, inp.count('l'))\\n    ans = inp.count('w') + tuple(zip(inp, 'l' + inp)).count('ww') + k * 2\\n    if 'w' in inp:\\n        inp2 = []\\n        cur = -1\\n        for c in inp:\\n            if cur != -1:\\n                if c == 'l':\\n                    cur += 1\\n                else:\\n                    inp2.append(cur)\\n            if c == 'w':\\n                cur = 0\\n        inp2.sort()\\n        for inp2i in inp2:\\n            if inp2i > k:\\n                break\\n            k -= inp2i\\n            ans += 1\\n    else:\\n        ans = max(ans - 1, 0)\\n    print(ans)\\n\", \"import sys\\nreadline = sys.stdin.readline\\n\\nT = int(readline())\\nAns = [None]*T\\n\\nfor qu in range(T):\\n    N, K = list(map(int, readline().split()))\\n    S = [1 if s == 'W' else 0 for s in readline().strip()]\\n    if all(s == 0 for s in S):\\n        Ans[qu] = max(0, 2*K-1)\\n        continue\\n    \\n    ans = 0\\n    ctr = 0\\n    st = []\\n    L = []\\n    res = 0\\n    hh = False\\n    for i in range(N):\\n        s = S[i]\\n        if s == 1:\\n            if i == 0 or S[i-1] == 0:\\n                ans += 1\\n            else:\\n                ans += 2\\n            if ctr:\\n                st.append(ctr)\\n                ctr = 0\\n            hh = True\\n        else:\\n            if hh:    \\n                ctr += 1\\n            else:\\n                res += 1\\n    res += ctr\\n    st.sort()\\n    J = []\\n    for s in st:\\n        J.extend([2]*(s-1) + [3])\\n    J.extend([2]*res)\\n    Ans[qu] = ans + sum(J[:min(len(J), K)])\\nprint('\\\\n'.join(map(str, Ans)))\\n\", \"def solve():\\n    n, k = list(map(int, input().split()))\\n    s = input()\\n    ans = 0\\n    prev = False\\n    c = []\\n    cc = 0\\n    for i in range(n):\\n        if s[i] == 'W':\\n            if cc:\\n                if cc != i:\\n                    c.append(cc)\\n                cc = 0\\n            if prev:\\n                ans += 2\\n            else:\\n                ans += 1\\n            prev = True\\n        else:\\n            prev = False\\n            cc += 1\\n    c.sort()\\n    for i in range(len(c)):\\n        if c[i] <= k:\\n            k -= c[i]\\n            ans += c[i] * 2 + 1\\n    if 'W' in s:\\n        ans += k * 2\\n    else:\\n        ans += max(k * 2 - 1, 0)\\n    ans = min(ans, n * 2 - 1)\\n    print(ans)\\nt = int(input())\\nfor _ in range(t):\\n    solve()\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"8\\n5 2\\nWLWLL\\n6 5\\nLLLWWL\\n7 1\\nLWLWLWL\\n15 5\\nWWWLLLWWWLLLWWW\\n40 7\\nLLWLWLWWWLWLLWLWWWLWLLWLLWLLLLWLLWWWLWWL\\n1 0\\nL\\n1 1\\nL\\n6 1\\nWLLWLW\\n\"\n  ],\n  \"outputs\": [\n    \"7\\n11\\n6\\n26\\n46\\n0\\n1\\n6\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1427/B", "starter_code": ""}
{"id": 9, "question": "Alice and Bob play a game. They have a binary string $s$ (a string such that each character in it is either $0$ or $1$). Alice moves first, then Bob, then Alice again, and so on.\n\nDuring their move, the player can choose any number (not less than one) of consecutive equal characters in $s$ and delete them.\n\nFor example, if the string is $10110$, there are $6$ possible moves (deleted characters are bold):  $\\textbf{1}0110 \\to 0110$;  $1\\textbf{0}110 \\to 1110$;  $10\\textbf{1}10 \\to 1010$;  $101\\textbf{1}0 \\to 1010$;  $10\\textbf{11}0 \\to 100$;  $1011\\textbf{0} \\to 1011$. \n\nAfter the characters are removed, the characters to the left and to the right of the removed block become adjacent. I. e. the following sequence of moves is valid: $10\\textbf{11}0 \\to 1\\textbf{00} \\to 1$.\n\nThe game ends when the string becomes empty, and the score of each player is the number of $1$-characters deleted by them.\n\nEach player wants to maximize their score. Calculate the resulting score of Alice.\n\n\n-----Input-----\n\nThe first line contains one integer $T$ ($1 \\le T \\le 500$) \u2014 the number of test cases.\n\nEach test case contains exactly one line containing a binary string $s$ ($1 \\le |s| \\le 100$).\n\n\n-----Output-----\n\nFor each test case, print one integer \u2014 the resulting score of Alice (the number of $1$-characters deleted by her).\n\n\n-----Example-----\nInput\n5\n01111001\n0000\n111111\n101010101\n011011110111\n\nOutput\n4\n0\n6\n3\n6\n\n\n\n-----Note-----\n\nQuestions about the optimal strategy will be ignored.", "solutions": "[\"for _ in range(int(input())):\\n    s = input()\\n    p = [i for i in s.split(\\\"0\\\") if i!=\\\"\\\"]\\n    p.sort(reverse=True)\\n    ans = 0\\n    for i in range(0,len(p),2):\\n        ans+=len(p[i])\\n    print(ans)\\n\\n\", \"for _ in range(int(input())):\\n    s=[len(i)for i in input().split('0')]\\n    s.sort()\\n    print(sum(s[-1::-2]))\", \"for _ in range(int(input())):\\n    s = input()\\n    t = [i for i in s.split(\\\"0\\\") if i!=\\\"\\\"]\\n    t.sort(reverse=True)\\n    cnt=0\\n    for i in range(0,len(t),2):\\n        cnt+=len(t[i])\\n    print(cnt)\", \"for _ in range(int(input())):\\n    s = input()\\n    ar = []\\n    cur = 0\\n    for c in s:\\n        if c == \\\"1\\\":\\n            cur += 1\\n        else:\\n            ar.append(cur)\\n            cur = 0\\n    if cur != 0:\\n        ar.append(cur)\\n    ar.sort()\\n    ar.reverse()\\n    print(sum(ar[::2]))\\n\", \"for nt in range(int(input())):\\n\\ts = input()\\n\\tn = len(s)\\n\\tif s[0]==\\\"1\\\":\\n\\t\\tcount = 1\\n\\telse:\\n\\t\\tcount = 0\\n\\tgroups = []\\n\\tfor i in range(1,n):\\n\\t\\tif s[i]==\\\"1\\\":\\n\\t\\t\\tcount += 1\\n\\t\\telse:\\n\\t\\t\\tif count:\\n\\t\\t\\t\\tgroups.append(count)\\n\\t\\t\\tcount = 0\\n\\tif count:\\n\\t\\tgroups.append(count)\\n\\tgroups.sort(reverse=True)\\n\\tans = 0\\n\\tfor i in range(0,len(groups),2):\\n\\t\\tans += groups[i]\\n\\tprint (ans)\\n\", \"def solv():\\n\\ts=list(map(int,input()))\\n\\tv=[]\\n\\tsm=0\\n\\tfor n in s:\\n\\t\\tif n:\\n\\t\\t\\tsm+=1\\n\\t\\telse:\\n\\t\\t\\tv.append(sm)\\n\\t\\t\\tsm=0\\n\\tif sm:v.append(sm)\\n\\tv.sort(reverse=True)\\n\\n\\tres=0\\n\\n\\tfor n in range(0,len(v),2):res+=v[n]\\n\\tprint(res)\\n\\nfor _ in range(int(input())):solv()\", \"import math\\nt=int(input())\\nfor w in range(t):\\n    s=sorted(input().split('0'),reverse=True)\\n    c=0\\n    for i in range(0,len(s),2):\\n        c+=len(s[i])\\n    print(c)\", \"from itertools import groupby\\n\\nt = int(input())\\n\\nfor _ in range(t):\\n    s = input()\\n    l = []\\n    for k, v in groupby(s):\\n        if k == '1':\\n            l.append(len(list(v)))\\n    l.sort(reverse=True)\\n    n = len(l)\\n    res = 0\\n    for i in range(0, n, 2):\\n        res += l[i]\\n    print(res)\\n\", \"for _ in range(int(input())):\\n    s = input()\\n    x = sorted(len(i) for i in s.split('0') if len(i) > 0)\\n\\n    print(max(sum(x[::2]), sum(x[1::2])))\", \"from sys import stdin,stdout\\nfrom math import sqrt,gcd,ceil,floor,log2,log10,factorial,cos,acos,tan,atan,atan2,sin,asin,radians,degrees,hypot\\nfrom bisect import insort, insort_left, insort_right, bisect_left, bisect_right, bisect\\nfrom array import array\\nfrom functools import reduce\\nfrom itertools import combinations, combinations_with_replacement, permutations\\nfrom fractions import Fraction\\nfrom random import choice,getrandbits,randint,random,randrange,shuffle\\nfrom re import compile,findall,escape\\nfrom statistics import mean,median,mode\\nfrom heapq import heapify,heappop,heappush,heappushpop,heapreplace,merge,nlargest,nsmallest\\n\\nfor test in range(int(stdin.readline())):\\n    s=input()\\n    l=findall(r'1+',s)\\n    lengths=[len(i) for i in l]\\n    lengths.sort(reverse=True)\\n    alice=0\\n    for i in range(0,len(lengths),2):\\n        alice+=lengths[i]\\n    print(alice)\", \"import sys\\ninput = sys.stdin.readline\\nT = int(input())\\n\\nfor t in range(T):\\n    s = input()[:-1]\\n\\n    counts = []\\n    current = 0\\n    for c in s:\\n        if c == '1':\\n            current += 1\\n        else:\\n            counts.append(current)\\n            current = 0\\n    if current:\\n        counts.append(current)\\n\\n    res = 0\\n    counts = sorted(counts, reverse=True)\\n    for i in range(len(counts)):\\n        if 2*i >= len(counts):\\n            break\\n        res += counts[2*i]\\n    print(res)\\n\", \"import sys\\nimport math\\ndef II():\\n\\treturn int(sys.stdin.readline())\\n\\ndef LI():\\n\\treturn list(map(int, sys.stdin.readline().split()))\\n\\ndef MI():\\n\\treturn map(int, sys.stdin.readline().split())\\n\\ndef SI():\\n\\treturn sys.stdin.readline().strip()\\nt = II()\\nfor q in range(t):\\n\\ts = SI()\\n\\ta = []\\n\\tcount = 0\\n\\tfor i in range(len(s)):\\n\\t\\tif s[i] == \\\"1\\\":\\n\\t\\t\\tcount+=1\\n\\t\\telse:\\n\\t\\t\\ta.append(count)\\n\\t\\t\\tcount = 0\\n\\ta.append(count)\\n\\ta.sort(reverse=True)\\n\\tprint(sum(a[0:len(a):2]))\", \"from math import *\\nfrom collections import *\\nfrom random import *\\nfrom decimal import Decimal\\nfrom heapq import *\\nfrom bisect import *\\nimport sys\\ninput=sys.stdin.readline\\nsys.setrecursionlimit(10**5)\\ndef lis():\\n    return list(map(int,input().split()))\\ndef ma():\\n    return list(map(int,input().split()))\\ndef inp():\\n    return int(input())\\ndef st1():\\n    return input().rstrip('\\\\n')\\nt=inp()\\nwhile(t):\\n    t-=1\\n    #n=inp()\\n    a=st1()\\n    oe=[]\\n    c=0\\n    for i in a:\\n        if(i=='1'):\\n            c+=1\\n        else:\\n            if(c!=0):\\n                oe.append(c)\\n                c=0\\n    if(c):\\n        oe.append(c)\\n    s=0\\n    oe.sort(reverse=True)\\n    for i in range(len(oe)):\\n        if(i%2==0):\\n            s+=oe[i]\\n    print(s)\\n        \\n\", \"for _ in range(int(input())):\\n    s = input() + '0'\\n    A = []\\n    tr = False\\n    x = 0\\n    for i in range(len(s)):\\n        if s[i] == '1':\\n            if tr:\\n                x += 1\\n            else:\\n                tr = True\\n                x = 1\\n        else:\\n            if tr:\\n                tr = False\\n                A.append(x)\\n    A.sort(reverse=True)\\n    Ans = 0\\n    for i in range(len(A)):\\n        if i % 2 == 0:\\n            Ans += A[i]\\n    print(Ans)\", \"t = int(input())\\nwhile t:\\n    s = input()\\n    arr = []\\n    k = 0\\n    for i in s:\\n        if i == '1':\\n            k += 1\\n        else:\\n            arr.append(k)\\n            k = 0\\n    if k:\\n        arr.append(k)\\n    arr.sort(reverse=True)\\n    ans = 0\\n    for i in range(0, len(arr), 2):\\n        ans += arr[i]\\n    print(ans)\\n    t -= 1\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nt = int(input())\\nfor _ in range(t):\\n    x = input().rstrip()\\n    \\n    arr = []\\n    \\n    c = 0\\n    for char in x:\\n        if char=='1':\\n            c+=1\\n        else:\\n            arr.append(c)\\n            c = 0\\n            \\n    arr.append(c)\\n    arr.sort()\\n    arr.reverse()\\n    \\n    ans = 0\\n    for i in range(0,len(arr),2):\\n        ans += arr[i]\\n        \\n    print(ans)\", \"import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\nfor tests in range(t):\\n    S=input().strip()+\\\"0\\\"\\n\\n    L=[]\\n\\n    NOW=0\\n    for s in S:\\n        if s==\\\"0\\\":\\n            L.append(NOW)\\n            NOW=0\\n        else:\\n            NOW+=1\\n\\n    L.sort(reverse=True)\\n\\n    ANS=0\\n\\n    for i in range(0,len(L),2):\\n        ANS+=L[i]\\n\\n    print(ANS)\\n        \\n\", \"for _ in range (int(input())):\\n    s=input()\\n    a = []\\n    flag = 0\\n    count = 0\\n    for i in range (len(s)):\\n        if s[i]=='1':\\n            count+=1\\n        else:\\n            a.append(count)\\n            count=0\\n        if i==len(s)-1 and count!=0:\\n            a.append(count)\\n    a.sort(reverse=True)\\n    ans = 0\\n    for i in range(len(a)):\\n        if i%2==0:\\n            ans+=a[i]\\n    print(ans)\", \"for t in range(int(input())):\\n\\ts = input()\\n\\tlast = -1\\n\\tnum = []\\n\\tn = len(s)\\n\\tfor i in range(n):\\n\\t\\tif (s[i] == \\\"0\\\"):\\n\\t\\t\\tif (i - last - 1 > 0):\\n\\t\\t\\t\\tnum.append(i - last - 1)\\n\\t\\t\\tlast = i\\n\\tif (n - last - 1 > 0):\\n\\t\\tnum.append(n - last - 1)\\n\\tnum = sorted(num)[::-1]\\n\\tans = 0\\n\\tfor i in range(0, len(num), 2):\\n\\t\\tans += num[i]\\n\\tprint(ans)\", \"for test in range(int(input())):\\n    s = input()\\n    a = []\\n    now = 0\\n    n = len(s)\\n    for i in range(n):\\n        if s[i] == \\\"0\\\":\\n            if now > 0:\\n                a.append(now)\\n            now = 0\\n        else:\\n            now += 1\\n    if now > 0:\\n        a.append(now)\\n    a.sort(reverse=True)\\n    ans = 0\\n    for i in range(0, len(a), 2):\\n        ans += a[i]\\n    print(ans)\", \"for _ in range(int(input())):\\n    s = input()\\n\\n    ones = []\\n    cnt = 0\\n    for i in s:\\n        if i == '1':\\n            cnt += 1\\n        else:\\n            if cnt != 0:\\n                ones.append(cnt)\\n                cnt = 0\\n    if cnt != 0:\\n        ones.append(cnt)\\n\\n    ones.sort(reverse=True)\\n    print(sum(ones[::2]))\\n\", \"from collections import defaultdict as dd\\nimport math\\nimport sys\\ninput=sys.stdin.readline\\ndef nn():\\n\\treturn int(input())\\n\\ndef li():\\n\\treturn list(input())\\n\\ndef mi():\\n\\treturn list(map(int, input().split()))\\n\\ndef lm():\\n\\treturn list(map(int, input().split()))\\n\\ndef solve():\\n\\ts = input()\\n\\n\\tsets = []\\n\\tstreak = 0\\n\\tfor i in range(len(s)):\\n\\t\\tif s[i]=='1':\\n\\t\\t\\tstreak+=1\\n\\t\\telse:\\n\\t\\t\\tif streak>0:\\n\\t\\t\\t\\tsets.append(streak)\\n\\t\\t\\t\\tstreak=0\\n\\tif streak>0:\\n\\t\\tsets.append(streak)\\n\\t\\tstreak=0\\n\\n\\tsets.sort(reverse=True)\\n\\n\\tprint(sum(sets[::2]))\\n\\n\\nq=nn()\\nfor _ in range(q):\\n\\tsolve()\\n\", \"t = int(input())\\n\\nfor _ in range(t):\\n    s = [int(i) for i in input().strip()]\\n    n = len(s)\\n    bckt = []\\n    ct = 0\\n    \\n    for i in range(n):\\n        if s[i]:\\n            ct += 1\\n        else:\\n            if ct:\\n                bckt.append(ct)\\n                ct = 0\\n    \\n    if ct:\\n        bckt.append(ct)\\n        \\n    bckt.sort(reverse=True)\\n    print(sum(bckt[::2]))\", \"for i in range(int(input())):\\n\\tip=list(map(int,input()))\\n\\tones=[]\\n\\ttot=0\\n\\tfor i in ip:\\n\\t\\tif i==1:\\n\\t\\t\\ttot+=1\\n\\t\\telse:\\n\\t\\t\\tones.append(tot)\\n\\t\\t\\ttot=0\\n\\tif tot:ones.append(tot)\\n\\tones.sort(reverse=True)\\n\\tans=0\\n\\tfor i in range(0,len(ones),2):\\n\\t\\tans+=ones[i]\\n\\tprint(ans)\", \"#BINOD\\nimport math\\ntest = int(input())\\nfor t in range(test):\\n    s = input()\\n    n = len(s)\\n    A = []\\n    o=0\\n    for i in range(n):\\n        if(s[i]=='1'):\\n            o+=1\\n        else:\\n            A.append(o)\\n            o=0\\n    if(s[n-1]=='1'):\\n        A.append(o)\\n    A.sort(reverse = True)\\n    ans = 0\\n    for i in range(0,len(A),2):\\n        ans += A[i]\\n    print(ans)\\n\\n\\n\\n\\n#Binod\\n\", \"for _ in range(int(input())):\\n    data = list(map(int,list(input())))\\n    fl = False\\n    data.append(\\\"&\\\")\\n    l = 0\\n    st = []\\n    for i in range(len(data)):\\n        if fl and data[i] == 1:\\n            l+=1\\n            continue\\n        if fl and data[i]!=1:\\n            st.append(l)\\n            l = 0\\n            fl = False\\n            continue\\n        if not fl and data[i] == 1:\\n            l = 1\\n            fl = True\\n    st.sort(reverse=True)\\n    c1 = 0\\n    for i in range(0,len(st),2):\\n        c1+=st[i]\\n    print(c1)\", \"import math\\nfrom collections import deque\\nfrom sys import stdin, stdout\\nfrom string import ascii_letters\\ninput = stdin.readline\\n#print = stdout.write\\nletters = ascii_letters[:26]\\n \\nfor _ in range(int(input())):\\n    arr = list(map(int, input().strip()))\\n    lens = []\\n    count = 0\\n    for i in arr:\\n        if i == 0:\\n            if count > 0:\\n                lens.append(count)\\n            count = 0\\n        else:\\n            count += 1\\n    if count > 0:\\n        lens.append(count)\\n    lens.sort(reverse=True)\\n    res = 0\\n    for i in range(0, len(lens), 2):\\n        res += lens[i]\\n    print(res)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"5\\n01111001\\n0000\\n111111\\n101010101\\n011011110111\\n\"\n  ],\n  \"outputs\": [\n    \"4\\n0\\n6\\n3\\n6\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1398/B", "starter_code": ""}
{"id": 10, "question": "Given a permutation $p$ of length $n$, find its subsequence $s_1$, $s_2$, $\\ldots$, $s_k$ of length at least $2$ such that:  $|s_1-s_2|+|s_2-s_3|+\\ldots+|s_{k-1}-s_k|$ is as big as possible over all subsequences of $p$ with length at least $2$.  Among all such subsequences, choose the one whose length, $k$, is as small as possible. \n\nIf multiple subsequences satisfy these conditions, you are allowed to find any of them.\n\nA sequence $a$ is a subsequence of an array $b$ if $a$ can be obtained from $b$ by deleting some (possibly, zero or all) elements.\n\nA permutation of length $n$ is an array of length $n$ in which every element from $1$ to $n$ occurs exactly once.\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 2 \\cdot 10^4$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains an integer $n$ ($2 \\le n \\le 10^5$)\u00a0\u2014 the length of the permutation $p$.\n\nThe second line of each test case contains $n$ integers $p_1$, $p_2$, $\\ldots$, $p_{n}$ ($1 \\le p_i \\le n$, $p_i$ are distinct)\u00a0\u2014 the elements of the permutation $p$.\n\nThe sum of $n$ across the test cases doesn't exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, the first line should contain the length of the found subsequence, $k$. The second line should contain $s_1$, $s_2$, $\\ldots$, $s_k$\u00a0\u2014 its elements.\n\nIf multiple subsequences satisfy these conditions, you are allowed to find any of them.\n\n\n-----Example-----\nInput\n2\n3\n3 2 1\n4\n1 3 4 2\n\nOutput\n2\n3 1 \n3\n1 4 2 \n\n\n\n-----Note-----\n\nIn the first test case, there are $4$ subsequences of length at least $2$:  $[3,2]$ which gives us $|3-2|=1$.  $[3,1]$ which gives us $|3-1|=2$.  $[2,1]$ which gives us $|2-1|=1$.  $[3,2,1]$ which gives us $|3-2|+|2-1|=2$. \n\nSo the answer is either $[3,1]$ or $[3,2,1]$. Since we want the subsequence to be as short as possible, the answer is $[3,1]$.", "solutions": "[\"for _ in range(int(input())):\\n    # n, x = map(int, input().split())\\n    n = int(input())\\n    arr = list(map(int, input().split()))\\n    ans = [arr[0]]\\n    for i in range(1, n - 1):\\n        if arr[i - 1] < arr[i] and arr[i] > arr[i + 1]:\\n            ans.append(arr[i])\\n        elif arr[i - 1] > arr[i] and arr[i] < arr[i + 1]:\\n            ans.append(arr[i])\\n    ans.append(arr[-1])\\n    print(len(ans))\\n    print(*ans)\", \"\\nt = int(input())\\n\\nfor loop in range(t):\\n\\n    n = int(input())\\n    p = list(map(int,input().split()))\\n    a = p\\n\\n    ans = []\\n    \\n\\n    for i in range(n):\\n\\n        if i == 0 or i == n-1:\\n            ans.append(p[i])\\n\\n        elif a[i-1] <= a[i] <= a[i+1]:\\n            continue\\n        elif a[i-1] >= a[i] >= a[i+1]:\\n            continue\\n        else:\\n            ans.append(p[i])\\n\\n    print(len(ans))\\n    print(*ans)\\n\", \"for t in range(int(input())):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    b = [a[0]] + [a[i] for i in range(1, n - 1) if not(a[i - 1] < a[i] < a[i + 1] or \\n                                                   a[i - 1] > a[i] > a[i + 1])] + [a[-1]]\\n    print(len(b))\\n    print(*b)\", \"for _ in range(int(input())):\\n    n = int(input())\\n    p = list(map(int, input().split()))\\n    ans = [str(p[0])]\\n    for i in range(1,n-1):\\n        if p[i-1] < p[i] < p[i+1]:\\n            continue\\n        if p[i-1] > p[i] > p[i+1]:\\n            continue\\n        ans.append(str(p[i]))\\n    ans.append(str(p[-1]))\\n    print(len(ans))\\n    print(\\\" \\\".join(ans))\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    p = tuple(map(int, input().split()))\\n    ans = [p[i] for i in range(n) if i in (0, n - 1) or p[i] != sorted(p[i - 1:i + 2])[1]]\\n    print(len(ans))\\n    print(*ans)\\n\", \"t = int(input())\\nfor test in range(t):\\n    n = int(input())\\n    l = list(map(int, input().rstrip().split()))\\n    i = 0\\n    arr = list()\\n    arr.append(str(l[0]))\\n    while i+1 < n:\\n        if i+1 == n-1 or (l[i] < l[i+1] and l[i+1] > l[i+2]) or (l[i] > l[i+1] and l[i+1] < l[i+2]):\\n            arr.append(str(l[i+1]))\\n        i += 1\\n    print(len(arr))\\n    print(\\\" \\\".join(arr))\", \"from collections import *\\nfrom sys import stdin,stderr\\ndef rl():\\n    return [int(w) for w in stdin.readline().split()]\\n\\nt, = rl()\\nfor _ in range(t):\\n    n, = rl()\\n    p = rl()\\n    s = [p[0]]\\n    for i in range(1, n-1):\\n        if p[i-1] < p[i] > p[i+1] or p[i-1] > p[i] < p[i+1]:\\n            s.append(p[i])\\n    s.append(p[-1])\\n    print(len(s))\\n    print(*s)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nfor nt in range(int(input())):\\n\\tn = int(input())\\n\\ta = list(map(int,input().split()))\\n\\tif n==2:\\n\\t\\tprint (2)\\n\\t\\tprint (*a)\\n\\t\\tcontinue\\n\\tans = [a[0]]\\n\\tif a[1]>a[0]:\\n\\t\\tturn = 1\\n\\telse:\\n\\t\\tturn = 0\\n\\ts = abs(a[1]-a[0])\\n\\tfor i in range(2,n):\\n\\t\\tif turn:\\n\\t\\t\\tif a[i]>a[i-1]:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tans.append(a[i-1])\\n\\t\\t\\tturn = 0\\n\\t\\telse:\\n\\t\\t\\tif a[i]<a[i-1]:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tans.append(a[i-1])\\n\\t\\t\\tturn = 1\\n\\tans.append(a[-1])\\n\\tprint (len(ans))\\n\\tprint (*ans)\", \"from collections import defaultdict as dd\\nimport math\\nimport sys\\ninput=sys.stdin.readline\\ndef nn():\\n\\treturn int(input())\\n\\ndef li():\\n\\treturn list(input())\\n\\ndef mi():\\n\\treturn list(map(int, input().split()))\\n\\ndef lm():\\n\\treturn list(map(int, input().split()))\\n\\n\\n\\nq=nn()\\n\\nfor _ in range(q):\\n\\tn = nn()\\n\\n\\tper = lm()\\n\\n\\tbest =[per[0]]\\n\\n\\tfor i in range(len(per)-2):\\n\\t\\tminper = min(per[i], per[i+1], per[i+2])\\n\\t\\tmaxper = max(per[i], per[i+1], per[i+2])\\n\\t\\tif minper==per[i+1] or maxper==per[i+1]:\\n\\t\\t\\tbest.append(per[i+1])\\n\\tbest.append(per[-1])\\n\\tprint(len(best))\\n\\tprint(*best)\\n\", \"import sys\\n\\ndef ii():\\n    return sys.stdin.readline().strip()\\n\\ndef idata():\\n    return [int(x) for x in ii().split()]\\n\\ndef solve_of_problem():\\n    n = int(ii())\\n    data = idata()\\n    ans = [data[0]]\\n    for i in range(1, n - 1):\\n        if data[i - 1] < data[i] > data[i + 1] or data[i - 1] > data[i] < data[i + 1]:\\n            ans += [data[i]]\\n    print(len(ans) + 1)\\n    print(*ans, data[-1])\\n    return\\n\\nfor ______ in range(int(ii())):\\n    solve_of_problem()\", \"def main():\\n    n = int(input())\\n    lst = list(map(int, input().split()))\\n    take = [lst[0]]\\n    sign = 0\\n    for i in range(1, n):\\n        if i == n - 1:\\n            take.append(lst[i])\\n        else:\\n            if lst[i] > take[-1]:\\n                if lst[i + 1] < lst[i]:\\n                    take.append(lst[i])\\n            elif lst[i] < take[-1]:\\n                if lst[i + 1] > lst[i]:\\n                    take.append(lst[i])\\n    line = str(len(take)) + '\\\\n'\\n    for i in take:\\n        line += str(i) + ' '\\n    print(line)\\n\\ndef __starting_point():\\n    t = int(input())\\n    for i in range(t):\\n        main()\\n\\n__starting_point()\", \"import sys\\ninput = sys.stdin.readline\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    p = list(map(int, input().split()))\\n    ans = [p[0]]\\n    for i in range(n-2):\\n        if (p[i]-p[i+1])*(p[i+1]-p[i+2])<0:\\n            ans.append(p[i+1])\\n    ans.append(p[-1])\\n    print(len(ans))\\n    print(*ans)\", \"T = int(input())\\n\\nfor t in range(T):\\n    N = int(input())\\n\\n    P = [int(_) for _ in input().split()]\\n    up = P[1] > P[0]\\n    res = [P[0]]\\n\\n    for i in range(1, N-1):\\n        if up and P[i+1] < P[i]:\\n            res.append(P[i])\\n            up = False\\n        elif not up and P[i+1] > P[i]:\\n            res.append(P[i])\\n            up = True\\n\\n    if P[N-1] != P[N-2]:\\n        res.append(P[N-1])\\n\\n    print(len(res))\\n    print(' '.join(map(str, res)))\\n\", \"def f(n,l):\\n    output = [l[0]]\\n    for i in range(1,n-1):\\n        if (l[i]-l[i-1])*(l[i+1]-l[i]) < 0:\\n            output.append(l[i])\\n    output.append(l[-1])\\n    return str(len(output))+'\\\\n'+' '.join([str(x) for x in output])\\n\\nnumberofcases = int(input())\\nfor _ in range(numberofcases):\\n    n = int(input())\\n    l = [int(t) for t in input().split()]\\n    print(f(n,l))\", \"def help():\\n\\tn = int(input())\\n\\tarr = list(map(int,input().split(\\\" \\\")))\\n\\n\\tpeak = [False]*n\\n\\tdown = [False]*n\\n\\tfor i in range(n):\\n\\t\\tif(i==0):\\n\\t\\t\\tif(arr[0]<arr[1]):\\n\\t\\t\\t\\tdown[0]=True\\n\\t\\t\\tif(arr[0]>arr[1]):\\n\\t\\t\\t\\tpeak[i]=True\\n\\t\\telif(i==n-1):\\n\\t\\t\\tif(arr[n-1]<arr[n-2]):\\n\\t\\t\\t\\tdown[i]=True\\n\\t\\t\\tif(arr[n-1]>arr[n-2]):\\n\\t\\t\\t\\tpeak[i]=True\\n\\t\\telse:\\n\\t\\t\\tif(arr[i-1]<arr[i] and arr[i]>arr[i+1]):\\n\\t\\t\\t\\tpeak[i]=True\\n\\t\\t\\telif(arr[i-1]>arr[i] and arr[i]<arr[i+1]):\\n\\t\\t\\t\\tdown[i]=True\\n\\tseries = []\\n\\tfor i in range(n):\\n\\t\\tif(peak[i]==True or down[i]==True):\\n\\t\\t\\tseries.append(i)\\n\\tans = 0\\n\\tfor i in range(len(series)-1):\\n\\t\\tans += abs(series[i]-series[i+1])\\n\\tprint(len(series))\\n\\tfor i in range(len(series)):\\n\\t\\tprint(arr[series[i]],end=\\\" \\\")\\n\\tprint()\\n\\nfor _ in range(int(input())):\\n\\thelp()\\n\", \"import sys\\n\\nT = int(sys.stdin.readline().strip())\\nfor t in range (0, T):\\n    n = int(sys.stdin.readline().strip())\\n    p = list(map(int, sys.stdin.readline().strip().split()))\\n    ans = [p[0]]\\n    for i in range(1, n):\\n        if p[i] != ans[-1]:\\n            if len(ans) == 1:\\n                ans.append(p[i])\\n            else:\\n                if (ans[-2] - ans[-1]) * (ans[-1] - p[i]) > 0:\\n                    ans.pop()\\n                ans.append(p[i])\\n    print(len(ans))\\n    print(\\\" \\\".join(list(map(str, ans))))\\n\\n    \\n    \\n\"]", "input_output": "{\n  \"inputs\": [\n    \"2\\n3\\n3 2 1\\n4\\n1 3 4 2\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n3 1 \\n3\\n1 4 2 \\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1364/B", "starter_code": ""}
{"id": 11, "question": "You have a string $s$ \u2014 a sequence of commands for your toy robot. The robot is placed in some cell of a rectangular grid. He can perform four commands:  'W' \u2014 move one cell up;  'S' \u2014 move one cell down;  'A' \u2014 move one cell left;  'D' \u2014 move one cell right. \n\nLet $Grid(s)$ be the grid of minimum possible area such that there is a position in the grid where you can place the robot in such a way that it will not fall from the grid while running the sequence of commands $s$. For example, if $s = \\text{DSAWWAW}$ then $Grid(s)$ is the $4 \\times 3$ grid:  you can place the robot in the cell $(3, 2)$;  the robot performs the command 'D' and moves to $(3, 3)$;  the robot performs the command 'S' and moves to $(4, 3)$;  the robot performs the command 'A' and moves to $(4, 2)$;  the robot performs the command 'W' and moves to $(3, 2)$;  the robot performs the command 'W' and moves to $(2, 2)$;  the robot performs the command 'A' and moves to $(2, 1)$;  the robot performs the command 'W' and moves to $(1, 1)$.  [Image] \n\nYou have $4$ extra letters: one 'W', one 'A', one 'S', one 'D'. You'd like to insert at most one of these letters in any position of sequence $s$ to minimize the area of $Grid(s)$.\n\nWhat is the minimum area of $Grid(s)$ you can achieve?\n\n\n-----Input-----\n\nThe first line contains one integer $T$ ($1 \\le T \\le 1000$) \u2014 the number of queries.\n\nNext $T$ lines contain queries: one per line. This line contains single string $s$ ($1 \\le |s| \\le 2 \\cdot 10^5$, $s_i \\in \\{\\text{W}, \\text{A}, \\text{S}, \\text{D}\\}$) \u2014 the sequence of commands.\n\nIt's guaranteed that the total length of $s$ over all queries doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nPrint $T$ integers: one per query. For each query print the minimum area of $Grid(s)$ you can achieve.\n\n\n-----Example-----\nInput\n3\nDSAWWAW\nD\nWA\n\nOutput\n8\n2\n4\n\n\n\n-----Note-----\n\nIn the first query you have to get string $\\text{DSAWW}\\underline{D}\\text{AW}$.\n\nIn second and third queries you can not decrease the area of $Grid(s)$.", "solutions": "[\"n = int(input())\\n\\ndef area(width, height) :\\n    return (width+1) * (height+1)\\n\\ndef calcul(s1, c, s2) :\\n    maxx, maxy, minx, miny = 0, 0, 0, 0\\n    x, y = 0, 0\\n    for k in range(len(s1)) :\\n        if s1[k] == \\\"W\\\" :\\n            y += 1\\n        if s1[k] == \\\"S\\\" :\\n            y -= 1\\n        if s1[k] == \\\"A\\\" :\\n            x -= 1\\n        if s1[k] == \\\"D\\\" :\\n            x += 1\\n        maxx = max(maxx, x)\\n        minx = min(minx, x)\\n\\n        maxy = max(maxy, y)\\n        miny = min(miny, y)\\n\\n\\n\\n\\n    if c == \\\"W\\\" :\\n        y += 1\\n    elif c == \\\"S\\\" :\\n        y -= 1\\n    elif c == \\\"A\\\" :\\n        x -= 1\\n    elif c == \\\"D\\\" :\\n        x += 1\\n    else :\\n        print(c, \\\"ok\\\")\\n\\n    maxx = max(maxx, x)\\n    minx = min(minx, x)\\n\\n    maxy = max(maxy, y)\\n    miny = min(miny, y)\\n\\n    for k in range(len(s2)) :\\n        if s2[k] == \\\"W\\\" :\\n            y += 1\\n        if s2[k] == \\\"S\\\" :\\n            y -= 1\\n        if s2[k] == \\\"A\\\" :\\n            x -= 1\\n        if s2[k] == \\\"D\\\" :\\n            x += 1\\n        maxx = max(maxx, x)\\n        minx = min(minx, x)\\n\\n        maxy = max(maxy, y)\\n        miny = min(miny, y)\\n\\n\\n\\n    diffx = maxx - minx\\n    diffy = maxy - miny\\n    tmp = area(diffx, diffy)\\n\\n\\n    return tmp\\n\\ndef pre_calcul(s, moment, pre_avant, date_debut) :\\n    x, y, maxx, minx, maxy, miny = pre_avant\\n    for k in range(date_debut, moment) :\\n        if s[k] == \\\"W\\\" :\\n            y += 1\\n        if s[k] == \\\"S\\\" :\\n            y -= 1\\n        if s[k] == \\\"A\\\" :\\n            x -= 1\\n        if s[k] == \\\"D\\\" :\\n            x += 1\\n        maxx = max(maxx, x)\\n        minx = min(minx, x)\\n\\n        maxy = max(maxy, y)\\n        miny = min(miny, y)\\n\\n    return (x, y, maxx, minx, maxy, miny)\\n\\ndef calcul2(s, c, moment, precalcul) :\\n    x, y, maxx, minx, maxy, miny = precalcul\\n\\n\\n\\n    if c == \\\"W\\\" :\\n        y += 1\\n    elif c == \\\"S\\\" :\\n        y -= 1\\n    elif c == \\\"A\\\" :\\n        x -= 1\\n    elif c == \\\"D\\\" :\\n        x += 1\\n    else :\\n        print(c, \\\"ok\\\")\\n\\n    maxx = max(maxx, x)\\n    minx = min(minx, x)\\n\\n    maxy = max(maxy, y)\\n    miny = min(miny, y)\\n\\n    for k in range(moment, len(s)) :\\n        if s[k] == \\\"W\\\" :\\n            y += 1\\n        if s[k] == \\\"S\\\" :\\n            y -= 1\\n        if s[k] == \\\"A\\\" :\\n            x -= 1\\n        if s[k] == \\\"D\\\" :\\n            x += 1\\n        maxx = max(maxx, x)\\n        minx = min(minx, x)\\n\\n        maxy = max(maxy, y)\\n        miny = min(miny, y)\\n\\n\\n\\n    diffx = maxx - minx\\n    diffy = maxy - miny\\n    tmp = area(diffx, diffy)\\n\\n\\n    return tmp\\n\\nfor _ in range(n) :\\n    s = input()\\n    maxx, maxy, minx, miny = 0, 0, 0, 0\\n    x, y = 0, 0\\n    momentminx, momentmaxx, momentminy, momentmaxy = -1, -1, -1, -1\\n    for k in range(len(s)) :\\n        if s[k] == \\\"W\\\" :\\n            y += 1\\n        if s[k] == \\\"S\\\" :\\n            y -= 1\\n        if s[k] == \\\"A\\\" :\\n            x -= 1\\n        if s[k] == \\\"D\\\" :\\n            x += 1\\n\\n        if x > maxx :\\n            momentmaxx = k\\n        if y > maxy :\\n            momentmaxy = k\\n        if x < minx :\\n            momentminx = k\\n        if y < miny :\\n            momentminy = k\\n        maxx = max(maxx, x)\\n        minx = min(minx, x)\\n\\n        maxy = max(maxy, y)\\n        miny = min(miny, y)\\n    diffx = maxx - minx\\n    diffy = maxy - miny\\n\\n\\n    tmp = 999999999999999999999999999999999999\\n    l = [momentmaxx, momentmaxy, momentminx, momentminy]\\n    l = list(set(l))\\n    l = [i for i in l if i != -1]\\n    l.sort()\\n    if l != [] :\\n        precalcul = pre_calcul(s, l[0], (0, 0, 0, 0, 0, 0), 0)\\n        avant = l[0]\\n        for moment in l :\\n            precalcul = pre_calcul(s, moment, precalcul, avant)\\n            avant = moment\\n            tmp = min(tmp, calcul2(s, 'W', moment, precalcul))\\n            tmp = min(tmp, calcul2(s, 'S', moment, precalcul))\\n            tmp = min(tmp, calcul2(s, 'A', moment, precalcul))\\n            tmp = min(tmp, calcul2(s, 'D', moment, precalcul))\\n    print(tmp)\\n\", \"import sys\\ninput = sys.stdin.readline\\n    \\nQ=int(input())\\n\\nfor testcases in range(Q):\\n    S=input().strip()\\n\\n    X=Y=0\\n    MAXX=MINX=MAXY=MINY=0\\n\\n    for s in S:\\n        if s==\\\"D\\\":\\n            X+=1\\n            MAXX=max(MAXX,X)\\n\\n        elif s==\\\"A\\\":\\n            X-=1\\n            MINX=min(MINX,X)\\n\\n        elif s==\\\"W\\\":\\n            Y+=1\\n            MAXY=max(MAXY,Y)\\n\\n        else:\\n            Y-=1\\n            MINY=min(MINY,Y)\\n\\n    #print(MAXX,MINX,MAXY,MINY)\\n\\n    MAXXLIST=[]\\n    MINXLIST=[]\\n    MAXYLIST=[]\\n    MINYLIST=[]\\n\\n    if MAXX==0:\\n        MAXXLIST.append(0)\\n\\n    if MAXY==0:\\n        MAXYLIST.append(0)\\n\\n    if MINX==0:\\n        MINXLIST.append(0)\\n\\n    if MINY==0:\\n        MINYLIST.append(0)\\n\\n    X=Y=0\\n        \\n\\n    for i in range(len(S)):\\n        s=S[i]\\n        if s==\\\"D\\\":\\n            X+=1\\n            if X==MAXX:\\n                MAXXLIST.append(i+1)\\n                \\n        elif s==\\\"A\\\":\\n            X-=1\\n            if X==MINX:\\n                MINXLIST.append(i+1)\\n\\n        elif s==\\\"W\\\":\\n            Y+=1\\n            if Y==MAXY:\\n                MAXYLIST.append(i+1)\\n\\n        else:\\n            Y-=1\\n            if Y==MINY:\\n                MINYLIST.append(i+1)\\n\\n    #print(MAXXLIST)\\n    #print(MAXYLIST)\\n    #print(MINXLIST)\\n    #print(MINYLIST)\\n\\n    ANS=(MAXX-MINX+1)*(MAXY-MINY+1)\\n\\n    #print(ANS)\\n\\n\\n    if MAXX-MINX>1:\\n        if MAXXLIST[0]>MINXLIST[-1] or MINXLIST[0]>MAXXLIST[-1]:\\n            ANS=min(ANS,(MAXX-MINX)*(MAXY-MINY+1))\\n\\n    if MAXY-MINY>1:\\n        if MAXYLIST[0]>MINYLIST[-1] or MINYLIST[0]>MAXYLIST[-1]:\\n            ANS=min(ANS,(MAXX-MINX+1)*(MAXY-MINY))\\n\\n    print(ANS)\\n        \\n\", \"T = int(input())\\n\\nfor _ in range(T):\\n\\ts = input()\\n\\n\\tcleft=cup=cdown=cright=0\\n\\tleft=up=down=right=0\\n\\tfleft=lleft=0\\n\\tfright=lright=0\\n\\tfup=lup=0\\n\\tfdown=ldown=0\\n\\n\\tx=y=0\\n\\tfor i, c in enumerate(s):\\n\\t\\tif c==\\\"W\\\":\\n\\t\\t\\ty -= 1\\n\\t\\t\\tcup += 1\\n\\t\\telif c==\\\"S\\\":\\n\\t\\t\\ty += 1\\n\\t\\t\\tcdown += 1\\n\\t\\telif c==\\\"A\\\":\\n\\t\\t\\tx -= 1\\n\\t\\t\\tcleft += 1\\n\\t\\telif c==\\\"D\\\":\\n\\t\\t\\tx += 1\\n\\t\\t\\tcright += 1\\n\\n\\t\\tif x == left:\\n\\t\\t\\tlleft = i\\n\\t\\tif x == right:\\n\\t\\t\\tlright = i\\n\\t\\tif y == down:\\n\\t\\t\\tldown = i\\n\\t\\tif y == up:\\n\\t\\t\\tlup = i\\n\\n\\t\\tif x < left:\\n\\t\\t\\tleft = x\\n\\t\\t\\tfleft=i\\n\\t\\t\\tlleft=i\\n\\n\\t\\tif x > right:\\n\\t\\t\\tright = x\\n\\t\\t\\tfright=i\\n\\t\\t\\tlright=i\\n\\n\\n\\t\\tif y < up:\\n\\t\\t\\tup = y\\n\\t\\t\\tfup=i\\n\\t\\t\\tlup=i\\n\\n\\n\\t\\tif y > down:\\n\\t\\t\\tdown = y\\n\\t\\t\\tfdown=i\\n\\t\\t\\tldown=i\\n\\n\\twidth = right - left + 1\\n\\theight = down - up + 1\\n\\n\\tbest = width * height\\n\\n\\tif height > 2:\\n\\t\\tif ldown < fup or lup < fdown:\\n\\t\\t\\tbest = min(best, width * (height-1))\\n\\tif width > 2:\\n\\t\\tif lleft < fright or lright < fleft:\\n\\t\\t\\tbest = min(best, (width-1) * height)\\n\\tprint(best)\", \"t = int(input())\\nfor _ in range(t):\\n\\ts = input()\\n\\tn = len(s)\\n\\tfa, fd, fs, fw = [0], [0], [0], [0]\\n\\tba, bd, bs, bw = [0], [0], [0], [0]\\n\\tcur = [0, 0]\\n\\tfor i in range(n):\\n\\t\\tif s[i] == \\\"A\\\":\\n\\t\\t\\tcur[0] -= 1\\n\\t\\t\\t\\n\\t\\telif s[i] == \\\"D\\\":\\n\\t\\t\\tcur[0] += 1\\n\\t\\t\\t\\n\\t\\telif s[i] == \\\"S\\\":\\n\\t\\t\\tcur[1] -= 1\\n\\t\\t\\t\\n\\t\\telif s[i] == \\\"W\\\":\\n\\t\\t\\tcur[1] += 1\\n\\t\\t\\t\\n\\t\\tfa.append(min(fa[-1], cur[0]))\\n\\t\\tfd.append(max(fd[-1], cur[0]))\\n\\t\\tfs.append(min(fs[-1], cur[1]))\\n\\t\\tfw.append(max(fw[-1], cur[1]))\\n\\n\\th = fd[-1]-fa[-1]\\n\\tv = fw[-1]-fs[-1]\\n\\tarea = (h+1)*(v+1)\\n\\n\\tcur = [0, 0]\\n\\tfor i in range(n-1, -1, -1):\\n\\t\\tif s[i] == \\\"D\\\":\\n\\t\\t\\tcur[0] -= 1\\n\\t\\telif s[i] == \\\"A\\\":\\n\\t\\t\\tcur[0] += 1\\n\\t\\telif s[i] == \\\"W\\\":\\n\\t\\t\\tcur[1] -= 1\\n\\t\\telif s[i] == \\\"S\\\":\\n\\t\\t\\tcur[1] += 1\\n\\n\\t\\tba.append(min(ba[-1], cur[0]))\\n\\t\\tbd.append(max(bd[-1], cur[0]))\\n\\t\\tbs.append(min(bs[-1], cur[1]))\\n\\t\\tbw.append(max(bw[-1], cur[1]))\\n\\n\\tba.reverse()\\n\\tbd.reverse()\\n\\tbs.reverse()\\n\\tbw.reverse()\\n\\n\\t#print(fa, fd, fs, fw)\\n\\t#print(ba, bd, bs, bw)\\n\\n\\thok, vok = False, False\\n\\tfor i in range(1, n):\\n\\t\\t#print(n, i)\\n\\t\\tif fd[i]-fa[i] < h and abs(bd[i]-ba[i]) < h:\\n\\t\\t\\thok = True\\n\\t\\tif fw[i]-fs[i] < v and abs(bw[i]-bs[i]) < v:\\n\\t\\t\\tvok = True\\n\\n\\tif hok:\\n\\t\\tarea = min(area, h*(v+1))\\n\\tif vok:\\n\\t\\tarea = min(area, v*(h+1))\\n\\tprint(area)\\n\", \"for q in range(int(input())):\\n\\n    data = input()\\n    # if data in [\\\"WW\\\", \\\"AA\\\", \\\"SS\\\", \\\"DD\\\"]:\\n    #     print(2)\\n    #     continue\\n    mx = [0,0,0,0]\\n    x = 0\\n    y = 0\\n    pos = [[-1],[-1],[-1],[-1]]\\n    for i in range(len(data)):\\n        # print(x,y)\\n        d = data[i]\\n        if d == \\\"W\\\":\\n            y += 1\\n            if y > mx[0]:\\n                \\n                mx[0] = y\\n                pos[0] = []\\n        elif d == \\\"S\\\":\\n            y -= 1\\n            if y < mx[2]:\\n                \\n                mx[2] = y\\n                pos[2] = []\\n        elif d == \\\"A\\\":\\n            x -= 1\\n            if x < mx[1]:\\n                \\n                mx[1] = x\\n                pos[1] = []\\n        else:\\n            x += 1\\n            if x > mx[3]:\\n                \\n                mx[3] = x\\n                pos[3] = []\\n        if x == mx[3]:\\n            pos[3].append(i)\\n        if x == mx[1]:\\n            pos[1].append(i)\\n        if y == mx[0]:\\n            pos[0].append(i)\\n        if y == mx[2]:\\n            pos[2].append(i)\\n\\n    # print(mx)\\n    # print(pos)\\n    wid = mx[3] - mx[1] + 1\\n    hei = mx[0] - mx[2] + 1\\n    ans = wid * hei\\n\\n    \\n    \\n    if pos[3][0] > pos[1][-1] + 1 or pos[1][0] > pos[3][-1] + 1:\\n        ans -= hei\\n    if pos[0][0] > pos[2][-1] + 1 or pos[2][0] > pos[0][-1] + 1:\\n        ans = min((hei-1)*(wid), ans)\\n    print(ans)\", \"T = int(input())\\n\\nw = [[-1, 0], [1, 0], [0, 1], [0, -1]]\\nmp = {'A':0, 'D':1, 'W':2, 'S':3}\\nwhile T > 0:\\n\\tT-=1\\n\\ts = input()\\n\\tl = [0]; r = [0];\\n\\tu = [0]; d = [0];\\n\\n\\tfor dir in s[::-1]:\\n\\t\\tl.append(l[-1])\\n\\t\\tr.append(r[-1])\\n\\t\\tu.append(u[-1])\\n\\t\\td.append(d[-1])\\n\\t\\tif dir == 'A':\\n\\t\\t\\tl[-1]+=1\\n\\t\\t\\tif r[-1] > 0: r[-1]-=1\\n\\t\\telif dir == 'D':\\n\\t\\t\\tr[-1]+=1\\n\\t\\t\\tif l[-1] > 0: l[-1]-=1\\n\\t\\telif dir == 'S':\\n\\t\\t\\td[-1]+=1\\n\\t\\t\\tif u[-1] > 0: u[-1]-=1\\n\\t\\telse:\\n\\t\\t\\tu[-1]+=1\\n\\t\\t\\tif d[-1] > 0: d[-1]-=1\\n\\n\\tl = l[::-1]; r = r[::-1]; u = u[::-1]; d = d[::-1];\\n\\n\\tx = 0; y = 0\\n\\tml = 0; mr = 0; mu = 0; md = 0;\\n\\n\\tans = (l[0] + r[0] + 1) * (u[0] + d[0] + 1)\\n\\tfor i in range(len(s)+1):\\n\\t\\tmml=ml;mmr=mr;mmu=mu;mmd=md;\\n\\t\\tfor j in range(4):\\n\\t\\t\\txx=x+w[j][0]\\n\\t\\t\\tyy=y+w[j][1]\\n\\n\\t\\t\\tif xx<0: ml=max(ml,-xx)\\n\\t\\t\\tif xx>0: mr=max(mr,xx)\\n\\t\\t\\tif yy>0: mu=max(mu,yy)\\n\\t\\t\\tif yy<0: md=max(md,-yy)\\n\\n\\t\\t\\txx-=l[i]\\n\\t\\t\\tif xx<0: ml=max(ml,-xx)\\n\\t\\t\\txx+=r[i]+l[i];\\n\\t\\t\\tif xx>0: mr=max(mr,xx)\\n\\t\\t\\tyy-=d[i]\\n\\t\\t\\tif yy<0: md=max(md,-yy)\\n\\t\\t\\tyy+=u[i]+d[i]\\n\\t\\t\\tif yy>0: mu=max(mu,yy)\\n\\n\\t\\t\\tans = min(ans, (ml+mr+1)*(mu+md+1))\\n\\t\\t\\tml=mml;mr=mmr;mu=mmu;md=mmd;\\n\\n\\t\\tif i < len(s):\\n\\t\\t\\tx+=w[mp[s[i]]][0]\\n\\t\\t\\ty+=w[mp[s[i]]][1]\\n\\t\\t\\tif x<0: ml=max(ml,-x)\\n\\t\\t\\tif x>0: mr=max(mr,x)\\n\\t\\t\\tif y>0: mu=max(mu,y)\\n\\t\\t\\tif y<0: md=max(md,-y)\\n\\n\\tprint(ans)\", \"import sys\\nfrom collections import defaultdict\\ninput = sys.stdin.readline\\nimport math\\n\\n\\ndef main():\\n    t = int(input())\\n    for _ in range(t):\\n        s = input().rstrip()\\n        a1 = []\\n        a2 = []\\n        ws = {'W': 1, 'S': -1}\\n        ad = {'A': 1, 'D': -1}\\n        for c in s:\\n            if c in ('W', 'S'):\\n                a1.append(ws[c])\\n            else:\\n                a2.append(ad[c])\\n        pref_a1 = [0] + a1.copy()\\n        pref_a2 = [0] + a2.copy()\\n        for i in range(1, len(pref_a1)):\\n            pref_a1[i] += pref_a1[i-1]\\n        for i in range(1, len(pref_a2)):\\n            pref_a2[i] += pref_a2[i-1]\\n\\n        def canDecrease(a):\\n            _min = min(a)\\n            _max = max(a)\\n\\n            # decrease max\\n            _min_rindex = a.index(_min)\\n            for i in range(_min_rindex, len(a)):\\n                if a[i] == _min:\\n                    _min_rindex = i\\n            _max_index = a.index(_max)\\n            if _max_index > _min_rindex:\\n                return True\\n\\n            # increase min\\n            _max_rindex = a.index(_max)\\n            for i in range(_max_rindex, len(a)):\\n                if a[i] == _max:\\n                    _max_rindex = i\\n            _min_index = a.index(_min)\\n            if _max_rindex < _min_index:\\n                return True\\n\\n            return False\\n\\n        x = max(pref_a1)-min(pref_a1)\\n        y = max(pref_a2)-min(pref_a2)\\n        res = (x+1) * (y+1)\\n        if x > 1 and canDecrease(pref_a1):\\n            res = min(res, x * (y+1))\\n        if y > 1 and canDecrease(pref_a2):\\n            res = min(res, (x+1) * y)\\n\\n        print(res)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n\\n__starting_point()\", \"\\nfor i in range(int(input())):\\n\\ts = input()\\n\\tlm, rm, um, dm = 0, 0, 0, 0\\n\\txp, yp = 0, 0\\n\\tfor ch in s:\\n\\t\\tif ch == 'W':\\n\\t\\t\\typ += 1\\n\\t\\telif ch == 'A':\\n\\t\\t\\txp -= 1\\n\\t\\telif ch == 'S':\\n\\t\\t\\typ -= 1\\n\\t\\telse:\\n\\t\\t\\txp += 1\\n\\t\\tlm = min(lm, xp)\\n\\t\\trm = max(rm, xp)\\n\\t\\tum = max(um, yp)\\n\\t\\tdm = min(dm, yp)\\n\\txp, yp = 0, 0\\n\\tlmfSet, rmfSet, umfSet, dmfSet = 0, 0, 0, 0\\n\\tif lm == 0:\\n\\t\\tlml = 0\\n\\t\\tlmf = 0\\n\\t\\tlmfSet = 1\\n\\tif rm == 0:\\n\\t\\trml = 0\\n\\t\\trmf = 0\\n\\t\\trmfSet = 1\\n\\tif um == 0:\\n\\t\\tuml = 0\\n\\t\\tumf = 0\\n\\t\\tumfSet = 1\\n\\tif dm == 0:\\n\\t\\tdml = 0\\n\\t\\tdmf = 0\\n\\t\\tdmfSet = 1\\n\\tfor i, ch in zip(list(range(1, len(s) + 1)), s):\\n\\t\\tif ch == 'W':\\n\\t\\t\\typ += 1\\n\\t\\telif ch == 'A':\\n\\t\\t\\txp -= 1\\n\\t\\telif ch == 'S':\\n\\t\\t\\typ -= 1\\n\\t\\telse:\\n\\t\\t\\txp += 1\\n\\t\\tif xp == lm:\\n\\t\\t\\tlml = i\\n\\t\\t\\tif not lmfSet:\\n\\t\\t\\t\\tlmf = i\\n\\t\\t\\t\\tlmfSet = 1\\n\\t\\tif xp == rm:\\n\\t\\t\\trml = i\\n\\t\\t\\tif not rmfSet:\\n\\t\\t\\t\\trmf = i\\n\\t\\t\\t\\trmfSet = 1\\n\\t\\tif yp == um:\\n\\t\\t\\tuml = i\\n\\t\\t\\tif not umfSet:\\n\\t\\t\\t\\tumf = i\\n\\t\\t\\t\\tumfSet = 1\\n\\t\\tif yp == dm:\\n\\t\\t\\tdml = i\\n\\t\\t\\tif not dmfSet:\\n\\t\\t\\t\\tdmf = i\\n\\t\\t\\t\\tdmfSet = 1\\n\\tcanx, cany = 0, 0\\n\\tif dml + 1 < umf or uml + 1 < dmf:\\n\\t\\tcany = 1\\n\\tif lml + 1 < rmf or rml + 1 < lmf:\\n\\t\\tcanx = 1\\n\\tif canx:\\n\\t\\tif cany:\\n\\t\\t\\tprint(min((um - dm) * (rm - lm + 1), (um - dm + 1) * (rm - lm)))\\n\\t\\telse:\\n\\t\\t\\tprint((rm - lm) * (um - dm + 1))\\n\\telse:\\n\\t\\tif cany:\\n\\t\\t\\tprint((um - dm) * (rm - lm + 1))\\n\\t\\telse:\\n\\t\\t\\tprint((rm - lm + 1) * (um - dm + 1))\\n\\n\\n\", \"t=int(input())\\ndef possible(presum):\\n    l=len(presum)\\n    lastmax=-1\\n    firstmin=l\\n    mx=max(presum)\\n    mn=min(presum)\\n    for i in range(l):\\n        if(mx==presum[i]):\\n            lastmax=max(lastmax,i)\\n        if(mn==presum[i]):\\n            firstmin=min(i,firstmin)\\n    if lastmax<firstmin:\\n        return True\\n    return False\\nfor i in range(t):\\n    s=input()\\n    l1=[0]\\n    l2=[0]\\n    for i in s:\\n        if i=='S':\\n            l1.append(l1[-1]-1)\\n        elif i=='W':\\n            l1.append(l1[-1]+1)\\n        elif i==\\\"D\\\":\\n            l2.append(l2[-1]+1)\\n        else:\\n            l2.append(l2[-1]-1)\\n    length=max(l1)-min(l1)+1\\n    breadth=max(l2)-min(l2)+1\\n    ans=length*breadth\\n    if length>2 and possible(l1):\\n        ans=min(ans,(length-1)*breadth)\\n    for i in range(len(l1)):\\n        l1[i]*=-1\\n    if length>2 and possible(l1):\\n        ans=min(ans,(length-1)*breadth)\\n    if breadth>2 and possible(l2):\\n        ans=min(ans,(length)*(breadth-1))\\n    for i in range(len(l2)):\\n        l2[i]*=-1\\n    if breadth>2 and possible(l2):\\n        ans=min(ans,(length)*(breadth-1))\\n    print(ans)\", \"def lim(s):\\n    now = 0\\n    up, down = 0, 0\\n    for i in s:\\n        now += i\\n        up = max(up, now)\\n        down = min(down, now)\\n    return up, down\\ndef f(a):\\n    return a[0] - a[1] + 1\\ndef upg(s):\\n    t = lim(s)\\n    up, down = t[0], t[1]\\n    arr = [1, 1]\\n    now = 0\\n    for i in range(len(s) - 1):\\n        if now == up - 1 and s[i + 1] == 1 and arr[0] == 1:\\n            arr[0] = 0\\n            if f(lim(s[:(i + 1)] + [-1] + s[(i + 1):])) < f(t):\\n                return 1\\n        if now == down + 1 and s[i + 1] == -1 and arr[1] == 1:\\n            arr[1] = 0\\n            if f(lim(s[:(i + 1)] + [1] + s[(i + 1):])) < f(t):\\n                return 1\\n        now += s[i + 1]\\n    return 0\\n\\n\\nfor q in range(int(input())):\\n    s = input()\\n    s1, s2 = [0], [0]\\n    for i in s:\\n        if i == 'W': s1.append(1)\\n        if i == 'S': s1.append(-1)\\n        if i == 'A': s2.append(1)\\n        if i == 'D': s2.append(-1)\\n    u1 = upg(s1)\\n    u2 = upg(s2)\\n    res1, res2 = f(lim(s1)), f(lim(s2))\\n    ans = min((res1 - u1) * res2, (res2 - u2) * res1)\\n    print(ans)\", \"t= int(input())\\n\\nfor _ in range(0,t):\\n\\n    a= list(input())\\n    nowx=0\\n    nowy=0\\n    maxx=0\\n    minx=0\\n    maxy=0\\n    miny=0\\n    tmaxx=0\\n    tminx=0\\n    tmaxy=0\\n    tminy=0\\n    highw=0\\n    highs=0\\n    widthd=0\\n    widtha=0\\n    for i in range (0,len(a)):\\n        \\n        if a[i] == 'W':\\n            nowy += 1\\n            if nowy >= maxy:\\n                maxy=nowy\\n                tmaxy=i\\n                \\n        elif a[i] == 'S':\\n            nowy -= 1\\n            if nowy <=miny:\\n                miny=nowy\\n                tminy=i\\n        elif a[i] == 'D':\\n            nowx += 1\\n            if nowx >= maxx:\\n                maxx=nowx\\n                tmaxx=i\\n        elif a[i] == 'A':\\n            nowx -= 1\\n            if nowx <=minx:\\n                minx=nowx\\n                tminx=i\\n\\n        highw= max(highw,nowy-miny)\\n        highs= max(highs,maxy-nowy)\\n        widthd=max(widthd,nowx-minx)\\n        widtha=max(widtha,maxx-nowx)\\n    y1= max(highw,highs)\\n    y2= max(highw!=0 or highs!=0, y1- ((highw!=highs)))\\n    x1= max(widthd,widtha)\\n    x2= max(widthd!=0 or widtha!=0, x1-((widthd!=widtha)))\\n    print(min((y1+1)*(x2+1),(1+y2)*(x1+1)))\\n    \\n  \\n    \\n    \\n\\n   \\n\\n    \\n    \\n\", \"t = int(input())\\nfor _ in range(t):\\n    ss = input()\\n    minx=0\\n    fminxpos = -1\\n    lminxpos = -1\\n    maxx=0\\n    fmaxxpos = -1\\n    lmaxxpos = -1\\n    miny=0\\n    fminypos = -1\\n    lminypos = -1\\n    maxy=0\\n    fmaxypos = -1\\n    lmaxypos = -1\\n    x = 0\\n    y = 0\\n    for i,s in enumerate(ss):\\n        if s == 'W':\\n            y +=1\\n            if y > maxy:\\n                maxy=y\\n                fmaxypos=i\\n            if y == maxy:\\n                lmaxypos=i\\n        elif s == 'S':\\n            y -= 1\\n            if y < miny:\\n                miny = y\\n                fminypos = i\\n            if y == miny:\\n                lminypos = i\\n        elif s == 'D':\\n            lastd = i\\n            x += 1\\n            if x > maxx:\\n                maxx = x\\n                fmaxxpos = i\\n            if x == maxx:\\n                lmaxxpos = i\\n        elif s == 'A':\\n            lasta = i\\n            x -= 1\\n            if x < minx:\\n                minx = x\\n                fminxpos = i\\n            if x == minx:\\n                lminxpos = i\\n    xsize = maxx - minx + 1\\n    ysize = maxy - miny + 1\\n    if xsize > 2 and (fmaxxpos > lminxpos or fminxpos > lmaxxpos):\\n        xmin = xsize - 1\\n    else:\\n        xmin = xsize\\n    if ysize > 2 and (fmaxypos > lminypos or fminypos > lmaxypos):\\n        ymin = ysize - 1\\n    else:\\n        ymin = ysize\\n    print(min(xmin*ysize, xsize*ymin))\", \"T = int(input())\\n\\nfor _ in range(T):\\n    cmd = input()\\n\\n    mostL, mostR, mostB, mostT = 0, 0, 0, 0\\n    mostLs, mostRs, mostBs, mostTs = [0],[0],[0],[0]\\n    x,y=0,0\\n    i = 0\\n    for c in cmd:\\n        i += 1\\n        if c == \\\"W\\\":\\n            y += 1\\n            if y>mostT:\\n                mostT = y\\n                mostTs = [i]\\n            elif y == mostT:\\n                mostTs.append(i)\\n        elif c == \\\"S\\\":\\n            y -= 1\\n            if y<mostB:\\n                mostB = y\\n                mostBs = [i]\\n            elif y == mostB:\\n                mostBs.append(i)\\n        elif c == \\\"A\\\":\\n            x -= 1\\n            if x < mostL:\\n                mostL = x\\n                mostLs = [i]\\n            elif x == mostL:\\n                mostLs.append(i)\\n        elif c == \\\"D\\\":\\n            x += 1\\n            if x > mostR:\\n                mostR = x\\n                mostRs = [i]\\n            elif x == mostR:\\n                mostRs.append(i)\\n\\n    LR = mostR - mostL + 1\\n    if LR >= 3:\\n        firstL, lastL = mostLs[0], mostLs[-1]\\n        firstR, lastR = mostRs[0], mostRs[-1]\\n\\n        cross = lastR > firstL and lastL > firstR\\n        LR_extra = not cross\\n    else:\\n        LR_extra = False\\n\\n    BT = mostT - mostB + 1\\n    if BT >= 3:\\n        firstB, lastB = mostBs[0], mostBs[-1]\\n        firstT, lastT = mostTs[0], mostTs[-1]\\n\\n        cross = lastB > firstT and lastT > firstB\\n        BT_extra = not cross\\n    else:\\n        BT_extra = False\\n\\n    if LR_extra and BT_extra:\\n        area = min((LR-1)*BT,LR*(BT-1))\\n    elif LR_extra:\\n        area = (LR-1)*BT\\n    elif BT_extra:\\n        area = LR*(BT-1)\\n    else:\\n        area = LR*BT\\n    print(area)\", \"def main():\\n    hh, vv, r = [0], [0], []\\n    f = {'W': (vv, -1), 'S': (vv, 1), 'A': (hh, -1), 'D': (hh, 1)}.get\\n    for _ in range(int(input())):\\n        del vv[1:], hh[1:], r[:]\\n        for l, d in map(f, input()):\\n            l.append(l[-1] + d)\\n        for l in hh, vv:\\n            mi, ma = min(l), max(l)\\n            a, tmp = mi - 1, []\\n            for b in filter((mi, ma).__contains__, l):\\n                if a != b:\\n                    a = b\\n                    tmp.append(a)\\n            ma -= mi - 1\\n            r.append(ma)\\n            if len(tmp) < 3 <= ma:\\n                ma -= 1\\n            r.append(ma)\\n        print(min((r[0] * r[3], r[1] * r[2])))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"def main():\\n    h, v = hv = ([0], [0])\\n    f = {'W': (v, -1), 'S': (v, 1), 'A': (h, -1), 'D': (h, 1)}.get\\n    for _ in range(int(input())):\\n        del h[1:], v[1:]\\n        for l, d in map(f, input()):\\n            l.append(l[-1] + d)\\n        x = y = 1\\n        for l in hv:\\n            lh, a, n = (min(l), max(l)), 200001, 0\\n            for b in filter(lh.__contains__, l):\\n                if a != b:\\n                    a = b\\n                    n += 1\\n            le = lh[1] - lh[0] + 1\\n            x, y = y * le, x * (le - (n < 3 <= le))\\n        print(x if x < y else y)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"t = int(input())\\nfor c in range(t):\\n    s = input()\\n    up_max = down_max = right_max = left_max = 0\\n    first_up = last_up = first_down = last_down = first_left = last_left = first_right = last_right = 0\\n    current_x = current_y = 0\\n    horizontal_count = vertical_count = 0\\n    for i in range(len(s)):\\n        if s[i] == 'W':\\n            current_y += 1\\n            vertical_count += 1\\n            if current_y > up_max:\\n                up_max = current_y\\n                first_up = last_up = i + 1\\n            elif current_y == up_max:\\n                last_up = i + 1\\n        elif s[i] == 'S':\\n            current_y -= 1\\n            vertical_count += 1\\n            if current_y < down_max:\\n                down_max = current_y\\n                first_down = last_down = i + 1\\n            elif current_y == down_max:\\n                last_down = i + 1\\n        elif s[i] == 'D':\\n            current_x += 1\\n            horizontal_count += 1\\n            if current_x > right_max:\\n                right_max = current_x\\n                first_right = last_right = i + 1\\n            elif current_x == right_max:\\n                last_right = i + 1\\n        else:\\n            current_x -= 1\\n            horizontal_count += 1\\n            if current_x < left_max:\\n                left_max = current_x\\n                first_left = last_left = i + 1\\n            elif current_x == left_max:\\n                last_left = i + 1\\n\\n    h = up_max - down_max + 1\\n    w = right_max - left_max + 1\\n    ans = h * w\\n    if vertical_count > 1 and last_up < first_down:\\n        ans = min(ans, (h - 1) * w)\\n    if vertical_count > 1 and last_down < first_up:\\n        ans = min(ans, (h - 1) * w)\\n    if horizontal_count > 1 and last_right < first_left:\\n        ans = min(ans, h * (w - 1))\\n    if horizontal_count > 1 and last_left < first_right:\\n        ans = min(ans, h * (w - 1))\\n\\n    print(ans)\", \"q = int(input())\\nfor _ in range(q):\\n    d = [x for x in list(input())]\\n    x, y = 0, 0\\n    minX, maxX, minY, maxY = 0, 0 ,0 ,0\\n    allowW, allowS, allowA, allowD = True, True, True, True\\n    for v in d:\\n        if v == 'W':\\n            y += 1\\n            if y > maxY:\\n                maxY = y\\n                allowS = True\\n                allowW = False\\n            elif y == maxY:\\n                allowW = False\\n        elif v == 'S':\\n            y -= 1\\n            if y < minY:\\n                minY = y\\n                allowW = True\\n                allowS = False\\n            elif y == minY:\\n                allowS = False\\n        elif v == 'A':\\n            x -= 1\\n            if x < minX:\\n                minX = x\\n                allowA = False\\n                allowD = True\\n            elif x == minX:\\n                allowA = False\\n        else:#if v == 'D':\\n            x += 1\\n            if x > maxX:\\n                maxX = x\\n                allowA = True\\n                allowD = False\\n            elif x == maxX:\\n                allowD = False\\n    val = (maxX-minX+1)*(maxY-minY+1)\\n    if (maxX-minX) > 1 and (allowD or allowA):\\n        val = min(val, (maxX-minX)*(maxY-minY+1))\\n    if (maxY-minY) > 1 and (allowW or allowS):\\n        val = min(val, (maxX-minX+1)*(maxY-minY))\\n    print(val)\", \"# coding=utf-8\\nINF = 1e11\\n\\n# move = {'W': (0, 0), 'A': (0, 0), 'S': (0, 0), 'D': (0, 0)}\\nmove = {'W': (0, 1), 'A': (-1, 0), 'S': (0, -1), 'D': (1, 0)}\\n\\n\\ndef getExtremes(positions):\\n    minX, minY, maxX, maxY = [positions[0][0]], [positions[0][1]], [positions[0][0]], [positions[0][1]]\\n    for p in positions[1:]:\\n        minX.append(min(minX[-1], p[0]))\\n        minY.append(min(minY[-1], p[1]))\\n        maxX.append(max(maxX[-1], p[0]))\\n        maxY.append(max(maxY[-1], p[1]))\\n    return minX, minY, maxX, maxY\\n\\n\\nt = int(input())\\n\\nwhile t > 0:\\n    t -= 1\\n    s = input()\\n    x, y = 0, 0\\n    positions = [(0, 0)]\\n    for c in s:\\n        x, y = x + move[c][0], y + move[c][1]\\n        positions.append((x, y))\\n    # print(positions)\\n    # print()\\n    minXBeg, minYBeg, maxXBeg, maxYBeg = getExtremes(positions)\\n    # print(minXBeg, minYBeg, maxXBeg, maxYBeg, sep=\\\"\\\\n\\\")\\n    # print()\\n    positions.reverse()\\n    minXEnd, minYEnd, maxXEnd, maxYEnd = getExtremes(positions)\\n    minXEnd.reverse()\\n    minYEnd.reverse()\\n    maxXEnd.reverse()\\n    maxYEnd.reverse()\\n    # print(minXEnd, minYEnd, maxXEnd, maxYEnd, sep=\\\"\\\\n\\\")\\n    # print()\\n    positions.reverse()\\n    ans = INF\\n    for i in range(len(s)):\\n        for c in move:\\n            minX = min(minXBeg[i], positions[i][0] + move[c][0], minXEnd[i + 1] + move[c][0])\\n            maxX = max(maxXBeg[i], positions[i][0] + move[c][0], maxXEnd[i + 1] + move[c][0])\\n            minY = min(minYBeg[i], positions[i][1] + move[c][1], minYEnd[i + 1] + move[c][1])\\n            maxY = max(maxYBeg[i], positions[i][1] + move[c][1], maxYEnd[i + 1] + move[c][1])\\n            area = (maxX - minX + 1) * (maxY - minY + 1)\\n            # print(i, c, minX, maxX, minY, maxY, area)\\n            ans = min(ans, area)\\n    print(ans)\\n\", \"def solve():\\n    i = 0\\n    j = 0\\n    imax = imin = 0\\n    jmax = jmin = 0\\n    fjmin = ljmin = fjmax = ljmax = fimax = limax = fimin = limin = -1\\n    for ind, e in enumerate(input()):\\n        if e == 'W':\\n            i += 1\\n            if i > imax:\\n                imax = i\\n                fimax = ind\\n                limax = ind\\n        elif e == 'S':\\n            i -= 1\\n            if i < imin:\\n                imin = i\\n                fimin = ind\\n                limin = ind\\n        elif e == \\\"A\\\":\\n            j -= 1\\n            if j < jmin:\\n                jmin = j\\n                fjmin = ind\\n                ljmin = ind\\n        elif e == 'D':\\n            j += 1\\n            if j > jmax:\\n                jmax = j\\n                fjmax = ind\\n                ljmax = ind\\n        if j == jmin:\\n            ljmin = ind\\n        if j == jmax:\\n            ljmax = ind\\n        if i == imin:\\n            limin = ind\\n        if i == imax:\\n            limax = ind\\n    ans = 0\\n    if fjmax > ljmin + 1 or fjmin > ljmax + 1:\\n        ans = imax - imin + 1\\n    if fimax > limin + 1 or fimin > limax + 1:\\n        ans = max(ans, jmax - jmin + 1)\\n    print((imax - imin + 1) * (jmax - jmin + 1) - ans)\\n\\n\\nfor _ in range(int(input())):\\n    solve()\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\n\\nQ = int(input())\\nQuery = [list(input().rstrip()) for _ in range(Q)]\\n\\nfor S in Query:\\n    L = len(S)\\n    T = [(0, 0)]\\n    for s in S:\\n        x, y = T[-1]\\n        if s == \\\"W\\\":\\n            T.append((x, y+1))\\n        elif s == \\\"S\\\":\\n            T.append((x, y-1))\\n        elif s == \\\"A\\\":\\n            T.append((x-1, y))\\n        else:\\n            T.append((x+1, y))\\n    \\n    # up, down, left, right\\n    dp1 = [[0, 0, 0, 0] for _ in range(L+1)]\\n    for i, (x, y) in enumerate(T):\\n        if i == 0: continue\\n        dp1[i][0] = max(y, dp1[i-1][0])\\n        dp1[i][1] = min(y, dp1[i-1][1])\\n        dp1[i][2] = min(x, dp1[i-1][2])\\n        dp1[i][3] = max(x, dp1[i-1][3])\\n    \\n\\n    lx, ly = T[-1]\\n    dp2 = [[ly, ly, lx, lx] for _ in range(L+1)]\\n    for i in reversed(range(L)):\\n        x, y = T[i]\\n        dp2[i][0] = max(y, dp2[i+1][0])\\n        dp2[i][1] = min(y, dp2[i+1][1])\\n        dp2[i][2] = min(x, dp2[i+1][2])\\n        dp2[i][3] = max(x, dp2[i+1][3])\\n    \\n    Y, X = dp1[L][0]-dp1[L][1]+1, dp1[L][3]-dp1[L][2]+1\\n    ans = 0\\n    for i in range(L):\\n        if dp1[i][0] < dp2[i][0] and dp1[i][1] < dp2[i][1]:\\n            ans = max(ans, X)\\n        if dp1[i][0] > dp2[i][0] and dp1[i][1] > dp2[i][1]:\\n            ans = max(ans, X)\\n        if dp1[i][2] < dp2[i][2] and dp1[i][3] < dp2[i][3]:\\n            ans = max(ans, Y)\\n        if dp1[i][2] > dp2[i][2] and dp1[i][3] > dp2[i][3]:\\n            ans = max(ans, Y)\\n    print(X*Y-ans)\", \"def read_int():\\n    return int(input())\\n\\n\\ndef read_ints():\\n    return list(map(int, input().split(' ')))\\n\\n\\nt = read_int()\\nINF = int(1e7)\\nfor case_num in range(t):\\n    s = input()\\n    x = 0\\n    y = 0\\n    xlist = [0]\\n    ylist = [0]\\n    for c in s:\\n        if c == 'W':\\n            y += 1\\n        elif c == 'S':\\n            y -= 1\\n        elif c == 'A':\\n            x -= 1\\n        else:\\n            x += 1\\n        xlist.append(x)\\n        ylist.append(y)\\n    n = len(s)\\n    l = [0]\\n    r = [0]\\n    u = [0]\\n    d = [0]\\n    for i in range(1, n + 1):\\n        l.append(min(l[-1], xlist[i]))\\n        r.append(max(r[-1], xlist[i]))\\n        u.append(max(u[-1], ylist[i]))\\n        d.append(min(d[-1], ylist[i]))\\n    lr = [xlist[n]]\\n    rr = [xlist[n]]\\n    ur = [ylist[n]]\\n    dr = [ylist[n]]\\n    for i in range(1, n + 1):\\n        lr.append(min(lr[-1], xlist[n - i]))\\n        rr.append(max(rr[-1], xlist[n - i]))\\n        ur.append(max(ur[-1], ylist[n - i]))\\n        dr.append(min(dr[-1], ylist[n - i]))\\n    ans = INF * INF\\n    coeff = [[-1, 0], [1, 0], [0, -1], [0, 1]]\\n    for k in range(4):\\n        for i in range(n):\\n            nl = min(l[i], lr[n - i] + coeff[k][0])\\n            nr = max(r[i], rr[n - i] + coeff[k][0])\\n            nu = max(u[i], ur[n - i] + coeff[k][1])\\n            nd = min(d[i], dr[n - i] + coeff[k][1])\\n            area = (nr - nl + 1) * (nu - nd + 1)\\n            ans = min(ans, area)\\n    print(ans)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nfor _ in range(int(input())):\\n    s = input()\\n    l, r, u, d, fl, fr, fu, fd, x, y = [0] * 10\\n    for i in range(len(s)):\\n        if s[i] == 'W':\\n            y += 1\\n            if y > u:\\n                u = y\\n                fd = 0\\n                fu = 1\\n            if y == u:\\n                fu = 1\\n        elif s[i] == 'A':\\n            x -= 1\\n            if x < l:\\n                l = x\\n                fl = 1\\n                fr = 0\\n            if x == l:\\n                fl = 1\\n        elif s[i] == 'S':\\n            y -= 1\\n            if y < d:\\n                d = y\\n                fd = 1\\n                fu = 0\\n            if y == d:\\n                fd = 1\\n        elif s[i] == 'D':\\n            x += 1\\n            if x > r:\\n                r = x\\n                fr = 1\\n                fl = 0\\n            if x == r:\\n                fr = 1\\n    #bless Ctrl+C Ctrl+V\\n    x, y = r - l + 1, u - d + 1\\n    s, k = x * y, x * y\\n    if x > 2 and not fl * fr:\\n        s = k - y\\n    if y > 2 and not fu * fd and k - x < s:\\n        s = k - x\\n    print(s)\", \"import sys\\ndef work(c,c1, s):\\n    maxlast, maxfirst,minlast,minfirst = 0,0,0,0\\n    max = 0\\n    min = 0\\n    y = 0\\n    for i in range(len(s)):\\n        if s[i] == c:\\n            y += 1\\n        elif s[i] == c1:\\n            y -=1\\n\\n        if max < y:\\n            maxfirst,maxlast = i,i\\n            max = y\\n        elif max ==y :\\n            maxlast = i\\n\\n        if y < min:\\n            minlast,minfirst =i,i\\n            min = y\\n        elif min == y:\\n            minlast = i\\n    flag = 0\\n    if (maxlast<minfirst or maxfirst>minlast) and max-min > 1:\\n        flag = 1\\n    return  max-min+1,flag\\n\\ncount = 0\\nfor line in sys.stdin:\\n    if count == 0:\\n        n = int(line.strip().split(' ')[0])\\n        #k = int(line.strip().split(' ')[1])\\n        #m = int(line.strip().split(' ')[2])\\n        count += 1\\n        continue\\n    s = line.strip()\\n    flag,flag1 =0,0\\n    n,flag = work('W','S', s)\\n    m,flag1 = work('A', 'D', s)\\n\\n    res = n * m\\n    if flag1 and flag:\\n        res = min(n*(m-1),m*(n-1))\\n    elif flag:\\n        res = m*(n-1)\\n    elif flag1:\\n        res = (m-1)*n\\n    print(res)\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\nDSAWWAW\\nD\\nWA\\n\"\n  ],\n  \"outputs\": [\n    \"8\\n2\\n4\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1202/C", "starter_code": ""}
{"id": 12, "question": "Once again, Boris needs the help of Anton in creating a task. This time Anton needs to solve the following problem:\n\nThere are two arrays of integers $a$ and $b$ of length $n$. It turned out that array $a$ contains only elements from the set $\\{-1, 0, 1\\}$.\n\nAnton can perform the following sequence of operations any number of times:  Choose any pair of indexes $(i, j)$ such that $1 \\le i < j \\le n$. It is possible to choose the same pair $(i, j)$ more than once.   Add $a_i$ to $a_j$. In other words, $j$-th element of the array becomes equal to $a_i + a_j$. \n\nFor example, if you are given array $[1, -1, 0]$, you can transform it only to $[1, -1, -1]$, $[1, 0, 0]$ and $[1, -1, 1]$ by one operation.\n\nAnton wants to predict if it is possible to apply some number (zero or more) of these operations to the array $a$ so that it becomes equal to array $b$. Can you help him?\n\n\n-----Input-----\n\nEach test contains multiple test cases. \n\nThe first line contains the number of test cases $t$ ($1 \\le t \\le 10000$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 10^5$) \u00a0\u2014 the length of arrays.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($-1 \\le a_i \\le 1$) \u00a0\u2014 elements of array $a$. There can be duplicates among elements.\n\nThe third line of each test case contains $n$ integers $b_1, b_2, \\dots, b_n$ ($-10^9 \\le b_i \\le 10^9$) \u00a0\u2014 elements of array $b$. There can be duplicates among elements.\n\nIt is guaranteed that the sum of $n$ over all test cases doesn't exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, output one line containing \"YES\" if it's possible to make arrays $a$ and $b$ equal by performing the described operations, or \"NO\" if it's impossible.\n\nYou can print each letter in any case (upper or lower).\n\n\n-----Example-----\nInput\n5\n3\n1 -1 0\n1 1 -2\n3\n0 1 1\n0 2 2\n2\n1 0\n1 41\n2\n-1 0\n-1 -41\n5\n0 1 -1 1 -1\n1 1 -1 1 -1\n\nOutput\nYES\nNO\nYES\nYES\nNO\n\n\n\n-----Note-----\n\nIn the first test-case we can choose $(i, j)=(2, 3)$ twice and after that choose $(i, j)=(1, 2)$ twice too. These operations will transform $[1, -1, 0] \\to [1, -1, -2] \\to [1, 1, -2]$\n\nIn the second test case we can't make equal numbers on the second position.\n\nIn the third test case we can choose $(i, j)=(1, 2)$ $41$ times. The same about the fourth test case.\n\nIn the last lest case, it is impossible to make array $a$ equal to the array $b$.", "solutions": "[\"from math import *\\n\\nmod = 1000000007\\n\\nfor zz in range(int(input())):\\n    n = int(input())\\n    a = [ int(i) for i in input().split()]\\n    b = [int(i) for i in input().split()]\\n    ha = True\\n    hp = False\\n    hm = False\\n    for i in range(n):\\n        if b[i] != a[i]:\\n            if b[i] > a[i]:\\n                if (hp):\\n                    pass\\n                else:\\n                    ha = False\\n                    break\\n            else:\\n                if (hm):\\n                    pass\\n                else:\\n                    ha = False\\n                    break\\n        if a[i] > 0:\\n            hp = True\\n        elif a[i] < 0:\\n            hm = True\\n\\n    if ha:\\n        print('YES')\\n    else:\\n        print('NO')\\n\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    b = list(map(int, input().split()))\\n    d1 = False\\n    d2 = False\\n    ans = True\\n    for j in range(n):\\n        if a[j] > b[j]:\\n            if not d1:\\n                ans = False\\n        if a[j] < b[j]:\\n            if not d2:\\n                ans = False\\n        if a[j] == -1:\\n            d1 = True\\n        elif a[j] == 1:\\n            d2 = True\\n    if ans:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"import sys\\ninput = sys.stdin.readline\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    b = list(map(int, input().split()))\\n    pos = neg = False\\n    ok = True\\n    for i in range(n):\\n        if a[i] > b[i] and not neg:\\n            ok = False\\n            break\\n        if a[i] < b[i] and not pos:\\n            ok = False\\n            break\\n        if a[i] == -1:\\n            neg = True\\n        if a[i] == 1:\\n            pos = True\\n    print('YES' if ok else 'NO')\", \"from math import *\\n\\n\\n\\nfor t in range(int(input())):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    b = list(map(int, input().split()))\\n    cnt1 = 0\\n    cnt0 = 0\\n    cntotr = 0\\n    f = True\\n    for i in range(n):\\n        if a[i] > b[i]:\\n            if cntotr == 0:\\n                f = False\\n                break\\n        if a[i] < b[i]:\\n            if cnt1 == 0:\\n                f = False\\n                break\\n        if a[i] == 0:\\n            cnt0 += 1\\n        elif a[i] == 1:\\n            cnt1 += 1\\n        else:\\n            cntotr += 1\\n    if f:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    A = map(int, input().split())\\n    B = map(int, input().split())\\n    \\n    seen_pos = seen_neg = False\\n    for a, b in zip(A, B):\\n        if (b > a and not seen_pos) or (b < a and not seen_neg):\\n            print('NO')\\n            break\\n        \\n        if a > 0:\\n            seen_pos = True\\n        elif a < 0:\\n            seen_neg = True        \\n    else:\\n        print('YES')\", \"import math\\nfrom collections import defaultdict\\nml=lambda:map(int,input().split())\\nll=lambda:list(map(int,input().split()))\\nii=lambda:int(input())\\nip=lambda:input()\\n\\n\\\"\\\"\\\"========main code===============\\\"\\\"\\\"\\n\\nt=ii()\\nfor _ in range(t):\\n    x=ii()\\n    a=ll()\\n    b=ll()\\n    one=-1\\n    minus=-1\\n    f=0\\n    for i in range(x):\\n        if(b[i]>a[i]):\\n            if(one==-1):\\n                f=1\\n                break\\n        elif (b[i]<a[i]):\\n            if(minus==-1):\\n                f=1\\n                break\\n        if(a[i]==1):\\n            one=1\\n        elif(a[i]==-1):\\n            minus=1\\n    if(f):\\n        print(\\\"NO\\\")\\n    else:\\n        print(\\\"YES\\\")\", \"t=int(input())\\nfor _ in range(t):\\n    n=int(input())\\n    a=list(map(int, input().split()))\\n    b=list(map(int, input().split()))\\n    grow = shrink = False\\n    for ai, bi in zip(a,b):\\n        if bi < ai:\\n            if not shrink:\\n                print('NO')\\n                break\\n        elif bi > ai and not grow:\\n            print('NO')\\n            break\\n        if ai == 1:\\n            grow = True\\n        elif ai == -1:\\n            shrink = True\\n    else:\\n        print('YES')\\n\", \"t = int(input())\\nfor case_num in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split(' ')))\\n    b = list(map(int, input().split(' ')))\\n    pos = False\\n    neg = False\\n    ok = True\\n    for i in range(n):\\n        if (not pos) and (not neg) and (a[i] != b[i]):\\n            ok = False\\n            break\\n        if (not pos) and (a[i] < b[i]):\\n            ok = False\\n            break\\n        if (not neg) and (a[i] > b[i]):\\n            ok = False\\n            break\\n        if a[i] < 0:\\n            neg = True\\n        if a[i] > 0:\\n            pos = True\\n    print('YES' if ok else 'NO')\\n\", \"import math\\n\\n\\ndef main():\\n    was = set()\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    b = list(map(int, input().split()))\\n    for i in range(n):\\n        if a[i] - b[i] > 0:\\n            if not -1 in was:\\n                print(\\\"NO\\\")\\n                return\\n        elif a[i] - b[i] < 0:\\n            if not 1 in was:\\n                print(\\\"NO\\\")\\n                return\\n        was.add(a[i])\\n    print(\\\"YES\\\")\\n\\ndef __starting_point():\\n    t = int(input())\\n    for i in range(t):\\n        main()\\n\\n__starting_point()\", \"from bisect import *\\nfrom collections import *\\nfrom itertools import *\\nimport functools\\nimport sys\\nimport math\\nfrom decimal import *\\nfrom copy import *\\nfrom heapq import *\\nfrom fractions import *\\ngetcontext().prec = 30\\nMAX = sys.maxsize\\nMAXN = 300010\\nMOD = 10**9+7\\nspf = [i for i in range(MAXN)]\\nspf[0]=spf[1] = -1\\ndef sieve():\\n    for i in range(2,MAXN,2):\\n        spf[i] = 2\\n    for i in range(3,int(MAXN**0.5)+1):\\n        if spf[i]==i:\\n            for j in range(i*i,MAXN,i):\\n                if spf[j]==j:\\n                    spf[j]=i\\ndef fib(n,m):\\n    if n == 0:\\n        return [0, 1]\\n    else:\\n        a, b = fib(n // 2)\\n        c = ((a%m) * ((b%m) * 2 - (a%m)))%m\\n        d = ((a%m) * (a%m))%m + ((b)%m * (b)%m)%m\\n        if n % 2 == 0:\\n            return [c, d]\\n        else:\\n            return [d, c + d]\\n\\ndef charIN(x= ' '):\\n    return(sys.stdin.readline().strip().split(x))\\n\\ndef arrIN(x = ' '):\\n    return list(map(int,sys.stdin.readline().strip().split(x)))\\n\\ndef ncr(n,r):\\n    num=den=1\\n    for i in range(r):\\n        num = (num*(n-i))%MOD\\n        den = (den*(i+1))%MOD\\n\\n    return (num*(pow(den,MOD-2,MOD)))%MOD\\n\\ndef flush():\\n    return sys.stdout.flush()\\n\\n'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''\\ndef solve():\\n    n = int(input())\\n    a = arrIN()\\n    b = arrIN()\\n    x = [[0,0,0] for i in range(n)]\\n    for i in range(n):\\n        x[i][0] = int(a[i]==-1)\\n        x[i][1] = int(a[i]==0)\\n        x[i][2] = int(a[i]==1)\\n        x[i][0]|=x[i-1][0]\\n        x[i][1]|=x[i-1][1]\\n        x[i][2]|=x[i-1][2]\\n    if a[0]!=b[0]:\\n        print('NO')\\n    else:\\n        for i in range(1,n):\\n            if a[i]!=b[i]:\\n                if a[i]>b[i]:\\n                    if not x[i-1][0]:\\n                        print('NO')\\n                        break\\n                else:\\n                    if not x[i-1][2]:\\n                        print('NO')\\n                        break\\n        else:\\n            print('YES')\\n\\n\\nt = int(input())\\nfor i in range(t):\\n    solve()\\n\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"5\\n3\\n1 -1 0\\n1 1 -2\\n3\\n0 1 1\\n0 2 2\\n2\\n1 0\\n1 41\\n2\\n-1 0\\n-1 -41\\n5\\n0 1 -1 1 -1\\n1 1 -1 1 -1\\n\"\n  ],\n  \"outputs\": [\n    \"YES\\nNO\\nYES\\nYES\\nNO\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1333/B", "starter_code": ""}
{"id": 13, "question": "Your company was appointed to lay new asphalt on the highway of length $n$. You know that every day you can either repair one unit of the highway (lay new asphalt over one unit of the highway) or skip repairing.\n\nSkipping the repair is necessary because of the climate. The climate in your region is periodical: there are $g$ days when the weather is good and if you lay new asphalt these days it becomes high-quality pavement; after that, the weather during the next $b$ days is bad, and if you lay new asphalt these days it becomes low-quality pavement; again $g$ good days, $b$ bad days and so on.\n\nYou can be sure that you start repairing at the start of a good season, in other words, days $1, 2, \\dots, g$ are good.\n\nYou don't really care about the quality of the highway, you just want to make sure that at least half of the highway will have high-quality pavement. For example, if the $n = 5$ then at least $3$ units of the highway should have high quality; if $n = 4$ then at least $2$ units should have high quality.\n\nWhat is the minimum number of days is needed to finish the repair of the whole highway?\n\n\n-----Input-----\n\nThe first line contains a single integer $T$ ($1 \\le T \\le 10^4$) \u2014 the number of test cases.\n\nNext $T$ lines contain test cases \u2014 one per line. Each line contains three integers $n$, $g$ and $b$ ($1 \\le n, g, b \\le 10^9$) \u2014 the length of the highway and the number of good and bad days respectively.\n\n\n-----Output-----\n\nPrint $T$ integers \u2014 one per test case. For each test case, print the minimum number of days required to repair the whole highway if at least half of it should have high quality.\n\n\n-----Example-----\nInput\n3\n5 1 1\n8 10 10\n1000000 1 1000000\n\nOutput\n5\n8\n499999500000\n\n\n\n-----Note-----\n\nIn the first test case, you can just lay new asphalt each day, since days $1, 3, 5$ are good.\n\nIn the second test case, you can also lay new asphalt each day, since days $1$-$8$ are good.", "solutions": "[\"for i in range(int(input())):\\n    n,g,b=map(int,input().split())\\n    nn=(n+1)//2\\n    print(max(nn+(nn-1)//g*b,n))\", \"for _ in range(int(input())):\\n    n, g, b = list(map(int, input().split()))\\n    half = (n - 1) // 2 + 1\\n\\n    ans = (g + b) * (half // g) - b  # + (half % g)\\n    if half % g != 0:\\n        ans += b + half % g\\n    print(max(ans, n))\\n\", \"# import sys\\n#\\n# input = lambda: sys.stdin.readline().strip()\\nfor i in range(int(input())):\\n    n,g, b = list(map(int, input().split()))\\n    n1 = n\\n    n = (n+1)//2\\n    k = n//g\\n    if n%g:\\n        print(max(n1,k*(g+b)+n%g))\\n    else:\\n        print(max(n1,g*k+b*(k-1)))\\n\", \"def iinput():\\n    return [int(x) for x in input().split()]\\n\\n\\ndef main():\\n    n, g, b = iinput()\\n    z = (n + 1) // 2\\n    d = (z - 1) // g\\n    return max(d * b + z, n)\\n\\n\\nfor i in range(int(input())):\\n    print(main())\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\nfor tests in range(t):\\n    n,g,b=list(map(int,input().split()))\\n    ALL=(n+1)//2\\n\\n    ANS=n\\n\\n    week=-(-ALL//g)-1\\n    ANS=max(ANS,week*(g+b)+(ALL-week*g))\\n\\n    print(ANS)\\n\", \"t = int(input())\\nfor q in range(t):\\n    n, g, b = [int(i) for i in input().split()]\\n    num = n\\n    n = n // 2 + n % 2\\n    val = n // g\\n    d = 0\\n    if n % g == 0:\\n        d = (val - 1) * (b + g) + g\\n    else:\\n        d = val * (b + g) + n % g\\n    if d < num:\\n        print(num)\\n    else:\\n        print(d)\\n    \\n\", \"t = int(input())\\n\\ndef check(n, h, g, b, m):\\n    if m < n:\\n        return False\\n    loop, rest = divmod(m, g + b)\\n    ok = min(rest, g) + loop * g\\n    return ok >= h\\n\\nfor _ in range(t):\\n    n,g,b = list(map(int,input().split()))\\n    high = (n + 1) // 2\\n    ok, ng = 10 ** 20, 0\\n    while ok - ng > 1:\\n        mid = (ok + ng) // 2\\n        if check(n, high, g, b, mid):\\n            ok = mid\\n        else:\\n            ng = mid\\n    print(ok)\\n\", \"def solve():\\n    n, g, b = [int(x) for x in input().split()]\\n    l = 0\\n    r = int(1e30)\\n\\n    while r-l > 1:\\n        m = (l+r)//2\\n\\n        blk = m // (g + b)\\n        cnt = blk * g + min(g, m % (g + b))\\n\\n        if cnt >= (n+1)//2:\\n            r = m\\n        else:\\n            l = m\\n    \\n    print(max(r, n))\\n\\nt = int(input())\\nfor _ in range(t):\\n    solve()\", \"import sys\\nimport math\\nfrom collections import defaultdict\\nfrom collections import deque\\nfrom itertools import combinations\\nfrom itertools import permutations\\ninput = lambda : sys.stdin.readline().rstrip()\\nread = lambda : list(map(int, input().split()))\\ngo = lambda : 1/0\\ndef write(*args, sep=\\\"\\\\n\\\"):\\n  for i in args:\\n    sys.stdout.write(\\\"{}{}\\\".format(i, sep))\\nINF = float('inf')\\nMOD = int(1e9 + 7)\\nYES = \\\"YES\\\"\\nNO = \\\"NO\\\"\\n\\nfor _ in range(int(input())):\\n  try:\\n    n, g, b = read()\\n\\n    total = math.ceil(n / 2)  \\n\\n    s = 0\\n    e = 1 << 63\\n    while s <= e:\\n      m = (s + e) // 2\\n      good = 0\\n      bad = 0 \\n\\n      x = m // (g + b)\\n      good += x * g\\n      bad += x * b \\n\\n      y = m - (m // (g + b)) * (g + b)\\n      good += min(y, g)\\n      bad += max(0, y - g)\\n\\n      if good + bad >= n and good >= total:\\n        e = m - 1\\n      else:\\n        s = m + 1\\n    \\n    print(s)\\n\\n\\n\\n    \\n\\n  except ZeroDivisionError:\\n    continue\\n\\n  except Exception as e:\\n    print(e)\\n    continue\", \"for _ in range(int(input())):\\n\\tn,g,b = map(int,input().split())\\n\\torign = n\\n\\tn = (n+1)//2\\n\\tcom = ((n-1)//g)\\n\\tans = com*(g+b)\\n\\tn -= com*g\\n\\tans += n\\n\\tprint(max(ans,orign))\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n5 1 1\\n8 10 10\\n1000000 1 1000000\\n\"\n  ],\n  \"outputs\": [\n    \"5\\n8\\n499999500000\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1303/B", "starter_code": ""}
{"id": 14, "question": "Vasya claims that he had a paper square. He cut it into two rectangular parts using one vertical or horizontal cut. Then Vasya informed you the dimensions of these two rectangular parts. You need to check whether Vasya originally had a square. In other words, check if it is possible to make a square using two given rectangles.\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases in the input. Then $t$ test cases follow.\n\nEach test case is given in two lines.\n\nThe first line contains two integers $a_1$ and $b_1$ ($1 \\le a_1, b_1 \\le 100$) \u2014 the dimensions of the first one obtained after cutting rectangle. The sizes are given in random order (that is, it is not known which of the numbers is the width, and which of the numbers is the length).\n\nThe second line contains two integers $a_2$ and $b_2$ ($1 \\le a_2, b_2 \\le 100$) \u2014 the dimensions of the second obtained after cutting rectangle. The sizes are given in random order (that is, it is not known which of the numbers is the width, and which of the numbers is the length).\n\n\n-----Output-----\n\nPrint $t$ answers, each of which is a string \"YES\" (in the case of a positive answer) or \"NO\" (in the case of a negative answer). The letters in words can be printed in any case (upper or lower).\n\n\n-----Example-----\nInput\n3\n2 3\n3 1\n3 2\n1 3\n3 3\n1 3\n\nOutput\nYes\nYes\nNo", "solutions": "[\"for _ in range(int(input())):\\n    a1, b1 = list(map(int, input().split()))\\n    a2, b2 = list(map(int, input().split()))\\n    if a1 > b1:\\n        a1, b1 = b1, a1\\n    if a2 > b2:\\n        a2, b2 = b2, a2\\n    flag = False\\n    if a1 == a2 and a1 == b1 + b2:\\n        flag = True\\n    if b1 == b2 and b1 == a1 + a2:\\n        flag = True\\n    print('Yes' if flag else 'No')\\n\", \"t = int(input())\\nfor _ in range(t):\\n\\ta1, b1 = map(int, input().split())\\n\\ta2, b2 = map(int, input().split())\\n\\tif a1 > b1:\\n\\t\\ta1, b1 = b1, a1\\n\\tif a2 > b2:\\n\\t\\ta2, b2 = b2, a2\\n\\n\\tif b1 == b2 and a1 + a2 == b1:\\n\\t\\tprint(\\\"Yes\\\")\\n\\telse:\\n\\t\\tprint(\\\"No\\\")\", \"t = int(input())\\nfor case in range(t):\\n    a, b = list(map(int, input().split()))\\n    c, d = list(map(int, input().split()))\\n    if a == c and b + d == a:\\n        print('Yes')\\n    elif b == d and a + c == b:\\n        print('Yes')\\n    elif a == d and b + c == a:\\n        print('Yes')\\n    elif b == c and a + d == b:\\n        print('Yes')\\n    else:\\n        print('No')\", \"import math\\nfor _ in range(int(input())):\\n    a,b=list(map(int,input().split()))\\n    c,d=list(map(int,input().split()))\\n    if min(c,d)+min(a,b)==max(a,b) and max(a,b)==max(c,d):\\n        print(\\\"Yes\\\")\\n    else:\\n        print(\\\"No\\\")\\n\", \"import sys\\n\\n\\n\\nfor t in range(int(sys.stdin.readline())):\\n\\n\\n\\ta, b = list(map(int, sys.stdin.readline().split()))\\n\\tx, y = list(map(int, sys.stdin.readline().split()))\\n\\ta, b = min(a, b), max(a, b)\\n\\tx, y = min(x, y), max(x, y)\\n\\tif b == y and b == a + x:\\n\\t\\tsys.stdout.write(\\\"Yes\\\\n\\\")\\n\\telse:\\n\\t\\tsys.stdout.write(\\\"No\\\\n\\\")\\n\", \"import sys,bisect,string,math,time,functools,random\\nfrom heapq import heappush,heappop,heapify\\nfrom collections import deque,defaultdict,Counter\\nfrom itertools import permutations,combinations,groupby\\ndef Golf():*a,=map(int,open(0))\\ndef I():return int(input())\\ndef S_():return input()\\ndef IS():return input().split()\\ndef LS():return [i for i in input().split()]\\ndef LI():return [int(i) for i in input().split()]\\ndef LI_():return [int(i)-1 for i in input().split()]\\ndef NI(n):return [int(input()) for i in range(n)]\\ndef NI_(n):return [int(input())-1 for i in range(n)]\\ndef StoLI():return [ord(i)-97 for i in input()]\\ndef ItoS(n):return chr(n+97)\\ndef LtoS(ls):return ''.join([chr(i+97) for i in ls])\\ndef GI(V,E,ls=None,Directed=False,index=1):\\n    org_inp=[];g=[[] for i in range(V)]\\n    FromStdin=True if ls==None else False\\n    for i in range(E):\\n        if FromStdin:\\n            inp=LI()\\n            org_inp.append(inp)\\n        else:\\n            inp=ls[i]\\n        if len(inp)==2:\\n            a,b=inp;c=1\\n        else:\\n            a,b,c=inp\\n        if index==1:a-=1;b-=1\\n        aa=(a,c);bb=(b,c);g[a].append(bb)\\n        if not Directed:g[b].append(aa)\\n    return g,org_inp\\ndef GGI(h,w,search=None,replacement_of_found='.',mp_def={'#':1,'.':0},boundary=1):\\n#h,w,g,sg=GGI(h,w,search=['S','G'],replacement_of_found='.',mp_def={'#':1,'.':0}) # sample usage\\n    mp=[boundary]*(w+2);found={}\\n    for i in range(h):\\n        s=input()\\n        for char in search:\\n            if char in s:\\n                found[char]=((i+1)*(w+2)+s.index(char)+1)\\n                mp_def[char]=mp_def[replacement_of_found]\\n        mp+=[boundary]+[mp_def[j] for j in s]+[boundary]\\n    mp+=[boundary]*(w+2)\\n    return h+2,w+2,mp,found\\ndef TI(n):return GI(n,n-1)\\ndef bit_combination(k,n=2):\\n    rt=[]\\n    for tb in range(n**k):\\n        s=[tb//(n**bt)%n for bt in range(k)];rt+=[s]\\n    return rt\\ndef show(*inp,end='\\\\n'):\\n    if show_flg:print(*inp,end=end)\\n\\nYN=['YES','NO'];Yn=['Yes','No']\\nmo=10**9+7\\ninf=float('inf')\\nl_alp=string.ascii_lowercase\\n#sys.setrecursionlimit(10**7)\\ninput=lambda: sys.stdin.readline().rstrip()\\n\\nclass Tree:\\n    def __init__(self,inp_size=None,init=True):\\n        self.LCA_init_stat=False\\n        self.ETtable=[]\\n        if init:\\n            self.stdin(inp_size)\\n        return\\n\\n    def stdin(self,inp_size=None,index=1):\\n        if inp_size==None:\\n            self.size=int(input())\\n        else:\\n            self.size=inp_size\\n        self.edges,_=GI(self.size,self.size-1,index=index)\\n        return\\n    \\n    def listin(self,ls,index=0):\\n        self.size=len(ls)+1\\n        self.edges,_=GI(self.size,self.size-1,ls,index=index)\\n        return\\n\\n    def __str__(self):\\n        return  str(self.edges)\\n\\n    def dfs(self,x,func=lambda prv,nx,dist:prv+dist,root_v=0):\\n        q=deque()\\n        q.append(x)\\n        v=[-1]*self.size\\n        v[x]=root_v\\n        while q:\\n            c=q.pop()\\n            for nb,d in self.edges[c]:\\n                if v[nb]==-1:\\n                    q.append(nb)\\n                    v[nb]=func(v[c],nb,d)\\n        return v\\n\\n    def EulerTour(self,x):\\n        q=deque()\\n        q.append(x)\\n        self.depth=[None]*self.size\\n        self.depth[x]=0\\n        self.ETtable=[]\\n        self.ETdepth=[]\\n        self.ETin=[-1]*self.size\\n        self.ETout=[-1]*self.size\\n        cnt=0\\n        while q:\\n            c=q.pop()\\n            if c<0:\\n                ce=~c\\n            else:\\n                ce=c\\n                for nb,d in self.edges[ce]:\\n                    if self.depth[nb]==None:\\n                        q.append(~ce)\\n                        q.append(nb)\\n                        self.depth[nb]=self.depth[ce]+1\\n            self.ETtable.append(ce)\\n            self.ETdepth.append(self.depth[ce])\\n            if self.ETin[ce]==-1:\\n                self.ETin[ce]=cnt\\n            else:\\n                self.ETout[ce]=cnt\\n            cnt+=1\\n        return\\n    \\n    def LCA_init(self,root):\\n        self.EulerTour(root)\\n        self.st=SparseTable(self.ETdepth,init_func=min,init_idl=inf)\\n        self.LCA_init_stat=True\\n        return\\n    \\n    def LCA(self,root,x,y):\\n        if self.LCA_init_stat==False:\\n            self.LCA_init(root)\\n        xin,xout=self.ETin[x],self.ETout[x]\\n        yin,yout=self.ETin[y],self.ETout[y]\\n        a=min(xin,yin)\\n        b=max(xout,yout,xin,yin)\\n        id_of_min_dep_in_et=self.st.query_id(a,b+1)\\n        return self.ETtable[id_of_min_dep_in_et]\\n\\nclass SparseTable: # O(N log N) for init, O(1) for query(l,r)\\n    def __init__(self,ls,init_func=min,init_idl=float('inf')):\\n        self.func=init_func\\n        self.idl=init_idl\\n        self.size=len(ls)\\n        self.N0=self.size.bit_length()\\n        self.table=[ls[:]]\\n        self.index=[list(range(self.size))]\\n        self.lg=[0]*(self.size+1)\\n        \\n        for i in range(2,self.size+1):\\n            self.lg[i]=self.lg[i>>1]+1\\n\\n        for i in range(self.N0):\\n            tmp=[self.func(self.table[i][j],self.table[i][min(j+(1<<i),self.size-1)]) for j in range(self.size)]\\n            tmp_id=[self.index[i][j] if self.table[i][j]==self.func(self.table[i][j],self.table[i][min(j+(1<<i),self.size-1)]) else self.index[i][min(j+(1<<i),self.size-1)] for j in range(self.size)]\\n            self.table+=[tmp]\\n            self.index+=[tmp_id]\\n    \\n    # return func of [l,r)\\n    def query(self,l,r):\\n        #N=(r-l).bit_length()-1\\n        N=self.lg[r-l]\\n        return self.func(self.table[N][l],self.table[N][r-(1<<N)])\\n    \\n    # return index of which val[i] = func of v among [l,r)\\n    def query_id(self,l,r):\\n        #N=(r-l).bit_length()-1\\n        N=self.lg[r-l]\\n        a,b=self.index[N][l],self.index[N][r-(1<<N)]\\n        if self.table[0][a]==self.func(self.table[N][l],self.table[N][r-(1<<N)]):\\n            b=a\\n        return b\\n    \\n    def __str__(self):\\n        return str(self.table[0])\\n        \\n    def print(self):\\n        for i in self.table:\\n            print(*i)\\n\\nshow_flg=False\\nshow_flg=True\\nans=0\\n\\nT=I()\\nfor _ in range(T):\\n    a,b=LI()\\n    c,d=LI()\\n    if a>b:\\n        a,b=b,a\\n    if c>d:\\n        c,d=d,c\\n    ans='Yes' if b==d and a+c==b else 'No'\\n    print(ans)\\n\\n\", \"q = int(input())\\n\\nfor _ in range(q):\\n    a, b = list(map(int, input().split()))\\n    c, d = list(map(int, input().split()))\\n    a, b = min(a, b), max(a, b)\\n    c, d = min(c, d), max(c, d)\\n    if b == d and a+c == b:\\n        print(\\\"Yes\\\")\\n    else:\\n        print(\\\"No\\\")\\n\\n\", \"t=int(input())\\nfor tests in range(t):\\n    a1,b1=list(map(int,input().split()))\\n    a2,b2=list(map(int,input().split()))\\n\\n    if min(a1,b1)+min(a2,b2)==max(a1,b1)==max(a2,b2):\\n        print(\\\"Yes\\\")\\n    else:\\n        print(\\\"No\\\")\\n\", \"for _ in range(int(input())):\\n    a, b = list(map(int,input().split()))\\n    c, d = list(map(int,input().split()))\\n    if b > a:\\n        a, b = b, a\\n    if d > c:\\n        c, d = d, c\\n    if a == c == b+d:\\n        print(\\\"Yes\\\")\\n    else:\\n        print(\\\"No\\\")\\n\", \"for __ in range(int(input())):\\n\\ta,b=map(int,input().split())\\n\\tx,y=map(int,input().split())\\n\\tif(a==x and b+y==x):\\n\\t\\tprint(\\\"Yes\\\")\\n\\telif(a==y and b+x==y):\\n\\t\\tprint(\\\"Yes\\\")\\n\\telif(b==x and a+y==x):\\n\\t\\tprint(\\\"Yes\\\")\\n\\telif(b==y and a+x==y):\\n\\t\\tprint(\\\"Yes\\\")\\n\\telse:\\n\\t\\tprint(\\\"No\\\")\", \"t=int(input())\\nfor i in range(t):\\n    a,b=list(map(int,input().split()))\\n    c,d=list(map(int,input().split()))\\n    if max(a,b)==max(c,d):\\n        if min(a,b)+min(c,d)==max(a,b):\\n            print(\\\"Yes\\\")\\n        else:\\n            print(\\\"No\\\")\\n    else:\\n        print(\\\"No\\\")\\n\", \"t = int(input())\\nfor i in range(t):\\n    a, b = list(map(int, input().split()))\\n    c, d = list(map(int, input().split()))\\n    if a + c == b == d or a + d == b == c or b + c == a == d or b + d == a == c:\\n        print(\\\"Yes\\\")\\n    else:\\n        print(\\\"No\\\")\", \"for n in range(int(input())):\\n\\ta,b=map(int,input().split())\\n\\tc,d=map(int,input().split())\\n\\tm1=max(a,b)\\n\\tn1=min(a,b)\\n\\tm2=max(c,d)\\n\\tn2=min(c,d)\\n\\tif m1==m2 and n1+n2==m1:\\n\\t\\tprint('Yes')\\n\\telse:\\n\\t\\tprint('No')\", \"a=int(input())\\nfor i in range(a):\\n    x,y=list(map(int,input().split()))\\n    r,s=list(map(int,input().split()))\\n    if(x==s and y+r==s):\\n        print('Yes')\\n    elif(x==r and y+s==x):\\n        print('Yes')\\n    elif(y==s and x+r==y):\\n        print('Yes')\\n    elif(y==r and x+s==y):\\n        print('Yes')\\n    else:\\n        print('No')\\n\", \"from sys import stdin, exit\\ninput = stdin.readline\\n\\ndef i(): return input()\\ndef ii(): return int(input())\\ndef iis(): return list(map(int, input().split()))\\ndef liis():\\treturn list(map(int, input().split()))\\ndef print_array(a): print(\\\" \\\".join(map(str, a)))\\n\\nt = ii()\\nfor _ in range(t):\\n\\ta1, b1 = iis()\\t\\n\\ta2, b2 = iis()\\n\\tif (a1 == a2 and b1+b2 == a1) or (a1 == b2 and a2+b1 == a1) or (a2 == b1 and a1+b2 == a2) or (b2 == b1 and a1+a2 == b2):\\n\\t\\tprint(\\\"Yes\\\")\\n\\telse:\\n\\t\\tprint(\\\"No\\\")\\n\", \"T = int(input())\\n\\nfor t in range(T):\\n  i1 = [int(i) for i in input().split(' ')]\\n  i2 = [int(i) for i in input().split(' ')]\\n  if i1[0]==i2[0] and i1[1]+i2[1]==i1[0]:\\n    print('Yes')\\n  elif i1[0]==i2[1] and i1[1]+i2[0]==i1[0]:\\n    print('Yes')\\n  elif i1[1]==i2[0] and i1[0]+i2[1]==i1[1]:\\n    print('Yes')\\n  elif i1[1]==i2[1] and i1[0]+i2[0]==i1[1]:\\n    print('Yes')\\n  else:\\n    print('No')\\n\", \"def read_int():\\n    return int(input())\\n\\n\\ndef read_ints():\\n    return list(map(int, input().split(' ')))\\n\\n\\nt = read_int()\\nfor case_num in range(t):\\n    a = list(read_ints())\\n    b = list(read_ints())\\n    ok = False\\n    for i in range(2):\\n        for j in range(2):\\n            if a[i] != b[j]:\\n                continue\\n            if a[1 - i] + b[1 - j] == a[i]:\\n                ok = True\\n    print('Yes' if ok else 'No')\\n\", \"q = int(input())\\nfor i in range(q):\\n    a1, b1 = map(int, input().split())\\n    a2, b2 = map(int, input().split())\\n    if max(a1, b1) == max(a2, b2) == (min(a1, b1) + min(a2, b2)):\\n        print('Yes')\\n    else:\\n        print('No')\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n2 3\\n3 1\\n3 2\\n1 3\\n3 3\\n1 3\\n\"\n  ],\n  \"outputs\": [\n    \"Yes\\nYes\\nNo\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1351/B", "starter_code": ""}
{"id": 15, "question": "Screen resolution of Polycarp's monitor is $a \\times b$ pixels. Unfortunately, there is one dead pixel at his screen. It has coordinates $(x, y)$ ($0 \\le x < a, 0 \\le y < b$). You can consider columns of pixels to be numbered from $0$ to $a-1$, and rows\u00a0\u2014 from $0$ to $b-1$.\n\nPolycarp wants to open a rectangular window of maximal size, which doesn't contain the dead pixel. The boundaries of the window should be parallel to the sides of the screen.\n\nPrint the maximal area (in pixels) of a window that doesn't contain the dead pixel inside itself.\n\n\n-----Input-----\n\nIn the first line you are given an integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases in the test. In the next lines you are given descriptions of $t$ test cases.\n\nEach test case contains a single line which consists of $4$ integers $a, b, x$ and $y$ ($1 \\le a, b \\le 10^4$; $0 \\le x < a$; $0 \\le y < b$)\u00a0\u2014 the resolution of the screen and the coordinates of a dead pixel. It is guaranteed that $a+b>2$ (e.g. $a=b=1$ is impossible).\n\n\n-----Output-----\n\nPrint $t$ integers\u00a0\u2014 the answers for each test case. Each answer should contain an integer equal to the maximal possible area (in pixels) of a rectangular window, that doesn't contain the dead pixel.\n\n\n-----Example-----\nInput\n6\n8 8 0 0\n1 10 0 3\n17 31 10 4\n2 1 0 0\n5 10 3 9\n10 10 4 8\n\nOutput\n56\n6\n442\n1\n45\n80\n\n\n\n-----Note-----\n\nIn the first test case, the screen resolution is $8 \\times 8$, and the upper left pixel is a dead pixel. Here you can see one of two possible layouts of the maximal window. [Image]", "solutions": "[\"from math import *\\n\\nzzz = int(input())\\nfor zz in range(zzz):\\n    a, b, x, y = list(map(int, input().split()))\\n    print(max(x*b, (a-x-1)*b, y*a, (b - y - 1)*a))\\n\", \"for t in range(int(input())):\\n    a, b, x, y = [int(i) for i in input().split()]\\n    l = max(x, a - 1 - x)\\n    h = max(y, b - 1 - y)\\n    print(max(l * b, h * a))\\n\", \"for _ in range(int(input())):\\n    a, b, x, y = list(map(int, input().split()))\\n    num1 = x * b\\n    num2 = y * a\\n    num3 = (a - x - 1) * b\\n    num4 = (b - y - 1) * a\\n    print(max(num2, num1, num3, num4))\", \"for _ in range(int(input())):\\n    a, b, x, y = map(int, input().split())\\n    w = max(a-1-x, x)\\n    h = max(b-1-y, y)\\n\\n    ans = max(w * b, h * a)\\n    print(ans)\", \"for _ in range(int(input())):\\n    a, b, x, y = list(map(int, input().split()))\\n    print(max(x*b, y*a, (a-x-1)*b, (b-y-1)*a))\\n\", \"t = int(input())\\nfor _ in range(t):\\n\\ta, b, x, y = map(int, input().split())\\n\\tr = max([a*y, a*(b-y-1), b*x, b*(a-x-1)])\\n\\tprint(r)\", \"t = int(input())\\nfor _ in range(t):\\n    a, b, x, y = list(map(int, input().split()))\\n    print(max(a*y, a*(b-y-1), x*b, (a-x-1)*b))\\n\", \"t = int(input())\\nfor _ in range(t):\\n\\ta, b, x, y = map(int, input().split())\\n\\n\\tl = max(a*y, a*(b-y-1))\\n\\tll = max(b*x, b*(a-x-1))\\n\\tprint(max(l, ll))\", \"import sys\\ninput = sys.stdin.readline\\nfor k in range(int(input())):\\n    a, b, x, y = list(map(int, input().split(\\\" \\\")))\\n    print(max(a*y, b*x, (b-1-y)*a, (a-1-x)*b)) \\n\", \"import sys\\ninput = sys.stdin.readline\\nt = int(input())\\nfor _ in range(t):\\n  h,w,x,y = map(int,input().split())\\n  can = [h*y,h*(w-1-y),w*x,w*(h-1-x)]\\n  print(max(can))\", \"t = int(input())\\nfor _ in range(t):\\n  n,m,a,b = map(int,input().split())\\n  print(max(max(a,n-a-1)*m,max(b,m-b-1)*n))\", \"# from collections import deque\\nimport sys\\ninput = lambda: sys.stdin.readline().strip()\\nfor i in range(int(input())):\\n    a,b,x,y = map(int,input().split())\\n    print(max(a*y,b*x,a*(b-y-1),b*(a-x-1)))\", \"for _ in range(int(input())):\\n    n,m,x,y=map(int,input().split())\\n    s=0\\n    s=max(s,x*m)\\n    s=max(s,(n-x-1)*m)\\n    s=max(s,y*n)\\n    s=max(s,(m-y-1)*n)\\n    print(s)\", \"t = int(input())\\nfor i in range(t):\\n    a, b, x, y = list(map(int, input().split()))\\n    print(max(x * b, y * a, (a - x - 1) * b, (b - y - 1) * a))\\n\", \"t = int(input())\\nfor _ in range(t):\\n    a,b,x,y = map(int, input().split())\\n    print(max([x*b,(a-x-1)*b,a*y,a*(b-y-1)]))\", \"from math import *\\nfrom collections import *\\nt = int(input())\\nfor y in range(t):\\n\\ta,b,x,y = map(int,input().split())\\n\\tl = max(x,a-x-1)\\n\\tw = max(y,b-y-1)\\n\\tprint(max(l*b,a*w))\", \"import sys\\nimport math\\nfrom collections import defaultdict\\nfrom collections import deque\\nfrom itertools import combinations\\nfrom itertools import permutations\\ninput = lambda : sys.stdin.readline().rstrip()\\nread = lambda : list(map(int, input().split()))\\ngo = lambda : 1/0\\ndef write(*args, sep=\\\"\\\\n\\\"):\\n  for i in args:\\n    sys.stdout.write(\\\"{}{}\\\".format(i, sep))\\nINF = float('inf')\\nMOD = int(1e9 + 7)\\nYES = \\\"YES\\\"\\nNO = \\\"NO\\\"\\n\\nfor _ in range(int(input())):\\n  try:\\n    a, b, x, y = read()\\n    up = y * a\\n    down = (b - y - 1) * a\\n    left = x * b\\n    right = (a - x - 1) * b \\n\\n    print(max([up, down, left, right]))\\n\\n  except ZeroDivisionError:\\n    continue\\n\\n  except Exception as e:\\n    print(e)\\n    continue\", \"TC = int(input())\\n\\nfor _ in range(TC):\\n    a, b, x, y = list(map(int, input().split()))\\n    print((max(\\n        y * a,\\n        x * b,\\n        (b - y - 1) * a,\\n        (a - x - 1) * b\\n    )))\\n\\n\\n\\n\", \"for nt in range(int(input())):\\n\\ta,b,x,y=map(int,input().split())\\n\\ta1=max(x,0)*b\\n\\ta2=(a-x-1)*b\\n\\ta3=(y)*a\\n\\ta4=(b-y-1)*a\\n\\tprint (max(a1,a2,a3,a4))\", \"def main(a, b, x, y):\\n\\tsol = max(max(x, a-x-1)*b, max(y, b-y-1)*a)\\n\\tprint(sol)\\n\\nn = int(input())\\nfor _ in range(n):\\n\\tlst = list(map(int, input().split()))\\n\\ta, b, x, y = lst[0], lst[1], lst[2], lst[3]\\n\\tmain(a, b, x, y)\\n\", \"t=int(input())\\nfor i in range(t):\\n    a,b,x,y=list(map(int,input().split()))\\n    r = [a*y, b*x, a*(b-y-1), b*(a-x-1)]\\n    print(max(r))\\n\", \"t = int(input())\\nwhile t:\\n    t += -1\\n    a, b, x, y = map(int, input().split())\\n    a1 = b * x\\n    a2 = a * y\\n    a3 = b * (a - x - 1)\\n    a4 = a * (b - y - 1)\\n    print(max(a1, a2, a3, a4))\", \"from sys import stdin,stderr\\ndef rl():\\n    return [int(w) for w in stdin.readline().split()]\\n\\nt, = rl()\\nfor _ in range(t):\\n    a,b,x,y = rl()\\n    print(max(x*b,y*a,(a-x-1)*b,(b-y-1)*a))\\n\", \"t = int(input())\\nfor _ in range(t):\\n    a, b, x, y = list(map(int, input().split()))\\n    h = max(a-x-1, x) * b\\n    v = max(b-y-1, y) * a\\n    print(max(h, v))\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\n\\ndef main():\\n    t = int(input())\\n    for _ in range(t):\\n        A, B, X, Y = [int(x) for x in input().split()]\\n        ma = 0\\n        ma = max(X * B, ma)\\n        ma = max(Y * A, ma)\\n        ma = max((A - X - 1) * B, ma)\\n        ma = max((B - Y - 1) * A, ma)\\n\\n        print(ma)\\n\\n\\n        \\n        \\n    \\n\\ndef __starting_point():\\n    main()\\n\\n\\n\\n__starting_point()\", \"t = int(input())\\nwhile t:\\n    t -= 1\\n    a, b, x, y = list(map(int, input().split()))\\n    area1 = a * y\\n    area2 = x * b\\n    area3 = (a - 1 - x) * b\\n    area4 = a * (b - 1 - y)\\n    print(max(area1, area2, area3, area4))\\n\", \"for _ in range(int(input())):\\n    a,b,x,y = map(int,input().split())\\n    total = a*b\\n    left = x*b\\n    right = total - left - b\\n    down = a*y\\n    up = total - down - a\\n    print( max( left, right, down, up ) )\", \"for i in range(int(input())):\\n    a, b, x, y = list(map(int, input().split()))\\n    print(max(a*max(y, b-y-1), b*max(x, a-x-1)))\\n\", \"#! /usr/bin/env python\\n# -*- coding: utf-8 -*-\\n# vim:fenc=tf-8\\n#\\n\\n\\\"\\\"\\\"\\n\\\"\\\"\\\"\\n\\nfrom operator import itemgetter\\nfrom collections import Counter\\n\\ndef solve(a, b, x, y):\\n    area1 = x*b\\n    area2 = (a-x-1)*b\\n    area3 = a*y\\n    area4 = a*(b-y-1)\\n    print(max(area1,area2,area3,area4))\\n\\n\\ndef main():\\n    t= int(input())\\n    for i in range(t):\\n        a, b, x, y = map(int,input().split())\\n        solve(a, b, x, y)\\n\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\"]", "input_output": "{\n  \"inputs\": [\n    \"6\\n8 8 0 0\\n1 10 0 3\\n17 31 10 4\\n2 1 0 0\\n5 10 3 9\\n10 10 4 8\\n\"\n  ],\n  \"outputs\": [\n    \"56\\n6\\n442\\n1\\n45\\n80\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1315/A", "starter_code": ""}
{"id": 16, "question": "Polycarp, Arkady's friend, prepares to the programming competition and decides to write a contest. The contest consists of $n$ problems and lasts for $T$ minutes. Each of the problems is defined by two positive integers $a_i$ and $p_i$\u00a0\u2014 its difficulty and the score awarded by its solution.\n\nPolycarp's experience suggests that his skill level is defined with positive real value $s$, and initially $s=1.0$. To solve the $i$-th problem Polycarp needs $a_i/s$ minutes.\n\nPolycarp loves to watch series, and before solving each of the problems he will definitely watch one episode. After Polycarp watches an episode, his skill decreases by $10\\%$, that is skill level $s$ decreases to $0.9s$. Each episode takes exactly $10$ minutes to watch. When Polycarp decides to solve some problem, he firstly has to watch one episode, and only then he starts solving the problem without breaks for $a_i/s$ minutes, where $s$ is his current skill level. In calculation of $a_i/s$ no rounding is performed, only division of integer value $a_i$ by real value $s$ happens.\n\nAlso, Polycarp can train for some time. If he trains for $t$ minutes, he increases his skill by $C \\cdot t$, where $C$ is some given positive real constant. Polycarp can train only before solving any problem (and before watching series). Duration of the training can be arbitrary real value.\n\nPolycarp is interested: what is the largest score he can get in the contest? It is allowed to solve problems in any order, while training is only allowed before solving the first problem.\n\n\n-----Input-----\n\nThe first line contains one integer $tc$ ($1 \\le tc \\le 20$)\u00a0\u2014 the number of test cases. Then $tc$ test cases follow.\n\nThe first line of each test contains one integer $n$ ($1 \\le n \\le 100$)\u00a0\u2014 the number of problems in the contest.\n\nThe second line of the test contains two real values $C, T$ ($0 < C < 10$, $0 \\le T \\le 2 \\cdot 10^5$), where $C$ defines the efficiency of the training and $T$ is the duration of the contest in minutes. Value $C, T$ are given exactly with three digits after the decimal point.\n\nEach of the next $n$ lines of the test contain characteristics of the corresponding problem: two integers $a_i, p_i$ ($1 \\le a_i \\le 10^4$, $1 \\le p_i \\le 10$)\u00a0\u2014 the difficulty and the score of the problem.\n\nIt is guaranteed that the value of $T$ is such that changing it by the $0.001$ in any direction will not change the test answer.\n\nPlease note that in hacks you can only use $tc = 1$.\n\n\n-----Output-----\n\nPrint $tc$ integers\u00a0\u2014 the maximum possible score in each test case.\n\n\n-----Examples-----\nInput\n2\n4\n1.000 31.000\n12 3\n20 6\n30 1\n5 1\n3\n1.000 30.000\n1 10\n10 10\n20 8\n\nOutput\n7\n20\n\n\n\n-----Note-----\n\nIn the first example, Polycarp can get score of $7$ as follows:  Firstly he trains for $4$ minutes, increasing $s$ to the value of $5$;  Then he decides to solve $4$-th problem: he watches one episode in $10$ minutes, his skill level decreases to $s=5*0.9=4.5$ and then he solves the problem in $5/s=5/4.5$, which is roughly $1.111$ minutes;  Finally, he decides to solve $2$-nd problem: he watches one episode in $10$ minutes, his skill level decreases to $s=4.5*0.9=4.05$ and then he solves the problem in $20/s=20/4.05$, which is roughly $4.938$ minutes. \n\nThis way, Polycarp uses roughly $4+10+1.111+10+4.938=30.049$ minutes, to get score of $7$ points. It is not possible to achieve larger score in $31$ minutes.\n\nIn the second example, Polycarp can get $20$ points as follows:  Firstly he trains for $4$ minutes, increasing $s$ to the value of $5$;  Then he decides to solve $1$-st problem: he watches one episode in $10$ minutes, his skill decreases to $s=5*0.9=4.5$ and then he solves problem in $1/s=1/4.5$, which is roughly $0.222$ minutes.  Finally, he decides to solve $2$-nd problem: he watches one episode in $10$ minutes, his skill decreases to $s=4.5*0.9=4.05$ and then he solves the problem in $10/s=10/4.05$, which is roughly $2.469$ minutes. \n\nThis way, Polycarp gets score of $20$ in $4+10+0.222+10+2.469=26.691$ minutes. It is not possible to achieve larger score in $30$ minutes.", "solutions": "[\"from math import sqrt\\nclass pro(object):\\n    def __init__(self,dif,sc):\\n        self.dif=dif\\n        self.sc=sc\\n\\n    def __lt__(self,other):\\n        return self.dif>other.dif\\n\\nT=int(input())\\nmul=[1]\\nfor i in range(100):\\n    mul.append(mul[i]*10/9)\\ninf=1000000007\\nfor t in range(T):\\n    n=int(input())\\n    effi,tim=list(map(float,input().split()))\\n    prob=[]\\n    for i in range(n):\\n        x,y=list(map(int,input().split()))\\n        prob.append(pro(x,y))\\n    prob.sort()\\n    f=[[inf for i in range(n+1)] for j in range(1001)]\\n    f[0][0]=0\\n    totsc=0\\n    for i in range(n):\\n        totsc+=prob[i].sc\\n        for j in range(totsc,prob[i].sc-1,-1):\\n            for k in range(1,i+2):\\n                f[j][k]=min(f[j][k],f[j-prob[i].sc][k-1]+prob[i].dif*mul[k])\\n    for i in range(totsc,-1,-1):\\n        flag=False\\n        for j in range(n+1):\\n            if sqrt(effi*f[i][j])>=1:\\n                res=2*sqrt(f[i][j]/effi)-1/effi+10*j\\n            else:\\n                res=f[i][j]+10*j\\n            if res<=tim:\\n                print(i)\\n                flag=True\\n                break\\n        if flag==True:\\n            break\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"2\\n4\\n1.000 31.000\\n12 3\\n20 6\\n30 1\\n5 1\\n3\\n1.000 30.000\\n1 10\\n10 10\\n20 8\\n\"\n  ],\n  \"outputs\": [\n    \"7\\n20\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1056/F", "starter_code": ""}
{"id": 17, "question": "You are given an array $a_1, a_2 \\dots a_n$. Calculate the number of tuples $(i, j, k, l)$ such that:   $1 \\le i < j < k < l \\le n$;  $a_i = a_k$ and $a_j = a_l$; \n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 100$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($4 \\le n \\le 3000$)\u00a0\u2014 the size of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$)\u00a0\u2014 the array $a$.\n\nIt's guaranteed that the sum of $n$ in one test doesn't exceed $3000$.\n\n\n-----Output-----\n\nFor each test case, print the number of described tuples.\n\n\n-----Example-----\nInput\n2\n5\n2 2 2 2 2\n6\n1 3 3 1 2 3\n\nOutput\n5\n2\n\n\n\n-----Note-----\n\nIn the first test case, for any four indices $i < j < k < l$ are valid, so the answer is the number of tuples.\n\nIn the second test case, there are $2$ valid tuples:   $(1, 2, 4, 6)$: $a_1 = a_4$ and $a_2 = a_6$;  $(1, 3, 4, 6)$: $a_1 = a_4$ and $a_3 = a_6$.", "solutions": "[\"class BIT():\\n    def __init__(self,n):\\n        self.BIT=[0]*(n+1)\\n        self.num=n\\n\\n    def query(self,idx):\\n        res_sum = 0\\n        while idx > 0:\\n            res_sum += self.BIT[idx]\\n            idx -= idx&(-idx)\\n        return res_sum\\n\\n    #Ai += x O(logN)\\n    def update(self,idx,x):\\n        while idx <= self.num:\\n            self.BIT[idx] += x\\n            idx += idx&(-idx)\\n        return\\n\\nimport sys,random\\n\\ninput=sys.stdin.readline\\n\\nfor _ in range(int(input())):\\n    n=int(input())\\n    a=list(map(int,input().split()))\\n    pair=[[] for i in range(n+1)]\\n    for i in range(n):\\n        for j in range(i+1,n):\\n            if a[i]==a[j]:\\n                pair[i+1].append(j+1)\\n\\n    bit=BIT(n)\\n    ans=0\\n    for i in range(1,n+1):\\n        minus=bit.query(i)\\n        for r in pair[i]:\\n            ans+=bit.query(r-1)-minus\\n        for r in pair[i]:\\n            bit.update(r,1)\\n\\n    print(ans)\\n    \\n\", \"\\nfrom sys import stdin\\n\\ntt = int(stdin.readline())\\n\\nfor loop in range(tt):\\n\\n    n = int(stdin.readline())\\n    a = list(map(int,stdin.readline().split()))\\n\\n    l = [0] * (n+1)\\n    ans = 0\\n\\n    for j in range(n):\\n        r = [0] * (n+1)\\n        for k in range(n-1,j,-1):\\n            ans += l[a[k]] * r[a[j]]\\n            r[a[k]] += 1\\n        l[a[j]] += 1\\n\\n    print (ans)\\n            \\n    \\n\", \"def calcCntAtPrefix(a):\\n    cntAtPrefix = [[0] * (len(a) + 1)]\\n    for i, x in enumerate(a):\\n        cntAtPrefix.append(cntAtPrefix[-1][:])\\n        cntAtPrefix[-1][x] += 1\\n    return cntAtPrefix\\n\\ndef solve():\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n\\n    cntAtPrefix = calcCntAtPrefix(a)\\n    cntAtSuffix = calcCntAtPrefix(a[::-1])\\n\\n    ans = 0\\n    for j in range(n):\\n        for k in range(j + 1, n):\\n            ans += cntAtPrefix[j][a[k]] * cntAtSuffix[n - 1 - k][a[j]]\\n    print(ans)\\n\\nfor t in range(int(input())):\\n    solve()\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    d = [[0] * n for _ in range(n)]\\n    for i in range(n):\\n        for j in range(i + 1, n):\\n            if a[i] == a[j]:\\n                d[i][j] = 1\\n    for i in range(n):\\n        for j in range(n - 1):\\n            d[i][j + 1] += d[i][j]\\n    for i in range(n - 1):\\n        for j in range(n):\\n            d[i + 1][j] += d[i][j]\\n    ans = 0\\n    for i in range(n):\\n        for j in range(i + 1, n):\\n            if a[i] == a[j]:\\n                ans += d[j - 1][n - 1] - d[j - 1][j] - d[i][n - 1] + d[i][j]\\n    print(ans)\", \"import sys\\n\\nsys.setrecursionlimit(10 ** 5)\\nint1 = lambda x: int(x) - 1\\np2D = lambda x: print(*x, sep=\\\"\\\\n\\\")\\ndef II(): return int(sys.stdin.readline())\\ndef MI(): return map(int, sys.stdin.readline().split())\\ndef LI(): return list(map(int, sys.stdin.readline().split()))\\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\\ndef SI(): return sys.stdin.readline()[:-1]\\n\\nfor _ in range(II()):\\n    n=II()\\n    aa=LI1()\\n    cnt=[0]*n\\n    ans=0\\n    for i,a in enumerate(aa):\\n        cur=0\\n        for a2 in aa[i+1:]:\\n            if a2==a:ans+=cur\\n            cur+=cnt[a2]\\n        cnt[a]+=1\\n    print(ans)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"2\\n5\\n2 2 2 2 2\\n6\\n1 3 3 1 2 3\\n\"\n  ],\n  \"outputs\": [\n    \"5\\n2\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1400/D", "starter_code": ""}
{"id": 18, "question": "The statement of this problem is the same as the statement of problem C2. The only difference is that, in problem C1, $n$ is always even, and in C2, $n$ is always odd.\n\nYou are given a regular polygon with $2 \\cdot n$ vertices (it's convex and has equal sides and equal angles) and all its sides have length $1$. Let's name it as $2n$-gon.\n\nYour task is to find the square of the minimum size such that you can embed $2n$-gon in the square. Embedding $2n$-gon in the square means that you need to place $2n$-gon in the square in such way that each point which lies inside or on a border of $2n$-gon should also lie inside or on a border of the square.\n\nYou can rotate $2n$-gon and/or the square.\n\n\n-----Input-----\n\nThe first line contains a single integer $T$ ($1 \\le T \\le 200$)\u00a0\u2014 the number of test cases.\n\nNext $T$ lines contain descriptions of test cases\u00a0\u2014 one per line. Each line contains single even integer $n$ ($2 \\le n \\le 200$). Don't forget you need to embed $2n$-gon, not an $n$-gon.\n\n\n-----Output-----\n\nPrint $T$ real numbers\u00a0\u2014 one per test case. For each test case, print the minimum length of a side of the square $2n$-gon can be embedded in. Your answer will be considered correct if its absolute or relative error doesn't exceed $10^{-6}$.\n\n\n-----Example-----\nInput\n3\n2\n4\n200\n\nOutput\n1.000000000\n2.414213562\n127.321336469", "solutions": "[\"import math\\n\\nT = int(input())\\nfor _ in range(T):\\n    n = int(input())\\n    print(1/math.tan(math.pi/2/n))\\n\", \"t=int(input())\\nimport math as m\\nwhile t:\\n    t-=1\\n    a=int(input())\\n    print(1/(m.tan(m.pi/(2*a))))\\n\", \"import sys\\nimport math\\n\\nreadline = sys.stdin.readline\\nread = sys.stdin.read\\nns = lambda: readline().rstrip()\\nni = lambda: int(readline().rstrip())\\nnm = lambda: map(int, readline().split())\\nnl = lambda: list(map(int, readline().split()))\\nprn = lambda x: print(*x, sep='\\\\n')\\n\\ndef solve():\\n    n = ni()\\n    print(1 / math.tan(math.pi / (2 * n)))\\n    return\\n\\n\\n# solve()\\n\\nT = ni()\\nfor _ in range(T):\\n    solve()\\n\", \"#                                               |\\n#   _` |  __ \\\\    _` |   __|   _ \\\\   __ \\\\    _` |   _` |\\n#  (   |  |   |  (   |  (     (   |  |   |  (   |  (   |\\n# \\\\__,_| _|  _| \\\\__,_| \\\\___| \\\\___/  _|  _| \\\\__,_| \\\\__,_|\\n\\nimport sys\\nimport math\\nimport operator as op\\nfrom functools import reduce\\n\\ndef read_line():\\n\\treturn sys.stdin.readline()[:-1]\\n \\ndef read_int():\\n\\treturn int(sys.stdin.readline())\\n\\t\\ndef read_int_line():\\n\\treturn [int(v) for v in sys.stdin.readline().split()]\\n\\ndef read_float_line():\\n\\treturn [float(v) for v in sys.stdin.readline().split()]\\n\\ndef ncr(n, r):\\n    r = min(r, n-r)\\n    numer = reduce(op.mul, range(n, n-r, -1), 1)\\n    denom = reduce(op.mul, range(1, r+1), 1)\\n    return numer / denom\\n\\ndef rad(x):\\n\\treturn math.pi*x/180\\n\\nt = read_int()\\nfor i in range(t):\\n\\tn = read_int()\\n\\tans = 1/(math.tan(rad(180/(2*n))))\\n\\tprint(ans)\", \"import math\\n\\ndef sqare_size(n):\\n    return 1/math.tan(math.pi/(2*n))\\n\\nt = int(input())\\nfor _ in range(t):\\n    print(sqare_size(int(input())))\\n\", \"from math import *\\n\\nt = int(input())\\nfor case in range(t):\\n    n = int(input())\\n    print(1/(tan(pi/(2*n))))\\n\", \"import sys\\nimport math\\n\\ninput = sys.stdin.readline\\nflush = sys.stdout.flush\\n\\nfor _ in range(int(input())):\\n\\tn = int(input())\\n\\tprint(1.0 / math.tan(math.pi / (2.0 * n)))\\n\", \"\\\"\\\"\\\"\\narr = list(map(int, input().split()))\\nn,k=map(int, input().split())\\n\\\"\\\"\\\"\\nimport math\\nimport sys\\n# input = sys.stdin.readline\\n\\n############ ---- Input Functions ---- ############\\ndef inp():\\n    return(int(input()))\\ndef inlt():\\n    return(list(map(int,input().split())))\\ndef insr():\\n    s = input()\\n    return(list(s[:len(s) - 1]))\\ndef invr():\\n    return(list(map(int,input().split())))\\n\\ntest_cases = int(input())\\nfor _ in range(test_cases):\\n    sides = int(input())\\n    sides *= 2\\n    apothem = 1 / (2 * math.tan((180 / sides) * (math.pi/180)))   \\n    print(2 * apothem)\\n# for _ in range(test_cases):\\n#     size = int(input())\\n#     arr = inlt()\\n#     maxx = -float('inf')\\n#     temp = []\\n#     max_diff = 0\\n#     #Checks the maximum number and difference of decreasing numbers, the moment it increases again, it rechecks for a bigger difference\\n#     for i in range(size):\\n#         if arr[i] < maxx:\\n#             max_diff = max(max_diff, maxx - arr[i])\\n#         maxx = max(arr[i], maxx)\\n#     i = 0\\n#     index = 0\\n#     while i < max_diff:\\n#         i += 2 ** index\\n#         index += 1\\n#     print(index)\\n\", \"import math\\nT = int(input())\\nfor i in range(T):\\n    x = 2*int(input())\\n    print(1/math.tan(math.pi/x))\\n\", \"from math import cos, pi, sin\\n\\nfor _ in range(int(input())):\\n    n = int(input())\\n    alpha = pi / (n * 2)\\n    print(cos(alpha) / sin(alpha))\\n\", \"from math import tan, pi\\nfor _ in range(int(input())):\\n    n = int(input())\\n    n *= 2\\n    print(1/tan(pi/n))\\n\", \"import math\\nimport sys\\n\\n#sys.stdin = open(\\\"in.txt\\\")\\n\\nt = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    n *= 2\\n    a = (n - 2) * math.pi / n / 2\\n    r = 1/2 * math.tan(a)\\n    print(2*r)\\n\", \"import math\\nimport sys\\ninput = sys.stdin.readline\\n\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    theta = 2 * n\\n    print(1 / math.tan(math.radians(360 / 4 / n)))\", \"from math import sin, pi\\n\\nn = int(input())\\n\\ndef f(a, b):\\n    return sin((b * pi) / a) / sin(pi / a)\\n\\nfor _ in range(n):\\n    m = int(input())\\n    if m % 2 == 0:\\n        print(\\\"%.12f\\\" % f(2 * m, m - 1))\\n    else:\\n        print(\\\"%.12f\\\" % f(2 * m, m))\\n\", \"from math import*\\nfor _ in range(int(input())):\\n  n=int(input())\\n  if n%2==0:\\n    print(1/tan(radians(90/n)))\", \"from math import sin, pi, sqrt, tan\\n\\n\\ndef read_int():\\n    return int(input())\\n\\n\\ndef read_ints():\\n    return list(map(int, input().split(' ')))\\n\\n\\nt = read_int()\\nfor case_num in range(t):\\n    n = read_int()\\n    angle = pi / n / 2\\n    r = 1 / tan(angle)\\n    print('{:.9f}'.format(r))\\n\", \"import math\\n\\nimport sys\\ninput = sys.stdin.readline\\n\\nQ = int(input())\\nQuery = [int(input()) for _ in range(Q)]\\n\\nfor N in Query:\\n    if N%2 == 0:\\n        print(1/math.tan(math.pi/(N*2)))\", \"import math\\nt = int(input())\\nfor i in range(0,t):\\n    a = int(input())\\n    pi = math.pi\\n    print(round(1/math.tan(pi/(2*(a))),9))\\n\", \"from math import cos,sin,pi\\nt = int(input())\\nfor test in range(t):\\n    n = int(input())\\n    if n == 2:\\n        print(1.)\\n    else:\\n        print(sin(pi/n)/(1-cos(pi/n)))\", \"import math\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    print(1/math.tan(math.pi/(2*n)))\\n\", \"import random\\nimport math\\nLI = lambda: list(map(int,input().split()))\\nMI = lambda: map(int,input().split())\\nyes = lambda: print(\\\"Yes\\\")\\nno = lambda: print(\\\"No\\\")\\nI = lambda: list(input())\\nJ = lambda x: \\\"\\\".join(x)\\nII = lambda: int(input())\\nSI = lambda: input()\\n#---khan17---template\\nt = II()\\nfor q in range(t):\\n\\tn = II()\\n\\tR = 1/(2*math.sin(math.pi/(2*n)))\\n\\tr = math.sqrt(R**2-0.25)\\n\\tprint(2*r)\", \"mod = 1000000007\\neps = 10**-9\\n\\n\\ndef main():\\n    import sys\\n    from math import sin, pi, cos\\n    input = sys.stdin.readline\\n\\n    for _ in range(int(input())):\\n        N = int(input())\\n        NN = N*2\\n\\n        print(cos(pi / NN) / sin(pi / NN))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import math\\nt = int(input())\\n\\n\\nfor ti in range(t):\\n\\tn = int(input())\\n\\t# n is even\\n\\t# if n == 2:\\n\\t# \\tprint(1)\\n\\ta = math.pi / (2*n)\\n\\tside = (1/math.tan(a))\\n\\tprint(side)\\t\\n\\n\\n# try:\\n\\n\\t# raise Exception\\n# except:\\n\\t# print(\\\"-1\\\")\\n\\t\\n\\n\\n# thenos.sort(key=lambda x: x[2], reverse=True)\\n\\n# int(math.log(max(numbers)+1,2))\\n# 2**3 (power)\\n\\n\\n\", \"import math as m\\n\\ndef fu(a):\\n    return (a/180)*m.pi\\n\\nt=int(input())\\nfor _ in range(t):\\n    n=int(input())\\n    a=n//2-1\\n    b=180-360/(2*n)\\n    s=0\\n    for i in range(1,a+1):\\n        s=s+m.cos(fu(i*b-(2*i-1)*90))\\n    print(2*s+1)\", \"import sys\\nfrom math import tan, pi\\n\\n_INPUT_LINES = sys.stdin.read().splitlines()\\ninput = iter(_INPUT_LINES).__next__\\nfrom itertools import islice, cycle\\n\\n\\ndef go():\\n    n = int(input())\\n    # a,b,c,d = map(int, input().split())\\n    # a = list(map(int, input().split()))\\n    # s = input()\\n\\n    return  1/(tan(pi/(2*n)))\\n\\n\\n# x,s = map(int,input().split())\\nt = int(input())\\n# t = 1\\nans = []\\nfor _ in range(t):\\n    # print(go())\\n    ans.append(str(go()))\\n#\\nprint('\\\\n'.join(ans))\\n\", \"import math\\n\\nt=int(input())\\n\\nwhile(t):\\n\\tt-=1\\n\\tn=int(input())\\n\\n\\tang= math.pi/(2*n)\\n\\n\\tans= 1/math.tan(ang)\\n\\tprint(ans)\", \"import math\\n\\n\\ndef main():\\n    n = int(input())\\n    a = math.pi/(2*n)\\n    x = 1 / (math.sin(a)) / 2\\n    res = 2 * math.cos(a) * x\\n    print(res)\\n\\n\\nfor _ in range(int(input())):\\n    main()\\n\", \"import math\\nfor nt in range(int(input())):\\n\\tn=int(input())\\n\\tm=2*n\\n\\ta=((m-2)*180)/m\\n\\ts=180-a\\n\\tt=s\\n\\tans=0\\n\\tfor i in range((n-2)//2):\\n\\t\\t# print (t,ans)\\n\\t\\tans+=(math.cos((t*math.pi)/180))\\n\\t\\tt+=s\\n\\tprint(ans*2+1)\\n\", \"import os\\nimport sys\\nif os.path.exists('/mnt/c/Users/Square/square/codeforces'):\\n    f = iter(open('C.txt').readlines())\\n    def input():\\n        return next(f).strip()\\n    # input = lambda: sys.stdin.readline().strip()  \\nelse:\\n    input = lambda: sys.stdin.readline().strip()\\n\\nfprint = lambda *args: print(*args, flush=True)\\n\\nimport math\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    print(1.0 / math.tan(math.pi / 2 / n))\", \"from math import sin, pi\\ndef solve():\\n    n = int( input())\\n    return(sin(((n-1)*pi/(2*n)))/sin(pi/(2*n)))\\n    \\ndef main():\\n    t = int( input())\\n    print(\\\"\\\\n\\\".join( map( str, [ solve() for _ in range(t)])))\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"from math import *\\nfor _ in range(int(input())):\\n    n = 2 * int(input())\\n    a = pi - (pi * (n - 2) / n)\\n    ans = 0\\n    for i in range(1, n // 4):\\n        ans += cos(i * a)\\n    print(2 * ans + 1)\", \"import math \\nr=math.pi\\nfor _ in range(int(input())):\\n    N=int(input())\\n    w=2*N\\n    t=(math.cos(r/w))/(math.sin(r/w))\\n    print(t)\", \"from math import tan, pi\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    print(1 / tan(pi / (2 * n)))\\n\", \"import math\\nq = int(input())\\nfor _ in range(q):\\n\\tn = int(input())\\n\\tn*=2\\n\\tprint(math.tan(math.pi/2-math.pi/n))\", \"from math import sin,pi,radians\\ndef solve():\\n    n = int(input())*2\\n    a = 180*(n-2)/n\\n    bc = (180-a)/2\\n    d = 0.5/sin(radians(bc))      \\n    return round(2*(d**2-0.25)**0.5,8)                      \\nfor _ in range(int(input())):\\n    print(solve())\", \"import sys\\nimport math\\n# from collections import deque\\n# import heapq\\n# from math import inf\\n# from math import gcd\\n\\n# print(help(deque))\\n# 26\\npprint = lambda s: print(' '.join(map(str, s)))\\ninput = lambda: sys.stdin.readline().strip()\\nipnut = input\\n# a, b, c, d = map(int, input().split())\\n# n = int(input())\\n# e = list(map(int,input().split()))\\nfor i in range(int(input())):\\n    n = int(input())\\n    print(1/math.tan(math.pi/(2*n)))\\n\\\"\\\"\\\"\\n10\\n10 11 12 13 14 15 16 17 11 11\\n\\\"\\\"\\\"\\n\", \"T = int(input())\\nimport math\\nn = [0]*T\\nm = [0]*T\\na = [0]*T\\np = [0]*T\\n\\n\\nfor t in range(T):\\n  n = 2*int(input())   #,m[t] = [int(i) for i in input().split(' ')]\\n  #a = [int(i) for i in input().split(' ')]\\n  out = 0\\n  if n%4 == 0:\\n    print((math.tan(math.pi/n))**-1)\\n  else:\\n    print((math.sin(math.pi/n))**-1)\", \"from math import pi, sin\\n\\nfor i in range(int(input())):\\n    n = int(input())\\n    a = 0\\n    ans = 0\\n    x = pi - pi * (n - 1) / n\\n    for j in range(n - 1):\\n        a += x\\n        ans += sin(a)\\n    print(ans)\\n\"]", "input_output": "{\"inputs\": [\"3\\n2\\n4\\n200\\n\"], \"outputs\": [\"1.000000000\\n2.414213562\\n127.321336469\\n\"]}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1354/C1", "starter_code": ""}
{"id": 19, "question": "The only difference between easy and hard versions is constraints.\n\nThe BerTV channel every day broadcasts one episode of one of the $k$ TV shows. You know the schedule for the next $n$ days: a sequence of integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le k$), where $a_i$ is the show, the episode of which will be shown in $i$-th day.\n\nThe subscription to the show is bought for the entire show (i.e. for all its episodes), for each show the subscription is bought separately.\n\nHow many minimum subscriptions do you need to buy in order to have the opportunity to watch episodes of purchased shows $d$ ($1 \\le d \\le n$) days in a row? In other words, you want to buy the minimum number of TV shows so that there is some segment of $d$ consecutive days in which all episodes belong to the purchased shows.\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10000$) \u2014 the number of test cases in the input. Then $t$ test case descriptions follow.\n\nThe first line of each test case contains three integers $n, k$ and $d$ ($1 \\le n \\le 2\\cdot10^5$, $1 \\le k \\le 10^6$, $1 \\le d \\le n$). The second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le k$), where $a_i$ is the show that is broadcasted on the $i$-th day.\n\nIt is guaranteed that the sum of the values \u200b\u200bof $n$ for all test cases in the input does not exceed $2\\cdot10^5$.\n\n\n-----Output-----\n\nPrint $t$ integers \u2014 the answers to the test cases in the input in the order they follow. The answer to a test case is the minimum number of TV shows for which you need to purchase a subscription so that you can watch episodes of the purchased TV shows on BerTV for $d$ consecutive days. Please note that it is permissible that you will be able to watch more than $d$ days in a row.\n\n\n-----Example-----\nInput\n4\n5 2 2\n1 2 1 2 1\n9 3 3\n3 3 3 2 2 2 1 1 1\n4 10 4\n10 8 6 4\n16 9 8\n3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3\n\nOutput\n2\n1\n4\n5\n\n\n\n-----Note-----\n\nIn the first test case to have an opportunity to watch shows for two consecutive days, you need to buy a subscription on show $1$ and on show $2$. So the answer is two.\n\nIn the second test case, you can buy a subscription to any show because for each show you can find a segment of three consecutive days, consisting only of episodes of this show.\n\nIn the third test case in the unique segment of four days, you have four different shows, so you need to buy a subscription to all these four shows.\n\nIn the fourth test case, you can buy subscriptions to shows $3,5,7,8,9$, and you will be able to watch shows for the last eight days.", "solutions": "[\"for _ in range(int(input())):\\n    n, k, d = list(map(int, input().split()))\\n    a = list(map(int, input().split()))\\n    s = {}\\n    for q in range(d):\\n        s[a[q]] = s.get(a[q], 0)+1\\n    ans = len(s)\\n    for q in range(d, n):\\n        if s[a[q-d]] == 1:\\n            del s[a[q-d]]\\n        else:\\n            s[a[q-d]] -= 1\\n        s[a[q]] = s.get(a[q], 0)+1\\n        ans = min(ans, len(s))\\n    print(ans)\\n\", \"Q = int(input())\\nfor q in range(Q):\\n    n, k, d = tuple(map(int, input().split()))\\n    arr = list(map(int, input().split()))\\n\\n    nums = {}\\n    for i in range(d):\\n        if arr[i] in nums:\\n            nums[arr[i]] += 1\\n        else:\\n            nums[arr[i]] = 1\\n\\n    ans = len(nums)\\n    for i in range(d, n):\\n        if nums[arr[i - d]] == 1:\\n            nums.pop(arr[i - d])\\n        else:\\n            nums[arr[i - d]] -= 1\\n\\n        if arr[i] in nums:\\n            nums[arr[i]] += 1\\n        else:\\n            nums[arr[i]] = 1\\n        ans = min(ans, len(nums))\\n\\n    print(ans)\\n\", \"for __ in range(int(input())):\\n    n, k, d = list(map(int, input().split()))\\n    ar = list(map(int, input().split()))\\n    A = dict()\\n    num = 0\\n    for i in range(d):\\n        if ar[i] in A:\\n            A[ar[i]] += 1\\n        else:\\n            A[ar[i]] = 1\\n            num += 1\\n    ans = num\\n    for j in range(d, n):\\n        A[ar[j - d]] -= 1\\n        if A[ar[j - d]] == 0:\\n            num -= 1\\n        if ar[j] in A:\\n            if A[ar[j]] == 0:\\n                num += 1\\n            A[ar[j]] += 1\\n        else:\\n            A[ar[j]] = 1\\n            num += 1\\n        ans = min(num, ans)\\n    print(ans)\", \"t = int(input())\\nfor i in range(t):\\n    n, k, d = list(map(int, input().split()))\\n    a = list(map(int, input().split()))\\n    b = dict()\\n    for i in range(n):\\n        b[a[i]] = 0\\n    count = 0\\n    for i in range(d):\\n        if b[a[i]] == 0:\\n            count += 1\\n        b[a[i]] += 1\\n    \\n    ans = count\\n    for i in range(n - d):\\n        if b[a[i]] == 1:\\n            count -=1\\n        b[a[i]] -= 1\\n        if b[a[i + d]] == 0:\\n            count += 1\\n        b[a[i + d]] += 1\\n        ans = min(ans, count)\\n    print(ans)\\n\", \"n=int(input())\\nfor i in range(n):\\n    n,k,d=list(map(int,input().split()))\\n    a=[int(j) for j in input().split()]\\n    dv=dict()\\n    s=set()\\n    mn=n\\n    for j in range(n):\\n        if j>=d:\\n            mn=min(mn,len(s))\\n            t=a[j-d]\\n            dv[t]-=1\\n            if dv[t]==0:\\n                s.discard(t)\\n        t=a[j]\\n        if t in dv:\\n            dv[t]+=1\\n        else:\\n            dv[t]=1\\n        s.add(t)\\n    mn=min(mn,len(s))\\n    print(mn)\\n\", \"t = int(input())\\nfor u in range(t):\\n    n, d, k = map(int, input().split())\\n    a = list(map(int, input().split()))\\n    c = set()\\n    b = {}\\n    ans = 10 ** 9\\n    for i in range(min(n, k)):\\n        c.add(a[i])\\n        if a[i] in b:\\n            b[a[i]] += 1\\n        else:\\n            b[a[i]] = 1\\n    i = k\\n    ans = min(ans, len(c))\\n    while i < n:\\n        b[a[i - k]] -= 1\\n        if b[a[i - k]] == 0:\\n            c.discard(a[i - k])\\n        if a[i] in b:\\n            b[a[i]] += 1\\n        else:\\n            b[a[i]] = 1     \\n        c.add(a[i])\\n        ans = min(ans, len(c))\\n        i += 1\\n    print(ans)\", \"import sys\\ninput = sys.stdin.readline\\n\\ndef getInt(): return int(input())\\ndef getVars(): return list(map(int, input().split()))\\ndef getList(): return list(map(int, input().split()))\\ndef getStr(): return input().strip()\\n\\n## -------------------------------\\n\\nt = getInt()\\nfor _ in range(t):\\n    n, k, d = getVars()\\n    a = getList()\\n    b = {}\\n    for i in range(d):\\n        if a[i] not in b:\\n            b[a[i]] = 0\\n        b[a[i]] += 1\\n    res = len(list(b.keys()))\\n    res1 = res\\n    for i in range(d, n):\\n        b[a[i-d]] -= 1\\n        if b[a[i-d]] == 0:\\n            del b[a[i-d]]\\n            res1 -= 1\\n        if a[i] not in b:\\n            b[a[i]] = 0\\n            res1 += 1\\n        b[a[i]] += 1     \\n        res = min(res, res1)\\n    print(res)\\n\", \"from collections import deque\\n\\nt=int(input())\\nfor i in range(t):\\n    n,k,dp=[int(x) for x in input().split()]\\n    d={}\\n    i=0\\n    p=deque()\\n    cur=0\\n    min=k\\n    for el in input().split():\\n        i+=1\\n        if i<=dp:\\n            p.append(el)\\n            if el in list(d.keys()):\\n                d[el]+=1\\n            else:\\n                d[el]=1\\n                cur+=1\\n        else:\\n            if cur<min:\\n                min=cur\\n            ##deleting\\n            exc=p.popleft()\\n            if d[exc]==1:\\n                d.pop(exc)\\n                cur-=1\\n            else:\\n                d[exc]-=1\\n            ##adding\\n            p.append(el)\\n            if el in list(d.keys()):\\n                d[el]+=1\\n            else:\\n                d[el]=1\\n                cur+=1\\n        ##print(d,p)\\n    if min>cur:\\n        min=cur\\n    print(min)\\n\", \"import math\\nimport collections\\narrK = [0] * 1000050\\n\\ndef cleanK(q):\\n    while len(q):\\n        arrK[q.pop()] = 0\\n\\n\\ndef test():\\n    n, k, d = list(map(int, input().split()))\\n    a = list(map(int, input().split()))\\n    ans = math.inf\\n    q = collections.deque()\\n    sumK = 0\\n    for i in range(len(a)):\\n        q.append(a[i])\\n        if arrK[a[i]] == 0:\\n            sumK += 1\\n        arrK[a[i]] += 1\\n\\n        if len(q) > d:\\n            var = q.popleft()\\n            arrK[var] -= 1\\n            if arrK[var] == 0:\\n                sumK -= 1\\n        if len(q) == d and sumK < ans:\\n            ans = sumK\\n    cleanK(q)\\n    print(ans)\\n#\\n# def print2d(a):\\n#     for i in a:\\n#       print(' '.join(list(map(str, i))))\\n\\nt = int(input())\\n\\nfor i in range(t):\\n    test()\", \"def main():\\n    n, k, d = list(map(int, input().split()))\\n    l = list(map(int, input().split()))\\n    rez = 0\\n    rezline = {}\\n    for i in range(d):\\n        if rezline.get(l[i]) is None:\\n            rezline[l[i]] = 0\\n            rez += 1\\n        rezline[l[i]] += 1\\n    rez_p = rez\\n    for i in range(d, n):\\n        if rezline[l[i-d]] == 1:\\n            rez_p -= 1\\n        rezline[l[i-d]] -= 1\\n        if rezline.get(l[i]) in [0, None]:\\n            rez_p += 1\\n            rezline[l[i]] = 1\\n        else:\\n            rezline[l[i]] += 1\\n        rez = min(rez, rez_p)\\n    print(rez)\\n\\n\\nt = int(input())\\nfor i in range(t):\\n    main()\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n, k, d = list(map(int, input().split()))\\n    a = list(map(int, input().split()))\\n    m = dict()\\n    for i in range(d):\\n        if a[i] not in m:\\n            m[a[i]] = 0\\n        m[a[i]] += 1\\n    ans = len(m)\\n    for i in range(n - d):\\n        m[a[i]] -= 1\\n        if m[a[i]] == 0:\\n            m.pop(a[i])\\n        if a[i + d] not in m:\\n            m[a[i + d]] = 0\\n        m[a[i + d]] += 1\\n        ans = min(ans, len(m))\\n    print(ans)\\n\", \"def check(m):\\n    dictsums = dict()\\n    i, j = 0, 0\\n    dictsums[series[0]] = 1\\n    while i < len(series) - 1 and i - j + 1 < d:\\n        if series[i + 1] not in dictsums and len(dictsums) == m:\\n            while dictsums[series[j]] > 1:\\n                dictsums[series[j]] -= 1\\n                j += 1\\n            dictsums.pop(series[j])\\n            dictsums[series[i + 1]] = 1\\n            j += 1\\n        elif series[i + 1] not in dictsums and len(dictsums) < m:\\n            dictsums[series[i + 1]] = 1\\n        else:\\n            dictsums[series[i + 1]] += 1\\n        i += 1\\n    if i - j + 1 >= d:\\n        return 1\\n    else:\\n        return 0\\n\\n\\n\\n\\n\\nq = int(input())\\nfor i in range(q):\\n    n, k, d = map(int, input().split())\\n    series = list(map(int, input().split()))\\n    L = 0\\n    R = k\\n    while R - L > 1:\\n        m = (R + L) // 2\\n        if check(m):\\n            R = m\\n        else:\\n            L = m\\n    print(R)\", \"for i in range(int(input())):\\n    a = list(map(int, input().split()))\\n    n, k, d = a[0], a[1], a[2]\\n    a = list(map(int, input().split()))\\n    di = dict()\\n    m = 0\\n    m2 = 1000000\\n    n2 = 0\\n    for j in range(len(a)):\\n        if n2 < d:\\n            if a[j] not in di:\\n                di[a[j]] = 1\\n                m += 1\\n            else:\\n                if di[a[j]] == 0:\\n                    m += 1\\n                di[a[j]] += 1\\n            n2 += 1\\n        else:           \\n            if di[a[j - d]] == 1:\\n                di[a[j - d]] = 0\\n                m -= 1\\n            else:\\n                di[a[j - d]] -= 1\\n            if a[j] not in di:\\n                di[a[j]] = 1\\n                m += 1\\n            else:\\n                if di[a[j]] == 0:\\n                    m += 1\\n                di[a[j]] += 1\\n        if n2 == d and m < m2:\\n            m2 = m\\n    print(m2)\\n\", \"c = [[0, 0] for i in range(round(1e6+1))]\\n\\ndef ans(t) :\\n    a, k, s = [int(x) for x in input().split()]\\n    v = list([int(x) for x in input().split()])\\n    y, x, a, m = 0, 0, 0, 1e12\\n    for i in range(len(v)) :\\n        if c[v[i]][0] != t : c[v[i]] = [t, 0]\\n        c[v[i]][1] += 1\\n        if c[v[i]][1] == 1 : a += 1\\n        if i-y+1 > s :\\n            c[v[y]][1] -= 1\\n            if c[v[y]][1] == 0 : a -= 1\\n            y += 1\\n        if a < m and i-y+1 == s : m = a\\n    return m\\n\\nt = int(input())\\nfor i in range(t) : print(ans(i))\\n\", \"from collections import deque\\nt = int(input())\\nfor jfrhg in range(t):\\n    n, k, d = list(map(int, input().split()))\\n    a = list(map(int, input().split()))\\n    l = deque(a[:d])\\n    s = dict()\\n    for i in l:\\n        if i in s:\\n            s[i]+=1\\n        else:\\n            s[i] = 1\\n    minimum = len(list(s.keys()))\\n    for i in range(d, n):\\n        ref = l.popleft()\\n        l.append(a[i])\\n        s[ref] -=1\\n        if s[ref]<1:\\n            del s[ref]\\n        if a[i] in s:\\n            s[a[i]]+=1\\n        else:\\n            s[a[i]] = 1\\n        if len(list(s.keys()))< minimum:\\n            minimum = len(list(s.keys()))\\n    print(minimum)\\n\", \"from collections import deque\\n\\nfor _ in range(int(input())):\\n    n, k, d = list(map(int, input().split()))\\n    a = list(map(int, input().split()))\\n    ans = len(set(a[:d]))\\n    now = dict()\\n    for i in range(d):\\n        if a[i] in now:\\n            now[a[i]] += 1\\n        else:\\n            now[a[i]] = 1\\n    for i in range(d, n):\\n        ans = min(ans, len(now))\\n        now[a[i - d]] -= 1\\n        if now[a[i - d]] == 0:\\n            now.pop(a[i - d])\\n        if a[i] in now:\\n            now[a[i]] += 1\\n        else:\\n            now[a[i]] = 1\\n    ans = min(ans, len(now))\\n    print(ans)\\n\", \"for _ in range(int(input())):\\n    _, _, n = list(map(int, input().split()))\\n    a = [int(x) for x in input().split()]\\n    cnt = dict()\\n    for i in a[:n]:\\n        cnt[i] = cnt.get(i, 0) + 1\\n    mlen = len(cnt)\\n    for i in range(n, len(a)):\\n        if a[i - n] != a[i]:\\n            if cnt[a[i - n]] == 1:\\n                del cnt[a[i - n]]\\n            else:\\n                cnt[a[i - n]] -= 1\\n            cnt[a[i]] = cnt.get(a[i], 0) + 1\\n            mlen = min(mlen, len(cnt))\\n    print(mlen)\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n, k, d = list(map(int, input().split()))\\n    timetable = list(map(int, input().split()))\\n    i = 0\\n    j = d\\n    used = {}\\n    for x in range(d):\\n        if timetable[x] in list(used.keys()):\\n            used[timetable[x]] += 1\\n        else:\\n            used[timetable[x]] = 1\\n    ans = len(used)\\n    while j < n:\\n        if timetable[i] in list(used.keys()):\\n            used[timetable[i]] -= 1\\n            if used[timetable[i]] == 0:\\n                used.pop(timetable[i])\\n        i += 1\\n        if timetable[j] in list(used.keys()):\\n            used[timetable[j]] += 1\\n        else:\\n            used[timetable[j]] = 1\\n        j += 1\\n        ans = min(ans, len(used))\\n    print(ans)\\n\", \"for i in range(int(input())):\\n    n,k,d = map(int,input().split())\\n    a = [int(s) for s in input().split()]\\n    s = dict()\\n    for j in range(d):\\n        if s.get(a[j],0) == 0:\\n            s[a[j]] = 1\\n        else:\\n            s[a[j]] += 1\\n    m = len(s)   \\n    for j in range(1,n-d+1):\\n        if s[a[j-1]] == 1:\\n            s.pop(a[j-1])\\n        else:\\n            s[a[j-1]] -= 1\\n        if s.get(a[j+d-1],0) == 0:\\n            s[a[j+d-1]] = 1\\n        else:\\n            s[a[j+d-1]] += 1\\n        if len(s) < m:\\n            m = len(s)\\n    print(m)\", \"t = int(input())\\nfor i in range(t):\\n    n, k, d = map(int, input().split())\\n    data = list(map(int, input().split()))\\n    \\n    dd = {}\\n    for j in range(d):\\n        elem = data[j]\\n        if elem in dd:\\n            dd[elem] += 1\\n        else:\\n            dd[elem] = 1\\n    m = len(dd)\\n    for j in range(d, n):\\n        elem = data[j]\\n        if elem in dd:\\n            dd[elem] += 1\\n        else:\\n            dd[elem] = 1\\n        dd[data[j - d]] -= 1\\n        if dd[data[j - d]] == 0:\\n            dd.pop(data[j - d])\\n        m = min(m, len(dd))\\n    print(m)\", \"t = int(input())\\nfor i in range(t):\\n    n, k, d = list(map(int, input().split()))\\n    a = list(map(int, input().split()))\\n    m = k\\n    s = dict()\\n    c = 0\\n    for j in range(d):\\n        if a[j] in s:\\n            s[a[j]] += 1\\n        else:\\n            c += 1\\n            s[a[j]] = 1\\n    mm = m = len(s)\\n    for j in range(d, n):\\n        if a[j-d] in s:\\n            s[a[j-d]] -= 1\\n            if s[a[j-d]] == 0:\\n                del s[a[j-d]]\\n                m -= 1\\n        else:\\n            s[a[j]] = 1\\n            m += 1\\n        if a[j] in s:\\n            s[a[j]] += 1\\n        else:\\n            s[a[j]] = 1\\n            m += 1\\n        if m < mm:\\n            mm = m\\n    print(mm)\\n\\n\\n\\n\", \"def solve(n,k,d,a):\\n    #if n == d:\\n      #  return len(set(a))\\n    m = {}\\n    s = list(set(a))\\n    ans = float(\\\"inf\\\")\\n    for i in s:\\n        m[i] = 0\\n    sm = 0\\n    for i in range(d):\\n        m[a[i]] += 1\\n        if m[a[i]] == 1:\\n          sm += 1\\n    ans = sm\\n    #print(m)\\n    for i in range(d,n):\\n     #   print(m)\\n        x = a[i-d]\\n        y = a[i]\\n      #  print(x,y, i, d)\\n        m[x] -= 1\\n        if m[x] == 0:\\n            sm -= 1\\n        if m[y] == 0:\\n            sm += 1\\n        m[y] += 1\\n        ans = min(ans,sm)\\n    return ans\\n\\n\\ndef main():\\n    t = int(input())\\n    for i in range(t):\\n        n,k,d = list(map(int,input().split()))\\n        a = list(map(int,input().split()))\\n        print(solve(n,k,d,a))\\n\\nmain()\\n\", \"3\\ndef main():\\n    t = int(input())\\n    for _ in range(t):\\n        n1, k, d = [int(e) for e in input().split()]\\n        a = [int(e) for e in input().split()]\\n        s = dict()\\n        for e in a[:d]:\\n            s[e] = s.get(e, 0) + 1\\n        b = len(s)\\n        n = b\\n        for i in range(d, n1):\\n            ai = a[i]\\n            aid = a[i-d]\\n            s[ai] = s.get(ai,0)+1\\n            if s[ai] == 1:\\n                n += 1\\n            s[aid] -= 1\\n            if s[aid] == 0:\\n                n -= 1\\n            b = min(n, b)\\n        print(b)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"t=int(input())\\nfor q in range(t):\\n    n, k, d = list(map(int, input().split()))\\n    a = list(map(int, input().split()))\\n    g = {}\\n    m=k\\n    j=0\\n    s=0\\n    for i in range(0, n):\\n        f=a[i]\\n        l=g.get(f, 0)\\n        g[f]=l+1\\n        j+=1\\n        if l==0:\\n            s+=1\\n        if j>d:\\n            vr=g[a[i-d]]\\n            g[a[i-d]]-=1\\n            j-=1\\n            if vr==1:\\n                s-=1\\n        if j==d:       \\n            m=min(m, s)\\n    print(m)\\n\\n\", \"t=int(input())\\nfor i1 in range(t):\\n      n,k,d=list(map(int,input().split()))\\n      a=list(map(int,input().split()))\\n      dic={}\\n      r=0\\n      for i in range(d):\\n            e=a[i]\\n            if e in dic:\\n                  dic[e]+=1\\n            else:\\n                  dic[e]=1\\n                  r+=1\\n      m=r\\n      for i in range(1,n-d+1):\\n            e=a[i+d-1]\\n            if e in dic:\\n                  dic[e]+=1\\n            else:\\n                  dic[e]=1\\n                  r+=1\\n            e=a[i-1]\\n            if dic.get(e)>1:\\n                  dic[e]-=1\\n            else:\\n                  dic.pop(e)\\n                  r-=1\\n            m=min(m,r)\\n      print(m)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n5 2 2\\n1 2 1 2 1\\n9 3 3\\n3 3 3 2 2 2 1 1 1\\n4 10 4\\n10 8 6 4\\n16 9 8\\n3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n1\\n4\\n5\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1225/B2", "starter_code": ""}
{"id": 20, "question": "Gildong owns a bulgogi restaurant. The restaurant has a lot of customers, so many of them like to make a reservation before visiting it.\n\nGildong tries so hard to satisfy the customers that he even memorized all customers' preferred temperature ranges! Looking through the reservation list, he wants to satisfy all customers by controlling the temperature of the restaurant.\n\nThe restaurant has an air conditioner that has 3 states: off, heating, and cooling. When it's off, the restaurant's temperature remains the same. When it's heating, the temperature increases by 1 in one minute. Lastly, when it's cooling, the temperature decreases by 1 in one minute. Gildong can change the state as many times as he wants, at any integer minutes. The air conditioner is off initially.\n\nEach customer is characterized by three values: $t_i$ \u2014 the time (in minutes) when the $i$-th customer visits the restaurant, $l_i$ \u2014 the lower bound of their preferred temperature range, and $h_i$ \u2014 the upper bound of their preferred temperature range.\n\nA customer is satisfied if the temperature is within the preferred range at the instant they visit the restaurant. Formally, the $i$-th customer is satisfied if and only if the temperature is between $l_i$ and $h_i$ (inclusive) in the $t_i$-th minute.\n\nGiven the initial temperature, the list of reserved customers' visit times and their preferred temperature ranges, you're going to help him find if it's possible to satisfy all customers.\n\n\n-----Input-----\n\nEach test contains one or more test cases. The first line contains the number of test cases $q$ ($1 \\le q \\le 500$). Description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n \\le 100$, $-10^9 \\le m \\le 10^9$), where $n$ is the number of reserved customers and $m$ is the initial temperature of the restaurant.\n\nNext, $n$ lines follow. The $i$-th line of them contains three integers $t_i$, $l_i$, and $h_i$ ($1 \\le t_i \\le 10^9$, $-10^9 \\le l_i \\le h_i \\le 10^9$), where $t_i$ is the time when the $i$-th customer visits, $l_i$ is the lower bound of their preferred temperature range, and $h_i$ is the upper bound of their preferred temperature range. The preferred temperature ranges are inclusive.\n\nThe customers are given in non-decreasing order of their visit time, and the current time is $0$.\n\n\n-----Output-----\n\nFor each test case, print \"YES\" if it is possible to satisfy all customers. Otherwise, print \"NO\".\n\nYou can print each letter in any case (upper or lower).\n\n\n-----Example-----\nInput\n4\n3 0\n5 1 2\n7 3 5\n10 -1 0\n2 12\n5 7 10\n10 16 20\n3 -100\n100 0 0\n100 -50 50\n200 100 100\n1 100\n99 -100 0\n\nOutput\nYES\nNO\nYES\nNO\n\n\n\n-----Note-----\n\nIn the first case, Gildong can control the air conditioner to satisfy all customers in the following way:  At $0$-th minute, change the state to heating (the temperature is 0).  At $2$-nd minute, change the state to off (the temperature is 2).  At $5$-th minute, change the state to heating (the temperature is 2, the $1$-st customer is satisfied).  At $6$-th minute, change the state to off (the temperature is 3).  At $7$-th minute, change the state to cooling (the temperature is 3, the $2$-nd customer is satisfied).  At $10$-th minute, the temperature will be 0, which satisfies the last customer. \n\nIn the third case, Gildong can change the state to heating at $0$-th minute and leave it be. Then all customers will be satisfied. Note that the $1$-st customer's visit time equals the $2$-nd customer's visit time.\n\nIn the second and the fourth case, Gildong has to make at least one customer unsatisfied.", "solutions": "[\"q = int(input())\\nfor _ in range(q):\\n    n, m = list(map(int, input().split()))\\n    info = [list(map(int, input().split())) for i in range(n)]\\n    info = sorted(info)\\n    now =(m, m)\\n    time = 0\\n    flag = True\\n    for i in range(n):\\n        t, l, h = info[i]\\n        l_now = now[0] - (t - time)\\n        h_now = now[1] + (t - time)\\n        time = t\\n        if h < l_now or h_now < l:\\n            flag = False\\n        else:\\n            l_now = max(l_now, l)\\n            h_now = min(h_now, h)\\n            now = (l_now, h_now)\\n    if flag:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"for _ in range(int(input())):\\n\\tn,m=map(int,input().split())\\n\\tlm=hm=m\\n\\tpt=0\\n\\tans=\\\"YES\\\"\\n\\tfor i in range(n):\\n\\t\\tt,l,h=map(int,input().split())\\n\\t\\tlm-=(t-pt)\\n\\t\\thm+=(t-pt)\\n\\t\\tpt=t\\n\\t\\thm=min(h,hm)\\n\\t\\tlm=max(l,lm)\\n\\t\\tif hm<lm:\\n\\t\\t\\tans=\\\"NO\\\"\\n\\tprint(ans)\", \"for _ in range(int(input())):\\n    n, m = list(map(int, input().split()))\\n    ar = [[0, -10 ** 9, 10 ** 9]]\\n    for ______ in range(n):\\n        ar.append(list(map(int, input().split())))\\n    ar.sort()\\n    left, right = m, m\\n    ans = 'YES'\\n    for i in range(1, n + 1):\\n        left -= ar[i][0] - ar[i - 1][0]\\n        right += ar[i][0] - ar[i - 1][0]\\n        left, right = [max(left, ar[i][1]), min(right, ar[i][2])]\\n        if right - left < 0:\\n            ans = 'NO'\\n    print(ans)\", \"import sys\\ninput = sys.stdin.readline\\n\\nT = int(input())\\nfor _ in range(T):\\n    n, m = map(int, input().split())\\n    CUS = [tuple(map(int, input().split())) for _ in range(n)]\\n    CUS.sort()\\n    L = m\\n    R = m\\n    prv = 0\\n    ans = True\\n    for t, l, r in CUS:\\n        d = t - prv\\n        L -= d\\n        R += d\\n        if R < l or r < L:\\n            ans = False\\n            break\\n        else:\\n            R = min(R, r)\\n            L = max(L, l)\\n            prv = t\\n    if ans:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"def solve():\\n    n, m = list(map(int, input().split()))\\n    cust = []\\n    for ___ in range(n):\\n        t, l, h = list(map(int, input().split()))\\n        cust.append((t, l, h))\\n\\n    cust.sort()\\n\\n    lastT = 0\\n    lastMaxT = m\\n    lastMinT = m\\n\\n    for t, l, h in cust:\\n        nextMax = lastMaxT + t - lastT\\n        nextMin = lastMinT - t + lastT\\n\\n        if nextMax < l or nextMin > h:\\n            print(\\\"NO\\\")\\n            return\\n\\n        lastMaxT = min(h, nextMax)\\n        lastMinT = max(l, nextMin)\\n        lastT = t\\n    print(\\\"YES\\\")\\n\\n\\nq = int(input())\\nfor __ in range(q):\\n    solve()\\n\", \"for t in range(int(input())):\\n    n, m = list(map(int, input().split()))\\n    a = []\\n    for i in range(n):\\n        a.append(list(map(int, input().split())))\\n    t0 = 0\\n    mi, ma = m, m\\n    f = True\\n    for t, l, h in a:\\n        delta = t - t0\\n        t0 = t\\n        mi -= delta\\n        ma += delta\\n        if mi <= l and ma >= h:\\n            mi = l\\n            ma = h\\n        elif l <= ma <= h and mi <= l:\\n            mi = l\\n            ma = ma\\n        elif l <= ma <= h and l <= mi <= h:\\n            mi = mi\\n            ma = ma\\n        elif ma >= h and l <= mi <= h:\\n            ma = h\\n            mi = mi\\n        else:\\n            f = False\\n    if f:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"T = int(input())\\n\\nfor _ in range(T):\\n    n, m = list(map(int, input().split()))\\n    time, mx, mn = 0, m, m\\n    flag = True\\n\\n    for __ in range(n):\\n        x, y, z = list(map(int, input().split()))\\n\\n        if not flag:\\n            continue\\n\\n        mx += x - time\\n        mn -= x - time\\n\\n        if mx < y or mn > z:\\n            flag = False\\n\\n        if mx > z:\\n            mx = z\\n\\n        if mn < y:\\n            mn = y\\n\\n        time = x\\n\\n    print('YES' if flag else 'NO')\\n\", \"def getIntersect(a, b, c, d):\\n    return (max(a, c), min(b, d))\\n\\n\\ndef solve(N, M, A):\\n    tHi = M\\n    tLo = M\\n    A.sort()\\n    lastT = 0\\n    for t, l, h in A:\\n        deltaT = t - lastT\\n        tLo -= deltaT\\n        tHi += deltaT\\n        tLo, tHi = getIntersect(tLo, tHi, l, h)\\n        if tLo > tHi:\\n            return \\\"NO\\\"\\n        lastT = t\\n    return \\\"YES\\\"\\n\\n\\ndef __starting_point():\\n    T, = list(map(int, input().split()))\\n    for t in range(T):\\n        N, M = list(map(int, input().split()))\\n        A = []\\n        for i in range(N):\\n            tlh = [int(x) for x in input().split()]\\n            A.append(tlh)\\n\\n        ans = solve(N, M, A)\\n        print(ans)\\n\\n__starting_point()\", \"Q = int(input())\\n\\nfor _ in range(Q):\\n    n, m = map(int, input().split())\\n    lt, mn, mx = 0, m, m\\n    ok = True\\n    for i in range(n):\\n        if ok:\\n            t, l, h = map(int, input().split())\\n            mn = max(mn - (t - lt), l)\\n            mx = min(mx + (t - lt), h)\\n            lt = t\\n            if mn>mx:\\n                ok=False\\n\\n        else:\\n            input()\\n    print('YES' if ok else 'NO')\", \"q = int(input())\\nfor rewrew in range(q):\\n\\tn, t0 = map(int,input().split())\\n\\tt = []\\n\\tl = []\\n\\th = []\\n\\tfor i in range(n):\\n\\t\\ttt,ll,hh = map(int,input().split())\\n\\t\\tt.append(tt)\\n\\t\\tl.append(ll)\\n\\t\\th.append(hh)\\n\\tpossib = [[0,0]]*n\\n\\tdasie = True\\n\\tpossib[0] = [-t[0]+t0,t[0]+t0]\\n\\tfor i in range(n):\\n\\t\\tif l[i]>possib[i][1] or h[i] < possib[i][0]:\\n\\t\\t\\tdasie = False\\n\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tpossib[i][0] = max(possib[i][0],l[i])\\n\\t\\t\\tpossib[i][1] = min(possib[i][1], h[i])\\n\\t\\tif i < n-1:\\n\\t\\t\\tpossib[i+1][0] = possib[i][0] - (t[i+1]-t[i])\\n\\t\\t\\tpossib[i+1][1] = possib[i][1] + (t[i+1]-t[i])\\n\\tif dasie:\\n\\t\\tprint(\\\"YES\\\")\\n\\telse:\\n\\t\\tprint(\\\"NO\\\")\", \"from collections import defaultdict\\n\\n\\ndef problemA():\\n    t = int(input())\\n    for _ in range(t):\\n        x, y, a, b = list(map(int, input().split()))\\n\\n        if (y - x) % (a + b) == 0:\\n            print((y - x) // (a + b))\\n        else:\\n            print(-1)\\n\\n\\ndef problemB():\\n    n, m = list(map(int, input().split()))\\n    ss = set()\\n    res = []\\n\\n    for i in range(n):\\n        s = input()\\n        rs = s[::-1]\\n        if rs in ss:\\n            res.append(s)\\n            ss.remove(rs)\\n        else:\\n            ss.add(s)\\n\\n    long = ''\\n    for s in ss:\\n        if s == s[::-1] and len(s) > len(int):\\n            long = s\\n\\n    res = ''.join(res)\\n    res = res + int + res[::-1]\\n    print(len(res))\\n    print(res)\\n\\n\\ndef problemC():\\n    inf = 2 * 10 ** 9\\n\\n    q = int(input())\\n    for _ in range(q):\\n        n, m = list(map(int, input().split()))\\n\\n        a = defaultdict(lambda: (-inf, inf))\\n        for _ in range(n):\\n            t, l, h = list(map(int, input().split()))\\n            pl, ph = a[t]\\n            a[t] = (max(l, pl), min(h, ph))\\n\\n        pt = 0\\n        pl, ph = m, m\\n        res = 'YES'\\n        for t in sorted(a.keys()):\\n            l, h = a[t]\\n\\n            delta = t - pt\\n            cl = pl - delta\\n            ch = ph + delta\\n\\n            pl = max(l, cl)\\n            ph = min(h, ch)\\n\\n            if pl > ph:\\n                res = 'NO'\\n                break\\n\\n            pt = t\\n\\n        print(res)\\n\\n\\ndef problemG():\\n    t = int(input())\\n    for _ in range(t):\\n        n = int(input())\\n        a = list(map(int, input().split()))\\n\\n        res = 0\\n        print(a)\\n\\n\\ndef __starting_point():\\n    problemC()\\n\\n__starting_point()\", \"q = int(input())\\nfor _ in range(q):\\n    n,m = list(map(int, input().split()))\\n    customers = [[int(x) for x in input().split()] for _ in range(n)]\\n\\n    now_l, now_h = m, m\\n    now = 0\\n    for t,l,h in customers:\\n        dt = t - now\\n\\n        # in area?\\n        next_h = min(now_h + dt, h)\\n        next_l = max(now_l - dt, l)\\n        if not next_l <= next_h:\\n            ok = False\\n            break\\n\\n        now = t\\n        now_l, now_h = next_l, next_h\\n    else:\\n        ok = True\\n\\n    print(\\\"YES\\\" if ok else \\\"NO\\\")\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nQ = int(input())\\nQuery = []\\nfor _ in range(Q):\\n    N, M = map(int, input().split())\\n    TLR = [list(map(int, input().split())) for _ in range(N)]\\n    Query.append((N, M, TLR))\\n\\n\\nfor N, M, TLR in Query:\\n    TLR.sort()\\n    large = M\\n    small = M\\n    pret = 0\\n    ok = True\\n    for t, l, r in TLR:\\n        delta = t - pret\\n        large += delta\\n        small -= delta\\n\\n        if large < l or r < small:\\n            ok = False\\n            break\\n        large = min(large, r)\\n        small = max(small, l)\\n\\n        pret = t\\n    \\n    print(\\\"YES\\\" if ok else \\\"NO\\\")\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n3 0\\n5 1 2\\n7 3 5\\n10 -1 0\\n2 12\\n5 7 10\\n10 16 20\\n3 -100\\n100 0 0\\n100 -50 50\\n200 100 100\\n1 100\\n99 -100 0\\n\"\n  ],\n  \"outputs\": [\n    \"YES\\nNO\\nYES\\nNO\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1304/C", "starter_code": ""}
{"id": 21, "question": "Among Johnny's numerous hobbies, there are two seemingly harmless ones: applying bitwise operations and sneaking into his dad's office. As it is usually the case with small children, Johnny is unaware that combining these two activities can get him in a lot of trouble.\n\nThere is a set $S$ containing very important numbers on his dad's desk. The minute Johnny heard about it, he decided that it's a good idea to choose a positive integer $k$ and replace each element $s$ of the set $S$ with $s \\oplus k$ ($\\oplus$ denotes the exclusive or operation). \n\nHelp him choose such $k$ that Johnny's dad will not see any difference after his son is done playing (i.e. Johnny will get the same set as before playing). It is possible that no such number exists. It is also possible that there are many of them. In such a case, output the smallest one. Note that the order of elements in a set doesn't matter, i.e. set $\\{1, 2, 3\\}$ equals to set $\\{2, 1, 3\\}$.\n\nFormally, find the smallest positive integer $k$ such that $\\{s \\oplus k | s \\in S\\} = S$ or report that there is no such number.\n\nFor example, if $S = \\{1, 3, 4\\}$ and $k = 2$, new set will be equal to $\\{3, 1, 6\\}$. If $S = \\{0, 1, 2, 3\\}$ and $k = 1$, after playing set will stay the same.\n\n\n-----Input-----\n\nIn the first line of input, there is a single integer $t$ ($1 \\leq t \\leq 1024$), the number of test cases. In the next lines, $t$ test cases follow. Each of them consists of two lines. \n\nIn the first line there is a single integer $n$ ($1 \\leq n \\leq 1024$) denoting the number of elements in set $S$. Second line consists of $n$ distinct integers $s_i$ ($0 \\leq s_i < 1024$), elements of $S$.\n\nIt is guaranteed that the sum of $n$ over all test cases will not exceed $1024$.\n\n\n-----Output-----\n\nPrint $t$ lines; $i$-th line should contain the answer to the $i$-th test case, the minimal positive integer $k$ satisfying the conditions or $-1$ if no such $k$ exists.\n\n\n-----Example-----\nInput\n6\n4\n1 0 2 3\n6\n10 7 14 8 3 12\n2\n0 2\n3\n1 2 3\n6\n1 4 6 10 11 12\n2\n0 1023\n\nOutput\n1\n4\n2\n-1\n-1\n1023\n\n\n\n-----Note-----\n\nIn the first test case, the answer is $1$ because it is a minimum positive integer and it satisfies all the conditions.", "solutions": "[\"t = int(input())\\n\\nfor _ in range(t):\\n    n = list(input().strip())\\n    s = list(map(int, input().strip().split()))\\n\\n    check = set(s)\\n    found = False\\n    for i in range(1, 1025):\\n        newset = set([e^i for e in s])\\n        if check == newset:\\n            print(i)\\n            found = True\\n            break\\n    if not found:\\n        print(-1)\\n\", \"import sys\\ninput = sys.stdin.readline\\nfor _ in range(int(input())):\\n  N = int(input())\\n  a = list(map(int, input().split()))\\n  a.sort()\\n  for x in range(1, 1024):\\n    b = [0] * N\\n    for i in range(N): b[i] = a[i] ^ x\\n    b.sort()\\n    if a == b:\\n      print(x)\\n      break\\n  else: print(-1)\", \"import sys\\ninput = sys.stdin.readline\\n\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    S = set(map(int, input().split()))\\n    ok = False\\n    for i in range(1, 1024):\\n        tmp = {i ^ val for val in S}\\n        if tmp == S:\\n            print(i)\\n            ok = True\\n            break\\n    if not ok:\\n        print(-1)\\n\", \"for _ in range(int(input())):\\n    n=int(input())\\n    s=list(map(int,input().split()))\\n    ans=-1\\n    for k in range(1,1025):\\n        st=set(s)\\n        for i in s:\\n            val=i^k \\n            if val not in st:\\n                break\\n            st.remove(val)\\n        if not st:\\n            ans=k \\n            break\\n    print(ans)\", \"# from decorators import *\\nfrom sys import stdin, stdout\\nfrom math import ceil\\n\\n# @debug\\ndef solve(n,s):\\n    s.sort()\\n    for i in range(1,1025):\\n        b = []\\n        for j in range(n):\\n            b.append(s[j]^i)\\n        b.sort()\\n        flag = True\\n        for j in range(n):\\n            if s[j]!=b[j]:\\n                flag = False\\n                break\\n        if flag:\\n            print(i)\\n            return True\\n    print(-1)\\n\\nfor _ in range(int(input())):\\n    n = int(stdin.readline())\\n    s = list(map(int,stdin.readline().split()))\\n    solve(n,s)\", \"t = int(input())\\n\\nfor k in range(t):\\n    n = int(input())\\n    a = set(map(int, input().split()))\\n    for x in range(1, 1025):\\n        if set(x ^ q for q in a) == a:\\n            print(x)\\n            break \\n    else:\\n        print(-1)\", \"import sys\\nints = (int(x) for x in sys.stdin.read().split())\\nsys.setrecursionlimit(3000)\\n\\ndef main():\\n    ntc = next(ints)\\n    for tc in range(1,ntc+1):\\n        n = next(ints)\\n        s = [next(ints) for i in range(n)]\\n        P = None\\n        for x in s:\\n            p = set(x^y for y in s)\\n            if P==None: P = p\\n            else: P &= p\\n        ans = next(iter(sorted(P)[1:]), -1)\\n        print(ans)\\n    return\\n\\nmain()\\n\", \"T = int(input())\\n\\nfor t in range(T):\\n    n = int(input())\\n    S = [int(_) for _ in input().split()]\\n    setS = set(S)\\n\\n    for k in range(1, 1025):\\n        for el in setS:\\n            if el ^ k not in setS:\\n                break\\n        else:\\n            print(k)\\n            break\\n    else:\\n        print(-1)\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    ans = -1\\n    l = set(map(int,input().split()))\\n    for i in range(1,4 * (10 ** 3)):\\n        s1 = set()\\n        for j in l:\\n            s1.add(i ^ j)\\n        if(s1 == l):\\n            ans = i\\n            break\\n    print(ans)\", \"import sys\\ndef arr():\\n    return list(map(int,input().split()))\\ninput=sys.stdin.readline\\nfrom collections import defaultdict\\nimport math\\nfor _ in range(int(input())):\\n    N=int(input())\\n    L=arr()\\n    L.sort()\\n    flag=False\\n    for i in range(1,1025):\\n        x=L[::]\\n        for j in range(N):\\n            x[j]=x[j]^i\\n        x.sort()\\n        x.sort()\\n        if x==L:\\n            ans=i\\n            flag=True\\n            break\\n    if flag:\\n        print(ans)\\n    else:\\n        print(-1)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"6\\n4\\n1 0 2 3\\n6\\n10 7 14 8 3 12\\n2\\n0 2\\n3\\n1 2 3\\n6\\n1 4 6 10 11 12\\n2\\n0 1023\\n\"\n  ],\n  \"outputs\": [\n    \"1\\n4\\n2\\n-1\\n-1\\n1023\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1362/B", "starter_code": ""}
{"id": 22, "question": "Let's define the following recurrence: $$a_{n+1} = a_{n} + minDigit(a_{n}) \\cdot maxDigit(a_{n}).$$\n\nHere $minDigit(x)$ and $maxDigit(x)$ are the minimal and maximal digits in the decimal representation of $x$ without leading zeroes. For examples refer to notes.\n\nYour task is calculate $a_{K}$ for given $a_{1}$ and $K$.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of independent test cases.\n\nEach test case consists of a single line containing two integers $a_{1}$ and $K$ ($1 \\le a_{1} \\le 10^{18}$, $1 \\le K \\le 10^{16}$) separated by a space.\n\n\n-----Output-----\n\nFor each test case print one integer $a_{K}$ on a separate line.\n\n\n-----Example-----\nInput\n8\n1 4\n487 1\n487 2\n487 3\n487 4\n487 5\n487 6\n487 7\n\nOutput\n42\n487\n519\n528\n544\n564\n588\n628\n\n\n\n-----Note-----\n\n$a_{1} = 487$ \n\n $a_{2} = a_{1} + minDigit(a_{1}) \\cdot maxDigit(a_{1}) = 487 + \\min (4, 8, 7) \\cdot \\max (4, 8, 7) = 487 + 4 \\cdot 8 = 519$ \n\n $a_{3} = a_{2} + minDigit(a_{2}) \\cdot maxDigit(a_{2}) = 519 + \\min (5, 1, 9) \\cdot \\max (5, 1, 9) = 519 + 1 \\cdot 9 = 528$ \n\n $a_{4} = a_{3} + minDigit(a_{3}) \\cdot maxDigit(a_{3}) = 528 + \\min (5, 2, 8) \\cdot \\max (5, 2, 8) = 528 + 2 \\cdot 8 = 544$ \n\n $a_{5} = a_{4} + minDigit(a_{4}) \\cdot maxDigit(a_{4}) = 544 + \\min (5, 4, 4) \\cdot \\max (5, 4, 4) = 544 + 4 \\cdot 5 = 564$ \n\n $a_{6} = a_{5} + minDigit(a_{5}) \\cdot maxDigit(a_{5}) = 564 + \\min (5, 6, 4) \\cdot \\max (5, 6, 4) = 564 + 4 \\cdot 6 = 588$ \n\n $a_{7} = a_{6} + minDigit(a_{6}) \\cdot maxDigit(a_{6}) = 588 + \\min (5, 8, 8) \\cdot \\max (5, 8, 8) = 588 + 5 \\cdot 8 = 628$", "solutions": "[\"import sys\\n\\ninput = sys.stdin.readline\\n\\nfor _ in range(int(input())):\\n\\ta, k = list(map(int, input().split()))\\n\\tfor _ in range(k - 1):\\n\\t\\tif '0' in str(a):\\n\\t\\t\\tbreak\\n\\t\\ta += int(min(list(str(a)))) * int(max(list(str(a))))\\n\\tprint(a)\\n\", \"for _ in range(int(input())):\\n    n,k = map(int,input().split())\\n    for i in range(k-1):\\n        n = str(n)\\n        if (\\\"0\\\" in n):\\n            break\\n        n = int(n) + int(min(n))*int(max(n))\\n\\n    print(n)\", \"import sys\\nINF = 10**20\\nMOD = 10**9 + 7\\nI = lambda:list(map(int,input().split()))\\nfrom math import gcd\\nfrom math import ceil\\nfrom collections import defaultdict as dd, Counter\\nfrom bisect import bisect_left as bl, bisect_right as br\\n\\nt, = I()\\nwhile t:\\n    t -= 1\\n    a, k = I()\\n    b = str(a)\\n    s = []\\n    while b not in s:\\n        s.append(b)\\n        b = str(int(b) + int(min(b)) * int(max(b)))\\n    if k >= len(s):\\n        print(s[-1])\\n    else:\\n        print(s[k - 1])\", \"t = int(input())\\n\\nfor i in range(t):\\n  a, b = list(map(int, input().split()))\\n\\n  last = -1\\n  b -= 1\\n  while last != a and b:\\n    b -= 1\\n    last = a\\n    aa = a\\n    maks = 0\\n    mini = 10\\n    while aa:\\n      mini = min(mini, aa%10)\\n      maks = max(maks, aa%10)\\n      aa = aa//10\\n\\n    a += mini*maks\\n\\n  print(a)\\n\", \"def read_int():\\n    return int(input())\\n\\n\\ndef read_ints():\\n    return list(map(int, input().split(' ')))\\n\\n\\nt = read_int()\\nfor case_num in range(t):\\n    a, k = read_ints()\\n    i = 1\\n    while i < k:\\n        s = str(a)\\n        lo = int(min(s))\\n        hi = int(max(s))\\n        if lo == 0:\\n            break\\n        a += lo * hi\\n        i += 1\\n    print(a)\\n\", \"t=int(input())\\nfor _ in range(t):\\n    N,K=map(int,input().split())\\n    while(K>1):\\n        x=list(str(N))\\n        if('0' in x):\\n            break\\n        x=[int(i) for i in x]\\n        N=N+min(x)*max(x)\\n        K-=1\\n    print(N)\", \"def maxd(val) :\\n\\tmx = 0\\n\\twhile val > 0 :\\n\\t\\tmx = max(mx, val % 10)\\n\\t\\tval //= 10\\n\\treturn mx\\n\\ndef mind(val) :\\n\\tmn = 9\\n\\twhile val > 0 :\\n\\t\\tmn = min(mn, val % 10)\\n\\t\\tval //= 10\\n\\treturn mn\\nt = int(input())\\nwhile t > 0:\\n\\tt -= 1\\n\\ta, k = map(int, input().split())\\n\\tk -= 1\\n\\twhile k > 0 and mind(a) > 0 :\\n\\t\\ta = a + mind(a) * maxd(a)\\n\\t\\tk -= 1\\n\\tprint(a)\", \"T = int(input())\\nn = [0]*T\\n\\nfor t in range(T):\\n # n = int(input())\\n  n,k = [int(i) for i in input().split(' ')]\\n  n1 = str(n)\\n  while n1.count('0') <1 and k>1: \\n    n += int(min(n1))*int(max(n1))\\n    n1 = str(n)\\n    k-=1\\n  print(n1)\", \"for _ in range(int(input())):\\n    n,k = map(int,input().split())\\n    for i in range(k-1):\\n        n = str(n)\\n        if (\\\"0\\\" in n):\\n            break\\n        n = int(n)+int(min(n))*int(max(n))\\n    print(n)\", \"for _ in range(int(input())):\\n    a, k = list(map(int, input().split()))\\n    for _ in range(k-1):\\n        mn = min(str(a))\\n        mx = max(str(a))\\n        if mn == \\\"0\\\":\\n            break\\n        a += int(mn)*int(mx)\\n    print(a)\\n\", \"def main():\\n\\tt = int(input())\\n\\tfor _ in range(t):\\n\\t\\tn, k = [int(x) for x in input().split(\\\" \\\")]\\n\\t\\tfor _ in range(k-1):\\n\\t\\t\\tnr = [int(x) for x in str(n)]\\n\\t\\t\\tmin_d = min(nr)\\n\\t\\t\\tmax_d = max(nr)\\n\\t\\t\\tif min_d == 0:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telse:\\n\\t\\t\\t\\tn += min_d * max_d\\n\\n\\t\\tprint(n)\\n\\n\\nmain()\", \"import os\\nimport sys\\nif os.path.exists('/mnt/c/Users/Square/square/codeforces'):\\n\\tf = iter(open('A.txt').readlines())\\n\\tdef input():\\n\\t\\treturn next(f)\\n\\t# input = lambda: sys.stdin.readline().strip()\\t\\nelse:\\n\\tinput = lambda: sys.stdin.readline().strip()\\n\\nfprint = lambda *args: print(*args, flush=True)\\n\\ndef min_max(x):\\n\\tl = list(str(x))\\n\\treturn int(min(l)), int(max(l))\\n\\nt = int(input())\\nfor _ in range(t):\\n\\ta, K = map(int, input().split())\\n\\tK -= 1\\n\\n\\tfor _ in range(K):\\n\\t\\tu, v = min_max(a)\\n\\t\\tif u == 0:\\n\\t\\t\\tbreak\\n\\t\\ta += u*v\\n\\tprint(a)\\n\\n\", \"import math\\nfor _ in range(int(input())):\\n    a,k=list(map(int,input().split()))\\n    for i in range(k-1):\\n        d=list(str(a))\\n        l=int(min(d))*int(max(d))\\n        if l==0:\\n            break\\n        a+=l\\n    print(a)\\n    \\n        \\n    \\n\\n    \\n\", \"import sys\\n# from collections import deque\\n# import heapq\\n# from math import inf\\n# from math import gcd\\n\\n# print(help(deque))\\n# 26\\npprint = lambda s:  print(' '.join(map(str,s)))\\ninput = lambda: sys.stdin.readline().strip()\\nipnut = input\\nfor i in range(int(input())):\\n    a,k = map(int,input().split())\\n    # n = int(input())\\n    # s = list(map(int,input().split()))\\n    for i in range(k-1):\\n        x = list(map(int,str(a)))\\n        a_i = min(x)\\n        a_m = max(x)\\n        a = a+a_i*a_m\\n        if a_i==0:\\n            break\\n    print(a)\\n\\n\\\"\\\"\\\"\\n10\\n10 11 12 13 14 15 16 17 11 11\\n\\\"\\\"\\\"\\n\", \"import sys\\ninput=sys.stdin.readline\\nfrom collections import defaultdict as dd,deque as dq\\nt=int(input())\\nwhile t:\\n    #n=int(input())\\n    n,k=map(int,input().split())\\n    #l=list(map(int,input().split())\\n    k-=1\\n    while k:\\n        l=str(n).strip()\\n        x=int(min(l))*int(max(l))\\n        if(x==0):\\n            break\\n        n=n+x\\n        k-=1\\n    print(n)\\n    t-=1\", \"t=int(input())\\ndef m(n):\\n    s=[int(i) for i in str(n)]\\n    s.sort()\\n    return (s[0],s[-1])\\nfor _ in range(t):\\n    n,k=(map(int,input().split()))\\n    pre=n\\n    for i in range(2,k+1):\\n        a=m(n)\\n        n=n+a[0]*a[1]\\n        if pre==n:\\n            break \\n        else:\\n            pre=n\\n        \\n    print(n)\", \"import sys\\ninput = sys.stdin.readline\\nt = int(input())\\nfor _ in range(t):\\n  a1,k = map(int,input().split())\\n  a = a1\\n  k -= 1\\n  while k and str(a).count(\\\"0\\\") == 0:\\n    ls = [int(str(a)[i]) for i in range(len(str(a)))]\\n    a += max(ls)*min(ls)\\n    k -= 1\\n  print(a)\", \"def solve():\\n\\ta, k = list(map(int,input().split()))\\n\\tseen = set()\\n\\titems = [a]\\n\\tfor i in range(k-1):\\n\\t\\tlast = items[-1]\\n\\t\\tmin_dig = int(min(str(last)))\\n\\t\\tmax_dig = int(max(str(last)))\\n\\t\\tnw = last + min_dig * max_dig\\n\\t\\titems.append(nw)\\n\\t\\tif '0' in str(items):\\n\\t\\t\\tbreak\\n\\tprint(items[-1])\\n\\nfor i in range(int(input())):\\n\\tsolve()\\n\", \"def digits(n):\\n\\tl=[]\\n\\twhile(n>0):\\n\\t\\tl.append(n%10)\\n\\t\\tn=n//10\\n\\tmina=min(l)\\n\\tmaxa=max(l)\\n\\treturn mina*maxa\\nt=int(input())\\nfor you in range(t):\\n\\tl=input().split()\\n\\ta=int(l[0])\\n\\tk=int(l[1])\\n\\tfor i in range(k-1):\\n\\t\\tif(digits(a)==0):\\n\\t\\t\\tbreak\\n\\t\\ta+=digits(a)\\n\\tprint(a)\\n\", \"t = int(input())\\nfor ii in range(t):\\n    a, k = map(int, input().split())\\n    cur = 0\\n    while cur < k - 1 and '0' not in str(a):\\n        mi = 1000\\n        ma = -1\\n        for i in str(a):\\n            mi = min(int(i), mi)\\n            ma = max(int(i), ma)\\n        a += mi * ma\\n        cur += 1\\n    print(a)\", \"t = int(input())\\nfor _ in range(t):\\n    a, k = list(map(int, input().split()))\\n    for i in range(k - 1):\\n        a += int(min(str(a))) * int(max(str(a)))\\n        if '0' in str(a):\\n            break\\n    print(a)\\n\", \"\\ndef f(x):\\n\\ts=str(x)\\n\\tmn=12\\n\\tmx=0\\n\\n\\tfor i in s:\\n\\t\\tmx=max(mx,int(i))\\n\\t\\tmn=min(mn,int(i))\\n\\treturn mn*mx\\n\\nfor _ in range(int(input())):\\n\\ta,k=list(map(int,input().split()))\\n\\tk-=1\\n\\tprev=-1\\n\\n\\twhile(k>0):\\n\\t\\tif(prev==a):\\n\\t\\t\\tbreak\\n\\t\\tprev=a\\n\\t\\ta+=f(a)\\n\\t\\tk-=1\\n\\n\\tprint(a)\\n\", \"'''input\\n8\\n1 4\\n487 1\\n487 2\\n487 3\\n487 4\\n487 5\\n487 6\\n487 7\\n'''\\nimport math\\ndef dig(x):\\n\\tmn = x%10\\n\\tmx = x%10\\n\\twhile x>0:\\n\\t\\tmn = min(mn,x%10)\\n\\t\\tmx = max(mx,x%10)\\n\\t\\tx//=10\\n\\treturn mn,mx\\ndef solve():\\n\\ta,k = map(int,input().split())\\n\\tl = [a]\\n\\tln = 1\\n\\tfor i in range(1000):\\n\\t\\tpv = l[ln-1]\\n\\t\\tmn,mx = dig(pv) \\n\\t\\tif mn ==0:\\n\\t\\t\\tbreak\\n\\t\\tl.append(pv+mx*mn)\\n\\t\\tln+=1\\n\\tk = min(k,len(l))\\n\\tprint(l[k-1])\\n\\treturn\\nt = 1\\nt = int(input())\\nwhile t>0:\\n\\tt-=1\\n\\tsolve()\", \"def main():\\n    t = int(input())\\n    for ti in range(t):\\n        a, k = map(int, input().split())\\n\\n        for i in range(k - 1):\\n            astr = str(a)\\n            mn, mx = int(min(astr)), int(max(astr))\\n            if mn == 0 or mx == 0:\\n                break\\n            a += mn * mx\\n        print(a)\\n\\nmain()\", \"from sys import stdin, stdout  \\ninput = stdin.readline\\n#print = stdout.write\\n\\nfor _ in range(int(input())):\\n    n, k = list(map(int, input().split()))\\n    have = n\\n    for i in range(k - 1):\\n        digits = list(map(int, str(have)))\\n        bf = min(digits) * max(digits)\\n        if bf == 0:\\n            break\\n        have += bf\\n    print(have)\\n\", \"cases = int(input())\\n\\nfor _ in range(cases):\\n    \\n    n, k = [int(s) for s in input().split()]\\n    \\n    mind = -1\\n    \\n    for _ in range(k-1):\\n        \\n        if mind==0:\\n            break\\n        \\n        s = str(n)\\n        mind, maxd = int(s[0]), int(s[0])\\n        \\n        for l in s:\\n            value = int(l)\\n            if value>maxd:\\n                maxd = value\\n            elif value<mind:\\n                mind = value\\n            \\n            if mind==0:\\n                break\\n                \\n        n += maxd*mind\\n\\n    print(n)\\n\", \"t=int(input())\\nfor i in range(t):\\n    a1,k=map(int,input().split())\\n    an=a1\\n    for j in range(1,k):\\n        astr=str(an)\\n        min=9\\n        max=0\\n        for r in range(len(astr)):\\n            if int(astr[r])<min:\\n                min=int(astr[r])\\n            if int(astr[r])>max:\\n                max=int(astr[r])\\n        an+=min*max\\n        if min==0:\\n            break\\n    print(an)\", \"\\n\\nT = int(input())\\n\\nfor t in range(T):\\n    a, K = list(map(int, input().split()))\\n\\n    for k in range(K - 1):\\n        a_ar = list(map(int, list(str(a))))\\n\\n        if min(a_ar) == 0:\\n            break\\n\\n        a += min(a_ar) * max(a_ar)\\n\\n    print(a)\\n\", \"for _ in range(int(input())):\\n    a, k = list(map(int, input().split()))\\n    if '0' in str(a):\\n        print(a)\\n    else:\\n        while '0' not in str(a) and k != 1:\\n            k -= 1\\n            a += int(max(str(a))) * int(min(str(a)))\\n        print(a)\\n\", \"import sys\\ninput = lambda: sys.stdin.readline().strip()\\nt = int(input())\\nwhile t:\\n    t-=1\\n    a1,k = map(int,input().split())\\n    while k>1:\\n        k-=1\\n        val = list(map(int,list(str(a1))))\\n        if min(val)==0:\\n            break\\n        # print(val)\\n        a1 = a1+min(val)*max(val)\\n    print(a1)\", \"for i in range(int(input())):\\n    a, k = map(int, input().split())\\n    while '0' not in str(a) and k > 1:\\n        mi = 10\\n        ma = -1\\n        for j in range(len(str(a))):\\n            if int(str(a)[j]) > ma:\\n                ma = int(str(a)[j])\\n            if int(str(a)[j]) < mi:\\n                mi = int(str(a)[j])\\n        a += ma * mi\\n        k -= 1\\n    print(a)\", \"import sys, os\\n\\nif 'local' in os.environ :\\n    sys.stdin = open('./input.txt', 'r')\\n\\nf = lambda:list(map(int, input().split()))\\n\\n\\nmidigit = lambda x: str(x)\\ndef solve():\\n    t = f()[0]\\n    for _ in range(t):\\n        a, k = f()\\n        if k == 1:\\n            print(a)\\n            continue\\n        for i in range(k-1):\\n            an = a + int(min(str(a))) * int(max(str(a)))\\n            if a == an:\\n                break\\n            a = an\\n        print(a)\\n\\nsolve()\\n\", \"for _ in range(int(input())):\\n    a, k = tuple(map(int, input().split()))\\n\\n    for i in range(k - 1):\\n        nums = [i for i in str(a)]\\n        delta = int(min(nums)) * int(max(nums))\\n\\n        if delta == 0:\\n            break\\n        a += delta\\n\\n    print(a)\\n\", \"t = int(input())\\nbuf = []\\nfor _ in range(t):\\n    a, k = input().split()\\n    k = int(k) - 1\\n    for _ in range(k):\\n        c = min(a)\\n        d = max(a)\\n        a = str(int(a) + int(c) * int(d))\\n        if '0' in a:\\n            break\\n    buf.append(a)\\n\\nprint('\\\\n'.join(buf))\\n\", \"from sys import stdin, stdout\\nimport heapq\\nimport cProfile, math\\nfrom collections import Counter, defaultdict, deque\\nfrom bisect import bisect_left, bisect, bisect_right\\nimport itertools\\nfrom copy import deepcopy\\nfrom fractions import Fraction\\nimport sys, threading\\nimport operator as op\\nfrom functools import reduce\\nimport sys\\n\\n\\ndef get_int():\\n    return int(stdin.readline().strip())\\n\\n\\ndef get_tuple():\\n    return list(map(int, stdin.readline().split()))\\n\\n\\ndef get_list():\\n    return list(map(int, stdin.readline().split()))\\n\\n\\ndef solve():\\n    n,k = get_tuple()\\n    n = str(n)\\n    while '0' not in n and k>1:\\n        n = int(n) + int(max(n))*int(min(n))\\n        n = str(n)\\n        k -= 1\\n    return n\\n\\n\\ndef main():\\n    ans = solve()\\n    print(ans)\\n\\nTestCases = True\\n\\nif TestCases:\\n    for i in range(get_int()):\\n        main()\\nelse:\\n    main()\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"8\\n1 4\\n487 1\\n487 2\\n487 3\\n487 4\\n487 5\\n487 6\\n487 7\\n\"\n  ],\n  \"outputs\": [\n    \"42\\n487\\n519\\n528\\n544\\n564\\n588\\n628\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1355/A", "starter_code": ""}
{"id": 23, "question": "The only difference between easy and hard versions is constraints.\n\nNow elections are held in Berland and you want to win them. More precisely, you want everyone to vote for you.\n\nThere are $n$ voters, and two ways to convince each of them to vote for you. The first way to convince the $i$-th voter is to pay him $p_i$ coins. The second way is to make $m_i$ other voters vote for you, and the $i$-th voter will vote for free.\n\nMoreover, the process of such voting takes place in several steps. For example, if there are five voters with $m_1 = 1$, $m_2 = 2$, $m_3 = 2$, $m_4 = 4$, $m_5 = 5$, then you can buy the vote of the fifth voter, and eventually everyone will vote for you. Set of people voting for you will change as follows: ${5} \\rightarrow {1, 5} \\rightarrow {1, 2, 3, 5} \\rightarrow {1, 2, 3, 4, 5}$.\n\nCalculate the minimum number of coins you have to spend so that everyone votes for you.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 5000$) \u2014 the number of test cases.\n\nThe first line of each test case contains one integer $n$ ($1 \\le n \\le 5000$) \u2014 the number of voters.\n\nThe next $n$ lines contains the description of voters. $i$-th line contains two integers $m_i$ and $p_i$ ($1 \\le p_i \\le 10^9, 0 \\le m_i < n$).\n\nIt is guaranteed that the sum of all $n$ over all test cases does not exceed $5000$.\n\n\n-----Output-----\n\nFor each test case print one integer \u2014 the minimum number of coins you have to spend so that everyone votes for you.\n\n\n-----Example-----\nInput\n3\n3\n1 5\n2 10\n2 8\n7\n0 1\n3 1\n1 1\n6 1\n1 1\n4 1\n4 1\n6\n2 6\n2 3\n2 8\n2 7\n4 4\n5 5\n\nOutput\n8\n0\n7\n\n\n\n-----Note-----\n\nIn the first test case you have to buy vote of the third voter. Then the set of people voting for you will change as follows: ${3} \\rightarrow {1, 3} \\rightarrow {1, 2, 3}$.\n\nIn the second example you don't need to buy votes. The set of people voting for you will change as follows: ${1} \\rightarrow {1, 3, 5} \\rightarrow {1, 2, 3, 5} \\rightarrow {1, 2, 3, 5, 6, 7} \\rightarrow {1, 2, 3, 4, 5, 6, 7}$.\n\nIn the third test case you have to buy votes of the second and the fifth voters. Then the set of people voting for you will change as follows: ${2, 5} \\rightarrow {1, 2, 3, 4, 5} \\rightarrow {1, 2, 3, 4, 5, 6}$.", "solutions": "[\"import heapq\\n\\nfor _ in range(int(input())):\\n    n = int(input())\\n    voters = []\\n    for i in range(n):\\n        m,p = list(map(int, input().split()))\\n        voters.append((m, -p))\\n    voters.sort()\\n    for i in range(n):\\n        voters[i] = (voters[i][0], -voters[i][1])\\n\\n    ans = 0\\n    costs = []\\n    heapq.heapify(costs)\\n    bought = 0\\n    for i in range(n-1, -1, -1):\\n        buysNeeded = voters[i][0] - i  - bought\\n        heapq.heappush(costs, voters[i][1])\\n        while buysNeeded > 0 and len(costs) > 0:\\n            ans += heapq.heappop(costs)\\n            bought += 1\\n            buysNeeded -= 1\\n\\n    print(ans)\\n\", \"'''\\nCreated on 2019. 9. 21.\\n\\n@author: kkhh88\\n'''\\n#q = int(input())\\n#x, y = map(int,input().split(' '))\\n\\nq = int(input())\\nfor _ in range(q):    \\n    n = int(input())\\n    lr = []\\n    for i in range(n):\\n        lr.append(list(map(int,input().split(' '))))\\n    \\n    lr.sort(key=lambda x:x[1], reverse = True)\\n    lr.sort(key=lambda x:x[0])\\n    \\n    cnt = [0]*n\\n    for i in range(n):\\n        if lr[i][0] > i:\\n            if lr[i][0] - i > cnt[lr[i][0]]:\\n                cnt[lr[i][0]] = lr[i][0] - i    \\n    \\n    i = n - 1\\n    tmp = 0\\n    ans = 0\\n    lst = []\\n    while i >= 0:\\n        if i > 0 and lr[i][0] == lr[i-1][0]:\\n            lst.append(lr[i][1])\\n            i = i - 1\\n        else:\\n            lst.append(lr[i][1])\\n            if cnt[lr[i][0]] > tmp:\\n                lst.sort()\\n                for _ in range(tmp, cnt[lr[i][0]]):\\n                    ans = ans + lst.pop(0)\\n                tmp = cnt[lr[i][0]]\\n            i = i - 1\\n    #print (cnt, lr)\\n    print (ans)\", \"import sys\\ndef I():\\n    return sys.stdin.readline().rstrip()\\n\\nclass Heap:\\n    def __init__( self ):\\n        self.l = [ -1 ]\\n        self.n = 0\\n    def n( self ):\\n        return self.n\\n    def top( self ):\\n        return self.l[ 1 ]\\n    def ins( self, x ):\\n        self.l.append( x )\\n        n = len( self.l ) - 1\\n        i = n\\n        while i > 1:\\n            j = i // 2\\n            if self.l[ j ] > self.l[ i ]:\\n                self.l[ j ], self.l[ i ] = self.l[ i ], self.l[ j ]\\n                i = j\\n            else:\\n                break\\n    def pop( self ):\\n        r = self.l[ 1 ]\\n        l = self.l.pop()\\n        n = len( self.l ) - 1\\n        if n:\\n            self.l[ 1 ] = l\\n            i = 1\\n            while True:\\n                j = i * 2\\n                k = j + 1\\n                if k < len( self.l ) and self.l[ i ] > max( self.l[ j ], self.l[ k ] ):\\n                    if self.l[ j ] == min( self.l[ j ], self.l[ k ] ):\\n                        self.l[ i ], self.l[ j ] = self.l[ j ], self.l[ i ]\\n                        i = j\\n                    else:\\n                        self.l[ i ], self.l[ k ] = self.l[ k ], self.l[ i ]\\n                        i = k\\n                elif k < len( self.l ) and self.l[ i ] > self.l[ k ]:\\n                    self.l[ i ], self.l[ k ] = self.l[ k ], self.l[ i ]\\n                    i = k\\n                elif j < len( self.l ) and self.l[ i ] > self.l[ j ]:\\n                    self.l[ i ], self.l[ j ] = self.l[ j ], self.l[ i ]\\n                    i = j\\n                else:\\n                    break\\n        return r\\n\\nt = int( I() )\\nfor _ in range( t ):\\n    n = int( I() )\\n    voter = [ list( map( int, I().split() ) ) for _ in range( n ) ]\\n    h = Heap()\\n    d = {}\\n    for m, p in voter:\\n        if m not in d:\\n            d[ m ] = []\\n        d[ m ].append( p )\\n    need = {}\\n    c = 0\\n    sk = sorted( d.keys() )\\n    for m in sk:\\n        need[ m ] = max( 0, m - c )\\n        c += len( d[ m ] )\\n    c = 0\\n    ans = 0\\n    for m in sk[::-1]:\\n        for p in d[ m ]:\\n            h.ins( p )\\n        while c < need[ m ]:\\n            c += 1\\n            ans += h.pop()\\n    print( ans )\\n\", \"import heapq\\n\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    info = [list(map(int, input().split())) for i in range(n)]\\n    info = sorted(info)\\n    cnt = [0] * n\\n    for i in range(n):\\n        ind = info[i][0]\\n        cnt[ind] += 1\\n    ruiseki_cnt = [0] * (n+1)\\n    for i in range(n):\\n        ruiseki_cnt[i+1] = ruiseki_cnt[i] + cnt[i]\\n    # print(cnt)\\n    # print(ruiseki_cnt)\\n    need = [0] * n\\n    for i in range(1,n):\\n        if cnt[i] != 0 and i > ruiseki_cnt[i]:\\n            need[i] = min(i - ruiseki_cnt[i], i)\\n    # print(need)\\n    info = sorted(info, reverse = True)\\n    #print(info)\\n\\n    num = n - 1\\n    pos = 0\\n    q = []\\n    used_cnt = 0\\n    ans = 0\\n    while True:\\n        if num == -1:\\n            break\\n        while True:\\n            if pos < n and info[pos][0] >= num:\\n                heapq.heappush(q, info[pos][1])\\n                pos += 1\\n            else:\\n                break\\n        if need[num] - used_cnt > 0:\\n            tmp = need[num] - used_cnt\\n            for _ in range(tmp):\\n                ans += heapq.heappop(q)\\n            used_cnt += tmp\\n        num -= 1\\n    print(ans)\", \"import sys\\ninput = sys.stdin.readline\\n\\nimport heapq\\nfrom itertools import accumulate\\n\\nt=int(input())\\n\\nfor test in range(t):\\n    n=int(input())\\n    M=[[] for i in range(n)]\\n    MCOUNT=[0]*(n)\\n\\n    for i in range(n):\\n        m,p=list(map(int,input().split()))\\n        M[m].append(p)\\n        MCOUNT[m]+=1\\n\\n    #print(M)\\n    #print(MCOUNT)\\n\\n    ACC=list(accumulate(MCOUNT))\\n\\n    #print(ACC)\\n    HQ=[]\\n    ANS=0\\n    use=0\\n\\n    for i in range(n-1,-1,-1):\\n        for j in M[i]:\\n            heapq.heappush(HQ,j)\\n\\n        #print(HQ)\\n            \\n        while ACC[i-1]+use<i:\\n            x=heapq.heappop(HQ)\\n            ANS+=x\\n            use+=1\\n\\n\\n\\n    print(ANS)\\n            \\n            \\n        \\n        \\n        \\n\\n    \\n\\n    \\n\", \"import sys\\nimport heapq\\n \\n \\ndef solve(pr, mm):\\n    omm = []\\n    n = len(mm)\\n    for i in range(n + 1):\\n        omm.append([])\\n    \\n    for i in range(n):\\n        omm[mm[i]].append(pr[i])\\n    \\n    for i in range(n + 1):\\n        omm[i] = sorted(omm[i])\\n    \\n    heap = []\\n    c = 0\\n    t = n\\n    p = 0\\n    for i in range(n, -1, -1):\\n        for h in omm[i]:\\n            heapq.heappush(heap, h)\\n            \\n        t -= len(omm[i])\\n        mn = max(i - c - t, 0)\\n        c += mn\\n        for j in range(mn):\\n            p += heapq.heappop(heap)\\n        \\n    return p\\n    \\n \\ndef __starting_point():\\n    t = int(input().strip())\\n    for i in range(t):\\n        n = int(input().strip())\\n        ms = []\\n        ps = []\\n        for j in range(n):\\n            arr = [int(v) for v in input().strip().split(' ')]\\n            ms.append(arr[0])\\n            ps.append(arr[1])\\n            \\n        print(solve(ps, ms))\\n\\n__starting_point()\", \"import heapq\\n \\nfor _ in range(int(input())):\\n    n = int(input())\\n    voters = []\\n    for i in range(n):\\n        m,p = list(map(int, input().split()))\\n        voters.append((m, -p))\\n    voters.sort()\\n    for i in range(n):\\n        voters[i] = (voters[i][0], -voters[i][1])\\n \\n    ans = 0\\n    costs = []\\n    heapq.heapify(costs)\\n    bought = 0\\n    for i in range(n-1, -1, -1):\\n        buysNeeded = voters[i][0] - i  - bought\\n        heapq.heappush(costs, voters[i][1])\\n        while buysNeeded > 0 and len(costs) > 0:\\n            ans += heapq.heappop(costs)\\n            bought += 1\\n            buysNeeded -= 1\\n \\n    print(ans)\", \"import sys\\nfrom heapq import heappop, heappush\\n\\nreader = (line.rstrip() for line in sys.stdin)\\ninput = reader.__next__\\n \\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    mp = []\\n    for i in range(n):\\n        mi, pi = list(map(int, input().split()))\\n        mp.append((mi, pi))\\n    mp.sort()\\n    \\n    prices = []\\n    cost = 0\\n    bribed = 0\\n    i = n - 1\\n    while i >= 0:\\n        currM = mp[i][0]\\n        heappush(prices, mp[i][1])\\n        while i >= 1 and mp[i-1][0] == currM:\\n            i -= 1\\n            heappush(prices, mp[i][1])\\n        already = i + bribed\\n        for k in range(max(0, currM - already)):\\n            cost += heappop(prices)\\n            bribed += 1\\n        i -= 1\\n    \\n    print(cost)\\n\", \"import sys\\ninput = sys.stdin.readline\\nimport heapq as hq\\nt = int(input())\\nfor _ in range(t):\\n  n = int(input())\\n  vt = [list(map(int,input().split())) for i in range(n)]\\n  vt.sort(reverse=True)\\n  q = []\\n  hq.heapify(q)\\n  ans = 0\\n  cnt = 0\\n  for i in range(n):\\n    hq.heappush(q,vt[i][1])\\n    if vt[i][0] >= n-i+cnt:\\n      ans += hq.heappop(q)\\n      cnt += 1\\n  print(ans)\", \"import sys\\nimport heapq as hq\\n\\nreadline = sys.stdin.readline\\nread = sys.stdin.read\\nns = lambda: readline().rstrip()\\nni = lambda: int(readline().rstrip())\\nnm = lambda: map(int, readline().split())\\nnl = lambda: list(map(int, readline().split()))\\nprn = lambda x: print(*x, sep='\\\\n')\\n\\ndef solve():\\n    n = ni()\\n    vot = [tuple(nm()) for _ in range(n)]\\n    vot.sort(key = lambda x: (-x[0], x[1]))\\n    q = list()\\n    c = 0\\n    cost = 0\\n    for i in range(n):\\n        hq.heappush(q, vot[i][1])\\n        while n - i - 1 + c < vot[i][0]:\\n            cost += hq.heappop(q)\\n            c += 1\\n    print(cost)\\n    return\\n\\n\\n# solve()\\n\\nT = ni()\\nfor _ in range(T):\\n    solve()\\n\", \"import sys\\nfrom heapq import *\\n#sys.stdin = open('in', 'r')\\nt = int(input())\\nfor ti in range(t):\\n    n = int(input())\\n    a = []\\n    for i in range(n):\\n        mi, pi = list(map(int, input().split()))\\n        a.append((mi, -pi))\\n    a.sort()\\n    c = 0\\n    h = []\\n    res = 0\\n    for i in reversed(list(range(n))):\\n        heappush(h, -a[i][1])\\n        while c + i < a[i][0]:\\n            res += heappop(h)\\n            c += 1\\n    print(res)\\n\\n\\n#sys.stdout.write('YES\\\\n')\\n#sys.stdout.write(f'{res}\\\\n')\\n#sys.stdout.write(f'{y1} {x1} {y2} {x2}\\\\n')\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n3\\n1 5\\n2 10\\n2 8\\n7\\n0 1\\n3 1\\n1 1\\n6 1\\n1 1\\n4 1\\n4 1\\n6\\n2 6\\n2 3\\n2 8\\n2 7\\n4 4\\n5 5\\n\"\n  ],\n  \"outputs\": [\n    \"8\\n0\\n7\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1251/E1", "starter_code": ""}
{"id": 24, "question": "Try guessing the statement from this picture:  $3$ \n\nYou are given a non-negative integer $d$. You have to find two non-negative real numbers $a$ and $b$ such that $a + b = d$ and $a \\cdot b = d$.\n\n\n-----Input-----\n\nThe first line contains $t$ ($1 \\le t \\le 10^3$) \u2014 the number of test cases.\n\nEach test case contains one integer $d$ $(0 \\le d \\le 10^3)$.\n\n\n-----Output-----\n\nFor each test print one line.\n\nIf there is an answer for the $i$-th test, print \"Y\", and then the numbers $a$ and $b$.\n\nIf there is no answer for the $i$-th test, print \"N\".\n\nYour answer will be considered correct if $|(a + b) - a \\cdot b| \\le 10^{-6}$ and $|(a + b) - d| \\le 10^{-6}$.\n\n\n-----Example-----\nInput\n7\n69\n0\n1\n4\n5\n999\n1000\n\nOutput\nY 67.985071301 1.014928699\nY 0.000000000 0.000000000\nN\nY 2.000000000 2.000000000\nY 3.618033989 1.381966011\nY 997.998996990 1.001003010\nY 998.998997995 1.001002005", "solutions": "[\"for _ in range(int(input())):\\n    d=int(input())\\n    anws=False\\n    if d**2>=4*d:\\n        root=(d**2-4*d)**0.5\\n        a=(d+root)/2\\n        b=(d-root)/2\\n        anws=True\\n    if anws:\\n        print(\\\"Y {:.9f} {:.9f}\\\".format(a,b))\\n    else:\\n        print(\\\"N\\\")\", \"n=int(input())\\n\\nfor i in range(n):\\n    d=int(input())\\n    #b**2-bd+d=0\\n    D=d**2-4*d\\n    if D>=0:\\n        b1=(d+D**0.5)/2\\n        b2=(d-D**0.5)/2\\n    if D<0 or (b1<0 and b2<0):\\n        print(\\\"N\\\")\\n    else:\\n        a1=d-b1\\n        a2=d-b2\\n        if a1>=0 and b1>=0:\\n            print(\\\"Y\\\", \\\"%.9f\\\"%a1, \\\"%.9f\\\"%b1)\\n        elif a2>=0 and b2>=0:\\n            print(\\\"Y\\\", \\\"%.9f\\\"%a2, \\\"%.9f\\\"%b2)\\n        else:\\n            print(\\\"N\\\")\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"7\\n69\\n0\\n1\\n4\\n5\\n999\\n1000\\n\"\n  ],\n  \"outputs\": [\n    \"Y 67.985071301 1.014928699\\nY 0.000000000 0.000000000\\nN\\nY 2.000000000 2.000000000\\nY 3.618033989 1.381966011\\nY 997.998996990 1.001003010\\nY 998.998997995 1.001002005\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1076/C", "starter_code": ""}
{"id": 25, "question": "We are committed to the well being of all participants. Therefore, instead of the problem, we suggest you enjoy a piece of cake.\n\nUh oh. Somebody cut the cake. We told them to wait for you, but they did it anyway. There is still some left, though, if you hurry back. Of course, before you taste the cake, you thought about how the cake was cut.\n\nIt is known that the cake was originally a regular $n$-sided polygon, each vertex of which had a unique number from $1$ to $n$. The vertices were numbered in random order.\n\nEach piece of the cake is a triangle. The cake was cut into $n - 2$ pieces as follows: each time one cut was made with a knife (from one vertex to another) such that exactly one triangular piece was separated from the current cake, and the rest continued to be a convex polygon. In other words, each time three consecutive vertices of the polygon were selected and the corresponding triangle was cut off.\n\nA possible process of cutting the cake is presented in the picture below. [Image] Example of 6-sided cake slicing. \n\nYou are given a set of $n-2$ triangular pieces in random order. The vertices of each piece are given in random order \u2014 clockwise or counterclockwise. Each piece is defined by three numbers \u2014 the numbers of the corresponding $n$-sided cake vertices.\n\nFor example, for the situation in the picture above, you could be given a set of pieces: $[3, 6, 5], [5, 2, 4], [5, 4, 6], [6, 3, 1]$.\n\nYou are interested in two questions.  What was the enumeration of the $n$-sided cake vertices?  In what order were the pieces cut? \n\nFormally, you have to find two permutations $p_1, p_2, \\dots, p_n$ ($1 \\le p_i \\le n$) and $q_1, q_2, \\dots, q_{n - 2}$ ($1 \\le q_i \\le n - 2$) such that if the cake vertices are numbered with the numbers $p_1, p_2, \\dots, p_n$ in order clockwise or counterclockwise, then when cutting pieces of the cake in the order $q_1, q_2, \\dots, q_{n - 2}$ always cuts off a triangular piece so that the remaining part forms one convex polygon.\n\nFor example, in the picture above the answer permutations could be: $p=[2, 4, 6, 1, 3, 5]$ (or any of its cyclic shifts, or its reversal and after that any cyclic shift) and $q=[2, 4, 1, 3]$.\n\nWrite a program that, based on the given triangular pieces, finds any suitable permutations $p$ and $q$.\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases. Then there are $t$ independent sets of input data.\n\nThe first line of each set consists of a single integer $n$ ($3 \\le n \\le 10^5$)\u00a0\u2014 the number of vertices in the cake.\n\nThe following $n - 2$ lines describe the numbers of the pieces vertices: each line consists of three different integers $a, b, c$ ($1 \\le a, b, c \\le n$)\u00a0\u2014 the numbers of the pieces vertices of cake given in random order. The pieces are given in random order.\n\nIt is guaranteed that the answer to each of the tests exists. It is also guaranteed that the sum of $n$ for all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nPrint $2t$ lines \u2014 answers to given $t$ test cases in the order in which they are written in the input. Each answer should consist of $2$ lines.\n\nIn the first line of an answer on a test case print $n$ distinct numbers $p_1, p_2, \\dots, p_n$($1 \\le p_i \\le n$)\u00a0\u2014 the numbers of the cake vertices in clockwise or counterclockwise order.\n\nIn the second line of an answer on a test case print $n - 2$ distinct numbers $q_1, q_2, \\dots, q_{n - 2}$($1 \\le q_i \\le n - 2$)\u00a0\u2014 the order of cutting pieces of the cake. The number of a piece of the cake corresponds to its number in the input.\n\nIf there are several answers, print any. It is guaranteed that the answer to each of the tests exists.\n\n\n-----Example-----\nInput\n3\n6\n3 6 5\n5 2 4\n5 4 6\n6 3 1\n6\n2 5 6\n2 5 1\n4 1 2\n1 3 5\n3\n1 2 3\n\nOutput\n1 6 4 2 5 3 \n4 2 3 1 \n1 4 2 6 5 3 \n3 4 2 1 \n1 3 2 \n1", "solutions": "[\"import os\\nfrom io import BytesIO\\nimport sys\\nimport threading\\n\\n\\nsys.setrecursionlimit(10 ** 9)\\nthreading.stack_size(67108864)\\n\\n\\ndef main():\\n\\n    # input = BytesIO(os.read(0, os.fstat(0).st_size)).readline\\n\\n    def ad(i, j):\\n        nonlocal g\\n        if j in g[i]:\\n            g[i].remove(j)\\n            g[j].remove(i)\\n        else:\\n            g[i].add(j)\\n            g[j].add(i)\\n\\n    def dfs(v):\\n        nonlocal used, g, nans\\n        used[v] = True\\n        nans.append(v + 1)\\n        for el in g[v]:\\n            if not used[el]:\\n                dfs(el)\\n\\n    for _ in range(int(input())):\\n        n = int(input())\\n        cnt = [set() for i in range(n)]\\n        g = [set() for i in range(n)]\\n        used = [False] * n\\n        triangles = []\\n        for i in range(n - 2):\\n            a, b, c = map(int, input().split())\\n            a -= 1\\n            b -= 1\\n            c -= 1\\n            cnt[a].add(i)\\n            cnt[b].add(i)\\n            cnt[c].add(i)\\n            triangles.append((a, b, c))\\n            ad(a, b)\\n            ad(b, c)\\n            ad(a, c)\\n        q = []\\n        ones = []\\n        for i in range(n):\\n            if len(cnt[i]) == 1:\\n                ones.append(i)\\n        ans = []\\n        nans = []\\n        for i in range(n - 2):\\n            t = ones.pop()\\n            ind = cnt[t].pop()\\n            ans.append(ind + 1)\\n            cnt[triangles[ind][0]].discard(ind)\\n            cnt[triangles[ind][1]].discard(ind)\\n            cnt[triangles[ind][2]].discard(ind)\\n            if len(cnt[triangles[ind][0]]) == 1:\\n                ones.append(triangles[ind][0])\\n            if len(cnt[triangles[ind][1]]) == 1:\\n                ones.append(triangles[ind][1])\\n            if len(cnt[triangles[ind][2]]) == 1:\\n                ones.append(triangles[ind][2])\\n        dfs(0)\\n        print(*nans)\\n        print(*ans)\\n\\n\\ntt = threading.Thread(target = main)\\ntt.start()\", \"import sys\\nfrom heapq import heappush, heappop\\nfrom collections import Counter, defaultdict\\n\\n# inf = open('input.txt', 'r')\\n# reader = (map(int, line.split()) for line in inf)\\nreader = (list(map(int, line.split())) for line in sys.stdin)\\n\\ndef insert(pq, value, entry_finder, push_id):\\n    entry = [value, push_id]\\n    entry_finder[push_id] = entry\\n    heappush(pq, entry)    \\n\\ndef remove(entry_finder, push_id):\\n    entry = entry_finder.pop(push_id)\\n    entry[-1] = -1\\n    \\ndef extract_min(pq, entry_finder):\\n    while pq:\\n        value, push_id = heappop(pq)\\n        if push_id > 0:\\n            del entry_finder[push_id]\\n            return (push_id, value)\\n    return (-1, '*')\\n\\nt, = next(reader)\\nfor test in range(t):\\n    n, = next(reader)\\n    pq = []\\n    entry_finder = {}\\n    triangle = [tuple(next(reader)) for _ in range(n-2)]\\n    deg = Counter()\\n    v_tri = defaultdict(list)\\n    used = set()\\n    for i, tri in enumerate(triangle):\\n        for v in tri:\\n            deg[v] += 1\\n            v_tri[v].append(i)\\n    for v, value in list(deg.items()):\\n        insert(pq, value, entry_finder, push_id=v)\\n    g = [set() for _ in range(n+1)]\\n    ansQ = []\\n    for _ in range(n-2):\\n        v, value = extract_min(pq, entry_finder)\\n        while True:\\n            i = v_tri[v].pop()\\n            if i not in used:\\n                break\\n        used.add(i)\\n        ansQ.append(i+1)\\n        tri = triangle[i]\\n        tos = [to for to in tri if to != v]\\n        for to in tos:\\n            if to in g[v]:\\n                g[v].remove(to)\\n                g[to].remove(v)\\n            else:\\n                g[v].add(to)\\n                g[to].add(v)\\n            deg[to] -= 1\\n            remove(entry_finder, push_id=to)\\n            insert(pq, deg[to], entry_finder, push_id=to)\\n        to1, to2 = tos\\n        if to1 in g[to2]:\\n            g[to1].remove(to2)\\n            g[to2].remove(to1)\\n        else:\\n            g[to1].add(to2)\\n            g[to2].add(to1)\\n    ansP = []\\n    visited = [False] * (n+1)\\n    s = 1\\n    stack = [s]\\n#     print(g)\\n    while stack:\\n        v = stack.pop()\\n        if not visited[v]:\\n            visited[v] = True\\n            ansP.append(v)\\n            for to in g[v]:\\n                stack.append(to)\\n    print(*ansP)\\n    print(*ansQ)\\n\\n# inf.close()\\n\", \"class Union:\\n    def __init__(self, n):\\n        self.p    = [i for i in range(n+1)]\\n        self.rank = [0] * (n+1) \\n        \\n    def find(self, x):\\n        if self.p[x] != x:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n    \\n    def union(self, x, y):\\n        x = self.find(x)\\n        y = self.find(y)\\n        \\n        if x != y:\\n            if self.rank[x] < self.rank[y]:\\n                self.p[x]     = y\\n                self.rank[y] += self.rank[x]\\n            else:\\n                self.p[y]     = x\\n                self.rank[x] += self.rank[y]\\n\\ndef push(g, u, v):\\n    if u not in g:\\n        g[u] = []\\n    if v not in g:\\n        g[v] = []\\n        \\n    g[u].append(v)\\n    g[v].append(u)\\n    \\n    \\ndef push_c(cnt, u, i):\\n    if u not in cnt:\\n        cnt[u] = set()\\n    cnt[u].add(i) \\n    \\ndef process(cnt, tup, deg0, order, g, U, u):\\n    if len(cnt[u]) > 0:\\n        i = next(iter(cnt[u]))\\n    else:\\n        return\\n    \\n    for v in tup[i]:\\n        cnt[v].remove(i)\\n        \\n        if len(cnt[v]) == 1:\\n            deg0.append(v)\\n            \\n    v, w = None, None\\n    for x in tup[i]:\\n        if x == u:\\n            continue\\n        if v is None:\\n            v = x\\n        else:\\n            w = x\\n    \\n    order.append(i)\\n    \\n    if U.find(u) != U.find(v):\\n        U.union(u, v)\\n        push(g, u, v)\\n        \\n    if U.find(u) != U.find(w):\\n        U.union(u, w)\\n        push(g, u, w)\\n        \\ndef solve():        \\n    n   = int(input())\\n    tup = [list(map(int, input().split())) for _ in range(n-2)]\\n    g = {}\\n    cnt={}\\n    order = []\\n\\n    for i, [u,v,w] in enumerate(tup):\\n        push_c(cnt, u, i)\\n        push_c(cnt, v, i)\\n        push_c(cnt, w, i)\\n    \\n    U = Union(n)\\n    deg0 = [x for x, num in list(cnt.items()) if len(num) == 1]\\n\\n    while len(deg0) > 0:\\n        u = deg0.pop()\\n        process(cnt, tup, deg0, order, g, U, u)\\n    \\n    used = [0] * (n-2)   \\n    for i in order:\\n        used[i] = 1\\n            \\n    for i, x in enumerate(used):\\n        if x == 0:\\n            order.append(i)\\n            \\n    circle=[]\\n    used = [0] * (n+1)    \\n\\n    for u in g:\\n        if len(g[u]) == 1:\\n            circle.append(u)\\n            used[u]=1\\n            break\\n    i=0\\n    \\n    while i<len(circle):\\n        u=circle[i]\\n        for v in g[u]:\\n            if used[v]==0:\\n                used[v]=1\\n                circle.append(v)\\n        i+=1        \\n        \\n    print(' '.join([str(x) for x in circle]))\\n    print(' '.join([str(x+1) for x in order]))\\n    \\nfor _ in range(int(input())):\\n    solve()\\n\", \"\\ndef get_edge(vertex1, vertex2):\\n    return (vertex1, vertex2) if vertex1 < vertex2 else (vertex2, vertex1)\\n\\n\\ndef swap(arr, i, j):\\n    temp = arr[i]\\n    arr[i] = arr[j]\\n    arr[j] = temp\\n\\n\\ndef __starting_point():\\n    T = int(input())\\n    for t in range(T):\\n        n = int(input())\\n        pieces = []\\n        for c in range(n-2):\\n            inp = input().rstrip().split(\\\" \\\")\\n            pieces.append([int(inp[0]), int(inp[1]), int(inp[2])])\\n\\n        # Preparing the graph\\n        G = {}\\n        piece_index = 0\\n        while piece_index < len(pieces):\\n            for vertex in pieces[piece_index]:\\n                if vertex not in G:\\n                    G[vertex] = {}\\n                G[vertex][piece_index] = True\\n            piece_index += 1\\n\\n        # prepare list of vertices associated with only one piece\\n        # That piece can be safely removed\\n        next_vertices = []\\n        for vertex in G:\\n            if len(G[vertex]) == 1:\\n                next_vertices.append(vertex)\\n\\n        q = []\\n        border_edges = {}\\n        non_border_edges = {}\\n        while len(next_vertices) > 0:\\n            v = next_vertices.pop()\\n            if len(G[v]) > 0:\\n                piece_index = list(G[v].keys()).pop()\\n                q.append(str(piece_index+1))\\n                piece = pieces[piece_index]\\n                G.pop(v)\\n                for vertex_index in range(3):\\n                    vertex = piece[vertex_index]\\n                    if vertex != v:\\n                        G[vertex].pop(piece_index)\\n                        if len(G[vertex]) == 1:\\n                            next_vertices.append(vertex)\\n                        edge = get_edge(v, vertex)\\n                        if edge not in non_border_edges:\\n                            border_edges[edge] = True\\n                    else:\\n                        swap(piece, 0, vertex_index)\\n                edge = get_edge(piece[1], piece[2])\\n                non_border_edges[edge] = True\\n\\n        border_edges = list(border_edges.keys())\\n        vertices = {}\\n        for a, b in border_edges:\\n            if a not in vertices:\\n                vertices[a] = {}\\n            if b not in vertices:\\n                vertices[b] = {}\\n            vertices[a][b] = True\\n            vertices[b][a] = True\\n\\n        start = None\\n        start_val = 5000000000\\n        for vertex in vertices:\\n            if len(vertices[vertex]) < start_val:\\n                start = vertex\\n                start_val = len(vertices[vertex])\\n\\n        v = start\\n        p = []\\n        while len(p) < n:\\n            p.append(str(v))\\n            assert len(vertices[v]) <= 1\\n            if len(vertices[v]) == 1:\\n                neighbor = list(vertices[v].keys()).pop()\\n                vertices[neighbor].pop(v)\\n                v = neighbor\\n\\n        print(\\\" \\\".join(p))\\n        print(\\\" \\\".join(q))\\n\\n__starting_point()\", \"import heapq\\n\\nt = int(input())\\n\\nfor _ in range(t):\\n    n = int(input())\\n    counts = [0] * n\\n    triangles = [set() for _ in range(n)]\\n    assign_order = {}\\n    for i in range(n - 2):\\n        a, b, c = [x - 1 for x in list(map(int, input().split()))]\\n        t = (a, b, c)\\n        assign_order[t] = i\\n        for x in t:\\n            counts[x] += 1\\n            triangles[x].add(t)\\n\\n    not_edges = set()\\n    edges = set()\\n    order = []\\n    que = [i for i in range(n) if counts[i] == 1]\\n    index = 0\\n    while index < n - 2:\\n        curr = que[index]\\n        tt = triangles[curr].pop()  # should remain one\\n        order.append(assign_order[tt])\\n        t = set(tt)\\n        t.remove(curr)\\n        a, b = t.pop(), t.pop()\\n        for e in (curr, a), (curr, b):\\n            if e not in not_edges:\\n                edges.add(e)\\n        if index < n - 3:\\n            not_edges.add((a, b))\\n            not_edges.add((b, a))\\n        else:\\n            if (a, b) not in not_edges:\\n                edges.add((a, b))\\n\\n        for x in a, b:\\n            counts[x] -= 1\\n            if counts[x] == 1:\\n                que.append(x)\\n            triangles[x].remove(tt)\\n        index += 1\\n\\n    e = [[] for _ in range(n)]\\n    for a, b in edges:\\n        e[a].append(b)\\n        e[b].append(a)\\n\\n    visited = [False] * n\\n    a = 0\\n    answer = []\\n    for i in range(n):\\n        visited[a] = True\\n        answer.append(a)\\n        for b in e[a]:\\n            if not visited[b]:\\n                a = b\\n                break\\n\\n    print(' '.join(map(str, [x + 1 for x in answer])))\\n    print(' '.join(map(str, [x + 1 for x in order])))\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n6\\n3 6 5\\n5 2 4\\n5 4 6\\n6 3 1\\n6\\n2 5 6\\n2 5 1\\n4 1 2\\n1 3 5\\n3\\n1 2 3\\n\"\n  ],\n  \"outputs\": [\n    \"1 6 4 2 5 3 \\n4 2 3 1 \\n1 4 2 6 5 3 \\n3 4 2 1 \\n1 3 2 \\n1 \\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1282/E", "starter_code": ""}
{"id": 26, "question": "You are given a special jigsaw puzzle consisting of $n\\cdot m$ identical pieces. Every piece has three tabs and one blank, as pictured below. $\\{3$ \n\nThe jigsaw puzzle is considered solved if the following conditions hold:  The pieces are arranged into a grid with $n$ rows and $m$ columns.  For any two pieces that share an edge in the grid, a tab of one piece fits perfectly into a blank of the other piece. \n\nThrough rotation and translation of the pieces, determine if it is possible to solve the jigsaw puzzle.\n\n\n-----Input-----\n\nThe test consists of multiple test cases. The first line contains a single integer $t$ ($1\\le t\\le 1000$)\u00a0\u2014 the number of test cases. Next $t$ lines contain descriptions of test cases.\n\nEach test case contains two integers $n$ and $m$ ($1 \\le n,m \\le 10^5$).\n\n\n-----Output-----\n\nFor each test case output a single line containing \"YES\" if it is possible to solve the jigsaw puzzle, or \"NO\" otherwise. You can print each letter in any case (upper or lower).\n\n\n-----Example-----\nInput\n3\n1 3\n100000 100000\n2 2\n\nOutput\nYES\nNO\nYES\n\n\n\n-----Note-----\n\nFor the first test case, this is an example solution:  [Image] \n\nFor the second test case, we can show that no solution exists.\n\nFor the third test case, this is an example solution: $\\left\\{\\begin{array}{l}{3} \\\\{3} \\end{array} \\right\\}$", "solutions": "[\"for _ in range(int(input())):\\n    n, m = list(map(int, input().split()))\\n    if n < m:\\n        n, m = m, n # n > m\\n\\n    if m == 1:\\n        print(\\\"YES\\\")\\n        continue\\n\\n    if m == 2 and n == 2:\\n        print(\\\"YES\\\")\\n        continue\\n\\n    print(\\\"NO\\\")\\n\", \"for zz in range(int(input())):\\n    n, m = list(map(int, input().split()))\\n    if n == 1 or m == 1 or (n <= 2 and m <= 2):\\n        print('YES')\\n    else:\\n        print('NO')\\n\", \"for i in range(int(input())):\\n    a, b = list(map(int,input().split()))\\n    if a > 2 and b >= 2 or b > 2 and a >= 2:\\n        print(\\\"NO\\\")\\n    else:\\n        print(\\\"YES\\\")\\n\", \"t=int(input())\\nfor i in range(t):\\n  a,b=map(int,input().split())\\n  if a==2 and b==2:\\n    print('YES')\\n  elif a==1:\\n    print('YES')\\n  elif b==1:\\n    print('YES')\\n  else:\\n    print('NO')\", \"for _ in range(int(input())):\\n\\ta, b = list(map(int, input().split()))\\n\\tif (a == 1 or b == 1) or (a == 2 and b == 2):\\n\\t\\tprint(\\\"YES\\\")\\n\\telse:\\n\\t\\tprint(\\\"NO\\\")\\n\", \"t=int(input())\\nfor _ in range(t):\\n    n,m=list(map(int, input().split()))\\n    print('YES' if n == 1 or m == 1 or n == 2 and m == 2 else 'NO')\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n, m = list(map(int, input().split()))\\n    if n == 1 or m == 1 or (m == 2 and n == 2):\\n        print('YES')\\n    else:\\n        print('NO')\\n\", \"import sys\\n# from collections import deque\\n\\n# print(help(deque))\\n# 26\\ninput = lambda: sys.stdin.readline().strip()\\nipnut = input\\nfor i in range(int(input())):\\n    n,m = map(int,ipnut().split())\\n    if n==m==2 or min(n,m)==1:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n    # n = int(input())\\n    # s = list(map(int,input()))\\n\\\"\\\"\\\"\\n10\\n10 11 12 13 14 15 16 17 11 11\\n\\\"\\\"\\\"\", \"t = int(input())\\nfor q in range(0, t):\\n    n, k = map(int, input().split())\\n    # a = list(map(int, input().split()))\\n    # n = int(input())\\n    # print(n)\\n    if n == k == 2:\\n        print(\\\"YES\\\")\\n    elif n == 1 or k == 1:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"import sys\\nints = (int(x) for x in sys.stdin.read().split())\\nsys.setrecursionlimit(3000)\\n\\ndef main():\\n    ntc = next(ints)\\n    for tc in range(ntc):\\n        n, m = (next(ints) for i in range(2))\\n        print('YES' if n==1 or m==1 or n==m==2 else 'NO')\\n    return\\n\\nmain()\\n\", \"from sys import stdin,stdout                           #\\nimport math                                            #\\nimport heapq                                           #\\n                                                       #\\nt = 1                                                  #\\ndef aint():                                            #\\n\\treturn int(input().strip())                        #\\ndef lint():                                            #\\n\\treturn list(map(int,input().split()))              #\\ndef fint():                                            #\\n\\treturn list(map(int,stdin.readline().split()))     #\\n                                                       #\\t\\n########################################################\\n\\ndef main():\\n\\tn,m=lint()\\n\\tif n==1 or m==1:\\n\\t\\tprint(\\\"YES\\\")\\n\\telif n==2 and m==2:\\n\\t\\tprint(\\\"YES\\\")\\n\\telse:\\n\\t\\tprint(\\\"NO\\\")\\n\\t#solve\\n\\nt=int(input())\\n\\n########################################################\\nfor i in range(t):                                     #\\n\\t#print(\\\"Case #\\\"+str(i+1)+\\\":\\\",end=\\\" \\\")\\t\\t       #\\n\\tmain()                                             #\", \"t=int(input())\\nfor i in range(t):\\n    n,m=map(int,input().split())\\n    if n == 1 or m==1:print(\\\"YES\\\")\\n    elif n==2 and m==2:print(\\\"YES\\\")\\n    else:print(\\\"NO\\\")\", \"for f in range(int(input())):\\n    n,m=map(int,input().split())\\n    if n==1 or m==1 or (n==2 and m==2):\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"for _ in range(int(input())):\\n    n, m = list(map(int, input().split()))\\n    print( \\\"YES\\\" if min(n, m) == 1 or max(n, m) <= 2 else \\\"NO\\\" )\\n\", \"t = int(input())\\nfor i in range(t):\\n    n, m = map(int, input().split())\\n    if n != 1 and m != 1 and n*m != 4:\\n        print(\\\"NO\\\")\\n    else:\\n        print(\\\"YES\\\")\", \"t = int(input())\\nfor case in range(t):\\n    n, m = list(map(int, input().split()))\\n    if (min(n, m) == 1):\\n        print('YES')\\n    elif n == m and n == 2:\\n        print('YES')\\n    else:\\n        print('NO')\", \"import sys\\n\\nreadline = sys.stdin.readline\\n\\nns = lambda: readline().rstrip()\\nni = lambda: int(readline().rstrip())\\nnm = lambda: list(map(int, readline().split()))\\nnl = lambda: list(map(int, readline().split()))\\n\\ndef solve():\\n    n, m = nm()\\n    if min(n, m) == 1 or max(n, m) == 2:\\n        print('YES')\\n    else:\\n        print('NO')\\n\\n# solve()\\n\\nT = ni()\\nfor _ in range(T):\\n    solve()\\n\", \"t = int(input())\\nfor i in range(t):\\n    n, m = list(map(int, input().split()))\\n    if n == 1 or m == 1 or (n == 2 and m == 2):\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"import sys\\nT = int(sys.stdin.readline().strip())\\ndef getT(line):\\n    return map(int, line.strip().split(\\\" \\\"))\\n\\nfor t in range(T):\\n    (m,n) = getT(sys.stdin.readline())\\n    if min(m, n) == 1: print(\\\"YES\\\")\\n    elif min(m, n) == 2 and max(m, n) == 2: print(\\\"YES\\\")\\n    else: print(\\\"NO\\\")\", \"for _ in range(int(input())):\\n    a,b=map(int,input().split())\\n    if min(a,b)==1:\\n        print('YES')\\n    elif a==2 and b==2:\\n        print('YES')\\n    else:\\n        print('NO')\", \"#from sys import stdin, stdout, setrecursionlimit\\n#input = stdin.readline\\n#print = stdout.write\\nfor _ in range(int(input())):\\n    n, m = list(map(int, input().split()))\\n    ans = 'NO'\\n    if n == 1 or m == 1 or (n == 2 and m == 2):\\n        ans = 'YES'\\n    print(ans)\\n\\n\\n\\n\\n\\n\\n\", \"for _ in range(int(input())):\\n    a, b = list(map(int, input().split()))\\n    if a == 1 or b == 1:\\n        print('YES')\\n    elif a == b == 2:\\n        print('YES')\\n    else:\\n        print('NO')\\n\", \"def solve():\\n    N,M = list(map(int,input().split()))\\n    if N==1 or M==1:\\n        print(\\\"YES\\\")\\n    elif N==2 and M==2:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\\nfor _ in range(int(input())):\\n        solve()\\n\", \"\\n\\ndef main():\\n    n, m = map(int, input().split())\\n    if n == 2 and m == 2:\\n        print(\\\"YES\\\")\\n    else:\\n        if n == 1 or m == 1:\\n            print(\\\"YES\\\")\\n        else:\\n            print(\\\"NO\\\")\\n\\n\\n\\ndef __starting_point():\\n    t = int(input())\\n    for i in range(t):\\n        main()\\n__starting_point()\", \"t = int(input())\\nfor i10 in range(t):\\n    n, m = list(map(int, input().split()))\\n    if n == 1 or m == 1 or n + m == 4:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"for _ in range(int(input())):\\n    n, m = list(map(int, input().split()))\\n    if n == 2 and m == 2:\\n        print(\\\"YES\\\")\\n        continue\\n    if n == 1 or m == 1:\\n        print(\\\"YES\\\")\\n        continue\\n    print(\\\"NO\\\")\\n\", \"\\n\\nt = int(input())\\n\\nfor fk in range(t):\\n    n, m = [int(x) for x in input().split()]\\n\\n    if n == 1 or m == 1:\\n        print('YES')\\n\\n    elif n==2 and m == 2:\\n        print('YES')\\n\\n    else : print('NO')\", \"q = int(input())\\n\\nfor _ in range(q):\\n    n, m = list(map(int, input().split()))\\n    if n == 2 and m == 2 or n == 1 or m == 1:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"q = int(input())\\nfor i in range(q):\\n    n, m = list(map(int, input().split()))\\n    if (n == 1 or m == 1):\\n        print(\\\"YES\\\")\\n    elif (n == m == 2):\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"n=int(input())\\nfor i in range(n):\\n    a,b=[int(i) for i in input().split()]\\n    if (a==b==2) or a==1 or b==1:\\n        print('YES')\\n    else:\\n        print('NO')\\n\", \"t = int(input())\\nfor u in range(t):\\n    n,m=list(map(int,input().split()))\\n    x = 2*n+2*m\\n    y = 3*n*m\\n    z = n*m\\n    if x+z >= y:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"for _ in range(int(input())):\\n    n, m = tuple(map(int, input().split()))\\n\\n    a = (n - 1) * m + (m - 1) * n\\n    b = n * m\\n\\n    if a <= b:\\n        print('YES')\\n    else:\\n        print('NO')\", \"t = int(input())\\n\\nfor case in range(t):\\n    n, m = map(int, input().split())\\n    ans = 'NO'\\n    if (n == m == 2):\\n        ans = 'YES'\\n    elif (n == 1 or m == 1):\\n        ans = 'YES'\\n    print (ans)\", \"t = int(input())\\nfor case in range(t):\\n    n, m = list(map(int, input().split()))\\n    perimeter = 2*n + 2*m\\n\\n    inside = m*(n-1) + n*(m-1)\\n    nobs = 2*n*m\\n\\n    if (nobs > perimeter):\\n        print (\\\"NO\\\")\\n    else:\\n        print (\\\"YES\\\")\\n\", \"for _ in range(int(input())):\\n    n, m = list(map(int, input().split()))\\n    if n * m <= n + m:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"t = int(input())\\nfor i in range(t):\\n    n, m = list(map(int, input().split()))\\n    if min(n, m) == 1 or m==2 and n==2:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"# n = int(input())\\n# l = list(map(int, input().split()))\\nfor tt in range(int(input())):\\n\\tn, m = map(int, input().split())\\n\\tif(n==1 or m==1 or (n==2 and m==2)):\\n\\t\\tprint(\\\"YES\\\")\\n\\t\\tcontinue\\n\\tprint(\\\"NO\\\")\", \"for _ in range(int(input())):\\n    n, m = list(map(int, input().split()))\\n    if n == m and n == 2:\\n        print('YES')\\n    elif n >= 2 and m >= 2:\\n        print('NO')\\n    else:\\n        print('YES')\\n\", \"for _ in range(int(input())):\\n    n, m = map(int, input().split())\\n    print('YES' if n == 1 or m == 1 or (n == 2 and m == 2) else 'NO')\", \"import sys\\nimport math\\nimport itertools\\nimport functools\\nimport collections\\nimport operator\\nimport fileinput\\nimport copy\\n\\nORDA = 97       #a\\ndef ii(): return int(input())\\ndef mi(): return map(int, input().split())\\ndef li(): return [int(i) for i in input().split()]\\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\\ndef revn(n): return str(n)[::-1]\\ndef dd(): return collections.defaultdict(int)\\ndef ddl(): return collections.defaultdict(list)\\ndef sieve(n):\\n    if n < 2: return list()\\n    prime = [True for _ in range(n + 1)]\\n    p = 3\\n    while p * p <= n:\\n        if prime[p]:\\n            for i in range(p * 2, n + 1, p):\\n                prime[i] = False\\n        p += 2\\n    r = [2]\\n    for p in range(3, n + 1, 2):\\n        if prime[p]:\\n            r.append(p)\\n    return r\\ndef divs(n, start=1):\\n    r = []\\n    for i in range(start, int(math.sqrt(n) + 1)):\\n        if (n % i == 0):\\n            if (n / i == i):\\n                r.append(i)\\n            else:\\n                r.extend([i, n // i])\\n    return r\\ndef divn(n, primes):\\n    divs_number = 1\\n    for i in primes:\\n        if n == 1:\\n            return divs_number\\n        t = 1\\n        while n % i == 0:\\n            t += 1\\n            n //= i\\n        divs_number *= t\\ndef prime(n):\\n    if n == 2: return True\\n    if n % 2 == 0 or n <= 1: return False\\n    sqr = int(math.sqrt(n)) + 1\\n    for d in range(3, sqr, 2):\\n        if n % d == 0: return False\\n    return True\\ndef convn(number, base):\\n    newnumber = 0\\n    while number > 0:\\n        newnumber += number % base\\n        number //= base\\n    return newnumber\\ndef cdiv(n, k): return n // k + (n % k != 0)\\n\\n\\nfor _ in range(ii()):\\n    n, m = mi()\\n    if n == 1 or m == 1 or m == 2 and n == 2:\\n        print('YES')\\n    else:\\n        print('NO')\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n1 3\\n100000 100000\\n2 2\\n\"\n  ],\n  \"outputs\": [\n    \"YES\\nNO\\nYES\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1345/A", "starter_code": ""}
{"id": 27, "question": "There are $n$ positive integers $a_1, a_2, \\dots, a_n$. For the one move you can choose any even value $c$ and divide by two all elements that equal $c$.\n\nFor example, if $a=[6,8,12,6,3,12]$ and you choose $c=6$, and $a$ is transformed into $a=[3,8,12,3,3,12]$ after the move.\n\nYou need to find the minimal number of moves for transforming $a$ to an array of only odd integers (each element shouldn't be divisible by $2$).\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases in the input. Then $t$ test cases follow.\n\nThe first line of a test case contains $n$ ($1 \\le n \\le 2\\cdot10^5$) \u2014 the number of integers in the sequence $a$. The second line contains positive integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$).\n\nThe sum of $n$ for all test cases in the input doesn't exceed $2\\cdot10^5$.\n\n\n-----Output-----\n\nFor $t$ test cases print the answers in the order of test cases in the input. The answer for the test case is the minimal number of moves needed to make all numbers in the test case odd (i.e. not divisible by $2$).\n\n\n-----Example-----\nInput\n4\n6\n40 6 40 3 20 1\n1\n1024\n4\n2 4 8 16\n3\n3 1 7\n\nOutput\n4\n10\n4\n0\n\n\n\n-----Note-----\n\nIn the first test case of the example, the optimal sequence of moves can be as follows:\n\n  before making moves $a=[40, 6, 40, 3, 20, 1]$;  choose $c=6$;  now $a=[40, 3, 40, 3, 20, 1]$;  choose $c=40$;  now $a=[20, 3, 20, 3, 20, 1]$;  choose $c=20$;  now $a=[10, 3, 10, 3, 10, 1]$;  choose $c=10$;  now $a=[5, 3, 5, 3, 5, 1]$ \u2014 all numbers are odd. \n\nThus, all numbers became odd after $4$ moves. In $3$ or fewer moves, you cannot make them all odd.", "solutions": "[\"tests = int(input())\\nfor test in range(tests):\\n    n = int(input())\\n    a = [int(i) for i in input().split()]\\n    d = {}\\n    for i in range(n):\\n        s = 0\\n        while a[i] % 2 == 0:\\n            a[i] //= 2\\n            s += 1\\n        if a[i] in list(d.keys()):\\n            d[a[i]] = max(s, d[a[i]])\\n        else:\\n            d[a[i]] = s\\n    s = 0\\n    for i in list(d.keys()):\\n        s += d[i]\\n    print(s)\\n\", \"t=int(input())\\nfor g in range(t):\\n  n=int(input())\\n  a=list(map(int,input().split()))\\n  b=list()\\n  for i in range(n):\\n    while a[i]%2==0:\\n      b.append(a[i])\\n      a[i]=a[i]//2\\n  b.sort()\\n  count=1\\n  for i in range(len(b)-1):\\n    if b[i]!=b[i+1]:\\n      count+=1\\n  if len(b)==0:\\n    print(0)\\n  else:\\n    print(count)\\n\", \"t=int(input())\\n\\ndef power(n):\\n    res=0\\n    while n%2==0:\\n        res+=1\\n        n//=2\\n    if n not in d:\\n        d[n]=0\\n    d[n]=max(d[n],res)\\nfor i in range(t):\\n    n=int(input())\\n    a=list(map(int,input().split()))\\n    maxx=0\\n    d={}\\n    for num in a:\\n        power(num)\\n    print(sum(list(d.values())))\\n    # print(maxx)\\n\", \"for _ in range(int(input())):\\n\\td = dict()\\n\\tN = int(input())\\n\\ta = list(map(int, input().split()))\\n\\tfor i in range(N):\\n\\t\\tc = 0\\n\\t\\ttmp = a[i]\\n\\t\\twhile tmp % 2 != 1:\\n\\t\\t\\ttmp = tmp // 2\\n\\t\\t\\tc += 1\\n\\t\\tif tmp in d:\\n\\t\\t\\td[tmp] = max(d[tmp], c)\\n\\t\\telse:\\n\\t\\t\\td[tmp] = c\\n\\tres = 0\\n\\tfor i in list(d.keys()):\\n\\t\\tres += d[i]\\n\\tprint(res)\\n\\n\", \"from collections import defaultdict\\n\\n\\ndef f(n):\\n    st = 0\\n    while n % 2 == 0:\\n        n //= 2\\n        st += 1\\n    return n, st\\n\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    d = defaultdict(int)\\n    for i in input().split():\\n        el = int(i)\\n        os, st = f(el)\\n        d[os] = max(d[os], st)\\n    s = 0\\n    for el in list(d.values()):\\n        s += el\\n    print(s)\\n\", \"t = int(input())\\nfor j in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    s = set()\\n    ans = 0\\n    for i in range(n):\\n        k = a[i]\\n        while k % 2 == 0 and k not in s:\\n            s.add(k)\\n            k = k // 2\\n            ans += 1\\n    print(ans)\\n\", \"t = int(input())\\nfor g in range(t):\\n    n = int(input())\\n    st = set()\\n    a = [int(i) for i in input().split()]\\n    for i in range(n):\\n        q = a[i]\\n        while q % 2 == 0:\\n            st.add(q)\\n            q //= 2\\n    print(len(st))\\n\", \"def f(x):\\n    tmp = x\\n    z = 0\\n    while tmp % 2 == 0:\\n        tmp //= 2\\n        z += 1\\n    return [tmp, z]\\n\\nfor i in range(int(input())):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    sl = dict()\\n    for x in a:\\n        y, z = f(x)\\n        if sl.get(y) == None:\\n            sl[y] = z\\n        else:\\n            sl[y] = max(sl[y], z)\\n    ans = 0\\n    for x in sl.keys():\\n        ans += sl[x]\\n    print(ans)\", \"for q in range(int(input())):\\n    n = int(input())\\n    line = list(map(int, input().split()))\\n    Q = dict()\\n    for i in range(n):\\n        l = 0\\n        r = 100\\n        while r - l > 1:\\n            m = (l + r) // 2\\n            if line[i] % (1 << m) == 0:\\n                l = m\\n            else:\\n                r = m\\n        f = line[i] // (1 << l)\\n        if f in Q:\\n            Q[f] = max(Q[f], l)\\n        else:\\n            Q[f] = l\\n    Q = list(Q.items())\\n    ans = 0\\n    for a, b in Q:\\n        ans += b\\n    print(ans)\\n    #print(Q)\\n\", \"import heapq\\nimport sys\\ninput = lambda : sys.stdin.readline()\\nfor i in range(int(input())):\\n    n = int(input())\\n    s = set()\\n    h  = []\\n    for i in map(int,input().split()):\\n        if i%2==0:\\n            if i in s:\\n                continue\\n            s.add(i)\\n            heapq.heappush(h,-i)\\n    ans = 0\\n    while h:\\n        i = -heapq.heappop(h)//2\\n        ans+=1\\n        if i % 2 == 0:\\n            if i in s:\\n                continue\\n            s.add(i)\\n            heapq.heappush(h, -i)\\n\\n    print(ans)\", \"t = int(input())\\n\\n\\n\\nfor _ in range(t):\\n    used_q = set()\\n    n = int(input())\\n    nums = list(map(int,input().split(' ')))\\n    for i in range(len(nums)):\\n        q = nums[i]\\n        while q % 2 == 0:\\n            if q in used_q:\\n                q = q // 2\\n            else:\\n                used_q.add(q)\\n                q = q // 2\\n    print(len(used_q))\\n\\n\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    A = list(map(int, input().split()))\\n    dell = []\\n    for i in range(n):\\n        new = 0\\n        while A[i] % 2 != 1:\\n            A[i] //= 2\\n            new += 1\\n        dell.append([A[i], new])\\n    dicter = {}\\n    for el in dell:\\n        if el[1] > dicter.get(el[0], -1):\\n            dicter[el[0]] = el[1]\\n    ans = 0\\n    for el in dicter:\\n        ans += dicter[el]\\n    print(ans)\", \"for _ in range(int(input())):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    b = dict()\\n    for j in range(n):\\n        if a[j] % 2 == 0:\\n            b[a[j]] = b.get(a[j], 0) + 1\\n    k = 0\\n    for key in b:\\n        c = key\\n        while c % 2 == 0:\\n            k += 1\\n            c = c // 2\\n            if c in b.keys():\\n                break\\n    print(k)\", \"t=int(input())\\nfor r in range(t):\\n q=input()\\n a=list(map(int,input().split()))\\n d=dict()\\n for w in a:\\n  s=0\\n  while w%2==0:\\n   w//=2\\n   s+=1\\n  if w in list(d.keys()):\\n   d[w]=max([d[w],s])\\n  else:\\n   d[w]=s\\n e=0\\n for w in list(d.keys()):\\n  e+=d[w]\\n print(e)\\n\", \"import sys\\nimport math\\nimport heapq\\n\\ndef input():\\n    return sys.stdin.readline().strip()\\ndef iinput():\\n    return int(input())\\ndef tinput():\\n    return input().split()\\ndef rinput():\\n    return list(map(int, tinput()))\\ndef rlinput():\\n    return list(rinput())\\n\\ndef main():\\n    n, w, q, res = iinput(), set(), [], 0\\n    for i in rinput():\\n        if i % 2 == 0:\\n            if i not in w:\\n                w.add(i)\\n                heapq.heappush(q, -i)\\n    while q:\\n        i = -heapq.heappop(q) // 2\\n        res += 1\\n        if i % 2 == 0:\\n            if i not in w:\\n                w.add(i)\\n                heapq.heappush(q, -i)\\n\\n    print(res)\\n    \\nfor i in range(iinput()):\\n    main()\\n\", \"for __ in range(int(input())):\\n    n = int(input())\\n    ar = list(map(int, input().split()))\\n    ar1 = []\\n    ar2 = []\\n    for elem in ar:\\n        num = 0\\n        while elem % 2 == 0:\\n            elem //= 2\\n            num += 1\\n        ar1.append(num)\\n        ar2.append(elem)\\n    ar3 = []\\n    for i in range(n):\\n        ar3.append([ar2[i], ar1[i]])\\n    ar3.sort()\\n    i = 1\\n    j = 1\\n    num = 1\\n    ans = sum(ar1)\\n    while i < n:\\n        while j < n and ar3[j][0] == ar3[j - 1][0]:\\n            j += 1\\n        times = j - i\\n        prev_val = 0\\n        for h in range(i - 1, min(j, n)):\\n            ans -= times * (ar3[h][1] - prev_val)\\n            times -= 1\\n            prev_val = ar3[h][1]\\n        i = j + 1\\n        j = i\\n    print(ans)\", \"a = int(input())\\nfor i in range(a):\\n    s1 = set()\\n    ans = 0\\n    l = input()\\n    now = input().split()\\n    for i in now:\\n        k =int(i) \\n        while k%2==0 and k not in s1:\\n            s1.add(k)\\n            k=k//2\\n    print(len(s1))\", \"def main():\\n    m = int(input())\\n\\n    for i in range(m):\\n        n = int(input())\\n        nums = map(int, input().split())\\n        arr = {}\\n        for j in nums:\\n            base = j\\n            step = 0\\n            while not base & 1:\\n                base >>= 1\\n                step += 1\\n\\n            if not base in arr:\\n                arr[base] = step\\n            else:\\n                arr[base] = max(arr[base], step)\\n\\n        print(sum(arr.values()))\\n\\n\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"t = int(input())\\nans = []\\nfor _ in range(t):\\n    n = int(input())\\n    m = list(map(int, input().split()))\\n    d = {}\\n    for el1 in m:\\n        el = el1\\n        c = 0\\n        while (el%2==0):\\n            el//=2\\n            c+=1\\n        if (el in list(d.keys())):\\n            d[el] = max(d[el], c)\\n        else:\\n            d[el] = c\\n    s = 0\\n    for el in d:\\n        s+=d[el]\\n    ans.append(s)\\n\\nfor el in ans:\\n    print(el)\\n\", \"t=int(input())\\nfor j in range(t):\\n    n=int(input())\\n    a=(list(map(int,input().split())))\\n    a.sort()\\n    s=set()\\n    s1=set(a)\\n    ans=0\\n    l=n\\n    while l>0:\\n        now=a.pop()\\n        l-=1\\n        if now not in s and now%2==0:\\n            s.add(now)\\n            ans+=1\\n            if now//2 not in s1:\\n                s1.add(now//2)\\n                a.append(now//2)\\n                l+=1\\n    print(ans)\\n    \\n\", \"t = int(input())\\nfor i in range(0, t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    b = []\\n    for j in range(0, n):\\n        if a[j] % 2 == 0:\\n            num = 0\\n            k = a[j]\\n            while k % 2 == 0:\\n                k //= 2\\n                num += 1\\n            b.append([k, num])\\n    b.sort()\\n    ans = 0\\n    length = len(b)\\n    for q in range(0, length - 1):\\n        if b[q][0] != b[q + 1][0]:\\n            ans += b[q][1]\\n    if length != 0:\\n        print(ans + b[length - 1][1])\\n    else:\\n        print(ans)\\n\", \"k = int(input())\\n\\ndef absolute() :\\n    c = dict()\\n    m = 0\\n    for i in [int(x) for x in input().split()] :\\n        q = 0\\n        if i % 2 != 0 : continue\\n        while i % 2 == 0 :\\n            i //= 2\\n            q += 1\\n        if c.get(i, 0) < q :\\n            m += q - c.get(i, 0)\\n            c[i] = q\\n    #print(c)\\n    return m\\n        \\n\\nfor j in range(k) :\\n    input()\\n    print(absolute())\\n\", \"def ck(a):\\n    ans=0\\n    while a%2==0:\\n        a=a//2\\n        ans+=1\\n    return([a,ans])\\nt=int(input())\\nfor _ in range(t):\\n    n=int(input())\\n    a=list(map(int,input().split()))\\n    c={}\\n    for i in range(n):\\n        x,y=ck(a[i])\\n        if c.get(x)==None:\\n            c[x]=y\\n        elif c.get(x)<y:\\n            c[x]=y\\n    ans=sum(c.values())\\n    print(ans)\\n\", \"def res(e):\\n    ans = 0\\n    e1 = int(e)\\n    while e1 % 2 == 0:\\n        e1 //= 2\\n        ans += 1\\n    return 2 ** ans\\n\\n\\nfor i in range(int(input())):\\n    n = int(input())\\n    s = list([x for x in list(map(int, input().split())) if x % 2 == 0])\\n    if len(s) == 0:\\n        print(0)\\n    else:\\n        temp = list([x // res(x) for x in s])\\n        ans = 0\\n        s1 = set()\\n        while temp != s:\\n            for i1 in range(len(s)):\\n                if temp[i1] == s[i1]:\\n                    continue\\n                elif temp[i1] not in s1:\\n                    s1.add(temp[i1])\\n                    ans += 1\\n                    temp[i1] *= 2\\n                elif temp[i1] in s1:\\n                    temp[i1] *= 2\\n        print(ans)\\n\\n\\n\", \"t = int(input())\\nfor i in range(0, t):\\n    n = int(input())\\n    data = list(map(int, input().split()))\\n    d = dict()\\n    for j in range(0, n):\\n        a = data[j]\\n        count = 0\\n        while a % 2 == 0:\\n            a = a // 2\\n            count += 1\\n        d[a] = max(d.get(a, 0), count)\\n    print(sum(d.values()))\", \"t = int(input())\\nfor i in range(0, t):\\n    n = int(input())\\n    data = list(map(int, input().split()))\\n    d = dict()\\n    for j in range(0, n):\\n        a = data[j]\\n        count = 0\\n        while a % 2 == 0:\\n            a = a // 2\\n            count += 1\\n        d[a] = max(d.get(a, 0), count)\\n    print(sum(d.values()))\\n\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    l = list(map(int, input().split()))\\n    s = set()\\n    d = {}\\n    for a in l:\\n        j = 0\\n        while (a % 2) == 0:\\n            a = a // 2\\n            j += 1\\n        s.add(a)\\n        if a in d:\\n            if d[a] < j:\\n                d[a] = j\\n        else:\\n            d[a] = j\\n    p = 0\\n    for q in d:\\n        p += d[q]\\n    print(p)\\n\", \"from sys import stdin as s\\nfor i in range(int(s.readline())):\\n    n=int(s.readline())\\n    l=sorted([i for i in set(map(int,s.readline().split())) if i%2==0],reverse=True)\\n    t=set()\\n    c=0\\n    for i in l:\\n        if i not in t:\\n            t.add(i)\\n            while i%2==0:\\n                i//=2\\n                t.add(i)\\n                c+=1\\n    print(c)\", \"from collections import Counter\\ndef primfacs(n):\\n    if n % 2 == 0:\\n        primfac = [0,0]\\n    else:\\n        primfac = [0,0]\\n    while n % 2 == 0:\\n        n = n / 2\\n        primfac[0] += 1\\n    primfac[1] = n\\n    return primfac\\n\\n\\n\\nt = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    A = list(map(int, input().split()))\\n    Ost = []\\n    for j in range(n):\\n        Ost.append(primfacs(A[j]))\\n    Ost.sort()\\n    d = {}\\n    for j in range(len(Ost)):\\n        d[Ost[j][1]] = Ost[j][0]\\n    print(sum(list(d.values())))\", \"t = int(input())\\nfor i in range(t):\\n\\tn = int(input())\\n\\ta = set(map(int, input().split()))\\n\\t#print(a)\\n\\teven_numbers = {x for x in a if x % 2 == 0}\\n\\tused_numbers = set()\\n\\tk = 0\\n\\tfor x in even_numbers:\\n\\t\\twhile x % 2 == 0 and x not in used_numbers:\\n\\t\\t\\tused_numbers.add(x)\\n\\t\\t\\tx //= 2\\n\\t\\t\\tk += 1\\n\\tprint(k)\\n\", \"from collections import Counter\\nimport heapq\\n\\n\\nt = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    rep = Counter()\\n    ans = 0\\n\\n    heap = []\\n    for i in range(len(a)):\\n        rep[a[i]] += 1\\n        if rep[a[i]] == 1:\\n            heapq.heappush(heap, -a[i])\\n\\n    while heap:\\n        x = -heapq.heappop(heap)\\n\\n        if x % 2 == 0:\\n            dx = x // 2\\n            if rep[dx] == 0:\\n                heapq.heappush(heap, -dx)\\n                rep[dx] = 1\\n            else:\\n                rep[dx] += rep[x]\\n\\n            ans += 1\\n\\n    print(ans)\\n\", \"t=int(input())\\nfor i in range(t):\\n    n=int(input())\\n    a=list([bin(int(x))[2:] for x in input().split()])\\n    d=dict()\\n    for i in a:\\n        ir=i.rfind(\\\"1\\\")\\n        c=len(i)-ir-1\\n        raw=int(i[:ir+1],base=2)\\n        d[raw]=max(d.get(raw,c),c)\\n    print(sum(d.values()))\\n\", \"def factorize(x):\\n    tmp = x\\n    cnt = 0\\n    while (tmp % 2 == 0):\\n        tmp //= 2\\n        cnt += 1\\n    return tmp, cnt\\n\\nn = int(input())\\nfor i in range(n):\\n    k = int(input())\\n    x = dict()\\n    cnt = 0\\n    tmp = list(map(int, input().split()))\\n    for j in tmp:\\n        g, v = factorize(j)\\n        try:\\n            x[g] = max(x[g], v)\\n        except:\\n            x[g] = v\\n    for c in list(x.keys()):\\n        cnt += x[c]\\n    print(cnt)\\n        \\n\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    a = [int(j) for j in input().split()]\\n    used = set()\\n    for j in a:\\n        if j%2==1:\\n            continue\\n        while j%2==0 and j not in used:\\n            used.add(j)\\n            j /= 2\\n    print(len(used))\", \"t=int(input())\\nfor _ in range(t):\\n        n=int(input())\\n        a=[int (i) for i in  input().split()]\\n        d=dict()\\n        su=0\\n        for i in a:\\n                k=0\\n                while i%2==0:\\n                        i=i//2\\n                        k+=1\\n                if i not in d:\\n                        d[i]=k\\n                else:\\n                        d[i]=max(d[i],k)\\n        for i in list(d.values()):\\n                su+=i\\n        print(su)\\n                \\n\", \"t = int(input())\\nfor i in range(t):\\n    ans = 0\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    \\n    for j in range(n):\\n        count = 0\\n        while a[j] % 2 == 0:\\n            a[j] = a[j] // 2\\n            count += 1\\n        a[j] = [a[j], count]\\n        \\n    a.sort()\\n    \\n    j = 0\\n    while j != n:\\n        m = a[j][1]\\n        \\n        while j + 1 < n and a[j][0] == a[j + 1][0]:\\n            m = max([a[j][1], a[j + 1][1]])\\n            j+=1\\n        j+=1\\n        ans += m\\n    print(ans)\\n\", \"n = int(input())\\n\\nfor i in range(n):\\n    answer = 0\\n    d = set()\\n    m = int(input())\\n    arr = [int(x) for x in input().split()]\\n    for j in arr:\\n        if j % 2 == 0:\\n            if j not in d:\\n                d.add(j)\\n    s = list(d)\\n    s.sort(reverse=True)\\n\\n    for j in s:\\n        ch = j // 2\\n        answer += 1\\n        while ch % 2 == 0:\\n            if ch not in d:\\n                ch //= 2\\n                answer += 1\\n            else:\\n                break\\n    \\n    print(answer)\", \"t = int(input())\\nans_l = []\\nfor _ in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    ar = set()\\n    for i in a:\\n        if i % 2 == 0:\\n            x = i\\n            ar.add(x)\\n            while x % 2 == 0:\\n                ar.add(x)\\n                x //= 2\\n    ans_l.append(len(ar))\\nprint(*ans_l, sep='\\\\n')\\n\", \"a = int(input())\\nfor i in range(a):\\n    f = int(input())\\n    k = list(map(int, input().split()))\\n    l = set()\\n    ch = 0\\n    lol = 0\\n    for i in range(len(k)):\\n        lol = k[i]\\n        while lol % 2 == 0:\\n            l.add(lol)\\n            lol /= 2\\n    print(len(l))\\n\", \"def razl(a):\\n    if a % 2 == 0:\\n        r = [0, 0]\\n    else:\\n        r = [0, 0]\\n    while a % 2 == 0:\\n        a = a / 2\\n        r[0] += 1\\n    r[1] = a\\n    return r\\n\\n\\nans = []\\nfor i in range(int(input())):\\n    a = int(input())\\n    b = list(map(int, input().split()))\\n    c = []\\n    for j in range(a):\\n        c.append(razl(b[j]))\\n    c.sort()\\n    d = {}\\n    for j in range(len(c)):\\n        d[c[j][1]] = c[j][0]\\n    ans.append(sum(list(d.values())))\\nfor i in ans:\\n    print(i)\", \"def f(n):\\n    minn = 0\\n    maxx = 30\\n    mid = 10\\n    while mid != minn:\\n        if n // (2 ** mid) == n / (2 ** mid):\\n            minn = mid\\n            mid = (minn + maxx) // 2\\n        else:\\n            maxx = mid\\n            mid = (minn + maxx) // 2\\n    return mid\\n\\n\\nt = int(input())\\nfor i in range(t):\\n    d = dict()\\n    n = int(input())\\n    a = set(map(int, input().split()))\\n    for j in a:\\n        p = f(j)\\n        if j // (2 ** p) in d:\\n            if p > d[j // (2 ** p)]:\\n                d[j // (2 ** p)] = p\\n        else:\\n            d[j // (2 ** p)] = p\\n    print(sum(d.values()))\\n\", \"def ans():\\n\\tnonlocal lst\\n\\td = dict()\\n\\tfor i in lst:\\n\\t\\ts2, delit = st2(i)\\n\\t\\tif delit not in d:\\n\\t\\t\\td[delit] = s2\\n\\t\\t\\tcontinue\\n\\t\\tif d[delit] < s2:\\n\\t\\t\\td[delit] = s2\\n\\treturn sum(d.values())\\ndef st2(num):\\n\\tc = 0\\n\\twhile (num%2==0) and num != 0:\\n\\t\\tnum = num >> 1\\n\\t\\tc += 1\\n\\treturn [c, num]\\nlst = []\\nfor i in range(int(input())):\\n\\tt = int(input())\\n\\tlst = list(map(int, input().split()))\\n\\tprint(ans())\", \"t = int(input())\\nanswers = [0] * t\\nfor i in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    arr = [[] for _ in range(n)]\\n    ans = 0\\n    for j in range(n):\\n        pow1 = 0\\n        cur = a[j]\\n        while cur % 2 == 0:\\n            cur //= 2\\n            pow1 += 1\\n        arr[j] = [cur, pow1]\\n    arr.sort(reverse=True)\\n    cur_nech = -1\\n    for j in range(n):\\n        if arr[j][0] != cur_nech:\\n            ans += arr[j][1]\\n            cur_nech = arr[j][0]\\n    answers[i] = ans\\nprint(*answers, sep='\\\\n')\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n6\\n40 6 40 3 20 1\\n1\\n1024\\n4\\n2 4 8 16\\n3\\n3 1 7\\n\"\n  ],\n  \"outputs\": [\n    \"4\\n10\\n4\\n0\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1259/B", "starter_code": ""}
{"id": 28, "question": "Acacius is studying strings theory. Today he came with the following problem.\n\nYou are given a string $s$ of length $n$ consisting of lowercase English letters and question marks. It is possible to replace question marks with lowercase English letters in such a way that a string \"abacaba\" occurs as a substring in a resulting string exactly once?\n\nEach question mark should be replaced with exactly one lowercase English letter. For example, string \"a?b?c\" can be transformed into strings \"aabbc\" and \"azbzc\", but can't be transformed into strings \"aabc\", \"a?bbc\" and \"babbc\".\n\nOccurrence of a string $t$ of length $m$ in the string $s$ of length $n$ as a substring is a index $i$ ($1 \\leq i \\leq n - m + 1$) such that string $s[i..i+m-1]$ consisting of $m$ consecutive symbols of $s$ starting from $i$-th equals to string $t$. For example string \"ababa\" has two occurrences of a string \"aba\" as a substring with $i = 1$ and $i = 3$, but there are no occurrences of a string \"aba\" in the string \"acba\" as a substring.\n\nPlease help Acacius to check if it is possible to replace all question marks with lowercase English letters in such a way that a string \"abacaba\" occurs as a substring in a resulting string exactly once.\n\n\n-----Input-----\n\nFirst line of input contains an integer $T$ ($1 \\leq T \\leq 5000$), number of test cases. $T$ pairs of lines with test case descriptions follow.\n\nThe first line of a test case description contains a single integer $n$ ($7 \\leq n \\leq 50$), length of a string $s$.\n\nThe second line of a test case description contains string $s$ of length $n$ consisting of lowercase English letters and question marks.\n\n\n-----Output-----\n\nFor each test case output an answer for it.\n\nIn case if there is no way to replace question marks in string $s$ with a lowercase English letters in such a way that there is exactly one occurrence of a string \"abacaba\" in the resulting string as a substring output \"No\".\n\nOtherwise output \"Yes\" and in the next line output a resulting string consisting of $n$ lowercase English letters. If there are multiple possible strings, output any.\n\nYou may print every letter in \"Yes\" and \"No\" in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answer).\n\n\n-----Example-----\nInput\n6\n7\nabacaba\n7\n???????\n11\naba?abacaba\n11\nabacaba?aba\n15\nasdf???f???qwer\n11\nabacabacaba\n\nOutput\nYes\nabacaba\nYes\nabacaba\nYes\nabadabacaba\nYes\nabacabadaba\nNo\nNo\n\n\n\n-----Note-----\n\nIn first example there is exactly one occurrence of a string \"abacaba\" in the string \"abacaba\" as a substring.\n\nIn second example seven question marks can be replaced with any seven lowercase English letters and with \"abacaba\" in particular.\n\nIn sixth example there are two occurrences of a string \"abacaba\" as a substring.", "solutions": "[\"import sys\\nINF = 10**20\\nMOD = 10**9 + 7\\nI = lambda:list(map(int,input().split()))\\nfrom math import gcd\\nfrom math import ceil\\nfrom collections import defaultdict as dd, Counter\\nfrom bisect import bisect_left as bl, bisect_right as br\\n\\n\\n\\\"\\\"\\\"\\nFacts and Data representation\\nConstructive? Top bottom up down\\n\\\"\\\"\\\"\\ndef check(s):\\n  t = 'abacaba'\\n  ans = 0\\n  for i in range(len(s)):\\n    if s[i: i + 7] == t:\\n      ans += 1\\n  return ans\\n\\ndef solve():\\n  n, = I()\\n  s = input()\\n  t = 'abacaba'\\n  cnt = check(s)\\n  if cnt > 1:\\n    print('No')\\n    return\\n  elif cnt == 1:\\n    s = list(s)\\n    for i in range(n):\\n      if s[i] == '?':\\n        s[i] = 'z'\\n    print('Yes')\\n    print(''.join(s))\\n  else:\\n    s = list(s)\\n    ok = s[::]\\n    for i in range(n - 6):\\n      ok = s[::]\\n      for j in range(7):\\n        if s[i + j] == t[j]:\\n          continue\\n        elif s[i + j] == '?':\\n          ok[i + j] = t[j]\\n        else:\\n          break\\n      else:\\n        for i in range(n):\\n          if ok[i] == '?':\\n            ok[i] = 'z'\\n        ok = ''.join(ok)\\n        if check(ok) != 1:\\n          continue\\n        print('Yes')\\n        print(ok)\\n        return\\n    print('No')\\n\\nt, = I()\\nwhile t:\\n  t -= 1\\n  solve()\", \"import sys\\nt = int(input())\\nreq = 'abacaba'\\n\\nfor _ in range(t):\\n    n = int(sys.stdin.readline())\\n    s = sys.stdin.readline().rstrip()\\n\\n    cnt = 0\\n    for i in range(n-6):\\n        if s[i:i+7] == req:\\n            cnt += 1\\n\\n    if cnt == 1:\\n        print('Yes')\\n        print(s.replace('?', 'z'))\\n        continue\\n    if cnt > 1:\\n        print('No')\\n        continue\\n\\n    for i in range(n-6):\\n        if all(c1 == c2 or c1 == '?' for c1, c2 in zip(s[i:i+7], req)):\\n            if s[i+7:i+11] == 'caba' or i >= 4 and s[i-4:i] == 'abac':\\n                continue\\n            s = s[:i] + req + s[i+7:]\\n            print('Yes')\\n            print(s.replace('?', 'z'))\\n            break\\n    else:\\n        print('No')\\n\", \"#\\n#    ------------------------------------------------\\n#           ____          _     Generatered using\\n#          / ___|        | |\\n#         | |    __ _  __| | ___ _ __  ______ _\\n#         | |   / _` |/ _` |/ _ \\\\ '_ \\\\|_  / _` |\\n#         | |__| (_| | (_| |  __/ | | |/ / (_| |\\n#          \\\\____\\\\____|\\\\____|\\\\___|_| |_/___\\\\____|\\n#\\n#      GNU Affero General Public License v3.0\\n#    ------------------------------------------------\\n#    Author   : prophet\\n#    Created  : 2020-07-19 05:12:32.701664\\n#    UUID     : fZpWYlRPKqbpTDmt\\n#    ------------------------------------------------\\n#\\nproduction = True\\n\\nimport sys, math, collections\\n\\ndef input(input_format = 0, multi = 0):\\n\\n    if multi > 0: return [input(input_format) for i in range(multi)]\\n    else:\\n        next_line = sys.stdin.readline()[:-1]\\n\\n        if input_format >= 10:\\n            use_list = False\\n            input_format = int(str(input_format)[-1])\\n        else: use_list = True\\n\\n        if input_format == 0: formatted_input = [next_line]\\n        elif input_format == 1: formatted_input = list(map(int, next_line.split()))\\n        elif input_format == 2: formatted_input = list(map(float, next_line.split()))\\n        elif input_format == 3: formatted_input = list(next_line)\\n        elif input_format == 4: formatted_input = list(map(int, list(next_line)))\\n        elif input_format == 5: formatted_input = next_line.split()\\n        else: formatted_input = [next_line]\\n\\n        return formatted_input if use_list else formatted_input[0]\\n\\ndef out(output_line, output_format = 0, newline = True):\\n\\n    formatted_output = \\\"\\\"\\n\\n    if output_format == 0: formatted_output = str(output_line)\\n    elif output_format == 1: formatted_output = \\\" \\\".join(map(str, output_line))\\n    elif output_format == 2: formatted_output = \\\"\\\\n\\\".join(map(str, output_line))\\n\\n    print(formatted_output, end = \\\"\\\\n\\\" if newline else \\\"\\\")\\n\\ndef log(*args):\\n    if not production:\\n        print(\\\"$$$\\\", end = \\\"\\\")\\n        print(*args)\\n\\nenu = enumerate\\n\\nter = lambda a, b, c: b if a else c\\n\\nceil = lambda a, b: -(-a // b)\\n\\ndef mapl(iterable, format = 0):\\n    \\n    if format == 0: return list(map(int, iterable))\\n    elif format == 1: return list(map(str, iterable))\\n    elif format == 2: return list(map(list, iterable))\\n#\\n#   >>>>>>>>>>>>>>> START OF SOLUTION <<<<<<<<<<<<<<\\n#\\n\\ndef ch(a, r, n):\\n    \\n    c = 0\\n\\n    for i in range(n - 6):\\n        y = a[i:i + 7]\\n        if y == r:\\n            c += 1\\n\\n    return c == 1\\n\\ndef solve():\\n\\n    n = input(11)\\n    a = input(3)\\n\\n    r = list(\\\"abacaba\\\")\\n\\n    for i in range(n - 6):\\n        y = a[i:i + 7]\\n        for x, z in zip(y, r):\\n            if not (x == \\\"?\\\" or x == z):\\n                break\\n        else:\\n            s = a[:i] + r + a[i + 7:]\\n            if ch(s, r, n):\\n                u = \\\"\\\"\\n                for j in s:\\n                    if j == \\\"?\\\":\\n                        u += \\\"z\\\"\\n                    else:\\n                        u += j\\n                out(\\\"Yes\\\")\\n                out(u)\\n                return\\n\\n    out(\\\"No\\\")\\n    return\\n\\n\\nfor i in range(input(11)): solve()\\n# solve()\\n\\n#\\n#   >>>>>>>>>>>>>>>> END OF SOLUTION <<<<<<<<<<<<<<<\\n#\\n\", \"def f(s):\\n  t=\\\"abacaba\\\"\\n  for i in range(7):\\n    if s[i]!=\\\"?\\\" and t[i]!=s[i]:return False\\n  return True\\ndef g(s):\\n  c=0\\n  for i in range(7,len(s)+1):\\n    if s[i-7:i]==\\\"abacaba\\\":c+=1\\n  return c\\n\\nfor _ in range(int(input())):\\n  n=int(input())\\n  s=input()\\n  if g(s)>1:\\n    print(\\\"No\\\")\\n    continue\\n  if \\\"abacaba\\\" in s:\\n    print(\\\"Yes\\\")\\n    print(s.replace(\\\"?\\\",\\\"z\\\"))\\n    continue\\n  flag=False\\n  for i in range(7,len(s)+1):\\n    if f(s[i-7:i]):\\n      t=(s[:i-7]+\\\"abacaba\\\"+s[i:]).replace(\\\"?\\\",\\\"z\\\")\\n      if g(t)>1:continue\\n      print(\\\"Yes\\\")\\n      print(t)\\n      flag=True\\n      break\\n  if not(flag):print(\\\"No\\\")\", \"check=\\\"abacaba\\\"\\n\\ndef compare(s,t):\\n    res=True\\n    for i in range(len(s)):\\n        res&=(s[i]==t[i] or s[i]==\\\"?\\\" or t[i]==\\\"?\\\")\\n    return res\\n\\n\\nfor _ in range(int(input())):\\n    n=int(input())\\n    s=input()\\n    ans=\\\"No\\\"\\n    res=\\\"\\\"\\n    for i in range(n-6):\\n        t=s\\n        test=t[i:i+7]\\n        if compare(test,check):\\n            t=s[:i]+check+s[i+7:]\\n            t=t.replace(\\\"?\\\",\\\"z\\\")\\n            count=0\\n            for j in range(n-6):\\n                if t[j:j+7]==check:\\n                    count+=1\\n            if count==1:\\n                ans=\\\"Yes\\\"\\n                res=t\\n    print(ans)\\n    if ans==\\\"Yes\\\":\\n        print(res)\\n\", \"def count(string, substring): \\n    count = 0\\n    start = 0\\n    while start < len(string): \\n        pos = string.find(substring, start) \\n        if pos != -1: \\n            start = pos + 1\\n            count += 1\\n        else:\\n            break\\n    return count \\n \\n\\nfor _ in range(int(input())):\\n    n = int(input())\\n    os = input()\\n    good = False\\n    for i in range(n):\\n        if (os[i] == \\\"a\\\" or os[i] == \\\"?\\\") and i <= n-7:\\n            s = list(os)\\n            bad = False\\n            for j in range(i, i+7):\\n                if s[j] != \\\"?\\\" and s[j] != \\\"abacaba\\\"[j-i]:\\n                    bad = True\\n                    break\\n                s[j] = \\\"abacaba\\\"[j-i]\\n            if bad:\\n                continue\\n            ans = \\\"\\\".join(s).replace(\\\"?\\\", \\\"z\\\")\\n            if count(ans, \\\"abacaba\\\") == 1:\\n                good = True\\n                break\\n\\n    if good:\\n        print(\\\"Yes\\\")\\n        print(ans)\\n    else:\\n        print(\\\"No\\\")\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"6\\n7\\nabacaba\\n7\\n???????\\n11\\naba?abacaba\\n11\\nabacaba?aba\\n15\\nasdf???f???qwer\\n11\\nabacabacaba\\n\"\n  ],\n  \"outputs\": [\n    \"Yes\\nabacaba\\nYes\\nabacaba\\nYes\\nabazabacaba\\nYes\\nabacabazaba\\nNo\\nNo\\n\"\n  ]\n}\n", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1379/A", "starter_code": ""}
{"id": 29, "question": "You are given an array $a$ consisting of $n$ integers numbered from $1$ to $n$.\n\nLet's define the $k$-amazing number of the array as the minimum number that occurs in all of the subsegments of the array having length $k$ (recall that a subsegment of $a$ of length $k$ is a contiguous part of $a$ containing exactly $k$ elements). If there is no integer occuring in all subsegments of length $k$ for some value of $k$, then the $k$-amazing number is $-1$.\n\nFor each $k$ from $1$ to $n$ calculate the $k$-amazing number of the array $a$.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases. Then $t$ test cases follow.\n\nThe first line of each test case contains one integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$) \u2014 the number of elements in the array. The second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$) \u2014 the elements of the array. \n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case print $n$ integers, where the $i$-th integer is equal to the $i$-amazing number of the array.\n\n\n-----Example-----\nInput\n3\n5\n1 2 3 4 5\n5\n4 4 4 4 2\n6\n1 3 1 5 3 1\n\nOutput\n-1 -1 3 2 1 \n-1 4 4 4 2 \n-1 -1 1 1 1 1", "solutions": "[\"input=__import__('sys').stdin.readline\\nfor _ in range(int(input())):\\n\\tn=int(input())\\n\\ts=list(map(int,input().split()))\\n\\tg=[[-1]for _ in range(n+1)]\\n\\tfor i in range(n):\\n\\t\\tg[s[i]].append(i)\\n\\tinf=10**10\\n\\tans=[-1]*n\\n\\tlstunused=n\\n\\tfor i in range(1,n+1):\\n\\t\\tg[i].append(n)\\n\\t\\tmx=0\\n\\t\\tfor j in range(1,len(g[i])):\\n\\t\\t\\tmx=max(mx,g[i][j]-g[i][j-1]-1)\\n\\t\\tfor j in range(mx,lstunused):\\n\\t\\t\\tans[j]=i\\n\\t\\tlstunused=min(lstunused,mx)\\n\\tprint(*ans)\", \"import sys\\n\\n    \\ndef main():\\n    #n = iinput()\\n    #k = iinput() \\n    #m = iinput() \\n    n = int(sys.stdin.readline().strip()) \\n    #n, k = rinput()\\n    #n, m = rinput()\\n    #m, k = rinput()\\n    #n, k, m = rinput()\\n    #n, m, k = rinput()\\n    #k, n, m = rinput()\\n    #k, m, n = rinput() \\n    #m, k, n = rinput()\\n    #m, n, k = rinput()\\n    q = list(map(int, sys.stdin.readline().split()))\\n    #q = linput()\\n    clovar, p, x = {}, [], 1e9\\n    for i in range(n):\\n        if q[i] in clovar:\\n            clovar[q[i]].append(i)\\n        else:\\n            clovar[q[i]] = [i]\\n    for o in clovar:\\n        t = clovar[o]\\n        ma = max(t[0] + 1, n - t[-1])\\n        dlinat = len(t) - 1\\n        for i in range(dlinat): \\n            ma = max(t[i + 1] - t[i], ma)\\n        p.append([ma, o])\\n    p.sort()\\n    ans = [p[0]]\\n    dlinap = len(p)\\n    for i in range(1, dlinap):\\n        if ans[-1][0] != p[i][0]:\\n            ans.append(p[i])\\n    ans.append([n + 1, 1e9])\\n    dlina_1 = ans[0][0] - 1\\n    print(*[-1 for i in range(dlina_1)], end=\\\" \\\")\\n    dlinaans = len(ans) - 1\\n    for i in range(dlinaans):\\n        x = min(x, ans[i][1])\\n        dlinax = ans[i + 1][0] - ans[i][0]\\n        print(*[x for o in range(dlinax)], end=\\\" \\\")\\n    print()\\n           \\n        \\n            \\n    \\n    \\n    \\n    \\n    \\n    \\n            \\n                \\n        \\n    \\n            \\n        \\n\\n            \\n        \\n    \\n                \\n    \\n    \\n    \\n            \\n    \\n        \\n    \\n\\nfor i in range(int(sys.stdin.readline().strip()) ):\\n    main()\\n    \\n\", \"import sys\\nimport math\\ninput = sys.stdin.readline\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    arr = list(map(int, input().split()))\\n    \\n    S = {}\\n    for el in arr:\\n        S[el] = [0]\\n        \\n    for i in range(len(arr)):\\n        S[arr[i]].append(i+1)\\n        \\n    G = {}\\n    \\n    for key in S:\\n        S[key].append(n+1)\\n        best = 0\\n        for i in range(len(S[key]) - 1):\\n            gap = abs(S[key][i] - S[key][i+1])\\n            best = max(gap, best)\\n        G[key] = best\\n        \\n    #print(G)\\n    B = {}\\n    for key in G:\\n        l = G[key]\\n        if l not in B:\\n            B[l] = key\\n        else:\\n            B[l] = min(B[l], key)\\n            \\n    ans = []\\n    for key in B:\\n        ans.append((key, B[key]))\\n        \\n    ans.sort()\\n    \\n    pp = []\\n    low = 9999999999999999\\n    j = 0\\n    for i in range(1, n+1):\\n        if j<len(ans) and i==ans[j][0]:\\n            if ans[j][1] < low:\\n                low = ans[j][1]\\n            j += 1\\n        if low > 10**10:\\n            pp.append(-1)\\n        else:\\n            pp.append(low)\\n            \\n    print(*pp)\\n        \\n        \\n\", \"from collections import defaultdict\\n\\nT = int(input())\\n\\nfor t in range(T):\\n    N = int(input())\\n    A = [int(_) for _ in input().split()]\\n\\n    els = sorted(set(A))\\n\\n    pos = defaultdict(list)\\n    for i, el in enumerate(A):\\n        pos[el].append(i)\\n\\n    DMAX = {}\\n    for el in list(pos.keys()):\\n        dmax = -1\\n        arr = [-1] + sorted(pos[el]) + [N]\\n        for i in range(1, len(arr)):\\n            dmax = max(dmax, arr[i] - arr[i-1])\\n        DMAX[el] = dmax\\n\\n    ci = 0\\n    answer = []\\n\\n    for i in range(N-1, -1, -1):\\n        while ci < len(els) and DMAX[els[ci]] > i+1:\\n            ci += 1\\n        if ci >= len(els):\\n            answer.append(-1)\\n        else:\\n            answer.append(els[ci])\\n\\n    print(' '.join(map(str, answer[::-1])))\\n\", \"t = int(input())\\n\\nfor case in range(t):\\n    n = int(input())\\n    a = [int(x) - 1 for x in input().split()]\\n\\n    last_occ = [-1 for _ in range(n)]\\n    max_dist = [float('-inf') for _ in range(n)]\\n\\n    for i, x in enumerate(a):\\n        max_dist[x] = max(max_dist[x], i - last_occ[x])\\n        last_occ[x] = i\\n\\n    for x in a:\\n        max_dist[x] = max(max_dist[x], n - last_occ[x])\\n        \\n    inverted = [float('inf') for _ in range(n)]\\n\\n    for x in a:\\n        inverted[max_dist[x] - 1] = min(inverted[max_dist[x] - 1], x)\\n\\n    best = float('inf')\\n    for x in inverted:\\n        if x != float('inf'):\\n            best = min(x, best)\\n\\n        if best == float('inf'):\\n            print(-1, end=' ')\\n        else:\\n            print(best + 1, end=' ')\\n\\n    print()\\n            \\n\", \"import sys\\nsys.setrecursionlimit(1000000)\\n\\nT = int(input())\\nfor _ in range(T):\\n    n = int(input())\\n    a = [int(x) - 1 for x in input().split()]\\n    prev = [-1 for _ in range(n)]\\n    val = [1 for _ in range(n)]\\n    for i, x in enumerate(a):\\n        delta = i - prev[x]\\n        val[x] = max(val[x], delta)\\n        prev[x] = i\\n    for i in range(n):\\n        val[i] = max(val[i], n - prev[i])\\n    ans = [-1 for _ in range(n + 1)]\\n    r = n + 1\\n    for i in range(n):\\n        if val[i] < r:\\n            for j in range(val[i], r):\\n                ans[j] = i + 1\\n            r = val[i]\\n    print(' '.join([str(x) for x in ans[1:]]))\\n\", \"for qq in range(int(input())):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    last = [-1] * (n+1)\\n    dura = [-1] * (n+1)\\n    for i in range(n):\\n        dura[a[i]] = max(dura[a[i]], i-last[a[i]]-1)\\n        last[a[i]] = i\\n    for i in range(n+1):\\n        dura[i] = max(dura[i], n-last[i]-1)\\n\\n    ans = [n+1] * n\\n    for i in range(n+1):\\n        if dura[i]==n: continue\\n        ans[dura[i]] = min(ans[dura[i]], i)\\n    for i in range(n-1):\\n        ans[i+1] = min(ans[i+1], ans[i])\\n    for i in range(n):\\n        if ans[i]==n+1: ans[i] = -1\\n    print(*ans)\", \"INF = 10 ** 15\\n\\n\\nfor _ in range(int(input())):\\n    n = int(input())\\n    arr = list(map(int, input().split()))\\n\\n    d = {i: 0 for i in arr}\\n    last = {i: -1 for i in arr}\\n    for i in range(n):\\n        if last[arr[i]] == -1:\\n            d[arr[i]] = max(d[arr[i]], i + 1)\\n        else:\\n            d[arr[i]] = max(d[arr[i]], i - last[arr[i]])\\n        last[arr[i]] = i\\n\\n    for i in list(last.keys()):\\n        d[i] = max(d[i], n - last[i])\\n\\n    # print(d)\\n\\n    d2 = {}\\n    for k, v in list(d.items()):\\n        if v not in d2:\\n            d2[v] = INF\\n        d2[v] = min(d2[v], k)\\n\\n    # print(d2)\\n\\n    ans = [INF] * n\\n    for i in range(1, n + 1):\\n        can = INF\\n        if i != 1:\\n            can = ans[i - 2]\\n        if i in list(d2.keys()):\\n            can = min(can, d2[i])\\n        ans[i - 1] = can\\n\\n    for i in range(n):\\n        if ans[i] == INF:\\n            ans[i] = -1\\n\\n    print(*ans)\\n\", \"import sys\\nimport math\\ndef II():\\n\\treturn int(sys.stdin.readline())\\n \\ndef LI():\\n\\treturn list(map(int, sys.stdin.readline().split()))\\n \\ndef MI():\\n\\treturn map(int, sys.stdin.readline().split())\\n \\ndef SI():\\n\\treturn sys.stdin.readline().strip()\\nt = II()\\nfor q in range(t):\\n    n = II()\\n    a = LI()\\n    d = [[] for i in range(n+1)]\\n    d2 = [0]*(n+1)\\n    dp = [0]*(n+1)\\n    for i in range(n):\\n        if d2[a[i]] == 0:\\n            d2[a[i]] = 1\\n            d[a[i]].append(i)\\n            dp[a[i]] = i+1\\n        else:\\n            d2[a[i]]+=1\\n            dp[a[i]] = max(dp[a[i]], i-d[a[i]][-1])\\n            d[a[i]].append(i)\\n    for i in range(n):\\n        dp[a[i]] = max(dp[a[i]], n-d[a[i]][-1])\\n    ans = [-1]*(n+1)\\n    temp = -1\\n    for i in range(n+1):\\n        if ans[dp[i]] == -1:\\n            ans[dp[i]] = i\\n    temp = -1\\n    for i in range(1,n+1):\\n        if ans[i]!=-1:\\n            if temp == -1:\\n                temp = ans[i]\\n            elif ans[i]<temp:\\n                temp = ans[i]\\n            else:\\n                ans[i] = temp\\n        else:\\n            ans[i] = temp\\n    print(*ans[1:])\", \"for anynumber in range(int(input())):\\n    n = int(input())\\n    l = list(map(int,input().split()))\\n    d = {}\\n    for (index, i) in enumerate(l):\\n        if i not in d.keys():\\n            d[i] = [index+1,index]\\n        else:\\n            d[i] = [max(index-d[i][1], d[i][0]),index]\\n    for i in d.keys():\\n        d[i] = max(d[i][0], n-d[i][1])\\n    ans = [-1 for i in range(n)]\\n    for i in sorted(d.keys(), reverse=True):\\n        ans[d[i]-1] = i\\n    for i in range(1,n):\\n        if ans[i] == -1:\\n            ans[i] = ans[i-1]\\n        elif ans[i-1] != -1:\\n            if ans[i-1]<ans[i]:\\n                ans[i] = ans[i-1]\\n    for i in range(n-1):\\n        print(ans[i],end=\\\" \\\")\\n    print(ans[n-1])\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    a = [int(x) for x in input().split()]\\n    dct = {}\\n    for i in a:\\n        dct[i] = (-1, 0)\\n    now = 0\\n    for i in a:\\n        dct[i] = [now, max(dct[i][1], now - dct[i][0])]\\n        now += 1\\n    for i in dct:\\n        dct[i] = max(dct[i][1], (n - dct[i][0]))\\n    a = [(dct[i], i) for i in dct]\\n    a.sort()\\n    mini = 1000000000000000\\n    now = 0\\n    q = len(a)\\n    for i in range(1, n + 1):\\n        while now < q and a[now][0] == i:\\n            mini = min(mini, a[now][1])\\n            now += 1\\n        if mini == 1000000000000000:\\n            print(-1,end=' ')\\n        else:\\n            print(mini,end=' ')\\n    print()\", \"t = int(input())\\n\\nfor w in range(t):\\n    n = int(input())\\n    a = tuple(map(int, input().split()))\\n\\n    d = {}\\n    for i, x in enumerate(a):\\n        if x not in d:\\n            d[x] = [i + 1, i + 1]\\n        else:\\n            d[x] = [i + 1, max(d[x][1], i + 1 - d[x][0])]\\n\\n    l = len(a) + 1\\n    for i in d:\\n        d[i] = max(d[i][1], l - d[i][0])\\n\\n    z = {}\\n    for i, x in list(d.items()):\\n        if x in z:\\n            if z[x] > i:\\n                z[x] = i\\n        else:\\n            z[x] = i\\n\\n    q = [-1 for x in range(n)]\\n    for i, x in list(z.items()):\\n        q[i - 1] = x\\n\\n    q1 = []\\n    m = -1\\n    for x in q:\\n        if x == -1:\\n            q1.append(m)\\n        else:\\n            if m != -1:\\n                m = min(m, x)\\n            else:\\n                m = x\\n            q1.append(m)\\n\\n    print(' '.join(str(x) for x in q1))\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    a = [0] + list(map(int, input().split()))\\n\\n    period = [0 for i in range(n+1)]\\n    first = [-1 for i in range(n+1)]\\n    last = [-1 for i in range(n+1)]\\n    for i in range(1, len(a)):\\n        b = a[i]\\n        if first[b] == -1:\\n            first[b] = i\\n            last[b] = i\\n        else:\\n            period[b] = max(period[b], i - last[b])\\n            last[b] = i\\n    \\n    for i in range(1, len(period)):\\n        period[i] = max(period[i], n-last[i]+1)\\n    \\n    period = period[1:]\\n    l = sorted(list(e if e[0] > first[e[1]] else (first[e[1]], e[1]) for e in zip(period, list(range(1, n+1))) if e[0] > 0))\\n\\n    ans = []\\n    AA = n+5\\n    ind = 0\\n    for i in range(1, n+1):\\n        if ind < len(l) and l[ind][0] == i:\\n            AA = min(AA, l[ind][1])\\n        ans.append(-1 if AA == n+5 else AA)\\n        while ind < len(l) and l[ind][0] == i:\\n            ind += 1\\n            \\n    print(*ans)\\n        \\n        \\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n5\\n1 2 3 4 5\\n5\\n4 4 4 4 2\\n6\\n1 3 1 5 3 1\\n\"\n  ],\n  \"outputs\": [\n    \"-1 -1 3 2 1 \\n-1 4 4 4 2 \\n-1 -1 1 1 1 1 \\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1417/C", "starter_code": ""}
{"id": 30, "question": "You are given a string $s$ of even length $n$. String $s$ is binary, in other words, consists only of 0's and 1's.\n\nString $s$ has exactly $\\frac{n}{2}$ zeroes and $\\frac{n}{2}$ ones ($n$ is even).\n\nIn one operation you can reverse any substring of $s$. A substring of a string is a contiguous subsequence of that string.\n\nWhat is the minimum number of operations you need to make string $s$ alternating? A string is alternating if $s_i \\neq s_{i + 1}$ for all $i$. There are two types of alternating strings in general: 01010101... or 10101010...\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 10^5$; $n$ is even)\u00a0\u2014 the length of string $s$.\n\nThe second line of each test case contains a binary string $s$ of length $n$ ($s_i \\in$ {0, 1}). String $s$ has exactly $\\frac{n}{2}$ zeroes and $\\frac{n}{2}$ ones.\n\nIt's guaranteed that the total sum of $n$ over test cases doesn't exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print the minimum number of operations to make $s$ alternating.\n\n\n-----Example-----\nInput\n3\n2\n10\n4\n0110\n8\n11101000\n\nOutput\n0\n1\n2\n\n\n\n-----Note-----\n\nIn the first test case, string 10 is already alternating.\n\nIn the second test case, we can, for example, reverse the last two elements of $s$ and get: 0110 $\\rightarrow$ 0101.\n\nIn the third test case, we can, for example, make the following two operations:   11101000 $\\rightarrow$ 10101100;  10101100 $\\rightarrow$ 10101010.", "solutions": "[\"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    s = input()\\n    ans = 0\\n    for y in range(1, n):\\n        if s[y] == s[y-1]:\\n            ans += 1\\n    print((ans + ans % 2) // 2)\\n    \\n\", \"import sys\\ninput=sys.stdin.readline\\nfor _ in range(int(input())):\\n    n = int(input())\\n    s = input().strip()\\n    c = 0\\n    for i in range(n-1):\\n        if s[i] == s[i+1]:\\n            c += 1\\n    print((c+1)//2)\", \"t = int(input())\\n\\nfor q in range(t):\\n    n = int(input())\\n    s = input()\\n    a, b = 0, 0\\n    for i in range(n - 1):\\n        if s[i] == s[i + 1]:\\n            if s[i] == '0':\\n                a += 1\\n            else:\\n                b += 1\\n    print(max(a, b))\\n\", \"import collections\\nimport math\\nfrom itertools import permutations as p\\n\\nfor t in range(int(input())):\\n    n=int(input())\\n    s=input()\\n    stack=[]\\n    for i in s:\\n        if i=='1':\\n            if stack and stack[-1]=='0':\\n                stack.pop()\\n        else:\\n            if stack and stack[-1]=='1':\\n                stack.pop()\\n        stack.append(i)\\n    print(len(stack)//2)\", \"import sys\\n\\ninput = sys.stdin.readline\\n\\n\\ndef gcd(a, b):\\n    if a == 0:\\n        return b\\n    return gcd(b % a, a)\\n\\n\\ndef lcm(a, b):\\n    return (a * b) / gcd(a, b)\\n\\ndef main():\\n    for _ in range(int(input())):\\n        n=int(input())\\n        # a=list(map(int, input().split()))\\n        s=input()\\n        c=0\\n        for i in range(1,len(s)):\\n            if s[i]==s[i-1]:\\n                c+=1\\n        print(c//2+c%2)\\n\\n    return\\n\\ndef __starting_point():\\n    main()\\n\\n\\n__starting_point()\", \"for _ in range(int(input())):\\n    n = int(input())\\n    *s, = list(map(int, input()))\\n    cnt = [0, 0]\\n    for i in range(len(s)):\\n        if i > 0 and s[i] == s[i - 1]:\\n            cnt[s[i]] += 1\\n    print(max(cnt))\\n\\n\\n\", \"import sys\\n\\ndef main():\\n    n = int(sys.stdin.readline().strip())\\n    #n, m = map(int, sys.stdin.readline().split())\\n    #q = list(map(int, sys.stdin.readline().split()))\\n    s = sys.stdin.readline().strip()\\n    res = 0\\n    i = 0\\n    while i < n:\\n        while i < n and s[i] != \\\"1\\\":\\n            i += 1\\n        if i >= n:\\n            break\\n        while i < n and s[i] == \\\"1\\\":\\n            i += 1\\n            res += 1\\n            #print(i, res)\\n        i += 1\\n        res -= 1\\n        #print(\\\" \\\", i, res)\\n    i = 0\\n    ans = 0\\n    while i < n:\\n        while i < n and s[i] != \\\"0\\\":\\n            i += 1\\n        if i >= n:\\n            break\\n        while i < n and s[i] == \\\"0\\\":\\n            i += 1\\n            ans += 1\\n            #print(i, res)\\n        i += 1\\n        ans -= 1\\n        #print(\\\" \\\", i, res)\\n    print(max(ans, res))\\n    \\n   \\n        \\n        \\n            \\n        \\n                \\n            \\n            \\n        \\n            \\n    \\n    \\n    \\n    \\n    \\n    \\n            \\n                \\n        \\n    \\n            \\n        \\n\\n            \\n        \\n    \\n                \\n    \\n    \\n    \\n            \\n    \\n        \\n    \\n\\nfor i in range(int(sys.stdin.readline().strip())):\\n    main()\", \"ans = []\\nfor _ in range(int(input())):\\n    n = int(input())\\n    u = list(map(int, list(input())))\\n    cnt1 = cnt0 = 0\\n    for i in range(1, n):\\n        if u[i] == u[i - 1]:\\n            if u[i] == 0:\\n                cnt0 += 1\\n            else:\\n                cnt1 += 1\\n    ans.append(max(cnt1, cnt0))\\nprint(*ans, sep='\\\\n')\\n\", \"def solve(n):\\n    s=input()\\n    ans=0\\n    flag=0\\n    for i in range(n-1):\\n        if s[i]==s[i+1]:\\n            if flag==1:\\n                ans+=1\\n                flag=0\\n            else:\\n                flag=1\\n    if flag:\\n        ans+=1\\n    return ans\\n\\nfor _ in range(int(input())):\\n    print(solve(int(input())))\\n\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    s = input()\\n    blocks = [[s[0], 1]]\\n    for i in range(1, n):\\n        if s[i] == blocks[-1][0]:\\n            blocks[-1][1] += 1\\n        else:\\n            blocks += [[s[i], 1]]\\n    one = 0\\n    zero = 0\\n    for i in range(len(blocks)):\\n        if blocks[i][0] == '0':\\n            zero += blocks[i][1] - 1\\n        else:\\n            one += blocks[i][1] - 1\\n    print(max(one, zero))\", \"for _ in range(int(input())):\\n    n = int(input())\\n    s = input()\\n    l = list(s)\\n    c0 = 0\\n    c1 = 0\\n    for i in range(n-1):\\n        if(l[i] == l[i+1]):\\n            if(l[i] == '0'):\\n                c0 += 1\\n            else:\\n                c1 += 1\\n\\n    print(max(c0, c1))\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    s = input()\\n    S = 0\\n    for j in range(1,len(s)):\\n        if s[j-1]=='1' and s[j]=='1':\\n            S+=1\\n    if s[0]=='1' and s[-1]=='1' and len(s)>2:\\n        S+=1\\n    print(S)\\n\", \"import sys\\ninput=sys.stdin.readline\\n\\nT=int(input())\\nfor _ in range(T):\\n    n=int(input())\\n    s=input()\\n    ans1=0\\n    ans2=0\\n    i=0\\n    while(i<n):\\n        c=1\\n        while (s[i]==s[i-1]):\\n            c=c+1\\n            i=i+1\\n            \\n        if (s[i-1]=='1'):\\n            ans2=ans2+c-1\\n        else:\\n            ans1=ans1+c-1\\n        i=i+1\\n    print(max(ans1,ans2))\\n            \\n            \\n\", \"t=int(input())\\nfor i in range(t):\\n    n=int(input())\\n    s=input().strip()\\n    o=0\\n    z=0\\n    for j in range(1,n):\\n        if s[j]==s[j-1]:\\n            if s[j]=='1':\\n                o=o+1\\n            else:\\n                z=z+1\\n    print(max(z,o))\", \"import sys\\n\\ndef input(): return sys.stdin.readline().strip()\\ndef list2d(a, b, c): return [[c for j in range(b)] for i in range(a)]\\ndef list3d(a, b, c, d): return [[[d for k in range(c)] for j in range(b)] for i in range(a)]\\ndef list4d(a, b, c, d, e): return [[[[e for l in range(d)] for k in range(c)] for j in range(b)] for i in range(a)]\\ndef ceil(x, y=1): return int(-(-x // y))\\ndef INT(): return int(input())\\ndef MAP(): return list(map(int, input().split()))\\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\\ndef Yes(): print('Yes')\\ndef No(): print('No')\\ndef YES(): print('YES')\\ndef NO(): print('NO')\\nINF = 10**19\\nMOD = 10**9 + 7\\nEPS = 10**-10\\n\\ndef RLE(data):\\n    from itertools import groupby\\n\\n    return [(x, len(list(grp))) for x, grp in groupby(data)]\\n\\n\\ndef check(S, T):\\n    A = [0] * N\\n    for i in range(N):\\n        if S[i] != T[i]:\\n            A[i] = 1\\n    \\n    rle = RLE(A)\\n    cnt = 0\\n    for x, _ in rle:\\n        if x:\\n            cnt += 1\\n    return cnt\\n\\nfor _ in range(INT()):\\n    N = INT()\\n    S = input()\\n\\n    T1 = '01' * (N//2)\\n    T2 = '10' * (N//2)\\n\\n    ans = min(check(S, T1), check(S, T2))\\n    print(ans)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\nfor tests in range(t):\\n    n=int(input())\\n    S=input().strip()\\n\\n    A=0\\n    for i in range(1,n):\\n        if S[i]==S[i-1]:\\n            A+=1\\n\\n    print((A+1)//2)\\n\", \"for irjfr in range(int(input())):\\n    input()\\n    s = input()\\n    res = int(s[0] == s[-1] == '1')\\n    for i in range(len(s) - 1):\\n        res += int(s[i] == s[i + 1] == '1')\\n    print(res)\", \"for _ in range(int(input())):\\n    n = int(input())\\n    s = input()\\n    ans1 = 0\\n    ans2 = 0\\n    for i in range(n - 1):\\n        if s[i] == s[i + 1]:\\n            if s[i] == '0':\\n                ans1 += 1\\n            else:\\n                ans2 += 1\\n    print(max(ans1, ans2))\\n\", \"import math\\nfor  _ in range(int(input())):\\n    n = int(input())\\n    s = input()\\n    r = 0\\n    for i in range(1,n):\\n        if s[i-1] != s[i]:\\n            continue\\n        else:\\n            r+=1\\n    print(math.ceil(r/2))\\n\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n2\\n10\\n4\\n0110\\n8\\n11101000\\n\"\n  ],\n  \"outputs\": [\n    \"0\\n1\\n2\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1437/B", "starter_code": ""}
{"id": 31, "question": "Skier rides on a snowy field. Its movements can be described by a string of characters 'S', 'N', 'W', 'E' (which correspond to $1$ meter movement in the south, north, west or east direction respectively).\n\nIt is known that if he moves along a previously unvisited segment of a path (i.e. this segment of the path is visited the first time), then the time of such movement is $5$ seconds. If he rolls along previously visited segment of a path (i.e., this segment of the path has been covered by his path before), then it takes $1$ second.\n\nFind the skier's time to roll all the path.\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases in the input. Then $t$ test cases follow.\n\nEach set is given by one nonempty string of the characters 'S', 'N', 'W', 'E'. The length of the string does not exceed $10^5$ characters.\n\nThe sum of the lengths of $t$ given lines over all test cases in the input does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print the desired path time in seconds.\n\n\n-----Example-----\nInput\n5\nNNN\nNS\nWWEN\nWWEE\nNWNWS\n\nOutput\n15\n6\n16\n12\n25", "solutions": "[\"DIR = {\\\"N\\\": (0, 1), \\\"S\\\": (0, -1), \\\"W\\\": (-1, 0), \\\"E\\\": (1, 0)}\\n\\nfor t in range(int(input())):\\n   path = input()\\n   tracks = set()\\n   x, y = 0, 0\\n   time = 0\\n   for char in path:\\n      x1 = x + DIR[char][0]\\n      y1 = y + DIR[char][1]\\n      if (x, y, x1, y1) in tracks or (x1, y1, x, y) in tracks:\\n         time += 1\\n      else:\\n         time += 5\\n         tracks.add((x, y, x1, y1))\\n      x, y = x1, y1\\n   print(time)\\n\", \"import sys\\nINF = 10**20\\nMOD = 10**9 + 7\\nI = lambda:list(map(int,input().split()))\\nfrom math import gcd\\nfrom math import ceil\\nfrom collections import defaultdict as dd, Counter\\nfrom bisect import bisect_left as bl, bisect_right as br\\n\\nt, = I()\\nwhile t:\\n    t -= 1\\n    s = input()\\n    x, y = 0, 0\\n    d = {'N': [0, 1], 'S': [0, -1], 'E': [1, 0], 'W': [-1, 0]}\\n    ans = 0\\n    v = dd(int)\\n    for i in s:\\n        a, b = x + d[i][0], y + d[i][1]\\n        if (x, y, a, b) in v:\\n            ans += 1\\n        else:\\n            ans += 5\\n        v[(x, y, a, b)] = v[(a, b, x, y)] = 1\\n        x, y = a, b\\n    print(ans)\", \"def read_int():\\n    return int(input())\\n\\n\\ndef read_ints():\\n    return list(map(int, input().split(' ')))\\n\\n\\nt = read_int()\\nfor case_num in range(t):\\n    path = input()\\n    pos = (0, 0)\\n    ans = 0\\n    use = set()\\n    d = {'N': (0, 1), 'S': (0, -1), 'W': (-1, 0), 'E': (1, 0)}\\n    for c in path:\\n        ci, cj = pos\\n        di, dj = d[c]\\n        ni, nj = ci + di, cj + dj\\n        pos = (ni, nj)\\n        if ((ci, cj), (ni, nj)) in use:\\n            ans += 1\\n        else:\\n            ans += 5\\n            use.add(((ci, cj), (ni, nj)))\\n            use.add(((ni, nj), (ci, cj)))\\n    print(ans)\\n\", \"t=int(input())\\nfor _ in range(t):\\n    s=input()\\n    aa={}\\n    i=0\\n    j=0\\n    ans=0\\n    for k in s:\\n        if(k==\\\"N\\\"):\\n            try:\\n                x=aa[((i,j),(i,j-1))]\\n                ans+=1\\n            except:\\n                ans+=5\\n                aa[((i,j),(i,j-1))]=1\\n            j-=1\\n                \\n        elif(k==\\\"E\\\"):\\n            try:\\n                x=aa[((i+1,j),(i,j))]\\n                ans+=1\\n            except:\\n                ans+=5\\n                aa[((i+1,j),(i,j))]=1\\n            i+=1\\n        elif(k==\\\"W\\\"):\\n            try:\\n                x=aa[((i,j),(i-1,j))]\\n                ans+=1\\n            except:\\n                ans+=5\\n                aa[((i,j),(i-1,j))]=1\\n            i-=1\\n        else:\\n            try:\\n                x=aa[((i,j+1),(i,j))]\\n                ans+=1\\n            except:\\n                ans+=5\\n                aa[((i,j+1),(i,j))]=1\\n            j+=1\\n    print(ans)\\n    \\n            \\n        \\n         \\n    \\n\", \"dir = {\\n    'N': (0, 1),\\n    'E': (1, 0),\\n    'W': (-1, 0),\\n    'S': (0, -1),\\n}\\n\\nfor tc in range(int(input())):\\n    cur, ans, vis = (0, 0), 0, set()\\n    for c in input():\\n        nxt = (cur[0] + dir[c][0], cur[1] + dir[c][1])\\n\\n        if (cur, nxt) in vis:\\n            ans += 1\\n        else:\\n            ans += 5\\n            vis.add((cur, nxt))\\n            vis.add((nxt, cur))\\n        cur = nxt\\n\\n    print(ans)\\n\", \"t=int(input())\\nfor tests in range(t):\\n    S=input().strip()\\n    ANS=0\\n    Already=set()\\n    X=0\\n    Y=0\\n    \\n    for s in S:\\n        if s==\\\"N\\\":\\n            if (X,Y,X,Y+1) in Already:\\n                ANS+=1\\n            else:\\n                ANS+=5\\n            Already.add((X,Y,X,Y+1))\\n            Already.add((X,Y+1,X,Y))\\n            Y+=1\\n        elif s==\\\"S\\\":\\n            if (X,Y,X,Y-1) in Already:\\n                ANS+=1\\n            else:\\n                ANS+=5\\n            Already.add((X,Y,X,Y-1))\\n            Already.add((X,Y-1,X,Y))\\n            Y-=1\\n        elif s==\\\"W\\\":\\n            if (X,Y,X-1,Y) in Already:\\n                ANS+=1\\n            else:\\n                ANS+=5\\n            Already.add((X,Y,X-1,Y))\\n            Already.add((X-1,Y,X,Y))\\n            X-=1\\n        else:\\n            if (X,Y,X+1,Y) in Already:\\n                ANS+=1\\n            else:\\n                ANS+=5\\n            Already.add((X,Y,X+1,Y))\\n            Already.add((X+1,Y,X,Y))\\n            X+=1\\n\\n    print(ANS)\\n        \\n\", \"for _ in range(int(input())):\\n    s = input()\\n    se = set()\\n    total = 0\\n    curr = [0, 0]\\n    for e in s:\\n        seg = ()\\n        if e == \\\"E\\\":\\n            seg = (curr[0], curr[1], 0)\\n            curr[0] += 1\\n        elif e == \\\"N\\\":\\n            seg = (curr[0], curr[1], 1)\\n            curr[1] += 1\\n        elif e == \\\"W\\\":\\n            seg = (curr[0]-1, curr[1], 0)\\n            curr[0] -= 1\\n        elif e == \\\"S\\\":\\n            seg = (curr[0], curr[1]-1, 1)\\n            curr[1] -= 1\\n        \\n        if seg in se:\\n            total += 1\\n        else:\\n            total += 5\\n            se.add(seg)\\n    print(total)\", \"def list_int(): return list(map(int, input().split()))\\ndef int_in(): return int(input())\\ndef map_in(): return list(map(int, input().split()))\\ndef list_in(): return input().split()\\n\\nt=int_in()\\nfor _ in range(t):\\n    v=set()\\n    s=input()\\n    x=0\\n    y=0\\n    c=0\\n    for i in s:\\n        #print(v, x, y, i)\\n        if i=='N':\\n            if (x,y,x+1,y) in v:\\n                c+=1\\n            elif (x+1,y, x,y) in v:\\n                c+=1\\n            else:\\n                c+=5\\n            v.add((x,y,x+1,y))\\n            x+=1\\n        elif i=='S':\\n            if (x,y,x-1,y) in v:\\n                c+=1\\n            elif (x-1,y, x,y) in v:\\n                c+=1\\n            else:\\n                c+=5\\n            v.add((x,y,x-1,y))\\n            x-=1\\n        elif i=='W':\\n            if (x,y,x,y+1) in v:\\n                c+=1\\n            elif (x, y+1, x,y) in v:\\n                c+=1\\n            else:\\n                c+=5\\n            v.add((x,y,x,y+1))\\n            y+=1\\n        else:\\n            if (x,y,x,y-1) in v:\\n                c+=1\\n            elif (x, y-1, x,y) in v:\\n                c+=1\\n            else:\\n                c+=5\\n            v.add((x,y,x,y-1))\\n            y-=1\\n    print(c)\\n\", \"import sys\\nimport heapq as hq\\n\\nreadline = sys.stdin.readline\\n\\nns = lambda: readline().rstrip()\\nni = lambda: int(readline().rstrip())\\nnm = lambda: list(map(int, readline().split()))\\nnl = lambda: list(map(int, readline().split()))\\n\\n# eps = 10**-7\\n\\ndef solve():\\n    s = ns()\\n    d = dict()\\n    cnt = 0\\n    g = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n    cur = (0, 0)\\n    d[cur] = ''\\n    for x in s:\\n        for i in range(4):\\n            if x == 'NEWS'[i]:\\n                nx = (cur[0] + g[i][0], cur[1] + g[i][1])\\n                if nx in d and x in d[cur]:\\n                    cnt += 1\\n                else:\\n                    cnt += 5\\n                    if nx not in d:\\n                        d[nx] = ''\\n                    d[nx] += 'NEWS'[3-i]\\n                    d[cur] += x\\n                cur = nx\\n                break\\n    print(cnt)\\n\\n\\n# solve()\\n\\nT = ni()\\nfor _ in range(T):\\n    solve()\\n\", \"for __ in range(int(input())):\\n\\ts=input()\\n\\tx=0\\n\\ty=0\\n\\tans=0\\n\\td={}\\n\\tfor i in range(len(s)):\\n\\t\\tif(s[i]=='N'):\\n\\t\\t\\tif(d.get((x,y,x,y+1))==None):\\n\\t\\t\\t\\tans+=5\\n\\t\\t\\t\\td[(x,y,x,y+1)]=1\\n\\t\\t\\t\\td[(x,y+1,x,y)]=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans+=1\\n\\t\\t\\ty=y+1\\n\\t\\telif(s[i]=='S'):\\n\\t\\t\\tif(d.get((x,y,x,y-1))==None):\\n\\t\\t\\t\\tans+=5\\n\\t\\t\\t\\td[(x,y,x,y-1)]=1\\n\\t\\t\\t\\td[(x,y-1,x,y)]=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans+=1\\n\\t\\t\\ty=y-1\\n\\t\\telif(s[i]=='W'):\\n\\t\\t\\tif(d.get((x,y,x-1,y))==None):\\n\\t\\t\\t\\tans+=5\\n\\t\\t\\t\\td[(x,y,x-1,y)]=1\\n\\t\\t\\t\\td[(x-1,y,x,y)]=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans+=1\\n\\t\\t\\tx=x-1\\n\\t\\telse:\\n\\t\\t\\tif(d.get((x,y,x+1,y))==None):\\n\\t\\t\\t\\tans+=5\\n\\t\\t\\t\\td[(x,y,x+1,y)]=1\\n\\t\\t\\t\\td[(x+1,y,x,y)]=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans+=1\\n\\t\\t\\tx=x+1\\n\\tprint(ans)\", \"# alpha = \\\"abcdefghijklmnopqrstuvwxyz\\\"\\n# prime = 1000000007#998244353 \\n# INF = 10000\\n\\n# from sys import stdout\\n# from heapq import heappush, heappop\\n# from collections import defaultdict\\n# from collections import deque \\n# import bisect \\n\\n# from math import sqrt    \\n# from math import gcd\\n# from math import log2\\n\\n# with open('input.in','r') as Reader:\\n#     with open('output.out','w') as out:\\n        # n = int(Reader.readline())\\n\\n    \\n# print(len(arr))\\n# print(arr[:10])\\n\\n\\nt = int(input())\\nfor test in range(t):\\n    # n = int(input())\\n    # n, m = list(map(int, input().split()))\\n    # n2, m2 = list(map(int, input().split()))\\n    s = input()\\n    v = set()\\n    start = 0\\n    ans = 0\\n    cur = [0, 0, 0, 0]\\n    for i in s:\\n        if i==\\\"N\\\":\\n            cur[2] += 1\\n        elif i==\\\"S\\\":\\n            cur[2] -= 1\\n        elif i == \\\"E\\\":\\n            cur[3] += 1\\n        else:\\n            cur[3] -= 1\\n\\n        key1 = str(cur)\\n        key2 = str([cur[2],cur[3], cur[0], cur[1]])\\n        if key1 in v:\\n            ans += 1\\n        else:\\n            ans += 5\\n        \\n        v.add(key1)\\n        v.add(key2)\\n\\n        cur[0] = cur[2]\\n        cur[1] = cur[3]\\n    print(ans)\", \"def new_pos(pos, step):\\n\\tif step == \\\"N\\\":\\n\\t\\tpos = pos[0], pos[1] + 1\\n\\telif step == \\\"S\\\":\\n\\t\\tpos = pos[0], pos[1] -1\\n\\telif step == \\\"W\\\":\\n\\t\\tpos = pos[0] + 1, pos[1]\\n\\telse:\\n\\t\\tpos = pos[0] -1, pos[1]\\n\\treturn pos\\n\\n\\nt = int(input())\\nfor _ in range(t):\\n\\tans = 0\\n\\ts = input()\\n\\tused_hor = set()\\n\\tused_ver = set()\\n\\n\\tpos = (0, 0)\\n\\tn = len(s)\\n\\tfor i in range(n):\\n\\t\\tnext_st = new_pos(pos, s[i])\\n\\t\\tway = (min(pos[0], next_st[0]), min(pos[1], next_st[1]))\\n\\n\\t\\tif s[i] == \\\"N\\\" or s[i] == \\\"S\\\":\\n\\t\\t\\tif way in used_ver:\\n\\t\\t\\t\\tans += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans += 5\\n\\t\\t\\tused_ver.add(way)\\n\\t\\telse:\\n\\t\\t\\tif way in used_hor:\\n\\t\\t\\t\\tans += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans += 5\\n\\t\\t\\tused_hor.add(way)\\n\\t\\tpos = next_st\\n\\t\\t# print(\\\"used_hor\\\", used_hor)\\n\\t\\t# print(\\\"used_ver\\\", used_ver)\\n\\tprint(ans)\\n\", \"import sys\\n\\ndef input(): return sys.stdin.readline().strip()\\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\\ndef ceil(x, y=1): return int(-(-x // y))\\ndef INT(): return int(input())\\ndef MAP(): return list(map(int, input().split()))\\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\\ndef Yes(): print('Yes')\\ndef No(): print('No')\\ndef YES(): print('YES')\\ndef NO(): print('NO')\\nINF = 10 ** 18\\nMOD = 10 ** 9 + 7\\n\\nfor _ in range(INT()):\\n    S = input()\\n\\n    se = set()\\n    h = w = 0\\n    ans = 0\\n    for s in S:\\n        prev = (h, w)\\n        if s == 'S':\\n            h += 1\\n        elif s == 'N':\\n            h -= 1\\n        elif s == 'W':\\n            w -= 1\\n        else:\\n            w += 1\\n        cur = (h, w)\\n        key = (min(prev, cur), max(prev, cur))\\n        if key in se:\\n            ans += 1\\n        else:\\n            ans += 5\\n            se.add(key)\\n    print(ans)\\n\", \"t = int(input())\\nd = {'E': (1, 0), 'W':(-1, 0), 'N':(0, 1), 'S':(0, -1)}\\nfor _ in range(t):\\n    s = input()\\n    time = 0\\n    met = set()\\n    x = y = 0\\n    for c in s:\\n        dx, dy = d[c]\\n        xx = x + dx\\n        yy = y + dy\\n        if (x, y, xx, yy) in met or (xx, yy, x, y) in met:\\n            time += 1\\n        else:\\n            time += 5\\n            met.add((x, y, xx, yy))\\n        x = xx\\n        y = yy\\n    print(time)\", \"import sys,bisect,string,math,time,functools,random\\nfrom heapq import heappush,heappop,heapify\\nfrom collections import deque,defaultdict,Counter\\nfrom itertools import permutations,combinations,groupby\\ndef Golf():*a,=map(int,open(0))\\ndef I():return int(input())\\ndef S_():return input()\\ndef IS():return input().split()\\ndef LS():return [i for i in input().split()]\\ndef LI():return [int(i) for i in input().split()]\\ndef LI_():return [int(i)-1 for i in input().split()]\\ndef NI(n):return [int(input()) for i in range(n)]\\ndef NI_(n):return [int(input())-1 for i in range(n)]\\ndef StoLI():return [ord(i)-97 for i in input()]\\ndef ItoS(n):return chr(n+97)\\ndef LtoS(ls):return ''.join([chr(i+97) for i in ls])\\ndef GI(V,E,ls=None,Directed=False,index=1):\\n    org_inp=[];g=[[] for i in range(V)]\\n    FromStdin=True if ls==None else False\\n    for i in range(E):\\n        if FromStdin:\\n            inp=LI()\\n            org_inp.append(inp)\\n        else:\\n            inp=ls[i]\\n        if len(inp)==2:\\n            a,b=inp;c=1\\n        else:\\n            a,b,c=inp\\n        if index==1:a-=1;b-=1\\n        aa=(a,c);bb=(b,c);g[a].append(bb)\\n        if not Directed:g[b].append(aa)\\n    return g,org_inp\\ndef GGI(h,w,search=None,replacement_of_found='.',mp_def={'#':1,'.':0},boundary=1):\\n#h,w,g,sg=GGI(h,w,search=['S','G'],replacement_of_found='.',mp_def={'#':1,'.':0}) # sample usage\\n    mp=[boundary]*(w+2);found={}\\n    for i in range(h):\\n        s=input()\\n        for char in search:\\n            if char in s:\\n                found[char]=((i+1)*(w+2)+s.index(char)+1)\\n                mp_def[char]=mp_def[replacement_of_found]\\n        mp+=[boundary]+[mp_def[j] for j in s]+[boundary]\\n    mp+=[boundary]*(w+2)\\n    return h+2,w+2,mp,found\\ndef TI(n):return GI(n,n-1)\\ndef bit_combination(k,n=2):\\n    rt=[]\\n    for tb in range(n**k):\\n        s=[tb//(n**bt)%n for bt in range(k)];rt+=[s]\\n    return rt\\ndef show(*inp,end='\\\\n'):\\n    if show_flg:print(*inp,end=end)\\n\\nYN=['YES','NO'];Yn=['Yes','No']\\nmo=10**9+7\\ninf=float('inf')\\nl_alp=string.ascii_lowercase\\n#sys.setrecursionlimit(10**7)\\ninput=lambda: sys.stdin.readline().rstrip()\\n\\nclass Tree:\\n    def __init__(self,inp_size=None,init=True):\\n        self.LCA_init_stat=False\\n        self.ETtable=[]\\n        if init:\\n            self.stdin(inp_size)\\n        return\\n\\n    def stdin(self,inp_size=None,index=1):\\n        if inp_size==None:\\n            self.size=int(input())\\n        else:\\n            self.size=inp_size\\n        self.edges,_=GI(self.size,self.size-1,index=index)\\n        return\\n    \\n    def listin(self,ls,index=0):\\n        self.size=len(ls)+1\\n        self.edges,_=GI(self.size,self.size-1,ls,index=index)\\n        return\\n\\n    def __str__(self):\\n        return  str(self.edges)\\n\\n    def dfs(self,x,func=lambda prv,nx,dist:prv+dist,root_v=0):\\n        q=deque()\\n        q.append(x)\\n        v=[-1]*self.size\\n        v[x]=root_v\\n        while q:\\n            c=q.pop()\\n            for nb,d in self.edges[c]:\\n                if v[nb]==-1:\\n                    q.append(nb)\\n                    v[nb]=func(v[c],nb,d)\\n        return v\\n\\n    def EulerTour(self,x):\\n        q=deque()\\n        q.append(x)\\n        self.depth=[None]*self.size\\n        self.depth[x]=0\\n        self.ETtable=[]\\n        self.ETdepth=[]\\n        self.ETin=[-1]*self.size\\n        self.ETout=[-1]*self.size\\n        cnt=0\\n        while q:\\n            c=q.pop()\\n            if c<0:\\n                ce=~c\\n            else:\\n                ce=c\\n                for nb,d in self.edges[ce]:\\n                    if self.depth[nb]==None:\\n                        q.append(~ce)\\n                        q.append(nb)\\n                        self.depth[nb]=self.depth[ce]+1\\n            self.ETtable.append(ce)\\n            self.ETdepth.append(self.depth[ce])\\n            if self.ETin[ce]==-1:\\n                self.ETin[ce]=cnt\\n            else:\\n                self.ETout[ce]=cnt\\n            cnt+=1\\n        return\\n    \\n    def LCA_init(self,root):\\n        self.EulerTour(root)\\n        self.st=SparseTable(self.ETdepth,init_func=min,init_idl=inf)\\n        self.LCA_init_stat=True\\n        return\\n    \\n    def LCA(self,root,x,y):\\n        if self.LCA_init_stat==False:\\n            self.LCA_init(root)\\n        xin,xout=self.ETin[x],self.ETout[x]\\n        yin,yout=self.ETin[y],self.ETout[y]\\n        a=min(xin,yin)\\n        b=max(xout,yout,xin,yin)\\n        id_of_min_dep_in_et=self.st.query_id(a,b+1)\\n        return self.ETtable[id_of_min_dep_in_et]\\n\\nclass SparseTable: # O(N log N) for init, O(1) for query(l,r)\\n    def __init__(self,ls,init_func=min,init_idl=float('inf')):\\n        self.func=init_func\\n        self.idl=init_idl\\n        self.size=len(ls)\\n        self.N0=self.size.bit_length()\\n        self.table=[ls[:]]\\n        self.index=[list(range(self.size))]\\n        self.lg=[0]*(self.size+1)\\n        \\n        for i in range(2,self.size+1):\\n            self.lg[i]=self.lg[i>>1]+1\\n\\n        for i in range(self.N0):\\n            tmp=[self.func(self.table[i][j],self.table[i][min(j+(1<<i),self.size-1)]) for j in range(self.size)]\\n            tmp_id=[self.index[i][j] if self.table[i][j]==self.func(self.table[i][j],self.table[i][min(j+(1<<i),self.size-1)]) else self.index[i][min(j+(1<<i),self.size-1)] for j in range(self.size)]\\n            self.table+=[tmp]\\n            self.index+=[tmp_id]\\n    \\n    # return func of [l,r)\\n    def query(self,l,r):\\n        #N=(r-l).bit_length()-1\\n        N=self.lg[r-l]\\n        return self.func(self.table[N][l],self.table[N][r-(1<<N)])\\n    \\n    # return index of which val[i] = func of v among [l,r)\\n    def query_id(self,l,r):\\n        #N=(r-l).bit_length()-1\\n        N=self.lg[r-l]\\n        a,b=self.index[N][l],self.index[N][r-(1<<N)]\\n        if self.table[0][a]==self.func(self.table[N][l],self.table[N][r-(1<<N)]):\\n            b=a\\n        return b\\n    \\n    def __str__(self):\\n        return str(self.table[0])\\n        \\n    def print(self):\\n        for i in self.table:\\n            print(*i)\\n\\nshow_flg=False\\nshow_flg=True\\nans=0\\nD='EWNS'\\nm=[(1,0),(-1,0),(0,1),(0,-1)]\\ndc=dict(zip(D,m))\\n\\nT=I()\\nfor _ in range(T):\\n    ans=0\\n    s=input()\\n    N=len(s)*2+5\\n    x,y=(N,N)\\n    p=x*N+y\\n    f=dict()\\n    for i in s:\\n        dx,dy=dc[i]\\n        nx=x+dx\\n        ny=y+dy\\n        X=min(x,nx)\\n        Y=min(y,ny)\\n        p=X*N+Y\\n        p*=1 if dx==0 else -1\\n        if p in f:\\n            ans+=1\\n        else:\\n            ans+=5\\n        \\n        f[p]=1\\n        x,y=nx,ny\\n        #show(x-N,y-N,p,ans,f,N)\\n    \\n    \\n    print(ans)\\n\\n\", \"t=int(input())\\ndef an(x):\\n    if x=='S':\\n        return 'N'\\n    if x=='N':\\n        return 'S'\\n    if x=='W':\\n        return 'E'\\n    if x=='E':\\n        return 'W'\\ndef mov(x,y):\\n    if y=='S':\\n        return (x[0]+1,x[1])\\n    if y=='N':\\n        return (x[0]-1,x[1])\\n    if y=='W':\\n        return (x[0],x[1]+1)\\n    if y=='E':\\n        return (x[0],x[1]-1)\\nwhile t>0:\\n    t-=1\\n    li={}\\n    s=input()\\n    at=(0,0)\\n    ans=0\\n    for i in s:\\n        nx=mov(at,i)\\n        if li.get((at,i),False):\\n            ans+=1\\n        else:\\n            ans+=5\\n            li[(at,i)]=True\\n            li[(nx,an(i))]=True\\n        at=nx\\n    print(ans)\\n\", \"rilist = lambda :[int(i) for  i  in  input().split()]\\nrlist = lambda :[i for  i  in  input().split()]\\nrint = lambda: int(input())\\nrfloat = lambda: float(input())\\ndef pmat(mat):\\n    for i in range(len(mat)):\\n        a = ' '.join(map(str, mat[i]))\\n        print(a)\\n    print()\\n\\nd = {'N':(1,0),'S':(-1,0),'E':(0,1),'W':(0,-1)}\\ndef solve(t):\\n    path = input()\\n    curr = (0, 0)\\n    tmp = {}\\n    res = 0\\n    for p in path:\\n        a,b = d[p]\\n        next = (curr[0]+a,curr[1]+b)\\n        key = sorted((curr, next), key=lambda x:x[0])\\n        key = sorted(key, key=lambda x:x[1])\\n        key = tuple(key)\\n        curr = next\\n        res += tmp.get( key ,5)\\n        tmp[key]=1\\n    print(res)\\ntest = int(input())\\nfor tc in range(test):\\n    solve(tc+1)\", \"t = int(input())\\nfor _ in range(t):\\n    crd = set()\\n    path = input()\\n    x,y = 0,0\\n    sum = 0\\n    for c in path:\\n        if c=='N':\\n            if (x,y-1,x,y) in crd:\\n                sum += 1\\n            elif (x,y,x,y-1) in crd:\\n                sum += 1\\n            else:\\n                crd.add((x,y-1, x, y))\\n                sum += 5\\n            x,y=x,y-1\\n        elif c == 'S':\\n            if (x,y+1,x,y) in crd:\\n                sum += 1\\n            elif (x,y,x,y+1) in crd:\\n                sum += 1\\n            else:\\n                crd.add((x,y+1, x, y))\\n                sum += 5\\n            x,y=x,y+1\\n        elif c=='W':\\n            if (x+1,y,x,y) in crd:\\n                sum += 1\\n            elif (x,y,x+1,y) in crd:\\n                sum += 1\\n            else:\\n                crd.add((x+1,y, x, y))\\n                sum += 5\\n            x,y=x+1,y\\n        elif c=='E':\\n            if (x-1,y,x,y) in crd:\\n                sum += 1\\n            elif (x,y,x-1,y) in crd:\\n                sum += 1\\n            else:\\n                crd.add((x-1,y, x, y))\\n                sum += 5\\n            x,y = x-1,y\\n    print(sum)\", \"from sys import stdin, exit\\ninput = stdin.readline\\n\\ndef i(): return input()\\ndef ii(): return int(input())\\ndef iis(): return list(map(int, input().split()))\\ndef liis():\\treturn list(map(int, input().split()))\\ndef print_array(a): print(\\\" \\\".join(map(str, a)))\\n\\nt = ii()\\nfor _ in range(t):\\n\\ttime = 0\\t\\n\\tx, y = 0, 0\\n\\tvisited = set()\\n\\ts = input()\\n\\tfor i in s:\\n\\t\\told_x = x\\n\\t\\told_y = y\\n\\t\\tif i == 'N': y += 1\\n\\t\\telif i == 'S': y -= 1\\n\\t\\telif i == 'E': x += 1\\n\\t\\telif i == 'W': x -= 1\\n\\t\\telse: continue\\t\\n\\t\\tif (old_x, old_y, x, y) in visited:\\n\\t\\t\\ttime += 1\\n\\t\\telse:\\n\\t\\t\\ttime += 5\\n\\t\\n\\t\\tvisited.add((x, y, old_x, old_y))\\n\\t\\tvisited.add((old_x, old_y, x, y))\\n\\t\\n\\tprint(time)\\n\", \"t = int(input())\\nfor _ in range(t):\\n    s = input()\\n    st = set()\\n    x, y = 0, 0\\n    ans = 0\\n    for c in s:\\n        if c == 'S':\\n            if (x, y + 1) in st:\\n                ans += 1\\n            else:\\n                ans += 5\\n                st.add((x, y + 1))\\n            y += 2\\n        elif c == 'N':\\n            if (x, y - 1) in st:\\n                ans += 1\\n            else:\\n                ans += 5\\n                st.add((x, y - 1))\\n            y -= 2\\n        elif c == 'W':\\n            if (x + 1, y) in st:\\n                ans += 1\\n            else:\\n                ans += 5\\n                st.add((x + 1, y))\\n            x += 2\\n        else:\\n            if (x - 1, y) in st:\\n                ans += 1\\n            else:\\n                ans += 5\\n                st.add((x - 1, y))\\n            x -= 2\\n    print(ans)\\n\", \"from math import *\\n\\nfor zz in range(int(input())):\\n    used = set()\\n    ans = 0\\n    pos = [0, 0]\\n    a = 0\\n    for i in range(35000):\\n        a += 1\\n    a = ans - 1\\n    for x in input():\\n        ppos = pos[:]\\n        ppos = tuple(ppos)\\n        if x == 'N':\\n            pos[0] += 1\\n        elif x == 'S':\\n            pos[0] -= 1\\n        elif x == 'W':\\n            pos[1] -= 1\\n        else:\\n            pos[1] += 1\\n        if ((ppos, tuple(pos)) in used) or ((tuple(pos), ppos) in used):\\n            ans += 1\\n        else:\\n            used.add((ppos, tuple(pos)))\\n            ans += 5\\n    print(ans)\\n\\n#aaa\\n\", \"import time\\nimport sys\\nreadline = sys.stdin.readline\\n\\nt = time.time()\\nd = {'N': -10**9, 'S': 10**9, 'E': 1, 'W': -1}\\nfor _ in range(int(input())):\\n    s = readline().rstrip()\\n    pos = 0\\n    visited = set()\\n    dist = 0\\n    for c in s:\\n        dest = pos + d[c]\\n        dist += 1 if (pos, dest) in visited or (dest, pos) in visited else 5\\n        visited.update(((pos, dest), (dest, pos)))\\n        pos = dest\\n\\n    print(dist)\\n\\nwhile time.time() - t < 0.9:\\n    pass\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"5\\nNNN\\nNS\\nWWEN\\nWWEE\\nNWNWS\\n\"\n  ],\n  \"outputs\": [\n    \"15\\n6\\n16\\n12\\n25\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1351/C", "starter_code": ""}
{"id": 32, "question": "Lately, Mr. Chanek frequently plays the game Arena of Greed. As the name implies, the game's goal is to find the greediest of them all, who will then be crowned king of Compfestnesia.\n\nThe game is played by two people taking turns, where Mr. Chanek takes the first turn. Initially, there is a treasure chest containing $N$ gold coins. The game ends if there are no more gold coins in the chest. In each turn, the players can make one of the following moves:  Take one gold coin from the chest.  Take half of the gold coins on the chest. This move is only available if the number of coins in the chest is even. \n\nBoth players will try to maximize the number of coins they have. Mr. Chanek asks your help to find the maximum number of coins he can get at the end of the game if both he and the opponent plays optimally.\n\n\n-----Input-----\n\nThe first line contains a single integer $T$ $(1 \\le T \\le 10^5)$ denotes the number of test cases.\n\nThe next $T$ lines each contain a single integer $N$ $(1 \\le N \\le 10^{18})$.\n\n\n-----Output-----\n\n$T$ lines, each line is the answer requested by Mr. Chanek.\n\n\n-----Example-----\nInput\n2\n5\n6\n\nOutput\n2\n4\n\n\n\n-----Note-----\n\nFor the first case, the game is as follows:   Mr. Chanek takes one coin.  The opponent takes two coins.  Mr. Chanek takes one coin.  The opponent takes one coin. \n\nFor the second case, the game is as follows:   Mr. Chanek takes three coins.  The opponent takes one coin.  Mr. Chanek takes one coin.  The opponent takes one coin.", "solutions": "[\"from sys import stdin, stdout\\nfrom collections import defaultdict\\ninput = stdin.readline\\nfor _ in range(int(input())):\\n\\tn = int(input())\\n\\tchanek = 0\\n\\tflag = 1\\n\\twhile n>0:\\n\\t\\tif n%4==0 and n!=4:\\n\\t\\t\\tif flag:\\n\\t\\t\\t\\tchanek += 1\\n\\t\\t\\t\\tn-=1\\n\\t\\t\\t\\tflag = 0\\n\\t\\t\\telse:\\n\\t\\t\\t\\tn-=1\\n\\t\\t\\t\\tflag = 1\\n\\t\\telif n%2:\\n\\t\\t\\tif flag:\\n\\t\\t\\t\\tchanek += 1\\n\\t\\t\\t\\tn-=1\\n\\t\\t\\t\\tflag = 0\\n\\t\\t\\telse:\\n\\t\\t\\t\\tn-=1\\n\\t\\t\\t\\tflag = 1\\n\\t\\telse:\\n\\t\\t\\tif flag:\\n\\t\\t\\t\\tchanek += n//2\\n\\t\\t\\t\\tn//=2\\n\\t\\t\\t\\tflag = 0\\n\\t\\t\\telse:\\n\\t\\t\\t\\tn//=2\\n\\t\\t\\t\\tflag = 1\\n\\tprint(chanek)\", \"from sys import stdin\\ninput = stdin.readline\\n\\ndef max_pos_coins(n):\\n\\ta = 0\\n\\twhile n != 0:\\n\\t\\tif n == 4:\\n\\t\\t\\ta += 3\\n\\t\\t\\tn = 0\\n\\t\\t\\tcontinue\\n\\t\\tif n % 4 == 0:\\n\\t\\t\\tn -= 2\\n\\t\\t\\ta += 1\\n\\t\\telse:\\n\\t\\t\\ta += n // 2\\n\\t\\t\\tn = n // 2 - 1\\n\\treturn a\\n\\nfor _ in range(int(input())):\\n\\tn = int(input())\\n\\tprint(max_pos_coins(n) if n % 2 == 0 else n - max_pos_coins(n - 1))\\n\", \"import itertools\\n\\ndef f(x):\\n    scores = [0, 0]\\n    for i in itertools.cycle([0, 1]):\\n\\n        if x & 1:\\n            scores[i] += 1\\n            x -= 1\\n\\n        elif x == 0:\\n            return scores[0]\\n\\n        elif x == 4 or x & 0b10:\\n            x >>= 1\\n            scores[i] += x\\n        else:\\n            x -= 1\\n            scores[i] += 1\\n\\n\\nN = int(input())\\nresults = []\\n\\nimport sys\\nfor n in map(f, map(int, sys.stdin.read().split())):\\n    results.append(n)\\n\\nprint('\\\\n'.join(map(str, results)))\"]", "input_output": "{\n  \"inputs\": [\n    \"2\\n5\\n6\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n4\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1425/A", "starter_code": ""}
{"id": 33, "question": "Numbers $1, 2, 3, \\dots n$ (each integer from $1$ to $n$ once) are written on a board. In one operation you can erase any two numbers $a$ and $b$ from the board and write one integer $\\frac{a + b}{2}$ rounded up instead.\n\nYou should perform the given operation $n - 1$ times and make the resulting number that will be left on the board as small as possible. \n\nFor example, if $n = 4$, the following course of action is optimal:  choose $a = 4$ and $b = 2$, so the new number is $3$, and the whiteboard contains $[1, 3, 3]$;  choose $a = 3$ and $b = 3$, so the new number is $3$, and the whiteboard contains $[1, 3]$;  choose $a = 1$ and $b = 3$, so the new number is $2$, and the whiteboard contains $[2]$. \n\nIt's easy to see that after $n - 1$ operations, there will be left only one number. Your goal is to minimize it.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains one integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of integers written on the board initially.\n\nIt's guaranteed that the total sum of $n$ over test cases doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, in the first line, print the minimum possible number left on the board after $n - 1$ operations. Each of the next $n - 1$ lines should contain two integers\u00a0\u2014 numbers $a$ and $b$ chosen and erased in each operation.\n\n\n-----Example-----\nInput\n1\n4\n\nOutput\n2\n2 4\n3 3\n3 1", "solutions": "[\"t=int(input())\\nfor i in range(t):\\n    n=int(input())\\n    print(2)\\n    print(n-1,n)\\n    for i in range(n-2,0,-1):\\n        print(i,i+2)\", \"for _ in range (int(input())):\\n    n=int(input())\\n    hold=n\\n    res=[]\\n    for i in range (n-1,0,-1):\\n        res.append((hold,i))\\n        hold=(hold+i+1)//2\\n    print(hold)\\n    for i in res:\\n        print(*i)\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    print(2)\\n    print(n-1, n)\\n    for i in range(n-2):\\n        print(n-2-i, n-i)\", \"import sys\\nimport random\\n# import numpy as np\\nimport math\\nimport copy\\nfrom heapq import heappush, heappop, heapify\\nfrom functools import cmp_to_key\\nfrom bisect import bisect_left, bisect_right\\nfrom collections import defaultdict, deque, Counter\\n# sys.setrecursionlimit(1000000)\\n# input aliases\\ninput = sys.stdin.readline\\ngetS = lambda: input().strip()\\ngetN = lambda: int(input())\\ngetList = lambda: list(map(int, input().split()))\\ngetZList = lambda: [int(x) - 1 for x in input().split()]\\n\\nINF = float(\\\"inf\\\")\\n\\nMOD = 10 ** 9 + 7\\ndivide = lambda x: pow(x, MOD-2, MOD)\\n\\ndef judge(at, ax, ay, bt, bx, by):\\n    if abs(at - bt) >= abs(ax - bx) + abs(ay - by):\\n        return True\\n    else:\\n        return False\\n\\n\\ndef solve():\\n    n = getN()\\n    if n == 2:\\n        print(2)\\n        print(1, 2)\\n        return\\n\\n    print(2)\\n    print(n-2, n)\\n    print(n-1, n-1)\\n    for i in range(n-3):\\n        print(n-1-i, n-3-i)\\n    return\\n\\ndef main():\\n    n = getN()\\n    for _ in range(n):\\n        solve()\\n\\n    return\\ndef __starting_point():\\n    main()\\n    # solve()\\n\\n__starting_point()\", \"t=int(input())\\nfor you in range(t):\\n    n=int(input())\\n    print(2)\\n    l=[i+1 for i in range(n)]\\n    for i in range(n-1):\\n        print(l[-1],l[-2])\\n        z=(l[-1]+l[-2]+1)//2\\n        l.pop(-1)\\n        l.pop(-1)\\n        l.append(z)\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    k = n\\n    print(2)\\n    for i in range(n-1,0,-1):\\n        print(i,k)\\n        if (k+i)%2!= 0:\\n            k = (k+i)//2 + 1\\n        else:\\n            k = (k+i)//2\\n        \\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nt = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    print(2)\\n    if n == 2:\\n        print(1,2)\\n    else:\\n        print(n,n-2)\\n        print(n-1,n-1)\\n        for j in range(n-3):\\n            print(n-1-j,n-1-j-2)   \", \"#dt = {} for i in x: dt[i] = dt.get(i,0)+1\\nimport sys;input = sys.stdin.readline\\n#import io,os; input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline #for pypy\\ninp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]\\n\\nfor _ in range(inp()):\\n    n = inp()\\n    prev = n\\n    print(2)\\n    for i in range(n-1,0,-1):\\n        print(i,prev)\\n        prev = (i+prev-1)//2 +1\", \"T =  int(input())\\nfor _ in range(T):\\n    N = int(input())\\n    A = list(range(1,N+1))\\n    print(2)\\n    while len(A) > 1:\\n        a = A.pop()\\n        b = A.pop()\\n        c = (a+b+1)//2\\n        print(a,b)\\n        A.append(c)\\n\", \"import sys, math\\nimport io, os\\n#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\\nfrom bisect import bisect_left as bl, bisect_right as br, insort\\nfrom heapq import heapify, heappush, heappop\\nfrom collections import defaultdict as dd, deque, Counter\\n#from itertools import permutations,combinations\\ndef data(): return sys.stdin.readline().strip()\\ndef mdata(): return list(map(int, data().split()))\\ndef outl(var) : sys.stdout.write('\\\\n'.join(map(str, var))+'\\\\n')\\ndef out(var) : sys.stdout.write(str(var)+'\\\\n')\\n#from decimal import Decimal\\n#from fractions import Fraction\\n#sys.setrecursionlimit(100000)\\nINF = float('inf')\\nmod=10**9+7\\n\\n\\nfor t in range(int(data())):\\n    n=int(data())\\n    out(2)\\n    ans=[]\\n    k=n\\n    for i in range(n-1,0,-1):\\n        ans.append(str(k)+' '+str(i))\\n        k=(k+i+1)//2\\n    outl(ans)\\n\", \"from bisect import bisect_left as bl\\nfrom bisect import bisect_right as br\\nfrom heapq import heappush,heappop,heapify\\nimport math\\nfrom collections import *\\nfrom functools import reduce,cmp_to_key\\nimport sys\\ninput = sys.stdin.readline\\n\\nfrom itertools import accumulate\\nfrom functools import lru_cache\\n\\nM = mod = 10 ** 9 + 7\\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\\ndef inv_mod(n):return pow(n, mod - 2, mod)\\n \\ndef li():return [int(i) for i in input().rstrip('\\\\n').split()]\\ndef st():return input().rstrip('\\\\n')\\ndef val():return int(input().rstrip('\\\\n'))\\ndef li2():return [i for i in input().rstrip('\\\\n')]\\ndef li3():return [int(i) for i in input().rstrip('\\\\n')]\\n\\n\\nfor _ in range(val()):\\n    n = val()\\n    \\n    print(2)\\n    l = list(range(1, n + 1))\\n    for i in range(n - 1):\\n        a, b = l.pop(), l.pop()\\n        print(a, b)\\n        l.append((a + b + 1) // 2)\\n\", \"from math import ceil\\n\\nn = int(input())\\n\\nfor _ in range(n):\\n    k = int(input())\\n    \\n    arr = list(range(1, k+1))\\n    o = []\\n\\n    for i in range(k-1):\\n        a = arr.pop()\\n        b = arr.pop()\\n        o.append((a, b))\\n        arr.append(ceil((a+b)/2))\\n\\n    print(arr[0])\\n    for i in range(len(o)):\\n        print(o[i][0], o[i][1])\\n    \\n\", \"import sys\\ninput = sys.stdin.readline\\n\\n\\ndef main():\\n    t = int(input())\\n    for _ in range(t):\\n        N = int(input())\\n\\n        x = []\\n        for i in range(1, N + 1):\\n            x.append(i)\\n\\n        print(2)\\n\\n        while len(x) >= 2:\\n            a = x.pop()\\n            b = x.pop()\\n            c = -(-(a + b) // 2)\\n            print(a, b)\\n            x.append(c)\\n\\n        \\n    \\n\\ndef __starting_point():\\n    main()\\n\\n\\n\\n__starting_point()\", \"t = int(input())\\nns = []\\nfor _ in range(t):\\n    n = int(input())\\n    ns.append(n)\\n\\nfor n in ns:\\n    print(2)\\n    print(n-1, n)\\n    if n > 2:\\n        for x in range(n, 2, -1):\\n            print(x-2, x)\\n\", \"t = int(input())\\n\\nfor _ in range(t):\\n    n = int(input())\\n\\n    print(2)\\n    print('{0} {1}'.format(n-1, n))\\n\\n    for k in range(n, 2, -1):\\n        print('{0} {1}'.format(k-2, k))\\n\", \"def solve():\\n    n = int(input())\\n    if n == 2:\\n        print(2)\\n        print(1, 2)\\n        return 0\\n    lst = list(range(1, n + 1))\\n    ans = []\\n    ans.append([n-2,n])\\n    ans.append([n-1,n-1])\\n    lst.pop()\\n    lst.pop()\\n    lst.pop()\\n    lst.append(n-1)\\n    while len(lst) > 1:\\n        a = lst[-1]\\n        b = lst[-2]\\n        c = (a + b + 1) // 2\\n        ans.append([a,b])\\n        lst.pop()\\n        lst.pop()\\n        lst.append(c)\\n    print(lst[0])\\n    for i in ans:\\n        print(*i)\\nfor i in range(int(input())):\\n    solve()\", \"import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\nfor tests in range(t):\\n    n=int(input())\\n    print(2)\\n    x=n\\n    for i in range(n-1,0,-1):\\n        print(x,i)\\n        x=(x+i+1)//2\\n\\n    \\n\\n    \\n\", \"\\\"\\\"\\\"T=int(input())\\nfor _ in range(0,T):\\n    n=int(input())\\n    a,b=map(int,input().split())\\n    s=input()\\n    s=[int(x) for x in input().split()]\\n    for i in range(0,len(s)):\\n        a,b=map(int,input().split())\\\"\\\"\\\"\\n\\n\\nT=int(input())\\nfor _ in range(0,T):\\n    n=int(input())\\n    print(2)\\n\\n    num=n\\n    for i in range(n-1,0,-1):\\n        print(i,num)\\n        if((num+i)%2==0):\\n            num=(num+i)//2\\n\\n            \\n        \\n\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    A = list(range(1, n+1))\\n    ans = []\\n    t = -1\\n    for i in range(n-1):\\n        ans.append((A[-2], A[-1]))\\n        x = A.pop()\\n        if (x+A[-1])%2 == 0:\\n            A[-1] = (x+A[-1])//2\\n        else:\\n            A[-1] = (x+A[-1]+1)//2\\n    print(A[0])\\n    for i in range(len(ans)):\\n        print(*ans[i])\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    print(2, flush=False)\\n    print(f'{n} {n-1}', flush=False)\\n    if n > 2:\\n        print('\\\\n'.join(f'{x} {x-2}' for x in range(n, 2, -1)))\\n\", \"# 3x + 5y + 7z\\n\\nt = int(input())\\n\\nwhile t:\\n    t -= 1\\n    n = int(input())\\n    print(2)\\n    arr = [n-1,n]\\n    print(*arr)\\n    for i in range(2,n):\\n        arr = [n-i,n-i+2]\\n        print(*arr)\"]", "input_output": "{\"inputs\": [\"1\\n4\\n\"], \"outputs\": [\"2\\n4 3\\n4 2\\n3 1\\n\"]}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1430/C", "starter_code": ""}
{"id": 34, "question": "You have a large electronic screen which can display up to $998244353$ decimal digits. The digits are displayed in the same way as on different electronic alarm clocks: each place for a digit consists of $7$ segments which can be turned on and off to compose different digits. The following picture describes how you can display all $10$ decimal digits:\n\n[Image]\n\nAs you can see, different digits may require different number of segments to be turned on. For example, if you want to display $1$, you have to turn on $2$ segments of the screen, and if you want to display $8$, all $7$ segments of some place to display a digit should be turned on.\n\nYou want to display a really large integer on the screen. Unfortunately, the screen is bugged: no more than $n$ segments can be turned on simultaneously. So now you wonder what is the greatest integer that can be displayed by turning on no more than $n$ segments.\n\nYour program should be able to process $t$ different test cases.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 100$) \u2014 the number of test cases in the input.\n\nThen the test cases follow, each of them is represented by a separate line containing one integer $n$ ($2 \\le n \\le 10^5$) \u2014 the maximum number of segments that can be turned on in the corresponding testcase.\n\nIt is guaranteed that the sum of $n$ over all test cases in the input does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print the greatest integer that can be displayed by turning on no more than $n$ segments of the screen. Note that the answer may not fit in the standard $32$-bit or $64$-bit integral data type.\n\n\n-----Example-----\nInput\n2\n3\n4\n\nOutput\n7\n11", "solutions": "[\"for _ in range(int(input())):\\n\\tn = int(input())\\n\\tif(n%2):\\n\\t\\tprint(\\\"7\\\"+\\\"1\\\"*((n-3)//2))\\n\\telse:\\n\\t\\tprint(\\\"1\\\"*(n//2))\\t\", \"t=int(input())\\nfor i in ' '*t:\\n    n=int(input())\\n    if n%2==1:print('7'+'1'*((n-3)//2))\\n    else:print('1'*(n//2))\", \"for _ in range(int(input())):\\n\\tn = int(input())\\n\\n\\tif n % 2:\\n\\t\\tprint('7', end = \\\"\\\")\\n\\t\\tn -= 3\\n\\n\\twhile n:\\n\\t\\tprint('1', end = \\\"\\\")\\n\\t\\tn -= 2\\n\\n\\tprint()\", \"T = int(input())\\nfor kase in range(T):\\n    n = int(input())\\n    if n&1:\\n        print('7'+(n-3)//2*'1')\\n    else:\\n        print(n//2*'1')\", \"for _ in range(int(input())):\\n\\tn=int(input())\\n\\tif n%2==1:\\n\\t\\tprint(\\\"7\\\"+\\\"1\\\"*(n//2-1))\\n\\telse:\\n\\t\\tprint(\\\"1\\\"*(n//2))\", \"import sys\\ninput = sys.stdin.readline\\ndef getInt(): return int(input())\\ndef getVars(): return list(map(int, input().split()))\\ndef getList(): return list(map(int, input().split()))\\ndef getStr(): return input().strip()\\n## -------------------------------\\nt = getInt()\\nfor _ in range(t):\\n    n = getInt()\\n    if n%2 == 1:\\n        print('7' + '1' * (n//2 - 1))\\n    else:\\n        print('1'*(n//2))\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    if n % 2 == 0:\\n        print ('1' * (n // 2))\\n    else:\\n        print ('7' + '1' * ((n - 3) // 2))\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    print(\\\"7\\\" * (n % 2) + \\\"1\\\" * (n // 2 - (n % 2)))\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    arr = ''\\n    if (n % 2 == 1):\\n        arr = '7'\\n        for j in range((n - 3) // 2):\\n            arr += '1'\\n    else:\\n        for j in range(n // 2):\\n            arr += '1'\\n    print(arr)\\n\\n\", \"import sys\\nimport math\\nimport itertools\\nimport functools\\nimport collections\\nimport operator\\n\\n\\ndef ii(): return int(input())\\ndef mi(): return list(map(int, input().split()))\\ndef li(): return list(map(int, input().split()))\\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\\ndef revn(n): return str(n)[::-1]\\ndef dd(): return collections.defaultdict(int)\\ndef ddl(): return collections.defaultdict(list)\\ndef sieve(n):\\n    if n < 2: return list()\\n    prime = [True for _ in range(n + 1)]\\n    p = 3\\n    while p * p <= n:\\n        if prime[p]:\\n            for i in range(p * 2, n + 1, p):\\n                prime[i] = False\\n        p += 2\\n    r = [2]\\n    for p in range(3, n + 1, 2):\\n        if prime[p]:\\n            r.append(p)\\n    return r\\ndef divs(n, start=2):\\n    r = []\\n    for i in range(start, int(math.sqrt(n) + 1)):\\n        if (n % i == 0):\\n            if (n / i == i):\\n                r.append(i)\\n            else:\\n                r.extend([i, n // i])\\n    return r\\ndef divn(n, primes):\\n    divs_number = 1\\n    for i in primes:\\n        if n == 1:\\n            return divs_number\\n        t = 1\\n        while n % i == 0:\\n            t += 1\\n            n //= i\\n        divs_number *= t\\ndef prime(n):\\n    if n == 2: return True\\n    if n % 2 == 0 or n <= 1: return False\\n    sqr = int(math.sqrt(n)) + 1\\n    for d in range(3, sqr, 2):\\n        if n % d == 0: return False\\n    return True\\ndef convn(number, base):\\n    newnumber = 0\\n    while number > 0:\\n        newnumber += number % base\\n        number //= base\\n    return newnumber\\ndef cdiv(n, k): return n // k + (n % k != 0)\\n\\n\\nt = ii()\\nfor _ in range(t):\\n    n = ii()\\n    if n % 2:\\n        print('7' + '1' * ((n - 3) // 2))\\n    else:\\n        print('1' * (n // 2))\\n\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    s = ''\\n    if n % 2:\\n        s = '7'\\n        n -= 3\\n    else:\\n        s = '1'\\n        n -= 2\\n    s += '1' * (n // 2)\\n    print(s)\\n\", \"t=int(input())\\nfor _ in range(t):\\n    n=int(input())\\n    if n%2==0:\\n        print(\\\"1\\\"*(n//2))\\n    else:\\n        print(\\\"7\\\"+\\\"1\\\"*((n-3)//2))\\n        \\n\", \"t =  int(input())\\n\\nfor _ in range(t):\\n    n = int(input())\\n    if (n%2==0):\\n        print('1'*(n//2))\\n    else:\\n        print('7'+'1'*((n-3)//2))\", \"for _ in range(int(input())):\\n    n=int(input())\\n    if n%2==0:\\n        print('1'*(n//2))\\n    else:\\n        print('7'+('1'*((n//2)-1)))\\n\", \"t = int(input())\\n\\nwhile t:\\n    t -= 1\\n    n = int(input())\\n    if n % 2 == 0:\\n        print('1' * (n//2))\\n    else:\\n        print('7' + '1' * ((n - 3)//2))\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    if n % 2 == 0:\\n        print('1'*(n//2))\\n    else:\\n        print('7'+'1'*(n//2-1))\\n\", \"t = int(input())\\nwhile t:\\n    n = int(input())\\n    o = \\\"1\\\" * (n // 2)\\n    if n % 2: o = \\\"7\\\" + o[1:]\\n    print(o)\\n    t -= 1\\n\", \"n=int(input())\\nfor i in range(n):\\n    d=int(input())\\n    if d%2==1:\\n        e=(d-3)//2\\n        s='7'+'1'*e\\n    else:\\n        e=d//2\\n        s='1'*e\\n    print(s)\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    if n % 2 == 0:\\n        print(\\\"1\\\"*(n//2))\\n    else:\\n        print(\\\"7\\\"+\\\"1\\\"*(n//2-1))\\n\", \"t=int(input())\\nfor _ in range(t):\\n    n=int(input())\\n    if n%2==0:\\n        x=n//2\\n        for i in range(x):\\n            print(1,end='')\\n    else:\\n        x=n//2\\n        x-=1\\n        print(7,end='')\\n        for i in range(x):\\n            print(1,end='')\\n    print()\", \"t = int(input())\\nfor y in range(t):\\n\\tn = int(input())\\n\\ts = \\\"\\\"\\n\\tif(n%2 == 1):\\n\\t\\ts += '7'\\n\\t\\tn -= 3\\n\\ts += (n//2)*'1'\\n\\tprint(int(s))\"]", "input_output": "{\"inputs\": [\"2\\n3\\n4\\n\"], \"outputs\": [\"7\\n11\\n\"]}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1295/A", "starter_code": ""}
{"id": 35, "question": "Young wilderness explorers set off to their first expedition led by senior explorer Russell. Explorers went into a forest, set up a camp and decided to split into groups to explore as much interesting locations as possible. Russell was trying to form groups, but ran into some difficulties...\n\nMost of the young explorers are inexperienced, and sending them alone would be a mistake. Even Russell himself became senior explorer not long ago. Each of young explorers has a positive integer parameter $e_i$\u00a0\u2014 his inexperience. Russell decided that an explorer with inexperience $e$ can only join the group of $e$ or more people.\n\nNow Russell needs to figure out how many groups he can organize. It's not necessary to include every explorer in one of the groups: some can stay in the camp. Russell is worried about this expedition, so he asked you to help him.\n\n\n-----Input-----\n\nThe first line contains the number of independent test cases $T$($1 \\leq T \\leq 2 \\cdot 10^5$). Next $2T$ lines contain description of test cases.\n\nThe first line of description of each test case contains the number of young explorers $N$ ($1 \\leq N \\leq 2 \\cdot 10^5$).\n\nThe second line contains $N$ integers $e_1, e_2, \\ldots, e_N$ ($1 \\leq e_i \\leq N$), where $e_i$ is the inexperience of the $i$-th explorer.\n\nIt's guaranteed that sum of all $N$ doesn't exceed $3 \\cdot 10^5$.\n\n\n-----Output-----\n\nPrint $T$ numbers, each number on a separate line.\n\nIn $i$-th line print the maximum number of groups Russell can form in $i$-th test case.\n\n\n-----Example-----\nInput\n2\n3\n1 1 1\n5\n2 3 1 2 2\n\nOutput\n3\n2\n\n\n\n-----Note-----\n\nIn the first example we can organize three groups. There will be only one explorer in each group. It's correct because inexperience of each explorer equals to $1$, so it's not less than the size of his group.\n\nIn the second example we can organize two groups. Explorers with inexperience $1$, $2$ and $3$ will form the first group, and the other two explorers with inexperience equal to $2$ will form the second group.\n\nThis solution is not unique. For example, we can form the first group using the three explorers with inexperience equal to $2$, and the second group using only one explorer with inexperience equal to $1$. In this case the young explorer with inexperience equal to $3$ will not be included in any group.", "solutions": "[\"import sys\\n\\ninput=sys.stdin.readline\\n\\nfor _ in range(int(input())):\\n    N=int(input())\\n    e=list(map(int,input().split()))\\n    e.sort()\\n    ans=0\\n    val=0\\n    g=0\\n    for i in range(0,N):\\n        g+=1\\n        val=e[i]\\n        if g>=val:\\n            ans+=1\\n            g=0\\n            val=0\\n    print(ans)\\n\", \"from sys import stdin\\nfor _ in range(int(stdin.readline())):\\n    n = int(stdin.readline())\\n    ans = 0\\n    arr = sorted(list(map(int,stdin.readline().split())))\\n    peo = 0\\n    for i in range(n):\\n        peo += 1\\n        if peo == arr[i]:\\n            ans += 1\\n            peo = 0\\n    print(ans)\\n\", \"import sys\\ninput = sys.stdin.readline\\nt = int(input())\\nfor _ in range(t):\\n  n = int(input())\\n  a = list(map(int,input().split()))\\n  a.sort()\\n  ans = 0\\n  sepa = -1\\n  for i in range(n):\\n    if i-sepa >= a[i]:\\n      sepa = i\\n      ans += 1\\n  print(ans)\", \"import sys\\n\\ndef solve():\\n    input = sys.stdin.readline\\n    T = int(input())\\n    Ans = [0] * T\\n    for t in range(T):\\n        N = int(input())\\n        A = [int(a) for a in input().split()]\\n        skillDict = dict()\\n        for a in A:\\n            if a in skillDict: skillDict[a] += 1\\n            else: skillDict[a] = 1\\n        for i in range(1, N+1):\\n            if i in skillDict:\\n                Ans[t] += skillDict[i] // i\\n                if i+1 not in skillDict: skillDict[i+1] = 0\\n                skillDict[i+1] += skillDict[i] % i\\n    print(\\\"\\\\n\\\".join(map(str, Ans)))\\n  \\n\\n    return 0\\n\\ndef __starting_point():\\n    solve()\\n__starting_point()\", \"import sys\\ninput = sys.stdin.readline\\n\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    e = list(map(int, input().split()))\\n    \\n    e = sorted(e)\\n    ans = 0\\n    \\n    cnt = 0\\n    max_ = 0\\n    for i in range(n):\\n        cnt += 1\\n        max_ = max(e[i], max_)\\n        if max_ <= cnt:\\n            ans += 1\\n            max_ = 0\\n            cnt = 0\\n    print(ans)\"]", "input_output": "{\n  \"inputs\": [\n    \"2\\n3\\n1 1 1\\n5\\n2 3 1 2 2\\n\"\n  ],\n  \"outputs\": [\n    \"3\\n2\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1355/B", "starter_code": ""}
{"id": 36, "question": "It is lunch time for Mole. His friend, Marmot, prepared him a nice game for lunch.\n\nMarmot brought Mole n ordered piles of worms such that i-th pile contains a_{i} worms. He labeled all these worms with consecutive integers: worms in first pile are labeled with numbers 1 to a_1, worms in second pile are labeled with numbers a_1 + 1 to a_1 + a_2 and so on. See the example for a better understanding.\n\nMole can't eat all the worms (Marmot brought a lot) and, as we all know, Mole is blind, so Marmot tells him the labels of the best juicy worms. Marmot will only give Mole a worm if Mole says correctly in which pile this worm is contained.\n\nPoor Mole asks for your help. For all juicy worms said by Marmot, tell Mole the correct answers.\n\n\n-----Input-----\n\nThe first line contains a single integer n (1 \u2264 n \u2264 10^5), the number of piles.\n\nThe second line contains n integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^3, a_1 + a_2 + ... + a_{n} \u2264 10^6), where a_{i} is the number of worms in the i-th pile.\n\nThe third line contains single integer m (1 \u2264 m \u2264 10^5), the number of juicy worms said by Marmot.\n\nThe fourth line contains m integers q_1, q_2, ..., q_{m} (1 \u2264 q_{i} \u2264 a_1 + a_2 + ... + a_{n}), the labels of the juicy worms.\n\n\n-----Output-----\n\nPrint m lines to the standard output. The i-th line should contain an integer, representing the number of the pile where the worm labeled with the number q_{i} is.\n\n\n-----Examples-----\nInput\n5\n2 7 3 4 9\n3\n1 25 11\n\nOutput\n1\n5\n3\n\n\n\n-----Note-----\n\nFor the sample input:\n\n  The worms with labels from [1, 2] are in the first pile.  The worms with labels from [3, 9] are in the second pile.  The worms with labels from [10, 12] are in the third pile.  The worms with labels from [13, 16] are in the fourth pile.  The worms with labels from [17, 25] are in the fifth pile.", "solutions": "[\"n=int(input())\\na=list(map(int,input().split()))\\nk=[]\\nfor i in range(n):\\n    for j in range(a[i]):\\n        k.append(i+1)\\nm=int(input())\\nb=list(map(int,input().split()))\\nfor i in b:\\n    print(k[i-1])\", \"n, p, m, w = int(input()), list(map(int, input().split())), int(input()), sorted(enumerate(map(int, input().split())), key = lambda x: x[1])\\nans, pos = [-1] * m, [0, 0]\\nfor i, c in w:\\n    while pos[0] + p[pos[1]] < c:\\n        pos[0] += p[pos[1]]\\n        pos[1] += 1\\n    ans[i] = pos[1] + 1\\nprint(*ans, sep = '\\\\n')\\n\", \"from sys import stdin, stdout\\nfrom bisect import *\\ninput = stdin.read()\\nn, ai_str, m, qi_str = [_f for _f in input.split('\\\\n') if _f]\\n\\na = list(map(int, ai_str.split()))\\nq = list(map(int, qi_str.split()))\\nassert len(a) > 0 and len(q) > 0\\n\\nb = [0] * len(a)\\nfor i, ai in enumerate(a):\\n\\tb[i] = b[i-1] + ai\\n\\n\\nfor qi in q:\\n\\tprint(bisect_left(b, qi) + 1)\\n\", \"\\n\\n\\ninput()\\nheaps = list(map(int, input().split()))\\ninput()\\nnumbers = list(map(int, input().split()))\\n#heaps = [2, 7, 3, 4, 9]\\n#numbers = [1, 25, 11]\\nres = [0] * len(numbers)\\n\\nsums = [heaps[0]]\\nmask = [1] * heaps[0]\\nfor i in range(1, len(heaps)):\\n    mask += [i+1] * (heaps[i])\\n    sums.append(heaps[i] + sums[-1])\\n\\nfor i in range(len(numbers)):\\n    print(mask[numbers[i]-1])\\n\\n\", \"num = int(input())\\npiles = list(map(int, input().split(' ')))\\ntuplex = []\\ncurr = 1\\nfor i in piles:\\n    tuplex.append((curr, curr+i-1))\\n    curr = curr+i\\n\\nquer = int(input())\\nqueries = list(map(int, input().split(' ')))\\nquer2 = [[queries[x], x, -1] for x in range(len(queries))]\\nquer2.sort(key = lambda x:x[0])\\n\\nind = 0\\nfor i in range(len(quer2)):\\n    while not (tuplex[ind][0] <= quer2[i][0] <= tuplex[ind][1]):\\n        ind += 1\\n    quer2[i][2] = ind\\n\\nquer2.sort(key = lambda x:x[1])\\nfor i in quer2:\\n    print(i[2]+1)\", \"kheap=int(input())\\nheaps=list(map(int,input().split()))\\nkworms=int(input())\\nworms=list(map(int,input().split()))\\nd1={i:0 for i in range(1,sum(heaps)+1)}\\nprev=0\\ncounter=1\\nfor i in heaps:\\n    start=prev+1\\n    prev+=i\\n    for i2 in range(start,prev+1):\\n        d1[i2]=counter\\n    counter+=1\\nfor num in worms:\\n    print(d1[num])\", \"'''\\nCreated on Oct 6, 2014\\n\\n@author: Ismael\\n'''\\nn = int(input())\\nA = list(map(int,input().split()))\\nq = int(input())\\nQ = list(map(int,input().split()))\\nans = []\\nprec = 1\\niStack = 0\\nfor ai in A:\\n    iStack += 1\\n    for query in range(prec,prec+ai):\\n        ans.append(iStack)\\n    prec = ai\\nfor query in Q:\\n    print(ans[query-1])\", \"\\n#class heap:\\n\\t#def __init__(self, first, last):\\n\\t\\t#self.first = first\\n\\t\\t#self.last = last\\n\\t#def __contains__(self, x):\\n\\t\\t#if self.first <= x <= self.last:\\n\\t\\t\\t#return True\\n\\t\\t#else:\\n\\t\\t\\t#return False\\n\\t\\t\\ndef borders(nums):\\n\\tprev = 1\\n\\tfor x in nums:\\n\\t\\tyield prev, prev + x - 1\\n\\t\\tprev += x\\n\\ndef inside(x, first, last):\\n\\treturn first <= x <= last\\n\\n#nums = list(int(x) for x in '2 7 3 4 9'.split(\\\" \\\"))\\n#print(nums)\\n#print(list(borders(nums)))\\n\\n#j = list(int(x) for x in '1 25 11'.split(\\\" \\\"))\\n\\n\\n\\n\\nheapsamount = int(input())\\nnums = list(int(x) for x in input().split(\\\" \\\"))\\njamount = int(input())\\nj = list(int(x) for x in input().split(\\\" \\\"))\\n\\n#heapsamount = 5\\n#nums = list(int(x) for x in '2 7 3 4 9'.split(\\\" \\\"))\\n#jamount = 4\\n#j = [1, 25, 11, 4]\\n\\nb= list(borders(nums))\\n\\n#for hp, number in zip(hps, j):\\n\\n#hps = list(heap(*args) for args in b)\\n#for number in j:\\n\\t#for hp, hpnum in zip(hps, range(1,heapsamount+1)):\\n\\t\\t#if number in hp:\\n\\t\\t\\t#print(hpnum)\\n\\t\\t\\t\\n\\t\\t\\t\\nsor = list([x, y, None] for x, y in zip(j, list(range(jamount))))\\n\\nsor.sort(key=lambda x: x[0])\\n\\ni=0\\nj=0\\nfor number, index, n in sor:\\n\\tbord = b[i]\\n\\t\\n\\twhile not inside(number, bord[0], bord[1]):\\n\\t\\ti+=1\\n\\t\\tbord = b[i]\\n\\t\\t\\n\\t#while inside(number, bord[0], bord[1]):\\n\\tsor[j][2] = i+1\\n\\t\\t\\n\\tj+=1\\n\\t\\nsor.sort(key=lambda x:x[1])\\nfor x in sor:\\n\\tprint(x[2])\\n\\t\\t\\n\\t\\t\\n\\t\\n\\t\\n\", \"n,a = int(input()), list(map(int, input().split()))\\nm,q = int(input()), list(map(int, input().split()))\\n\\ndp = []\\nfor i in range(n):\\n    dp += [i+1]*a[i]\\nfor x in q:\\n    print (dp[x-1])\", \"__author__ = 'hamed1soleimani'\\nimport math\\ninput()\\np = input().split()\\ninput()\\nq = input().split()\\n\\n\\nworms = list(range(10 ** 6))\\n\\nm = 0\\nfor i in range(len(p)):\\n    for j in range(int(p[i])):\\n        worms[m] = i\\n        m += 1\\n\\nfor x in q:\\n    print(worms[int(x) - 1] + 1)\\n\\n\\n\", \"n=int(input())\\na=list(map(int,input().split())) \\nm=int(input()) \\nq=list(map(int,input().split()))\\n\\nb=[]\\nfor i in range(n):\\n    b+=[i+1]*a[i]\\n \\n\\nfor i in q:\\n    print(b[i-1])\\n\", \"n = int(input())\\na = list(map(int, input().split()))\\ninput()\\nqueries = list(map(int, input().split()))\\n\\nans = []\\nfor i in range(n):\\n\\tans += [i]*a[i]\\n\\nfor q in queries:\\n\\tprint(ans[q-1]+1)\\n\", \"n = int(input())\\npre = []\\nrow = 1\\nfor i in input().split(' '):\\n    for j in range(int(i)):\\n        pre.append(row)\\n    row += 1\\nm = int(input())\\ntasty_worms = []\\nfor i in input().split(' '):\\n    i = int(i)\\n    print(pre[i - 1])\\n\", \"mp = {}\\n\\t\\ndef main():\\n\\n\\ta,b =-1,0\\n\\tn = int(input())\\n\\tline = input() #Read the whole line\\n\\tx = line.split()\\n \\t\\n\\t\\t\\t\\n\\tfor i in range(n):\\n\\t\\ta = b\\n\\t\\tb = b + int(x[i])\\n\\t\\tfor k in range(a+1,b+1):\\n                        mp[k] = 1 + i\\n\\n\\tm = int(input())\\t\\n\\tline = input()\\n\\tq = line.split()\\n\\n\\tfor i in range(m):\\n\\t\\tprint(mp[int(q[i])])\\n\\nmain()\\t \\n\", \"from itertools import accumulate\\n\\ndef bs(ws, w):\\n   i, e = -1, len(ws)-1\\n   \\n   while e-i > 1:\\n      m = (e+i)//2\\n      if w <= ws[m]:\\n         e = m\\n      else:\\n         i = m\\n   return e\\n   \\ninput()\\nworms = list(accumulate(map(int, input().split())))\\ninput()\\ntofind = list(map(int, input().split()))\\n\\nprint(\\\"\\\\n\\\".join(str(bs(worms, w)+1) for w in tofind))\", \"3\\n\\nfrom bisect import bisect_left\\n\\nn = int(input())\\nA = list(map(int, input().split()))\\nm = int(input())\\nQ = list(map(int, input().split()))\\n\\nsum_A = list(A)\\nfor i in range(1, n):\\n    sum_A[i] += sum_A[i-1]\\nfor q in Q:\\n    print(bisect_left(sum_A, q) + 1)\", \"n = int(input())\\na = [0]\\nb = list(map(int,input().split()))\\nfor i in range(len(b)):\\n    for j in range(b[i]):\\n        a.append(i+1)\\nn = int(input())\\nb = list(map(int,input().split()))\\nfor i in range(len(b)):\\n    print(a[b[i]])\\n\\n    \\n\", \"# Codeforces contest 271d1 problem B\\n\\nimport bisect\\n\\nn = int(input())\\nworms = [int(x) for x in input().split(' ')]\\nfor i in range(n-1):\\n    worms[i+1] += worms[i]\\n\\nm = int(input())\\nv = [int(x) for x in input().split(' ')]\\n[(lambda x: print(bisect.bisect_left(worms, x)+1))(x) for x in v]\\n\\n\\n\", \"import math\\nimport random\\nimport itertools\\nimport collections\\nimport sys\\nimport time\\nimport fractions\\nimport os\\nimport functools\\nimport bisect\\n\\n\\ndef timer(f):\\n    def tmp(*args, **kwargs):\\n        t = time.time()\\n        res = f(*args, **kwargs)\\n        print(\\\"\\u0412\\u0440\\u0435\\u043c\\u044f \\u0432\\u044b\\u043f\\u043e\\u043b\\u043d\\u0435\\u043d\\u0438\\u044f \\u0444\\u0443\\u043d\\u043a\\u0446\\u0438\\u0438: %f\\\" % (time.time()-t))\\n        return res\\n    return tmp\\n\\ndef contains(l, elem):\\n    index = bisect.bisect_left(l, elem)\\n    if index < len(l):\\n        return l[index] == elem\\n    return False\\n\\n\\nn = int(input())\\n\\nl = list(map(int, input().split(' ')))\\nq = int(input())\\nqs = list(map(int, input().split(' ')))\\n\\n\\\"\\\"\\\"\\nn = 3\\nl = [5, 3, 4]\\nq = 12\\nqs = [i+1 for i in range(q)]\\n\\\"\\\"\\\"\\n\\\"\\\"\\\"\\nn = 5\\nl = [random.randint(0, 10) for i in range(n)]\\nq = random.randint(0, 15)\\nqs = [random.randint(0, 10) for i in range(q)]\\nl = sorted(l)\\nprint(l)\\nprint(qs)\\n\\\"\\\"\\\"\\n\\n#print(l)\\n#print(qs)\\n\\npartials = list(itertools.accumulate(l))\\n#print(partials)\\n\\nfor i in range(q):\\n    kuchka = bisect.bisect_left(partials, qs[i])\\n    print(kuchka+1)\", \"n = int(input())\\na = list(map(int, input().split()))\\nm = int(input())\\nq = list(map(int, input().split()))\\n\\nqq = sorted(q)\\nans = dict()\\n\\nlimit = 0\\ni = 0\\nfor k in qq:\\n    while not (limit < k <= limit + a[i]):\\n        limit += a[i]\\n        i += 1\\n    ans[k] = i + 1\\n\\nfor k in q:\\n    print(ans[k])\\n\", \"from bisect import bisect_left\\nn=int(input())\\nS=A=list(map(int,input().split()))\\nfor i in range(1,n): \\n  S[i] += S[i-1]\\nm=int(input())\\nfor q in list(map(int,input().split())):\\n  print(bisect_left(S, q)+1)\", \"from sys import stdin\\n\\ndef main():\\n    '''\\n    Name: Kevin S. Sanchez\\n    Code: B. Worms\\n    '''\\n    inp = stdin\\n    n = int(inp.readline())\\n    worms = list(map(int, inp.readline().split()))\\n    J = int(inp.readline())\\n    Jworms = list(map(int, inp.readline().split()))\\n\\n    lunch = list()\\n    \\n    for i in range (0,len(worms)):\\n        lunch += [i+1] * worms[i]\\n\\n    for i in Jworms:\\n        print(lunch[i-1])\\n\\nmain()\\n\", \"from bisect import *\\nn = int(input())\\na = list(map(int, input().split()))\\nfor i in range(n - 1): a[i + 1] += a[i]\\ninput()\\nfor i in map(int, input().split()): print(bisect_left(a, i) + 1)\", \"from sys import stdin\\nfrom bisect import bisect_left\\n\\nstdin.readline()\\nx, l = 0, []\\nfor y in map(int, stdin.readline().split()):\\n    x += y\\n    l.append(x)\\nstdin.readline()\\n\\nfor y in map(int, stdin.readline().split()):\\n    print(bisect_left(l, y) + 1)\\n\", \"from sys import stdin\\nfrom bisect import bisect_left\\n\\n\\ndef main():\\n    stdin.readline()\\n    x, a = 0, []\\n    for y in map(int, stdin.readline().split()):\\n        x += y\\n        a.append(x)\\n\\n    stdin.readline()\\n    for x in map(int, stdin.readline().split()):\\n        print(bisect_left(a, x) + 1)\\n\\n\\nmain()\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"5\\n2 7 3 4 9\\n3\\n1 25 11\\n\"\n  ],\n  \"outputs\": [\n    \"1\\n5\\n3\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/474/B", "starter_code": ""}
{"id": 37, "question": "Yeah, we failed to make up a New Year legend for this problem.\n\nA permutation of length $n$ is an array of $n$ integers such that every integer from $1$ to $n$ appears in it exactly once. \n\nAn element $y$ of permutation $p$ is reachable from element $x$ if $x = y$, or $p_x = y$, or $p_{p_x} = y$, and so on. \n\nThe decomposition of a permutation $p$ is defined as follows: firstly, we have a permutation $p$, all elements of which are not marked, and an empty list $l$. Then we do the following: while there is at least one not marked element in $p$, we find the leftmost such element, list all elements that are reachable from it in the order they appear in $p$, mark all of these elements, then cyclically shift the list of those elements so that the maximum appears at the first position, and add this list as an element of $l$. After all elements are marked, $l$ is the result of this decomposition.\n\nFor example, if we want to build a decomposition of $p = [5, 4, 2, 3, 1, 7, 8, 6]$, we do the following:  initially $p = [5, 4, 2, 3, 1, 7, 8, 6]$ (bold elements are marked), $l = []$;  the leftmost unmarked element is $5$; $5$ and $1$ are reachable from it, so the list we want to shift is $[5, 1]$; there is no need to shift it, since maximum is already the first element;  $p = [\\textbf{5}, 4, 2, 3, \\textbf{1}, 7, 8, 6]$, $l = [[5, 1]]$;  the leftmost unmarked element is $4$, the list of reachable elements is $[4, 2, 3]$; the maximum is already the first element, so there's no need to shift it;  $p = [\\textbf{5}, \\textbf{4}, \\textbf{2}, \\textbf{3}, \\textbf{1}, 7, 8, 6]$, $l = [[5, 1], [4, 2, 3]]$;  the leftmost unmarked element is $7$, the list of reachable elements is $[7, 8, 6]$; we have to shift it, so it becomes $[8, 6, 7]$;  $p = [\\textbf{5}, \\textbf{4}, \\textbf{2}, \\textbf{3}, \\textbf{1}, \\textbf{7}, \\textbf{8}, \\textbf{6}]$, $l = [[5, 1], [4, 2, 3], [8, 6, 7]]$;  all elements are marked, so $[[5, 1], [4, 2, 3], [8, 6, 7]]$ is the result. \n\nThe New Year transformation of a permutation is defined as follows: we build the decomposition of this permutation; then we sort all lists in decomposition in ascending order of the first elements (we don't swap the elements in these lists, only the lists themselves); then we concatenate the lists into one list which becomes a new permutation. For example, the New Year transformation of $p = [5, 4, 2, 3, 1, 7, 8, 6]$ is built as follows:  the decomposition is $[[5, 1], [4, 2, 3], [8, 6, 7]]$;  after sorting the decomposition, it becomes $[[4, 2, 3], [5, 1], [8, 6, 7]]$;  $[4, 2, 3, 5, 1, 8, 6, 7]$ is the result of the transformation. \n\nWe call a permutation good if the result of its transformation is the same as the permutation itself. For example, $[4, 3, 1, 2, 8, 5, 6, 7]$ is a good permutation; and $[5, 4, 2, 3, 1, 7, 8, 6]$ is bad, since the result of transformation is $[4, 2, 3, 5, 1, 8, 6, 7]$.\n\nYour task is the following: given $n$ and $k$, find the $k$-th (lexicographically) good permutation of length $n$.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nThen the test cases follow. Each test case is represented by one line containing two integers $n$ and $k$ ($1 \\le n \\le 50$, $1 \\le k \\le 10^{18}$).\n\n\n-----Output-----\n\nFor each test case, print the answer to it as follows: if the number of good permutations of length $n$ is less than $k$, print one integer $-1$; otherwise, print the $k$-th good permutation on $n$ elements (in lexicographical order).\n\n\n-----Example-----\nInput\n5\n3 3\n5 15\n4 13\n6 8\n4 2\n\nOutput\n2 1 3 \n3 1 2 5 4 \n-1\n1 2 6 3 4 5 \n1 2 4 3", "solutions": "[\"3\\n\\nfrom math import factorial as fact\\n\\nN = 55\\nc = [1]\\nfor i in range(N):\\n\\tc.append(fact(i))\\ndp = [0] * N\\ndp[0] = 1\\nfor i in range(1, N):\\n\\tfor j in range(i):\\n\\t\\tdp[i] += dp[j] * c[i - j - 1]\\n\\ndef get_kth_cycle(n, k):\\n\\tif n == 1:\\n\\t\\treturn [1]\\n\\tans = [-1] * n\\n\\tans[0] = n - 1\\n\\tfin = [i for i in range(n)]\\n\\tfin[0] = n - 1\\n\\tinit = [i for i in range(n)]\\n\\tinit[n - 1] = 0\\n\\tused = [False] * n\\n\\tused[n - 1] = True\\n\\tfor i in range(1, n - 1):\\n\\t\\tj = 0\\n\\t\\tcur = fact(n - i - 2)\\n\\t\\twhile True:\\n\\t\\t\\twhile used[j] or (i < n - 1 and j == init[i]):\\n\\t\\t\\t\\tj += 1\\n\\t\\t\\tif k > cur:\\n\\t\\t\\t\\tk -= cur\\n\\t\\t\\t\\tj += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tfin[init[i]] = fin[j]\\n\\t\\t\\t\\tinit[fin[j]] = init[i]\\n\\t\\t\\t\\tans[i] = j\\n\\t\\t\\t\\tused[j] = True\\n\\t\\t\\t\\tbreak\\n\\tans[-1] = init[-1]\\n\\treturn [x + 1 for x in ans]\\n\\ndef f(n, k):\\n\\tif n == 0:\\n\\t\\tassert k == 1\\n\\t\\treturn []\\n\\tcl = 1\\n\\twhile c[cl - 1] * dp[n - cl] < k:\\n\\t\\tk -= c[cl - 1] * dp[n - cl]\\n\\t\\tcl += 1\\n\\trest = f(n - cl, (k - 1) % dp[n - cl] + 1)\\n\\trest = [x + cl for x in rest]\\n\\tk = (k - 1) // dp[n - cl] + 1\\n\\treturn get_kth_cycle(cl, k) + rest\\n\\ndef solve():\\n\\tn, k = list(map(int, input().split()))\\n\\tif k > dp[n]:\\n\\t\\tprint(-1)\\n\\t\\treturn\\n\\tprint(*f(n, k))\\n\\ndef main():\\n\\tt = int(input())\\n\\twhile t > 0:\\n\\t\\tt -= 1\\n\\t\\tsolve()\\n\\nmain()\\n\", \"3\\n \\nfrom math import factorial as fact\\n \\nN = 55\\nc = [1]\\nfor i in range(N):\\n\\tc.append(fact(i))\\ndp = [0] * N\\ndp[0] = 1\\nfor i in range(1, N):\\n\\tfor j in range(i):\\n\\t\\tdp[i] += dp[j] * c[i - j - 1]\\n \\ndef get_kth_cycle(n, k):\\n\\tif n == 1:\\n\\t\\treturn [1]\\n\\tans = [-1] * n\\n\\tans[0] = n - 1\\n\\tfin = [i for i in range(n)]\\n\\tfin[0] = n - 1\\n\\tinit = [i for i in range(n)]\\n\\tinit[n - 1] = 0\\n\\tused = [False] * n\\n\\tused[n - 1] = True\\n\\tfor i in range(1, n - 1):\\n\\t\\tj = 0\\n\\t\\tcur = fact(n - i - 2)\\n\\t\\twhile True:\\n\\t\\t\\twhile used[j] or (i < n - 1 and j == init[i]):\\n\\t\\t\\t\\tj += 1\\n\\t\\t\\tif k > cur:\\n\\t\\t\\t\\tk -= cur\\n\\t\\t\\t\\tj += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tfin[init[i]] = fin[j]\\n\\t\\t\\t\\tinit[fin[j]] = init[i]\\n\\t\\t\\t\\tans[i] = j\\n\\t\\t\\t\\tused[j] = True\\n\\t\\t\\t\\tbreak\\n\\tans[-1] = init[-1]\\n\\treturn [x + 1 for x in ans]\\n \\ndef f(n, k):\\n\\tif n == 0:\\n\\t\\tassert k == 1\\n\\t\\treturn []\\n\\tcl = 1\\n\\twhile c[cl - 1] * dp[n - cl] < k:\\n\\t\\tk -= c[cl - 1] * dp[n - cl]\\n\\t\\tcl += 1\\n\\trest = f(n - cl, (k - 1) % dp[n - cl] + 1)\\n\\trest = [x + cl for x in rest]\\n\\tk = (k - 1) // dp[n - cl] + 1\\n\\treturn get_kth_cycle(cl, k) + rest\\n \\ndef solve():\\n\\tn, k = map(int, input().split())\\n\\tif k > dp[n]:\\n\\t\\tprint(-1)\\n\\t\\treturn\\n\\tprint(*f(n, k))\\n \\ndef main():\\n\\tt = int(input())\\n\\twhile t > 0:\\n\\t\\tt -= 1\\n\\t\\tsolve()\\n \\nmain()\", \"from math import factorial as fact\\n \\nN = 55\\nc = [1]\\nfor i in range(N):\\n\\tc.append(fact(i))\\ndp = [0] * N\\ndp[0] = 1\\nfor i in range(1, N):\\n\\tfor j in range(i):\\n\\t\\tdp[i] += dp[j] * c[i - j - 1]\\n \\ndef get_kth_cycle(n, k):\\n\\tif n == 1:\\n\\t\\treturn [1]\\n\\tans = [-1] * n\\n\\tans[0] = n - 1\\n\\tfin = [i for i in range(n)]\\n\\tfin[0] = n - 1\\n\\tinit = [i for i in range(n)]\\n\\tinit[n - 1] = 0\\n\\tused = [False] * n\\n\\tused[n - 1] = True\\n\\tfor i in range(1, n - 1):\\n\\t\\tj = 0\\n\\t\\tcur = fact(n - i - 2)\\n\\t\\twhile True:\\n\\t\\t\\twhile used[j] or (i < n - 1 and j == init[i]):\\n\\t\\t\\t\\tj += 1\\n\\t\\t\\tif k > cur:\\n\\t\\t\\t\\tk -= cur\\n\\t\\t\\t\\tj += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tfin[init[i]] = fin[j]\\n\\t\\t\\t\\tinit[fin[j]] = init[i]\\n\\t\\t\\t\\tans[i] = j\\n\\t\\t\\t\\tused[j] = True\\n\\t\\t\\t\\tbreak\\n\\tans[-1] = init[-1]\\n\\treturn [x + 1 for x in ans]\\n \\ndef f(n, k):\\n\\tif n == 0:\\n\\t\\tassert k == 1\\n\\t\\treturn []\\n\\tcl = 1\\n\\twhile c[cl - 1] * dp[n - cl] < k:\\n\\t\\tk -= c[cl - 1] * dp[n - cl]\\n\\t\\tcl += 1\\n\\trest = f(n - cl, (k - 1) % dp[n - cl] + 1)\\n\\trest = [x + cl for x in rest]\\n\\tk = (k - 1) // dp[n - cl] + 1\\n\\treturn get_kth_cycle(cl, k) + rest\\n \\ndef solve():\\n\\tn, k = map(int, input().split())\\n\\tif k > dp[n]:\\n\\t\\tprint(-1)\\n\\t\\treturn\\n\\tprint(*f(n, k))\\n \\ndef main():\\n\\tt = int(input())\\n\\twhile t > 0:\\n\\t\\tt -= 1\\n\\t\\tsolve()\\n \\nmain()\", \"import math\\n\\n# init\\nmaxn = 55\\ng = [1]\\nfor i in range(maxn):\\n    g.append(math.factorial(i))\\nf = [0] * maxn\\nf[0] = 1\\nfor i in range(1, maxn):\\n    for j in range(i):\\n        f[i] += f[j] * g[i - j - 1]\\n\\ndef kth(n, k):\\n    if n == 1:\\n        return [1]\\n    ret = [-1] * n\\n    ret[0] = n - 1\\n    p1 = [i for i in range(n)]\\n    p2 = [i for i in range(n)]\\n    vis = [False] * n\\n    p1[0] = n - 1\\n    p2[n - 1] = 0\\n    vis[n - 1] = True\\n    for i in range(1, n - 1):\\n        j = 0\\n        now = math.factorial(n - i - 2)\\n        while True:\\n            while vis[j] or (i < n - 1 and j == p2[i]):\\n                j += 1\\n            if k > now:\\n                k -= now\\n                j += 1\\n            else:\\n                p1[p2[i]] = p1[j]\\n                p2[p1[j]] = p2[i]\\n                ret[i] = j\\n                vis[j] = True\\n                break\\n    ret[-1] = p2[-1]\\n    return [x + 1 for x in ret]\\n\\ndef solve(n, k):\\n    if n == 0:\\n        return []\\n    i = 1\\n    while g[i - 1] * f[n - i] < k:\\n        k -= g[i - 1] * f[n - i]\\n        i += 1\\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\\n    rem = [x + i for x in rem]\\n    k = (k - 1) // f[n - i] + 1\\n    return kth(i, k) + rem\\n\\ndef SOLVE():\\n    n, k = map(int, input().split())\\n    if k > f[n]:\\n        print(-1)\\n        return\\n    ans = solve(n, k)\\n    for x in ans:\\n        print(x, end = \\\" \\\")\\n    print()\\n\\nT = int(input())\\nwhile T > 0:\\n    T -= 1\\n    SOLVE()\\n\\n\", \"from math import factorial as fact\\n \\nN = 55\\nc = [1]\\nfor i in range(N):\\n\\tc.append(fact(i))\\ndp = [0] * N\\ndp[0] = 1\\nfor i in range(1, N):\\n\\tfor j in range(i):\\n\\t\\tdp[i] += dp[j] * c[i - j - 1]\\n \\ndef get_kth_cycle(n, k):\\n\\tif n == 1:\\n\\t\\treturn [1]\\n\\tans = [-1] * n\\n\\tans[0] = n - 1\\n\\tfin = [i for i in range(n)]\\n\\tfin[0] = n - 1\\n\\tinit = [i for i in range(n)]\\n\\tinit[n - 1] = 0\\n\\tused = [False] * n\\n\\tused[n - 1] = True\\n\\tfor i in range(1, n - 1):\\n\\t\\tj = 0\\n\\t\\tcur = fact(n - i - 2)\\n\\t\\twhile True:\\n\\t\\t\\twhile used[j] or (i < n - 1 and j == init[i]):\\n\\t\\t\\t\\tj += 1\\n\\t\\t\\tif k > cur:\\n\\t\\t\\t\\tk -= cur\\n\\t\\t\\t\\tj += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tfin[init[i]] = fin[j]\\n\\t\\t\\t\\tinit[fin[j]] = init[i]\\n\\t\\t\\t\\tans[i] = j\\n\\t\\t\\t\\tused[j] = True\\n\\t\\t\\t\\tbreak\\n\\tans[-1] = init[-1]\\n\\treturn [x + 1 for x in ans]\\n \\ndef f(n, k):\\n\\tif n == 0:\\n\\t\\tassert k == 1\\n\\t\\treturn []\\n\\tcl = 1\\n\\twhile c[cl - 1] * dp[n - cl] < k:\\n\\t\\tk -= c[cl - 1] * dp[n - cl]\\n\\t\\tcl += 1\\n\\trest = f(n - cl, (k - 1) % dp[n - cl] + 1)\\n\\trest = [x + cl for x in rest]\\n\\tk = (k - 1) // dp[n - cl] + 1\\n\\treturn get_kth_cycle(cl, k) + rest\\n \\ndef solve():\\n\\tn, k = map(int, input().split())\\n\\tif k > dp[n]:\\n\\t\\tprint(-1)\\n\\t\\treturn\\n\\tprint(*f(n, k))\\n \\ndef main():\\n\\tt = int(input())\\n\\twhile t > 0:\\n\\t\\tt -= 1\\n\\t\\tsolve()\\n \\nmain()\", \"MAXN = 55\\n\\nf = [0] * MAXN\\nfac = [0] * MAXN\\n\\nfac[0] = 1\\nfor i in range(1, 51):\\n  fac[i] = fac[i - 1] * i\\n\\nf[0] = 1;\\nfor i in range(1, 51):\\n  f[i] += f[i - 1]\\n  for j in range(2, i + 1):\\n    f[i] += fac[j - 2] * f[i - j]\\n\\ndef my_fac(n):\\n  if n <= 0:\\n    return 1\\n  return fac[n]\\n\\ndef solve_first(n, k):\\n  ret = [0] * (n + 1)\\n  ret[1] = n\\n  for p in range(2, n + 1):\\n    for i in range(1, n + 1):\\n      if i in ret or i == p:\\n        continue\\n      ret[p] = i\\n\\n      cur = p\\n      good = True\\n      for fuck in range(0, n - 1):\\n        cur = ret[cur]\\n        if cur == 0:\\n          good = True\\n          break\\n        if cur == p:\\n          good = False\\n          break\\n      \\n      if not good:\\n        ret[p] = 0\\n        continue\\n\\n      k1 = my_fac(n - p - 1)\\n      if k > k1:\\n        k -= k1\\n      else:\\n        break\\n      ret[p] = 0\\n  ret.pop(0)\\n  assert len(ret) == n\\n  return ret;\\n\\ndef solve(n, k):\\n  if k == 1:\\n    ret = []\\n    for i in range(1, n + 1):\\n      ret.append(i)\\n    return ret\\n\\n  tot = 0\\n  first = -1\\n  for i in range(1, n + 1):\\n    if tot + my_fac(i - 2) * f[n - i] >= k:\\n      first = i\\n      break;\\n    tot += my_fac(i - 2) * f[n - i]\\n\\n  k -= tot\\n  cnt1 = my_fac(first - 1)\\n  cnt2 = f[n - first]\\n  \\n  x = k // cnt2 + 1\\n  y = k % cnt2\\n\\n  if y == 0:\\n    y = cnt2\\n    x -= 1\\n\\n  ret = solve_first(first, x)\\n\\n  for v in solve(n - first, y):\\n    ret.append(v + first)\\n\\n  return ret\\n\\nT = int(input())\\n\\nfor t in range(0, T):\\n  s = input().split()\\n  n = int(s[0])\\n  k = int(s[1])\\n  if (k > f[n]):\\n    print(\\\"-1\\\")\\n  else:\\n    ans = solve(n, k)\\n    for x in ans:\\n      print(x, end=\\\" \\\")\\n    print(\\\"\\\")\", \"import math\\n\\n# init\\nmaxn = 55\\ng = [1]\\nfor i in range(maxn):\\n    g.append(math.factorial(i))\\nf = [0] * maxn\\nf[0] = 1\\nfor i in range(1, maxn):\\n    for j in range(i):\\n        f[i] += f[j] * g[i - j - 1]\\n\\ndef kth(n, k):\\n    if n == 1:\\n        return [1]\\n    ret = [-1] * n\\n    ret[0] = n - 1\\n    p1 = [i for i in range(n)]\\n    p2 = [i for i in range(n)]\\n    vis = [False] * n\\n    p1[0] = n - 1\\n    p2[n - 1] = 0\\n    vis[n - 1] = True\\n    for i in range(1, n - 1):\\n        j = 0\\n        now = math.factorial(n - i - 2)\\n        while True:\\n            while vis[j] or (i < n - 1 and j == p2[i]):\\n                j += 1\\n            if k > now:\\n                k -= now\\n                j += 1\\n            else:\\n                p1[p2[i]] = p1[j]\\n                p2[p1[j]] = p2[i]\\n                ret[i] = j\\n                vis[j] = True\\n                break\\n    ret[-1] = p2[-1]\\n    return [x + 1 for x in ret]\\n\\ndef solve(n, k):\\n    if n == 0:\\n        return []\\n    i = 1\\n    while g[i - 1] * f[n - i] < k:\\n        k -= g[i - 1] * f[n - i]\\n        i += 1\\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\\n    rem = [x + i for x in rem]\\n    k = (k - 1) // f[n - i] + 1\\n    return kth(i, k) + rem\\n\\ndef SOLVE():\\n    n, k = map(int, input().split())\\n    if k > f[n]:\\n        print(-1)\\n        return\\n    ans = solve(n, k)\\n    for x in ans:\\n        print(x, end = \\\" \\\")\\n    print()\\n\\nT = int(input())\\nwhile T > 0:\\n    T -= 1\\n    SOLVE()\\n\\n\", \"import math\\n\\n# init\\nmaxn = 55\\ng = [1]\\nfor i in range(maxn):\\n    g.append(math.factorial(i))\\nf = [0] * maxn\\nf[0] = 1\\nfor i in range(1, maxn):\\n    for j in range(i):\\n        f[i] += f[j] * g[i - j - 1]\\n\\ndef kth(n, k):\\n    if n == 1:\\n        return [1]\\n    ret = [-1] * n\\n    ret[0] = n - 1\\n    p1 = [i for i in range(n)]\\n    p2 = [i for i in range(n)]\\n    vis = [False] * n\\n    p1[0] = n - 1\\n    p2[n - 1] = 0\\n    vis[n - 1] = True\\n    for i in range(1, n - 1):\\n        j = 0\\n        now = math.factorial(n - i - 2)\\n        while True:\\n            while vis[j] or (i < n - 1 and j == p2[i]):\\n                j += 1\\n            if k > now:\\n                k -= now\\n                j += 1\\n            else:\\n                p1[p2[i]] = p1[j]\\n                p2[p1[j]] = p2[i]\\n                ret[i] = j\\n                vis[j] = True\\n                break\\n    ret[-1] = p2[-1]\\n    return [x + 1 for x in ret]\\n\\ndef solve(n, k):\\n    if n == 0:\\n        return []\\n    i = 1\\n    while g[i - 1] * f[n - i] < k:\\n        k -= g[i - 1] * f[n - i]\\n        i += 1\\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\\n    rem = [x + i for x in rem]\\n    k = (k - 1) // f[n - i] + 1\\n    return kth(i, k) + rem\\n\\ndef SOLVE():\\n    n, k = map(int, input().split())\\n    if k > f[n]:\\n        print(-1)\\n        return\\n    ans = solve(n, k)\\n    for x in ans:\\n        print(x, end = \\\" \\\")\\n    print()\\n\\nT = int(input())\\nwhile T > 0:\\n    T -= 1\\n    SOLVE()\\n#\\n#\", \"import math\\n\\n# init\\nmaxn = 55\\ng = [1]\\nfor i in range(maxn):\\n    g.append(math.factorial(i))\\nf = [0] * maxn\\nf[0] = 1\\nfor i in range(1, maxn):\\n    for j in range(i):\\n        f[i] += f[j] * g[i - j - 1]\\n\\ndef kth(n, k):\\n    if n == 1:\\n        return [1]\\n    ret = [-1]* n\\n    ret[0] = n - 1\\n    p1 = [i for i in range(n)]\\n    p2 = [i for i in range(n)]\\n    vis = [False] * n\\n    p1[0] = n - 1\\n    p2[n - 1] = 0\\n    vis[n - 1] = True\\n    for i in range(1, n - 1):\\n        j = 0\\n        now = math.factorial(n - i - 2)\\n        while True:\\n            while vis[j] or (i < n - 1 and j == p2[i]):\\n                j += 1\\n            if k > now:\\n                k -= now\\n                j += 1\\n            else:\\n                p1[p2[i]] = p1[j]\\n                p2[p1[j]] = p2[i]\\n                ret[i] = j\\n                vis[j] = True\\n                break\\n    ret[-1] = p2[-1]\\n    return [x + 1 for x in ret]\\n\\ndef solve(n, k):\\n    if n == 0:\\n        return []\\n    i = 1\\n    while g[i - 1] * f[n - i] < k:\\n        k -= g[i - 1] * f[n - i]\\n        i += 1\\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\\n    rem = [x + i for x in rem]\\n    k = (k - 1) // f[n - i] + 1\\n    return kth(i, k) + rem\\n\\ndef SOLVE():\\n    n, k = map(int, input().split())\\n    if k > f[n]:\\n        print(-1)\\n        return\\n    ans = solve(n, k)\\n    for x in ans:\\n        print(x, end = \\\" \\\")\\n    print()\\n\\nT = int(input())\\nwhile T > 0:\\n    T -= 1\\n    SOLVE()\\n\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"5\\n3 3\\n5 15\\n4 13\\n6 8\\n4 2\\n\"\n  ],\n  \"outputs\": [\n    \"2 1 3 \\n3 1 2 5 4 \\n-1\\n1 2 6 3 4 5 \\n1 2 4 3 \\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1279/E", "starter_code": ""}
{"id": 38, "question": "Two players decided to play one interesting card game.\n\nThere is a deck of $n$ cards, with values from $1$ to $n$. The values of cards are pairwise different (this means that no two different cards have equal values). At the beginning of the game, the deck is completely distributed between players such that each player has at least one card. \n\nThe game goes as follows: on each turn, each player chooses one of their cards (whichever they want) and puts on the table, so that the other player doesn't see which card they chose. After that, both cards are revealed, and the player, value of whose card was larger, takes both cards in his hand. Note that as all cards have different values, one of the cards will be strictly larger than the other one. Every card may be played any amount of times. The player loses if he doesn't have any cards.\n\nFor example, suppose that $n = 5$, the first player has cards with values $2$ and $3$, and the second player has cards with values $1$, $4$, $5$. Then one possible flow of the game is:\n\nThe first player chooses the card $3$. The second player chooses the card $1$. As $3>1$, the first player gets both cards. Now the first player has cards $1$, $2$, $3$, the second player has cards $4$, $5$.\n\nThe first player chooses the card $3$. The second player chooses the card $4$. As $3<4$, the second player gets both cards. Now the first player has cards $1$, $2$. The second player has cards $3$, $4$, $5$.\n\nThe first player chooses the card $1$. The second player chooses the card $3$. As $1<3$, the second player gets both cards. Now the first player has only the card $2$. The second player has cards $1$, $3$, $4$, $5$.\n\nThe first player chooses the card $2$. The second player chooses the card $4$. As $2<4$, the second player gets both cards. Now the first player is out of cards and loses. Therefore, the second player wins.\n\nWho will win if both players are playing optimally? It can be shown that one of the players has a winning strategy.\n\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $k_1$, $k_2$ ($2 \\le n \\le 100, 1 \\le k_1 \\le n - 1, 1 \\le k_2 \\le n - 1, k_1 + k_2 = n$)\u00a0\u2014 the number of cards, number of cards owned by the first player and second player correspondingly.\n\nThe second line of each test case contains $k_1$ integers $a_1, \\dots, a_{k_1}$ ($1 \\le a_i \\le n$)\u00a0\u2014 the values of cards of the first player.\n\nThe third line of each test case contains $k_2$ integers $b_1, \\dots, b_{k_2}$ ($1 \\le b_i \\le n$)\u00a0\u2014 the values of cards of the second player.\n\nIt is guaranteed that the values of all cards are different.\n\n\n-----Output-----\n\nFor each test case, output \"YES\" in a separate line, if the first player wins. Otherwise, output \"NO\" in a separate line. You can print each letter in any case (upper or lower).\n\n\n-----Example-----\nInput\n2\n2 1 1\n2\n1\n5 2 3\n2 3\n1 4 5\n\nOutput\nYES\nNO\n\n\n\n-----Note-----\n\nIn the first test case of the example, there is only one possible move for every player: the first player will put $2$, the second player will put $1$. $2>1$, so the first player will get both cards and will win.\n\nIn the second test case of the example, it can be shown that it is the second player who has a winning strategy. One possible flow of the game is illustrated in the statement.", "solutions": "[\"q = int(input())\\nfor z in range(q):\\n    n, k1, k2 = map(int, input().split())\\n    arr1 = list(map(int, input().split()))\\n    arr2 = list(map(int, input().split()))\\n    if max(arr1) > max(arr2):\\n        print('YES')\\n    else:\\n        print('NO')\", \"t = int(input())\\n\\nfor _ in range(t):\\n    n, k1, k2 = list(map(int, input().strip().split()))\\n    prvi = list(map(int, input().strip().split()))\\n    drugi = list(map(int, input().strip().split()))\\n\\n    if max(prvi) > max(drugi):\\n        print('YES')\\n    else:\\n        print('NO')\", \"for i in range(int(input())):\\n    n, k1, k2 = map(int,input().split())\\n    l1 = list(map(int,input().split()))\\n    a = max(l1)\\n    l2 = list(map(int,input().split()))\\n    b = max(l2)\\n    if a > b:\\n        print(\\\"YES\\\")\\n    else :\\n        print(\\\"NO\\\")\", \"a = int(input())\\nfor i in range(a):\\n    n, k1, k2 = list(map(int, input().split()))\\n    k11 = list(map(int, input().split()))\\n    k22 = list(map(int, input().split()))\\n    if max(k11) > max(k22):\\n        print('YES')\\n    else:\\n        print('NO')\\n\", \"from math import *\\nimport os, sys\\nfrom bisect import *\\nfrom io import BytesIO\\n\\n#input = BytesIO(os.read(0, os.fstat(0).st_size)).readline\\nsys.setrecursionlimit(10 ** 9)\\n#sys.stdin = open(\\\"moobuzz.in\\\", 'r')\\n#sys.stdout = open(\\\"moobuzz.out\\\", 'w')\\n\\nfor _ in range(int(input())):\\n\\tn, k1, k2 = list(map(int, input().split()))\\n\\ta = list(map(int, input().split()))\\n\\tb = list(map(int, input().split()))\\n\\tif max(a) > max(b):\\n\\t\\tprint(\\\"YES\\\")\\n\\telse:\\n\\t\\tprint(\\\"NO\\\")\\n\", \"t = int(input())\\nfor rwuer in range(t):\\n\\tn,k1,k2 = map(int,input().split())\\n\\tl1 = list(map(int,input().split()))\\n\\tl2 = list(map(int,input().split()))\\n\\ta1 = max(l1)\\n\\ta2 = max(l2)\\n\\tif a1>a2:\\n\\t\\tprint(\\\"YES\\\")\\n\\telse:\\n\\t\\tprint(\\\"NO\\\")\", \"def solve():\\n    n, k1, k2 = list(map(int, input().split()))\\n    m1 = max(list(map(int, input().split())))\\n    m2 = max(list(map(int, input().split())))\\n    if m1 > m2:\\n        print('YES')\\n    else:\\n        print('NO')\\n\\n\\ndef main():\\n    t = int(input())\\n    # t = 1\\n    for _ in range(t):\\n        solve()\\n\\n\\nmain()\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n, k1, k2 = list(map(int, input().split()))\\n    a = list(map(int, input().split()))\\n    b = list(map(int, input().split()))\\n\\n    if max(a) > max(b):\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"t=int(input())\\nfor _ in range(t):\\n    n,k1,k2=list(map(int,input().split()))\\n    a1=sorted(list(map(int,input().split())))\\n    a2=sorted(list(map(int,input().split())))\\n    if(n in a1):\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"for tc in range(int(input())):\\n    input()\\n    lsa = list(map(int, input().split()))\\n    lsb = list(map(int, input().split()))\\n    print('YES' if max(max(lsa),max(lsb)) in lsa else 'NO')\\n\", \"t = int(input())\\nfor i in range(t):\\n    n, k1, k2 = list(map(int, input().split()))\\n    a = max(list(map(int, input().split())))\\n    b = max(list(map(int, input().split())))\\n    if a > b:\\n        print('YES')\\n    else:\\n        print('NO')\\n\", \"q = int(input())\\nwhile q:\\n    n, k1, k2 = list(map(int, input().split()))\\n    a = list(map(int, input().split()))\\n    b = list(map(int, input().split()))\\n    if max(a) > max(b):\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n    q -= 1\\n\", \"t = int(input())\\n\\nfor test in range(t):\\n    input()\\n    max1 = max(list(map(int,input().split())))\\n    max2 = max(list(map(int,input().split())))\\n    if max1 > max2:\\n        print('YES')\\n    else:\\n        print('NO')\\n\", \"import sys\\nimport math\\nfrom collections import defaultdict\\nfrom collections import deque\\nfrom itertools import combinations\\nfrom itertools import permutations\\ninput = lambda : sys.stdin.readline().rstrip()\\nread = lambda : list(map(int, input().split()))\\ngo = lambda : 1/0\\ndef write(*args, sep=\\\"\\\\n\\\"):\\n  for i in args:\\n    sys.stdout.write(\\\"{}{}\\\".format(i, sep))\\nINF = float('inf')\\nMOD = int(1e9 + 7)\\nYES = \\\"YES\\\"\\nNO = \\\"NO\\\"\\n\\nfor _ in range(int(input())):\\n  n, x, y = read()\\n  X = read()\\n  Y = read()\\n\\n  if n in X:\\n    print(YES)\\n  else:\\n    print(NO)\\n\", \"for case in range(int(input())):\\n    input()\\n    a=max(list(map(int,input().split())))\\n    b=max(list(map(int,input().split())))\\n    print('YES' if a>b else 'NO')\", \"t=int(input())\\nfor q in range(t):\\n    n,k1,k2=map(int,input().split())\\n    a1=max(list(map(int,input().split())))\\n    a2=max(list(map(int,input().split())))\\n    if a1>a2:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"for _ in range(int(input())):\\n    n,k1A,k2A = list(map(int,input().split()))\\n    k1 = list(map(int,input().split()))\\n    k2 = list(map(int,input().split()))\\n    print(\\\"YES\\\" if max(k1) > max(k2) else \\\"NO\\\")\", \"from bisect import bisect_left as bl\\nfrom bisect import bisect_right as br\\nimport heapq\\nimport math\\nfrom collections import *\\nfrom functools import reduce,cmp_to_key\\nimport sys\\ninput = sys.stdin.readline\\n \\n# M = mod = 998244353\\ndef factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))\\ndef inv_mod(n):return pow(n, mod - 2, mod)\\n \\ndef li():return [int(i) for i in input().rstrip('\\\\n').split(' ')]\\ndef st():return input().rstrip('\\\\n')\\ndef val():return int(input().rstrip('\\\\n'))\\ndef li2():return [i for i in input().rstrip('\\\\n').split(' ')]\\ndef li3():return [int(i) for i in input().rstrip('\\\\n')]\\n \\n\\nfor _ in range(val()):\\n    n,k1,k2 = li()\\n    a = sorted(li())\\n    b = sorted(li())\\n    print('YES' if a[-1]>b[-1] else 'NO')\\n\", \"import sys\\nimport math\\nimport itertools\\nimport functools\\nimport collections\\nimport random\\n\\n\\ndef ii(): return int(input())\\ndef mi(): return list(map(int, input().split()))\\ndef li(): return list(map(int, input().split()))\\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\\ndef wr(arr): return ' '.join(map(str, arr))\\ndef revn(n): return str(n)[::-1]\\ndef dd(): return collections.defaultdict(int)\\ndef ddl(): return collections.defaultdict(list)\\ndef sieve(n):\\n    if n < 2: return list()\\n    prime = [True for _ in range(n + 1)]\\n    p = 3\\n    while p * p <= n:\\n        if prime[p]:\\n            for i in range(p * 2, n + 1, p):\\n                prime[i] = False\\n        p += 2\\n    r = [2]\\n    for p in range(3, n + 1, 2):\\n        if prime[p]:\\n            r.append(p)\\n    return r\\ndef divs(n, start=1):\\n    r = []\\n    for i in range(start, int(math.sqrt(n) + 1)):\\n        if (n % i == 0):\\n            if (n / i == i):\\n                r.append(i)\\n            else:\\n                r.extend([i, n // i])\\n    return r\\ndef divn(n, primes):\\n    divs_number = 1\\n    for i in primes:\\n        if n == 1:\\n            return divs_number\\n        t = 1\\n        while n % i == 0:\\n            t += 1\\n            n //= i\\n        divs_number *= t\\ndef prime(n):\\n    if n == 2: return True\\n    if n % 2 == 0 or n <= 1: return False\\n    sqr = int(math.sqrt(n)) + 1\\n    for d in range(3, sqr, 2):\\n        if n % d == 0: return False\\n    return True\\ndef convn(number, base):\\n    newnumber = 0\\n    while number > 0:\\n        newnumber += number % base\\n        number //= base\\n    return newnumber\\ndef cdiv(n, k): return n // k + (n % k != 0)\\n\\n\\nt = ii()\\nfor _ in range(t):\\n    n, k1, k2 = mi()\\n    a = li()\\n    b = li()\\n    if max(a) > max(b):\\n        print('YES')\\n    else:\\n        print('NO')\\n\", \"t = int(input())\\nfor query in range(t):\\n    n, k1, k2 = list(map(int, input().split()))\\n    A = list(map(int, input().split()))\\n    B = list(map(int, input().split()))\\n    if n in A:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"t = int(input())\\n\\nfor qwe in range(t):\\n\\tn, k1, k2 = map(int, input().split())\\n\\ta = list(map(int, input().split()))\\n\\tb = list(map(int, input().split()))\\n\\n\\tif max(a) == n:\\n\\t\\tprint(\\\"YES\\\")\\n\\telse:\\n\\t\\tprint(\\\"NO\\\")\", \"for _ in range(int(input())):\\n\\tn,k1,k2 = map(int,input().split())\\n\\ta = list(map(int,input().split()))\\n\\tb = list(map(int,input().split()))\\n\\tif n in a:\\n\\t\\tprint(\\\"YES\\\")\\n\\telse: print(\\\"NO\\\")\\t\", \"for i in range(int(input())):\\n    n, k1, k2 = list(map(int, input().split()))\\n    u = max(list(map(int, input().split())))\\n    v = max(list(map(int, input().split())))\\n    if u < v:\\n        print('NO')\\n    else:\\n        print('YES')\\n\", \"t=int(input())\\nfor l in range(t):\\n    n,k1,k2=list(map(int,input().split()))\\n    arr1=list(map(int,input().split()))\\n    arr2=list(map(int,input().split()))\\n    if(max(arr1)>max(arr2)):\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"for i in ' '*int(input()):\\n    n,k1,k2=map(int,input().split())\\n    L1=list(map(int,input().split()))\\n    L2=list(map(int,input().split()))\\n    if max(L1)>max(L2):print('YES')\\n    else:print('NO')\", \"def case():\\n    n, k1, k2 = map(int, input().split())\\n    a = list(map(int, input().split()))\\n    b = list(map(int, input().split()))\\n    if max(a) > max(b):\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\nfor _ in range(int(input())):\\n    case()\", \"for _ in range(int(input())):\\n    n,k1,k2 = list(map(int, input().split()))\\n    arr = list(map(int, input().split()))\\n    brr = list(map(int, input().split()))\\n    max1 = max(arr)\\n    max2 = max(brr)\\n    if max1>max2:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"t = int(input())\\nfor i in range(t):\\n    n,k1,k2 = list(map(int,input().split()))\\n    s1 = max(list(map(int,input().split())))\\n    s2 = max(list(map(int,input().split())))\\n    if s1 == n:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"t=int(input())\\nfor i in range(t):\\n    n, k1, k2=list(map(int, input().split()))\\n    d=max(list(map(int, input().split())))\\n    d1=max(list(map(int, input().split())))\\n    if d>d1:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"2\\n2 1 1\\n2\\n1\\n5 2 3\\n2 3\\n1 4 5\\n\"\n  ],\n  \"outputs\": [\n    \"YES\\nNO\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1270/A", "starter_code": ""}
{"id": 39, "question": "After a long party Petya decided to return home, but he turned out to be at the opposite end of the town from his home. There are $n$ crossroads in the line in the town, and there is either the bus or the tram station at each crossroad.\n\nThe crossroads are represented as a string $s$ of length $n$, where $s_i = \\texttt{A}$, if there is a bus station at $i$-th crossroad, and $s_i = \\texttt{B}$, if there is a tram station at $i$-th crossroad. Currently Petya is at the first crossroad (which corresponds to $s_1$) and his goal is to get to the last crossroad (which corresponds to $s_n$).\n\nIf for two crossroads $i$ and $j$ for all crossroads $i, i+1, \\ldots, j-1$ there is a bus station, one can pay $a$ roubles for the bus ticket, and go from $i$-th crossroad to the $j$-th crossroad by the bus (it is not necessary to have a bus station at the $j$-th crossroad). Formally, paying $a$ roubles Petya can go from $i$ to $j$ if $s_t = \\texttt{A}$ for all $i \\le t < j$. \n\nIf for two crossroads $i$ and $j$ for all crossroads $i, i+1, \\ldots, j-1$ there is a tram station, one can pay $b$ roubles for the tram ticket, and go from $i$-th crossroad to the $j$-th crossroad by the tram (it is not necessary to have a tram station at the $j$-th crossroad). Formally, paying $b$ roubles Petya can go from $i$ to $j$ if $s_t = \\texttt{B}$ for all $i \\le t < j$.\n\nFor example, if $s$=\"AABBBAB\", $a=4$ and $b=3$ then Petya needs:[Image]  buy one bus ticket to get from $1$ to $3$,  buy one tram ticket to get from $3$ to $6$,  buy one bus ticket to get from $6$ to $7$. \n\nThus, in total he needs to spend $4+3+4=11$ roubles. Please note that the type of the stop at the last crossroad (i.e. the character $s_n$) does not affect the final expense.\n\nNow Petya is at the first crossroad, and he wants to get to the $n$-th crossroad. After the party he has left with $p$ roubles. He's decided to go to some station on foot, and then go to home using only public transport.\n\nHelp him to choose the closest crossroad $i$ to go on foot the first, so he has enough money to get from the $i$-th crossroad to the $n$-th, using only tram and bus tickets.\n\n\n-----Input-----\n\nEach test contains one or more test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$).\n\nThe first line of each test case consists of three integers $a, b, p$ ($1 \\le a, b, p \\le 10^5$)\u00a0\u2014 the cost of bus ticket, the cost of tram ticket and the amount of money Petya has.\n\nThe second line of each test case consists of one string $s$, where $s_i = \\texttt{A}$, if there is a bus station at $i$-th crossroad, and $s_i = \\texttt{B}$, if there is a tram station at $i$-th crossroad ($2 \\le |s| \\le 10^5$).\n\nIt is guaranteed, that the sum of the length of strings $s$ by all test cases in one test doesn't exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case print one number\u00a0\u2014 the minimal index $i$ of a crossroad Petya should go on foot. The rest of the path (i.e. from $i$ to $n$ he should use public transport).\n\n\n-----Example-----\nInput\n5\n2 2 1\nBB\n1 1 1\nAB\n3 2 8\nAABBBBAABB\n5 3 4\nBBBBB\n2 1 1\nABABAB\n\nOutput\n2\n1\n3\n1\n6", "solutions": "[\"t=int(input())\\n\\nfor tt in range(t):\\n    a,b,p=map(int,input().split())\\n    s=input()\\n    n=len(s)\\n    cost = [0]*n\\n    cost[-1] = 0\\n    typ = ''\\n    i=n-2\\n    while i>=0:\\n        if s[i]==typ:\\n            cost[i] = cost[i+1]\\n        else:\\n            typ = s[i]\\n            cost[i] = cost[i+1] + (a if typ=='A' else b)\\n        i-=1\\n    i=0\\n    while cost[i] > p:\\n        i+=1\\n    print(i+1)\", \"from sys import stdin,stderr\\ndef rl():\\n    return [int(w) for w in stdin.readline().split()]\\n\\nt, = rl()\\nfor _ in range(t):\\n    a,b,p = rl()\\n    s = stdin.readline().rstrip()\\n    r = 1\\n    t = ''\\n    for i in range(len(s)-1,0,-1):\\n        if s[i-1] != t:\\n            t = s[i-1]\\n            p -= a if t == 'A' else b\\n            if p < 0:\\n                r = i+1\\n                break\\n    print(r)\\n\", \"# from collections import defaultdict\\n\\nfor _ in range(int(input())):\\n\\t# n = int(input())\\n\\ta, b, p = map(int, input().split())\\n\\ts = input()\\n\\tn = len(s)\\n\\tmoney = [0] * n\\n\\tlast = 'C'\\n\\tfor i in range(n-2, -1, -1):\\n\\t\\tif s[i] == last:\\n\\t\\t\\tmoney[i] = money[i+1]\\n\\t\\telif s[i] == 'A':\\n\\t\\t\\tmoney[i] = money[i+1] + a\\n\\t\\telse:\\n\\t\\t\\tmoney[i] = money[i+1] + b\\n\\t\\tlast = s[i]\\n\\n\\tfor i in range(1, n+1):\\n\\t\\tif money[i-1] <= p:\\n\\t\\t\\tprint(i)\\n\\t\\t\\tbreak\", \"from math import *\\nfrom collections import *\\nt = int(input())\\nfor y in range(t):\\n\\ta,b,p = map(int,input().split())\\n\\ts = input()\\n\\tn = len(s)\\n\\ti = n-2\\n\\tans = n\\n\\tct = 0\\n\\twhile(i >= 0):\\n\\t\\tst = s[i]\\n\\t\\twhile(i >= 0 and s[i] == st):\\n\\t\\t\\ti -= 1\\n\\t\\tif(st == 'A'):\\n\\t\\t\\tct += a\\n\\t\\telse:\\n\\t\\t\\tct += b\\n\\t\\tif(ct <= p):\\n\\t\\t\\tans = i+2\\n\\tprint(ans)\", \"for _ in range(int(input())):\\n    a, b, p = list(map(int, input().split()))\\n    ar = list(input())\\n    i = len(ar) - 2\\n    now = ar[i]\\n    flag = 0\\n    if now == 'A':\\n        if p >= a:\\n            flag = 1\\n    else:\\n        if p >= b:\\n            flag = 1\\n    while i >= 0 and p > 0 and flag == 1:\\n        if ar[i] == now:\\n            i -= 1\\n        else:\\n            if ar[i + 1] == 'A':\\n                p -= a\\n            else:\\n                p -= b\\n            if ar[i] == 'A':\\n                if p < a:\\n                    break\\n                now = 'A'\\n            else:\\n                if p < b:\\n                    break\\n                now = 'B'\\n    print(i + 2)\", \"t = int(input())\\nfor i in range(t):\\n    a, b, p = list(map(int, input().split()))\\n    s = input()\\n    n = len(s)\\n    ind = n\\n    sum = 0\\n    while sum <= p and ind > 0:\\n        ind -= 1\\n        if ind == n - 1 or s[ind - 1] != s[ind]:\\n            if s[ind - 1] == \\\"A\\\":\\n                sum += a\\n            else:\\n                sum += b\\n    print(ind + 1)\\n\", \"t = int(input())\\nfor tt in range(t):\\n\\ta, b, p = map(int, input().split())\\n\\ts = input()\\n\\tcs = {'A':a, 'B':b}\\n\\tc = 0\\n\\ti = len(s)-1\\n\\twhile i > 0 and c+cs[s[i-1]] <= p:\\n\\t\\t# print(tt, i)\\n\\t\\tc += cs[s[i-1]]\\n\\t\\ti -= 1\\n\\t\\twhile i > 0 and s[i-1] == s[i]:\\n\\t\\t\\ti -= 1\\n\\tprint(i+1)\", \"\\n\\n\\\"\\\"\\\"\\nNTC here\\n\\\"\\\"\\\" \\nimport sys\\ninp= sys.stdin.readline\\ninput = lambda : inp().strip()\\n# flush= sys.stdout.flush\\n# import threading\\n# sys.setrecursionlimit(10**6)\\n# threading.stack_size(2**26)\\n\\ndef iin(): return int(input())\\ndef lin(): return list(map(int, input().split()))\\n\\n\\n\\ndef main():\\n    T = iin()\\n    while T:\\n        T-=1\\n        a, b, p = lin()\\n        \\n        s = list(input())\\n        n = len(s)\\n        ans = []\\n        ch = 'D'\\n        for i in range( n-1):\\n            if s[i]!=ch:\\n                ch = s[i]\\n                x = a\\n                if ch=='B':x=b\\n                ans.append([x, i])\\n        l = len(ans)\\n        ans = ans[::-1]\\n        for i in range(1, l):\\n            ans[i][0]+=ans[i-1][0]\\n        ans = ans[::-1]\\n        for i, j in ans:\\n            if p>=i:\\n                print(j+1)\\n                break\\n        else:\\n            print(n)\\n        #print(ans)\\n\\n\\nmain()\\n\\n#threading.Thread(target=main).start()\\n\\n\", \"for _ in range(int(input())):\\n    a, b, p = list(map(int, input().split()))\\n    s = input()\\n    naw = 0\\n    for q in range(len(s)-2, -1, -1):\\n        if (q == len(s)-2 or s[q] != s[q+1]) and naw+(a if s[q] == 'A' else b) > p:\\n            print(q+2)\\n            break\\n        elif q == len(s)-2 or s[q] != s[q+1]:\\n            naw += (a if s[q] == 'A' else b)\\n    else:\\n        print(1)\\n\", \"import sys\\ninput = sys.stdin.readline\\nfor j in range(int(input())):\\n    a, b, p = list(map(int, input().split(\\\" \\\")))\\n    s = input().rstrip()\\n    \\n    costs = [0 for x in range(len(s))]\\n    \\n    costs[len(s)-1] = 0\\n    if(s[len(s)-2] == \\\"B\\\"):\\n        costs[len(s)-2] = b\\n    else:\\n        costs[len(s)-2] = a\\n    for it in range(3, len(s)+1):\\n        if(s[len(s)-it] !=s[len(s)-it+1]):\\n            costs[len(s)-it] = costs[len(s)-it+1]+(s[len(s)-it]==\\\"A\\\")*a+(s[len(s)-it]==\\\"B\\\")*b\\n        else:\\n            costs[len(s)-it] = costs[len(s)-it+1]\\n\\n\\n    for j in range(len(costs)):\\n        if(costs[j]<=p):\\n            print(j+1)\\n            break\\n    \\n\", \"t = int(input())\\nfor _ in range(t):\\n  a,b,p = map(int,input().split())\\n  s = list(input())\\n  n = len(s)\\n  flg = 0\\n  ans = n\\n  y = \\\"C\\\"\\n  k = 0\\n  while s:\\n    x = s.pop()\\n    if not flg:\\n      flg = 1\\n      continue\\n    if x == y:\\n      ans -= 1\\n      continue\\n    else:\\n      if x == \\\"A\\\":\\n        if p<a:\\n          print(ans)\\n          k = 1\\n          break\\n        else:\\n          p -= a\\n      if x == \\\"B\\\":\\n        if p<b:\\n          print(ans)\\n          k = 1\\n          break\\n        else:\\n          p -= b\\n    y = x\\n    ans -= 1\\n  if s == [] and k == 0:\\n    print(1)\", \"for t in range(int(input())):\\n    a, b, p = [int(i) for i in input().split()]\\n    s = input()[::-1]\\n    n = len(s)\\n    curr = s[1]\\n    res = 0\\n    for i in range(1, n):\\n        if (s[i] != curr):\\n            if (curr == \\\"A\\\"):\\n                p -= a\\n                curr = \\\"B\\\"\\n            else:\\n                p -= b\\n                curr = \\\"A\\\"\\n            if (p < 0):\\n                break\\n            else:\\n                res = i - 1\\n    if (curr == \\\"A\\\"):\\n        p -= a\\n    else:\\n        p -= b\\n    if (p < 0):\\n        print(n - res)\\n    else:\\n        print(1)\", \"# from collections import deque\\nimport sys\\ninput = lambda: sys.stdin.readline().strip()\\ndef d(x):\\n    if x=='A':\\n        return a\\n    return b\\ndef f(j):\\n    su = d(s[j])\\n    for i in range(j+1, len(s) - 1):\\n        if s[i]!=s[i-1]:\\n            su+=d(s[i])\\n    return su\\nfor i in range(int(input())):\\n    a,b,p = map(int,input().split())\\n    s = list(input())\\n    l = -1\\n    r = len(s)-1\\n    while r - l > 1:\\n        m = (r + l) // 2\\n        if f(m) > p:\\n            l = m\\n        else:\\n            r = m\\n    print(r+1)\", \"from math import inf\\nt = int(input())\\nfor q in range(t):\\n    a, b, p = [int(i) for i in input().split()]\\n    s = input()\\n    l = len(s) \\n    dp = [0] * l\\n    if s[l - 2] == 'A':\\n        dp[l - 2] = a\\n    else:\\n        dp[l - 2] = b\\n    for i in range(l - 3, -1, -1):\\n        if s[i] == s[i + 1]:\\n            dp[i] = dp[i + 1]\\n        else:\\n            if s[i] == 'A':\\n                dp[i] = dp[i + 1] + a\\n            else:\\n                dp[i] = dp[i + 1] + b\\n    #print(dp)\\n    for i in range(l):\\n        if p >= dp[i]:\\n            print(i + 1)\\n            break\\n\", \"# import sys\\n# input = sys.stdin.readline\\n\\nt = int(input())\\nfor _ in range(t):\\n    a, b, p = map(int, input().split())\\n    s = input()\\n    n = len(s)\\n    dp = [0] * n\\n    for i in range(n-2, -1, -1):\\n        if i == n-2:\\n            dp[i] = a if s[i] == 'A' else b\\n        elif s[i] == s[i+1]:\\n            dp[i] = dp[i+1]\\n        else:\\n            dp[i] = dp[i+1] + (a if s[i] == 'A' else b)\\n    ans = -1\\n    for i in range(n):\\n        if dp[i] <= p:\\n            ans = i+1\\n            break\\n    print(ans)\", \"t = int(input())\\nwhile t:\\n    t += -1\\n    a, b, p = map(int, input().split())\\n    s = input()\\n    l = []\\n    for i in s: l.append(i)\\n    cost = 0\\n    for i in range(len(l) - 1):\\n        if l[i + 1] != l[i]:\\n            if l[i] == 'A': cost += a\\n            else: cost += b\\n    if l[len(l) - 1] == l[len(l) - 2]:\\n        if l[len(l) - 1] == 'A': cost += a\\n        else: cost += b\\n    # print(cost)\\n    ind = -1\\n    for i in range(len(l) - 1):\\n        if cost <= p:\\n            ind = i\\n            break\\n        if l[i + 1] != l[i]:\\n            if l[i] == 'A': cost -= a\\n            else: cost -= b\\n    if ind == -1: print(len(l))\\n    else: print(ind + 1)\", \"import sys\\nimport math\\nfrom collections import defaultdict\\nfrom collections import deque\\nfrom itertools import combinations\\nfrom itertools import permutations\\ninput = lambda : sys.stdin.readline().rstrip()\\nread = lambda : list(map(int, input().split()))\\ngo = lambda : 1/0\\ndef write(*args, sep=\\\"\\\\n\\\"):\\n  for i in args:\\n    sys.stdout.write(\\\"{}{}\\\".format(i, sep))\\nINF = float('inf')\\nMOD = int(1e9 + 7)\\nYES = \\\"YES\\\"\\nNO = \\\"NO\\\"\\n\\nfor _ in range(int(input())):\\n  try:\\n    a, b, p = read()\\n    s = input()\\n\\n    stack = [[s[0], 1]]\\n\\n    for i in s[1:-1]:\\n      if i == stack[-1][0]:\\n        stack[-1][1] += 1\\n        \\n      else:\\n        stack.append([i, 1])\\n    \\n\\n\\n    ans = len(s) \\n    temp = []\\n    # print(stack)\\n\\n    if p < a and p < b:\\n      print(len(s))\\n      go() \\n    \\n    while stack:\\n      i, j = stack[-1]\\n      stack.pop()\\n      if i == 'A' and p >= a:\\n        p -= a\\n        ans -= j\\n        temp.append(j)\\n      elif i == 'A' and p < a:\\n        break\\n      if i == 'B' and p >= b:\\n        p -= b \\n        ans -= j \\n        temp.append(j)\\n      elif i == 'B' and p < b:\\n        break\\n    \\n    print(ans)\\n      \\n\\n  except ZeroDivisionError:\\n    continue\\n\\n  except Exception as e:\\n    print(e)\\n    continue\", \"for _ in range(int(input())):\\n    a, b, p = map(int, input().split())\\n    s = input()\\n    \\n    d = {'A': a, 'B': b}\\n\\n    c = '0'\\n    inv = []\\n    start = 0\\n    for i in range(1, len(s)):\\n        if s[i] != s[i-1]:\\n            inv.append((start, i, s[i-1]))\\n            start = i\\n        elif i == len(s) - 1:\\n            inv.append((start, i, s[i]))\\n\\n    ans, cost = len(s) - 1, 0\\n    for q in inv[::-1]:\\n        cost += d[q[2]]\\n        if cost > p:\\n            break\\n        else:\\n            ans = q[0]\\n\\n    print(ans + 1)\", \"for i in range(int(input())):\\n    a, b, p = map(int, input().split())\\n    s = input()\\n    dp = [0 for i in range(len(s))]\\n    for j in range(len(s) - 2, -1, -1):\\n        if s[j] != s[j + 1] or dp[j + 1] == 0:\\n            if s[j] == 'B':\\n                if dp[j + 1] == 0:\\n                    dp[j] = b\\n                else:\\n                    dp[j] = dp[j + 1] + b\\n            else:\\n                if dp[j + 1] == 0:\\n                    dp[j] = a\\n                else:\\n                    dp[j] = dp[j + 1] + a\\n        else:\\n            dp[j] = dp[j + 1]\\n    ans = 1\\n    for i in dp:\\n        if i > p:\\n            ans += 1\\n        else:\\n            break\\n    print(ans)\", \"from math import *\\n\\ndef check(a, b, p, s, x):\\n    ps = s[x]\\n    ans = 0\\n    for i in range(x, len(s)):\\n        if ps == s[i]:\\n            pass\\n        else:\\n            if ps == 'A':\\n                ans += a\\n            else:\\n                ans += b\\n            if s[i] == 'E':\\n                break\\n            ps = s[i]\\n    return ans <= p\\n\\nzzz = int(input())\\nfor zz in range(zzz):\\n    a, b, p = list(map(int, input().split()))\\n    s = input()\\n    s = list(s)\\n    s[-1] = 'E'\\n    s = ''.join(s)\\n    lb = 0\\n    ub = len(s) + 1\\n    while lb + 1 < ub:\\n        tx = (lb + ub) // 2\\n        dx = (ub -lb)//2\\n        if check(a, b, p, s, tx):\\n            ub -= dx\\n        else:\\n            lb += dx\\n        #print(ub, lb, dx)\\n\\n    x = (lb + ub) // 2\\n    for i in range(4):\\n        if x > 0 and check(a, b, p, s, x-1):\\n            x -= 1\\n        elif x <= len(s) and not check(a, b, p, s, x):\\n            x += 1\\n    print(min(x + 1, len(s)))\\n    \\n\", \"t = int(input())\\nfor _ in range(t):\\n    a,b,p = map(int,input().split())\\n    sl = list(input())\\n    before = \\\"\\\"\\n    for idx, i in enumerate(sl[::-1][1:]):\\n        cost = a if i == \\\"A\\\" else b\\n        if before == i:\\n            continue\\n        if cost > p:\\n            break\\n        else:\\n            before = i\\n            p -= cost\\n    else:\\n        print(1)\\n        continue\\n    print(len(sl) - idx)\"]", "input_output": "{\n  \"inputs\": [\n    \"5\\n2 2 1\\nBB\\n1 1 1\\nAB\\n3 2 8\\nAABBBBAABB\\n5 3 4\\nBBBBB\\n2 1 1\\nABABAB\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n1\\n3\\n1\\n6\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1315/B", "starter_code": ""}
{"id": 40, "question": "You are given a sequence $a_1, a_2, \\dots, a_n$, consisting of integers.\n\nYou can apply the following operation to this sequence: choose some integer $x$ and move all elements equal to $x$ either to the beginning, or to the end of $a$. Note that you have to move all these elements in one direction in one operation.\n\nFor example, if $a = [2, 1, 3, 1, 1, 3, 2]$, you can get the following sequences in one operation (for convenience, denote elements equal to $x$ as $x$-elements):   $[1, 1, 1, 2, 3, 3, 2]$ if you move all $1$-elements to the beginning;  $[2, 3, 3, 2, 1, 1, 1]$ if you move all $1$-elements to the end;  $[2, 2, 1, 3, 1, 1, 3]$ if you move all $2$-elements to the beginning;  $[1, 3, 1, 1, 3, 2, 2]$ if you move all $2$-elements to the end;  $[3, 3, 2, 1, 1, 1, 2]$ if you move all $3$-elements to the beginning;  $[2, 1, 1, 1, 2, 3, 3]$ if you move all $3$-elements to the end; \n\nYou have to determine the minimum number of such operations so that the sequence $a$ becomes sorted in non-descending order. Non-descending order means that for all $i$ from $2$ to $n$, the condition $a_{i-1} \\le a_i$ is satisfied.\n\nNote that you have to answer $q$ independent queries.\n\n\n-----Input-----\n\nThe first line contains one integer $q$ ($1 \\le q \\le 3 \\cdot 10^5$)\u00a0\u2014 the number of the queries. Each query is represented by two consecutive lines.\n\nThe first line of each query contains one integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$)\u00a0\u2014 the number of elements.\n\nThe second line of each query contains $n$ integers $a_1, a_2, \\dots , a_n$ ($1 \\le a_i \\le n$)\u00a0\u2014 the elements.\n\nIt is guaranteed that the sum of all $n$ does not exceed $3 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each query print one integer\u00a0\u2014 the minimum number of operation for sorting sequence $a$ in non-descending order.\n\n\n-----Example-----\nInput\n3\n7\n3 1 6 6 3 1 1\n8\n1 1 4 4 4 7 8 8\n7\n4 2 5 2 6 2 7\n\nOutput\n2\n0\n1\n\n\n\n-----Note-----\n\nIn the first query, you can move all $1$-elements to the beginning (after that sequence turn into $[1, 1, 1, 3, 6, 6, 3]$) and then move all $6$-elements to the end.\n\nIn the second query, the sequence is sorted initially, so the answer is zero.\n\nIn the third query, you have to move all $2$-elements to the beginning.", "solutions": "[\"def main():\\n    from sys import stdin, stdout\\n    for _ in range(int(stdin.readline())):\\n        n = int(stdin.readline())\\n        inp1 = [-1] * (n + 1)\\n        inp2 = [-1] * (n + 1)\\n        for i, ai in enumerate(map(int, stdin.readline().split())):\\n            if inp1[ai] < 0:\\n                inp1[ai] = i\\n            inp2[ai] = i\\n        inp1 = tuple((inp1i for inp1i in inp1 if inp1i >= 0))\\n        inp2 = tuple((inp2i for inp2i in inp2 if inp2i >= 0))\\n        n = len(inp1)\\n        ans = 0\\n        cur = 0\\n        for i in range(n):\\n            if i and inp1[i] < inp2[i - 1]:\\n                cur = 1\\n            else:\\n                cur += 1\\n                ans = max(ans, cur)\\n        stdout.write(f'{n - ans}\\\\n')\\n\\n\\nmain()\\n\", \"from sys import stdin\\ninput = stdin.readline\\n\\n\\ndef main():\\n    anses = []\\n    for _ in range(int(input())):\\n        n = int(input())\\n        a = list(map(int, input().split()))\\n        f = [0]*(n+1)\\n        d = sorted(list(set(a)))\\n        for q in range(1, len(d)+1):\\n            f[d[q-1]] = q\\n        for q in range(len(a)):\\n            a[q] = f[a[q]]\\n        n = len(d)\\n        starts, ends = [-1]*(n+1), [n+1]*(n+1)\\n        for q in range(len(a)):\\n            if starts[a[q]] == -1:\\n                starts[a[q]] = q\\n            ends[a[q]] = q\\n        s = [0]*(n+1)\\n        max1 = -float('inf')\\n        for q in range(1, n+1):\\n            s[q] = s[q-1]*(ends[q-1] < starts[q])+1\\n            max1 = max(max1, s[q])\\n        anses.append(str(len(d)-max1))\\n    print('\\\\n'.join(anses))\\n\\n\\nmain()\\n\", \"#                                               |\\n#   _` |  __ \\\\    _` |   __|   _ \\\\   __ \\\\    _` |   _` |\\n#  (   |  |   |  (   |  (     (   |  |   |  (   |  (   |\\n# \\\\__,_| _|  _| \\\\__,_| \\\\___| \\\\___/  _|  _| \\\\__,_| \\\\__,_|\\n\\nimport sys\\nimport math\\n\\ndef read_line():\\n\\treturn sys.stdin.readline()[:-1]\\n \\ndef read_int():\\n\\treturn int(sys.stdin.readline())\\n\\t\\ndef read_int_line():\\n\\treturn [int(v) for v in sys.stdin.readline().split()]\\n\\ndef read_float_line():\\n\\treturn [float(v) for v in sys.stdin.readline().split()]\\n\\nt = read_int()\\nfor i in range(t):\\n\\tn = read_int()\\n\\ta = read_int_line()\\n\\td = {}\\n\\tfor i in range(n):\\n\\t\\tif a[i] in d:\\n\\t\\t\\td[a[i]].append(i)\\n\\t\\telse:\\n\\t\\t\\td[a[i]] = [i]\\n\\n\\tdp = [1]*len(list(d.keys()))\\n\\n\\ts = list(d.keys())\\n\\ts.sort()\\n\\n\\tfor i in range(len(s)-2,-1,-1):\\n\\t\\tif d[s[i]][-1] < d[s[i+1]][0]:\\n\\t\\t\\tdp[i] = dp[i+1]+1\\n\\t\\telse:\\n\\t\\t\\tdp[i] = 1\\n\\tans = len(s)-max(dp)\\n\\tprint(ans)\\n\\n\", \"import os\\nimport sys\\n\\n\\ndef solve(arr):\\n    items = sorted(set(arr))\\n    min_max = [(float(\\\"inf\\\"), float(\\\"-inf\\\"))] * len(items)\\n    item_to_idx = {k: idx for idx, k in enumerate(items)}\\n    for idx, a in enumerate(arr):\\n        m, M = min_max[item_to_idx[a]]\\n        min_max[item_to_idx[a]] = (min(idx, m), max(idx, M))\\n\\n    best = 1\\n    current = 1\\n    for i in range(1, len(items)):\\n        _, prev_M = min_max[i - 1]\\n        m, _ = min_max[i]\\n        if prev_M <= m:\\n            current += 1\\n        else:\\n            current = 1\\n\\n        best = max(best, current)\\n\\n    return len(items) - best\\n\\n\\ndef pp(input):\\n    T = int(input())\\n    for t in range(T):\\n        input()\\n        arr = list(map(int, input().strip().split()))\\n        print(solve(arr))\\n\\n\\nif \\\"paalto\\\" in os.getcwd():\\n    from string_source import string_source, codeforces_parse\\n\\n    pp(\\n        string_source(\\n            \\\"\\\"\\\"3\\n7\\n3 1 6 6 3 1 1\\n8\\n1 1 4 4 4 7 8 8\\n7\\n4 2 5 2 6 2 7\\\"\\\"\\\"\\n        )\\n    )\\nelse:\\n    pp(sys.stdin.readline)\\n\", \"import sys as _sys\\n\\n\\ndef main():\\n    q = int(input())\\n    for i_q in range(q):\\n        n, = _read_ints()\\n        a = tuple(_read_ints())\\n        result = find_min_sorting_cost(sequence=a)\\n        print(result)\\n\\n\\ndef _read_line():\\n    result = _sys.stdin.readline()\\n    assert result[-1] == \\\"\\\\n\\\"\\n    return result[:-1]\\n\\n\\ndef _read_ints():\\n    return list(map(int, _read_line().split(\\\" \\\")))\\n\\n\\ndef find_min_sorting_cost(sequence):\\n    sequence = tuple(sequence)\\n    \\n    if not sequence:\\n        return 0\\n    \\n    indices_by_values = {x: [] for x in sequence}\\n    for i, x in enumerate(sequence):\\n        indices_by_values[x].append(i)\\n    \\n    borders_by_values = {\\n        x: (indices[0], indices[-1]) for x, indices in list(indices_by_values.items())\\n    }\\n    \\n    borders_sorted_by_values = [borders for x, borders in sorted(borders_by_values.items())]\\n    \\n    max_cost_can_keep_n = curr_can_keep_n = 1\\n    for prev_border, curr_border in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\\n        if curr_border[0] > prev_border[1]:\\n            curr_can_keep_n += 1\\n        else:\\n            if curr_can_keep_n > max_cost_can_keep_n:\\n                max_cost_can_keep_n = curr_can_keep_n\\n            curr_can_keep_n = 1\\n    if curr_can_keep_n > max_cost_can_keep_n:\\n        max_cost_can_keep_n = curr_can_keep_n\\n    \\n    return len(set(sequence)) - max_cost_can_keep_n\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import copy\\ndef DeleteRepetitionsIn(Array):\\n    AlreadyRead = {}\\n    index = 0\\n    ConstantArray = copy.deepcopy(Array)\\n    for a in range(len(ConstantArray)):\\n        if Array[index] not in AlreadyRead:\\n            AlreadyRead[Array[index]] = \\\"\\\"\\n            index += 1\\n            continue\\n        Array = Array[0:index] + Array[index + 1:len(Array)]\\n\\n    return Array\\n\\ndef DeleteRepetitionsIn2(Array):\\n    AlreadyRead = {}\\n    for elem in Array:\\n        if elem in AlreadyRead:\\n            continue\\n        AlreadyRead[elem] = \\\"\\\"\\n    return list(AlreadyRead)\\n\\nResults = []\\nArraysNumber = int(input())\\nfor e in range(ArraysNumber):\\n    AbsolutelyUselessNumber = int(input())\\n    Array = list(map(int, input().split()))\\n    if len(Array) == 1:\\n        Results.append(0)\\n        continue\\n\\n    #print(Array)\\n    TheRightOrder = DeleteRepetitionsIn2(Array)\\n    TheRightOrder.sort()\\n    TheCurrentOrder = {}\\n    for i in range(len(Array)):\\n        if Array[i] not in TheCurrentOrder:\\n            TheCurrentOrder[Array[i]] = [i, i]\\n            continue\\n        TheCurrentOrder[Array[i]][1] = i\\n\\n    #print(TheRightOrder)\\n    #print(TheCurrentOrder)\\n    #print(Array)\\n\\n    TheCurrentResult = 1\\n    TheMaxResult = 1\\n    for i in range(len(TheRightOrder)):\\n        #print(\\\"a =\\\", TheCurrentResult)\\n        #print(\\\"b =\\\", TheMaxResult)\\n        if i == len(TheRightOrder) - 1:\\n            if TheCurrentResult >= TheMaxResult:\\n                TheMaxResult = TheCurrentResult\\n            continue\\n        if TheCurrentOrder[TheRightOrder[i]][1] > TheCurrentOrder[TheRightOrder[i + 1]][0]:\\n            if TheCurrentResult >= TheMaxResult:\\n                TheMaxResult = TheCurrentResult\\n\\n            TheCurrentResult = 1\\n            continue\\n\\n        TheCurrentResult += 1\\n\\n    Results.append(len(TheRightOrder) - TheMaxResult)\\n\\nfor i in Results:\\n    print(i)\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n7\\n3 1 6 6 3 1 1\\n8\\n1 1 4 4 4 7 8 8\\n7\\n4 2 5 2 6 2 7\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n0\\n1\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1223/D", "starter_code": ""}
{"id": 41, "question": "You are fed up with your messy room, so you decided to clean it up.\n\nYour room is a bracket sequence $s=s_{1}s_{2}\\dots s_{n}$ of length $n$. Each character of this string is either an opening bracket '(' or a closing bracket ')'.\n\nIn one operation you can choose any consecutive substring of $s$ and reverse it. In other words, you can choose any substring $s[l \\dots r]=s_l, s_{l+1}, \\dots, s_r$ and change the order of elements in it into $s_r, s_{r-1}, \\dots, s_{l}$.\n\nFor example, if you will decide to reverse substring $s[2 \\dots 4]$ of string $s=$\"((()))\" it will be equal to $s=$\"()(())\".\n\nA regular (aka balanced) bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters '1' and '+' between the original characters of the sequence. For example, bracket sequences \"()()\", \"(())\" are regular (the resulting expressions are: \"(1)+(1)\", \"((1+1)+1)\"), and \")(\" and \"(\" are not.\n\nA prefix of a string $s$ is a substring that starts at position $1$. For example, for $s=$\"(())()\" there are $6$ prefixes: \"(\", \"((\", \"(()\", \"(())\", \"(())(\" and \"(())()\".\n\nIn your opinion, a neat and clean room $s$ is a bracket sequence that:\n\n  the whole string $s$ is a regular bracket sequence;  and there are exactly $k$ prefixes of this sequence which are regular (including whole $s$ itself). \n\nFor example, if $k = 2$, then \"(())()\" is a neat and clean room.\n\nYou want to use at most $n$ operations to make your room neat and clean. Operations are applied one after another sequentially.\n\nIt is guaranteed that the answer exists. Note that you do not need to minimize the number of operations: find any way to achieve the desired configuration in $n$ or less operations.\n\n\n-----Input-----\n\nThe first line contains integer number $t$ ($1 \\le t \\le 100$)\u00a0\u2014 the number of test cases in the input. Then $t$ test cases follow.\n\nThe first line of a test case contains two integers $n$ and $k$ ($1 \\le k \\le \\frac{n}{2}, 2 \\le n \\le 2000$, $n$ is even)\u00a0\u2014 length of $s$ and required number of regular prefixes.\n\nThe second line of a test case contains $s$ of length $n$\u00a0\u2014 the given bracket sequence. It contains only '(' and ')'.\n\nIt is guaranteed that there are exactly $\\frac{n}{2}$ characters '(' and exactly $\\frac{n}{2}$ characters ')' in the given string.\n\nThe sum of all values $n$ over all the test cases in the input doesn't exceed $2000$.\n\n\n-----Output-----\n\nFor each test case print an answer.\n\nIn the first line print integer $m$ ($0 \\le m \\le n$)\u00a0\u2014 the number of operations. You do not need to minimize $m$, any value is suitable.\n\nIn the following $m$ lines print description of the operations, each line should contain two integers $l,r$ ($1 \\le l \\le r \\le n$), representing single reverse operation of $s[l \\dots r]=s_{l}s_{l+1}\\dots s_{r}$. Operations are applied one after another sequentially.\n\nThe final $s$ after all operations should be a regular, also it should be exactly $k$ prefixes (including $s$) which are regular.\n\nIt is guaranteed that the answer exists. If there are several possible answers you can print any.\n\n\n-----Example-----\nInput\n4\n8 2\n()(())()\n10 3\n))()()()((\n2 1\n()\n2 1\n)(\n\nOutput\n4\n3 4\n1 1\n5 8\n2 2\n3\n4 10\n1 4\n6 7\n0\n1\n1 2\n\n\n\n-----Note-----\n\nIn the first example, the final sequence is \"()(()())\", where two prefixes are regular, \"()\" and \"()(()())\". Note, that all the operations except \"5 8\" in the example output are useless (they do not change $s$).", "solutions": "[\"t = int(input())\\nfor tt in range(t):\\n    n,k=list(map(int,input().split()))\\n    s = input()\\n    ans = []\\n    if s[0] == ')':\\n        for i in range(n):\\n            if s[i] == '(':\\n                ans.append([1,i+1])\\n                s = s[i::-1] + s[i+1:]\\n                break\\n    for i in range(1,(k-1)*2):\\n        if i%2==0:\\n            if s[i]!='(':\\n                for j in range(i+1,n):\\n                    if s[j] == '(':\\n                        ans.append([i+1,j+1])\\n                        s = s[:i] + s[j:i-1:-1] + s[j+1:]\\n                        break\\n        else:\\n            if s[i]!=')':\\n                for j in range(i+1,n):\\n                    if s[j] == ')':\\n                        ans.append([i+1,j+1])\\n                        s = s[:i] + s[j:i-1:-1] + s[j+1:]\\n                        break\\n    for i in range((k-1)*2,(n+(2*(k-1)))//2+1):\\n        if s[i]!='(':\\n            for j in range(i+1,n):\\n                if s[j] == '(':\\n                    ans.append([i+1,j+1])\\n                    s = s[:i] + s[j:i-1:-1] + s[j+1:]\\n                    break\\n    print(len(ans))\\n    for i in ans:\\n        print(*i)\\n            \\n\\n\\n\\n\", \"t = int(input())\\nfor test_i in range(t):\\n    n, k = map(int, input().split())\\n    s = list(input())\\n    ans = []\\n    for i in range(k - 1):\\n        if s[2 * i] != '(':\\n            i0 = s.index('(', 2 * i)\\n            ans.append((2 * i + 1, i0 + 1))\\n            s[2 * i], s[i0] = '(', ')'\\n        if s[2 * i + 1] != ')':\\n            i0 = s.index(')', 2 * i + 1)\\n            ans.append((2 * i + 2, i0 + 1))\\n            s[2 * i + 1], s[i0] = ')', '('\\n    for i in range(n // 2 - k + 1):\\n        if s[2 * (k - 1) + i] != '(':\\n            i0 = s.index('(', 2 * (k - 1) + i)\\n            ans.append((2 * (k - 1) + i + 1, i0 + 1))\\n            s[2 * (k - 1) + i], s[i0] = '(', ')'\\n    print(len(ans))\\n    for pair in ans:\\n        print(*pair)\", \"for _ in range(int(input())):\\n    n, k = map(int, input().split())\\n    st = input()\\n    s = [st[i] for i in range(n)]\\n    res = '()' * (k - 1) + '(' * ((n - 2 * (k - 1)) // 2) + ')' * ((n - 2 * (k - 1)) // 2)\\n    ans = []\\n    for i in range(n):\\n        if  s[i] != res[i]:\\n            for j in range(i + 1, n):\\n                if res[i] == s[j]:\\n                    ans.append([i + 1, j + 1])\\n                    sub = s[i:j + 1]\\n                    sub = sub[::-1]\\n                    #print(sub)\\n                    for k in range(len(sub)):\\n                        s[i + k] = sub[k]\\n                    break\\n    #print(res, s)\\n    print(len(ans))\\n    for i in range(len(ans)):\\n        print(ans[i][0], ans[i][1])\", \"m = int(input())\\nfor h in range(m):\\n    n, b = list(map(int, input().split()))\\n    a = input()\\n    t = 0\\n    ans = []\\n    while b != 1:\\n        if a[t] == ')':\\n            for i in range(t, n):\\n                if a[i] == '(':\\n                    k = i\\n                    break\\n            c = a[t:k + 1]\\n            a = a[:t] + c[::-1]  + a[k + 1:]\\n            #print(t, k, a)\\n            ans.append([t, k]) \\n        if a[t + 1] == '(':\\n            for i in range(t + 1, n):\\n                if a[i] == ')':\\n                    k = i\\n                    break\\n            c = a[t + 1:k + 1]\\n            a = a[:t + 1] + c[::-1]  + a[k + 1:]\\n            #print(t, k, a)\\n            ans.append([t + 1, k])\\n        t += 2\\n        b -= 1\\n    for i in range(t, t + (n - t) // 2):\\n        if a[i] == ')':\\n            for j in range(i, n):\\n                if a[j] == '(':\\n                    k = j\\n                    break\\n            #print(i, k)\\n            c = a[i:k + 1]\\n            a = a[:i] + c[::-1]  + a[k + 1:]\\n            ans.append([i, k])\\n    #print(a)\\n    for i in range(t + (n - t) // 2, n):\\n        if a[i] == '(':\\n            for j in range(i, n):\\n                if a[j] == ')':\\n                    k = j\\n                    break\\n            c = a[i:k + 1]\\n            a = a[:i] + c[::-1] + a[k + 1:]\\n            ans.append([i, k])\\n            \\n    print(len(ans))\\n    for i in ans:\\n        print(i[0] + 1, i[1] + 1)\\n\", \"t = int(input())\\nfor i in range(t):\\n    n, k = map(int, input().split())\\n    a = []\\n    s = input()\\n    for j in range(len(s)):\\n        a.append(s[j:j + 1])\\n    answer = (k - 1) * \\\"()\\\" + (n // 2 - k + 1) * \\\"(\\\" + (n // 2 - k + 1) * \\\")\\\"\\n    b = []\\n    for j in range(len(answer)):\\n        b.append(answer[j:j + 1])\\n    ans = []\\n    j = 0\\n    while j < len(answer):\\n        if b[j] == a[j]:\\n            j += 1\\n        else:\\n            x = j + 1\\n            while a[x] == a[j]:\\n                x += 1\\n            ans.append([j + 1, x + 1])\\n            for f in range(j, j + (x - j + 1) // 2):\\n                a[f], a[x - f + j] = a[x - f + j], a[f]\\n            j += 1\\n    print(len(ans))\\n    for j in range(len(ans)):\\n        print(\\\" \\\".join(map(str, ans[j])))\", \"t = int(input())\\nfor z in range(t):\\n    n, k = map(int, input().split())\\n    arr = list(input())\\n    need = '()' * (k - 1) + '(' * ((n - (k - 1) * 2) // 2) + ')' * ((n - (k - 1) * 2) // 2)\\n    #print(need)\\n    li = 0\\n    ri = n - 1\\n    ln = 0\\n    rn = n - 1\\n    ret = []\\n    rev = 0\\n    while li < n:\\n        if arr[li] != need[li]:\\n            ri = li + 1\\n            while arr[ri] != need[li]:\\n                ri += 1\\n            ret.append([li, ri])\\n            arr = arr[:li] + list(reversed(arr[li:ri+1])) + arr[ri+1:]\\n        li += 1\\n    #print(*arr, sep='')\\n            \\n    print(len(ret))\\n    for x in ret:\\n        print(x[0] + 1, x[1] + 1)\", \"t=int(input())\\nfor r in range(t):\\n n,k=list(map(int,input().split()))\\n k-=1\\n want='()'*k+'('*(n//2-k)+')'*(n//2-k)\\n have=input()\\n prn=[]\\n for w in range(len(want)):\\n  if have[w]!=want[w]:\\n   e=w+have[w:].index(want[w])\\n   have=have[:w]+have[w:e+1][::-1]+have[e+1:]\\n   prn+=[[w+1,e+1]]\\n print(len(prn))\\n for w in prn:\\n  print(*w)\\n\", \"for _ in range(int(input())):\\n    n, k = tuple(map(int, input().split()))\\n    s = list(input())\\n    ans = list(\\\"()\\\" * (k - 1) + \\\"(\\\" * ((n // 2) - k + 1) + \\\")\\\" * (n // 2 - k + 1))\\n    ops = []\\n    i = 0\\n    while ans != s and i < n:\\n        # print(\\\"----\\\" , i, \\\"----\\\")\\n        if ans[i] != s[i]:\\n            j = s[i:].index(ans[i]) + i\\n            # print(0,\\\"|\\\",j, s[j], s[i])\\n            ops.append(str(i + 1) + \\\" \\\" + str(j + 1))\\n            for k in range(i, (j + i + 1) // 2):\\n                # print(11, \\\"|\\\", j, s[k], s[j + i - k])\\n                (s[k], s[j + i - k]) = (s[j + i - k], s[k])\\n                # print(12, \\\"|\\\", j, s[k], s[j + i - k])\\n        # print(\\\" \\\".join(s))\\n        # print(\\\" \\\".join(ans))\\n        # print(\\\"|\\\".join(ops))\\n        i += 1\\n    print(len(ops))\\n    if len(ops) != 0:\\n        print(\\\"\\\\n\\\".join(ops))\\n\", \"t = int(input())\\nfor request in range(t):\\n    n, k = map(int, input().split())\\n    box = list(input())\\n    pattern = '()' * (k - 1) + '(' + ('()' * ((n - (k) * 2) // 2) ) + ')'\\n    changes = []\\n    for i in range(n):\\n        if box[i] != pattern[i]:\\n            for j in range(i + 1, n):\\n                if box[j] == pattern[i]:\\n                    for z in range((j - i + 1) // 2):\\n                        box[i + z], box[j - z] = box[j - z], box[i + z]\\n                    changes.append((i + 1, j + 1))\\n                    break\\n    print(len(changes))\\n    for i in range(len(changes)):\\n        print(*changes[i])\", \"t = int(input())\\n\\nfor i in range(t):\\n    n, k = map(int, input().split())\\n    *s, = input()\\n    operations = []\\n    best = (['('] + [')']) * (k - 1) + (['('] * (n // 2 - k + 1) + [')'] * (n // 2 - k + 1))\\n\\n    for startx_pos in range((k - 1) * 2):\\n        try:\\n            if s[startx_pos - 1] == ')' or startx_pos == 0:\\n                end_pos = s.index('(', startx_pos)\\n            else:\\n                end_pos = s.index(')', startx_pos)\\n        except ValueError:\\n            continue\\n        if startx_pos == end_pos:\\n            continue\\n        if startx_pos == 0:\\n            s = s[:startx_pos] + s[end_pos::-1] + s[end_pos + 1:]\\n        else:\\n            s = s[:startx_pos] + s[end_pos:startx_pos - 1:-1] + s[end_pos + 1:]\\n        operations.append(f'{startx_pos + 1} {end_pos + 1}')\\n\\n    for startx_pos in range((k - 1) * 2, (k - 1) * 2 + (n // 2 - k + 1)):\\n        try:\\n            end_pos = s.index('(', startx_pos)\\n        except ValueError:\\n            continue\\n        if startx_pos == end_pos:\\n            continue\\n        if startx_pos == 0:\\n            s = s[:startx_pos] + s[end_pos::-1] + s[end_pos + 1:]\\n        else:\\n            s = s[:startx_pos] + s[end_pos:startx_pos - 1:-1] + s[end_pos + 1:]\\n        operations.append(f'{startx_pos + 1} {end_pos + 1}')\\n\\n    print(len(operations))\\n    if len(operations):\\n        print(*operations, sep='\\\\n')\\n\", \"\\n\\ndef openBracket(i):\\n    nonlocal firstOpen, ans\\n    ind = index[0][firstOpen]\\n    a = s[i: ind + 1]\\n    a.reverse()\\n    #print(i + 1, ind + 1)\\n    s[i: ind + 1] = a\\n    ans += [[i + 1, ind + 1]]\\n    firstOpen += 1\\n    \\n\\ndef closeBracket(i):\\n    nonlocal firstClose, ans\\n    ind = index[1][firstClose]\\n    a = s[i: ind + 1]\\n    a.reverse()\\n    #print(i + 1, ind + 1)\\n    ans += [[i + 1, ind + 1]]\\n    s[i: ind + 1] = a\\n    firstClose += 1\\n    \\n    \\nt = int(input())\\nfor h in range(t):\\n    n, k = map(int, input().split())\\n    s = list(input())\\n    ans = []\\n    fl = 0\\n    index = [[], []]\\n    firstOpen = 0\\n    firstClose = 0\\n    for i in range(n):\\n        if s[i] == \\\"(\\\":\\n            index[0] += [i];\\n        else:\\n            index[1] += [i];\\n    for i in range(2 * k - 2):\\n        if fl == 0:\\n            if s[i] != \\\"(\\\":\\n                openBracket(i)\\n            else:\\n                firstOpen += 1\\n        elif fl == 1:\\n            if s[i] != \\\")\\\":\\n                closeBracket(i)\\n            else:\\n                firstClose += 1\\n        fl = abs(fl - 1)\\n    fl = 0\\n    for i in range(2 * k - 2, n):\\n        if fl == 0:\\n            if s[i] != \\\"(\\\":\\n                openBracket(i)\\n            else:\\n                firstOpen += 1\\n        elif fl == 1:\\n            if s[i] != \\\")\\\":\\n                closeBracket(i)\\n            else:\\n                firstClose += 1\\n        if i == n // 2 - k + 2 * k - 2:\\n            fl = 1\\n    print(len(ans))\\n    [print(*i) for i in ans]\\n\", \"t=int(input())\\nwhile t:\\n    n,k=list(map(int,input().split()))\\n    s=list(input())\\n    hyp=[]\\n    k1=k\\n    while (k-1):\\n        hyp.append('(')\\n        hyp.append(')')\\n        k-=1\\n    ll=(n//2)-(k1-1)\\n    for i in range(ll):\\n        hyp.append('(')\\n    for i in range(ll):\\n        hyp.append(')')\\n    #print(hyp,s)   \\n    ans=[]\\n    for i in range(n):\\n        if hyp[i]!=s[i]:\\n            l=[]\\n            c=0\\n            for j in range(i,n):\\n                l.append(s[j])\\n                c+=1\\n                if s[j]==hyp[i]:\\n                    ans.append(i+1)\\n                    ans.append(j+1)\\n                    break\\n            k=i    \\n            for l2 in range(c-1,-1,-1):\\n                s[k]=l[l2]\\n                k+=1\\n    l3=len(ans)//2\\n    print(l3)\\n    j=0\\n    for i in range(l3):\\n        print(ans[j],ans[j+1])\\n        j+=2\\n    t-=1\\n\\n\", \"def replace(i, right_s):\\n    j = i + 1\\n    while j < n and s[j] != right_s:\\n        j += 1\\n    else:\\n        for k in range((j - i + 1) // 2):\\n            s[i + k], s[j - k] = s[j - k], s[i + k]\\n    return j\\n\\nt = int(input())\\noperations = []\\nfor _ in range(t):\\n    n, k = input().split()\\n    n = int(n)\\n    k = int(k) - 1\\n    s = list(input())\\n    operations.append([])\\n    for i in range(n):\\n        if i < 2 * k:\\n            if i % 2 and s[i] == '(':\\n                operations[_].append([i, replace(i, ')')])\\n            elif i % 2 == 0 and s[i] == ')':\\n                operations[_].append([i, replace(i, '(')])\\n        elif i < n // 2 + k and s[i] == ')':\\n            operations[_].append([i, replace(i, '(')])\\n        elif i >= n // 2 + k and s[i] == '(':\\n            operations[_].append([i, replace(i, ')')])\\nfor i in range(t):\\n    print(len(operations[i]))\\n    for operation in operations[i]:\\n        print(operation[0] + 1, operation[1] + 1)\\n\", \"def craftIdeal(length, zeroes):\\n    asdf = []\\n    x = 0\\n    for i in range(zeroes - 1):\\n        asdf.append(True)\\n        asdf.append(False)\\n        x += 2\\n    for j in range(x, x + (length - x)//2):\\n        asdf.append(True)\\n    for k in range(x + (length - x)//2, length):\\n        asdf.append(False)\\n    return asdf\\n\\ndef getAns(string, l, m):\\n    real = []\\n    for char in string:\\n        if char == \\\")\\\":\\n            real.append(False)\\n        else:\\n            real.append(True)\\n    endgoal = craftIdeal(l, m)\\n    operations = []\\n    temp = []\\n    \\n    for i in range(l):\\n        target = endgoal[i]\\n        if real[i] != target:\\n            nextDiffIndex = i + 1\\n            while real[nextDiffIndex] != target:\\n                nextDiffIndex += 1\\n                \\n            temp = real[i:nextDiffIndex + 1]\\n            for j in range(i, nextDiffIndex + 1):\\n                real[j] = temp[nextDiffIndex - j]\\n                \\n            operations.append(str(i + 1) + \\\" \\\" + str(nextDiffIndex + 1))\\n    print(len(operations))\\n    for e in operations:\\n        print(e)\\n    return\\n    \\nn = int(input())\\nfor i in range(n):\\n    k = [int(x) for x in input().split(' ')]\\n    getAns(input(), k[0], k[1])\\n\", \"for T in range(int(input())):\\n\\tn, k = list(map(int, input().split()))\\n\\ts = input()\\n\\tlp = 0\\n\\trp = 0\\n\\tl = []\\n\\tfor i in range(k * 2 - 2):\\n\\t\\twhile lp < n and s[lp] != '(' or lp < i:\\n\\t\\t\\tlp += 1\\n\\t\\twhile rp < n and s[rp] != ')' or rp < i:\\n\\t\\t\\trp += 1\\n\\t\\tif i % 2 == 0 and s[i] == '(' or i % 2 == 1 and s[i] == ')':\\n\\t\\t\\tcontinue\\n\\t\\telif i % 2 == 0:\\n\\t\\t\\tlp += 1\\n\\t\\t\\ts = s[: i] + s[i: lp][::-1] + s[lp:]\\n\\t\\t\\tl.append([i + 1, lp])\\n\\t\\t\\trp = i\\n\\n\\t\\telse:\\n\\t\\t\\trp += 1\\n\\t\\t\\ts = s[: i] + s[i: rp][::-1] + s[rp: ]\\n\\t\\t\\tl.append([i + 1, rp])\\n\\t\\t\\tlp = i\\n\\t\\n\\tfor i in range(k * 2 - 2, (n+k+k-2)//2):\\n\\t\\twhile lp < n and s[lp] != '(' or lp < i:\\n\\t\\t\\tlp += 1\\n\\t\\twhile rp < n and s[rp] != ')' or rp < i:\\n\\t\\t\\trp += 1\\n\\t\\tif i<(n+k+k-2)//2 and s[i] == '(' or i>=(n+k+k-2)//2 and s[i] == ')':\\n\\t\\t\\tcontinue\\n\\t\\telif i<(n+k+k)//2:\\n\\t\\t\\tlp += 1\\n\\t\\t\\ts = s[: i] + s[i: lp][::-1] + s[lp: ]\\n\\t\\t\\tl.append([i + 1, lp])\\n\\t\\t\\trp = i\\n\\n\\t\\telse:\\n\\t\\t\\trp += 1\\n\\t\\t\\ts = s[: i] + s[i: rp][::-1] + s[rp: ]\\n\\t\\t\\tl.append([i + 1, rp])\\n\\t\\t\\tlp = i\\n\\tprint(len(l))\\n\\tfor i in l:\\n\\t\\tprint(*i)\\n\", \"t = int(input())\\n\\ndef conv1(v) :\\n    nonlocal z\\n    index, q = 0, 0\\n    for i in range(len(v)) :\\n        if v[i] == '(' : q += 1\\n        else : q -= 1\\n        if q == 0 and v[i] == '(' :\\n            if i != len(v) : v = v[:index] + list(reversed(v[index:i+1])) + v[i+1:]\\n            else : v = v[:index] + list(reversed(v[index:i+1]))\\n            z.append([index+1, i+1])\\n            index = i+1\\n        elif q == 0 : index = i+1\\n    return v\\n\\ndef count(v) :\\n    q, k = 0, 0\\n    for i in v :\\n        if i == '(' : q += 1\\n        else : q -= 1\\n        if q == 0 : k += 1\\n    return k\\n\\ndef conv_min(v, k, n) :\\n    nonlocal z\\n    q = 0\\n    for i in range(0, len(v)) :\\n        if k == n : return v\\n        if v[i] == '(' : q += 1\\n        else : q -= 1\\n        if q == 0 :\\n            z.append([i+1, i+2])\\n            n -= 1\\n\\ndef conv_max(v, k, n) :\\n    nonlocal z\\n    q = 0\\n    for i in range(0, len(v)) :\\n        if k == n : return v\\n        if v[i] == '(' : q += 1\\n        else :\\n            if q == 2 :\\n                v[i-1], v[i] = v[i], v[i-1]\\n                q = 1\\n                z.append([i, i+1])\\n                n += 1\\n            elif q > 2 :\\n                v[i-q+1], v[i] = v[i], v[i-q+1]\\n                z.append([i-q+1, i+1])\\n                z.append([i-q+1, i-q+2])\\n                q -= 1\\n                n += 1\\n            else : q = 0\\n\\nif 1 == 2 :\\n    s = list('()(())')\\n    z = []\\n    print(''.join(conv_max(s, 3, 2)))\\n    raise SystemExit\\n\\nfor _ in range(t) :\\n    _, k = [int(x) for x in input().split()]\\n    s = list(input())\\n    z = []\\n    \\n    s = conv1(s)\\n    ct = count(s)\\n    if ct >= k : conv_min(s, k, ct)\\n    else : conv_max(s, k, ct)\\n    print(len(z))\\n    print('\\\\n'.join(list([str(x[0])+' '+str(x[1]) for x in z])))\\n\", \"t=int(input())\\nfor i3 in range(t):\\n    n,k=map(int,input().split())\\n    inp=str(input())\\n    s,ans,x=[],[],[]\\n    for i in range(n): x.append(inp[i])\\n    for i in range(k-1):\\n        s.append(\\\"(\\\")\\n        s.append(\\\")\\\")\\n    for i in range(n//2-k+1): s.append(\\\"(\\\")\\n    for i in range(n//2-k+1): s.append(\\\")\\\")\\n    for i in range(n):\\n        if x[i]==s[i]:\\n            pass\\n        else:\\n            temp=[]\\n            for i2 in range(i,n):\\n                temp.append(x[i])\\n                if x[i2]==s[i]:\\n                    ans.append([i+1,i2+1])\\n                    temp.reverse()\\n                    for i3 in range(i,i2+1):\\n                        x[i3]=temp[i3-i]\\n                    break\\n    print(len(ans))\\n    for i in range(len(ans)):\\n        print(ans[i][0],ans[i][1])\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n8 2\\n()(())()\\n10 3\\n))()()()((\\n2 1\\n()\\n2 1\\n)(\\n\"\n  ],\n  \"outputs\": [\n    \"1\\n5 7\\n5\\n1 3\\n3 5\\n5 7\\n6 9\\n7 10\\n0\\n1\\n1 2\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1227/C", "starter_code": ""}
{"id": 42, "question": "You are given a binary string $s$ (recall that a string is binary if each character is either $0$ or $1$).\n\nLet $f(t)$ be the decimal representation of integer $t$ written in binary form (possibly with leading zeroes). For example $f(011) = 3, f(00101) = 5, f(00001) = 1, f(10) = 2, f(000) = 0$ and $f(000100) = 4$.\n\nThe substring $s_{l}, s_{l+1}, \\dots , s_{r}$ is good if $r - l + 1 = f(s_l \\dots s_r)$.\n\nFor example string $s = 1011$ has $5$ good substrings: $s_1 \\dots s_1 = 1$, $s_3 \\dots s_3 = 1$, $s_4 \\dots s_4 = 1$, $s_1 \\dots s_2 = 10$ and $s_2 \\dots s_4 = 011$. \n\nYour task is to calculate the number of good substrings of string $s$.\n\nYou have to answer $t$ independent queries.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of queries.\n\nThe only line of each query contains string $s$ ($1 \\le |s| \\le 2 \\cdot 10^5$), consisting of only digits $0$ and $1$.\n\nIt is guaranteed that $\\sum\\limits_{i=1}^{t} |s_i| \\le 2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each query print one integer \u2014 the number of good substrings of string $s$.\n\n\n-----Example-----\nInput\n4\n0110\n0101\n00001000\n0001000\n\nOutput\n4\n3\n4\n3", "solutions": "[\"LOG = 20\\n\\ndef solve(s):\\n\\tn = len(s)\\n\\tres = 0\\n\\tz = 0\\n\\tfor t in range(0, n):\\n\\t\\tif s[t] == '0':\\n\\t\\t\\tz += 1\\n\\t\\t\\tcontinue\\n\\t\\tfor l in range(1, min(LOG, n - t + 1)):\\n\\t\\t\\tx = int(s[t:t+l], 2)\\n\\t\\t\\t# print(l, t, x, l + z)\\n\\t\\t\\tif l + z >= x:\\n\\t\\t\\t\\tres += 1\\n\\n#\\t\\t\\tprint(t, l, x, res, z)\\n\\t\\tz = 0\\n\\treturn res\\n\\n\\nt = int(input())\\nwhile t > 0:\\n\\tt -= 1\\n\\ts = input()\\n\\tprint(solve(s))\", \"t = int(input())\\n\\n\\nc = [0] * 200100\\nfor _ in range(t):\\n    s = input()\\n    for i in range(len(s)):\\n        c[i] = s[i] == '0'\\n        if i and s[i] == '0':\\n            c[i] += c[i-1]\\n\\n    sol = 0\\n    for i in range(len(s)):\\n        tmp = 0\\n        for k in range(20):\\n            if i - k < 0:\\n                break\\n            \\n            tmp += (s[i - k] == '1') << k\\n            if tmp == k + 1:\\n                sol += 1\\n\\n        if i >= 20:\\n            top = 20 + c[i-20]\\n            if tmp > 20 and tmp <= top:\\n                sol += 1\\n    print(sol)\\n        \\n\", \"T = int(input())\\nfor t in range(T):\\n    s = input()\\n    n = len(s)\\n    res = 0\\n    zeros = 0\\n    for i, c in enumerate(s):\\n        if c == '0':\\n            zeros += 1\\n        else:\\n            tail = 1\\n            j = 1\\n            while tail <= zeros+j:\\n                res += 1\\n                j += 1\\n                if i-1+j == n:\\n                    break\\n                tail *= 2\\n                tail += int(s[i-1+j])\\n            zeros = 0\\n    print(res)\", \"def main():\\n    from sys import stdin, stdout\\n    input = stdin.readline\\n    print = stdout.write\\n    for _ in range(int(input())):\\n        ans = 0\\n        i = -1\\n        s = input()\\n        for j in range(len(s) - 1):\\n            if s[j] == '1':\\n                c = 0\\n                for k in range(j, len(s)):\\n                    c = c * 2 + (s[k] == '1') + (s[k] == '\\\\n') * k\\n                    if k - i < c:\\n                        ans += k - j\\n                        break\\n                i = j\\n        print(f'{ans}\\\\n')\\n\\n\\nmain()\\n\", \"for _ in range(int(input())):\\n    s = input()\\n    q1 = ans = 0\\n    for q in range(len(s)):\\n        if s[q] == '0':\\n            q1 += 1\\n        else:\\n            ans += 1+(q != len(s)-1 and s[q+1] == '0')\\n            q2 = size = 1\\n            for q3 in range(1, q1+1):\\n                size += 1\\n                if q2 == size:\\n                    ans += 1\\n                while q2 < size and size-q3+q < len(s):\\n                    q2 *= 2\\n                    q2 += ord(s[q+size-q3])-ord('0')\\n                    size += 1\\n                    if q2 == size:\\n                        ans += 1\\n            q1 = 0\\n    print(ans)\\n\", \"import sys\\nD = {}\\nm = 18\\nfor i in range(1, 1<<m):\\n    D[bin(i)[2:]] = i\\nfor _ in range(int(input())):\\n    S = sys.stdin.readline().rstrip()\\n    s = 0\\n    N = len(S)\\n    ans = 0\\n    for i in range(N):\\n        if S[i] == \\\"1\\\":\\n            for j in range(1, min(m, N - i) + 1):\\n                k = D[S[i:i+j]]\\n                if s + j >= k:\\n                    ans += 1\\n            s = 0\\n        else:\\n            s += 1\\n    print(ans)\\n\\n\", \"from bisect import *\\nstrings = []\\nzeronumber = []\\nfor i in range(1, 200001):\\n    strings.append(format(i, \\\"b\\\"))\\n    zeronumber.append(i-i.bit_length())\\n\\nt = int(input())\\nfor _ in range(t):\\n    s = input()\\n    z = 0\\n    ans = 0\\n    for i in range(len(s)):\\n        if s[i] == \\\"0\\\":\\n            z += 1\\n            continue\\n        else:\\n            for j in range(bisect_right(zeronumber, z)):\\n                #print(j)\\n                #print(s[i:i+len(strings[j])], strings[j])\\n                if i+len(strings[j])-1 <= len(s)-1:\\n                    if s[i:i+len(strings[j])] == strings[j]:\\n                        ans += 1\\n            z = 0\\n    print(ans)\\n\", \"t = int(input())\\n\\nfor _ in [0]*t:\\n    s = input()\\n    stack = []\\n    zero_count = 0\\n    ans = 0\\n    for c in map(int, s):\\n        new_stack = []\\n        append = new_stack.append\\n        if c:\\n            append((c, zero_count))\\n            ans += 1\\n            zero_count = 0\\n        else:\\n            zero_count += 1\\n\\n        for v, zeros in stack:\\n            v = (v << 1) + c\\n            need_zeros = v - v.bit_length()\\n            if need_zeros <= zeros:\\n                ans += 1\\n                append((v, zeros))\\n\\n        stack = new_stack\\n\\n    print(ans)\\n\", \"q = int(input())\\nfor _ in range(q):\\n    s=input()\\n    n=len(s)\\n    ans=100000000\\n    r=[0 for i in range(n)]\\n    for i in range(n-1,-1,-1):\\n        if(s[i]=='1'):\\n            ans=i\\n        r[i]=ans\\n    ansss=0\\n    for i in range(n):\\n        ns=0\\n        for j in range(r[i],n):\\n            ns=2*ns+(ord(s[j])-ord('0'))\\n            if(ns==j-i+1):\\n                ansss+=1\\n            if(ns>n):\\n                break\\n    print(ansss)\", \"import sys\\ninput = sys.stdin.readline\\n\\nT = int(input())\\nfor testcases in range(T):\\n    S=input().strip()\\n    LEN=len(S)\\n\\n    zeros=0\\n    ANS=0\\n\\n    for i in range(LEN):\\n        if S[i]==\\\"0\\\":\\n            zeros+=1\\n        else:\\n\\n            for j in range(1,min(22,LEN-i+1)):\\n                k=int((S[i:i+j]),2)\\n                if k==0:\\n                    continue\\n                #print(i,j,k)\\n                if zeros>=k-j:\\n                    ANS+=1\\n\\n            zeros=0\\n\\n    print(ANS)\\n\\n        \\n\\n    \\n\", \"import sys \\nimport math \\nfrom collections import defaultdict\\ninput = lambda : sys.stdin.readline().rstrip()\\n\\nfor t in range(int(input())):\\n  ans = 0\\n  s = input()\\n\\n  i = 0\\n  while i < len(s):\\n    if s[i] == \\\"1\\\":\\n      ans += 1\\n      j = i - 1 \\n      zero_cnt = 0\\n      while j >= 0 and s[j] == \\\"0\\\":\\n        zero_cnt += 1\\n        j -= 1\\n      \\n      k = i \\n      b = \\\"1\\\"\\n      while k + 1 < len(s) and (int(b + s[k+1], 2) - len(b) - 1 <= zero_cnt):\\n        ans += 1\\n        b += s[k+1]\\n        k += 1\\n    \\n    i += 1\\n  \\n  print(ans)\", \"t=int(input())\\nfor i in range(t):\\n    a=[int(x) for x in list(input())]\\n    n=len(a)\\n    zero=0\\n    arr=0\\n    for i in range(n):\\n        if a[i]==1:\\n            size=2\\n            num=1\\n            arr+=1\\n            if i!=n-1:\\n                j=i+1\\n                if a[j]==1:\\n                    num*=2+1\\n                else:\\n                    num*=2\\n                    \\n                while num<=size+zero and num>=size:\\n                    arr+=1\\n                    if j==n-1:\\n                        break\\n                    j+=1\\n                    if a[j]==1:\\n                        num=num*2+1\\n                    else:\\n                        num*=2\\n                    size+=1\\n            zero=0\\n        else:\\n            zero+=1\\n    print(arr)\\n       \\n\", \"for _ in range(int(input())):\\n    s = input()\\n    num_zero = 0\\n    ans = 0\\n    \\n    length = len(s)\\n    \\n    for i in range(length):\\n        if s[i] == \\\"0\\\": num_zero += 1\\n        else:\\n            act_num = 1\\n            j = i\\n            \\n            is_right = True\\n            \\n            while j < length and is_right:\\n                if (act_num-(j-i+1)) <= num_zero:\\n                    ans += 1\\n                    j += 1\\n                   \\n                    if j < length:\\n                        act_num = act_num*2+int(s[j])\\n                else: is_right = False\\n                   \\n                    \\n                \\n            num_zero = 0\\n            \\n    print(ans)\", \"''' CODED WITH LOVE BY SATYAM KUMAR '''\\n\\nfrom sys import stdin, stdout\\nimport heapq\\nimport cProfile, math\\nfrom collections import Counter, defaultdict, deque\\nfrom bisect import bisect_left, bisect, bisect_right\\nimport itertools\\nfrom copy import deepcopy\\nfrom fractions import Fraction\\nimport sys, threading\\nimport operator as op\\nfrom functools import reduce\\nimport sys\\n\\nsys.setrecursionlimit(10 ** 6)  # max depth of recursion\\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\\nfac_warm_up = False\\nprintHeap = str()\\nmemory_constrained = False\\nP = 10 ** 9 + 7\\n\\n\\nclass MergeFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.size = [1] * n\\n        self.num_sets = n\\n        self.lista = [[_] for _ in range(n)]\\n\\n    def find(self, a):\\n        to_update = []\\n        while a != self.parent[a]:\\n            to_update.append(a)\\n            a = self.parent[a]\\n        for b in to_update:\\n            self.parent[b] = a\\n        return self.parent[a]\\n\\n    def merge(self, a, b):\\n        a = self.find(a)\\n        b = self.find(b)\\n        if a == b:\\n            return\\n        if self.size[a] < self.size[b]:\\n            a, b = b, a\\n        self.num_sets -= 1\\n        self.parent[b] = a\\n        self.size[a] += self.size[b]\\n        self.lista[a] += self.lista[b]\\n\\n    def set_size(self, a):\\n        return self.size[self.find(a)]\\n\\n    def __len__(self):\\n        return self.num_sets\\n\\n\\ndef display(string_to_print):\\n    stdout.write(str(string_to_print) + \\\"\\\\n\\\")\\n\\n\\ndef prime_factors(n):  # n**0.5 complex\\n    factors = dict()\\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\\n        while n % i == 0:\\n            if i in factors:\\n                factors[i] += 1\\n            else:\\n                factors[i] = 1\\n            n = n // i\\n    if n > 2:\\n        factors[n] = 1\\n    return (factors)\\n\\n\\ndef all_factors(n):\\n    return set(reduce(list.__add__,\\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\\n\\n\\ndef fibonacci_modP(n, MOD):\\n    if n < 2: return 1\\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(\\n        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\\n\\n\\ndef factorial_modP_Wilson(n, p):\\n    if (p <= n):\\n        return 0\\n    res = (p - 1)\\n    for i in range(n + 1, p):\\n        res = (res * cached_fn(InverseEuler, i, p)) % p\\n    return res\\n\\n\\ndef binary(n, digits=20):\\n    b = bin(n)[2:]\\n    b = '0' * (digits - len(b)) + b\\n    return b\\n\\n\\ndef is_prime(n):\\n    \\\"\\\"\\\"Returns True if n is prime.\\\"\\\"\\\"\\n    if n < 4:\\n        return True\\n    if n % 2 == 0:\\n        return False\\n    if n % 3 == 0:\\n        return False\\n    i = 5\\n    w = 2\\n    while i * i <= n:\\n        if n % i == 0:\\n            return False\\n        i += w\\n        w = 6 - w\\n    return True\\n\\n\\ndef generate_primes(n):\\n    prime = [True for i in range(n + 1)]\\n    p = 2\\n    while p * p <= n:\\n        if prime[p]:\\n            for i in range(p * 2, n + 1, p):\\n                prime[i] = False\\n        p += 1\\n    return prime\\n\\n\\nfactorial_modP = []\\n\\n\\ndef warm_up_fac(MOD):\\n    nonlocal factorial_modP, fac_warm_up\\n    if fac_warm_up: return\\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\\n    for i in range(2, fac_warm_up_size):\\n        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD\\n    fac_warm_up = True\\n\\n\\ndef InverseEuler(n, MOD):\\n    return pow(n, MOD - 2, MOD)\\n\\n\\ndef nCr(n, r, MOD):\\n    nonlocal fac_warm_up, factorial_modP\\n    if not fac_warm_up:\\n        warm_up_fac(MOD)\\n        fac_warm_up = True\\n    return (factorial_modP[n] * (\\n            (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD\\n\\n\\ndef test_print(*args):\\n    if testingMode:\\n        print(args)\\n\\n\\ndef display_list(list1, sep=\\\" \\\"):\\n    stdout.write(sep.join(map(str, list1)) + \\\"\\\\n\\\")\\n\\n\\ndef display_2D_list(li):\\n    for i in li:\\n        print(i)\\n\\n\\ndef prefix_sum(li):\\n    sm = 0\\n    res = []\\n    for i in li:\\n        sm += i\\n        res.append(sm)\\n    return res\\n\\n\\ndef get_int():\\n    return int(stdin.readline().strip())\\n\\n\\ndef get_tuple():\\n    return list(map(int, stdin.readline().split()))\\n\\n\\ndef get_list():\\n    return list(map(int, stdin.readline().split()))\\n\\n\\nmemory = dict()\\n\\n\\ndef clear_cache():\\n    nonlocal memory\\n    memory = dict()\\n\\n\\ndef cached_fn(fn, *args):\\n    nonlocal memory\\n    if args in memory:\\n        return memory[args]\\n    else:\\n        result = fn(*args)\\n        memory[args] = result\\n        return result\\n\\n\\ndef ncr(n, r):\\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\\n\\n\\ndef binary_search(i, li):\\n    fn = lambda x: li[x] - x // i\\n    x = -1\\n    b = len(li)\\n    while b >= 1:\\n        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like\\n            x += b\\n        b = b // 2\\n    return x\\n\\n\\n# -------------------------------------------------------------- MAIN PROGRAM\\n\\n\\nTestCases = True\\nfac_warm_up_size = 10 ** 5 + 100\\noptimise_for_recursion = False  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3\\n\\n\\ndef main():\\n    li = list(stdin.readline().strip())\\n    k = 0\\n    res = 0\\n    for index, cri in enumerate(li):\\n        if cri == '0':\\n            k += 1\\n        else:\\n            sm = 0\\n            for i in range(18):\\n                try:\\n                    sm = sm * 2 + int(li[index + i])\\n                    if i + 1 <= sm <= i + 1 + k:\\n                        res += 1\\n                except:\\n                    a = 1\\n            k = 0\\n    print(res)\\n\\n\\n# --------------------------------------------------------------------- END=\\n\\n\\nif TestCases:\\n    for i in range(get_int()):\\n        main()\\nelse:\\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()\\n\", \"for _ in range(int(input())):\\n    s=input()\\n    n=len(s)\\n    i=0\\n    j=0\\n    c=0\\n    ans=0\\n    while(i<n):\\n        if(s[i]=='0'):\\n            c+=1\\n        if(s[i]=='1'):\\n            x=0\\n            y=0\\n            for j in range(i,n):\\n                x=x*2\\n                if(s[j]=='1'):\\n                    x+=1\\n                # print(x,y,c)\\n                if(x-y-1<=c):\\n                    ans+=1\\n                    # print(i,j)\\n                else:\\n                    break\\n                y+=1\\n            c=0\\n        i+=1\\n    print(ans)\", \"from collections import defaultdict\\nfrom math import log2\\n\\n\\ndef zeros(n):\\n    return n - int(log2(n)) - 1\\n\\n\\ndef binary(n):\\n    s = \\\"\\\"\\n    while(n > 0):\\n        s = str(n & 1) + s\\n        n = n // 2\\n    return s\\n\\n\\nt = int(input())\\n\\nd = defaultdict(list)\\nfor i in range(1, 2 * 10**5 + 1):\\n    z = zeros(i)\\n    d[z].append(i)\\n\\nfor _ in range(t):\\n    s = input()\\n    n = len(s)\\n    zs = [0] * n\\n    z = 0\\n\\n    for i in reversed(list(range(n))):\\n        if (s[i] == '0'):\\n            z += 1\\n        else:\\n            z = 0\\n        zs[i] = z\\n\\n    total = 0\\n\\n    for i in range(n):\\n        z = zs[i]\\n        candidates = d[z]\\n\\n        j = i + z\\n        for c in candidates:\\n            cS = binary(c)\\n            cSL = len(cS)\\n\\n            jEnd = j + cSL\\n            if (jEnd > n):\\n                continue\\n            if (s[j:jEnd] == cS):\\n                total += 1\\n\\n    print(total)\\n\", \"import bisect\\n\\ndef solve(s,ans):\\n    count = 0\\n    one = []\\n    n = len(s)\\n    for i in range(n):\\n        if s[i] == '1':\\n            one.append(i)\\n\\n\\n    for i in range(n):\\n        curr = 0\\n        if s[i] == '0':\\n            start = bisect.bisect(one,i)\\n            if start < len(one):\\n                start = one[start]\\n            else:\\n                start = n\\n        else:\\n            start = i\\n\\n        #print(i,start)\\n        for j in range(start,n):\\n            curr *= 2\\n            if s[j] == '1':\\n                curr += 1\\n            #print(curr,i,j-i+1,j)\\n            if curr == j-i+1:\\n                count += 1\\n\\n            if curr > n-i:\\n                break\\n\\n    ans.append(count)\\n        \\n\\ndef main():\\n    t = int(input())\\n    ans = []\\n    for i in range(t):\\n        s = input()\\n        solve(s,ans)\\n\\n    for i in ans:\\n        print(i)\\n\\nmain()\\n\", \"import math\\n\\nfor _ in range(int(input())):\\n\\ts = input()\\n\\tn = len(s)\\n\\tans = 0\\n\\tlg = int(math.log2(n)) + 1\\n\\tnpfx = 0\\n\\tfor i in range(n):\\n\\t\\tif s[i] == '0':\\n\\t\\t\\tnpfx += 1\\n\\t\\t\\tcontinue\\n\\t\\tans += 1\\n\\t\\tcv = 1\\n\\t\\tln = 1\\n\\t\\tfor j in range(i + 1, min(i + lg + 1, n)):\\n\\t\\t\\tln += 1\\n\\t\\t\\tcv *= 2\\n\\t\\t\\tcv += s[j] == '1'\\n\\t\\t\\tans += (ln <= cv) and (ln + npfx >= cv)\\n\\t\\tnpfx = 0\\n\\tprint(ans)\\n\", \"from math import log\\nt=int(input())\\naa=[1]\\nfor i in range(100):\\n    aa.append(aa[-1]*2)\\nfor _ in range(t):\\n    s=input()\\n    ii=[]\\n    co=0\\n    j=0\\n    ss={}\\n    ind=-1\\n    for i in s:\\n        if i==\\\"0\\\":\\n            if ind==-1:\\n                ind=j\\n            co+=1\\n        else:\\n            if ind!=-1:\\n                ss[j-1]=ind\\n            co=0\\n            ind=-1\\n        j+=1\\n    if s[-1]==\\\"0\\\":\\n        ss[len(s)-1]=ind\\n    ans=0\\n    for i in range(1,int(log(len(s))/log(2))+2):\\n        for j in range(len(s)-i+1):\\n            st=s[j:j+i]\\n            if st[0]==\\\"1\\\":\\n                tot=0\\n                for ii in range(i):\\n                    if st[-ii-1]==\\\"1\\\":\\n                      #  print(ii)\\n                        tot+=aa[ii]\\n                le=tot-i\\n                try:\\n                    xx=ss[j-1]\\n                    if (j-xx)>=le:\\n                        ans+=1\\n                     #   print(i,j,tot,st)\\n                except:\\n                    if le==0:\\n                        ans+=1\\n                    #    print(i,j,tot,st)\\n                    pass\\n    print(ans)\\n #   print()\\n\", \"def run(a, ind, l):\\n    newSt = ''\\n    ans = 0\\n    for i in range(ind, len(a)):\\n        newSt += a[i]\\n        if int(newSt, 2) == (i - l + 1):\\n            ans += 1\\n        if int(newSt, 2) > (i - l + 1):\\n            return ans\\n    return ans\\n\\n\\nn = int(input())\\nfor kkk in range(n):\\n    st = input()\\n    uk = [0] * len(st)\\n    for i in range(len(uk)):\\n        uk[i] = i\\n\\n    for j in range(len(uk)):\\n        if st[j] == '1':\\n            uk[0] = j\\n            break\\n    for i in range(1, len(uk)):\\n        if i < uk[i - 1]:\\n            uk[i] = uk[i - 1]\\n        else:\\n            for j in range(i, len(uk)):\\n                if st[j] == '1':\\n                    uk[i] = j\\n                    break\\n\\n    s = 0\\n    for i in range(len(uk)):\\n         if ((uk[i] != i) or st[i] == '1'):\\n             s += run(st, uk[i], i)\\n    print(s)\", \"'''input\\n4\\n0110\\n0101\\n00001000\\n0001000\\n'''\\nfor test in range(int(input())):\\n\\ts = input()\\n\\tans = 0\\n\\tfor l in range(1, min(20, len(s))+1):\\n\\t\\tp = 0\\n\\t\\tfor i in range(len(s)-l+1):\\n\\t\\t\\tif s[i]=='0':\\n\\t\\t\\t\\tp += 1\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tx = int(s[i:i+l], 2)\\n\\t\\t\\tif x>=l and (x-l)<=p:\\n\\t\\t\\t\\tans+=1\\n\\t\\t\\tp = 0\\n\\tprint(ans)\\n\\n\", \"from math import log2\\nfrom math import ceil\\n\\nfor _ in range(int(input())):\\n    S = list(map(int, list(input())))\\n    combs = 0\\n    maxlen = ceil(log2(len(S)))\\n    #print(maxlen)\\n    prezeros = 0\\n    next1 = [0] * len(S)\\n    nxt = len(S) - 1\\n    for i in range(len(S) - 1, -1, -1):\\n        if S[i] == 1:\\n            nxt = i\\n        next1[i] = nxt\\n    for l in range(len(S)):\\n        if S[l] == 0:\\n            nxtl = next1[l]\\n            val = 0\\n            lcomb = 0\\n            for r in range(nxtl, min(nxtl + maxlen + 1, len(S))):\\n                val = 2 * val + S[r]\\n                if val == r - l + 1:\\n                    # print(l, r)\\n                    lcomb += 1\\n            combs += lcomb\\n            continue\\n        val = 0\\n        lcomb = 0\\n        for r in range(l, min(l + maxlen + 1, len(S))):\\n            val = 2 * val + S[r]\\n            if val == r - l + 1:\\n                #print(l, r)\\n                lcomb += 1\\n        combs += lcomb\\n        prezeros = 0\\n    print(combs)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n0110\\n0101\\n00001000\\n0001000\\n\"\n  ],\n  \"outputs\": [\n    \"4\\n3\\n4\\n3\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1217/C", "starter_code": ""}
{"id": 43, "question": "Petya is preparing for his birthday. He decided that there would be $n$ different dishes on the dinner table, numbered from $1$ to $n$. Since Petya doesn't like to cook, he wants to order these dishes in restaurants.\n\nUnfortunately, all dishes are prepared in different restaurants and therefore Petya needs to pick up his orders from $n$ different places. To speed up this process, he wants to order courier delivery at some restaurants. Thus, for each dish, there are two options for Petya how he can get it:  the dish will be delivered by a courier from the restaurant $i$, in this case the courier will arrive in $a_i$ minutes,  Petya goes to the restaurant $i$ on his own and picks up the dish, he will spend $b_i$ minutes on this. \n\nEach restaurant has its own couriers and they start delivering the order at the moment Petya leaves the house. In other words, all couriers work in parallel. Petya must visit all restaurants in which he has not chosen delivery, he does this consistently.\n\nFor example, if Petya wants to order $n = 4$ dishes and $a = [3, 7, 4, 5]$, and $b = [2, 1, 2, 4]$, then he can order delivery from the first and the fourth restaurant, and go to the second and third on your own. Then the courier of the first restaurant will bring the order in $3$ minutes, the courier of the fourth restaurant will bring the order in $5$ minutes, and Petya will pick up the remaining dishes in $1 + 2 = 3$ minutes. Thus, in $5$ minutes all the dishes will be at Petya's house.\n\nFind the minimum time after which all the dishes can be at Petya's home.\n\n\n-----Input-----\n\nThe first line contains one positive integer $t$ ($1 \\le t \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of test cases. Then $t$ test cases follow.\n\nEach test case begins with a line containing one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of dishes that Petya wants to order.\n\nThe second line of each test case contains $n$ integers $a_1 \\ldots a_n$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the time of courier delivery of the dish with the number $i$.\n\nThe third line of each test case contains $n$ integers $b_1 \\ldots b_n$ ($1 \\le b_i \\le 10^9$)\u00a0\u2014 the time during which Petya will pick up the dish with the number $i$.\n\nThe sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case output one integer\u00a0\u2014 the minimum time after which all dishes can be at Petya's home.\n\n\n-----Example-----\nInput\n4\n4\n3 7 4 5\n2 1 2 4\n4\n1 2 3 4\n3 3 3 3\n2\n1 2\n10 10\n2\n10 10\n1 2\n\nOutput\n5\n3\n2\n3", "solutions": "[\"def check(M):\\n    sm = 0\\n    for i in range(n):\\n        if a[i] > M:\\n            sm += b[i]\\n    return sm <= M\\n\\n\\ngans = []\\nfor _ in range(int(input())):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    b = list(map(int, input().split()))\\n    L = 0\\n    R = max(a)\\n    while R - L > 1:\\n        M = (L + R) // 2\\n        if check(M):\\n            R = M\\n        else:\\n            L = M\\n    gans.append(R)\\nprint(*gans, sep='\\\\n')\\n\", \"def helper(m):\\n\\ts = 0\\n\\tfor i in range(len(a)):\\n\\t\\tif a[i] > m:\\n\\t\\t\\ts += b[i]\\n\\treturn s <= m\\n\\nfor _ in range(int(input())):\\n\\tn = int(input())\\n\\ta = list(map(int, input().split()))\\n\\tb = list(map(int, input().split()))\\n\\tl, r = 1, 10**9\\n\\n\\twhile l < r:\\n\\t\\tmid = l + (r-l)//2\\n\\t\\ttemp = helper(mid)\\n\\n\\t\\tif temp:\\n\\t\\t\\tr = mid\\n\\t\\telse:\\n\\t\\t\\tl = mid+1\\n\\tprint(l)\\n\\n\\n\", \"import sys\\ninput=sys.stdin.readline\\ndef f(x):\\n    ans=0\\n    for i in range(n):\\n        if(a[i]<=x):\\n            continue\\n        ans+=b[i]\\n    if(ans<=x):\\n        return 1\\n    return 0\\ndef bsearch(l,r):\\n    m=(l+r)//2\\n    if(f(m)):\\n        if(f(m-1)==0):\\n            return m\\n        return bsearch(l,m-1)\\n    return bsearch(m+1,r)\\nt=int(input())\\nfor you in range(t):\\n    n=int(input())\\n    l=input().split()\\n    a=[int(i) for i in l]\\n    l=input().split()\\n    b=[int(i) for i in l]\\n    print(bsearch(0,10**9+5))\\n\", \"for _ in range(int(input())):\\n\\t n = int(input())\\n\\t a = [*list(map(int, input().split()))]\\n\\t b = [*list(map(int, input().split()))]\\n\\t lo = 0\\n\\t hi = sum(a)\\n\\t while lo < hi:\\n\\t \\tmid = (lo + hi) // 2\\n\\t \\tif sum(y if x > mid else 0 for x,y in zip(a,b)) <= mid:\\n\\t \\t\\thi = mid\\n\\t \\telse:\\n\\t \\t\\tlo = mid + 1\\n\\t print(lo)\\n\", \"def f(aa, bb, target):\\n    total = 0\\n    for i in range(len(aa)):\\n        if aa[i] > target:\\n            total += bb[i]\\n\\n    return total <= target\\n\\n\\nt = int(input())\\n\\nfor case in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    b = list(map(int, input().split()))\\n\\n    low = 1\\n    high = 1000000000\\n\\n    while low < high:\\n        mid = (low + high) // 2\\n        res = f(a, b, mid)\\n        if res:\\n            # mid is possible\\n            high = mid\\n        else:\\n            low = mid + 1\\n\\n    print(low)\\n\", \"\\\"\\\"\\\"T=int(input())\\nfor _ in range(0,T):\\n    n=int(input())\\n    a,b=map(int,input().split())\\n    s=input()\\n    s=[int(x) for x in input().split()]\\n    for i in range(0,len(s)):\\n        a,b=map(int,input().split())\\\"\\\"\\\"\\n\\n\\n\\nT=int(input())\\nfor _ in range(0,T):\\n    n=int(input())\\n    a=[int(x) for x in input().split()]\\n    b=[int(x) for x in input().split()]\\n    low=0\\n    high=max(a)\\n    ans=max(a)\\n    while(low<=high):\\n        mid=(low+high)>>1\\n        tot=0\\n        for i in range(0,len(a)):\\n            if(a[i]>mid):\\n                tot+=b[i]\\n\\n        if(tot<=mid):\\n            ans=min(ans, mid)\\n            high=mid-1\\n        else:\\n            low=mid+1\\n    print(ans)\\n            \\n\", \"\\nimport sys\\n\\ndef input():\\n    \\n    return sys.stdin.readline()\\n    \\n    \\nfor _ in range(int(input())):\\n    \\n    n = int(input())\\n    \\n    A = list(map(int, input().split()))\\n    B = list(map(int, input().split()))\\n    \\n    x = 10 ** 9\\n    y = 0\\n    while x > y + 1:\\n        \\n        z = (x + y) // 2\\n        \\n        t = 0\\n        \\n        for i in range(n):\\n            if A[i] > z:\\n                t += B[i]\\n        \\n        if t > z:\\n            y = z\\n        \\n        else:\\n            x = z\\n            \\n    print(x)\\n    \\n        \\n\", \"import sys\\nimport math\\ndef II():\\n\\treturn int(sys.stdin.readline())\\n \\ndef LI():\\n\\treturn list(map(int, sys.stdin.readline().split()))\\n \\ndef MI():\\n\\treturn list(map(int, sys.stdin.readline().split()))\\n \\ndef SI():\\n\\treturn sys.stdin.readline().strip()\\nt = II()\\nfor q in range(t):\\n\\tn = II()\\n\\ta = LI()\\n\\tb = LI()\\n\\tb = sorted(enumerate(b), key=lambda x: a[x[0]])\\n\\tb = [i[1] for i in b]\\n\\ta.sort()\\n\\tx = []\\n\\ts = 0\\n\\tfor i in range(n-1,-1,-1):\\n\\t\\ts+=b[i]\\n\\t\\tx.append(s)\\n\\tx = x[:][::-1]\\n\\tans = s\\n\\tfor i in range(n):\\n\\t\\tif i == n-1:\\n\\t\\t\\tans = min(ans,a[i])\\n\\t\\telse:\\n\\t\\t\\tans = min(ans,max(a[i],x[i+1]))\\n\\tprint(ans)\\n\", \"def read_generator():\\n    while True:\\n        tokens = input().split(' ')\\n        for t in tokens:\\n            yield t\\n\\nreader = read_generator()\\n\\ndef readword():\\n    return next(reader)\\n\\ndef readint():\\n    return int(next(reader))\\n\\ndef readfloat():\\n    return float(next(reader))\\n\\ndef readline():\\n    return input()\\n\\ndef solve(a, b, n):\\n    l = 1\\n    r = 10 ** 9\\n\\n    while r - l > 1:\\n        t = (l + r) // 2\\n        if possible(a, b, n, t):\\n            r = t\\n        else:\\n            l = t\\n\\n    if possible(a, b, n, l):\\n        return l\\n    return r\\n\\n\\ndef possible(a, b, n, t):\\n    s = 0\\n    for i in range(n):\\n        if a[i] > t:\\n            s += b[i]\\n    return s <= t\\n\\ntests = readint()\\n\\nfor t in range(tests):\\n    n = readint()\\n    a = [readint() for _ in range(n)]\\n    b = [readint() for _ in range(n)]\\n    print(solve(a, b, n))\", \"import sys\\ninput = iter(sys.stdin.read().splitlines()).__next__\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    a = [int(i) for i in input().split()]\\n    b = [int(i) for i in input().split()]\\n    times = list(zip(a, b))\\n    times.sort()\\n    # print(times)\\n    pickup_time = sum(b)\\n    best_time = pickup_time\\n    for num_deliveries in range(1, n+1):\\n        pickup_time -= times[num_deliveries-1][1]\\n        delivery_time = times[num_deliveries-1][0]\\n        best_time = min(best_time, max(pickup_time, delivery_time))\\n        if pickup_time < delivery_time:\\n            break\\n    print(best_time)\", \"def xxx(x):\\n    nonlocal a,b\\n    res=0\\n    for i in range(len(a)):\\n        if a[i]>x:\\n            res+=b[i]\\n    if res<=x:\\n        return True\\n    else:\\n        return False\\n\\nfor i in range(int(input())):\\n    n=int(input())\\n    a=list(map(int,input().split()))\\n    b=list(map(int,input().split()))\\n    i1=0\\n    i2=sum(b)\\n    while i2-i1>1:\\n        m=(i1+i2)//2\\n        if xxx(m):\\n            i2=m\\n        else:\\n            i1=m\\n    print(i2)\\n    \\n        \\n            \\n        \\n\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n4\\n3 7 4 5\\n2 1 2 4\\n4\\n1 2 3 4\\n3 3 3 3\\n2\\n1 2\\n10 10\\n2\\n10 10\\n1 2\\n\"\n  ],\n  \"outputs\": [\n    \"5\\n3\\n2\\n3\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1443/C", "starter_code": ""}
{"id": 44, "question": "Today the kindergarten has a new group of $n$ kids who need to be seated at the dinner table. The chairs at the table are numbered from $1$ to $4n$. Two kids can't sit on the same chair. It is known that two kids who sit on chairs with numbers $a$ and $b$ ($a \\neq b$) will indulge if:   $gcd(a, b) = 1$ or,  $a$ divides $b$ or $b$ divides $a$. \n\n$gcd(a, b)$\u00a0\u2014 the maximum number $x$ such that $a$ is divisible by $x$ and $b$ is divisible by $x$.\n\nFor example, if $n=3$ and the kids sit on chairs with numbers $2$, $3$, $4$, then they will indulge since $4$ is divided by $2$ and $gcd(2, 3) = 1$. If kids sit on chairs with numbers $4$, $6$, $10$, then they will not indulge.\n\nThe teacher really doesn't want the mess at the table, so she wants to seat the kids so there are no $2$ of the kid that can indulge. More formally, she wants no pair of chairs $a$ and $b$ that the kids occupy to fulfill the condition above.\n\nSince the teacher is very busy with the entertainment of the kids, she asked you to solve this problem.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\leq t \\leq 100$)\u00a0\u2014 the number of test cases. Then $t$ test cases follow.\n\nEach test case consists of one line containing an integer $n$ ($1 \\leq n \\leq 100$)\u00a0\u2014 the number of kids.\n\n\n-----Output-----\n\nOutput $t$ lines, which contain $n$ distinct integers from $1$ to $4n$\u00a0\u2014 the numbers of chairs that the kids should occupy in the corresponding test case. If there are multiple answers, print any of them. You can print $n$ numbers in any order.\n\n\n-----Example-----\nInput\n3\n2\n3\n4\n\nOutput\n6 4\n4 6 10\n14 10 12 8", "solutions": "[\"t=int(input())\\nfor you in range(t):\\n    n=int(input())\\n    for i in range(n):\\n        print(4*n-2*i,end=\\\" \\\")\\n    print()\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    for i in range(4 * n, 2 * n, -2):\\n        print(i, end=' ')\\n    print(' ')\\n\", \"import sys\\ninput=sys.stdin.readline\\nfrom collections import defaultdict\\n\\nfor _ in range(int(input())):\\n    n=int(input())\\n    x=4*n\\n    for i in range(n):\\n        print(x,end=\\\" \\\")\\n        x-=2\\n    print()\\n\\n\\n\", \"for _ in range (int(input())):\\n    n=int(input())\\n    for i in range (4*n,4*n-2*n,-2):\\n        print(i,end=' ')\\n    print()\", \"import sys,math\\n# import re\\n# from heapq import *\\n# from collections import defaultdict as dd\\n# from collections import Counter as cc\\n# sys.setrecursionlimit(10**6)#thsis is must\\nmod = 10**9+7; md = 998244353\\ninput = lambda: sys.stdin.readline().strip()\\ninp = lambda: list(map(int,input().split()))\\n#______________________________________________________\\nfor _ in range(int(input())):\\n\\tn = int(input())\\n\\tt = 4*n\\n\\tfor i in range(n):\\n\\t\\tprint(t,end = \\\" \\\")\\n\\t\\tt-=2\\n\\tprint()\", \"for i in range(int(input())):\\n    n=int(input())\\n    l=[]\\n    a=4*n\\n    for j in range(n):\\n        l.append(a)\\n        a-=2\\n    print(*l)\\n    \\n\", \"import sys\\nimport math\\nimport itertools\\nimport functools\\nimport collections\\nimport operator\\nimport fileinput\\nimport copy\\nimport string\\n\\n\\nORDA = 97  # a\\ndef ii(): return int(input())\\ndef mi(): return list(map(int, input().split()))\\ndef li(): return [int(i) for i in input().split()]\\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\\ndef revn(n): return str(n)[::-1]\\ndef dd(): return collections.defaultdict(int)\\ndef ddl(): return collections.defaultdict(list)\\ndef sieve(n):\\n    if n < 2: return list()\\n    prime = [True for _ in range(n + 1)]\\n    p = 3\\n    while p * p <= n:\\n        if prime[p]:\\n            for i in range(p * 2, n + 1, p):\\n                prime[i] = False\\n        p += 2\\n    r = [2]\\n    for p in range(3, n + 1, 2):\\n        if prime[p]:\\n            r.append(p)\\n    return r\\ndef divs(n, start=2):\\n    r = []\\n    for i in range(start, int(math.sqrt(n) + 1)):\\n        if (n % i == 0):\\n            if (n / i == i):\\n                r.append(i)\\n            else:\\n                r.extend([i, n // i])\\n    return r\\ndef divn(n, primes):\\n    divs_number = 1\\n    for i in primes:\\n        if n == 1:\\n            return divs_number\\n        t = 1\\n        while n % i == 0:\\n            t += 1\\n            n //= i\\n        divs_number *= t\\ndef prime(n):\\n    if n == 2: return True\\n    if n % 2 == 0 or n <= 1: return False\\n    sqr = int(math.sqrt(n)) + 1\\n    for d in range(3, sqr, 2):\\n        if n % d == 0: return False\\n    return True\\ndef convn(number, base):\\n    new_number = 0\\n    while number > 0:\\n        new_number += number % base\\n        number //= base\\n    return new_number\\ndef cdiv(n, k): return n // k + (n % k != 0)\\ndef ispal(s):\\n    for i in range(len(s) // 2 + 1):\\n        if s[i] != s[-i - 1]:\\n            return False\\n    return True\\n\\n\\nfor _ in range(ii()):\\n    n = ii()\\n    print(*[i for i in range(2 * n + 2, 4 * n + 2, 2)])\\n\", \"a = int(input())\\nfor i in range (a):\\n    b = int(input())\\n    for j in range (2 * b + 2, 4 * b, 2):\\n        print(j, end = \\\" \\\")\\n    print(4 * b)\", \"def main():\\n    t = int(input())\\n    for _ in range(t):\\n        n = int(input())\\n        p = []\\n        for i in range(n):\\n            p.append(4 * n - i * 2)\\n        print(*p)\\nmain()\", \"t = int(input())\\nfor case in range(t):\\n    n = int(input())\\n    ans = [2 * n + 2 * i + 2 for i in range(n)]\\n    print(*ans)\", \"import math\\nimport sys\\n\\n\\ndef chek(m, b, c, li):\\n    for i in range(li):\\n        if m[i] + b[i] > c:\\n            return False\\n    return True\\n\\n\\n# 113759\\ninput = lambda: sys.stdin.readline().rstrip()\\nf = int(input())\\nfor _ in range(f):\\n    n = int(input())\\n    n = n * 4\\n    for i in range(n, n // 2 , -1):\\n        if i % 2 == 0:\\n            print(i, end=' ')\\n    print()\", \"import sys\\ninput=sys.stdin.readline\\n\\nT=int(input())\\nfor _ in range(T):\\n    #N,K=map(int,input().split())\\n    #A=list(map(int,input().split()))\\n    n=int(input())\\n    v=4*n\\n    for i in range(n):\\n        print(v,end=\\\" \\\")\\n        v=v-2\\n    print()\\n\", \"for i in range(int(input())):\\n n=int(input())\\n g=[]\\n c=4*n\\n for j in range(n):\\n  g.append(c)\\n  c=c-2\\n print(' '.join(map(str,g))) \", \"# map(int, input().split())\\ndef main():\\n    n = int(input())\\n    for i in range(4 * n, 2 * n, -2):\\n        print(i, end = ' ')\\n    print('')\\n\\n\\nrw = int(input())\\nfor wewq in range(rw):\\n    main()\\n\"]", "input_output": "{\"inputs\": [\"3\\n2\\n3\\n4\\n\"], \"outputs\": [\"8 6 \\n12 10 8 \\n16 14 12 10 \\n\"]}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1443/A", "starter_code": ""}
{"id": 45, "question": "Jett is tired after destroying the town and she wants to have a rest. She likes high places, that's why for having a rest she wants to get high and she decided to craft staircases.\n\nA staircase is a squared figure that consists of square cells. Each staircase consists of an arbitrary number of stairs. If a staircase has $n$ stairs, then it is made of $n$ columns, the first column is $1$ cell high, the second column is $2$ cells high, $\\ldots$, the $n$-th column if $n$ cells high. The lowest cells of all stairs must be in the same row.\n\nA staircase with $n$ stairs is called nice, if it may be covered by $n$ disjoint squares made of cells. All squares should fully consist of cells of a staircase. This is how a nice covered staircase with $7$ stairs looks like: [Image] \n\nFind out the maximal number of different nice staircases, that can be built, using no more than $x$ cells, in total. No cell can be used more than once.\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ $(1 \\le t \\le 1000)$ \u00a0\u2014 the number of test cases.\n\nThe description of each test case contains a single integer $x$ $(1 \\le x \\le 10^{18})$ \u00a0\u2014 the number of cells for building staircases.\n\n\n-----Output-----\n\nFor each test case output a single integer \u00a0\u2014 the number of different nice staircases, that can be built, using not more than $x$ cells, in total.\n\n\n-----Example-----\nInput\n4\n1\n8\n6\n1000000000000000000\n\nOutput\n1\n2\n1\n30\n\n\n\n-----Note-----\n\nIn the first test case, it is possible to build only one staircase, that consists of $1$ stair. It's nice. That's why the answer is $1$.\n\nIn the second test case, it is possible to build two different nice staircases: one consists of $1$ stair, and another consists of $3$ stairs. This will cost $7$ cells. In this case, there is one cell left, but it is not possible to use it for building any nice staircases, that have not been built yet. That's why the answer is $2$.\n\nIn the third test case, it is possible to build only one of two nice staircases: with $1$ stair or with $3$ stairs. In the first case, there will be $5$ cells left, that may be used only to build a staircase with $2$ stairs. This staircase is not nice, and Jett only builds nice staircases. That's why in this case the answer is $1$. If Jett builds a staircase with $3$ stairs, then there are no more cells left, so the answer is $1$ again.", "solutions": "[\"import sys\\nimport random\\nfrom fractions import Fraction\\nfrom math import *\\n \\ndef input():\\n    return sys.stdin.readline().strip()\\n \\ndef iinput():\\n    return int(input())\\n\\ndef finput():\\n    return float(input())\\n\\ndef tinput():\\n    return input().split()\\n\\ndef linput():\\n    return list(input())\\n \\ndef rinput():\\n    return list(map(int, tinput()))\\n\\ndef fiinput():\\n    return list(map(float, tinput()))\\n \\ndef rlinput():\\n    return list(map(int, input().split()))\\ndef trinput():\\n    return tuple(rinput())\\n\\ndef srlinput():\\n    return sorted(list(map(int, input().split())))\\n\\ndef NOYES(fl):\\n    if fl:\\n        print(\\\"NO\\\")\\n    else:\\n        print(\\\"YES\\\")\\ndef YESNO(fl):\\n    if fl:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n    \\ndef main():\\n    n = iinput()\\n    #k = iinput() \\n    #m = iinput() \\n    #n = int(sys.stdin.readline().strip()) \\n    #n, k = rinput()\\n    #n, m = rinput()\\n    #m, k = rinput()\\n    #n, k, m = rinput()\\n    #n, m, k = rinput()\\n    #k, n, m = rinput()\\n    #k, m, n = rinput() \\n    #m, k, n = rinput()\\n    #m, n, k = rinput()\\n    #q = srlinput()\\n    #q = linput()\\n    s, t, res = 1, 1, 0\\n    while s <= n:\\n        res += 1\\n        n -= s\\n        t = 2 * t + 1\\n        s = (t * (t + 1)) // 2\\n    print(res)\\n        \\n    \\n                \\n    \\n    \\n    \\n            \\n    \\n        \\n    \\n\\nfor i in range(iinput()):\\n    main()\\n\", \"for _ in [0]*int(input()):\\n n=int(input());o=0;c=1\\n while n >= 0:\\n  n-=c*(c+1)//2;o+=1;c=2*c+1\\n print(o-1)\", \"tests = int(input())\\nfor test in range(tests):\\n    n = int(input())\\n    ans = 0\\n    s = 0\\n    for i in range(1, 31):\\n        d = 2 ** i - 1\\n        r = d * (d + 1) // 2\\n        if s + r <= n:\\n            ans += 1\\n            s += r\\n        else:\\n            break\\n    print(ans)\\n        \\n\", \"t = int(input())\\nfor _ in range(t):\\n  x = int(input())\\n  ans = 0\\n  size = 1\\n  temp = (size*(size+1))//2\\n  while x >= temp:\\n    ans += 1\\n    x -= temp\\n    size = 2*size + 1\\n    temp = (size*(size+1))//2\\n  print(ans)\\n\", \"q = int(input())\\nfor _ in range(q):\\n    n = int(input())\\n    wyn = 0\\n    pot = 1\\n    total = 1\\n    while total <= n:\\n        wyn += 1\\n        pot += 1\\n        total += (2**pot-1)*(2**pot)//2\\n    print(wyn)\", \"for _ in range(int(input())):\\n    n = int(input())\\n\\n    i = 1\\n    have = 0\\n    ans = 0\\n    while have + i * (i + 1) // 2 <= n:\\n        have += i * (i + 1) // 2\\n        ans += 1\\n        i = i * 2 + 1\\n\\n    print(ans)\\n\", \"from bisect import bisect_left,bisect_right\\na=[1]\\nf=1\\nwhile a[-1]<=10**18:\\n  f=f*2+1\\n  a.append(a[-1]+f*(f+1)//2)\\nfor _ in range(int(input())):\\n  n=int(input())\\n  print(bisect_right(a,n))\", \"import bisect\\np2 = [2 ** n - 1 for n in range(32)]\\np2 = [x * (x + 1) // 2 for x in p2]\\nfor i in range(1, 32):\\n    p2[i] += p2[i - 1]\\nfor _ in range(int(input())):\\n    n = int(input())\\n    print(bisect.bisect_right(p2, n) - 1)\\n\", \"for _ in range(int(input())):\\n\\tans=0\\n\\tn=int(input())\\n\\tcp=1\\n\\twhile cp*(cp+1)//2<=n:\\n\\t\\tans+=1\\n\\t\\tn-=cp*(cp+1)//2\\n\\t\\tcp=cp*2+1\\n\\tprint(ans)\", \"y=lambda:int(input())\\nfor _ in range(y()):\\n n=y();c=0\\n while 2**(2*c+1)-2**c<=n:n-=2**(2*c+1)-2**c;c+=1\\n print(c)\", \"l=[]\\ni=1\\nwhile(i<10**18+5):\\n    l.append((i*(i+1))//2)\\n    i=i*2+1\\nt=int(input())\\nfor you in range(t):\\n    n=int(input())\\n    count=0\\n    sum=0\\n    for i in range(len(l)):\\n        sum+=l[i]\\n        if(sum>n):\\n            break\\n    print(i)\\n\", \"from bisect import bisect_right\\nt = int(input())\\na = []\\ns = 0\\nx = 2\\nwhile s <= 10 ** 18:\\n    s += x * (x - 1) // 2\\n    a.append(s)\\n    x *= 2\\nfor _ in range(t):\\n    print(bisect_right(a, int(input())))\\n\", \"nice = [1]\\nwhile nice[-1] <= 10**18:\\n    nice.append((nice[-1]<<1)+1)\\nfor i in range(len(nice)):\\n    nice[i] = nice[i] * (nice[i] + 1) // 2\\n\\nt = int(input())\\nfor _ in range(t):\\n    x = int(input())\\n    i = 0\\n    num = 0\\n    while x > 0 and i < len(nice):\\n        if x >= nice[i]:\\n            x -= nice[i]\\n            num += 1\\n        i += 1\\n    print(num)\", \"T = int(input())\\n\\ndef need(n):\\n    return (n*(n+1))//2\\n\\nfor t in range(T):\\n    x = int(input())\\n    ans = 0\\n    nxt = 1\\n    while True:\\n        if x < need(nxt):\\n            break\\n        ans+=1\\n        x -= need(nxt)\\n        nxt = nxt*2+1\\n    print(ans)\", \"from math import log2\\nfor _ in range(int(input())):\\n    x = int(input())\\n    acc = 0\\n    for i in range(1, 60):\\n        acc += (2**i-1) * (2**(i-1))\\n        if acc > x:\\n            break\\n    print(i-1)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nT = int(input())\\n\\nfor t in range(T):\\n    X = int(input())\\n    answer = 0\\n    pow2 = 1\\n\\n    while True:\\n        r = 2**pow2 - 1\\n        needed = r*(r+1) // 2\\n        if needed <= X:\\n            answer += 1\\n            X -= needed\\n        else:\\n            break\\n        pow2 += 1\\n\\n    print(answer)\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    i = 1\\n    while True:\\n        x = pow(2,i-1)*(pow(2,i)-1)\\n        if n < x:\\n            break\\n        n -= x\\n        i += 1\\n    print(i-1)\", \"gans = []\\nfor _ in range(int(input())):\\n    n = int(input())\\n    ans = 0\\n    cur = 1\\n    while n >= cur * (cur + 1) // 2:\\n        n -= cur * (cur + 1) // 2\\n        ans += 1\\n        cur = cur * 2 + 1\\n        #print(cur, n)\\n    gans.append(ans)\\nprint('\\\\n'.join(map(str, gans)))\\n\", \"arr=[]\\ns=1\\ni=1\\nwhile s<((10**18)+1):\\n    temp=(s*(s+1))//2\\n    arr.append(temp)\\n    s+=(2**i)\\n    i+=1\\nt=int(input())\\nfor i in range(t):\\n    x=int(input())\\n    ans=0\\n    j=0\\n    while x>0:\\n        if arr[j]<=x:\\n            x-=arr[j]\\n            ans+=1\\n        else:\\n            x=0\\n        j+=1\\n    print(ans)\", \"l = [1]\\nfor i in range(70):\\n    l.append(2*l[-1] + 1)\\n# print(l[-1])\\nl = [(ll * (ll+1))//2 for ll in l]\\nlll = [l[0]]\\nfor i in range(1, 70):\\n    lll.append(lll[-1] + l[i])\\nl = lll\\n\\nfor t in range(int(input())):\\n    n = int(input())\\n    for i in range(70):\\n        if l[i] > n:\\n            print(i)\\n            break\", \"t = int(input())\\n\\nj = 0\\nr  = 0\\nR = []\\nfor i in range(10**5):\\n    j = 2*j+1\\n    s = j*(j+1)//2\\n    r += s\\n    R.append(r)\\n    if r > 10**18:\\n        break\\n\\nimport bisect\\n\\nfor _ in range(t):\\n    x = int(input())\\n    i = bisect.bisect_right(R, x)\\n    print(i)\\n\", \"A = [1]\\ns = 1\\nfor i in range(32):\\n    s *= 4\\n    A.append(A[-1] * 2 + s)\\nS = [0] * 33\\nfor i in range(32):\\n    S[i+1] = S[i] + A[i]\\nT = int(input())\\nfor _ in range(T):\\n    N = int(input())\\n    for i in range(33):\\n        if S[i] > N:\\n            print(i - 1)\\n            break\\n\\n\", \"import sys\\nii = lambda: sys.stdin.readline().strip()\\nidata = lambda: [int(x) for x in ii().split()]\\n\\ndef solve():\\n    ans = 0\\n    cnt = 1\\n    s = 1\\n    n = int(ii())\\n    while s <= n:\\n        cnt = 2 * cnt + 1\\n        ans += 1\\n        n -= s\\n        s = (cnt * (cnt + 1)) // 2\\n    print(ans)\\n    return\\n\\nfor t in range(int(ii())):\\n    solve()\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n1\\n8\\n6\\n1000000000000000000\\n\"\n  ],\n  \"outputs\": [\n    \"1\\n2\\n1\\n30\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1419/B", "starter_code": ""}
{"id": 46, "question": "Recently, you found a bot to play \"Rock paper scissors\" with. Unfortunately, the bot uses quite a simple algorithm to play: he has a string $s = s_1 s_2 \\dots s_{n}$ of length $n$ where each letter is either R, S or P.\n\nWhile initializing, the bot is choosing a starting index $pos$ ($1 \\le pos \\le n$), and then it can play any number of rounds. In the first round, he chooses \"Rock\", \"Scissors\" or \"Paper\" based on the value of $s_{pos}$:   if $s_{pos}$ is equal to R the bot chooses \"Rock\";  if $s_{pos}$ is equal to S the bot chooses \"Scissors\";  if $s_{pos}$ is equal to P the bot chooses \"Paper\"; \n\nIn the second round, the bot's choice is based on the value of $s_{pos + 1}$. In the third round\u00a0\u2014 on $s_{pos + 2}$ and so on. After $s_n$ the bot returns to $s_1$ and continues his game.\n\nYou plan to play $n$ rounds and you've already figured out the string $s$ but still don't know what is the starting index $pos$. But since the bot's tactic is so boring, you've decided to find $n$ choices to each round to maximize the average number of wins.\n\nIn other words, let's suggest your choices are $c_1 c_2 \\dots c_n$ and if the bot starts from index $pos$ then you'll win in $win(pos)$ rounds. Find $c_1 c_2 \\dots c_n$ such that $\\frac{win(1) + win(2) + \\dots + win(n)}{n}$ is maximum possible.\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nNext $t$ lines contain test cases\u00a0\u2014 one per line. The first and only line of each test case contains string $s = s_1 s_2 \\dots s_{n}$ ($1 \\le n \\le 2 \\cdot 10^5$; $s_i \\in \\{\\text{R}, \\text{S}, \\text{P}\\}$)\u00a0\u2014 the string of the bot.\n\nIt's guaranteed that the total length of all strings in one test doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, print $n$ choices $c_1 c_2 \\dots c_n$ to maximize the average number of wins. Print them in the same manner as the string $s$.\n\nIf there are multiple optimal answers, print any of them.\n\n\n-----Example-----\nInput\n3\nRRRR\nRSP\nS\n\nOutput\nPPPP\nRSP\nR\n\n\n-----Note-----\n\nIn the first test case, the bot (wherever it starts) will always choose \"Rock\", so we can always choose \"Paper\". So, in any case, we will win all $n = 4$ rounds, so the average is also equal to $4$.\n\nIn the second test case:   if bot will start from $pos = 1$, then $(s_1, c_1)$ is draw, $(s_2, c_2)$ is draw and $(s_3, c_3)$ is draw, so $win(1) = 0$;  if bot will start from $pos = 2$, then $(s_2, c_1)$ is win, $(s_3, c_2)$ is win and $(s_1, c_3)$ is win, so $win(2) = 3$;  if bot will start from $pos = 3$, then $(s_3, c_1)$ is lose, $(s_1, c_2)$ is lose and $(s_2, c_3)$ is lose, so $win(3) = 0$;  The average is equal to $\\frac{0 + 3 + 0}{3} = 1$ and it can be proven that it's the maximum possible average.\n\nA picture from Wikipedia explaining \"Rock paper scissors\" game:  $\\beta$", "solutions": "[\"#\\n#    ------------------------------------------------\\n#           ____          _     Generatered using\\n#          / ___|        | |\\n#         | |    __ _  __| | ___ _ __  ______ _\\n#         | |   / _` |/ _` |/ _ \\\\ '_ \\\\|_  / _` |\\n#         | |__| (_| | (_| |  __/ | | |/ / (_| |\\n#          \\\\____\\\\____|\\\\____|\\\\___|_| |_/___\\\\____|\\n#\\n#      GNU Affero General Public License v3.0\\n#    ------------------------------------------------\\n#    Author   : prophet\\n#    Created  : 2020-07-12 11:19:01.523119\\n#    UUID     : aXsU7xuXyjk3Ky2f\\n#    ------------------------------------------------\\n#\\nproduction = True\\n\\nimport sys, math, collections\\n\\ndef input(input_format = 0, multi = 0):\\n\\n    if multi > 0: return [input(input_format) for i in range(multi)]\\n    else:\\n        next_line = sys.stdin.readline()[:-1]\\n\\n        if input_format >= 10:\\n            use_list = False\\n            input_format = int(str(input_format)[-1])\\n        else: use_list = True\\n\\n        if input_format == 0: formatted_input = [next_line]\\n        elif input_format == 1: formatted_input = list(map(int, next_line.split()))\\n        elif input_format == 2: formatted_input = list(map(float, next_line.split()))\\n        elif input_format == 3: formatted_input = list(next_line)\\n        elif input_format == 4: formatted_input = list(map(int, list(next_line)))\\n        elif input_format == 5: formatted_input = next_line.split()\\n        else: formatted_input = [next_line]\\n\\n        return formatted_input if use_list else formatted_input[0]\\n\\ndef out(output_line, output_format = 0, newline = True):\\n\\n    formatted_output = \\\"\\\"\\n\\n    if output_format == 0: formatted_output = str(output_line)\\n    elif output_format == 1: formatted_output = \\\" \\\".join(map(str, output_line))\\n    elif output_format == 2: formatted_output = \\\"\\\\n\\\".join(map(str, output_line))\\n\\n    print(formatted_output, end = \\\"\\\\n\\\" if newline else \\\"\\\")\\n\\ndef log(*args):\\n    if not production:\\n        print(\\\"$$$\\\", end = \\\"\\\")\\n        print(*args)\\n\\nenu = enumerate\\n\\nter = lambda a, b, c: b if a else c\\n\\nceil = lambda a, b: -(-a // b)\\n\\ndef mapl(iterable, format = 0):\\n    \\n    if format == 0: return list(map(int, iterable))\\n    elif format == 1: return list(map(str, iterable))\\n    elif format == 2: return list(map(list, iterable))\\n#\\n#   >>>>>>>>>>>>>>> START OF SOLUTION <<<<<<<<<<<<<<\\n#\\n\\n\\ndef solve():\\n\\n    s = input(3)\\n\\n    u = [0] * 3\\n\\n    for i in s:\\n        if i == \\\"R\\\":\\n            u[0] += 1\\n        elif i == \\\"P\\\":\\n            u[1] += 1\\n        elif i == \\\"S\\\":\\n            u[2] += 1\\n\\n    log(u)\\n    y = 0\\n    p = 0\\n\\n    for i, j in enu(u):\\n        if j > y:\\n            y = j\\n            p = i\\n\\n    if p == 0:\\n        a = \\\"P\\\"\\n    elif p == 1:\\n        a = \\\"S\\\"\\n    elif p == 2:\\n        a = \\\"R\\\"\\n\\n    out(a * len(s))\\n\\n    return\\n\\n\\nfor i in range(input(11)): solve()\\n# solve()\\n\\n#\\n#   >>>>>>>>>>>>>>>> END OF SOLUTION <<<<<<<<<<<<<<<\\n#\\n\", \"# import sys\\nfrom collections import Counter\\n# input = sys.stdin.readline\\n\\n# T = int(input())\\n\\n# for t in range(T):\\n#     s = input()\\n#     pos = set(range(len(s)))\\n\\n#     answer = ['']\\n\\n#     for i in range(len(s)):\\n#         lets = [s[k] for k in pos]\\n#         if not pos:\\n#             break\\n#         cc = Counter(lets)\\n#         fl = cc.most_common()[0][0]\\n#         choice = ''\\n#         if fl == 'R':\\n#             choice = 'P'\\n#         elif fl == 'S':\\n#             choice = 'R'\\n#         else:\\n#             choice = 'S'\\n#         answer.append(choice)\\n#         next_pos = set()\\n#         for p in pos:\\n#             if s[p] == choice:\\n#                 np = p+1\\n#                 if np >= len(s):\\n#                     np = 0\\n#                 next_pos.add(np)\\n#         pos = next_pos\\n\\n#     while len(answer) < len(s):\\n#         answer.append('R')\\n\\n#     print(''.join(answer))\\n\\nT = int(input())\\n\\nfor t in range(T):\\n    s = input()\\n    cc = Counter(s)\\n    fl = cc.most_common()[0][0]\\n    if fl == 'R':\\n        choice = 'P'\\n    elif fl == 'S':\\n        choice = 'R'\\n    else:\\n        choice = 'S'\\n    print(choice*len(s))\\n\", \"T = int(input())\\nfor _ in range(T):\\n    s = input().strip()\\n    rc = 0\\n    sc = 0\\n    pc = 0\\n    for c in s:\\n        if c == 'R':\\n            rc += 1\\n        elif c == 'S':\\n            sc += 1\\n        else:\\n            pc += 1\\n    if rc == max(rc,sc,pc):\\n        print('P'*len(s))\\n    elif sc == max(rc,sc,pc):\\n        print('R'*len(s))\\n    else:\\n        print('S'*len(s))\\n\", \"\\nt=int(input())\\nfor you in range(t):\\n    s=input()\\n    n=len(s)\\n    numofr=0\\n    numofs=0\\n    numofp=0\\n    for i in s:\\n        if(i=='R'):\\n            numofr+=1\\n        elif(i=='S'):\\n            numofs+=1\\n        else:\\n            numofp+=1\\n    z=max(numofr,numofp,numofs)\\n    if(z==numofr):\\n        print('P'*n)\\n    elif(z==numofs):\\n        print('R'*n)\\n    else:\\n        print('S'*n)\", \"import sys\\nimport math\\nimport collections\\nimport heapq\\n\\ndef set_debug(debug_mode=False):\\n    if debug_mode:\\n        fin = open('input.txt', 'r')\\n        sys.stdin = fin\\n\\n\\ndef int_input():\\n    return list(map(int, input().split()))\\n\\n\\ndef __starting_point():\\n    # set_debug(True)\\n\\n    t = int(input())\\n    # t = 1\\n\\n    for ti in range(1, t + 1):\\n        # n = int(input())\\n        s = input()\\n\\n        c = collections.Counter(s)\\n        m = max(c['R'], c['S'], c['P'])\\n\\n        if m == c['R']:\\n            print('P' * len(s))\\n        elif m == c['S']:\\n            print('R' * len(s))\\n        else:\\n            print('S' * len(s))\\n\\n__starting_point()\", \"t = int(input())\\nfor _ in range(t):\\n    s = input()\\n    n = len(s)\\n    cnt_r = s.count(\\\"R\\\")\\n    cnt_s = s.count(\\\"S\\\")\\n    cnt_p = s.count(\\\"P\\\")\\n    max_cnt = max(cnt_r, cnt_s, cnt_p)\\n\\n    if max_cnt == cnt_r:\\n        print(\\\"P\\\" * n)\\n    elif max_cnt == cnt_s:\\n        print(\\\"R\\\" * n)\\n    else:\\n        print(\\\"S\\\" * n)\", \"for _ in range(int(input())):\\n\\ts = input()\\n\\td = dict()\\n\\td['R'] = 0\\n\\td['S'] = 0\\n\\td['P'] = 0\\n\\td1 = dict()\\n\\td1['R'] = 'P'\\n\\td1['S'] = 'R'\\n\\td1['P'] = 'S'\\n\\tfor i in s:\\n\\t\\td[i] += 1\\n\\tans = ''\\n\\tc = ''\\n\\tmx = -1\\n\\tfor i in list(d.items()):\\n\\t\\tif mx < i[1]:\\n\\t\\t\\tc = d1[i[0]]\\n\\t\\t\\tmx = i[1]\\n\\tprint(c * len(s))\\n\", \"import sys\\n\\nt = int(sys.stdin.readline().strip())\\nfor _ in range(t):\\n\\ts = sys.stdin.readline().strip()\\n\\tx, y, z = s.count('R'), s.count('S'), s.count('P')\\n\\tif max(x, y, z) == x:\\n\\t\\tprint('P'*len(s))\\n\\telif max(x, y, z) == y:\\n\\t\\tprint('R'*len(s))\\n\\telse:\\n\\t\\tprint('S'*len(s))\", \"#!/usr/bin/env python3\\n\\nfrom collections import Counter\\n\\ndef ans(S):\\n\\tfreqs = Counter(S)\\n\\targ_max = max(freqs, key=freqs.get)\\n\\td = {\\n\\t\\t'R': 'P',\\n\\t\\t'P': 'S',\\n\\t\\t'S': 'R'\\n\\t}\\n\\treturn d[arg_max]*len(S)\\n\\nT = int(input())\\nfor t in range(T):\\n\\tS = input()\\n\\tprint(ans(S))\\n\", \"t=int(input())\\nfor _ in range(t):\\n  s=input()\\n  rcount=0\\n  pcount=0\\n  scount=0\\n  for i in range(len(s)):\\n    if s[i]=='R':\\n      rcount+=1\\n    if s[i]=='S':\\n      scount+=1\\n    if s[i]=='P':\\n      pcount+=1\\n  ans=[]\\n  if rcount>=pcount and rcount>=scount:\\n    for i in range(len(s)):\\n      ans.append('P')\\n  elif scount>=pcount and scount>=rcount:\\n    for i in range(len(s)):\\n      ans.append('R')\\n  else:\\n    for i in range(len(s)):\\n      ans.append('S')\\n  print(''.join(ans))\", \"import sys\\nimport math\\ndef II():\\n\\treturn int(sys.stdin.readline())\\n\\ndef LI():\\n\\treturn list(map(int, sys.stdin.readline().split()))\\n\\ndef MI():\\n\\treturn map(int, sys.stdin.readline().split())\\n\\ndef SI():\\n\\treturn sys.stdin.readline().strip()\\nt = II()\\nfor q in range(t):\\n\\ts = SI()\\n\\tans = \\\"\\\"\\n\\td = {\\\"R\\\":\\\"P\\\",\\\"S\\\":\\\"R\\\",\\\"P\\\":\\\"S\\\"}\\n\\tm = 0\\n\\tif s.count(\\\"R\\\")>m:\\n\\t\\tm = s.count(\\\"R\\\")\\n\\t\\tans = \\\"R\\\"\\n\\tif s.count(\\\"S\\\")>m:\\n\\t\\tm = s.count(\\\"S\\\")\\n\\t\\tans = \\\"S\\\"\\n\\tif s.count(\\\"P\\\")>m:\\n\\t\\tans = \\\"P\\\"\\n\\tans = d[ans]\\n\\tprint(ans*len(s))\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\nRRRR\\nRSP\\nS\\n\"\n  ],\n  \"outputs\": [\n    \"PPPP\\nPPP\\nR\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1380/B", "starter_code": ""}
{"id": 47, "question": "This is the easy version of the problem. The difference between the versions is that the easy version has no swap operations. You can make hacks only if all versions of the problem are solved.\n\nPikachu is a cute and friendly pok\u00e9mon living in the wild pikachu herd.\n\nBut it has become known recently that infamous team R wanted to steal all these pok\u00e9mon! Pok\u00e9mon trainer Andrew decided to help Pikachu to build a pok\u00e9mon army to resist.\n\nFirst, Andrew counted all the pok\u00e9mon\u00a0\u2014 there were exactly $n$ pikachu. The strength of the $i$-th pok\u00e9mon is equal to $a_i$, and all these numbers are distinct.\n\nAs an army, Andrew can choose any non-empty subsequence of pokemons. In other words, Andrew chooses some array $b$ from $k$ indices such that $1 \\le b_1 < b_2 < \\dots < b_k \\le n$, and his army will consist of pok\u00e9mons with forces $a_{b_1}, a_{b_2}, \\dots, a_{b_k}$.\n\nThe strength of the army is equal to the alternating sum of elements of the subsequence; that is, $a_{b_1} - a_{b_2} + a_{b_3} - a_{b_4} + \\dots$.\n\nAndrew is experimenting with pok\u00e9mon order. He performs $q$ operations. In $i$-th operation Andrew swaps $l_i$-th and $r_i$-th pok\u00e9mon.\n\nNote: $q=0$ in this version of the task.\n\nAndrew wants to know the maximal stregth of the army he can achieve with the initial pok\u00e9mon placement. He also needs to know the maximal strength after each operation.\n\nHelp Andrew and the pok\u00e9mon, or team R will realize their tricky plan!\n\n\n-----Input-----\n\nEach test contains multiple test cases.\n\nThe first line contains one positive integer $t$ ($1 \\le t \\le 10^3$) denoting the number of test cases. Description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $q$ ($1 \\le n \\le 3 \\cdot 10^5, q = 0$) denoting the number of pok\u00e9mon and number of operations respectively.\n\nThe second line contains $n$ distinct positive integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$) denoting the strengths of the pok\u00e9mon.\n\n$i$-th of the last $q$ lines contains two positive integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le n$) denoting the indices of pok\u00e9mon that were swapped in the $i$-th operation.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$, and the sum of $q$ over all test cases does not exceed $3 \\cdot 10^5$. \n\n\n-----Output-----\n\nFor each test case, print $q+1$ integers: the maximal strength of army before the swaps and after each swap.\n\n\n-----Example-----\nInput\n3\n3 0\n1 3 2\n2 0\n1 2\n7 0\n1 2 5 4 3 6 7\n\nOutput\n3\n2\n9\n\n\n\n-----Note-----\n\nIn third test case we can build an army in such way: [1 2 5 4 3 6 7], its strength will be $5\u22123+7=9$.", "solutions": "[\"import sys\\ninput = sys.stdin.readline\\nfrom bisect import bisect_right\\n\\nbin_s = [1]\\nwhile bin_s[-1] <= 10 ** 9:\\n    bin_s.append(bin_s[-1] * 2)\\n\\n\\ndef main():\\n    n, q = map(int, input().split())\\n    alst = list(map(int, input().split()))\\n    dp = [[-1, -1] for _ in range(n)]\\n    dp[0] = [alst[0], 0]\\n    for i, a in enumerate(alst[1:], start = 1):\\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + a)\\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - a)\\n    print(max(dp[-1]))\\n    \\n\\nfor _ in range(int(input())):\\n    main()\", \"for i in range(int(input())):\\n\\tn, q = list(map(int, input().split()))\\n\\ta = list(map(int, input().split()))\\n\\ttot = 0\\n\\tsmall = 400000\\n\\tbig = 0\\n\\tgoingUp = True\\n\\tfor i, val in enumerate(a):\\n\\t\\tif goingUp:\\n\\t\\t\\tif val > big:\\n\\t\\t\\t\\tbig = val\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttot += big\\n\\t\\t\\t\\tgoingUp = False\\n\\t\\t\\t\\tsmall = val\\n\\t\\telse:\\n\\t\\t\\tif val < small:\\n\\t\\t\\t\\tsmall = val\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttot -= small\\n\\t\\t\\t\\tgoingUp = True\\n\\t\\t\\t\\tbig = val\\n\\tif goingUp:\\n\\t\\ttot += big\\n\\tprint(tot)\", \"import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\n\\nfor tests in range(t):\\n    n,q=list(map(int,input().split()))\\n    A=list(map(int,input().split()))\\n    #Q=[tuple(map(int,input().split())) for i in range(q)]\\n\\n    DP0=[0]*n\\n    DP1=[0]*n\\n\\n    for i in range(n):\\n        DP0[i]=max(DP0[i-1],DP1[i-1]+A[i])\\n        DP1[i]=max(DP1[i-1],DP0[i-1]-A[i])\\n\\n    #print(DP0)\\n    #print(DP1)\\n\\n    print(DP0[-1])\\n    \\n\\n    \\n\", \"import sys\\ninput = sys.stdin.readline\\nfor nt in range(int(input())):\\n\\tn,q = map(int,input().split())\\n\\ta = list(map(int,input().split()))\\n\\tif n==1:\\n\\t\\tprint (a[0])\\n\\t\\tcontinue\\n\\tdp = [[0,0] for i in range(n)]\\n\\tdp[0][0] = a[0]\\n\\tdp[1][0] = max(a[0],a[1])\\n\\tdp[1][1] = max(0,a[0]-a[1])\\n\\tfor i in range(2,n):\\n\\t\\tdp[i][0] = max(dp[i-1][0],dp[i-1][1]+a[i])\\n\\t\\tdp[i][1] = max(dp[i-1][1],dp[i-1][0]-a[i])\\n\\tprint (max(dp[-1][0],dp[-1][1]))\", \"t = int(input())\\n\\nfor _ in range(t):\\n    n, q = list(map(int, input().split()))\\n    \\n    a = list(map(int, input().split()))\\n    \\n    best_p = best_m = 0\\n    \\n    for x in a:\\n        best_p = max(best_p, best_m - x)\\n        best_m = max(best_m, best_p + x)\\n        \\n    print(max(best_p, best_m))\\n\", \"from sys import stdin\\n\\ntt = int(stdin.readline())\\n\\nfor loop in range(tt):\\n\\n    n,q = map(int,stdin.readline().split())\\n    a   = list(map(int,stdin.readline().split()))\\n\\n    dp = [0,float(\\\"-inf\\\")]\\n\\n    for i in range(n):\\n        \\n        ndp = [dp[0],dp[1]]\\n        ndp[0] = max(ndp[0] , dp[1]-a[i])\\n        ndp[1] = max(ndp[1] , dp[0]+a[i])\\n        dp = ndp\\n\\n    print (max(dp))\", \"INF = 10 ** 15\\n\\nfor _ in range(int(input())):\\n    n, q = tuple(map(int, input().split()))\\n    arr = list(map(int, input().split()))\\n\\n    a = -INF\\n    b = 0\\n    for i in arr:\\n        if a == -INF:\\n            c = 0\\n            d = i\\n        else:\\n            c = b - i\\n            d = a + i\\n        a, b = max(a, c), max(b, d)\\n\\n    print(max(a, b))\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n3 0\\n1 3 2\\n2 0\\n1 2\\n7 0\\n1 2 5 4 3 6 7\\n\"\n  ],\n  \"outputs\": [\n    \"3\\n2\\n9\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1420/C1", "starter_code": ""}
{"id": 48, "question": "You are playing a very popular game called Cubecraft. Initially, you have one stick and want to craft $k$ torches. One torch can be crafted using one stick and one coal.\n\nHopefully, you've met a very handsome wandering trader who has two trade offers:  exchange $1$ stick for $x$ sticks (you lose $1$ stick and gain $x$ sticks).  exchange $y$ sticks for $1$ coal (you lose $y$ sticks and gain $1$ coal). \n\nDuring one trade, you can use only one of these two trade offers. You can use each trade offer any number of times you want to, in any order.\n\nYour task is to find the minimum number of trades you need to craft at least $k$ torches. The answer always exists under the given constraints.\n\nYou have to answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 2 \\cdot 10^4$) \u2014 the number of test cases. Then $t$ test cases follow.\n\nThe only line of the test case contains three integers $x$, $y$ and $k$ ($2 \\le x \\le 10^9$; $1 \\le y, k \\le 10^9$) \u2014 the number of sticks you can buy with one stick, the number of sticks required to buy one coal and the number of torches you need, respectively.\n\n\n-----Output-----\n\nFor each test case, print the answer: the minimum number of trades you need to craft at least $k$ torches. The answer always exists under the given constraints.\n\n\n-----Example-----\nInput\n5\n2 1 5\n42 13 24\n12 11 12\n1000000000 1000000000 1000000000\n2 1000000000 1000000000\n\nOutput\n14\n33\n25\n2000000003\n1000000001999999999", "solutions": "[\"for haaghfj in range(int(input())):\\n    x,y,k = list(map(int,input().split()))\\n    print(k + (y * k + k - 1 +x-2) // (x - 1))\\n\", \"import sys\\nimport math\\nimport collections\\nimport bisect\\nimport itertools\\nimport decimal\\nimport copy\\nimport heapq\\n\\n# import numpy as np\\n\\n# sys.setrecursionlimit(10 ** 6)\\nINF = 10 ** 20\\nMOD = 10 ** 9 + 7\\n# MOD = 998244353\\n\\nni = lambda: int(sys.stdin.readline().rstrip())\\nns = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\\nna = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\\nna1 = lambda: list([int(x) - 1 for x in sys.stdin.readline().rstrip().split()])\\nflush = lambda: sys.stdout.flush()\\n\\n\\n# ===CODE===\\ndef main():\\n    t = ni()\\n\\n    for _ in range(t):\\n        x, y, k = ns()\\n        ans = k\\n        total = k + k * y - 1\\n\\n        ans += -(-total // (x - 1))\\n        print(ans)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"for _ in range(int(input())):\\n    x, y, k = [int(s) for s in input().split()]\\n    n = ((y + 1) * k - 1 + (x - 2)) // (x - 1)\\n    print(n + k)\\n\", \"q = int(input())\\nfor t in range(q):\\n    x, y, k = list(map(int, input().split()))\\n    a = ((y + 1) * k - 1 + x - 1 - 1) // (x - 1)\\n    b = k\\n    print(a + b)\\n\", \"t = int(input())\\n\\nfor i in range(t):\\n    x, y, k = list(map(int, input().split()))\\n\\n    a = (y + 1) * k - 1\\n\\n    # print(a)\\n\\n    print((a - 1) // (x - 1) + 1 + k)\\n\", \"from collections import defaultdict\\nfrom queue import deque\\n\\n\\ndef arrinp():\\n    return [*list(map(int, input().split(' ')))]\\n\\n\\ndef mulinp():\\n    return list(map(int, input().split(' ')))\\n\\n\\ndef intinp():\\n    return int(input())\\n\\n\\ndef solution():\\n    x,y,k = mulinp()\\n    num = y*k + k\\n    ans = (num-1)//(x-1)\\n    if (num-1)%(x-1) != 0:\\n        ans += 1\\n    ans += k\\n    print(ans)\\n\\n\\ntestcases = 1\\ntestcases = int(input())\\nfor _ in range(testcases):\\n    solution()\\n\", \"t=int(input())\\nfor i in range(t):\\n    z=list(map(int, input().split()))\\n    x=z[0]\\n    y=z[1]\\n    k=z[2]\\n    palok=k*y+k-1\\n    ans=0\\n    ans=palok//(x-1)\\n    if palok%(x-1)!=0:\\n        ans+=1\\n    print(ans+k)\\n\", \"tests = int(input())\\nfor test in range(tests):\\n    a = 1\\n    x, y, k = list(map(int, input().split()))\\n    a1 = (k * (y + 1) - 1 + x - 2) // (x - 1)\\n    print(a1 + k)\\n\", \"t = int(input())\\nfor _ in range(t):\\n    x, y, k = map(int, input().split())\\n    n = (k * (y + 1) - 1 + (x - 2)) // (x - 1)\\n    print(n + k)\", \"for _ in range(int(input())):\\n    x, y, k = map(int, input().split())\\n\\n    print((k*y+k-1+x-2)//(x-1)+k)\", \"from math import ceil\\n\\n\\ndef read_int():\\n    return int(input())\\n\\n\\ndef read_ints():\\n    return list(map(int, input().split(' ')))\\n\\n\\nt = read_int()\\nfor case_num in range(t):\\n    x, y, k = read_ints()\\n    a = (k * (y + 1) - 2) // (x - 1) + 1 + k\\n    print(a)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nfor _ in range(int(input())):\\n    x, y, k = [int(i) for i in input().split()]\\n    \\n    stick_need = k+k*y-1\\n    \\n    num_stick_trade = (stick_need+x-2)//(x-1)\\n\\n    \\n    print(num_stick_trade+k)\", \"for _ in range(int(input())):\\n\\tx,y,k=map(int,input().split()) \\n\\ta=(y+1)*k-1 \\n\\tb=x-1 \\n\\tif a%b==0:\\n\\t\\tc=a//b\\n\\telse:\\n\\t\\tc=a//b+1 \\n\\tprint(c+k)\", \"import sys\\n\\nsys.setrecursionlimit(10**5)\\nint1 = lambda x: int(x)-1\\np2D = lambda x: print(*x, sep=\\\"\\\\n\\\")\\ndef II(): return int(sys.stdin.readline())\\ndef MI(): return map(int, sys.stdin.readline().split())\\ndef LI(): return list(map(int, sys.stdin.readline().split()))\\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\\ndef SI(): return sys.stdin.readline()[:-1]\\n\\nfor _ in range(II()):\\n    x,y,k=MI()\\n    a=(k*(y+1)-1+x-2)//(x-1)\\n    print(a+k)\\n\", \"import sys\\n\\ndef minp():\\n\\treturn sys.stdin.readline().strip()\\n\\ndef mint():\\n\\treturn int(minp())\\n\\ndef mints():\\n\\treturn list(map(int, minp().split()))\\n\\ndef solve():\\n\\tx, y, k = mints()\\n\\tta = k*(y+1)\\n\\td = ((ta-1)+(x-2))//(x-1)\\n\\tprint(d+k)\\n\\nfor i in range(mint()):\\n\\tsolve()\\n\", \"#!/usr/bin/env python3\\nimport sys\\ninput = sys.stdin.readline\\n\\nt = int(input())\\nfor i in range(t):\\n    x, y, k = map(int, input().split())\\n    needed = k + y * k\\n    trades = ((needed - 1) + (x - 2)) // (x - 1)\\n    trades += k\\n    print(trades)\", \"t = int(input())\\n\\nfor ii in range(t):\\n\\n\\tx, y, k = map(int, input().split())\\n\\n\\tcoals = k\\n\\tsticks = k\\n\\n\\tsticks = k*y + k\\n\\n\\tnum = (sticks-1)//(x-1)\\n\\n\\tif (sticks-1)%(x-1) != 0:\\n\\t\\tnum+=1\\n\\n\\tnum += k\\n\\n\\tprint(num)\"]", "input_output": "{\n  \"inputs\": [\n    \"5\\n2 1 5\\n42 13 24\\n12 11 12\\n1000000000 1000000000 1000000000\\n2 1000000000 1000000000\\n\"\n  ],\n  \"outputs\": [\n    \"14\\n33\\n25\\n2000000003\\n1000000001999999999\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1418/A", "starter_code": ""}
{"id": 49, "question": "Let's call some positive integer classy if its decimal representation contains no more than $3$ non-zero digits. For example, numbers $4$, $200000$, $10203$ are classy and numbers $4231$, $102306$, $7277420000$ are not.\n\nYou are given a segment $[L; R]$. Count the number of classy integers $x$ such that $L \\le x \\le R$.\n\nEach testcase contains several segments, for each of them you are required to solve the problem separately.\n\n\n-----Input-----\n\nThe first line contains a single integer $T$ ($1 \\le T \\le 10^4$) \u2014 the number of segments in a testcase.\n\nEach of the next $T$ lines contains two integers $L_i$ and $R_i$ ($1 \\le L_i \\le R_i \\le 10^{18}$).\n\n\n-----Output-----\n\nPrint $T$ lines \u2014 the $i$-th line should contain the number of classy integers on a segment $[L_i; R_i]$.\n\n\n-----Example-----\nInput\n4\n1 1000\n1024 1024\n65536 65536\n999999 1000001\n\nOutput\n1000\n1\n0\n2", "solutions": "[\"\\nimport sys\\n#sys.stdin=open(\\\"data.txt\\\")\\ninput=sys.stdin.readline\\n\\n# this math tutorial is boring\\n\\nclassy=set()\\n\\nfor i in range(19):\\n    for j in range(i):\\n        for k in range(j):\\n            for a in range(10):     # a=0 for good measure\\n                for b in range(10):\\n                    for c in range(10):\\n                        what=a*10**i+b*10**j+c*10**k\\n                        classy.add(what)\\n\\nli=sorted(classy)\\n\\ndef counting(i):\\n    # return len([x for x in li if x <= i])+C\\n    lo=0\\n    hi=len(li)-1\\n    while lo<hi:\\n        mid=(lo+hi+1)//2\\n        if li[mid]<=i:\\n            lo=mid\\n        else:\\n            hi=mid-1\\n    return lo\\n\\nfor _ in range(int(input())):\\n    a,b=map(int,input().split())\\n    print(counting(b)-counting(a-1))\", \"#      \\nimport collections, atexit, math, sys, bisect \\n\\nsys.setrecursionlimit(1000000)\\ndef getIntList():\\n    return list(map(int, input().split()))    \\n\\ntry :\\n    #raise ModuleNotFoundError\\n    import numpy\\n    def dprint(*args, **kwargs):\\n        print(*args, **kwargs, file=sys.stderr)\\n    dprint('debug mode')\\nexcept ModuleNotFoundError:\\n    def dprint(*args, **kwargs):\\n        pass\\n\\n\\n\\ninId = 0\\noutId = 0\\nif inId>0:\\n    dprint('use input', inId)\\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\\u6807\\u51c6\\u8f93\\u51fa\\u91cd\\u5b9a\\u5411\\u81f3\\u6587\\u4ef6\\nif outId>0:\\n    dprint('use output', outId)\\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\\u6807\\u51c6\\u8f93\\u51fa\\u91cd\\u5b9a\\u5411\\u81f3\\u6587\\u4ef6\\n    atexit.register(lambda :sys.stdout.close())     #idle \\u4e2d\\u4e0d\\u4f1a\\u6267\\u884c atexit\\n    \\nN, = getIntList()\\ndef memo(func):  \\n    cache={}  \\n    def wrap(*args):  \\n        if args not in cache:  \\n            cache[args]=func(*args)  \\n        return cache[args]  \\n    return wrap\\n\\n@memo\\ndef comb (n,k):\\n    if k>n: return 0    \\n    if k==0: return 1\\n    if n==k: return 1\\n    return comb(n-1,k-1) + comb(n-1,k)\\ndef getclam(K, left = 3):\\n    if K==0: return 1\\n    if left ==0: return 1\\n    s = str(K)\\n    l = len(s)\\n\\n    r = 0\\n    x = int(s[0])\\n    if l>1:\\n        for i in range(left+1):\\n            r += comb(l-1,i) * 9 ** i\\n        if x>0:\\n            for i in range(left):\\n                r += comb(l-1,i) * 9 ** i * (x-1)\\n        s1 = s[1:]\\n        y = 0\\n        if s1:\\n            y = int(s1)\\n        if x!=0:\\n            left-=1\\n        r+= getclam( y, left)\\n        return r\\n    else:\\n        return x+1\\nfor i in range(1000, 1100):\\n    continue\\n    dprint(i, getclam(i))\\n\\nfor _ in range(N):\\n    L,R = getIntList()\\n    r = getclam(R) - getclam(L-1)\\n    print(r)\\n\\n\\n\\n\\n\\n\", \"USE_STDIO = False\\n\\nif not USE_STDIO:\\n    try: import mypc\\n    except: pass\\n\\ndef Cnk(n, k):\\n    ans = 1\\n    for i in range(k):\\n        ans *= n - i\\n        ans //= i + 1\\n    return ans\\n\\ndef main():\\n    num = [[0] * 4 for _ in range(19)]\\n    for i in range(19):\\n        for j in range(4):\\n            if j: num[i][j] += num[i][j-1]\\n            if i >= j:\\n                num[i][j] += 9 ** j * Cnk(i, j)\\n    \\n    def count(n):\\n        if n == 0: return 0\\n        n = list(map(int, str(n)))\\n        l = len(n)\\n        ans = 0\\n        for i in range(1, l):\\n            ans += 9 * num[i - 1][2]\\n        cur = 3\\n        for i in range(l):\\n            if n[i] > 0:\\n                ans += (n[i] - 1) * num[l - i - 1][cur - 1]\\n                if i: ans += num[l - i - 1][cur]\\n                cur -= 1\\n                if cur <= 0: break\\n        ans += 1\\n        return ans\\n\\n    q,  = list(map(int, input().split(' ')))\\n    for _ in range(q):\\n        L, R = list(map(int, input().split(' ')))\\n        ans = count(R) - count(L - 1)\\n        print(ans)\\n\\ndef __starting_point():\\n    main()\\n\\n\\n\\n\\n__starting_point()\", \"t = int(input())\\narr = []\\nfor i in range(1, 19):\\n    arr.append((i - 1) * (i - 2) // 2 * 9 * 9 * 9 + (i - 1) * 9 * 9 + 9)\\npref = [0]\\nfor i in arr:\\n    pref.append(pref[-1] + i)\\n\\ndef f(x):\\n    if x == 0:\\n        return 0\\n    s = str(x)\\n    n = len(s)\\n    ans = pref[n - 1]\\n    cnt = 0\\n    for i in range(n):\\n        a = int(s[i])\\n        if a != 0:\\n            if cnt == 0:\\n                ans += (a - 1) * (n - i - 1) * (n - i - 2) // 2 * 9 * 9 + (a - 1) * (n - i - 1) * 9 + (a - 1)\\n                cnt += 1\\n            elif cnt == 1:\\n                ans += (n - i - 1) * (n - i - 2) // 2 * 9 * 9 + (n - i - 1) * 9 + 1\\n                if a != 1:\\n                    ans += (a - 1) * (n - i - 1) * 9 + (a - 1)\\n                cnt += 1\\n            elif cnt == 2:\\n                ans += (n - i - 1) * 9 + 1\\n                if a != 1:\\n                    ans += (a - 1)\\n                cnt += 1\\n                break\\n    return ans + 1\\n            \\nfor i in range(t):\\n    l, r = map(int, input().split())\\n    l -= 1\\n    print(f(r) - f(l))    \\n\\n'''n = int(input())\\narr1 = list(map(int, input().split()))\\nm = int(input())\\narr2 = list(map(int, input().split()))\\n\\nl = 0\\nr = 0\\nif arr1[l] == arr2[r]\\n'''\\n'''\\nn, k = map(int, input().split())\\nprint((k + n - 1) // n)\\n'''\", \"def f(n):\\n    if n == 0:\\n        return 1\\n    dp = [[[0] * 2 for j in range(4)] for z in range(len(n))]\\n    dp[0][3][0] = 1\\n    dp[0][2][0] = int(n[0]) - 1\\n    dp[0][2][1] = 1\\n    for i in range(1, len(n)):\\n        for j in range(4):\\n            if n[i] == '0':\\n                dp[i][j][0] += dp[i - 1][j][0]\\n                dp[i][j][1] += dp[i - 1][j][1]\\n            else:\\n                dp[i][j][0] += dp[i - 1][j][0] + dp[i - 1][j][1]\\n            for z in range(1, 10):\\n                if z < int(n[i]):\\n                    if j < 3:\\n                        dp[i][j][0] += dp[i - 1][j + 1][0] + dp[i - 1][j + 1][1]\\n                elif z == int(n[i]):\\n                    if j < 3:\\n                        dp[i][j][0] += dp[i - 1][j + 1][0]\\n                        dp[i][j][1] += dp[i - 1][j + 1][1]\\n                else:\\n                    if j < 3:\\n                        dp[i][j][0] += dp[i - 1][j + 1][0]\\n\\n    res = 0\\n    for j in range(4):\\n        res += dp[len(n) - 1][j][0] + dp[len(n) - 1][j][1]\\n    return res\\n\\nt = int(input())\\nwhile t:\\n    t -= 1\\n    l, r = list(map(int, input().split()))\\n    print(f(str(r)) - f(str(l - 1)))\\n\", \"def f(n):\\n    if n == 0:\\n        return 1\\n    dp = [[[0] * 2 for j in range(4)] for z in range(len(n))]\\n    dp[0][3][0] = 1\\n    dp[0][2][0] = int(n[0]) - 1\\n    dp[0][2][1] = 1\\n    for i in range(1, len(n)):\\n        for j in range(4):\\n            if n[i] == '0':\\n                dp[i][j][0] += dp[i - 1][j][0]\\n                dp[i][j][1] += dp[i - 1][j][1]\\n            else:\\n                dp[i][j][0] += dp[i - 1][j][0] + dp[i - 1][j][1]\\n            if j >= 3:\\n                continue\\n            for z in range(1, 10):\\n                if z < int(n[i]):\\n                    dp[i][j][0] += dp[i - 1][j + 1][0] + dp[i - 1][j + 1][1]\\n                elif z == int(n[i]):\\n                    dp[i][j][0] += dp[i - 1][j + 1][0]\\n                    dp[i][j][1] += dp[i - 1][j + 1][1]\\n                else:\\n                    dp[i][j][0] += dp[i - 1][j + 1][0]\\n\\n    res = 0\\n    for j in range(4):\\n        res += dp[len(n) - 1][j][0] + dp[len(n) - 1][j][1]\\n    return res\\n\\nt = int(input())\\nwhile t:\\n    t -= 1\\n    l, r = list(map(int, input().split()))\\n    print(f(str(r)) - f(str(l - 1)))\\n\", \"def C(n, r):\\n    ret = 1\\n    for i in range(r):\\n        ret = ret * (n - i) // (i + 1);\\n    return ret\\n\\ndef f(N):\\n    N = [int(ch) for ch in reversed(str(N))]\\n    cnt, nonzero = 0, 0\\n    for k in range(len(N)-1, -1, -1):\\n        if N[k] > 0:\\n            for i in range(4 - nonzero):\\n                cnt += C(k, i) * pow(9, i)\\n            nonzero += 1\\n            for i in range(4 - nonzero):\\n                cnt += (N[k] - 1) * C(k, i) * pow(9, i)\\n        if nonzero > 3:\\n            break\\n    return cnt\\n\\nfor run in range(int(input())):\\n    l, r = list(map(int, input().split()))\\n    print(f(r+1) - f(l))\\n\", \"def C(n, r):\\n    ret = 1\\n    for i in range(r):\\n        ret = ret * (n - i) // (i + 1);\\n    return ret\\n\\ndef f(N):\\n    N = [int(ch) for ch in reversed(str(N))]\\n    cnt, nonzero = 0, 0\\n    for k in range(len(N)-1, -1, -1):\\n        if N[k] > 0:\\n            for i in range(4 - nonzero):\\n                cnt += C(k, i) * pow(9, i)\\n            nonzero += 1\\n            for i in range(4 - nonzero):\\n                cnt += (N[k] - 1) * C(k, i) * pow(9, i)\\n        if nonzero > 3:\\n            break\\n    return cnt\\n\\nfor run in range(int(input())):\\n    l, r = map(int, input().split())\\n    print(f(r+1) - f(l))\", \"def cnt(l, c):\\n    if l <= c:\\n        return 10**c\\n    res = 1\\n    if c > 0: res += l*9\\n    if c > 1: res += l*(l-1)*9*9//2\\n    if c > 2: res += l*(l-1)*(l-2)*9*9*9//6\\n    return res\\n\\ndef calc(n, c):\\n    x=str(n)\\n    xn = len(x)\\n    if xn <= c:\\n        return n+1\\n    res = cnt(xn-1, c)+1\\n    d = int(x[0])\\n    if d > 1:\\n        res += cnt(xn-1, c-1)*(d - 1)\\n    if c > 1:\\n        for i in range(1,xn):\\n            d = int(x[i])\\n            if d != 0:\\n                res += calc(int(x[i:]), c-1)-1\\n                break\\n    return res\\n\\\"\\\"\\\"ans=0\\nfor i in range(90000):\\n    s = str(i)\\n    if len(s)-s.count('0') < 3:\\n        ans+=1\\nprint(ans)\\\"\\\"\\\"\\n\\n#ans=calc(1000000,3) # 15850\\nt = int(input())\\nfor i in range(t):\\n    l,r = map(int, input().split())\\n    print(calc(r,3)-calc(l-1,3))\", \"from bisect import bisect_left as bl\\nc=[]\\ndef gen(n,nz):\\n    if len(n)>=19:\\n        return\\n    nonlocal c\\n    c.append(int(n))\\n    if nz==3:\\n        n+=\\\"0\\\"\\n        gen(n,nz)\\n        return\\n    gen(n+\\\"0\\\",nz)\\n    for i in (\\\"123456789\\\"):\\n        gen(n+i,nz+1)\\nfor i in (\\\"123456789\\\"):\\n    gen(i,1)\\nc.append(10**18)\\nc.sort()\\nn=int(input())\\nfor i in range(n):\\n    a,b=list(map(int,input().split()))\\n    x=min(bl(c,b),len(c)-1)\\n    y=bl(c,a)\\n    if x==y and b<c[x]:\\n        print(0)\\n    elif (c[x]==b and c[y]==a) or c[x]==b:\\n        print(x-y+1)\\n    else:\\n        print(x-y)\\n\\n        \\n\", \"import math\\ndef combi(L,n):\\n    return math.factorial(L)//math.factorial(n)//math.factorial(L-n)\\n\\n\\nT=int(input())\\nLR=[list(map(int,input().split())) for i in range(T)]\\n\\ndef classy(less,nonzero,now):\\n    L=len(str(now))\\n\\n    if less==0:\\n        if 3-nonzero>=L:\\n            return 10**L\\n        else:\\n            ANS=1\\n            for i in range(1,3-nonzero+1):\\n                ANS+=combi(L,i)*(9**i)\\n\\n            return ANS\\n\\n    else:\\n        if nonzero<=2:\\n            if now<=9:\\n                return now+1\\n            \\n            else:\\n                if int(str(now)[0])==1:\\n                    return classy(1,nonzero+1,int(str(now)[1:]))\\\\\\n                           +classy(0,nonzero,int(\\\"9\\\"*(L-1)))\\\\\\n\\n                else:\\n                    return classy(1,nonzero+1,int(str(now)[1:]))\\\\\\n                           +(int(str(now)[0])-1)*classy(0,nonzero+1,int(\\\"9\\\"*(L-1)))\\\\\\n                           +classy(0,nonzero,int(\\\"9\\\"*(L-1)))\\n\\n        else:\\n            return 1\\n\\nfor l,r in LR:\\n    print(classy(1,0,r)-classy(1,0,l-1))\\n\\n            \\n        \\n                          \\n        \\n    \\n    \\n\", \"import math\\ndef combi(L,n):\\n    return math.factorial(L)//math.factorial(n)//math.factorial(L-n)\\n\\n\\nT=int(input())\\nLR=[list(map(int,input().split())) for i in range(T)]\\n\\ndef classy(less,nonzero,now):\\n    L=len(str(now))\\n\\n    if less==0:\\n        if 3-nonzero>=L:\\n            return 10**L\\n        else:\\n            ANS=1\\n            for i in range(1,3-nonzero+1):\\n                ANS+=combi(L,i)*(9**i)\\n\\n            return ANS\\n\\n    else:\\n        if nonzero<=2:\\n            if now<=9:\\n                return now+1\\n            \\n            else:\\n                if int(str(now)[0])==1:\\n                    return classy(1,nonzero+1,int(str(now)[1:]))\\\\\\n                           +classy(0,nonzero,int(\\\"9\\\"*(L-1)))\\\\\\n\\n                else:\\n                    return classy(1,nonzero+1,int(str(now)[1:]))\\\\\\n                           +(int(str(now)[0])-1)*classy(0,nonzero+1,int(\\\"9\\\"*(L-1)))\\\\\\n                           +classy(0,nonzero,int(\\\"9\\\"*(L-1)))\\n\\n        else:\\n            return 1\\n\\nfor l,r in LR:\\n    print(classy(1,0,r)-classy(1,0,l-1))\\n\\n            \\n        \\n                          \\n        \\n    \\n    \\n\", \"\\ndp = [[-1]*20 for _ in range(5)]\\ndef dfs(pos, cnt, limited, dp, nums):\\n\\tif cnt > 3:\\n\\t\\treturn 0\\n\\tif pos == -1:\\n\\t\\treturn 1\\n\\tif not limited and dp[cnt][pos] != -1:\\n\\t\\treturn dp[cnt][pos]\\n\\tupper = nums[pos] if limited else 9\\n\\ttmp = 0\\n\\tfor i in range(upper + 1):\\n\\t\\ttmp += dfs(pos - 1, cnt + (i > 0), limited&(i==upper), dp, nums)\\n\\tif not limited:\\n\\t\\tdp[cnt][pos] = tmp\\n\\treturn tmp\\ndef classy(num):\\n\\tnums = []\\n\\twhile num:\\n\\t\\tnums.append(num % 10)\\n\\t\\tnum //= 10\\n\\t\\n\\treturn dfs(len(nums) - 1, 0, 1, dp, nums)\\n\\n\\ndef __starting_point():\\n\\tT = int(input())\\n\\tfor _ in range(T):\\n\\t\\tL, R = map(int, input().split())\\n\\t\\tprint(classy(R) - classy(L-1))\\n__starting_point()\", \"import sys\\nclass Solution():\\n    mem = dict()\\n\\n    def classy_Numbers(self):\\n        T = int(sys.stdin.readline().strip())\\n        self.queries = []\\n        for t in range(T):\\n            left, right = list(map(int, sys.stdin.readline().strip().split()))\\n            print(self.dp(right, 3) - self.dp(left-1, 3))\\n\\n    def dp(self, target, limit):\\n        num_digits = len(str(target))\\n        if (target, limit) in self.mem:\\n            return self.mem[(target, limit)]\\n        if limit == 0:\\n            return 1\\n        if num_digits <= limit:\\n            return target + 1\\n\\n        top_digit = target // (10 ** (num_digits-1))\\n        res = target % (10 ** (num_digits-1))\\n        ret = self.dp(res, limit-1) \\\\\\n                + max(top_digit-1, 0) * self.dp(10**(num_digits-1)-1, limit-1) \\\\\\n                + self.dp(10**(num_digits-1)-1, limit)\\n        self.mem[(target, limit)] = ret\\n        return ret\\n\\nsol = Solution()\\nsol.classy_Numbers()\\n# print(sol.dp(1, 3))\\n# print(sol.dp(1234, 4, 3))\\n# print(sol.dp(12345, 5, 3))\\n\", \"import math\\n\\ndef check(x):\\n    cnt = 0\\n    while(x):\\n        cnt = cnt + (x%10 != 0)\\n        x = math.floor(x/10)\\n    return cnt<=3\\n\\ndef bl(x):\\n    ans = 0\\n    for i in range(1,x+1):\\n        if check(i):\\n            ans = ans+1\\n    return ans\\n\\n\\ndef jc(x):\\n    sm = 1\\n    for i in range(1,x+1):\\n        sm = sm * i\\n    return sm\\n\\ndef c(x,y):\\n    if x<y:\\n        return 0\\n    return jc(x)/(jc(x-y)*jc(y))\\n\\ndef cal1(x,y):\\n    ans = 0\\n    for i in range(1,min(x,y)+1):\\n        ans = ans + c(x,i)*(9**i)\\n    return ans+1\\n\\ndef revers(x):\\n    ans = 0\\n    while(x):\\n        ans = ans*10+ x%10\\n        x = x.__floordiv__(10)\\n\\n    return ans\\n\\ndef cal2(x):\\n    rx = revers(x)\\n    ans = 0\\n    cnt = 0\\n    l = 0\\n    l_ = 0\\n    while(x):\\n        l = l+1\\n        x = x.__floordiv__(10)\\n\\n\\n    while(rx):\\n        now = rx % 10\\n        rx = rx.__floordiv__(10)\\n        l_ = l_ + 1\\n        if now!=0:\\n            cnt = cnt+1\\n        else:\\n            continue\\n        ans = ans + (now-1)*cal1(l-l_,3-cnt) + cal1(l-l_,3-cnt+1)\\n\\n        if cnt>=3:\\n            break\\n\\n    return ans\\n\\nT = int(input())\\nfor i in range(T):\\n\\n    x,y = list(map(int,input().split()))\\n\\n    print(int(cal2(y)-cal2(x-1)))\\n\", \"from itertools import combinations\\n\\nall_classy = []\\n\\ndef all_possible(a):\\n    if len(a) == 0:\\n        return [['0']*19]\\n    lower = all_possible(a[1:])\\n    ans = []\\n    for l in lower:\\n        for x in range(1, 10):\\n            this = l[:]\\n            this[a[0]] = str(x)\\n            ans.append(this)\\n    return ans\\n\\nfor i in range(1, 4):\\n    for a in combinations(range(19), i):\\n        this_possible = all_possible(a)\\n        this_possible = [int(''.join(x)) for x in this_possible]\\n        all_classy += this_possible\\n\\nall_classy.sort()\\n\\ndef ge(num):\\n    if num == 1:\\n        return 0\\n    lower, upper = 0, len(all_classy)\\n    while lower < upper - 1:\\n        mid = (lower+upper)>>1\\n        if(all_classy[mid] < num):\\n            lower = mid\\n        else:\\n            upper = mid\\n\\n    return upper\\n\\n\\ndef le(num):\\n    lower, upper = 0, len(all_classy)\\n    while lower < upper-1:\\n        mid = (lower+upper)>>1\\n        if all_classy[mid] > num:\\n            upper = mid\\n        else:\\n            lower = mid\\n\\n    return lower\\n\\nq = int(input())\\n\\nfor i in range(q):\\n    l, r = map(int, input().strip().split())\\n    x, y = ge(l), le(r)\\n    print(y-x+1)\", \"import sys\\n\\nMAX_N = 20\\nMAX_DIG = 3\\ndp = [[0] * (MAX_DIG + 1) for i in range(MAX_N)]\\n\\ndef calc_dp():\\n    dp[0][0] = 1\\n    for i in range(1, MAX_N):\\n        dp[i][0] = 1\\n        for j in range(MAX_DIG):\\n            dp[i][j + 1] += 9 * dp[i - 1][j]\\n            dp[i][j + 1] += dp[i - 1][j + 1]\\n\\ndef first_dig(n):\\n    cnt = 0\\n    while n >= 10:\\n        n //= 10\\n        cnt += 1\\n    return n, cnt\\n\\ndef calc_ans(n):\\n    ans = 0\\n    for n_digs in range(MAX_DIG, -1, -1):\\n        x, cnt = first_dig(n)\\n        for i in range(n_digs):\\n            ans += x * dp[cnt][i]\\n        ans += dp[cnt][n_digs]\\n        n -= x * 10 ** cnt\\n    return ans\\n\\ndef main():\\n    calc_dp()\\n    T = int(input())\\n    for _ in range(T):\\n        l, r = map(int, input().split())\\n        print(calc_ans(r) - calc_ans(l - 1) if l > 0 else 0)\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"import sys\\n\\nMAX_N = 20\\nMAX_DIG = 3\\ndp = [[0] * (MAX_DIG + 1) for i in range(MAX_N)]\\n\\ndef calc_dp():\\n    dp[0][0] = 1\\n    for i in range(1, MAX_N):\\n        dp[i][0] = 1\\n        for j in range(MAX_DIG):\\n            dp[i][j + 1] += 9 * dp[i - 1][j]\\n            dp[i][j + 1] += dp[i - 1][j + 1]\\n\\ndef first_dig(n):\\n    cnt = 0\\n    while n >= 10:\\n        n //= 10\\n        cnt += 1\\n    return n, cnt\\n\\ndef calc_ans(n):\\n    ans = 0\\n    for n_digs in range(MAX_DIG, -1, -1):\\n        x, cnt = first_dig(n)\\n        for i in range(n_digs):\\n            ans += x * dp[cnt][i]\\n        ans += dp[cnt][n_digs]\\n        n -= x * 10 ** cnt\\n    return ans\\n\\ndef main():\\n    calc_dp()\\n    T = int(input())\\n    for _ in range(T):\\n        l, r = map(int, input().split())\\n        print(calc_ans(r) - calc_ans(l - 1) if l > 0 else 0)\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"import sys\\n\\nMAX_N = 20\\nMAX_DIG = 3\\ndp = [[0] * (MAX_DIG + 1) for i in range(MAX_N)]\\n\\ndef calc_dp():\\n    dp[0][0] = 1\\n    for i in range(1, MAX_N):\\n        dp[i][0] = 1\\n        for j in range(MAX_DIG):\\n            dp[i][j + 1] += 9 * dp[i - 1][j]\\n            dp[i][j + 1] += dp[i - 1][j + 1]\\n\\ndef first_dig(n):\\n    cnt = 0\\n    while n >= 10:\\n        n //= 10\\n        cnt += 1\\n    return n, cnt\\n\\ndef calc_ans(n):\\n    ans = 0\\n    for n_digs in range(MAX_DIG, -1, -1):\\n        x, cnt = first_dig(n)\\n        for i in range(n_digs):\\n            ans += x * dp[cnt][i]\\n        ans += dp[cnt][n_digs]\\n        n -= x * 10 ** cnt\\n    return ans\\n\\ndef main():\\n    calc_dp()\\n    T = int(input())\\n    for _ in range(T):\\n        l, r = map(int, input().split())\\n        print(calc_ans(r) - calc_ans(l - 1))\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"com = [[0]*19 for i in range(19)]\\n\\n\\ndef solve(x):\\n    sx, non_zero, res = str(x), 3, 0\\n\\n    for i in range(len(sx)):\\n        if not int(sx[i]):\\n            continue\\n\\n        for j in range(0, non_zero+1):\\n            res += com[len(sx)-i-1][j] * 9 ** j\\n\\n        non_zero -= 1\\n\\n        if non_zero == -1:\\n            break\\n\\n        for j in range(0, non_zero+1):\\n            res += (int(sx[i])-1) * com[len(sx)-i-1][j] * 9 ** j\\n\\n    return res\\n\\n\\ndef main():\\n    t = int(input())\\n\\n    for i in range(19):\\n        com[i][0] = 1\\n    for i in range(1, 19):\\n        for j in range(1, i+1):\\n            com[i][j] = com[i-1][j] + com[i-1][j-1]\\n\\n    for i in range(t):\\n        l, r = list(map(int, input().split()))\\n        print(solve(r+1)-solve(l))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"t=int(input())\\nl=[]\\nr=[]\\nfor i in range (t):\\n    q,w=[int(el) for el in input().split()]\\n    l.append(q)\\n    r.append(w)\\n\\ndef count(x):\\n    if x<=1110:\\n        return x\\n    s=str(x)\\n    n=len(s)\\n    cz=3\\n    out=0\\n    for i in range(n-2): #\\u043f\\u0440\\u043e\\u0431\\u0435\\u0436\\u0430\\u043b\\u0438 \\u0434\\u043e \\u0441\\u043e\\u0442\\u0435\\u043d\\n        a=int(s[i])\\n        k = n - i - 1  # \\u043e\\u0441\\u0442\\u0430\\u043b\\u043e\\u0441\\u044c \\u0437\\u043d\\u0430\\u043a\\u043e\\u0432 \\u043f\\u043e\\u0441\\u043b\\u0435 i\\n\\n        if a>0:\\n            if cz==3:\\n                out=out+k*(k-1)*(k-2)/6*9*9*9+k*(k-1)/2*9*9+k*9\\n            elif cz==2:\\n                out=out+k*(k-1)/2*9*9+k*9+1\\n            elif cz==1:\\n                out=out+k*9+1\\n            cz=cz-1\\n\\n            if cz==2:\\n                plus=k*(k-1)/2*9*9+k*9+1\\n            elif cz==1:\\n                plus=k*9+1\\n            elif cz==0:\\n                plus=1\\n            out=out+plus*(a-1)\\n        if cz==0:\\n            break\\n    if cz==0:\\n        out=out+1\\n        return out\\n    if cz==1:\\n#        out=out+1+int(s[n-2])\\n        if int(s[n-2])>0:\\n            out=out+int(s[n-2])+10\\n        else:\\n            out=out+1+int(s[n-1])\\n        return out\\n    out=out+int(s[n-2:])+1\\n    return out\\n\\nfor i in range(t):\\n    a=int(count(r[i]))\\n    b=int(count(l[i]-1))\\n    print(a-b)\\n\\n\", \"\\nimport bisect as b\\n\\nfrom collections import OrderedDict\\n\\nnum =[]\\n\\ndef Classy (pos, count, current):\\n    if pos==18:\\n        num.append(current)\\n        return\\n    Classy(pos+1, count, current*10)\\n    \\n    if (count < 3 ):\\n        for i in range(1,10):\\n            Classy(pos+1, count+1, current *10 + i)\\n    \\nClassy(0,0,0)\\n\\nnum=list(OrderedDict.fromkeys(num))\\n\\nnum.pop(0)\\n\\nnum.insert(len(num)+1, 1000000000000000000)\\n\\n\\n\\nT = int(input())\\n\\nwhile(0 < T):\\n    L, R = [int(x) for x in input().split(' ')]\\n    \\n    ans = b.bisect_right(num, R, lo=0, hi=len(num)) - b.bisect_left(num, L, lo=0, hi=len(num))\\n    print(int(ans))\\n    \\n    T=T-1\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n1 1000\\n1024 1024\\n65536 65536\\n999999 1000001\\n\"\n  ],\n  \"outputs\": [\n    \"1000\\n1\\n0\\n2\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1036/C", "starter_code": ""}
{"id": 50, "question": "Karlsson has recently discovered a huge stock of berry jam jars in the basement of the house. More specifically, there were $2n$ jars of strawberry and blueberry jam.\n\nAll the $2n$ jars are arranged in a row. The stairs to the basement are exactly in the middle of that row. So when Karlsson enters the basement, he sees exactly $n$ jars to his left and $n$ jars to his right.\n\nFor example, the basement might look like this: [Image] \n\nBeing the starightforward man he is, he immediately starts eating the jam. In one minute he chooses to empty either the first non-empty jar to his left or the first non-empty jar to his right.\n\nFinally, Karlsson decided that at the end the amount of full strawberry and blueberry jam jars should become the same.\n\nFor example, this might be the result: [Image] He has eaten $1$ jar to his left and then $5$ jars to his right. There remained exactly $3$ full jars of both strawberry and blueberry jam. \n\nJars are numbered from $1$ to $2n$ from left to right, so Karlsson initially stands between jars $n$ and $n+1$.\n\nWhat is the minimum number of jars Karlsson is required to empty so that an equal number of full strawberry and blueberry jam jars is left?\n\nYour program should answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 10^5$).\n\nThe second line of each test case contains $2n$ integers $a_1, a_2, \\dots, a_{2n}$ ($1 \\le a_i \\le 2$) \u2014 $a_i=1$ means that the $i$-th jar from the left is a strawberry jam jar and $a_i=2$ means that it is a blueberry jam jar.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case print the answer to it \u2014 the minimum number of jars Karlsson is required to empty so that an equal number of full strawberry and blueberry jam jars is left.\n\n\n-----Example-----\nInput\n4\n6\n1 1 1 2 2 1 2 1 2 1 1 2\n2\n1 2 1 2\n3\n1 1 1 1 1 1\n2\n2 1 1 1\n\nOutput\n6\n0\n6\n2\n\n\n\n-----Note-----\n\nThe picture from the statement describes the first test case.\n\nIn the second test case the number of strawberry and blueberry jam jars is already equal.\n\nIn the third test case Karlsson is required to eat all $6$ jars so that there remain $0$ jars of both jams.\n\nIn the fourth test case Karlsson can empty either the second and the third jars or the third and the fourth one. The both scenarios will leave $1$ jar of both jams.", "solutions": "[\"for tcase in range(int(input())):\\n    n=int(input())\\n    ls = list(map(int, input().split()))\\n    oneneed = 2*(n - ls.count(1))\\n    ldct = {0:0}\\n    ctr = 0\\n    eaten = 0\\n    for i in range(n-1,-1,-1):\\n        eaten += 1\\n        ctr += (1 if ls[i] == 2 else -1)\\n        if ctr not in ldct:\\n            ldct[ctr] = eaten\\n\\n    rdct = {0:0}\\n    ctr = 0\\n    eaten = 0\\n    for i in range(n,2*n):\\n        eaten += 1\\n        ctr += (1 if ls[i] == 2 else -1)\\n        if ctr not in rdct:\\n            rdct[ctr] = eaten\\n    #print(oneneed, ldct, rdct)\\n\\n    best=99**99\\n    for k in list(rdct.keys()):\\n        otk = oneneed - k\\n        if otk in ldct:\\n            best = min(best, rdct[k]+ldct[otk])\\n    print(best)\\n\", \"import sys\\nreader = (s.rstrip() for s in sys.stdin)\\ninput = reader.__next__\\n\\ndef solve():\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    red = a.count(1)\\n    blue = 2*n - red\\n    s = red-blue\\n    if s == 0:\\n        print(0)\\n        return\\n\\n    cur = 0\\n    d = {0:0}\\n    for i in range(n, 2*n):\\n        if a[i] == 2:\\n            cur -= 1\\n        else:\\n            cur += 1\\n        if cur not in d:\\n            d[cur] = i-n+1\\n    ans = float(\\\"inf\\\")\\n    need = s\\n    cur = 0\\n    if need in d:\\n        ans = min(ans, d[need])\\n    for i in reversed(list(range(n))):\\n        if a[i] == 2:\\n            cur -= 1\\n        else:\\n            cur += 1\\n        if need-cur in d:\\n            ans = min(ans, d[need-cur]+n-i)\\n    print(ans)\\n\\nt = int(input())\\nfor i in range(t):\\n    solve()\\n\\n\", \"import sys\\ninput = sys.stdin.readline\\nfor _ in range(int(input())):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    a, b = a[n - 1::-1], a[n:]\\n    ma, mb = {0: 0}, {0: 0}\\n    pa = pb = 0\\n    for i in range(n):\\n        pa += 1 if a[i] == 1 else -1\\n        pb += 1 if b[i] == 1 else -1\\n        if pa not in ma:\\n            ma[pa] = i + 1\\n        if pb not in mb:\\n            mb[pb] = i + 1\\n    total = pa + pb\\n    ans = 10 ** 9\\n    for da, va in list(ma.items()):\\n        req = total - da\\n        if req in mb:\\n            ans = min(ans, va + mb[req])\\n    print(ans)\\n\", \"from math import *\\nfor _ in range(int(input())):\\n\\tn=int(input())\\n\\ta=list(map(int,input().split()))\\n\\tz=a.count(1)-a.count(2)\\n\\tc=a[:n]\\n\\td=a[n:]\\n\\tjk={0:0}\\n\\tb=0\\n\\tfor i in range(n):\\n\\t\\tx=d[i]\\n\\t\\tif x==1:\\n\\t\\t\\tb-=1\\n\\t\\telse:\\n\\t\\t\\tb+=1\\n\\t\\tif b not in jk:\\n\\t\\t\\tjk[b]=i+1\\n\\tans=1000000\\n\\tb=0\\n\\ti=1\\n\\tif z==0:\\n\\t\\tans=0\\n\\tfor x in c[::-1]:\\n\\t\\tif x==1:\\n\\t\\t\\tb-=1\\n\\t\\telse:\\n\\t\\t\\tb+=1\\n\\t\\tif -z-b in jk:\\n\\t\\t\\tans = min(ans,i+jk[-z-b])\\n\\t\\ti+=1\\n\\tif -z in jk:\\n\\t\\tans=min(ans,jk[-z])\\n\\tprint(ans)\\n\", \"import sys\\n\\ndef minp():\\n\\treturn sys.stdin.readline().strip()\\n\\ndef mint():\\n\\treturn int(minp())\\n\\ndef mints():\\n\\treturn list(map(int,minp().split()))\\n\\ndef solve():\\n\\tn = mint()\\n\\ta = list(mints())\\n\\tc = dict()\\n\\tc[0] = 2*n\\n\\td = 0\\n\\t#print(d, end=' ')\\n\\tfor i in range(2*n-1,n-1,-1):\\n\\t\\tif a[i] == 1:\\n\\t\\t\\td += 1\\n\\t\\telse:\\n\\t\\t\\td -= 1\\n\\t\\t#print(d, i-n, end=' ')\\n\\t\\tc[d] = i\\n\\t#print()\\n\\td = 0\\n\\tr = 2*n\\n\\tr = min(r, n + c[0] - n)\\n\\tfor i in range(n):\\n\\t\\tif a[i] == 1:\\n\\t\\t\\td += 1\\n\\t\\telse:\\n\\t\\t\\td -= 1\\n\\t\\t#print(d, n-i-1, end=' ')\\n\\t\\tif (-d) in c:\\n\\t\\t\\tr = min(r, n - i - 1 + c[-d] - n)\\n\\t#print()\\n\\treturn r\\n\\n\\nfor i in range(mint()):\\n\\tprint(solve())\\n\", \"def inp(ai):\\n    cur = sum(ai) * 2 - n * 3\\n    yield cur\\n    for aii in ai:\\n        if aii == 1:\\n            cur += 1\\n        else:\\n            cur -= 1\\n        yield cur\\n\\n\\ndef inp2(ii):\\n    ans = {}\\n    for i, iii in enumerate(ii):\\n        if iii not in ans:\\n            ans[iii] = i\\n    return ans\\n\\n\\nfor _ in range(int(input())):\\n    n = int(input())\\n    a = iter(map(int, input().split()))\\n    a1 = [next(a) for _ in range(n)]\\n    a1.reverse()\\n    a2 = list(a)\\n    i1 = inp2(inp(a1))\\n    i2 = inp2((-i2i for i2i in inp(a2)))\\n    res = n * 2\\n    for k in list(i1.keys()):\\n        if k in list(i2.keys()):\\n            res = min(res, i1[k] + i2[k])\\n    print(res)\\n\", \"q = int(input())\\nfor rwier in range(q):\\n\\tn = int(input())\\n\\tl = list(map(int,input().split()))\\n\\tj = l.count(1)\\n\\td = l.count(2)\\n\\tpr = [0] * n\\n\\tle = [0] * n\\n\\tpr[0] = (1 if l[n] == 1 else -1)\\n\\tle[0] = (1 if l[n-1] == 1 else -1)\\n\\tfor i in range(1, n):\\n\\t\\tpr[i] = pr[i-1] + (1 if l[n+i] == 1 else -1)\\n\\t\\tle[i] = le[i-1] + (1 if l[n-i-1] == 1 else -1)\\n\\t#print(pr,le)\\n\\tif j - d < 0:\\n\\t\\tfor i in range(n):\\n\\t\\t\\tpr[i] = -pr[i]\\n\\t\\t\\tle[i] = -le[i]\\n\\tab = abs(j-d)\\n\\tif ab == 0:\\n\\t\\tprint(0)\\n\\telse:\\n\\t\\t#suma = abs\\n\\t\\tnajwp = [123456789] * (2*n+1)\\n\\t\\tnajwl = [123456789] * (2*n+1)\\n\\t\\tle = [0] + le\\n\\t\\tpr = [0] + pr\\n\\t\\tfor i in range(n+1):\\n\\t\\t\\tif pr[i] >= 0 and najwp[pr[i]] == 123456789:\\n\\t\\t\\t\\tnajwp[pr[i]] = i\\n\\t\\t\\tif le[i] >= 0 and najwl[le[i]] == 123456789:\\n\\t\\t\\t\\tnajwl[le[i]] = i\\n\\t\\twyn = 41343443143\\n\\t\\tfor i in range(ab+1):\\n\\t\\t\\tif najwp[i] + najwl[ab-i] < wyn:\\n\\t\\t\\t\\twyn = najwp[i] +najwl[ab-i]\\n\\t\\tprint(wyn)\\n\", \"import itertools\\nfrom collections import defaultdict\\n\\nt = int(input())\\n\\nfor _ in range(t):\\n    n = int(input())\\n    \\n    a = list(map(int, input().split()))\\n    \\n    ones = a.count(1)\\n    twos = a.count(2)\\n    \\n    a1 = a[:n][::-1]\\n    a2 = a[n:]\\n    \\n    target = ones - twos\\n    \\n    a1 = [[-1,1][x==1]for x in a1]\\n    a1 = [0] + list(itertools.accumulate(a1))\\n    a2 = [[-1,1][x==1]for x in a2]\\n    a2 = [0] + list(itertools.accumulate(a2))\\n    \\n    a2v = defaultdict(lambda: 2*n+1)\\n    for i2, x2 in enumerate(a2):\\n        a2v[x2] = min(a2v[x2], i2)\\n    best = 2*n\\n    \\n    for i1, x1 in enumerate(a1):\\n        best = min(best, i1+a2v[target-x1])\\n    \\n    print(best)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\n\\nfor test in range(t):\\n    n=int(input())\\n    A=list(map(int,input().split()))\\n\\n    LEFT=[0]\\n    RIGHT=[0]\\n\\n    for a in A[:n]:\\n        if a==1:\\n            LEFT.append(LEFT[-1]+1)\\n        else:\\n            LEFT.append(LEFT[-1]-1)\\n\\n    for a in A[n:][::-1]:\\n        if a==1:\\n            RIGHT.append(RIGHT[-1]+1)\\n        else:\\n            RIGHT.append(RIGHT[-1]-1)\\n\\n    #print(LEFT)\\n    #print(RIGHT)\\n    #print()\\n\\n    MAXLEFT=[-1]*(2*n+1)\\n    MAXRIGHT=[-1]*(2*n+1)\\n\\n    for i in range(n+1):\\n        MAXLEFT[LEFT[i]+n]=i\\n        MAXRIGHT[RIGHT[i]+n]=i\\n   \\n    #print(MAXLEFT)\\n    #print(MAXRIGHT)\\n    #print()\\n\\n    ANS=0\\n    for i in range(2*n+1):\\n        if MAXLEFT[i]==-1 or MAXRIGHT[2*n-i]==-1:\\n            continue\\n        ANS=max(ANS,MAXLEFT[i]+MAXRIGHT[2*n-i])\\n\\n    #print(ANS)\\n    print(2*n-ANS)\\n\\n    \\n    \\n\\n    \\n\\n    \\n    \\n\", \"import sys\\nreadline = sys.stdin.readline\\nT = int(readline())\\nAns = [None]*T\\ninf = 10**9+7\\nfor qu in range(T):\\n    N = int(readline())\\n    A = list(map(int, readline().split()))\\n    bj = A.count(1)\\n    sj = 2*N-bj\\n    x = sj-bj\\n    A1 = [3-2*a for a in A[:N][::-1]]\\n    A2 = [3-2*a for a in A[N:]]          \\n    for i in range(1, N):\\n        A1[i] += A1[i-1]\\n        A2[i] += A2[i-1]\\n    geta = -min(0, min(A2))+1\\n    mA = max(0, max(A2))\\n    idx = [inf]*(mA+geta+1)\\n    idx[geta+0] = 0\\n    for i in range(N):\\n        a2 = A2[i]\\n        idx[geta+a2] = min(idx[geta+a2], i+1)\\n    \\n    ans = inf\\n    A1 = [0]+A1\\n    for i in range(N+1):\\n        a1 = A1[i]\\n        if -geta <= -a1-x <= mA:\\n            ans = min(ans, i+idx[geta-a1-x])\\n    Ans[qu] = ans\\nprint('\\\\n'.join(map(str, Ans)))\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n6\\n1 1 1 2 2 1 2 1 2 1 1 2\\n2\\n1 2 1 2\\n3\\n1 1 1 1 1 1\\n2\\n2 1 1 1\\n\"\n  ],\n  \"outputs\": [\n    \"6\\n0\\n6\\n2\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1278/C", "starter_code": ""}
{"id": 51, "question": "There are n games in a football tournament. Three teams are participating in it. Currently k games had already been played. \n\nYou are an avid football fan, but recently you missed the whole k games. Fortunately, you remember a guess of your friend for these k games. Your friend did not tell exact number of wins of each team, instead he thought that absolute difference between number of wins of first and second team will be d_1 and that of between second and third team will be d_2.\n\nYou don't want any of team win the tournament, that is each team should have the same number of wins after n games. That's why you want to know: does there exist a valid tournament satisfying the friend's guess such that no team will win this tournament?\n\nNote that outcome of a match can not be a draw, it has to be either win or loss.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer corresponding to number of test cases t (1 \u2264 t \u2264 10^5).\n\nEach of the next t lines will contain four space-separated integers n, k, d_1, d_2 (1 \u2264 n \u2264 10^12;\u00a00 \u2264 k \u2264 n;\u00a00 \u2264 d_1, d_2 \u2264 k) \u2014 data for the current test case.\n\n\n-----Output-----\n\nFor each test case, output a single line containing either \"yes\" if it is possible to have no winner of tournament, or \"no\" otherwise (without quotes).\n\n\n-----Examples-----\nInput\n5\n3 0 0 0\n3 3 0 0\n6 4 1 0\n6 3 3 0\n3 3 3 2\n\nOutput\nyes\nyes\nyes\nno\nno\n\n\n\n-----Note-----\n\nSample 1. There has not been any match up to now (k = 0, d_1 = 0, d_2 = 0). If there will be three matches (1-2, 2-3, 3-1) and each team wins once, then at the end each team will have 1 win.\n\nSample 2. You missed all the games (k = 3). As d_1 = 0 and d_2 = 0, and there is a way to play three games with no winner of tournament (described in the previous sample), the answer is \"yes\".\n\nSample 3. You missed 4 matches, and d_1 = 1, d_2 = 0. These four matches can be: 1-2 (win 2), 1-3 (win 3), 1-2 (win 1), 1-3 (win 1). Currently the first team has 2 wins, the second team has 1 win, the third team has 1 win. Two remaining matches can be: 1-2 (win 2), 1-3 (win 3). In the end all the teams have equal number of wins (2 wins).", "solutions": "[\"def main():\\n    t = int(input())\\n    for z in range(t):\\n        n, k, d1, d2 = map(int, input().split())\\n        if n % 3 != 0:\\n            print('no')\\n            continue\\n        f = 0\\n        for i in [-1, +1]:\\n            for j in [-1, +1]:\\n                w = (k - i * d1 - j * d2)\\n                if f == 0 and (w % 3 == 0) and (n//3)>=(w//3)>=0 and (n//3)>=(w//3 + i * d1)>=0 and (n//3)>=(w//3 + j * d2)>=0:\\n                    print('yes')\\n                    f = 1\\n        if f == 0:\\n            print('no')\\nmain()\", \"import itertools\\nimport sys\\n\\n\\n'''\\nw1 - w2 = d1\\nw2 - w3 = d2\\nw1 + w2 + w3 = k\\n\\nw1 = w2 + d1\\nw3 = w2 - d2\\nw2 + d1 + w2 + w2 - d2 = k\\n\\nw2 = (k - d1 + d2) / 3\\nw1 = w2 + d1\\nw3 = w2 - d2\\n'''\\nfor _ in range(int(input())):\\n\\n    n, k, d1, d2 = list(map(int, str.split(sys.stdin.readline())))\\n    for s1, s2 in itertools.product((1, -1), repeat=2):\\n\\n        cd1, cd2 = d1 * s1, d2 * s2\\n        w2 = k - cd1 + cd2\\n        if w2 % 3 != 0:\\n\\n            continue\\n\\n        w2 //= 3\\n        w1 = w2 + cd1\\n        w3 = w2 - cd2\\n        if w1 >= 0 and w2 >= 0 and w3 >= 0:\\n\\n            d = n - k\\n            mw = max((w1, w2, w3))\\n            nw = 3 * mw - w1 - w2 - w3\\n            if d >= nw and (d - nw) % 3 == 0:\\n\\n                print(\\\"yes\\\")\\n                break\\n\\n    else:\\n\\n        print(\\\"no\\\")\\n\", \"def f1(d1, d2, n, k):\\n    a1 = 2 * d1 + d2 + k\\n    a2 = -d1 + d2 + k\\n    a3 = -d1 - (2 * d2) + k\\n    if (a1 < 0 or a2 < 0 or a3 < 0 or a1 % 3 or a2 % 3 or a2 % 3):\\n        return False\\n    else:\\n        a1 //= 3\\n        a2 //= 3 \\n        a3 //= 3\\n        a1, a2, a3 = tuple(sorted([a1, a2, a3])[::-1])\\n        if (a2 - a3 + 2 * (a1 - a2)) > n - k:\\n            return False\\n        else:\\n            return True\\n\\ndef f2(d1, d2, n, k):\\n    a1 = -2 * d1 + d2 + k\\n    a2 = d1 + d2 + k\\n    a3 = d1 - (2 * d2) + k\\n    if (a1 < 0 or a2 < 0 or a3 < 0 or a1 % 3 or a2 % 3 or a2 % 3):\\n        return False\\n    else:\\n        a1 //= 3\\n        a2 //= 3 \\n        a3 //= 3\\n        a1, a2, a3 = tuple(sorted([a1, a2, a3])[::-1])\\n        if (a2 - a3 + 2 * (a1 - a2)) > n - k:\\n            return False\\n        else:\\n            return True\\n\\ndef f3(d1, d2, n, k):\\n    a1 = 2 * d1 - d2 + k\\n    a2 = -d1 - d2 + k\\n    a3 = -d1 + (2 * d2) + k\\n    if (a1 < 0 or a2 < 0 or a3 < 0 or a1 % 3 or a2 % 3 or a2 % 3):\\n        return False\\n    else:\\n        a1 //= 3\\n        a2 //= 3 \\n        a3 //= 3\\n        a1, a2, a3 = tuple(sorted([a1, a2, a3])[::-1])\\n        if (a2 - a3 + 2 * (a1 - a2)) > n - k:\\n            return False\\n        else:\\n            return True\\n\\ndef f4(d1, d2, n, k):\\n    a1 = -2 * d1 - d2 + k\\n    a2 = d1 - d2 + k\\n    a3 = d1 + (2 * d2) + k\\n    if (a1 < 0 or a2 < 0 or a3 < 0 or a1 % 3 or a2 % 3 or a2 % 3):\\n        return False\\n    else:\\n        a1 //= 3\\n        a2 //= 3 \\n        a3 //= 3\\n        a1, a2, a3 = tuple(sorted([a1, a2, a3])[::-1])\\n        if (a2 - a3 + 2 * (a1 - a2)) > n - k:\\n            return False\\n        else:\\n            return True\\n\\n\\na = []\\nz = int(input())\\n\\nfor i in range(z):\\n    n, k, d1, d2 = map(int, input().split())\\n    v1 = f1(d1, d2, n, k)\\n    v2 = f2(d1, d2, n, k)\\n    v3 = f3(d1, d2, n, k)\\n    v4 = f4(d1, d2, n, k)\\n    \\n        \\n    if (v1 or v2 or v3 or v4) and n % 3 == 0:\\n        a.append('yes')\\n    else:\\n        a.append('no')\\n    \\n    \\nprint(*a, sep = '\\\\n')\", \"q = int(input())\\n\\nwhile q > 0:\\n    n, k, d1, d2 = list(map(int, input().split()))\\n    if d1 > d2:\\n        d1, d2 = d2, d1\\n    if k - 2 * d1 - d2 >= 0 and (k - 2 * d1 - d2) % 3 == 0 and \\\\\\n            (n - k) - d1 - 2 * d2 >= 0 and ((n - k) - d1 - 2 * d2) % 3 == 0:\\n        print('yes')\\n    elif k - 2 * d2 - d1 >= 0 and (k - 2 * d2 - d1) % 3 == 0 and \\\\\\n            (n - k) - d2 - 2 * d1 >= 0 and ((n - k) - d2 - 2 * d1) % 3 == 0:\\n        print('yes')\\n    elif k - 2 * d2 + d1 >= 0 and (k - 2 * d2 + d1) % 3 == 0 and \\\\\\n            (n - k) - d2 - d1 >= 0 and ((n - k) - d2 - d1) % 3 == 0:\\n        print('yes')\\n    elif k - d1 - d2 >= 0 and (k - d1 - d2) % 3 == 0 and \\\\\\n            (n - k) - 2 * d2 + d1 >= 0 and ((n - k) - 2 * d2 + d1) % 3 == 0:\\n        print('yes')\\n    else:\\n        print('no')\\n    q -= 1\\n\", \"t = int(input())\\nfor l in range(t):\\n    n, k, d1, d2 = map(int, input().split())\\n    if n % 3 != 0:\\n        print(\\\"no\\\")\\n        continue\\n    n = n // 3\\n    ok = False\\n    for i in [-1, 1]:\\n        for j in [-1, 1]:\\n            tmp = k;\\n            tmp -= d1 * i\\n            tmp -= d1 * i\\n            tmp -= d2 * j\\n            if tmp % 3 != 0: continue\\n            if tmp < 0: continue\\n            tmp = tmp // 3\\n            x1 = tmp\\n            x2 = x1 + d1 * i\\n            x3 = x2 + d2 * j\\n            if x1 < 0 or x2 < 0 or x3 < 0: continue\\n            if x1 <= n and x2 <= n and x3 <= n:\\n                ok = True\\n                break\\n    if ok: print(\\\"yes\\\")\\n    else: print(\\\"no\\\")\", \"t = int(input())\\nfor _ in range(t):\\n    n, k, d1, d2 = map(int, input().split())\\n    if n % 3 != 0:\\n        print(\\\"no\\\")\\n        continue\\n    n = n // 3\\n    ok = False\\n    for i in [-1, 1]:\\n        for j in [-1, 1]:\\n            tmp = k;\\n            tmp -= d1 * i\\n            tmp -= d1 * i\\n            tmp -= d2 * j\\n            if tmp % 3 != 0: continue\\n            if tmp < 0: continue\\n            tmp = tmp // 3\\n            x1 = tmp\\n            x2 = x1 + d1 * i\\n            x3 = x2 + d2 * j\\n            if x1 < 0 or x2 < 0 or x3 < 0: continue\\n            if x1 <= n and x2 <= n and x3 <= n:\\n                ok = True\\n                break\\n    if ok: print(\\\"yes\\\")\\n    else: print(\\\"no\\\")\", \"def doall():\\n    t = int(input())\\n    def solve(n, k, d1, d2):\\n        if n % 3 == 0:\\n            r = n - k\\n            a = [[0, d1, d1 + d2],\\n                 [0, d1, d1 - d2],\\n                 [0, -d1, -d1 + d2],\\n                 [0, -d1, -d1 - d2]]\\n            for now in a:\\n                mn = min(now)\\n                sumn = sum(now)\\n                sumb = sumn - 3 * min(now)\\n                if k < sumb or (k - sumb) % 3 != 0:\\n                    continue\\n                w = max(now)\\n                tmp = 3 * w - sumn\\n                if tmp <= r and (r - tmp) % 3 == 0:\\n                    \\n                    return True\\n        return False\\n    ans = []\\n    for i in range(t):\\n        n, k, d1, d2 = list(map(int, input().split()))\\n        if solve(n, k, d1, d2):\\n            ans.append('yes')\\n        else:\\n            ans.append('no')\\n    print('\\\\n'.join(ans))\\n                \\ndoall()\", \"def f(x, y, a, b): return x > a or y > b or (a - x) % 3 or (b - y) % 3\\ndef g(x, y, a, b): return f(x, y, a, b) and f(x, y, b, a)\\nfor i in range(int(input())):\\n    n, u, a, b = map(int, input().split())\\n    v, s, t = n - u, a + b, 2 * b - a if b > a else 2 * a - b\\n    print('no' if g(s, t, u, v) and g(s + a, s + b, u, v) else 'yes')\", \"for i in range(int(input())):\\n    n, u, a, b = map(int, input().split())\\n    if n % 3: print('no')\\n    else:\\n        if a > b: a, b = b, a\\n        p, q = a + b, 2 * b - a\\n        s, r, v = p + a, p + b, n - u\\n        t = [(p, q), (q, p), (s, r), (r, s)]\\n        print('no' if all(x > u or (x - u) % 3 or y > v or (y - v) % 3 for x, y in t) else 'yes')\", \"read = lambda: list(map(int, input().split()))\\nf = lambda x, y, a, b: x > a or y > b or (a - x) % 3 or (b - y) % 3\\ng = lambda x, y, a, b: f(x, y, a, b) and f(x, y, b, a)\\nt = int(input())\\nfor i in range(t):\\n    n, k, d1, d2 = read()\\n    r = n - k\\n    d = d1 + d2\\n    p = 2 * d2 - d1 if d2 > d1 else 2 * d1 - d2\\n    print('no' if g(d, p, k, r) and g(d + d1, d + d2, k, r) else 'yes')\\n\", \"t=int(input())\\n\\nfor j in range(t):\\n  inp=[int(n) for n in input().split()]\\n  n=inp[0]\\n  k=inp[1]\\n  d1=inp[2]\\n  d2=inp[3]\\n  \\n  if d2<d1:\\n    s=d1\\n    d1=d2\\n    d2=s\\n  \\n  if ((k>=2*d1+d2) and ((k-2*d1-d2)%3==0) and (n-k>=d1+2*d2) and ((n-k-d1-2*d2)%3==0)):\\n    print('yes')\\n  elif ((k>=2*d2+d1) and ((k-2*d2-d1)%3==0) and (n-k>=d2+2*d1) and ((n-k-d2-2*d1)%3==0)):\\n    print('yes')\\n  elif ((k>=d1+d2) and ((k-d1-d2)%3==0) and (n-k>=2*d2-d1) and ((n-k-2*d2+d1)%3==0)):\\n    print('yes')\\n  elif ((k>=2*d2-d1) and ((k-2*d2+d1)%3==0) and (n-k>=d1+d2) and ((n-k-d1-d2)%3==0)):\\n    print('yes')\\n  else:\\n    print('no')\", \"from sys import *\\n\\nt=int(stdin.readline())\\nfor i in range(t):\\n    n,k,d1,d2=(int(z) for z in stdin.readline().split())\\n    vars=[[2*d1+d2,2*d2+d1],[2*d2+d1,2*d1+d2],[2*max(d1,d2)-min(d1,d2),d1+d2], [d1+d2,2*max(d1,d2)-min(d1,d2)]]\\n    y=False\\n    for i in vars:\\n        if i[0]<=k and i[0]%3==k%3 and n-k-i[1]>=0 and (n-i[1]-k)%3==0:\\n            print(\\\"yes\\\")\\n            y=True\\n            break\\n    if not y:\\n        print(\\\"no\\\")\", \"from sys import *\\n\\nt=int(stdin.readline())\\nfor i in range(t):\\n    n,k,d1,d2=(int(z) for z in stdin.readline().split())\\n    vars=((2*d1+d2,2*d2+d1),(2*d2+d1,2*d1+d2),(2*max(d1,d2)-min(d1,d2),d1+d2), (d1+d2,2*max(d1,d2)-min(d1,d2)))\\n    y=False\\n    for i in vars:\\n        if i[0]<=k and i[0]%3==k%3 and n-k-i[1]>=0 and (n-i[1]-k)%3==0:\\n            print(\\\"yes\\\")\\n            y=True\\n            break\\n    if not y:\\n        print(\\\"no\\\")\", \"from sys import *\\n\\nt=int(stdin.readline())\\nfor i in range(t):\\n    n,k,d1,d2=(int(z) for z in stdin.readline().split())\\n    vars=((2*d1+d2,2*d2+d1),(2*max(d1,d2)-min(d1,d2),d1+d2))\\n    y=False\\n    for i in vars:\\n        if i[0]<=k and i[0]%3==k%3 and n-k-i[1]>=0 and (n-i[1]-k)%3==0:\\n            print(\\\"yes\\\")\\n            y=True\\n            break\\n        if i[1]<=k and i[1]%3==k%3 and n-k-i[0]>=0 and (n-i[0]-k)%3==0:\\n            print(\\\"yes\\\")\\n            y=True\\n            break        \\n    if not y:\\n        print(\\\"no\\\")\", \"from sys import *\\n\\nt=int(stdin.readline())\\nfor i in range(t):\\n    n,k,d1,d2=(int(z) for z in stdin.readline().split())\\n    vars=((2*d1+d2,2*d2+d1),(2*max(d1,d2)-min(d1,d2),d1+d2))\\n    y=False\\n    for i in vars:\\n        if i[0]<=k and i[0]%3==k%3 and n-k-i[1]>=0 and (n-i[1]-k)%3==0:\\n            print(\\\"yes\\\")\\n            y=True\\n            break\\n        if i[1]<=k and i[1]%3==k%3 and n-k-i[0]>=0 and (n-i[0]-k)%3==0:\\n            print(\\\"yes\\\")\\n            y=True\\n            break        \\n    if not y:\\n        print(\\\"no\\\")\", \"from sys import *\\n\\nt=int(stdin.readline())\\nfor i in range(t):\\n    n,k,d1,d2=(int(z) for z in stdin.readline().split())\\n    if (k-2*d1-d2>=0 and (k-2*d1-d2)%3==0 and n-2*d2-d1-k>=0 and (n-2*d2-d1-k)%3==0) or (k-2*d2-d1>=0 and (k-2*d2-d1)%3==0 and n-2*d1-d2-k>=0 and (n-2*d1-d2-k)%3==0) or (k-d1-d2>=0 and (k-d1-d2)%3==0 and n-2*max(d1,d2)+min(d1,d2)-k>=0 and (n-2*max(d1,d2)+min(d1,d2)-k)%3==0) or (k-2*max(d1,d2)+min(d1,d2)>=0 and (k-2*max(d1,d2)+min(d1,d2))%3==0 and n-d1-d2-k>=0 and (n-d1-d2-k)%3==0):\\n        print(\\\"yes\\\")\\n    else:\\n        print(\\\"no\\\")\", \"from sys import *\\n\\nt=int(stdin.readline())\\nmm=0\\nfor i in range(t):\\n    n,k,d1,d2=(int(z) for z in stdin.readline().split())\\n    mm=2*max(d1,d2)-min(d1,d2)\\n    if (k-2*d1-d2>=0 and (k-2*d1-d2)%3==0 and n-2*d2-d1-k>=0 and (n-2*d2-d1-k)%3==0) or (k-2*d2-d1>=0 and (k-2*d2-d1)%3==0 and n-2*d1-d2-k>=0 and (n-2*d1-d2-k)%3==0) or (k-d1-d2>=0 and (k-d1-d2)%3==0 and n-mm-k>=0 and (n-mm-k)%3==0) or (k-mm>=0 and (k-mm)%3==0 and n-d1-d2-k>=0 and (n-d1-d2-k)%3==0):\\n        print(\\\"yes\\\")\\n    else:\\n        print(\\\"no\\\")\", \"from sys import *\\n\\nt=int(stdin.readline())\\nmm,mmm,mmmm,m=0,0,0,0\\nfor i in range(t):\\n    n,k,d1,d2=(int(z) for z in stdin.readline().split())\\n    m=d1+d2\\n    mm=2*max(d1,d2)-min(d1,d2)\\n    mmm=2*d1+d2\\n    mmmm=2*d2+d1\\n    if (k-mmm>=0 and (k-mmm)%3==0 and n-mmmm-k>=0 and (n-mmmm-k)%3==0) or (k-mmmm>=0 and (k-mmmm)%3==0 and n-mmm-k>=0 and (n-mmm-k)%3==0) or (k-m>=0 and (k-m)%3==0 and n-mm-k>=0 and (n-mm-k)%3==0) or (k-mm>=0 and (k-mm)%3==0 and n-m-k>=0 and (n-m-k)%3==0):\\n        print(\\\"yes\\\")\\n    else:\\n        print(\\\"no\\\")\", \"t=int(input())\\nfor i in range(t):\\n    n,k,d1,d2=map(int,input().split())\\n    m=d1+d2\\n    mm=2*max(d1,d2)-min(d1,d2)\\n    mmm=2*d1+d2\\n    mmmm=2*d2+d1\\n    if (k-mmm>=0 and (k-mmm)%3==0 and n-mmmm-k>=0 and (n-mmmm-k)%3==0) or (k-mmmm>=0 and (k-mmmm)%3==0 and n-mmm-k>=0 and (n-mmm-k)%3==0) or (k-m>=0 and (k-m)%3==0 and n-mm-k>=0 and (n-mm-k)%3==0) or (k-mm>=0 and (k-mm)%3==0 and n-m-k>=0 and (n-m-k)%3==0):\\n        print(\\\"yes\\\")\\n    else:\\n        print(\\\"no\\\")\", \"from sys import *\\n\\nt=int(stdin.readline())\\nmm=0\\nfor i in range(t):\\n    n,k,d1,d2=(int(z) for z in stdin.readline().split())\\n    mm=2*max(d1,d2)-min(d1,d2)\\n    if (k-2*d1-d2>=0 and (k-2*d1-d2)%3==0 and n-2*d2-d1-k>=0 and (n-2*d2-d1-k)%3==0) or (k-2*d2-d1>=0 and (k-2*d2-d1)%3==0 and n-2*d1-d2-k>=0 and (n-2*d1-d2-k)%3==0) or (k-d1-d2>=0 and (k-d1-d2)%3==0 and n-mm-k>=0 and (n-mm-k)%3==0) or (k-mm>=0 and (k-mm)%3==0 and n-d1-d2-k>=0 and (n-d1-d2-k)%3==0):\\n        print(\\\"yes\\\")\\n    else:\\n        print(\\\"no\\\")\", \"import sys\\ndef check(a, b, c, n, k):\\n\\tneed = n // 3\\n\\treturn ((n - k) == (need - a) + (need - b) + (need - c) and a <= need and b <= need and c <= need and a >= 0 and b >= 0 and c >= 0)\\n\\nfor tc in range(int(sys.stdin.readline())):\\n\\tn,k,d1,d2 = map(int, sys.stdin.readline().split())\\n\\tif n % 3 != 0:\\n\\t\\tprint('no')\\n\\t\\tcontinue\\n\\n\\tans = False\\n\\t#case++\\n\\ta = k - 2 * d1 - d2\\n\\tif a % 3 == 0:\\n\\t\\ta //= 3\\n\\t\\tans |= check(a, a + d1, a + d1 + d2, n ,k)\\n\\n\\t#case+-\\n\\ta = k + d2 - 2 * d1\\n\\tif a % 3 == 0:\\n\\t\\ta //= 3\\n\\t\\tans |= check(a, a + d1, a + d1 - d2, n, k)\\n\\n\\t#case--\\n\\ta = k + 2 * d1 + d2\\n\\tif a % 3 == 0:\\n\\t\\ta //= 3\\n\\t\\tans |= check(a, a - d1, a - d1 - d2, n, k)\\n\\n\\t#case-+\\n\\ta = k - d2 + 2 * d1\\n\\tif a % 3 == 0:\\n\\t\\ta //= 3\\n\\t\\tans |= check(a, a - d1, a - d1 + d2, n, k)\\n\\n\\tprint('yes' if ans else 'no')\", \"for i in range(int(input())):\\n\\n    n, u, a, b = list(map(int, input().split()))\\n\\n    if n % 3: print('no')\\n\\n    else:\\n\\n        if a > b: a, b = b, a\\n\\n        p, q = a + b, 2 * b - a\\n\\n        s, r, v = p + a, p + b, n - u\\n\\n        t = [(p, q), (q, p), (s, r), (r, s)]\\n\\n        print('no' if all(x > u or (x - u) % 3 or y > v or (y - v) % 3 for x, y in t) else 'yes')\\n\\n\\n\\n# Made By Mostafa_Khaled\\n\", \"t = int(input())\\nret = []\\nwhile t>0:\\n    t-=1\\n    n,k,d1,d2 = map(int,input().split())\\n\\n    # ans = []\\n\\n    y1 = (k-(d1-d2))//3\\n    x1 = y1+d1\\n    z1 = y1-d2\\n    # ans = [y1,z1,x1]\\n    # ans = sorted(ans)\\n    # ans1 = 2*ans[2]-(ans[0]+ans[1])\\n    ans1 = 2*x1-(z1+y1)\\n    if x1+y1+z1==k and min(z1,y1)>=0 and ans1<=n-k and (n-k-ans1)%3==0:\\n        ret.append('yes')\\n        continue\\n    \\n    # ans = []\\n\\n    y1 = (k-(d1+d2))//3\\n    x1 = y1+d1\\n    z1 = y1+d2\\n    if d1>=d2:\\n        # ans = [y1,z1,x1]\\n        ans1 = 2*x1-(y1+z1)\\n    else:\\n        # ans = [y1,x1,z1]\\n        ans1 = 2*z1-(y1+x1)\\n    # ans = sorted(ans)\\n    # ans1 = 2*ans[2]-(ans[0]+ans[1])\\n    if x1+y1+z1==k and y1>=0 and ans1<=n-k and (n-k-ans1)%3==0:\\n        ret.append('yes')\\n        continue\\n    \\n    y1 = (k-(d2-d1))//3\\n    x1 = y1-d1\\n    z1 = y1+d2\\n    # ans = [x1,y1,z1]\\n    # ans = sorted(ans)\\n    ans1 = 2*z1-(x1+y1)\\n    if x1+y1+z1==k and min(x1,y1)>=0 and ans1<=n-k and (n-k-ans1)%3==0:\\n        ret.append('yes')\\n        continue\\n    \\n    y1 = (k+(d2+d1))//3\\n    x1 = y1-d1\\n    z1 = y1-d2\\n    # ans = [x1,y1,z1]\\n    # ans = sorted(ans)\\n    ans1 = 2*y1-(x1+z1)\\n    if x1+y1+z1==k and min(x1,z1)>=0 and ans1<=n-k and (n-k-ans1)%3==0:\\n        ret.append('yes')\\n        continue\\n\\n\\n\\n\\n\\n    # if d1>=d2:\\n    #     ans.append(2*d1-d2)\\n    #     ans.append(d2+2*(d1-d2))\\n    # else:\\n    #     ans.append(2*d2-d1)\\n    #     ans.append(d1+2*(d2-d1))\\n\\n    # ans+=[d1+2*d2,d2+2*d1,d1+d2]\\n    # done = False\\n    # print(ans)\\n    # for a in ans:\\n    #     # if (a==0 and (n-k)%3==0) or (a!=0 and (n-k)//a>1 and (n-k)%a==0):\\n    #     if (a<=n-k) and (n-k-a)%3==0:\\n    #         print(a)\\n    #         done = True\\n    #         break\\n\\n    # if done:\\n    #     print('yes')\\n    # else:\\n    ret.append('no')\\n\\nprint(*ret, sep = '\\\\n')\\n\", \"import sys\\nlines = sys.stdin.readlines()\\n\\n'''\\n(n, p) = map(int, lines[0].strip().split(\\\" \\\"))\\nranges = []\\nfor i in range(1, n+1):\\n    (l, r) = map(int, lines[i].strip().split(\\\" \\\"))\\n    ranges.append((l,r))\\n\\nprobs = []\\nfor lr in ranges:\\n    poss = lr[1]//p - (lr[0]-1)//p\\n    probs.append(poss/(lr[1]-lr[0]+1))\\n\\nres = 0\\nfor i in range(n):\\n    res += probs[i] + probs[i-1] - probs[i] * probs[i-1]\\nprint(res * 2000)\\n'''\\nN = int(lines[0].strip())\\nfor i in range(1, 1+N):\\n    (n, k, d1, d2) = map(int, lines[i].strip().split(\\\" \\\"))\\n    if n % 3 != 0: print(\\\"no\\\"); continue\\n\\n    def solve(da, db):\\n        tmp = k - da - db\\n        if tmp % 3 != 0: return True\\n        b = tmp // 3\\n        a = b + da\\n        c = b + db\\n        if min(a,b,c) < 0: return True\\n        if n//3 >= max(a,b,c): return False\\n        else: return True\\n        \\n    cannot = True\\n    if cannot: cannot = solve(d1, d2)\\n    if cannot: cannot = solve(d1, -d2)\\n    if cannot: cannot = solve(-d1, d2)\\n    if cannot: cannot = solve(-d1, -d2)\\n    if cannot: print(\\\"no\\\")\\n    else: print(\\\"yes\\\")\"]", "input_output": "{\n  \"inputs\": [\n    \"5\\n3 0 0 0\\n3 3 0 0\\n6 4 1 0\\n6 3 3 0\\n3 3 3 2\\n\"\n  ],\n  \"outputs\": [\n    \"yes\\nyes\\nyes\\nno\\nno\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/451/C", "starter_code": ""}
{"id": 52, "question": "Harry Water, Ronaldo, Her-my-oh-knee and their friends have started a new school year at their MDCS School of Speechcraft and Misery. At the time, they are very happy to have seen each other after a long time. The sun is shining, birds are singing, flowers are blooming, and their Potions class teacher, professor Snipe is sulky as usual. Due to his angst fueled by disappointment in his own life, he has given them a lot of homework in Potions class. \n\nEach of the n students has been assigned a single task. Some students do certain tasks faster than others. Thus, they want to redistribute the tasks so that each student still does exactly one task, and that all tasks are finished. Each student has their own laziness level, and each task has its own difficulty level. Professor Snipe is trying hard to improve their work ethics, so each student\u2019s laziness level is equal to their task\u2019s difficulty level. Both sets of values are given by the sequence a, where a_{i} represents both the laziness level of the i-th student and the difficulty of his task. \n\nThe time a student needs to finish a task is equal to the product of their laziness level and the task\u2019s difficulty. They are wondering, what is the minimum possible total time they must spend to finish all tasks if they distribute them in the optimal way. Each person should receive one task and each task should be given to one person. Print the answer modulo 10 007.\n\n\n-----Input-----\n\nThe first line of input contains integer n (1 \u2264 n \u2264 100 000)\u00a0\u2014 the number of tasks. The next n lines contain exactly one integer number a_{i} (1 \u2264 a_{i} \u2264 100 000)\u00a0\u2014 both the difficulty of the initial task and the laziness of the i-th students.\n\n\n-----Output-----\n\nPrint the minimum total time to finish all tasks modulo 10 007.\n\n\n-----Example-----\nInput\n2\n1\n3\n\nOutput\n6\n\n\n\n-----Note-----\n\nIn the first sample, if the students switch their tasks, they will be able to finish them in 3 + 3 = 6 time units.", "solutions": "[\"n=int(input())\\na=sorted(int(input()) for _ in range(n))\\nprint(sum(a[i]*a[-i-1] for i in range(n))%10007)\", \"n = int(input())\\nA = [0] * n\\nfor i in range(n):\\n    per = int(input())\\n    A[i] = per\\nA.sort()\\nanswer = 0\\nfor i in range(n):\\n    answer  = (answer + A[i] * A[n - i - 1]) % 10007\\nprint(answer)\", \"n = int(input())\\nai = []\\nnum = 0\\nfor i in range(n):\\n    ai += [int(input())]\\nai.sort()\\nfor i in range(n//2):\\n    num += ai[n-i-1] * ai[i] * 2\\nif n % 2:\\n    num += ai[n//2] ** 2\\nprint(num % 10007)\\n\", \"n = int(input())\\na =[]\\nb =[]\\nfor i in range(n):\\n\\ta.append(int(input()))\\n\\tb.append(a[len(a)-1])\\na.sort()\\nb.sort()\\nb.reverse()\\nsum = 0\\nfor i in range(n):\\n\\tsum+=(a[i]*b[i])\\n\\tsum%=10007\\nprint(sum)\", \"n = int(input())\\na = [int(input()) for i in range(n)]\\na.sort()\\nprint(sum(map(lambda x,y: x*y, a, reversed(a))) % 10007)\\n\", \"#import sys\\n#sys.stdin=open('input.txt')\\n#a=map(int,input().split())\\nn=int(input())\\nl=[]\\nfor i in range(n):\\n\\tl.append(int(input()))\\nd=l[::]\\nl.sort()\\nd.sort(reverse=True)\\nprint(sum((l[x]*d[x] for x in range(n)))%10007)\\n#print('right:',input())\\n\", \"n = int(input())\\nsp = []\\nfor i in range(n):\\n    sp.append(int(input()))\\nsp.sort()\\ns = 0\\nfor i in range(n):\\n    s = (s + sp[i] * sp[-i-1]) % 10007\\nprint(s)\\n\", \"I=input\\nn=int(I())\\nR=list(range(n))\\na=sorted(int(I())for _ in R)\\nk=0\\nfor i in R:k=(k+a[i]*a[n-i-1])%10007\\nprint(k)\", \"n=int(input())\\nlist=[]\\nsumm=int(0)\\nfor i in range(n):\\n    a=int(input())\\n    list.append(a)\\nrev=list[::]\\nlist.sort()\\nrev.sort(reverse=True)\\nfor x in range(n):\\n    summ=(summ+((list[x]*rev[x])%10007)%10007)%10007\\nprint(summ)\", \"n = int(input())\\na = sorted([int(input()) for i in range(n)])\\n\\ntime = 0\\nfor i in range(n):\\n    time += a[i] * a[n - 1 - i]\\n    \\nprint(time % 10007)\\n\", \"n = int(input())\\nC = []\\nA = [int(input()) for i in range(n)]\\nA.sort()\\nB = A\\nfor x in range(n):\\n    C.append(A[x]*B[n-x-1])\\na = sum(C)\\nprint(a%10007)\\n\", \"n = int(input())\\ndt = sorted([int(input()) for i in range(n)])\\n\\nans = 0\\nfor i in range(n):\\n\\tans += dt[i] * dt[-i-1]\\nprint(ans%10007)\", \"#!/usr/bin/env\\tpython\\n#-*-coding:utf-8 -*-\\nn=int(input())\\nA=sorted(int(input())for _ in range(n))\\nB=10007\\ns=0\\nfor i in range(n):s=(A[i]*A[-1-i]+s)%B\\nprint(s)\\n\", \"n = int(input())\\n\\nnum = [int(input()) for _ in range(n)]\\nnum.sort()\\n\\nbegin = 0\\nend = n-1\\nans = 0\\n\\nwhile begin<=end:\\n    if begin == end:\\n        ans += (num[begin]*num[end])\\n        ans %= 10007\\n    else:\\n        ans += 2*num[begin]*num[end]\\n        ans %= 10007\\n    begin+=1\\n    end-=1\\n        \\nprint(ans)\", \"n = int(input())\\n\\nnum = [int(input()) for _ in range(n)]\\nnum.sort()\\n\\nbegin = 0\\nend = n-1\\nans = 0\\n\\nwhile begin<=end:\\n    if begin == end:\\n        ans += (num[begin]*num[end])\\n        ans %= 10007\\n    else:\\n        ans += 2*num[begin]*num[end]\\n        ans %= 10007\\n    begin+=1\\n    end-=1\\n        \\nprint(ans)\", \"n = int(input())\\nnum = sorted([int(input()) for _ in range(n)])\\nprint(sum([x*y for x,y in zip(num, reversed(num))])%10007)\", \"'''\\na=input()\\nstring=input()\\nn=int(input())\\nlist1=[]\\nscore=0\\n\\nfor i in range(n):\\n    list1.append((input()).split())\\n\\n\\nmaX=int(input())\\n\\nlist2=[0]*len(string)\\nvar = 0\\nwhile n>0:\\n    times = 0\\n    for i in range (len(string)):\\n        if string[i:i+len(list1[var][0])] == list1[var][0] and not maX in list2[i:i+len(list1[var][0])]:\\n            score += int(list1[var][1])\\n            for j in range(i, i+len(list1[var][0])):\\n                list2[j] += 1\\n            if i+len(list1[var][0]) == len(string):\\n                break\\n            if times == maX:\\n                break\\n    var += 1\\n    n -= 1\\n\\nprint(score)\\n'''\\n\\nfinal=0\\nn= int(input())\\nlist1=[]\\n\\nfor i in range(n):\\n    list1.append(int(input()))\\nlist1.sort()\\nfor i in range(n):\\n    final += list1[i] * list1[n-i-1]\\nprint(final%10007)\\n\\n\\n    \\n\", \"\\n\\nn = int(input())\\n\\na = []\\n\\nfor i in range(n): \\n    a.append(int(input()))\\n\\na.sort()\\n\\nb = [];\\n\\nfor i in range(int((n+1)/2)):\\n    b.append(a[i]*a[n-1-i])\\n\\nres = sum(b)*2\\n\\nif n%2 == 1:\\n    res-=b[len(b)-1]\\n\\nprint(res % 10007)\\n\", \"n=int(input())\\na=sorted(int(input()) for _ in range(n))\\nprint(sum(a[i]*a[-i-1] for i in range(n))%10007)\", \"n=int(input())\\nl=[]\\nfor i in range(n):\\n    l.append(int(input()))\\nl.sort()\\nr=l[:];\\nr.reverse()\\nres=0;\\nfor i in range(n):\\n    res=(res+l[i]*r[i])%10007\\nprint(res)\", \"n = int(input())\\na=[]\\nfor i in range(n):\\n    a += [int(input())]\\na.sort()\\nans = 0\\nfor i in range(n):\\n    ans += a[i] * a[n-i-1]\\nprint(ans % 10007)\", \"laziness = []\\nfor i in range(int(input())):\\n    laziness.append(int(input()))\\n\\nlaziness.sort()\\nj = len(laziness) - 1\\nsum = 0\\nfor numb in laziness:\\n    sum += numb * laziness[j]\\n    j -= 1\\n\\nprint(sum % 10007)\\n\", \"num= int(input())\\nwork=[]\\nfor i in range(num):\\n    work.append(int(input()))\\nlaziness= work.copy()\\ntime= 0\\n\\nlaziness.sort()\\nwork.sort()\\nwork=work[::-1]\\n\\nfor i in range(len(work)):\\n    time += work[i] * laziness[i]\\n\\nprint(time % (10007))\\n\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"2\\n1\\n3\\n\"\n  ],\n  \"outputs\": [\n    \"6\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/717/C", "starter_code": ""}
{"id": 53, "question": "Gildong recently learned how to find the longest increasing subsequence (LIS) in $O(n\\log{n})$ time for a sequence of length $n$. He wants to test himself if he can implement it correctly, but he couldn't find any online judges that would do it (even though there are actually many of them). So instead he's going to make a quiz for you about making permutations of $n$ distinct integers between $1$ and $n$, inclusive, to test his code with your output.\n\nThe quiz is as follows.\n\nGildong provides a string of length $n-1$, consisting of characters '<' and '>' only. The $i$-th (1-indexed) character is the comparison result between the $i$-th element and the $i+1$-st element of the sequence. If the $i$-th character of the string is '<', then the $i$-th element of the sequence is less than the $i+1$-st element. If the $i$-th character of the string is '>', then the $i$-th element of the sequence is greater than the $i+1$-st element.\n\nHe wants you to find two possible sequences (not necessarily distinct) consisting of $n$ distinct integers between $1$ and $n$, inclusive, each satisfying the comparison results, where the length of the LIS of the first sequence is minimum possible, and the length of the LIS of the second sequence is maximum possible.\n\n\n-----Input-----\n\nEach test contains one or more test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$).\n\nEach test case contains exactly one line, consisting of an integer and a string consisting of characters '<' and '>' only. The integer is $n$ ($2 \\le n \\le 2 \\cdot 10^5$), the length of the permutation you need to find. The string is the comparison results explained in the description. The length of the string is $n-1$.\n\nIt is guaranteed that the sum of all $n$ in all test cases doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, print two lines with $n$ integers each. The first line is the sequence with the minimum length of the LIS, and the second line is the sequence with the maximum length of the LIS. If there are multiple answers, print any one of them. Each sequence should contain all integers between $1$ and $n$, inclusive, and should satisfy the comparison results.\n\nIt can be shown that at least one answer always exists.\n\n\n-----Example-----\nInput\n3\n3 <<\n7 >><>><\n5 >>><\n\nOutput\n1 2 3\n1 2 3\n5 4 3 7 2 1 6\n4 3 1 7 5 2 6\n4 3 2 1 5\n5 4 2 1 3\n\n\n\n-----Note-----\n\nIn the first case, $1$ $2$ $3$ is the only possible answer.\n\nIn the second case, the shortest length of the LIS is $2$, and the longest length of the LIS is $3$. In the example of the maximum LIS sequence, $4$ '$3$' $1$ $7$ '$5$' $2$ '$6$' can be one of the possible LIS.", "solutions": "[\"import sys\\ninput = sys.stdin.readline\\n\\n\\ndef compress(array):\\n    array2 = sorted(set(array))\\n    memo = {value : index for index, value in enumerate(array2)}\\n    for i in range(len(array)):\\n        array[i] = memo[array[i]] + 1\\n    return array\\n\\n\\nt = int(input())\\nbase = 10 ** 6\\nfor _ in range(t):\\n    n, b = list(map(str, input().split()))\\n    n = int(n)\\n    ans = [0] * n\\n    \\n    now = base\\n    ans[0] = base\\n    for i in range(n - 1):\\n        if b[i] == \\\">\\\":\\n            now -= base\\n            ans[i + 1] = now\\n        else:\\n            now += 1\\n            ans[i + 1] = now\\n    print(*compress(ans))\\n\\n    now = base\\n    ans[0] = base\\n    for i in range(n - 1):\\n        if b[i] == \\\">\\\":\\n            now -= 1\\n            ans[i + 1] = now\\n        else:\\n            now += base\\n            ans[i + 1] = now\\n    print(*compress(ans))\\n\", \"def main():\\n    import sys\\n    input = sys.stdin.readline\\n\\n    for _ in range(int(input())):\\n        line = list(input().split())\\n        N = int(line[0])\\n        S = line[1]\\n\\n        inc_num = S.count('<')\\n        ans = [0] * N\\n        inc = N\\n        dec = N - inc_num\\n        for i in range(N - 1):\\n            if ans[i+1]:\\n                continue\\n            if S[i] == '<':\\n                j = i+1\\n                cnt = 1\\n                while True:\\n                    if j == N-1:\\n                        break\\n                    if S[j] == '<':\\n                       cnt += 1\\n                    else:\\n                        break\\n                    j += 1\\n                #print(cnt)\\n                for j in range(i+cnt-1, i-1, -1):\\n                    #print(j)\\n                    ans[j+1] = inc\\n                    inc -= 1\\n        for i in range(N):\\n            if ans[i] == 0:\\n                ans[i] = dec\\n                dec -= 1\\n        print(*ans)\\n\\n        ans = [0] * N\\n        inc = N - inc_num + 1\\n        dec = N - inc_num\\n        for i in range(N - 1):\\n            if S[i] == '<':\\n                ans[i + 1] = inc\\n                inc += 1\\n        for i in range(N):\\n            if ans[i] == 0:\\n                ans[i] = dec\\n                dec -= 1\\n        print(*ans)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"from sys import stdin,stderr\\ndef rl():\\n    return [int(w) for w in stdin.readline().split()]\\n\\ndef p1(n, s, le):\\n    r = []\\n    b = i = 0\\n    while i < n:\\n        try:\\n            ni = s.index(le, i) + 1\\n        except ValueError:\\n            ni = n\\n        r += list(range(ni, i, -1))\\n        i = ni\\n    return r\\n\\nt, = rl()\\nfor _ in range(t):\\n    n,s = stdin.readline().split()\\n    n = int(n)\\n    print(*(n - x + 1 for x in p1(n, s, '>')))\\n    print(*p1(n, s, '<'))\\n\", \"import sys\\n\\nQ = int(sys.stdin.readline().strip())\\nfor q in range (0, Q):\\n    n, s = sys.stdin.readline().strip().split()\\n    n = int(n)\\n    U = [1]\\n    D = [1]\\n    for i in range (0, n-1):\\n        if s[i] == \\\"<\\\":\\n            U[-1] = U[-1] + 1\\n            D.append(1)\\n        else:\\n            D[-1] = D[-1] + 1\\n            U.append(1)\\n    m = n\\n    i = 0\\n    A = []\\n    while m > 0:\\n        for j in range (0, U[i]):\\n            A.append(str(m-U[i]+j+1))\\n        m = m - U[i]\\n        i = i + 1\\n    print(\\\" \\\".join(A))\\n    m = 0\\n    i = 0\\n    A = []\\n    while i < len(D):\\n        for j in range (0, D[i]):\\n            A.append(str(m+D[i]-j))\\n        m = m + D[i]\\n        i = i + 1\\n    print(\\\" \\\".join(A))\\n\\n\", \"def makeRepeat(s):\\n    repeat = [[s[0], 0]]\\n    for ch in s:\\n        if ch == repeat[-1][0]:\\n            repeat[-1][1] += 1\\n        else:\\n            repeat.append([ch, 1])\\n    return repeat\\n\\n\\ndef solve(N, S):\\n    assert len(S) == N - 1\\n    curr = 0\\n    repeat = makeRepeat(S)\\n    longest = list(range(1, N + 1))\\n    shortest = list(reversed(list(range(1, N + 1))))\\n    for ch, count in repeat:\\n        if ch == \\\">\\\":\\n            longest[curr : curr + count + 1] = reversed(\\n                longest[curr : curr + count + 1]\\n            )\\n        else:\\n            assert ch == \\\"<\\\"\\n            shortest[curr : curr + count + 1] = reversed(\\n                shortest[curr : curr + count + 1]\\n            )\\n        curr += count\\n\\n    # print(\\\" \\\" + \\\" \\\".join(S))\\n    return \\\" \\\".join(map(str, shortest)) + \\\"\\\\n\\\" + \\\" \\\".join(map(str, longest))\\n\\n\\ndef __starting_point():\\n    T, = list(map(int, input().split()))\\n    for t in range(T):\\n        N, S = input().split()\\n        N = int(N)\\n        ans = solve(N, S)\\n        print(ans)\\n\\n__starting_point()\", \"def solve1(n, comps):\\n    ans = []\\n    rng = iter(list(range(1, n + 1)))\\n    for comp in [len(comp) + 1 for comp in comps.split(\\\">\\\")][::-1]:\\n        ans.append([ansi for (_, ansi) in zip(list(range(comp)), rng)])\\n    fin_ans = []\\n    ans.reverse()\\n    for ansi in ans:\\n        fin_ans.extend(ansi)\\n    return fin_ans\\n\\n\\ndef solve2(n, comps):\\n    ans = []\\n    rng = iter(list(range(1, n + 1)))\\n    for comp in [len(comp) + 1 for comp in comps.split(\\\"<\\\")]:\\n        ans.extend([ansi for (_, ansi) in zip(list(range(comp)), rng)][::-1])\\n    return ans\\n\\n\\ndef main():\\n    for _ in range(int(input())):\\n        n, comps = input().split()\\n        n = int(n)\\n        print(*solve1(n, comps))\\n        print(*solve2(n, comps))\\n\\n\\nmain()\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nT = int(input())\\nfor _ in range(T):\\n    n, S = input().split()\\n    n = int(n)\\n    max_ans = [0] * n\\n    i = j = 0\\n    cur = 1\\n    for s in S + '<':\\n        if s == '>':\\n            j += 1\\n        elif s == '<':\\n            for k in range(j, i - 1, -1):\\n                max_ans[k] = cur\\n                cur += 1\\n            j += 1\\n            i = j\\n\\n\\n    min_ans = [0] * n\\n    i = j = 0\\n    cur = 1\\n    for s in S[::-1] + '>':\\n        if s == '<':\\n            j += 1\\n        elif s == '>':\\n            for k in range(j, i - 1, -1):\\n                min_ans[k] = cur\\n                cur += 1\\n            j += 1\\n            i = j\\n    print(*min_ans[::-1])\\n    print(*max_ans)\\n\\n\", \"def getInput():\\n\\tline = input().split()\\n\\treturn int(line[0]), line[1]\\n\\ndef sLIS(n, s):\\n\\tans = list(range(n, 0, -1))\\n\\t\\n\\trev = []\\n\\ti = 0\\n\\twhile i < n-1:\\n\\t\\tif s[i] == '<':\\n\\t\\t\\tj = i+1\\n\\t\\t\\twhile j < n-1 and s[j] == '<':\\n\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\n\\t\\t\\trev.append((i, j))\\n\\t\\t\\ti = j+1\\n\\t\\telse:\\n\\t\\t\\ti += 1\\n\\n\\tfor r in rev:\\n\\t\\ti, j = r\\n\\t\\twhile i <= j:\\n\\t\\t\\tans[i], ans[j] = ans[j], ans[i]\\n\\t\\t\\ti += 1\\n\\t\\t\\tj -= 1\\n\\t\\n\\treturn ans\\n\\ndef lLIS(n, s):\\n\\tans = list(range(1, n+1))\\n\\t\\n\\trev = []\\n\\ti = 0\\n\\twhile i < n-1:\\n\\t\\tif s[i] == '>':\\n\\t\\t\\tj = i+1\\n\\t\\t\\twhile j < n-1 and s[j] == '>':\\n\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\n\\t\\t\\trev.append((i, j))\\n\\t\\t\\ti = j+1\\n\\t\\telse:\\n\\t\\t\\ti += 1\\n\\n\\tfor r in rev:\\n\\t\\ti, j = r\\n\\t\\twhile i <= j:\\n\\t\\t\\tans[i], ans[j] = ans[j], ans[i]\\n\\t\\t\\ti += 1\\n\\t\\t\\tj -= 1\\n\\t\\n\\treturn ans\\n\\nfor _ in range(int(input())):\\n\\tn, s = getInput()\\n\\n\\t\\\"\\\"\\\"\\n\\t\\tp = []\\n\\t\\tc = +1 if s[0] == '<' else -1\\n\\t\\tfor e in s[1:]:\\n\\t\\t\\tif c > 0 and e == '>':\\n\\t\\t\\t\\tp.append(c)\\n\\t\\t\\t\\tc = -1\\n\\t\\t\\telif c < 0 and e == '<':\\n\\t\\t\\t\\tp.append(c)\\n\\t\\t\\t\\tc = +1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tc += +1 if e == '<' else -1\\n\\t\\tp.append(c)\\n\\t\\\"\\\"\\\"\\n\\tprint(*sLIS(n, s))\\n\\tprint(*lLIS(n, s))\\n\", \"Q = int(input())\\n\\n\\ntotal = []\\nfor _ in range(Q):\\n    n, s = input().split()\\n    n=int(n)\\n\\n    seq = []\\n    curlen = 1\\n    for i in range(len(s)):\\n        if s[i]=='<':\\n            curlen+=1\\n        else:\\n            seq.append(curlen)\\n            curlen=1\\n    seq.append(curlen)\\n    curr = n\\n    ans =[]\\n    for sq in seq:\\n        ans.extend(range(curr-sq+1,curr+1))\\n        curr-=sq\\n    total.append(' '.join(map(str,ans)))\\n\\n    curr = n\\n    ans = ['']*n\\n    for i in range(len(s)-1,-1,-1):\\n        if s[i]=='<':\\n            ans[i+1]=str(curr)\\n            curr-=1\\n    for i in range(n):\\n        if not ans[i]:\\n            ans[i]=str(curr)\\n            curr-=1\\n    total.append(' '.join(ans))\\n\\n\\nprint(*total, sep='\\\\n')\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n3 <<\\n7 >><>><\\n5 >>><\\n\"\n  ],\n  \"outputs\": [\n    \"1 2 3\\n1 2 3\\n5 4 3 7 2 1 6\\n4 3 1 7 5 2 6\\n4 3 2 1 5\\n5 4 2 1 3\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1304/D", "starter_code": ""}
{"id": 54, "question": "You are playing a variation of game 2048. Initially you have a multiset $s$ of $n$ integers. Every integer in this multiset is a power of two. \n\nYou may perform any number (possibly, zero) operations with this multiset.\n\nDuring each operation you choose two equal integers from $s$, remove them from $s$ and insert the number equal to their sum into $s$.\n\nFor example, if $s = \\{1, 2, 1, 1, 4, 2, 2\\}$ and you choose integers $2$ and $2$, then the multiset becomes $\\{1, 1, 1, 4, 4, 2\\}$.\n\nYou win if the number $2048$ belongs to your multiset. For example, if $s = \\{1024, 512, 512, 4\\}$ you can win as follows: choose $512$ and $512$, your multiset turns into $\\{1024, 1024, 4\\}$. Then choose $1024$ and $1024$, your multiset turns into $\\{2048, 4\\}$ and you win.\n\nYou have to determine if you can win this game.\n\nYou have to answer $q$ independent queries.\n\n\n-----Input-----\n\nThe first line contains one integer $q$ ($1 \\le q \\le 100$) \u2013 the number of queries.\n\nThe first line of each query contains one integer $n$ ($1 \\le n \\le 100$) \u2014 the number of elements in multiset.\n\nThe second line of each query contains $n$ integers $s_1, s_2, \\dots, s_n$ ($1 \\le s_i \\le 2^{29}$) \u2014 the description of the multiset. It is guaranteed that all elements of the multiset are powers of two. \n\n\n-----Output-----\n\nFor each query print YES if it is possible to obtain the number $2048$ in your multiset, and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).\n\n\n-----Example-----\nInput\n6\n4\n1024 512 64 512\n1\n2048\n3\n64 512 2\n2\n4096 4\n7\n2048 2 2048 2048 2048 2048 2048\n2\n2048 4096\n\nOutput\nYES\nYES\nNO\nNO\nYES\nYES\n\n\n\n-----Note-----\n\nIn the first query you can win as follows: choose $512$ and $512$, and $s$ turns into $\\{1024, 64, 1024\\}$. Then choose $1024$ and $1024$, and $s$ turns into $\\{2048, 64\\}$ and you win.\n\nIn the second query $s$ contains $2048$ initially.", "solutions": "[\"for i in range(int(input())):\\n    n=int(input())\\n    s=list(map(int,input().split()))\\n    a=0\\n    for i in s:\\n        if i<2049:a+=i\\n    if a<2048:print(\\\"NO\\\")\\n    else:print(\\\"YES\\\")\", \"t=int(input())\\nfor i in range(t):\\n    n=int(input())\\n    a=list(map(int,input().split()))\\n    a.sort(reverse=True)\\n    s=0\\n    for j in a:\\n        if j<=2048:\\n            s+=j\\n        if s==2048:\\n            print(\\\"YES\\\")\\n            break\\n    else:\\n        print(\\\"NO\\\")\\n\\n\", \"q = int(input())\\nfor i in range(q):\\n    n = int(input())\\n    a = [int(x) for x in input().split()]\\n    a.sort()\\n    s = 0\\n    for i in a:\\n        if i <= 2048:\\n            s += i\\n    print(\\\"YES\\\" if s >= 2048 else \\\"NO\\\")\\n\", \"for _ in range(int(input())):\\n\\tn = int(input())\\n\\ta = [*map(int, input().split())]\\n\\ta.sort(reverse=True)\\n\\tt = 2048\\n\\n\\tfor i in a:\\n\\t\\tif t - i >= 0:\\n\\t\\t\\tt -= i\\n\\n\\tprint(['NO', 'YES'][t == 0])\", \"q = int(input())\\nwhile q:\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    a.sort()\\n    i = 0\\n    d = False\\n    while i < len(a) - 1:\\n        if 2048 in a:\\n            d = True\\n            break\\n        if a[i] == a[i + 1]:\\n            a.append(a[i] + a[i + 1])\\n            a.sort()\\n            i += 2\\n        else:\\n            i += 1  \\n    if 2048 in a:\\n        d = True\\n    if d:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n    q -= 1\", \"t=int(input())\\nfor nt in range(t):\\n\\tn=int(input())\\n\\tl=list(map(int,input().split()))\\n\\tnew=[]\\n\\tfor i in l:\\n\\t\\tif i<=2048:\\n\\t\\t\\tnew.append(i)\\n\\tnew.sort()\\n\\tif 2048 in new:\\n\\t\\tprint (\\\"YES\\\")\\n\\telse:\\n\\t\\ts=0\\n\\t\\tflag=0\\n\\t\\tfor i in range(len(new)-1,-1,-1):\\n\\t\\t\\ts+=new[i]\\n\\t\\t\\tif s==2048:\\n\\t\\t\\t\\tprint (\\\"YES\\\")\\n\\t\\t\\t\\tflag=1\\n\\t\\t\\t\\tbreak\\n\\t\\tif flag==0:\\n\\t\\t\\tprint (\\\"NO\\\")\", \"for _ in range(int(input())):\\n    n=int(input())\\n    arr=list(map(int,input().split()))\\n    s=0\\n    for i in arr:\\n        if i<=2048:\\n            s+=i\\n    if s>=2048:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\\n\", \"import sys\\nfrom collections import defaultdict\\nfrom itertools import combinations\\nfrom itertools import permutations\\ninput = lambda : sys.stdin.readline().rstrip()\\ndef write(*args, sep=\\\" \\\"):\\n  for i in args:\\n    sys.stdout.write(\\\"{}\\\".format(i) + sep)\\nINF = float('inf')\\nMOD = int(1e9 + 7)\\n\\nfor t in range(int(input())):\\n  n = int(input())\\n  arr = list(map(int, input().split()))\\n  d = defaultdict(int) \\n\\n  for i in arr:\\n    d[i] += 1\\n  \\n  for i in range(0, 11):\\n    x = d[1 << i] // 2\\n    d[1 << (i + 1)] += x \\n  if d[2048]:\\n    print(\\\"YES\\\")\\n  else:\\n    print(\\\"NO\\\")\\n\\n\", \"q = int(input())\\nfor rew in range(q):\\n\\tn = int(input())\\n\\tl = list(map(int,input().split()))\\n\\tl.sort()\\n\\twhile True:\\n\\t\\tif 2048 in l:\\n\\t\\t\\tprint(\\\"YES\\\")\\n\\t\\t\\tbreak\\n\\t\\tif len(l) == 0:\\n\\t\\t\\tprint(\\\"NO\\\")\\n\\t\\t\\tbreak\\n\\t\\tif len(l) > 1 and l[0] == l[1]:\\n\\t\\t\\tl = [2*l[0]] + l[2:]\\n\\t\\telse:\\n\\t\\t\\tl = l[1:]\\n\\t\\tl.sort()\\n\", \"t = int(input())\\n\\nfor _ in range(t):\\n _ = input()\\n L = [int(x) for x in input().split() if int(x) <= 2048]\\n print(\\\"YES\\\" if sum(L) >= 2048 else \\\"NO\\\")\", \"import collections\\n\\ndef solve():\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    d = collections.defaultdict(int)\\n    for i in a:\\n        d[i] += 1\\n    for i in range(11):\\n        d[2 ** (i + 1)] += d[2 ** i] // 2\\n\\n    if d[2 ** 11]:\\n        print('YES')\\n    else:\\n        print('NO')\\n\\nt = int(input())\\n\\nfor _ in range(t):\\n    solve()\\n\\n\", \"q=int(input())\\nfor t in range(q):\\n      n=int(input())\\n      l=list(map(int,input().split()))\\n      tot=0\\n      for i in range(n):\\n            if(l[i]<=2048):\\n                  tot+=l[i]\\n      if(tot>=2048):\\n            print(\\\"YES\\\")\\n      else:\\n            print(\\\"NO\\\")\\n\", \"tgt = (2048).bit_length() - 1\\nfor _ in range(int(input())):\\n    n = int(input())\\n    c = [0] * 31\\n    for x in input().split():\\n        c[int(x).bit_length() - 1] += 1\\n    for i in range(tgt):\\n        c[i + 1] += c[i] // 2\\n    print('YES' if c[tgt] else 'NO')\", \"T = int(input())\\n\\nwhile T > 0:\\n    T -= 1\\n    n = int(input())\\n    A = map(int, input().split())\\n\\n    cnt = [0] * 40\\n\\n    for i in A:\\n        pw = 0\\n        while i > 1:\\n            i //= 2\\n            pw += 1\\n        cnt[pw] += 1\\n    \\n    for i in range(12):\\n        cnt[i+1] += cnt[i] // 2\\n\\n    if cnt[11] > 0:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"q = int(input())\\nfor i in range(q):\\n    n = int(input())\\n    s1 = list(map(int,input().split()))\\n    s1.sort()\\n    num = 0\\n    for i in s1:\\n        if i > 2048:\\n            break\\n        num += i\\n    if num >= 2048:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"q = int(input())\\nfor _ in range(q):\\n    n = int(input())\\n    s = list(map(int, input().split()))\\n    beki = [0]*50\\n    for i in range(n):\\n        beki[s[i].bit_length()-1] += 1\\n\\n    for i in range(29):\\n        beki[i+1] += beki[i]//2\\n\\n    if beki[11] > 0:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    S = [d for d in map(int, input().split()) if d <= 2048]\\n    if sum(S) >= 2048:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"for _ in range(int(input())):\\n    n = int(input())\\n    l = [int(i) if int(i) <= 2048 else 0 for i in input().split()]\\n    if(sum(l)>=2048):\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"t = int(input())\\nfor _ in range(t):\\n    input()\\n    s = [int(x) for x in input().split()]\\n    mysum = sum([x for x in s if x <= 2048])\\n    print(\\\"YES\\\" if mysum >= 2048 else \\\"NO\\\")\\n\\n\", \"from sys import stdin\\nq=int(stdin.readline().strip())\\nfor i in range(q):\\n    n=int(stdin.readline().strip())\\n    s=list(map(int,stdin.readline().strip().split()))\\n    flag=False\\n    for j in range(12):\\n        \\n        x=2**j\\n\\n        s1=[]\\n        cnt=0\\n        for k in range(len(s)):\\n            if s[k]==x:\\n                cnt+=1\\n            else:\\n                s1.append(s[k])\\n            if s[k]==2048:\\n                flag=True\\n        y=cnt//2\\n        s1=s1+[x*2]*y\\n        s=s1.copy()\\n    if flag:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"for _ in range(int(input())):\\n    N = int(input())\\n    num = list(map(int, input().split()))\\n    num.sort(reverse=True)\\n    x = 0\\n    ans = 'NO'\\n    for k in num:\\n        if k > 2048: continue\\n        else: x += k\\n        if x == 2048: ans = 'YES'\\n    print(ans)\", \"Q = int(input())\\n\\ndef solve():\\n    N = int(input())\\n    S = list(map(int, input().split()))\\n    S = sorted(S)\\n\\n    while len(S) > 1:\\n        if S[0] == 2048:\\n            return True\\n\\n        if S[0] == S[1]:\\n            S = [2*S[0]] + S[2:]\\n        else:\\n            S = S[1:]\\n        S = sorted(S)\\n        \\n    return 2048 in S\\n    \\n\\nfor _ in range(Q):\\n    if solve():\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"6\\n4\\n1024 512 64 512\\n1\\n2048\\n3\\n64 512 2\\n2\\n4096 4\\n7\\n2048 2 2048 2048 2048 2048 2048\\n2\\n2048 4096\\n\"\n  ],\n  \"outputs\": [\n    \"YES\\nYES\\nNO\\nNO\\nYES\\nYES\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1221/A", "starter_code": ""}
{"id": 55, "question": "A penguin Rocher has $n$ sticks. He has exactly one stick with length $i$ for all $1 \\le i \\le n$.\n\nHe can connect some sticks. If he connects two sticks that have lengths $a$ and $b$, he gets one stick with length $a + b$. Two sticks, that were used in the operation disappear from his set and the new connected stick appears in his set and can be used for the next connections.\n\nHe wants to create the maximum number of sticks that have the same length. It is not necessary to make all sticks have the same length, some sticks can have the other length. How many sticks with the equal length he can create?\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases. Next $t$ lines contain descriptions of test cases.\n\nFor each test case, the only line contains a single integer $n$ ($1 \\le n \\le 10^{9}$).\n\n\n-----Output-----\n\nFor each test case, print a single integer \u00a0\u2014 the answer to the problem.\n\n\n-----Example-----\nInput\n4\n1\n2\n3\n4\n\nOutput\n1\n1\n2\n2\n\n\n\n-----Note-----\n\nIn the third case, he can connect two sticks with lengths $1$ and $2$ and he will get one stick with length $3$. So, he will have two sticks with lengths $3$.\n\nIn the fourth case, he can connect two sticks with lengths $1$ and $3$ and he will get one stick with length $4$. After that, he will have three sticks with lengths $\\{2, 4, 4\\}$, so two sticks have the same length, and one stick has the other length.", "solutions": "[\"for __ in range(int(input())):\\n    n = int(input())\\n    print((n + 1) // 2)\", \"from math import ceil\\nt = int(input())\\n\\nfor _ in range(t):\\n    n = int(input())\\n    print(int(ceil(n/2)))\", \"for _ in range(int(input())):\\n      print((int(input())+1)//2)\", \"tests = int(input())\\nfor _ in range(tests):\\n    n = int(input())\\n    print((n + 1) // 2)\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    print((n + 1) // 2)\\n    \\n\", \"t = int(input())\\nfor test in range(t):\\n    a = int(input())\\n    print((a+1)//2)\", \"\\nt=int(input())\\nfor _ in range(t):\\n    n=int(input())\\n    print((n+1)//2)\", \"#list(map(int,input().split()))\\n\\nt=int(input())\\nfor _ in range(t):\\n    n=int(input())\\n    print((n+1)//2)\\n\", \"# for _ in range(1):\\nfor _ in range(int(input())):\\n    # a, b = map(int, input().split())\\n    n = int(input())\\n    # arr = list(map(int, input().split()))\\n    # s = input()\\n    x = (n + 1) // 2\\n    print(x)\\n\", \"from math import ceil\\nfor _ in range(int(input())):\\n    print(ceil(int(input())/2))\", \"for _ in range(int(input())):\\n    n = int(input())\\n    print((n + 1) // 2)\\n    #n, m = map(int, input().split())\\n    '''A = list(map(int, input().split()))\\n    Ans = 0\\n    for i in range(len(A)):'''\\n\", \"from math import *\\n\\ndef r1(t):\\n    return t(input())\\n\\ndef r2(t):\\n    return [t(i) for i in input().split()]\\n\\nfor _ in range(r1(int)):\\n    n = r1(int)\\n    print((n + 1) // 2)\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    print((n+1)//2)\", \"q = int(input())\\nfor _ in range(q):\\n    a = int(input())\\n    print((a+1)//2)\", \"import sys\\nimport math\\ndef II():\\n\\treturn int(sys.stdin.readline())\\n\\ndef LI():\\n\\treturn list(map(int, sys.stdin.readline().split()))\\n\\ndef MI():\\n\\treturn map(int, sys.stdin.readline().split())\\n\\ndef SI():\\n\\treturn sys.stdin.readline().strip()\\nt = II()\\nfor q in range(t):\\n\\tn = II()\\n\\tprint(math.ceil(n/2))\", \"import sys\\nimport math\\nimport itertools\\nimport functools\\nimport collections\\nimport operator\\nimport fileinput\\nimport copy\\n\\nORDA = 97  # a\\ndef ii(): return int(input())\\ndef mi(): return list(map(int, input().split()))\\ndef li(): return [int(i) for i in input().split()]\\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\\ndef revn(n): return str(n)[::-1]\\ndef dd(): return collections.defaultdict(int)\\ndef ddl(): return collections.defaultdict(list)\\ndef sieve(n):\\n    if n < 2: return list()\\n    prime = [True for _ in range(n + 1)]\\n    p = 3\\n    while p * p <= n:\\n        if prime[p]:\\n            for i in range(p * 2, n + 1, p):\\n                prime[i] = False\\n        p += 2\\n    r = [2]\\n    for p in range(3, n + 1, 2):\\n        if prime[p]:\\n            r.append(p)\\n    return r\\ndef divs(n, start=1):\\n    r = []\\n    for i in range(start, int(math.sqrt(n) + 1)):\\n        if (n % i == 0):\\n            if (n / i == i):\\n                r.append(i)\\n            else:\\n                r.extend([i, n // i])\\n    return r\\ndef divn(n, primes):\\n    divs_number = 1\\n    for i in primes:\\n        if n == 1:\\n            return divs_number\\n        t = 1\\n        while n % i == 0:\\n            t += 1\\n            n //= i\\n        divs_number *= t\\ndef prime(n):\\n    if n == 2: return True\\n    if n % 2 == 0 or n <= 1: return False\\n    sqr = int(math.sqrt(n)) + 1\\n    for d in range(3, sqr, 2):\\n        if n % d == 0: return False\\n    return True\\ndef convn(number, base):\\n    newnumber = 0\\n    while number > 0:\\n        newnumber += number % base\\n        number //= base\\n    return newnumber\\ndef cdiv(n, k): return n // k + (n % k != 0)\\ndef ispal(s):\\n    for i in range(len(s) // 2 + 1):\\n        if s[i] != s[-i - 1]:\\n            return False\\n    return True\\n\\nfor _ in range(ii()):\\n    print(math.ceil(ii() / 2))\\n\\n\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nans = []\\nfor i in range(int(input())):\\n    n = int(input())\\n    ans.append(n//2 + n %2)\\n\\nprint(*ans,sep='\\\\n')\", \"import sys\\ninput = lambda :sys.stdin.readline().rstrip()\\nfor _ in range(int(input())):\\n\\tn=int(input())\\n\\tprint(n//2 + (1 if n%2 else 0))\", \"def solve():\\n    print((int(input()) + 1) // 2)\\n\\n\\nfor i in range(int(input())):\\n    solve()\\n\", \"import sys\\n# from collections import deque\\n# from collections import Counter\\n# from math import sqrt\\n# from math import log\\nfrom math import ceil\\n# from bisect import bisect_left, bisect_right\\n\\n# alpha=['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\\n# mod=10**9+7\\n# mod=998244353\\n\\n# def BinarySearch(a,x): \\n# \\ti=bisect_left(a,x) \\n# \\tif(i!=len(a) and a[i]==x): \\n# \\t\\treturn i \\n# \\telse: \\n# \\t\\treturn -1\\n\\n# def sieve(n): \\n# \\tprime=[True for i in range(n+1)]\\n# \\tp=2\\n# \\twhile(p*p<=n): \\n# \\t\\tif (prime[p]==True): \\n# \\t\\t\\tfor i in range(p*p,n+1,p): \\n# \\t\\t\\t\\tprime[i]=False\\n# \\t\\tp+=1\\n# \\tprime[0]=False\\n# \\tprime[1]=False\\n# \\ts=set()\\n# \\tfor i in range(len(prime)):\\n# \\t\\tif(prime[i]):\\n# \\t\\ts.add(i)\\n# \\treturn s\\n\\n# def gcd(a, b):\\n# \\tif(a==0):\\n# \\t\\treturn b \\n# \\treturn gcd(b%a,a)\\n\\nfast_reader=sys.stdin.readline\\nfast_writer=sys.stdout.write\\n\\ndef input():\\n\\treturn fast_reader().strip()\\n\\ndef print(*argv):\\n\\tfast_writer(' '.join((str(i)) for i in argv))\\n\\tfast_writer('\\\\n')\\n\\n#____________________________________________________________________________________________________________________________________\\n\\nfor _ in range(int(input())):\\n\\tn=int(input())\\n\\tprint(ceil(n/2))\", \"t = int(input())\\n\\nfor _ in range(t):\\n    a = int(input())\\n    print((a + 1) // 2)\\n\", \"#!usr/bin/env python3\\nfrom collections import defaultdict, deque\\nfrom heapq import heappush, heappop\\nfrom itertools import permutations, accumulate\\nimport sys\\nimport math\\nimport bisect\\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\\ndef I(): return int(sys.stdin.readline())\\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\\ndef S():\\n    res = list(sys.stdin.readline())\\n    if res[-1] == \\\"\\\\n\\\":\\n        return res[:-1]\\n    return res\\ndef IR(n):\\n    return [I() for i in range(n)]\\ndef LIR(n):\\n    return [LI() for i in range(n)]\\ndef SR(n):\\n    return [S() for i in range(n)]\\ndef LSR(n):\\n    return [LS() for i in range(n)]\\n\\nsys.setrecursionlimit(1000000)\\nmod = 1000000007\\n\\ndef solve():\\n    t = I()\\n    for _ in range(t):\\n        n = I()\\n        print((n+1)>>1)\\n    return\\n\\n#Solve\\ndef __starting_point():\\n    solve()\\n\\n__starting_point()\", \"import sys\\ninput = sys.stdin.readline\\n\\nT = int(input())\\n\\nfor t in range(T):\\n    N = int(input())\\n    print((N+1)//2)\\n\", \"import sys\\nINF = 10**20\\nMOD = 10**9 + 7\\nI = lambda:list(map(int,input().split()))\\nfrom math import gcd\\nfrom math import ceil\\nfrom collections import defaultdict as dd, Counter\\nfrom bisect import bisect_left as bl, bisect_right as br\\n\\n\\n\\\"\\\"\\\"\\nFacts and Data representation\\nConstructive? Top bottom up down\\n\\\"\\\"\\\"\\ndef solve():\\n  n, = I()\\n  if n % 2:\\n    print(1 + n // 2)\\n  else:\\n    print(n // 2)\\n\\nt, = I()\\nwhile t:\\n  t -= 1\\n  solve()\", \"t=int(input())\\nfor i in range(t):\\n    n=int(input())\\n    print((n+1)//2)\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n1\\n2\\n3\\n4\\n\"\n  ],\n  \"outputs\": [\n    \"1\\n1\\n2\\n2\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1371/A", "starter_code": ""}
{"id": 56, "question": "A mad scientist Dr.Jubal has made a competitive programming task. Try to solve it!\n\nYou are given integers $n,k$. Construct a grid $A$ with size $n \\times n$ consisting of integers $0$ and $1$. The very important condition should be satisfied: the sum of all elements in the grid is exactly $k$. In other words, the number of $1$ in the grid is equal to $k$.\n\nLet's define:  $A_{i,j}$ as the integer in the $i$-th row and the $j$-th column.  $R_i = A_{i,1}+A_{i,2}+...+A_{i,n}$ (for all $1 \\le i \\le n$).  $C_j = A_{1,j}+A_{2,j}+...+A_{n,j}$ (for all $1 \\le j \\le n$).  In other words, $R_i$ are row sums and $C_j$ are column sums of the grid $A$.  For the grid $A$ let's define the value $f(A) = (\\max(R)-\\min(R))^2 + (\\max(C)-\\min(C))^2$ (here for an integer sequence $X$ we define $\\max(X)$ as the maximum value in $X$ and $\\min(X)$ as the minimum value in $X$). \n\nFind any grid $A$, which satisfies the following condition. Among such grids find any, for which the value $f(A)$ is the minimum possible. Among such tables, you can find any.\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 100$)\u00a0\u2014 the number of test cases. Next $t$ lines contain descriptions of test cases.\n\nFor each test case the only line contains two integers $n$, $k$ $(1 \\le n \\le 300, 0 \\le k \\le n^2)$.\n\nIt is guaranteed that the sum of $n^2$ for all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, firstly print the minimum possible value of $f(A)$ among all tables, for which the condition is satisfied.\n\nAfter that, print $n$ lines contain $n$ characters each. The $j$-th character in the $i$-th line should be equal to $A_{i,j}$.\n\nIf there are multiple answers you can print any.\n\n\n-----Example-----\nInput\n4\n2 2\n3 8\n1 0\n4 16\n\nOutput\n0\n10\n01\n2\n111\n111\n101\n0\n0\n0\n1111\n1111\n1111\n1111\n\n\n\n-----Note-----\n\nIn the first test case, the sum of all elements in the grid is equal to $2$, so the condition is satisfied. $R_1 = 1, R_2 = 1$ and $C_1 = 1, C_2 = 1$. Then, $f(A) = (1-1)^2 + (1-1)^2 = 0$, which is the minimum possible value of $f(A)$.\n\nIn the second test case, the sum of all elements in the grid is equal to $8$, so the condition is satisfied. $R_1 = 3, R_2 = 3, R_3 = 2$ and $C_1 = 3, C_2 = 2, C_3 = 3$. Then, $f(A) = (3-2)^2 + (3-2)^2 = 2$. It can be proven, that it is the minimum possible value of $f(A)$.", "solutions": "[\"for _ in range(int(input())):\\n    n, k = map(int, input().split())\\n    mat = [[0] * n for _ in range(n)]\\n    for i in range(n):\\n        b = False\\n        for j in range(n):\\n            if i*n+j == k:\\n                b = True\\n                break\\n            mat[(i+j)%n][j] = 1\\n        if b:\\n            break\\n    if k%n == 0:\\n        print(0)\\n    else:\\n        print(2)\\n    for i in range(n):\\n        for j in range(n):\\n            print(mat[i][j], end=\\\"\\\")\\n        print()\\n\", \"q = int(input())\\nfor _ in range(q):\\n    n, k = list(map(int,input().split()))\\n    odp = [[0] * n for i in range(n)]\\n    cur = [0,0]\\n    zap = 0\\n    while True:\\n        if zap >= k:\\n            break\\n        odp[cur[0]][cur[1]] = 1\\n        zap += 1\\n        cur[0] = (cur[0]+1)%n\\n        cur[1] = (cur[1]+1)%n\\n        if cur[0] == 0:\\n            cur[1] = zap//n\\n    if k%n == 0:\\n        print(0)\\n    else:\\n        print(2)\\n    for i in range(n):\\n        print(\\\"\\\".join(list(map(str,odp[i]))))\\n\", \"for _ in range(int(input())):\\n    n,k=list(map(int,input().split()))\\n    ans=[[\\\"0\\\" for j in range(n)] for i in range(n)]\\n    posx=0\\n    posy=0\\n    count=k\\n    while count:\\n        ans[posx][posy]=\\\"1\\\"\\n        count-=1\\n        if (k-count)%n!=0:\\n            posx=(posx+1)%n\\n            posy=(posy+1)%n\\n        else:\\n            posx=(posx+1)%n\\n            posy=(posy+2)%n\\n\\n    res=0\\n    R=[sum(int(ans[i][j]) for j in range(n)) for i in range(n)]\\n    C=[sum(int(ans[i][j]) for i in range(n)) for j in range(n)]\\n    res=(max(R)-min(R))**2+(max(C)-min(C))**2\\n    print(res)\\n    for i in range(n):\\n        print(\\\"\\\".join(ans[i]))\\n\", \"mod = 1000000007\\neps = 10**-9\\n\\n\\ndef main():\\n    import sys\\n    input = sys.stdin.readline\\n\\n    for _ in range(int(input())):\\n        N, K = list(map(int, input().split()))\\n        if K % N == 0:\\n            print(0)\\n        else:\\n            print(2)\\n        ans = [[0] * N for _ in range(N)]\\n        cnt = 0\\n        flg = 0\\n        for p in range(N):\\n            if flg:\\n                break\\n            for i in range(N):\\n                if cnt == K:\\n                    flg = 1\\n                    break\\n                ans[i][(i+p)%N] = 1\\n                cnt += 1\\n        for i in range(N):\\n            print(\\\"\\\".join(map(str, ans[i])))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import sys\\nlines = sys.stdin.readlines()\\nT = int(lines[0].strip())\\n# (N, K) = map(int, lines[0].strip().split(\\\" \\\"))\\nfor t in range(T):\\n    (a, b) = map(int, lines[t+1].strip().split(\\\" \\\"))\\n    res = [[0 for _ in range(a)] for _ in range(a)]\\n    rema = b % a\\n    deno = b // a\\n    if rema == 0: val = 0\\n    else: val = 2\\n    for i in range(a):\\n        if i < rema:\\n            for j in range(deno+1):\\n                res[i][(i+j)%a] = 1\\n        else:\\n            for j in range(deno):\\n                res[i][(i+j)%a] = 1\\n    print(val)\\n    for i in range(a):\\n        print(''.join(map(str, res[i])))\", \"import sys\\ninput = sys.stdin.readline\\nfor f in range(int(input())):\\n    n,k=list(map(int,input().split()))\\n    sm=k//n\\n    bg=sm\\n    toad=k%n\\n    if toad!=0:\\n        bg+=1\\n    print(2*(bg-sm)**2)\\n    for i in range(n):\\n        line=\\\"\\\"\\n        for j in range(n):\\n            x=i+j\\n            x%=n\\n            if x<=sm:\\n                if x<sm or i<toad:\\n                    line+=\\\"1\\\"\\n                else:\\n                    line+=\\\"0\\\"\\n            else:\\n                line+=\\\"0\\\"\\n        print(line)\\n\", \"t=int(input())\\nfor _ in range(t):\\n  n,k=map(int,input().split())\\n  a=k//n\\n  rem=k%n\\n  grid=[]\\n  for i in range(n):\\n    grid.append([])\\n    for j in range(n):\\n      grid[-1].append('0')\\n  for i in range(n):\\n    for j in range(i,i+a):\\n      grid[i][j%n]='1'\\n    if i<rem:\\n      grid[i][(i+a)%n]='1'\\n  ans=0\\n  r=[]\\n  for i in range(n):\\n    p=0\\n    for j in range(n):\\n      if grid[i][j]=='1':\\n        p+=1\\n    r.append(p)\\n  c=[]\\n  for i in range(n):\\n    p=0\\n    for j in range(n):\\n      if grid[j][i]=='1':\\n        p+=1\\n    c.append(p)\\n  print((max(r)-min(r))**2+(max(c)-min(c))**2)\\n  for i in range(n):\\n    ans=''.join(grid[i])\\n    print(ans)\", \"import sys\\ninput=lambda: sys.stdin.readline().rstrip()\\nt=int(input())\\nfor _ in range(t):\\n  n,k=map(int,input().split())\\n  if k%n==0:\\n    print(0)\\n  else:\\n    print(2)\\n  for i in range(n):\\n    ans=\\\"\\\"\\n    if i<k%n:\\n      ans=\\\"1\\\"*(k//n+1)+\\\"0\\\"*(n-(k//n+1))\\n      ans=ans[i:]+ans[:i]\\n\\n    else:\\n      ans=\\\"1\\\"*(k//n)+\\\"0\\\"*(n-(k//n))\\n      ans=ans[i:]+ans[:i]\\n    print(ans)\", \"import sys\\ninput = sys.stdin.readline\\nt = int(input())\\nfor _ in range(t):\\n  n,k = map(int,input().split())\\n  if k%n:\\n    print(2)\\n  else:\\n    print(0)\\n  ans = [[0 for i in range(n)] for j in range(n)]\\n  if k == 0:\\n    for i in ans:\\n      print(*i,sep=\\\"\\\")\\n    continue\\n  for i in range(n):\\n    for j in range(n):\\n      ans[j][(i+j)%n] = 1\\n      k -= 1\\n      if k == 0:\\n        break\\n    else:\\n      continue\\n    break\\n  for i in ans:\\n    print(*i,sep=\\\"\\\")\", \"import sys\\ninput=sys.stdin.readline\\nt=int(input())\\nfor i in range(t):\\n    n,k=map(int,input().split())\\n    m=k//n\\n    r=k%n\\n    if r:\\n        print(2)\\n        s='1'*(m+1)+'0'*(n-m-1)\\n        for i in range(r):\\n            print(s)\\n            s=s[1:]+s[0]\\n        i=(m-r)%n\\n        s=s[:i]+'0'+s[i+1:]\\n        for i in range(n-r):\\n            print(s)\\n            s=s[1:]+s[0]\\n    else:\\n        print(0)\\n        s='1'*m+'0'*(n-m)\\n        for i in range(n):\\n            print(s)\\n            s=s[1:]+s[0]\", \"def solve():\\n    n, m = map(int, input().split())\\n    ans = 2 if m % n else 0\\n    a = [[0] * n for _ in range(n)]\\n    for i in range(n):\\n        if m <= 0:\\n            break\\n        for j in range(n):\\n            if m <= 0:\\n                break\\n            a[j][(i + j) % n] = 1\\n            m -= 1\\n    print(ans)\\n    for i in a:\\n        print(*i, sep='')\\n\\nt = int(input())\\nfor _ in range(t):\\n    solve()\", \"t=int(input())\\nfor _ in range(t):\\n    n,k=map(int,input().split())\\n    board=[[0]*n for _ in range(n)]\\n    cnt=0\\n    for i in range(n):\\n        for j in range(n):\\n            if cnt==k:\\n                break\\n            board[(j+i)%n][j]=1\\n            cnt+=1\\n        if cnt==k:\\n            break\\n    if k%n==0:\\n        print(0)\\n    else:\\n        maxs=(k+n-1)//n\\n        mins=k//n\\n        print(2*((maxs-mins)**2))\\n    for i in range(n):\\n        print(''.join(map(str,board[i])))\", \"import sys\\ninput = sys.stdin.readline\\n\\nimport math\\n\\nT = int(input())\\n\\n\\ndef f(M):\\n    minR = math.inf\\n    maxR = -math.inf\\n    minC = math.inf\\n    maxC = -math.inf\\n\\n    for i in range(len(M)):\\n        sumRow = sum(M[i])\\n        minR = min(minR, sumRow)\\n        maxR = max(maxR, sumRow)\\n\\n        sumCol = sum([M[el][i] for el in range(len(M))])\\n        maxC = max(maxC, sumCol)\\n        minC = min(minC, sumCol)\\n\\n    return (maxR - minR)**2 + (maxC - minC)**2\\n\\nfor t in range(T):\\n    N, K = [int(_) for _ in input().split()]\\n    M = [[0] * N for i in range(N)]\\n\\n    # save = set()\\n\\n    for i in range(K):\\n        # assert (i%N, (i//N + i)%N) not in save\\n        # save.add((i%N, (i//N + i)%N))\\n        M[i%N][(i//N + i)%N] = 1\\n\\n    print(f(M))\\n    for row in M:\\n        print(''.join(map(str, row)))\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\nfor tests in range(t):\\n    n,k=list(map(int,input().split()))\\n\\n    ANS=[[0]*n for i in range(n)]\\n\\n    o=k//n\\n    m=k-o*n\\n\\n    now=0\\n    for i in range(n):\\n        if i<m:\\n            for j in range(o+1):\\n                ANS[i][now]=1\\n                now=(now+1)%n\\n\\n        else:\\n            for j in range(o):\\n                ANS[i][now]=1\\n                now=(now+1)%n\\n\\n    if m==0:\\n        print(0)\\n    else:\\n        print(2)\\n\\n    for ans in ANS:\\n        print(\\\"\\\".join(map(str,ans)))\\n        \\n    \\n\\n    \\n    \\n\", \"import sys\\ninput = sys.stdin.readline\\nfor _ in range(int(input())):\\n  n, k = map(int, input().split())\\n  res = [[\\\"0\\\"] * n for _ in range(n)]\\n  if k % n: print(2)\\n  else: print(0)\\n  for d in range(n):\\n    for i in range(n):\\n      if k == 0: break\\n      res[i][(i + d) % n] = \\\"1\\\"\\n      k -= 1\\n  for r in res: print(\\\"\\\".join(r))\", \"\\ntt = int(input())\\n\\nfor loop in range(tt):\\n\\n    n,k = list(map(int,input().split()))\\n\\n    lis = [ [0] * n for i in range(n) ]\\n\\n    ns = 0\\n    for si in range(n):\\n\\n        if ns == k:\\n            break\\n\\n        for i in range(n):\\n\\n            lis[(si+i)%n][i] = 1\\n            ns += 1\\n\\n            if ns == k:\\n                break\\n        else:\\n            continue\\n        break\\n\\n    R = []\\n    for i in range(n):\\n        now = 0\\n        for j in range(n):\\n            now += lis[i][j]\\n        R.append(now)\\n\\n    C = []\\n    for i in range(n):\\n        now = 0\\n        for j in range(n):\\n            now += lis[j][i]\\n        C.append(now)\\n\\n    print((max(R)-min(R))**2 + (max(C)-min(C))**2)\\n    for i in lis:\\n        print(\\\"\\\".join(map(str,i)))\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n, k = map(int, input().split())\\n    table = [[0 for i in range(n)] for j in range(n)]\\n    if k % n == 0:\\n        print(0)\\n    else:\\n        print(2)\\n    i = 0\\n    j = 0\\n    bias = 0\\n    for __ in range(k):\\n        table[i][j % n] = 1\\n        i += 1\\n        j += 1\\n        if i >= n:\\n            bias += 1\\n            i = 0\\n            j = bias\\n    for i in table:\\n        print(''.join(map(str, i)))\", \"for __ in range(int(input())):\\n    n, k = list(map(int, input().split()))\\n    ans = [[0] * n for i in range(n)]\\n    i, j = 0, 0\\n    while k > 0:\\n        while i < n and k > 0:\\n            ans[i][j] = 1\\n            i += 1\\n            j += 1\\n            k -= 1\\n            j %= n\\n        i = 0\\n        j += 1\\n    a1, a2, b1, b2 = 10 ** 9, 0, 10 ** 9, 0\\n    for i in range(n):\\n        a1 = min(a1, ans[i].count(1))\\n        a2 = max(a2, ans[i].count(1))\\n    for i in range(n):\\n        kek1 = 0\\n        for j in range(n):\\n            if ans[j][i] == 1:\\n                kek1 += 1\\n        b1 = min(b1, kek1)\\n        b2 = max(b2, kek1)\\n    print((a2 - a1) ** 2 + (b2 - b1) ** 2)\\n    for elem in ans:\\n        print(''.join(map(str, elem)))\", \"def solve(n, k):\\n    matrix = [[0 for _ in range(n)] for _ in range(n)]\\n    for right_move in range(n):\\n        for height in range(n):\\n            if k == 0:\\n                continue\\n            i = height\\n            j = (height + right_move) % n\\n            matrix[i][j] = 1\\n            k -= 1\\n    return matrix\\n\\n\\ndef get_value(matrix):\\n    n = len(matrix)\\n    max_r = 0\\n    min_r = n\\n    max_c = 0\\n    min_c = n\\n    for line in matrix:\\n        value = sum(line)\\n        max_r = max(max_r, value)\\n        min_r = min(min_r, value)\\n    for j in range(n):\\n        value = sum([matrix[i][j] for i in range(n)])\\n        max_c = max(max_c, value)\\n        min_c = min(min_c, value)\\n    res = (max_r - min_r) ** 2\\n    res += (max_c - min_c) ** 2\\n    return res\\n\\n\\nT = int(input())\\nfor _ in range(T):\\n    n, k = list(map(int, input().split()))\\n    matrix = solve(n, k)\\n    value = get_value(matrix)\\n    print(value)\\n    for line in matrix:\\n        print(''.join(map(str, line)))\\n\", \"import math\\nimport sys\\nt = int(input())\\nresult = []\\nfor cs in range(t):\\n    n, k = list(map(int, input().split()))\\n    a = [[0] * n for _ in range(n)]\\n    result.append('0' if k % n == 0 else '2')\\n    for i in range(n):\\n        cur = 0\\n        while cur < n and k > 0:\\n            a[cur][(i + cur) % n] = 1\\n            k -= 1\\n            cur += 1\\n    for i in range(n):\\n        result.append(''.join(map(str, a[i])))\\nprint('\\\\n'.join(result))\\n\\n\\n\", \"t = int(input())\\nfor test in range(t):\\n    n,k = [int(i) for i in input().split()]\\n    tab = [[\\\"0\\\" for c in range(n)] for r in range(n)]\\n    row = 0\\n    col = 0\\n    while k>0:\\n        tab[row][col] = \\\"1\\\"\\n        row = (row+1)%n\\n        col += 1\\n        if col==n:\\n            col = 0\\n            row = (row+1)%n\\n        k -= 1\\n    if col==0:\\n        print(0)\\n    else:\\n        print(2)\\n    for row in range(n):\\n        print(''.join(tab[row]))\", \"import sys\\ninput = sys.stdin.readline\\ninputr = lambda: sys.stdin.readline().rstrip('\\\\n')\\n\\nfor _ in range(int(input())):\\n\\tn, k = list(map(int, input().split()))\\n\\n\\te = k // n\\n\\tT = [[0] * n for _ in range(n)]\\n\\n\\tfor i in range((k+n-1)//n):\\n\\t\\tfor j in range(min(n, k - i * n)):\\n\\t\\t\\tT[j][(i + j)%n] = 1\\n\\n\\trows = [sum(R) for R in T]\\n\\tcols = [sum(C) for C in zip(*T)]\\n\\tassert sum(rows) == k\\n\\tassert sum(cols) == k\\n\\tprint((max(rows) - min(rows)) ** 2 + (max(cols) - min(cols)) ** 2)\\n\\tfor R in T:\\n\\t\\tprint(''.join(map(str, R)))\\n\"]", "input_output": "{\"inputs\": [\"4\\n2 2\\n3 8\\n1 0\\n4 16\\n\"], \"outputs\": [\"0\\n10\\n01\\n2\\n111\\n111\\n101\\n0\\n0\\n0\\n1111\\n1111\\n1111\\n1111\\n\"]}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1371/D", "starter_code": ""}
{"id": 57, "question": "You are given an array $a$ of length $n$, which initially is a permutation of numbers from $1$ to $n$. In one operation, you can choose an index $i$ ($1 \\leq i < n$) such that $a_i < a_{i + 1}$, and remove either $a_i$ or $a_{i + 1}$ from the array (after the removal, the remaining parts are concatenated). \n\nFor example, if you have the array $[1, 3, 2]$, you can choose $i = 1$ (since $a_1 = 1 < a_2 = 3$), then either remove $a_1$ which gives the new array $[3, 2]$, or remove $a_2$ which gives the new array $[1, 2]$.\n\nIs it possible to make the length of this array equal to $1$ with these operations?\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 2 \\cdot 10^4$) \u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\leq n \\leq 3 \\cdot 10^5$) \u00a0\u2014 the length of the array.\n\nThe second line of each test case contains $n$ integers $a_1$, $a_2$, ..., $a_n$ ($1 \\leq a_i \\leq n$, $a_i$ are pairwise distinct)\u00a0\u2014 elements of the array.\n\nIt is guaranteed that the sum of $n$ over all test cases doesn't exceed $3 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, output on a single line the word \"YES\" if it is possible to reduce the array to a single element using the aforementioned operation, or \"NO\" if it is impossible to do so.\n\n\n-----Example-----\nInput\n4\n3\n1 2 3\n4\n3 1 2 4\n3\n2 3 1\n6\n2 4 6 1 3 5\n\nOutput\nYES\nYES\nNO\nYES\n\n\n\n-----Note-----\n\nFor the first two test cases and the fourth test case, we can operate as follow (the bolded elements are the pair chosen for that operation):\n\n$[\\text{1}, \\textbf{2}, \\textbf{3}] \\rightarrow [\\textbf{1}, \\textbf{2}] \\rightarrow [\\text{1}]$\n\n$[\\text{3}, \\textbf{1}, \\textbf{2}, \\text{4}] \\rightarrow [\\text{3}, \\textbf{1}, \\textbf{4}] \\rightarrow [\\textbf{3}, \\textbf{4}] \\rightarrow [\\text{4}]$\n\n$[\\textbf{2}, \\textbf{4}, \\text{6}, \\text{1}, \\text{3}, \\text{5}] \\rightarrow [\\textbf{4}, \\textbf{6}, \\text{1}, \\text{3}, \\text{5}] \\rightarrow [\\text{4}, \\text{1}, \\textbf{3}, \\textbf{5}] \\rightarrow [\\text{4}, \\textbf{1}, \\textbf{5}] \\rightarrow [\\textbf{4}, \\textbf{5}] \\rightarrow [\\text{4}]$", "solutions": "[\"t = int(input())\\nfor case in range(t):\\n    n = int(input())\\n    arr = list(map(int, input().split()))\\n    if arr[-1] > arr[0]:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"for _ in range(int(input())):\\n    n = int(input())\\n    a = list(map(int,input().split()))\\n    if a[-1]>a[0]:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"for _ in range(int(input())):\\n    #n, m = map(int, input().split())\\n    n = int(input())\\n    A = list(map(int, input().split()))\\n    if A[0] <= A[-1]:\\n        print('YES')\\n    else:\\n        print('NO')\", \"def solve():\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    q = []\\n    for i in a:\\n        while len(q) >= 2 and ((q[-2] < q[-1] and q[-1] > i) or (q[-2] > q[-1] and q[-1] < i)):\\n            q.pop(-1)\\n        q.append(i)\\n    for i in range(len(q) - 1):\\n        if q[i] > q[i + 1]:\\n            print('NO')\\n            return\\n    print('YES')\\n\\nt = int(input())\\nfor _ in range(t):\\n    solve()\", \"import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\nfor tests in range(t):\\n    n=int(input())\\n    A=list(map(int,input().split()))\\n\\n    if A[0]<A[-1]:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\\n    \\n\", \"''' author: Priyank Koul, PES University, Bengaluru'''\\nfor _ in range(int(input())):\\n\\tx= int(input())\\n\\tli= list(map(int, input().strip().split()))\\n\\tfli=[]\\n\\tfor i in range(1,x):\\n\\t\\tfli.append(li[i]-li[i-1])\\n\\tif(sum(fli)<0):\\n\\t\\tprint(\\\"NO\\\")\\n\\telse:\\n\\t\\tprint(\\\"YES\\\")\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\", \"def main():\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    if a[0] < a[-1]:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\\n\\ndef __starting_point():\\n    t = int(input())\\n    for i in range(t):\\n        main()\\n\\n__starting_point()\", \"import sys\\ninput = sys.stdin.readline\\nfor f in range(int(input())):\\n    n=int(input())\\n    p=list(map(int,input().split()))\\n    if p[0]>p[-1]:\\n        print(\\\"NO\\\")\\n    else:\\n        print(\\\"YES\\\")\", \"def solve():\\n    n = int(input())\\n    arr = [int(x) for x in input().split()]\\n    if arr[0] < arr[-1]:\\n        print('YES')\\n    else:\\n        print('NO')\\n\\ndef __starting_point():\\n    for _ in range(int(input())):\\n        solve()\\n__starting_point()\", \"\\nT = int(input())\\n\\nfor i in range(T):\\n  n = int(input())\\n  #n,m = map(int, input().split())\\n  #a,b = map(int, input().split())\\n  a = [int(i) for i in input().split()]\\n  #a = list(input())\\n  \\n  if a[-1]>a[0]:\\n    print('YES')\\n  else:\\n    print('NO')\\n\\n\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n3\\n1 2 3\\n4\\n3 1 2 4\\n3\\n2 3 1\\n6\\n2 4 6 1 3 5\\n\"\n  ],\n  \"outputs\": [\n    \"YES\\nYES\\nNO\\nYES\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1375/C", "starter_code": ""}
{"id": 58, "question": "You have a rectangular chocolate bar consisting of n \u00d7 m single squares. You want to eat exactly k squares, so you may need to break the chocolate bar. \n\nIn one move you can break any single rectangular piece of chocolate in two rectangular pieces. You can break only by lines between squares: horizontally or vertically. The cost of breaking is equal to square of the break length.\n\nFor example, if you have a chocolate bar consisting of 2 \u00d7 3 unit squares then you can break it horizontally and get two 1 \u00d7 3 pieces (the cost of such breaking is 3^2 = 9), or you can break it vertically in two ways and get two pieces: 2 \u00d7 1 and 2 \u00d7 2 (the cost of such breaking is 2^2 = 4).\n\nFor several given values n, m and k find the minimum total cost of breaking. You can eat exactly k squares of chocolate if after all operations of breaking there is a set of rectangular pieces of chocolate with the total size equal to k squares. The remaining n\u00b7m - k squares are not necessarily form a single rectangular piece.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer t (1 \u2264 t \u2264 40910)\u00a0\u2014 the number of values n, m and k to process.\n\nEach of the next t lines contains three integers n, m and k (1 \u2264 n, m \u2264 30, 1 \u2264 k \u2264 min(n\u00b7m, 50))\u00a0\u2014 the dimensions of the chocolate bar and the number of squares you want to eat respectively.\n\n\n-----Output-----\n\nFor each n, m and k print the minimum total cost needed to break the chocolate bar, in order to make it possible to eat exactly k squares.\n\n\n-----Examples-----\nInput\n4\n2 2 1\n2 2 3\n2 2 2\n2 2 4\n\nOutput\n5\n5\n4\n0\n\n\n\n-----Note-----\n\nIn the first query of the sample one needs to perform two breaks:  to split 2 \u00d7 2 bar into two pieces of 2 \u00d7 1 (cost is 2^2 = 4),  to split the resulting 2 \u00d7 1 into two 1 \u00d7 1 pieces (cost is 1^2 = 1). \n\nIn the second query of the sample one wants to eat 3 unit squares. One can use exactly the same strategy as in the first query of the sample.", "solutions": "[\"mem = [[[0 for i in range(51)] for j in range(31)] for k in range(31)]\\n\\n\\ndef f(n, m, k):\\n    if mem[n][m][k]:\\n        return mem[n][m][k]\\n    if (n*m == k) or (k == 0):\\n        return 0\\n    cost = 10**9\\n    for x in range(1, n//2 + 1):\\n        for z in range(k+1):\\n            cost = min(cost, m*m + f(n-x, m, k-z) + f(x, m, z))\\n    for y in range(1, m//2 + 1):\\n        for z in range(k+1):\\n            cost = min(cost, n*n + f(n, m-y, k-z) + f(n, y, z))\\n    mem[n][m][k] = cost\\n    return cost\\n\\n\\nt = int(input())\\nfor i in range(t):\\n    n, m, k = list(map(int, input().split()))\\n    print(f(n, m, k))\\n\\n\", \"import sys\\n\\n# sys.stdin = open('ivo.in')\\n\\nmem = []\\nfor i in range(32):\\n    mem.append([[-1] * 52 for u in range(32)])\\n\\ndef solve(x, y, z):\\n    if x > y:\\n        mem[x][y][z] = solve(y, x, z)\\n        return mem[x][y][z]\\n    if x * y == z or z == 0:\\n        mem[x][y][z] = 0\\n        return 0\\n    if x * y < z:\\n        mem[x][y][z] = -2\\n        return -2\\n    res = -2\\n    for i in range(1, x//2 + 1):\\n        for eaten in range(z + 1):\\n            t1 = mem[i][y][eaten] if mem[i][y][eaten] != -1 else solve(i, y, eaten)\\n            if t1 == -2:\\n                continue\\n            t2 = mem[x - i][y][z - eaten] if mem[x - i][y][z - eaten] != -1 else solve(x - i, y, z - eaten)\\n            if t2 == -2:\\n                continue\\n            if res == -2 or res > t1 + t2 + y * y:\\n                res = t1 + t2 + y * y\\n\\n    for j in range(1, y//2 + 1):\\n        for eaten in range(z + 1):\\n            t1 = mem[x][j][eaten] if mem[x][j][eaten] != -1 else solve(x, j, eaten)\\n            if t1 == -2:\\n                continue\\n            t2 = mem[x][y - j][z - eaten] if mem[x][y - j][z - eaten] != -1 else solve(x, y - j, z - eaten)\\n            if t2 == -2:\\n                continue\\n            if res == -2 or res > t1 + t2 + x * x:\\n                res = t1 + t2 + x * x\\n\\n    mem[x][y][z] = res\\n    return mem[x][y][z]\\n\\nt = int(sys.stdin.readline())\\nfor it in range(t):\\n    n, m, k = list(map(int, sys.stdin.readline().split()))\\n    print(solve(n, m, k))\\n\\n\\n\", \"d = [[[0 for i in range(51)] for j in range(31)] for k in range(31)]\\n\\n\\ndef rec(n, m, k):\\n    nonlocal d\\n    if n*m == k or k == 0:\\n        return 0\\n    if d[n][m][k] > 0:\\n        return d[n][m][k]\\n    if n*m<k:\\n        return 10**10\\n    cost = 10**10\\n    for i in range(1, n // 2 + 1):\\n        for j in range(k+1):\\n            cost = min(cost, m*m + rec(n-i, m, k-j) + rec(i, m, j))\\n    for i in range(1, m // 2 + 1):\\n        for j in range(k+1):\\n            cost = min(cost, n*n + rec(n, m-i, k-j) + rec(n, i, j))\\n    d[n][m][k] = cost\\n    return cost\\n\\np = []\\nt = int(input())\\nfor i in range(t):\\n    n, m, k = list(map(int, input().split()))\\n    p.append(rec(n, m, k))\\nprint('\\\\n'.join(str(x) for x in p))\\n\", \"d = [[[0 for i in range(51)] for j in range(31)] for k in range(31)]\\n\\n\\ndef rec(n, m, k):\\n    nonlocal d\\n    if n*m == k or k == 0:\\n        return 0\\n    if d[n][m][k] > 0:\\n        return d[n][m][k]\\n    if n*m<k:\\n        return 10**10\\n    cost = 10**10\\n    for i in range(1, n // 2 + 1):\\n        for j in range(k+1):\\n            cost = min(cost, m*m + rec(n-i, m, k-j) + rec(i, m, j))\\n    for i in range(1, m // 2 + 1):\\n        for j in range(k+1):\\n            cost = min(cost, n*n + rec(n, m-i, k-j) + rec(n, i, j))\\n    d[n][m][k] = cost\\n    return cost\\n\\np = []\\nt = int(input())\\nfor i in range(t):\\n    n, m, k = list(map(int, input().split()))\\n    #p.append(rec(n, m, k))\\n    print(rec(n, m, k))\\n#print('\\\\n'.join(str(x) for x in p))\\n\", \"d = [0] * 49011\\n\\ndef g(n, m, k):\\n    t = 1e9\\n    for i in range(1, m // 2 + 1):\\n        for j in range(k + 1):\\n            t = min(t, f(n, m - i, k - j) + f(n, i, j))\\n    return n * n + t\\n\\ndef f(n, m, k):\\n    if n > m: n, m = m, n\\n    k = min(k, n * m - k)\\n    if k == 0: return 0\\n    if k < 0: return 1e9\\n    q = n + 31 * m + 961 * k\\n    if d[q] == 0: d[q] = min(g(n, m, k), g(m, n, k))\\n    return d[q]\\n\\nfor q in range(int(input())):\\n    n, m, k = map(int, input().split())\\n    print(f(n, m, k))\", \"d = [[[0 for i in range(51)] for j in range(31)] for k in range(31)]\\n\\n\\ndef rec(n, m, k):\\n    nonlocal d\\n    if n*m == k or k == 0:\\n        return 0\\n    if d[n][m][k] > 0:\\n        return d[n][m][k]\\n    if n*m<k:\\n        return 10**10\\n    cost = 10**10\\n    for i in range(1, n // 2 + 1):\\n        for j in range(k+1):\\n            cost = min(cost, m*m + rec(n-i, m, k-j) + rec(i, m, j))\\n    for i in range(1, m // 2 + 1):\\n        for j in range(k+1):\\n            cost = min(cost, n*n + rec(n, m-i, k-j) + rec(n, i, j))\\n    d[n][m][k] = cost\\n    return cost\\n\\np = []\\nt = int(input())\\nfor i in range(t):\\n    n, m, k = map(int, input().split())\\n    p.append(rec(n, m, k))\\nprint('\\\\n'.join(str(x) for x in p))\", \"d = [ [ [ 0 for i in range(51) ] for j in range(31) ] for g in range(31)]\\ndef rec(n, m ,k):\\n    nonlocal d\\n    if k == 0 or n*m == k:\\n        return 0\\n    if d[n][m][k] > 0 :\\n        return d[n][m][k]\\n    if n * m < k:\\n        return 10 ** 10\\n    cost  = 10**10\\n    for i in range(1, n//2 +1):\\n        for j in range(k+1):\\n            cost = min(cost, m**2 + rec(i, m, j) + rec(n-i, m, k-j))\\n    for i in range(1, m//2 +1):\\n        for j in range(0, k+1):\\n            cost = min(cost, n**2 + rec(n, i, j) + rec(n, m-i, k-j))\\n    d[n][m][k] = cost\\n    return cost\\nt = int(input())\\na = []\\nfor c in range(t):\\n    n, m ,k = map(int, input().split())\\n    a.append(rec(n,m,k))\\nprint('\\\\n'.join(str(x) for x in a))\", \"t=int(input())\\nd=[]\\nfor i in range(31):\\n    dd=[]\\n    for j in range(31):\\n        dd.append([0]*51)\\n    d.append(dd)\\nd[1][1][1]=0\\nfor i in range(1,31):\\n    for j in range(1,31):\\n        for k in range(1,min(i*j,50)+1):\\n            if k>i*j//2:\\n                d[i][j][k]=d[i][j][i*j-k]\\n            elif i>j:\\n                d[i][j][k]=d[j][i][k]\\n            elif (i,j)!=(1,1):\\n                k=min(k,i*j-k)\\n                kk=i*j-k\\n                jj=(i**2*j)*(j**2)*i\\n                for l in range(1,i):\\n                    if k<=l*j:\\n                        jj=min(jj,d[l][j][k]+j**2)\\n                    else:\\n                        k1=k-l*j\\n                        jj=min(jj,d[i-l][j][k1]+j**2)\\n                    if kk<=l*j:\\n                        if kk<=50:\\n                            jj=min(jj,d[l][j][kk]+j**2)\\n                    else:\\n                        kk1=kk-l*j\\n                        if kk1<=50:\\n                            jj=min(jj,d[i-l][j][kk1]+j**2)\\n                for l in range(1,j):\\n                    if k<=l*i:\\n                        jj=min(jj,d[i][l][k]+i**2)\\n                    else:\\n                        k1=k-l*i\\n                        jj=min(jj,d[i][j-l][k1]+i**2)\\n                    if kk<=l*i:\\n                        if kk<=50:\\n                            jj=min(jj,d[i][l][kk]+i**2)\\n                    else:\\n                        kk1=kk-l*i\\n                        if kk1<=50:\\n                            jj=min(jj,d[i][j-l][kk1]+i**2)\\n                d[i][j][k]=jj\\nfor i in range(t):\\n    n,m,k=list(map(int,input().split()))\\n    jj=d[n][m][k]\\n    print(jj)\\n\", \"mem = [[[0 for i in range(51)] for j in range(31)] for k in range(31)]\\n\\n\\ndef f(n, m, k):\\n    if mem[n][m][k]:\\n        return mem[n][m][k]\\n    if (n*m == k) or (k == 0):\\n        return 0\\n    cost = 10**9\\n    for x in range(1, n//2 + 1):\\n        for z in range(k+1):\\n            cost = min(cost, m*m + f(n-x, m, k-z) + f(x, m, z))\\n    for y in range(1, m//2 + 1):\\n        for z in range(k+1):\\n            cost = min(cost, n*n + f(n, m-y, k-z) + f(n, y, z))\\n    mem[n][m][k] = cost\\n    return cost\\n\\n\\nt = int(input())\\nfor i in range(t):\\n    n, m, k = map(int, input().split())\\n    print(f(n, m, k))\", \"t = int(input())\\n\\ndp = [[[0 for i in range(51)] for j in range(31)] for k in range(31)]\\n\\ndef cost(n, m, k):\\n    if (dp[n][m][k] or k == 0 or n * m == k): return dp[n][m][k]\\n    c = 10**9\\n    for i in range(1, n // 2 + 1):\\n        for j in range(k + 1):\\n            c = min(c, cost(n - i, m, k - j) + cost(i, m, j) + m * m)\\n    for i in range(1, m // 2 + 1):\\n        for j in range(k + 1):\\n            c = min(c, cost(n, m - i, k - j) + cost(n, i, j) + n * n)\\n    dp[n][m][k] = c\\n    return c\\n\\nfor _ in range(t):\\n    n, m, k = list(map(int, input().split()))\\n    print(cost(n, m, k))\\n\\n# mem = [[[0 for i in range(51)] for j in range(31)] for k in range(31)]\\n\\n\\n# def f(n, m, k):\\n#     if mem[n][m][k]:\\n#         return mem[n][m][k]\\n#     if (n*m == k) or (k == 0):\\n#         return 0\\n#     cost = 10**9\\n#     for x in range(1, n//2 + 1):\\n#         for z in range(k+1):\\n#             cost = min(cost, m*m + f(n-x, m, k-z) + f(x, m, z))\\n#     for y in range(1, m//2 + 1):\\n#         for z in range(k+1):\\n#             cost = min(cost, n*n + f(n, m-y, k-z) + f(n, y, z))\\n#     mem[n][m][k] = cost\\n#     return cost\\n\\n\\n# t = int(input())\\n# for i in range(t):\\n#     n, m, k = map(int, input().split())\\n#     print(f(n, m, k))\\n\", \"t = int(input())\\n\\ndp = [[[0 for i in range(51)] for j in range(31)] for k in range(31)]\\n\\ndef cost(n, m, k):\\n    if (dp[n][m][k] or k == 0 or n * m == k): return dp[n][m][k]\\n    c = 10**9\\n    for i in range(1, n // 2 + 1):\\n        for j in range(k + 1):\\n            c = min(c, cost(i, m, j) + cost(n - i, m, k - j) + m * m)\\n    for i in range(1, m // 2 + 1):\\n        for j in range(k + 1):\\n            c = min(c, cost(n, i, j) + cost(n, m - i, k - j) + n * n)\\n    dp[n][m][k] = c\\n    return c\\n\\nfor _ in range(t):\\n    n, m, k = list(map(int, input().split()))\\n    print(cost(n, m, k))\\n\\n\", \"D = {}\\n\\n\\ndef h(m,n,answ,k):\\n    x = answ\\n    for i in range(1,(n+2)//2):\\n        if k >= i*m:\\n            if m**2+ans(m,n-i,k-i*m) < x:\\n                x = m**2+ans(m,n-i,k-i*m)\\n        if k <= (n-i)*m:\\n            if m**2+ans(m,n-i,k) < x:\\n                x = m**2+ans(m,n-i,k)\\n        if k >= (n-i)*m:\\n            if m**2+ans(m,i,k-(n-i)*m) < x:\\n                x = m**2+ans(m,i,k-(n-i)*m)\\n        if k <= i*m:\\n            if m**2+ans(m,i,k) < x :\\n                x = m**2+ans(m,i,k)\\n    return x\\ndef ans(m,n,k):\\n    if k == 0:\\n        D[(m,n,k)] = 0\\n        D[(n,m,k)] = 0\\n        return 0\\n    if m*n == k:\\n        D[(m,n,k)] = 0\\n        D[(n,m,k)] = 0\\n        return 0\\n    elif m == 1:\\n        D[(m,n,k)] = 1\\n        D[(n,m,k)] = 1\\n        return 1\\n    elif n == 1:\\n        D[(m,n,k)] = 1\\n        D[(n,m,k)] = 1\\n        return 1\\n    elif (m,n,k) in D:\\n        return D[(m,n,k)]\\n    else:\\n        answ = (n**2)*m\\n        t = h(m,n,answ,k)\\n        if t < answ:\\n            answ = t\\n        s = h(n,m,answ,k)\\n        if s < answ:\\n            answ = s\\n        D[(m,n,k)] = answ\\n        D[(n,m,k)] = answ\\n        return answ\\n\\nfor i in range(30,0,-1):\\n    for j in range(i,0,-1):\\n        for k in range(0,min(i*j,50)+1):\\n            ans(i,j,k)\\n\\nt = int(input())\\n\\nfor i in range(t):\\n    m,n,k = [int(x) for x in input().split()]\\n    print(D[(m,n,k)])\", \"import sys\\ninput=sys.stdin.readline\\ndef main():\\n\\tans=[]\\n\\tmemo=[[[-1 for _ in range(51)] for _ in range(31)] for _ in range(31)]\\n\\tdef  solve(n, m , k) :\\n\\t\\tif n*m == k or k==0: return 0\\n\\t\\tif memo[n][m][k] > -1 : return memo[n][m][k]\\n\\t\\tif memo[m][n][k] > -1 : memo[n][m][k]=memo[m][n][k] ; return memo[n][m][k]\\n\\t\\tr=float('inf')\\n\\t\\tfor i in range(k+1):\\n\\t\\t\\tfor j in range(1,max(m,n)):\\n\\t\\t\\t\\tif m > j :\\n\\t\\t\\t\\t\\tr=min(r,n**2+solve(j,n,i)+solve(m-j,n,k-i))\\n\\t\\t\\t\\tif n > j :\\n\\t\\t\\t\\t\\tr=min(r,m**2+solve(m,j,i)+solve(m,n-j,k-i))\\n\\t\\tmemo[n][m][k] = r\\n\\t\\treturn r\\n\\tfor _ in range(int(input())):\\n\\t\\tn,m,k = map(int,input().split())\\n\\t\\tans.append(str(solve(n,m,k)))\\n\\tprint('\\\\n'.join(ans))\\nmain()\", \"t = int(input())\\nd = []\\nfor i in range(31):\\n    dd = []\\n    for j in range(31):\\n        dd.append([0] * 51)\\n    d.append(dd)\\nd[1][1][1] = 0\\nfor i in range(1, 31):\\n    for j in range(1, 31):\\n        for k in range(1, min(i * j, 50) + 1):\\n            if k > i * j // 2:\\n                d[i][j][k] = d[i][j][i * j - k]\\n            elif i > j:\\n                d[i][j][k] = d[j][i][k]\\n            elif (i, j) != (1, 1):\\n                k = min(k, i * j - k)\\n                kk = i * j - k\\n                jj = (i ** 2 * j) * (j ** 2) * i\\n                for l in range(1, i):\\n                    if k <= l * j:\\n                        jj = min(jj, d[l][j][k] + j ** 2)\\n                    else:\\n                        k1 = k - l * j\\n                        jj = min(jj, d[i - l][j][k1] + j ** 2)\\n                    # if kk <= l * j:\\n                    #     if kk <= 50:\\n                    #         jj = min(jj, d[l][j][kk] + j ** 2)\\n                    # else:\\n                    #     kk1 = kk - l * j\\n                    #     if kk1 <= 50:\\n                    #         jj = min(jj, d[i - l][j][kk1] + j ** 2)\\n                for l in range(1, j):\\n                    if k <= l * i:\\n                        jj = min(jj, d[i][l][k] + i ** 2)\\n                    else:\\n                        k1 = k - l * i\\n                        jj = min(jj, d[i][j - l][k1] + i ** 2)\\n                    # if kk <= l * i:\\n                    #     if kk <= 50:\\n                    #         jj = min(jj, d[i][l][kk] + i ** 2)\\n                    # else:\\n                    #     kk1 = kk - l * i\\n                    #     if kk1 <= 50:\\n                    #         jj = min(jj, d[i][j - l][kk1] + i ** 2)\\n                d[i][j][k] = jj\\nfor i in range(t):\\n    n, m, k = list(map(int, input().split()))\\n    jj = d[n][m][k]\\n    print(jj)\\n# print(d[3][3][2])\\n\", \"dp = {}\\n\\n\\ndef getDP(n, m, k):\\n    if (n, m, k) in dp:\\n        return dp[(n, m, k)]\\n    elif (m, n, k) in dp:\\n        return dp[(m, n, k)]\\n    return None\\n\\n\\ndef solve(n, m, k):\\n    if n == 2 and m == 3 and k == 5:\\n        h = 5\\n    if k == m * n or k == 0:\\n        dp[(n, m, k)] = 0\\n    elif k % min(n, m) == 0:\\n        dp[(n, m, k)] = min(n, m) ** 2\\n    elif k == 1:\\n        dp[(n, m, k)] = min(n, m) ** 2 + 1\\n    elif getDP(n, m, k) is not None:\\n        return getDP(n, m, k)\\n    else:\\n        bestAns = float('inf')\\n        for i in range(1, n):\\n            if k <= i * m:\\n                bestAns = min(bestAns, getDP(i, m, k) + m ** 2)\\n            else:\\n                bestAns = min(bestAns, getDP(n - i, m, k - i * m) + m ** 2)\\n\\n        for i in range(1, m):\\n            if k <= i * n:\\n                bestAns = min(bestAns, getDP(i, n, k) + n ** 2)\\n            else:\\n                bestAns = min(bestAns, getDP(m - i, n, k - i * n) + n ** 2)\\n        dp[(n, m, k)] = bestAns\\n\\n\\nfor i in range(1, 31):\\n    for j in range(1, 31):\\n        for k in range(min(i * j, 50) + 1):\\n            solve(i, j, k)\\ntoPrint = []\\nt = int(input())\\nfor i in range(t):\\n    n, m, k = [int(x) for x in input().split(\\\" \\\")]\\n    toPrint.append(getDP(n, m, k))\\n\\nfor x in toPrint:\\n    print(x)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nd={}\\ntestnumber = int(input())\\n\\ndef calc(n, m, k):\\n    if k <= 0 or k == m*n:\\n        return 0\\n    if k > n*m:\\n        return 1000_000_000\\n\\n    nonlocal d\\n    if n < m:\\n        n, m = m, n\\n    \\n    if k > (m*n - m):\\n        return m*m + 1\\n    if k < m:\\n        return m*m + 1\\n    if k % m == 0:\\n        return m*m\\n\\n    if (n, m, k) in d:\\n        return d[ (n, m, k)]\\n\\n    d[ (n, m, k) ] = min( calc2(n, m, k), calc2(m, n, k) )\\n\\n    return d[ (n, m, k) ]\\n\\ndef calc2(n, m, k):\\n    m2 = m*m\\n    ans = m2*2 + 1\\n    for i in range(1, n):\\n        if i*m >= k:\\n            ans = min(ans, m2 + calc(m, i, k) )\\n        else:\\n            ans = min(ans, m2 + calc(m, n-i, k - i*m))\\n    \\n    return ans\\n\\nfor ntest in range(testnumber):\\n    n, m, k = map( int, input().split() )\\n    if k == n*m:\\n        print(0)\\n        continue\\n\\n    print( calc(n, m, k) )\", \"import sys\\ninput = sys.stdin.readline\\n\\nd={}\\ntestnumber = int(input())\\n\\ndef calc(n, m, k):\\n    if k <= 0 or k == m*n:\\n        return 0\\n    if k > n*m:\\n        return 1000_000_000\\n\\n    nonlocal d\\n    if n < m:\\n        n, m = m, n\\n    \\n    if k > (m*n - m):\\n        return m*m + 1\\n    if k < m:\\n        return m*m + 1\\n    if k % m == 0:\\n        return m*m\\n\\n    if (n, m, k) in d:\\n        return d[ (n, m, k)]\\n\\n    d[ (n, m, k) ] = min( calc2(n, m, k), calc2(m, n, k) )\\n\\n    return d[ (n, m, k) ]\\n\\ndef calc2(n, m, k):\\n    m2 = m*m\\n    ans = m2*2 + 1\\n    for i in range(1, n):\\n        if i*m >= k:\\n            ans = min(ans, m2 + calc(m, i, k) )\\n        else:\\n            ans = min(ans, m2 + calc(m, n-i, k - i*m))\\n    \\n    return ans\\n\\nfor ntest in range(testnumber):\\n    n, m, k = map( int, input().split() )\\n    if k == n*m:\\n        print(0)\\n        continue\\n\\n    print( calc(n, m, k) )\", \"d=[[[0 for i in range(51)] for j in range(31)] for k in range(31)]\\n\\nfor i in range(31):\\n    d.append([])\\n    for j in range(31):\\n        d[i].append([])\\n        for k in range(50):\\n            d[i][j].append(0)\\n\\n    \\ndef rec(n,m,k):\\n    nonlocal d\\n    if n*m==k or k==0:\\n        return 0\\n    if d[n][m][k]>0:\\n        return d[n][m][k]\\n    if n*m<k:\\n        return 10**10\\n    cost=10**10\\n    for i in range(1,n//2+1):\\n        for j in range(k+1):\\n            cost=min(cost,m*m+rec(n-i,m,k-j)+rec(i,m,j))\\n    for i in range(1,m//2+1):\\n        for j in range(k+1):\\n            cost=min(cost,n*n+rec(n,m-i,k-j)+rec(n,i,j))\\n            \\n    d[n][m][k]=cost\\n    return cost\\n    \\nfor i in range(int(input())):\\n    a,b,c=list(map(int,input().split()))\\n    print(rec(a,b,c))\\n\", \"d=[[[0 for i in range(51)] for j in range(31)] for k in range(31)]\\n    \\ndef rec(n,m,k):\\n    nonlocal d\\n    if n*m==k or k==0:\\n        return 0\\n    if d[n][m][k]>0:\\n        return d[n][m][k]\\n    if n*m<k:\\n        return 10**10\\n    cost=10**10\\n    for i in range(1,n//2+1):\\n        for j in range(k+1):\\n            cost=min(cost,m*m+rec(n-i,m,k-j)+rec(i,m,j))\\n    for i in range(1,m//2+1):\\n        for j in range(k+1):\\n            cost=min(cost,n*n+rec(n,m-i,k-j)+rec(n,i,j))\\n            \\n    d[n][m][k]=cost\\n    return cost\\n    \\nfor i in range(int(input())):\\n    a,b,c=list(map(int,input().split()))\\n    print(rec(a,b,c))\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n2 2 1\\n2 2 3\\n2 2 2\\n2 2 4\\n\"\n  ],\n  \"outputs\": [\n    \"5\\n5\\n4\\n0\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/598/E", "starter_code": ""}
{"id": 59, "question": "Dark is going to attend Motarack's birthday. Dark decided that the gift he is going to give to Motarack is an array $a$ of $n$ non-negative integers.\n\nDark created that array $1000$ years ago, so some elements in that array disappeared. Dark knows that Motarack hates to see an array that has two adjacent elements with a high absolute difference between them. He doesn't have much time so he wants to choose an integer $k$ ($0 \\leq k \\leq 10^{9}$) and replaces all missing elements in the array $a$ with $k$.\n\nLet $m$ be the maximum absolute difference between all adjacent elements (i.e. the maximum value of $|a_i - a_{i+1}|$ for all $1 \\leq i \\leq n - 1$) in the array $a$ after Dark replaces all missing elements with $k$.\n\nDark should choose an integer $k$ so that $m$ is minimized. Can you help him?\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains one integer $n$ ($2 \\leq n \\leq 10^{5}$)\u00a0\u2014 the size of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($-1 \\leq a_i \\leq 10 ^ {9}$). If $a_i = -1$, then the $i$-th integer is missing. It is guaranteed that at least one integer is missing in every test case.\n\nIt is guaranteed, that the sum of $n$ for all test cases does not exceed $4 \\cdot 10 ^ {5}$.\n\n\n-----Output-----\n\nPrint the answers for each test case in the following format:\n\nYou should print two integers, the minimum possible value of $m$ and an integer $k$ ($0 \\leq k \\leq 10^{9}$) that makes the maximum absolute difference between adjacent elements in the array $a$ equal to $m$.\n\nMake sure that after replacing all the missing elements with $k$, the maximum absolute difference between adjacent elements becomes $m$.\n\nIf there is more than one possible $k$, you can print any of them.\n\n\n-----Example-----\nInput\n7\n5\n-1 10 -1 12 -1\n5\n-1 40 35 -1 35\n6\n-1 -1 9 -1 3 -1\n2\n-1 -1\n2\n0 -1\n4\n1 -1 3 -1\n7\n1 -1 7 5 2 -1 5\n\nOutput\n1 11\n5 35\n3 6\n0 42\n0 0\n1 2\n3 4\n\n\n\n-----Note-----\n\nIn the first test case after replacing all missing elements with $11$ the array becomes $[11, 10, 11, 12, 11]$. The absolute difference between any adjacent elements is $1$. It is impossible to choose a value of $k$, such that the absolute difference between any adjacent element will be $\\leq 0$. So, the answer is $1$.\n\nIn the third test case after replacing all missing elements with $6$ the array becomes $[6, 6, 9, 6, 3, 6]$.  $|a_1 - a_2| = |6 - 6| = 0$;  $|a_2 - a_3| = |6 - 9| = 3$;  $|a_3 - a_4| = |9 - 6| = 3$;  $|a_4 - a_5| = |6 - 3| = 3$;  $|a_5 - a_6| = |3 - 6| = 3$. \n\nSo, the maximum difference between any adjacent elements is $3$.", "solutions": "[\"for _ in range(int(input())):\\n    n=int(input())\\n    a=list(map(int,input().split()))\\n    ans,small,big=0,2*10**9,-1\\n    for i in range(len(a)-1):\\n        if a[i]==-1 and a[i+1]!=-1:\\n            small=min(small, a[i+1])\\n            big=max(big, a[i+1])\\n        if a[i]!=-1 and a[i+1]==-1:\\n            small = min(small, a[i])\\n            big = max(big, a[i])\\n        if a[i]!=-1 and a[i+1]!=-1:\\n            ans=max(ans, abs(a[i]-a[i+1]))\\n    if big==-1:print(ans, 0)\\n    else:\\n        x=(small+big)//2\\n        ans=max(ans, abs(big-x))\\n        ans=max(ans, abs(x-small))\\n        print(ans, x)\", \"for _ in range(int(input())):\\n    n = int(input())\\n    ans = 0\\n    adj = []\\n    a = tuple(map(int, input().split()))\\n    a1 = iter(a)\\n    next(a1)\\n    for ai, aj in zip(a, a1):\\n        if ai > -1 < aj:\\n            ans = max(ans, abs(ai - aj))\\n        elif ai != aj:\\n            adj.append(ai + aj + 1)\\n    min_adj, max_adj = (min(adj), max(adj)) if adj else (0, 0)\\n    print(max(ans, (max_adj - min_adj + 1) // 2), (min_adj + max_adj) // 2)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\nfor test in range(t):\\n    n=int(input())\\n    A=list(map(int,input().split()))\\n\\n    MAX=0\\n    DIFMIN=10**10\\n    DIFMAX=-100\\n\\n    for i in range(1,n):\\n        if A[i-1]==A[i]==-1:\\n            continue\\n        elif A[i-1]==-1:\\n            DIFMIN=min(DIFMIN,A[i])\\n            DIFMAX=max(DIFMAX,A[i])\\n        elif A[i]==-1:\\n            DIFMIN=min(DIFMIN,A[i-1])\\n            DIFMAX=max(DIFMAX,A[i-1])\\n        else:\\n            MAX=max(MAX,abs(A[i]-A[i-1]))\\n\\n    \\n    if DIFMIN==10**10:\\n        print(0,0)\\n    else:\\n        #print(DIFMIN,DIFMAX)\\n        k=(DIFMAX+DIFMIN)//2\\n        m=max(MAX,DIFMAX-k,k-DIFMIN)\\n\\n        print(m,k)\\n\", \"from math import *\\n\\nzzz = int(input())\\nfor zz in range(zzz):\\n    n = int(input())\\n    a = [int(i) for i in input().split()]\\n    b = set()\\n    for i in range(n):\\n        if a[i] == -1:\\n            if i > 0:\\n                if a[i-1] >= 0:\\n                    b.add(a[i-1])\\n            if i < n - 1:\\n                if a[i+1] >= 0:\\n                    b.add(a[i+1])\\n    b = list(b)\\n    if len(b) == 0:\\n        print(0, 0)\\n    else:\\n        k = (min(b) + max(b)) // 2\\n        m = 0\\n        for i in range(n):\\n            if a[i] == -1:\\n                a[i] = k\\n        for i in range(1, n):\\n            m = max(m, abs(a[i-1]- a[i]))\\n        print(m, k)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"7\\n5\\n-1 10 -1 12 -1\\n5\\n-1 40 35 -1 35\\n6\\n-1 -1 9 -1 3 -1\\n2\\n-1 -1\\n2\\n0 -1\\n4\\n1 -1 3 -1\\n7\\n1 -1 7 5 2 -1 5\\n\"\n  ],\n  \"outputs\": [\n    \"1 11\\n5 37\\n3 6\\n0 0\\n0 0\\n1 2\\n3 4\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1301/B", "starter_code": ""}
{"id": 60, "question": "In order to celebrate Twice's 5th anniversary, Tzuyu and Sana decided to play a game.\n\nTzuyu gave Sana two integers $a$ and $b$ and a really important quest.\n\nIn order to complete the quest, Sana has to output the smallest possible value of ($a \\oplus x$) + ($b \\oplus x$) for any given $x$, where $\\oplus$ denotes the bitwise XOR operation. \n\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^{4}$). Description of the test cases follows.\n\nThe only line of each test case contains two integers $a$ and $b$ ($1 \\le a, b \\le 10^{9}$).\n\n\n-----Output-----\n\nFor each testcase, output the smallest possible value of the given expression.\n\n\n-----Example-----\nInput\n6\n6 12\n4 9\n59 832\n28 14\n4925 2912\n1 1\n\nOutput\n10\n13\n891\n18\n6237\n0\n\n\n\n-----Note-----\n\nFor the first test case Sana can choose $x=4$ and the value will be ($6 \\oplus 4$) + ($12 \\oplus 4$) = $2 + 8$ = $10$. It can be shown that this is the smallest possible value.", "solutions": "[\"n = int(input())\\nfor _ in range(n):\\n    a, b = list(map(int, input().split()))\\n    print(a ^ b)\\n\", \"for __ in range(int(input())):\\n    a, b = list(map(int, input().split()))\\n    print(a ^ b)\", \"import sys\\ninput = sys.stdin.readline\\n\\ndef main():\\n    a, b = map(int, input().split())\\n    print(a^b)\\n    \\nfor _ in range(int(input())):\\n    main()\", \"from math import *\\nfrom bisect import *\\nfrom collections import *\\nfrom random import *\\nfrom decimal import *\\nfrom itertools import *\\nimport sys\\ninput=sys.stdin.readline\\ndef inp():\\n    return int(input())\\ndef st():\\n    return input().rstrip('\\\\n')\\ndef lis():\\n    return list(map(int,input().split()))\\ndef ma():\\n    return list(map(int,input().split()))\\nt=inp()\\nwhile(t):\\n    t-=1\\n    a,b=ma()\\n    print(a^b)\\n        \\n\", \"read = lambda: map(int, input().split())\\nt = int(input())\\nfor i in range(t):\\n    a, b = read()\\n    print(a^b)\", \"def main():\\n    a, b = list(map(int, input().split()))\\n    print(a + b - 2*(a&b))\\ndef __starting_point():\\n    t = int(input())\\n    for i in range(t):\\n        main()\\n\\n__starting_point()\", \"for _ in range(int(input())):\\n    a, b = list(map(int, input().split()))\\n    n = a & b\\n    print((a^n) + (b^n))\\n\", \"import sys\\ninput=sys.stdin.readline\\n\\nT=int(input())\\nfor _ in range(T):\\n    n,m=list(map(int,input().split()))\\n    print(n^m)\\n\", \"from bisect import bisect_left as bl\\nfrom bisect import bisect_right as br\\nfrom heapq import heappush,heappop\\nimport math\\nfrom collections import *\\nfrom functools import reduce,cmp_to_key\\nimport sys\\ninput = sys.stdin.readline\\nM = mod = 998244353\\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\\ndef inv_mod(n):return pow(n, mod - 2, mod)\\n \\ndef li():return [int(i) for i in input().rstrip('\\\\n').split()]\\ndef st():return input().rstrip('\\\\n')\\ndef val():return int(input().rstrip('\\\\n'))\\ndef li2():return [i for i in input().rstrip('\\\\n')]\\ndef li3():return [int(i) for i in input().rstrip('\\\\n')]\\n\\nfor _ in range(val()):\\n    a, b = li()\\n\\n    ans = 0\\n    for i in range(32):\\n        if (a >> i) & 1 == (b >> i) & 1:\\n            ans += 0\\n        else:\\n            ans += 1 << i\\n    print(ans)\", \"import sys\\ninput = sys.stdin.readline\\nfor _ in range(int(input())):\\n  a, b = map(int, input().split())\\n  print(a + b - (a & b) * 2)\", \"import sys\\nimport math\\nimport bisect\\nfrom sys import stdin, stdout\\nfrom math import gcd, floor, sqrt, log\\nfrom collections import defaultdict as dd\\nfrom bisect import bisect_left as bl, bisect_right as br\\nfrom collections import Counter\\n\\n#sys.setrecursionlimit(100000000)\\n\\ninp = lambda: int(input())\\nstrng = lambda: input().strip()\\njn = lambda x, l: x.join(map(str, l))\\nstrl = lambda: list(input().strip())\\nmul = lambda: map(int, input().strip().split())\\nmulf = lambda: map(float, input().strip().split())\\nseq = lambda: list(map(int, input().strip().split()))\\n\\nceil = lambda x: int(x) if (x == int(x)) else int(x) + 1\\nceildiv = lambda x, d: x // d if (x % d == 0) else x // d + 1\\n\\nflush = lambda: stdout.flush()\\nstdstr = lambda: stdin.readline()\\nstdint = lambda: int(stdin.readline())\\nstdpr = lambda x: stdout.write(str(x))\\nstdarr = lambda: map(int, stdstr().split())\\n\\nmod = 1000000007\\n\\n\\nfor _ in range(stdint()):\\n    a,b = stdarr()\\n\\n    print(a^b)\", \"\\nt = int(input())\\n\\nfor _ in range(t):\\n    a,b = map(int,input().split())\\n    if a > b:\\n        a,b = b,a\\n    print(a^b)\", \"\\\"\\\"\\\"\\n    Author: Sagar Pandey\\n\\n\\\"\\\"\\\"\\n# ---------------------------------------------------Import Libraries---------------------------------------------------\\nimport sys\\nimport os\\nfrom math import sqrt, log, log2, log10, gcd, floor, pow, sin, cos, tan, pi, inf, factorial\\nfrom copy import copy, deepcopy\\nfrom sys import stdin, stdout\\nfrom collections import Counter, defaultdict, deque\\nfrom itertools import permutations\\nimport heapq\\nfrom bisect import bisect_left as bl\\n# If the element is already present in the list,\\n# the left most position where element has to be inserted is returned.\\nfrom bisect import bisect_right as br\\nfrom bisect import bisect\\n\\n# If the element is already present in the list,\\n# the right most position where element has to be inserted is r\\n\\n# ---------------------------------------------------Global Variables---------------------------------------------------\\n# sys.setrecursionlimit(100000000)\\nmod = 1000000007\\n# ---------------------------------------------------Helper Functions---------------------------------------------------\\niinp = lambda: int(sys.stdin.readline())\\ninp = lambda: sys.stdin.readline().strip()\\nstrl = lambda: list(inp().strip().split(\\\" \\\"))\\nintl = lambda: list(map(int, inp().split(\\\" \\\")))\\nmint = lambda: list(map(int, inp().split()))\\nflol = lambda: list(map(float, inp().split(\\\" \\\")))\\nflush = lambda: stdout.flush()\\n\\n\\ndef permute(nums):\\n    def fun(arr, nums, cur, v):\\n        if len(cur) == len(nums):\\n            arr.append(cur.copy())\\n        i = 0\\n        while i < len(nums):\\n            if v[i]:\\n                i += 1\\n                continue\\n            else:\\n                cur.append(nums[i])\\n                v[i] = 1\\n                fun(arr, nums, cur, v)\\n                cur.pop()\\n                v[i] = 0\\n                i += 1\\n            # while i<len(nums) and nums[i]==nums[i-1]:i+=1    # Uncomment for unique permutations\\n        return arr\\n\\n    res = []\\n    nums.sort()\\n    v = [0] * len(nums)\\n    return fun(res, nums, [], v)\\n\\n\\ndef subsets(res, index, arr, cur):\\n    res.append(cur.copy())\\n    for i in range(index, len(arr)):\\n        cur.append(arr[i])\\n        subsets(res, i + 1, arr, cur)\\n        cur.pop()\\n    return res\\n\\n\\ndef sieve(N):\\n    root = int(sqrt(N))\\n    primes = [1] * (N + 1)\\n    primes[0], primes[1] = 0, 0\\n    for i in range(2, root + 1):\\n        if primes[i]:\\n            for j in range(i * i, N + 1, i):\\n                primes[j] = 0\\n    return primes\\n\\n\\ndef bs(arr, l, r, x):\\n    if x < arr[0] or x > arr[len(arr) - 1]:\\n        return -1\\n    while l <= r:\\n        mid = l + (r - l) // 2\\n        if arr[mid] == x:\\n            return mid\\n        elif arr[mid] < x:\\n            l = mid + 1\\n        else:\\n            r = mid - 1\\n    return -1\\n\\n\\ndef isPrime(n):\\n    if n <= 1: return False\\n    if n <= 3: return True\\n    if n % 2 == 0 or n % 3 == 0: return False\\n    p = int(sqrt(n))\\n    for i in range(5, p + 1, 6):\\n        if n % i == 0 or n % (i + 2) == 0:\\n            return False\\n    return True\\n\\n\\n# -------------------------------------------------------Functions------------------------------------------------------\\n\\ndef solve():\\n    a,b=mint()\\n    print(a^b)\\n\\n\\n# -------------------------------------------------------Main Code------------------------------------------------------\\nfor _ in range(iinp()):\\n    solve()\\n\", \"t = int(input())\\nfor _ in range(t):\\n    a, b = map(int, input().split())\\n    print((a + b) - (a & b) * 2)\", \"t = int(input())\\n\\nfor _ in range(t):\\n    a,b = list(map(int,input().split()))\\n    x = a&b\\n    print((a^x) + (b^x))\\n\", \"t=int(input())\\nfor you in range(t):\\n    l=input().split()\\n    a=int(l[0])\\n    b=int(l[1])\\n    z=a&b\\n    print((a^z)+(b^z))\\n\", \"from sys import stdin, stdout\\ninput = stdin.readline\\nfrom collections import defaultdict as dd\\nimport math\\ndef geti(): return list(map(int, input().strip().split()))\\ndef getl(): return list(map(int, input().strip().split()))\\ndef gets(): return input()\\ndef geta(): return int(input())\\ndef print_s(s): stdout.write(s+'\\\\n')\\n\\ndef solve():\\n    for _ in range(geta()):\\n        a,b=geti()\\n        print(a^b)\\n\\n\\ndef __starting_point():\\n    solve()\\n\\n__starting_point()\", \"def read_int():\\n    return int(input())\\n\\n\\ndef read_ints():\\n    return list(map(int, input().split(' ')))\\n\\n\\nt = read_int()\\nfor case_num in range(t):\\n    a, b = read_ints()\\n    print(a ^ b)\\n\", \"from sys import stdin,stdout\\nfor _ in range(int(stdin.readline())):\\n    # n=int(stdin.readline())\\n    a,b=list(map(int,stdin.readline().split()))\\n    print(a^b)\\n\", \"import sys, math\\nimport io, os\\n#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\\nfrom bisect import bisect_left as bl, bisect_right as br, insort\\nfrom heapq import heapify, heappush, heappop\\nfrom collections import defaultdict as dd, deque, Counter\\n#from itertools import permutations,combinations\\ndef data(): return sys.stdin.readline().strip()\\ndef mdata(): return list(map(int, data().split()))\\ndef outl(var) : sys.stdout.write('\\\\n'.join(map(str, var))+'\\\\n')\\ndef out(var) : sys.stdout.write(str(var)+'\\\\n')\\n#from decimal import Decimal\\n#from fractions import Fraction\\n#sys.setrecursionlimit(100000)\\nINF = float('inf')\\nmod=10**9+7\\n\\n\\nfor t in range(int(data())):\\n    a,b=mdata()\\n    out(a^b)\\n\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"6\\n6 12\\n4 9\\n59 832\\n28 14\\n4925 2912\\n1 1\\n\"\n  ],\n  \"outputs\": [\n    \"10\\n13\\n891\\n18\\n6237\\n0\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1421/A", "starter_code": ""}
{"id": 61, "question": "You are given a permutation $p_1, p_2, \\dots, p_n$. Recall that sequence of $n$ integers is called a permutation if it contains all integers from $1$ to $n$ exactly once.\n\nFind three indices $i$, $j$ and $k$ such that:   $1 \\le i < j < k \\le n$;  $p_i < p_j$ and $p_j > p_k$.  Or say that there are no such indices.\n\n\n-----Input-----\n\nThe first line contains a single integer $T$ ($1 \\le T \\le 200$)\u00a0\u2014 the number of test cases.\n\nNext $2T$ lines contain test cases\u00a0\u2014 two lines per test case. The first line of each test case contains the single integer $n$ ($3 \\le n \\le 1000$)\u00a0\u2014 the length of the permutation $p$.\n\nThe second line contains $n$ integers $p_1, p_2, \\dots, p_n$ ($1 \\le p_i \\le n$; $p_i \\neq p_j$ if $i \\neq j$)\u00a0\u2014 the permutation $p$.\n\n\n-----Output-----\n\nFor each test case:   if there are such indices $i$, $j$ and $k$, print YES (case insensitive) and the indices themselves;  if there are no such indices, print NO (case insensitive). \n\nIf there are multiple valid triples of indices, print any of them.\n\n\n-----Example-----\nInput\n3\n4\n2 1 4 3\n6\n4 6 1 2 5 3\n5\n5 3 1 2 4\n\nOutput\nYES\n2 3 4\nYES\n3 5 6\nNO", "solutions": "[\"import sys\\nimport math\\n#from queue import *\\nimport random\\n#sys.setrecursionlimit(int(1e6))\\ninput = sys.stdin.readline\\n \\n############ ---- USER DEFINED INPUT FUNCTIONS ---- ############\\ndef inp():\\n    return(int(input()))\\ndef inara():\\n    return(list(map(int,input().split())))\\ndef insr():\\n    s = input()\\n    return(list(s[:len(s) - 1]))\\ndef invr():\\n    return(list(map(int,input().split())))\\n################################################################\\n############ ---- THE ACTUAL CODE STARTS BELOW ---- ############\\n\\nt=inp()\\n\\nfor _ in range(t):\\n\\tn=inp()\\n\\tara=inara()\\n\\t\\n\\tans=[]\\n\\t\\n\\tfor i in range(1,n-1):\\n\\t\\tif ara[i]>ara[i-1] and ara[i]>ara[i+1]:\\n\\t\\t\\tans.append(i)\\n\\t\\t\\tans.append(i+1)\\n\\t\\t\\tans.append(i+2)\\n\\t\\t\\tbreak\\n\\t\\n\\tif len(ans)==0:\\n\\t\\tprint(\\\"NO\\\")\\n\\telse:\\n\\t\\tprint(\\\"YES\\\")\\n\\t\\tprint(*ans)\\n\\t\\n\\t\\n\\t\\t\\t\\n\", \"for _ in range(int(input())):\\n    N=int(input())\\n    A=list(map(int,input().split()))\\n    temp=0\\n    for i in range(1,N-1):\\n        if(A[i]>A[i-1] and A[i]>A[i+1]):\\n            temp=1\\n            print(\\\"YES\\\")\\n            print(i,i+1,i+2)\\n            break\\n    if(temp==0):\\n        print(\\\"NO\\\")\", \"T = int(input())\\nfor _ in range(T):\\n    n = int(input())\\n    ls = list(map(int, input().split()))\\n    ans = 'NO'\\n    for i in range(1, n -1):\\n        if ls[i] > ls[i-1] and ls[i] > ls[i+1]:\\n            ans = 'YES'\\n            break\\n    if ans == 'NO':\\n        print(ans)\\n    else:\\n        i += 1\\n        print(ans)\\n        print(i-1, i, i+1)\", \"import sys\\n# from collections import defaultdict\\n# t=1\\nt=int(input())\\nfor i in range(t):\\n    n=int(input())\\n    a=list(map(int,sys.stdin.readline().strip().split()))\\n    # a,b,c,d=list(sys.stdin.readline().strip().split())\\n    # n,k=list(map(int,sys.stdin.readline().strip().split()))\\n    \\n    x1=[]\\n    x2=[]\\n    \\n    x=a[0]\\n    mni=0\\n    for j in range(n):\\n       if(a[j]<x):\\n           x=a[j]\\n           mni=j\\n       x1.append([x,mni])\\n    \\n    x=a[n-1]\\n    mni=n-1\\n    for j in range(n-1,-1,-1):\\n        if(a[j]<x):\\n            x=a[j]\\n            mni=j\\n        x2.append([x,mni])\\n        \\n    f=0\\n    for j in range(1,n-1):\\n        if(x1[j-1][0]<a[j] and a[j]>x2[n-j-1][0]):\\n            print(\\\"YES\\\")\\n            print(x1[j-1][1]+1,j+1,x2[n-j-1][1]+1)\\n            f=1\\n            break\\n    if(f):\\n        continue\\n    print(\\\"NO\\\")\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    p = list(map(int, input().split()))\\n    for i in range(1, n - 1):\\n        if p[i] > p[i - 1] and p[i] > p[i + 1]:\\n            print(\\\"YES\\\")\\n            print(i, i + 1, i + 2)\\n            break\\n    else:\\n        print(\\\"NO\\\")\", \"for _ in range(int(input())):\\n\\tn=int(input())\\n\\ta=list(map(int,input().split()))\\n\\t#n,k=map(int,input().split())\\n\\tyes=0 \\n\\tfor i in range(1,n-1):\\n\\t\\tif(a[i]>a[i-1] and a[i]>a[i+1]):\\n\\t\\t\\tprint('YES')\\n\\t\\t\\tprint(i-1+1,i+1,i+2)\\n\\t\\t\\tyes=1\\n\\t\\t\\tbreak \\n\\tif(yes==0):\\n\\t\\tprint('NO')\", \"def main():\\n\\t# n ,m= map(int,input().split())\\n\\t# arr = list(map(int,input().split()))\\n\\t# b = list(map(int,input().split()))\\n\\t# n = int(input())\\n\\t# string = str(input())\\n\\t# a = list(map(int,input().split()))\\t\\n\\tn = int(input())\\n\\ta = list(map(int,input().split()))\\n\\tfor i in range(n-2):\\n\\t\\tif a[i]<a[i+1] and a[i+1]>a[i+2]:\\n\\t\\t\\tprint(\\\"YES\\\")\\n\\t\\t\\tprint(i+1,i+2,i+3)\\n\\t\\t\\treturn\\n\\tprint(\\\"NO\\\")\\n\\t\\n\\t\\n# main()\\ndef test():\\n\\tt = int(input())\\n\\twhile t:\\n\\t\\tmain()\\n\\t\\tt-=1\\ntest()\", \"\\nfor kek in range(int(input())):\\n    n = int(input())\\n    p = list(map(int, input().split()))\\n    flag = False\\n    ans = 0\\n    for i in range(1, n-1):\\n\\n        if p[i-1] < p[i] and p[i] > p[i+1]:\\n            flag = True\\n            ans = i + 1\\n            break\\n\\n    if flag:\\n        print('YES')\\n        print(ans-1,ans,ans+1)\\n    else:\\n        print('NO')\\n\", \"t = int(input())\\n\\nfor _ in range(t):\\n    n = int(input())\\n    A = [int(x) for x in input().split()]\\n    for i in range(1,n-1):\\n        if A[i-1] < A[i] and A[i] > A[i+1]:\\n            print('YES')\\n            print(i, i+1, i+2)\\n            break\\n    else:\\n        print('NO')\\n\\n\", \"from math import *\\nt=int(input())\\nfor _ in range(t):\\n    n=int(input())\\n    a=list(map(int,input().split()))\\n    for i in range(1,n-1):\\n        if a[i]>a[i-1] and a[i]>a[i+1]:\\n            print('YES')\\n            print(i,i+1,i+2)\\n            break\\n    else:\\n        print('NO')\\n\", \"t = int(input())\\n\\nfor _ in range(t):\\n    n = int(input())\\n    A = [int(x) for x in input().split()]\\n    for i in range(1,n-1):\\n        if A[i-1] < A[i] and A[i] > A[i+1]:\\n            print('YES')\\n            print(i, i+1, i+2)\\n            break\\n    else:\\n        print('NO')\\n\\n\", \"from sys import stdin, stdout\\nimport math,sys\\nfrom itertools import permutations, combinations\\nfrom collections import defaultdict,deque,OrderedDict\\nfrom os import path\\nimport bisect as bi\\nimport heapq \\ndef yes():print('YES')\\ndef no():print('NO')\\nif (path.exists('input.txt')): \\n    #------------------Sublime--------------------------------------#\\n    sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\\n    def I():return (int(input()))\\n    def In():return(list(map(int,input().split())))\\nelse:\\n    #------------------PYPY FAst I/o--------------------------------#\\n    def I():return (int(stdin.readline()))\\n    def In():return(list(map(int,stdin.readline().split())))\\n\\ndef dict(a):\\n    d={}\\n    for x in a:\\n        if d.get(x,-1)!=-1:\\n            d[x]+=1\\n        else:\\n            d[x]=1\\n    return d\\n\\ndef main():\\n    try:\\n        n=I()\\n        l=list(In())\\n        ans=-1\\n        for x in range(1,n-1):\\n            if l[x-1]<l[x] and l[x]>l[x+1]:\\n                ans=x\\n                break\\n        if ans==-1:\\n            no()\\n        else:\\n            yes()\\n            print(ans,ans+1,ans+2)\\n\\n    except:\\n        pass\\n        \\nM = 998244353\\nP = 1000000007\\n \\ndef __starting_point():\\n    for _ in range(I()):main()\\n    #for _ in range(1):main()\\n\\n__starting_point()\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n4\\n2 1 4 3\\n6\\n4 6 1 2 5 3\\n5\\n5 3 1 2 4\\n\"\n  ],\n  \"outputs\": [\n    \"YES\\n2 3 4\\nYES\\n1 2 3\\nNO\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1380/A", "starter_code": ""}
{"id": 62, "question": "Polycarp wants to assemble his own keyboard. Layouts with multiple rows are too complicated for him \u2014 his keyboard will consist of only one row, where all $26$ lowercase Latin letters will be arranged in some order.\n\nPolycarp uses the same password $s$ on all websites where he is registered (it is bad, but he doesn't care). He wants to assemble a keyboard that will allow to type this password very easily. He doesn't like to move his fingers while typing the password, so, for each pair of adjacent characters in $s$, they should be adjacent on the keyboard. For example, if the password is abacaba, then the layout cabdefghi... is perfect, since characters a and c are adjacent on the keyboard, and a and b are adjacent on the keyboard. It is guaranteed that there are no two adjacent equal characters in $s$, so, for example, the password cannot be password (two characters s are adjacent).\n\nCan you help Polycarp with choosing the perfect layout of the keyboard, if it is possible?\n\n\n-----Input-----\n\nThe first line contains one integer $T$ ($1 \\le T \\le 1000$) \u2014 the number of test cases.\n\nThen $T$ lines follow, each containing one string $s$ ($1 \\le |s| \\le 200$) representing the test case. $s$ consists of lowercase Latin letters only. There are no two adjacent equal characters in $s$.\n\n\n-----Output-----\n\nFor each test case, do the following:\n\n  if it is impossible to assemble a perfect keyboard, print NO (in upper case, it matters in this problem);  otherwise, print YES (in upper case), and then a string consisting of $26$ lowercase Latin letters \u2014 the perfect layout. Each Latin letter should appear in this string exactly once. If there are multiple answers, print any of them. \n\n\n-----Example-----\nInput\n5\nababa\ncodedoca\nabcda\nzxzytyz\nabcdefghijklmnopqrstuvwxyza\n\nOutput\nYES\nbacdefghijklmnopqrstuvwxyz\nYES\nedocabfghijklmnpqrstuvwxyz\nNO\nYES\nxzytabcdefghijklmnopqrsuvw\nNO", "solutions": "[\"T = int(input())\\n\\n\\n\\ndef solve(S):\\n    res = [S[0]]\\n    pos = 0 # think...\\n    for s in S[1:]:\\n        # can we change?\\n        if 0 <= pos-1 < len(res) and res[pos-1] == s:\\n            pos = pos-1\\n        elif 0 <= pos+1 < len(res) and res[pos+1] == s:\\n            pos = pos+1\\n        elif pos == 0 and s not in res:\\n            res.insert(0, s) # pos is still 0\\n        elif pos == len(res)-1 and s not in res:\\n            res.append(s)\\n            pos += 1\\n        else: return None\\n    #print(''.join(res))\\n    for x in range(ord('a'), ord('z')+1):\\n        x = chr(x)\\n        if x not in res:\\n            res.append(x)\\n    return ''.join(res)\\n\\nfor _ in range(T):\\n    res = solve(input())\\n    if res is None:\\n        print('NO')\\n    else:\\n        print('YES')\\n        print(res)\\n\", \"#!python3\\n\\\"\\\"\\\"\\nAuthor: w1ld [at] inbox [dot] ru\\n\\\"\\\"\\\"\\n\\nfrom collections import deque, Counter\\nimport array\\nfrom itertools import combinations, permutations\\nfrom math import sqrt\\n# import unittest\\n\\n\\ndef read_int():\\n    return int(input().strip())\\n\\n\\ndef read_int_array():\\n    return [int(i) for i in input().strip().split(' ')]\\n\\n######################################################\\n\\nclass Node:\\n    def __init__(self, c):\\n        self.c = c\\n        self.l = None\\n        self.r = None\\n\\n\\ntests = read_int()\\n\\nfor test in range(tests):\\n    s = input().strip()\\n    left = Node(s[0])\\n    x = left\\n    found = True\\n    used = set([x.c])\\n    for c in s[1:]:\\n        if x.c == c:\\n            continue\\n        if x.l and x.l.c == c:\\n            x = x.l\\n        elif x.r and x.r.c == c:\\n            x = x.r\\n        elif not x.l and c not in used:\\n            x.l = Node(c)\\n            used.add(c)\\n            x.l.r = x\\n            x = x.l\\n            left = x\\n        elif not x.r and c not in used:\\n            x.r = Node(c)\\n            used.add(c)\\n            x.r.l = x\\n            x = x.r\\n        else:\\n            found = False\\n            break\\n\\n    if not found:\\n        print(\\\"NO\\\")\\n    else:\\n        ans = []\\n        x = left\\n        while x:\\n            ans.append(x.c)\\n            x = x.r\\n        for c in 'abcdefghijklmnopqrstuvwxyz':\\n            if c not in used:\\n                ans.append(c)\\n        print(\\\"YES\\\")\\n        print(''.join(ans))\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\", \"for _ in range(int(input())):\\n    q=input()\\n    ans=q[0]\\n    test=[0]*26\\n    j=0\\n    c = 1\\n    for i in q[1:]:\\n        if j>0 and ans[j-1]==i:\\n            j-=1\\n            continue\\n        if j<len(ans)-1 and ans[j+1]==i:\\n            j+=1\\n            continue\\n        if j==0:\\n            ans=i+ans\\n            continue\\n        if j==len(ans)-1:\\n            ans+=i\\n            j+=1\\n            continue\\n        c=0\\n    for i in ans:test[ord(i)-97]+=1\\n    for i in range(26):\\n        if test[i]>1:c=0\\n        if test[i]==0:ans+=chr(i+97)\\n    if c:\\n        print('YES')\\n        print(ans)\\n    else:\\n        print('NO')\", \"T = int(input())\\n\\ndef solve(s):\\n    kb = list()\\n    cursor = -1\\n    seen = set()\\n    for c in s:\\n        if c in seen:\\n            if cursor - 1 >= 0 and kb[cursor - 1] == c:\\n                cursor -= 1\\n            elif cursor + 1 < len(kb) and kb[cursor + 1] == c:\\n                cursor += 1\\n            else:\\n                print('NO')\\n                return\\n        else:\\n            if cursor not in [0, len(kb) - 1]:\\n                print('NO')\\n                return\\n            elif cursor == 0:\\n                kb.insert(0, c)\\n                cursor = 0\\n            else:\\n                kb.append(c)\\n                cursor = len(kb) - 1\\n            seen.add(c)\\n    print('YES')\\n    ans = ''.join(kb)\\n    for c in 'abcdefghijklmnopqrstuvwxyz':\\n        if c not in seen:\\n            ans += c\\n    print(ans)\\n\\nfor _ in range(T):\\n    solve(input())\"]", "input_output": "{\n  \"inputs\": [\n    \"5\\nababa\\ncodedoca\\nabcda\\nzxzytyz\\nabcdefghijklmnopqrstuvwxyza\\n\"\n  ],\n  \"outputs\": [\n    \"YES\\nbacdefghijklmnopqrstuvwxyz\\nYES\\nedocabfghijklmnpqrstuvwxyz\\nNO\\nYES\\nxzytabcdefghijklmnopqrsuvw\\nNO\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1303/C", "starter_code": ""}
{"id": 63, "question": "Lee just became Master in Codeforces, and so, he went out to buy some gifts for his friends. He bought $n$ integers, now it's time to distribute them between his friends rationally...\n\nLee has $n$ integers $a_1, a_2, \\ldots, a_n$ in his backpack and he has $k$ friends. Lee would like to distribute all integers in his backpack between his friends, such that the $i$-th friend will get exactly $w_i$ integers and each integer will be handed over to exactly one friend.\n\nLet's define the happiness of a friend as the sum of the maximum and the minimum integer he'll get.\n\nLee would like to make his friends as happy as possible, in other words, he'd like to maximize the sum of friends' happiness. Now he asks you to calculate the maximum sum of friends' happiness.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases.\n\nNext $3t$ lines contain test cases\u00a0\u2014 one per three lines.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le n \\le 2 \\cdot 10^5$; $1 \\le k \\le n$)\u00a0\u2014 the number of integers Lee has and the number of Lee's friends.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($-10^9 \\le a_i \\le 10^9$)\u00a0\u2014 the integers Lee has.\n\nThe third line contains $k$ integers $w_1, w_2, \\ldots, w_k$ ($1 \\le w_i \\le n$; $w_1 + w_2 + \\ldots + w_k = n$)\u00a0\u2014 the number of integers Lee wants to give to each friend. \n\nIt's guaranteed that the sum of $n$ over test cases is less than or equal to $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, print a single integer\u00a0\u2014 the maximum sum of happiness Lee can achieve.\n\n\n-----Example-----\nInput\n3\n4 2\n1 13 7 17\n1 3\n6 2\n10 10 10 10 11 11\n3 3\n4 4\n1000000000 1000000000 1000000000 1000000000\n1 1 1 1\n\nOutput\n48\n42\n8000000000\n\n\n\n-----Note-----\n\nIn the first test case, Lee should give the greatest integer to the first friend (his happiness will be $17 + 17$) and remaining integers to the second friend (his happiness will be $13 + 1$).\n\nIn the second test case, Lee should give $\\{10, 10, 11\\}$ to the first friend and to the second friend, so the total happiness will be equal to $(11 + 10) + (11 + 10)$\n\nIn the third test case, Lee has four friends and four integers, it doesn't matter how he distributes the integers between his friends.", "solutions": "[\"def solve():\\n    n, k = map(int,input().split())\\n    lst1 = list(map(int,input().split()))\\n    lst1.sort(reverse=True)\\n    ind = 0\\n    ans = 0\\n    lst2 = list(map(int,input().split()))\\n    lst2.sort()\\n    for i in range(k):\\n        lst2[i] -= 1\\n        if lst2[i] == 0: ans += lst1[ind]\\n        ans += lst1[ind]\\n        ind += 1\\n    lst2.sort()\\n    for i in lst2:\\n        if i != 0:\\n            ind += i - 1\\n            ans += lst1[ind]\\n            ind += 1\\n    print(ans)\\nfor i in range(int(input())):\\n    solve()\", \"for _ in range(int(input())):\\n    n, k = list(map(int, input().split()))\\n    # n = int(input())\\n    arr = list(map(int, input().split()))\\n    wrr = list(map(int, input().split()))\\n    wrr.sort()\\n    arr.sort()\\n    ans = 0\\n    for i in range(k):\\n        ans += arr[-1]\\n        wrr[i] -= 1\\n        if wrr[i] == 0:\\n            ans += arr[-1]\\n        arr.pop()\\n    i = 0\\n    j = 0\\n    wrr.sort(reverse=True)\\n    while i < len(arr) and j < len(wrr):\\n        if wrr[j] == 0:\\n            j += 1\\n        else:\\n            ans += arr[i]\\n            i += wrr[j]\\n            wrr[j] = 0\\n    print(ans)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\nfor tests in range(t):\\n    n,k=list(map(int,input().split()))\\n    A=list(map(int,input().split()))\\n    W=list(map(int,input().split()))\\n\\n    W.sort()\\n    A.sort(reverse=True)\\n\\n    ANS=[[] for i in range(k)]\\n\\n    ind=0\\n    for i in range(k):\\n        ANS[i].append(A[ind])\\n        ind+=1\\n        W[i]-=1\\n\\n    for i in range(k):\\n        while W[i]:\\n            ANS[i].append(A[ind])\\n            ind+=1\\n            W[i]-=1\\n\\n    L=0\\n    for ans in ANS:\\n        L+=max(ans)+min(ans)\\n    print(L)\\n\\n    \\n\", \"from sys import stdin, stdout\\nimport math\\n\\nt = int(stdin.readline())\\nfor _ in range(t):\\n    n, k = list(map(int, stdin.readline().split()))\\n    a = list(map(int, stdin.readline().split()))\\n    w = list(map(int, stdin.readline().split()))\\n\\n    a = sorted(a)\\n    w = sorted(w)\\n    st, end = 0, n-1\\n    ans = 0\\n    idx = 0\\n    while idx < k and w[idx] == 1:\\n        ans += a[end]*2\\n        end -= 1\\n        idx += 1\\n    for i in range(k-1, idx-1, -1):\\n        wi = w[i]\\n        ans += a[st] + a[end]\\n        end -= 1\\n        st += wi-1\\n    print(ans)\\n\", \"ans = []\\nfor _ in range(int(input())):\\n    n, k = list(map(int, input().split()))\\n    u = list(map(int, input().split()))\\n    w = list(map(int, input().split()))\\n    u.sort()\\n    w.sort(reverse=1)\\n    ansi = 0\\n    ind = 0\\n    for i in range(k):\\n        if w[i] == 1:\\n            ansi += u[n - k + i] * 2\\n        else:\\n            ansi += u[ind] + u[n - k + i]\\n        ind += w[i] - 1\\n    ans.append(ansi)\\nprint('\\\\n'.join(map(str, ans)))\\n    \\n\", \"from collections import defaultdict as dd\\nfrom collections import deque\\nimport bisect\\nimport heapq\\n\\ndef ri():\\n    return int(input())\\n\\ndef rl():\\n    return list(map(int, input().split()))\\n\\n\\ndef solve():\\n    n, k = rl()\\n    A = rl()\\n    W = rl()\\n    A.sort()\\n    W.sort(reverse=True)\\n\\n    lo, hi = 0, len(A) - 1\\n    answer = 0\\n    for w in W[::-1]:\\n        if w != 1:\\n            break\\n        answer += 2 * A[hi]\\n        hi -= 1\\n\\n    for w in W:\\n        if w == 1:\\n            break\\n        else:\\n            answer += A[hi] + A[lo]\\n            lo += w - 1\\n            hi -= 1\\n    print (answer)\\n\\n\\n\\n\\n\\n\\nmode = 'T'\\n\\nif mode == 'T':\\n    t = ri()\\n    for i in range(t):\\n        solve()\\nelse:\\n    solve()\\n\", \"import sys\\nimport math\\ninput = sys.stdin.readline\\n\\nt = int(input())\\nfor _ in range(t):\\n    a,b = list(map(int, input().split()))\\n    n = list(map(int, input().split()))\\n    w = list(map(int, input().split()))\\n    \\n    n.sort(reverse=True)\\n    w.sort()\\n    \\n    ans = 0\\n    for j in range(b):\\n        ans += n[j]\\n        if w[j] == 1:\\n            ans += n[j]\\n        \\n    ind = b - 1\\n        \\n    for j in range(b):\\n        if w[j]>1:\\n            ind += w[j] - 1\\n            ans += n[ind]\\n        \\n    print(ans)\", \"import math\\n\\n\\ndef main():\\n    n, k = list(map(int, input().split()))\\n    a = sorted(list(map(int, input().split())))\\n    w = sorted(list(map(int, input().split())))\\n    sm = 0\\n    w = list(reversed(w))\\n    for i in range(k):\\n        r = a.pop()\\n        w[k - 1 - i] -= 1\\n        if w[k - 1 - i] == 0:\\n            sm += 2*r\\n        else:\\n            sm += r\\n    o = 0\\n    for i in range(k):\\n        if w[i] != 0:\\n            sm += a[o]\\n            o += w[i]\\n    print(sm)\\n\\n\\n\\ndef __starting_point():\\n    t = int(input())\\n    for i in range(t):\\n        main()\\n\\n__starting_point()\", \"t=int(input())\\nfor i in range(t):\\n    n,k=map(int,input().split())\\n    a=list(map(int,input().split()))\\n    w=list(map(int,input().split()))\\n    a.sort()\\n    a.reverse()\\n    w.sort()\\n    ans=0\\n    for i in range(k):\\n        ans+=a[i]\\n    pointer=k-1\\n    for i in range(k):\\n        if w[i]==1:\\n            ans+=a[i]\\n            continue\\n        pointer+=w[i]-1\\n        ans+=a[pointer]\\n    print(ans)\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n4 2\\n1 13 7 17\\n1 3\\n6 2\\n10 10 10 10 11 11\\n3 3\\n4 4\\n1000000000 1000000000 1000000000 1000000000\\n1 1 1 1\\n\"\n  ],\n  \"outputs\": [\n    \"48\\n42\\n8000000000\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1369/C", "starter_code": ""}
{"id": 64, "question": "There is a road with length $l$ meters. The start of the road has coordinate $0$, the end of the road has coordinate $l$.\n\nThere are two cars, the first standing at the start of the road and the second standing at the end of the road. They will start driving simultaneously. The first car will drive from the start to the end and the second car will drive from the end to the start.\n\nInitially, they will drive with a speed of $1$ meter per second. There are $n$ flags at different coordinates $a_1, a_2, \\ldots, a_n$. Each time when any of two cars drives through a flag, the speed of that car increases by $1$ meter per second.\n\nFind how long will it take for cars to meet (to reach the same coordinate). \n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\leq t \\leq 10^4$): the number of test cases.\n\nThe first line of each test case contains two integers $n$, $l$ ($1 \\leq n \\leq 10^5$, $1 \\leq l \\leq 10^9$): the number of flags and the length of the road.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ in the increasing order ($1 \\leq a_1 < a_2 < \\ldots < a_n < l$).\n\nIt is guaranteed that the sum of $n$ among all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case print a single real number: the time required for cars to meet.\n\nYour answer will be considered correct, if its absolute or relative error does not exceed $10^{-6}$. More formally, if your answer is $a$ and jury's answer is $b$, your answer will be considered correct if $\\frac{|a-b|}{\\max{(1, b)}} \\leq 10^{-6}$.\n\n\n-----Example-----\nInput\n5\n2 10\n1 9\n1 10\n1\n5 7\n1 2 3 4 6\n2 1000000000\n413470354 982876160\n9 478\n1 10 25 33 239 445 453 468 477\n\nOutput\n3.000000000000000\n3.666666666666667\n2.047619047619048\n329737645.750000000000000\n53.700000000000000\n\n\n\n-----Note-----\n\nIn the first test case cars will meet in the coordinate $5$.\n\nThe first car will be in the coordinate $1$ in $1$ second and after that its speed will increase by $1$ and will be equal to $2$ meters per second. After $2$ more seconds it will be in the coordinate $5$. So, it will be in the coordinate $5$ in $3$ seconds.\n\nThe second car will be in the coordinate $9$ in $1$ second and after that its speed will increase by $1$ and will be equal to $2$ meters per second. After $2$ more seconds it will be in the coordinate $5$. So, it will be in the coordinate $5$ in $3$ seconds.\n\nIn the second test case after $1$ second the first car will be in the coordinate $1$ and will have the speed equal to $2$ meters per second, the second car will be in the coordinate $9$ and will have the speed equal to $1$ meter per second. So, they will meet after $\\frac{9-1}{2+1} = \\frac{8}{3}$ seconds. So, the answer is equal to $1 + \\frac{8}{3} = \\frac{11}{3}$.", "solutions": "[\"import sys\\nimport random\\nfrom fractions import Fraction\\nfrom math import *\\n \\ndef input():\\n    return sys.stdin.readline().strip()\\n \\ndef iinput():\\n    return int(input())\\n\\ndef finput():\\n    return float(input())\\n\\ndef tinput():\\n    return input().split()\\n\\ndef linput():\\n    return list(input())\\n \\ndef rinput():\\n    return list(map(int, tinput()))\\n\\ndef fiinput():\\n    return list(map(float, tinput()))\\n \\ndef rlinput():\\n    return list(map(int, input().split()))\\ndef trinput():\\n    return tuple(rinput())\\n\\ndef srlinput():\\n    return sorted(list(map(int, input().split())))\\n\\ndef NOYES(fl):\\n    if fl:\\n        print(\\\"NO\\\")\\n    else:\\n        print(\\\"YES\\\")\\ndef YESNO(fl):\\n    if fl:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n    \\ndef main():\\n    n, l = rinput()\\n    #n = iinput()\\n    #k = iinput() \\n    #m = iinput() \\n    #n = int(sys.stdin.readline().strip()) \\n    #n, k = rinput()\\n    #n, m = rinput()\\n    #m, k = rinput()\\n    #n, k, m = rinput()\\n    #n, m, k = rinput()\\n    #k, n, m = rinput()\\n    #k, m, n = rinput() \\n    #m, k, n = rinput()\\n    #m, n, k = rinput()\\n    q = rlinput()\\n    #q = linput()\\n    q = [0] + q + [l]\\n    w, e = [0] * (n + 2), [0] * (n + 2)\\n    \\n    for i in range(1, n + 2):\\n        e[n + 1 - i] = e[n + 2 - i] + ((q[-i] - q[-1 - i]) / i)\\n        w[i] = w[i - 1] + ((q[i] - q[i - 1]) / i)\\n        \\n    left, right = 0, n + 2\\n    while right > left + 1:\\n        mid = (right + left) // 2\\n        if w[mid] >= e[mid]:\\n            right = mid\\n        else:\\n            left = mid\\n            \\n    print((q[right] - q[right - 1] - (max(0, w[right - 1] - e[right]) * (n - right + 2) + max(0, e[right] - w[right - 1]) * right)) / (n + 2) + max(w[right - 1], e[right]))\\n        \\n\\n            \\n        \\n    \\n                \\n    \\n    \\n    \\n            \\n    \\n        \\n    \\n\\nfor i in range(iinput()):\\n    main()\\n\", \"for __ in range(int(input())):\\n    n, l = list(map(int, input().split()))\\n    ar = list(map(int, input().split()))\\n    i, j = 0, n - 1\\n    x, y = 0, l\\n    v1, v2 = 1, 1\\n    ans = 0\\n    while i <= j and x < y:\\n        if (ar[i] - x) / v1 < (y - ar[j]) / v2:\\n            ans += (ar[i] - x) / v1\\n            y -= v2 * (ar[i] - x) / v1\\n            x = ar[i]\\n            v1 += 1\\n            i += 1\\n        else:\\n            ans += (y - ar[j]) / v2\\n            x += v1 * (y - ar[j]) / v2\\n            y = ar[j]\\n            v2 += 1\\n            j -= 1\\n    ans += (y - x) / (v1 + v2)\\n    print(ans)\", \"for _ in range(int(input())):\\n  n,l=map(int,input().split())\\n  a=[0]+list(map(int,input().split()))+[l]\\n  b=[a[i+1]-a[i] for i in range(n+1)]\\n  ansl=0\\n  le=0\\n  lf=1\\n  ansr=0\\n  ri=n\\n  rf=1\\n  while le!=ri:\\n    if ansl+b[le]/lf<ansr+b[ri]/rf:\\n      ansl+=b[le]/lf\\n      le+=1\\n      lf+=1\\n    else:\\n      ansr+=b[ri]/rf\\n      ri-=1\\n      rf+=1\\n  t=b[le]\\n  ans=max(ansl,ansr)\\n  if ansl<ansr:\\n    t-=(ansr-ansl)*lf\\n  if ansl>ansr:\\n    t-=(ansl-ansr)*rf\\n  print(ans+t/(lf+rf))\", \"import sys\\ninput = sys.stdin.readline\\n\\ndef main():\\n    n, l = map(int, input().split())\\n    alst = list(map(int, input().split()))\\n    ll = 0\\n    rr = n - 1\\n    l_pos = 0\\n    r_pos = l\\n    l_speed = 1\\n    r_speed = 1\\n    ans = 0\\n    while rr >= ll:\\n        l2 = (alst[ll] - l_pos) * r_speed\\n        r2 = (r_pos - alst[rr]) * l_speed\\n        if r2 == l2:\\n            ans += (alst[ll] - l_pos) / l_speed\\n            r_pos = alst[rr]\\n            l_pos = alst[ll]\\n            r_speed += 1\\n            l_speed += 1\\n            rr -= 1\\n            ll += 1\\n        elif r2 < l2:\\n            ans += (r_pos - alst[rr]) / r_speed\\n            l_pos += (r_pos - alst[rr]) / r_speed * l_speed\\n            r_pos = alst[rr]\\n            r_speed += 1\\n            rr -= 1\\n        else:\\n            ans += (alst[ll] - l_pos) / l_speed\\n            r_pos -= (alst[ll] - l_pos) / l_speed * r_speed\\n            l_pos = alst[ll]\\n            l_speed += 1\\n            ll += 1\\n\\n    ans += (r_pos - l_pos) / (r_speed + l_speed)\\n    print(ans)\\n    \\nfor _ in range(int(input())):\\n    main()\", \"from sys import stdin\\ninput = stdin.readline\\n\\n\\ndef myk(l, stops, czas):\\n    pos = 0\\n    v = 1.0\\n    for stop in stops:\\n        dist = stop - pos\\n        if czas * v > dist:\\n            czas -= dist/v\\n            pos = stop\\n            v += 1\\n        else:\\n            return pos + czas * v\\n    return pos + czas * v\\n\\n\\ndef solve():\\n    n, l = [int(x) for x in input().split()]\\n    a = [int(x) for x in input().split()]\\n    b = [l - x for x in a[::-1]]\\n    pocz = 0.0\\n    kon = l/2.0\\n    eps = 1e-7\\n    while pocz + eps < kon:\\n        mid = (pocz + kon) / 2.0\\n        pos1 = myk(l, a, mid)\\n        pos2 = l - myk(l, b, mid)\\n        if pos1 < pos2:\\n            pocz = mid\\n        else:\\n            kon = mid\\n    print(kon)\\n\\n\\nt = int(input())\\n\\nfor _ in range(t):\\n    solve()\", \"import sys\\n\\ninput = sys.stdin.readline\\n\\nfor _ in range(int(input())):\\n    n,l = list(map(int,input().split()))\\n    a = list(map(int,input().split()))\\n    a = [0] + a + [l]\\n\\n    s = [0 for i in range(n+2)]\\n    e = [0 for i in range(n+2)]\\n    for i in range(1,n+2):\\n        s[i] = (a[i] - a[i-1])/i\\n        s[i] += s[i-1]\\n    a = a[::-1]\\n    for i in range(1,n+2):\\n        e[i] = (a[i-1] - a[i])/i\\n        e[i] += e[i-1]\\n    e = e[::-1]\\n    #print(s)\\n    #print(e)\\n    a = a[::-1]\\n\\n    for i in range(1,n+2):\\n        if s[i]>=e[i]:\\n            #i-1~i\\n            #print(i)\\n            s_speed = i\\n            e_spped = n+2-i\\n            if s[i-1]<=e[i]:\\n                L = a[i] - a[i-1] - s_speed * (e[i] - s[i-1])\\n                t = L/(n+2)\\n                ans = e[i] + t\\n                print(ans)\\n                break\\n            else:\\n                L = a[i] - a[i-1] - e_spped * (s[i-1] - e[i])\\n                t = L/(n+2)\\n                ans = s[i-1] + t\\n                print(ans)\\n                break\\n\", \"t = int(input())\\nfor i in range(t):\\n\\tn, l = list(map(int, input().split()))\\n\\ta = list(map(int, input().split()))\\n\\ttmp1 = 0\\n\\ttmp2 = n - 1\\n\\tt = 0\\n\\tv1 = 1\\n\\tv2 = 1\\n\\tx1 = 0\\n\\tx2 = l\\n\\twhile (tmp2 - tmp1) > -1:\\n\\t\\tt1 = (a[tmp1] - x1) / v1\\n\\t\\tt2 = (x2 - a[tmp2]) / v2\\n\\t\\tif t1 > t2:\\n\\t\\t\\tx1 += v1 * t2\\n\\t\\t\\tx2 -= v2 * t2\\n\\t\\t\\tv2 += 1\\n\\t\\t\\tt += t2\\n\\t\\t\\ttmp2 -= 1\\n\\t\\telif abs(t1 - t2) < 0.000000001:\\n\\t\\t\\tx1 += v1 * t1\\n\\t\\t\\tx2 -= v2 * t2\\n\\t\\t\\tv1 += 1\\n\\t\\t\\tv2 += 1\\n\\t\\t\\tt += t1\\n\\t\\t\\ttmp2 -= 1\\n\\t\\t\\ttmp1 += 1\\n\\t\\telse:\\n\\t\\t\\tx1 += v1 * t1\\n\\t\\t\\tx2 -= v2 * t1\\n\\t\\t\\tv1 += 1\\n\\t\\t\\tt += t1\\n\\t\\t\\ttmp1 += 1\\n\\tt += (x2 - x1) / (v1 + v2)\\n\\tprint(\\\"{:.07f}\\\".format(t))\\n\\t\\t\\n\", \"for _ in range(int(input())):\\n    n, l = list(map(int, input().split()))\\n    arr = list(map(int, input().split()))\\n    ls, rs, lx, rx, li, ri = 1, 1, 0, l, 0, n\\n    total = 0\\n    while li != ri:\\n        if (arr[li]-lx)/ls < (rx-arr[ri-1])/rs:\\n            total += (arr[li]-lx)/ls\\n            rx -= (arr[li]-lx)/ls*rs\\n            lx = arr[li]\\n            li += 1\\n            ls += 1\\n        else:\\n            total += (rx-arr[ri-1])/rs\\n            lx += (rx-arr[ri-1])/rs*ls\\n            rx = arr[ri-1]\\n            ri -= 1\\n            rs += 1\\n    total += (rx-lx)/(ls+rs)\\n    print(total)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nfrom bisect import bisect_right\\n\\nfor _ in range(int(input())):\\n\\tn, l = list(map(int, input().split()))\\n\\tA = list(map(int, input().split()))\\n\\n\\tc1 = []\\n\\tspeed = 1\\n\\tx = 0\\n\\tt = 0.\\n\\tfor a in A:\\n\\t\\tt += (a-x)/speed\\n\\t\\tc1.append(t)\\n\\t\\tspeed += 1\\n\\t\\tx = a\\n\\n\\tc2 = []\\n\\tspeed = 1\\n\\tx = l\\n\\tt = 0.\\n\\tfor a in reversed(A):\\n\\t\\tt += (x-a)/speed\\n\\t\\tc2.append(t)\\n\\t\\tspeed += 1\\n\\t\\tx = a\\n\\n\\tlo = 0.\\n\\thi = float(l)\\n\\n\\twhile hi - lo > 1e-7:\\n\\t\\tm = (lo + hi) / 2\\n\\n\\t\\ti1 = bisect_right(c1, m)-1\\n\\t\\tif i1 == -1:\\n\\t\\t\\tx1 = m\\n\\t\\telse:\\n\\t\\t\\ttpass = c1[i1]\\n\\t\\t\\ttextra = m - tpass\\n\\t\\t\\tx1 = A[i1] + textra * (i1+2)\\n\\n\\t\\ti2 = bisect_right(c2, m)-1\\n\\t\\tif i2 == -1:\\n\\t\\t\\tx2 = l-m\\n\\t\\telse:\\n\\t\\t\\ttpass = c2[i2]\\n\\t\\t\\ttextra = m - tpass\\n\\t\\t\\tx2 = A[-1-i2] - textra * (i2+2)\\n\\n\\t\\tif x1 < x2: lo = m\\n\\t\\telse: hi = m\\n\\n\\tprint((lo+hi)/2)\\n\", \"y=lambda:[*map(int,input().split())]\\nfor _ in range(int(input())):\\n    n,t=map(int,input().split())\\n    a=[0]+y()+[t]\\n    l,h=0,n+1\\n    tl=th=0\\n    while h-l>1:\\n        dl=(a[l+1]-a[l])/(l+1)\\n        dh=(a[h]-a[h-1])/(n+2-h)\\n        if tl+dl>th+dh:th+=dh;h-=1\\n        else:tl+=dl;l+=1\\n    sh,sl=n+2-h,l+1\\n    if tl>th:tl,th=th,tl;sh,sl=sl,sh\\n    print(th+(a[h]-a[l]-(th-tl)*sl)/(sh+sl))\", \"import sys\\ninput = lambda: sys.stdin.readline().rstrip()\\n\\nT = int(input())\\nfor _ in range(T):\\n    N, L = list(map(int, input().split()))\\n    N += 2\\n    A = [0] + [int(a) for a in input().split()] + [L]\\n    x1 = 0\\n    x2 = N - 1\\n    t1, t2 = 0, 0\\n    while x2 - x1 > 1:\\n        a1 = t1 + (A[x1+1] - A[x1]) / (x1 + 1)\\n        a2 = t2 + (A[x2] - A[x2-1]) / (N - x2)\\n        if a1 < a2:\\n            t1 = a1\\n            x1 += 1\\n        else:\\n            t2 = a2\\n            x2 -= 1\\n    if t1 < t2:\\n        ans = t2 + ((A[x2] - A[x1]) - (x1 + 1) * (t2 - t1)) / (x1 + 1 + N - x2)\\n    else:\\n        ans = t1 + ((A[x2] - A[x1]) - (N - x2) * (t1 - t2)) / (x1 + 1 + N - x2)\\n    print(ans)\\n\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"5\\n2 10\\n1 9\\n1 10\\n1\\n5 7\\n1 2 3 4 6\\n2 1000000000\\n413470354 982876160\\n9 478\\n1 10 25 33 239 445 453 468 477\\n\"\n  ],\n  \"outputs\": [\n    \"3.000000000000000\\n3.666666666666667\\n2.047619047619048\\n329737645.750000000000000\\n53.700000000000000\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1408/C", "starter_code": ""}
{"id": 65, "question": "You and your friend are playing the game Mortal Kombat XI. You are trying to pass a challenge tower. There are $n$ bosses in this tower, numbered from $1$ to $n$. The type of the $i$-th boss is $a_i$. If the $i$-th boss is easy then its type is $a_i = 0$, otherwise this boss is hard and its type is $a_i = 1$.\n\nDuring one session, either you or your friend can kill one or two bosses (neither you nor your friend can skip the session, so the minimum number of bosses killed during one session is at least one). After your friend session, your session begins, then again your friend session begins, your session begins, and so on. The first session is your friend's session.\n\nYour friend needs to get good because he can't actually kill hard bosses. To kill them, he uses skip points. One skip point can be used to kill one hard boss.\n\nYour task is to find the minimum number of skip points your friend needs to use so you and your friend kill all $n$ bosses in the given order.\n\nFor example: suppose $n = 8$, $a = [1, 0, 1, 1, 0, 1, 1, 1]$. Then the best course of action is the following:\n\n  your friend kills two first bosses, using one skip point for the first boss;  you kill the third and the fourth bosses;  your friend kills the fifth boss;  you kill the sixth and the seventh bosses;  your friend kills the last boss, using one skip point, so the tower is completed using two skip points. \n\nYou have to answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 2 \\cdot 10^4$) \u2014 the number of test cases. Then $t$ test cases follow.\n\nThe first line of the test case contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of bosses. The second line of the test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0 \\le a_i \\le 1$), where $a_i$ is the type of the $i$-th boss.\n\nIt is guaranteed that the sum of $n$ does not exceed $2 \\cdot 10^5$ ($\\sum n \\le 2 \\cdot 10^5$).\n\n\n-----Output-----\n\nFor each test case, print the answer: the minimum number of skip points your friend needs to use so you and your friend kill all $n$ bosses in the given order.\n\n\n-----Example-----\nInput\n6\n8\n1 0 1 1 0 1 1 1\n5\n1 1 1 1 0\n7\n1 1 1 1 0 0 1\n6\n1 1 1 1 1 1\n1\n1\n1\n0\n\nOutput\n2\n2\n2\n2\n1\n0", "solutions": "[\"import math\\nfrom collections import deque\\nfrom sys import stdin, stdout\\nfrom string import ascii_letters\\nimport sys\\nletters = ascii_letters\\ninput = stdin.readline\\n#print = stdout.write\\n\\nfor _ in range(int(input())):\\n    n = int(input())\\n    arr = list(map(int, input().split()))\\n    ans = [999999999] * n\\n    ans[0] = 1 if arr[0] == 1 else 0\\n    if n > 1:\\n        ans[1] = ans[0]\\n        if n > 2:\\n            ans[2] = ans[0]\\n    for i in range(n):\\n        if i + 1 >= n:\\n            continue\\n        if arr[i + 1] == 1:\\n            ans[i + 1] = min(ans[i + 1], ans[i] + 1)\\n            if i + 2 < n:\\n                ans[i + 2] = min(ans[i + 2], ans[i] + 1)\\n            if i + 3 < n: \\n                ans[i + 3] = min(ans[i + 3], ans[i] + 1)\\n        else:\\n            ans[i + 1] = min(ans[i + 1], ans[i])\\n            if i + 2 < n:\\n                ans[i + 2] = min(ans[i + 2], ans[i])\\n            if i + 3 < n:\\n                ans[i + 3] = min(ans[i + 3], ans[i])\\n    print(ans[-1])\\n\", \"INF = 10**6\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n\\n    out = [0] * (n + 1)\\n\\n    for i in range(1, n + 1):\\n        best = INF\\n        if i >= 2:\\n            best = min(best, a[i-2] + out[i-2])\\n        if i >= 3:\\n            best = min(best, a[i-3] + out[i-3])\\n        if i >= 4:\\n            best = min(best, a[i-4] + a[i-3] + out[i-4])\\n        out[i] = best\\n\\n    fin = out[n]\\n    for i in range(1,4):\\n        if i <= n:\\n            fin = min(fin, out[n-i] + a[n-i])\\n    print(fin)\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    *difficulty, = list(map(int, input().split()))\\n    groups = [0]\\n    for i, v in enumerate(difficulty):\\n        if v == 0 and (i == 0 or difficulty[i - 1] == 1):\\n            groups.append(0)\\n        if v == 1:\\n            groups[-1] += 1\\n    ans = (groups[0] + 2) // 3 + sum(v // 3 for v in groups[1:])\\n    print(ans)\\n\\n\\n\\n\", \"def solve():\\n    n = int(input())\\n    lst = list(map(int,input().split()))\\n    if n == 1:\\n        print(lst[0])\\n        return 0\\n    dpi = [-1 for i in range(n)]\\n    dpdrug = [-1 for i in range(n)]\\n    dpi[n-1] = 0\\n    dpdrug[n-1] = lst[n-1]\\n    dpi[n-2] = 0\\n    dpdrug[n-2] = lst[n-2]\\n    for i in range(n-3,-1,-1):\\n        dpi[i] = min(dpdrug[i + 2], dpdrug[i + 1])\\n        dpdrug[i] = min(dpi[i + 1] + lst[i], dpi[i + 2] + lst[i] + lst[i + 1])\\n    print(dpdrug[0])\\nfor i in range(int(input())):\\n    solve()\", \"for haaghfj in range(int(input())):\\n    n = int(input())\\n    a = list(map(int,input().split()))\\n    dp = [[100000000000000] * 2 for i in range(n + 2)]\\n    dp[0][0] = 0\\n    for i in range(1, n + 1):\\n        dp[i][0] = min(dp[i -1][1], dp[i - 2][1])\\n        dp[i][1] = min(dp[i -1][0]  + a[i - 1], dp[i - 2][0]  + a[i - 1] + a[i - 2])\\n    print(min(dp[n]))\\n\", \"import sys\\ninput = lambda: sys.stdin.readline().rstrip()\\n\\nT = int(input())\\nfor _ in range(T):\\n    N = int(input())\\n    A = [int(a) for a in input().split()] + [0] * 5\\n    X = [0] + [1 << 30] * (N + 5)\\n    for i in range(2, N + 5):\\n        X[i] = min(X[i], X[i-2] + A[i-2])\\n        if i >= 3:\\n            X[i] = min(X[i], X[i-3] + A[i-3])\\n        if i >= 4:\\n            X[i] = min(X[i], X[i-4] + A[i-4] + A[i-3])\\n    print(min(X[-5:]))\\n\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\nfor tests in range(t):\\n    n=int(input())\\n    A=list(map(int,input().split()))\\n    A.append(0)\\n    A.append(0)\\n\\n    DP0=[1<<30]*(n+3)\\n    DP1=[1<<30]*(n+3)\\n\\n    DP0[0]=0\\n\\n    for i in range(n):\\n        if A[i]==0 and A[i+1]==0:\\n            DP1[i+1]=min(DP1[i+1],DP0[i])\\n            DP1[i+2]=min(DP1[i+2],DP0[i])\\n\\n        elif A[i]==0 and A[i+1]==1:\\n            DP1[i+1]=min(DP1[i+1],DP0[i])\\n            DP1[i+2]=min(DP1[i+2],DP0[i]+1)\\n\\n        elif A[i]==1 and A[i+1]==0:\\n            DP1[i+1]=min(DP1[i+1],DP0[i]+1)\\n            DP1[i+2]=min(DP1[i+2],DP0[i]+1)\\n\\n        elif A[i]==1 and A[i+1]==1:\\n            DP1[i+1]=min(DP1[i+1],DP0[i]+1)\\n            DP1[i+2]=min(DP1[i+2],DP0[i]+2)\\n\\n        DP0[i+1]=min(DP0[i+1],DP1[i])\\n        DP0[i+2]=min(DP0[i+2],DP1[i])\\n\\n    print(min(DP0[n],DP1[n]))\\n\\n    \\n\\n    \\n\\n    \\n    \\n    \\n\", \"from math import ceil\\n\\ndef main():\\n    t = int(input())\\n    for i in range(t):\\n        n = int(input())\\n        enemies = list(map(int, input().split()))\\n        j = 0\\n        c = 1\\n        ans = 0\\n        while j < n:\\n            if c:\\n                c = 0\\n                if enemies[j] == 1:\\n                    ans += 1\\n                    j += 1\\n                if j < n and enemies[j] == 0:\\n                    j += 1\\n            else:\\n                c = 1\\n                if enemies[j] == 1:\\n                    j += 1\\n                if j < n and enemies[j] == 1:\\n                    j += 1\\n        print(ans)\\n\\n\\nmain()\", \"from sys import stdin\\nt = int(stdin.readline())\\n\\nfor loop in range(t):\\n\\n    n = int(stdin.readline())\\n    a = list(map(int,stdin.readline().split()))\\n\\n    dp = [[float(\\\"inf\\\"),float(\\\"inf\\\")] for i in range(n)]\\n\\n    for i in range(n):\\n\\n        if i == 0:\\n            dp[i][0] = a[0]\\n            continue\\n        elif i == 1:\\n            dp[i][0] = a[0] + a[1]\\n            dp[i][1] = dp[i-1][0]\\n            continue\\n\\n        dp[i][0] = min(dp[i-2][1] + a[i-1] + a[i] , dp[i-1][1] + a[i])\\n        dp[i][1] = min(dp[i-2][0] , dp[i-1][0])\\n\\n    print (min(dp[-1]))\"]", "input_output": "{\n  \"inputs\": [\n    \"6\\n8\\n1 0 1 1 0 1 1 1\\n5\\n1 1 1 1 0\\n7\\n1 1 1 1 0 0 1\\n6\\n1 1 1 1 1 1\\n1\\n1\\n1\\n0\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n2\\n2\\n2\\n1\\n0\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1418/C", "starter_code": ""}
{"id": 66, "question": "Kuroni has $n$ daughters. As gifts for them, he bought $n$ necklaces and $n$ bracelets:  the $i$-th necklace has a brightness $a_i$, where all the $a_i$ are pairwise distinct (i.e. all $a_i$ are different),  the $i$-th bracelet has a brightness $b_i$, where all the $b_i$ are pairwise distinct (i.e. all $b_i$ are different). \n\nKuroni wants to give exactly one necklace and exactly one bracelet to each of his daughters. To make sure that all of them look unique, the total brightnesses of the gifts given to each daughter should be pairwise distinct. Formally, if the $i$-th daughter receives a necklace with brightness $x_i$ and a bracelet with brightness $y_i$, then the sums $x_i + y_i$ should be pairwise distinct. Help Kuroni to distribute the gifts.\n\nFor example, if the brightnesses are $a = [1, 7, 5]$ and $b = [6, 1, 2]$, then we may distribute the gifts as follows:  Give the third necklace and the first bracelet to the first daughter, for a total brightness of $a_3 + b_1 = 11$. Give the first necklace and the third bracelet to the second daughter, for a total brightness of $a_1 + b_3 = 3$. Give the second necklace and the second bracelet to the third daughter, for a total brightness of $a_2 + b_2 = 8$. \n\nHere is an example of an invalid distribution:   Give the first necklace and the first bracelet to the first daughter, for a total brightness of $a_1 + b_1 = 7$. Give the second necklace and the second bracelet to the second daughter, for a total brightness of $a_2 + b_2 = 8$. Give the third necklace and the third bracelet to the third daughter, for a total brightness of $a_3 + b_3 = 7$. \n\nThis distribution is invalid, as the total brightnesses of the gifts received by the first and the third daughter are the same. Don't make them this upset!\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 100$) \u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 100$) \u00a0\u2014 the number of daughters, necklaces and bracelets.\n\nThe second line of each test case contains $n$ distinct integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 1000$) \u00a0\u2014 the brightnesses of the necklaces.\n\nThe third line of each test case contains $n$ distinct integers $b_1, b_2, \\dots, b_n$ ($1 \\le b_i \\le 1000$) \u00a0\u2014 the brightnesses of the bracelets.\n\n\n-----Output-----\n\nFor each test case, print a line containing $n$ integers $x_1, x_2, \\dots, x_n$, representing that the $i$-th daughter receives a necklace with brightness $x_i$. In the next line print $n$ integers $y_1, y_2, \\dots, y_n$, representing that the $i$-th daughter receives a bracelet with brightness $y_i$.\n\nThe sums $x_1 + y_1, x_2 + y_2, \\dots, x_n + y_n$ should all be distinct. The numbers $x_1, \\dots, x_n$ should be equal to the numbers $a_1, \\dots, a_n$ in some order, and the numbers $y_1, \\dots, y_n$ should be equal to the numbers $b_1, \\dots, b_n$ in some order. \n\nIt can be shown that an answer always exists. If there are multiple possible answers, you may print any of them.\n\n\n-----Example-----\nInput\n2\n3\n1 8 5\n8 4 5\n3\n1 7 5\n6 1 2\n\nOutput\n1 8 5\n8 4 5\n5 1 7\n6 2 1\n\n\n\n-----Note-----\n\nIn the first test case, it is enough to give the $i$-th necklace and the $i$-th bracelet to the $i$-th daughter. The corresponding sums are $1 + 8 = 9$, $8 + 4 = 12$, and $5 + 5 = 10$.\n\nThe second test case is described in the statement.", "solutions": "[\"#list(map(int,input().split()))\\nt=int(input())\\nfor _ in range(t):\\n    n=int(input())\\n    aa=list(map(int,input().split()))\\n    bb=list(map(int,input().split()))\\n    aa.sort()\\n    bb.sort()\\n    print(*aa)\\n    print(*bb)\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    a = sorted(list(map(int, input().split())))\\n    s = sorted(list(map(int, input().split())))\\n    print(*a)\\n    print(*s)\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    ar1 = list(map(int, input().split()))\\n    ar2 = list(map(int, input().split()))\\n    ar1.sort()\\n    ar2.sort()\\n    print(*ar1)\\n    print(*ar2)\", \"import math, collections, sys\\ninput = sys.stdin.readline\\ndef solve():\\n    n=int(input())\\n    a = list(map(int, input().split()))\\n    b= list(map(int, input().split()))\\n    a.sort()\\n    b.sort()\\n    print(*a)\\n    print(*b)\\nfor _ in range(int(input())):\\n    solve()\", \"import math,sys\\nfrom collections import Counter, defaultdict, deque\\nfrom sys import stdin, stdout\\ninput = stdin.readline\\nli = lambda:list(map(int,input().split()))\\n\\ndef solve():\\n    n=int(input())\\n    a=li()\\n    b=li()\\n    a.sort()\\n    b.sort()\\n    print(*a)\\n    print(*b)\\n\\nfor _ in range(int(input())):\\n    solve()\", \"import sys\\nreader = (s.rstrip() for s in sys.stdin)\\ninput = reader.__next__\\n\\ndef solve():\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    b = list(map(int, input().split()))\\n    a.sort()\\n    b.sort()\\n    print(*a)\\n    print(*b)\\n\\nt = int(input())\\nfor i in range(t):\\n    solve()\\n\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    l1 = list(map(int,input().split()))\\n    l2 = list(map(int,input().split()))\\n    l1.sort()\\n    l2.sort()\\n    print(*l1, sep= \\\" \\\")\\n    print(*l2, sep= \\\" \\\")\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    a = map(int, input().split())\\n    b = map(int, input().split())\\n    print(*sorted(a))\\n    print(*sorted(b))\"]", "input_output": "{\n  \"inputs\": [\n    \"2\\n3\\n1 8 5\\n8 4 5\\n3\\n1 7 5\\n6 1 2\\n\"\n  ],\n  \"outputs\": [\n    \"1 8 5\\n8 4 5\\n5 1 7\\n6 2 1\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1305/A", "starter_code": ""}
{"id": 67, "question": "This problem is different from the easy version. In this version Ujan makes at most $2n$ swaps. In addition, $k \\le 1000, n \\le 50$ and it is necessary to print swaps themselves. You can hack this problem if you solve it. But you can hack the previous problem only if you solve both problems.\n\nAfter struggling and failing many times, Ujan decided to try to clean up his house again. He decided to get his strings in order first.\n\nUjan has two distinct strings $s$ and $t$ of length $n$ consisting of only of lowercase English characters. He wants to make them equal. Since Ujan is lazy, he will perform the following operation at most $2n$ times: he takes two positions $i$ and $j$ ($1 \\le i,j \\le n$, the values $i$ and $j$ can be equal or different), and swaps the characters $s_i$ and $t_j$.\n\nUjan's goal is to make the strings $s$ and $t$ equal. He does not need to minimize the number of performed operations: any sequence of operations of length $2n$ or shorter is suitable.\n\n\n-----Input-----\n\nThe first line contains a single integer $k$ ($1 \\leq k \\leq 1000$), the number of test cases.\n\nFor each of the test cases, the first line contains a single integer $n$ ($2 \\leq n \\leq 50$), the length of the strings $s$ and $t$. \n\nEach of the next two lines contains the strings $s$ and $t$, each having length exactly $n$. The strings consist only of lowercase English letters. It is guaranteed that strings are different.\n\n\n-----Output-----\n\nFor each test case, output \"Yes\" if Ujan can make the two strings equal with at most $2n$ operations and \"No\" otherwise. You can print each letter in any case (upper or lower).\n\nIn the case of \"Yes\" print $m$ ($1 \\le m \\le 2n$) on the next line, where $m$ is the number of swap operations to make the strings equal. Then print $m$ lines, each line should contain two integers $i, j$ ($1 \\le i, j \\le n$) meaning that Ujan swaps $s_i$ and $t_j$ during the corresponding operation. You do not need to minimize the number of operations. Any sequence of length not more than $2n$ is suitable.\n\n\n-----Example-----\nInput\n4\n5\nsouse\nhouhe\n3\ncat\ndog\n2\naa\naz\n3\nabc\nbca\n\nOutput\nYes\n1\n1 4\nNo\nNo\nYes\n3\n1 2\n3 1\n2 3", "solutions": "[\"for _ in range(int(input())):\\n    n = int(input())\\n    s = input()\\n    t = input()\\n\\n    d = {}\\n    for i in range(ord('a'), ord('z') + 1):\\n        d[chr(i)] = 0\\n\\n    for cs in s:\\n        d[cs] += 1\\n    for ct in t:\\n        d[ct] += 1\\n\\n    ok = True\\n    for e in d:\\n        if d[e] % 2 == 1:\\n            ok = False\\n\\n    if not ok:\\n        print(\\\"No\\\")\\n    else:\\n        print(\\\"Yes\\\")\\n\\n        changes = []\\n\\n        s, t = list(s), list(t)\\n        for i in range(n-1):\\n            if s[i] != t[i]:\\n                r = (0, -1)\\n                for j in range(i+1, n):\\n                    if s[j] == t[i]:\\n                        r = (j, 0)\\n\\n                for j in range(i+1, n):\\n                    if t[j] == t[i]:\\n                        r = (j, 1)\\n\\n                if r[1] == 0:\\n                    changes += [(r[0], i+1), (i, i+1)]\\n                    s[r[0]], t[i+1] = t[i+1], s[r[0]]\\n                    s[i], t[i+1] = t[i+1], s[i]\\n                elif r[1] == 1:\\n                    changes += [(i, r[0])]\\n                    s[i], t[r[0]] = t[r[0]], s[i]\\n\\n        print(len(changes))\\n        for change in changes:\\n            x, y = change\\n            print(x+1, y+1)\", \"from bisect import *\\nfrom collections import *\\nfrom itertools import *\\nimport functools\\nimport sys\\nimport math\\nfrom decimal import *\\nfrom copy import *\\nfrom heapq import *\\nfrom fractions import *\\ngetcontext().prec = 30\\nMAX = sys.maxsize\\nMAXN = 1000010\\nMOD = 10**9+7\\nspf = [i for i in range(MAXN)]\\ndef sieve():\\n    for i in range(2,MAXN,2):\\n        spf[i] = 2\\n    for i in range(3,int(MAXN**0.5)+1):\\n        if spf[i]==i:\\n            for j in range(i*i,MAXN,i):\\n                if spf[j]==j:\\n                    spf[j]=i\\ndef fib(n,m):\\n    if n == 0:\\n        return [0, 1]\\n    else:\\n        a, b = fib(n // 2)\\n        c = ((a%m) * ((b%m) * 2 - (a%m)))%m\\n        d = ((a%m) * (a%m))%m + ((b)%m * (b)%m)%m\\n        if n % 2 == 0:\\n            return [c, d]\\n        else:\\n            return [d, c + d]\\n\\ndef charIN(x= ' '):\\n    return(sys.stdin.readline().strip().split(x))\\n\\ndef arrIN(x = ' '):\\n    return list(map(int,sys.stdin.readline().strip().split(x)))\\n\\ndef ncr(n,r):\\n    num=den=1\\n    for i in range(r):\\n        num = (num*(n-i))%MOD\\n        den = (den*(i+1))%MOD\\n\\n    return (num*(pow(den,MOD-2,MOD)))%MOD\\n\\ndef flush():\\n    return sys.stdout.flush()\\n\\n'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''\\nfor _ in range(int(input())):\\n    n = int(input())\\n    s = [i for i in input()]\\n    t = [i for i in input()]\\n    d = defaultdict(int)\\n    for i in range(n):\\n        d[s[i]]+=1\\n        d[t[i]]+=1\\n    if len(list(d.keys()))>n or sum(i%2 for i in list(d.values())):\\n        print('No')\\n    else:\\n        ans = []\\n        for i in range(n):\\n            if s[i]!=t[i]:\\n                for j in range(i+1,n):\\n                    if s[j]!=t[j]:\\n                        if s[i]==s[j]:\\n                            ans.append([j,i])\\n                            s[j],t[i] = t[i],s[j]\\n                            break\\n                        elif s[i]==t[j]:\\n                            ans.append([j,j])\\n                            s[j],t[j] = t[j],s[j]\\n                            ans.append([j,i])\\n                            s[j],t[i] = t[i],s[j]\\n                            break\\n                        elif t[i]==t[j]:\\n                            ans.append([i,j])\\n                            s[i],t[j] = t[j],s[i]\\n                            break\\n                        elif t[i]==s[j]:\\n                            ans.append([j,j])\\n                            s[j],t[j] = t[j],s[j]\\n                            ans.append([i,j])\\n                            s[i],t[j] = t[j],s[i]\\n                            break\\n            #assert(s[i]==t[i])\\n        #assert(len(ans)<=2*n)\\n        print('Yes')\\n        print(len(ans))\\n        for i in ans:\\n            print(i[0]+1,i[1]+1)\\n\\n\\n\\n\\n        \\n\\n\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n5\\nsouse\\nhouhe\\n3\\ncat\\ndog\\n2\\naa\\naz\\n3\\nabc\\nbca\\n\"\n  ],\n  \"outputs\": [\n    \"Yes\\n1\\n1 4\\nNo\\nNo\\nYes\\n3\\n2 2\\n1 2\\n2 3\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1243/B2", "starter_code": ""}
{"id": 68, "question": "You have a string $s$ consisting of $n$ characters. Each character is either 0 or 1.\n\nYou can perform operations on the string. Each operation consists of two steps:  select an integer $i$ from $1$ to the length of the string $s$, then delete the character $s_i$ (the string length gets reduced by $1$, the indices of characters to the right of the deleted one also get reduced by $1$);  if the string $s$ is not empty, delete the maximum length prefix consisting of the same characters (the indices of the remaining characters and the string length get reduced by the length of the deleted prefix). \n\nNote that both steps are mandatory in each operation, and their order cannot be changed.\n\nFor example, if you have a string $s =$ 111010, the first operation can be one of the following:  select $i = 1$: we'll get 111010 $\\rightarrow$ 11010 $\\rightarrow$ 010;  select $i = 2$: we'll get 111010 $\\rightarrow$ 11010 $\\rightarrow$ 010;  select $i = 3$: we'll get 111010 $\\rightarrow$ 11010 $\\rightarrow$ 010;  select $i = 4$: we'll get 111010 $\\rightarrow$ 11110 $\\rightarrow$ 0;  select $i = 5$: we'll get 111010 $\\rightarrow$ 11100 $\\rightarrow$ 00;  select $i = 6$: we'll get 111010 $\\rightarrow$ 11101 $\\rightarrow$ 01. \n\nYou finish performing operations when the string $s$ becomes empty. What is the maximum number of operations you can perform?\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the length of the string $s$.\n\nThe second line contains string $s$ of $n$ characters. Each character is either 0 or 1.\n\nIt's guaranteed that the total sum of $n$ over test cases doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, print a single integer\u00a0\u2014 the maximum number of operations you can perform.\n\n\n-----Example-----\nInput\n5\n6\n111010\n1\n0\n1\n1\n2\n11\n6\n101010\n\nOutput\n3\n1\n1\n1\n3\n\n\n\n-----Note-----\n\nIn the first test case, you can, for example, select $i = 2$ and get string 010 after the first operation. After that, you can select $i = 3$ and get string 1. Finally, you can only select $i = 1$ and get empty string.", "solutions": "[\"from itertools import groupby\\ndef main():\\n    N = int(input())\\n    S = input()\\n    \\n    C = [len(list(x[1])) for x in groupby(S)]\\n    M = len(C)\\n    dup_idx = []\\n    for i, c in enumerate(C):\\n        if c > 1:\\n            dup_idx.append(i)\\n    \\n    dup_idx.reverse()\\n\\n    curr = 0\\n    while dup_idx:\\n        i = dup_idx[-1]\\n\\n        if i < curr:\\n            dup_idx.pop()\\n            continue\\n\\n        C[i] -= 1\\n        if C[i] == 1:\\n            dup_idx.pop()\\n\\n        curr += 1\\n\\n    ans = curr + (M-curr+1)//2\\n    \\n    print(ans)\\n\\ndef __starting_point():\\n    for __ in [0]*int(input()):\\n        main()\\n\\n__starting_point()\", \"import sys\\n\\nT = int(sys.stdin.readline().strip())\\nfor t in range (0, T):\\n    n = int(sys.stdin.readline().strip())\\n    s = sys.stdin.readline().strip()\\n    L = [1]\\n    for i in range (1, n):\\n        if s[i] == s[i-1]:\\n            L[-1] = L[-1] + 1\\n        else:\\n            L.append(1)\\n    L.reverse()\\n    i = n - 1\\n    ans = 0\\n    while len(L) > 0:\\n        ans = ans + 1\\n        v = True\\n        i = min(i, len(L) - 1)\\n        while i >= 0 and v == True:\\n            if L[i] == 1:\\n                i = i - 1\\n                if i == -1:\\n                    v = False\\n            else:\\n                v = False\\n        if i == -1:\\n            L.pop()\\n        else:\\n            L[i] = L[i] - 1\\n        if len(L) > 0:\\n            L.pop()\\n    print(ans)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nt = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    s = input().rstrip()\\n    changes = 1\\n    spare = 0\\n    before = s[0]\\n    spare_can = 1\\n    for j in range(n-1):\\n        if s[j+1] == before:\\n            if spare_can > 0:\\n                spare_can -= 1\\n                spare += 1\\n        else:\\n            before = s[j+1]\\n            changes +=1\\n            spare_can +=1\\n    ans = 0\\n    ans += spare\\n    changes-=spare\\n    ans += (changes+1)//2\\n    print(ans)   \", \"n = int(input())\\n\\nfor _ in range(n):\\n    k = int(input())\\n    s = input()\\n    s = s[0] + s + str(int(s[-1])^1)\\n    \\n    m = []\\n\\n    prev = 1\\n    \\n    for i in range(1, k+2):\\n        if s[i] != s[i-1]:\\n            m.append(i-prev)\\n            prev = i\\n\\n    ans = 0\\n    start = 0\\n    end = len(m)\\n    first = 0\\n\\n    while (start < end):\\n        if m[start] > 1:\\n            start += 1\\n            first = max(first, start)\\n            \\n        else:\\n            while (first < end) and (m[first] == 1):\\n                first += 1\\n            \\n            if (first >= end):\\n                end -= 1\\n            else:\\n                m[first] -= 1\\n\\n            start += 1\\n\\n        ans += 1\\n\\n    print(ans)\\n\", \"for _ in range(int(input())):\\n\\tn = int(input())\\n\\n\\ts = list(input())\\n\\n\\tgroups = []\\n\\tlast = ''\\n\\tcnt = 0\\n\\tfor c in s:\\n\\t\\tif c != last:\\n\\t\\t\\tif cnt: groups.append(cnt)\\n\\t\\t\\tcnt = 1\\n\\t\\telse:\\n\\t\\t\\tcnt += 1\\n\\t\\tlast = c\\n\\n\\tif cnt: groups.append(cnt)\\n\\n\\tm = len(groups)\\n\\ti = 0\\n\\tj = 0\\n\\n\\tops = 0\\n\\twhile i < m:\\n\\t\\tops += 1\\n\\n\\t\\twhile j < i or (j < m and groups[j] == 1): j += 1\\n\\n\\t\\tif j < m: groups[j] -= 1\\n\\t\\telse: i += 1\\n\\t\\ti += 1\\n\\n\\tprint(ops)\\n\\n\\n\", \"T = int(input())\\nfor _ in range(T):\\n    N = int(input())\\n    S = input()\\n    arr = []\\n    seq = 1\\n    for a,b in zip(S,S[1:]):\\n        if a==b:\\n            seq += 1\\n        else:\\n            arr.append(seq)\\n            seq = 1\\n    arr.append(seq)\\n    hist = []\\n    arr.reverse()\\n    for i,a in enumerate(arr):\\n        if a==1: continue\\n        hist.append([i,a])\\n    ans = 0\\n    while len(arr):\\n        if len(hist):\\n            hist[-1][1] -= 1\\n            if hist[-1][1] == 1:\\n                hist.pop()\\n        elif len(arr):\\n            arr.pop()\\n        else:\\n            break\\n        ans += 1\\n        if len(arr):\\n            arr.pop()\\n        if len(hist) and hist[-1][0] == len(arr):\\n            hist.pop()\\n    print(ans)\\n\", \"gans = []\\nfor _ in range(int(input())):\\n    n = int(input())\\n    a = list(map(int, list(input())))\\n    u = []\\n    k = 1\\n    for i in range(1, n):\\n        if a[i] == a[i - 1]:\\n            k += 1\\n        else:\\n            u.append(k)\\n            k = 1\\n    u.append(k)\\n    dop = 0\\n    ln = len(u)\\n    for i in range(ln):\\n        dop += u[i] - 1\\n    cur = 0\\n    ind = 0\\n    while ind < ln:\\n        if dop == 0:\\n            ln -= 1\\n        else:\\n            cur += 1\\n            dop -= 1\\n        cnt = u[ind] - 1\\n        if cur < cnt:\\n            dop -= cnt - cur\\n            cur = 0\\n        else:\\n            cur -= cnt\\n        ind += 1\\n    gans.append(ind)\\nprint('\\\\n'.join(map(str, gans)))\\n    \\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\n\\nfor tests in range(t):\\n    n=int(input())\\n    S=input().strip()\\n\\n    L=[1]\\n\\n    for i in range(1,n):\\n        if S[i]==S[i-1]:\\n            L[-1]+=1\\n        else:\\n            L.append(1)\\n        \\n    de=0\\n    i=0\\n    ANS=0\\n    LEN=len(L)\\n    flag=0\\n    \\n    while de<LEN:\\n\\n        if flag==0:            \\n            i=max(i,de)\\n            while i<LEN:\\n                if L[i]>1:\\n                    break\\n                else:\\n                    i+=1\\n\\n            if i==LEN:\\n                flag=1\\n            else:\\n                L[i]-=1\\n\\n        if flag==0:\\n            de+=1\\n            ANS+=1\\n        else:\\n            de+=2\\n            ANS+=1\\n    print(ANS)\\n\\n        \\n        \\n        \\n\", \"import sys, math\\nimport io, os\\n#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\\nfrom bisect import bisect_left as bl, bisect_right as br, insort\\nfrom heapq import heapify, heappush, heappop\\nfrom collections import defaultdict as dd, deque, Counter\\n#from itertools import permutations,combinations\\ndef data(): return sys.stdin.readline().strip()\\ndef mdata(): return list(map(int, data().split()))\\ndef outl(var) : sys.stdout.write('\\\\n'.join(map(str, var))+'\\\\n')\\ndef out(var) : sys.stdout.write(str(var)+'\\\\n')\\n#from decimal import Decimal\\n#from fractions import Fraction\\n#sys.setrecursionlimit(100000)\\nINF = float('inf')\\nmod=10**9+7\\n\\n\\nfor t in range(int(data())):\\n    n=int(data())\\n    s=data()\\n    ind=0\\n    l=[]\\n    for i in range(1,n):\\n        if s[i]!=s[i-1]:\\n            l.append(i-ind)\\n            ind=i\\n    l.append(n-ind)\\n    l=l[::-1]\\n    i=0\\n    ans=0\\n    j=len(l)-1\\n    while l:\\n        if l[-1]>1:\\n            ans+=1\\n            l.pop()\\n            j-=1\\n        else:\\n            j=min(j,len(l)-1)\\n            while j>=0 and l[j]==1:\\n                j-=1\\n            if j==-1:\\n                l.pop()\\n                if l:\\n                    l.pop()\\n            else:\\n                l.pop()\\n                l[j]-=1\\n            ans+=1\\n    out(ans)\", \"for _ in range (int(input())):\\n    n=int(input())\\n    s=input()\\n    a=[]\\n    curr=1\\n    g=0\\n    for i in range (1,n):\\n        if s[i]==s[i-1]:\\n            curr+=1\\n        else:\\n            a.append(curr)\\n            if curr>1:\\n                g+=1\\n            curr=1\\n    if curr>0:\\n        if curr>1:\\n            g+=1\\n        a.append(curr)\\n    #print(a)\\n    j=0\\n    i=0\\n    res=0\\n    while i<len(a):\\n        if a[i]>1:\\n            res+=1\\n            i+=1\\n        else:\\n            j=max(i+1,j)\\n            ch=0\\n            while j<len(a):\\n                if a[j]>1:\\n                    a[j]-=1\\n                    ch=1\\n                    break\\n                j+=1\\n            if ch==1:\\n                i+=1\\n                res+=1\\n            else:\\n                i+=2\\n                res+=1\\n    print(res)\", \"def main():\\n    n = int(input())\\n    line = input()\\n    turn_take = []\\n    prev = line[-1]\\n    can_be = 0\\n    for i in range(n - 2, -1, -1):\\n        if line[i] == prev:\\n            can_be += 1\\n        else:\\n            prev = line[i]\\n            turn_take.append(can_be)\\n    turn_take.append(can_be)\\n    turns = len(turn_take)\\n    taken = 0\\n    res = 0\\n    for i in range(1, turns + 1):\\n        if i > 1 and turn_take[-i] < turn_take[-i + 1]:\\n            taken = min(0, taken + turn_take[-i + 1] - turn_take[-i])\\n        if turn_take[-i] > -taken:\\n            taken -= 1\\n            res += 1\\n        else:\\n            res += (turns - i + 1)//2\\n            if (turns - i + 1)%2 != 0:\\n                res += 1\\n            break\\n    print(res)\\n\\n\\ndef __starting_point():\\n    t = int(input())\\n    for i in range(t):\\n        main()\\n\\\"\\\"\\\"\\n1 2 3 4 5\\n1 2 4 4\\n1 2 4\\n1 3\\n2\\n1 2 3 4 5 6\\n1 2 3 5 5\\n1 2 3 5\\n1 2 4\\n1 3\\n2\\n1 2 3 4 5 6 7 ( max, max - 2)\\n1 2 3 4 6 6 (max - 1, max - 1)\\n1 2 3 4 6 (max - 1, max - 3)\\n1 2 3 5 (max - 2 max - 4)\\n1 2 4\\n1 3\\n2\\n1 2 3 4 5 6 7 8 (6, 8)\\n1 2 3 4 5 7 7 (7, 7)\\n1 2 3 4 5 7 (5, 7)\\n1 2 3 4 6 (4, 6)\\n1 2 3 5 (3, 5)\\n1 2 4 (2, 4)\\n1 3 (1, 3)\\n2\\n\\\"\\\"\\\"\\n__starting_point()\", \"t = int(input())\\n\\nfor case in range(t):\\n    n = int(input())\\n    s = input()\\n    #print(\\\"Input read in OK\\\", n, s)\\n\\n    groups = [s[0]]\\n    for x in s[1:]:\\n        if x == groups[-1][-1]:\\n            groups[-1] += x\\n        else:\\n            groups.append(x)\\n\\n    groups = [len(x) for x in groups]\\n    to_use = 0\\n    #print(\\\"groups are\\\", groups)\\n\\n    ops = 0\\n    for i, x in enumerate(groups):\\n        while to_use < len(groups):\\n            if to_use < i:\\n                to_use += 1\\n                continue\\n            if groups[to_use] <= 1:\\n                to_use += 1\\n                continue\\n            break\\n        else:\\n            break\\n\\n        #print(\\\"using\\\", to_use)\\n        groups[to_use] -= 1\\n        groups[i] = 0\\n        ops += 1\\n    else:\\n        print(ops)\\n        continue\\n\\n    # We now have a situation where the grid is of the form 10101010.\\n    # What do we do? Well,\\n    # 1010 (even length = n/2)\\n    # 10101 (odd length = (n + 1)/2)\\n    # so (n+1)/2 it is\\n    #print(\\\"ops before was\\\", ops)\\n    size = len(groups) - i\\n    #print(\\\"size is\\\", size)\\n    ops += (size + 1) // 2\\n    print(ops)\\n        \\n        \\n\", \"import io\\nimport os\\nimport sys\\nimport math\\nimport heapq\\n\\ninput = sys.stdin.readline\\nmod = 10**9 + 7\\n \\nt = int(input())\\n\\nfor i in range(t):\\n    #n,k = list(map(int, input().split()))\\n    n = int(input())\\n    s = list(input().rstrip())\\n    \\n    arr = []\\n    \\n    st = s[0]\\n    c = 0\\n    for i in range(len(s)):\\n        if s[i]!=st:\\n            arr.append(c)\\n            st = s[i]\\n            c = 0\\n            \\n        c+=1\\n            \\n    if c>0:\\n        arr.append(c)\\n        \\n    limit = 0\\n    steps = 0\\n    \\n    #print(arr)\\n    \\n    for i in range(len(arr)):\\n        limit += 1\\n        if arr[i] > 1:\\n            red = arr[i] - 1\\n            #print(limit)\\n            gh = min(red, limit)\\n            arr[i] -= gh\\n            limit -=gh\\n            steps += gh\\n          \\n    #print(arr, len(arr), steps)\\n    ans = math.ceil((len(arr) + steps) / 2)\\n    #\\n    print(ans)\\n    \\n\"]", "input_output": "{\n  \"inputs\": [\n    \"5\\n6\\n111010\\n1\\n0\\n1\\n1\\n2\\n11\\n6\\n101010\\n\"\n  ],\n  \"outputs\": [\n    \"3\\n1\\n1\\n1\\n3\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1430/D", "starter_code": ""}
{"id": 69, "question": "Bertown is a city with $n$ buildings in a straight line.\n\nThe city's security service discovered that some buildings were mined. A map was compiled, which is a string of length $n$, where the $i$-th character is \"1\" if there is a mine under the building number $i$ and \"0\" otherwise.\n\nBertown's best sapper knows how to activate mines so that the buildings above them are not damaged. When a mine under the building numbered $x$ is activated, it explodes and activates two adjacent mines under the buildings numbered $x-1$ and $x+1$ (if there were no mines under the building, then nothing happens). Thus, it is enough to activate any one mine on a continuous segment of mines to activate all the mines of this segment. For manual activation of one mine, the sapper takes $a$ coins. He can repeat this operation as many times as you want.\n\nAlso, a sapper can place a mine under a building if it wasn't there. For such an operation, he takes $b$ coins. He can also repeat this operation as many times as you want.\n\nThe sapper can carry out operations in any order.\n\nYou want to blow up all the mines in the city to make it safe. Find the minimum number of coins that the sapper will have to pay so that after his actions there are no mines left in the city.\n\n\n-----Input-----\n\nThe first line contains one positive integer $t$ ($1 \\le t \\le 10^5$)\u00a0\u2014 the number of test cases. Then $t$ test cases follow.\n\nEach test case begins with a line containing two integers $a$ and $b$ ($1 \\le a, b \\le 1000$)\u00a0\u2014 the cost of activating and placing one mine, respectively.\n\nThe next line contains a map of mines in the city\u00a0\u2014 a string consisting of zeros and ones.\n\nThe sum of the string lengths for all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, output one integer\u00a0\u2014 the minimum number of coins that the sapper will have to pay.\n\n\n-----Example-----\nInput\n2\n1 1\n01000010\n5 1\n01101110\n\nOutput\n2\n6\n\n\n\n-----Note-----\n\nIn the second test case, if we place a mine under the fourth building and then activate it, then all mines on the field are activated. The cost of such operations is six, $b=1$ coin for placing a mine and $a=5$ coins for activating.", "solutions": "[\"t = int(input())\\n\\nfor case in range(t):\\n    a, b = list(map(int, input().split()))\\n    s = input()\\n\\n    z = 10000\\n    total = 0\\n    act = False\\n\\n    for i in range(len(s)):\\n        cur = s[i]\\n        if cur == '0':\\n            z += 1\\n            act = False\\n        else:\\n            if not act:\\n                act = True\\n                total += min(a, b * z)\\n                z = 0\\n\\n    print(total)\\n\", \"t=int(input())\\nfor you in range(t):\\n    l=input().split()\\n    a=int(l[0])\\n    b=int(l[1])\\n    s=input()\\n    n=len(s)\\n    l=[]\\n    start=0\\n    end=0\\n    done=0\\n    for i in range(n):\\n        if(done):\\n            if(s[i]=='1'):\\n                end+=1\\n            else:\\n                l.append((start,end))\\n                done=0\\n        else:\\n            if(s[i]=='1'):\\n                done=1\\n                start=i\\n                end=i\\n    if(done):\\n        l.append((start,end))\\n    z=a*len(l)\\n    lo=[]\\n    for i in range(len(l)-1):\\n        lo.append(l[i+1][0]-l[i][1]-1)\\n    for i in lo:\\n        if(i*b<a):\\n            z-=a\\n            z+=(i*b)\\n    print(z)\\n\", \"for i in range(int(input())):\\n    a,b=list(map(int,input().split()))\\n    s=input()\\n    j=0\\n    n=len(s)\\n    l=[]\\n    while j<n:\\n        if s[j]=='1':\\n            x=j\\n            while s[j]=='1':\\n                j+=1\\n                if j==n:\\n                    break\\n            y=j-1\\n            l.append([x,y])\\n        else:\\n            j+=1\\n    ans=0\\n    j=0\\n    while j<len(l):\\n        if j==0:\\n            ans+=a\\n        else:\\n            ans+=min(a,b*(l[j][0]-l[j-1][1]-1))\\n        j+=1\\n    print(ans)\\n                \\n    \\n                \\n            \\n    \\n\", \"for _ in range(int(input())):\\n\\ta,b = list(map(int, input().split()))\\n\\ts = input()\\n\\tcost = 0\\n\\trowcost = a\\n\\tamchain = False\\n\\tfor c in s:\\n\\t\\tif c == '1':\\n\\t\\t\\tif not amchain and rowcost:\\n\\t\\t\\t\\tamchain = True\\n\\t\\t\\t\\tcost += min(rowcost, a)\\n\\t\\telse:\\n\\t\\t\\tif amchain:\\n\\t\\t\\t\\tamchain = False\\n\\t\\t\\t\\trowcost = b\\n\\t\\t\\telse:\\n\\t\\t\\t\\trowcost += b\\n\\tprint(cost)\\n\\t\\n\", \"for t in range(int(input())):\\n    a,b = list(map(int, input().split()))\\n    m = input()\\n    x=[]\\n    i=0\\n    while i<len(m) and m[i]=='0':\\n        i+=1\\n    cs=0\\n\\n    while i< len(m):\\n        if m[i]=='0':\\n            cs+=1\\n        if m[i]=='1' and cs!=0:\\n            x+=[cs]\\n            cs=0\\n        i+=1\\n    cp = (len(x)+1)*a\\n    for i in x:\\n        if i*b<a:\\n            cp-=a\\n            cp+=i*b\\n    if m=='0'*len(m):\\n        print(0)\\n    else:\\n        print(cp)\\n\", \"\\n\\nfor _ in range(int(input())):\\n    \\n    a, b = map(int, input().split())\\n    \\n    x = 0\\n    y = 10 ** 10\\n    \\n    for i in input():\\n        \\n        if i == '0':\\n            \\n            x, y = min(x, y), min(y + b, x + b + a)\\n            \\n        else:\\n            \\n            x, y = 10 ** 10, min(y, x + a)\\n            \\n            \\n    print(min(x, y))\", \"import sys\\nimport math\\ndef II():\\n\\treturn int(sys.stdin.readline())\\n \\ndef LI():\\n\\treturn list(map(int, sys.stdin.readline().split()))\\n \\ndef MI():\\n\\treturn list(map(int, sys.stdin.readline().split()))\\n \\ndef SI():\\n\\treturn sys.stdin.readline().strip()\\nt = II()\\nfor q in range(t):\\n\\ta,b = MI()\\n\\ts = list(SI())\\n\\tx = []\\n\\ty = []\\n\\tcount = 1\\n\\tfor i in range(1,len(s)):\\n\\t\\tif s[i] == s[i-1]:\\n\\t\\t\\tcount+=1\\n\\t\\telse:\\n\\t\\t\\tif s[i-1] == \\\"0\\\":\\n\\t\\t\\t\\ty.append(0)\\n\\t\\t\\telse:\\n\\t\\t\\t\\ty.append(1)\\n\\t\\t\\tx.append(count)\\n\\t\\t\\tcount = 1\\n\\tif len(s)!=0 and s[-1] == \\\"1\\\":\\n\\t\\ty.append(1)\\n\\t\\tx.append(count)\\n\\tif len(y)!=0 and y[0] == 0:\\n\\t\\ty.pop(0)\\n\\t\\tx.pop(0)\\n\\ty1 = []\\n\\tans = 0\\n\\tfor i in range(len(y)):\\n\\t\\tif y[i] == 0:\\n\\t\\t\\ty1.append(x[i])\\n\\t\\telse:\\n\\t\\t\\tans+=a\\n\\tfor i in y1:\\n\\t\\tif i*b<a:\\n\\t\\t\\tans-=a\\n\\t\\t\\tans+=i*b\\n\\tprint(ans)\\n\", \"import sys\\nfor _ in range(int(sys.stdin.readline())):\\n\\ta=list(map(int,sys.stdin.readline().strip().split(\\\" \\\")))\\n\\tb=sys.stdin.readline().strip()\\n\\tn=0\\n\\tinq=False\\n\\ts=0\\n\\tif b.count(\\\"1\\\")!=0:\\n\\t\\tfor i in b[b.index(\\\"1\\\"):]:\\n\\t\\t\\tif i==\\\"1\\\":\\n\\t\\t\\t\\tif not inq:\\n\\t\\t\\t\\t\\tinq=True\\n\\t\\t\\t\\t\\tif n!=0:\\n\\n\\t\\t\\t\\t\\t\\ts+=min(a[0],n*a[1])\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ts+=a[0]\\n\\t\\t\\t\\t\\tn=0\\n\\t\\t\\telse:\\n\\t\\t\\t\\tinq=False\\n\\t\\t\\t\\tn+=1\\n\\tprint(s)\\n\", \"import sys\\ninput=sys.stdin.readline\\n\\nt=int(input())\\nfor _ in range(t):\\n    x,y=list(map(int,input().split()))\\n    s=list(input())\\n    if \\\"1\\\" not in s:\\n        print(0)\\n    else:\\n        c=s.index(\\\"1\\\")\\n        d=len(s)-s[::-1].index(\\\"1\\\")\\n        s=s[c:d]\\n        b=[]\\n        c=0\\n        for i in range(len(s)):\\n            if s[i]==\\\"0\\\":\\n                c+=1\\n            else:\\n                if c!=0:\\n                    b.append(c)\\n                c=0\\n        s=x\\n        for i in range(len(b)):\\n            if b[i]*y>x:\\n                s+=x\\n            else:\\n                s+=b[i]*y\\n        print(s)\", \"import math\\nimport sys\\n\\n\\ndef chek(m, b, c, li):\\n    for i in range(li):\\n        if m[i] + b[i] > c:\\n            return False\\n    return True\\n\\n\\n# 113759\\ninput = lambda: sys.stdin.readline().rstrip()\\nf = int(input())\\nfor _ in range(f):\\n    a, b = list(map(int, input().split()))\\n    s = input()\\n    mas = []\\n    c = 1\\n    k = len(s)\\n    cur = 1\\n    while c != k:\\n        if s[c] == s[c - 1]:\\n            cur += 1\\n        else:\\n            if len(mas) != 0:\\n                mas.append(cur)\\n                cur = 1\\n            else:\\n                if s[c] == \\\"0\\\":\\n                    mas.append(cur)\\n                    cur = 1\\n                else:\\n                    cur = 1\\n        c += 1\\n    if s[c - 1] == \\\"1\\\":\\n        mas.append(cur)\\n    ans = 0\\n    for i in range(len(mas)):\\n        if i % 2 == 0:\\n            ans += a\\n        else:\\n            if a > b * mas[i]:\\n                ans += b * mas[i]\\n                ans -= a\\n    print(ans)\\n\", \"def f():\\n    a, b = map(int, input().split())\\n    s = input()\\n    ToF = False\\n    c = 0\\n    ans = 0\\n    for item in s:\\n        if ToF:\\n            if item == \\\"0\\\":\\n                c += 1\\n            else:\\n                ans += min(c * b, a)\\n                c = 0\\n        if item == \\\"1\\\":\\n            ToF = True\\n    print(ans + a * ToF)\\n\\n\\nt = int(input())\\nfor i in range(t):\\n    f()\", \"t=int(input())\\nfor _ in range(t):\\n    a,b=list(map(int,input().split()))\\n    m=input()\\n    flag=False\\n    l=[]\\n    prev=0\\n    flag=False\\n    for i in range(len(m)):\\n        if flag:\\n            if m[i]=='0':\\n                l.append((prev,i-1))\\n                flag=False\\n            else:\\n                continue \\n        else:\\n            if m[i]=='0':\\n                continue\\n            else:\\n                flag=True \\n                prev=i \\n    if flag:\\n        l.append((prev,len(m)-1))\\n    # print(l)\\n    if(len(l)==1):\\n        print(a)\\n    elif (len(l)==0):\\n        print(0)\\n    else:\\n        ans=a\\n        for i in range(1,len(l)):\\n            if (l[i][0]-l[i-1][1]-1)*b<=a:\\n                ans+=(l[i][0]-l[i-1][1]-1)*b\\n            else:\\n                ans+=a \\n        print(ans)\\n        \\n        \\n        \\n\", \"T = int(input())\\nfor t in range(T):\\n    a, b = [int(x) for x in input().split()]\\n    mines = input()\\n    price = 0\\n    last = \\\"\\\"\\n    not_mines = []\\n    there_was_mines = False\\n    not_mine = 0\\n    for c in mines:\\n        if c == '1':\\n            if last != c:\\n                price += a\\n                if not_mine > 0:\\n                    if there_was_mines:\\n                        not_mines.append(not_mine)\\n                    not_mine = 0\\n            there_was_mines = True\\n        else:\\n            not_mine += 1\\n        last = c\\n    # print(not_mines)\\n    for m in not_mines:\\n        if m*b < a:\\n            price = price - a + m*b\\n        \\n                \\n                \\n\\n    print(price)\", \"gans = []\\nfor _ in range(int(input())):\\n    a, b = map(int, input().split())\\n    w = list(map(int, list(input())))\\n    u = []\\n    k = 1\\n    for i in range(1, len(w)):\\n        if w[i] == w[i - 1]:\\n            k += 1\\n        else:\\n            u.append([w[i - 1], k])\\n            k = 1\\n    u.append([w[-1], k])\\n    dp = [0] * len(u)\\n    if u[0][0] == 1:\\n        dp[0] = a\\n    for i in range(1, len(u)):\\n        if u[i][0] == 0:\\n            dp[i] = dp[i - 1]\\n        else:\\n            if i == 1:\\n                dp[i] = dp[i - 1] + a\\n            else:\\n                dp[i] = min(dp[i - 1] + a, dp[i - 1] + b * u[i - 1][1])\\n    gans.append(dp[-1])\\nprint(*gans, sep='\\\\n')\\n            \\n\", \"mod = 10**9 + 7\\ndef solve():\\n    a, b = map(int, input().split())\\n    s = input()\\n    v = []\\n    tmp = 0\\n    ok = False\\n    for i in range(len(s)):\\n        if s[i] == '1':\\n            if tmp > 0:\\n                v.append(tmp)\\n            tmp = 0\\n            ok = True\\n        elif ok:\\n            tmp += 1\\n    v.sort()\\n    ans = a * (len(v) + 1)\\n    if not ok:\\n        ans = 0\\n    for i in range(len(v)):\\n        if ans >= ans - a + b * v[i]:\\n            ans = ans - a + b * v[i]\\n        else:\\n            break\\n    print(ans)\\nt = 1\\nt = int(input())\\nwhile t > 0:\\n    solve()\\n    t -= 1\", \"t = int(input())\\nfor _ in range(t):\\n\\ta, b = list(map(int, input().split()))\\n\\ts = input()\\n\\tn = len(s)\\n\\n\\tind1 = 0\\n\\tind2 = n-1\\n\\n\\twhile ind1 != n and s[ind1] == '0':\\n\\t\\tind1 += 1\\n\\n\\twhile ind2 != -1 and s[ind2] == '0':\\n\\t\\tind2 -= 1\\n\\n\\tif ind1 == n:\\n\\t\\tprint(0)\\n\\t\\tcontinue\\n\\n\\t# print(ind1, ind2)\\n\\n\\n\\tarr = []\\n\\tcount = 0\\n\\tfor i in range(ind1, ind2+1):\\n\\t\\tif s[i] == '0':\\n\\t\\t\\tcount += 1\\n\\t\\telse:\\n\\t\\t\\tif count != 0:\\n\\t\\t\\t\\tarr += [count]\\n\\t\\t\\tcount = 0\\n\\n\\tif count != 0:\\n\\t\\tarr += [count]\\n\\n\\tans = a*(len(arr)+1)\\n\\n\\t# print(arr)\\n\\tarr.sort()\\n\\n\\ttot = 0\\n\\tfor i in range(len(arr)):\\n\\t\\ttot += arr[i]\\n\\t\\tans = min(ans, b*tot + a*(len(arr)-i))\\n\\n\\tprint(ans)\\n\", \"import sys,math\\n# import re\\n# from heapq import *\\n# from collections import defaultdict as dd\\n# from collections import Counter as cc\\n# sys.setrecursionlimit(10**6)#thsis is must\\nmod = 10**9+7; md = 998244353\\ninput = lambda: sys.stdin.readline().strip()\\ninp = lambda: list(map(int,input().split()))\\n#______________________________________________________\\nfor _ in range(int(input())):\\n\\ta,b = inp()\\n\\ts = str(input())\\n\\tans = []\\n\\tc = 0\\n\\tfor i in s:\\n\\t\\tif i==\\\"1\\\":\\n\\t\\t\\tc+=1\\n\\t\\telse:\\n\\t\\t\\tif c==0:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tans.append(c)\\n\\t\\t\\tc=0\\n\\tif c>0:ans.append(c)\\n\\tflag = False\\n\\tc =0\\n\\tres = []\\n\\tfor i in s:\\n\\t\\tif i==\\\"1\\\":\\n\\t\\t\\tflag = True\\n\\t\\tif flag==True:\\n\\t\\t\\tif i==\\\"0\\\":\\n\\t\\t\\t\\tc+=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif c==0:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tres.append(c)\\n\\t\\t\\t\\tc = 0\\n\\t# print(res)\\n\\t# print(ans)\\n\\tfin = 0\\n\\tif len(ans)>0:\\n\\t\\tfin+=a\\n\\tif len(ans)>1:\\n\\t\\tfor i in range(len(res)):\\n\\t\\t\\tif res[i]*b>a:\\n\\t\\t\\t\\tfin+=a\\n\\t\\t\\telse:\\n\\t\\t\\t\\tfin+=res[i]*b\\n\\tprint(fin)\\n\\n\", \"for _ in range (int(input())):\\n    a,b=map(int,input().split())\\n    s=input()\\n    n=len(s)\\n    j=0\\n    while j<n and s[j]=='0':\\n        j+=1\\n    c=0\\n    r=a\\n    if j==n:\\n        r=0\\n    damp=0\\n    for i in range(j,n):\\n        if s[i]=='1':\\n            if damp>0:\\n                r+=min(a,damp*b)\\n            damp=0\\n        else:\\n            damp+=1\\n        #print(damp,r)\\n    print(r)\", \"def read_generator():\\n    while True:\\n        tokens = input().split(' ')\\n        for t in tokens:\\n            yield t\\n\\nreader = read_generator()\\n\\ndef readword():\\n    return next(reader)\\n\\ndef readint():\\n    return int(next(reader))\\n\\ndef readfloat():\\n    return float(next(reader))\\n\\ndef readline():\\n    return input()\\n\\ndef solve(a, b, m):\\n    o = []\\n    new = True\\n    i = 0\\n    for c in m:\\n        if c == '1':\\n            if new:\\n                o.append([i, i])\\n                new = False\\n            else:\\n                o[len(o) - 1][1] = i\\n        else:\\n            new = True\\n        i += 1\\n\\n    res = len(o) * a\\n\\n    for i in range(1, len(o)):\\n        cur = o[i]\\n        prev = o[i - 1]\\n        if (cur[0] - prev[1] - 1) * b < a:\\n            res -= a\\n            res += (cur[0] - prev[1] - 1) * b\\n\\n    return res\\n\\n\\ntests = readint()\\n\\nfor t in range(tests):\\n    (a, b) = readint(), readint()\\n    m = readline()\\n    print(solve(a, b, m))\", \"\\\"\\\"\\\"T=int(input())\\nfor _ in range(0,T):\\n    n=int(input())\\n    a,b=map(int,input().split())\\n    s=input()\\n    s=[int(x) for x in input().split()]\\n    for i in range(0,len(s)):\\n        a,b=map(int,input().split())\\\"\\\"\\\"\\n\\n\\n\\nT=int(input())\\nfor _ in range(0,T):\\n    a,b=list(map(int,input().split()))\\n    s=input()\\n    ptr1=len(s)\\n    ptr2=0\\n    for i in range(0,len(s)):\\n        if(s[i]=='1' and ptr1==len(s)):\\n            ptr1=i\\n        if(s[i]=='1'):\\n            ptr2=i+1\\n\\n    if(ptr1==len(s)):\\n        print(0)\\n    else:\\n        L1=[]\\n        L0=[]\\n        c=1\\n        for i in range(ptr1+1,ptr2):\\n            if(s[i]==s[i-1]):\\n                c+=1\\n            else:\\n                if(s[i-1]=='0'):\\n                    L0.append(c)\\n                    c=1\\n                else:\\n                    L1.append(c)\\n                    c=1\\n        L1.append(c)\\n\\n        if(len(L1)==1):\\n            print(a)\\n        else:\\n            ans=a\\n            for i in range(0,len(L1)-1):\\n                if((b*L0[i])<=a):\\n                    ans+=(b*L0[i])\\n                else:\\n                    ans+=a\\n            print(ans)\\n                \\n\", \"t = int(input())\\nfor case in range(t):\\n    a, b = [int(x) for x in input().split(' ')]\\n    s = input()\\n    n = len(s)\\n    for j in range(2):\\n        for i in range(len(s)):\\n            if s[i] != '0':\\n                break\\n        s = s[i:]\\n        s = s[::-1]\\n    if s == '0':\\n        s = ''\\n    y = [u for u in s.split('0') if u]\\n    c = len(y) * a\\n    x = [u for u in s.split('1') if u]\\n    for z in x:\\n        if len(z) * b < a:\\n            c -= a\\n            c += len(z) * b\\n    print(c)\\n\\n\", \"for _ in range(int(input())):\\n    a,b = list(map(int,input().split()))\\n    arr = list(map(int,list(input())))+[0]\\n    n = len(arr)\\n    now = 0\\n    lastEnds = 0\\n    fl = False\\n    lenghts = []\\n    dists = []\\n    for i in range(n):\\n        if fl and not arr[i]:\\n            if len(lenghts):\\n                dists.append(i-lastEnds-now)\\n            lenghts.append(now)\\n            fl = False\\n            now = 0\\n            lastEnds = i\\n        elif fl and arr[i]:\\n            now+=1\\n        elif not fl and arr[i]:\\n            fl = True\\n            now = 1\\n\\n    price = a\\n    if len(lenghts) == 0:\\n        price = 0\\n\\n    for i in range(len(dists)):\\n        if dists[i]*b<a:\\n            price+=dists[i]*b\\n        else:\\n            price+=a\\n\\n    print(price)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"2\\n1 1\\n01000010\\n5 1\\n01101110\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n6\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1443/B", "starter_code": ""}
{"id": 70, "question": "Word $s$ of length $n$ is called $k$-complete if   $s$ is a palindrome, i.e. $s_i=s_{n+1-i}$ for all $1 \\le i \\le n$;  $s$ has a period of $k$, i.e. $s_i=s_{k+i}$ for all $1 \\le i \\le n-k$. \n\nFor example, \"abaaba\" is a $3$-complete word, while \"abccba\" is not.\n\nBob is given a word $s$ of length $n$ consisting of only lowercase Latin letters and an integer $k$, such that $n$ is divisible by $k$. He wants to convert $s$ to any $k$-complete word.\n\nTo do this Bob can choose some $i$ ($1 \\le i \\le n$) and replace the letter at position $i$ with some other lowercase Latin letter.\n\nSo now Bob wants to know the minimum number of letters he has to replace to convert $s$ to any $k$-complete word.\n\nNote that Bob can do zero changes if the word $s$ is already $k$-complete.\n\nYou are required to answer $t$ test cases independently.\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t\\le 10^5$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le k < n \\le 2 \\cdot 10^5$, $n$ is divisible by $k$).\n\nThe second line of each test case contains a word $s$ of length $n$.\n\nIt is guaranteed that word $s$ only contains lowercase Latin letters. And it is guaranteed that the sum of $n$ over all test cases will not exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, output one integer, representing the minimum number of characters he has to replace to convert $s$ to any $k$-complete word.\n\n\n-----Example-----\nInput\n4\n6 2\nabaaba\n6 3\nabaaba\n36 9\nhippopotomonstrosesquippedaliophobia\n21 7\nwudixiaoxingxingheclp\n\nOutput\n2\n0\n23\n16\n\n\n\n-----Note-----\n\nIn the first test case, one optimal solution is aaaaaa.\n\nIn the second test case, the given word itself is $k$-complete.", "solutions": "[\"import sys\\ninput = sys.stdin.readline\\nfrom collections import defaultdict\\n\\nclass Unionfind:\\n    def __init__(self, n):\\n        self.par = [-1]*n\\n        self.rank = [1]*n\\n    \\n    def root(self, x):\\n        r = x\\n        \\n        while not self.par[r]<0:\\n            r = self.par[r]\\n        \\n        t = x\\n        \\n        while t!=r:\\n            tmp = t\\n            t = self.par[t]\\n            self.par[tmp] = r\\n        \\n        return r\\n    \\n    def unite(self, x, y):\\n        rx = self.root(x)\\n        ry = self.root(y)\\n        \\n        if rx==ry:\\n            return\\n        \\n        if self.rank[rx]<=self.rank[ry]:\\n            self.par[ry] += self.par[rx]\\n            self.par[rx] = ry\\n            \\n            if self.rank[rx]==self.rank[ry]:\\n                self.rank[ry] += 1\\n        else:\\n            self.par[rx] += self.par[ry]\\n            self.par[ry] = rx\\n    \\n    def is_same(self, x, y):\\n        return self.root(x)==self.root(y)\\n    \\n    def count(self, x):\\n        return -self.par[self.root(x)]\\n\\nt = int(input())\\n\\nfor _ in range(t):\\n    n, k = map(int, input().split())\\n    s = input()[:-1]\\n    uf = Unionfind(n)\\n    \\n    for i in range(n//2):\\n        uf.unite(i, n-1-i)\\n    \\n    for i in range(n-k):\\n        uf.unite(i, i+k)\\n    \\n    d = defaultdict(dict)\\n    \\n    for i in range(n):\\n        if s[i] not in d[uf.root(i)]:\\n            d[uf.root(i)][s[i]] = 1\\n        else:\\n            d[uf.root(i)][s[i]] += 1\\n    \\n    rs = set(uf.root(i) for i in range(n))\\n    ans = 0\\n    \\n    for r in rs:\\n        ans += uf.count(r)-max(list(d[r].values()))\\n    \\n    print(ans)\", \"def main():\\n    import sys\\n    input = sys.stdin.readline\\n\\n    for _ in range(int(input())):\\n        N, K = list(map(int, input().split()))\\n        S = input().rstrip('\\\\n')\\n\\n        cnt = [[0] * K for _ in range(26)]\\n        for i, s in enumerate(S):\\n            j = ord(s) - 97\\n            cnt[j][i%K] += 1\\n        ans = 0\\n        L = (N//K) * 2\\n        for i in range(K//2):\\n            tmp = N+1\\n            for j in range(26):\\n                tmp = min(tmp, L - (cnt[j][i] + cnt[j][K-i-1]))\\n            ans += tmp\\n        if K&1:\\n            tmp = N+1\\n            for j in range(26):\\n                tmp = min(tmp, N//K - cnt[j][K//2])\\n            ans += tmp\\n        print(ans)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import sys\\ninput = lambda: sys.stdin.readline().rstrip()\\ndef calc(n, k, A):\\n    X = [[0] * 26 for _ in range((k+1)//2)]\\n    for i, a in enumerate(A):\\n        j = i % k\\n        j = min(j, k-1-j)\\n        X[j][a] += 1\\n    return sum([sum(x) - max(x) for x in X])\\n\\nT = int(input())\\nfor _ in range(T):\\n    N, K = list(map(int, input().split()))\\n    S = [ord(a) - 97 for a in input()]\\n    print(calc(N, K, S))\\n\\n\", \"import sys\\ninput=sys.stdin.readline\\nt=int(input())\\ndef find(no):\\n    nonlocal par\\n    if par[no]==no:\\n        return no\\n    par[no]=find(par[no])\\n    return par[no]\\nfor _ in range(t):\\n    n,k=list(map(int,input().split()))\\n    s=[ord(i)-97 for i in input()]\\n    \\n    par=[i for i in range(n)]\\n    vis=[0 for i in range(n)]\\n    for i in range(k):\\n        for j in range(i,n,k):\\n        \\n            vis[j]=1\\n            x=n-j-1\\n            aa=find(x)\\n            bb=find(j)\\n            par[bb]=aa\\n            if(j>i):\\n                aa=find(j-k)\\n                bb=find(j)\\n                par[bb]=aa\\n    tot=n\\n    aa=set(par)\\n    co=[[0 for i in range(26)] for j in range(n)]\\n   # print(par)\\n    for i in range(n):\\n        co[par[i]][s[i]]+=1\\n    tot-=sum([max(i) for i in co])\\n    print(tot)\\n        \\n        \\n    \\n            \\n                \\n            \\n    \\n    \\n    \\n\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n6 2\\nabaaba\\n6 3\\nabaaba\\n36 9\\nhippopotomonstrosesquippedaliophobia\\n21 7\\nwudixiaoxingxingheclp\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n0\\n23\\n16\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1332/C", "starter_code": ""}
{"id": 71, "question": "You're given an array $a$ of $n$ integers, such that $a_1 + a_2 + \\cdots + a_n = 0$.\n\nIn one operation, you can choose two different indices $i$ and $j$ ($1 \\le i, j \\le n$), decrement $a_i$ by one and increment $a_j$ by one. If $i < j$ this operation is free, otherwise it costs one coin.\n\nHow many coins do you have to spend in order to make all elements equal to $0$?\n\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 5000$). Description of the test cases follows.\n\nThe first line of each test case contains an integer $n$ ($1 \\le n \\le 10^5$) \u00a0\u2014 the number of elements.\n\nThe next line contains $n$ integers $a_1, \\ldots, a_n$ ($-10^9 \\le a_i \\le 10^9$). It is given that $\\sum_{i=1}^n a_i = 0$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print the minimum number of coins we have to spend in order to make all elements equal to $0$.\n\n\n-----Example-----\nInput\n7\n4\n-3 5 -3 1\n2\n1 -1\n4\n-3 2 -3 4\n4\n-1 1 1 -1\n7\n-5 7 -6 -4 17 -13 4\n6\n-1000000000 -1000000000 -1000000000 1000000000 1000000000 1000000000\n1\n0\n\nOutput\n3\n0\n4\n1\n8\n3000000000\n0\n\n\n\n-----Note-----\n\nPossible strategy for the first test case:   Do $(i=2, j=3)$ three times (free), $a = [-3, 2, 0, 1]$.  Do $(i=2, j=1)$ two times (pay two coins), $a = [-1, 0, 0, 1]$.  Do $(i=4, j=1)$ one time (pay one coin), $a = [0, 0, 0, 0]$.", "solutions": "[\"t=int(input())\\nwhile t>0 :\\n    n=int(input())\\n    a=list(map(int,input().split()))\\n    an=0\\n    s=0\\n    for i in a :\\n        if s+i>=0 :\\n            s+=i \\n        else :\\n            s+=i\\n            an-=s \\n            s=0\\n    print(an)\\n    t-=1 \", \"\\nT = int(input())\\n\\n#lets = 'abcdefghijklmnopqrstuvwxyz'\\n#key = {lets[i]:i for i in range(26)}\\n\\nfor t in range(T):\\n  n = int(input())\\n  #n,k = map(int,input().split())\\n  a = list(map(int,input().split()))\\n  #a = input().split()\\n  d = False\\n  cu = 0\\n  cu_m = 0\\n  for i in range(n):\\n    cu += a[i]\\n    cu_m = min(cu_m,cu)\\n  \\n  print(-cu_m)\", \"tests = int(input())\\nfor t in range(tests):\\n    n = int(input())\\n    ls = list(map(int, input().split()))\\n    curr = 0\\n    res = 0\\n    for item in ls:\\n        curr += item\\n        if curr < res:\\n            res = curr\\n    print(-res)\", \"def main():\\n    t = int(input())\\n    for _ in range(t):\\n        n = int(input())\\n        alst = list(map(int, input().split()))\\n        ans = 0\\n        total = 0\\n        for a in alst:\\n            total -= a\\n            ans = max(ans, total)\\n        print(ans)\\n    \\nmain()\", \"for _ in range (int(input())):\\n    n=int(input())\\n    a=list(map(int,input().split()))\\n    r=0\\n    avl=0\\n    for i in a:\\n        if i>0:\\n            avl+=i\\n        else:\\n            i=abs(i)\\n            d=min(avl,i)\\n            avl-=d\\n            r+=i-d\\n    print(r)\", \"import bisect\\nimport copy\\nimport fractions\\nimport functools\\nimport heapq\\nimport math\\nimport random\\nimport sys\\n\\n\\ndef __starting_point():\\n\\n    T = int(input())\\n\\n    for t in range(T):\\n        N = int(input())\\n        A = list(map(int, input().split()))\\n\\n        total = 0\\n        min_ = 0\\n        for a in A:\\n            total += a\\n            min_ = min(min_, total)\\n\\n        print(str(abs(min_)))\\n\\n__starting_point()\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    A = list(map(int,input().split()))\\n    res = 0\\n    temp = 0\\n    for a in A:\\n        temp+=a\\n        res = min(res,temp)\\n    print(-res)\", \"for _ in range(int(input())):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    pre = [0]*(n+1)\\n    for i in range(n):\\n        pre[i+1] = pre[i]+a[i]\\n    print(abs(min(pre)))\", \"t = int(input())\\nwhile t:\\n    t += -1\\n    n = int(input())\\n    l = list(map(int, input().split()))\\n    ans = 0\\n    sm = 0\\n    for i in l:\\n        sm += i\\n        ans = min(ans, sm)\\n    print(abs(ans))\", \"\\\"\\\"\\\"\\nAuthor: Q.E.D\\nTime: 2020-09-06 09:39:09\\n\\\"\\\"\\\"\\nT = int(input())\\nfor _ in range(T):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    ans = 0\\n    quota = 0\\n    for x in a:\\n        k = abs(x)\\n        if x >= 0:\\n            quota += k\\n        else:\\n            r = max(0, k - quota)\\n            quota -= (k - r)\\n            ans += r\\n    print(ans)\\n\", \"#!/usr/bin/env pypy3\\n\\t\\nfrom sys import stdin, stdout\\n \\ndef input():\\n    return stdin.readline().strip()\\n\\ndef ans(A):\\n\\tA = A[::-1]\\n\\n\\tret = float(\\\"-inf\\\")\\n\\ts = 0\\n\\tfor a in A:\\n\\t\\ts += a\\n\\t\\tret = max(ret, s)\\n\\n\\treturn ret\\n\\n\\nT = int(input())\\nfor t in range(T):\\n\\tinput()\\n\\tA = list(map(int, input().split()))\\n\\tprint(ans(A))\\n\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    min = 0\\n    s = 0\\n    for i in range(n):\\n        s = s + a[i]\\n        if s < min:\\n            min = s\\n    print(abs(min))\\n\", \"from collections import defaultdict as dd\\nimport sys\\ninput=sys.stdin.readline\\nt=int(input())\\nwhile t:\\n    n=int(input())\\n    #n,m=map(int,input().split())\\n    l=list(map(int,input().split()))\\n    st=0\\n    for i in range(n):\\n        if(l[i]>0):\\n            st+=l[i]\\n        else:\\n            if(st):\\n                mi=min(st,-l[i])\\n                st-=mi\\n    print(st)\\n    t-=1\", \"from sys import stdin\\nfrom math import ceil\\ninp = lambda : stdin.readline().strip()\\n\\nt = int(inp())\\n\\nfor _ in range(t):\\n    n = int(inp())\\n    a = [int(x) for x in inp().split()]\\n    cumm = 0\\n    ans = 0\\n    for i in range(n):\\n        cumm += a[i]\\n        if cumm < 0:\\n            ans = min(ans,cumm)\\n    print(-1*ans)\", \"t=int(input())\\nfor t in range(t):\\n\\tn=int(input())\\n\\ta=[int(x) for x in input().split(' ')]\\n\\tb=[0]\\n\\tfor i in range(n):\\n\\t\\tb.append(b[-1]+a[i])\\n\\t# print(b)\\n\\tmn=b[0]\\n\\tfor x in b:\\n\\t\\tmn=min(mn,x)\\n\\tprint(abs(mn))\\n\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    a = list(map(int,input().split()))\\n    cnt = 0\\n    av = 0\\n    for i in range(n):\\n        if a[i]<0:\\n            cr = min(-1*a[i],av)\\n            a[i]+=cr\\n            av-=cr\\n            cnt+=a[i]\\n            a[i]=0\\n        else:\\n            av+=a[i]\\n    print(-1*cnt)\", \"# cook your dish here\\n# code\\n#    ___________________________________\\n#   |                                   |\\n#   |                                   |\\n#   |        _,     _   _     ,_        |\\n#   |    .-'` /     \\\\'-'/     \\\\ `'-.    |\\n#   |   /    |      |   |      |    \\\\   |\\n#   |  ;      \\\\_  _/     \\\\_  _/      ;  |\\n#   | |         ``         ``         | |\\n#   | |                               | |\\n#   |  ;    .-.   .-.   .-.   .-.    ;  |\\n#   |   \\\\  (   '.'   \\\\ /   '.'   )  /   |\\n#   |    '-.;         V         ;.-'    |\\n#   |        `                 `        |\\n#   |                                   |\\n#   |___________________________________|\\n#   |                                   |\\n#   |  Author      :   Ramzz            |\\n#   |  Created On  :   21-07-2020       |\\n#   |___________________________________|\\n#\\n#    _ __ __ _ _ __ ___  ________\\n#   | '__/ _` | '_ ` _ \\\\|_  /_  /\\n#   | | | (_| | | | | | |/ / / / \\n#   |_|  \\\\__,_|_| |_| |_/___/___|\\n#\\n\\nimport math\\nimport collections\\nfrom sys import stdin,stdout,setrecursionlimit\\nfrom bisect import bisect_left as bsl\\nfrom bisect import bisect_right as bsr\\nimport heapq as hq\\nsetrecursionlimit(2**20)\\n\\nt = 1\\nt = int(stdin.readline())\\n\\nfor _ in range(t):\\n    n = int(stdin.readline())\\n    #s = stdin.readline().strip('\\\\n')\\n    a = list(map(int, stdin.readline().rstrip().split()))\\n    \\n    ans = 0\\n    s = 0\\n    for i in range(n):\\n        s += a[i]\\n        if(s<0 and abs(s)>ans):\\n            ans = abs(s)\\n            \\n    print(ans)\\n    \\n    \\n\", \"from math import ceil\\nfrom collections import deque\\n\\n\\nfor _ in range(int(input())):\\n\\tn = int(input())\\n\\ta = [int(i) for i in input().split()]\\n\\tans = 0\\n\\ts = 0\\n\\tfor i in range(n):\\n\\t\\tif a[i]<s:\\n\\t\\t\\tans += s-a[i]\\n\\t\\t\\ts = 0\\n\\t\\telse:\\n\\t\\t\\ts -= a[i]\\n\\tprint(ans)\\n\", \"#Codeforces.com round #668\\n#Problem B\\nimport sys\\n\\n#\\n#BEGIN TEMPLATE\\n#\\ndef input():\\n    return sys.stdin.readline()[:-1]\\n\\ndef getInt():\\n    #Assumes next line consists of only one integer and returns an integer\\n    return int(input())\\n\\ndef getIntIter():\\n    return list(map(int, input().split()))\\n\\ndef getIntList():\\n    return list(getIntIter())\\n\\n#\\n#END TEMPLATE\\n#\\n\\nfor _ in range(getInt()):\\n    n = getInt()\\n    nums = getIntList()\\n    minSum = 0\\n    currSum = 0\\n    for num in nums:\\n        currSum += num\\n        minSum = min(currSum, minSum)\\n    print(abs(minSum))\\n\", \"for T in range(int(input())) :\\n    n = int(input())\\n    l = list(map(int,input().split()))\\n    bal = 0 \\n    ans = 0\\n    for i in l :\\n        if i >= 0 :\\n            bal += i\\n        else :\\n            if abs(i) > bal :\\n                ans += abs(i)-bal\\n                bal = 0\\n            else :\\n                bal += i \\n    print(ans)\", \"import sys\\nimport math\\ndef II():\\n\\treturn int(sys.stdin.readline())\\n\\ndef LI():\\n\\treturn list(map(int, sys.stdin.readline().split()))\\n\\ndef MI():\\n\\treturn list(map(int, sys.stdin.readline().split()))\\n\\ndef SI():\\n\\treturn sys.stdin.readline().strip()\\nt = II()\\nfor q in range(t):\\n\\tn = II()\\n\\ta = LI()\\n\\td = [0]*n\\n\\ts = 0\\n\\tfor i in range(n):\\n\\t\\ts+=a[i]\\n\\t\\td[i] = s\\n\\tans = min(d)\\n\\tif ans>0:\\n\\t\\tans = 0\\n\\tprint(-ans)\\n\", \"import math\\nfrom collections import deque\\nfrom sys import stdin, stdout\\nfrom string import ascii_letters\\nimport sys\\nletters = ascii_letters\\ninput = stdin.readline\\n#print = stdout.write\\n\\nfor _ in range(int(input())):\\n    n = int(input())\\n    arr = list(map(int, input().split()))\\n    need = sum([i for i in arr if i >= 0])\\n    was = 0\\n    have = [0] * n\\n    for i in range(n):\\n        if i != 0:\\n            have[i] = have[i - 1]\\n        if arr[i] > 0:\\n            have[i] += arr[i]\\n    for i in range(n - 1, -1, -1):\\n        if arr[i] < 0:\\n            bf = min(abs(arr[i]), have[i] - was)\\n            was += bf\\n            need -= bf\\n        else:\\n            was = max(0, was - arr[i])\\n    print(need)\\n\\n\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    l = list(map(int,input().split()))\\n    h = 0\\n    ans = 0\\n    for j in range(n):\\n        h+=l[j]\\n        if h<0:\\n            ans = max(ans,abs(h))\\n    print(ans)\", \"for __ in range(int(input())):\\n    n = int(input())\\n    ar = list(map(int, input().split()))\\n    ans = 0\\n    a = 0\\n    b = 0\\n    for elem in ar:\\n        if elem < 0:\\n            if b > -elem:\\n                b += elem\\n                a += elem\\n            else:\\n                ans += abs(elem) - b\\n                b = 0\\n                a += abs(elem) - b\\n        else:\\n            b += elem\\n    print(ans)\", \"# Lack of emotion causes lack of progress and lack of motivation. Tony Robbins\\n\\nfor _ in range(int(input())):\\n    n=int(input())\\n    a=list(map(int,input().split()))\\n    s=0\\n    ans=0\\n    for x in a:\\n        s+=x\\n        ans=min(ans,s)\\n    print(-ans)\\n\", \"for _ in range(int(input())):\\n    n=int(input())\\n    a=list(map(int,input().split()))\\n    m=a[0]\\n    s=a[0]\\n    for i in range(1,n):\\n        s+=a[i]\\n        m=min(m,s)\\n    print(max(abs(m),0))\", \"import math\\n\\nt = int(input())\\n\\nfor q in range(t):\\n    n = int(input())\\n    P = [int(i) for i in input().split()]\\n    c = 0\\n    res = 0\\n    for i in P:\\n        if i > 0:\\n            c += i\\n        elif i < 0:\\n            if i < -1 * c:\\n                res += abs(i + c)\\n                c = 0\\n            else:\\n                c += i\\n    print(res)\\n        \\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    arr = list(map(int,input().split()))\\n    pos = 0\\n    i = 0\\n    while i < n:\\n        if arr[i] < 0:\\n            if pos >= abs(arr[i]):\\n                pos += arr[i]\\n                arr[i] = 0\\n            else:\\n                arr[i] += pos\\n                pos = 0\\n        else:\\n            pos += arr[i]\\n        i += 1\\n    print(pos)\\n\", \"gans = []\\nfor _ in range(int(input())):\\n    n = int(input())\\n    u = list(map(int, input().split()))\\n    cur = 0\\n    ans = 0\\n    for i in range(n):\\n        if u[i] == 0:\\n            continue\\n        if u[i] > 0:\\n            cur += u[i]\\n        else:\\n            u[i] = -u[i]\\n            if cur > u[i]:\\n                cur -= u[i]\\n            else:\\n                ans += u[i] - cur\\n                cur = 0\\n        #print(cur, u[i])\\n    gans.append(ans)\\nprint('\\\\n'.join(map(str, gans)))\\n\", \"from bisect import bisect_left as bl\\nfrom bisect import bisect_right as br\\nfrom heapq import heappush,heappop,heapify\\nimport math\\nfrom collections import *\\nfrom functools import reduce,cmp_to_key\\nimport sys\\ninput = sys.stdin.readline\\n\\nfrom itertools import accumulate\\nfrom functools import lru_cache\\n\\nM = mod = 998244353\\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\\ndef inv_mod(n):return pow(n, mod - 2, mod)\\n\\ndef li():return [int(i) for i in input().rstrip('\\\\n').split()]\\ndef st():return input().rstrip('\\\\n')\\ndef val():return int(input().rstrip('\\\\n'))\\ndef li2():return [i for i in input().rstrip('\\\\n')]\\ndef li3():return [int(i) for i in input().rstrip('\\\\n')]\\n\\nfor _ in range(val()):\\n    n = val()\\n    l = li()\\n\\n\\n    ans = curr = 0\\n    for i in l:\\n\\n        if i >= 0:\\n            curr += i\\n            continue\\n        else:\\n            temp = min(curr, abs(i))\\n            curr -= temp\\n        if abs(i) > temp:\\n            ans += abs(i) - temp\\n    print(ans)\\n\", \"\\\"\\\"\\\"T=int(input())\\nfor _ in range(0,T):\\n    n=int(input())\\n    a,b=map(int,input().split())\\n    s=input()\\n    s=[int(x) for x in input().split()]\\n    for i in range(0,len(s)):\\n        a,b=map(int,input().split())\\\"\\\"\\\"\\n\\n\\n\\nT=int(input())\\nfor _ in range(0,T):\\n    n=int(input())\\n    s=[int(x) for x in input().split()]\\n    nrem = 0\\n    ans=0\\n    for i in range(len(s)-1,-1,-1):\\n        if(s[i]>0):\\n            tt=min(nrem,s[i])\\n            s[i]-=tt\\n            ans+=s[i]\\n            nrem-=tt\\n        else:\\n            nrem+=abs(s[i])\\n\\n    print(ans)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"7\\n4\\n-3 5 -3 1\\n2\\n1 -1\\n4\\n-3 2 -3 4\\n4\\n-1 1 1 -1\\n7\\n-5 7 -6 -4 17 -13 4\\n6\\n-1000000000 -1000000000 -1000000000 1000000000 1000000000 1000000000\\n1\\n0\\n\"\n  ],\n  \"outputs\": [\n    \"3\\n0\\n4\\n1\\n8\\n3000000000\\n0\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1405/B", "starter_code": ""}
{"id": 72, "question": "Phoenix loves beautiful arrays. An array is beautiful if all its subarrays of length\u00a0$k$ have the same sum. A subarray of an array is any sequence of consecutive elements.\n\nPhoenix currently has an array $a$ of length $n$. He wants to insert some number of integers, possibly zero, into his array such that it becomes beautiful. The inserted integers must be between $1$ and $n$ inclusive. Integers may be inserted anywhere (even before the first or after the last element), and he is not trying to minimize the number of inserted integers.\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 50$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 100$).\n\nThe second line of each test case contains $n$ space-separated integers ($1 \\le a_i \\le n$)\u00a0\u2014 the array that Phoenix currently has. This array may or may not be already beautiful.\n\n\n-----Output-----\n\nFor each test case, if it is impossible to create a beautiful array, print -1. Otherwise, print two lines.\n\nThe first line should contain the length of the beautiful array $m$ ($n \\le m \\le 10^4$). You don't need to minimize $m$.\n\nThe second line should contain $m$ space-separated integers ($1 \\le b_i \\le n$)\u00a0\u2014 a beautiful array that Phoenix can obtain after inserting some, possibly zero, integers into his array $a$. You may print integers that weren't originally in array $a$.\n\nIf there are multiple solutions, print any. It's guaranteed that if we can make array $a$ beautiful, we can always make it with resulting length no more than $10^4$.\n\n\n-----Example-----\nInput\n4\n4 2\n1 2 2 1\n4 3\n1 2 2 1\n3 2\n1 2 3\n4 4\n4 3 4 2\n\nOutput\n5\n1 2 1 2 1\n4\n1 2 2 1\n-1\n7\n4 3 2 1 4 3 2\n\n\n-----Note-----\n\nIn the first test case, we can make array $a$ beautiful by inserting the integer $1$ at index $3$ (in between the two existing $2$s). Now, all subarrays of length $k=2$ have the same sum $3$. There exists many other possible solutions, for example:   $2, 1, 2, 1, 2, 1$  $1, 2, 1, 2, 1, 2$ \n\nIn the second test case, the array is already beautiful: all subarrays of length $k=3$ have the same sum $5$.\n\nIn the third test case, it can be shown that we cannot insert numbers to make array $a$ beautiful.\n\nIn the fourth test case, the array $b$ shown is beautiful and all subarrays of length $k=4$ have the same sum $10$. There exist other solutions also.", "solutions": "[\"t = int(input())\\n\\nfor _ in range(t):\\n    n, k = [int(x) for x in input().split()]\\n    a = [int(x) for x in input().split()]\\n    if len(set(a)) > k:\\n        print(-1)\\n        continue\\n    l = list(set(a))\\n    l.extend([1]*(k - len(l)))\\n\\n    print(n*k)\\n    for _ in range(n):\\n        print(*l, end=\\\" \\\")\\n    print()\\n\", \"for i in range(int(input())):\\n\\tn, k=(int(j) for j in input().split())\\n\\ta=[int(j) for j in input().split()]\\n\\tmm=set(a)\\n\\tif(len(mm)>k):\\n\\t\\tprint(\\\"-1\\\", end=\\\" \\\")\\n\\telse:\\n\\t\\tif(len(mm)<k):\\n\\t\\t\\tfor j in range(1, 101):\\n\\t\\t\\t\\tif(j not in mm):\\n\\t\\t\\t\\t\\tmm.add(j)\\n\\t\\t\\t\\tif(len(mm)==k):\\n\\t\\t\\t\\t\\tbreak\\n\\t\\tprint(n*len(mm))\\n\\t\\tfor j in range(n):\\n\\t\\t\\tprint(\\\" \\\".join(str(x) for x in mm), end=\\\" \\\")\\n\\tprint()\", \"import sys\\n\\nstdin = sys.stdin\\n\\nns = lambda: stdin.readline().rstrip()\\nni = lambda: int(stdin.readline().rstrip())\\nnm = lambda: list(map(int, stdin.readline().split()))\\nnl = lambda: list(map(int, stdin.readline().split()))\\n\\ndef solve():\\n    n, k = nm()\\n    a = nl()\\n    if k < len(set(a)):\\n        print(-1)\\n        return\\n    f = list(set(a))\\n    f += [1]*(k-len(f))\\n    f *= n\\n    print(len(f))\\n    print(*f)\\n    return\\n\\n\\nt = ni()\\nfor _ in range(t):\\n    solve()\\n\", \"for _ in range(int(input())):\\n    n, k = list(map(int, input().split()))\\n    arr = list(map(int, input().split()))\\n    if len(set(arr)) > k:\\n        print(-1)\\n    else:\\n        result = []\\n        temp = list(set(arr))\\n        for i in range(1, n + 1):\\n            if len(temp) == k:\\n                break\\n            if i not in temp:\\n                temp.append(i)\\n                \\n        for i in range(len(arr)):\\n            result.extend(temp)\\n        print(len(result))\\n        print(*result)\\n        \\n\", \"import collections\\n\\nt=int(input())\\nfor _ in range(t):\\n    n,k=map(int,input().split())\\n    arr=list(map(int,input().split()))\\n    if len(collections.Counter(arr))>k:\\n        print(-1)\\n    else:\\n        cand=list(collections.Counter(arr).keys())\\n        cnt=len(cand)\\n        for i in range(1,n+1):\\n            if cnt>=k:\\n                break\\n            else:\\n                if i not in cand:\\n                    cand.append(i)\\n                    cnt+=1\\n        print(cnt*n)\\n        print(*(cand*n))\", \"from collections import Counter\\n\\ndef read_int():\\n    return int(input())\\n\\n\\ndef read_ints():\\n    return map(int, input().split(' '))\\n\\n\\nt = read_int()\\nfor case_num in range(t):\\n    n, k = read_ints()\\n    a = list(read_ints())\\n    cnt = Counter(a)\\n    distinct = len(cnt)\\n    if distinct > k:\\n        print(-1)\\n    else:\\n        print(n * k)\\n        s = set(cnt)\\n        for i in range(1, n + 1):\\n            if len(s) < k and not i in s:\\n                s.add(i)\\n        ans = list(s) * n\\n        print(' '.join(map(str, ans)))\", \"import sys\\nreadline = sys.stdin.readline\\n\\nT = int(readline())\\nAns = []\\nfor qu in range(T):\\n    N, K = map(int, readline().split())\\n    A = list(map(int, readline().split()))\\n    SA = set(A)\\n    if len(SA) <= K:\\n        res = list(SA)\\n        for i in range(1, N+1):\\n            if len(res) == K:\\n                break\\n            if i not in SA:\\n                res.append(i)\\n        Ans.append(str(N*K))\\n        Ans.append(' '.join(map(str, res*N)))\\n    else:\\n        Ans.append('-1')\\nprint('\\\\n'.join(map(str, Ans)))\", \"import sys\\n\\ninput = sys.stdin.readline\\n\\nfor _ in range(int(input())):\\n    n, k = list(map(int, input().split()))\\n    a = list(map(int, input().split()))\\n    if len(set(a)) > k:\\n        print(-1)\\n        continue\\n    a = list(set(a))\\n    a += [1] * (k - len(a))\\n    print(k * n)\\n    print(*(a * n))\\n\", \"def Solve(nCase):\\n    n, k = [int(x) for x in input().split()]\\n    a = [int(x) for x in input().split()]\\n    l = list(set(a))\\n    p = len(l)\\n    if p > k:\\n        print(-1)\\n        return\\n    for i in range(k - p):\\n        l.append(a[0])\\n    ans = n * l\\n    print(len(ans))\\n    print(' '.join(str(x) for x in ans)) \\n\\n\\nT = int(input())\\nfor i in range(1, T + 1):\\n    Solve(i)\\n\", \"def beauty(n, k, array):\\n    s = set(array)\\n    \\n    if len(s) > k:\\n        print(-1)\\n        return\\n    \\n    L = list(s)\\n    L.extend([array[0]] * (k - len(s)))\\n    L *= n\\n    \\n    print(len(L))\\n    print(*L)\\n    \\nt = int(input())\\nfor i in range(t):\\n    n, k = list(map(int, input().split()))\\n    array = list(map(int, input().split()))\\n    beauty(n, k, array)\\n\", \"q = int(input())\\nfor _ in range(q):\\n\\tn,k = map(int,input().split())\\n\\tl = list(map(int,input().split()))\\n\\t#szukamy tak zeby okres byl k-1\\n\\tif k==1:\\n\\t\\tif max(l) == min(l):\\n\\t\\t\\tprint(len(l))\\n\\t\\t\\tprint(*l)\\n\\t\\telse:\\n\\t\\t\\tprint(-1)\\n\\telse:\\n\\t\\tcyk = set()\\n\\t\\tfor i in l:\\n\\t\\t\\tcyk.add(i)\\n\\t\\tif len(cyk) > k:\\n\\t\\t\\tdasie = 0\\n\\t\\telse:\\n\\t\\t\\tdasie = 1\\n\\t\\tif dasie == 0:\\n\\t\\t\\tprint(-1)\\n\\t\\telse:\\n\\t\\t\\ta = list(cyk)\\n\\t\\t\\twhile len(a) != k:\\n\\t\\t\\t\\ta.append(l[0])\\n\\t\\t\\todp = n*a\\n\\t\\t\\tprint(len(odp))\\n\\t\\t\\tprint(*odp)\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n4 2\\n1 2 2 1\\n4 3\\n1 2 2 1\\n3 2\\n1 2 3\\n4 4\\n4 3 4 2\\n\"\n  ],\n  \"outputs\": [\n    \"8\\n1 2 1 2 1 2 1 2 \\n12\\n1 2 1 1 2 1 1 2 1 1 2 1 \\n-1\\n16\\n2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 \\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1348/B", "starter_code": ""}
{"id": 73, "question": "You're given an array of $n$ integers between $0$ and $n$ inclusive.\n\nIn one operation, you can choose any element of the array and replace it by the MEX of the elements of the array (which may change after the operation).\n\nFor example, if the current array is $[0, 2, 2, 1, 4]$, you can choose the second element and replace it by the MEX of the present elements \u00a0\u2014 $3$. Array will become $[0, 3, 2, 1, 4]$.\n\nYou must make the array non-decreasing, using at most $2n$ operations.\n\nIt can be proven that it is always possible. Please note that you do not have to minimize the number of operations. If there are many solutions, you can print any of them.\n\n\u00a0\u2013\n\nAn array $b[1 \\ldots n]$ is non-decreasing if and only if $b_1 \\le b_2 \\le \\ldots \\le b_n$.\n\nThe MEX (minimum excluded) of an array is the smallest non-negative integer that does not belong to the array. For instance:  The MEX of $[2, 2, 1]$ is $0$, because $0$ does not belong to the array.  The MEX of $[3, 1, 0, 1]$ is $2$, because $0$ and $1$ belong to the array, but $2$ does not.  The MEX of $[0, 3, 1, 2]$ is $4$ because $0$, $1$, $2$ and $3$ belong to the array, but $4$ does not. \n\nIt's worth mentioning that the MEX of an array of length $n$ is always between $0$ and $n$ inclusive.\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 200$)\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($3 \\le n \\le 1000$)\u00a0\u2014 length of the array.\n\nThe second line of each test case contains $n$ integers $a_1, \\ldots, a_n$ ($0 \\le a_i \\le n$)\u00a0\u2014 elements of the array. Note that they don't have to be distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases doesn't exceed $1000$.\n\n\n-----Output-----\n\nFor each test case, you must output two lines:\n\nThe first line must contain a single integer $k$ ($0 \\le k \\le 2n$) \u00a0\u2014 the number of operations you perform.\n\nThe second line must contain $k$ integers $x_1, \\ldots, x_k$ ($1 \\le x_i \\le n$), where $x_i$ is the index chosen for the $i$-th operation.\n\nIf there are many solutions, you can find any of them. Please remember that it is not required to minimize $k$.\n\n\n-----Example-----\nInput\n5\n3\n2 2 3\n3\n2 1 0\n7\n0 7 3 1 3 7 7\n9\n2 0 1 1 2 4 4 2 0\n9\n8 4 7 6 1 2 3 0 5\n\nOutput\n0\n\n2\n3 1\n4\n2 5 5 4\n11\n3 8 9 7 8 5 9 6 4 1 2\n10\n1 8 1 9 5 2 4 6 3 7\n\n\n\n-----Note-----\n\nIn the first test case, the array is already non-decreasing ($2 \\le 2 \\le 3$).\n\nExplanation of the second test case (the element modified by each operation is colored in red):   $a = [2, 1, 0]$ ; the initial MEX is $3$.  $a = [2, 1, \\color{red}{3}]$ ; the new MEX is $0$.  $a = [\\color{red}{0}, 1, 3]$ ; the new MEX is $2$.  The final array is non-decreasing: $0 \\le 1 \\le 3$. \n\nExplanation of the third test case:   $a = [0, 7, 3, 1, 3, 7, 7]$ ; the initial MEX is $2$.  $a = [0, \\color{red}{2}, 3, 1, 3, 7, 7]$ ; the new MEX is $4$.  $a = [0, 2, 3, 1, \\color{red}{4}, 7, 7]$ ; the new MEX is $5$.  $a = [0, 2, 3, 1, \\color{red}{5}, 7, 7]$ ; the new MEX is $4$.  $a = [0, 2, 3, \\color{red}{4}, 5, 7, 7]$ ; the new MEX is $1$.  The final array is non-decreasing: $0 \\le 2 \\le 3 \\le 4 \\le 5 \\le 7 \\le 7$.", "solutions": "[\"def solve():\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    c = [0] * (n + 1)\\n    def inc():\\n        for i in range(n - 1):\\n            if a[i] > a[i + 1]:\\n                return False\\n        return True\\n    def calc():\\n        for i in range(n + 1):\\n            c[i] = 0\\n        for i in a:\\n            c[i] += 1\\n        for i in range(n + 1):\\n            if not c[i]:\\n                return i\\n        return n + 1\\n    ans = []\\n    while not inc():\\n        x = calc()\\n        if x >= n:\\n            y = 0\\n            while y < n and a[y] == y:\\n                y += 1\\n            a[y] = x\\n            ans.append(y)\\n        else:\\n            a[x] = x\\n            ans.append(x)\\n    print(len(ans))\\n    print(*map(lambda x: x + 1, ans))\\n\\nt = int(input())\\nfor _ in range(t):\\n    solve()\", \"# Fast IO (only use in integer input) or take care about string\\n\\n# import os,io\\n# input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    a = list(map(int,input().split()))\\n    operation = []\\n    while True:\\n        isNonDecreasing = True\\n        for i in range(n-1):\\n            if a[i] > a[i+1]:\\n                isNonDecreasing = False\\n                break\\n        if isNonDecreasing:\\n            break\\n        isNIn = [False] * (n + 1)\\n        for elem in a:\\n            isNIn[elem] = True\\n        for i in range(n + 1):\\n            if isNIn[i] == False:\\n                MEX = i\\n                break\\n        if MEX == n:\\n            for i in range(n):\\n                if a[i] != i and a[i] != n:\\n                    break\\n            operation.append(str(i + 1))\\n            a[i] = n\\n        else:\\n            operation.append(str(MEX+1))\\n            a[MEX] = MEX\\n    print(len(operation))\\n    if len(operation) != 0:\\n        print(' '.join(operation))\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"5\\n3\\n2 2 3\\n3\\n2 1 0\\n7\\n0 7 3 1 3 7 7\\n9\\n2 0 1 1 2 4 4 2 0\\n9\\n8 4 7 6 1 2 3 0 5\\n\"\n  ],\n  \"outputs\": [\n    \"0\\n\\n2\\n3 1\\n4\\n2 5 5 4\\n11\\n3 8 9 7 8 5 9 6 4 1 2\\n10\\n1 8 1 9 5 2 4 6 3 7\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1375/D", "starter_code": ""}
{"id": 74, "question": "Polycarp plays a computer game. In this game, the players summon armies of magical minions, which then fight each other.\n\nPolycarp can summon $n$ different minions. The initial power level of the $i$-th minion is $a_i$, and when it is summoned, all previously summoned minions' power levels are increased by $b_i$. The minions can be summoned in any order.\n\nUnfortunately, Polycarp cannot have more than $k$ minions under his control. To get rid of unwanted minions after summoning them, he may destroy them. Each minion can be summoned (and destroyed) only once.\n\nPolycarp's goal is to summon the strongest possible army. Formally, he wants to maximize the sum of power levels of all minions under his control (those which are summoned and not destroyed).\n\nHelp Polycarp to make up a plan of actions to summon the strongest possible army!\n\n\n-----Input-----\n\nThe first line contains one integer $T$ ($1 \\le T \\le 75$) \u2014 the number of test cases.\n\nEach test case begins with a line containing two integers $n$ and $k$ ($1 \\le k \\le n \\le 75$) \u2014 the number of minions availible for summoning, and the maximum number of minions that can be controlled by Polycarp, respectively.\n\nThen $n$ lines follow, the $i$-th line contains $2$ integers $a_i$ and $b_i$ ($1 \\le a_i \\le 10^5$, $0 \\le b_i \\le 10^5$) \u2014 the parameters of the $i$-th minion.\n\n\n-----Output-----\n\nFor each test case print the optimal sequence of actions as follows:\n\nFirstly, print $m$ \u2014 the number of actions which Polycarp has to perform ($0 \\le m \\le 2n$). Then print $m$ integers $o_1$, $o_2$, ..., $o_m$, where $o_i$ denotes the $i$-th action as follows: if the $i$-th action is to summon the minion $x$, then $o_i = x$, and if the $i$-th action is to destroy the minion $x$, then $o_i = -x$. Each minion can be summoned at most once and cannot be destroyed before being summoned (and, obviously, cannot be destroyed more than once). The number of minions in Polycarp's army should be not greater than $k$ after every action.\n\nIf there are multiple optimal sequences, print any of them.\n\n\n-----Example-----\nInput\n3\n5 2\n5 3\n7 0\n5 0\n4 0\n10 0\n2 1\n10 100\n50 10\n5 5\n1 5\n2 4\n3 3\n4 2\n5 1\n\nOutput\n4\n2 1 -1 5\n1\n2\n5\n5 4 3 2 1\n\n\n\n-----Note-----\n\nConsider the example test.\n\nIn the first test case, Polycarp can summon the minion $2$ with power level $7$, then summon the minion $1$, which will increase the power level of the previous minion by $3$, then destroy the minion $1$, and finally, summon the minion $5$. After this, Polycarp will have two minions with power levels of $10$.\n\nIn the second test case, Polycarp can control only one minion, so he should choose the strongest of them and summon it.\n\nIn the third test case, Polycarp is able to summon and control all five minions.", "solutions": "[\"def read_int():\\n    return int(input())\\n\\n\\ndef read_ints():\\n    return list(map(int, input().split(' ')))\\n\\n\\nt = read_int()\\nfor case_num in range(t):\\n    n, k = read_ints()\\n    p = []\\n    for i in range(n):\\n        ai, bi = read_ints()\\n        p.append((bi, ai, i + 1))\\n    p.sort()\\n    dp = [[0 for j in range(k + 1)] for i in range(n + 1)]\\n    use = [[False for j in range(k + 1)] for i in range(n + 1)]\\n    for i in range(1, n + 1):\\n        for j in range(min(i, k) + 1):\\n            if i - 1 >= j:\\n                dp[i][j] = dp[i - 1][j] + (k - 1) * p[i - 1][0]\\n            if j > 0:\\n                x = dp[i - 1][j - 1] + (j - 1) * p[i - 1][0] + p[i - 1][1]\\n                if x > dp[i][j]:\\n                    dp[i][j] = x\\n                    use[i][j] = True\\n    used = []\\n    curr = k\\n    for i in range(n, 0, -1):\\n        if use[i][curr]:\\n            used.append(p[i - 1][2])\\n            curr -= 1\\n    used.reverse()\\n    seq = used[:-1]\\n    st = set(used)\\n    for i in range(1, n + 1):\\n        if not i in st:\\n            seq.append(i)\\n            seq.append(-i)\\n    seq.append(used[-1])\\n    print(len(seq))\\n    print(' '.join(map(str, seq)))\\n\", \"from operator import itemgetter\\nimport sys\\n\\nint1 = lambda x: int(x) - 1\\np2D = lambda x: print(*x, sep=\\\"\\\\n\\\")\\ndef II(): return int(sys.stdin.readline())\\ndef MI(): return map(int, sys.stdin.readline().split())\\ndef LI(): return list(map(int, sys.stdin.readline().split()))\\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\\ndef SI(): return sys.stdin.readline()[:-1]\\n\\ndef main():\\n    inf = 10 ** 9\\n    for _ in range(II()):\\n        n, k = MI()\\n        ab = [(a, b, i) for i, (a, b) in enumerate(LLI(n))]\\n\\n        dp = [[inf] * n for _ in range(k)]\\n        log = [[[] for _ in range(n)] for _ in range(k)]\\n        for e in range(n): dp[0][e] = -ab[e][0]\\n        ab.sort(key=itemgetter(1))\\n        for a, b, i in ab:\\n            for j in range(k - 2, -1, -1):\\n                for e in range(n):\\n                    if i==e:continue\\n                    pre = dp[j][e]\\n                    if pre==inf:continue\\n                    cur = pre + b * (k - 1 - j) - a\\n                    if cur < dp[j + 1][e]:\\n                        dp[j + 1][e] = cur\\n                        log[j+1][e]=log[j][e]+[i]\\n        #print(ab)\\n        #p2D(dp)\\n        #p2D(log)\\n        #print()\\n        mn=mne=inf\\n        for e in range(n):\\n            cur=dp[-1][e]\\n            if cur<mn:\\n                mn=cur\\n                mne=e\\n        first=log[-1][mne]\\n        use=[False]*n\\n        use[mne]=True\\n        ans=[]\\n        for i in first:\\n            ans.append(i+1)\\n            use[i]=True\\n        for i in range(n):\\n            if use[i]:continue\\n            ans.append(i+1)\\n            ans.append(-i-1)\\n        ans.append(mne+1)\\n        print(len(ans))\\n        print(*ans)\\n\\nmain()\\n\", \"import sys\\n\\nreadline = sys.stdin.readline\\nread = sys.stdin.read\\nns = lambda: readline().rstrip()\\nni = lambda: int(readline().rstrip())\\nnm = lambda: map(int, readline().split())\\nnl = lambda: list(map(int, readline().split()))\\nprn = lambda x: print(*x, sep='\\\\n')\\n\\n\\ndef solve():\\n    n, k = nm()\\n    mini = [tuple(nl() + [i+1]) for i in range(n)]\\n    mini.sort(key = lambda x: x[1])\\n    # print(mini)\\n    dp = [-1]*(k+1)\\n    dp[0] = 0\\n    f = [[0]*(k+1) for _ in range(n)]\\n    for i in range(n):\\n        if dp[k] > 0:\\n            dp[k] += (k - 1) * mini[i][1]\\n        for j in range(k-1, -1, -1):\\n            if dp[j] >= 0:\\n                if dp[j+1] < dp[j] + mini[i][0] + j * mini[i][1]:\\n                    dp[j+1] = dp[j] + mini[i][0] + j * mini[i][1]\\n                    f[i][j+1] = 1\\n                dp[j] += (k - 1) * mini[i][1]\\n    \\n    cx = k\\n    a = list()\\n    b = list()\\n    for i in range(n-1, -1, -1):\\n        if f[i][cx]:\\n            a.append(mini[i][2])\\n            cx -= 1\\n        else:\\n            b.append(mini[i][2])\\n    com = list()\\n    for x in a[:0:-1]:\\n        com.append(x)\\n    for x in b:\\n        com.append(x)\\n        com.append(-x)\\n    com.append(a[0])\\n    print(len(com))\\n    print(*com)\\n    return\\n\\nT = ni()\\nfor _ in range(T):\\n    solve()\", \"from typing import List\\nimport sys\\ninput = sys.stdin.readline\\nimport math\\n\\n############ ---- Input Functions ---- ############\\ndef inp():\\n    return(int(input()))\\ndef inlt():\\n    return(list(map(int,input().split())))\\ndef insr():\\n    s = input().strip()\\n    return(list(s[:len(s)]))\\ndef invr():\\n    return(list(map(int,input().strip().split())))\\n\\n\\n\\ndef solve_hungarian(a: List[List[int]], n: int, m: int):\\n    \\\"\\\"\\\"\\n    Implementation of Hungarian algorithm in n^2 m\\n    \\\"\\\"\\\"\\n    # potentials\\n    u = [0] * (n+1)\\n    v = [0] * (m+1)\\n\\n    # pair row of each col\\n    p = [0] * (m+1)\\n\\n    # for each col the number of prev col along the augmenting path\\n    way = [0] * (m+1)\\n\\n\\n    for i in range(1, n+1):\\n        p[0] = i\\n        j0 = 0\\n        minv = [float('inf')] *  (m+1)\\n        used = [False] * (m+1)\\n\\n        # iterative Kun starts here\\n        condition = True\\n        while condition:\\n            # mark the current col as reachable\\n            used[j0] = True\\n            i0 = p[j0]\\n            delta = float('inf')\\n\\n            # determine which col will become reachable after next potential update\\n            for j in range(1, m+1):\\n                if not used[j]:\\n                    cur = a[i0][j] - u[i0]-v[j]\\n                    if cur < minv[j]:\\n                        minv[j] = cur\\n                        way[j] = j0\\n                    if minv[j] < delta:\\n                        delta = minv[j]\\n                        j1 = j\\n                        # j1 will hold the col with min\\n                        # way[j1] - the prev col in dfs\\n\\n            # update the potential\\n            for j in range(0, m+1):\\n                if used[j]: # if col j was discovered:\\n                    u[p[j]] += delta\\n                    v[j] -= delta\\n                else: # not discovered - update min?\\n                    minv[j] -= delta\\n\\n            # j0 becomes the col on which the delta is achieved\\n            j0 = j1\\n            # p[j0] == 0 => j0 - a col not in matching\\n            condition = p[j0] != 0\\n\\n        # the augmenting path was found - update the mapping\\n        condition = True\\n        while condition:\\n\\n            # j1 is the prev column of j0 in augmenting path\\n            j1 = way[j0]\\n            p[j0] = p[j1]\\n            j0 = j1\\n            condition = j0 != 0\\n\\n    ans = [0] * (n+1)\\n    for j in range(1, m+1):\\n        ans[p[j]] = j\\n\\n    return -v[0], ans\\n\\n\\ndef solve(n, k, a, b):\\n    A = [[0] * (n+1) for _ in range(n+1) ]\\n\\n    for i in range(1, n+1):\\n        for j in range(1, k+1):\\n            A[i][j] = a[i] + (j-1) * b[i]\\n        for j in range(k+1, n+1):\\n            A[i][j] = (k-1) * b[i]\\n\\n        # turn into a max problem\\n    for i, row in enumerate(A):\\n        M = max(row)\\n        for j in range(n+1):\\n            A[i][j] = M - A[i][j]\\n\\n    cost, match = solve_hungarian(A, n, n)\\n\\n    print(n + (n-k))\\n\\n    role_to_creature = list(zip(match, list(range(len(match)))))\\n    role_to_creature.sort()\\n\\n    res = []\\n\\n    for index in range(1, k):\\n        res.append(role_to_creature[index][1])\\n\\n    for index in range(k+1, n+1):\\n        res.append(role_to_creature[index][1])\\n        res.append(-role_to_creature[index][1])\\n    res.append(role_to_creature[k][1])\\n    print(\\\" \\\".join(map(str, res)))\\n\\n\\n\\n\\ndef from_file(f):\\n    return f.readline\\n\\n\\n# with open('test.txt') as f:\\n#     input = from_file(f)\\nt = inp()\\nfor _ in range(t):\\n    n, k = invr()\\n    a = [0]\\n    b = [0]\\n    for _ in range(n):\\n        ai, bi = invr()\\n        a.append(ai)\\n        b.append(bi)\\n    solve(n, k, a, b)\\n\\n\\n\\n\\n\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n5 2\\n5 3\\n7 0\\n5 0\\n4 0\\n10 0\\n2 1\\n10 100\\n50 10\\n5 5\\n1 5\\n2 4\\n3 3\\n4 2\\n5 1\\n\"\n  ],\n  \"outputs\": [\n    \"8\\n5 1 -1 3 -3 4 -4 2 \\n3\\n1 -1 2 \\n5\\n5 4 3 2 1 \\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1354/F", "starter_code": ""}
{"id": 75, "question": "The statement of this problem is the same as the statement of problem C1. The only difference is that, in problem C1, $n$ is always even, and in C2, $n$ is always odd.\n\nYou are given a regular polygon with $2 \\cdot n$ vertices (it's convex and has equal sides and equal angles) and all its sides have length $1$. Let's name it as $2n$-gon.\n\nYour task is to find the square of the minimum size such that you can embed $2n$-gon in the square. Embedding $2n$-gon in the square means that you need to place $2n$-gon in the square in such way that each point which lies inside or on a border of $2n$-gon should also lie inside or on a border of the square.\n\nYou can rotate $2n$-gon and/or the square.\n\n\n-----Input-----\n\nThe first line contains a single integer $T$ ($1 \\le T \\le 200$)\u00a0\u2014 the number of test cases.\n\nNext $T$ lines contain descriptions of test cases\u00a0\u2014 one per line. Each line contains single odd integer $n$ ($3 \\le n \\le 199$). Don't forget you need to embed $2n$-gon, not an $n$-gon.\n\n\n-----Output-----\n\nPrint $T$ real numbers\u00a0\u2014 one per test case. For each test case, print the minimum length of a side of the square $2n$-gon can be embedded in. Your answer will be considered correct if its absolute or relative error doesn't exceed $10^{-6}$.\n\n\n-----Example-----\nInput\n3\n3\n5\n199\n\nOutput\n1.931851653\n3.196226611\n126.687663595", "solutions": "[\"import math\\n\\nT = int(input())\\nfor _ in range(T):\\n    n = int(input())\\n    diags = 1/math.sin(math.pi/2/n)\\n    print(diags * math.cos(math.pi/4/n))\\n\", \"import math\\nimport sys\\n\\n#sys.stdin = open(\\\"in.txt\\\")\\n\\nt = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    n *= 2\\n    a = (n - 2) * math.pi / n / 2\\n    r = 1/2 / math.cos(a)\\n    a2 = (math.pi/2 - a) / 2\\n    r2 = r * math.cos(a2)\\n    print(r2*2)\\n\", \"import sys\\nimport math\\n\\nreadline = sys.stdin.readline\\nread = sys.stdin.read\\nns = lambda: readline().rstrip()\\nni = lambda: int(readline().rstrip())\\nnm = lambda: map(int, readline().split())\\nnl = lambda: list(map(int, readline().split()))\\nprn = lambda x: print(*x, sep='\\\\n')\\n\\n\\ndef solve():\\n    n = ni()\\n    print(math.cos(math.pi / (4 * n)) / math.sin(math.pi / (2 * n)))\\n    return\\n\\n\\n# solve()\\n\\nT = ni()\\nfor _ in range(T):\\n    solve()\\n\", \"import math\\n\\ndef sqare_size(n):\\n    return math.sin((2*n-1)/(4*n)*math.pi)/math.sin(math.pi/(2*n))\\n\\nt = int(input())\\nfor _ in range(t):\\n    print(sqare_size(int(input())))\\n\", \"import sys\\nimport math\\n\\ninput = sys.stdin.readline\\nflush = sys.stdout.flush\\n\\nfor _ in range(int(input())):\\n\\tn = int(input())\\n\\tprint(2.0 * math.cos(math.pi / (4.0 * n)) / (2.0 * math.sin(math.pi / (2.0 * n))))\\n\", \"# cook your dish here\\n# import sys\\n# sys.stdin = open('input.txt', 'r') \\n# sys.stdout = open('output.txt', 'w')\\n\\nimport math\\nimport collections\\nfrom sys import stdin,stdout,setrecursionlimit\\nimport bisect as bs\\nT = int(stdin.readline())\\n\\nfor _ in range(T):\\n    n = int(stdin.readline())\\n    # a,b,c,d = list(map(int,stdin.readline().split()))\\n    # h = list(map(int,stdin.readline().split()))\\n    # b = list(map(int,stdin.readline().split()))\\n    # a = stdin.readline().strip('\\\\n')\\n    t = 2*n\\n    x = math.pi/(2*t)\\n    h = 0.5 / (math.sin(x))\\n    print(round(h,7))\", \"import sys\\nfrom math import tan, pi, cos, sin\\n\\n_INPUT_LINES = sys.stdin.read().splitlines()\\ninput = iter(_INPUT_LINES).__next__\\nfrom itertools import islice, cycle\\n\\n\\ndef go():\\n    n = int(input())\\n    # a,b,c,d = map(int, input().split())\\n    # a = list(map(int, input().split()))\\n    # s = input()\\n    nn = 2*n\\n    pin = pi/nn\\n    l,r = 0, pin\\n    for i in range(100):\\n        c = (l+r)/2\\n        if cos(c)-(cos(pin-c))>0:\\n            l=c\\n        else:\\n            r=c\\n    return cos(c)/(sin(pin))\\n\\n\\n# x,s = map(int,input().split())\\nt = int(input())\\n# t = 1\\nans = []\\nfor _ in range(t):\\n    # print(go())\\n    ans.append(str(go()))\\n#\\nprint('\\\\n'.join(ans))\\n\", \"from math import pi, sin, cos\\n\\nT = int(input().strip())\\nfor t in range(T):\\n    n = int(input().strip())\\n    alpha = pi/n\\n    R = 1/(2*sin(alpha/2))\\n    if n %2 ==0:\\n        gamma = alpha/2\\n    else:\\n        k = n//2\\n        gamma = (pi/2 - alpha*k)/2\\n\\n    # print(alpha*180/pi)\\n    # print(gamma * 180 / pi)\\n    res = R* 2*cos(gamma)\\n    print(res)\", \"import math\\n\\nt=int(input())\\n\\nwhile(t):\\n\\tt-=1\\n\\tn=int(input())\\n\\n\\tang= math.pi/(2*n)\\n\\n\\tans= 1/math.sin(ang)\\n\\tprint(ans*math.cos(ang/2))\", \"from math import*\\nfor _ in range(int(input())):\\n  n=int(input())\\n  if n%2==0:print(1/tan(radians(90/n)))\\n  else:print(cos(radians(45/n))/sin(radians(90/n)))\", \"import math\\n# your code goes here\\nfor _ in range(int(input())):\\n\\tn=2*int(input())\\n\\tprint(math.cos(math.pi/(2*n))/math.sin(math.pi/n))\", \"import math\\nimport sys\\ninput = sys.stdin.readline\\n\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    theta = 2 * n\\n    y = 1 / math.sin(math.radians(360 / 4 / n)) / 2\\n    p = [(0, y)]\\n    \\n    rot45 =  [math.cos(math.radians(45)), -math.sin(math.radians(45))], [math.sin(math.radians(45)), math.cos(math.radians(45))]\\n    tmp = p[-1]\\n    x = rot45[0][0] * tmp[0] + rot45[0][1] * tmp[1]\\n    y = rot45[1][0] * tmp[0] + rot45[1][1] * tmp[1]\\n    p[0] = (x, y)\\n    the = 360 / (2 * n) \\n    rot = [math.cos(math.radians(the)), -math.sin(math.radians(the))], [math.sin(math.radians(the)), math.cos(math.radians(the))]\\n    max_x = 0\\n    max_y = 0\\n    for i in range(2 * n - 1):\\n        tmp = p[-1]\\n        x = rot[0][0] * tmp[0] + rot[0][1] * tmp[1]\\n        y = rot[1][0] * tmp[0] + rot[1][1] * tmp[1]\\n        max_x = max(abs(x), max_x)\\n        max_y = max(abs(y), max_y)\\n        p.append((x, y))\\n    print(2 * max_x)\\n\", \"import os\\nimport sys\\nif os.path.exists('/mnt/c/Users/Square/square/codeforces'):\\n    f = iter(open('D.txt').readlines())\\n    def input():\\n        return next(f).strip()\\n    # input = lambda: sys.stdin.readline().strip()  \\nelse:\\n    input = lambda: sys.stdin.readline().strip()\\n\\nfprint = lambda *args: print(*args, flush=True)\\n\\nimport math\\n\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    # print(1.0 / math.tan(math.pi / 2 / n))\\n    a = math.pi / 2 / n\\n    tmp = 0.5 / math.sin(a)\\n    \\n    # def func(phi):\\n    #     return max(math.cos(phi), math.cos(a-phi))\\n\\n    # l, r = 0, a\\n    # while l - r > 1e-10:\\n    #     u = func(l)\\n    #     v = func(r)\\n    #     x = func((l*2+r*1)/3)\\n    #     y = func((l*1+r*2)/3)\\n\\n    #     if x < y:\\n    #         r = (l*2+r*1)/3\\n    #     else:\\n    #         l = (l*1+r*2)/3\\n    print(tmp * math.cos(a/2)*2)\\n    # print(n, tmp * func(0))\\n    # print(tmp * math.cos(0), tmp * math.cos(a-0))\\n    # print(tmp * func(l))\\n    # print()\", \"from math import sin, tan, cos, pi\\n\\nfor t in range(int(input())):\\n    n = int(input())\\n    if n % 2 == 0:\\n        print(1 / tan(pi / (2 * n)))\\n    else:\\n        #print(1 + 1 / tan(pi / (2 * n)) / 2 ** 0.5)\\n        print(1 / sin(pi / (2 * n)) * cos(pi / (4 * n)))\", \"t = int(input())\\n\\nimport math\\n\\nans=[0]*t\\n\\nfor i in range(t):\\n  n=int(input())\\n  theta=90/n\\n  temp=1/math.sin(math.radians(theta))\\n  ans[i]=temp*math.cos(math.radians(theta/2))\\n\\n\\nfor i in range(t):\\n  print(format(ans[i], '.9f'))\", \"import sys\\nfrom math import pi, sin\\ndef I():\\n    return sys.stdin.readline().rstrip()\\n\\ndef h(n):\\n    m = n // 2 - 0.5\\n    a = 1\\n    return a * sin(pi * m / n) / sin(pi / n)\\n\\ndef main():\\n    for tc in range(1, 1+int(I())):\\n        n = int(I())\\n        n *= 2\\n        print(h(n))\\n\\nmain()\\n\", \"from math import sin, pi, sqrt, tan\\n\\n\\ndef read_int():\\n    return int(input())\\n\\n\\ndef read_ints():\\n    return list(map(int, input().split(' ')))\\n\\n\\nt = read_int()\\nfor case_num in range(t):\\n    n = read_int()\\n    angle = pi / n / 2\\n    r = 0.5 / sin(angle)\\n    a = 0\\n    for i in range(1, n // 2 + 1):\\n        A = 3 * pi / 4 - i * pi / n\\n        a = max(a, 2 * r * sin(A))\\n    print('{:.9f}'.format(a))\\n\", \"from math import cos, pi, sin, sqrt\\n\\nfor _ in range(int(input())):\\n    n = int(input())\\n    k0 = (n + 2) // 4\\n    alpha = k0 * pi / n\\n    print((sin(alpha) + cos(alpha)) / (sqrt(2) * sin(pi / (2 * n))))\\n\", \"from math import radians,sin,cos\\nt = int(input())\\n\\nfor _ in range(t):\\n    n = int(input())\\n    alpha = radians(90/n)\\n    r = 0.5/(sin(alpha))\\n    beta = 180*(n//2)/n\\n    gamma = radians((90-beta)/2)\\n    d = r*cos(gamma)\\n    print(2*d)\", \"import math\\n\\nT = int(input())\\nfor _ in range(T):\\n\\tn = int(input())\\n\\tth = math.pi / (2*n)\\n\\tl = 1. / math.sin(th)\\n\\tth1 = (n // 2) * (2*th)\\n\\tth = math.atan((1 - math.sin(th1)) / math.cos(th1))\\n\\tres = l*math.cos(th)\\n\\tprint(res)\\n\\t# print(math.cos(th), math.sin(th+th1), th1, l, math.pi/3)\\n\", \"import math\\n\\ndef solve(n):\\n    if n == 2:\\n        return 1.0\\n    each_angle = math.pi / n\\n    height = 0\\n    width = 0\\n    for i in range(n):\\n        angle = each_angle * i\\n        height += math.sin(angle) * 1.0\\n        width += abs(math.cos(angle)) * 1.0\\n    if width > height:\\n        sectors = n // 2\\n        angle = each_angle * (0.5 + sectors / 2) - math.pi / 4\\n        ans = width * math.cos(angle)\\n    else:\\n        ans = height\\n    # print(height, width, ans)\\n    return ans\\n\\ndef main():\\n    T = int(input())\\n    for _ in range(1, T + 1):\\n        n = int(input())\\n        print(solve(n))\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"from math import sin, pi, cos\\ndef solve():\\n    n = int( input())\\n    return(cos(pi/(4*n))/sin(pi/(2*n)))\\n    \\ndef main():\\n    t = int( input())\\n    print(\\\"\\\\n\\\".join( map( str, [ solve() for _ in range(t)])))\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import math\\n\\nfor _ in range(int(input())):\\n    n=int(input())\\n    s=2*n\\n    #side = (((1/2*(math.sin(math.pi/(2*s))))**2)-1)**.5\\n    side = 1/(2*(math.sin(math.pi/(2*s))))\\n    print(side)\", \"import math\\nq = int(input())\\nfor _ in range(q):\\n\\tn = int(input())\\n\\talfa = 3*math.pi/4 - ((n//2)*math.pi/(2*n))\\n\\ty = math.tan(math.pi/2-math.pi/(2*n))\\n\\tx = y/math.cos(math.pi/(2*n))\\n\\tbok = math.sin(alfa)*x\\n\\tprint(bok)\", \"import math\\nPI = math.pi\\n\\ndef radius(n):\\n    return 0.5/math.sin(PI/(2*n))\\n\\ndef chord(num_sides, n):\\n    return 2*radius(n)*math.sin((PI*num_sides)/(2*n))\\n\\nt = int(input())\\n\\nfor i in range(t):\\n    n = int(input())\\n    x = int(n/2)+1\\n    y = int(n/2)\\n    print(chord(x,n)/math.sqrt(2)+chord(y,n)/math.sqrt(2))\", \"\\n\\n# for n in range(3, 200, 2):\\n\\n#     N = 2 * n\\n\\n#     alpha = (2 * pi) / (2 * n)\\n#     beta = (pi - alpha) / 2\\n\\n#     L = sin(beta) / sin(alpha)\\n\\n#     ans = 10 ** 10\\n#     MAX = 1000\\n#     for i in range(MAX):\\n#         t0 = alpha * i / MAX\\n\\n#         xx = []\\n#         yy = []\\n#         for i in range(N):\\n#             t = alpha * i + t0\\n#             x, y = L * cos(t), L * sin(t)\\n#             xx.append(x)\\n#             yy.append(y)\\n\\n#         tmpr = max(max(xx) - min(xx), max(yy) - min(yy))\\n#         ans = min(ans, tmpr)\\n\\n#     print(f\\\"{n} : {ans},\\\")\\n\\n\\nans = {3: 1.931851652578137,\\n       5: 3.1962266107498305,\\n       7: 4.465702135190254,\\n       9: 5.736856622834928,\\n       11: 7.00877102284205,\\n       13: 8.281093789118495,\\n       15: 9.553661304648701,\\n       17: 10.826387080174316,\\n       19: 12.099221090606225,\\n       21: 13.372132387773904,\\n       23: 14.64510079714694,\\n       25: 15.918112604548812,\\n       27: 17.191158161652254,\\n       29: 18.464230483075124,\\n       31: 19.737324386897843,\\n       33: 21.010435947900465,\\n       35: 22.283562138356153,\\n       37: 23.556700585376017,\\n       39: 24.829849402946724,\\n       41: 26.10300707314532,\\n       43: 27.376172360514047,\\n       45: 28.649344249275092,\\n       47: 29.922521896579926,\\n       49: 31.195704597210476,\\n       51: 32.46889175658776,\\n       53: 33.742082869893075,\\n       55: 35.015277505745324,\\n       57: 36.28847529331536,\\n       59: 37.561675912061524,\\n       61: 38.8348790834848,\\n       63: 40.10808456445453,\\n       65: 41.38129214176658,\\n       67: 42.65450162767617,\\n       69: 43.927712856207805,\\n       71: 45.20092568008886,\\n       73: 46.47413996818731,\\n       75: 47.747355603359544,\\n       77: 49.02057248063344,\\n       79: 50.29379050566765,\\n       81: 51.56700959343902,\\n       83: 52.84022966711982,\\n       85: 54.1134506571136,\\n       87: 55.386672500223845,\\n       89: 56.659895138934914,\\n       91: 57.93311852078775,\\n       93: 59.20634259783608,\\n       95: 60.47956732617132,\\n       97: 61.75279266550647,\\n       99: 63.026018578810074,\\n       101: 64.29924503198401,\\n       103: 65.57247199357865,\\n       105: 66.84569943454059,\\n       107: 68.11892732798874,\\n       109: 69.39215564901495,\\n       111: 70.66538437450639,\\n       113: 71.93861348298648,\\n       115: 73.21184295447279,\\n       117: 74.4850727703492,\\n       119: 75.75830291325114,\\n       121: 77.03153336696215,\\n       123: 78.3047641163205,\\n       125: 79.57799514713487,\\n       127: 80.85122644610789,\\n       129: 82.12445800076682,\\n       131: 83.39768979940062,\\n       133: 84.67092183100281,\\n       135: 85.94415408521901,\\n       137: 87.21738655229956,\\n       139: 88.49061922305593,\\n       141: 89.76385208882093,\\n       143: 91.0370851414123,\\n       145: 92.31031837309914,\\n       147: 93.58355177657134,\\n       149: 94.85678534491129,\\n       151: 96.13001907156787,\\n       153: 97.40325295033253,\\n       155: 98.67648697531708,\\n       157: 99.94972114093346,\\n       159: 101.22295544187476,\\n       161: 102.49618987309775,\\n       163: 103.76942442980673,\\n       165: 105.04265910743855,\\n       167: 106.31589390164861,\\n       169: 107.58912880829797,\\n       171: 108.8623638234414,\\n       173: 110.13559894331603,\\n       175: 111.40883416433105,\\n       177: 112.68206948305792,\\n       179: 113.95530489622139,\\n       181: 115.22854040069092,\\n       183: 116.50177599347283,\\n       185: 117.77501167170294,\\n       187: 119.04824743263957,\\n       189: 120.32148327365705,\\n       191: 121.5947191922398,\\n       193: 122.86795518597636,\\n       195: 124.14119125255439,\\n       197: 125.41442738975526,\\n       199: 126.68766359544964,\\n       }\\n\\n\\nT = int(input())\\n\\nfor t in range(T):\\n    n = int(input())\\n    print(ans[n])\\n\", \"import math\\ndef rad(angle) :\\n\\treturn (angle / 180) * math.pi\\ndef dist(a, b, c, d) :\\n\\treturn math.sqrt((a - c) * (a - c) + (b - d) * (b - d))\\ntt = int(input())\\nwhile tt > 0 :\\n\\ttt -= 1\\n\\tn = int(input())\\n\\tangle = rad(360 / (2 * n))\\n\\tl1, l2 = n // 2, n - n // 2\\n\\tpx, py = 0, 0\\n\\tvx, vy = 1, 0\\n\\tans = 0\\n\\tcur = 0\\n\\tfor i in range(1, n + 1) :\\n\\t\\tpx += vx\\n\\t\\tpy += vy\\n\\t\\tif i == l1 or i == l2 :\\n\\t\\t\\tans += dist(0, 0, px, py)\\n\\t\\tcur += angle\\n\\t\\tvx = math.cos(cur)\\n\\t\\tvy = math.sin(cur)\\n\\tprint(ans / math.sqrt(2))\", \"import math\\nT = int(input())\\n\\nwhile T !=0:\\n    n = int(input())\\n\\n    side = math.sin(math.pi/(4*n)) * 2\\n    print(1/side)\\n    \\n    T -= 1\", \"from math import sin, pi\\nt = int(input())\\nwhile t!=0:\\n    t-=1 \\n    n = int(input())\\n    k = 1/(sin(pi/(4*n)))\\n    print(k/2)\\n        \\n\\n\", \"import math\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    print(\\\"{:.10f}\\\".format(math.cos(math.pi/(4*n))/math.sin(math.pi/(2*n))))\\n    \\n\", \"from sys import stdin\\nfrom math import cos,sin,radians\\nimport math\\ninp = lambda: stdin.readline().strip()\\n\\n# [int(x) for x in inp().split()]\\n\\n\\ndef diagonal(x):\\n    return 1/(2*sin(radians(90/x)))\\n\\n\\nt = int(inp())\\nfor _ in range(t):\\n    n = int(inp())\\n    # f = (diagonal(2*n)**2)**(1/2)\\n    print(diagonal(2*n))\", \"from math import sin, cos, pi\\n\\nn = int(input())\\n\\ndef f(a, b):\\n    return sin((b * pi) / a) / sin(pi / a)\\n\\nfor _ in range(n):\\n    m = int(input())\\n    print(\\\"%.12f\\\" % (f(2 * m, m) * cos(pi / (4 * m))))\\n\", \"#!/usr/bin/env python3\\nimport sys\\ninput = sys.stdin.readline\\nimport math\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    a = 1.0 / (2.0 * math.tan(math.pi / (n * 2)))\\n    b = 1.0 * math.sin(math.pi / 2.0) / (math.sin(math.pi / (n * 2)))\\n    if n % 2 == 0:\\n        print(a * 2.0)\\n    else:\\n        rotation = [math.pi * 2.0 / (2 * n) * item for item in range(2 * n)]\\n        l = 0.0; r = math.pi / 2.0 \\n        eps_rot = [(math.pi * 2.0 / (2 * n) / 10**2) * item for item in range(10**2)]\\n        ret = b\\n        for eps in eps_rot:\\n            max_rad = 0.0 \\n            for rad in rotation:\\n                val = max(b * abs(math.sin(rad + eps)), b * abs(math.cos(rad + eps)))\\n                max_rad = max(max_rad, val)\\n            ret = min(ret, max_rad)\\n        print(ret)\", \"import math\\n\\nT = int(input())\\n\\nfor _ in range(T):\\n    N = int(input())\\n    v1 = complex(1, 0)\\n    angle = (N//2)*(math.pi/N)\\n    v2 = complex(math.cos(angle), math.sin(angle))\\n    print(math.sqrt(2) * 0.5 * (abs(v1+v2) + abs(v1-v2)) * (1/(2*math.sin(math.pi/(2*N)))))\\n\", \"import math\\n\\nMIN_INF, MAX_INF = float('-inf'), float('inf')\\n\\ndef get_len(n, R, alpha, beta):\\n    maxx, maxy = MIN_INF, MIN_INF\\n    minx, miny = MAX_INF, MAX_INF\\n    d = MAX_INF\\n    for i in range(n):\\n        theta = alpha * i + beta\\n        x = math.cos(theta) * R\\n        y = math.sin(theta) * R\\n        maxx = max(x, maxx)\\n        maxy = max(y, maxy)\\n        minx = min(x, minx)\\n        miny = min(y, miny)\\n    d = min(d, max(abs(maxx - minx), abs(maxy - miny)))\\n    return d\\n\\ndef main():\\n    T = int(input())\\n    for t in range(T):\\n        n = int(input()) * 2\\n\\n        alpha = 2 * math.pi / n\\n        R = 1.0 / 2.0 / (math.sin(math.pi / n))\\n\\n        # ans = float('inf')\\n\\n        # a, b = 0, alpha\\n        # va, vb = get_len(n, R, alpha, a), get_len(n, R, alpha, b)\\n\\n        print(get_len(n, R, alpha, alpha / 4))\\n\\n        # while True:\\n        #     d3 = (b - a) / 3\\n        #     c, d = a + d3, b - d3\\n        #     vc, vd = get_len(n, R, alpha, c), get_len(n, R, alpha, d)\\n\\n        #     if abs(vc - vd) < 1e-10:\\n        #         print(n, R, alpha, c, vc)\\n        #         break\\n\\n        #     if vc < vd:\\n        #         b, vb = d, vd\\n        #     else:\\n        #         a, va = c, vc\\n\\nmain()\", \"import math\\nfor _ in range(int(input())):\\n    n = int(input())\\n    n = 2*n\\n    L = (1/math.sin(math.pi/(2*n)))*abs(math.sin(math.pi*(n-1)/4*n))\\n    print(L/2)\\n\", \"from math import pi,sin\\ndef solve(n):\\n    r= pi/(4*n)\\n    m= 1/sin(r)\\n    return round(m/2,9)\\n    \\nfor _ in range(int(input())):\\n    n= int(input())\\n    print(solve(n))\", \"import math\\nfor ad in range(int(input())):\\n    n=int(input())\\n    n*=2\\n    t=math.pi/n\\n    x=math.cos(t/2)/(2*math.sin(t))\\n    print(2*x)\", \"import math\\nfrom sys import stdin, stdout\\nfor _ in range(int(stdin.readline().strip())):\\n    n = 2*int(stdin.readline().strip())\\n    ans = 1/((math.sin(math.radians(90/n))))\\n    print(\\\"{0:.9f}\\\".format(ans/2))\", \"import math\\ndef solve(n):\\n    alpha = 2*math.pi/(4*n)\\n    ratio = math.sin(alpha)\\n    half = 0.5/ratio\\n    ag = 180/(4*n)\\n    ag = ag*2*math.pi/360\\n    return half*2*math.cos(ag)\\nt = int(input())\\nfor _ in range(t):\\n    s = int(input())\\n    print(solve(s))\\n    \\n\"]", "input_output": "{\"inputs\": [\"3\\n3\\n5\\n199\\n\"], \"outputs\": [\"1.931851653\\n3.196226611\\n126.687663595\\n\"]}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1354/C2", "starter_code": ""}
{"id": 76, "question": "Lee is going to fashionably decorate his house for a party, using some regular convex polygons...\n\nLee thinks a regular $n$-sided (convex) polygon is beautiful if and only if he can rotate it in such a way that at least one of its edges is parallel to the $OX$-axis and at least one of its edges is parallel to the $OY$-axis at the same time.\n\nRecall that a regular $n$-sided polygon is a convex polygon with $n$ vertices such that all the edges and angles are equal.\n\nNow he is shopping: the market has $t$ regular polygons. For each of them print YES if it is beautiful and NO otherwise.\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of polygons in the market. \n\nEach of the next $t$ lines contains a single integer $n_i$ ($3 \\le n_i \\le 10^9$): it means that the $i$-th polygon is a regular $n_i$-sided polygon. \n\n\n-----Output-----\n\nFor each polygon, print YES if it's beautiful or NO otherwise (case insensitive).\n\n\n-----Example-----\nInput\n4\n3\n4\n12\n1000000000\n\nOutput\nNO\nYES\nYES\nYES\n\n\n\n-----Note-----\n\nIn the example, there are $4$ polygons in the market. It's easy to see that an equilateral triangle (a regular $3$-sided polygon) is not beautiful, a square (a regular $4$-sided polygon) is beautiful and a regular $12$-sided polygon (is shown below) is beautiful as well. [Image]", "solutions": "[\"t = int(input())\\n\\nfor _ in range(t):\\n    n = int(input())\\n    if n%4 == 0:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"for _ in range(int(input())):\\n    # a, b = map(int, input().split())\\n    n = int(input())\\n    # arr = list(map(int, input().split()))\\n    if n % 4 == 0:\\n        print('YES')\\n    else:\\n        print('NO')\\n\", \"t11 = int(input())\\nfor _ in range(t11):\\n    a = int(input())\\n    if a % 4 == 0:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"import math as ma\\n# import sys\\n# input=sys.stdin.readline\\n\\nt=int(input())\\nfor _ in range(t):\\n    n=int(input())\\n    if n%4==0:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"t11 = int(input())\\nfor _ in range(t11):\\n    n = int(input())\\n    if n % 4 == 0:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"import math\\nt = int(input())\\nfor g in range(t):\\n    n = int(input())\\n    if(n%4==0):\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"for _ in range(int(input())):\\n    if int(input()) % 4 == 0:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"import math\\nt = int(input())\\nfor helloworld in range(t):\\n\\tn = int(input())\\n\\tif n % 4 == 0:\\n\\t\\tprint('YES')\\n\\telse:\\n\\t\\tprint('NO')\", \"for nt in range(int(input())):\\n\\tn = int(input())\\n\\tif n%4==0:\\n\\t\\tprint (\\\"YES\\\")\\n\\telse:\\n\\t\\tprint (\\\"NO\\\")\", \"import sys\\n\\ndef ii():\\n    return sys.stdin.readline().strip()\\n\\ndef idata():\\n    return [int(x) for x in ii().split()]\\n\\ndef solve():\\n    n = int(ii())\\n    if n % 4 == 0:\\n        print('YES')\\n    else:\\n        print('NO')\\n    return\\n\\nfor t in range(int(ii())):\\n    solve()\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    if n % 4 == 0:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"from math import *\\n\\ndef r1(t):\\n    return t(input())\\n\\ndef r2(t):\\n    return [t(i) for i in input().split()]\\n\\nfor _ in range(r1(int)):\\n    n = r1(int)\\n    if n % 4 == 0:\\n        print('YES')\\n    else:\\n        print('NO')\\n\", \"t=int(input())\\nfor i in range(t):\\n    n=int(input())\\n    if n%4==0:\\n        print('YES')\\n    else:\\n        print('NO')\", \"t = int(input())\\nfor q in range(t):\\n    n = int(input())\\n    if n % 4 == 0:\\n        print('YES')\\n    else:\\n        print('NO')\", \"import sys\\ndef second(ele):\\n    return(ele[1])\\nfor _ in range(int(input())):\\n    n = int(input())\\n    if(n%4==0):\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"def read_int():\\n    return int(input())\\n\\n\\ndef read_ints():\\n    return list(map(int, input().split(' ')))\\n\\n\\nt = read_int()\\nfor case_num in range(t):\\n    n = read_int()\\n    print('YES' if n % 4 == 0 else 'NO')\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    if(n%4==0):\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\nfor tests in range(t):\\n    n=int(input())\\n    if n%4==0:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"from sys import stdin, stdout\\nimport math\\n\\nt = int(stdin.readline())\\nfor _ in range(t):\\n    n = int(stdin.readline())\\n    print(\\\"YES\\\" if n%4==0 else \\\"NO\\\")\\n\", \"t=int(input())\\nfor i in range(t):\\n    n=int(input())\\n    if n%4==0:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n    \\n    \\n\", \"for _ in range(int(input())):\\n    a=int(input())\\n    if a%4==0: print(\\\"YES\\\")\\n    else: print(\\\"NO\\\")\\n\", \"def solve():\\n    n = int(input())\\n    if n % 4 == 0:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\\n\\nfor i in range(int(input())):\\n    solve()\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n3\\n4\\n12\\n1000000000\\n\"\n  ],\n  \"outputs\": [\n    \"NO\\nYES\\nYES\\nYES\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1369/A", "starter_code": ""}
{"id": 77, "question": "You have a fence consisting of $n$ vertical boards. The width of each board is $1$. The height of the $i$-th board is $a_i$. You think that the fence is great if there is no pair of adjacent boards having the same height. More formally, the fence is great if and only if for all indices from $2$ to $n$, the condition $a_{i-1} \\neq a_i$ holds.\n\nUnfortunately, it is possible that now your fence is not great. But you can change it! You can increase the length of the $i$-th board by $1$, but you have to pay $b_i$ rubles for it. The length of each board can be increased any number of times (possibly, zero).\n\nCalculate the minimum number of rubles you have to spend to make the fence great again!\n\nYou have to answer $q$ independent queries.\n\n\n-----Input-----\n\nThe first line contains one integer $q$ ($1 \\le q \\le 3 \\cdot 10^5$) \u2014 the number of queries.\n\nThe first line of each query contains one integers $n$ ($1 \\le n \\le 3 \\cdot 10^5$) \u2014 the number of boards in the fence.\n\nThe following $n$ lines of each query contain the descriptions of the boards. The $i$-th line contains two integers $a_i$ and $b_i$ ($1 \\le a_i, b_i \\le 10^9$) \u2014 the length of the $i$-th board and the price for increasing it by $1$, respectively.\n\nIt is guaranteed that sum of all $n$ over all queries not exceed $3 \\cdot 10^5$.\n\nIt is guaranteed that answer to each query will not exceed $10^{18}$.\n\n\n-----Output-----\n\nFor each query print one integer \u2014 the minimum number of rubles you have to spend to make the fence great.\n\n\n-----Example-----\nInput\n3\n3\n2 4\n2 1\n3 5\n3\n2 3\n2 10\n2 6\n4\n1 7\n3 3\n2 6\n1000000000 2\n\nOutput\n2\n9\n0\n\n\n\n-----Note-----\n\nIn the first query you have to increase the length of second board by $2$. So your total costs if $2 \\cdot b_2 = 2$.\n\nIn the second query you have to increase the length of first board by $1$ and the length of third board by $1$. So your total costs if $1 \\cdot b_1 + 1 \\cdot b_3 = 9$.\n\nIn the third query the fence is great initially, so you don't need to spend rubles.", "solutions": "[\"3\\n\\nimport math\\nimport os\\nimport sys\\n\\n\\nDEBUG = 'DEBUG' in os.environ\\n\\n\\ndef inp():\\n    return sys.stdin.readline().rstrip()\\n\\n\\ndef dprint(*value, sep=' ', end='\\\\n'):\\n    if DEBUG:\\n        print(*value, sep=sep, end=end)\\n\\n\\nINF = 10 ** 20\\n\\n\\ndef solve(N, A, B):\\n    dp = {A[0]: 0, A[0] + 1: B[0], A[0] + 2: B[0] * 2}\\n    for i in range(1, N):\\n        ndp = {}\\n\\n        h = A[i]\\n        for ph, c in dp.items():\\n            for inc in range(3):\\n                nh = h + inc\\n                if ph == nh:\\n                    continue\\n                if nh not in ndp:\\n                    ndp[nh] = INF\\n                ndp[nh] = min(ndp[nh], c + B[i] * inc)\\n\\n        dp = ndp\\n\\n    return min(dp.values())\\n\\n\\ndef main():\\n    Q = int(inp())\\n    for _ in range(Q):\\n        N = int(inp())\\n        A = []\\n        B = []\\n        for _ in range(N):\\n            a, b = [int(e) for e in inp().split()]\\n            A.append(a)\\n            B.append(b)\\n        print(solve(N, A, B))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import sys\\ninput = sys.stdin.readline\\n\\nq=int(input())\\n\\nfor testcases in range(q):\\n    n=int(input())\\n    f=[tuple(map(int,input().split())) for i in range(n)]\\n\\n    \\n    DP0=[0]*n\\n    DP1=[0]*n\\n    DP2=[0]*n\\n\\n    DP1[0]=f[0][1]\\n    DP2[0]=f[0][1]*2\\n\\n    for i in range(1,n):\\n        x=f[i-1][0]\\n        y=f[i][0]\\n\\n        if y==x:\\n            DP0[i]=min(DP1[i-1],DP2[i-1])\\n            DP1[i]=f[i][1]+min(DP0[i-1],DP2[i-1])\\n            DP2[i]=f[i][1]*2+min(DP0[i-1],DP1[i-1])\\n\\n        elif y==x+1:\\n            DP0[i]=min(DP0[i-1],DP2[i-1])\\n            DP1[i]=f[i][1]+min(DP0[i-1],DP1[i-1])\\n            DP2[i]=f[i][1]*2+min(DP0[i-1],DP1[i-1],DP2[i-1])\\n\\n        elif y==x+2:\\n            DP0[i]=min(DP0[i-1],DP1[i-1])\\n            DP1[i]=f[i][1]+min(DP0[i-1],DP1[i-1],DP2[i-1])\\n            DP2[i]=f[i][1]*2+min(DP0[i-1],DP1[i-1],DP2[i-1])\\n\\n        elif y==x-1:\\n            DP0[i]=min(DP0[i-1],DP1[i-1],DP2[i-1])\\n            DP1[i]=f[i][1]+min(DP1[i-1],DP2[i-1])\\n            DP2[i]=f[i][1]*2+min(DP0[i-1],DP2[i-1])\\n\\n        elif y==x-2:\\n            DP0[i]=min(DP0[i-1],DP1[i-1],DP2[i-1])\\n            DP1[i]=f[i][1]+min(DP0[i-1],DP1[i-1],DP2[i-1])\\n            DP2[i]=f[i][1]*2+min(DP1[i-1],DP2[i-1])\\n            \\n        else:\\n            DP0[i]=min(DP0[i-1],DP1[i-1],DP2[i-1])\\n            DP1[i]=f[i][1]+min(DP0[i-1],DP1[i-1],DP2[i-1])\\n            DP2[i]=f[i][1]*2+min(DP0[i-1],DP1[i-1],DP2[i-1])\\n\\n    print(min(DP0[n-1],DP1[n-1],DP2[n-1]))\\n            \\n            \\n            \\n\\n    \\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nQ = int(input())\\nfor _ in range(Q):\\n    N = int(input())\\n    X = []\\n    ne = [0] * 3\\n    for i in range(N):\\n        a, b = list(map(int, input().split()))\\n        X.append((a, b))\\n        if i == 0:\\n            ne = [0, b, b*2]\\n            continue\\n        Y = ne\\n        ne = [1<<100] * 3\\n        if X[i][0] != X[i-1][0]: ne[0] = min(ne[0], Y[0])\\n        if X[i][0] != X[i-1][0]+1: ne[0] = min(ne[0], Y[1])\\n        if X[i][0] != X[i-1][0]+2: ne[0] = min(ne[0], Y[2])\\n        if X[i][0]+1 != X[i-1][0]: ne[1] = min(ne[1], Y[0] + b)\\n        if X[i][0]+1 != X[i-1][0]+1: ne[1] = min(ne[1], Y[1] + b)\\n        if X[i][0]+1 != X[i-1][0]+2: ne[1] = min(ne[1], Y[2] + b)\\n        if X[i][0]+2 != X[i-1][0]: ne[2] = min(ne[2], Y[0] + b * 2)\\n        if X[i][0]+2 != X[i-1][0]+1: ne[2] = min(ne[2], Y[1] + b * 2)\\n        if X[i][0]+2 != X[i-1][0]+2: ne[2] = min(ne[2], Y[2] + b * 2)\\n        \\n    print(min(ne))\\n\", \"from sys import stdin\\ninput = stdin.readline\\nq = int(input())\\nfor rwe in range(q):\\n\\tn = int(input())\\n\\ta = [0] * n\\n\\tb = [0] * n\\n\\tfor i in range(n):\\n\\t\\tx, y = map(int, input().split())\\n\\t\\ta[i] = x\\n\\t\\tb[i] = y\\n\\tdp = [[0,0,0] for i in range(n)]\\n\\tdp[0][0] = 0\\n\\tdp[0][1] = b[0]\\n\\tdp[0][2] = 2 * b[0]\\n\\tfor i in range(1, n):\\n\\t\\tfor pod in range(3):\\n\\t\\t\\tx = (dp[i-1][0] if a[i-1] != a[i] + pod else 100000000000000000000000000)\\n\\t\\t\\ty = (dp[i-1][1] if a[i-1] + 1 != a[i] + pod else 10000000000000000000000000000)\\n\\t\\t\\tz = (dp[i-1][2] if a[i-1] + 2 != a[i] + pod else 10000000000000000000000000000)\\n\\t\\t\\tdp[i][pod] = min(x, y, z) + pod*b[i]\\n\\tprint(min(dp[n-1]))\", \"''' CODED WITH LOVE BY SATYAM KUMAR '''\\n\\nfrom sys import stdin, stdout\\nimport heapq\\nimport cProfile, math\\nfrom collections import Counter, defaultdict, deque\\nfrom bisect import bisect_left, bisect, bisect_right\\nimport itertools\\nfrom copy import deepcopy\\nfrom fractions import Fraction\\nimport sys, threading\\nimport operator as op\\nfrom functools import reduce\\nimport sys\\n\\nsys.setrecursionlimit(10 ** 6)  # max depth of recursion\\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\\nfac_warm_up = False\\nprintHeap = str()\\nmemory_constrained = False\\nP = 10 ** 9 + 7\\n\\n\\nclass MergeFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.size = [1] * n\\n        self.num_sets = n\\n        self.lista = [[_] for _ in range(n)]\\n\\n    def find(self, a):\\n        to_update = []\\n        while a != self.parent[a]:\\n            to_update.append(a)\\n            a = self.parent[a]\\n        for b in to_update:\\n            self.parent[b] = a\\n        return self.parent[a]\\n\\n    def merge(self, a, b):\\n        a = self.find(a)\\n        b = self.find(b)\\n        if a == b:\\n            return\\n        if self.size[a] < self.size[b]:\\n            a, b = b, a\\n        self.num_sets -= 1\\n        self.parent[b] = a\\n        self.size[a] += self.size[b]\\n        self.lista[a] += self.lista[b]\\n\\n    def set_size(self, a):\\n        return self.size[self.find(a)]\\n\\n    def __len__(self):\\n        return self.num_sets\\n\\n\\ndef display(string_to_print):\\n    stdout.write(str(string_to_print) + \\\"\\\\n\\\")\\n\\n\\ndef prime_factors(n):  # n**0.5 complex\\n    factors = dict()\\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\\n        while n % i == 0:\\n            if i in factors:\\n                factors[i] += 1\\n            else:\\n                factors[i] = 1\\n            n = n // i\\n    if n > 2:\\n        factors[n] = 1\\n    return (factors)\\n\\n\\ndef all_factors(n):\\n    return set(reduce(list.__add__,\\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\\n\\n\\ndef fibonacci_modP(n, MOD):\\n    if n < 2: return 1\\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(\\n        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\\n\\n\\ndef factorial_modP_Wilson(n, p):\\n    if (p <= n):\\n        return 0\\n    res = (p - 1)\\n    for i in range(n + 1, p):\\n        res = (res * cached_fn(InverseEuler, i, p)) % p\\n    return res\\n\\n\\ndef binary(n, digits=20):\\n    b = bin(n)[2:]\\n    b = '0' * (digits - len(b)) + b\\n    return b\\n\\n\\ndef is_prime(n):\\n    \\\"\\\"\\\"Returns True if n is prime.\\\"\\\"\\\"\\n    if n < 4:\\n        return True\\n    if n % 2 == 0:\\n        return False\\n    if n % 3 == 0:\\n        return False\\n    i = 5\\n    w = 2\\n    while i * i <= n:\\n        if n % i == 0:\\n            return False\\n        i += w\\n        w = 6 - w\\n    return True\\n\\n\\ndef generate_primes(n):\\n    prime = [True for i in range(n + 1)]\\n    p = 2\\n    while p * p <= n:\\n        if prime[p]:\\n            for i in range(p * 2, n + 1, p):\\n                prime[i] = False\\n        p += 1\\n    return prime\\n\\n\\nfactorial_modP = []\\n\\n\\ndef warm_up_fac(MOD):\\n    nonlocal factorial_modP, fac_warm_up\\n    if fac_warm_up: return\\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\\n    for i in range(2, fac_warm_up_size):\\n        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD\\n    fac_warm_up = True\\n\\n\\ndef InverseEuler(n, MOD):\\n    return pow(n, MOD - 2, MOD)\\n\\n\\ndef nCr(n, r, MOD):\\n    nonlocal fac_warm_up, factorial_modP\\n    if not fac_warm_up:\\n        warm_up_fac(MOD)\\n        fac_warm_up = True\\n    return (factorial_modP[n] * (\\n            (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD\\n\\n\\ndef test_print(*args):\\n    if testingMode:\\n        print(args)\\n\\n\\ndef display_list(list1, sep=\\\" \\\"):\\n    stdout.write(sep.join(map(str, list1)) + \\\"\\\\n\\\")\\n\\n\\ndef display_2D_list(li):\\n    for i in li:\\n        print(i)\\n\\n\\ndef prefix_sum(li):\\n    sm = 0\\n    res = []\\n    for i in li:\\n        sm += i\\n        res.append(sm)\\n    return res\\n\\n\\ndef get_int():\\n    return int(stdin.readline().strip())\\n\\n\\ndef get_tuple():\\n    return list(map(int, stdin.readline().split()))\\n\\n\\ndef get_list():\\n    return list(map(int, stdin.readline().split()))\\n\\n\\nmemory = dict()\\n\\n\\ndef clear_cache():\\n    nonlocal memory\\n    memory = dict()\\n\\n\\ndef cached_fn(fn, *args):\\n    nonlocal memory\\n    if args in memory:\\n        return memory[args]\\n    else:\\n        result = fn(*args)\\n        memory[args] = result\\n        return result\\n\\n\\ndef ncr(n, r):\\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\\n\\n\\ndef binary_search(i, li):\\n    fn = lambda x: li[x] - x // i\\n    x = -1\\n    b = len(li)\\n    while b >= 1:\\n        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like\\n            x += b\\n        b = b // 2\\n    return x\\n\\n\\n# -------------------------------------------------------------- MAIN PROGRAM\\n\\n\\nTestCases = True\\nfac_warm_up_size = 10 ** 5 + 100\\noptimise_for_recursion = False  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3\\n\\n\\ndef main():\\n    n = get_int()\\n    lengths = []\\n    costs = []\\n\\n    for _ in range(n):\\n        a, b = get_tuple()\\n        lengths.append(a)\\n        costs.append(b)\\n    dp = [[0, costs[0], 2*costs[0]]]\\n    for i in range(1, n):\\n        kt = [10 ** 20] * 3\\n        for k in range(3):\\n            for j, ele in enumerate(dp[-1]):\\n                if lengths[i-1]+j!=lengths[i]+k:\\n                    kt[k] = min(kt[k], ele+costs[i]*k)\\n        dp.append(kt)\\n    #print(dp)\\n    print(min(dp[-1]))\\n\\n\\n# --------------------------------------------------------------------- END=\\n\\n\\nif TestCases:\\n    for i in range(get_int()):\\n        main()\\nelse:\\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nq = int(input())\\nfor i in range(q):\\n    n = int(input())\\n    dp = [[0] * n for _ in range(3)]\\n    prev = 0\\n    for i in range(n):\\n        l, c = [int(item) for item in input().split()]\\n        if i == 0:\\n            dp[0][0] = 0\\n            dp[1][0] = c\\n            dp[2][0] = c * 2\\n            prev = l\\n            continue\\n        prev_min = min(dp[0][i-1], dp[1][i-1], dp[2][i-1])\\n        if l > prev + 2:\\n            dp[0][i] = prev_min\\n            dp[1][i] = prev_min + c\\n            dp[2][i] = prev_min + c * 2\\n        elif l == prev + 2:\\n            dp[0][i] = min(dp[0][i-1], dp[1][i-1])\\n            dp[1][i] = prev_min + c\\n            dp[2][i] = prev_min + c * 2\\n        elif l == prev + 1:\\n            dp[0][i] = min(dp[0][i-1], dp[2][i-1]) \\n            dp[1][i] = min(dp[0][i-1], dp[1][i-1]) + c\\n            dp[2][i] = prev_min + c * 2\\n        elif l == prev:\\n            dp[0][i] = min(dp[1][i-1], dp[2][i-1])\\n            dp[1][i] = min(dp[0][i-1], dp[2][i-1]) + c\\n            dp[2][i] = min(dp[0][i-1], dp[1][i-1]) + 2 * c\\n        elif l == prev - 1:\\n            dp[0][i] = prev_min\\n            dp[1][i] = min(dp[1][i-1], dp[2][i-1]) + c\\n            dp[2][i] = min(dp[0][i-1], dp[2][i-1]) + 2 * c\\n        elif l == prev - 2:\\n            dp[0][i] = prev_min\\n            dp[1][i] = prev_min + c\\n            dp[2][i] = min(dp[1][i-1], dp[2][i-1]) + 2 * c\\n        elif l < prev - 2:\\n            dp[0][i] = prev_min\\n            dp[1][i] = prev_min + c\\n            dp[2][i] = prev_min + c * 2\\n        prev = l\\n    print(min(dp[0][n-1], dp[1][n-1], dp[2][n-1]))\", \"import sys\\ninput = sys.stdin.readline\\nq = int(input())\\nfor _ in range(q):\\n    n = int(input())\\n    d = [[-100, 0]] + [list(map(int, input().split())) for _ in range(n)]\\n    dp = [[100 for j in range(3)] for i in range(n+1)]\\n    dp[0] = [0, 0, 0, 0]\\n    for i in range(n):\\n        if d[i+1][0] == d[i][0]:\\n            dp[i+1][0] = min(dp[i][1], dp[i][2])\\n            dp[i+1][1] = min(dp[i][0], dp[i][2]) + d[i+1][1]\\n            dp[i+1][2] = min(dp[i][0], dp[i][1]) + d[i+1][1] * 2\\n        elif d[i+1][0] + 1 == d[i][0]:\\n            dp[i+1][0] = min(dp[i])\\n            dp[i+1][1] = min(dp[i][1], dp[i][2]) + d[i+1][1]\\n            dp[i+1][2] = min(dp[i][0], dp[i][1]) + d[i+1][1] * 2\\n        elif d[i+1][0] + 2 == d[i][0]:\\n            dp[i+1][0] = min(dp[i])\\n            dp[i+1][1] = min(dp[i]) + d[i+1][1]\\n            dp[i+1][2] = min(dp[i][1], dp[i][2]) + d[i+1][1] * 2\\n        elif d[i+1][0] - 1 == d[i][0]:\\n            dp[i+1][0] = min(dp[i][0], dp[i][2])\\n            dp[i+1][1] = min(dp[i][1], dp[i][0]) + d[i+1][1]\\n            dp[i+1][2] = min(dp[i]) + d[i+1][1] * 2\\n        elif d[i+1][0] - 2 == d[i][0]:\\n            dp[i+1][0] = min(dp[i][0], dp[i][1])\\n            dp[i+1][1] = min(dp[i]) + d[i+1][1]\\n            dp[i+1][2] = min(dp[i]) + d[i+1][1] * 2\\n        else:\\n            dp[i+1][0] = min(dp[i])\\n            dp[i+1][1] = min(dp[i]) + d[i+1][1]\\n            dp[i+1][2] = min(dp[i]) + d[i+1][1] * 2\\n    print(min(dp[n]))\\n\", \"import sys\\ninput=sys.stdin.readline\\nq=int(input())\\nfor _ in range(q):\\n  n=int(input())\\n  ans=0\\n  a,b=list(map(int,input().split()))\\n  cur=a\\n  A=[0,b,2*b]\\n  for i in range(n-1):\\n    a=cur\\n    na,nb=list(map(int,input().split()))\\n    cur=na\\n    a0,a1,a2=A\\n    if na==a:\\n      A[0]=min(a1,a2)\\n      A[1]=nb+min(a0,a2)\\n      A[2]=2*nb+min(a0,a1)\\n    elif na==a-1:\\n      A[0]=min(a0,a1,a2)\\n      A[1]=nb+min(a1,a2)\\n      A[2]=2*nb+min(a0,a2)\\n    elif na==a-2:\\n      A[0]=min(a0,a1,a2)\\n      A[1]=nb+min(a0,a1,a2)\\n      A[2]=2*nb+min(a1,a2)\\n    elif na==a+1:\\n      A[0]=min(a0,a2)\\n      A[1]=nb+min(a0,a1)\\n      A[2]=2*nb+min(a0,a1,a2)\\n    elif na==a+2:\\n      A[0]=min(a0,a1)\\n      A[1]=nb+min(a0,a1,a2)\\n      A[2]=2*nb+min(a0,a1,a2)\\n    else:\\n      A[0]=min(a0,a1,a2)\\n      A[1]=nb+min(a0,a1,a2)\\n      A[2]=2*nb+min(a0,a1,a2)\\n \\n  print(min(A))\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nQ = int(input())\\ndata = []\\nfor _ in range(Q):\\n    N = int(input())\\n    A = []\\n    B = []\\n    for _ in range(N):\\n        a, b = list(map(int, input().split()))\\n        A.append(a)\\n        B.append(b)\\n    data.append([N, A, B])\\n\\nfor N, A, B in data:\\n    dp = [[0, 0, 0] for _ in range(N)]\\n    dp[0][1] = B[0]\\n    dp[0][2] = 2*B[0]\\n    for i in range(1, N):\\n        if A[i] == A[i-1]:\\n            dp[i][0] = min(dp[i-1][1], dp[i-1][2])\\n        elif A[i] == A[i-1]+1:\\n            dp[i][0] = min(dp[i-1][0], dp[i-1][2])\\n        elif A[i] == A[i-1]+2:\\n            dp[i][0] = min(dp[i-1][0], dp[i-1][1])\\n        else:\\n            dp[i][0] = min([dp[i-1][0], dp[i-1][1], dp[i-1][2]])\\n        \\n        if A[i] == A[i-1]+1:\\n            dp[i][1] = min(dp[i-1][0], dp[i-1][1]) + B[i]\\n        elif A[i] == A[i-1]:\\n            dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + B[i]\\n        elif A[i] == A[i-1]-1:\\n            dp[i][1] = min(dp[i-1][1], dp[i-1][2]) + B[i]\\n        else:\\n            dp[i][1] = min([dp[i-1][0], dp[i-1][1], dp[i-1][2]]) + B[i]\\n        \\n        if A[i] == A[i-1]:\\n            dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + 2*B[i]\\n        elif A[i] == A[i-1]-1:\\n            dp[i][2] = min(dp[i-1][0], dp[i-1][2]) + 2*B[i]\\n        elif A[i] == A[i-1]-2:\\n            dp[i][2] = min(dp[i-1][1], dp[i-1][2]) + 2*B[i]\\n        else:\\n            dp[i][2] = min([dp[i-1][0], dp[i-1][1], dp[i-1][2]]) + 2*B[i]\\n    ans = min(dp[N-1])\\n    print(ans)\\n\\n\", \"'''input\\n3\\n3\\n2 4\\n2 1\\n3 5\\n3\\n2 3\\n2 10\\n2 6\\n4\\n1 7\\n3 3\\n2 6\\n1000000000 2\\n'''\\nfrom sys import stdin\\nfrom math import ceil, log\\n\\n\\n# main starts\\nq = int(stdin.readline().strip())\\nfor _ in range(q):\\n\\tn = int(stdin.readline().strip())\\n\\th = []\\n\\tc  = []\\n\\tdp = dict()\\n\\tfor i in range(n):\\n\\t\\ta, b = list(map(int, stdin.readline().split()))\\n\\t\\th.append(a)\\n\\t\\tc.append(b)\\n\\tdp = [[0 for x in range(3)] for y in range(n)]\\n\\tdp[0][0] = 0\\n\\tdp[0][1] = c[0]\\n\\tdp[0][2] = 2*c[0]\\n\\tfor i in range(1, n):\\n\\t\\tif h[i] == h[i - 1]:\\n\\t\\t\\tdp[i][0] = min(dp[i - 1][1], dp[i- 1][2])\\n\\t\\t\\tdp[i][1] = min(dp[i - 1][0], dp[i - 1][2]) + c[i]\\n\\t\\t\\tdp[i][2] = min(dp[i - 1][0], dp[i - 1][1]) + 2 * c[i]\\n\\t\\telif h[i] + 1 == h[i - 1]:\\n\\t\\t\\tdp[i][0] = min(dp[i - 1])\\n\\t\\t\\tdp[i][1] = min(dp[i - 1][1], dp[i - 1][2]) + c[i]\\n\\t\\t\\tdp[i][2] = min(dp[i - 1][0], dp[i - 1][2]) + 2 * c[i]\\n\\t\\telif h[i] + 2 == h[i - 1]:\\n\\t\\t\\tdp[i][0] = min(dp[i - 1])\\n\\t\\t\\tdp[i][1] = min(dp[i - 1])+ c[i]\\n\\t\\t\\tdp[i][2] = min(dp[i - 1][0], dp[i - 1][1]) + 2 * c[i]\\n\\t\\telif h[i] == h[i - 1] + 1:\\n\\t\\t\\tdp[i][0] = min(dp[i - 1][0], dp[i - 1][2])\\n\\t\\t\\tdp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + c[i]\\n\\t\\t\\tdp[i][2] = min(dp[i - 1]) + 2 * c[i]\\n\\t\\telif h[i] == h[i - 1] + 2:\\n\\t\\t\\tdp[i][0] = min(dp[i - 1][:2])\\n\\t\\t\\tdp[i][1] = min(dp[i - 1])+ c[i]\\n\\t\\t\\tdp[i][2] = min(dp[i - 1]) + 2 * c[i]\\n\\n\\t\\telse:\\n\\t\\t\\tdp[i][0] = min(dp[i - 1])\\n\\t\\t\\tdp[i][1] = min(dp[i - 1])+ c[i]\\n\\t\\t\\tdp[i][2] = min(dp[i - 1]) + 2 * c[i]\\n\\tprint(min(dp[-1]))\", \"import sys\\nfrom math import inf as inf\\nfor _ in range(int(input())):\\n    n=int(sys.stdin.readline())\\n    dp=[[inf,inf,inf] for i in range(n+1)]\\n    a=[]\\n    for i in range(n):\\n        a.append(list(map(int,sys.stdin.readline().split())))\\n    dp[0][0]=0\\n    dp[0][1]=a[0][1]\\n    dp[0][2]=2*a[0][1]\\n    for i in range(1,n):\\n        for j in range(3):\\n            for k in range(3):\\n                if a[i][0] + j != a[i-1][0] + k:\\n                    dp[i][j]=min(dp[i][j],dp[i-1][k] + j*a[i][1])\\n    # print(dp)                \\n    print(min(dp[n-1]))                \", \"from sys import stdin\\n\\ntest = stdin.readlines()\\ninf = float('infinity')\\n\\nq = int(test[0])\\nk = 1\\nfor _ in range(q):\\n    n = int(test[k])\\n\\n    h, c = [], []\\n    for j in range(k+1, k+n+1):\\n        x, y = list(map(int, test[j].split()))\\n        h.append(x)\\n        c.append(y)\\n\\n    dp = [[0, c[0], 2 * c[0]]] + [[0, 0, 0] for i in range(n-1)]\\n\\n    for i in range(1, n):\\n        for j in range(3):\\n            x = (dp[i - 1][0] if h[i - 1] != h[i] + j else inf)\\n            y = (dp[i - 1][1] if h[i - 1] + 1 != h[i] + j else inf)\\n            z = (dp[i - 1][2] if h[i - 1] + 2 != h[i] + j else inf)\\n            dp[i][j] = min(x, y, z) + j * c[i]\\n\\n    print(min(dp[n - 1]))\\n\\n    k += n + 1\\n\", \"from sys import stdin\\n\\ntest = stdin.readlines()\\ninf = float('infinity')\\n\\nq = int(test[0])\\nk = 1\\nfor _ in range(q):\\n    n = int(test[k])\\n\\n    h, c = [], []\\n    for j in range(k+1, k+n+1):\\n        x, y = list(map(int, test[j].split()))\\n        h.append(x)\\n        c.append(y)\\n\\n    dp = [[0, c[0], 2 * c[0]]]\\n    dp += [[0, 0, 0] for i in range(n-1)]\\n\\n    for i in range(1, n):\\n        for j in range(3):\\n            x = (dp[i - 1][0] if h[i - 1] != h[i] + j else inf)\\n            y = (dp[i - 1][1] if h[i - 1] + 1 != h[i] + j else inf)\\n            z = (dp[i - 1][2] if h[i - 1] + 2 != h[i] + j else inf)\\n            dp[i][j] = min(x, y, z) + j * c[i]\\n\\n    print(min(dp[n - 1]))\\n\\n    k += n + 1\\n\", \"from sys import stdin\\n\\ntest = stdin.readlines()\\ninf = float('infinity')\\n\\nq = int(test[0])\\nk = 1\\nfor _ in range(q):\\n    n = int(test[k])\\n\\n    h, c = [], []\\n    for j in range(k+1, k+n+1):\\n        x, y = list(map(int, test[j].split()))\\n        h.append(x)\\n        c.append(y)\\n\\n    dp = [[0, 0, 0] for i in range(n)]\\n    dp[0] = [0, c[0], 2 * c[0]]\\n\\n    for i in range(1, n):\\n        for j in range(3):\\n            x = (dp[i - 1][0] if h[i - 1] != h[i] + j else inf)\\n            y = (dp[i - 1][1] if h[i - 1] + 1 != h[i] + j else inf)\\n            z = (dp[i - 1][2] if h[i - 1] + 2 != h[i] + j else inf)\\n            dp[i][j] = min(x, y, z) + j * c[i]\\n\\n    print(min(dp[n - 1]))\\n\\n    k += n + 1\\n\", \"from sys import stdin\\n\\ntest = stdin.readlines()\\ninf = float('infinity')\\n\\nq = int(test[0])\\nk = 1\\nfor _ in range(q):\\n    n = int(test[k])\\n\\n    h, c = [0]*n, [0]*n\\n    for j in range(k+1, k+n+1):\\n        h[j-k-1], c[j-k-1] = list(map(int, test[j].split()))\\n\\n    dp = [[0, c[0], 2 * c[0]]] + [[0, 0, 0] for i in range(n-1)]\\n\\n    for i in range(1, n):\\n        for j in range(3):\\n            x = (dp[i - 1][0] if h[i - 1] != h[i] + j else inf)\\n            y = (dp[i - 1][1] if h[i - 1] + 1 != h[i] + j else inf)\\n            z = (dp[i - 1][2] if h[i - 1] + 2 != h[i] + j else inf)\\n            dp[i][j] = min(x, y, z) + j * c[i]\\n\\n    print(min(dp[n - 1]))\\n\\n    k += n + 1\\n\", \"import sys\\ninput = sys.stdin.readline\\nt=int(input()) \\nfor rainbow in range(t):\\n    n=int(input())\\n    f=[tuple(map(int,input().split())) for i in range(n)]\\n    dp=[0]*n;dp1=[0]*n;dp2=[0]*n\\n    dp1[0]=f[0][1];dp2[0]=f[0][1]*2\\n    for i in range(1,n):\\n        a=f[i-1][0]\\n        b=f[i][0]\\n        if b==a:\\n            dp[i]=min(dp1[i-1],dp2[i-1])\\n            dp1[i]=f[i][1]+min(dp[i-1],dp2[i-1])\\n            dp2[i]=f[i][1]*2+min(dp[i-1],dp1[i-1])\\n        elif b==a+1:\\n            dp[i]=min(dp[i-1],dp2[i-1])\\n            dp1[i]=f[i][1]+min(dp[i-1],dp1[i-1])\\n            dp2[i]=f[i][1]*2+min(dp[i-1],dp1[i-1],dp2[i-1])\\n        elif b==a+2:\\n            dp[i]=min(dp[i-1],dp1[i-1])\\n            dp1[i]=f[i][1]+min(dp[i-1],dp1[i-1],dp2[i-1])\\n            dp2[i]=f[i][1]*2+min(dp[i-1],dp1[i-1],dp2[i-1])\\n        elif b==a-1:\\n            dp[i]=min(dp[i-1],dp1[i-1],dp2[i-1])\\n            dp1[i]=f[i][1]+min(dp1[i-1],dp2[i-1])\\n            dp2[i]=f[i][1]*2+min(dp[i-1],dp2[i-1])\\n        elif b==a-2:\\n            dp[i]=min(dp[i-1],dp1[i-1],dp2[i-1])\\n            dp1[i]=f[i][1]+min(dp[i-1],dp1[i-1],dp2[i-1])\\n            dp2[i]=f[i][1]*2+min(dp1[i-1],dp2[i-1])\\n        else:\\n            dp[i]=min(dp[i-1],dp1[i-1],dp2[i-1])\\n            dp1[i]=f[i][1]+min(dp[i-1],dp1[i-1],dp2[i-1])\\n            dp2[i]=f[i][1]*2+min(dp[i-1],dp1[i-1],dp2[i-1])\\n    print(min(dp[n-1],dp1[n-1],dp2[n-1]))\", \"\\\"\\\"\\\"\\nNTC here\\n\\\"\\\"\\\"\\nfrom sys import setcheckinterval, stdin, setrecursionlimit\\nsetcheckinterval(1000)\\nsetrecursionlimit(10**7)\\n \\n# print(\\\"Case #{}: {} {}\\\".format(i, n + m, n * m))\\n \\n \\ndef iin(): return int(stdin.readline())\\n \\n \\ndef lin(): return list(map(int, stdin.readline().split()))\\n\\nfor _ in range(iin()):\\n    n=iin()\\n    fence=[lin() for i in range(n)]\\n    dp=[[0,j,2*j] for i,j in fence]\\n    for i in range(1,n):\\n        for j in range(3):\\n            dp[i][j]+= min([dp[i-1][k] for k in range(3) if fence[i-1][0]+k!=fence[i][0]+j])\\n    #print(*dp)\\n    print(min(dp[-1]))\", \"# -*- coding: utf-8 -*-\\nimport bisect\\nimport heapq\\nimport math\\n# import random\\nimport sys\\nfrom collections import Counter, defaultdict, deque\\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\\nfrom functools import lru_cache, reduce\\nfrom itertools import combinations, combinations_with_replacement, product, permutations\\nfrom operator import add, mul, sub\\n\\nsys.setrecursionlimit(100000)\\ninput = sys.stdin.readline\\n\\n\\ndef read_int():\\n    return int(input())\\n\\n\\ndef read_int_n():\\n    return list(map(int, input().split()))\\n\\n\\ndef read_float():\\n    return float(input())\\n\\n\\ndef read_float_n():\\n    return list(map(float, input().split()))\\n\\n\\ndef read_str():\\n    return input().strip()\\n\\n\\ndef read_str_n():\\n    return list(map(str, input().split()))\\n\\n\\ndef error_print(*args):\\n    print(*args, file=sys.stderr)\\n\\n\\ndef mt(f):\\n    import time\\n\\n    def wrap(*args, **kwargs):\\n        s = time.time()\\n        ret = f(*args, **kwargs)\\n        e = time.time()\\n\\n        error_print(e - s, 'sec')\\n        return ret\\n\\n    return wrap\\n\\n\\n# @mt\\ndef slv(N, AB):\\n    \\n    memo = [0, AB[0][1], AB[0][1]*2]\\n\\n    for i in range(1, N):\\n        a, b = AB[i]\\n        a1, _ = AB[i-1]\\n        memo2 = [0] * 3\\n        for j in range(3):\\n            tmp = 1e+1000\\n            for k in range(3):\\n                if a + j != a1 + k:\\n                    tmp = min(tmp, memo[k])\\n            memo2[j] = tmp + j * b\\n        memo = memo2\\n    return min(memo)\\n\\n\\ndef main():\\n    Q = read_int()\\n    for _ in range(Q):\\n        N = read_int()\\n        AB = [read_int_n() for _ in range(N)]\\n        print(slv(N, AB))\\n\\n    # N = 100\\n    # AB = [[1000000000, 1000000000] for _ in range(N)]\\n    # print(slv(N, AB))\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import sys\\n\\n\\nfor q in range(int(input())):\\n    n = int(sys.stdin.readline())\\n    data = []\\n    for i in range(n):\\n        data.append([int(j) for j in sys.stdin.readline().split()])\\n    dp = [[0, data[0][1], 2 * data[0][1]]]\\n    for i in range(1, n):\\n        a, b = data[i]\\n        lasta = data[i-1][0]\\n        l = dp[-1]\\n\\n        vals = [(lasta + j) for j in range(3)]\\n        ans = [0]*3\\n        for j in range(3):\\n            w = a + j\\n            x = [ l[k] for k in range(3) if lasta + k != w ]\\n            # print(w, dp[-1], x)\\n            ans[j] = j*b + min(x)\\n        dp.append(ans)\\n    print(min(dp[-1]))\\n    # print(dp)\\n\", \"from math import inf as inf\\nimport sys\\nfor _ in range(int(input())):\\n    n=int(sys.stdin.readline())\\n    dp = [[inf,inf,inf] for _ in range(n+1)]\\n    arr = []\\n    for i in range(n):\\n        arr.append(list(map(int,sys.stdin.readline().split())))\\n    dp[0] = [0,arr[0][1],arr[0][1]*2]\\n    \\n    for i in range(1,n):\\n        for j in range(3):\\n            for k in range(3):\\n                if arr[i][0]+j!=arr[i-1][0]+k:\\n                    dp[i][j] = min(dp[i][j],dp[i-1][k]+j*arr[i][1])\\n    print(min(dp[n-1]))\\n\\n\", \"import sys, math\\nINF = float(\\\"inf\\\")\\ndef main():\\n    def input():\\n        return sys.stdin.readline()[:-1]\\n    q = int(input())\\n    for _ in range(q):\\n        n = int(input())\\n        w = [list(map(int,input().split())) for k in range(n)]\\n        dp = [[INF,INF,INF] for k in range(n)]\\n        dp[0] = [0,w[0][1],2*w[0][1]]\\n        for k in range(1,n):\\n            for l in range(3):\\n                for m in range(3):\\n                    if w[k-1][0]+l != w[k][0]+m:\\n                        dp[k][m] = min(dp[k][m], dp[k-1][l] + w[k][1]*m)\\n        print(min(dp[n-1]))\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n3\\n2 4\\n2 1\\n3 5\\n3\\n2 3\\n2 10\\n2 6\\n4\\n1 7\\n3 3\\n2 6\\n1000000000 2\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n9\\n0\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1221/D", "starter_code": ""}
{"id": 78, "question": "You are given a picture consisting of $n$ rows and $m$ columns. Rows are numbered from $1$ to $n$ from the top to the bottom, columns are numbered from $1$ to $m$ from the left to the right. Each cell is painted either black or white. \n\nYou think that this picture is not interesting enough. You consider a picture to be interesting if there is at least one cross in it. A cross is represented by a pair of numbers $x$ and $y$, where $1 \\le x \\le n$ and $1 \\le y \\le m$, such that all cells in row $x$ and all cells in column $y$ are painted black.\n\nFor examples, each of these pictures contain crosses:\n\n [Image] \n\nThe fourth picture contains 4 crosses: at $(1, 3)$, $(1, 5)$, $(3, 3)$ and $(3, 5)$.\n\nFollowing images don't contain crosses:\n\n [Image] \n\nYou have a brush and a can of black paint, so you can make this picture interesting. Each minute you may choose a white cell and paint it black.\n\nWhat is the minimum number of minutes you have to spend so the resulting picture contains at least one cross?\n\nYou are also asked to answer multiple independent queries.\n\n\n-----Input-----\n\nThe first line contains an integer $q$ ($1 \\le q \\le 5 \\cdot 10^4$) \u2014 the number of queries.\n\nThe first line of each query contains two integers $n$ and $m$ ($1 \\le n, m \\le 5 \\cdot 10^4$, $n \\cdot m \\le 4 \\cdot 10^5$) \u2014 the number of rows and the number of columns in the picture.\n\nEach of the next $n$ lines contains $m$ characters \u2014 '.' if the cell is painted white and '*' if the cell is painted black.\n\nIt is guaranteed that $\\sum n \\le 5 \\cdot 10^4$ and $\\sum n \\cdot m \\le 4 \\cdot 10^5$.\n\n\n-----Output-----\n\nPrint $q$ lines, the $i$-th line should contain a single integer \u2014 the answer to the $i$-th query, which is the minimum number of minutes you have to spend so the resulting picture contains at least one cross.\n\n\n-----Example-----\nInput\n9\n5 5\n..*..\n..*..\n*****\n..*..\n..*..\n3 4\n****\n.*..\n.*..\n4 3\n***\n*..\n*..\n*..\n5 5\n*****\n*.*.*\n*****\n..*.*\n..***\n1 4\n****\n5 5\n.....\n..*..\n.***.\n..*..\n.....\n5 3\n...\n.*.\n.*.\n***\n.*.\n3 3\n.*.\n*.*\n.*.\n4 4\n*.**\n....\n*.**\n*.**\n\nOutput\n0\n0\n0\n0\n0\n4\n1\n1\n2\n\n\n\n-----Note-----\n\nThe example contains all the pictures from above in the same order.\n\nThe first 5 pictures already contain a cross, thus you don't have to paint anything.\n\nYou can paint $(1, 3)$, $(3, 1)$, $(5, 3)$ and $(3, 5)$ on the $6$-th picture to get a cross in $(3, 3)$. That'll take you $4$ minutes.\n\nYou can paint $(1, 2)$ on the $7$-th picture to get a cross in $(4, 2)$.\n\nYou can paint $(2, 2)$ on the $8$-th picture to get a cross in $(2, 2)$. You can, for example, paint $(1, 3)$, $(3, 1)$ and $(3, 3)$ to get a cross in $(3, 3)$ but that will take you $3$ minutes instead of $1$.\n\nThere are 9 possible crosses you can get in minimum time on the $9$-th picture. One of them is in $(1, 1)$: paint $(1, 2)$ and $(2, 1)$.", "solutions": "[\"import sys\\n\\nq = int(sys.stdin.readline().strip())\\nfor t in range(0, q):\\n    n, m = list(map(int, sys.stdin.readline().strip().split()))\\n    L = []\\n    R = [0] * n\\n    C = [0] * m\\n    for i in range (0, n):\\n        L.append(sys.stdin.readline().strip())\\n        for j in range (0, m):\\n            if L[i][j] != \\\"*\\\":\\n                R[i] = R[i] + 1\\n                C[j] = C[j] + 1\\n    ans = n + m - 1\\n    for i in range (0, n):\\n        for j in range (0, m):\\n            x = 0\\n            if L[i][j] != \\\"*\\\":\\n                x = -1\\n            ans = min([ans, R[i]+C[j]+x])\\n    print(ans)\", \"import sys\\nQ = int(input())\\nfor _ in range(Q):\\n    N, M = map(int, sys.stdin.readline().split())\\n    G = [[1 if s == '*' else 0 for s in sys.stdin.readline().strip()] for _ in range(N)]\\n    ans = 10**9+7\\n    G1 = [sum(g) for g in G]\\n    G = list(map(list, zip(*G)))\\n    G2 = [sum(g) for g in G]\\n    G = list(map(list, zip(*G)))\\n    K = N + M - 1\\n    for i in range(N):\\n        for j in range(M):\\n            if G[i][j]:\\n                ans = min(ans, K - (G1[i] + G2[j] - 1))\\n            else:\\n                ans = min(ans, K - (G1[i] + G2[j]))\\n    sys.stdout.write('{}\\\\n'.format(ans))\", \"import sys\\nimport math\\ninput = sys.stdin.readline\\n\\nq=int(input())\\nfor i in range(q):\\n\\tn,m=list(map(int,input().split()))\\n\\tr=[0]*n\\n\\tc=[0]*m\\n\\tarr=[]\\n\\tfor i in range(n):\\n\\t\\tarr.append(input())\\n\\n\\tfor i in range(n):\\n\\t\\tfor j in range(m):\\n\\t\\t\\tif arr[i][j]==\\\".\\\":\\n\\t\\t\\t\\tr[i]+=1\\n\\t\\t\\t\\tc[j]+=1\\n\\tminn=1000000000\\n\\tfor i in range(n):\\n\\t\\tfor j in range(m):\\n\\t\\t\\tif arr[i][j]==\\\".\\\":\\n\\t\\t\\t\\tminn=min(minn,r[i]+c[j]-1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tminn=min(minn,r[i]+c[j])\\n\\n\\tprint(minn)\\n\\t\\t\\n\", \"q = int(input())\\nfor query in range(q):\\n\\tn, m = list(map(int, input().split()))\\n\\tmatrix = [input() for i in range(n)]\\n\\trow = [0] * n\\n\\tcol = [0] * m\\n\\tfor i in range(n):\\n\\t\\tsuma = 0\\n\\t\\tfor j in range(m):\\n\\t\\t\\tif matrix[i][j] == '*':\\n\\t\\t\\t\\tsuma += 1\\n\\t\\trow[i] = suma\\n\\tfor j in range(m):\\n\\t\\tsuma = 0\\n\\t\\tfor i in range(n):\\n\\t\\t\\tif matrix[i][j] == '*':\\n\\t\\t\\t\\tsuma += 1\\n\\t\\tcol[j] = suma\\n\\twynik = 100000000000\\n\\tfor i in range(n):\\n\\t\\tfor j in range(m):\\n\\t\\t\\tpom = m + n - 1 - (row[i] + col[j] - (1 if matrix[i][j] == '*' else 0))\\n\\t\\t\\twynik = min(wynik, pom)\\n\\tprint(wynik)\\n\\t\\t\\t\\n\", \"from sys import stdin\\nc=int(stdin.readline().strip())\\nfor i in range(c):\\n    n,m=list(map(int,stdin.readline().strip().split()))\\n    s=[stdin.readline().strip() for j in range(n)]\\n    ms=[]\\n    ns=[]\\n    for j in range(n):\\n        ns.append(s[j].count(\\\".\\\"))\\n    \\n    for j in range(m):\\n        ms.append(0)\\n        for k in range(n):\\n            if s[k][j]==\\\".\\\":\\n                ms[-1]+=1\\n    ans=10**15\\n    for j in range(n):\\n        for k in range(m):\\n            x=ns[j]+ms[k]\\n            if s[j][k]==\\\".\\\":\\n                x-=1\\n            ans=min(ans,x)\\n    print(ans)\\n\", \"t = int(input())\\nfor i in range(t):\\n    e,s = list(map(int, input().split()))\\n    f = []\\n    for h in range(e):\\n        f.append(input())\\n    now = 0\\n    mi = 0\\n    mi2 = []\\n    g = []\\n    for y in range(e):\\n        now = 0\\n        g = []\\n        for x in range(s):\\n            if(f[y][x]==\\\"*\\\"):\\n                now+=1\\n            else:\\n                g.append(x)\\n        if(now>mi):\\n            mi = now\\n            mi2 = []\\n            for k in range(len(g)):\\n                mi2.append(g[k])\\n        elif(now==mi):\\n            for k in range(len(g)):\\n                mi2.append(g[k])\\n    now = 0\\n    ma = 0\\n    d = True\\n    for y in range(s):\\n        now = 0\\n        for x in range(e):\\n            if(f[x][y]==\\\"*\\\"):\\n                now+=1\\n        if(now>ma):\\n            ma = now\\n            if(y in mi2):\\n                d = False\\n            else:\\n                d = True\\n        elif(now==ma):\\n            if(y in mi2):\\n                d = False\\n    if(d):\\n        print(e-mi+s-ma)\\n    else:\\n        print(e-mi+s-ma-1)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nQ=int(input())\\nfor testcases in range(Q):\\n    n,m=list(map(int,input().split()))\\n\\n    MAP=[list(input().strip()) for i in range(n)]\\n\\n    R=[MAP[i].count(\\\"*\\\") for i in range(n)]\\n    C=[]\\n    \\n    for j in range(m):\\n        M=[MAP[i][j] for i in range(n)]\\n        C.append(M.count(\\\"*\\\"))\\n\\n    ANS=float(\\\"inf\\\")\\n\\n    for i in range(n):\\n        for j in range(m):\\n            if MAP[i][j]==\\\"*\\\":\\n                ANS=min(ANS,n+m-R[i]-C[j])\\n            else:\\n                ANS=min(ANS,n+m-R[i]-C[j]-1)\\n\\n    print(ANS)\\n                \\n    \\n\", \"n=int(input())\\nfor i in range(n):\\n    x,y=list(map(int,input().split()))\\n    stolb=[0]*y\\n    stroki=[0]*x\\n    al=[]\\n    for j in range(x):\\n        st=input()\\n        al.append(st)\\n        for j2 in range(y):\\n            if st[j2]=='.':\\n                stroki[j]+=1\\n                stolb[j2]+=1\\n    mi=1000000000000000\\n    for j in range(x):\\n        for j2 in range(y):\\n            if al[j][j2]=='.':\\n                if stroki[j]+stolb[j2]-1<mi:\\n                    mi=stroki[j]+stolb[j2]-1\\n            else:\\n                if stroki[j]+stolb[j2]<mi:\\n                    mi=stroki[j]+stolb[j2]\\n    print(mi)\\n\", \"q = int(input())\\nfor _ in range(q):\\n    n, m = list(map(int, input().split()))\\n    d = [list(input()) for _ in range(n)]\\n    count_x = list([x.count('*') for x in d])\\n    count_y = list([x.count('*') for x in zip(*d)])\\n    #dt = map(list, zip(*d))\\n    rls = n+m-1\\n    for i in range(n):\\n        for j in range(m):\\n            a = count_x[i]\\n            b = count_y[j]\\n            if d[i][j] == '*':\\n                rls = min(rls, n+m-a-b)\\n            else:\\n                rls = min(rls, n+m-a-b-1)\\n    print(rls)\\n\", \"import io, sys, atexit, os\\nimport math as ma\\nfrom decimal import Decimal as dec\\nfrom itertools import permutations\\nfrom itertools import combinations\\n\\n\\ndef li ():\\n\\treturn list (map (int, input ().split ()))\\n\\n\\ndef num ():\\n\\treturn map (int, input ().split ())\\n\\n\\ndef nu ():\\n\\treturn int (input ())\\n\\n\\ndef find_gcd ( x, y ):\\n\\twhile (y):\\n\\t\\tx, y = y, x % y\\n\\treturn x\\n\\n\\ndef lcm ( x, y ):\\n\\tgg = find_gcd (x, y)\\n\\treturn (x * y // gg)\\n\\n\\nmm = 1000000007\\nyp = 0\\n\\n\\ndef solve ():\\n\\tt =nu()\\n\\tfor tt in range (t):\\n\\t\\tn,m=num()\\n\\t\\ta=[0]*n\\n\\t\\tx=[0]*n\\n\\t\\ty=[0]*m\\n\\t\\tfor i in range(n):\\n\\t\\t\\tp=input()\\n\\t\\t\\ta[i]=[0]*m\\n\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\tif(p[j]==\\\"*\\\"):\\n\\t\\t\\t\\t\\ta[i][j]=1\\n\\t\\t\\tx[i]=sum(a[i])\\n\\t\\tfor i in range(m):\\n\\t\\t\\tcc=0\\n\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\tcc+=a[j][i]\\n\\t\\t\\ty[i]=cc\\n\\t\\tmn=9999999999\\n\\t\\tfor i in range(n):\\n\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\tpp=0\\n\\t\\t\\t\\tpp = (n - x [ i ]) + (m - y [ j ])\\n\\t\\t\\t\\tif(a[i][j]==0):\\n\\t\\t\\t\\t\\tpp-=1\\n\\t\\t\\t\\tmn=min(mn,pp)\\n\\t\\tprint(mn)\\n\\n\\n\\n\\n\\ndef __starting_point():\\n\\tsolve ()\\n__starting_point()\", \"from fractions import gcd\\nimport math\\n\\n\\ndef inverse(a):\\n    return pow(a, mod - 2, mod)\\n\\n\\ndef usearch(x, a):\\n    lft = 0\\n    rgt = len(a) + 1\\n    while rgt - lft > 1:\\n        mid = (rgt + lft) // 2\\n        if a[mid] <= x:\\n            lft = mid\\n        else:\\n            rgt = mid\\n    return lft\\n\\n\\ndef main():\\n    q = int(input())\\n    for i in range(q):\\n        n,m = list(map(int, input().split()))\\n        a = [input() for i in range(n)]\\n        h = 0\\n        h_a = []\\n        for i in range(m):\\n            tmp = 0\\n            for j in range(n):\\n                if a[j][i] == '*':\\n                    tmp += 1\\n            if h < tmp:\\n                h = tmp\\n                h_a = [i]\\n            if h == tmp:\\n                h_a.append(i)\\n        w = 0\\n        w_a = []\\n        for i in range(n):\\n            tmp = len([i for i in a[i] if i == '*'])\\n            if w < tmp:\\n                w = tmp\\n                w_a = [i]\\n            if w == tmp:\\n                w_a.append(i)\\n        flag = 0\\n        for i in h_a:\\n            for j in w_a:\\n                if a[j][i] == '.':\\n                    flag = 1\\n                    break\\n        print(n+m-h-w-flag)\\n\\nmain()\\n\", \"\\nfor _ in range(int(input())):\\n    m,n=list(map(int,input().strip().split(' ')))\\n    grid=[]\\n    for i in range(m):\\n        grid+=[input()]\\n    row=[]\\n    col=[]\\n    MIN_row=10**10\\n    MIN_col=10**10\\n    for i in range(m):\\n        count=0\\n        for j in range(n):\\n            if grid[i][j]==\\\".\\\":\\n                count+=1\\n        row+=[count]\\n        MIN_row=min(MIN_row,count)\\n    for j in range(n):\\n        count=0\\n        for i in range(m):\\n            if grid[i][j]==\\\".\\\":\\n                count+=1\\n        col+=[count]\\n        MIN_col=min(MIN_col,count)\\n    \\n    want_row=set([])\\n    for i in range(len(row)):\\n        if row[i]==MIN_row:\\n            want_row.add(i)\\n            \\n    want_col=set([])\\n    for i in range(len(col)):\\n        if col[i]==MIN_col:\\n            want_col.add(i)\\n            \\n    flag=0\\n    for i in range(len(row)):\\n        if flag==1:\\n            break\\n        for j in range(len(col)):\\n            if grid[i][j]==\\\".\\\":\\n                if i in want_row and j in want_col:\\n                    flag=1\\n                    break\\n                    \\n    print(MIN_row+MIN_col-flag)\\n    \\n    \\n\", \"# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\\nfrom sys import stdin, stdout\\nimport collections\\nimport math\\n\\nT = int(input())\\n \\n#A,H,Q = [int(x) for x in stdin.readline().split()] \\nfor t in range(T):\\n    N,M = [int(x) for x in stdin.readline().split()]\\n    #print(N,M)\\n    data = []\\n    row = [M]*N\\n    col = [N]*M\\n    for i in range(N):\\n        s = input()\\n        data.append(list(s))\\n        for j in range(M):\\n            if s[j]=='*':\\n                row[i] -= 1\\n                col[j] -= 1\\n                \\n    min_row = min(row)\\n    min_col = min(col)\\n    \\n    if min_row==0 or min_col==0:\\n        print(min_row+min_col)\\n    else:\\n        r = []\\n        c = []\\n        #res = 9999999\\n        for i in range(N):\\n            if row[i]==min_row:\\n                r.append(i)\\n        for j in range(M):\\n            if col[j]==min_col:\\n                c.append(j)\\n                \\n        flag = 0\\n        for x in r:\\n            for y in c:\\n                if data[x][y]=='.' and flag==0:\\n                    print(min_row+min_col-1)\\n                    flag = 1\\n            if flag==1:\\n                break\\n                    \\n        if flag==0:        \\n            print(min_row+min_col)\\n                    \\n        \\n    \\n    \\n    \\n \\n\", \"q = int(input())\\nfor i in range(q):\\n    n, m = list(map(int,input().split()))\\n    field = [input() for j in range(n)]\\n    raw = [0] * n\\n    col = [0] * m\\n    num = 0\\n    for j in range(n):\\n        for z in range(m):\\n            if field[j][z] == \\\"*\\\":\\n                raw[j] += 1\\n                col[z] += 1\\n    for z in range(m):\\n        for j in range(n):\\n            temp = raw[j] + col[z] - int(field[j][z] == \\\"*\\\")\\n            if num < temp:\\n                num = temp\\n    print(n + m - num - 1)\\n\", \"def gns():\\n    return list(map(int,input().split()))\\nt=int(input())\\n\\n\\ndef one():\\n    n, m = gns()\\n    mp = []\\n    ns = [0] * n\\n    ms = [0] * m\\n    for i in range(n):\\n        mp.append(input())\\n        for j in range(m):\\n            if mp[-1][j] == '*':\\n                ns[i] += 1\\n                ms[j] += 1\\n    min_n = max(ns)\\n    min_m = max(ms)\\n    min_ns = set([i for i in range(n) if ns[i] == min_n])\\n    min_ms = set([i for i in range(m) if ms[i] == min_m])\\n    ans = n - min_n + m - min_m\\n    for i in min_ns:\\n        for j in min_ms:\\n            if mp[i][j] == '.':\\n                print(ans - 1)\\n                return\\n    print(ans)\\n\\n\\nfor i in range(t):\\n    one()\\n\\n\\n\\n\\n\", \"for TT in range(1, int(input()) + 1):\\n    n, m = map(int, input().split())\\n    mat = [[1 if c == '*' else 0 for c in input()] for _ in range(n)]\\n    h = [sum(l) for l in mat]\\n    v = [0] * m\\n    for i in range(n):\\n        for j in range(m):\\n            v[j] += mat[i][j]\\n    res = float('inf')\\n    for i in range(n):\\n        for j in range(m):\\n            val = (n - h[i]) + (m - v[j])\\n            if mat[i][j] == 0: val -= 1\\n            res = min(res, val)\\n    print(res)\", \"import sys\\ninput = lambda: sys.stdin.readline().strip()\\nprint = lambda x: sys.stdout.write(f\\\"{x}\\\\n\\\")\\n\\nfor t in range(int(input())):\\n  r, c = map(int, input().split())\\n  arr = [input() for i in range(r)]\\n  rarr = [0] * r\\n  carr = [0] * c\\n\\n  for i in range(r):\\n    for j in range(c):\\n      if arr[i][j] == '.':\\n        rarr[i] += 1\\n        carr[j] += 1\\n\\n  ans = float('inf')\\n  for i in range(r):\\n    for j in range(c):\\n      s = rarr[i] + carr[j]\\n      if arr[i][j] == '.':\\n        ans = min(ans, s - 1)\\n      else:\\n        ans = min(ans, s)\\n  \\n  print(ans)\\n\", \"def __starting_point():\\n    T = int(input())\\n    #fout = open('1194B.out', 'w')\\n    for _ in range(T):\\n        s = input().rstrip().split()\\n        n = int(s[0])\\n        m = int(s[1])\\n        cell = [[0 for j in range(m)] for i in range(n)]\\n        r = [0 for i in range(n)]\\n        c = [0 for j in range(m)]\\n        for i in range(n):\\n            s = input()\\n            for j in range(len(s)):\\n                cell[i][j] = s[j]\\n                if s[j] == '*':\\n                    r[i] += 1\\n                    c[j] += 1\\n        nmax = 0\\n        for i in range(n):\\n            for j in range(m):\\n                if r[i] + c[j] + (cell[i][j] == '.') > nmax:\\n                    nmax = r[i] + c[j] + (cell[i][j] == '.')\\n        print(str(m + n - nmax) + '\\\\n')\\n\\n__starting_point()\", \"q = int(input())\\n\\nfor _ in range(q):\\n    ans = 10000000000\\n    n, m = list(map(int, input().split()))\\n    picture = []\\n    dotcount_w = []\\n    dotcount_h = []\\n    for _ in range(n):\\n        picture.append(input())\\n        dotcount_w.append(picture[-1].count(\\\".\\\"))\\n\\n    for i in range(m):\\n        count = 0\\n        for j in range(n):\\n            if picture[j][i] == \\\".\\\":\\n                count += 1\\n        dotcount_h.append(count)\\n    for i in range(m):\\n        for j in range(n):\\n            if picture[j][i] == \\\".\\\":\\n                ans = min(dotcount_h[i]+dotcount_w[j]-1, ans)\\n            else:\\n                ans = min(dotcount_h[i]+dotcount_w[j], ans)\\n    print(ans)\\n\", \"q = int(input())\\nfor i in range(q):\\n    n,m = list(map(int,input().split()))\\n    a = [input() for _ in range(n)]\\n    a_t = list(zip(*a))\\n    mx_1 = mx_2 = 0\\n    idx_1 = []\\n    idx_2 = []\\n    for j,i in enumerate(a):\\n        temp = i.count('*')\\n        if temp > mx_1:\\n            mx_1 = temp\\n            idx_1 = [j]\\n        elif temp == mx_1:\\n            idx_1.append(j)\\n    for j,i in enumerate(a_t):\\n        temp = i.count('*')\\n        if temp > mx_2:\\n            mx_2 = temp\\n            idx_2 = [j]\\n        elif temp == mx_2:\\n            idx_2.append(j)\\n    ans = 0\\n    for i in idx_1:\\n        for j in idx_2:\\n            if a[i][j] == '.':\\n                ans = -1\\n    print(n+m-mx_1-mx_2+ans)\\n\\n\", \"M = 10**9 + 7\\nR = lambda: map(int, input().split())\\nn = int(input())\\nfor i in range(n):\\n    n,m = R()\\n    L = [[0 for i in range(m)] for j in range(n)]\\n    a = []\\n    for i in range(n):\\n        a.append(input())\\n    for i in range(n):\\n        c = 0\\n        for j in range(m):\\n            if a[i][j] == '.':c += 1\\n        for j in range(m):\\n            L[i][j] = c\\n    for i in range(m):\\n        c = 0\\n        for j in range(n):\\n            if a[j][i] == '.':c += 1\\n        for j in range(n):\\n            L[j][i] += c\\n    mi = 10**9\\n    k = []\\n    for i in range(n):\\n        for j in range(m):\\n            mi = min(mi,L[i][j])\\n    for i in range(n):\\n        for j in range(m):\\n            if L[i][j] == mi and a[i][j] == '.':\\n                mi -= 1\\n    print(mi)\"]", "input_output": "{\n  \"inputs\": [\n    \"9\\n5 5\\n..*..\\n..*..\\n*****\\n..*..\\n..*..\\n3 4\\n****\\n.*..\\n.*..\\n4 3\\n***\\n*..\\n*..\\n*..\\n5 5\\n*****\\n*.*.*\\n*****\\n..*.*\\n..***\\n1 4\\n****\\n5 5\\n.....\\n..*..\\n.***.\\n..*..\\n.....\\n5 3\\n...\\n.*.\\n.*.\\n***\\n.*.\\n3 3\\n.*.\\n*.*\\n.*.\\n4 4\\n*.**\\n....\\n*.**\\n*.**\\n\"\n  ],\n  \"outputs\": [\n    \"0\\n0\\n0\\n0\\n0\\n4\\n1\\n1\\n2\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1194/B", "starter_code": ""}
{"id": 79, "question": "An agent called Cypher is decrypting a message, that contains a composite number $n$. All divisors of $n$, which are greater than $1$, are placed in a circle. Cypher can choose the initial order of numbers in the circle.\n\nIn one move Cypher can choose two adjacent numbers in a circle and insert their least common multiple between them. He can do that move as many times as needed.\n\nA message is decrypted, if every two adjacent numbers are not coprime. Note that for such constraints it's always possible to decrypt the message.\n\nFind the minimal number of moves that Cypher should do to decrypt the message, and show the initial order of numbers in the circle for that.\n\n\n-----Input-----\n\nThe first line contains an integer $t$ $(1 \\le t \\le 100)$\u00a0\u2014 the number of test cases. Next $t$ lines describe each test case.\n\nIn a single line of each test case description, there is a single composite number $n$ $(4 \\le n \\le 10^9)$\u00a0\u2014 the number from the message.\n\nIt's guaranteed that the total number of divisors of $n$ for all test cases does not exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case in the first line output the initial order of divisors, which are greater than $1$, in the circle. In the second line output, the minimal number of moves needed to decrypt the message.\n\nIf there are different possible orders with a correct answer, print any of them.\n\n\n-----Example-----\nInput\n3\n6\n4\n30\n\nOutput\n2 3 6 \n1\n2 4 \n0\n2 30 6 3 15 5 10 \n0\n\n\n\n-----Note-----\n\nIn the first test case $6$ has three divisors, which are greater than $1$: $2, 3, 6$. Regardless of the initial order, numbers $2$ and $3$ are adjacent, so it's needed to place their least common multiple between them. After that the circle becomes $2, 6, 3, 6$, and every two adjacent numbers are not coprime.\n\nIn the second test case $4$ has two divisors greater than $1$: $2, 4$, and they are not coprime, so any initial order is correct, and it's not needed to place any least common multiples.\n\nIn the third test case all divisors of $30$ greater than $1$ can be placed in some order so that there are no two adjacent numbers that are coprime.", "solutions": "[\"from math import ceil\\n\\nt = int(input())\\nfor _ in range(t):\\n  n = int(input())\\n  pf = []\\n  for i in range(2, ceil(n**0.5)+1):\\n    while n % i == 0:\\n      pf.append(i)\\n      n //= i\\n  if n > 1:\\n    pf.append(n)\\n  if len(pf) == 2 and pf[0] != pf[1]:\\n    print(pf[0], pf[1], pf[0]*pf[1])\\n    print(1)\\n  else:\\n    pg = []\\n    fac = []\\n    nfac = []\\n    while len(pf) > 0:\\n      p = pf[-1]\\n      mul = 0\\n      while len(pf) > 0 and pf[-1] == p:\\n        pf.pop()\\n        mul += 1\\n      pg.append([mul, p])\\n    pg.sort()\\n    pg = pg[::-1]\\n    # print(pg)\\n    cur = 0\\n    if pg[0][0] == 1:\\n      a = pg[0][1]\\n      b = pg[1][1]\\n      c = pg[2][1]\\n      fac = [a, a*b*c, a*b, b, b*c, c, a*c]\\n      cur = 3\\n    else:\\n      fac = [pg[0][1]**i for i in range(1, pg[0][0]+1)]\\n      cur = 1\\n    while cur < len(pg):\\n      mul = pg[cur][0]\\n      p = pg[cur][1]\\n      nfac = []\\n      for i in range(len(fac)):\\n        if i == 0:\\n          nfac += [fac[i]*(p**j) for j in range(mul, -1, -1)]\\n        else:\\n          nfac += [fac[i]*(p**j) for j in range(mul+1)]\\n      nfac += [p**i for i in range(1, mul+1)]\\n      fac = nfac\\n      cur += 1\\n    print(\\\" \\\".join([str(i) for i in fac]))\\n    print(0)\\n\", \"\\ndef gcd(a, b):\\n    while b: a, b = b, a % b\\n    return a\\ndef isPrimeMR(n):\\n    d = n - 1\\n    d = d // (d & -d)\\n    L = [2, 7, 61] if n < 1<<32 else [2, 3, 5, 7, 11, 13, 17] if n < 1<<48 else [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\\n    for a in L:\\n        t = d\\n        y = pow(a, t, n)\\n        if y == 1: continue\\n        while y != n - 1:\\n            y = y * y % n\\n            if y == 1 or t == n - 1: return 0\\n            t <<= 1\\n    return 1\\ndef findFactorRho(n):\\n    m = 1 << n.bit_length() // 8\\n    for c in range(1, 99):\\n        f = lambda x: (x * x + c) % n\\n        y, r, q, g = 2, 1, 1, 1\\n        while g == 1:\\n            x = y\\n            for i in range(r):\\n                y = f(y)\\n            k = 0\\n            while k < r and g == 1:\\n                ys = y\\n                for i in range(min(m, r - k)):\\n                    y = f(y)\\n                    q = q * abs(x - y) % n\\n                g = gcd(q, n)\\n                k += m\\n            r <<= 1\\n        if g == n:\\n            g = 1\\n            while g == 1:\\n                ys = f(ys)\\n                g = gcd(abs(x - ys), n)\\n        if g < n:\\n            if isPrimeMR(g): return g\\n            elif isPrimeMR(n // g): return n // g\\n            return findFactorRho(g)\\ndef primeFactor(n):\\n    i = 2\\n    ret = {}\\n    rhoFlg = 0\\n    while i * i <= n:\\n        k = 0\\n        while n % i == 0:\\n            n //= i\\n            k += 1\\n        if k: ret[i] = k\\n        i += i % 2 + (3 if i % 3 == 1 else 1)\\n        if i == 101 and n >= 2 ** 20:\\n            while n > 1:\\n                if isPrimeMR(n):\\n                    ret[n], n = 1, 1\\n                else:\\n                    rhoFlg = 1\\n                    j = findFactorRho(n)\\n                    k = 0\\n                    while n % j == 0:\\n                        n //= j\\n                        k += 1\\n                    ret[j] = k\\n\\n    if n > 1: ret[n] = 1\\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\\n    return ret\\n\\ndef divisors(pf):\\n    ret = [1]\\n    for p in pf:\\n        ret_prev = ret\\n        ret = []\\n        for i in range(pf[p]+1):\\n            for r in ret_prev:\\n                ret.append(r * (p ** i))\\n    return sorted(ret)\\n\\nT = int(input())\\nfor _ in range(T):\\n    N = int(input())\\n    pf = primeFactor(N)\\n    dv = divisors(pf)\\n    if len(pf) == 2 and len(dv) == 4:\\n        print(*dv[1:])\\n        print(1)\\n        continue\\n    \\n    if len(pf) == 1:\\n        print(*dv[1:])\\n        print(0)\\n        continue\\n    \\n    lpf = list(pf)\\n    # print(\\\"lpf =\\\", lpf)\\n    \\n    X = [[] for _ in range(len(pf))]\\n    S = {1}\\n    if len(lpf) == 2:\\n        X[0].append(lpf[0] * lpf[1])\\n        X[1].append(N)\\n        S.add(lpf[0] * lpf[1])\\n        S.add(N)\\n        for i, p in enumerate(lpf):\\n            for j in range(1, pf[p] + 1):\\n                X[i].append(p ** j)\\n                S.add(p ** j)\\n    else:\\n        for i, p in enumerate(lpf):\\n            # print(\\\"i, p, pf[p] =\\\", i, p, pf[p])\\n            X[i].append(lpf[i-1] * p)\\n            S.add(lpf[i-1] * p)\\n            for j in range(1, pf[p] + 1):\\n                X[i].append(p ** j)\\n                S.add(p ** j)\\n    for a in dv:\\n        if a not in S:\\n            for i, p in enumerate(lpf):\\n                if a % p == 0:\\n                    X[i].append(a)\\n                    break\\n    # print(\\\"X =\\\", X)\\n    ANS = []\\n    for x in X:\\n        for y in x:\\n            ANS.append(y)\\n    print(*ANS)\\n    print(0)\\n\", \"t = int(input())\\nfor _ in range(t):\\n    works = 0\\n    n = int(input())\\n    ps = []\\n    for i in range(2,4*10**4):\\n        c = 0\\n        while n % i == 0:\\n            c += 1\\n            n //= i\\n        if c:\\n            ps.append((i,c))\\n    if n > 1:\\n        ps.append((n,1))\\n    if len(ps) >= 3:\\n        base = [0] * (2 * len(ps))\\n        lists = [[] for i in range(2 * len(ps))]\\n        for i in range(len(ps)):\\n            base[2*i] = ps[i][0]\\n            base[2*i+1] = ps[i][0] * ps[(i + 1)%len(ps)][0]\\n            factors = [1]\\n\\n        for p,pp in ps:\\n            mult = [pow(p,i) for i in range(pp+1)]\\n            new = []\\n            for m in mult:\\n                for f in factors:\\n                    new.append(m*f)\\n            factors = new\\n        \\n        for v in factors:\\n            if v in base:\\n                lists[base.index(v)] += [v]\\n            else:\\n                for u in range(2*len(ps)):\\n                    if v % base[u] ==0:\\n                        lists[u] += [v]\\n                        break\\n    \\n        out=sum(lists,[])\\n    elif len(ps) == 2:\\n        p, q = ps\\n        if p[1] < q[1]:\\n            p,q=q,p\\n        p, pp = p\\n        q, qq = q\\n        if pp == 1 and qq == 1:\\n            works = 1\\n            out = [p,p*q,q]\\n        else:\\n            base = [p,p*q,q,p*p*q]\\n            lists = [[],[],[],[]]\\n            for i in range(pp + 1):\\n                for j in range(qq + 1):\\n                    v = pow(p,i) * pow(q,j)\\n                    if v in base:\\n                        lists[base.index(v)] += [v]\\n                    else:\\n                        for u in range(4):\\n                            if v % base[u]==0:\\n                                lists[u] += [v]\\n                                break\\n            out=sum(lists,[])\\n            \\n    else:\\n        out = []\\n        for i in range(1, ps[0][1]+1):\\n            out.append(pow(ps[0][0],i))\\n    print(' '.join(map(str,out)))\\n    print(works)\\n\", \"import itertools\\ny=lambda:int(input())\\np=[1]*32000\\nfor i in range(180):\\n    if p[i]:\\n        for j in range(2*i+2,len(p),i+2):p[j]=0\\nq=[i+2 for i in range(len(p))if p[i]]\\nfor _ in range(y()):\\n    n=y();d=[];e=set()\\n    for i in q:\\n        if n%i<1:\\n            n//=i;d.append([i,1])\\n            while n%i<1:n//=i;d[-1][1]+=1\\n    if n>1:d.append([n,1])\\n    l=len(d)\\n    for i in itertools.product(*(range(i[1]+1)for i in d)):\\n        p=1\\n        for j in range(l):p*=d[j][0]**i[j]\\n        e.add(p)\\n    e.remove(1)\\n    \\n    b=l==2 and d[0][1]+d[1][1]==2\\n    if l<2 or b:f=list(e)\\n    elif l<3:\\n        s=d[1][1]>1\\n        v=d[s][0]*d[1-s][0]\\n        f=[v]\\n        e.remove(v)\\n        k=set()\\n        for i in e:\\n            if i%d[1-s][0]<1:k.add(i);f.append(i)\\n        v=(d[s][0]**2)*d[1-s][0]\\n        f.remove(v)\\n        f.append(v)\\n        e-=k\\n        for i in e:f.append(i)\\n    else:\\n        v=d[0][0]*d[-1][0]\\n        f=[v]\\n        e.remove(v)\\n        for i in range(l):\\n            v=d[i][0]*d[i-1][0]\\n            f.remove(v)\\n            f.append(v)\\n            k=set()\\n            for j in e:\\n                if j%d[i][0]<1:k.add(j);f.append(j)\\n            e-=k\\n    print(' '.join(map(str,f)))\\n    print(int(b))\", \"import sys\\ninput=sys.stdin.readline\\nt=int(input())\\nfor you in range(t):\\n    n=int(input())\\n    z=n\\n    primes=[]\\n    i=2\\n    while(i*i<=z):\\n        if(z%i==0):\\n            primes.append(i)\\n            while(z%i==0):\\n                z=z//i\\n        i+=1\\n    if(z!=1):\\n        primes.append(z)\\n    hashi=dict()\\n    for i in primes:\\n        hashi[i]=[]\\n    hashinew=dict()\\n    new=[]\\n    k=len(primes)\\n    hasho=dict()\\n    if(k>2):\\n        for i in range(k):\\n            new.append(primes[i]*primes[(i+1)%k])\\n            hasho[primes[i]*primes[(i+1)%k]]=1\\n    if(k==2):\\n        hasho[primes[0]*primes[1]]=1\\n    i=2\\n    while(i*i<=n):\\n        if(n%i==0):\\n            num1=i\\n            num2=n//i\\n            if(num1 not in hasho):\\n                for j in primes:\\n                    if(num1%j==0):\\n                        break\\n                hashi[j].append(num1)\\n            if(num2!=num1 and num2 not in hasho):\\n                for j in primes:\\n                    if(num2%j==0):\\n                        break\\n                hashi[j].append(num2)\\n        i+=1\\n    for j in primes:\\n        if(n%j==0):\\n            break\\n    hashi[j].append(n)\\n    done=dict()\\n    if(len(primes)==1):\\n        for i in hashi[primes[0]]:\\n            print(i,end=\\\" \\\")\\n        print()\\n        print(0)\\n        continue\\n    if(len(primes)==2):\\n        if(primes[0]*primes[1]==n):\\n            print(primes[0],primes[1],n)\\n            print(1)\\n        else:\\n            for i in hashi[primes[0]]:\\n                print(i,end=\\\" \\\")\\n            for i in hashi[primes[1]]:\\n                print(i,end=\\\" \\\")\\n            print(primes[0]*primes[1],end=\\\" \\\")\\n            print()\\n            print(0)\\n        continue\\n    for i in range(k):\\n        for j in hashi[primes[i]]:\\n            print(j,end=\\\" \\\")\\n        ko=primes[i]*primes[(i+1)%k]\\n        print(ko,end=\\\" \\\")\\n    print()\\n    print(0)\\n\", \"import sys\\ninput=lambda:sys.stdin.readline().rstrip()\\n\\ndef gcd(a, b):\\n  while b: a, b = b, a % b\\n  return a\\ndef isPrimeMR(n):\\n  d = n - 1\\n  d = d // (d & -d)\\n  L = [2, 3, 61]\\n  for a in L:\\n    t = d\\n    y = pow(a, t, n)\\n    if y == 1: continue\\n    while y != n - 1:\\n      y = (y * y) % n\\n      if y == 1 or t == n - 1: return 0\\n      t <<= 1\\n  return 1\\ndef findFactorRho(n):\\n  m = 1 << n.bit_length() // 8\\n  for c in range(1, 99):\\n    f = lambda x: (x * x + c) % n\\n    y, r, q, g = 2, 1, 1, 1\\n    while g == 1:\\n      x = y\\n      for i in range(r):\\n        y = f(y)\\n      k = 0\\n      while k < r and g == 1:\\n        ys = y\\n        for i in range(min(m, r - k)):\\n          y = f(y)\\n          q = q * abs(x - y) % n\\n        g = gcd(q, n)\\n        k += m\\n      r <<= 1\\n    if g == n:\\n      g = 1\\n      while g == 1:\\n        ys = f(ys)\\n        g = gcd(abs(x - ys), n)\\n    if g < n:\\n      if isPrimeMR(g): return g\\n      elif isPrimeMR(n // g): return n // g\\n      return findFactorRho(g)\\ndef primeFactor(n):\\n  i = 2\\n  ret = {}\\n  rhoFlg = 0\\n  while i*i <= n:\\n    k = 0\\n    while n % i == 0:\\n      n //= i\\n      k += 1\\n    if k: ret[i] = k\\n    i += 1 + i % 2\\n    if i == 101 and n >= 2 ** 20:\\n      while n > 1:\\n        if isPrimeMR(n):\\n          ret[n], n = 1, 1\\n        else:\\n          rhoFlg = 1\\n          j = findFactorRho(n)\\n          k = 0\\n          while n % j == 0:\\n            n //= j\\n            k += 1\\n          ret[j] = k\\n\\n  if n > 1: ret[n] = 1\\n  if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\\n  return ret\\n\\nfor _ in range(int(input())):\\n  n=int(input())\\n  ret=primeFactor(n)\\n  m=len(ret)\\n  s=1\\n  a=[]\\n  for i in ret:\\n    a.append(i)\\n    s*=ret[i]+1\\n  ans=[]\\n  for i in range(m):\\n    s//=ret[a[i]]+1\\n    for j in range(1,ret[a[i]]+1):\\n      for k in range(s):\\n        x=a[i]**j\\n        for l in range(i+1,m):\\n          k,t=divmod(k,ret[a[l]]+1)\\n          x*=a[l]**t\\n        ans.append(x)\\n  if gcd(ans[0],ans[-1])==1:\\n    del ans[ans.index(ans[0]*ans[-1])]\\n    ans.append(ans[0]*ans[-1])\\n  anss=0\\n  for i in range(len(ans)-1):\\n    if gcd(ans[i],ans[i+1])==1:anss+=1\\n  print(*ans)\\n  print(anss)\", \"from bisect import bisect_left as bl\\nfrom bisect import bisect_right as br\\nfrom heapq import heappush,heappop,heapify\\nimport math\\nfrom collections import *\\nfrom functools import reduce,cmp_to_key\\nimport sys\\ninput = sys.stdin.readline\\n\\nfrom itertools import accumulate\\nfrom functools import lru_cache\\n\\nM = mod = 998244353\\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\\ndef inv_mod(n):return pow(n, mod - 2, mod)\\n \\ndef li():return [int(i) for i in input().rstrip('\\\\n').split()]\\ndef st():return input().rstrip('\\\\n')\\ndef val():return int(input().rstrip('\\\\n'))\\ndef li2():return [i for i in input().rstrip('\\\\n')]\\ndef li3():return [int(i) for i in input().rstrip('\\\\n')]\\n\\n\\n\\ndef isprime(n):\\n    for j in range(2, int(n ** 0.5) + 1):\\n        if n % j == 0:return 0\\n    return 1\\n\\nfor _ in range(val()):\\n    n = val()\\n\\n    l1 = factors(n)[1:]\\n    l = []\\n    for j in l1:\\n        if isprime(j):l.append(j)\\n    l1 = set(l1)\\n    l1 -= set(l)\\n    # print(l, l1)\\n    d = defaultdict(set)\\n    for j in range(len(l)):\\n        for i in sorted(list(l1)):\\n            if i % l[j] == 0 and i % l[j - 1] == 0:\\n                d[tuple(sorted([l[j], l[j - 1]]))].add(i)\\n                l1.remove(i)\\n                break\\n    # print(l, l1)\\n    for j in range(len(l)):\\n        for i in sorted(list(l1)):\\n            if i % l[j] == 0 and i % l[j - 1] == 0:\\n                d[tuple(sorted([l[j], l[j - 1]]))].add(i)\\n                l1.remove(i)\\n    # print(l, l1, d)\\n\\n    only = defaultdict(list)\\n    for j in range(len(l)):\\n        for i in sorted(list(l1)):\\n            if i % l[j] == 0:\\n                only[l[j]].append(i)\\n                l1.remove(i)\\n    \\n    fin = []\\n    if len(l) == 2:\\n        fin.append(l[0])\\n        for j in only[l[0]]:fin.append(j)\\n        for i in range(len(l)):\\n            for j in list(d[tuple(sorted([l[i], l[(i + 1)  % len(l)]]))]):\\n                fin.append(j)\\n                d[tuple(sorted([l[i], l[(i + 1)  % len(l)]]))].remove(j)\\n                if i != len(l) - 1:break\\n            if i != len(l) - 1:\\n                fin.append(l[i + 1])\\n                for j in only[l[i + 1]]:\\n                    fin.append(j)\\n\\n\\n\\n\\n    else:\\n        fin.append(l[0])\\n        for j in only[l[0]]:fin.append(j)\\n        for i in range(len(l)):\\n            for j in d[tuple(sorted([l[i], l[(i + 1)  % len(l)]]))]:\\n                fin.append(j)\\n            if i != len(l) - 1:\\n                fin.append(l[i + 1])\\n                for j in only[l[i + 1]]:\\n                    fin.append(j)\\n\\n\\n    ans = 0\\n    for i in range(len(fin)):\\n        if math.gcd(fin[i], fin[i - 1]) == 1:ans += 1\\n    print(*fin)\\n    print(ans)\", \"from sys import stdin\\ninput = stdin.readline\\nq = int(input())\\nfor _ in range(q):\\n    n = int(input())\\n    pier = []\\n    i = 2\\n    nn = n\\n    while True:\\n        if nn%i == 0:\\n            pier.append(i)\\n            nn//=i\\n        else:\\n            i+= 1\\n        if i**2 > n:\\n            break\\n    if nn != 1:\\n        pier.append(nn)\\n    pier_unique = list(set(pier))\\n    dzielniki = [1]\\n    for p in pier_unique:\\n        pot = p\\n        addition = []\\n        while n%pot == 0:\\n            addition1 = [d*pot for d in dzielniki]\\n            addition += addition1\\n            pot *= p\\n        dzielniki += addition\\n    dzielniki = dzielniki[1:]\\n    k = len(pier_unique)\\n    if k == 1:\\n        print(*dzielniki)\\n        print(0)\\n    elif k >= 3:\\n        dzielniki = set(dzielniki)\\n        odp = []\\n        for i in range(k):\\n            dzielniki.remove(pier_unique[i-1]*pier_unique[i])\\n        for i in range(k):\\n            odp.append(pier_unique[i-1]*pier_unique[i])\\n            to_rem = []\\n            for dz in dzielniki:\\n                if dz%pier_unique[i] == 0:\\n                    to_rem.append(dz)\\n                    odp.append(dz)\\n            for to in to_rem:\\n                dzielniki.remove(to)\\n        print(*odp)\\n        print(0)\\n    else:\\n        p = pier_unique[0]\\n        q = pier_unique[1]\\n        if n == p*q:\\n            print(p,q,p*q)\\n            print(1)\\n        else:\\n            test = p**2\\n            if n%test != 0:\\n                p,q= q,p\\n            #p^2 dzieli n\\n            dzielniki = set(dzielniki)\\n            dzielniki.remove(p*q)\\n            dzielniki.remove(p*p*q)\\n            odp = [p*q]\\n            to_rem = []\\n            for dzu in dzielniki:\\n                if dzu%p == 0:\\n                    to_rem.append(dzu)\\n                    odp.append(dzu)\\n            for tu in to_rem:\\n                dzielniki.remove(tu)\\n            odp.append(p*p*q)\\n            for dzu in dzielniki:\\n                odp.append(dzu)\\n            print(*odp)\\n            print(0)\\n\\n\", \"from sys import stdin, stdout\\nimport math\\nimport bisect\\n\\ndef gcd(a,b):\\n    while b > 0:\\n        a, b = b, a % b\\n    return a\\n\\ndef solve(n):\\n    dv = [n]\\n    x = 2\\n    while x*x <= n:\\n        if n%x == 0:\\n            dv.append(x)\\n            if x != n//x:\\n                dv.append(n//x)\\n        x += 1\\n    dv = sorted(dv)\\n    ans = [0]*len(dv) \\n\\n    ans[0], ans[-1] = dv[0], dv[-1]\\n    seen = {dv[0], dv[-1]}\\n    cur_prime = dv[0]\\n    min_prime = dv[0]\\n    while len(seen) < len(dv):\\n        for x in dv:\\n            if x in seen: continue\\n            if min_prime == -1:\\n                min_prime = x\\n\\n            if cur_prime == -1:\\n                if ans[len(seen)-2]%x == 0:\\n                    cur_prime = x\\n                    ans[len(seen)-1] = x\\n                    seen.add(x)\\n            else:\\n                if x%cur_prime == 0:\\n                    ans[len(seen)-1] = x\\n                    seen.add(x)\\n        if cur_prime == -1:\\n            cur_prime = min_prime\\n        else:\\n            cur_prime = -1\\n        min_prime = -1\\n    cnt = 0\\n    for i in range(1, len(ans)):\\n        if gcd(ans[i], ans[i-1]) == 1:\\n            cnt += 1\\n    print(\\\" \\\".join(map(str, ans)))\\n    print(cnt)\\n\\nt = int(stdin.readline())\\nfor _ in range(t):\\n    n = int(stdin.readline())\\n    solve(n)\\n\\n#for i in range(2, 50):\\n#    solve(i)\\n\", \"# prime power always 0\\n# two prime powers?\\n#\\n# == 1 prime factor\\n#   trivial\\n# == 2 prime factors\\n#   p^a q^b\\n#   if a + b > 2: then fine\\n#   p*q\\n#   (remaining with p)\\n#   p*p*q\\n#   (remaining with q)\\n# >= 3 prime factors is fine\\n#   what ordering?\\n#   p*q*r\\n#   (all left with p)\\n#   p*q\\n#   (all left with q)\\n#   q*r\\n#   (all left with r)\\n\\nfrom collections import defaultdict as dd, deque\\n\\ndef factor(n):\\n    factors = dd(int)\\n    d = 2\\n    while d*d <= n:\\n        while n%d == 0:\\n            factors[d] += 1\\n            n //= d\\n        d += 1\\n    if n != 1:\\n        factors[n] += 1\\n    return factors\\n\\ndef divisors(n) : \\n    i = 1\\n    factors = []\\n    while i*i <= n: \\n        if n % i == 0: \\n            # If divisors are equal, print only one \\n            if n//i == i: \\n                factors.append(i)\\n            else : \\n                factors.append(i)\\n                factors.append(n//i)\\n        i += 1\\n    return factors\\n\\nt = int(input())\\n\\nfor _ in range(t):\\n    n = int(input())\\n    F = factor(n)\\n    D = set(divisors(n))\\n    D.remove(1)\\n    if len(F) == 1:\\n        print(*list(D))\\n        print(0)\\n        continue\\n    if len(F) == 2:\\n        p,q = list(F)\\n        exp = sum(F.values())\\n        if exp > 2:\\n            res = []\\n            D.remove(p*q)\\n            D.remove(p*p*q)\\n\\n            divP = {d for d in D if d%p == 0}\\n            divQ = D - divP\\n            print(p*q, *divP, p*p*q, *divQ)\\n            print(0)\\n        else:\\n            print(p, p*q, q)\\n            print(1)\\n        continue\\n    first = 1\\n    for prime in F:\\n        first *= prime\\n    D.remove(first)\\n    Flist = list(F)\\n    res = [first]\\n    for i in range(len(Flist)-1):\\n        p,q = Flist[i-1],Flist[i]\\n        D.remove(p*q)\\n    for i in range(len(Flist)-1):\\n        p,q = Flist[i-1],Flist[i]\\n        div = {d for d in D if d%p == 0}\\n        D -= div\\n        res.extend(div)\\n        res.append(p*q)\\n    res.extend(D)\\n    print(*res)\\n    print(0)\\n\", \"from itertools import product\\ndef p_factorization_t(n):\\n    if n == 1: return []\\n    pf_cnt = []\\n    temp = n\\n    for i in range(2, int(-(-n**0.5//1))+1):\\n        if temp%i == 0:\\n            cnt = 0\\n            while temp%i == 0:\\n                cnt += 1\\n                temp //= i\\n            pf_cnt.append((i,cnt))\\n\\n    if temp != 1: pf_cnt.append((temp,1))\\n    return pf_cnt\\n\\n\\ndef main():\\n    ansl = []\\n    for _ in range(int(input())):\\n        n = int(input())\\n        facs = p_factorization_t(n)\\n        # print(facs)\\n        if len(facs) == 1:\\n            p,cnt = facs[0]\\n            al = []\\n            for i in range(1,cnt+1):\\n                al.append(pow(p,i))\\n            print(*al)\\n            print(0)\\n\\n        ff = []\\n        pd = {}\\n        ps = []\\n        for p,cnt in facs:\\n            row = []\\n            for i in range(0,cnt+1):\\n                row.append(pow(p,i))\\n            ff.append(row)\\n            pd[p] = []\\n            ps.append(p)\\n\\n        vals = [1]\\n        for row in ff:\\n            new_vals = []\\n            for v in vals:\\n                for p in row:\\n                    new_vals.append(p*v)\\n                    if p != 1:\\n                        pd[row[1]].append(v*p)\\n            vals = new_vals[:]\\n        \\n\\n        if len(facs) >= 3:\\n            al = []\\n            for i in range(len(ps)):\\n                cval = -1\\n                if i > 0:\\n                    cval = (ps[i]*ps[i-1])\\n                    al.append(cval)\\n                else:\\n                    cval = (ps[i]*ps[-1])\\n                for v in pd[ps[i]]:\\n                    if v != cval:\\n                        al.append(v)\\n            print(*al)\\n            print(0)\\n\\n        elif len(facs) == 2:\\n            al = []\\n            for i in range(len(ps)):\\n                cval = -1\\n                if i > 0:\\n                    cval = (ps[i]*ps[i-1])\\n                    al.append(cval)\\n                else:\\n                    cval = (ps[i]*ps[-1])\\n                for v in pd[ps[i]]:\\n                    if v != cval:\\n                        al.append(v)\\n            print(*al)\\n            if facs[0][1] == 1 and facs[1][1] == 1:\\n                print(1)\\n            else:\\n                print(0)\\n\\n        # elif len(facs) == 2:\\n\\n\\n\\n\\n\\n\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"def gen(i, cur):\\n    nonlocal dvs, used\\n    if i == len(kk):\\n        if (ohne != 1 or cur != 1) and (ok or not used[cur * ohne]):\\n            dvs.append(cur * ohne)\\n        return\\n    gen(i + 1, cur)\\n    for j in range(kk[i]):\\n        cur *= pp[i]\\n        gen(i + 1, cur)\\n\\n\\ngans = []\\nfor _ in range(int(input())):\\n    n = int(input())\\n    pp = []\\n    kk = []\\n    i = 2\\n    cnt = []\\n    while i * i <= n:\\n        if n % i == 0:\\n            pp.append(i)\\n            kk.append(0)\\n            while n % i == 0:\\n                kk[-1] += 1\\n                n //= i\\n        i += 1\\n    if n != 1:\\n        pp.append(n)\\n        kk.append(1)\\n    dvs = []\\n    ohne = 1\\n    ok = True\\n    gen(0, 1)\\n    if len(pp) == 1:\\n        gans.append(' '.join(map(str, dvs)))\\n        gans.append(str(0))\\n    elif len(pp) == 2 and kk[0] == kk[1] == 1:\\n        gans.append(' '.join(map(str, dvs)))\\n        gans.append(str(1))\\n    elif len(pp) == 2:\\n        used = dict()\\n        for i in range(len(dvs)):\\n            used[dvs[i]] = False\\n        ans = []\\n        ok = False\\n        used[pp[0] * pp[1]] = True\\n        aaa = [pp[0] * pp[1]]\\n        if kk[0] > 1:\\n            used[pp[0] * pp[0] * pp[1]] = True\\n            aaa.append(pp[0] * pp[0] * pp[1])\\n        else:\\n            used[pp[0] * pp[1] * pp[1]] = True\\n            aaa.append(pp[0] * pp[1] * pp[1])\\n        for i in range(len(pp)):\\n            dvs = []\\n            ans.append(aaa[i])\\n            kk[i] -= 1\\n            ohne = pp[i]\\n            gen(0, 1)\\n            for j in range(len(dvs)):\\n                used[dvs[j]] = True\\n                ans.append(dvs[j])\\n        gans.append(' '.join(map(str, ans)))\\n        gans.append(str(0))\\n    else:\\n        used = dict()\\n        for i in range(len(dvs)):\\n            used[dvs[i]] = False\\n        ans = []\\n        ok = False\\n        for i in range(len(pp)):\\n            used[pp[i - 1] * pp[i]] = True\\n        for i in range(len(pp)):\\n            dvs = []\\n            ans.append(pp[i - 1] * pp[i])\\n            kk[i] -= 1\\n            ohne = pp[i]\\n            gen(0, 1)\\n            for j in range(len(dvs)):\\n                used[dvs[j]] = True\\n                ans.append(dvs[j])\\n        gans.append(' '.join(map(str, ans)))\\n        gans.append(str(0))\\nprint('\\\\n'.join(gans))\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n6\\n4\\n30\\n\"\n  ],\n  \"outputs\": [\n    \"2 3 6 \\n1\\n2 4 \\n0\\n2 30 6 3 15 5 10 \\n0\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1419/E", "starter_code": ""}
{"id": 80, "question": "While doing some spring cleaning, Daniel found an old calculator that he loves so much. However, it seems like it is broken. When he tries to compute $1 + 3$ using the calculator, he gets $2$ instead of $4$. But when he tries computing $1 + 4$, he gets the correct answer, $5$. Puzzled by this mystery, he opened up his calculator and found the answer to the riddle: the full adders became half adders! \n\nSo, when he tries to compute the sum $a + b$ using the calculator, he instead gets the xorsum $a \\oplus b$ (read the definition by the link: https://en.wikipedia.org/wiki/Exclusive_or).\n\nAs he saw earlier, the calculator sometimes gives the correct answer. And so, he wonders, given integers $l$ and $r$, how many pairs of integers $(a, b)$ satisfy the following conditions: $$a + b = a \\oplus b$$ $$l \\leq a \\leq r$$ $$l \\leq b \\leq r$$\n\nHowever, Daniel the Barman is going to the bar and will return in two hours. He tells you to solve the problem before he returns, or else you will have to enjoy being blocked.\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 100$) \u2014 the number of testcases.\n\nThen, $t$ lines follow, each containing two space-separated integers $l$ and $r$ ($0 \\le l \\le r \\le 10^9$).\n\n\n-----Output-----\n\nPrint $t$ integers, the $i$-th integer should be the answer to the $i$-th testcase.\n\n\n-----Example-----\nInput\n3\n1 4\n323 323\n1 1000000\n\nOutput\n8\n0\n3439863766\n\n\n\n-----Note-----\n\n$a \\oplus b$ denotes the bitwise XOR of $a$ and $b$.\n\nFor the first testcase, the pairs are: $(1, 2)$, $(1, 4)$, $(2, 1)$, $(2, 4)$, $(3, 4)$, $(4, 1)$, $(4, 2)$, and $(4, 3)$.", "solutions": "[\"def solve(L, R):\\n    res = 0\\n    for i in range(32):\\n        for j in range(32):\\n            l = (L >> i) << i\\n            r = (R >> j) << j\\n            #print(l, r)\\n            if l>>i&1==0 or r>>j&1==0:\\n                continue\\n            l -= 1<<i\\n            r -= 1<<j\\n            if l & r:\\n                continue\\n            lr = l ^ r\\n            ma = max(i, j)\\n            mi = min(i, j)\\n            mask = (1<<ma)-1\\n            p = bin(lr&mask).count(\\\"1\\\")\\n            ip = ma - mi - p\\n            res += 3**mi * 2**ip\\n            #print(l, r, mi, ip, 3**mi * 2**ip)\\n    return res\\n\\nT = int(input())\\nfor _ in range(T):\\n    l, r = list(map(int, input().split()))\\n    print(solve(r+1, r+1) + solve(l, l) - solve(l, r+1) * 2)\\n\", \"def g( a , b ):\\n    cur = 1\\n    res = 0\\n    ze = 0\\n    while cur <= b:\\n        if b & cur:\\n            b ^= cur\\n            if a & b == 0:\\n                res += ( 1 << ze )\\n        if a & cur == 0:\\n            ze = ze + 1\\n        cur <<= 1\\n    return res\\n\\ndef f( a , b ):\\n    res = 0\\n    if a == b:\\n        return 0\\n    if a == 0:\\n        return 2 * b - 1 + f( 1 , b )\\n    if a & 1:\\n        res = res + 2 * ( g( a , b ) - g( a , a ) )\\n        a = a + 1\\n    if b & 1:\\n        res = res + 2 * ( g( b - 1 , b ) - g( b - 1 , a ) )\\n    return 3 * f( a >> 1 , b >> 1 ) + res\\n\\nt = int(input())\\n\\nwhile t > 0:\\n    t = t - 1\\n    l , r = map(int , input().split())\\n    print( f( l , r + 1 ) )\", \"def g( a , b ):\\n    cur = 1\\n    res = 0\\n    ze = 0\\n    while cur <= b:\\n        if b & cur:\\n            b ^= cur\\n            if a & b == 0:\\n                res += ( 1 << ze )\\n        if a & cur == 0:\\n            ze = ze + 1\\n        cur <<= 1\\n    return res\\n \\ndef f( a , b ):\\n    res = 0\\n    if a == b:\\n        return 0\\n    if a == 0:\\n        return 2 * b - 1 + f( 1 , b )\\n    if a & 1:\\n        res = res + 2 * ( g( a , b ) - g( a , a ) )\\n        a = a + 1\\n    if b & 1:\\n        res = res + 2 * ( g( b - 1 , b ) - g( b - 1 , a ) )\\n    return 3 * f( a >> 1 , b >> 1 ) + res\\n \\nt = int(input())\\n \\nwhile t > 0:\\n    t = t - 1\\n    l , r = map(int , input().split())\\n    print( f( l , r + 1 ) )\", \"\\ndef get_bin (a):\\n    nums=[]\\n    for i in range (32):\\n        if ((1<<i)&a):\\n            nums.append(1)\\n        else:\\n            nums.append(0)\\n    \\n    while(len(nums)>0 and nums[-1]==0):\\n        nums.pop()\\n    \\n    return nums\\n\\ndp={}\\ndef get_num (a, b):\\n    nonlocal dp\\n    if ((a,b) in dp):\\n        return dp[(a,b)]\\n    if (a < 0 or b < 0):\\n        return 0 \\n    if (a == 0 and b == 0):\\n        return 1\\n    \\n    a_bin = get_bin(a)\\n    b_bin = get_bin(b)\\n    \\n    if(b>a):\\n        a_bin,b_bin=b_bin,a_bin\\n        a,b=b,a\\n    \\n    if (len(a_bin)>len(b_bin)):\\n        big_bit = 1 << (len(a_bin) - 1)\\n        to_ret=((get_num(big_bit-1,b) + get_num(a-big_bit, b)))\\n        dp[(a,b)]=to_ret\\n        return to_ret\\n    \\n    if(sum(a_bin)==len(a_bin) and sum(b_bin)==len(b_bin)):\\n        to_ret = pow(3, len(a_bin))\\n        dp[(a,b)]=to_ret\\n        return to_ret\\n        \\n    big_bit = 1 << (len(a_bin) - 1)\\n    to_ret=(get_num(big_bit-1, b-big_bit) + get_num(a, big_bit-1))\\n    dp[(a,b)]=to_ret\\n    return to_ret\\n    \\n    \\n        \\n    \\ntc = int(input(\\\"\\\"))\\n\\nfor i in range (int(tc)): \\n    nums = input(\\\"\\\").split(' ')\\n    \\n    l = int(nums[0])\\n    r = int(nums[1])\\n    \\n    ans = get_num(r, r) - 2 * get_num(r, l - 1) + get_num(l - 1, l - 1)\\n\\n    print(ans)\\n\", \"def g( a , b ):\\n    cur = 1\\n    res = 0\\n    ze = 0\\n    while cur <= b:\\n        if b & cur:\\n            b ^= cur\\n            if a & b == 0:\\n                res += ( 1 << ze )\\n        if a & cur == 0:\\n            ze = ze + 1\\n        cur <<= 1\\n    return res\\n \\ndef f( a , b ):\\n    res = 0\\n    if a == b:\\n        return 0\\n    if a == 0:\\n        return 2 * b - 1 + f( 1 , b )\\n    if a & 1:\\n        res = res + 2 * ( g( a , b ) - g( a , a ) )\\n        a = a + 1\\n    if b & 1:\\n        res = res + 2 * ( g( b - 1 , b ) - g( b - 1 , a ) )\\n    return 3 * f( a >> 1 , b >> 1 ) + res\\n \\nt = int(input())\\n \\nwhile t > 0:\\n    t = t - 1\\n    l , r = map(int , input().split())\\n    print( f( l , r + 1 ) )\", \"def g( a , b ):\\n    cur = 1\\n    res = 0\\n    ze = 0\\n    while cur <= b:\\n        if b & cur:\\n            b ^= cur\\n            if a & b == 0:\\n                res += ( 1 << ze )\\n        if a & cur == 0:\\n            ze = ze + 1\\n        cur <<= 1\\n    return res\\n \\ndef f( a , b ):\\n    res = 0\\n    if a == b:\\n        return 0\\n    if a == 0:\\n        return 2 * b - 1 + f( 1 , b )\\n    if a & 1:\\n        res = res + 2 * ( g( a , b ) - g( a , a ) )\\n        a = a + 1\\n    if b & 1:\\n        res = res + 2 * ( g( b - 1 , b ) - g( b - 1 , a ) )\\n    return 3 * f( a >> 1 , b >> 1 ) + res\\n \\nt = int(input())\\n \\nwhile t > 0:\\n    t = t - 1\\n    l , r = list(map(int , input().split()))\\n    print( f( l , r + 1 ) )\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n1 4\\n323 323\\n1 1000000\\n\"\n  ],\n  \"outputs\": [\n    \"8\\n0\\n3439863766\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1245/F", "starter_code": ""}
{"id": 81, "question": "You are given three strings $a$, $b$ and $c$ of the same length $n$. The strings consist of lowercase English letters only. The $i$-th letter of $a$ is $a_i$, the $i$-th letter of $b$ is $b_i$, the $i$-th letter of $c$ is $c_i$.\n\nFor every $i$ ($1 \\leq i \\leq n$) you must swap (i.e. exchange) $c_i$ with either $a_i$ or $b_i$. So in total you'll perform exactly $n$ swap operations, each of them either $c_i \\leftrightarrow a_i$ or $c_i \\leftrightarrow b_i$ ($i$ iterates over all integers between $1$ and $n$, inclusive).\n\nFor example, if $a$ is \"code\", $b$ is \"true\", and $c$ is \"help\", you can make $c$ equal to \"crue\" taking the $1$-st and the $4$-th letters from $a$ and the others from $b$. In this way $a$ becomes \"hodp\" and $b$ becomes \"tele\".\n\nIs it possible that after these swaps the string $a$ becomes exactly the same as the string $b$?\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 100$) \u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a string of lowercase English letters $a$.\n\nThe second line of each test case contains a string of lowercase English letters $b$.\n\nThe third line of each test case contains a string of lowercase English letters $c$.\n\nIt is guaranteed that in each test case these three strings are non-empty and have the same length, which is not exceeding $100$.\n\n\n-----Output-----\n\nPrint $t$ lines with answers for all test cases. For each test case:\n\nIf it is possible to make string $a$ equal to string $b$ print \"YES\" (without quotes), otherwise print \"NO\" (without quotes).\n\nYou can print either lowercase or uppercase letters in the answers.\n\n\n-----Example-----\nInput\n4\naaa\nbbb\nccc\nabc\nbca\nbca\naabb\nbbaa\nbaba\nimi\nmii\niim\n\nOutput\nNO\nYES\nYES\nNO\n\n\n\n-----Note-----\n\nIn the first test case, it is impossible to do the swaps so that string $a$ becomes exactly the same as string $b$.\n\nIn the second test case, you should swap $c_i$ with $a_i$ for all possible $i$. After the swaps $a$ becomes \"bca\", $b$ becomes \"bca\" and $c$ becomes \"abc\". Here the strings $a$ and $b$ are equal.\n\nIn the third test case, you should swap $c_1$ with $a_1$, $c_2$ with $b_2$, $c_3$ with $b_3$ and $c_4$ with $a_4$. Then string $a$ becomes \"baba\", string $b$ becomes \"baba\" and string $c$ becomes \"abab\". Here the strings $a$ and $b$ are equal.\n\nIn the fourth test case, it is impossible to do the swaps so that string $a$ becomes exactly the same as string $b$.", "solutions": "[\"for _ in range(int(input())):\\n\\ta, b, c = input(), input(), input()\\n\\tn = len(a)\\n\\n\\tok = True\\n\\tfor i in range(n):\\n\\t\\tif c[i] not in [a[i], b[i]]:\\n\\t\\t\\tok = False\\n\\n\\tprint('YES' if ok else 'NO')\\n\", \"for _ in range(int(input())):\\n    a=input()\\n    b=input()\\n    c=input()\\n    ans=\\\"YES\\\"\\n    for i in range(len(a)):\\n        if a[i]!=c[i] and b[i]!=c[i]:ans=\\\"NO\\\"\\n    print(ans)\", \"t = int(input())\\n\\ndef test(a,b,c):\\n    for x,y,z in zip(a,b,c):\\n        if not (x==z or y==z):\\n            return False\\n    return True\\n\\nfor _ in range(t):\\n    a = input()\\n    b = input()\\n    c = input()\\n    if test(a,b,c):\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\\n\", \"for _ in range(int(input())):\\n    for a, b, c in zip(input(), input(), input()):\\n        if c not in (a, b):\\n            print(\\\"NO\\\")\\n            break\\n    else:\\n        print(\\\"YES\\\")\\n\", \"q = int(input())\\nfor rwere in range(q):\\n\\ta = input()\\n\\tb = input()\\n\\tc = input()\\n\\tn = len(a)\\n\\tdasie = True\\n\\tfor i in range(n):\\n\\t\\tif c[i] == a[i] or c[i] == b[i]:\\n\\t\\t\\tcontinue\\n\\t\\telse:\\n\\t\\t\\tdasie = False\\n\\tif dasie:\\n\\t\\tprint(\\\"YES\\\")\\n\\telse:\\n\\t\\tprint(\\\"NO\\\")\", \"for _ in range(int(input())):\\n    a = input()\\n    b = input()\\n    c = input()\\n    n = len(a)\\n    flag = 0\\n    for i in range(n):\\n        if a[i]==c[i] or b[i]==c[i]:\\n            continue\\n        flag = 1\\n        break\\n    if flag==0:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"T = int(input())\\nfor _ in range(T):\\n    A = input()\\n    B = input()\\n    C = input()\\n    N = len(A)\\n    for i in range(N):\\n        if not (A[i] == C[i] or B[i] == C[i]):\\n            print(\\\"NO\\\")\\n            break\\n    else:\\n        print(\\\"YES\\\")\\n\", \"from math import *\\n\\nzzz = int(input())\\nfor zz in range(zzz):\\n    a = input()\\n    b = input()\\n    c = input()\\n    ha = True\\n    for i in range (len(a)):\\n        if not b[i] == c[i] and not a[i] == c[i]:\\n            ha= False\\n            break\\n    if not ha:\\n        print('NO')\\n    else:\\n        print('YES')\\n\", \"def mi():\\n\\treturn map(int, input().split())\\n\\nfor _ in range(int(input())):\\n\\ta = list(input())\\n\\tb = list(input())\\n\\tc = list(input())\\n\\tnp = False\\n\\tfor i in range(len(a)):\\n\\t\\tif a[i]==c[i] or b[i]==c[i]:\\n\\t\\t\\tcontinue\\n\\t\\tnp = True\\n\\t\\tbreak\\n\\tif np:\\n\\t\\tprint ('NO')\\n\\telse:\\n\\t\\tprint ('YES')\", \"t = int(input())\\n\\ndef test():\\n    a = input().strip()\\n\\n    b = input().strip()\\n\\n    c= input().strip()\\n\\n\\n    for x,y,z in zip(a,b,c):\\n        if z != x and z != y:\\n            print(\\\"NO\\\"); return\\n    print(\\\"YES\\\")\\nfor _ in range(t):\\n    test()\", \"\\nt = int(input())\\nfor _ in range(t):\\n    a = input()\\n    b = input()\\n    c = input()\\n    n = len(a)\\n    flag = True\\n    for i in range(n):\\n        if a[i] == c[i] or b[i] == c[i]:\\n            continue\\n        flag = False\\n    if flag:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"for _ in range(int(input())):\\n    a = input()\\n    b = input()\\n    c = input()\\n    l = len(a)\\n    flag = 0\\n    for i in range(l):\\n        if c[i]==a[i] or c[i]==b[i]:\\n            continue\\n        else:\\n            flag = 1\\n            break\\n    if flag:\\n        print(\\\"NO\\\")\\n    else:\\n        print(\\\"YES\\\")\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\naaa\\nbbb\\nccc\\nabc\\nbca\\nbca\\naabb\\nbbaa\\nbaba\\nimi\\nmii\\niim\\n\"\n  ],\n  \"outputs\": [\n    \"NO\\nYES\\nYES\\nNO\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1301/A", "starter_code": ""}
{"id": 82, "question": "A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array) and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\nLet $p$ be any permutation of length $n$. We define the fingerprint $F(p)$ of $p$ as the sorted array of sums of adjacent elements in $p$. More formally,\n\n$$F(p)=\\mathrm{sort}([p_1+p_2,p_2+p_3,\\ldots,p_{n-1}+p_n]).$$\n\nFor example, if $n=4$ and $p=[1,4,2,3],$ then the fingerprint is given by $F(p)=\\mathrm{sort}([1+4,4+2,2+3])=\\mathrm{sort}([5,6,5])=[5,5,6]$.\n\nYou are given a permutation $p$ of length $n$. Your task is to find a different permutation $p'$ with the same fingerprint. Two permutations $p$ and $p'$ are considered different if there is some index $i$ such that $p_i \\ne p'_i$.\n\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 668$). Description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2\\le n\\le 100$) \u00a0\u2014 the length of the permutation.\n\nThe second line of each test case contains $n$ integers $p_1,\\ldots,p_n$ ($1\\le p_i\\le n$). It is guaranteed that $p$ is a permutation.\n\n\n-----Output-----\n\nFor each test case, output $n$ integers $p'_1,\\ldots, p'_n$ \u2014 a permutation such that $p'\\ne p$ and $F(p')=F(p)$.\n\nWe can prove that for every permutation satisfying the input constraints, a solution exists.\n\nIf there are multiple solutions, you may output any.\n\n\n-----Example-----\nInput\n3\n2\n1 2\n6\n2 1 6 5 4 3\n5\n2 4 3 1 5\n\nOutput\n2 1\n1 2 5 6 3 4\n3 1 5 2 4\n\n\n\n-----Note-----\n\nIn the first test case, $F(p)=\\mathrm{sort}([1+2])=[3]$.\n\nAnd $F(p')=\\mathrm{sort}([2+1])=[3]$.\n\nIn the second test case, $F(p)=\\mathrm{sort}([2+1,1+6,6+5,5+4,4+3])=\\mathrm{sort}([3,7,11,9,7])=[3,7,7,9,11]$.\n\nAnd $F(p')=\\mathrm{sort}([1+2,2+5,5+6,6+3,3+4])=\\mathrm{sort}([3,7,11,9,7])=[3,7,7,9,11]$.\n\nIn the third test case, $F(p)=\\mathrm{sort}([2+4,4+3,3+1,1+5])=\\mathrm{sort}([6,7,4,6])=[4,6,6,7]$.\n\nAnd $F(p')=\\mathrm{sort}([3+1,1+5,5+2,2+4])=\\mathrm{sort}([4,6,7,6])=[4,6,6,7]$.", "solutions": "[\"for __ in range(int(input())):\\n    n = int(input())\\n    ar = list(map(int, input().split()))\\n    ar.reverse()\\n    print(*ar)\", \"for _ in range(int(input())):\\n    am = int(input())\\n    arr = list(map(int,input().split()))\\n    print(*list(reversed(arr)))\", \"for _ in range(int(input())):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    print(*a[::-1])\", \"for _ in range(int(input())):\\n    n=int(input())\\n    print(*[*map(int,input().split())][::-1])\", \"import sys\\nii = lambda: sys.stdin.readline().strip()\\nidata = lambda: [int(x) for x in ii().split()]\\n\\ndef solve():\\n    n = int(ii())\\n    data = idata()\\n    print(*data[::-1])\\n    return\\n\\nfor t in range(int(ii())):\\n    solve()\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    print(*a[::-1])\", \"import sys\\nimport random\\nfrom fractions import Fraction\\nfrom math import *\\n \\ndef input():\\n    return sys.stdin.readline().strip()\\n \\ndef iinput():\\n    return int(input())\\n\\ndef finput():\\n    return float(input())\\n\\ndef tinput():\\n    return input().split()\\n\\ndef linput():\\n    return list(input())\\n \\ndef rinput():\\n    return list(map(int, tinput()))\\n\\ndef fiinput():\\n    return list(map(float, tinput()))\\n\\ndef flinput():\\n    return list(fiinput())\\n \\ndef rlinput():\\n    return list(map(int, input().split()))\\ndef trinput():\\n    return tuple(rinput())\\n\\ndef srlinput():\\n    return sorted(list(map(int, input().split())))\\n\\ndef NOYES(fl):\\n    if fl:\\n        print(\\\"NO\\\")\\n    else:\\n        print(\\\"YES\\\")\\ndef YESNO(fl):\\n    if fl:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n    \\ndef main():\\n    n = iinput()\\n    q = rlinput()\\n    q.reverse()\\n    print(*q)\\n            \\n        \\n    \\n    \\n    \\n    \\nfor TESTING in range(iinput()):\\n    main()\\n\", \"for _ in range(int(input())):\\n    n=int(input())\\n    l=list(map(int,input().split()))\\n    print(' '.join(list(map(str,l[::-1]))))\", \"#!/usr/bin/env pypy3\\n\\t\\nT = int(input())\\nfor t in range(T):\\n\\tinput()\\n\\tP = input().split()\\n\\tprint(*(P[::-1]))\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    l = list(map(int,input().split()))\\n    l.reverse()\\n    print(*l)\", \"\\nT = int(input())\\n\\n#lets = 'abcdefghijklmnopqrstuvwxyz'\\n#key = {lets[i]:i for i in range(26)}\\n\\nfor t in range(T):\\n  n = int(input())\\n  #n,k = map(int,input().split())\\n  #a = list(map(int,input().split()))\\n  a = input().split()\\n  d = False\\n  a.reverse()\\n  print(' '.join(a))\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    a = list(map(int,input().split()))\\n    for i in range(n-1,-1,-1):\\n        print(a[i],end=' ')\\n    print()\", \"t = int(input())\\n\\nfor _ in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    print(*a[::-1])\", \"t=int(input())\\nfor _ in range(t):\\n\\tn=int(input())\\n\\tarr=list(map(int,input().split()))\\n\\tfor i in range(len(arr)-1,-1,-1):\\n\\t\\tprint(arr[i],end=\\\" \\\")\\n\\tprint()\", \"for _ in range (int(input())):\\n    n=int(input())\\n    a=list(map(int,input().split()))\\n    a=a[::-1]\\n    print(*a)\", \"for i in range(int(input())):\\n    input()\\n    print(*[int(i) for i in input().split()][::-1])\", \"t=int(input())\\nfor t in range(t):\\n\\tn=int(input())\\n\\ta=[int(x) for x in input().split(' ')]\\n\\ta.reverse()\\n\\tprint(*a)\", \"#!/usr/local/bin/python3\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    arr=list(map(int,input().split()))\\n    result=arr[::-1]\\n    print(' '.join(map(str,result)))\", \"t=int(input())\\nwhile t:\\n    t-=1\\n    n=int(input())\\n    a=[int(i) for i in input().split()]\\n    a.reverse()\\n    print(*a,sep=\\\" \\\")\\n\", \"import sys\\n\\n# import math\\n# from collections import deque\\n\\n# import heapq\\n\\n# from math import inf\\n# from math import gcd\\n\\n# print(help(deque))\\n# 26\\npprint = lambda s: print(' '.join(map(lambda x: str(x), s)))\\ninput = lambda: sys.stdin.readline().strip()\\nipnut = input\\nmod = 1000000007\\nfor i in range(int(input())):\\n    # n, k = map(int, input().split())\\n    n = int(input())\\n    p = list(map(int,input().split()))\\n    pprint(reversed(p))\\n# c = list(map(lambda x: int(x)-1, input().split()))\\n\", \"import sys\\nimport math\\n# sys.stdin  = open(\\\"input.txt\\\")\\nfor _ in range(int(input())):\\n    n=int(input())\\n    a=[int(o) for o in input().split()]\\n    print(*a[::-1])\", \"for i in range(int(input())):\\n\\tn = int(input())\\n\\tp = list(map(int, input().split()))\\n\\tp.reverse()\\n\\tprint(\\\" \\\".join(str(num) for num in p))\", \"\\\"\\\"\\\"\\nAuthor: Q.E.D\\nTime: 2020-09-06 09:35:20\\n\\\"\\\"\\\"\\nT = int(input())\\nfor _ in range(T):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    print(' '.join(map(str, a[::-1])))\", \"for _ in range(int(input())):\\n    n = int(input())\\n    arr = list(map(int,input().split()))\\n    arr = arr[-1::-1]\\n    print(*arr)\", \"for t in range(int(input())):\\n    n=int(input())\\n    a = list(map(str, input().split()))\\n    print(\\\" \\\".join(a[::-1]))\\n\", \"for _ in range(int(input())):\\n\\tn = int(input())\\n\\tp = [*list(map(int, input().split()))][::-1]\\n\\tprint(*p)\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    p = list(map(int, input().split()))\\n    p.reverse()\\n    print(*p)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\n\\nt = int(input())\\n\\n\\nfor _ in range(t):\\n    n = int(input())\\n    nList = list(map(int, input().split()))\\n    print(*nList[::-1])\\n\\n\", \"for T in range(int(input())) :\\n    n = int(input())\\n    l = input().split()\\n    print(*l[::-1])\", \"import math\\nfrom collections import deque\\nfrom sys import stdin, stdout\\nfrom string import ascii_letters\\nimport sys\\nletters = ascii_letters\\ninput = stdin.readline\\n#print = stdout.write\\n\\nfor _ in range(int(input())):\\n    n = int(input())\\n    print(*(list(map(int, input().split()))[::-1]))\\n\", \"\\n\\ndef main():\\n    n = int(input())\\n    p = list(map(int,input().split()))\\n    p = list(reversed(p))\\n    for i in p:\\n        print(i, end=\\\" \\\")\\n    print()\\n\\n\\ndef __starting_point():\\n    t = int(input())\\n    for i in range(t):\\n        main()\\n\\\"\\\"\\\"\\n60, 61\\n\\\"\\\"\\\"\\n\\\"\\\"\\\"\\n\\\"\\\"\\\"\\n\\n__starting_point()\", \"for i in range(int(input())):\\n    n=int(input())\\n    a=list(map(int,input().split()))\\n    print(*a[::-1])\", \"def solve():\\n    N = int(input())\\n    A = [int(s) for s in input().split()]\\n    A = A[::-1]\\n    print(*A)\\n    return\\n\\nT = int(input())\\nfor t in range(T):\\n    solve()\\n\", \"# -*- coding: utf-8 -*-\\nimport sys\\nfrom collections import deque, defaultdict\\nfrom math import sqrt, factorial, gcd, ceil, atan, pi\\ndef input(): return sys.stdin.readline()[:-1] # warning not \\\\n\\n# def input(): return sys.stdin.buffer.readline().strip() # warning bytes\\n# def input(): return sys.stdin.buffer.readline().decode('utf-8')\\nimport string\\n# string.ascii_lowercase\\nfrom bisect import bisect_left, bisect_right\\nfrom functools import lru_cache\\nMOD = int(1e9)+7\\nINF = float('inf')\\n\\n\\ndef solve():\\n    n = int(input())\\n    p = [int(x) for x in input().split()]\\n    p.reverse()\\n    print(*p)\\n        \\n\\n    \\nt = 1\\nt = int(input())\\nfor case in range(1,t+1):\\n    ans = solve()\\n\\n\\n\\\"\\\"\\\"\\n\\n\\n\\\"\\\"\\\"\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n2\\n1 2\\n6\\n2 1 6 5 4 3\\n5\\n2 4 3 1 5\\n\"\n  ],\n  \"outputs\": [\n    \"2 1 \\n3 4 5 6 1 2 \\n5 1 3 4 2 \\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1405/A", "starter_code": ""}
{"id": 83, "question": "Being tired of participating in too many Codeforces rounds, Gildong decided to take some rest in a park. He sat down on a bench, and soon he found two rabbits hopping around. One of the rabbits was taller than the other.\n\nHe noticed that the two rabbits were hopping towards each other. The positions of the two rabbits can be represented as integer coordinates on a horizontal line. The taller rabbit is currently on position $x$, and the shorter rabbit is currently on position $y$ ($x \\lt y$). Every second, each rabbit hops to another position. The taller rabbit hops to the positive direction by $a$, and the shorter rabbit hops to the negative direction by $b$.\n\n [Image] \n\nFor example, let's say $x=0$, $y=10$, $a=2$, and $b=3$. At the $1$-st second, each rabbit will be at position $2$ and $7$. At the $2$-nd second, both rabbits will be at position $4$.\n\nGildong is now wondering: Will the two rabbits be at the same position at the same moment? If so, how long will it take? Let's find a moment in time (in seconds) after which the rabbits will be at the same point.\n\n\n-----Input-----\n\nEach test contains one or more test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$).\n\nEach test case contains exactly one line. The line consists of four integers $x$, $y$, $a$, $b$ ($0 \\le x \\lt y \\le 10^9$, $1 \\le a,b \\le 10^9$) \u2014 the current position of the taller rabbit, the current position of the shorter rabbit, the hopping distance of the taller rabbit, and the hopping distance of the shorter rabbit, respectively.\n\n\n-----Output-----\n\nFor each test case, print the single integer: number of seconds the two rabbits will take to be at the same position.\n\nIf the two rabbits will never be at the same position simultaneously, print $-1$.\n\n\n-----Example-----\nInput\n5\n0 10 2 3\n0 10 3 3\n900000000 1000000000 1 9999999\n1 2 1 1\n1 3 1 1\n\nOutput\n2\n-1\n10\n-1\n1\n\n\n\n-----Note-----\n\nThe first case is explained in the description.\n\nIn the second case, each rabbit will be at position $3$ and $7$ respectively at the $1$-st second. But in the $2$-nd second they will be at $6$ and $4$ respectively, and we can see that they will never be at the same position since the distance between the two rabbits will only increase afterward.", "solutions": "[\"def one():\\n    return int(input())\\n\\n\\ndef two():\\n    return list(map(int, input().split()))\\n\\n\\ndef lis():\\n    return list(map(int, input().split()))\\n\\n\\ndef st():\\n    return input()\\n\\n\\nfor _ in range(one()):\\n    x, y, a, b = list(map(int, input().split()))\\n    d = y - x\\n    if d%(a+b)==0:\\n        print(d//(a+b))\\n    else:\\n        print(-1)\\n\", \"t = int(input())\\nfor _ in range(t):\\n    x,y,a,b = list(map(int,input().split()))\\n    k = y - x\\n    if k % (a + b) == 0:\\n        print(k // (a+b))\\n    else:\\n        print(-1)\\n\", \"from math import *\\n\\nt = int(input())\\nfor i in range(t):\\n    x, y, a, b = list(map(int, input().split()))\\n    if (y - x) % (a + b) == 0:\\n        print((y - x) // (a + b))\\n    else:\\n        print(-1)\\n\", \"for __ in range(int(input())):\\n    x, y, a, b = map(int, input().split())\\n    z = y - x\\n    c = a + b\\n    print(-1 if z % c else z // c)\", \"for _ in range(int(input())):\\n\\tx, y, a, b = list(map(int, input().split()))\\n\\t\\n\\tt = (y - x) / (a + b)\\n\\ttz = (y - x) // (a + b)\\n\\n\\tif t != tz:\\n\\t\\tprint(-1)\\n\\telse:\\n\\t\\tprint(tz)\\n\", \"#  =========     /\\\\       /|    |====/|\\n#      |        /  \\\\       |    |   / |\\n#      |       /____\\\\      |    |  /  |\\n#      |      /      \\\\     |    | /   |\\n#  ========= /        \\\\  =====  |/====|  \\n#  code\\n\\ndef main():\\n    t = int(input())\\n    for _ in range(t):\\n        x,y,a,b = map(int,input().split())\\n        i = (y - x)//(a + b)\\n        if x + a * i == y - b * i:\\n            print(i)\\n        else:\\n            print(-1)\\n    return\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"from math import *\\nimport itertools\\n\\n\\nzzz = int(input())\\n\\nfor zz in range(zzz):\\n    x, y, a, b = list(map(int, input().split()))\\n    s = y - x\\n    t = s / (a + b)\\n    if int(t) == t:\\n        print(int(t))\\n    else:\\n        print(-1)\\n\", \"from math import *\\n\\nt = int(input())\\nfor y in range(t):\\n\\tx,y,a,b = list(map(int,input().split()))\\n\\tif (y-x)%(a+b) != 0: print(-1)\\n\\telse:\\n\\t\\tprint((y-x)//(a+b))\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nQ = int(input())\\nQuery = [list(map(int, input().split())) for _ in range(Q)]\\n\\nfor x, y, a, b in Query:\\n    d = y-x\\n    r = a+b\\n    if d%r == 0:\\n        print(d//r)\\n    else:\\n        print(-1)\", \"t = int(input())\\nfor _ in range(t):\\n    x,y,a,b = [int(i) for i in input().split()]\\n    s = (y-x)/(a+b)\\n    if s.is_integer():\\n        print(int(s))\\n    else:\\n        print(-1)\", \"t=int(input())\\nfor _ in range(t):\\n    \\n    x,y,a,b=list(map(int,input().split()))\\n    if (y-x)%(a+b)!=0:\\n        print(-1)\\n    else:\\n        print(int((y-x)/(a+b)))\\n\", \"for _ in range(int(input())):\\n    x, y, a, b = map(int, input().split())\\n\\n    d = y - x\\n    if d % (a + b ) == 0:\\n        print(d // (a + b))\\n    else:\\n        print(-1)\", \"for nt in range(int(input())):\\n\\tx,y,a,b=map(int,input().split())\\n\\tif (y-x)%(a+b)==0:\\n\\t\\tprint ((y-x)//(a+b))\\n\\telse:\\n\\t\\tprint (-1)\", \"def solve(X, Y, A, B):\\n    d, r = divmod(Y - X, A + B)\\n    if r == 0:\\n        return d\\n    else:\\n        return -1\\n\\n\\ndef __starting_point():\\n    T, = list(map(int, input().split()))\\n    for t in range(T):\\n        X, Y, A, B = list(map(int, input().split()))\\n        ans = solve(X, Y, A, B)\\n        print(ans)\\n\\n__starting_point()\", \"import sys\\nimport math\\n\\ndef input():\\n    return sys.stdin.readline().strip()\\n\\ndef iinput():\\n    return [int(x) for x in sys.stdin.readline().split()]\\n\\ndef main():\\n    x, y, a, b = iinput()\\n    if (y - x) % (a + b) == 0:\\n        print((y - x) // (a + b))\\n    else:\\n        print(-1)\\n    return\\n\\nfor ______ in range(int(input())):\\n    main()\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"5\\n0 10 2 3\\n0 10 3 3\\n900000000 1000000000 1 9999999\\n1 2 1 1\\n1 3 1 1\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n-1\\n10\\n-1\\n1\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1304/A", "starter_code": ""}
{"id": 84, "question": "Let's look at the following process: initially you have an empty stack and an array $s$ of the length $l$. You are trying to push array elements to the stack in the order $s_1, s_2, s_3, \\dots s_{l}$. Moreover, if the stack is empty or the element at the top of this stack is not equal to the current element, then you just push the current element to the top of the stack. Otherwise, you don't push the current element to the stack and, moreover, pop the top element of the stack. \n\nIf after this process the stack remains empty, the array $s$ is considered stack exterminable.\n\nThere are samples of stack exterminable arrays:   $[1, 1]$;  $[2, 1, 1, 2]$;  $[1, 1, 2, 2]$;  $[1, 3, 3, 1, 2, 2]$;  $[3, 1, 3, 3, 1, 3]$;  $[3, 3, 3, 3, 3, 3]$;  $[5, 1, 2, 2, 1, 4, 4, 5]$; \n\nLet's consider the changing of stack more details if $s = [5, 1, 2, 2, 1, 4, 4, 5]$ (the top of stack is highlighted).   after pushing $s_1 = 5$ the stack turn into $[\\textbf{5}]$;  after pushing $s_2 = 1$ the stack turn into $[5, \\textbf{1}]$;  after pushing $s_3 = 2$ the stack turn into $[5, 1, \\textbf{2}]$;  after pushing $s_4 = 2$ the stack turn into $[5, \\textbf{1}]$;  after pushing $s_5 = 1$ the stack turn into $[\\textbf{5}]$;  after pushing $s_6 = 4$ the stack turn into $[5, \\textbf{4}]$;  after pushing $s_7 = 4$ the stack turn into $[\\textbf{5}]$;  after pushing $s_8 = 5$ the stack is empty. \n\nYou are given an array $a_1, a_2, \\ldots, a_n$. You have to calculate the number of its subarrays which are stack exterminable.\n\nNote, that you have to answer $q$ independent queries.\n\n\n-----Input-----\n\nThe first line contains one integer $q$ ($1 \\le q \\le 3 \\cdot 10^5$)\u00a0\u2014 the number of queries.\n\nThe first line of each query contains one integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$)\u00a0\u2014 the length of array $a$.\n\nThe second line of each query contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$)\u00a0\u2014 the elements.\n\nIt is guaranteed that the sum of all $n$ over all queries does not exceed $3 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case print one integer in single line \u2014 the number of stack exterminable subarrays of the array $a$.\n\n\n-----Example-----\nInput\n3\n5\n2 1 1 2 2\n6\n1 2 1 1 3 2\n9\n3 1 2 2 1 6 6 3 3\n\nOutput\n4\n1\n8\n\n\n\n-----Note-----\n\nIn the first query there are four stack exterminable subarrays: $a_{1 \\ldots 4} = [2, 1, 1, 2], a_{2 \\ldots 3} = [1, 1], a_{2 \\ldots 5} = [1, 1, 2, 2], a_{4 \\ldots 5} = [2, 2]$.\n\nIn the second query, only one subarray is exterminable subarray\u00a0\u2014 $a_{3 \\ldots 4}$.\n\nIn the third query, there are eight stack exterminable subarrays: $a_{1 \\ldots 8}, a_{2 \\ldots 5}, a_{2 \\ldots 7}, a_{2 \\ldots 9}, a_{3 \\ldots 4}, a_{6 \\ldots 7}, a_{6 \\ldots 9}, a_{8 \\ldots 9}$.", "solutions": "[\"# encoding: utf-8\\nfrom sys import stdin\\n\\ndef solve(a):\\n\\n    # root node of tries denotes empty stack\\n    stack = [None]\\n    node_stack = [[1, {}]]\\n    trie = node_stack[-1]\\n\\n    counter = 0\\n    for i in range(len(a)):\\n        el = a[i]\\n\\n        if len(stack) == 0 or stack[-1] != el:\\n\\n            current_node = node_stack[-1]\\n            stack.append(el)\\n            if el not in current_node[1]:\\n                current_node[1][el] = [0, {}]\\n\\n            next_node = current_node[1][el]\\n            next_node[0] += 1\\n            node_stack.append(next_node)\\n\\n        else:\\n            # just go up in trie\\n            stack.pop()\\n            node_stack.pop()\\n            node_stack[-1][0] += 1\\n\\n        value = node_stack[-1][0]\\n        counter -= (((value - 1) * (value - 2)) // 2)\\n        counter += (((value) * (value - 1)) // 2)\\n\\n    return counter\\n\\n\\nq = int(stdin.readline().strip())\\nfor _ in range(q):\\n    n = int(stdin.readline().strip())\\n    a = [int(i) for i in stdin.readline().strip().split()]\\n    print(solve(a))\\n\", \"# encoding: utf-8\\nfrom sys import stdin\\n\\n\\ndef solve(a):\\n    # root node of tries denotes empty stack\\n    stack = [None]\\n    node_stack = [[1, {}]]\\n\\n    counter = 0\\n    for i in range(len(a)):\\n        el = a[i]\\n\\n        if len(stack) == 0 or stack[-1] != el:\\n\\n            current_node = node_stack[-1]\\n            stack.append(el)\\n            if el not in current_node[1]:\\n                current_node[1][el] = [0, {}]\\n\\n            next_node = current_node[1][el]\\n            next_node[0] += 1\\n            node_stack.append(next_node)\\n\\n        else:\\n            # just go up in trie\\n            stack.pop()\\n            node_stack.pop()\\n            node_stack[-1][0] += 1\\n\\n        value = node_stack[-1][0]\\n        counter += (value - 1)\\n\\n    return counter\\n\\n\\nq = int(stdin.readline().strip())\\nfor _ in range(q):\\n    n = int(stdin.readline().strip())\\n    a = [int(i) for i in stdin.readline().strip().split()]\\n    print(solve(a))\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n5\\n2 1 1 2 2\\n6\\n1 2 1 1 3 2\\n9\\n3 1 2 2 1 6 6 3 3\\n\"\n  ],\n  \"outputs\": [\n    \"4\\n1\\n8\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1241/F", "starter_code": ""}
{"id": 85, "question": "Consider the following process. You have a binary string (a string where each character is either 0 or 1) $w$ of length $n$ and an integer $x$. You build a new binary string $s$ consisting of $n$ characters. The $i$-th character of $s$ is chosen as follows:\n\n  if the character $w_{i-x}$ exists and is equal to 1, then $s_i$ is 1 (formally, if $i > x$ and $w_{i-x} = $ 1, then $s_i = $ 1);  if the character $w_{i+x}$ exists and is equal to 1, then $s_i$ is 1 (formally, if $i + x \\le n$ and $w_{i+x} = $ 1, then $s_i = $ 1);  if both of the aforementioned conditions are false, then $s_i$ is 0. \n\nYou are given the integer $x$ and the resulting string $s$. Reconstruct the original string $w$.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nEach test case consists of two lines. The first line contains the resulting string $s$ ($2 \\le |s| \\le 10^5$, each character of $s$ is either 0 or 1). The second line contains one integer $x$ ($1 \\le x \\le |s| - 1$).\n\nThe total length of all strings $s$ in the input does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print the answer on a separate line as follows:\n\n  if no string $w$ can produce the string $s$ at the end of the process, print $-1$;  otherwise, print the binary string $w$ consisting of $|s|$ characters. If there are multiple answers, print any of them. \n\n\n-----Example-----\nInput\n3\n101110\n2\n01\n1\n110\n1\n\nOutput\n111011\n10\n-1", "solutions": "[\"import sys\\n\\ninput=sys.stdin.readline\\n\\nfor _ in range(int(input())):\\n    s=input().rstrip()\\n    x=int(input())\\n    n=len(s)\\n    ans=[\\\"1\\\" for i in range(n)]\\n    for i in range(n):\\n        if s[i]==\\\"0\\\":\\n            if i-x>=0:\\n                ans[i-x]=\\\"0\\\"\\n            if i+x<n:\\n                ans[i+x]=\\\"0\\\"\\n    for i in range(n):\\n        if s[i]==\\\"1\\\":\\n            check=False\\n            if i-x>=0:\\n                check|=(ans[i-x]==\\\"1\\\")\\n            if i+x<n:\\n                check|=(ans[i+x]==\\\"1\\\")\\n            if not check:\\n                print(-1)\\n                break\\n    else:\\n        print(\\\"\\\".join(ans))\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nt = int(input())\\nfor _ in range(t):\\n    s = input().strip()\\n    n = len(s)\\n    x = int(input())\\n    outl = ['1'] * n\\n    for i in range(n):\\n        if s[i] == '0':\\n            if i >= x:\\n                outl[i-x] = '0'\\n            if i + x < n:\\n                outl[i+x] = '0'\\n    out = ''.join(outl)\\n    works = True\\n    for i in range(n):\\n        if s[i] == '1':\\n            if (i < x or out[i - x] == '0') and (i + x >= n or out[i + x] == '0'):\\n                works = False\\n                break\\n\\n    if works:\\n        print(out)\\n    else:\\n        print(-1)\\n\", \"t = int(input())\\nfor _ in range(t):\\n    s = input()\\n    n = len(s)\\n    x = int(input())\\n    w = [0]*n\\n    for i in range(n):\\n        if 0 <= i + x < n and 0 <= i - x < n:\\n            if s[i+x] == \\\"1\\\" and s[i-x] == \\\"1\\\":\\n                w[i] = 1\\n        elif 0 <= i + x < n:\\n            if s[i+x] == \\\"1\\\":\\n                w[i] = 1\\n        elif 0 <= i - x < n:\\n            if s[i-x] == \\\"1\\\":\\n                w[i] = 1\\n\\n    for i in range(n):\\n        if 0 <= i-x < n and w[i-x] == 1:\\n            if s[i] == \\\"1\\\":\\n                continue\\n            else:\\n                print(-1)\\n                break\\n        if 0 <= i + x < n and w[i+x] == 1:\\n            if s[i] == \\\"1\\\":\\n                continue\\n            else:\\n                print(-1)\\n                break\\n        if s[i] == \\\"1\\\":\\n            print(-1)\\n            break\\n    else:\\n        print(*w, sep=\\\"\\\")\\n\", \"\\n\\ndef process():\\n    li=list(input())\\n    x=int(input())\\n    n=len(li)\\n    ans=['1' for i in range(n)]\\n\\n    for i in range(0,n):\\n        if(li[i]=='0'):\\n            if(i-x>=0):\\n                ans[i-x]='0'\\n            if(i+x<n):\\n                ans[i+x]='0'\\n\\n    for i in range(0,n):\\n        chr='0'\\n        if(i-x>=0 and ans[i-x]=='1'):\\n            chr='1'\\n        if(i+x<n and ans[i+x]=='1'):\\n            chr='1'\\n        if(li[i]==chr):\\n            pass\\n        else:\\n            print(-1)\\n            return\\n    print(\\\"\\\".join(ans))\\n\\n\\n\\ntests=int(input())\\nfor i in range(tests):\\n    process()\", \"import sys\\n# sys.stdin = open('input.txt', 'r') \\n# sys.stdout = open('output.txt', 'w')\\n \\nimport math\\nimport collections\\nfrom sys import stdin,stdout,setrecursionlimit\\nimport bisect as bs\\nsetrecursionlimit(2**20)\\nM = 10**9+7\\n    \\nT = int(stdin.readline())\\n# T = 1\\n\\nfor _ in range(T):\\n    # n = int(stdin.readline())\\n    # n,d,m = list(map(int,stdin.readline().split()))\\n    # a = list(map(int,stdin.readline().split()))\\n    # q = int(stdin.readline())\\n    # a = list(map(int,stdin.readline().split()))\\n    # b = list(map(int,stdin.readline().split()))\\n    s = stdin.readline().strip('\\\\n')\\n    x = int(stdin.readline())\\n    n = len(s)\\n    a = [-1]*n\\n    res = True\\n    for i in range(n):\\n        if(s[i] == '1'):\\n            if((i-x) >= 0 and a[i-x] != 0):\\n                a[i-x] = 1\\n                continue\\n            if((i+x) < n):\\n                if(a[i+x] == 0):\\n                    res = False\\n                    break\\n                else:\\n                    a[i+x] = 1\\n                    continue\\n            res = False\\n            break\\n        else:\\n            if((i-x) >= 0):\\n                if(a[i-x] == 1):\\n                    res = False\\n                    break\\n                else:\\n                    a[i-x] = 0\\n            if((i+x) < n):\\n                if(a[i+x] == 1):\\n                    res = False\\n                    break\\n                else:\\n                    a[i+x] = 0\\n    ans = ''\\n    for i in range(n):\\n        if(a[i] != -1):\\n            ans = ans + str(a[i])\\n        else:\\n            ans = ans + '1'\\n    if(res): print(ans)\\n    else: print(-1)\\n\", \"from bisect import bisect_left as bl\\nfrom bisect import bisect_right as br\\nfrom heapq import heappush,heappop,heapify\\nimport math\\nfrom collections import *\\nfrom functools import reduce,cmp_to_key\\nimport sys\\ninput = sys.stdin.readline\\n\\nfrom itertools import accumulate\\n\\nM = mod = 998244353\\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\\ndef inv_mod(n):return pow(n, mod - 2, mod)\\n \\ndef li():return [int(i) for i in input().rstrip('\\\\n').split()]\\ndef st():return input().rstrip('\\\\n')\\ndef val():return int(input().rstrip('\\\\n'))\\ndef li2():return [i for i in input().rstrip('\\\\n')]\\ndef li3():return [int(i) for i in input().rstrip('\\\\n')]\\n\\n\\n\\nfor _ in range(val()):\\n    l = [0] + li3()\\n    x = val()\\n    n = len(l) - 1\\n    ans = [None] * (n + 1)\\n    flag = 0\\n\\n    # print(l, n, x)\\n    for i in range(1, n + 1):\\n        # print(ans, i)\\n        if l[i] == 1:\\n            if i > x and (ans[i - x] == 1 or ans[i - x] == None):\\n                ans[i - x] = 1\\n            elif i + x <= n:\\n                ans[i + x] = 1\\n            else:\\n                flag = 1\\n                break\\n        else:\\n            if (i <= x or (ans[i - x] == None or ans[i - x ] == 0)) and (i + x > n or (ans[i + x] == None)):\\n                if i > x:ans[i - x] = 0\\n                if i + x <= n:ans[i + x] = 0\\n            else:\\n                flag = 1\\n                break\\n    for i in range(1, n + 1):\\n        if ans[i] == None:ans[i] = 1  \\n    if flag:\\n        print(-1)\\n    else:\\n        print(*ans[1:n + 1], sep = '')\", \"for t in range(int(input())):\\n    s = [int(c == \\\"1\\\") for c in input()]\\n    x = int(input())\\n    n = len(s)\\n\\n    sat = lambda i: (s[i] if i in range(n) else 1)\\n\\n    w = [(sat(i - x) & sat(i + x)) for i in range(n)]\\n\\n    wat = lambda i: (w[i] if i in range(n) else 0)\\n\\n    s_ref = [(wat(i - x) | wat(i + x)) for i in range(n)]\\n    \\n    if s != s_ref:\\n        print(-1)\\n    else:\\n        print(\\\"\\\".join(map(str, w)))\\n\", \"def solve():\\n    s = list(map(int, input()))\\n    n = len(s)\\n    x = int(input())\\n    w = [0] * n\\n    d = [False] * n\\n    for i in range(n):\\n        if s[i] == 0:\\n            if i - x >= 0:\\n                w[i - x] = 0\\n                d[i - x] = True\\n            if i + x < n:\\n                w[i + x] = 0\\n                d[i + x] = True\\n    for i in range(n):\\n        if not d[i]:\\n            w[i] = 1\\n            d[i] = True\\n    t = [0] * n\\n    for i in range(n):\\n        if i - x >= 0 and w[i - x] == 1:\\n            t[i] = 1\\n        if i + x < n and w[i + x] == 1:\\n            t[i] = 1\\n    if s != t:\\n        print('-1')\\n        return\\n    print(''.join(map(str, w)))\\nt = int(input())\\nfor _ in range(t):\\n    solve()\", \"t = int(input())\\nfor i in range(t):\\n    s = input()\\n    m = len(s)\\n    x = int(input())\\n    ANS = [1] * m\\n    for i in range(m):\\n        if s[i] == \\\"0\\\":\\n            if i-x >= 0:\\n                ANS[i-x] = 0\\n            if i+x < m:\\n                ANS[i+x] = 0\\n    \\n    ng = 0\\n    for i in range(m):\\n        one = 0\\n        if (i-x >= 0 and ANS[i-x] == 1) or (i+x < m and ANS[i+x] == 1):\\n            one = 1\\n        if (one == 1 and s[i] == \\\"0\\\") or (one == 0 and s[i] == \\\"1\\\"):\\n            ng = 1\\n            break\\n    \\n    if ng == 1:\\n        print(-1)\\n    else:\\n        print(\\\"\\\".join([str(i) for i in ANS]))\\n\", \"for _ in range(int(input())):\\n    s = input()\\n    n = len(s)\\n    x = int(input())\\n    \\n    w = ['1'] * len(s)\\n    \\n    for i in range(n):\\n        if s[i] == '0':\\n            if i + x < n:\\n                w[i + x] = '0'\\n            if i - x >= 0:\\n                w[i - x] = '0'\\n    \\n    temp = ['0'] * len(s)\\n    for i in range(n):\\n        if i + x < n:\\n            if w[i + x] == '1':\\n                temp[i] = '1'\\n        if i - x >= 0:\\n            if w[i - x] == '1':\\n                temp[i] = '1'\\n    if ''.join(temp) == s:\\n        print(''.join(w))\\n    else:\\n        print(-1)\", \"t=int(input())\\nfor you in range(t):\\n    s=input()\\n    n=len(s)\\n    x=int(input())\\n    arr=[1 for i in range(n)]\\n    poss=1\\n    for i in range(n):\\n        if(s[i]=='1'):\\n            if(i-x>=0 and arr[i-x]==0 and i+x<n and arr[i+x]==0):\\n                poss=0\\n                break\\n        else:\\n            if(i-x>=0):\\n                arr[i-x]=0\\n            if(i+x<n):\\n                arr[i+x]=0\\n    if(poss==0):\\n        print(-1)\\n        continue\\n    isposs=\\\"\\\"\\n    for i in range(n):\\n        if(i-x>=0 and arr[i-x]):\\n            isposs=isposs+'1'\\n        elif(i+x<n and arr[i+x]):\\n            isposs=isposs+'1'\\n        else:\\n            isposs=isposs+'0'\\n    if(isposs==s):\\n        for i in arr:\\n            print(i,end=\\\"\\\")\\n        print()\\n    else:\\n        print(-1)\\n\", \"import sys\\n\\nsys.setrecursionlimit(10 ** 5)\\nint1 = lambda x: int(x) - 1\\np2D = lambda x: print(*x, sep=\\\"\\\\n\\\")\\ndef II(): return int(sys.stdin.readline())\\ndef MI(): return map(int, sys.stdin.readline().split())\\ndef LI(): return list(map(int, sys.stdin.readline().split()))\\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\\ndef SI(): return sys.stdin.readline()[:-1]\\n\\nfor _ in range(II()):\\n    s=SI()\\n    x=II()\\n    n=len(s)\\n    ans=[1]*n\\n    for i,c in enumerate(s):\\n        if c==\\\"0\\\":\\n            if i-x>=0:ans[i-x]=0\\n            if i+x<n:ans[i+x]=0\\n\\n    def ok():\\n        for i in range(n):\\n            if s[i]==\\\"1\\\":\\n                flag=0\\n                if i-x>=0:flag|=ans[i-x]\\n                if i+x<n:flag|=ans[i+x]\\n                if flag==0:return False\\n        return True\\n\\n    if ok():print(*ans,sep=\\\"\\\")\\n    else:print(-1)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n101110\\n2\\n01\\n1\\n110\\n1\\n\"\n  ],\n  \"outputs\": [\n    \"111011\\n10\\n-1\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1400/C", "starter_code": ""}
{"id": 86, "question": "Alexandra has an even-length array $a$, consisting of $0$s and $1$s. The elements of the array are enumerated from $1$ to $n$. She wants to remove at most $\\frac{n}{2}$ elements (where $n$ \u2014 length of array) in the way that alternating sum of the array will be equal $0$ (i.e. $a_1 - a_2 + a_3 - a_4 + \\dotsc = 0$). In other words, Alexandra wants sum of all elements at the odd positions and sum of all elements at the even positions to become equal. The elements that you remove don't have to be consecutive.\n\nFor example, if she has $a = [1, 0, 1, 0, 0, 0]$ and she removes $2$nd and $4$th elements, $a$ will become equal $[1, 1, 0, 0]$ and its alternating sum is $1 - 1 + 0 - 0 = 0$.\n\nHelp her!\n\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^3$). Description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 10^3$, $n$ is even) \u00a0\u2014 length of the array.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 1$) \u00a0\u2014 elements of the array.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^3$.\n\n\n-----Output-----\n\nFor each test case, firstly, print $k$ ($\\frac{n}{2} \\leq k \\leq n$) \u2014 number of elements that will remain after removing in the order they appear in $a$. Then, print this $k$ numbers. Note that you should print the numbers themselves, not their indices.\n\nWe can show that an answer always exists. If there are several answers, you can output any of them. \n\n\n-----Example-----\nInput\n4\n2\n1 0\n2\n0 0\n4\n0 1 1 1\n4\n1 1 0 0\n\nOutput\n1\n0\n1\n0\n2\n1 1\n4\n1 1 0 0\n\n\n\n-----Note-----\n\nIn the first and second cases, alternating sum of the array, obviously, equals $0$.\n\nIn the third case, alternating sum of the array equals $1 - 1 = 0$.\n\nIn the fourth case, alternating sum already equals $1 - 1 + 0 - 0 = 0$, so we don't have to remove anything.", "solutions": "[\"def solve():\\n    n = int(input())\\n    lst = list(map(int,input().split()))\\n    if sum(lst) <= n // 2:\\n        print(n//2)\\n        print(\\\"0 \\\" * (n // 2))\\n    else:\\n        print(n//2 + (n // 2) % 2)\\n        print(\\\"1 \\\" * (n//2 + (n // 2) % 2))\\nfor i in range(int(input())):\\n    solve()\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    l = list(map(int,input().split()))\\n    o = 0\\n    z = 0\\n    for i in range(n):\\n        if(l[i]): o+=1\\n        else: z+=1\\n    if(o>z):\\n        o-=o%2\\n        print(o)\\n        for i in range(o):\\n            print(1, end =\\\" \\\")\\n    else:\\n        print(z)\\n        for i in range(z):\\n            print(0, end=\\\" \\\")\\n    print()\", \"#OM GANESHAY NAMH\\n#GANPATI BAPPA MORYA\\nimport math,queue,heapq \\nimport sys \\nsys.setrecursionlimit(10**6)\\nfastinput=sys.stdin.readline\\nfastout=sys.stdout.write\\nt=int(fastinput()) \\nwhile t:\\n    t-=1\\n    n=int(fastinput()) \\n    a=list(map(int,fastinput().split()))  \\n    c=a.count(1) \\n    if c==0 or c==n:\\n        print(n)\\n        print(*a) \\n    elif c<=n//2:\\n        print(n-c)\\n        print('0 '*(n-c)) \\n    else:\\n        if c%2==0:\\n            print(c)\\n            print('1 '*c) \\n        else:\\n            c-=1 \\n            print(c) \\n            print('1 '*c)\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    res = []\\n    for i in range(n // 2):\\n        if a[i * 2] == 1 and a[i * 2 + 1] == 1:\\n            res.append(1)\\n            res.append(1)\\n        elif a[i * 2] == 0 and a[i * 2 + 1] == 0:\\n            res.append(0)\\n            res.append(0)\\n        else:\\n            res.append(0)\\n    print(len(res))\\n    print(*res)\", \"import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\nfor tests in range(t):\\n    n=int(input())\\n    A=list(map(int,input().split()))\\n\\n    ZERO=A.count(0)\\n    if ZERO>=n//2:\\n        print(ZERO)\\n        print(*[0]*ZERO)\\n    else:\\n        ONE=n-ZERO\\n        print(ONE//2*2)\\n        print(*[1]*(ONE//2*2))\\n\\n    \\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    arr = list(map(int, input().split()))\\n\\n    a = arr.count(0)\\n    b = arr.count(1)\\n\\n    if b > n // 2:\\n        print(b - b % 2)\\n        print(*[1 for _ in range(b - b % 2)])\\n    elif b == n // 2:\\n        print(a)\\n        print(*[0 for _ in range(a)])\\n    else:\\n        print(a - a % 2)\\n        print(*[0 for _ in range(a - a % 2)])\\n\", \"for i in ' '*(int(input())):\\n    n=int(input())\\n    L=list(map(int,input().split()))\\n    s=sum(L)\\n    if s*2>n:\\n        if (n//2)%2:\\n            print(n//2+1)\\n            for i in ' '*(n//2+1):print(1,end=' ')\\n        else:\\n            print(n//2)\\n            for i in ' '*(n//2):print(1,end=' ')\\n    else:\\n        print(n//2)\\n        for i in ' '*(n//2):print(0,end=' ')\\n    print()\", \"from math import log2, ceil\\n\\ndef readGenerator():\\n    while True:\\n        tokens = input().split(' ')\\n        for t in tokens:\\n            yield t\\n\\nreader = readGenerator()\\n\\ndef readWord():\\n    return next(reader)\\n\\ndef readInt():\\n    return int(next(reader))\\n\\ndef readFloat():\\n    return float(next(reader))\\n\\ndef readLine():\\n    return input()\\n\\ndef solve(a):\\n    v0, v1 = 0, 0\\n    for i in a:\\n        if i == 0:\\n            v0 += 1\\n        else:\\n            v1 += 1\\n\\n    if v1 > v0:\\n        if v1 % 2 != 0:\\n            v1 -= 1\\n        print(v1)\\n        return '1 ' * v1\\n    print(v0)\\n    return '0 ' * v0\\n\\n\\ntests = readInt()\\n\\nfor i in range(tests):\\n    n = readInt()\\n    a = [readInt() for _ in range(n)]\\n    print(solve(a))\", \"def solve():\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    if a.count(0) >= n // 2:\\n        print(n // 2)\\n        print(' '.join('0' * (n // 2)))\\n    else:\\n        m = n // 2\\n        if m % 2 == 1:\\n            m += 1\\n        print(m)\\n        print(' '.join('1' * (m)))\\nt = int(input())\\nfor _ in range(t):\\n    solve()\", \"t = int(input())\\nfor _ in range(t):\\n\\tn = int(input())\\n\\tarr = [int(j) for j in input().split()]\\n\\n\\to = arr.count(1)\\n\\tz = arr.count(0)\\n\\n\\tif o > z:\\n\\t\\tif (n-z)%2 == 1:\\n\\t\\t\\tprint(n-z-1)\\n\\t\\t\\tprint(*([1]*(n-z-1)))\\n\\t\\telse:\\n\\t\\t\\tprint(n-z)\\n\\t\\t\\tprint(*([1]*(n-z)))\\n\\telse:\\n\\t\\tprint(n-o)\\n\\t\\tprint(*([0]*(n-o)))\", \"for _ in range(int(input())):\\n    n = int(input())\\n    l = list(map(int,input().split()))\\n    one = l.count(1)\\n    zero = n-one\\n    if zero>=n//2:\\n        print(zero)\\n        print(*[0]*zero)\\n    else:\\n        one -= one%2\\n        print(one)\\n        print(*[1]*one)\", \"\\nfrom sys import stdin\\n\\ntt = int(stdin.readline())\\n\\nfor loop in range(tt):\\n\\n    n = int(stdin.readline())\\n    a = list(map(int,stdin.readline().split()))\\n\\n    z = 0\\n    o = 0\\n    ans = []\\n\\n    for i in a:\\n        if i == 0:\\n            z += 1\\n        else:\\n            o += 1\\n\\n        if z == 2:\\n            z = 0\\n            o = 0\\n            ans.append(0)\\n            ans.append(0)\\n\\n        elif o == 2:\\n            z = 0\\n            o = 0\\n            ans.append(1)\\n            ans.append(1)\\n\\n    if z > 0:\\n        ans.append(0)\\n    \\n    print(len(ans))\\n    print(*ans)\\n\", \"for _ in range(int(input())):\\n    n=int(input())\\n    a=list(map(int,input().split()))\\n    if a.count(0)>=n//2:\\n        print(n//2)\\n        print(*[0]*(n//2))\\n    else:\\n        if (n//2)%2==0:\\n            print(n//2)\\n            print(*[1]*(n//2))\\n        else:\\n            print(n//2+1)\\n            print(*[1]*(n//2+1))\\n\", \"import sys\\n\\ndef input():\\n\\treturn sys.stdin.readline().rstrip()\\n\\ndef input_split():\\n\\treturn [int(i) for i in input().split()]\\n\\ntestCases = int(input())\\nanswers = []\\nfor _ in range(testCases):\\n\\t#take input\\n\\tn = int(input())\\n\\tarr = input_split()\\n\\n\\ts = sum(arr)\\n\\n\\tif s <= n//2:\\n\\t\\tans = [0]*(n//2)\\n\\telse:\\n\\t\\t#num of ones is greater than equal to n//2\\n\\t\\tif n%4 == 0:\\n\\t\\t\\tans = [1]*(n//2)\\n\\t\\telse:\\n\\t\\t\\tans = [1]*((n//2) + 1)\\n\\t\\t# ans = [1]*()\\n\\n\\tanswers.append(ans)\\nfor ans in answers:\\n\\tprint(len(ans))\\n\\tprint(*ans, sep = ' ')\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n2\\n1 0\\n2\\n0 0\\n4\\n0 1 1 1\\n4\\n1 1 0 0\\n\"\n  ],\n  \"outputs\": [\n    \"1\\n0 \\n2\\n0 0 \\n2\\n1 1 \\n2\\n0 0 \\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1407/A", "starter_code": ""}
{"id": 87, "question": "Berland year consists of $m$ months with $d$ days each. Months are numbered from $1$ to $m$. Berland week consists of $w$ days. The first day of the year is also the first day of the week. Note that the last week of the year might be shorter than $w$ days.\n\nA pair $(x, y)$ such that $x < y$ is ambiguous if day $x$ of month $y$ is the same day of the week as day $y$ of month $x$.\n\nCount the number of ambiguous pairs.\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of testcases.\n\nEach of the next $t$ lines contains three integers $m$, $d$ and $w$ ($1 \\le m, d, w \\le 10^9$)\u00a0\u2014 the number of months in a year, the number of days in a month and the number of days in a week.\n\n\n-----Output-----\n\nPrint $t$ integers\u00a0\u2014 for each testcase output the number of pairs $(x, y)$ such that $x < y$ and day $x$ of month $y$ is the same day of the week as day $y$ of month $x$.\n\n\n-----Example-----\nInput\n5\n6 7 4\n10 7 12\n12 30 7\n1 1 1\n3247834 10298779 625324\n\nOutput\n6\n9\n5\n0\n116461800\n\n\n\n-----Note-----\n\nHere are the pairs for the first test case:  $$", "solutions": "[\"import sys\\n\\nreadline = sys.stdin.readline\\nreadlines = sys.stdin.readlines\\nns = lambda: readline().rstrip()\\nni = lambda: int(readline().rstrip())\\nnm = lambda: map(int, readline().split())\\nnl = lambda: list(map(int, readline().split()))\\nprn = lambda x: print(*x, sep='\\\\n')\\n\\ndef gcd(a, b):\\n    while b:\\n        a, b = b, a%b\\n    return a\\n\\ndef solve():\\n    m, d, w = nm()\\n    g = w // gcd(d-1, w)\\n    c = min(m, d)\\n    v = c // g\\n    ans = v * (v - 1) // 2 * g\\n    ans += (c - g * v) * v\\n    print(ans)\\n    return\\n\\n\\n# solve()\\n\\nT = ni()\\nfor _ in range(T):\\n    solve()\\n\", \"from  math import gcd\\n\\nfor _ in range(int(input())):\\n    m,d,w=list(map(int,input().split()))\\n    M=min(m,d)\\n    W=w//gcd(w,d-1)\\n    Q=M//W\\n    R=M%W\\n    ans=(W-R)*(Q*(Q-1)//2)+R*(Q*(Q+1)//2)\\n    print(ans)\\n\", \"import sys\\nimport math\\n\\nT = int(sys.stdin.readline().strip())\\nfor t in range (0, T):\\n    m, d, w = list(map(int, sys.stdin.readline().strip().split()))\\n    w = w // math.gcd(w, d-1)\\n    d = min(d, m)\\n    m = d\\n    ans = -d\\n    ans = ans + (m // w) * d\\n    m = m - (m // w) * w\\n    ans = ans + (d // w) * m\\n    d = d - (d // w) * w\\n    ans = ans + d\\n    print(ans//2)\", \"import sys\\nimport heapq, functools, collections\\nimport math, random\\nfrom collections import Counter, defaultdict\\n\\n# available on Google, not available on Codeforces\\n# import numpy as np\\n# import scipy\\n\\n\\ndef solve(m,d,w):  # fix inputs here\\n    console(\\\"----- solving ------\\\")\\n\\n    a = int(w/math.gcd(w,1-d))\\n    b = min(m,d)\\n\\n    console(a,b)\\n\\n    return ((1 + b//a)*(b + b%a))//2 - b\\n\\n\\ndef console(*args):  # the judge will not read these print statement\\n    print('\\\\033[36m', *args, '\\\\033[0m', file=sys.stderr)\\n    return\\n\\n# fast read all\\n# sys.stdin.readlines()\\n\\nfor case_num in range(int(input())):\\n    # read line as a string\\n    # strr = input()\\n\\n    # read line as an integer\\n    # k = int(input())\\n    \\n    # read one line and parse each word as a string\\n    # lst = input().split()\\n\\n    # read one line and parse each word as an integer\\n    m,d,w = list(map(int,input().split()))\\n\\n    # read matrix and parse as integers (after reading read nrows)\\n    # lst = list(map(int,input().split()))\\n    # nrows = lst[0]  # index containing information, please change\\n    # grid = []\\n    # for _ in range(nrows):\\n    #     grid.append(list(map(int,input().split())))\\n\\n    res = solve(m,d,w)  # please change\\n    \\n    # Google - case number required\\n    # print(\\\"Case #{}: {}\\\".format(case_num+1, res))\\n\\n    # Codeforces - no case number required\\n    print(res)\\n\", \"from math import gcd\\n\\ndef sum_of_floor(n, p, q):\\n    t = gcd(p, q)\\n    p, q = p // t, q // t\\n    s = 0\\n    z = 1\\n    while q > 0 and n > 0:\\n        t = p // q\\n        s = s + z * t * n * (n + 1) // 2\\n        p = p - q * t\\n        t = n // q\\n        s = s + z * p * t * (n + 1) - z * t * (p * q * t + p + q - 1) // 2\\n        n = n - q * t\\n        t = (n * p) // q\\n        s = s + z * t * n\\n        n = t\\n        p, q = q, p\\n        z = -z\\n    return s\\n\\ndef solve():\\n    m, d, w = map(int, input().split())\\n    if d == 1:\\n        print(0)\\n        return\\n    u = gcd(d - 1, w)\\n    res = sum_of_floor(min(m, d) - 1, 1, w // u)\\n    print(res)\\n\\nt = int(input())\\nfor _ in range(t):\\n    solve()\", \"from math import gcd\\n\\nfor _ in range(int(input())):\\n    m, d, w = list(map(int, input().split()))\\n    if d == 1:\\n        print(0)\\n    else:\\n        w1 = w // gcd(w, d - 1)\\n        md = min(m, d)\\n        # sum(max(md - w1 * n, 0) for n in 1..inf)\\n        # sum(md - w1 * n for n in 1..md // w1)\\n        mdd_w1 = md // w1\\n        print((md * 2 - w1 - mdd_w1 * w1) * mdd_w1 // 2)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"5\\n6 7 4\\n10 7 12\\n12 30 7\\n1 1 1\\n3247834 10298779 625324\\n\"\n  ],\n  \"outputs\": [\n    \"6\\n9\\n5\\n0\\n116461800\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1389/E", "starter_code": ""}
{"id": 88, "question": "Bob is playing with $6$-sided dice. A net of such standard cube is shown below.\n\n[Image]\n\nHe has an unlimited supply of these dice and wants to build a tower by stacking multiple dice on top of each other, while choosing the orientation of each dice. Then he counts the number of visible pips on the faces of the dice.\n\nFor example, the number of visible pips on the tower below is $29$ \u2014 the number visible on the top is $1$, from the south $5$ and $3$, from the west $4$ and $2$, from the north $2$ and $4$ and from the east $3$ and $5$.\n\n[Image]\n\nThe one at the bottom and the two sixes by which the dice are touching are not visible, so they are not counted towards total.\n\nBob also has $t$ favourite integers $x_i$, and for every such integer his goal is to build such a tower that the number of visible pips is exactly $x_i$. For each of Bob's favourite integers determine whether it is possible to build a tower that has exactly that many visible pips.\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 1000$)\u00a0\u2014 the number of favourite integers of Bob. \n\nThe second line contains $t$ space-separated integers $x_i$ ($1 \\leq x_i \\leq 10^{18}$)\u00a0\u2014 Bob's favourite integers.\n\n\n-----Output-----\n\nFor each of Bob's favourite integers, output \"YES\" if it is possible to build the tower, or \"NO\" otherwise (quotes for clarity).\n\n\n-----Example-----\nInput\n4\n29 34 19 38\n\nOutput\nYES\nYES\nYES\nNO\n\n\n\n-----Note-----\n\nThe first example is mentioned in the problem statement.\n\nIn the second example, one can build the tower by flipping the top dice from the previous tower.\n\nIn the third example, one can use a single die that has $5$ on top.\n\nThe fourth example is impossible.", "solutions": "[\"n = input()\\na = list(map(int, input().split()))\\nfor i in a:\\n\\tif i % 7 == 0 or (i // 7) % 2 == 1 or i <= 14:\\n\\t\\tprint('NO')\\n\\telse:\\n\\t\\tprint('YES')\", \"n = int(input())\\narr = list(map(int, input().split()))\\nfor x in arr:\\n    if x < 15:\\n        print('NO')\\n        continue\\n    if x % 14 >= 7 or x % 14 == 0:\\n        print('NO')\\n        continue\\n    else:\\n        print('YES')\\n\\n\", \"n = int(input())\\na = list(map(int, input().split()))\\nfor i in a:\\n    tmp = i%14\\n    if i>=15 and tmp>=1 and tmp<=6:\\n        print('YES')\\n    else:\\n        print('NO')\\n\", \"n = int(input())\\n\\nfor x in map(int, input().split()):\\n\\tprint(\\\"YES\\\" if x > 14 and x % 14 > 0 and x % 14 <= 6 else \\\"NO\\\")\", \"n=int(input())\\narr=list(map(int,input().split()))\\nfor i in arr:\\n\\tif i<=14:\\n\\t\\tprint(\\\"NO\\\")\\n\\telse:\\n\\t\\tflg=False\\n\\t\\tfor j in range(1,7):\\n\\t\\t\\tif (i-j)%14==0:\\n\\t\\t\\t\\tflg=True\\n\\t\\tif flg:\\n\\t\\t\\tprint(\\\"YES\\\")\\n\\t\\telse:\\n\\t\\t\\tprint(\\\"NO\\\")\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n29 34 19 38\\n\"\n  ],\n  \"outputs\": [\n    \"YES\\nYES\\nYES\\nNO\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1266/B", "starter_code": ""}
{"id": 89, "question": "Monocarp had a tree which consisted of $n$ vertices and was rooted at vertex $1$. He decided to study BFS (Breadth-first search), so he ran BFS on his tree, starting from the root. BFS can be described by the following pseudocode:a = [] # the order in which vertices were processed\n\nq = Queue()\n\nq.put(1) # place the root at the end of the queue\n\nwhile not q.empty():\n\n    k = q.pop() # retrieve the first vertex from the queue\n\n    a.append(k) # append k to the end of the sequence in which vertices were visited\n\n    for y in g[k]: # g[k] is the list of all children of vertex k, sorted in ascending order\n\n        q.put(y)\n\n\n\nMonocarp was fascinated by BFS so much that, in the end, he lost his tree. Fortunately, he still has a sequence of vertices, in which order vertices were visited by the BFS algorithm (the array a from the pseudocode). Monocarp knows that each vertex was visited exactly once (since they were put and taken from the queue exactly once). Also, he knows that all children of each vertex were viewed in ascending order.\n\nMonocarp knows that there are many trees (in the general case) with the same visiting order $a$, so he doesn't hope to restore his tree. Monocarp is okay with any tree that has minimum height.\n\nThe height of a tree is the maximum depth of the tree's vertices, and the depth of a vertex is the number of edges in the path from the root to it. For example, the depth of vertex $1$ is $0$, since it's the root, and the depth of all root's children are $1$.\n\nHelp Monocarp to find any tree with given visiting order $a$ and minimum height.\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of vertices in the tree.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$; $a_i \\neq a_j$; $a_1 = 1$)\u00a0\u2014 the order in which the vertices were visited by the BFS algorithm.\n\nIt's guaranteed that the total sum of $n$ over test cases doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case print the minimum possible height of a tree with the given visiting order $a$.\n\n\n-----Example-----\nInput\n3\n4\n1 4 3 2\n2\n1 2\n3\n1 2 3\n\nOutput\n3\n1\n1\n\n\n\n-----Note-----\n\nIn the first test case, there is only one tree with the given visiting order:  [Image] \n\nIn the second test case, there is only one tree with the given visiting order as well:  [Image] \n\nIn the third test case, an optimal tree with the given visiting order is shown below:  [Image]", "solutions": "[\"from sys import stdin\\n\\ntt = int(stdin.readline())\\n\\nfor loop in range(tt):\\n\\n    n = int(stdin.readline())\\n    a = list(map(int,stdin.readline().split()))\\n\\n    lis = [ [1] ]\\n\\n    now = []\\n    tmp = 0\\n\\n    for i in range(1,n):\\n        if len(now) == 0:\\n            now.append(a[i])\\n            tmp = 1\\n        elif now[-1] > a[i]:\\n            if tmp == len(lis[-1]):\\n                lis.append(now)\\n                now = [a[i]]\\n                tmp = 1\\n            else:\\n                tmp += 1\\n                now.append(a[i])\\n        else:\\n            now.append(a[i])\\n\\n    if len(now) > 0:\\n        lis.append(now)\\n\\n    #print (lis)\\n    print (len(lis)-1)\", \"for _ in range(int(input())):\\n  N = int(input())\\n  A = [int(x) for x in input().split()]\\n  last = i = j = 1\\n  ans = nxt = cur = 0\\n  while j < N:\\n    while j < N-1 and A[j+1] > A[j]:\\n      j += 1\\n    if cur == 0:\\n      ans += 1\\n    nxt += j - i + 1\\n    j += 1\\n    i = j\\n    cur += 1\\n    if cur == last:\\n      last = nxt\\n      nxt = cur = 0\\n\\n  print(ans)\\n\", \"import sys\\ninput=sys.stdin.readline\\nfor _ in range(int(input())):\\n    n = int(input())\\n    a = list(map(int,input().split()))\\n    if n < 3:\\n        print(1)\\n        continue\\n    old = [0]\\n    h = 1\\n    nind = prev = cum = 0\\n    for i in range(1,n):\\n        if a[i] < prev:\\n            nind += 1\\n            if nind >= len(old):\\n                old = [0] * cum\\n                nind = cum = 0\\n                h += 1\\n        prev = a[i]\\n        old[nind] += 1\\n        cum += 1\\n    print(h)\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n4\\n1 4 3 2\\n2\\n1 2\\n3\\n1 2 3\\n\"\n  ],\n  \"outputs\": [\n    \"3\\n1\\n1\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1437/D", "starter_code": ""}
{"id": 90, "question": "You are given an array $a$, consisting of $n$ integers.\n\nEach position $i$ ($1 \\le i \\le n$) of the array is either locked or unlocked. You can take the values on the unlocked positions, rearrange them in any order and place them back into the unlocked positions. You are not allowed to remove any values, add the new ones or rearrange the values on the locked positions. You are allowed to leave the values in the same order as they were.\n\nFor example, let $a = [-1, 1, \\underline{3}, 2, \\underline{-2}, 1, -4, \\underline{0}]$, the underlined positions are locked. You can obtain the following arrays:   $[-1, 1, \\underline{3}, 2, \\underline{-2}, 1, -4, \\underline{0}]$;  $[-4, -1, \\underline{3}, 2, \\underline{-2}, 1, 1, \\underline{0}]$;  $[1, -1, \\underline{3}, 2, \\underline{-2}, 1, -4, \\underline{0}]$;  $[1, 2, \\underline{3}, -1, \\underline{-2}, -4, 1, \\underline{0}]$;  and some others. \n\nLet $p$ be a sequence of prefix sums of the array $a$ after the rearrangement. So $p_1 = a_1$, $p_2 = a_1 + a_2$, $p_3 = a_1 + a_2 + a_3$, $\\dots$, $p_n = a_1 + a_2 + \\dots + a_n$.\n\nLet $k$ be the maximum $j$ ($1 \\le j \\le n$) such that $p_j < 0$. If there are no $j$ such that $p_j < 0$, then $k = 0$.\n\nYour goal is to rearrange the values in such a way that $k$ is minimum possible.\n\nOutput the array $a$ after the rearrangement such that the value $k$ for it is minimum possible. If there are multiple answers then print any of them.\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of testcases.\n\nThen $t$ testcases follow.\n\nThe first line of each testcase contains a single integer $n$ ($1 \\le n \\le 100$)\u00a0\u2014 the number of elements in the array $a$.\n\nThe second line of each testcase contains $n$ integers $a_1, a_2, \\dots, a_n$ ($-10^5 \\le a_i \\le 10^5$)\u00a0\u2014 the initial array $a$.\n\nThe third line of each testcase contains $n$ integers $l_1, l_2, \\dots, l_n$ ($0 \\le l_i \\le 1$), where $l_i = 0$ means that the position $i$ is unlocked and $l_i = 1$ means that the position $i$ is locked.\n\n\n-----Output-----\n\nPrint $n$ integers\u00a0\u2014 the array $a$ after the rearrangement. Value $k$ (the maximum $j$ such that $p_j < 0$ (or $0$ if there are no such $j$)) should be minimum possible. For each locked position the printed value should be equal to the initial one. The values on the unlocked positions should be an arrangement of the initial ones.\n\nIf there are multiple answers then print any of them.\n\n\n-----Example-----\nInput\n5\n3\n1 3 2\n0 0 0\n4\n2 -3 4 -1\n1 1 1 1\n7\n-8 4 -2 -6 4 7 1\n1 0 0 0 1 1 0\n5\n0 1 -4 6 3\n0 0 0 1 1\n6\n-1 7 10 4 -8 -1\n1 0 0 0 0 1\n\nOutput\n1 2 3\n2 -3 4 -1\n-8 -6 1 4 4 7 -2\n-4 0 1 6 3\n-1 4 7 -8 10 -1\n\n\n-----Note-----\n\nIn the first testcase you can rearrange all values however you want but any arrangement will result in $k = 0$. For example, for an arrangement $[1, 2, 3]$, $p=[1, 3, 6]$, so there are no $j$ such that $p_j < 0$. Thus, $k = 0$.\n\nIn the second testcase you are not allowed to rearrange any elements. Thus, the printed array should be exactly the same as the initial one.\n\nIn the third testcase the prefix sums for the printed array are $p = [-8, -14, -13, -9, -5, 2, 0]$. The maximum $j$ is $5$, thus $k = 5$. There are no arrangements such that $k < 5$.\n\nIn the fourth testcase $p = [-4, -4, -3, 3, 6]$.\n\nIn the fifth testcase $p = [-1, 3, 10, 2, 12, 11]$.", "solutions": "[\"import math\\nfrom collections import deque\\nfrom sys import stdin, stdout\\nfrom string import ascii_letters\\nimport sys\\nletters = ascii_letters\\ninput = stdin.readline\\n#print = stdout.write\\n\\nfor _ in range(int(input())):\\n    n = int(input())\\n    arr = list(map(int, input().split()))\\n    can = list(map(int, input().split()))\\n    vals = sorted([i for i in range(n) if not can[i]], key=lambda x: -arr[x])\\n    res = [0] * n\\n    last = 0\\n    for i in range(n):\\n        if can[i]:\\n            res[i] = arr[i]\\n        else:\\n            res[i] = arr[vals[last]]\\n            last += 1\\n    print(*res)\\n\", \"import sys\\nimport math as mt\\nimport collections as cc\\nimport sys\\nimport itertools as it\\ninput=sys.stdin.readline\\nI=lambda:list(map(int,input().split()))\\nfor tc in range(int(input())):\\n\\tn,=I()\\n\\tar=I()\\n\\tl=I()\\n\\ts=[]\\n\\tll=l.copy()\\n\\tloc=cc.defaultdict(int)\\n\\tfor i in range(n):\\n\\t\\tif l[i]==0:\\n\\t\\t\\ts.append(ar[i])\\n\\t\\t\\tloc[i]=-10**6\\t\\n\\t\\telse:\\n\\t\\t\\tloc[i]=ar[i]\\n\\ts.sort(reverse=True)\\n\\tj=0\\n\\tfor i in range(n):\\n\\t\\tif l[i]==0:\\n\\t\\t\\tl[i]=s[j]\\n\\t\\t\\tj+=1\\n\\t\\telse:\\n\\t\\t\\tl[i]=ar[i]\\n\\tprint(*l)\\n\\n\", \"from collections import deque\\n\\nt = int(input())\\n\\nfor _ in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    l = list(map(int, input().split()))\\n    \\n    bckt = []\\n    for i in range(n):\\n        if not l[i]:\\n            bckt.append(a[i])\\n            a[i] = 10**9\\n            \\n    bckt.sort(reverse=True)\\n    bckt = deque(bckt)\\n    \\n    for i in range(n):\\n        if a[i] == 10**9:\\n            a[i] = bckt.popleft()\\n            \\n    print(*a)\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    l = list(map(int, input().split()))\\n\\n    s = []\\n    out = [10**6] * n\\n    for i in range(n):\\n        if l[i]:\\n            out[i] = a[i]\\n        else:\\n            s.append(a[i])\\n    s.sort()\\n    for i in range(n):\\n        if out[i] == 10**6:\\n            out[i] = s.pop()\\n    print(' '.join(map(str,out)))\\n\", \"for _ in range (int(input())):\\n    n = int(input())\\n    a =  [int(i) for i in input().split()]\\n    l =  [int(i) for i in input().split()]\\n    b = []\\n    for i in range (n):\\n        if l[i]==0:\\n            b.append(a[i])\\n    b.sort(reverse=True)\\n    ind = 0\\n    for i in range (n):\\n        if l[i]==0:\\n            a[i]=b[ind]\\n            ind+=1\\n    print(*a)\", \"from sys import stdin\\ndef input(): return stdin.readline().rstrip()\\n\\nfor _ in range(int(input())):\\n    L = int(input())\\n    lockSort = []\\n    s = list(map(int, input().split()))\\n    l = list(map(int, input().split()))\\n    for i, c in enumerate(s):\\n        if l[i] == 0:\\n            lockSort.append(c)\\n    lockSort = sorted(lockSort)[::-1]\\n    cnt = 0\\n    for i, c in enumerate(s):\\n        if l[i] == 1:\\n            print(c, end=\\\" \\\")\\n        else:\\n            print(lockSort[cnt], end=\\\" \\\")\\n            cnt += 1\\n    print()\\n\", \"for t in range(int(input())):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    lock = list(map(int, input().split()))\\n    b = []\\n    for i in range(n):\\n        if lock[i] == 0:\\n            b.append(a[i])\\n    b.sort()\\n    b=b[::-1]\\n    ind = 0\\n    for i in range(n):\\n        if lock[i] == 0:\\n            a[i]=b[ind]\\n            ind+=1\\n    a=[str(i) for i in a]\\n    print(\\\" \\\".join(a))\", \"\\nINF = float('inf')\\n\\n\\ndef prod(arr):\\n    ret = 1\\n    for x in arr:\\n        ret *= x\\n\\n    return ret\\n\\n\\ndef tc():\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    l = list(map(int, input().split()))\\n\\n    uis = []\\n    for i in range(n):\\n        if not l[i]:\\n            uis.append(i)\\n\\n    uvals = [a[i] for i in uis]\\n    uvals.sort()\\n\\n    for i in uis:\\n        a[i] = uvals.pop()\\n\\n    print(' '.join(map(str, a)))\\n\\n\\n################\\nT = int(input())\\nfor _ in range(T):\\n    tc()\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    l = list(map(int, input().split()))\\n    b = []\\n    for i in range(n):\\n        if l[i] == 0:\\n            b.append(a[i])\\n    b.sort()\\n    b.reverse()\\n    j = 0\\n    for i in range(n):\\n        if l[i] == 0:\\n            a[i] = b[j]\\n            j += 1\\n    print(*a)\", \"input=__import__('sys').stdin.readline\\nfor _ in range(int(input())):\\n    n=int(input())\\n    a=list(map(int,input().split()))\\n    blocked=[]\\n    binds=[]\\n    b=list(map(int,input().split()))\\n    for i in range(n):\\n        if not b[i]:blocked+=a[i],;binds+=i,\\n    blocked.sort()\\n    for i in range(len(binds)):\\n        a[binds[i]]=blocked[i]\\n    k1=-1\\n    cs=0\\n    for i in range(n):\\n        cs+=a[i]\\n        if cs<0:k1=i\\n    ans1=a.copy()\\n    blocked.reverse()\\n    for i in range(len(binds)):\\n        a[binds[i]]=blocked[i]\\n    k2=-1\\n    cs=0\\n    for i in range(n):\\n        cs+=a[i]\\n        if cs<0:k2=i\\n    ans2=a.copy()\\n    ans=ans1 if k1<k2 else ans2\\n    print(*ans)\", \"import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\nfor tests in range(t):\\n    n=int(input())\\n    A=list(map(int,input().split()))\\n    l=list(map(int,input().split()))\\n\\n    B=[]\\n    for i in range(n):\\n        if l[i]==0:\\n            B.append(A[i])\\n    B.sort(reverse=True)\\n\\n    ind=0\\n    for i in range(n):\\n        if l[i]==0:\\n            A[i]=B[ind]\\n            ind+=1\\n\\n    print(*A)\\n            \\n\\n    \\n    \\n    \\n\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    nums = list(map(int, input().split()))\\n    st = list(map(int, input().split()))\\n    sv = []\\n    for j in range(n):\\n        if st[j] == 0:\\n            sv.append(nums[j])\\n    sv.sort(reverse=True)\\n    new = []\\n    k = 0\\n    for j in range(n):\\n        if st[j] == 1:\\n            new.append(nums[j])\\n        else:\\n            new.append(sv[k])\\n            k += 1\\n    print(*new)\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    a = list(map(int,input().split()))\\n    l = list(map(int,input().split()))\\n    b = []\\n    if sum(l) < n: # exist non-blocked\\n        for i in range(n):\\n            if l[i] == 0:\\n                b.append(a[i])\\n        b.sort(reverse=True)\\n        j = 0\\n        for i in range(n):\\n            if l[i] == 0:\\n                print(b[j], end =' ')\\n                j += 1\\n            else:\\n                print(a[i], end =' ')\\n        print()\\n    else:\\n        for i in range(n):\\n            print(a[i],end=' ')\\n        print()\", \"import sys,os,io\\ninput = sys.stdin.readline\\n#input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\\nT = int(input())\\nans = [0]*T\\nfor t in range(T):\\n  N = int(input())\\n  A = list(map(int, input().split()))\\n  L = list(map(int, input().split()))\\n  B = [A[i] for i in range(N) if L[i]==0]\\n  B.sort()\\n  ans[t] = []\\n  for i in range(N):\\n    if L[i]==0:\\n      ans[t].append(B.pop())\\n    else:\\n      ans[t].append(A[i])\\nfor a in ans:\\n  print(*a)\", \"for _ in range(int(input())):\\n    n = int(input())\\n    *arr, = list(map(int, input().split()))\\n    *locks, = list(map(int, input().split()))\\n\\n    locked = []\\n    unlocked = []\\n    for v, is_locked in zip(arr, locks):\\n        if not is_locked:\\n            unlocked.append(v)\\n    unlocked.sort(reverse=True)\\n    arr_idx = 0\\n    unlocked_idx = 0\\n    while unlocked_idx < len(unlocked) and arr_idx < len(arr):\\n        if not locks[arr_idx]:\\n            arr[arr_idx] = unlocked[unlocked_idx]\\n            unlocked_idx += 1\\n        arr_idx += 1\\n    print(*arr)\\n\", \"from math import inf, ceil\\nfrom heapq import *\\nfrom collections import defaultdict\\n\\nfor _ in range(int(input())):\\n    n = int(input())\\n    arr = list(map(int, input().split()))\\n    brr = list(map(int, input().split()))\\n    crr = [arr[i] for i in range(n) if not brr[i]]\\n    crr.sort(reverse=True)\\n    ind = 0\\n    for i in range(n):\\n        if not brr[i]:\\n            arr[i] = crr[ind]\\n            ind += 1\\n    print(*arr)\", \"def main():\\n    n = int(input())\\n    a = list(map(int,input().split()))\\n    l = list(map(int,input().split()))\\n    new_lst = []\\n    for i in range(n):\\n        if not l[i]:\\n            new_lst.append(a[i])\\n    new_lst = sorted(new_lst, reverse=True)\\n    k = 0\\n    for i in range(n):\\n        if not l[i]:\\n            a[i] = new_lst[k]\\n            k += 1\\n    sm = 0\\n    for i in a:\\n        print(i, end=\\\" \\\")\\n    print()\\n\\ndef __starting_point():\\n    t = int(input())\\n    for i in range(t):\\n        main()\\n\\n__starting_point()\", \"for _ in range(int(input())):\\n    N = int(input())\\n    List = [int(x) for x in input().split()]\\n    Lock = [int(x) for x in input().split()]\\n    X = []\\n    for i in range(N):\\n        if(not Lock[i]):\\n            X.append(List[i])\\n    X.sort(reverse  = True)\\n    j = 0\\n    for i in range(N):\\n        if(not Lock[i]):\\n            List[i] = X[j]\\n            j+=1\\n    print(*List)\", \"t=int(input())\\nfor _ in range(t):\\n    n=int(input())\\n    a=list(map(int,input().split(\\\" \\\")))\\n    b = list(map(int, input().split(\\\" \\\")))\\n    c=[]\\n    for i in range(n):\\n        if b[i]==0:\\n            c.append(a[i])\\n    c.sort(reverse=True)\\n    k=0\\n    for i in range(n):\\n        if b[i]==0:\\n            a[i]=c[k]\\n            k+=1\\n    print(\\\" \\\".join(str(j) for j in a))\\n\", \"import sys\\nimport heapq, functools, collections\\nimport math, random\\nfrom collections import Counter, defaultdict\\n\\n# available on Google, not available on Codeforces\\n# import numpy as np\\n# import scipy\\n\\n\\ndef solve(arr, brr):  # fix inputs here\\n    console(\\\"----- solving ------\\\")\\n\\n    movable = []\\n    for a,b in zip(arr,brr):\\n        if b == 0:\\n            movable.append(a)\\n    \\n    movable = sorted(movable)\\n    # console(movable)\\n\\n    for i in range(len(arr)):\\n        if brr[i] == 0:\\n            arr[i] = movable.pop()\\n\\n    # return a string (i.e. not a list or matrix)\\n    return arr \\n\\n\\ndef console(*args):  # the judge will not read these print statement\\n    print('\\\\033[36m', *args, '\\\\033[0m', file=sys.stderr)\\n    return\\n\\n# fast read all\\n# sys.stdin.readlines()\\n\\nfor case_num in range(int(input())):\\n    # read line as a string\\n    # strr = input()\\n\\n    # read line as an integer\\n    k = int(input())\\n    \\n    # read one line and parse each word as a string\\n    # lst = input().split()\\n\\n    # read one line and parse each word as an integer\\n    arr = list(map(int,input().split()))\\n    brr = list(map(int,input().split()))\\n\\n    # read matrix and parse as integers (after reading read nrows)\\n    # lst = list(map(int,input().split()))\\n    # nrows = lst[0]  # index containing information, please change\\n    # grid = []\\n    # for _ in range(nrows):\\n    #     grid.append(list(map(int,input().split())))\\n\\n    res = solve(arr,brr)  # please change\\n    \\n    # Google - case number required\\n    # print(\\\"Case #{}: {}\\\".format(case_num+1, res))\\n\\n    # Codeforces - no case number required\\n    print(\\\" \\\".join([str(x) for x in res]))\\n\", \"import sys\\ninput = sys.stdin.readline\\nI = lambda : list(map(int,input().split()))\\n\\nt,=I()\\nfor i in range(t):\\n\\tn,=I()\\n\\ta=I()\\n\\tl=I()\\n\\tar=[a[i] for i in range(n) if l[i]==0]\\n\\tar.sort(reverse=True)\\n\\tx=0\\n\\tfor i in range(n):\\n\\t\\tif l[i]==0:\\n\\t\\t\\ta[i]=ar[x]\\n\\t\\t\\tx+=1\\n\\tprint(*a)\\n\", \"from sys import stdin\\ndef input(): return stdin.readline()\\ndef lmi(): return list(map(int, input().split()))\\n\\nT = int(input())\\nfor _ in range(T):\\n    input()\\n    temp = list()\\n    s, l = lmi(), lmi()\\n    for i, c in enumerate(s):\\n        if l[i] == 0: temp.append(c)\\n    temp = sorted(temp)[::-1]\\n    cc = 0\\n    for i, x in enumerate(s):\\n        if l[i] == 1: print(x, end=\\\" \\\")\\n        else:\\n            print(temp[cc], end=\\\" \\\")\\n            cc += 1\\n    print()\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"5\\n3\\n1 3 2\\n0 0 0\\n4\\n2 -3 4 -1\\n1 1 1 1\\n7\\n-8 4 -2 -6 4 7 1\\n1 0 0 0 1 1 0\\n5\\n0 1 -4 6 3\\n0 0 0 1 1\\n6\\n-1 7 10 4 -8 -1\\n1 0 0 0 0 1\\n\"\n  ],\n  \"outputs\": [\n    \"3 2 1 \\n2 -3 4 -1 \\n-8 4 1 -2 4 7 -6 \\n1 0 -4 6 3 \\n-1 10 7 4 -8 -1 \\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1418/B", "starter_code": ""}
{"id": 91, "question": "Permutation $p$ is a sequence of integers $p=[p_1, p_2, \\dots, p_n]$, consisting of $n$ distinct (unique) positive integers between $1$ and $n$, inclusive. For example, the following sequences are permutations: $[3, 4, 1, 2]$, $[1]$, $[1, 2]$. The following sequences are not permutations: $[0]$, $[1, 2, 1]$, $[2, 3]$, $[0, 1, 2]$.\n\nThe important key is in the locked box that you need to open. To open the box you need to enter secret code. Secret code is a permutation $p$ of length $n$. \n\nYou don't know this permutation, you only know the array $q$ of prefix maximums of this permutation. Formally:  $q_1=p_1$,  $q_2=\\max(p_1, p_2)$,  $q_3=\\max(p_1, p_2,p_3)$,  ...  $q_n=\\max(p_1, p_2,\\dots,p_n)$. \n\nYou want to construct any possible suitable permutation (i.e. any such permutation, that calculated $q$ for this permutation is equal to the given array).\n\n\n-----Input-----\n\nThe first line contains integer number $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases in the input. Then $t$ test cases follow.\n\nThe first line of a test case contains one integer $n$ $(1 \\le n \\le 10^{5})$\u00a0\u2014 the number of elements in the secret code permutation $p$.\n\nThe second line of a test case contains $n$ integers $q_1, q_2, \\dots, q_n$ $(1 \\le q_i \\le n)$\u00a0\u2014 elements of the array $q$ for secret permutation. It is guaranteed that $q_i \\le q_{i+1}$ for all $i$ ($1 \\le i < n$).\n\nThe sum of all values $n$ over all the test cases in the input doesn't exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print:  If it's impossible to find such a permutation $p$, print \"-1\" (without quotes).  Otherwise, print $n$ distinct integers $p_1, p_2, \\dots, p_n$ ($1 \\le p_i \\le n$). If there are multiple possible answers, you can print any of them. \n\n\n-----Example-----\nInput\n4\n5\n1 3 4 5 5\n4\n1 1 3 4\n2\n2 2\n1\n1\n\nOutput\n1 3 4 5 2 \n-1\n2 1 \n1 \n\n\n\n-----Note-----\n\nIn the first test case of the example answer $[1,3,4,5,2]$ is the only possible answer:  $q_{1} = p_{1} = 1$;  $q_{2} = \\max(p_{1}, p_{2}) = 3$;  $q_{3} = \\max(p_{1}, p_{2}, p_{3}) = 4$;  $q_{4} = \\max(p_{1}, p_{2}, p_{3}, p_{4}) = 5$;  $q_{5} = \\max(p_{1}, p_{2}, p_{3}, p_{4}, p_{5}) = 5$. \n\nIt can be proved that there are no answers for the second test case of the example.", "solutions": "[\"t = int(input())\\nfor faw in range(t):\\n    n = int(input())\\n    a = [0] + list(map(int,input().split()))\\n    nun = []\\n    ans = []\\n    f = True\\n    for i in range(1, n + 1):\\n        if a[i] == a[i-1]:\\n            if len(nun) == 0:\\n                f = False\\n                break\\n            else:\\n                ans.append(nun.pop())\\n        else:\\n            ans.append(a[i])\\n            for i in range(a[i - 1] + 1, a[i]):\\n                nun.append(i)\\n    if f:\\n        print(*ans)\\n    else:\\n        print(-1)\\n\", \"t=int(input())\\nfor i in range(t):\\n    n=int(input())\\n    a=[int(x) for x in input().split()]\\n    b=[0] * n\\n    m=0\\n    c=set(range(1, n+1))\\n    for i in range(n):\\n        if a[i] > m:\\n            b[i] = a[i]\\n            m = a[i]\\n            c.discard(a[i])\\n    c=sorted(c)\\n    j=0\\n    for i in range(n):\\n        if b[i] == 0:\\n            b[i] = c[j]\\n            j+=1\\n            if b[i] > a[i]:\\n                print(-1)\\n                break\\n    else:\\n        print(*b)\\n\", \"t = int(input())\\nfor z in range(t):\\n    n = int(input())\\n    arr = list(map(int, input().split()))\\n    ret = [0 for i in range(n)]\\n    was = set()\\n    can = set([i for i in range(1, n + 1)])\\n    for i in range(n):\\n        x = arr[i]\\n        if not x in was:\\n            ret[i] = x\\n            was.add(x)\\n    left = sorted(list(can - was), reverse=True)\\n    for i in range(n):\\n        if not left:\\n            break\\n        x = left[-1]\\n        if not ret[i]:\\n            ret[i] = x\\n            left.pop()\\n    mx = ret[0]\\n    flag = True\\n    for i in range(n):\\n        mx = max(mx, ret[i])\\n        if mx != arr[i]:\\n            flag = False\\n            break\\n    if flag:\\n        print(*ret)\\n    else:\\n        print(-1)\\n\", \"n = int(input())\\nfor i in range(n):\\n    k = int(input())\\n    used = [0]*k\\n    a = list(map(int, input().split()))\\n    p = 0\\n    ans = [0]*k\\n    for i in range(k):\\n        if a[i] != p:\\n            ans[i] = a[i]\\n            used[a[i]-1] = 1\\n        p = a[i]\\n    t = 0\\n    flag = 0\\n    for i in range(k):\\n        if ans[i] == 0:\\n            while used[t] == 1 and t < a[i]:\\n                t +=1\\n            if t == a[i]:\\n                flag = 1\\n                break\\n            else:\\n                used[t] = 1\\n                ans[i] = t+1\\n    if flag == 1:\\n        print(-1)\\n    else:\\n        print(*ans)\\n\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    b = [0] * (n + 2)\\n    c = 1\\n    d = a[0]\\n    ans = [a[0]]\\n    b[a[0]] = 1\\n    for i in range(1, len(a)):\\n        if a[i] == a[i - 1]:\\n            while b[c] != 0:\\n                c += 1\\n            if c > a[i]:\\n                ans = -1\\n                break\\n            else:\\n                b[c] = 1\\n                ans.append(c)\\n        else:\\n            ans.append(a[i])\\n            b[a[i]] = 1\\n    if ans == -1:\\n        print(ans)\\n    else:\\n        print(*ans)\\n    \\n    \\n\", \"t = int(input())\\nfor i in range(t):\\n\\tn = int(input())\\n\\ta = [int(ii) for ii in input().split()]\\n\\tb = [0 for ii in range(n)]\\n\\twas = [0 for ii in range(n + 1)]\\n\\tminimum = 1\\n\\tfor j in range(n):\\n\\t\\tif j == 0 or a[j] != a[j - 1]:\\n\\t\\t\\twas[a[j]] = 1\\n\\t\\t\\tb[j] = a[j]\\n\\t\\telse:\\n\\t\\t\\twhile was[minimum] == 1:\\n\\t\\t\\t\\tminimum += 1\\n\\t\\t\\tif minimum > a[j]:\\n\\t\\t\\t\\tminimum = -1\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tb[j] = minimum\\n\\t\\t\\twas[minimum] = 1\\n\\tif minimum == -1:\\n\\t\\tprint (-1)\\n\\telse:\\n\\t\\tfor j in b:\\n\\t\\t\\tprint(j, end = ' ')\\n\\t\\tprint ('')\", \"a =  int(input())\\nAns = []\\nfor i in range(a):\\n    B = []\\n    x = int(input())\\n    A = list(map(int, input().split()))\\n    C = []\\n    for j in range(1, len(A) + 1):\\n        C.append([j, 0])\\n    k = 1\\n    n = 0\\n    for j in range(len(A)):\\n        if A[j] >k:\\n            B.append(A[j])\\n            k = A[j]\\n            C[A[j] - 1][1] = 1\\n        else:\\n            while C[n][1] == 1:\\n                n += 1\\n            C[n][1] = 1\\n            B.append(n + 1)\\n    b0 = B[0]\\n    Tr = True\\n    for j in range(len(B)):\\n        b0 = max(b0, B[j])\\n        if A[j] != b0:\\n            Tr = False\\n    if Tr:\\n        Ans.append(B)\\n    else:\\n        Ans.append([-1])\\n    #Ans.append(B[-1])\\nfor b in Ans:\\n    print(*b)\\n\", \"t = int(input())\\nfor request in range(t):\\n    n = int(input())\\n    result, initial = list(map(int, input().split())), []\\n    box, flag = [], True\\n    initial.append(result[0])\\n    for d in range(1, result[0]):\\n                box.append(d)\\n    for i in range(1, n):\\n        if result[i - 1] < result[i]:\\n            initial.append(result[i])\\n            for d in range(result[i - 1] + 1, result[i]):\\n                box.append(d)\\n        else:\\n            try:\\n                initial.append(box.pop())\\n            except:\\n                flag = False\\n                break\\n    if flag:\\n        print(*initial)\\n    else:\\n        print(-1)\", \"t = int(input())\\nfor tt in range(t):\\n    n = int(input())\\n    ent = list(map(int,input().split()))\\n    used = [0]*(n+1)\\n    mnex = 1\\n    mx = 0\\n    ans = []\\n    ansex = True\\n    for i in range(n):\\n        if ent[i] > mx:\\n            mx = ent[i]\\n            if used[mx] == 0:\\n                ans.append(mx)\\n                used[mx] = 1\\n            else:\\n                ansex = False\\n                break\\n        else:\\n            while used[mnex] == 1:\\n                mnex += 1\\n            if mnex <= mx:\\n                used[mnex]=1\\n                ans.append(mnex)\\n                mnex+=1\\n            else:\\n                ansex = False\\n                break\\n    if ansex:\\n        print(*ans)\\n    else:\\n        print(-1)\\n                \\n\\n\\n\\n\\n\\n\", \"t=int(input())\\nfor i in range(t):\\n    n=int(input())\\n    q=list(map(int,input().split()))\\n    pr=[0]*n\\n    ans=[0]*n\\n    ans[0]=q[0]\\n    sh=0\\n    s=set([q[0]])\\n    for i in range(1,n):\\n        if q[i]==q[i-1]:\\n            pr[i]=pr[i-1]\\n            sh+=1\\n        else:\\n            pr[i]=i\\n            ans[i]=q[i]\\n            s.add(q[i])\\n    steak=[]\\n    for i in range(n,0,-1):\\n        if i not in s:\\n            steak.append(i)\\n    tr=True\\n    for i in range(n):\\n        if ans[i]==0:\\n            x=steak.pop()\\n            if x<q[pr[i]]:\\n                ans[i]=x\\n            else:\\n                tr=False\\n                break\\n    if tr:\\n        print(*ans)\\n    else:\\n        print(-1)\\n\", \"a = int(input())\\nfor i in range(a):\\n    b = int(input())\\n    l = list(map(int, input().split()))\\n    k = []\\n    t = [i for i in range(b + 1)]\\n    k.append(l[0])\\n    last = k[0]\\n    j = 0\\n    t[last] = 0\\n    for i in l[1:]:\\n        if i != last:\\n            last = i\\n            k.append(last)\\n            t[last] = 0\\n        else:\\n            while t[j] == 0:\\n                j += 1\\n            k.append(t[j])\\n            j += 1\\n    ch = [k[0]]\\n    for i in k[1:]:\\n        ch.append(max(ch[-1], i))\\n    if l != ch:\\n        print(-1)\\n    else:\\n        print(*k)\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    used = []\\n    for i in range(n):\\n        used.append(False)\\n    p = [str(a[0])]\\n    used[a[0] - 1] = True\\n    ans = 1\\n    now = 0\\n    for i in range(1, n):\\n        while now < n and used[now]:\\n            now += 1\\n        if a[i] > a[i - 1]:\\n            p.append(str(a[i]))\\n            if used[a[i] - 1]:\\n                ans = 0\\n                break\\n            used[a[i] - 1] = True\\n        else:\\n            if now + 1 > a[i] or used[now]:\\n                ans = 0\\n                break\\n            used[now] = True\\n            p.append(str(now + 1))\\n    if ans:\\n        print(\\\" \\\".join(p))\\n    else:\\n        print(-1)\", \"from collections import deque\\nfor i in range(int(input())):\\n    n = int(input())\\n    h = deque([i+1 for i in range(n)])\\n    used = [False]*n\\n    ans = [0]*n\\n    c = list(map(int,input().split()))\\n    ans[0] = c[0]\\n    used[c[0]-1] = True\\n    f = True\\n    for i in range(n):\\n        if i+1>c[i]:\\n            f = False\\n    if not f:\\n        print(-1)\\n        continue\\n    for i in range(n-1):\\n        if c[i+1]!=c[i]:\\n            ans[i+1] = c[i+1]\\n        else:\\n            x = h.popleft()\\n            while used[x-1]:\\n                x = h.popleft()\\n            ans[i+1] = x\\n        used[ans[i+1] - 1] = True\\n    print(*ans)\", \"t=int(input())\\nfor magic in range(t):\\n    n=int(input())\\n    res=[0 for j in range(n+1)]\\n    have=[1 for sth in range(n+1)]\\n    br_p=0\\n    given=[0]+list(map(int,input().split()))\\n    for i in range(1,n+1):\\n        if given[i-1]<given[i]:\\n            res[i]=given[i]\\n            have[given[i]]=0\\n        elif given[i-1]>given[i]:\\n            br_p=1\\n            break\\n    if br_p:\\n        print(-1)\\n    else:\\n        ind_last=1\\n        for i in range(1,n+1):\\n            if res[i]==0:\\n                while have[ind_last]==0:\\n                    ind_last+=1\\n                res[i]=ind_last\\n                ind_last+=1\\n        for i in range(1,n+1):\\n            if given[i]<res[i]:\\n                br_p=1\\n                break\\n        if br_p:\\n            print(-1)\\n        else:\\n            print(*res[1:])\\n\\n\\n\\n\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    b = [False] * n\\n    b[a[0] - 1] = True\\n    k = 0\\n    res = [a[0]]\\n    flag = True\\n    for j in range(1, n):\\n        if a[j] == a[j - 1]:\\n            while k < n and b[k]:\\n                k += 1\\n            if k + 1 > a[j]:\\n                flag = False\\n                break\\n            res.append(k + 1)\\n            b[k] = True\\n        else:\\n            b[a[j] - 1] = True\\n            res.append(a[j])\\n    if flag:\\n        print(' '.join(map(str, res)))\\n    else:\\n        print(-1)\", \"t=int(input())\\nfor g in range(t):\\n  n=int(input())\\n  a=list(map(int,input().split()))\\n  b=list(False for i in range(n))\\n  flag=False\\n  count=0\\n  res=list(range(n))\\n  for i in range(n):\\n    if i==0:\\n      res[i]=a[i]\\n      b[a[i]-1]=True\\n    elif a[i]!=a[i-1]:\\n      res[i]=a[i]\\n      b[a[i]-1]=True\\n    else:\\n      for j in range(count,n):\\n        if j+1>a[i]:\\n          flag=True\\n          count=j\\n          break\\n        else:\\n          if not b[j]:\\n            res[i]=j+1\\n            b[j]=True\\n            count=j\\n            break\\n  if flag:\\n    print(-1)\\n  else:\\n    for i in range(n):\\n      print(res[i],end=' ')\\n    print()\\n\", \"for __ in range(int(input())):\\n    n = int(input())\\n    ar1 = list(map(int, input().split()))\\n    ar = ar1.copy()\\n    lol = set()\\n    for j in range(1, n + 1):\\n        lol.add(j)\\n    lol.discard(ar[0])\\n    for i in range(1, n):\\n        if ar1[i] > ar1[i - 1]:\\n            lol.discard(ar1[i])\\n        else:\\n            ar[i] = 0\\n    kek = list(lol)\\n    kek.sort()\\n    num = 0\\n    flag = 0\\n    for j in range(n):\\n        if ar[j] == 0:\\n            ar[j] = kek[num]\\n            num += 1\\n        if ar[j] > ar1[j]:\\n            flag = 1\\n    if flag == 1:\\n        print(-1)\\n    else:\\n        print(*ar)\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    ans = [0] * n\\n    used = [False] * (n + 1)\\n    ans[0] = a[0]\\n    used[a[0]] = True\\n    lst = 1\\n    ok = True\\n    for i in range(1, n):\\n        if a[i] > a[i - 1]:\\n            ans[i] = a[i]\\n            used[a[i]] = True\\n        elif a[i] < a[i - 1]:\\n            print(-1)\\n            ok = False\\n            break\\n        else:\\n            while used[lst]:\\n                lst += 1\\n            #print(lst)\\n            if a[i] < lst:\\n                print(-1)\\n                ok = False\\n                break\\n            else:\\n                ans[i] = lst\\n                lst += 1\\n                used[ans[i]] = True\\n    if ok:\\n        for i in range(n):\\n            print(ans[i], end=' ')\\n        print()\", \"m = int(input())\\nfor j in range(m):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    b = []\\n    used = [0] * (n + 1)\\n    t = 1\\n    b.append(a[0])\\n    f = True\\n    used[a[0]] = 1\\n    for k in range(1, n):\\n        if a[k] == a[k - 1]:\\n            while used[t] == 1:\\n                t += 1                    \\n            if t < a[k - 1]:\\n                b.append(t)\\n                used[t] = 1\\n                t += 1\\n            else:\\n                f = False\\n                break\\n        elif a[k] > a[k - 1]:\\n            b.append(a[k])\\n            used[a[k]] = 1\\n        else:\\n            f = False\\n            break\\n    if f:\\n        print(*b)\\n    else:\\n        print(-1)\\n            \\n\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    q = list(map(int, input().split()))\\n    used = set()\\n    ans = []\\n    used.add(q[0])\\n    ans.append(q[0])\\n    cnt = 1\\n    flag = False\\n    for i in range(1, n):\\n        if q[i] == q[i - 1]:\\n            while cnt in used:\\n                cnt += 1\\n            used.add(cnt)\\n            if q[i] > cnt:\\n                ans.append(cnt)\\n            else:\\n                flag = True\\n                break\\n        else:\\n            used.add(q[i])\\n            ans.append(q[i])\\n    if flag:\\n        print(-1)\\n    else:\\n        print(*ans)\", \"for i in range(int(input())):\\n    n=int(input())\\n    a=list(map(int,input().split()))\\n    q=-1\\n    t=0\\n    r=[]\\n    for i in range(n):\\n        if a[i]<q or a[i]<i+1:\\n            t=1\\n            break\\n        else:\\n            q=a[i]\\n    if t==1:\\n        print(-1)\\n    else:\\n        q=-1\\n        w=[True]*n\\n        z=0\\n        for i in range(n):\\n            if a[i]>q:\\n                r.append(a[i])\\n                w[a[i]-1]=False\\n                q=a[i]\\n            else:\\n                while w[z]==False:\\n                    z+=1\\n                r.append(z+1)\\n                z+=1\\n        print(*r)\\n\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    used = [0for i in range(n + 2)]\\n    ans = []\\n    minimum = 1\\n    ans.append(a[0])\\n    used[a[0]] = 1\\n    if a[0] == 1:\\n        minimum = 2\\n    for i in range(1, len(a)):\\n        if a[i] != a[i - 1]:\\n            ans.append(a[i])\\n            used[a[i]] = 1\\n            if a[i] == minimum:\\n                minimum += 1\\n        else:\\n            ans.append(minimum)\\n            used[minimum] = 1\\n            while used[minimum] == 1:\\n                minimum += 1\\n    maximum = 0\\n    flag = True\\n    for i in range(len(ans)):\\n        maximum = max(maximum, ans[i])\\n        if a[i] != maximum:\\n            flag = False\\n    if flag and a[-1] == n:\\n        print(\\\" \\\".join(map(str, ans)))\\n    else:\\n        print(-1)\", \"t = int(input())\\n\\nfor i in range(t):\\n    n = int(input())\\n    q = list(map(int, input().split()))\\n    used = {q[0]: True}\\n    seq = [q[0]]\\n\\n    ks = 1\\n\\n    for j in range(1, n):\\n        if q[j] == q[j - 1]:\\n            for k in range(ks, q[j]):\\n                if used.get(k) is None:\\n                    seq.append(k)\\n                    used[k] = True\\n                    ks = k + 1\\n                    break\\n            else:\\n                print(-1)\\n                break\\n        else:\\n            used[q[j]] = True\\n            seq.append(q[j])\\n    else:\\n        print(*seq)\", \"w = int(input())\\nfor q in range(w):\\n    fr = 1\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    a.append(a[0] - 1)\\n    e = [1] * (n+1)\\n    ei = 1\\n    r = [0] * n\\n    for i in range(n):\\n        if a[i] == a[i-1]:\\n            while e[ei] == 0 and ei < n:\\n                ei += 1\\n            if ei > a[i]:\\n                print(-1)\\n                fr = 0\\n                break\\n            r[i] = ei\\n            e[ei] = 0\\n        else:\\n            if e[a[i]] == 1:\\n                e[a[i]] = 0\\n                r[i] = a[i]\\n            else:\\n                print(-1)\\n                fr = 0\\n                break\\n    if fr:\\n        print(*r)\\n\\n\\n\\n\\n\\n\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n5\\n1 3 4 5 5\\n4\\n1 1 3 4\\n2\\n2 2\\n1\\n1\\n\"\n  ],\n  \"outputs\": [\n    \"1 3 4 5 2 \\n-1\\n2 1 \\n1 \\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1227/B", "starter_code": ""}
{"id": 92, "question": "You are given two strings of equal length $s$ and $t$ consisting of lowercase Latin letters. You may perform any number (possibly, zero) operations on these strings.\n\nDuring each operation you choose two adjacent characters in any string and assign the value of the first character to the value of the second or vice versa.\n\nFor example, if $s$ is \"acbc\" you can get the following strings in one operation:   \"aabc\" (if you perform $s_2 = s_1$);  \"ccbc\" (if you perform $s_1 = s_2$);  \"accc\" (if you perform $s_3 = s_2$ or $s_3 = s_4$);  \"abbc\" (if you perform $s_2 = s_3$);  \"acbb\" (if you perform $s_4 = s_3$); \n\nNote that you can also apply this operation to the string $t$.\n\nPlease determine whether it is possible to transform $s$ into $t$, applying the operation above any number of times.\n\nNote that you have to answer $q$ independent queries.\n\n\n-----Input-----\n\nThe first line contains one integer $q$ ($1 \\le q \\le 100$)\u00a0\u2014 the number of queries. Each query is represented by two consecutive lines.\n\nThe first line of each query contains the string $s$ ($1 \\le |s| \\le 100$) consisting of lowercase Latin letters.\n\nThe second line of each query contains the string $t$ ($1 \\le |t| \\leq 100$, $|t| = |s|$) consisting of lowercase Latin letters.\n\n\n-----Output-----\n\nFor each query, print \"YES\" if it is possible to make $s$ equal to $t$, and \"NO\" otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will all be recognized as positive answer).\n\n\n-----Example-----\nInput\n3\nxabb\naabx\ntechnocup\ntechnocup\na\nz\n\nOutput\nYES\nYES\nNO\n\n\n\n-----Note-----\n\nIn the first query, you can perform two operations $s_1 = s_2$ (after it $s$ turns into \"aabb\") and $t_4 = t_3$ (after it $t$ turns into \"aabb\"). \n\nIn the second query, the strings are equal initially, so the answer is \"YES\".\n\nIn the third query, you can not make strings $s$ and $t$ equal. Therefore, the answer is \"NO\".", "solutions": "[\"for _ in range(int(input())):\\n    print(\\\"YES\\\" if set(input()).intersection(input()) else \\\"NO\\\")\\n\", \"for _ in range(int(input())):\\n    s = input()\\n    t = input()\\n    ans = 'NO'\\n    for c in s:\\n        if c in t:\\n            ans = 'YES'\\n            break\\n    print(ans)\", \"q = int(input())\\nfor z in range(q):\\n    s = input()\\n    t = input()\\n    for c in s:\\n        if c in t:\\n            print('YES')\\n            break\\n    else:\\n        print('NO')\", \"q = int(input())\\nfor qq in range(q):\\n    s1 = input()\\n    s2 = input()\\n    for i in s1:\\n        if i in s2:\\n            print('YES')\\n            break\\n    else:\\n        print('NO')\\n    \\n\\n\\n\", \"q = int(input())\\nfor i in range(q):\\n    a = input()\\n    b = input()\\n    done = False\\n    for i in a:\\n        if i in b:\\n            done = True\\n            break\\n    print('YES' if done else 'NO')\", \"n = int(input())\\nfor i in range(n):\\n    a = input()\\n    b = input()\\n    a, b = min(a, b), max(a, b)\\n    h = True\\n    for j in range(len(a)):\\n        if a[j] in b:\\n            print('YES')\\n            h = False\\n            break\\n    if h:\\n        print('NO')\\n\\n\", \"for _ in range(int(input())):\\n    line1 = input()\\n    line2 = input()\\n    if set(line1) & set(line2):\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"for i in range(int(input())):\\n    s1 = set(input())\\n    s2 = set(input())\\n    if len(s1 & s2) > 0:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n    \\n\", \"q = int(input())\\nfor i in range(q):\\n    s = input()\\n    t = input()\\n    s = set(s)\\n    t = set(t)\\n    if len(s.intersection(t)) > 0:\\n        print('YES')\\n    else:\\n        print('NO')\", \"a = int(input())\\nfor i in range(a):\\n    b = input()\\n    c = input()\\n    y = 0\\n    for i in b:\\n        if i in c:\\n            y = 1\\n        else:\\n            pass\\n    if  y == 1:\\n        print('YES')\\n    else:\\n        print(\\\"NO\\\")\", \"for _ in range(int(input())):\\n    s,t=input(), input()\\n    k=\\\"NO\\\"\\n    for i in s:\\n        if i in t:\\n            k=\\\"YES\\\"\\n            break\\n    print(k)\", \"n=int(input())\\nfor i in range(n):\\n    s=input()\\n    t=input()\\n    s1 = set()\\n    s2=set()\\n    for q in s:\\n        s1.add(q)\\n    for q in t:\\n        s2.add(q)\\n    if len(s1.intersection(s2)):\\n        print('YES')\\n    else:\\n        print('NO')\", \"q = int(input())\\nfor i in range(q):\\n    s1 = input()\\n    s2 = input()\\n    if len(set(s1) & set(s2)) > 0:\\n        print('YES')\\n    else:\\n        print('NO')\\n\", \"q = int(input())\\n\\nfor i in range(q):\\n    s = input()\\n    t = input()\\n    if set(s) & set(t):\\n        print('YES')\\n    else:\\n        print('NO')\\n\", \"q = int(input())\\nfor i in range(q):\\n    k = 0\\n    s = input()\\n    t = input()\\n    for p in range(len(s)):\\n        for j in range(len(s)):\\n            if s[p] == t[j]:\\n                k += 1\\n    if k > 0:\\n        print('YES')\\n    else:\\n        print('NO')\", \"import sys\\nimport math\\nfrom math import ceil\\nimport bisect\\n \\ndef input():\\n    return sys.stdin.readline().strip()\\n \\ndef iinput():\\n    return int(input())\\n \\ndef finput():\\n    return float(input())\\n \\ndef tinput():\\n    return input().split()\\n \\ndef rinput():\\n    return map(float, tinput())\\n \\ndef rlinput():\\n    return list(rinput())\\n\\ndef sli():\\n    return set(list(input()))\\n \\ndef modst(a, s):\\n    res = 1\\n    while s:\\n        if s % 2:\\n            res *= a\\n        a *= a\\n        s //= 2\\n    return res   \\n\\ndef pro(x):\\n    if x < 37:\\n        return (x - 1) // 4\\n    else:\\n        return 8 - (x - 37) // 2\\n \\n \\ndef main():  \\n    q = sli()\\n    w = sli()\\n    flag = False\\n    for i in q:\\n        if i in w:\\n            flag = True\\n            break\\n    if flag:\\n        print('YES')\\n    else:\\n        print('NO')\\n        \\nfor i in range(iinput()):\\n    main() \", \"q = int(input())\\nfor i in range(q):\\n    c = True\\n    s = input()\\n    t = input()\\n    for j in s:\\n        if j in t:\\n            print(\\\"YES\\\")\\n            c = False\\n            break\\n    if c:\\n        print(\\\"NO\\\")\", \"q=int(input())\\nfor i in range(q):\\n    test=set()\\n    s=list(input())\\n    t=list(input())\\n    for item in s:\\n        test.add(item)\\n    for item in t:\\n        if item in test:\\n            print('YES')\\n            break\\n    else:\\n            print('NO')\\n\", \"n = int(input())\\nfor i in range(n):\\n    m1 = set(list(input()))\\n    m2 = set(list(input()))\\n    f = 'NO'\\n    for el in m1:\\n        if el in m2:\\n            f = 'YES'\\n    print(f)\", \"q = int(input())\\nfor i in range(q):\\n    s1 = input()\\n    s2 = input()\\n    f = 1\\n    for i in range(len(s1)):\\n        for j in range(len(s2)):\\n            if f and s1[i] == s2[j]:\\n                print(\\\"YES\\\")\\n                f = 0\\n    if f:\\n        print(\\\"NO\\\")\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\nxabb\\naabx\\ntechnocup\\ntechnocup\\na\\nz\\n\"\n  ],\n  \"outputs\": [\n    \"YES\\nYES\\nNO\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1223/B", "starter_code": ""}
{"id": 93, "question": "Santa has to send presents to the kids. He has a large stack of $n$ presents, numbered from $1$ to $n$; the topmost present has number $a_1$, the next present is $a_2$, and so on; the bottom present has number $a_n$. All numbers are distinct.\n\nSanta has a list of $m$ distinct presents he has to send: $b_1$, $b_2$, ..., $b_m$. He will send them in the order they appear in the list.\n\nTo send a present, Santa has to find it in the stack by removing all presents above it, taking this present and returning all removed presents on top of the stack. So, if there are $k$ presents above the present Santa wants to send, it takes him $2k + 1$ seconds to do it. Fortunately, Santa can speed the whole process up \u2014 when he returns the presents to the stack, he may reorder them as he wishes (only those which were above the present he wanted to take; the presents below cannot be affected in any way).\n\nWhat is the minimum time required to send all of the presents, provided that Santa knows the whole list of presents he has to send and reorders the presents optimally? Santa cannot change the order of presents or interact with the stack of presents in any other way.\n\nYour program has to answer $t$ different test cases.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 100$) \u2014 the number of test cases.\n\nThen the test cases follow, each represented by three lines.\n\nThe first line contains two integers $n$ and $m$ ($1 \\le m \\le n \\le 10^5$) \u2014 the number of presents in the stack and the number of presents Santa wants to send, respectively.\n\nThe second line contains $n$ integers $a_1$, $a_2$, ..., $a_n$ ($1 \\le a_i \\le n$, all $a_i$ are unique) \u2014 the order of presents in the stack.\n\nThe third line contains $m$ integers $b_1$, $b_2$, ..., $b_m$ ($1 \\le b_i \\le n$, all $b_i$ are unique) \u2014 the ordered list of presents Santa has to send.\n\nThe sum of $n$ over all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case print one integer \u2014 the minimum number of seconds which Santa has to spend sending presents, if he reorders the presents optimally each time he returns them into the stack.\n\n\n-----Example-----\nInput\n2\n3 3\n3 1 2\n3 2 1\n7 2\n2 1 7 3 4 5 6\n3 1\n\nOutput\n5\n8", "solutions": "[\"for tc in range(int(input())):\\n    n,m = list(map(int, input().split()))\\n    al = list(map(int, input().split()))\\n    bl = list(map(int, input().split()))\\n    aidx = {}\\n    for i,e in enumerate(al):\\n        aidx[e]=i\\n    midx = -1\\n    res = 0\\n    for i,e in enumerate(bl):\\n        idx = aidx[e]\\n        if idx <= midx:\\n            res += 1\\n        else:\\n            res += 2*(idx-i)+1\\n        midx = max(midx, idx)\\n    print(res)\\n\", \"for q11 in range(int(input())):\\n    n, m = list(map(int, input().split()))\\n    a = [int(q)-1 for q in input().split()]\\n    s = [int(q)-1 for q in input().split()]\\n    d = [0]*n\\n    for q in range(n):\\n        d[a[q]] = q\\n    max1, ans = -1, 0\\n    for q in range(m):\\n        if d[s[q]] > max1:\\n            ans += 2*(d[s[q]]-q)+1\\n            max1 = d[s[q]]\\n        else:\\n            ans += 1\\n    print(ans)\\n\", \"t = int(input())\\n\\nfor _ in range(t):\\n    n, m = list(map(int, input().split(' ')))\\n    a = list(map(int, input().split(' ')))\\n    b = list(map(int, input().split(' ')))\\n\\n    order = [0] * (n + 1)\\n    for i in range(n):\\n        order[a[i]] = i\\n\\n    pref_max = 0\\n    ans = 0\\n    for i in range(m):\\n        if order[b[i]] < pref_max:\\n            ans += 1\\n        else:\\n            pref_max = order[b[i]]\\n            ans += 2 * (order[b[i]] - i) + 1\\n\\n    print(ans)\", \"T = int(input())\\nfor t in range(T):\\n    n, m = map(int, input().split())\\n    a = list(map(int, input().split()))\\n    b = list(map(int, input().split()))\\n    \\n    for i in range(n):\\n        a[i] -= 1\\n    for j in range(m):\\n        b[j] -= 1\\n    \\n    nummap = [0 for i in range(n)]\\n    for i in range(n):\\n        nummap[a[i]] = i\\n    b = [nummap[b[i]] for i in range(m)]\\n    \\n    largest = -1\\n    res = 0\\n    for i in range(m):\\n        if b[i] >= largest:\\n            res += 2*(b[i]-i) + 1\\n            largest = b[i]\\n        else:\\n            res += 1\\n    print(res)\", \"from math import *\\nimport os, sys\\nfrom bisect import *\\nfrom io import BytesIO\\n\\n#input = BytesIO(os.read(0, os.fstat(0).st_size)).readline\\nsys.setrecursionlimit(10 ** 9)\\n#sys.stdin = open(\\\"moobuzz.in\\\", 'r')\\n#sys.stdout = open(\\\"moobuzz.out\\\", 'w')\\n\\nfor i in range(int(input())):\\n\\tn, m = list(map(int, input().split()))\\n\\ta = list(map(int, input().split()))\\n\\tb = list(map(int, input().split()))\\n\\td = {}\\n\\tfor i in range(n):\\n\\t\\td[a[i]] = i\\n\\t\\n\\tans = 0\\n\\tmx = 0\\n\\tfor i in range(m):\\n\\t\\tif mx < d[b[i]]:\\n\\t\\t\\tans += 2 * (d[b[i]] - i) + 1\\n\\t\\t\\tmx = d[b[i]]\\n\\t\\telse:\\n\\t\\t\\tans += 1\\n\\tprint(ans)\\n\", \"T = int(input())\\nfor _ in range(T):\\n    N, M = map(int, input().split())\\n    A = [int(a)-1 for a in input().split()]\\n    B = [int(a)-1 for a in input().split()]\\n    \\n    X = [0] * N\\n    for i, a in enumerate(A):\\n        X[a] = i\\n    ans = 0\\n    ma = -1\\n    for i, b in enumerate(B):\\n        ans += (X[b] - i) * 2 + 1 if X[b] > ma else 1\\n        ma = max(ma, X[b])\\n    print(ans)\", \"import sys\\ninput = sys.stdin.readline\\n\\nt = int(input())\\nfor _ in range(t):\\n    n, m = map(int, input().split())\\n    a = list(map(int, input().split()))\\n    b = list(map(int, input().split()))\\n    \\n    memo = {}\\n    for i in range(n):\\n        memo[a[i]] = i\\n    \\n    max_num = -1\\n    cnt = 0\\n    ans = 0\\n    for i in range(m):\\n        if max_num < memo[b[i]]:\\n            ans += 2 * (memo[b[i]] - cnt) + 1\\n            max_num = memo[b[i]]\\n            cnt += 1\\n        else:\\n            ans += 1\\n            cnt += 1\\n    print(ans)\", \"import sys\\ninput=sys.stdin.readline\\nt=int(input())\\nfor _ in range(t):\\n    n,m=list(map(int,input().split()))\\n    aa=list(map(int,input().split()))\\n    bb=list(map(int,input().split()))\\n    ans=0\\n    ind=0\\n    vis=[0 for i in range(n)]\\n    co=0\\n    for i in range(m):\\n        if vis[bb[i]-1]==1:\\n            ans+=1\\n            co-=1\\n            continue\\n        while ind<n:\\n            co+=1\\n            if aa[ind]==bb[i]:\\n                vis[aa[ind]-1]=1\\n                ind+=1\\n                break\\n            else:\\n                \\n                vis[aa[ind]-1]=1\\n                ind+=1\\n        co-=1\\n        ans+=co*2+1\\n       # print(ans,ind)\\n        \\n    print(ans)\\n   # print()\\n\", \"q = int(input())\\nt = 1\\nvis = [0] * 300000\\nfor i in range(q):\\n    n, m = [int(x) for x in input().split()]\\n    a = [ int(x) for x in input().split()]\\n    b =  [int(x) for x in input().split()]\\n    arr = 0\\n    i = 0\\n    k = 0\\n    for item in b:\\n        if vis[item] == t:\\n            arr += 1\\n            k -= 1\\n            continue\\n        while i < n:\\n            vis[a[i]] = t\\n            if a[i] == item:\\n                arr += (2 * k) + 1\\n                i += 1\\n                break\\n            i += 1\\n            k += 1\\n    print(arr)\\n    t += 1\\n        \\n\", \"for _ in range(int(input())):\\n    n, m = list(map(int, input().split()))\\n    topmost = set()\\n    a = iter(map(int, input().split()))\\n    b = list(map(int, input().split()))\\n    ans = 0\\n    for bi in b:\\n        if bi in topmost:\\n            k = 0\\n            topmost.remove(bi)\\n        else:\\n            k = len(topmost)\\n            for ai in a:\\n                if ai == bi:\\n                    break\\n                topmost.add(ai)\\n                k += 1\\n            else:\\n                raise ValueError(f'No {bi} in a')\\n        ans += 2 * k + 1\\n    print(ans)\\n\", \"import sys\\nreadline = sys.stdin.readline\\n\\nT = int(readline())\\n\\nAns = [None]*T\\n\\nfor qu in range(T):\\n    N, M = map(int, readline().split())\\n    A = list(map(int, readline().split()))\\n    B = list(map(int, readline().split()))\\n    A.reverse()\\n    \\n    res = 0\\n    seen = set()\\n    for b in B:\\n        res += 1\\n        if b in seen: \\n            seen.remove(b)\\n            continue\\n        res += 2*len(seen)\\n        while A[-1] != b:\\n            seen.add(A.pop())\\n            res += 2\\n        A.pop()\\n    Ans[qu] = res\\nprint('\\\\n'.join(map(str, Ans)))\", \"import sys\\n\\n# inf = open('input.txt', 'r')\\n# reader = (map(int, line.split()) for line in inf)\\nreader = (list(map(int, line.split())) for line in sys.stdin)\\ninput = reader.__next__\\n\\nt, = input()\\nfor _ in range(t):\\n    n, m = input()\\n    a = list(input())\\n    b = list(input())\\n    d = {el:i for i, el in enumerate(a)}\\n    maxPos = d[b[0]]\\n    ans = 2 * maxPos + 1\\n    Nremoved = 1\\n    for el in b[1:]:\\n        pos = d[el]\\n        if pos < maxPos:\\n            ans += 1\\n        else:\\n            ans += 2 * (pos - Nremoved) + 1\\n            maxPos = pos\\n        Nremoved += 1\\n    print(ans)\\n        \\n    \\n    \\n# inf.close()\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"2\\n3 3\\n3 1 2\\n3 2 1\\n7 2\\n2 1 7 3 4 5 6\\n3 1\\n\"\n  ],\n  \"outputs\": [\n    \"5\\n8\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1279/C", "starter_code": ""}
{"id": 94, "question": "RedDreamer has an array $a$ consisting of $n$ non-negative integers, and an unlucky integer $T$.\n\nLet's denote the misfortune of array $b$ having length $m$ as $f(b)$ \u2014 the number of pairs of integers $(i, j)$ such that $1 \\le i < j \\le m$ and $b_i + b_j = T$. RedDreamer has to paint each element of $a$ into one of two colors, white and black (for each element, the color is chosen independently), and then create two arrays $c$ and $d$ so that all white elements belong to $c$, and all black elements belong to $d$ (it is possible that one of these two arrays becomes empty). RedDreamer wants to paint the elements in such a way that $f(c) + f(d)$ is minimum possible.\n\nFor example:\n\n  if $n = 6$, $T = 7$ and $a = [1, 2, 3, 4, 5, 6]$, it is possible to paint the $1$-st, the $4$-th and the $5$-th elements white, and all other elements black. So $c = [1, 4, 5]$, $d = [2, 3, 6]$, and $f(c) + f(d) = 0 + 0 = 0$;  if $n = 3$, $T = 6$ and $a = [3, 3, 3]$, it is possible to paint the $1$-st element white, and all other elements black. So $c = [3]$, $d = [3, 3]$, and $f(c) + f(d) = 0 + 1 = 1$. \n\nHelp RedDreamer to paint the array optimally!\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases. Then $t$ test cases follow.\n\nThe first line of each test case contains two integers $n$ and $T$ ($1 \\le n \\le 10^5$, $0 \\le T \\le 10^9$) \u2014 the number of elements in the array and the unlucky integer, respectively. \n\nThe second line contains $n$ integers $a_1$, $a_2$, ..., $a_n$ ($0 \\le a_i \\le 10^9$) \u2014 the elements of the array. \n\nThe sum of $n$ over all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case print $n$ integers: $p_1$, $p_2$, ..., $p_n$ (each $p_i$ is either $0$ or $1$) denoting the colors. If $p_i$ is $0$, then $a_i$ is white and belongs to the array $c$, otherwise it is black and belongs to the array $d$.\n\nIf there are multiple answers that minimize the value of $f(c) + f(d)$, print any of them.\n\n\n-----Example-----\nInput\n2\n6 7\n1 2 3 4 5 6\n3 6\n3 3 3\n\nOutput\n1 0 0 1 1 0 \n1 0 0", "solutions": "[\"T = int(input())\\nfor test in range(T):\\n    n,t = list(map(int,input().split()))\\n    a = list(map(int,input().split()))\\n    res = []\\n    j=0\\n    for i in a:\\n        if(i*2<t):\\n            res+=[\\\"0\\\"]\\n        elif(i*2>t):\\n            res+=[\\\"1\\\"]\\n        else:\\n            res.append([\\\"0\\\",\\\"1\\\"][j])\\n            j = 1-j\\n    print(\\\" \\\".join(res))\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n, T = map(int, input().split())\\n    a = list(map(int, input().split()))\\n    white = set()\\n    if not T%2 and T//2 in a:\\n        halfcount = 0\\n        for i in range(len(a)):\\n            if a[i] == T//2:\\n                if halfcount % 2:\\n                    a[i] = 1\\n                else:\\n                    a[i] = 0\\n                halfcount += 1\\n            else:\\n                if T-a[i] in white:\\n                    a[i] = 1\\n                else:\\n                    white.add(a[i])\\n                    a[i] = 0\\n    else:\\n        for i in range(len(a)):\\n            if T-a[i] in white:\\n                a[i] = 1\\n            else:\\n                white.add(a[i])\\n                a[i] = 0\\n    print(*a)\", \"import sys\\nimport math\\ndef II():\\n\\treturn int(sys.stdin.readline())\\n \\ndef LI():\\n\\treturn list(map(int, sys.stdin.readline().split()))\\n \\ndef MI():\\n\\treturn list(map(int, sys.stdin.readline().split()))\\n \\ndef SI():\\n\\treturn sys.stdin.readline().strip()\\nt = II()\\nfor q in range(t):\\n    n,k = MI()\\n    a = LI()\\n    d = [0]*n\\n    c = a.count(k//2)\\n    boo = k%2 == 0\\n    count = 0\\n    for i in range(n):\\n        if a[i]<k//2:\\n            d[i] = 0\\n        elif a[i] == k//2:\\n            if not boo:\\n                d[i] = 0\\n            elif count<c//2:\\n                d[i] = 0\\n                count+=1\\n            else:\\n                d[i] = 1\\n        else:\\n            d[i] = 1\\n    print(*d)\\n\", \"from collections import defaultdict\\n\\nT = int(input())\\n\\nfor t in range(T):\\n    n, T = [int(_) for _ in input().split()]\\n    A = [int(_) for _ in input().split()]\\n\\n    pen_in_c = defaultdict(int)\\n    pen_in_d = defaultdict(int)\\n\\n    answer = []\\n    for el in A:\\n        if pen_in_d[el] < pen_in_c[el]:\\n            answer.append(1)\\n            pen_in_d[T - el] += 1\\n        else:\\n            answer.append(0)\\n            pen_in_c[T - el] += 1\\n\\n    print(' '.join(map(str, answer)))\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n,T = map(int,input().split())\\n    l1 = [int(x) for x in input().split()]\\n    current = 0\\n    for i in range(n):\\n        if T%2==0 and l1[i]==T//2:\\n            #print(\\\"HERE\\\")\\n            if current:\\n                l1[i]=0\\n                current = 0\\n            else:\\n                l1[i]=1\\n                current = 1\\n        else:\\n            l1[i]=int(l1[i]>(T//2))\\n    print(*l1)\", \"input=__import__('sys').stdin.readline\\nfor _ in range(int(input())):\\n\\tn,T=map(int,input().split())\\n\\ts=list(map(int,input().split()))\\n\\tans=[0]*n\\n\\tg={} # last ind with sum x\\n\\tfor i in range(n):\\n\\t\\tif T-s[i] in g:\\n\\t\\t\\tans[i]=1-ans[g[T-s[i]]]\\n\\t\\tg[s[i]]=i\\n\\tprint(*ans)\", \"for _ in range(int(input())):\\n    n, t = list(map(int, input().split()))\\n    *arr, = list(map(int, input().split()))\\n    flip = 0\\n    for i in range(n):\\n        if 2 * arr[i] > t:\\n            arr[i] = 1\\n        elif 2 * arr[i] < t:\\n            arr[i] = 0\\n        else:\\n            arr[i] = flip\\n            flip = 1 - flip\\n    print(*arr)\\n\\n\\n\\n\", \"from collections import defaultdict\\n\\n\\ndef solve():\\n    n, T = list(map(int, input().split()))\\n    a = list(map(int, input().split()))\\n    white = defaultdict(int)\\n    black = defaultdict(int)\\n    ans = [0]*n\\n    for i, x in enumerate(a):\\n        if white[T-x] > black[T-x]:\\n            black[x] += 1\\n            ans[i] = 1\\n        else:\\n            white[x] += 1\\n            ans[i] = 0\\n    print(*ans)\\n    return\\n\\n\\ndef main():\\n    T = int(input())\\n    for i in range(T):\\n        solve()\\n    return\\n\\n\\ndef __starting_point():\\n    main()\\n\\n\\n__starting_point()\", \"t = int(input())\\n\\nfor case in range(t):\\n    n, T = map(int, input().split())\\n    a = [int(x) for x in input().split()]\\n    halfTticker = False\\n    halfT = T / 2\\n    white = set()\\n\\n    for x in a:\\n        if x == halfT:\\n            print(int(halfTticker), end=' ')\\n            halfTticker = not halfTticker\\n        elif x in white:\\n            print(0, end=' ')\\n        elif T - x in white:\\n            print(1, end=' ')\\n        else:\\n            white.add(x)\\n            print(0, end=' ')\\n\\n    print()\\n\\n\", \"import sys\\nimport math\\ninput = sys.stdin.readline\\n\\nt = int(input())\\nfor _ in range(t):\\n    n,k = list(map(int, input().split()))\\n    arr = list(map(int, input().split()))\\n    \\n    alt = 0\\n    ans = []\\n    for i in range(len(arr)):\\n        if k%2==1:\\n            if arr[i] < k/2:\\n                ans.append(0)\\n            else:\\n                ans.append(1)\\n        else:\\n            if arr[i] == k//2:\\n                ans.append(alt%2)\\n                alt += 1\\n            elif arr[i] < k//2:\\n                ans.append(0)\\n            else:\\n                ans.append(1)\\n                \\n    print(*ans)\", \"import math\\nimport sys\\n \\nclass Read:\\n    @staticmethod\\n    def string():\\n        return input()\\n \\n    @staticmethod\\n    def int():\\n        return int(input())\\n \\n    @staticmethod\\n    def list(sep=' '):\\n        return input().split(sep)\\n \\n    @staticmethod\\n    def list_int(sep=' '):\\n        return list(map(int, input().split(sep)))\\n \\n\\ndef solve():\\n    n, T = Read.list_int()\\n    a = Read.list_int()\\n\\n    tmp = {}\\n    res = []\\n    for i in a:\\n        v = T - i\\n        r = '1'\\n        if v in tmp:\\n            if tmp[v] == '1':\\n                r = '0'\\n        tmp[i] = r\\n        res.append(r)\\n\\n    print(' '.join(res))\\n    \\n\\n# query_count = 1\\nquery_count = Read.int()\\nwhile query_count:\\n    query_count -= 1\\n    solve()\", \"for _ in range(int(input())):\\n    n, t = tuple(map(int, input().split()))\\n    arr = list(map(int, input().split()))\\n\\n    ans = [-1] * n\\n\\n    if t % 2 == 0:\\n        x = t // 2\\n        c = arr.count(x)\\n\\n        c2 = 0\\n        for i in range(n):\\n            if arr[i] != x:\\n                continue\\n            if c2 < c // 2:\\n                ans[i] = 0\\n            else:\\n                ans[i] = 1\\n            c2 += 1\\n\\n    for i in range(n):\\n        if ans[i] != -1:\\n            continue\\n        if arr[i] <= t // 2:\\n            ans[i] = 0\\n        else:\\n            ans[i] = 1\\n\\n    print(*ans)\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n, u = map(int, input().split())\\n    a = list(map(int, input().split()))\\n    k=u//2\\n    p = [-1 for i in range(n)]\\n    if u%2!=0:\\n        for i in range(n):\\n            if a[i]<=k:\\n                p[i]=0\\n            else:\\n                p[i]=1\\n    else:\\n        x=0\\n        for i in range(n):\\n            if a[i]<k:\\n                p[i]=0\\n            elif a[i]>k:\\n                p[i]=1\\n            elif a[i]==k:\\n                if x==0:\\n                    p[i]=0\\n                    x=1\\n                else:\\n                    p[i]=1\\n                    x=0\\n    print(*p)\", \"import os\\nfrom sys import stdin, stdout\\n\\nclass Input:\\n    def __init__(self):\\n        self.lines = stdin.readlines()\\n        self.idx = 0\\n    \\n    def line(self):\\n        try:\\n            return self.lines[self.idx].strip()\\n        finally:\\n            self.idx += 1\\n    \\n    def array(self, sep = ' ', cast = int):\\n        return list(map(cast, self.line().split(sep = sep)))\\n    \\n    def known_tests(self):\\n        num_of_cases, = self.array()\\n    \\n        for case in range(num_of_cases):\\n            yield self\\n    \\n    def unknown_tests(self):\\n        while self.idx < len(self.lines):\\n            yield self\\n\\ndef problem_solver():\\n    '''\\n    \\n    '''\\n    def solver(inpt):\\n        n, T = inpt.array()\\n        a = inpt.array()\\n        b = []\\n        c = 0\\n\\n        for x in a:\\n            if x * 2 > T:\\n                b.append(1)\\n            elif x * 2 == T:\\n                b.append(c & 1)\\n                c += 1\\n            else:\\n                b.append(0)\\n        \\n        print(*b)\\n\\n    '''Returns solver'''\\n    return solver\\n\\ntry:\\n    solver = problem_solver()\\n    for tc in Input().known_tests():\\n        solver(tc)\\nexcept Exception as e:\\n    import traceback\\n    traceback.print_exc(file=stdout)\", \"import sys\\ninput = sys.stdin.readline\\n\\ndef main():\\n    n, t = map(int, input().split())\\n    alst = list(map(int, input().split()))\\n    lst = [[i, a] for i, a in enumerate(alst)]\\n    lst.sort()\\n    if t % 2 == 0:\\n        mid = t // 2\\n    else:\\n        mid = t / 2\\n    ans = [-1 for _ in range(n)]\\n    flg = False\\n    for i, a in lst:\\n        if a < mid:\\n            ans[i] = 0\\n        elif a > mid:\\n            ans[i] = 1\\n        elif flg:\\n            flg = False\\n            ans[i] = 0\\n        else:\\n            flg = True\\n            ans[i] = 1\\n    print(*ans)\\n    \\nfor _ in range(int(input())):\\n    main()\", \"import os\\nimport sys\\nimport io\\n\\n# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline # \\u795e\\u5947\\u5feb\\u8bfb\\uff0c\\u65e0\\u6cd5\\u8fd0\\u884c\\u8c03\\u8bd5\\nGANS = []\\n\\n# def print(*args): # \\u795e\\u5947\\u5feb\\u5199\\uff0c\\u6700\\u540e\\u5f97\\u5199\\u4e0aos.write\\n#     nonlocal GANS\\n#     for i in args:\\n#         GANS.append(f'{i}'.encode())\\n\\n\\nt = int(input())\\n\\nfor _ in range(t):\\n    n,k = map(int,input().split())\\n    li = [int(i) for i in input().split()]\\n    d1 = {}\\n    d2 = {}\\n    col = []\\n    for i in li:\\n        if d1.get(k-i,0) > d2.get(k-i,0):\\n            d2[i] = d2.get(i,0) + 1\\n            col.append(1)\\n        else:\\n            d1[i] = d1.get(i,0) + 1\\n            col.append(0)\\n    print(*col)\", \"import math\\nimport collections\\nt=int(input())\\nfor w in range(t):\\n    n,k=(int(i) for i in input().split())\\n    l=[int(i) for i in input().split()]\\n    l1=[0]*n\\n    c=0\\n    for i in range(n):\\n        if(l[i]>k/2):\\n            l1[i]=1\\n        elif(l[i]<k/2):\\n            l1[i]=0\\n        else:\\n            if(c%2==0):\\n                l1[i]=0\\n                c+=1\\n            else:\\n                l1[i]=1\\n                c+=1\\n    print(*l1)\", \"for _ in range (int(input())):\\n    n,k=map(int,input().split())\\n    a=list(map(int,input().split()))\\n    s=set()\\n    c=0\\n    b=[0]*n\\n    for i in range (n):\\n        if 2*a[i]==k:\\n            b[i]=c\\n            c=1-c\\n        else:\\n            if a[i] in s:\\n                b[i]=1\\n            else:\\n                s.add(k-a[i])\\n    print(*b)\", \"import random\\n\\n\\ndef gcd(a, b):\\n    if a == 0:\\n        return b\\n    return gcd(b % a, a)\\n\\n\\ndef lcm(a, b):\\n    return (a * b) / gcd(a, b)\\n\\n\\nfor _ in range(int(input())):\\n    #n = int(input())\\n    n,t= map(int, input().split())\\n    a = list(map(int, input().split()))\\n    d={}\\n    for i in range(n):\\n        if a[i] in d:\\n            d[a[i]].append(i)\\n        else:\\n            d[a[i]]=[i]\\n    ans=[-1]*n\\n    for i in d.keys():\\n        if ans[d[i][0]]==-1:\\n            if i==t//2:\\n                for j in range(len(d[i])//2):\\n                    ans[d[i][j]]=0\\n                for j in range(len(d[i])//2,len(d[i])):\\n                    ans[d[i][j]] = 1\\n            else:\\n                for j in range(len(d[i])):\\n                    ans[d[i][j]]=0\\n                if t-i in d:\\n                    for j in range(len(d[t-i])):\\n                        ans[d[t-i][j]]=1\\n    for i in ans:\\n        print(i,end=' ')\\n    print('')\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"2\\n6 7\\n1 2 3 4 5 6\\n3 6\\n3 3 3\\n\"\n  ],\n  \"outputs\": [\n    \"0 0 0 1 1 1 \\n1 0 1 \\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1417/B", "starter_code": ""}
{"id": 95, "question": "You are given a integer $n$ ($n > 0$). Find any integer $s$ which satisfies these conditions, or report that there are no such numbers:\n\nIn the decimal representation of $s$:   $s > 0$,  $s$ consists of $n$ digits,  no digit in $s$ equals $0$,  $s$ is not divisible by any of it's digits. \n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line of the input contains a single integer $t$ ($1 \\leq t \\leq 400$), the number of test cases. The next $t$ lines each describe a test case.\n\nEach test case contains one positive integer $n$ ($1 \\leq n \\leq 10^5$).\n\nIt is guaranteed that the sum of $n$ for all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print an integer $s$ which satisfies the conditions described above, or \"-1\" (without quotes), if no such number exists. If there are multiple possible solutions for $s$, print any solution.\n\n\n-----Example-----\nInput\n4\n1\n2\n3\n4\n\nOutput\n-1\n57\n239\n6789\n\n\n\n-----Note-----\n\nIn the first test case, there are no possible solutions for $s$ consisting of one digit, because any such solution is divisible by itself.\n\nFor the second test case, the possible solutions are: $23$, $27$, $29$, $34$, $37$, $38$, $43$, $46$, $47$, $49$, $53$, $54$, $56$, $57$, $58$, $59$, $67$, $68$, $69$, $73$, $74$, $76$, $78$, $79$, $83$, $86$, $87$, $89$, $94$, $97$, and $98$.\n\nFor the third test case, one possible solution is $239$ because $239$ is not divisible by $2$, $3$ or $9$ and has three digits (none of which equals zero).", "solutions": "[\"#JMD\\n#Nagendra Jha-4096\\n\\n \\nimport sys\\nimport math\\n\\n#import fractions\\n#import numpy\\n \\n###File Operations###\\nfileoperation=0\\nif(fileoperation):\\n    orig_stdout = sys.stdout\\n    orig_stdin = sys.stdin\\n    inputfile = open('W:/Competitive Programming/input.txt', 'r')\\n    outputfile = open('W:/Competitive Programming/output.txt', 'w')\\n    sys.stdin = inputfile\\n    sys.stdout = outputfile\\n\\n###Defines...###\\nmod=1000000007\\n \\n###FUF's...###\\ndef nospace(l):\\n    ans=''.join(str(i) for i in l)\\n    return ans\\n \\n \\n \\n##### Main ####\\nt=int(input())\\nfor tt in range(t):\\n    n=int(input())\\n\\n    if n==1:\\n        print(-1)\\n    else:\\n        s=\\\"2\\\"\\n        for i in range(n-1):\\n            s+='3'\\n        print(s)\\n    #n,k,s= map(int, sys.stdin.readline().split(' '))\\n    #a=list(map(int,sys.stdin.readline().split(' ')))\\n    \\n    \\n#####File Operations#####\\nif(fileoperation):\\n    sys.stdout = orig_stdout\\n    sys.stdin = orig_stdin\\n    inputfile.close()\\n    outputfile.close()\", \"for _ in range(int(input())):\\n    n = int(input())\\n    if n == 1:\\n        print(-1)\\n    else:\\n        print(\\\"2\\\"+\\\"3\\\"*(n-1))\", \"def main():\\n    import sys\\n    input = sys.stdin.readline\\n\\n    for _ in range(int(input())):\\n        N = int(input())\\n        if N == 1:\\n            print(-1)\\n        else:\\n            ans = ['3'] * N\\n            ans[0] = '2'\\n            print(''.join(ans))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"tc = int(input())\\nfor _ in range(tc):\\n\\tn = int(input())\\n\\tif n > 1:\\n\\t\\tprint(\\\"2\\\" + \\\"3\\\" * (n-1))\\n\\telse:\\n\\t\\tprint(-1)\\n\"]", "input_output": "{\"inputs\": [\"4\\n1\\n2\\n3\\n4\\n\"], \"outputs\": [\"-1\\n23\\n233\\n2333\\n\"]}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1326/A", "starter_code": ""}
{"id": 96, "question": "Petya has come to the math exam and wants to solve as many problems as possible. He prepared and carefully studied the rules by which the exam passes.\n\nThe exam consists of $n$ problems that can be solved in $T$ minutes. Thus, the exam begins at time $0$ and ends at time $T$. Petya can leave the exam at any integer time from $0$ to $T$, inclusive.\n\nAll problems are divided into two types:   easy problems \u2014 Petya takes exactly $a$ minutes to solve any easy problem;  hard problems \u2014 Petya takes exactly $b$ minutes ($b > a$) to solve any hard problem. \n\nThus, if Petya starts solving an easy problem at time $x$, then it will be solved at time $x+a$. Similarly, if at a time $x$ Petya starts to solve a hard problem, then it will be solved at time $x+b$.\n\nFor every problem, Petya knows if it is easy or hard. Also, for each problem is determined time $t_i$ ($0 \\le t_i \\le T$) at which it will become mandatory (required). If Petya leaves the exam at time $s$ and there is such a problem $i$ that $t_i \\le s$ and he didn't solve it, then he will receive $0$ points for the whole exam. Otherwise (i.e if he has solved all such problems for which $t_i \\le s$) he will receive a number of points equal to the number of solved problems. Note that leaving at time $s$ Petya can have both \"mandatory\" and \"non-mandatory\" problems solved.\n\nFor example, if $n=2$, $T=5$, $a=2$, $b=3$, the first problem is hard and $t_1=3$ and the second problem is easy and $t_2=2$. Then:  if he leaves at time $s=0$, then he will receive $0$ points since he will not have time to solve any problems;  if he leaves at time $s=1$, he will receive $0$ points since he will not have time to solve any problems;  if he leaves at time $s=2$, then he can get a $1$ point by solving the problem with the number $2$ (it must be solved in the range from $0$ to $2$);  if he leaves at time $s=3$, then he will receive $0$ points since at this moment both problems will be mandatory, but he will not be able to solve both of them;  if he leaves at time $s=4$, then he will receive $0$ points since at this moment both problems will be mandatory, but he will not be able to solve both of them;  if he leaves at time $s=5$, then he can get $2$ points by solving all problems. \n\nThus, the answer to this test is $2$.\n\nHelp Petya to determine the maximal number of points that he can receive, before leaving the exam.\n\n\n-----Input-----\n\nThe first line contains the integer $m$ ($1 \\le m \\le 10^4$)\u00a0\u2014 the number of test cases in the test.\n\nThe next lines contain a description of $m$ test cases. \n\nThe first line of each test case contains four integers $n, T, a, b$ ($2 \\le n \\le 2\\cdot10^5$, $1 \\le T \\le 10^9$, $1 \\le a < b \\le 10^9$)\u00a0\u2014 the number of problems, minutes given for the exam and the time to solve an easy and hard problem, respectively.\n\nThe second line of each test case contains $n$ numbers $0$ or $1$, separated by single space: the $i$-th number means the type of the $i$-th problem. A value of $0$ means that the problem is easy, and a value of $1$ that the problem is hard.\n\nThe third line of each test case contains $n$ integers $t_i$ ($0 \\le t_i \\le T$), where the $i$-th number means the time at which the $i$-th problem will become mandatory.\n\nIt is guaranteed that the sum of $n$ for all test cases does not exceed $2\\cdot10^5$.\n\n\n-----Output-----\n\nPrint the answers to $m$ test cases. For each set, print a single integer\u00a0\u2014 maximal number of points that he can receive, before leaving the exam.\n\n\n-----Example-----\nInput\n10\n3 5 1 3\n0 0 1\n2 1 4\n2 5 2 3\n1 0\n3 2\n1 20 2 4\n0\n16\n6 20 2 5\n1 1 0 1 0 0\n0 8 2 9 11 6\n4 16 3 6\n1 0 1 1\n8 3 5 6\n6 20 3 6\n0 1 0 0 1 0\n20 11 3 20 16 17\n7 17 1 6\n1 1 0 1 0 0 0\n1 7 0 11 10 15 10\n6 17 2 6\n0 0 1 0 0 1\n7 6 3 7 10 12\n5 17 2 5\n1 1 1 1 0\n17 11 10 6 4\n1 1 1 2\n0\n1\n\nOutput\n3\n2\n1\n0\n1\n4\n0\n1\n2\n1", "solutions": "[\"import sys\\nfrom operator import itemgetter\\n\\ndef count(a, b, num_a, num_b, cur_time):\\n\\tcurrent_result = 0\\n\\t#print('count time = ', cur_time, \\\"num_a =\\\", num_a, 'num_b = ', num_b)\\n\\tif num_a * a + num_b * b <= cur_time and cur_time >= 0:\\n\\t\\tcur_time -= num_a * a + num_b * b\\n\\t\\tcurrent_result = num_a + num_b\\n\\t\\tif num_a < total_a:\\n\\t\\t\\tif (total_a - num_a) * a <= cur_time:\\n\\t\\t\\t\\tcurrent_result += total_a - num_a\\n\\t\\t\\t\\tcur_time -= (total_a - num_a) * a\\n\\t\\t\\t\\t#print(1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcurrent_result += cur_time // a\\n\\t\\t\\t\\tcur_time -= a *(cur_time // a)\\n\\t\\t\\t\\t#print(2)\\n\\t\\tif num_b < total_b:\\n\\t\\t\\tif (total_b - num_b) * b <= cur_time:\\n\\t\\t\\t\\tcurrent_result += total_b - num_b\\n\\t\\t\\t\\t#print(3)\\n\\t\\t\\telse:\\n\\t\\t\\t\\t#print(4)\\n\\t\\t\\t\\tcurrent_result += cur_time // b\\n\\t#print('current_result = ', current_result)\\n\\treturn current_result\\n\\n\\ndef solve(n, T, a, b, tasks, total_a, total_b):\\t\\n\\ttasks = sorted(tasks)\\n\\t#print(tasks)\\n\\tresult = 0\\n\\tnum_a = 0\\n\\tnum_b = 0\\n\\n\\tfor i in range(len(tasks)):\\n\\t\\ttime, t = tasks[i] \\n\\t\\t#print(tasks[i])\\n\\t\\tcur_time = time - 1\\n\\t\\t#print('cur time = ', cur_time)\\n\\t\\tcurrent_result = count(a, b, num_a, num_b, cur_time)\\n\\t\\tresult = max(current_result, result)\\n\\n\\t\\tif t == 0:\\n\\t\\t\\tnum_a += 1\\n\\t\\telse:\\n\\t\\t\\tnum_b += 1\\n\\n\\t\\tif i == len(tasks) - 1 or tasks[i + 1][1] != tasks[i][1]:\\n\\t\\t\\tresult = max(result, count(a, b, num_a, num_b, cur_time))\\n\\n\\t\\t#print(\\\"i =\\\", i, \\\"result = \\\", result)\\n\\n\\tresult = max(result, count(a, b, total_a, total_b, T))\\n\\treturn result\\n\\n\\nq = int(input())\\n\\nfor i in range(q):\\n\\tn, T, a, b = list(map(int, input().split()))\\n\\ttypes = list(map(int, input().split()))\\n\\ttotal_a, total_b = 0, 0\\n\\tfor t in types:\\n\\t\\tif t == 0:\\n\\t\\t\\ttotal_a += 1\\n\\t\\telse:\\n\\t\\t\\ttotal_b += 1\\n\\tt = list(map(int, input().split()))\\n\\t#print(t)\\n\\t#print(types)\\n\\ttasks = list(zip(t, types))\\n\\tprint(solve(n, T, a, b, tasks, total_a, total_b))\\t\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\nfor testcases in range(t):\\n    n,T,a,b=list(map(int,input().split()))\\n    A=list(map(int,input().split()))\\n    L=list(map(int,input().split()))\\n\\n    LCAN=[T]\\n\\n    EASY=[]\\n    HARD=[]\\n\\n    for i in range(n):\\n        if A[i]==0:\\n            EASY.append(L[i])\\n        else:\\n            HARD.append(L[i])\\n\\n        if L[i]>1:\\n            LCAN.append(L[i]-1)\\n\\n    LCAN=sorted(set(LCAN))\\n\\n    EASY.sort()\\n    HARD.sort()\\n\\n    #print(LCAN,a,b)\\n    #print(EASY)\\n    #print(HARD)\\n    #print()\\n\\n    eind=0\\n    hind=0\\n\\n    LENE=len(EASY)\\n    LENH=len(HARD)\\n\\n    needtime=0\\n    ANS=0\\n    \\n    for time in LCAN:\\n        while eind<LENE and EASY[eind]<=time:\\n            needtime+=a\\n            eind+=1\\n\\n        while hind<LENH and HARD[hind]<=time:\\n            needtime+=b\\n            hind+=1\\n\\n        if time<needtime:\\n            continue\\n        else:\\n            rest=time-needtime\\n            score=eind+hind\\n\\n            if (LENE-eind)*a>=rest:\\n                score+=rest//a\\n            else:\\n                score=LENE+hind\\n                rest-=(LENE-eind)*a\\n\\n                score+=min(LENH-hind,rest//b)\\n\\n            ANS=max(ANS,score)\\n            \\n    print(ANS)\\n                \\n\\n        \\n\\n            \\n        \\n\\n    \\n\", \"m = int(input())\\nfor ii in range(m):\\n    n, T, a, b = list(map(int, input().split()))\\n    score = [a,b]\\n    d = list(map(int, input().split()))\\n    t = list(map(int, input().split()))\\n    easy = 0\\n    for d1 in d:\\n        if d1 == 0:\\n            easy += 1\\n    diff = list(zip(t,d))\\n    diff = sorted(diff) # from least to greatest\\n    cnt = 0\\n    cur = 0\\n    ans = 0\\n    for i in range(n):\\n        t,d = diff[i]\\n        # print('----',i, cur, cnt)\\n        if cur < t and cur <= T:\\n            # can leave\\n            ans = max(cnt, ans)\\n            # try easy problems as much as possible\\n            tmp = (t - 1 - cur) // a\\n            tmp = min(tmp, easy)\\n            ans = max(ans, cnt + tmp)\\n\\n        # force this one\\n        cnt += 1\\n        cur += score[d]\\n        if d==0:\\n            easy -= 1\\n    if cur <= T:\\n        ans = max(cnt, ans)\\n\\n    print(ans)\\n\", \"import sys\\n\\ndef minp():\\n\\treturn sys.stdin.readline().strip()\\n\\ndef mint():\\n\\treturn int(minp())\\n\\ndef mints():\\n\\treturn list(map(int,minp().split()))\\n\\ndef solve():\\n\\tn, T, a, b = mints()\\n\\th = list(mints())\\n\\tc = [0, 0]\\n\\tfor i in h:\\n\\t\\tc[i] += 1\\n\\ti = 0\\n\\tt = [None]*n\\n\\tfor j in mints():\\n\\t\\tt[i] = (j, i)\\n\\t\\ti += 1\\n\\tt.sort()\\n\\ttt = 0\\n\\ttmust = 0\\n\\tcmust = 0\\n\\tr = 0\\n\\tfor ii in range(len(t)):\\n\\t\\ttn, i = t[ii]\\n\\t\\tif tt < tn - 1:\\n\\t\\t\\ttt = tn - 1\\n\\t\\t\\tleft = tt - tmust\\n\\t\\t\\tif left >= 0:\\n\\t\\t\\t\\tac = min(left//a, c[0])\\n\\t\\t\\t\\tbc = min((left - ac*a)//b, c[1])\\n\\t\\t\\t\\t#print(tt, tmust, left, cmust, ac, bc)\\n\\t\\t\\t\\tr = max(r, cmust + ac + bc)\\n\\t\\tif h[i]:\\n\\t\\t\\ttmust += b\\n\\t\\t\\tc[1] -= 1\\n\\t\\telse:\\n\\t\\t\\ttmust += a\\n\\t\\t\\tc[0] -= 1\\n\\t\\t#print(\\\"tmust\\\", tmust)\\n\\t\\tcmust += 1\\n\\tif tt < T:\\n\\t\\ttt = T\\n\\t\\tleft = tt - tmust\\n\\t\\tif left >= 0:\\n\\t\\t\\tac = min(left//a, c[0])\\n\\t\\t\\tbc = min((left - ac*a)//b, c[1])\\n\\t\\t\\tr = max(r, cmust + ac + bc)\\n\\treturn r\\n\\nfor i in range(mint()):\\n\\tprint(solve())\\n\", \"\\nm = int(input())\\nfor i in range(m):\\n\\tn, T, a, b = list(map(int, input().split()))\\n\\tis_hard = list(map(int, input().split()))\\n\\ttotal_hard = sum(is_hard)\\n\\ttotal_easy = n - total_hard\\n\\ttime_mandatory = list(map(int, input().split()))\\n\\tmandatory_times = sorted([(time_mandatory[i], i)\\n\\t\\tfor i in range(len(time_mandatory))])\\n\\tmandatory_times.append((T, -1))\\n\\tmaximal_points = 0\\n\\tmin_easy = 0\\n\\tmin_hard = 0\\n\\tfor (i, (time, problem_no)) in enumerate(mandatory_times):\\n\\t\\tbad = False\\n\\t\\tif i != len(mandatory_times) - 1 and mandatory_times[i + 1][0] == time:\\n\\t\\t\\tbad = True\\n\\t\\tremaining_easy = total_easy - min_easy\\n\\t\\tremaining_hard = total_hard - min_hard\\n\\t\\tremaining_time = time - 1 - min_easy * a - min_hard * b\\n\\t\\tif remaining_time >= 0:\\n\\t\\t\\tif remaining_time >= a * remaining_easy:\\n\\t\\t\\t\\tmaximal_points = max(maximal_points,\\n\\t\\t\\t\\t\\tmin_easy + min_hard + remaining_easy +\\n\\t\\t\\t\\t\\tmin((remaining_time - a * remaining_easy) // b,\\n\\t\\t\\t\\t\\t\\tremaining_hard))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmaximal_points = max(maximal_points,\\n\\t\\t\\t\\t\\tmin_easy + min_hard + remaining_time // a)\\n\\t\\tif problem_no == -1:\\n\\t\\t\\tmin_easy = min_easy\\n\\t\\telif is_hard[problem_no] == 1:\\n\\t\\t\\tmin_hard += 1\\n\\t\\telse:\\n\\t\\t\\tmin_easy += 1\\n\\t\\tif bad:\\n\\t\\t\\tcontinue\\n\\t\\tremaining_easy = total_easy - min_easy\\n\\t\\tremaining_hard = total_hard - min_hard\\n\\t\\tremaining_time = time - min_easy * a - min_hard * b\\n\\t\\tif remaining_time >= 0:\\n\\t\\t\\tif remaining_time >= a * remaining_easy:\\n\\t\\t\\t\\tmaximal_points = max(maximal_points,\\n\\t\\t\\t\\t\\tmin_easy + min_hard + remaining_easy +\\n\\t\\t\\t\\t\\tmin((remaining_time - a * remaining_easy) // b,\\n\\t\\t\\t\\t\\t\\tremaining_hard))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmaximal_points = max(maximal_points,\\n\\t\\t\\t\\t\\tmin_easy + min_hard + remaining_time // a)\\n\\tprint(maximal_points)\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n, T, a, b = list(map(int, input().split(' ')))\\n    task_t = list(map(int, input().split(' ')))\\n    ness = list(map(int, input().split(' ')))\\n\\n    perm = sorted(list(range(n)), key=lambda i: ness[i])\\n\\n    score = 0\\n    tot_hard = sum(task_t)\\n    tot_easy = n - tot_hard\\n\\n    must_easy = 0\\n    must_hard = 0\\n    for i in range(n):\\n        if i > 0 and ness[perm[i]] == ness[perm[i - 1]]:\\n            if task_t[perm[i]] == 0:\\n                must_easy += 1\\n            else:\\n                must_hard += 1\\n            continue\\n\\n        tm = ness[perm[i]] - 1\\n\\n        req_time = must_easy * a + must_hard * b\\n\\n        if req_time > tm:\\n            if task_t[perm[i]] == 0:\\n                must_easy += 1\\n            else:\\n                must_hard += 1\\n            continue\\n\\n        extra_time = tm - req_time\\n        extra_easy = min(extra_time // a, tot_easy - must_easy)\\n\\n        extra_time -= a * extra_easy\\n        extra_hard = min(extra_time // b, tot_hard - must_hard)\\n\\n        #print(tm, extra_easy, extra_hard, must_easy, must_hard)\\n\\n        score = max(score, extra_easy + extra_hard + must_easy + must_hard)\\n\\n        if task_t[perm[i]] == 0:\\n            must_easy += 1\\n        else:\\n            must_hard += 1\\n\\n    if tot_easy * a + tot_hard * b <= T:\\n        score = n\\n    print(score)\\n\\n\\n\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"10\\n3 5 1 3\\n0 0 1\\n2 1 4\\n2 5 2 3\\n1 0\\n3 2\\n1 20 2 4\\n0\\n16\\n6 20 2 5\\n1 1 0 1 0 0\\n0 8 2 9 11 6\\n4 16 3 6\\n1 0 1 1\\n8 3 5 6\\n6 20 3 6\\n0 1 0 0 1 0\\n20 11 3 20 16 17\\n7 17 1 6\\n1 1 0 1 0 0 0\\n1 7 0 11 10 15 10\\n6 17 2 6\\n0 0 1 0 0 1\\n7 6 3 7 10 12\\n5 17 2 5\\n1 1 1 1 0\\n17 11 10 6 4\\n1 1 1 2\\n0\\n1\\n\"\n  ],\n  \"outputs\": [\n    \"3\\n2\\n1\\n0\\n1\\n4\\n0\\n1\\n2\\n1\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1282/C", "starter_code": ""}
{"id": 97, "question": "Your friend Jeff Zebos has been trying to run his new online company, but it's not going very well. He's not getting a lot of sales on his website which he decided to call Azamon. His big problem, you think, is that he's not ranking high enough on the search engines. If only he could rename his products to have better names than his competitors, then he'll be at the top of the search results and will be a millionaire.\n\nAfter doing some research, you find out that search engines only sort their results lexicographically. If your friend could rename his products to lexicographically smaller strings than his competitor's, then he'll be at the top of the rankings!\n\nTo make your strategy less obvious to his competitors, you decide to swap no more than two letters of the product names.\n\nPlease help Jeff to find improved names for his products that are lexicographically smaller than his competitor's!\n\nGiven the string $s$ representing Jeff's product name and the string $c$ representing his competitor's product name, find a way to swap at most one pair of characters in $s$ (that is, find two distinct indices $i$ and $j$ and swap $s_i$ and $s_j$) such that the resulting new name becomes strictly lexicographically smaller than $c$, or determine that it is impossible.\n\nNote: String $a$ is strictly lexicographically smaller than string $b$ if and only if one of the following holds:  $a$ is a proper prefix of $b$, that is, $a$ is a prefix of $b$ such that $a \\neq b$;  There exists an integer $1 \\le i \\le \\min{(|a|, |b|)}$ such that $a_i < b_i$ and $a_j = b_j$ for $1 \\le j < i$. \n\n\n-----Input-----\n\nThe first line of input contains a single integer $t$ ($1 \\le t \\le 1500$) denoting the number of test cases. The next lines contain descriptions of the test cases.\n\nEach test case consists of a single line containing two space-separated strings $s$ and $c$ ($2 \\le |s| \\le 5000, 1 \\le |c| \\le 5000$). The strings $s$ and $c$ consists of uppercase English letters.\n\nIt is guaranteed that the sum of $|s|$ in the input is at most $5000$ and the sum of the $|c|$ in the input is at most $5000$.\n\n\n-----Output-----\n\nFor each test case, output a single line containing a single string, which is either  the new name which is obtained after swapping no more than one pair of characters that is strictly lexicographically smaller than $c$. In case there are many possible such strings, you can output any of them;  three dashes (the string \"---\" without quotes) if it is impossible. \n\n\n-----Example-----\nInput\n3\nAZAMON APPLE\nAZAMON AAAAAAAAAAALIBABA\nAPPLE BANANA\n\nOutput\nAMAZON\n---\nAPPLE\n\n\n\n-----Note-----\n\nIn the first test case, it is possible to swap the second and the fourth letters of the string and the resulting string \"AMAZON\" is lexicographically smaller than \"APPLE\".\n\nIt is impossible to improve the product's name in the second test case and satisfy all conditions.\n\nIn the third test case, it is possible not to swap a pair of characters. The name \"APPLE\" is lexicographically smaller than \"BANANA\". Note that there are other valid answers, e.g., \"APPEL\".", "solutions": "[\"import sys\\nreader = (s.rstrip() for s in sys.stdin)\\ninput = reader.__next__\\n\\ndef solve():\\n    s,c = input().split()\\n    # i,j\\u3067j\\u304c\\u8907\\u6570\\u3042\\u308b\\u3068\\u304d\\n    n = len(s)\\n    for i in range(n-1):\\n        prev = s[i]\\n        pos = i\\n        for j in range(i+1, n):\\n            if s[j]<prev:\\n                prev = s[j]\\n                pos = j\\n            elif s[j] == prev:\\n                pos = j\\n        if prev == s[i]:\\n            continue\\n        t = list(s)\\n        t[i], t[pos] = prev, s[i]\\n        s = \\\"\\\".join(t)\\n        break\\n    if s<c:\\n        print(s)\\n    else:\\n        print(\\\"---\\\")\\n\\nt = int(input())\\nfor i in range(t):\\n    solve()\\n\", \"import heapq\\nimport math\\nfrom collections import *\\nfrom functools import reduce,cmp_to_key\\nimport sys\\n\\ninput = sys.stdin.readline\\nM = mod = 10**9 + 7\\ndef factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))\\ndef inv_mod(n):return pow(n, mod - 2, mod)\\n\\ndef li():return [int(i) for i in input().rstrip('\\\\n').split(' ')]\\ndef st():return input().rstrip('\\\\n')\\ndef val():return int(input())\\ndef li2():return [i for i in input().rstrip('\\\\n').split(' ')]\\n\\n\\nn = val()\\nfor _ in range(n):\\n    s1,s2 = li2()\\n    fin = sorted(s1)\\n\\n    if fin[0]>s2[0]:\\n        print('---')\\n        continue\\n    for i in range(len(s1)):\\n        if s1[i] != fin[i]:\\n            for j in range(len(s1)-1,-1,-1):\\n                if s1[j] == fin[i]:\\n                    s1 = list(s1)\\n                    s1[j] = s1[i]\\n                    s1[i] = fin[i]\\n                    s1 = ''.join(s1)\\n                    break\\n            break\\n    print('---' if s1 >= s2 else s1)\\n\", \"def main():\\n    TT = int(input())\\n    for _ in range(TT):\\n        w, t = input().strip().split(' ')\\n        w = list(w)\\n\\n        sf = [len(w) - 1 for _ in range(len(w))]\\n        for i in range(len(w) - 2, -1, -1):\\n            if w[i] < w[sf[i+1]]:\\n                sf[i] = i\\n            else:\\n                sf[i] = sf[i + 1]\\n\\n        for i in range(len(w)):\\n            if sf[i] != i and w[sf[i]] != w[i]:\\n                w[i], w[sf[i]] = w[sf[i]], w[i]\\n                break\\n        w = ''.join(w)\\n        if w < t:\\n            print(w)\\n        else:\\n            print('---')\\n\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"q=int(input())\\nfor i in range(q):\\n    ok=[x for x in input().split()]\\n    r=ok[0]\\n    s=ok[1]\\n    w = [(ord(r[i])) for i in range(len(r))]\\n    w.sort()\\n    w=[chr(w[i]) for i in range(len(r))]\\n    first=True\\n    at=-1\\n    for j in range(len(r)):\\n        if w[j]!=r[j]:\\n            first=False\\n            at=j\\n            break\\n    if first==False:\\n        t=r[::-1].find(w[at])\\n        r=r[:at]+w[at]+r[at+1:len(r)-1-t]+r[at]+r[len(r)-t:]\\n    if r<s:\\n        print(r)\\n    else:\\n        print(\\\"---\\\")\", \"def gets(a):\\n    i = 0\\n    a = list(a)\\n    b = [0]*100\\n    \\n    for j in a:\\n        b[ord(j)-ord('A')]+=1\\n    \\n    r = -1\\n    t = -1\\n    while(b[i]==0 and i<26):\\n        i+=1\\n        \\n    for k in range(0,len(a)):\\n        if r==-1 and (ord(a[k]) - ord('A'))== i:\\n            b[i]-=1\\n            while(b[i]==0 and i<26):\\n                i+=1\\n        elif r==-1:\\n            t = k\\n            r = 0\\n        elif ord(a[k]) - ord('A') == i:\\n            r = k\\n    \\n    if r!=-1 and t!=-1:\\n        a[t] , a[r] = a[r] , a[t]\\n    return ''.join(a)\\n\\nfor _ in range(int(input())):\\n    a,b = input().split()\\n    a = gets(a)\\n    if a<b:\\n        print(a)\\n    else:\\n        print(\\\"---\\\")\", \"for _ in range(int(input())):\\n    a, b = input().split()\\n    a = list(a)\\n    for i in range(len(a)-1):\\n        j = min((i for i in range(i+1, len(a))), key=lambda x: (a[x], -x))\\n        if a[i] > a[j]:\\n            a[i], a[j] = a[j], a[i]\\n            break\\n        \\n    a = ''.join(a)\\n    if a < b:\\n        print(a)\\n    else:\\n        print('---')\\n            \\n\", \"import math\\n\\ndef better(a, b):\\n    for i in range(min(len(a), len(b))):\\n        if ord(a[i]) < ord(b[i]):\\n            return True\\n        elif ord(a[i]) > ord(b[i]):\\n            return False\\n    return len(a) < len(b)\\n\\ndef optimize(a):\\n    occ = [0] * 26\\n    for i in range(len(a)):\\n        occ[ord(a[i]) - ord('A')] += 1\\n    p1 = -1\\n    p2 = -1\\n    t = 0\\n    for i in range(len(a)):\\n        if p1 < 0:\\n            occ[ord(a[i]) - ord('A')] -= 1\\n            for j in range(ord(a[i]) - ord('A')):\\n                if occ[j] > 0:\\n                    p1 = i\\n                    t = j\\n                    break\\n        else:\\n            if ord(a[i]) - ord('A') == t:\\n                p2 = i\\n\\n    if p1 >= 0 and p2 >= 0:\\n        return a[:p1] + a[p2] + a[p1+1:p2] + a[p1] + a[p2+1:]\\n    return a\\n\\ndef main():\\n    t = int(input())\\n    for i in range(t):\\n        line = str(input())\\n        p = line.split()\\n        mine = p[0]\\n        yours = p[1]\\n        new = optimize(mine)\\n        if better(new, yours):\\n            print(new)\\n        else:\\n            print('---')\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"for _ in range(int(input())):\\n    a,c=input().split()\\n    a=list(a)\\n    b=sorted(a)\\n    if a!=b:\\n        for i,x in enumerate(b):\\n            if a[i]!=x:\\n                tmp=a[i]\\n                a[i]=x\\n                break\\n        for i in range(len(a)-1,-1,-1):\\n            if a[i]==x:\\n                a[i]=tmp\\n                break\\n    a=''.join(a)\\n    \\n    if a<c:\\n        print(a)\\n    else:\\n        print('---')\", \"import sys\\ninput = sys.stdin.readline\\n\\nQ = int(input())\\nQuery = [list(map(str, input().rstrip().split())) for _ in range(Q)]\\n\\nfor S, T in Query:\\n    L = len(S)\\n    update = False\\n    A = list(S)\\n    for i in range(L-1):\\n        tmp = S[i]\\n        for j in range(i+1, L):\\n            if update and tmp == S[j]:\\n                ind = j\\n            if tmp > S[j]:\\n                tmp = S[j]\\n                update = True\\n                ind = j\\n        if update:\\n            A[ind] = S[i]\\n            A[i] = S[ind]\\n            break\\n    A_str = \\\"\\\".join(A)\\n    if A_str < T:\\n        print(A_str)\\n    else:\\n        print(\\\"---\\\")        \", \"from string import ascii_uppercase\\n\\na = ascii_uppercase\\nN = int(input())\\n\\nfor i in range(N):\\n    me, comp = input().split(' ')\\n    # Want to maximize the lexicographic swap\\n    best = ''.join(sorted(me))\\n    # print(best)\\n\\n    mismatch = -1\\n    for index, pair in enumerate(zip(best, me)):\\n        i, j = pair\\n        if i != j:\\n            mismatch = index\\n            break\\n    \\n    if mismatch != -1:\\n        # Want to swap mismatch (index) with last occurence after mismatch\\n        swaploc = len(me) - me[mismatch+1:][::-1].find(best[mismatch]) - 1\\n        swap1 = me[:mismatch] + me[swaploc] + me[mismatch+1:swaploc] + me[mismatch] + me[swaploc+1:]\\n    else:\\n        swap1 = me\\n    if swap1 < comp:\\n        print(swap1)\\n    else:\\n        print('---')\", \"n = int(input())\\nfor i in range(n):\\n\\ts, t = list(map(str, input().split()))\\n\\tif len(s) == 1:\\n\\t\\tif s < t:\\n\\t\\t\\tprint (s)\\n\\t\\telse:\\n\\t\\t\\tprint (\\\"---\\\")\\n\\t\\tcontinue\\n\\tmas = [['ZZ', -1]]\\n\\tfor j in range(len(s) - 1, -1, -1):\\n\\t\\tif mas[-1][0] > s[j]:\\n\\t\\t\\tmas.append([s[j], j])\\n\\t\\telse:\\n\\t\\t\\tmas.append(mas[-1])\\n\\tmas = mas[::-1]\\n\\t#print (*mas)\\n\\tflag = True\\n\\tfor j in range(len(s)):\\n\\t\\t#print (j)\\n\\t\\tif s[j] > mas[j][0]:\\n\\t\\t\\ts = s[:j] + mas[j][0] + s[j + 1:mas[j][1]] + s[j] + s[mas[j][1] + 1:]\\n\\t\\t\\tif (s >= t):\\n\\t\\t\\t\\tprint (\\\"---\\\")\\n\\t\\t\\telse:\\n\\t\\t\\t\\tprint (s)\\n\\t\\t\\tflag = False\\n\\t\\t\\tbreak\\n\\tif flag:\\n\\t\\tif s < t:\\n\\t\\t\\tprint (s)\\n\\t\\telse:\\n\\t\\t\\tprint (\\\"---\\\")\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\ndef getInt(): return int(input())\\ndef getVars(): return list(map(int, input().split()))\\ndef getList(): return list(map(int, input().split()))\\ndef getStr(): return input().strip()\\n\\n## -------------------------------\\n\\nn = getInt()\\nfor i in range(n):\\n    s, c = getStr().split()\\n    p = False\\n    for i in range(len(s)-1):\\n        ch = i\\n        for j in range(i+1,len(s)):\\n            if s[j] <= s[ch]:\\n                ch = j\\n        if s[ch] < s[i]:\\n            s = s[:i] + s[ch] + s[i+1:ch] + s[i] + s[ch+1:]\\n            break\\n    if s < c: print(s)\\n    else: print('---')\\n    \\n\\n\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\nAZAMON APPLE\\nAZAMON AAAAAAAAAAALIBABA\\nAPPLE BANANA\\n\"\n  ],\n  \"outputs\": [\n    \"AAZMON\\n---\\nAEPLP\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1281/B", "starter_code": ""}
{"id": 98, "question": "You may have already known that a standard ICPC team consists of exactly three members. The perfect team however has more restrictions. A student can have some specialization: coder or mathematician. She/he can have no specialization, but can't have both at the same time.\n\nSo the team is considered perfect if it includes at least one coder, at least one mathematician and it consists of exactly three members.\n\nYou are a coach at a very large university and you know that $c$ of your students are coders, $m$ are mathematicians and $x$ have no specialization.\n\nWhat is the maximum number of full perfect teams you can distribute them into? \n\nNote that some students can be left without a team and each student can be a part of no more than one team.\n\nYou are also asked to answer $q$ independent queries.\n\n\n-----Input-----\n\nThe first line contains a single integer $q$ ($1 \\le q \\le 10^4$) \u2014 the number of queries. \n\nEach of the next $q$ lines contains three integers $c$, $m$ and $x$ ($0 \\le c, m, x \\le 10^8$) \u2014 the number of coders, mathematicians and students without any specialization in the university, respectively.\n\nNote that the no student is both coder and mathematician at the same time. \n\n\n-----Output-----\n\nPrint $q$ integers \u2014 the $i$-th of them should be the answer to the $i$ query in the order they are given in the input. The answer is the maximum number of full perfect teams you can distribute your students into. \n\n\n-----Example-----\nInput\n6\n1 1 1\n3 6 0\n0 0 0\n0 1 1\n10 1 10\n4 4 1\n\nOutput\n1\n3\n0\n0\n1\n3\n\n\n\n-----Note-----\n\nIn the first example here are how teams are formed:  the only team of 1 coder, 1 mathematician and 1 without specialization;  all three teams consist of 1 coder and 2 mathematicians;  no teams can be formed;  no teams can be formed;  one team consists of 1 coder, 1 mathematician and 1 without specialization, the rest aren't able to form any team;  one team consists of 1 coder, 1 mathematician and 1 without specialization, one consists of 2 coders and 1 mathematician and one consists of 1 coder and 2 mathematicians.", "solutions": "[\"q = int(input())\\nfor _ in range(q):\\n\\tc, m, x = list(map(int, input().split()))\\n\\tprint(min([c, m, (c + m + x) // 3]))\", \"q = int(input())\\nfor i in range(q):\\n    c, m, x = map(int, input().split())\\n    ans = min(c, m, x)\\n    c -= ans\\n    m -= ans\\n    x -= ans\\n    ans += min(c, m, (c + m) // 3)\\n    print(ans)\", \"for i in range(int(input())):\\n    c,m,x=map(int,input().split())\\n    print(min((c+m+x)//3,c,m))\", \"t = int(input())\\nfor i in range(t):\\n  c,m,x = map(int,input().split())\\n  ans1 = min(c,m)\\n  ans2 = (c+m+x)//3\\n  print(min(ans1,ans2))\", \"for _ in range(int(input())):\\n\\tc, m, x = map(int, input().split())\\n\\tprint(min((c + m + x) // 3, min(c, m)))\", \"q = int(input())\\ninfo=[[int(i) for i in input().split()] for k in range(q)]\\n\\nfor inf in info:\\n    c,m,x = inf\\n    print(min([c,m,int((c+m+x)/3)]))\", \"Q = int(input())\\nfor q in range(Q):\\n    c, m, x = tuple(map(int, input().split()))\\n    ans = min(c, m)\\n    #m = ans\\n    c -= ans\\n    m -= ans\\n\\n    if c + m + x >= ans:\\n        print(ans)\\n        continue\\n\\n    delta = (ans - (c + m + x)) * 2\\n    ans = c + m + x\\n\\n    ans += min(delta // 3, delta // 2)\\n    print(ans)\\n\", \"t=int(input())\\nwhile t:\\n    t=t-1\\n    c,m,x=[int(x) for x in input().split(\\\" \\\")]\\n    y=min(c,m)\\n    c=c-y\\n    m=m-y\\n    #print(\\\"y\\\",y)\\n    if y<=c+m+x:\\n        print(y)\\n    else:\\n        print((c+m+x+y*2)//3)\", \"n = int(input())\\nwhile n:\\n    a,b,c=map(int,input().split())\\n    if a<b:\\n        a,b=b,a\\n    print(min(b,(a+b+c)//3))\\n    n-=1\", \"n=int(input())\\nwhile n:\\n    n-=1\\n    l=list(map(int,input().split()))\\n    if sum(l)//3 < min(l[0],l[1]):\\n        print(sum(l)//3)\\n    else:\\n        print(min(l[0],l[1]))\", \"for q in range(int(input())):\\n      c,m,x=list(map(int,input().split()))\\n      a=min(c,m,(c+m+x)//3)\\n      print(a)\\n\", \"Q = int(input())\\n\\ndef solve():\\n    [c,m,x] = list(map(int,input().split()))\\n\\n    def canMakeK(k):\\n        if c < k or m < k:\\n            return False\\n        return ((c-k) + (m-k) + x) >= k\\n\\n    ans = 0\\n    jump = max(c,m,x)\\n    while jump > 0:\\n        while canMakeK(ans+jump):\\n            ans += jump\\n        jump //= 2\\n\\n    return ans\\n\\nfor _ in range(Q):\\n    print(solve())\\n\", \"from sys import stdin\\nfor i in range(int(stdin.readline())):\\n    c, m, x = list(map(int, stdin.readline().split()))\\n    def ok(nteam):\\n        return c >= nteam and m >= nteam and x + c + m >= 3 * nteam\\n    l = 0\\n    r = max(c, m, x) + 1\\n    while r - l > 1:\\n        mid = (r + l) // 2\\n        if ok(mid):\\n            l = mid\\n        else:\\n            r = mid\\n    print(l)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\ndef getInt(): return int(input())\\ndef getVars(): return list(map(int, input().split()))\\ndef getList(): return list(map(int, input().split()))\\ndef getStr(): return input().strip()\\n## -------------------------------\\n\\ndef addDictList(d, key, val):\\n    if key not in d: d[key] = []\\n    d[key].append(val)\\n\\ndef addDictInt(d, key, val):\\n    if key not in d: d[key] = 0\\n    d[key] = val\\n\\n\\ndef addDictCount(d, key):\\n    if key not in d: d[key] = 0\\n    d[key] += 1\\n\\ndef addDictSum(d, key, val):\\n    if key not in d: d[key] = 0\\n    d[key] += val\\n\\n## -------------------------------\\n\\nt=getInt()\\nfor _ in range(t):\\n    c, m, x = getVars()\\n    res = min(c, m)\\n    res = min(res, (c+m+x)//3)\\n    print(res)\\n\\n\", \"q = int(input())\\nfor _ in range(q):\\n    c, m, x = list(map(int, input().split()))\\n    s = c + m + x\\n    i = min(c, m)\\n    if s//3 <= i:\\n        print(s//3)\\n    else:\\n        print(min(i, s-i*2))\\n\", \"def solve():\\n    c, m, x = list(map(int, input().split()))\\n    u = min(c, m)\\n    y = c - u + m - u + x\\n    if y >= u:\\n        print(u)\\n        return\\n    print(y + (u - y) * 2 // 3)\\n\\nt = int(input())\\n\\nfor _ in range(t):\\n    solve()\\n\", \"for i in range(int(input())):\\n    c,m,x=map(int,input().split())\\n    print(min((c+m+x)//3,min(c,m)))\", \"for _ in range(int(input())):\\n    c,m,s = [int(i) for i in input().split()]\\n    a,b = min(c,m),max(c,m)\\n    if(s>=a):\\n        print(a)\\n    else:\\n        a = a-s\\n        b = b-s\\n        temp = (a+b)//3\\n        print(s + min(temp,a))\", \"n = int(input())\\nfor i in range(n):\\n\\tc, m, x = list(map(int, input().split()))\\n\\twynik = 0\\n\\twynik += min(c, m,x)\\n\\thuj = min(c,m,x)\\n\\tc -= huj\\n\\tm -= huj\\n\\tx -= huj\\n\\tif x > 0:\\n\\t\\tprint(wynik)\\n\\telse:\\n\\t\\tif c > m:\\n\\t\\t\\tc, m = m, c\\n\\t\\twynik += min(m,c,(m+c)//3)\\n\\t\\tprint(wynik)\\n\", \"for _ in range(int(input())):\\n\\tc, m, a = map(int, input().split())\\n\\tprint(min(c, m, (c + m + a) // 3))\", \"from sys import stdin\\nq=int(stdin.readline().strip())\\nfor i in range(q):\\n    c,m,x=list(map(int,stdin.readline().strip().split()))\\n    n=c+m+x\\n    y=min(c,m)\\n    t=n//3\\n    ans=min(y,t)\\n    print(ans)\\n\", \"q = int(input())\\nfor i in range(q):\\n\\tc, m, x = map(int, input().split())\\n\\tprint(min(min(c, m), (c + m + x) // 3))\", \"q = int(input())\\nfor i in range(q):\\n    c, m, x = map(int, input().split())\\n    if min(c, m) <= x:\\n        print(min(c, m))\\n    else:\\n        l = -1\\n        r = min(c, m) + 1\\n        while l + 1 < r:\\n            mid = (l + r) // 2\\n            if c - mid + m - mid + x >= mid:\\n                l = mid\\n            else:\\n                r = mid\\n        if l == -1:\\n            l = 0\\n        print(l)\", \"import sys\\n\\ndef read():\\n\\treturn sys.stdin.readline()\\n\\ndef main():\\n\\tq = int(read())\\n\\tfor i in range(q):\\n\\t\\tc, m, x = list(map(int, read().split()))\\n\\t\\tif c <= m and c <= x:\\n\\t\\t\\tprint(c)\\n\\t\\telif m <= c and m <= x:\\n\\t\\t\\tprint(m)\\n\\t\\telse:\\n\\t\\t\\tt = x\\n\\t\\t\\tc -= x\\n\\t\\t\\tm -= x\\n\\t\\t\\tq = min(m, c, (m + c) // 3)\\n\\t\\t\\tprint(t + q)\\n\\t\\ndef __starting_point():\\n\\tmain()\\n\\n__starting_point()\", \"q=int(input())\\nfor _ in range(q):\\n  c,m,x=map(int,input().split())\\n  if c<m:\\n    c,m,x=c,c,x+m-c\\n  elif c>m:\\n    c,m,x=m,m,x+c-m\\n  ans=min(c,m,x)\\n  if c>x:\\n    ans+=2*(c-x)//3\\n  print(ans)\"]", "input_output": "{\n  \"inputs\": [\n    \"6\\n1 1 1\\n3 6 0\\n0 0 0\\n0 1 1\\n10 1 10\\n4 4 1\\n\"\n  ],\n  \"outputs\": [\n    \"1\\n3\\n0\\n0\\n1\\n3\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1221/C", "starter_code": ""}
{"id": 99, "question": "Lee was cleaning his house for the party when he found a messy string under the carpets. Now he'd like to make it clean accurately and in a stylish way...\n\nThe string $s$ he found is a binary string of length $n$ (i. e. string consists only of 0-s and 1-s).\n\nIn one move he can choose two consecutive characters $s_i$ and $s_{i+1}$, and if $s_i$ is 1 and $s_{i + 1}$ is 0, he can erase exactly one of them (he can choose which one to erase but he can't erase both characters simultaneously). The string shrinks after erasing.\n\nLee can make an arbitrary number of moves (possibly zero) and he'd like to make the string $s$ as clean as possible. He thinks for two different strings $x$ and $y$, the shorter string is cleaner, and if they are the same length, then the lexicographically smaller string is cleaner.\n\nNow you should answer $t$ test cases: for the $i$-th test case, print the cleanest possible string that Lee can get by doing some number of moves.\n\nSmall reminder: if we have two strings $x$ and $y$ of the same length then $x$ is lexicographically smaller than $y$ if there is a position $i$ such that $x_1 = y_1$, $x_2 = y_2$,..., $x_{i - 1} = y_{i - 1}$ and $x_i < y_i$.\n\n\n-----Input-----\n\nThe first line contains the integer $t$ ($1 \\le t \\le 10^4$)\u00a0\u2014 the number of test cases. \n\nNext $2t$ lines contain test cases\u00a0\u2014 one per two lines.\n\nThe first line of each test case contains the integer $n$ ($1 \\le n \\le 10^5$)\u00a0\u2014 the length of the string $s$.\n\nThe second line contains the binary string $s$. The string $s$ is a string of length $n$ which consists only of zeroes and ones.\n\nIt's guaranteed that sum of $n$ over test cases doesn't exceed $10^5$.\n\n\n-----Output-----\n\nPrint $t$ answers\u00a0\u2014 one per test case.\n\nThe answer to the $i$-th test case is the cleanest string Lee can get after doing some number of moves (possibly zero).\n\n\n-----Example-----\nInput\n5\n10\n0001111111\n4\n0101\n8\n11001101\n10\n1110000000\n1\n1\n\nOutput\n0001111111\n001\n01\n0\n1\n\n\n\n-----Note-----\n\nIn the first test case, Lee can't perform any moves.\n\nIn the second test case, Lee should erase $s_2$.\n\nIn the third test case, Lee can make moves, for example, in the following order: 11001101\u00a0$\\rightarrow$ 1100101\u00a0$\\rightarrow$ 110101\u00a0$\\rightarrow$ 10101\u00a0$\\rightarrow$ 1101\u00a0$\\rightarrow$ 101\u00a0$\\rightarrow$ 01.", "solutions": "[\"for _ in range(int(input())):\\n    # a, b = map(int, input().split())\\n    n = int(input())\\n    # arr = list(map(int, input().split()))\\n    s = input()\\n    l = 0\\n    r = n - 1\\n    if s.count('0') == n:\\n        print(s)\\n        continue\\n    if s.count('1') == n:\\n        print(s)\\n        continue\\n    while s[l] == '0':\\n        l += 1\\n    while s[r] == '1':\\n        r -= 1\\n    if r <= l:\\n        print(s)\\n        continue\\n    print(l * '0' + '0' + (n - r - 1) * '1')\", \"ans = []\\nfor _ in range(int(input())):\\n    n = int(input())\\n    u = list(map(int, list(input())))\\n    for i in range(n):\\n        if u[i] == 1:\\n            i1 = i\\n            break\\n    else:\\n        ans.append(''.join(map(str, u)))\\n        continue\\n    for i in range(n - 1, -1, -1):\\n        if u[i] == 0:\\n            i2 = i\\n            break\\n    else:\\n        ans.append(''.join(map(str, u)))\\n        continue\\n    if i2 < i1:\\n        ans.append(''.join(map(str, u)))\\n        continue\\n    u1 = '0' * i1 + '0' + '1' * (n - i2 - 1)\\n    ans.append(u1)\\nprint('\\\\n'.join(ans))\\n\", \"def solve():\\n    n = int(input())\\n    st = input()\\n    pref0 = 0\\n    for i in st:\\n        if i == \\\"0\\\":\\n            pref0 += 1\\n        else:\\n            break\\n    post1 = 0\\n    for i in st[::-1]:\\n        if i == \\\"1\\\":\\n            post1 += 1\\n        else:\\n            break\\n    if n != post1 + pref0:\\n        print(pref0 *\\\"0\\\"+\\\"0\\\"+post1*\\\"1\\\")\\n    else:\\n        print(pref0 * \\\"0\\\" + post1 * \\\"1\\\")\\nfor i in range(int(input())):\\n    solve()\", \"#list(map(int,input().split()))\\nt=int(input())\\nfor _ in range(t):\\n    n=int(input())\\n    s=input()\\n    co=0\\n    for i in range(n):\\n        if(s[i]=='1'):\\n            break\\n        print('0',end=\\\"\\\")\\n        co+=1\\n    ind=n\\n    \\n    for i in range(n-1,-1,-1):\\n        if(s[i]=='0'):\\n            break\\n        ind=i\\n    if(co-1<ind-1):\\n        print('0',end=\\\"\\\")\\n    for i in range(ind,n):\\n        print('1',end=\\\"\\\")\\n    print()\\n    \\n    \\n    \\n\", \"for test_i in range(int(input())):\\n    n = int(input())\\n    s = input()\\n    l1 = 0\\n    while l1 < n:\\n        if s[-l1 - 1] == '1':\\n            l1 += 1\\n        else:\\n            break\\n    l0 = 0\\n    while l0 < n:\\n        if s[l0] == '0':\\n            l0 += 1\\n        else:\\n            break\\n    if l0 + l1 < len(s):\\n        print('0' * (l0 + 1) + '1' * l1)\\n    else:\\n        print('0' * l0 + '1' * l1)\", \"import sys\\ninput = sys.stdin.readline\\n\\nQ = int(input())\\nQuery = []\\nfor _ in range(Q):\\n    N = int(input())\\n    S = input().rstrip()\\n    Query.append((N, S))\\n\\nfor N, S in Query:\\n    i1 = N\\n    while i1 > 0 and S[i1-1] == \\\"1\\\":\\n        i1 -= 1\\n    i2 = -1\\n    while i2 +1< N-1 and S[i2+1] == \\\"0\\\":\\n        i2 += 1\\n    \\n    if i2 + 1 == i1:\\n        tmp = \\\"\\\"\\n    else:\\n        tmp = \\\"0\\\"\\n    ans = \\\"0\\\"*(i2+1) + tmp + \\\"1\\\"*(N-i1)\\n    print(ans)\", \"import sys\\nfrom functools import lru_cache, cmp_to_key\\nfrom heapq import merge, heapify, heappop, heappush\\nfrom math import *\\nfrom collections import defaultdict as dd, deque, Counter as C\\nfrom itertools import combinations as comb, permutations as perm\\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\\nfrom time import perf_counter\\nfrom fractions import Fraction\\n# import numpy as np\\nsys.setrecursionlimit(int(pow(10,6)))\\n# sys.stdin = open(\\\"input.txt\\\", \\\"r\\\")\\n# sys.stdout = open(\\\"output.txt\\\", \\\"w\\\")\\nmod = int(pow(10, 9) + 7)\\nmod2 = 998244353\\ndef data(): return sys.stdin.readline().strip()\\ndef out(*var, end=\\\"\\\\n\\\"): sys.stdout.write(' '.join(map(str, var))+end)\\ndef l(): return list(sp())\\ndef sl(): return list(ssp())\\ndef sp(): return map(int, data().split())\\ndef ssp(): return map(str, data().split())\\ndef l1d(n, val=0): return [val for i in range(n)]\\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\\n\\n# @lru_cache(None)\\nterm=l()[0]\\n# term=1\\n\\nfor _ in range(term):\\n    n=l()[0]\\n    s=list(input())\\n    i=0\\n    while(i<n and s[i]!=\\\"1\\\"):\\n        i+=1\\n    j=n-1\\n    while j>=0 and s[j]!=\\\"0\\\":\\n        j-=1\\n    if(i<j+1):\\n        del(s[i:j])\\n    print(\\\"\\\".join(s))\", \"for nt in range(int(input())):\\n\\tn = int(input())\\n\\ts = input()\\n\\tif \\\"1\\\" not in s:\\n\\t\\tprint (s)\\n\\t\\tcontinue\\n\\tans = \\\"\\\"\\n\\tfor i in range(n):\\n\\t\\tif s[i]==\\\"0\\\":\\n\\t\\t\\tans += s[i]\\n\\t\\telse:\\n\\t\\t\\tind = i\\n\\t\\t\\tbreak\\n\\ttemp = \\\"\\\"\\n\\tfor i in range(n-1,ind-1,-1):\\n\\t\\tif s[i]==\\\"0\\\":\\n\\t\\t\\tans += \\\"0\\\"\\n\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\ttemp += \\\"1\\\"\\n\\tans += temp\\n\\tprint (ans)\\n\", \"from sys import stdin, stdout\\nimport math\\n\\nt = int(stdin.readline())\\nfor _ in range(t):\\n    n = int(stdin.readline())\\n    s = stdin.readline().strip()\\n    st, end = float('inf'), -1\\n    for i in range(n):\\n        if s[i] == '1':\\n            st = i\\n            break\\n\\n    for i in range(n-1, -1, -1):\\n        if s[i] == '0':\\n            end = i\\n            break\\n\\n    if st < end:\\n        print(s[:st]+'0'+s[end+1:])\\n    else:\\n        print(s)\\n\\n\\n\", \"from itertools import groupby as gb\\n\\nt = int(input())\\n\\nfor _ in range(t):\\n    n = int(input())\\n    s = input()\\n    if s.count('10') == 0:\\n        print(s)\\n        continue\\n    res = \\\"\\\"\\n    suf = \\\"\\\"\\n    l = [(k, len(list(v))) for k, v in gb(s)]\\n    if len(l) > 0 and l[0][0] == '0':\\n        res += l[0][0] * l[0][1]\\n        l = l[1:]\\n    if len(l) > 0 and l[-1][0] == '1':\\n        suf = l[-1][0] * l[-1][1]\\n        l = l[:-1]\\n    print(res + '0' + suf)\\n\", \"import math\\n\\n\\ndef main():\\n    n = int(input())\\n    line = input()\\n    zero = 0\\n    one = 0\\n    i = 0\\n    while i < n and line[i] == '0':\\n        zero += 1\\n        i += 1\\n    i = n - 1\\n    while i > -1 and line[i] == '1':\\n        one += 1\\n        i -= 1\\n    zr = False\\n    on = False\\n    for i in range(n):\\n        if line[i] == '0':\\n            zr = True\\n    for i in range(n - 1, -1, -1):\\n        if line[i] == \\\"0\\\":\\n            on = True\\n        if line[i] == \\\"1\\\" and on:\\n            zero += 1\\n            break\\n    if zero == 0 and one == 0:\\n        if zr:\\n            print(0)\\n        else:\\n            print(1)\\n    else:\\n        line = \\\"\\\"\\n        for k in range(zero):\\n            line += \\\"0\\\"\\n        for k in range(one):\\n            line += \\\"1\\\"\\n        print(line)\\n\\ndef __starting_point():\\n    t = int(input())\\n    for i in range(t):\\n        main()\\n\\n__starting_point()\", \"for _ in range(int(input())):\\n    n = int(input())\\n    s = input()\\n    if n == 1:\\n        print(s)\\n        continue\\n    zero = -1\\n    one = -1\\n    for i in range(n):\\n        if s[i] == \\\"0\\\":\\n            zero = i\\n        if s[i] == \\\"1\\\" and one < 0:\\n            one = i\\n    if zero < one or one == -1 or zero == -1:\\n        print(s)\\n    else:\\n        print((one+1) * \\\"0\\\" + (n-zero-1) * \\\"1\\\")\\n\", \"# Contest No.: 652\\n# Problem No.: B\\n# Solver:      JEMINI\\n# Date:        20200623\\n\\nimport sys\\nimport heapq\\n\\ndef main():\\n    t = int(input())\\n    for _ in range(t):\\n        n = int(sys.stdin.readline().strip())\\n        s = sys.stdin.readline().strip()\\n        if (\\\"1\\\" in s and \\\"0\\\" not in s) or (\\\"1\\\" not in s and \\\"0\\\" in s):\\n            print(s)\\n            continue\\n        lPoint = 0\\n        while s[lPoint] == \\\"0\\\":\\n            lPoint += 1\\n        rPoint = n - 1\\n        while s[rPoint] == \\\"1\\\":\\n            rPoint -= 1\\n        \\n        if lPoint > rPoint:\\n            print(s)\\n            continue\\n        \\n        if lPoint != n - 1:\\n            ans = s[:lPoint]\\n        else:\\n            ans = \\\"\\\"\\n        \\n        ans += \\\"0\\\"\\n\\n        if rPoint != n - 1:\\n            ans += s[rPoint + 1:]\\n        print(ans)\\n        \\n\\n    return\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\nfor tests in range(t):\\n    n=int(input())\\n    S=input().strip()\\n\\n    OPENING=-1\\n    for i in range(n):\\n        if S[i]==\\\"1\\\":\\n            OPENING=i\\n            break\\n\\n    ENDING=n\\n    for i in range(n-1,-1,-1):\\n        if S[i]==\\\"0\\\":\\n            ENDING=i\\n            break\\n\\n    if OPENING==-1 or ENDING==n:\\n        print(S)\\n    elif OPENING>ENDING:\\n        print(S)\\n    else:\\n        print(\\\"\\\".join(map(str,[0]*(OPENING+1)+[1]*(n-1-ENDING))))\\n        \\n\", \"for _ in range(int(input())):\\n    #n, m = map(int, input().split())\\n    #A = list(map(int, input().split()))\\n    n = int(input())\\n    s = input()\\n    if s == '0' * n or s == '1' * n:\\n        print(s)\\n\\n    else:\\n\\n        i = 0\\n        while s[i] == '0':\\n            i += 1\\n        j = n - 1\\n        while s[j] == '1':\\n            j -= 1\\n        if '1' in s[i:j + 1] and '0' in s[i:j + 1]:\\n            print(s[:i] + '0' + s[j + 1:])\\n        else:\\n            print(s)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"5\\n10\\n0001111111\\n4\\n0101\\n8\\n11001101\\n10\\n1110000000\\n1\\n1\\n\"\n  ],\n  \"outputs\": [\n    \"0001111111\\n001\\n01\\n0\\n1\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1369/B", "starter_code": ""}
{"id": 100, "question": "You have three piles of candies: red, green and blue candies:  the first pile contains only red candies and there are $r$ candies in it,  the second pile contains only green candies and there are $g$ candies in it,  the third pile contains only blue candies and there are $b$ candies in it. \n\nEach day Tanya eats exactly two candies of different colors. She is free to choose the colors of eaten candies: the only restriction that she can't eat two candies of the same color in a day.\n\nFind the maximal number of days Tanya can eat candies? Each day she needs to eat exactly two candies.\n\n\n-----Input-----\n\nThe first line contains integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases in the input. Then $t$ test cases follow.\n\nEach test case is given as a separate line of the input. It contains three integers $r$, $g$ and $b$ ($1 \\le r, g, b \\le 10^8$) \u2014 the number of red, green and blue candies, respectively.\n\n\n-----Output-----\n\nPrint $t$ integers: the $i$-th printed integer is the answer on the $i$-th test case in the input.\n\n\n-----Example-----\nInput\n6\n1 1 1\n1 2 1\n4 1 1\n7 4 10\n8 1 4\n8 2 8\n\nOutput\n1\n2\n2\n10\n5\n9\n\n\n\n-----Note-----\n\nIn the first example, Tanya can eat candies for one day only. She can eat any pair of candies this day because all of them have different colors.\n\nIn the second example, Tanya can eat candies for two days. For example, she can eat red and green candies on the first day, and green and blue candies on the second day.\n\nIn the third example, Tanya can eat candies for two days. For example, she can eat red and green candies on the first day, and red and blue candies on the second day. Note, that two red candies will remain uneaten.", "solutions": "[\"n = int(input())\\n\\nfor _ in range(n):\\n    a, b, c = list(map(int, input().split()))\\n\\n    print(min((a+b+c)//2, a+b, a+c, b+c))\\n\", \"t = int(input())\\nfor _ in range(t):\\n    li = list(map(int, input().split()))\\n    li = sorted(li)\\n    if li[0] + li[1] <= li[2]:\\n        print(li[0] + li[1])\\n    else:\\n        print(sum(li) // 2)\", \"for _ in range(int(input())):\\n\\tl = sorted(map(int, input().split()))\\n\\tprint(min(sum(l) // 2, l[0] + l[1]))\", \"for _ in range(int(input())):\\n\\tl=sorted(list(map(int,input().split())))\\n\\tprint(min(l[0]+l[1],sum(l)//2))\", \"t=int(input())\\nfor _ in range(t):\\n    a,b,c=list(map(int,input().split()))\\n    a,b,c=sorted([a,b,c])\\n    aa=a\\n    bb=b\\n    cc=c\\n    d=c-b\\n    c-=min(d,a)\\n    a-=min(a,d)\\n    b-=min(a//2,0)\\n    a-=min(a//2,0)\\n    c-=min(a,0)\\n    a-=min(a,0)\\n    b,c=sorted([b,c])\\n    c-=b\\n    b=0\\n    print((aa+bb+cc-c)//2)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\nfor testcases in range(t):\\n    r,g,b=sorted(map(int,input().split()))\\n\\n    if b>r+g:\\n        print(r+g)\\n    else:\\n        print((r+g+b)//2)\\n\\n    \\n\", \"t = int(input())\\nfor i in range (t):\\n    r, g, b = list(map(int,input().split()))\\n    maxi = max(r, g, b)\\n    total = r + g + b\\n    if 2 * maxi > total:\\n        print(total - maxi)\\n    else:\\n        print(total//2)\", \"q=int(input())\\nfor i in range(q):\\n    r=[int(x) for x in input().split()]\\n    print(min(int(sum(r)/2),sum(r)-max(r)))\", \"T = int(input())\\nfor t in range(T):\\n    a, b, c = sorted(map(int, input().strip().split()))\\n    d = c - b\\n    v = a\\n    if d > a:\\n        v += min(c - a, b)\\n    else:\\n        a -= d\\n        c -= d + a // 2\\n        b -= a - a // 2\\n        v += min(c, b)\\n    print(v)\\n\", \"for i in range(int(input())):\\n\\ta = sorted([int(i) for i in input().split()])\\n\\tprint(min(a[0]+a[1], sum(a)//2))\", \"\\nt = int(input())\\n\\nfor _ in range(t):\\n    r, g, b = sorted(map(int, input().split()))\\n    s = sum([r, g, b])\\n    print(min([r + g, s // 2]))\\n\", \"def solve():\\n    r,g,b = map(int, input().split())\\n    a,b,c = sorted([r,g,b])\\n    if a+b <= c:\\n        ans = a+b\\n    else:\\n        ans = a+b+c\\n        ans //= 2\\n    print(ans)\\n\\nt = int(input())\\nfor i in range(t):\\n    solve()\", \"# https://codeforces.com/contest/1263/problem/A\\n\\nt = int(input())\\nfor i in range(t):\\n    rgb = list(map(int, input().split()))\\n    rgb.sort()\\n    ans = min(sum(rgb) // 2, sum(rgb[:2]))\\n    print(ans)\\n\", \"t=int(input())\\nfor ij in range(0,t):\\n\\tl=list(map(int,input().split()))\\n\\tl=sorted(l)\\n\\tif l[2]>l[1]+l[0]:\\n\\t\\tprint(l[1]+l[0])\\n\\telse:\\n\\t\\tprint(sum(l)//2)\", \"a = int(input())\\nfor i in range(a):\\n    x, y, z = map(int, input().split())\\n    x, y, z = sorted([x, y, z])\\n    k = z - y\\n    if k == 0:\\n        y += x//2\\n        print(y)\\n    elif k > x:\\n        y += x\\n        print(y)\\n    else:\\n        x -= z - y\\n        y = z\\n        z += x//2\\n        print(z)\", \"import sys\\n\\n# sys.stdin = open(\\\"in.txt\\\")\\nfor _ in range(int(input())):\\n    a, b, c = sorted(list(map(int, input().split())))\\n    print((a + b + c - max(0, c - (a + b))) // 2)\\n    # res = min(a, b)\\n    # a -= res\\n    # b -= res\\n    # res2 = min(b, c)\\n    # b -= res2\\n    # c -= res2\\n    # res3 = min(a, c)\\n    # a -= res3\\n    # c -= res3\\n    # print(res + res2 + res3)\\n\", \"n = int(input())\\nfor i in range(n):\\n    a = sorted(list(map(int, input().split())))\\n    if a[2] >= a[0]+a[1]:\\n        print(a[0]+a[1])\\n    else:\\n        print(a[2]+(a[0]+a[1]-a[2])//2)\", \"sp = lambda: list(map(int, input().split()))\\nsi = lambda: int(input())\\n\\nTESTCASES = int(input())\\nfor tc in range(TESTCASES):\\n    r,g,b=sorted(sp())\\n    if b>r+g: b=r+g\\n    print((r+g+b)//2)\", \"t = int(input())\\nfor i in range(t):\\n    r, g, b = list(map(int, input().split()))\\n    if 2 * max(r, g, b) >= (r + g + b):\\n        print(r + g + b - max(r, g, b))\\n    else:\\n        print((r + g + b) // 2)\\n\", \"t=int(input())\\nfor i in range(t):\\n  r,g,b = map(int,input().split())\\n  arr = [r,g,b]\\n  arr.sort()\\n  diff = arr[2]-arr[1]\\n  arr[2] -= arr[0]\\n  if arr[2] < arr[1]:\\n    arr[2] = int((arr[1]+arr[2])/2)\\n    arr[1] = arr[2]\\n  print(arr[0]+min(arr[2],arr[1]))\", \"for _ in range(int(input())):\\n    l =list( map( int, input().split()) )\\n    l.sort()\\n    s, m , b = l\\n    a = s\\n    c = min( s, b - m )\\n    s -= c\\n    b -= c\\n    b -= s // 2\\n    m -= s - s // 2\\n    a += min( m, b )\\n    print( a )\\n\\n\", \"n = int(input())\\nwhile n != 0:\\n    n -= 1\\n    a = list(map(int, input().split()))\\n    a.sort()\\n    if a[0] + a[1] >= a[2]:\\n        print(sum(a)//2)\\n    else:\\n        print(a[0] + a[1])\", \"import sys\\n\\n\\n# inf = open('input.txt', 'r')\\n# reader = (map(int, line.split()) for line in inf)\\nreader = (list(map(int, s.split())) for s in sys.stdin)\\n\\ndef sweets(r, g, b):\\n    total = g - r\\n    g -= total\\n    b -= total\\n    if b > r + g:\\n        total += r + g\\n    else:\\n        total += (r + b + g) // 2\\n        \\n    return total\\n\\nt, = next(reader)\\nfor _ in range(t):\\n    r, g, b = sorted(list(next(reader)))\\n    ans = sweets(r, g, b)\\n    print(ans)\\n    \\n# inf.close()\\n\", \"#!/usr/bin/env python3\\nimport sys\\ninput = sys.stdin.readline\\n\\nt = int(input())\\nfor i in range(t):\\n    candy = [int(item) for item in input().split()]\\n    candy.sort(reverse=True)\\n    total = sum(candy)\\n    if candy[0] <= candy[1] + candy[2]:\\n        print((total - total % 2) // 2)\\n    else:\\n        print(total - (candy[0] - candy[1] - candy[2]) // 2)\", \"from math import *\\nfrom collections import *\\nimport sys\\nsys.setrecursionlimit(10**9)\\n\\nt = int(input())\\nfor y in range(t):\\n\\tr,g,b = list(map(int,input().split()))\\n\\tm = max(r,g,b)\\n\\tif(r + g + b - m >= m):\\n\\t\\tans = (r+g+b)//2\\n\\telse:\\n\\t\\tans = r+g+b - m\\n\\tprint(ans)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"6\\n1 1 1\\n1 2 1\\n4 1 1\\n7 4 10\\n8 1 4\\n8 2 8\\n\"\n  ],\n  \"outputs\": [\n    \"1\\n2\\n2\\n10\\n5\\n9\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1263/A", "starter_code": ""}
{"id": 101, "question": "Polycarp lives on the coordinate axis $Ox$ and travels from the point $x=a$ to $x=b$. It moves uniformly rectilinearly at a speed of one unit of distance per minute.\n\nOn the axis $Ox$ at the point $x=c$ the base station of the mobile operator is placed. It is known that the radius of its coverage is $r$. Thus, if Polycarp is at a distance less than or equal to $r$ from the point $x=c$, then he is in the network coverage area, otherwise\u00a0\u2014 no. The base station can be located both on the route of Polycarp and outside it.\n\nPrint the time in minutes during which Polycarp will not be in the coverage area of the network, with a rectilinear uniform movement from $x=a$ to $x=b$. His speed\u00a0\u2014 one unit of distance per minute.\n\n\n-----Input-----\n\nThe first line contains a positive integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases. In the following lines are written $t$ test cases.\n\nThe description of each test case is one line, which contains four integers $a$, $b$, $c$ and $r$ ($-10^8 \\le a,b,c \\le 10^8$, $0 \\le r \\le 10^8$)\u00a0\u2014 the coordinates of the starting and ending points of the path, the base station, and its coverage radius, respectively.\n\nAny of the numbers $a$, $b$ and $c$ can be equal (either any pair or all three numbers). The base station can be located both on the route of Polycarp and outside it.\n\n\n-----Output-----\n\nPrint $t$ numbers\u00a0\u2014 answers to given test cases in the order they are written in the test. Each answer is an integer\u00a0\u2014 the number of minutes during which Polycarp will be unavailable during his movement.\n\n\n-----Example-----\nInput\n9\n1 10 7 1\n3 3 3 0\n8 2 10 4\n8 2 10 100\n-10 20 -17 2\n-3 2 2 0\n-3 1 2 0\n2 3 2 3\n-1 3 -2 2\n\nOutput\n7\n0\n4\n0\n30\n5\n4\n0\n3\n\n\n\n-----Note-----\n\nThe following picture illustrates the first test case.  [Image] Polycarp goes from $1$ to $10$. The yellow area shows the coverage area of the station with a radius of coverage of $1$, which is located at the point of $7$. The green area shows a part of the path when Polycarp is out of coverage area.", "solutions": "[\"import os\\nfrom io import BytesIO\\n\\n# input = BytesIO(os.read(0, os.fstat(0).st_size)).readline\\nfor i in range(int(input())):\\n    a, b, c, r = list(map(int, input().split()))\\n    a, b = min(a, b), max(a, b)\\n    left = max(c - r, a)\\n    right = min(c + r, b)\\n    if right >= a and left <= right:\\n        print(b - a - (right - left))\\n    else:\\n        print(b - a)\\n\", \"from math import *\\nimport os, sys\\nfrom io import BytesIO\\n\\n#input = BytesIO(os.read(0, os.fstat(0).st_size)).readline\\nsys.setrecursionlimit(10 ** 9)\\n#sys.stdin = open(\\\"moobuzz.in\\\", 'r')\\n#sys.stdout = open(\\\"moobuzz.out\\\", 'w')\\n\\n\\nfor i in range(int(input())):\\n\\ta, b, c, r = list(map(int, input().split()))\\n\\tc1 = c - r\\n\\tc2 = c + r\\n\\td1 = max(min(a, b), min(c1, c2))\\n\\td2 = min(max(a, b), max(c1, c2))\\n\\tprint(abs(b - a) - max(d2 - d1, 0))\\n\", \"t = int(input())\\nfor i in range(t):\\n    a, b, c, r = list(map(int, input().split()))\\n\\n    s = max(min(a, b), c - r)\\n    f = min(max(a, b), c + r)\\n\\n    l = max(0, f - s)\\n    print(abs(a - b) - l)\\n\", \"#!/usr/bin/env python3\\n# coding: utf-8\\n# Last Modified: 24/Dec/19 08:08:49 PM\\n\\n\\nimport sys\\n\\n\\ndef main():\\n    for tc in range(int(input())):\\n        a, b, c, r = get_ints()\\n\\n        if a > b:\\n            a, b = b, a\\n\\n        arr = [c - r, c + r]\\n\\n        ans = 0\\n\\n        if a > c + r:\\n            print(abs(b - a))\\n            continue\\n\\n        if b < c - r:\\n            print(abs(b - a))\\n            continue\\n\\n        if a < c - r:\\n            ans += abs(a - (c - r))\\n\\n        if b > c + r:\\n            ans += abs(b - (c + r))\\n\\n        print(ans)\\n\\n\\nget_array = lambda: list(map(int, sys.stdin.readline().split()))\\n\\n\\nget_ints = lambda: list(map(int, sys.stdin.readline().split()))\\n\\n\\ninput = lambda: sys.stdin.readline().strip()\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"for _ in range(int(input())):\\n    a,b,c,r=map(int,input().split())\\n    a,b=min(a,b),max(a,b)\\n    n = b - a\\n    l,f = c-r,c+r\\n    if a>l:\\n        a,b,l,f=l,f,a,b\\n    # print (a,b,l,f)\\n\\n    if l >= b:\\n        print (n)\\n    else:\\n        if f <= b:\\n            print (n - (f - l))\\n        else:\\n            print (n - (b - l))\", \"t = int(input())\\nfor i in range(t):\\n\\ta, b, c, r = list(map(int, input().split()))\\n\\tif b < a:\\n\\t\\ta, b = b, a\\n\\tk = min(c + r, b) - max(c - r, a)\\n\\td = b - a\\n\\tif k <= 0:\\n\\t\\tprint(d)\\n\\telse:\\n\\t\\tprint(d - k)\\n\", \"import sys\\n\\ndef minp():\\n\\treturn sys.stdin.readline().strip()\\n\\ndef mint():\\n\\treturn int(minp())\\n\\ndef mints():\\n\\treturn list(map(int,minp().split()))\\n\\ndef solve():\\n\\ta,b,c,r = mints()\\n\\tif a > b:\\n\\t\\ta, b = b, a\\n\\treturn b-a-max(min(c+r,b)-max(c-r,a), 0)\\n\\nfor i in range(mint()):\\n\\tprint(solve())\\n\", \"for tcase in range(int(input())):\\n    a,b,c,r = list(map(int, input().split()))\\n\\n    ca, cb = c-r, c+r\\n\\n    a,b = min(a,b), max(a,b)\\n\\n    if b<=ca:\\n        print(b-a)\\n    elif cb<=a:\\n        print(b-a)\\n    elif a<=ca<=b<=cb:\\n        print(ca-a)\\n    elif ca<=a<=cb<=b:\\n        print(b-cb)\\n    elif a<=ca<=cb<=b:\\n        print((ca-a)+(b-cb))\\n    elif ca<=a<=b<=cb:\\n        print(0)\\n    else:\\n        print(0)\\n\", \"import sys\\nfrom collections import Counter\\nfrom math import *\\n\\n# sys.stdin = open(\\\"in.txt\\\")\\nfor _ in range(int(input())):\\n    a, b, c, r = map(int, input().split())\\n    if b < a:\\n        a, b = b, a\\n    res1 = max(a, c - r)\\n    res2 = min(b, c + r)\\n    print(max(0, b - a - max(0, res2 - res1)))\", \"for _ in range(int(input())):\\n\\ta,b,c,r = map(int,input().split())\\n\\tif a > b: a,b = b,a\\n\\tx = max(c-r,a)\\n\\ty = min(c+r,b)\\n\\tans = b-a\\n\\tans -= max(0,y-x) \\n\\tprint(max(ans,0))\\t\\t\", \"for _ in range(int(input())):\\n    a, b, c, r = list(map(int, input().split()))\\n    if a > b:\\n        a, b = b, a\\n    x, y = c - r, c + r\\n    d = max(0, min(b, y) - max(x, a))\\n    print(b - a - d)\\n\", \"t = int(input())\\n\\nfor _ in range(t):\\n    a, b, c, r = list(map(int, input().strip().split()))\\n    a, b = min(a,b), max(a, b)\\n    \\n    low = max(a, c-r)\\n    high = min(b, c+r)\\n    unavaialbe = high - low\\n    unavaialbe = max(unavaialbe, 0)\\n    print(b - a - unavaialbe)\\n\", \"t = int(input())\\nwhile t>0:\\n    t-=1\\n    a,b,c,r = map(int,input().split())\\n    if a>b:\\n        a,b=b,a\\n    print(min(max((c-r)-a,0)+max(b-(c+r),0),abs(b-a)))\", \"t = int(input())\\nfor _ in range(t):\\n    a, b, c, r = list(map(int, input().split()))\\n    if b < a:\\n        a, b = b, a\\n    ans = 0\\n    if c < a:\\n        if c + r < a:\\n            ans = b - a\\n        else:\\n            ans = max(b - (c + r), 0)\\n    elif c > b:\\n        if c - r > b:\\n            ans = b - a\\n        else:\\n            ans = max((c - r) - a, 0)\\n    else:\\n        ans += max(0, b - (c + r)) + max(0, c - r - a)\\n    print(ans)\\n\", \"from sys import stdin, exit\\nfrom math import *\\n\\ndef main():\\n    def len_intersect(a, b, c, d):\\n        if d <= a or c >= b:\\n            return 0\\n        u, v = (max(a, c), min(b, d))\\n        return max(0, v - u)\\n\\n    for testcase in range(int(stdin.readline())):\\n        a, b, c, r = list(map(int, stdin.readline().split()))\\n        if a > b:\\n            a, b = b, a\\n        print(b - a - len_intersect(a, b, c - r, c + r))\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"for i in range(int(input())):\\n    a,b,c,r=map(int,input().split())\\n    x=c-r\\n    y=c+r\\n    if a>b:a,b=b,a\\n    z=max(0,min(y,b)-max(x,a))\\n    print(b-a-z)\"]", "input_output": "{\n  \"inputs\": [\n    \"9\\n1 10 7 1\\n3 3 3 0\\n8 2 10 4\\n8 2 10 100\\n-10 20 -17 2\\n-3 2 2 0\\n-3 1 2 0\\n2 3 2 3\\n-1 3 -2 2\\n\"\n  ],\n  \"outputs\": [\n    \"7\\n0\\n4\\n0\\n30\\n5\\n4\\n0\\n3\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1282/A", "starter_code": ""}
{"id": 102, "question": "Hooray! Polycarp turned $n$ years old! The Technocup Team sincerely congratulates Polycarp!\n\nPolycarp celebrated all of his $n$ birthdays: from the $1$-th to the $n$-th. At the moment, he is wondering: how many times he turned beautiful number of years?\n\nAccording to Polycarp, a positive integer is beautiful if it consists of only one digit repeated one or more times. For example, the following numbers are beautiful: $1$, $77$, $777$, $44$ and $999999$. The following numbers are not beautiful: $12$, $11110$, $6969$ and $987654321$.\n\nOf course, Polycarpus uses the decimal numeral system (i.e. radix is 10).\n\nHelp Polycarpus to find the number of numbers from $1$ to $n$ (inclusive) that are beautiful.\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases in the input. Then $t$ test cases follow.\n\nEach test case consists of one line, which contains a positive integer $n$ ($1 \\le n \\le 10^9$) \u2014 how many years Polycarp has turned.\n\n\n-----Output-----\n\nPrint $t$ integers \u2014 the answers to the given test cases in the order they are written in the test. Each answer is an integer: the number of beautiful years between $1$ and $n$, inclusive.\n\n\n-----Example-----\nInput\n6\n18\n1\n9\n100500\n33\n1000000000\n\nOutput\n10\n1\n9\n45\n12\n81\n\n\n\n-----Note-----\n\nIn the first test case of the example beautiful years are $1$, $2$, $3$, $4$, $5$, $6$, $7$, $8$, $9$ and $11$.", "solutions": "[\"s = []\\nfor i in range(1, 10):\\n    k = 0\\n    for l in range(1, 10):\\n        k *= 10\\n        k += i\\n        s.append(k)\\ns.sort()\\nq = int(input())\\nwhile q:\\n    n = int(input())\\n    l = 0\\n    r = len(s)\\n    while l + 1 < r:\\n        m = (l + r) // 2\\n        if s[m] <= n:\\n            l = m\\n        else:\\n            r = m\\n    print(r)\\n    q -= 1\", \"t = int(input())\\nfor i in range(t):\\n    ans = 0\\n    n = int(input())\\n    for i in range(1, 10):\\n        now = i\\n        while now <= n:\\n            now *= 10\\n            now += i\\n            ans += 1\\n    print(ans)\", \"for t in range(int(input())):\\n\\tn = int(input())\\n\\ttt = 1\\n\\trazr = 1\\n\\tc = 0\\n\\twhile int(str(tt)*razr) <= n:\\n\\t\\tc += 1\\n\\t\\ttt += 1\\n\\t\\tif tt == 10:\\n\\t\\t\\ttt = 1\\n\\t\\t\\trazr += 1\\n\\tprint(c)\", \"for i in range(int(input())):\\n    n = int(input())\\n    ans = 0\\n    for k in range  (1,11):\\n        for j in range (1,10):\\n            s = str(j)*k\\n            \\n            if int(s) <= n:\\n                ans+=1\\n                \\n    print(ans)\\n\", \"for t in range(int(input())):\\n    a = input()\\n    out = 9 * (len(a) - 1)\\n    for i in range(1, 10):\\n        if(int(a) >= int(str(i) * len(a))):\\n            out += 1\\n        else:\\n            break\\n    print(out)\\n\", \"t=int(input())\\nfor i in range(t):\\n  n=int(input())\\n  count=0\\n  for j in range(1,10):\\n    s=str(j)\\n    while int(s)<=n:\\n      s=s+str(j)\\n      count+=1\\n  print(count)\\n\", \"N = int(input())\\ndef check(n, cifra):\\n    f = cifra\\n    count = 0\\n    while cifra <= n:\\n        cifra = cifra * 10 + f\\n        count += 1\\n    return count\\nfor i in range (N):\\n    a = int(input())\\n    print(check(a, 1) + check(a, 2) + check(a, 3) + check(a, 4) + check(a, 5) + check(a, 6) + check(a, 7) + check(a, 8) + check(a, 9))\", \"q = int(input())\\nwhile q:\\n    a = int(input())\\n    g = len(str(a))\\n    ans = (g - 1)*9\\n    h = (pow(10, g) - 1)/9\\n    x = h\\n    while a - (x + h) >= 0:\\n        x += h\\n    ans += int(str(x)[0])\\n    if x > a:\\n        ans -= 1\\n    print(ans)\\n    q -= 1\\n\", \"tests = int(input())\\nfor test in range(tests):\\n    n = int(input())\\n    l = len(str(n))\\n    c = 0\\n    for i in range(1, l+1):\\n        for j in range(1, 10):\\n            a = int(str(j)*i)\\n            if a <= n:\\n                c += 1\\n    print(c)\\n\", \"for _ in range(int(input())):\\n    limit = int(input())\\n    count = 0\\n    for numb in range(1, 10):\\n        i = 1\\n        while int(str(numb) * i) <= limit:\\n            count += 1\\n            i += 1\\n    print(count)\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    ans = 0\\n    for i in range(1, 10):\\n        s = ''\\n        for j in range(10):\\n            s += str(i)\\n            if int(s) <= n: ans += 1\\n    print(ans)\", \"t = int(input())\\nfor kkk in range(t):\\n    n = int(input())\\n    ans = 0\\n    nn = len(str(n))\\n    for i in range(1, 10):\\n        ans += (nn - (1 if int(str(i) * nn) > n else 0))\\n    print(ans)\\n\", \"t = int(input())\\nall = []\\nfor i in range(1, 10):\\n    for j in range(1, 10):\\n        all.append(int(str(i) * j))\\nfor i in range(t):\\n    n = int(input())\\n    ans = 0\\n    for i in range(len(all)):\\n        if all[i] <= n:\\n            ans += 1\\n    print(ans)\", \"n = int(input())\\nfor i in range(n):\\n    t = int(input())\\n    c = 0\\n    for r in range(1, 10):\\n        for k in range(1, 11):\\n            if int(str(r) * k) <= t:\\n                c += 1\\n    print(c)\\n\", \"t = int(input())\\nans = []\\nfor j in range(t):\\n    n = int(input())\\n    s = ''\\n    k = 0\\n    for i in range(1, 10):\\n        s = str(i)\\n        while int(s) <= n:\\n            k += 1\\n            s += str(i)\\n    ans.append(k)\\nfor i in ans:\\n    print(i)\\n\", \"t = int(input())\\nfor i in range(t):\\n    k = 0\\n    n = input()\\n    k += (len(n) - 1) * 9\\n    if n[0] * len(n) > n:\\n        k += int(n[0]) - 1\\n    else:\\n        k += int(n[0])\\n    print(k)\", \"k = int(input())\\na = []\\nfor i in range(1, 10):\\n        for i1 in range(1, 10):\\n            a.append(str(i) * i1)\\nfor _ in range(k):\\n    n = int(input())\\n    ans = 0\\n    for i1 in a:\\n        if int(i1) <= n:\\n            ans += 1\\n    print(ans)\\n\\n\", \"n = int(input())\\n\\nfor _ in range(n):\\n\\ta = (input())\\n\\n\\tp = (len(a)-1)*9\\n\\n\\tp += int(a[0]) if int(a) >= int(a[0]*len(a)) else int(a[0])-1\\n\\n\\tprint(p)\\n\", \"for i in range(int(input())):\\n    x = int(input())\\n    ans = 0\\n    ans += 9 * (len(str(x)) - 1)\\n    ans += (int(str(x)[0]) - 1)\\n    if int(str(x)[0] * len(str(x))) <= x:\\n        ans += 1\\n    print(ans)\", \"n = int(input())\\n\\nfor i in range(n):\\n    t = int(input())\\n    answer = 0\\n    for i in range(1, 10):\\n        k = i\\n        while k <= t:\\n            answer += 1\\n            k = k * 10 + i\\n    print(answer)\\n\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    l = len(str(n))\\n    ans = (l - 1) * 9\\n    s = str(n)[0]\\n    if n >= int(s * l):\\n        ans += int(s)\\n    else:\\n        ans += int(s) - 1\\n    print(ans)\", \"t = int(input())\\nfor _ in range(t):\\n    n = input()\\n    l = len(n)\\n    n = int(n)\\n    c = 0\\n    for i in range(1, 10):\\n        x = i\\n        while x <= n:\\n            c += 1\\n            x = int(str(x) + str(i))\\n    print(c)\\n\", \"for __ in range(int(input())):\\n    n = int(input())\\n    x = n\\n    num = 0\\n    while x >= 10:\\n        x //= 10\\n        num += 1\\n    ans = num * 9\\n    ans += (n // int('1' * (num + 1)))\\n    print(ans)\", \"g = int(input())\\nfor i in range(g):\\n    a = int(input())\\n    ans = 0\\n    if a >= 10:\\n        ans += 9\\n    else:\\n        ans += a\\n        print(ans)\\n        continue\\n    \\n    for i in range(2, 11):\\n        if 10**i <= a:\\n            ans += 9\\n        else:\\n            for j in range(1, 10):\\n                if int(str(j) * i) <= a:\\n                    ans += 1\\n                else:\\n                    break\\n            break\\n            \\n            \\n    print(ans)\", \"t=int(input())\\nfor i in range(t):\\n    r=int(input())\\n    a=[1,2,3,4,5,6,7,8,9]\\n    ans=0\\n    i=0\\n    while True:\\n        if i==9:\\n            i=0\\n        if a[i]<=r:\\n            ans+=1\\n        if a[i]>r:\\n            break\\n        a[i]=a[i]*10+(a[i]%10)\\n        i+=1\\n    print(ans)\\n\", \"t=int(input())\\nfor i in range(t):\\n    n=int(input())\\n    a=9*(len(str(n))-1)\\n    if n>=int(str(n)[0]*len(str(n))):\\n        print(a+int(str(n)[0]))\\n    else:\\n        print(a+int(str(n)[0])-1)\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    s = str(n)\\n    ans = (len(s) - 1) * 9\\n    for j in range(1, 10):\\n        if int(str(j) * len(s)) <= n:\\n            ans += 1\\n        else:\\n            break\\n    print(ans)\", \"for i in range(int(input())):\\n    n = int(input())\\n    s = len(str(n)) - 1\\n    ans = s * 9\\n    if n >= int(str(n)[0] * (s + 1)):\\n        ans += int(str(n)[0])\\n    else:\\n        ans += int(str(n)[0]) - 1\\n    print(ans)\\n\", \"t = int(input())\\nfor i in range(0, t):\\n    n = input()\\n    ans = 9 * (len(n) - 1)\\n    if int(n) >= int(n[0] * len(n)):\\n        ans += int(n[0])\\n    else:\\n        ans += int(n[0]) - 1\\n    print(ans)\\n\", \"for _ in range(int(input())):\\n\\tN = input()\\n\\tkolvo = (len(N) - 1) * 9\\n\\tfor i in range(1, 10):\\n\\t\\tkolvo += int(str(i) * len(N)) <= int(N)\\n\\tprint(kolvo)\\n\", \"t = int(input())\\narr=[]\\nwhile t > 0:\\n    t -= 1\\n    n = int(input())\\n    ans = 9 * (len(str(n))-1)\\n    for i in range(1, 10):\\n        if int(str(i) * len(str(n))) <= n:\\n            ans += 1\\n    arr.append(ans)\\nprint(*arr, sep=\\\"\\\\n\\\")\", \"a = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '11', '22', '33', '44', '55', '66', '77', '88', '99', '111', '222', '333', '444', '555', '666', '777', '888', '999', '1111', '2222', '3333', '4444', '5555', '6666', '7777', '8888', '9999', '11111', '22222', '33333', '44444', '55555', '66666', '77777', '88888', '99999', '111111', '222222', '333333', '444444', '555555', '666666', '777777', '888888', '999999', '1111111', '2222222', '3333333', '4444444', '5555555', '6666666', '7777777', '8888888', '9999999', '11111111', '22222222', '33333333', '44444444', '55555555', '66666666', '77777777', '88888888', '99999999', '111111111', '222222222', '333333333', '444444444', '555555555', '666666666', '777777777', '888888888', '999999999', '1111111111', '2222222222', '3333333333', '4444444444', '5555555555', '6666666666', '7777777777', '8888888888', '9999999999']\\nt = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    j = 0\\n    ans = 0\\n    while j < len(a) and n >= int(a[j]):\\n        ans += 1\\n        j += 1\\n    print(ans)\", \"t = int(input())\\nfor j in range(t):\\n    n = int(input())\\n    n1 = str(n)\\n    a = 0\\n    while n // 10:\\n        a += 9\\n        n = n // 10\\n    a += n - 1\\n    if str(n) * len(n1) <= n1:\\n        a += 1\\n    print(a)\", \"k = int(input())\\nfor i in range(k):\\n    n = input()\\n    if int(n[0] * len(n)) <= int(n):\\n        print(int(n[0]) + (len(n) - 1) * 9)\\n    else:\\n        print(int(n[0]) - 1 + (len(n) - 1) * 9)\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    ans = 0\\n    for i in range(1, len(str(n)) + 1):\\n        for j in range(1, 10):\\n            if (int(str(j) * i) <= n):\\n                ans += 1\\n    print(ans)\\n\", \"t = int(input())\\n\\nwhile t > 0:\\n    n = int(input())\\n    ans = 0\\n    for i in range(1, 10):\\n        for j in range(1, 10):\\n            if int(str(i) * j) <= n:\\n                #print(str(i) * j)\\n                ans += 1\\n    print(ans)\\n\\n    t -= 1\\n\", \"for i in range(int(input())):\\n    n = int(input())\\n    ch = len(str(n))\\n    ans = 0\\n    for i in range(ch - 1):\\n        ans += 9\\n    for i in range(int('1' * ch), n + 1, int('1' * ch)):\\n        ans += 1\\n    print(ans)\", \"t=int(input())\\nfor i in range(t):\\n    n=int(input())\\n    a=0;p='1';c=1;u=1\\n    while True:\\n        if int(p)<=n:\\n            a+=1\\n        else:\\n            break\\n        c+=1\\n        if c==10:\\n            u+=1\\n            p='1'*u\\n            c=1\\n        else:\\n            p=str(int('1'*u)*c)\\n    print(a)    \", \"t = int(input())\\na = set()\\nfor i in range(1, 10):\\n    s = str(i)\\n    for j in range(1, 11):\\n        a.add(int(j * s))\\nb = list(a)\\nb.sort()\\nfor i in range(t):\\n    n = int(input())\\n    j = 0\\n    while b[j] <= n:\\n        j += 1\\n    print(j)\\n\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    j = 1\\n    while int(\\\"9\\\" * j) <= n:\\n        j += 1\\n    ans = 9 * (j - 1)\\n    for k in range(1, 9):\\n        if int(str(k) * j) <= n:\\n            ans += 1\\n        else:\\n            break\\n    print(ans)\\n\", \"t = int(input())\\n\\nfor i in range(t):\\n    ns = input()\\n    n = int(ns)\\n\\n    ans = 0\\n    s = ''\\n    for j in range(1, len(ns) + 1):\\n        s += '1'\\n        si = int(s)\\n\\n        if si > n:\\n            break\\n\\n        for k in range(1, 10):\\n            if si * k <= n:\\n                ans += 1\\n            else:\\n\\n                break\\n\\n    print(ans)\", \"for _ in range(int(input())):\\n    n = int(input())\\n    i = 1\\n    j = 1\\n    cnt = 0\\n    while True:\\n        if n - int(str(i) * j) >= 0:\\n            cnt += 1\\n        else:\\n            break\\n        i += 1\\n        if i == 10:\\n            i = 1\\n            j += 1\\n    print(cnt)\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    s = str(n)\\n    l = len(s)\\n    x = int(s[0])\\n    nm = int(str(x)*l)\\n    if n - nm < 0:\\n        x -= 1\\n    print((l - 1) * 9 + x)\", \"for t in range(int(input())):\\n    s = 0\\n    n = input()\\n    s += 9 * (len(n) - 1)\\n    if int(n) >= int(n[0] * len(n)):\\n        s += int(n[0])\\n    else:\\n        s += int(n[0]) - 1\\n    print(s)\\n\", \"t=int(input())\\nfor _ in range(t):\\n        n=input()\\n        s=len(n)\\n        n=int(n)\\n        su=(s-1)*9\\n        q='1'*s\\n        q=int(q)\\n        print(su+n//q)\\n\", \"n = int(input())\\nfor i in range(n):\\n    k = int(input())\\n    l = len(str(k))\\n    s = 9*(l-1)\\n    for i in range(9):\\n        if int(str(i+1)*l)>k:\\n            break\\n        s+=1\\n    print(s)\\n\", \"a = int(input())\\nfor i in range(a):\\n    ans = 0\\n    now = input()\\n    l  = len(now)\\n    ans = 9*(len(now)-1)\\n    now = int(now)\\n    for i in range(1,10):\\n        if now>=int(str(i)*l):\\n            ans +=1\\n        else:\\n            break\\n    print(ans)\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    l = len(str(n))\\n    c = 0\\n    for j in range(1, 10):\\n        g = 10\\n        num = j\\n        for d in range(1, 11):\\n            if num <= n:\\n                c += 1\\n                num += g * j\\n                g *= 10\\n\\n    print(c)\\n\\n\\n\", \"t = int(input())\\n\\nanswer = []\\n\\nfor i in range(t):\\n    n = input()\\n    k = (len(n) - 1) * 9 + int(n[0])\\n    if int(n[0] * len(n)) > int(n):\\n        k -= 1\\n    answer.append(k)\\n\\nfor i in answer:\\n    print(i)\\n        \\n\", \"t = int(input())\\nfor i in range(t):\\n    n = input()\\n    ans = (len(n) - 1) * 9\\n    for j in range(1, 10):\\n        if n >= str(j) * len(n):\\n            ans += 1\\n    print(ans)\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    if n == 1:\\n        print(1)\\n    else:\\n        i = 0\\n        while 10 ** i <= n:\\n            i += 1\\n        i -= 1\\n        k = 1\\n        ans = 0\\n        while int(str(k) * (i + 1)) <= n:\\n            k += 1\\n            ans += 1\\n        print(9 * i + ans)\", \"t=int(input())\\nfor _ in range(t):\\n    n=int(input())\\n    answer=0\\n    k=1\\n    while n>=10**k:\\n        answer+=9\\n        k+=1\\n    n%=10**k\\n    i=1\\n    while n>=int(str(i)*(k)):\\n        answer+=1\\n        i+=1\\n\\n    print(answer)\\n\", \"n = int(input())\\nfor i in range(n):\\n    q = int(input())\\n    qq = str(q)\\n    L = len(qq)\\n    w = (L-1)*9\\n    for i in range(1, 10):\\n        if q>=int(str(i)*L):\\n            w+=1\\n        else:\\n            break\\n    print(w)\\n\", \"t=int(input())\\nfor i in range(t):\\n    n=int(input())\\n    l=len(str(n))\\n    if n<10:\\n        ans=n\\n    else:\\n        ans=l*9-9\\n        k=str(n)[0]\\n        k=int(k*l)\\n        if k<=n:\\n            ans+=int(str(n)[0])\\n        else:\\n            ans+=int(str(n)[0])-1\\n    print(ans)\\n\", \"t = int(input())\\nfor i in range(t):\\n   s = input()\\n   q = int(s[0])\\n   if (int(s) >= int(str(q)*len(s))):\\n       print(q+(len(s)-1)*9)\\n   else:\\n       print(q-1 + (len(s)-1)*9)\\n\\n\", \"import sys\\nimport math\\n\\ndef input():\\n    return sys.stdin.readline().strip()\\ndef iinput():\\n    return int(input())\\ndef tinput():\\n    return input().split()\\ndef rinput():\\n    return list(map(int, tinput()))\\ndef rlinput():\\n    return list(rinput())\\n\\ndef main():\\n    n = iinput()\\n    res = 10\\n    q = 1\\n    while res <= n:\\n        res *= 10\\n        q += 1\\n    res //= 10\\n    q -= 1\\n    for i in range(q):\\n        res += 10 ** i\\n    ans = 0\\n    i = 1\\n    while res <= n and i <= 9:\\n        ans += 1\\n        res = res //i * (i + 1)\\n        i += 1\\n        \\n    \\n    \\n    \\n    print(9 * q + ans)\\n    \\nfor i in range(iinput()):\\n    main()\\n\", \"from sys import stdin as s\\nfor i in range(int(s.readline())):\\n    a=s.readline().rstrip()\\n    l=len(a)\\n    a=int(a)\\n    c=(l-1)*9\\n    list=[int(str(j)*l) for j in range(1,10)]\\n    for j in list:\\n        if j<=a:\\n            c+=1\\n    print(c)\", \"n=int(input())\\nfor i in range(n):\\n    a=int(input())\\n    t=['1','2','3','4','5','6','7','8','9']\\n    keks=0\\n    c=0\\n    while True:\\n        if int(t[keks])>a:\\n            break\\n        else:\\n            c+=1\\n            t[keks]+=t[keks][0]\\n            keks+=1\\n        if keks==9:\\n            keks=0\\n    print(c)\", \"t = int(input())\\nfor _ in range(t):\\n    s = input()\\n    g = len(s)\\n    cnt = 9 * (g - 1)\\n    let = 1\\n    j = int(str(let) * g)\\n    while j <= int(s):\\n        cnt += 1\\n        let += 1\\n        j = int(str(let) * g)\\n    print(cnt)\", \"Q = int(input())\\nfor _ in range(Q):\\n    n = int(input())\\n    ans = 9 * (len(str(n)) - 1)\\n\\n    first = n // (10 ** (len(str(n)) - 1))\\n    ans += first - 1\\n\\n    if n >= int(str(first) * len(str(n))):\\n        ans += 1\\n\\n    print(ans)\\n\", \"q = int(input())\\nfor _ in range(q):\\n\\tn = int(input())\\n\\tt = (len(str(n))-1)*9\\n\\tfor i in range(1, 10):\\n\\t\\tif int(str(i)*len(str(n))) <= n:\\n\\t\\t\\tt+=1\\n\\tprint(t)\", \"n = int(input())\\nfor i in range(n):\\n    a = input()\\n    k = 9 * (len(a) - 1)\\n    k += int(a[0])\\n    s = int(a[0] * len(a))\\n    if int(a) < s:\\n        k -= 1\\n    print(k)\\n    \\n        \\n    \\n\", \"for i in range(int(input())):\\n    x = input()\\n    h = len(x)\\n    f = (int(x) >= int(x[0] * h))\\n    print((h - 1) * 9 + int(x[0]) - 1 + f)\", \"def rec(l, n):\\n    c = 0\\n    for i in (1, 2, 3, 4, 5, 6, 7, 8, 9):\\n        if (int(str(i) * l) <= n):\\n            c += 1\\n        else:\\n            return (c, 0)\\n    return (c, 1)\\n\\nt = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    c = 0\\n    x = 1\\n    ans = (0, 1)\\n    while (ans[1]):\\n        ans = rec(x, n)\\n        c += ans[0]\\n        x += 1\\n    print(c)\\n\", \"t = int(input())\\nans_l = []\\nfor _ in range(t):\\n    n = int(input())\\n    ans = 0\\n    ans += 9 * (len(str(n)) - 1)\\n    for i in range(1, 10):\\n        x = int(str(i) * len(str(n)))\\n        if x <= n:\\n            ans += 1\\n        else:\\n            break\\n    ans_l.append(ans)\\nprint(*ans_l, sep='\\\\n')\\n\", \"for _ in ' '*int(input()):\\n    n = int(input())\\n    ans = len(str(n))*9-9\\n    k = 0\\n    a = int(str(k)*len(str(n)))\\n    while a<=n:\\n        a = int(str(k)*len(str(n)))\\n        if a<=n:\\n            k += 1\\n    print(ans+k-1)\", \"n = int(input())\\nfor i in range(n):\\n    x = input()\\n    col = (len(x) - 1) * 9\\n    la = int(x)\\n    s = ''\\n    for i in range(len(x)):\\n        s += '1'\\n    for i in range(9):\\n        if (int(s) * (i + 1) <= la):\\n            col += 1\\n    print(col)\\n\", \"t = int(input())\\nfor q in range(t):\\n    n = input()\\n    k = len(n)\\n    ans = 9 * (k - 1)\\n    a1 = n[0]\\n    v = ''\\n    for i in range(k):\\n        v += a1\\n    n = int(n)\\n    v = int(v)\\n    if v <= n:\\n        ans += int(a1)\\n    else:\\n        ans += int(a1) - 1\\n    print(ans)\", \"for i in range(int(input())):\\n    n = (input())\\n    m = len(n)\\n    ans = 9 * (m - 1) \\n    n = int(n)\\n    ans += int('1' * m) <= n\\n    ans += int('2' * m) <= n\\n    ans += int('3' * m) <= n\\n    ans += int('4' * m) <= n\\n    ans += int('5' * m) <= n\\n    ans += int('6' * m) <= n\\n    ans += int('7' * m) <= n\\n    ans += int('8' * m) <= n\\n    ans += int('9' * m) <= n\\n    print(ans)\", \"n = int(input())\\nfor i in range(n):\\n    num = int(input())\\n    temp = 1\\n    res = 0\\n    temp1 = 1\\n    slog = 1\\n    slog_temp = 11\\n    while(temp <= num):\\n        if(temp < (10 ** temp1)):\\n            temp += slog\\n            res += 1\\n        else:\\n            temp = slog_temp\\n            temp1 += 1\\n            slog = slog_temp\\n            slog_temp = slog_temp + (10 ** temp1)\\n    print(res)\", \"s = int(input())\\nfor _ in range(s):\\n    n = int(input())\\n    ans = 0\\n    for i in range(1, 10):\\n        k = 1\\n        while int(str(i)*k) <= n:\\n            k += 1\\n            ans += 1\\n    print(ans)\\n\", \"t = int(input())\\nfor i in range(t):\\n    n = list(input())\\n    if len(n) == 1:\\n        print(int(n[0]))\\n    else:\\n        count = (len(n) - 1) * 9\\n        flag = True\\n        for i in range(len(n) - 1):\\n            if n[i] < n[i + 1]:\\n                break\\n            if n[i] > n[i + 1]:\\n                flag = False\\n                break\\n        if flag:\\n            count += int(n[0])\\n        else:\\n            count += int(n[0]) - 1\\n        print(count)\", \"n = int(input())\\nfor i in range(n):\\n    a = int(input())\\n    b = max(len(str(a)) * 9 - 9, 0)\\n    j = '1' * len(str(a))\\n    j = int(j)\\n    t = j\\n    for q in range(9):\\n        if t <= a:\\n            t += j\\n            b += 1\\n    print(b)\\n\", \"q=int(input())\\n\\nfor _ in range(q):\\n    n = int(input())\\n    z=10\\n    k=1\\n    ans = 0\\n    x=1\\n    while z<=n:\\n        x=x*10+1\\n        z*=10\\n        k+=1\\n        ans+=9\\n    k=1\\n    while n>=x*k:\\n        k+=1\\n    print(ans+k-1)\\n\", \"a = int(input())\\nfor iter in range(a):\\n    b = input()\\n    if len(b) == 1:\\n        print(b)\\n        continue\\n    ans = (len(b) - 1) * 9\\n    counter = 0\\n    for iter in range(1, 10):\\n        if int(str(iter) * len(b)) <= int(b):\\n            counter += 1\\n    print(ans + counter)\\n\\n\", \"a = int(input())\\nfor i in range(a): \\n    n = int(input())\\n    b = 1\\n    k = 1\\n    d = 0\\n    while b*k <= n:\\n        if k == 9:\\n            k = 0\\n            b *= 10\\n            b += 1\\n        d+=1\\n        k+=1\\n    print(d)\\n\", \"k = int(input())\\nfor i in range(k):\\n    n = input()\\n    l = len(n)\\n    a = (l - 1) * 9\\n    x1 = int('1' * l)\\n    x = int('1' * l)\\n    n = int(n)\\n    while n >= x:\\n        a += 1\\n        x += x1\\n    print(a)\\n\", \"def main():\\n    best = []\\n    for i in range(1, 20):\\n        for j in ['1','2','3','4','5','6','7','8','9']:\\n            best.append(int(j * i))\\n\\n    m = int(input())\\n\\n    for i in range(m):\\n        n = int(input())\\n        t = 0\\n        for j in best:\\n            if n >= j:\\n                t += 1\\n        print(t)\\n\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    r = len(str(n))\\n    cnt = 0\\n    cnt += (r - 1) * 9\\n    x = int(str(n)[0])\\n    if int(str(x) * r) <= n:\\n        cnt += x\\n    else:\\n        cnt += x - 1\\n    print(cnt)\", \"n = int(input())\\nfor i in range(n):\\n    x = input()\\n    print(9 * (len(str(x)) - 1) + int(x) // int('1' * len(x)))\\n\\n\", \"def ans(s):\\n\\tsize = len(s)\\n\\tflag = True\\n\\tfor i in range(1, size):\\n\\t\\tif s[i-1] < s[i]:\\n\\t\\t\\tbreak\\n\\t\\tif s[i-1] == s[i]:\\n\\t\\t\\tcontinue\\n\\t\\tif s[i-1] > s[i]:\\n\\t\\t\\tflag = False\\n\\t\\t\\tbreak\\n\\tx = 0\\n\\tif flag:\\n\\t\\tx = int(s[0])\\n\\telse:\\n\\t\\tx = int(s[0])-1\\n\\treturn x+(size-1)*9\\nfor i in range(int(input())):\\n    print(ans(input()))\\n\", \"n = int(input())\\n\\nfor i in range(n):\\n    t = int(input())\\n\\n    ans = ((len(str(t)) - 1) * 9)\\n\\n    for j in range(1, 10):\\n        if int(len(str(t)) * str(j)) <= t:\\n            ans += 1\\n        else:\\n            break\\n    print(ans)\\n\", \"lst = []\\nfor i in range(1, 11):\\n\\tfor j in range(1, 10):\\n\\t\\tlst.append(int(str(j) * i))\\nlst.sort()\\nt = int(input())\\nfor i in range(t):\\n\\tn = int(input())\\n\\tc = 0\\n\\tfor j in lst:\\n\\t\\tif n >= j:\\n\\t\\t\\tc += 1\\n\\t\\telse:\\n\\t\\t\\tbreak\\n\\tprint(c)\", \"def f(x):\\n    x1=len(x)\\n    x1= '1'*x1\\n    return x1\\nn=int(input())\\nfor i in range(n):\\n    a=input()\\n    ans=((len(a)-1)*9)\\n    a1=f(a)\\n    a1,a=int(a1),int(a)\\n    ans+= a // a1\\n    print(ans)\", \"from math import log10\\n#A = list(map(int, input().split()))\\nAns = []\\nfor i in range(int(input())):\\n    x = int(input())\\n    if x >= int(str(x)[0] * len(str(x))):\\n        Ans.append(int(log10(x)) * 9 + int(str(x)[0]) - 0)\\n    else:\\n        Ans.append(int(log10(x)) * 9 + int(str(x)[0]) - 1)\\nfor a in Ans:\\n    print(a)\", \"t = int(input())\\nfor i in range(t):\\n    ans = 0\\n    t1 = int(input())\\n    n = len(str(t1))\\n    ans = 9 * (n - 1)\\n    l = ['1', '2', '3', '4', '5', '6', '7', '8', '9']\\n    for el in l:\\n        if int(el * (n)) <= t1:\\n            ans += 1\\n        else:\\n            break\\n    print(ans)\\n\", \"t=int(input())\\nfor j in range(t):\\n\\tn=int(input())\\n\\tans=9*(len(str(n))-1)\\n\\tminx=10;\\n\\ts=\\\"\\\"\\n\\tfor i in range(len(str(n))):\\n\\t\\ts+=\\\"1\\\"\\n\\tans+=n//int(s)\\n\\tprint(ans)\", \"\\nt = int(input())\\nfor i in range(t):\\n\\tn = input()\\n\\tres = (len(n) - 1) * 9\\n\\tres += int(n) // int(n[0] * len(n))\\n\\tres += int(n[0]) - 1\\n\\tprint(res)\\n\", \"t = int(input())\\na = []\\nfor i in range(t):\\n    n = int(input())\\n    a.append(n)\\nfor i in range(t):\\n    ans = 0\\n    for j in range(1, 10):\\n        for k in range(1, 10):\\n            if int(str(j) * k) <= a[i]:\\n                ans += 1\\n    print(ans)\", \"def main():\\n    t = int(input())\\n    for i in range(t):\\n        n = int(input())\\n        s = str(n)\\n        l = len(s)\\n        if(l == 1):\\n            print(n)\\n            continue\\n        c = 9*(l-1)\\n        f = int(s[0]*l)\\n        if(n>=f):\\n            print(c+(f%10))\\n        else:\\n            print(c+(f%10)-1)\\n\\nmain()\", \"n = int(input())\\nfor i in range(n):\\n    k = int(input())\\n    s = 9 * (len(str(k)) - 1)\\n    if (len(str(k)) == 1):\\n        print(k)\\n    else:\\n\\n        f = int(str(k)[0])\\n        if (int(str(f) * len(str(k))) > k):\\n            print(s + f - 1)\\n        else:\\n            print(s + f)\", \"arr = [11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111]\\nfor t in range(int(input())):\\n    n = int(int(input()))\\n    if n < 10:\\n        res = n\\n    else:\\n        res = 9\\n        for item in arr:\\n            if n > item*9:\\n                res += 9\\n            else:\\n                res += n // item\\n                break\\n    print(res)\\n\", \"for i in range(int(input())):\\n    n = int(input())\\n    numbers = 0\\n    j = 0\\n    minn = 0\\n    for j in range(1, 10):\\n        if int(str(j) * len(str(n))) <= n:\\n            minn = j\\n    print(9 * (len(str(n)) - 1) + minn)\\n\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    cnt = 0\\n    i = 1\\n    tmp = 1\\n    while (int(str(tmp) * i) <= n):\\n        cnt += 1\\n        if (tmp == 9):\\n            i += 1\\n            tmp = 1\\n        else:\\n            tmp += 1\\n    print(cnt)\\n           \\n\", \"for i in range(int(input())):\\n    n = input()\\n    counter = (len(n) - 1) * 9\\n    for i in range(1, 10):\\n        if (int(str(i) * len(n)) <= int(n)):\\n            counter += 1\\n    print(counter)\\n\", \"t = int(input())\\nfor i in range(t):\\n\\tn = input()\\n\\tpos = (len(n) - 1) * 9\\n\\tx = 1\\n\\twhile int(str(x) * len(n)) <= int(n):\\n\\t\\tpos += 1\\n\\t\\tx += 1\\n\\tprint(pos)\\n\", \"t = int(input())\\nfor i in range(t):\\n\\tn = input()\\n\\tle = len(n)\\n\\tans = 9 * (le - 1)\\n\\tl = n[0] * le\\n\\tif (int(n) >= int(l)): ans += int(n[0])\\n\\telse: ans += int(n[0]) - 1\\n\\tprint(ans)\\n\", \"n = int(input())\\nfor i in range(n):\\n\\ta = int(input())\\n\\tk, amount = 1, 0\\n\\twhile k*10+1 <= a:\\n\\t\\tk = k*10+1\\n\\tfor j in range(len(str(k))):\\n\\t\\tfor h in [1, 2, 3, 4, 5, 6, 7, 8, 9]:\\n\\t\\t\\tif h*int(str(k)[:j+1]) <= a:\\n\\t\\t\\t\\t# print(h*int(str(k)[:j]))\\n\\t\\t\\t\\tamount += 1\\n\\tprint(amount)\\n\\t\\n\", \"t=int(input())\\nfor r in range(t):\\n q=input()\\n a='1'*len(q)\\n s=int(a)\\n while s<=int(q):\\n  s+=int(a)\\n e=s//int(a)-1\\n e+=-9+9*len(q)\\n print(e)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"6\\n18\\n1\\n9\\n100500\\n33\\n1000000000\\n\"\n  ],\n  \"outputs\": [\n    \"10\\n1\\n9\\n45\\n12\\n81\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1259/A", "starter_code": ""}
{"id": 103, "question": "Ashish and Vivek play a game on a matrix consisting of $n$ rows and $m$ columns, where they take turns claiming cells. Unclaimed cells are represented by $0$, while claimed cells are represented by $1$. The initial state of the matrix is given. There can be some claimed cells in the initial state.\n\nIn each turn, a player must claim a cell. A cell may be claimed if it is unclaimed and does not share a row or column with any other already claimed cells. When a player is unable to make a move, he loses and the game ends.\n\nIf Ashish and Vivek take turns to move and Ashish goes first, determine the winner of the game if both of them are playing optimally.\n\nOptimal play between two players means that both players choose the best possible strategy to achieve the best possible outcome for themselves.\n\n\n-----Input-----\n\nThe first line consists of a single integer $t$ $(1 \\le t \\le 50)$\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case consists of two space-separated integers $n$, $m$ $(1 \\le n, m \\le 50)$\u00a0\u2014 the number of rows and columns in the matrix.\n\nThe following $n$ lines consist of $m$ integers each, the $j$-th integer on the $i$-th line denoting $a_{i,j}$ $(a_{i,j} \\in \\{0, 1\\})$.\n\n\n-----Output-----\n\nFor each test case if Ashish wins the game print \"Ashish\" otherwise print \"Vivek\" (without quotes).\n\n\n-----Example-----\nInput\n4\n2 2\n0 0\n0 0\n2 2\n0 0\n0 1\n2 3\n1 0 1\n1 1 0\n3 3\n1 0 0\n0 0 0\n1 0 0\n\nOutput\nVivek\nAshish\nVivek\nAshish\n\n\n\n-----Note-----\n\nFor the first case: One possible scenario could be: Ashish claims cell $(1, 1)$, Vivek then claims cell $(2, 2)$. Ashish can neither claim cell $(1, 2)$, nor cell $(2, 1)$ as cells $(1, 1)$ and $(2, 2)$ are already claimed. Thus Ashish loses. It can be shown that no matter what Ashish plays in this case, Vivek will win. \n\nFor the second case: Ashish claims cell $(1, 1)$, the only cell that can be claimed in the first move. After that Vivek has no moves left.\n\nFor the third case: Ashish cannot make a move, so Vivek wins.\n\nFor the fourth case: If Ashish claims cell $(2, 3)$, Vivek will have no moves left.", "solutions": "[\"t = int(input())\\n\\nfor _ in range(t):\\n    n, m = [int(x) for x in input().split()]\\n    grid = [[int(x) for x in input().split()] for _ in range(n)]\\n\\n    rows = sum(1 for x in grid if all(y == 0 for y in x))\\n    cols = sum(1 for j in range(m) if all(grid[i][j] == 0 for i in range(n)))\\n\\n    res = min(rows, cols)\\n\\n    print(\\\"Ashish\\\" if res % 2 else \\\"Vivek\\\")\\n\", \"q = int(input())\\nfor _ in range(q):\\n    r,c = map(int,input().split())\\n    mat = [list(map(int,input().split())) for i in range(r)]\\n    row = 0\\n    for i in mat:\\n        if sum(i) == 0:\\n            row += 1\\n    col = 0\\n    for i in range(c):\\n        su = 0\\n        for j in range(r):\\n            su += mat[j][i]\\n        if su == 0:\\n            col += 1\\n    cyk = min(row, col)\\n    if cyk%2 == 0:\\n        print(\\\"Vivek\\\")\\n    else:\\n        print(\\\"Ashish\\\")\", \"from bisect import bisect_left as bl\\nfrom bisect import bisect_right as br\\nfrom heapq import heappush,heappop\\nimport math\\nfrom collections import *\\nfrom functools import reduce,cmp_to_key\\nimport sys\\ninput = sys.stdin.readline\\nM = mod = 998244353\\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\\ndef inv_mod(n):return pow(n, mod - 2, mod)\\n \\ndef li():return [int(i) for i in input().rstrip('\\\\n').split()]\\ndef st():return input().rstrip('\\\\n')\\ndef val():return int(input().rstrip('\\\\n'))\\ndef li2():return [i for i in input().rstrip('\\\\n')]\\ndef li3():return [int(i) for i in input().rstrip('\\\\n')]\\n\\nfor _ in range(val()):\\n    n,m = li()\\n    l = []\\n    for i in range(n):l.append(li())\\n    rows = n\\n    cols = m\\n    for i in range(n):\\n        if sum(l[i]):rows -= 1\\n    for j in range(m):\\n        for i in range(n):\\n            if l[i][j]:\\n                cols -= 1\\n                break\\n    n = rows\\n    m = cols\\n    print('Ashish' if min(n,m)&1 else 'Vivek')\", \"for _ in range(int(input())):\\n    n, m = list(map(int, input().split()))\\n    arr = [list(map(int, input().split())) for _ in range(n)]\\n\\n    rows = 0\\n    for i in range(n):\\n        if 1 in arr[i]:\\n            rows += 1\\n    rows = n-rows\\n\\n    cols = 0\\n    for j in range(m):\\n        for i in range(n):\\n            if arr[i][j] == 1:\\n                cols += 1\\n                break\\n\\n    cols = m-cols\\n\\n    if min(cols, rows) % 2 == 0:\\n        print(\\\"Vivek\\\")\\n    else:\\n        print(\\\"Ashish\\\")\\n\", \"T = int(input())\\n\\nfor t in range(T):\\n    N, M = [int(_) for _ in input().split()]\\n    matrix = []\\n\\n    for i in range(N):\\n        row = [int(_) for _ in input().split()]\\n        matrix.append(row)\\n\\n    available_rows = 0\\n    for row in matrix:\\n        if 1 not in row:\\n            available_rows += 1\\n    available_cols = 0\\n    for i in range(len(matrix[0])):\\n        for j in range(len(matrix)):\\n            if matrix[j][i] == 1:\\n                break\\n        else:\\n            available_cols += 1\\n\\n    a = min(available_cols, available_rows)\\n    if a & 1:\\n        print('Ashish')\\n    else:\\n        print('Vivek')\\n\", \"for _ in range(int(input())):\\n    n, m = list(map(int, input().split()))\\n    arr = [[0] * m for i in range(n)]\\n    for i in range(n):\\n        arr[i] = list(map(int, input().split()))\\n    a = 0\\n    for i in range(n):\\n        if sum(arr[i]) == 0:\\n            a += 1\\n    b = 0\\n    for j in range(m):\\n        cnt = 0\\n        for i in range(n):\\n            cnt += arr[i][j]\\n        if cnt == 0:\\n            b += 1\\n    if min(a, b) % 2 == 1:\\n        print('Ashish')\\n    else:\\n        print('Vivek')\\n\", \"from math import *\\n\\ndef r1(t):\\n    return t(input())\\n\\ndef r2(t):\\n    return [t(i) for i in input().split()]\\n\\ndef r3(t):\\n    return [t(i) for i in input()]\\n\\nfor _ in range(r1(int)):\\n    n, m = r2(int)\\n    a = []\\n    for i in range(n):\\n        a.append(r2(int))\\n\\n    c = 0\\n    for i in range(n):\\n        if sum(a[i]) > 0:\\n            c += 1\\n\\n    c2 = 0\\n    for j in range(m):\\n        for i in range(n):\\n            if a[i][j] > 0:\\n                c2 += 1\\n                break\\n\\n    if min(n - c, m - c2) % 2 == 1:\\n        print('Ashish')\\n    else:\\n        print('Vivek')\\n\", \"t=int(input())\\nfor q in range(t):\\n\\tn,m=[int(i) for i in input().split()]\\n\\ta=[[int(j) for j in input().split()] for i in range(n)]\\n\\trow=[False for i in range(n)]\\n\\tcol=[False for i in range(m)]\\n\\tnr,nc=0,0\\n\\tfor i in range(n):\\n\\t\\tfor j in range(m):\\n\\t\\t\\tif a[i][j]==1:\\n\\t\\t\\t\\tif not row[i]:\\n\\t\\t\\t\\t\\trow[i]=True\\n\\t\\t\\t\\t\\tnr+=1\\n\\t\\t\\t\\tif not col[j]:\\n\\t\\t\\t\\t\\tcol[j]=True\\n\\t\\t\\t\\t\\tnc+=1\\n\\tt=min(n-nr,m-nc)\\n\\tres=\\\"Vivek\\\" if t%2==0 else \\\"Ashish\\\"\\n\\tprint(res)\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n,m = [int(i) for i in input().split()]\\n    v,h = 0,0\\n    grid = []\\n    for _ in range(n):\\n        line = [int(i) for i in input().split()]\\n        if 1 not in line:\\n            h += 1\\n        grid.append(line)\\n    for i in range(m):\\n        if 1 not in [j[i] for j in grid]:\\n            v += 1\\n    M = min(h, v)\\n    if M&1:\\n        print(\\\"Ashish\\\")\\n    else:\\n        print(\\\"Vivek\\\")\", \"T = int(input())\\n\\nfor t in range(T):\\n    n, m = list(map(int, input().split()))\\n    a = [list(map(int, input().split())) for i in range(n)]\\n\\n    rows = set()\\n    cols = set()\\n    for i in range(n):\\n        for j in range(m):\\n            if a[i][j] == 1:\\n                rows.add(i)\\n                cols.add(j)\\n\\n    m = min(n - len(rows), m - len(cols))\\n    if m % 2 == 0:\\n        print(\\\"Vivek\\\")\\n    else:\\n        print(\\\"Ashish\\\")\\n\", \"from sys import stdin\\ninput = stdin.readline\\n\\nfor _ in range(int(input())):\\n    n, m = map(int, input().split())\\n\\n    l = [[] for _ in range(m)]\\n\\n    r = c = 0\\n\\n    for _ in range(n):\\n        a = list(map(int, input().split()))\\n\\n        for i in range(m):\\n            l[i].append(a[i])\\n\\n        if 1 not in a:\\n            r += 1\\n\\n    for a in l:\\n        if 1 not in a:\\n            c += 1\\n\\n    if min(r, c) % 2:\\n        print('Ashish')\\n    else:\\n        print('Vivek')\", \"def read_int():\\n    return int(input())\\n\\n\\ndef read_ints():\\n    return list(map(int, input().split(' ')))\\n\\n\\nt = read_int()\\nfor case_num in range(t):\\n    n, m = read_ints()\\n    a = []\\n    for i in range(n):\\n        a.append(list(read_ints()))\\n    row = set([i for i in range(n)])\\n    col = set([i for i in range(m)])\\n    for i in range(n):\\n        for j in range(m):\\n            if a[i][j] == 1:\\n                if i in row:\\n                    row.remove(i)\\n                if j in col:\\n                    col.remove(j)\\n    lo = min(len(row), len(col))\\n    print(\\\"Ashish\\\" if lo % 2 == 1 else \\\"Vivek\\\")\\n\", \"def solve(n, m, grid):\\n    n_free_cols = sum(all(grid[i][j] == 0 for i in range(n)) for j in range(m))\\n    n_free_lines = sum(all(grid[i][j] == 0 for j in range(m)) for i in range(n))\\n    N = min(n_free_lines, n_free_cols)\\n    return N % 2 == 1\\n\\n\\ndef main():\\n    T = int(input())\\n    for _ in range(T):\\n        n, m = list(map(int, input().split()))\\n        grid = [list(map(int, input().split())) for _ in range(n)]\\n        print(\\\"Ashish\\\" if solve(n, m, grid) else \\\"Vivek\\\")\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"from math import *\\nt = int(input())\\nfor y in range(t):\\n\\tn,m = list(map(int,input().split()))\\n\\ta = []\\n\\tfor i in range(n):\\n\\t\\ta.append(list(map(int,input().split())))\\n\\tr,c = 0,0\\n\\tfor i in range(n):\\n\\t\\tct = 0\\n\\t\\tfor j in range(m):\\n\\t\\t\\tif(a[i][j] == 0):\\n\\t\\t\\t\\tct += 1\\n\\t\\tif(ct == m):\\n\\t\\t\\tr += 1\\n\\tfor i in range(m):\\n\\t\\tct = 0\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif(a[j][i] == 0):\\n\\t\\t\\t\\tct += 1\\n\\t\\tif(ct == n):\\n\\t\\t\\tc += 1\\n\\tx = min(r,c)\\n\\tif(x&1):\\n\\t\\tprint(\\\"Ashish\\\")\\n\\telse:\\n\\t\\tprint(\\\"Vivek\\\")\\n\\n\\n\\n\", \"from sys import stdin\\nT=int(stdin.readline().strip())\\nfor caso in range(T):\\n    \\n    n,m=list(map(int,stdin.readline().strip().split()))\\n    s=[list(map(int,stdin.readline().strip().split())) for i in range(n)]\\n    r=n\\n    for i in range(n):\\n        if 1 in s[i]:\\n            r-=1\\n    c=m\\n    for i in range(m):\\n        for j in range(n):\\n            if s[j][i]==1:\\n                c-=1\\n                break\\n    x=min(c,r)\\n    if x%2==0:\\n        print(\\\"Vivek\\\")\\n    else:\\n        print(\\\"Ashish\\\")\\n            \\n\", \"t = int(input())\\n\\nfor _ in range(t):\\n    n, m = list(map(int, input().strip().split()))\\n\\n    matrix = []\\n    for _ in range(n):\\n        matrix.append(list(map(int, input().strip().split())))\\n\\n    rows = 0\\n    for row in matrix:\\n        if sum(row) == 0:\\n            rows += 1\\n\\n    cols = 0\\n    for i in range(m):\\n        s = 0\\n        for j in range(n):\\n            s += matrix[j][i]\\n        if s == 0:\\n            cols += 1\\n    \\n    mini = min(cols, rows)\\n\\n    if mini % 2 == 1:\\n        print(\\\"Ashish\\\")\\n    else:\\n        print(\\\"Vivek\\\")\", \"for ttt in range(int(input())):\\n#\\tl = list(map(int, input().split()))\\n#\\tn = int(input())\\n\\tn, m = list(map(int, input().split()))\\n\\tx = [0] * n\\n\\ty = [0] * m\\n\\tfor i in range(n):\\n\\t\\tl = list(map(int, input().split()))\\n\\t\\tif 1 in l:\\n\\t\\t\\tx[i] = 1\\n\\t\\tfor j in range(m):\\n\\t\\t\\tif l[j] == 1:\\n\\t\\t\\t\\ty[j] = 1\\n\\tt = min(x.count(0), y.count(0))\\n\\tprint('Vivek' if t % 2 == 0 else 'Ashish')\\n\\n\", \"for nt in range(int(input())):\\n\\tn,m = map(int,input().split())\\n\\tmat = []\\n\\tfor i in range(n):\\n\\t\\tmat.append(list(map(int,input().split())))\\n\\trow = {}\\n\\tcol = {}\\n\\tfor i in range(n):\\n\\t\\tif 1 in mat[i]:\\n\\t\\t\\trow[i]=1\\n\\tfor i in range(m):\\n\\t\\tflag = 0\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif mat[j][i]==1:\\n\\t\\t\\t\\tflag = 1\\n\\t\\t\\t\\tbreak\\n\\t\\tif flag:\\n\\t\\t\\tcol[i]=1\\n\\tcount = 0\\n\\tfor i in range(n):\\n\\t\\tfor j in range(m):\\n\\t\\t\\tif i not in row and j not in col:\\n\\t\\t\\t\\trow[i]=1\\n\\t\\t\\t\\tcol[j]=1\\n\\t\\t\\t\\tcount+=1\\n\\tif count%2:\\n\\t\\tprint (\\\"Ashish\\\")\\n\\telse:\\n\\t\\tprint (\\\"Vivek\\\")\", \"\\n\\nfor _ in range(int(input())):\\n\\tn,m=map(int,input().split())\\n\\n\\ta=[]\\n\\n\\tfor i in range(n):\\n\\t\\ta.append(list(map(int,input().split())))\\n\\n\\trow=[0]*n\\n\\tcol=[0]*m\\n\\n\\tfor i in range(n):\\n\\t\\tfor j in range(m):\\n\\t\\t\\tif(a[i][j]):\\n\\t\\t\\t\\trow[i]=1;\\n\\t\\t\\t\\tcol[j]=1;\\n\\n\\trowc=row.count(0)\\n\\tcolc=col.count(0)\\n\\n\\tmoves=min(rowc,colc)\\n\\n\\tif(moves&1):\\n\\t\\tprint(\\\"Ashish\\\")\\n\\telse:\\n\\t\\tprint(\\\"Vivek\\\")\"]", "input_output": "{\n  \"inputs\": [\n    \"4\\n2 2\\n0 0\\n0 0\\n2 2\\n0 0\\n0 1\\n2 3\\n1 0 1\\n1 1 0\\n3 3\\n1 0 0\\n0 0 0\\n1 0 0\\n\"\n  ],\n  \"outputs\": [\n    \"Vivek\\nAshish\\nVivek\\nAshish\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1365/A", "starter_code": ""}
{"id": 104, "question": "You are given a colored permutation $p_1, p_2, \\dots, p_n$. The $i$-th element of the permutation has color $c_i$.\n\nLet's define an infinite path as infinite sequence $i, p[i], p[p[i]], p[p[p[i]]] \\dots$ where all elements have same color ($c[i] = c[p[i]] = c[p[p[i]]] = \\dots$).\n\nWe can also define a multiplication of permutations $a$ and $b$ as permutation $c = a \\times b$ where $c[i] = b[a[i]]$. Moreover, we can define a power $k$ of permutation $p$ as $p^k=\\underbrace{p \\times p \\times \\dots \\times p}_{k \\text{ times}}$.\n\nFind the minimum $k > 0$ such that $p^k$ has at least one infinite path (i.e. there is a position $i$ in $p^k$ such that the sequence starting from $i$ is an infinite path).\n\nIt can be proved that the answer always exists.\n\n\n-----Input-----\n\nThe first line contains single integer $T$ ($1 \\le T \\le 10^4$) \u2014 the number of test cases.\n\nNext $3T$ lines contain test cases \u2014 one per three lines. The first line contains single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the size of the permutation.\n\nThe second line contains $n$ integers $p_1, p_2, \\dots, p_n$ ($1 \\le p_i \\le n$, $p_i \\neq p_j$ for $i \\neq j$) \u2014 the permutation $p$.\n\nThe third line contains $n$ integers $c_1, c_2, \\dots, c_n$ ($1 \\le c_i \\le n$) \u2014 the colors of elements of the permutation.\n\nIt is guaranteed that the total sum of $n$ doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nPrint $T$ integers \u2014 one per test case. For each test case print minimum $k > 0$ such that $p^k$ has at least one infinite path.\n\n\n-----Example-----\nInput\n3\n4\n1 3 4 2\n1 2 2 3\n5\n2 3 4 5 1\n1 2 3 4 5\n8\n7 4 5 6 1 8 3 2\n5 3 6 4 7 5 8 4\n\nOutput\n1\n5\n2\n\n\n\n-----Note-----\n\nIn the first test case, $p^1 = p = [1, 3, 4, 2]$ and the sequence starting from $1$: $1, p[1] = 1, \\dots$ is an infinite path.\n\nIn the second test case, $p^5 = [1, 2, 3, 4, 5]$ and it obviously contains several infinite paths.\n\nIn the third test case, $p^2 = [3, 6, 1, 8, 7, 2, 5, 4]$ and the sequence starting from $4$: $4, p^2[4]=8, p^2[8]=4, \\dots$ is an infinite path since $c_4 = c_8 = 4$.", "solutions": "[\"from sys import stdin\\ninput = stdin.readline\\nq = int(input())\\nfor rwerew in range(q):\\n\\tn = int(input())\\n\\tp = list(map(int,input().split()))\\n\\tc = list(map(int,input().split()))\\n\\tfor i in range(n):\\n\\t\\tp[i] -= 1\\n\\tprzyn = [0] * n\\n\\tgrupa = []\\n\\ti = 0\\n\\twhile i < n:\\n\\t\\tif przyn[i] == 1:\\n\\t\\t\\ti += 1\\n\\t\\telse:\\n\\t\\t\\tnowa_grupa = [i]\\n\\t\\t\\tj = p[i]\\n\\t\\t\\tprzyn[i] = 1\\n\\t\\t\\twhile j != i:\\n\\t\\t\\t\\tprzyn[j] = 1\\n\\t\\t\\t\\tnowa_grupa.append(j)\\n\\t\\t\\t\\tj = p[j]\\n\\t\\t\\tgrupa.append(nowa_grupa)\\n\\tgrupacol = []\\n\\tfor i in grupa:\\n\\t\\tcyk = []\\n\\t\\tfor j in i:\\n\\t\\t\\tcyk.append(c[j])\\n\\t\\tgrupacol.append(cyk)\\n\\t#print(grupacol)\\n\\tmini = 234283742834\\n\\tfor cykl in grupacol:\\n\\t\\tdziel = []\\n\\t\\td =  1\\n\\t\\twhile d**2 <= len(cykl):\\n\\t\\t\\tif len(cykl)%d == 0:\\n\\t\\t\\t\\tdziel.append(d)\\n\\t\\t\\td += 1\\n\\t\\tdodat = []\\n\\t\\tfor d in dziel:\\n\\t\\t\\tdodat.append(len(cykl)/d)\\n\\t\\tdziel_ost = list(map(int,dziel + dodat))\\n\\t\\t#print(dziel_ost, len(cykl))\\n\\t\\tfor dzielnik in dziel_ost:\\n\\t\\t\\tfor i in range(dzielnik):\\n\\t\\t\\t\\tindeks = i\\n\\t\\t\\t\\tsecik = set()\\n\\t\\t\\t\\tchuj = True\\n\\t\\t\\t\\twhile indeks < len(cykl):\\n\\t\\t\\t\\t\\tsecik.add(cykl[indeks])\\n\\t\\t\\t\\t\\tindeks += dzielnik\\n\\t\\t\\t\\t\\tif len(secik) > 1:\\n\\t\\t\\t\\t\\t\\tchuj = False\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tif chuj:\\n\\t\\t\\t\\t\\tmini = min(mini, dzielnik)\\n\\tprint(mini)\\n\\t\\t\\t\\n\", \"T = int(input())\\nfor _ in range(T):\\n    n = int(input())\\n    perm = list([int(x) - 1 for x in input().split()])\\n    color = list(map(int, input().split()))\\n\\n    SMALL = n\\n\\n    unseen = set(range(n))\\n    while unseen:\\n        start = unseen.pop()\\n        l = [start]\\n        nex = start\\n        while perm[nex] != start:\\n            nex = perm[nex]\\n            l.append(nex)\\n            unseen.remove(nex)\\n\\n        size = len(l)\\n        factors = []\\n\\n        curr = 1\\n        while curr * curr <= size:\\n            if size % curr == 0:\\n                factors.append(curr)\\n                factors.append(size//curr)\\n            curr += 1\\n\\n        for f in factors:\\n            works = [True] * f\\n            for i in range(size):\\n                if color[l[i]] != color[l[i % f]]:\\n                    works[i % f] = False\\n\\n            for b in works:\\n                if b:\\n                    SMALL = min(SMALL, f)\\n                    break\\n\\n    print(SMALL)\\n        \\n\", \"import sys\\n\\nT = int(sys.stdin.readline().strip())\\nQ = []\\nP = [0] * (10 ** 6)\\nfor i in range (2, 2 * 10 ** 5 + 10):\\n    v = True\\n    if P[i] == 0:\\n        Q.append(i)\\n        j = i\\n        while j < 10 ** 6:\\n            P[j] = 1\\n            j = j + i\\n\\ndef factors(n):\\n    i2 = 0\\n    ans = [1]\\n    while n > 1:\\n        m = 0\\n        while n % Q[i2] == 0:\\n            m = m + 1\\n            n = n // Q[i2]\\n        ans2 = []\\n        for h in range (0, m+1):\\n            for j in ans:\\n                ans2.append(j * (Q[i2] ** h))\\n        i2 = i2 + 1\\n        ans = ans2[:]\\n    return ans\\n\\nfor t in range (0, T):\\n    n = int(sys.stdin.readline())\\n    p = list(map(int, sys.stdin.readline().strip().split()))\\n    c = list(map(int, sys.stdin.readline().strip().split()))\\n    for i in range (0, n):\\n        p[i] = p[i] - 1\\n    P = []\\n    L = []\\n    i = 0\\n    ans = n\\n    while i < n:\\n        if p[i] == -1:\\n            i = i + 1\\n        else:\\n            j = i\\n            x = [j]\\n            while p[j] != i:\\n                x.append(p[j])\\n                j2 = p[j]\\n                p[j] = -1\\n                j = j2\\n            p[j] = -1\\n            P.append(x)\\n            l = len(x)\\n            F = factors(l)\\n            for f in F:\\n                for j in range (0, f):\\n                    v = True\\n                    for h in range (0, l // f):\\n                        if c[x[j + h * f]] != c[x[j]]:\\n                            v = False\\n                    if v == True:\\n                        ans = min(ans, f)   \\n    print(ans)\\n\\n\", \"import sys\\ninput = lambda: sys.stdin.readline().rstrip()\\n\\ndef primeFactor(N):\\n    i, n, ret, d, sq = 2, N, {}, 2, 99\\n    while i <= sq:\\n        k = 0\\n        while n % i == 0: n, k, ret[i] = n//i, k+1, k+1\\n        if k > 0 or i == 97: sq = int(n**(1/2)+0.5)\\n        if i < 4: i = i * 2 - 1\\n        else: i, d = i+d, d^6\\n    if n > 1: ret[n] = 1\\n    return ret\\n\\ndef divisors(N):\\n    pf = primeFactor(N)\\n    ret = [1]\\n    for p in pf:\\n        ret_prev = ret\\n        ret = []\\n        for i in range(pf[p]+1):\\n            for r in ret_prev:\\n                ret.append(r * (p ** i))\\n    return sorted(ret)\\n\\ndef chk(X):\\n    n = len(X)\\n    XX = X * 2\\n    mi = 1 << 30\\n    for d in divisors(n):\\n        if d >= mi: break\\n        for i in range(d):\\n            for j in range(i, n+i, d):\\n                if XX[j] != XX[j+d]:\\n                    break\\n            else:\\n                mi = min(mi, d)\\n    return mi\\n\\nT = int(input())\\nfor _ in range(T):\\n    N = int(input())\\n    A = [int(a) - 1 for a in input().split()]\\n    C = [int(a) - 1 for a in input().split()]\\n    done = [0] * N\\n    L = []\\n    for i in range(N):\\n        if done[i]: continue\\n        t = [C[i]]\\n        j = A[i]\\n        while j != i:\\n            t.append(C[j])\\n            done[j] = 1\\n            j = A[j]\\n        L.append(t)\\n    print(min([chk(a) for a in L]))\\n\", \"import sys\\n\\n\\n\\ndef bestval(pp, cc):\\n    # print(\\\"BESTVAL:\\\")\\n    # print(pp)\\n    # print(cc)\\n    k = len(pp)\\n    k_2 = k//2+1\\n    for f in range(1, k_2):\\n        if k % f == 0:\\n            for offs in range(f):\\n                \\n                good = True\\n                num = cc[offs]\\n                # print(f\\\"{f}, {offs}, {num}: \\\")\\n                upp = (k//f)//2+1\\n                for j in range(1, upp):\\n                    v1 = f*j \\n                    v2 = k - v1 + offs\\n                    v1 += offs\\n                    # print(pp[v1], pp[v2])\\n                    if cc[v1] != num or cc[v2] != num:\\n                        good = False\\n                        break\\n                if good:\\n                    return f\\n    return k\\n\\n\\n\\nfor q in range(int(sys.stdin.readline())):\\n    n = int(sys.stdin.readline())\\n    p = [int(j)-1 for j  in sys.stdin.readline().split()]\\n    c = [int(j)-1 for j  in sys.stdin.readline().split()]\\n    fnd = [0]*n\\n    ans = n+1\\n    for i in range(n):\\n        if not fnd[i]:\\n            ppp = [i]\\n            ccc = [c[i]]\\n            fnd[i] = 1\\n            j = p[i]\\n            while j != i:\\n                fnd[j] = 1\\n                ppp.append(j)\\n                ccc.append(c[j])\\n                j = p[j]\\n            # bb = \\n            # print(bb)\\n            ans = min(ans, bestval(ppp, ccc))\\n    sys.stdout.write(str(ans) + '\\\\n')\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n4\\n1 3 4 2\\n1 2 2 3\\n5\\n2 3 4 5 1\\n1 2 3 4 5\\n8\\n7 4 5 6 1 8 3 2\\n5 3 6 4 7 5 8 4\\n\"\n  ],\n  \"outputs\": [\n    \"1\\n5\\n2\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1327/D", "starter_code": ""}
{"id": 105, "question": "\u2014 Hey folks, how do you like this problem?\n\n\u2014 That'll do it. \n\nBThero is a powerful magician. He has got $n$ piles of candies, the $i$-th pile initially contains $a_i$ candies. BThero can cast a copy-paste spell as follows:   He chooses two piles $(i, j)$ such that $1 \\le i, j \\le n$ and $i \\ne j$.  All candies from pile $i$ are copied into pile $j$. Formally, the operation $a_j := a_j + a_i$ is performed. \n\nBThero can cast this spell any number of times he wants to \u2014 but unfortunately, if some pile contains strictly more than $k$ candies, he loses his magic power. What is the maximum number of times BThero can cast the spell without losing his power?\n\n\n-----Input-----\n\nThe first line contains one integer $T$ ($1 \\le T \\le 500$) \u2014 the number of test cases.\n\nEach test case consists of two lines:   the first line contains two integers $n$ and $k$ ($2 \\le n \\le 1000$, $2 \\le k \\le 10^4$);  the second line contains $n$ integers $a_1$, $a_2$, ..., $a_n$ ($1 \\le a_i \\le k$). \n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $1000$, and the sum of $k$ over all test cases does not exceed $10^4$.\n\n\n-----Output-----\n\nFor each test case, print one integer \u2014 the maximum number of times BThero can cast the spell without losing his magic power.\n\n\n-----Example-----\nInput\n3\n2 2\n1 1\n3 5\n1 2 3\n3 7\n3 2 2\n\nOutput\n1\n5\n4\n\n\n\n-----Note-----\n\nIn the first test case we get either $a = [1, 2]$ or $a = [2, 1]$ after casting the spell for the first time, and it is impossible to cast it again.", "solutions": "[\"import math\\nt = int(input())\\nfor test in range(t):\\n    n,k = map(int,input().split())\\n    A = list(map(int,input().split()))\\n    A.sort()\\n    ans = 0\\n    for i in range(1,n):\\n        if(A[i]>k):\\n            ans = 0\\n            break\\n        rem = k-A[i]\\n        ans+=rem//A[0]\\n    print(ans)\", \"t = int(input())\\n\\nfor _ in range(t):\\n    n, k = map(int, input().split())\\n    a = list(map(int, input().split()))\\n    \\n    a.sort()\\n    ct = 0\\n    \\n    for i in range(1, n):\\n        ct += (k-a[i])//a[0]\\n        \\n    print(ct)\", \"for _ in range(int(input())):\\n    n,k = map(int,input().split())\\n    A = list(map(int,input().split()))\\n    A.sort()\\n    ans = 0\\n    for i in range(1,n):\\n        if(A[i]>k):\\n            ans = 0\\n            break\\n        rem = k-A[i]\\n        ans+=rem//A[0]\\n    print(ans)\", \"#   ==========     //\\\\\\\\       //||     ||====//||\\n#       ||        //  \\\\\\\\        ||     ||   // ||\\n#       ||       //====\\\\\\\\       ||     ||  //  ||\\n#       ||      //      \\\\\\\\      ||     || //   ||\\n#   ========== //        \\\\\\\\  ========  ||//====|| \\n#  code\\n\\ndef solve():\\n    n, k = map(int, input().split())\\n    a = list(map(int, input().split()))\\n    a.sort()\\n    ans = 0\\n    for i in a[1:]:\\n        ans += (k - i) // a[0]\\n    print(ans)\\n    return\\n\\ndef main():\\n    t = 1\\n    t = int(input())\\n    for _ in range(t):\\n        solve()\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"t = int(input())\\nfor _ in range(t):\\n    n, k = map(int, input().split())\\n    a = list(map(int, input().split()))\\n    a.sort()\\n    m = a[0]\\n    a = a[1:]\\n    total = 0\\n    for b in a:\\n        total += (k-b)//m\\n\\n    print(total)\", \"import math\\nt=int(input())\\nfor _ in range(t):\\n    n,k=list(map(int,input().split()))\\n    a=list(map(int,input().split()))\\n    a.sort()\\n    b=a[0]\\n    sumi=0\\n    for i in range(1,n):\\n        c=k-a[i]\\n        sumi+=c//b\\n    print(sumi)\\n\", \"import sys\\nimport random\\nfrom fractions import Fraction\\nfrom math import *\\nfrom decimal import *\\n \\ndef input():\\n    return sys.stdin.readline().strip()\\n \\ndef iinput():\\n    return int(input())\\n\\ndef finput():\\n    return float(input())\\n\\ndef tinput():\\n    return input().split()\\n\\ndef linput():\\n    return list(input())\\n \\ndef rinput():\\n    return list(map(int, tinput()))\\n\\ndef fiinput():\\n    return list(map(float, tinput()))\\n \\ndef rlinput():\\n    return list(map(int, input().split()))\\ndef trinput():\\n    return tuple(rinput())\\n\\ndef srlinput():\\n    return sorted(list(map(int, input().split())))\\n\\ndef NOYES(fl):\\n    if fl:\\n        print(\\\"NO\\\")\\n    else:\\n        print(\\\"YES\\\")\\ndef YESNO(fl):\\n    if fl:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n    \\ndef modst(a, s):\\n    res = 1\\n    while s:\\n        if s % 2:\\n            res =res * a %998244353\\n        a *= a\\n        a = a % 998244353\\n        s //= 2\\n    return res\\n\\n\\n\\n    \\ndef main():\\n    #n = iinput()\\n    #k = iinput() \\n    #m = iinput() \\n    #n = int(sys.stdin.readline().strip()) \\n    n, k = rinput()\\n    #n, m = rinput()\\n    #m, k = rinput()\\n    #n, k, m = rinput()\\n    #n, m, k = rinput()\\n    #k, n, m = rinput()\\n    #k, m, n = rinput() \\n    #m, k, n = rinput()\\n    #m, n, k = rinput()\\n    q = srlinput()\\n    #q = linput()\\n    res = 0\\n    for i in range(1, n):\\n        res += (k - q[i]) // q[0]\\n    print(res)\\n           \\n        \\n            \\n    \\n    \\n    \\n    \\n    \\n    \\n            \\n                \\n        \\n    \\n            \\n        \\n\\n            \\n        \\n    \\n                \\n    \\n    \\n    \\n            \\n    \\n        \\n    \\n\\nfor i in range(iinput()):\\n    main()\\n    \\n\", \"from sys import stdin\\n###############################################################\\ndef iinput(): return int(stdin.readline())\\ndef minput(): return list(map(int, stdin.readline().split()))\\ndef linput(): return list(map(int, stdin.readline().split()))\\n###############################################################\\n\\n\\nt = iinput()\\nwhile t:\\n    t -= 1\\n    n, k = minput()\\n    a = linput()\\n    a.sort()\\n    ans = 0\\n    for i in range(1, n):\\n        ans += max(0, k - a[i]) // a[0]\\n    print(ans)\\n\", \"def solve(n,k):\\n    s=list(map(int,input().split()))\\n    s.sort()\\n    ans=0\\n    p=s[0]\\n    for i in range(1,n):\\n        ans+=((k-s[i])//p)\\n    print(ans)\\n\\n\\nfor _ in range(int(input())):\\n    n,k=map(int,input().split())\\n    solve(n,k)\", \"for _ in range(int(input())):\\n    n, k = map(int, input().split())\\n    a = list(map(int, input().split()))\\n    m = min(a)\\n    ind = a.index(m)\\n    ans = 0\\n    for i in range(n):\\n        if i == ind:\\n            continue\\n        ans += (k - a[i]) // m\\n    print(ans)\", \"import sys\\nimport math\\ndef II():\\n\\treturn int(sys.stdin.readline())\\n \\ndef LI():\\n\\treturn list(map(int, sys.stdin.readline().split()))\\n \\ndef MI():\\n\\treturn list(map(int, sys.stdin.readline().split()))\\n \\ndef SI():\\n\\treturn sys.stdin.readline().strip()\\nt = II()\\nfor q in range(t):\\n    n,k = MI()\\n    a = LI()\\n    a.sort()\\n    count = 0\\n    for i in range(1,n):\\n        b = max(k-a[i],0)\\n        count+=b//a[0]\\n    print(count)\\n\", \"#Codeforces Round #673\\n#Problem A\\nimport sys\\n\\n#\\n#BEGIN TEMPLATE\\n#\\ndef input(): return sys.stdin.readline()[:-1]\\ndef getInt(): return int(input())\\ndef getIntIter(): return list(map(int, input().split()))\\ndef getIntList(): return list(getIntIter())\\ndef flush(): sys.stdout.flush()\\n#\\n#END TEMPLATE\\n#\\n\\nfor _ in range(getInt()):\\n    n,k = getIntIter()\\n    nums = getIntList()\\n    m = min(nums)\\n    ans = 0\\n    for num in nums:\\n        ans += (k-num)//m\\n    ans -= (k-m)//m\\n    print(ans)\\n\", \"for _ in range(int(input())):\\n    n, k = list(map(int, input().split()))\\n    *arr, = list(map(int, input().split()))\\n    cnt = 0\\n    mn = min(arr)\\n    arr.remove(mn)\\n    for v in arr:\\n        cnt += (k - v) // mn\\n    print(cnt)\\n\\n\\n\\n\\n\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n,k = [int(x) for x in input().split()]\\n    l = [int(x) for x in input().split()]\\n    ans = 0\\n    m = min(l)\\n    mi = l.index(m)\\n    for i in range(n):\\n        if i!=mi:\\n            ans+=max((k-l[i])//m,0)\\n    print(ans)\\n\", \"'''Author- Akshit Monga'''\\nt=int(input())\\nfor _ in range(t):\\n    n,k=map(int,input().split())\\n    arr=[int(x) for x in input().split()]\\n    m=min(arr)\\n    ans=0\\n    for i in arr:\\n        ans+=(k-i)//m\\n    print(ans-(k-m)//m)\", \"from sys import stdin\\ninput = stdin.readline\\nfor _ in range(int(input())):\\n    n,x = list(map(int,input().split()))\\n    a = sorted(list(map(int,input().split())),reverse=True)\\n    g = a.pop()\\n    ans = 0\\n    for i in a:\\n        ans += max(0,(x-i)//g)\\n    print(ans)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n2 2\\n1 1\\n3 5\\n1 2 3\\n3 7\\n3 2 2\\n\"\n  ],\n  \"outputs\": [\n    \"1\\n5\\n4\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1417/A", "starter_code": ""}
{"id": 106, "question": "There are $n$ segments $[l_i, r_i]$ for $1 \\le i \\le n$. You should divide all segments into two non-empty groups in such way that there is no pair of segments from different groups which have at least one common point, or say that it's impossible to do it. Each segment should belong to exactly one group.\n\nTo optimize testing process you will be given multitest.\n\n\n-----Input-----\n\nThe first line contains one integer $T$ ($1 \\le T \\le 50000$) \u2014 the number of queries. Each query contains description of the set of segments. Queries are independent.\n\nFirst line of each query contains single integer $n$ ($2 \\le n \\le 10^5$) \u2014 number of segments. It is guaranteed that $\\sum{n}$ over all queries does not exceed $10^5$.\n\nThe next $n$ lines contains two integers $l_i$, $r_i$ per line ($1 \\le l_i \\le r_i \\le 2 \\cdot 10^5$) \u2014 the $i$-th segment.\n\n\n-----Output-----\n\nFor each query print $n$ integers $t_1, t_2, \\dots, t_n$ ($t_i \\in \\{1, 2\\}$) \u2014 for each segment (in the same order as in the input) $t_i$ equals $1$ if the $i$-th segment will belongs to the first group and $2$ otherwise.\n\nIf there are multiple answers, you can print any of them. If there is no answer, print $-1$.\n\n\n-----Example-----\nInput\n3\n2\n5 5\n2 3\n3\n3 5\n2 3\n2 3\n3\n3 3\n4 4\n5 5\n\nOutput\n2 1 \n-1\n1 1 2 \n\n\n\n-----Note-----\n\nIn the first query the first and the second segments should be in different groups, but exact numbers don't matter.\n\nIn the second query the third segment intersects with the first and the second segments, so they should be in the same group, but then the other group becomes empty, so answer is $-1$.\n\nIn the third query we can distribute segments in any way that makes groups non-empty, so any answer of $6$ possible is correct.", "solutions": "[\"t = int(input())\\n\\nfor ti in range(t):\\n\\tn = int(input())\\n\\n\\tlri = [None for _ in range(n)]\\n\\n\\tfor _ in range(n):\\n\\t\\tli, ri = list(map(int, input().split()))\\n\\t\\tlri[_] = (li, ri, _)\\n\\n\\tlri.sort()\\n\\n\\tt = [None for _ in range(n)]\\n\\n\\tct, t[lri[0][2]], eg = 1, 1, lri[0][1]\\n\\n\\tfor i in range(1, n):\\n\\t\\tif lri[i][0] <= eg:\\n\\t\\t\\tt[lri[i][2]] = ct\\n\\t\\t\\teg = max(eg, lri[i][1])\\n\\t\\telse:\\n\\t\\t\\tct = 3 - ct\\n\\t\\t\\tt[lri[i][2]] = ct\\n\\t\\t\\teg = lri[i][1]\\n\\n\\tif all(ti == 1 for ti in t):\\n\\t\\tprint(-1)\\n\\telse:\\n\\t\\tprint(*t)\\n\", \"def ii():\\n    return int(input())\\ndef mi():\\n    return list(map(int, input().split()))\\ndef li():\\n    return list(mi())\\n\\nfor _ in range(ii()):\\n    n = ii()\\n    a = [(li() + [i]) for i in range(n)]\\n    a.sort()\\n    ans = [2] * n\\n    pr = a[0][0]\\n    for l, r, i in a:\\n        if l > pr:\\n            break\\n        ans[i] = 1\\n        pr = max(pr, r)\\n    if 2 in ans:\\n        print(*ans)\\n    else:\\n        print(-1)\\n\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    sobs = []\\n    for j in range(n):\\n        a, b = list(map(int, input().split()))\\n        sobs.append([[a, -1], j])\\n        sobs.append([[b, 1], j])\\n    sobs.sort()\\n    counts = 0\\n    passed = []\\n    success = []\\n    alls = [0 for q in range(n)]\\n    succeed = False\\n    for sob in sobs:\\n        if succeed:\\n            if sob[0][1] == -1:\\n                pass\\n            else: \\n                success.append(sob[1])\\n            continue\\n        if sob[0][1] == -1:\\n            counts += 1\\n        else:\\n            counts -= 1\\n            passed.append(sob[1])\\n            if counts == 0:\\n                succeed = True\\n    if succeed and success:\\n        for a in passed:\\n            alls[a] = 1\\n        for b in success:\\n            alls[b] = 2\\n        print(*alls)\\n    else:\\n        print(-1)\\n\", \"T=int(input())\\nfor i in range(0,T):\\n    n=int(input())\\n    L=[]\\n    dp=[0]*n\\n    for j in range(0,n):\\n        l,r=map(int,input().split())\\n        L.append((l,r,j))\\n    L=sorted(L)\\n    temp=-1\\n    ed=L[0][1]\\n    for j in range(1,len(L)):\\n        if(L[j][0]>ed):\\n            temp=j\\n            break\\n        ed=max(ed,L[j][1])\\n    if(temp==-1 or n==1):\\n        print(-1)\\n    else:\\n        for j in range(0,len(L)):\\n            if(j<temp):\\n                dp[L[j][2]]=1\\n            else:\\n                dp[L[j][2]]=2\\n        for j in range(0,n):\\n            print(dp[j],end=\\\" \\\")\\n        print(\\\" \\\")\\n        \\n        \\n\", \"for _ in range(int(input())):\\n\\tn=int(input())\\n\\ta=[]\\n\\tf=0\\n\\tfor i in range(n):\\n\\t\\tl,r=map(int,input().split())\\n\\t\\ta.append([l,r,i])\\n\\ta.sort(key=lambda x:x[0])\\n\\trm=a[0][1]\\n\\tfor i in range(n):\\n\\t\\tif a[i][0]>rm:\\n\\t\\t\\tb=a[i]\\n\\t\\t\\tf=1\\n\\t\\t\\tbreak\\n\\t\\tif a[i][1]>rm:\\n\\t\\t\\trm=a[i][1]\\n\\tif f==0:\\n\\t\\tprint(-1)\\n\\telse:\\n\\t\\ta.sort(key=lambda x:x[2])\\n\\t\\tfor i in range(n):\\n\\t\\t\\tif a[i][0]<b[0]:\\n\\t\\t\\t\\tprint(1,end=\\\" \\\")\\n\\t\\t\\telse:\\n\\t\\t\\t\\tprint(2,end=\\\" \\\")\\n\\tprint()\\n\", \"T = int(input())\\n\\nfor i in range(T):\\n    n = int(input())\\n    X = []\\n    for j in range(n):\\n        l, r = list(map(int, input().split()))\\n        X.append([j, l, r])\\n\\n    X = sorted(X, key = lambda x: x[1])\\n    # print(X)\\n    \\n    Y = [\\\"2\\\"] * n\\n    s = -1\\n    rmax = X[0][2]\\n    Y[X[0][0]] = \\\"1\\\"\\n    for i in range(1, n):\\n        if X[i][1] > rmax:\\n            s = i\\n            break\\n        rmax = max(rmax, X[i][2])\\n        Y[X[i][0]] = \\\"1\\\"\\n        \\n    if s < 0:\\n        print(-1)\\n    else:\\n        print(\\\" \\\".join(Y))\\n\", \"\\nfor c in range(int(input())):\\n    N = int(input())\\n    counter = 0\\n    segments = []\\n    for n in range(N):\\n        l, r = map(int, input().split())\\n        segments.append([[l, r], counter])\\n        counter += 1\\n    \\n    segments.sort()\\n    ans = [-1] * N\\n    \\n    rightBound = segments[0][0][1]\\n    valid = -1\\n    for i in range(1, len(segments)):\\n        if segments[i][0][0] > rightBound:\\n            valid = i\\n            break\\n        else:\\n            rightBound = max(rightBound, segments[i][0][1])\\n    \\n    if valid == -1:\\n        print(-1)\\n    else:\\n        for i in range(valid):\\n            ans[segments[i][1]] = 1\\n        for i in range(valid, len(segments)):\\n            ans[segments[i][1]] = 2\\n    \\n        for a in ans:\\n            print(a, end= ' ') \\n    print()\\n'''\\n3\\n2\\n5 5\\n2 3\\n3\\n3 5\\n2 3\\n2 3\\n3\\n3 3\\n4 4\\n5 5\\n'''    \", \"MOD = 10**9 + 7\\nI = lambda:list(map(int,input().split()))\\n\\nt, = I()\\nwhile t:\\n    t -= 1\\n    n, = I()\\n    a = [2]*(n)\\n    l = []\\n    for i in range(n):\\n        l.append(I()+[i])\\n    l.sort()\\n    mn = l[0][0]\\n    mx = l[0][1]\\n    i = 0\\n    while i < n and l[i][0] <= mx:\\n        mx = max(mx, l[i][1])\\n        a[l[i][2]] = 1\\n        i += 1\\n    if all([i == 1 for i in a]) or all([i == 2 for i in a]):\\n        print(-1)\\n    else:\\n        print(*a)\", \"t = int(input())\\nfor tc in range(t):\\n    n = int(input())\\n    l = []\\n\\n    for i in range( n ):\\n        a,b = map(int,input().split())\\n        l.append([i,a,b])\\n\\n    l = sorted(l, key=lambda x: x[1])\\n    last = l[0][1]\\n    i = 0\\n    while i < n:\\n        if l[ i ][ 1 ] > last:\\n            break\\n        last = max( last, l[ i ][ 2 ] )\\n        i += 1\\n\\n    if i == n:\\n        print( -1 )\\n    else:\\n        ind = [2] * n\\n        for j in range( i ):\\n            ind[ l[ j ][ 0 ] ] = 1\\n        for i in ind:\\n            print( i,end=' ')\\n        print(\\\"\\\")\\n\", \"t = int(input())\\nfinal = []\\nfor k in range(t):\\n    n = int(input())\\n    skl = []\\n    for i in range(n):\\n        a, b = map(int, input().split())\\n        skl.append((a, -1, i))\\n        skl.append((b, 1, i))\\n    skl.sort()\\n    m = 0\\n    ans = ['0']*n\\n    for i, p in enumerate(skl):\\n        if m == 0 and i != 0:\\n            for j in range(i, 2*n):\\n                ans[skl[j][2]] = '2'\\n            break\\n\\n        m -= p[1]\\n        if p[1] == -1:\\n            ans[skl[i][2]] = '1'\\n    if not '2' in ans:\\n        final.append('-1')\\n    else:\\n        final.append(' '.join(ans))\\nprint('\\\\n'.join(final))\", \"def check(data):\\n    n = len(data)\\n    s = sorted(zip(data, range(n)))\\n    m = s[0][0][1]\\n    left = set()\\n    for i, r in enumerate(s):\\n        left.add(r[1])\\n        if i == len(s)-1:\\n            return '-1'\\n        m = max(m, r[0][1])\\n        if s[i+1][0][0] > m:\\n            break\\n    res = ['1' if j in left else '2' for j in range(n)]\\n    return ' '.join(res)\\n\\n\\nT = int(input())\\nfor i in range(T):\\n    n = int(input())\\n    data = []\\n    for j in range(n):\\n        l, r = map(int, input().split())\\n        data.append((l, r))\\n    print(check(data))\", \"T = int(input())\\n\\nfor _ in range(T):\\n    n = int(input())\\n    seg = []\\n    for s in range(n):\\n        l,r = [int(x) for x in input().split()]\\n        seg.append((l,r))\\n    pos = {}\\n    for i in range(n):\\n        if seg[i] in pos:\\n            pos[seg[i]].append(i)\\n        else:\\n            pos[seg[i]] = [i]\\n    seg.sort()\\n    right = seg[0][1]\\n    goodindex = -1\\n    for j in range(1,n):\\n        if seg[j][0] > right:\\n            goodindex = j\\n            break\\n        right = max(right,seg[j][1])\\n    if goodindex == -1:\\n        print(-1)\\n    else:\\n        ans = ['2']*n\\n        for i in range(goodindex):\\n            ans[pos[seg[i]][-1]] = '1'\\n            pos[seg[i]].pop()\\n        print(' '.join(ans))\", \"import sys\\ninput = sys.stdin.readline\\n\\nQ=int(input())\\n\\nfor test in range(Q):\\n    n=int(input())\\n    LR=[list(map(int,input().split()))+[i] for i in range(n)]\\n    LR.sort()\\n\\n    GR1=[LR[0][0],LR[0][1]]\\n\\n    for i in range(1,n):\\n        l,r,_=LR[i]\\n\\n        if r<GR1[0] or l>GR1[1]:\\n            ANS=i\\n            break\\n        else:\\n            GR1=[min(GR1[0],l),max(GR1[1],r)]\\n\\n    else:\\n        print(-1)\\n        continue\\n\\n    ANSLIST=[1]*n\\n    for j in range(ANS,n):\\n        ANSLIST[LR[j][2]]=2\\n\\n    for a in ANSLIST:\\n        print(a,end=\\\" \\\")\\n    print()\\n\", \"\\nL = 0\\nR = 1\\n\\ndef main():\\n    buf = input()\\n    T = int(buf)\\n    n = []\\n    lr = []\\n    for i in range(T):\\n        buf = input()\\n        n.append(int(buf))\\n        lr.append([])\\n        for j in range(n[i]):\\n            buf = input()\\n            buflist = buf.split()\\n            lr[i].append([int(buflist[0]), int(buflist[1])])\\n    for i in range(T):\\n        lr_s = list(sorted(lr[i]))\\n        threshold = lr_s[0][R]\\n        threshold_final = None\\n        for j in range(1, n[i]):\\n            if threshold < lr_s[j][L]:\\n                threshold_final = threshold\\n                break\\n            elif threshold < lr_s[j][R]:\\n                threshold = lr_s[j][R]\\n        if threshold_final == None:\\n            print(-1) # impossible\\n            continue\\n        answer = \\\"\\\"\\n        for j in range(n[i]):\\n            if lr[i][j][L] <= threshold_final:\\n                answer += \\\"1\\\"\\n            else:\\n                answer += \\\"2\\\"\\n            if j < n[i] - 1:\\n                answer += \\\" \\\"\\n        print(answer)\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"T = int(input())\\nfor i in range(T):\\n    n = int(input())\\n    inp=[]\\n    temp = []\\n    for j in range(n):\\n        a,b = [int(u) for u in input().split()]\\n        inp.append([a,b])\\n        temp.append([a,b])\\n    inp.sort()\\n    check=0\\n    begin = inp[0][0]\\n    end = inp[0][1]\\n    for j in range(n):\\n        if(inp[j][0]>end):\\n            check=1\\n            break\\n        if(inp[j][1]>end):\\n            end = inp[j][1]\\n    ans = []\\n    if(check==0):\\n        print(-1)\\n    else:\\n        for j in range(n):\\n            if(temp[j][0]>=begin and temp[j][1]<=end):\\n                ans.append(\\\"1\\\")\\n            else:\\n                ans.append(\\\"2\\\")\\n        print(\\\" \\\".join(ans))\\n\", \"q=int(input())\\n\\nfor i in range(q):\\n    \\n    n=int(input())\\n    ilist=[]\\n    for j in  range(n):\\n        ilist.append(list(map(int, input().rstrip().split())))\\n        ilist[j].append(j)\\n    ilist.sort()\\n    \\n    seglist=[2]*n\\n    seglist[ilist[0][2]]=1\\n    #print(seglist)\\n    #print(ilist)\\n    #print(ilist)\\n    goodvalue=-1\\n    currentmax=ilist[0][1]\\n    for k in range(n-1):\\n        if currentmax>=ilist[k+1][0]:\\n            seglist[ilist[k+1][2]]=1\\n            currentmax=max([currentmax,ilist[k+1][1]])\\n        if currentmax<ilist[k+1][0]:\\n            break\\n            \\n    #for k in range(goodvalue+1,n):        \\n    #    seglist[ilist[k][2]]=2    \\n    #    print(k)\\n    #print(seglist)    \\n    if sum(seglist)==n:\\n        print(-1)\\n    else:\\n        print(*seglist)\", \"n = int(input())\\n\\nfor t in range(n):\\n\\n    k = int(input())\\n    samples = []\\n    for i in range(k):\\n        samples.append(tuple(map(int, input().split())))\\n\\n    samples = sorted(enumerate(samples), key=lambda x: x[1])\\n\\n    tick = 1\\n    ans = [1]\\n    group_end = samples[0][1][1]\\n\\n    for si in range(1, len(samples)):\\n        now = samples[si][1]\\n        if now[0] > group_end:\\n            tick = 2\\n        else:\\n            group_end = max(now[1], group_end)\\n            ans.append(1)\\n        if tick == 2:\\n            ans.extend([2] * (len(samples) - si))\\n            break\\n\\n    ans = sorted(zip(samples, ans))\\n    ans = list([x[1] for x in ans])\\n    if 2 not in ans:\\n        print(-1)\\n    else:\\n        print(' '.join(map(str, ans)))\\n\\n\", \"import math\\n\\n\\ndef is_intersect(l1, r1, l2, r2):\\n    return (l1 < l2 and r1 >= l2) or (l1 >= l2 and l1 <= r2)\\n\\n\\ndef get_groups(ranges):\\n    ranges.sort(key=lambda x: x[1])\\n    ranges.sort(key=lambda x: x[0])\\n    ranges[0][3] = 1\\n    group1 = ranges[0][:2]\\n    group2 = None\\n    for i, rng in enumerate(ranges[1:]):\\n        l, r = rng[:2]\\n        if is_intersect(l, r, *group1) and ((group2 is None) or not is_intersect(l, r, group2)):\\n            rng[3] = 1\\n            group1[0] = min(group1[0], l)\\n            group1[1] = max(group1[1], r)\\n        elif not is_intersect(l, r, *group1):\\n            if group2 is None:\\n                group2 = [l, r]\\n            else:\\n                group2[0] = min(group2[0], l)\\n                group2[1] = max(group2[1], r)\\n            rng[3] = 2\\n        else:\\n            return -1\\n    if group2 is None:\\n        return -1\\n    ranges.sort(key=lambda x: x[2])\\n    return ' '.join(list(map(str, (rng[3] for rng in ranges))))\\n\\n\\n\\ndef __starting_point():\\n    n = int(input())\\n    for i in range(n):\\n        k = int(input())\\n        arr = [None] * k\\n        for j in range(k):\\n            arr[j] = list(map(int, input().split())) + [j, -1]\\n        print(get_groups(arr))\\n\\n__starting_point()\", \"q=int(input())\\nfor i in range(q):\\n\\tn=int(input())\\n\\tarr=[0 for i in range(n)]\\n\\tfor i in range(n):\\n\\t\\ttemp=list(map(int,input().split()))\\n\\t\\ttemp.append(i)\\n\\t\\tarr[i]=temp\\n\\tarr=sorted(arr,key=lambda l:l[0])\\n\\t#print(arr)\\n\\tans=[1 for i in range(n)]\\n\\t# if(arr[0][1]<arr[1][0]):\\n\\t# \\tans[0]=2\\n\\t# \\tfor i in range(n):\\n\\t# \\t\\tprint(ans[i],end=' ')\\n\\t# \\tprint()\\n\\t# \\tcontinue\\n\\t# if(arr[n-1][0]>arr[n-2][1]):\\n\\t# \\tans[n-1]=2\\n\\t# \\tfor i in range(n):\\n\\t# \\t\\tprint(ans[i],end=' ')\\n\\t# \\tprint()\\n\\t# \\tcontinue\\n\\tyoyo=-1\\n\\tmaxa=arr[0][1]\\n\\tfor i in range(1,n):\\n\\t\\tif(arr[i][0]>maxa):\\n\\t\\t\\tyoyo=i\\n\\t\\t\\tbreak\\n\\t\\tif(arr[i][1]>maxa):\\n\\t\\t\\tmaxa=arr[i][1]\\n\\tif(yoyo==-1):\\n\\t\\tprint(-1)\\n\\t\\tcontinue\\n\\telse:\\n\\t\\tfor i in range(yoyo,n):\\n\\t\\t\\tans[arr[i][2]]=2\\n\\tfor i in range(n):\\n\\t\\tprint(ans[i],end=' ')\\n\\tprint()\\n\", \"T = int(input())\\nfor _ in range(T):\\n    n = int(input())\\n    events = []\\n    results = [0 for i in range(n)]\\n    fail = False\\n    for i in range(n):\\n        l, r = map(int, input().split())\\n        events.append((l, 0, i))\\n        events.append((r, 1, i))\\n\\n    events.sort()\\n    cnt = 0\\n    cur_seg = 1\\n    for _, t, i in events:\\n        if t == 0:\\n            cnt += 1\\n            results[i] = cur_seg\\n        else:\\n            cnt -= 1\\n\\n        if cnt == 0:\\n            cur_seg = 1 + cur_seg % 2\\n\\n    if len(set(results)) == 2:\\n        print(*results)\\n    else:\\n        print(-1)\", \"q = int(input())\\nwhile q > 0:\\n    q = q-1\\n    L = []\\n    n = int(input())\\n    for i in range(n):\\n        L.append(tuple(map(int, input().split())))\\n    d = {}\\n    ind = 0\\n    for i in L:\\n        if i not in d:\\n            d[i] = []\\n        d[i].append(ind)\\n        ind += 1\\n    S = sorted(L)\\n    r = S[0][1]\\n    i = 1\\n    while i < n:\\n        if S[i][0] > r:\\n            break\\n        r = max(r,S[i][1])\\n        i += 1\\n    #print(S,i)\\n    if i == n:\\n        print(-1)\\n    else:\\n        while i < n:\\n            d[S[i]].append(-2)\\n            i += 1\\n        for i in L:\\n            if d[i][-1] == -2:\\n                print(2,end=' ')\\n            else:\\n                print(1,end=' ')\\n        print()\", \"T = int(input())\\nfor _ in range(T):\\n    n = int(input())\\n    s = []\\n    for k in range(n):\\n        l, r = [int(i) for i in input().split()]\\n        s.append([l, 1, k])\\n        s.append([r, 2, k])\\n    s.sort()\\n    u = [2] * n\\n    o = set()\\n    for i in s:\\n        u[i[2]] = 1\\n        if i[2] not in o:\\n            o.add(i[2])\\n        else:\\n            o.remove(i[2])\\n        if not o:\\n            if i != s[-1]:\\n                print(*u)\\n                break\\n    else:\\n        print(-1)\\n\", \"t = int(input())\\n\\nfor test in range(t):\\n    n = int(input())\\n    ans = ['1' for i in range(n)]\\n\\n    start, end = dict(), dict()\\n    for i in range(n):\\n        a, b = list(map(int, input().split()))\\n        if a in start:\\n            start[a].append(i + 1)\\n        else:\\n            start[a] = [i + 1]\\n\\n        if (i + 1) in end:\\n            end[i + 1].append(b)\\n        else:\\n            end[i + 1] = [b]\\n\\n    st_sorted = sorted(list(start.keys()))\\n\\n    m = 0\\n    ok = False\\n    ans_pos = -1\\n    for pos in range(len(st_sorted) - 1):\\n        for i in start[st_sorted[pos]]:\\n            m = max(m, max(end[i]))\\n        if m < st_sorted[pos + 1]:\\n            ok = True\\n            ans_pos = pos\\n            break\\n    if ok:\\n        for i in range(pos + 1, len(st_sorted)):\\n            for pos in start[st_sorted[i]]:\\n                ans[pos - 1] = '2'\\n        print(' '.join(ans))\\n    else:\\n        print(-1)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n2\\n5 5\\n2 3\\n3\\n3 5\\n2 3\\n2 3\\n3\\n3 3\\n4 4\\n5 5\\n\"\n  ],\n  \"outputs\": [\n    \"2 1 \\n-1\\n1 1 2 \\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1101/C", "starter_code": ""}
{"id": 107, "question": "Chaneka has a hobby of playing with animal toys. Every toy has a different fun value, a real number. Chaneka has four boxes to store the toys with specification:   The first box stores toys with fun values in range of $(-\\infty,-1]$.  The second box stores toys with fun values in range of $(-1, 0)$.  The third box stores toys with fun values in range of $(0, 1)$.  The fourth box stores toys with fun value in range of $[1, \\infty)$. \n\nChaneka has $A$, $B$, $C$, $D$ toys in the first, second, third, and fourth box, respectively. One day she decides that she only wants one toy, a super toy. So she begins to create this super toy by sewing all the toys she has.\n\nWhile the number of toys Chaneka has is more than 1, she takes two different toys randomly and then sews them together, creating a new toy. The fun value of this new toy is equal to the multiplication of fun values of the sewn toys. She then puts this new toy in the appropriate box. She repeats this process until she only has one toy. This last toy is the super toy, and the box that stores this toy is the special box.\n\nAs an observer, you only know the number of toys in each box initially but do not know their fun values. You also don't see the sequence of Chaneka's sewing. Determine which boxes can be the special box after Chaneka found her super toy.\n\n\n-----Input-----\n\nThe first line has an integer $T$ $(1 \\le T \\le 5 \\cdot 10^4)$, the number of test cases.\n\nEvery case contains a line with four space-separated integers $A$ $B$ $C$ $D$ $(0 \\le A, B, C, D \\le 10^6, A + B + C + D > 0)$, which denotes the number of toys in the first, second, third, and fourth box, respectively.\n\n\n-----Output-----\n\nFor each case, print four space-separated strings. Each string represents the possibility that the first, second, third, and fourth box can be the special box from left to right.\n\nFor each box, print \"Ya\" (Without quotes, Indonesian for yes) if that box can be the special box. Print \"Tidak\" (Without quotes, Indonesian for No) otherwise.\n\n\n-----Example-----\nInput\n2\n1 2 0 1\n0 1 0 0\n\nOutput\nYa Ya Tidak Tidak\nTidak Ya Tidak Tidak\n\n\n\n-----Note-----\n\nFor the first case, here is a scenario where the first box is the special box:   The first box had toys with fun values $\\{-3\\}$.  The second box had toys with fun values $\\{ -0.5, -0.5 \\}$  The fourth box had toys with fun values $\\{ 3 \\}$ \n\nThe sewing sequence:   Chaneka sews the toy with fun $-0.5$ and $-0.5$ to a toy with fun $0.25$ and then put it in the third box.  Chaneka sews the toy with fun $-3$ and $0.25$ to a toy with fun $-0.75$ and then put it in the second box.  Chaneka sews the toy with fun $-0.75$ and $3$ to a toy with fun $-1.25$ and then put it in the first box, which then became the special box. \n\nHere is a scenario where the second box ends up being the special box:   The first box had toys with fun values $\\{-3\\}$  The second box had toys with fun values $\\{ -0.33, -0.25 \\}$.  The fourth box had toys with fun values $\\{ 3 \\}$. \n\nThe sewing sequence:   Chaneka sews the toy with fun $-3$ and $-0.33$ to a toy with fun $0.99$ and then put it in the third box.  Chaneka sews the toy with fun $0.99$ and $3$ to a toy with fun $2.97$ and then put in it the fourth box.  Chaneka sews the toy with fun $2.97$ and $-0.25$ to a toy with fun $-0.7425$ and then put it in the second box, which then became the special box.  There is only one toy for the second case, so Chaneka does not have to sew anything because that toy, by definition, is the super toy.", "solutions": "[\"t = int(input())\\nfor _ in range(t):\\n  a, b, c, d = [int(i) for i in input().split(\\\" \\\")]\\n  sgn = (a+b)%2\\n  small = False\\n  large = False\\n  if a == 0 and d == 0:\\n    small = True\\n  if b == 0 and c == 0:\\n    large = True\\n  okay = [True] * 4\\n  if sgn == 0:\\n    okay[0] = False\\n    okay[1] = False\\n  else:\\n    okay[2] = False\\n    okay[3] = False\\n  if small:\\n    okay[0] = False\\n    okay[3] = False\\n  if large:\\n    okay[1] = False\\n    okay[2] = False\\n  print(\\\" \\\".join([\\\"Ya\\\" if okay[i] else \\\"Tidak\\\" for i in range(4)]))\", \"t=int(input())\\nfor you in range(t):\\n    l=input().split()\\n    a=int(l[0])\\n    b=int(l[1])\\n    c=int(l[2])\\n    d=int(l[3])\\n    z=a+b\\n    if(z%2==0):\\n        print(\\\"Tidak Tidak\\\",end=\\\" \\\")\\n        if(b>0 or c>0):\\n            print(\\\"Ya\\\",end=\\\" \\\")\\n        else:\\n            print(\\\"Tidak\\\",end=\\\" \\\")\\n        if(a>0 or d>0):\\n            print(\\\"Ya\\\")\\n        else:\\n            print(\\\"Tidak\\\")\\n    else:\\n        if(a>0 or d>0):\\n            print(\\\"Ya\\\",end=\\\" \\\")\\n        else:\\n            print(\\\"Tidak\\\",end=\\\" \\\")\\n        if(b>0 or c>0):\\n            print(\\\"Ya\\\",end=\\\" \\\")\\n        else:\\n            print(\\\"Tidak\\\",end=\\\" \\\")\\n        print(\\\"Tidak Tidak\\\")\", \"import sys\\n\\nt = int(input())\\n\\nfor i in range(t):\\n    a1, a2, a3, a4  = list(map(int, input().split()))\\n    \\n    neg = (a1 + a2) % 2 == 1\\n    \\n    \\n    large =  (a1 == 0 and a4 == 0)\\n    small  = (a2 == 0 and a3 == 0)\\n    \\n    r1, r2, r3, r4 = True, True, True, True\\n    if(neg):\\n        r3, r4 = False, False\\n    else:\\n        r1, r2 = False, False\\n        \\n    if large:\\n        r1, r4 = False,False\\n        \\n    if small:\\n        r2, r3 = False, False\\n        \\n    res = ''\\n    for j in [r1, r2, r3, r4]:\\n        if (j):\\n            res += 'Ya '\\n        else:\\n            res += 'Tidak '\\n    \\n    print(res[:-1])    \\n        \\n\", \"from sys import stdin, stdout\\nfrom collections import defaultdict\\ninput = stdin.readline\\n\\nfor _ in range(int(input())):\\n\\ta, b, c, d = map(int, input().split())\\n\\tsmall , large, positive = 0, 0, 1\\n\\tif a>0 or d>0:\\n\\t\\tlarge = 1\\n\\tif b>0 or c>0:\\n\\t\\tsmall = 1\\n\\tif (a+b)%2:\\n\\t\\tpositive = 0\\n\\tl = list()\\n\\tif large and not positive:\\n\\t\\tl.append('Ya')\\n\\telse:\\n\\t\\tl.append('Tidak')\\n\\tif small and not positive:\\n\\t\\tl.append('Ya')\\n\\telse:\\n\\t\\tl.append('Tidak')\\n\\tif small and positive:\\n\\t\\tl.append('Ya')\\n\\telse:\\n\\t\\tl.append('Tidak')\\n\\tif large and positive:\\n\\t\\tl.append('Ya')\\n\\telse:\\n\\t\\tl.append('Tidak')\\n\\tprint(*l)\", \"t = int(input())\\nfor _ in range(t):\\n    a, b, c, d = list(map(int, input().split()))\\n    possible = ['Ya', 'Ya', 'Ya', 'Ya']\\n    if (a+b)%2 == 0:\\n        possible[0] = 'Tidak'\\n        possible[1] = 'Tidak'\\n    else:\\n        possible[2] = 'Tidak'\\n        possible[3] = 'Tidak'\\n    if (a+d) == 0:\\n        possible[0] = 'Tidak'\\n        possible[3] = 'Tidak'\\n    if (b+c) == 0:\\n        possible[1] = 'Tidak'\\n        possible[2] = 'Tidak'\\n\\n    print(' '.join(possible))\\n\", \"t=int(input())\\nwhile(t>0):\\n    t=t-1\\n    l=input().split()\\n    a=int(l[0])\\n    b=int(l[1])\\n    c=int(l[2])\\n    d=int(l[3])\\n   # print(a,b,c,d)\\n    #for a\\n    if(a!=0):\\n        if((a+b)%2==1):\\n            print(\\\"Ya\\\",end=\\\" \\\")\\n        else:\\n            print(\\\"Tidak\\\",end=\\\" \\\")\\n    else:\\n        if(d>=1  and (a+b)%2==1):\\n            print(\\\"Ya\\\",end=\\\" \\\")\\n        else:\\n            print(\\\"Tidak\\\",end=\\\" \\\")\\n    if(b!=0):\\n        if((a+b)%2):\\n            print(\\\"Ya\\\",end=\\\" \\\")\\n        else:\\n            print(\\\"Tidak\\\",end=\\\" \\\")\\n    else:\\n        if(c>=1  and (a+b)%2==1):\\n            print(\\\"Ya\\\",end=\\\" \\\")\\n        else:\\n            print(\\\"Tidak\\\",end=\\\" \\\")\\n    if(c!=0):\\n        if((a+b)%2==0):\\n            print(\\\"Ya\\\",end=\\\" \\\")\\n        else:\\n            print(\\\"Tidak\\\",end=\\\" \\\")\\n    else:\\n        if(b>=1  and (a+b)%2==0):\\n            print(\\\"Ya\\\",end=\\\" \\\")\\n        else:\\n            print(\\\"Tidak\\\",end=\\\" \\\")\\n    if(d!=0):\\n        if((a+b)%2==0):\\n            print(\\\"Ya\\\",end=\\\" \\\")\\n        else:\\n            print(\\\"Tidak\\\",end=\\\" \\\")\\n    else:\\n        if(a>=1  and (a+b)%2==0):\\n            print(\\\"Ya\\\",end=\\\" \\\")\\n        else:\\n            print(\\\"Tidak\\\",end=\\\" \\\")\\n    print()\", \"for _ in range(int(input())):\\n    a,b,c,d=list(map(int,input().split()))\\n    if (a+b)%2==0:\\n        if (b!=0 or c!=0) and (a!=0 or d!=0):\\n            print(\\\"Tidak Tidak Ya Ya\\\")\\n        elif d!=0 or a!=0:\\n            print(\\\"Tidak Tidak Tidak Ya\\\")\\n        elif b!=0 or c!=0:\\n            print(\\\"Tidak Tidak Ya Tidak\\\")\\n    else:\\n        if (b!=0 or c!=0) and (a!=0 or d!=0):\\n            print(\\\"Ya Ya Tidak Tidak\\\")\\n        elif d!=0 or a!=0:\\n            print(\\\"Ya Tidak Tidak Tidak\\\")\\n        elif b!=0 or c!=0:\\n            print(\\\"Tidak Ya Tidak Tidak\\\")\\n    \\n            \\n\", \"\\nt = int(input())\\nfor i in range(t):\\n    a, b, c, d = list(map(int, input().split()))\\n    ans = ['Tidak', 'Tidak', 'Tidak', 'Tidak']\\n    if ((a + b) % 2 == 1) and ((a + d) > 0):\\n        ans[0] = 'Ya'\\n    if ((a + b) % 2 == 1) and (((a + d) == 0) or ((b + c) > 0)):\\n        ans[1] = 'Ya'\\n    if ((a + b) % 2 == 0) and (((a + d) == 0) or ((b + c) > 0)):\\n        ans[2] = 'Ya'\\n    if ((a + b) % 2 == 0) and ((a + d) > 0):\\n        ans[3] = 'Ya'\\n    print(' '.join(ans))\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"2\\n1 2 0 1\\n0 1 0 0\\n\"\n  ],\n  \"outputs\": [\n    \"Ya Ya Tidak Tidak\\nTidak Ya Tidak Tidak\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1425/H", "starter_code": ""}
{"id": 108, "question": "You're given an array $a_1, \\ldots, a_n$ of $n$ non-negative integers.\n\nLet's call it sharpened if and only if there exists an integer $1 \\le k \\le n$ such that $a_1 < a_2 < \\ldots < a_k$ and $a_k > a_{k+1} > \\ldots > a_n$. In particular, any strictly increasing or strictly decreasing array is sharpened. For example:  The arrays $[4]$, $[0, 1]$, $[12, 10, 8]$ and $[3, 11, 15, 9, 7, 4]$ are sharpened;  The arrays $[2, 8, 2, 8, 6, 5]$, $[0, 1, 1, 0]$ and $[2, 5, 6, 9, 8, 8]$ are not sharpened. \n\nYou can do the following operation as many times as you want: choose any strictly positive element of the array, and decrease it by one. Formally, you can choose any $i$ ($1 \\le i \\le n$) such that $a_i>0$ and assign $a_i := a_i - 1$.\n\nTell if it's possible to make the given array sharpened using some number (possibly zero) of these operations.\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 15\\ 000$) \u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$).\n\nThe second line of each test case contains a sequence of $n$ non-negative integers $a_1, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, output a single line containing \"Yes\" (without quotes) if it's possible to make the given array sharpened using the described operations, or \"No\" (without quotes) otherwise.\n\n\n-----Example-----\nInput\n10\n1\n248618\n3\n12 10 8\n6\n100 11 15 9 7 8\n4\n0 1 1 0\n2\n0 0\n2\n0 1\n2\n1 0\n2\n1 1\n3\n0 1 0\n3\n1 0 1\n\nOutput\nYes\nYes\nYes\nNo\nNo\nYes\nYes\nYes\nYes\nNo\n\n\n\n-----Note-----\n\nIn the first and the second test case of the first test, the given array is already sharpened.\n\nIn the third test case of the first test, we can transform the array into $[3, 11, 15, 9, 7, 4]$ (decrease the first element $97$ times and decrease the last element $4$ times). It is sharpened because $3 < 11 < 15$ and $15 > 9 > 7 > 4$.\n\nIn the fourth test case of the first test, it's impossible to make the given array sharpened.", "solutions": "[\"for _ in range(int(input())):\\n    n=int(input())\\n    li=list(map(int,input().split()))\\n    ans=0\\n    for i in range(n):\\n        if li[i]>=i:\\n            ans+=1\\n        else:\\n            break\\n    for i in range(n):\\n        if li[n-1-i]>=i:\\n            ans+=1\\n        else:\\n            break\\n    if ans>n:\\n        print(\\\"Yes\\\")\\n    else:\\n        print(\\\"No\\\")\", \"for nt in range(int(input())):\\n\\tn=int(input())\\n\\tl=list(map(int,input().split()))\\n\\tpoint = -1\\n\\tfor i in range(n):\\n\\t\\tif l[i]<i:\\n\\t\\t\\tpoint = i-1\\n\\t\\t\\tbreak\\n\\tif point == -1:\\n\\t\\tprint (\\\"Yes\\\")\\n\\telse:\\n\\t\\tflag=0\\n\\t\\tfor i in range(n-1,point-1,-1):\\n\\t\\t\\tif l[i]<(n-1-i):\\n\\t\\t\\t\\tflag=1\\n\\t\\t\\t\\tprint (\\\"No\\\")\\n\\t\\t\\t\\tbreak\\n\\t\\tif flag==0:\\n\\t\\t\\tprint (\\\"Yes\\\")\", \"t = int(input().rstrip())\\n\\nfor i in range(t):\\n    n = int(input().rstrip())\\n    nums = list(map(int, input().rstrip().split()))\\n    forw = 0\\n    back = n-1\\n\\n    for j in range(n):\\n        if nums[j] >= j:\\n            forw = j\\n        else:\\n            break\\n    \\n    for j in range(1, n+1):\\n        if nums[-j] >= j-1:\\n            back = n-j\\n        else:\\n            break\\n    \\n    if forw >= back:\\n        print(\\\"Yes\\\")\\n    else:\\n        print(\\\"No\\\")\", \"def f(a):\\n    for i in range(len(a)):\\n        if a[i] < i: return i-1\\n    return len(a)-1\\n\\ndef solve(a):\\n    i = f(a)\\n    j = len(a) - 1 - f(a[::-1])\\n    return \\\"Yes\\\" if i >= j else \\\"No\\\"\\n\\n\\nn = int(input())\\nfor i in range(n):\\n    input()\\n    a = list(map(int, input().strip().split()))\\n    print(solve(a))\", \"import sys\\ninput = sys.stdin.readline\\n\\nt = int(input())\\n\\nfor testcase in range(t):\\n    n = int(input())\\n    a = list(map(int,input().split()))\\n\\n    left = n-1\\n    for i in range(n):\\n        if a[i] <= i-1:\\n            left = i-1\\n            break\\n    \\n    right = 0\\n    for i in range(n-1,-1,-1):\\n        if a[i] < n-1-i:\\n            right = i+1\\n            break\\n    \\n\\n    if right <= left:\\n        print('Yes')\\n    else:\\n        print('No')\", \"T = int(input())\\nfor _ in range(T):\\n    N = int(input())\\n    A = list(map(int,input().split()))\\n    if N%2:\\n        X = [i if i<N//2 else N-i-1 for i in range(N)]\\n        if all(a>=x for a,x in zip(A,X)):\\n            print('Yes')\\n        else:\\n            print('No')\\n    else:\\n        X = [i if i<N//2+1 else N-i-1 for i in range(N)]\\n        if all(a>=x for a,x in zip(A,X)):\\n            print('Yes')\\n            continue\\n        X[N//2-1], X[N//2] = X[N//2], X[N//2-1]\\n        if all(a>=x for a,x in zip(A,X)):\\n            print('Yes')\\n        else:\\n            print('No')\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"10\\n1\\n248618\\n3\\n12 10 8\\n6\\n100 11 15 9 7 8\\n4\\n0 1 1 0\\n2\\n0 0\\n2\\n0 1\\n2\\n1 0\\n2\\n1 1\\n3\\n0 1 0\\n3\\n1 0 1\\n\"\n  ],\n  \"outputs\": [\n    \"Yes\\nYes\\nYes\\nNo\\nNo\\nYes\\nYes\\nYes\\nYes\\nNo\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1291/B", "starter_code": ""}
{"id": 109, "question": "You have a bag of size $n$. Also you have $m$ boxes. The size of $i$-th box is $a_i$, where each $a_i$ is an integer non-negative power of two.\n\nYou can divide boxes into two parts of equal size. Your goal is to fill the bag completely.\n\nFor example, if $n = 10$ and $a = [1, 1, 32]$ then you have to divide the box of size $32$ into two parts of size $16$, and then divide the box of size $16$. So you can fill the bag with boxes of size $1$, $1$ and $8$.\n\nCalculate the minimum number of divisions required to fill the bag of size $n$.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n \\le 10^{18}, 1 \\le m \\le 10^5$) \u2014 the size of bag and the number of boxes, respectively.\n\nThe second line of each test case contains $m$ integers $a_1, a_2, \\dots , a_m$ ($1 \\le a_i \\le 10^9$) \u2014 the sizes of boxes. It is guaranteed that each $a_i$ is a power of two.\n\nIt is also guaranteed that sum of all $m$ over all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case print one integer \u2014 the minimum number of divisions required to fill the bag of size $n$ (or $-1$, if it is impossible).\n\n\n-----Example-----\nInput\n3\n10 3\n1 32 1\n23 4\n16 1 4 1\n20 5\n2 1 16 1 8\n\nOutput\n2\n-1\n0", "solutions": "[\"import sys\\nimport math\\nfrom collections import defaultdict\\nfrom collections import deque\\nfrom itertools import combinations\\nfrom itertools import permutations\\ninput = lambda : sys.stdin.readline().rstrip()\\nread = lambda : list(map(int, input().split()))\\ngo = lambda : 1/0\\ndef write(*args, sep=\\\"\\\\n\\\"):\\n  for i in args:\\n    sys.stdout.write(\\\"{}{}\\\".format(i, sep))\\nINF = float('inf')\\nMOD = int(1e9 + 7)\\nYES = \\\"YES\\\"\\nNO = -1\\n\\nfor _ in range(int(input())):\\n  try:\\n    n, m = read()\\n    arr = read()\\n    x = [0] * 65\\n    \\n    if sum(arr) < n:\\n      print(NO)\\n      go()\\n  \\n    for i in arr:\\n      x[int(math.log2(i))] += 1\\n    \\n    ans = 0\\n    for i in range(65):\\n      if (1 << i) & n:\\n        if x[i] != 0:\\n          x[i] -= 1\\n          continue \\n\\n        total = 0\\n        for j in range(i):\\n          total += (1 << j) * x[j]\\n        \\n        if total >= (1 << i):\\n          temp = 1 << i \\n          for j in reversed(range(i)):\\n            while temp - (1 << j) >= 0 and x[j] > 0:\\n              temp -= 1 << j \\n              x[j] -= 1\\n          continue \\n        \\n        j = i\\n        while j < 65 and x[j] == 0:\\n          j += 1\\n        if j == 65:\\n          print(NO)\\n          go() \\n        else:\\n          x[j] -= 1\\n          for k in range(i, j):\\n            x[k] += 1\\n          ans += (j - i)\\n    \\n    print(ans)\\n\\n\\n  except ZeroDivisionError:\\n    continue\\n\\n  except Exception as e:\\n    print(e)\\n    continue\", \"import math\\nt = int(input())\\nM2 = [1]\\nfor i in range(35):\\n    M2.append(M2[-1]*2)\\nfor i in range(t):\\n    n, m = map(int,input().split())\\n    A = list(map(int,input().split()))\\n    if sum(A) < n:\\n        print(-1)\\n    else:\\n        B = [0] * 33\\n        for i in range(m):\\n            B[int(math.log2(A[i]))] += 1\\n        # print(B[:10])\\n        C = [0] * 33\\n        nn = n\\n        for i in range(33):\\n            C[i] = nn%2\\n            nn//=2\\n            if nn==0:\\n                break\\n        # print(C)\\n        b = 0\\n        c = 0\\n        i = 0\\n        ans = 0\\n        ok = 0\\n        while i < len(B):\\n            while i < len(B) and b >= c:\\n                b += B[i] * M2[i]\\n                c += C[i] * M2[i]\\n                B[i]=0\\n                i += 1\\n            if i == len(B) and b >= c:\\n                print(ans)\\n                ok = 1\\n                break\\n            else:\\n                i-=1\\n                while B[i] == 0:\\n                    i += 1\\n                    ans += 1\\n                    # print(\\\"ansplus\\\",i)\\n                B[i] -= 1\\n                b=0\\n                c=0\\n            if ok==1:\\n                break\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n10 3\\n1 32 1\\n23 4\\n16 1 4 1\\n20 5\\n2 1 16 1 8\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n-1\\n0\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1303/D", "starter_code": ""}
{"id": 110, "question": "On February 14 Denis decided to give Valentine to Nastya and did not come up with anything better than to draw a huge red heart on the door of the length $k$ ($k \\ge 3$). Nastya was very confused by this present, so she decided to break the door, throwing it on the mountains.\n\nMountains are described by a sequence of heights $a_1, a_2, \\dots, a_n$ in order from left to right ($k \\le n$). It is guaranteed that neighboring heights are not equal to each other (that is, $a_i \\ne a_{i+1}$ for all $i$ from $1$ to $n-1$).\n\nPeaks of mountains on the segment $[l,r]$ (from $l$ to $r$) are called indexes $i$ such that $l < i < r$, $a_{i - 1} < a_i$ and $a_i > a_{i + 1}$. It is worth noting that the boundary indexes $l$ and $r$ for the segment are not peaks. For example, if $n=8$ and $a=[3,1,4,1,5,9,2,6]$, then the segment $[1,8]$ has only two peaks (with indexes $3$ and $6$), and there are no peaks on the segment $[3, 6]$.\n\nTo break the door, Nastya throws it to a segment $[l,l+k-1]$ of consecutive mountains of length $k$ ($1 \\le l \\le n-k+1$). When the door touches the peaks of the mountains, it breaks into two parts, after that these parts will continue to fall in different halves and also break into pieces when touching the peaks of the mountains, and so on. Formally, the number of parts that the door will break into will be equal to $p+1$, where $p$ is the number of peaks on the segment $[l,l+k-1]$.\n\nNastya wants to break it into as many pieces as possible. Help her choose such a segment of mountains $[l, l+k-1]$ that the number of peaks on it is maximum. If there are several optimal segments, Nastya wants to find one for which the value $l$ is minimal.\n\nFormally, you need to choose a segment of mountains $[l, l+k-1]$ that has the maximum number of peaks. Among all such segments, you need to find the segment that has the minimum possible value $l$.\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u00a0\u2014 the number of test cases. Then the descriptions of the test cases follow.\n\nThe first line of each test case contains two integers $n$ and $k$ ($3 \\leq k \\leq n \\leq 2 \\cdot 10^5$) \u00a0\u2014 the number of mountains and the length of the door.\n\nThe second line of the input data set contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0 \\leq a_i \\leq 10 ^ 9$, $a_i \\neq a_{i + 1}$) \u00a0\u2014 the heights of mountains.\n\nIt is guaranteed that the sum of $n$ over all the test cases will not exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, output two integers $t$ and $l$ \u00a0\u2014 the maximum number of parts that the door can split into, and the left border of the segment of length $k$ that the door should be reset to.\n\n\n-----Example-----\nInput\n5\n8 6\n1 2 4 1 2 4 1 2\n5 3\n3 2 3 2 1\n10 4\n4 3 4 3 2 3 2 1 0 1\n15 7\n3 7 4 8 2 3 4 5 21 2 3 4 2 1 3\n7 5\n1 2 3 4 5 6 1\n\nOutput\n3 2\n2 2\n2 1\n3 1\n2 3\n\n\n\n-----Note-----\n\nIn the first example, you need to select a segment of mountains from $2$ to $7$. In this segment, the indexes $3$ and $6$ are peaks, so the answer is $3$ (only $2$ peaks, so the door will break into $3$ parts). It is not difficult to notice that the mountain segments $[1, 6]$ and $[3, 8]$ are not suitable since they only have a $1$ peak (for the first segment, the $6$ index is not a peak, and for the second segment, the $3$ index is not a peak).\n\nIn the second example, you need to select a segment of mountains from $2$ to $4$. In this segment, the index $3$ is a peak, so the answer is $2$ (only $1$ peak, so the door will break into $2$ parts).\n\nIn the third example, you need to select a segment of mountains from $1$ to $4$. In this segment, the index $3$ is a peak, so the answer is $2$ (only $1$ peak, so the door will break into $2$ parts). You can see that on the segments $[2, 5]$, $[4, 7]$ and $[5, 8]$ the number of peaks is also $1$, but these segments have a left border greater than the segment $[1, 4]$, so they are not the correct answer.", "solutions": "[\"for _ in range(int(input())):\\n    n, k = tuple(map(int, input().split()))\\n    arr = list(map(int, input().split()))\\n\\n    peaks = [0 for i in range(n)]\\n    for i in range(1, n - 1):\\n        if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:\\n            peaks[i] = 1\\n\\n    cnt = 0\\n    max_peaks = 0\\n    answer = 0\\n\\n    for i in range(k - 1):\\n        cnt += peaks[i]\\n        max_peaks += peaks[i]\\n\\n    for i in range(k - 1, n - 1):\\n        cnt -= peaks[i - k + 2]\\n        cnt += peaks[i]\\n        if cnt > max_peaks:\\n            max_peaks = cnt\\n            answer = i - k + 2\\n\\n    print(max_peaks + 1, answer + 1)\\n\", \"from math import *\\nfrom random import *\\nfor t in range(int(input())):\\n    n, k = map(int, input().split())\\n    mas = list(map(int, input().split()))\\n    pick = [0 for i in range(n)]\\n    for i in range(1, n - 1):\\n        pick[i] = pick[i - 1]\\n        if mas[i] > mas[i - 1] and mas[i] > mas[i + 1]:\\n            pick[i] += 1\\n    if n > 1:\\n        pick[n - 1] = pick[n - 2]\\n    mx = 0\\n    mxotv = 0\\n    for i in range(0, n - k + 1):\\n        if i + k - 2 < 0:\\n            continue\\n        res = pick[i + k - 2]\\n        res -= pick[i]\\n        if res > mx:\\n            mx = res\\n            mxotv = i\\n    print(mx + 1, mxotv + 1)\", \"#list(map(int,input().split()))\\nt=int(input())\\nfor _ in range(t):\\n    n,k=list(map(int,input().split()))\\n    aa=list(map(int,input().split()))\\n    tot=0\\n    ind=1\\n    \\n    for i in range(1,k-1):\\n        if(aa[i]>aa[i-1] and aa[i]>aa[i+1]):\\n            tot+=1\\n  #  print(tot)\\n    ma=tot+1\\n    for i in range(1,n):\\n        if(i+k-1>=n):\\n            continue\\n        if(aa[i]>aa[i-1] and aa[i]>aa[i+1]):\\n            tot-=1\\n        if(aa[i+k-2]>aa[i+k-3] and aa[i+k-2]>aa[i+k-1]):\\n            tot+=1\\n        if(tot+1>ma):\\n            ma=tot+1\\n            ind=i+1\\n      #  print(tot)\\n    print(ma,ind)\\n            \\n        \\n    \\n\", \"t = int(input())\\nfor qq in range(t):\\n    n, k = list(map(int, input().split()))\\n    m = list(map(int, input().split()))\\n    p = 0\\n    for i in range(n - k + 1, n - 1):\\n        if m[i] > m[i - 1] and m[i] > m[i + 1]:\\n            p += 1\\n    mp = p\\n    ii = n - k + 1\\n    for i in range(n - k, 0, -1):\\n        if m[i] > m[i - 1] and m[i] > m[i + 1]:\\n            p += 1\\n        if m[i + k - 2] > m[i + k - 3] and m[i + k - 2] > m[i + k - 1]:\\n            p -= 1\\n        if p >= mp:\\n            mp = p\\n            ii = i\\n    print(mp + 1, ii)\\n\", \"t=int(input())\\nfor _ in range(t):\\n    n,k=map(int,input().split())\\n    arr=list(map(int,input().split()))\\n    peaks=[0]*(n)\\n    for i in range(1,n-1):\\n        if arr[i]>arr[i-1] and arr[i]>arr[i+1]:\\n            peaks[i]=1\\n    acum=[0]\\n    for i in range(1,n):\\n        acum.append(acum[-1]+peaks[i])\\n    maxs=0\\n    pos=-1\\n    for i in range(n-k,-1,-1):\\n        tmp=acum[i+k-1]-acum[i]\\n        if peaks[i+k-1]==1:\\n            tmp-=1\\n        if tmp>=maxs:\\n            maxs=tmp\\n            pos=i\\n    print(maxs+1,pos+1)\", \"from _collections import deque\\n\\nfor _ in range(int(input())):\\n    n, k = list(map(int, input().split()))\\n    ar = list(map(int, input().split()))\\n    picks = 0\\n    lol = deque([])\\n    for i in range(1, k - 1):\\n        if ar[i - 1] < ar[i] > ar[i + 1]:\\n            picks += 1\\n            lol.append(i)\\n    max_picks = picks\\n    ans = 0\\n    for i in range(k - 1, n - 1):\\n        if len(lol) > 0 and lol[0] == i - k + 2:\\n            lol.popleft()\\n            picks -= 1\\n        if ar[i - 1] < ar[i] > ar[i + 1]:\\n            picks += 1\\n            lol.append(i)\\n        if picks > max_picks:\\n            max_picks = picks\\n            ans = i - k + 2\\n    print(max_picks + 1, ans + 1)\\n\", \"def mult_input():\\n\\treturn map(int,input().split())\\n\\ndef list_input():\\n\\treturn list(map(int,input().split()))\\n\\nfor nt in range(int(input())):\\n\\tn,k=mult_input()\\n\\tl=list(map(int,input().split()))\\n\\tans=0\\n\\tfor i in range(1,k-1):\\n\\t\\tif l[i]>l[i-1] and l[i]>l[i+1]:\\n\\t\\t\\tans+=1\\n\\tind=1\\n\\ti=1\\n\\tcount=ans\\n\\twhile i<n-k+1:\\n\\t\\tif l[i]>l[i-1] and l[i]>l[i+1]:\\n\\t\\t\\tcount-=1\\n\\t\\tif l[i+k-2]>l[i+k-3] and l[i+k-2]>l[i+k-1]:\\n\\t\\t\\tcount+=1\\n\\t\\tif count>ans:\\n\\t\\t\\tans=count\\n\\t\\t\\tind=i+1\\n\\t\\ti+=1\\n\\tprint (ans+1,ind)\", \"from collections import defaultdict as dd\\ndef ri():\\n    return int(input())\\n\\ndef rl():\\n    return list(map(int, input().split()))\\n\\n\\ndef solve():\\n    n, k = rl()\\n    A = rl()\\n    peaks = []\\n    for i in range(1, n - 1):\\n        if A[i] > max(A[i - 1], A[i + 1]):\\n            peaks.append(1)\\n        else:\\n            peaks.append(0)\\n\\n    best = sum(peaks[:k-2])\\n    curr = best\\n    best_l = 0\\n    for i in range(1, n - (k - 1)):\\n        curr -= peaks[i - 1]\\n        curr += peaks[i + k - 3]\\n        if curr > best:\\n            best = curr\\n            best_l = i\\n    return best + 1, best_l + 1\\n\\n\\n\\nt = ri()\\nfor i in range(t):\\n    print(*solve())\\n\", \"import sys\\nlines = sys.stdin.readlines()\\n# nums = lists(map(int, lines[0].strip().split(\\\" \\\")))\\nT = int(lines[0].strip())\\nfor t in range(T):\\n    (n, k) = list(map(int, lines[2*t+1].strip().split(\\\" \\\")))\\n    nums = list(map(int, lines[2*t+2].strip().split(\\\" \\\")))\\n    peaks = [0 for _ in range(n)]\\n\\n    for i in range(1, n-1):\\n        if nums[i] > nums[i-1] and nums[i] > nums[i+1]: peaks[i] = 1\\n    for i in range(1, n):\\n        peaks[i] += peaks[i-1]\\n    maxP = -1\\n    maxIndex = -1\\n    for i in range(n-k+1):\\n        if peaks[i+k-2] - peaks[i] > maxP:\\n            maxP = peaks[i+k-2] - peaks[i]\\n            maxIndex = i\\n    print(\\\"{} {}\\\".format(maxP+1, maxIndex+1))\\n\", \"import sys\\n\\ninput = sys.stdin.readline\\n\\nfor _ in range(int(input())):\\n    n, k = list(map(int, input().split()))\\n    a = list(map(int, input().split()))\\n    peak = [0] + [1 if a[i - 1] < a[i] and a[i] > a[i + 1] else 0 for i in range(1, n - 1)] + [0]\\n    b = [None] * (n - k + 1)\\n    b[0] = sum(peak[1 : k - 1])\\n    for i in range(1, n - k + 1):\\n        b[i] = b[i - 1] - peak[i] + peak[i + k - 2]\\n    p = max(b)    \\n    print(p + 1, b.index(p) + 1)\\n\", \"import sys\\n# from collections import defaultdict\\n# t=1\\nt=int(input())\\nfor i in range(t):\\n    # n=int(input())\\n    # n,m=list(map(int,sys.stdin.readline().strip().split()))\\n    # a,b,c,d=list(sys.stdin.readline().strip().split())\\n    n,k=list(map(int,sys.stdin.readline().strip().split()))\\n    # if(n*(a+b)>=(c-d) and n*(a-b)<=(c+d)):\\n    #     print(\\\"YES\\\")\\n    # else:\\n    #     print(\\\"NO\\\")\\n    \\n    a=list(map(int,sys.stdin.readline().strip().split()))\\n    x=[0]*n\\n    for j in range(1,n-1):\\n        if(a[j]>a[j-1] and a[j]>a[j+1]):\\n            x[j]=1\\n    # print(a)\\n    # print(x)\\n    k=k-2\\n    op=0\\n    curr=0\\n    curr=sum(x[:k])\\n    # print(x)\\n    # print(curr)\\n    op=curr\\n    op1=1\\n\\n    for j in range(k,n):\\n        # op=max(op,curr)\\n        curr=curr+x[j]-x[j-k]\\n        if(curr>op):\\n            # print(\\\"here\\\")\\n            op1=j-k+1\\n            op=curr\\n        # op=max(op,curr)\\n    op=max(op,curr)\\n    print(op+1,op1)\", \"t = int(input())\\nfor ii in range(t):\\n    n, k = map(int, input().split())\\n    a = list(map(int, input().split()))\\n    p = [0] * n\\n    for i in range(1, n - 1):\\n        if a[i] > a[i - 1] and a[i] > a[i + 1]:\\n            p[i] = 1\\n    cur = 0\\n    ind = k - 1\\n    for i in range(k):\\n        if i != 0 and i != k - 1:\\n            cur += p[i]\\n    ans = cur\\n    ans_ind = k - 1\\n    while ind < n:\\n        if p[ind - k + 2]:\\n            cur -= 1\\n        if p[ind]:\\n            cur += 1\\n        if cur > ans:\\n            ans = cur\\n            ans_ind = ind + 1\\n        ind += 1\\n    print(ans + 1, ans_ind - k + 2)\", \"t = int(input())\\nfor i in range(t):\\n    n, k = list(map(int, input().split()))\\n    a = list(map(int, input().split()))\\n    cnt = 0\\n    for j in range(k):\\n        if 0 < j < k - 1 and a[j - 1] < a[j] > a[j + 1]:\\n            cnt += 1\\n    ans = cnt\\n    l = 0\\n    for j in range(n - k):\\n        if a[j + 2] < a[j + 1] > a[j]:\\n            cnt -= 1\\n        if a[j + k - 2] < a[j + k - 1] > a[j + k]:\\n            cnt += 1\\n        if cnt > ans:\\n            ans = cnt\\n            l = j + 1\\n    print(ans + 1, l + 1)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"5\\n8 6\\n1 2 4 1 2 4 1 2\\n5 3\\n3 2 3 2 1\\n10 4\\n4 3 4 3 2 3 2 1 0 1\\n15 7\\n3 7 4 8 2 3 4 5 21 2 3 4 2 1 3\\n7 5\\n1 2 3 4 5 6 1\\n\"\n  ],\n  \"outputs\": [\n    \"3 2\\n2 2\\n2 1\\n3 1\\n2 3\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1341/B", "starter_code": ""}
{"id": 111, "question": "You are given an image, that can be represented with a 2-d n by m grid of pixels. Each pixel of the image is either on or off, denoted by the characters \"0\" or \"1\", respectively. You would like to compress this image. You want to choose an integer k > 1 and split the image into k by k blocks. If n and m are not divisible by k, the image is padded with only zeros on the right and bottom so that they are divisible by k. Each pixel in each individual block must have the same value. The given image may not be compressible in its current state. Find the minimum number of pixels you need to toggle (after padding) in order for the image to be compressible for some k. More specifically, the steps are to first choose k, then the image is padded with zeros, then, we can toggle the pixels so it is compressible for this k. The image must be compressible in that state.\n\n\n-----Input-----\n\nThe first line of input will contain two integers n, m (2 \u2264 n, m \u2264 2 500), the dimensions of the image.\n\nThe next n lines of input will contain a binary string with exactly m characters, representing the image.\n\n\n-----Output-----\n\nPrint a single integer, the minimum number of pixels needed to toggle to make the image compressible.\n\n\n-----Example-----\nInput\n3 5\n00100\n10110\n11001\n\nOutput\n5\n\n\n\n-----Note-----\n\nWe first choose k = 2.\n\nThe image is padded as follows: \n\n001000\n\n101100\n\n110010\n\n000000\n\n\n\nWe can toggle the image to look as follows: \n\n001100\n\n001100\n\n000000\n\n000000\n\n\n\nWe can see that this image is compressible for k = 2.", "solutions": "[\"#!/usr/bin/env python\\n# coding:utf-8\\n# Copyright (C) dirlt\\n\\nfrom sys import stdin\\n\\n\\ndef run(n, m, pixels):\\n    ans = 1 << 30\\n\\n    acc = [[0] * (m + 1) for _ in range(n + 1)]\\n    for i in range(n):\\n        for j in range(m):\\n            acc[i + 1][j + 1] = acc[i + 1][j] + int(pixels[i][j])\\n        for j in range(m):\\n            acc[i + 1][j + 1] += acc[i][j + 1]\\n    # print(acc)\\n\\n    for k in range(2, max(n, m) + 1):\\n        r, c = (n + k - 1) // k, (m + k - 1) // k\\n        res = 0\\n        for i in range(r):\\n            for j in range(c):\\n                x, y = i * k, j * k\\n                x2, y2 = min(x + k - 1, n - 1), min(y + k - 1, m - 1)\\n                zero = acc[x2 + 1][y2 + 1] - acc[x][y2 + 1] - acc[x2 + 1][y] + acc[x][y]\\n                # print(x, y, k, zero, k * k - zero)\\n                res += min(zero, k * k - zero)\\n        # print(k, res)\\n        ans = min(ans, res)\\n    print(ans)\\n\\n\\ndef main():\\n    n, m = [int(x) for x in stdin.readline().split()]\\n    pixels = []\\n    for i in range(n):\\n        pixels.append(stdin.readline().strip())\\n    run(n, m, pixels)\\n\\n\\ndef __starting_point():\\n    import os\\n\\n    if os.path.exists('tmp.in'):\\n        stdin = open('tmp.in')\\n    main()\\n\\n__starting_point()\"]", "input_output": "{\n  \"inputs\": [\n    \"3 5\\n00100\\n10110\\n11001\\n\"\n  ],\n  \"outputs\": [\n    \"5\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/838/A", "starter_code": ""}
{"id": 112, "question": "Now that Heidi has made sure her Zombie Contamination level checker works, it's time to strike! This time, the zombie lair is a strictly convex polygon on the lattice. Each vertex of the polygon occupies a point on the lattice. For each cell of the lattice, Heidi knows the level of Zombie Contamination \u2013 the number of corners of the cell that are inside or on the border of the lair.\n\nGiven this information, Heidi wants to know the exact shape of the lair to rain destruction on the zombies. Help her!\n\n[Image]\n\n\n-----Input-----\n\nThe input contains multiple test cases.\n\nThe first line of each test case contains one integer N, the size of the lattice grid (5 \u2264 N \u2264 500). The next N lines each contain N characters, describing the level of Zombie Contamination of each cell in the lattice. Every character of every line is a digit between 0 and 4. \n\nCells are given in the same order as they are shown in the picture above: rows go in the decreasing value of y coordinate, and in one row cells go in the order of increasing x coordinate. This means that the first row corresponds to cells with coordinates (1, N), ..., (N, N) and the last row corresponds to cells with coordinates (1, 1), ..., (N, 1).\n\nThe last line of the file contains a zero. This line should not be treated as a test case. The sum of the N values for all tests in one file will not exceed 5000.\n\n\n-----Output-----\n\nFor each test case, give the following output:\n\nThe first line of the output should contain one integer V, the number of vertices of the polygon that is the secret lair. The next V lines each should contain two integers, denoting the vertices of the polygon in the clockwise order, starting from the lexicographically smallest vertex.\n\n\n-----Examples-----\nInput\n8\n00000000\n00000110\n00012210\n01234200\n02444200\n01223200\n00001100\n00000000\n5\n00000\n01210\n02420\n01210\n00000\n7\n0000000\n0122100\n0134200\n0013200\n0002200\n0001100\n0000000\n0\n\nOutput\n4\n2 3\n2 4\n6 6\n5 2\n4\n2 2\n2 3\n3 3\n3 2\n3\n2 5\n4 5\n4 2\n\n\n\n-----Note-----\n\nIt is guaranteed that the solution always exists and is unique. It is guaranteed that in the correct solution the coordinates of the polygon vertices are between 2 and N - 2. A vertex (x_1, y_1) is lexicographically smaller than vertex (x_2, y_2) if x_1 < x_2 or $x_{1} = x_{2} \\wedge y_{1} < y_{2}$.", "solutions": "[\"import math\\n\\ndef lexComp(a, b):\\n    if a[0] != b[0]:\\n        return -1 if a[0] < b[0] else 1\\n    if a[1] != b[1]:\\n        return -1 if a[1] < b[1] else 1\\n    return 0\\n\\ndef turn(a, b, c):\\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\\n    \\ndef dist2(a, b):\\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\\n\\ndef solve(n):\\n    a = [list(map(int, input())) for _ in range(n)]\\n    points = []\\n    for i in range(n):\\n        for j in range(n):\\n            if a[i][j] == 1:\\n                curPoints = []\\n                for dx in range(0, 2):\\n                    for dy in range(0, 2):\\n                        ok = True\\n                        for ddx in range(0, 2):\\n                            for ddy in range(0, 2):\\n                                x, y = i - 1 + dx + ddx, j - 1 + dy + ddy\\n                                if 0 <= x < n and 0 <= y < n and a[x][y] == 0:\\n                                    ok = False\\n                        if ok:\\n                            curPoints.append((i + dx, j + dy))\\n                points.append(curPoints[0])\\n    points = list(set(points))\\n    for i in range(1, len(points)):\\n        if lexComp(points[0], points[i]) > 0:\\n            points[0], points[i] = points[i], points[0]\\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\\n    hull = []\\n    for p in points:\\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\\n            hull.pop()\\n        hull.append(p)\\n    hull = [(p[1], n - p[0]) for p in hull]\\n    hull = hull[::-1]\\n    start = 0\\n    for i in range(1, len(hull)):\\n        if lexComp(hull[i], hull[start]) < 0:\\n            start = i\\n    newHull = hull[start:]\\n    newHull.extend(hull[:start])\\n    hull = newHull\\n    print(len(hull))\\n    for p in hull:\\n        print(p[0], p[1])\\n    \\nwhile True:\\n    n = int(input())\\n    if n == 0:\\n        break\\n    solve(n)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"8\\n00000000\\n00000110\\n00012210\\n01234200\\n02444200\\n01223200\\n00001100\\n00000000\\n5\\n00000\\n01210\\n02420\\n01210\\n00000\\n7\\n0000000\\n0122100\\n0134200\\n0013200\\n0002200\\n0001100\\n0000000\\n0\\n\"\n  ],\n  \"outputs\": [\n    \"4\\n2 3\\n2 4\\n6 6\\n5 2\\n4\\n2 2\\n2 3\\n3 3\\n3 2\\n3\\n2 5\\n4 5\\n4 2\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/690/B2", "starter_code": ""}
{"id": 113, "question": "Bob watches TV every day. He always sets the volume of his TV to $b$. However, today he is angry to find out someone has changed the volume to $a$. Of course, Bob has a remote control that can change the volume.\n\nThere are six buttons ($-5, -2, -1, +1, +2, +5$) on the control, which in one press can either increase or decrease the current volume by $1$, $2$, or $5$. The volume can be arbitrarily large, but can never be negative. In other words, Bob cannot press the button if it causes the volume to be lower than $0$.\n\nAs Bob is so angry, he wants to change the volume to $b$ using as few button presses as possible. However, he forgets how to do such simple calculations, so he asks you for help. Write a program that given $a$ and $b$, finds the minimum number of presses to change the TV volume from $a$ to $b$.\n\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains the number of test cases $T$ ($1 \\le T \\le 1\\,000$). Then the descriptions of the test cases follow.\n\nEach test case consists of one line containing two integers $a$ and $b$ ($0 \\le a, b \\le 10^{9}$)\u00a0\u2014 the current volume and Bob's desired volume, respectively.\n\n\n-----Output-----\n\nFor each test case, output a single integer\u00a0\u2014 the minimum number of presses to change the TV volume from $a$ to $b$. If Bob does not need to change the volume (i.e. $a=b$), then print $0$.\n\n\n-----Example-----\nInput\n3\n4 0\n5 14\n3 9\n\nOutput\n2\n3\n2\n\n\n\n-----Note-----\n\nIn the first example, Bob can press the $-2$ button twice to reach $0$. Note that Bob can not press $-5$ when the volume is $4$ since it will make the volume negative. \n\nIn the second example, one of the optimal ways for Bob is to press the $+5$ twice, then press $-1$ once.\n\nIn the last example, Bob can press the $+5$ once, then press $+1$.", "solutions": "[\"import math\\nfrom decimal import Decimal\\nimport heapq\\nfrom collections import deque\\ndef na():\\n\\tn = int(input())\\n\\tb = [int(x) for x in input().split()]\\n\\treturn n,b\\n \\n \\ndef nab():\\n\\tn = int(input())\\n\\tb = [int(x) for x in input().split()]\\n\\tc = [int(x) for x in input().split()]\\n\\treturn n,b,c\\n \\n \\ndef dv():\\n\\tn, m = list(map(int, input().split()))\\n\\treturn n,m\\n \\n \\ndef dva():\\n\\tn, m = list(map(int, input().split()))\\n\\ta = [int(x) for x in input().split()]\\n\\tb = [int(x) for x in input().split()]\\n\\treturn n,m,b\\n \\n \\ndef eratosthenes(n): \\n\\tsieve = list(range(n + 1))\\n\\tfor i in sieve:\\n\\t\\tif i > 1:\\n\\t\\t\\tfor j in range(i + i, len(sieve), i):\\n\\t\\t\\t\\tsieve[j] = 0\\n\\treturn sorted(set(sieve))\\n \\n \\ndef lol(lst,k):\\n\\tk=k%len(lst)\\n\\tret=[0]*len(lst)\\n\\tfor i in range(len(lst)):\\n\\t\\tif i+k<len(lst) and i+k>=0:\\n\\t\\t\\tret[i]=lst[i+k]\\n\\t\\tif i+k>=len(lst):\\n\\t\\t\\tret[i]=lst[i+k-len(lst)]\\n\\t\\tif i+k<0:\\n\\t\\t\\tret[i]=lst[i+k+len(lst)]\\n\\treturn(ret)\\ndef nm():\\n\\tn = int(input())\\n\\tb = [int(x) for x in input().split()]\\n\\tm = int(input())\\n\\tc = [int(x) for x in input().split()]\\n\\treturn n,b,m,c\\n \\n \\ndef dvs():\\n\\tn = int(input())\\n\\tm = int(input())\\n\\treturn n, m \\n \\ndef fact(a, b):\\n\\tc = []\\n\\tans = 0\\n\\tf = int(math.sqrt(a))\\n\\tfor i in range(1, f + 1):\\n\\t\\tif a % i == 0:\\n\\t\\t\\tc.append(i)\\n\\tl = len(c)\\n\\tfor i in range(l):\\n\\t\\tc.append(a // c[i])\\n\\tfor i in range(len(c)):\\n\\t\\tif c[i] <= b:\\n\\t\\t\\tans += 1\\n\\tif a / f == f and b >= f:\\n\\t\\treturn ans - 1\\n\\treturn ans\\n \\n\\nt = int(input())\\nfor i in range(t):\\n\\ta ,b = list(map(int, input().split()))\\n\\tif a == b:\\n\\t\\tprint(0)\\n\\telse:\\n\\t\\td = abs(a - b)\\n\\t\\tk1 = d//5\\n\\t\\td -= k1 *5 \\n\\t\\tk2 = d // 2\\n\\t\\td -= k2 * 2\\n\\t\\tprint(d + k1 + k2)\\n\", \"import sys\\nimport math\\n\\n# sys.stdin = open(\\\"in.txt\\\")\\nfor _ in range(int(input())):\\n    a, b = map(int, input().split())\\n    x = abs(a - b)\\n    res = x // 5\\n    x %= 5\\n    res += x // 2\\n    x %= 2\\n    print(res + x)\", \"def main():\\n    t = int(input())\\n    for i in range(t):\\n        a,b = list(map(int,input().split()))\\n        moves = 0\\n        diff = abs(a-b)\\n        x = diff//5\\n        moves += x\\n        diff -= (5*x)\\n        x = diff//2\\n        moves += x\\n        diff -= (2*x)\\n        x = diff\\n        moves += x\\n\\n        print(moves)\\n\\nmain()\\n\", \"t = int(input())\\nfor _ in range (t):\\n    a, b = list(map(int, input().split()))\\n\\n    d = abs(b - a)\\n    ans = 0\\n    ans += d // 5\\n    d = d % 5\\n    ans += d // 2\\n    d %= 2\\n    ans += d // 1\\n    d %= 1\\n\\n    print(ans)\\n\", \"''' \\u0628\\u0650\\u0633\\u0652\\u0645\\u0650 \\u0627\\u0644\\u0644\\u064e\\u0651\\u0647\\u0650 \\u0627\\u0644\\u0631\\u064e\\u0651\\u062d\\u0652\\u0645\\u064e\\u0670\\u0646\\u0650 \\u0627\\u0644\\u0631\\u064e\\u0651\\u062d\\u0650\\u064a\\u0645\\u0650 '''\\n#codeforces\\ngi = lambda : list(map(int,input().split()))\\nfor j in range(gi()[0]):\\n\\ta, b = gi()\\n\\td = abs(a - b)\\n\\tprint(d // 5 + (d % 5) // 2 + ((d % 5) % 2))\", \"\\nt = int(input())\\n\\nfor gg in range(t):\\n\\t\\n\\ta, b = list(map(int, input().split()))\\n\\td = abs(a-b)\\n\\tif d == 0:\\n\\t\\tprint(0)\\n\\telse:\\n\\t\\tans = 0\\n\\t\\tans += d//5\\n\\t\\td%=5\\n\\t\\tans+=d//2\\n\\t\\td%=2\\n\\t\\tans+=d\\n\\t\\tprint(ans)\\n\", \"from bisect import *\\nfrom collections import *\\nfrom itertools import *\\nimport functools\\nimport sys\\nimport math\\nfrom decimal import *\\nfrom copy import *\\nfrom heapq import *\\nfrom fractions import *\\ngetcontext().prec = 30\\nMAX = sys.maxsize\\nMAXN = 1000010\\nMOD = 10**9+7\\nspf = [i for i in range(MAXN)]\\ndef sieve():\\n    for i in range(2,MAXN,2):\\n        spf[i] = 2\\n    for i in range(3,int(MAXN**0.5)+1):\\n        if spf[i]==i:\\n            for j in range(i*i,MAXN,i):\\n                if spf[j]==j:\\n                    spf[j]=i\\ndef fib(n,m):\\n    if n == 0:\\n        return [0, 1]\\n    else:\\n        a, b = fib(n // 2)\\n        c = ((a%m) * ((b%m) * 2 - (a%m)))%m\\n        d = ((a%m) * (a%m))%m + ((b)%m * (b)%m)%m\\n        if n % 2 == 0:\\n            return [c, d]\\n        else:\\n            return [d, c + d]\\n\\ndef charIN(x= ' '):\\n    return(sys.stdin.readline().strip().split(x))\\n\\ndef arrIN(x = ' '):\\n    return list(map(int,sys.stdin.readline().strip().split(x)))\\n\\ndef ncr(n,r):\\n    num=den=1\\n    for i in range(r):\\n        num = (num*(n-i))%MOD\\n        den = (den*(i+1))%MOD\\n\\n    return (num*(pow(den,MOD-2,MOD)))%MOD\\n\\ndef flush():\\n    return sys.stdout.flush()\\n\\n'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''\\nfor _ in range(int(input())):\\n    a,b = arrIN()\\n    d = abs(a-b)\\n    ans = 0\\n    x,y = divmod(d,5)\\n    ans+=x\\n    z,w = divmod(y,2)\\n    ans+=z\\n    ans+=w\\n    print(ans)\\n\", \"t=int(input())\\nwhile(t):\\n    t-=1\\n    a,b=map(int,input().split())\\n    if a>b:\\n        a,b=b,a\\n    d=b-a\\n    ans=0\\n    if(d>=5):\\n        ans+=d//5\\n        d%=5\\n    if(d>=2):\\n        ans+=d//2\\n        d%=2\\n    if(d>=1):\\n        ans+=d\\n    print(ans)\", \"def ii(): return int(input())\\ndef si(): return input()\\ndef mi(): return list(map(int,input().strip().split(\\\" \\\")))\\ndef li(): return list(mi())\\nmod=1e9\\nt=ii()\\nwhile(t):\\n    t-=1\\n    a,b=mi()\\n    x=abs(b-a)\\n    c=x//5\\n    x=x%5\\n    c+=x//2\\n    x%=2\\n    c+=x\\n    print(c)\\n    \\n\", \"for i in ' '*int(input()):\\n    a,b=map(int,input().split())\\n    k=abs(b-a)\\n    c=0\\n    c+=k//5\\n    k%=5\\n    if k>3:\\n        c+=1\\n        k=5-k\\n    c+=k//2\\n    k%=2\\n    c+=k\\n    print(c)\", \"import sys\\nimport math\\nimport itertools\\nimport collections\\n\\n\\ndef sieve(n):\\n    if n < 2: return list()\\n    prime = [True for _ in range(n + 1)]\\n    p = 3\\n    while p * p <= n:\\n        if prime[p]:\\n            for i in range(p * 2, n + 1, p):\\n                prime[i] = False\\n        p += 2\\n    r = [2]\\n    for p in range(3, n + 1, 2):\\n        if prime[p]:\\n            r.append(p)\\n    return r\\ndef divs(n, start=1):\\n    r = []\\n    for i in range(start, int(math.sqrt(n) + 1)):\\n        if (n % i == 0):\\n            if (n / i == i):\\n                r.append(i)\\n            else:\\n                r.extend([i, n // i])\\n    return r\\ndef cdiv(n, k): return n // k + (n % k != 0)\\ndef ii(): return int(input())\\ndef mi(): return list(map(int, input().split()))\\ndef li(): return list(map(int, input().split()))\\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\\ndef wr(arr): return ''.join(map(str, arr))\\ndef revn(n): return str(n)[::-1]\\ndef prime(n):\\n    if n == 2: return True\\n    if n % 2 == 0 or n <= 1: return False\\n    sqr = int(math.sqrt(n)) + 1\\n    for d in range(3, sqr, 2):\\n        if n % d == 0: return False\\n    return True\\ndef convn(number, base):\\n    newnumber = 0\\n    while number > 0:\\n        newnumber += number % base\\n        number //= base\\n    return newnumber\\n\\n\\nt = ii()\\nfor _ in range(t):\\n    a, b = mi()\\n    d = abs(b - a)\\n    ans = 0\\n    ans += d // 5\\n    d %= 5\\n    ans += d // 2\\n    d %= 2\\n    ans += d\\n    print(ans)\\n\", \"for i in range(int(input())):\\n    a,b=list(map(int,input().split()))\\n    a=-min(a,b)+max(a,b)\\n    ans=0\\n    ans= a//5\\n    a%=5\\n    ans+=a//2\\n    a%=2\\n    ans+=a\\n    print(ans)\\n\", \"for _ in range(int(input())):\\n    a, b = list(map(int, input().split()))\\n    a = abs( a - b )\\n    c = a // 5\\n    a -= c * 5\\n    print( c + a // 2 + a % 2 )\\n\", \"for _ in range(int(input())):\\n    a,b=list(map(int,input().split()))\\n    target=abs(a-b)\\n    res=0\\n\\n    res+=target//5;target=target%5\\n    res+=target//2;target=target%2\\n    res+=target//1;target=target%1\\n\\n    print(res)\\n\", \"#JMD\\n#Nagendra Jha-4096\\n\\n \\nimport sys\\nimport math\\n\\n#import fractions\\n#import numpy\\n \\n###File Operations###\\nfileoperation=0\\nif(fileoperation):\\n    orig_stdout = sys.stdout\\n    orig_stdin = sys.stdin\\n    inputfile = open('W:/Competitive Programming/input.txt', 'r')\\n    outputfile = open('W:/Competitive Programming/output.txt', 'w')\\n    sys.stdin = inputfile\\n    sys.stdout = outputfile\\n\\n###Defines...###\\nmod=1000000007\\n \\n###FUF's...###\\ndef nospace(l):\\n    ans=''.join(str(i) for i in l)\\n    return ans\\n \\n \\n \\n##### Main ####\\nt=int(input())\\nfor tt in range(t):\\n    #n=int(input())\\n    a,b= map(int, sys.stdin.readline().split(' '))\\n    ans=0\\n    if(a>b):\\n        temp=b\\n        b=a\\n        a=temp\\n    diff=b-a\\n    ans+=(diff//5)\\n    diff%=5\\n    ans+=(diff//2)\\n    diff%=2\\n    ans+=diff\\n    print(ans)\\n    #a=list(map(int,sys.stdin.readline().split(' ')))\\n    \\n    \\n#####File Operations#####\\nif(fileoperation):\\n    sys.stdout = orig_stdout\\n    sys.stdin = orig_stdin\\n    inputfile.close()\\n    outputfile.close()\", \"for _ in range(int(input())):\\n    a,b=list(map(int,input().split()))\\n    x=min(a,b)\\n    y=max(a,b)\\n    c=0\\n    if x==y:\\n        print(0)\\n    else:\\n        c+=(y-x)//5\\n        rem=(y-x)%5\\n        c+=rem//2\\n        rem=rem%2\\n        c+=rem\\n        print(c)\\n\", \"n = int(input())\\nfor i in range(n):\\n\\tx, y = list(map(int, input().split()))\\n\\tif x > y:\\n\\t\\tx, y = y, x\\n\\ta = (y - x) // 5\\n\\tx += a * 5\\n\\tb = (y - x) // 2\\n\\tx += b * 2\\n\\tc = (y - x)\\n\\tprint(a + b + c)\\n\", \"t = int(input())\\n\\nfor _ in range(t):\\n\\ta, b = map(int, input().split())\\n\\tdiff = abs(a-b)\\n\\tfives = diff//5\\n\\tdiff %= 5\\n\\ttwos = diff//2\\n\\tdiff %= 2\\n\\tones = diff\\n\\n\\tprint(fives+twos+ones)\", \"n=int(input())\\nfor i in range(n):\\n    a,b=[int(x) for x in input().split(' ')]\\n    c=abs(a-b)\\n    d=0\\n    d+=int(c/5)\\n    c=c%5\\n    d+=int(c/2)\\n    c=c%2\\n    d+=c\\n    print(d)\\n\", \"import io, sys, atexit, os\\nimport math as ma\\nfrom decimal import Decimal as dec\\nfrom itertools import permutations\\nfrom itertools import combinations\\n\\n\\ndef li():\\n    return list(map(int, sys.stdin.readline().split()))\\n\\n\\ndef num():\\n    return map(int, sys.stdin.readline().split())\\n\\n\\ndef nu():\\n    return int(input())\\n\\n\\ndef find_gcd(x, y):\\n    while (y):\\n        x, y = y, x % y\\n    return x\\n\\n\\ndef lcm(x, y):\\n    gg = find_gcd(x, y)\\n    return (x * y // gg)\\n\\n\\nmm = 1000000007\\n\\n\\ndef solve():\\n    t = nu()\\n    for tt in range(t):\\n        a,b=num()\\n        if(a<=b):\\n            dd=b-a\\n            pq=dd//5\\n            yp=dd%5\\n            yo=yp//2\\n            yu=yp%2\\n            print(pq+yu+yo)\\n        else:\\n            a,b=b,a\\n            dd = b - a\\n            pq = dd // 5\\n            yp = dd % 5\\n            yo = yp // 2\\n            yu = yp % 2\\n            print(pq + yu + yo)\\n\\n\\ndef __starting_point():\\n    solve()\\n__starting_point()\", \"n = int(input())\\nfor i in range(n):\\n    a, b = map(int, input().split())\\n    s = abs(a - b)\\n    x = s // 5\\n    s %= 5\\n    x += s // 2\\n    s %= 2\\n    x += s\\n    print(x)\", \"T = int(input())\\n\\nfor _ in range(T):\\n\\ta, b = map(int, input().split())\\n\\n\\td = abs(a - b)\\n\\n\\tans = (d // 5)\\n\\n\\td = d % 5\\n\\n\\tif d == 1 or d == 2:\\n\\t\\tans += 1\\n\\n\\tif d == 3 or d == 4:\\n\\t\\tans += 2\\n\\n\\tprint(ans)\", \"for _ in range(int(input())):\\n    a,b=map(int,input().split())\\n    d=abs(a-b)\\n    ans=0\\n    sm=0 \\n    ans+=(d//5)\\n    d%=5 \\n    ans+=(d//2)\\n    d%=2 \\n    ans+=d \\n    print(ans)\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n4 0\\n5 14\\n3 9\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n3\\n2\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1255/A", "starter_code": ""}
{"id": 114, "question": "You play a computer game. In this game, you lead a party of $m$ heroes, and you have to clear a dungeon with $n$ monsters. Each monster is characterized by its power $a_i$. Each hero is characterized by his power $p_i$ and endurance $s_i$.\n\nThe heroes clear the dungeon day by day. In the beginning of each day, you choose a hero (exactly one) who is going to enter the dungeon this day.\n\nWhen the hero enters the dungeon, he is challenged by the first monster which was not defeated during the previous days (so, if the heroes have already defeated $k$ monsters, the hero fights with the monster $k + 1$). When the hero fights the monster, there are two possible outcomes:\n\n  if the monster's power is strictly greater than the hero's power, the hero retreats from the dungeon. The current day ends;  otherwise, the monster is defeated. \n\nAfter defeating a monster, the hero either continues fighting with the next monster or leaves the dungeon. He leaves the dungeon either if he has already defeated the number of monsters equal to his endurance during this day (so, the $i$-th hero cannot defeat more than $s_i$ monsters during each day), or if all monsters are defeated \u2014 otherwise, he fights with the next monster. When the hero leaves the dungeon, the current day ends.\n\nYour goal is to defeat the last monster. What is the minimum number of days that you need to achieve your goal? Each day you have to use exactly one hero; it is possible that some heroes don't fight the monsters at all. Each hero can be used arbitrary number of times.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^5$) \u2014 the number of test cases. Then the test cases follow.\n\nThe first line of each test case contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of monsters in the dungeon.\n\nThe second line contains $n$ integers $a_1$, $a_2$, ..., $a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ is the power of the $i$-th monster.\n\nThe third line contains one integer $m$ ($1 \\le m \\le 2 \\cdot 10^5$) \u2014 the number of heroes in your party.\n\nThen $m$ lines follow, each describing a hero. Each line contains two integers $p_i$ and $s_i$ ($1 \\le p_i \\le 10^9$, $1 \\le s_i \\le n$) \u2014 the power and the endurance of the $i$-th hero.\n\nIt is guaranteed that the sum of $n + m$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case print one integer \u2014 the minimum number of days you have to spend to defeat all of the monsters (or $-1$ if it is impossible).\n\n\n-----Example-----\nInput\n2\n6\n2 3 11 14 1 8\n2\n3 2\n100 1\n5\n3 5 100 2 3\n2\n30 5\n90 1\n\nOutput\n5\n-1", "solutions": "[\"import sys\\ninput = sys.stdin.readline\\nimport bisect\\n\\nt=int(input())\\n\\nfor testcases in range(t):\\n    n=int(input())\\n    A=list(map(int,input().split()))\\n    m=int(input())\\n    PS=[tuple(map(int,input().split())) for i in range(m)]\\n\\n    PS.sort()\\n    K=[PS[-1]]\\n\\n    for a,b in PS[::-1][1:]:\\n        if b<=K[-1][1]:\\n            continue\\n        else:\\n            K.append((a,b))\\n\\n    K.reverse()\\n\\n    ANS=1\\n    count=0\\n    countmax=n+1\\n    LEN=len(K)\\n    for a in A:\\n        x=bisect.bisect_left(K,(a,0))\\n        if x==LEN:\\n            print(-1)\\n            break\\n        elif K[x][1]>=count+1 and countmax>=count+1:\\n            count+=1\\n            countmax=min(countmax,K[x][1])\\n        else:\\n            ANS+=1\\n            count=1\\n            countmax=K[x][1]\\n\\n        #print(a,count,countmax,ANS)\\n    else:\\n        print(ANS)\\n            \\n        \\n        \\n\", \"import sys\\ninput = sys.stdin.readline\\nT = int(input())\\nAns = []\\nfor _ in range(T):\\n    N = int(input())  # \\u30e2\\u30f3\\u30b9\\u30bf\\u30fc\\u306e\\u6570\\n    A = list(map(int, input().split()))  # \\u30e2\\u30f3\\u30b9\\u30bf\\u30fc\\u306e\\u30d1\\u30ef\\u30fc\\n    M = int(input())  # \\u30d2\\u30fc\\u30ed\\u30fc\\u306e\\u6570\\n    PS = [list(map(int, input().split())) for _ in range(M)]  # \\u30d1\\u30ef\\u30fc\\u3068\\u8010\\u4e45\\n    # \\u30e2\\u30f3\\u30b9\\u30bf\\u30fc\\u306e\\u30d1\\u30ef\\u30fc\\u304c\\u30d2\\u30fc\\u30ed\\u30fc\\u306e\\u30d1\\u30ef\\u30fc\\u3088\\u308a\\u5927\\u304d\\u3044\\u3068\\u30d2\\u30fc\\u30ed\\u30fc\\u306e\\u8ca0\\u3051\\n    # S \\u306f 1 \\u65e5\\u306b\\u5012\\u305b\\u308b\\u30e2\\u30f3\\u30b9\\u30bf\\u30fc\\u306e\\u6570\\u306e\\u4e0a\\u9650\\n\\n    # L[n] := n \\u4f53\\u5012\\u305b\\u308b\\u30d2\\u30fc\\u30ed\\u30fc\\u306e\\u6700\\u5927\\u30d1\\u30ef\\u30fc\\n    L = [0] * (N+1)\\n    for p, s in PS:\\n        L[s] = max(L[s], p)\\n    for i in range(N-1, -1, -1):\\n        L[i] = max(L[i], L[i+1])\\n    ans = 1\\n    cnt = 1\\n    ma = 0\\n    if L[1] < max(A):\\n        Ans.append(-1)\\n        continue\\n    for a in A:\\n        ma = max(ma, a)\\n        if L[cnt] < ma:\\n            cnt = 1\\n            ans += 1\\n            ma = a\\n        cnt += 1\\n    Ans.append(ans)\\n\\nprint(\\\"\\\\n\\\".join(map(str, Ans)))\\n\", \"3\\n\\nimport os\\nimport sys\\n\\n\\ndef main():\\n    T = read_int()\\n    for _ in range(T):\\n        N = read_int()\\n        A = read_ints()\\n        M = read_int()\\n        H = [tuple(read_ints()) for _ in range(M)]\\n        print(solve(N, A, M, H))\\n\\n\\ndef solve(N, A, M, H):\\n    H.sort(key=lambda h: (h[1], -h[0]))\\n    spow = [0] * (N + 1)\\n    s0 = 0\\n    for p, s in H:\\n        if s0 == s:\\n            continue\\n        spow[s] = p\\n        s0 = s\\n\\n    maxp = 0\\n    for d in range(N, -1, -1):\\n        maxp = max(maxp, spow[d])\\n        spow[d] = maxp\\n\\n    ans = 0\\n    maxa = A[0]\\n    if A[0] > spow[1]:\\n        return -1\\n    start = 0\\n    for i, a in enumerate(A[1:]):\\n        if a > spow[1]:\\n            return -1\\n        i += 1\\n        days = i - start + 1\\n        maxa = max(maxa, a)\\n        if spow[days] < maxa:\\n            ans += 1\\n            maxa = a\\n            start = i\\n    return ans + 1\\n\\n\\n###############################################################################\\n# AUXILIARY FUNCTIONS\\n\\nDEBUG = 'DEBUG' in os.environ\\n\\n\\ndef inp():\\n    return sys.stdin.readline().rstrip()\\n\\n\\ndef read_int():\\n    return int(inp())\\n\\n\\ndef read_ints():\\n    return [int(e) for e in inp().split()]\\n\\n\\ndef dprint(*value, sep=' ', end='\\\\n'):\\n    if DEBUG:\\n        print(*value, sep=sep, end=end)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"from sys import stdin\\ninput = stdin.readline\\nq = int(input())\\nfor rew in range(q):\\n\\tn = int(input())\\n\\tmonster = list(map(int,input().split()))\\n\\tm = int(input())\\n\\trycerz = [list(map(int,input().split())) for i in range(m)]\\n\\trycerz.sort()\\n\\trycerz.reverse()\\n\\tp = [a[0] for a in rycerz]\\n\\ts = [a[1] for a in rycerz]\\n\\tmaxendu = [-1] * m\\n\\tmaxendu[0] = s[0]\\n\\tif max(p) < max(monster):\\n\\t\\tprint(-1)\\n\\telse:\\n\\t\\tfor i in range(1, m):\\n\\t\\t\\tmaxendu[i] = max(maxendu[i-1], s[i])\\n\\t\\tdays = 0\\n\\t\\tpoz = 0\\n\\t\\twhile True:\\n\\t\\t\\tif poz >= n:\\n\\t\\t\\t\\tprint(days)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tbest_potwor = -1\\n\\t\\t\\tkroki = 0\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tif poz + kroki >= n:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tbest_potwor = max(monster[poz + kroki], best_potwor)\\n\\t\\t\\t\\t#tyle krokow robimy i taki best potwor\\n\\t\\t\\t\\tl = 0\\n\\t\\t\\t\\tpr = m - 1\\n\\t\\t\\t\\twhile abs(pr-l) > 0:\\n\\t\\t\\t\\t\\tsr = (l + pr + 1) // 2\\n\\t\\t\\t\\t\\tif p[sr] >= best_potwor:\\n\\t\\t\\t\\t\\t\\tl = sr\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tpr = sr - 1\\n\\t\\t\\t\\tsr = (pr + l) // 2\\n\\t\\t\\t\\tif maxendu[sr] >= kroki + 1:\\n\\t\\t\\t\\t\\tkroki += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tkroki -= 1\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\tdays += 1\\n\\t\\t\\tpoz += kroki\\n\\t\\t\\tpoz += 1\", \"import sys\\nimport bisect\\nsys.setrecursionlimit(10**8)\\ninput = sys.stdin.readline\\nINF = 10**9\\n\\nclass RMQ:\\n    def __init__(self, a):\\n        self.n = len(a)\\n        self.size = 2**(self.n - 1).bit_length()\\n        self.data = [0] * (2*self.size-1)\\n        self.initialize(a)\\n\\n    # Initialize data\\n    def initialize(self, a):\\n        for i in range(self.n):\\n            self.data[self.size + i - 1] = a[i]\\n        for i in range(self.size-2, -1, -1):\\n            self.data[i] = max(self.data[i*2 + 1], self.data[i*2 + 2])\\n\\n    # Update ak as x\\n    def update(self, k, x):\\n        k += self.size - 1\\n        self.data[k] = x\\n        while k > 0:\\n            k = (k - 1) // 2\\n            self.data[k] = max(self.data[2*k+1], self.data[2*k+2])\\n\\n    # max value in [l, r)\\n    def query(self, l, r):\\n        L = l + self.size; R = r + self.size\\n        s = 0\\n        while L < R:\\n            if R & 1:\\n                R -= 1\\n                s = max(s, self.data[R-1])\\n            if L & 1:\\n                s = max(s, self.data[L-1])\\n                L += 1\\n            L >>= 1; R >>= 1\\n        return s\\n\\nt = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    a = [int(item) for item in input().split()]\\n    m = int(input())\\n    brave = []\\n    for j in range(m):\\n        pp, ss = [int(item) for item in input().split()]\\n        brave.append((pp, ss))\\n    brave.sort(reverse=True)\\n    p = []\\n    s = []\\n    for pp, ss in brave:\\n        p.append(pp)\\n        s.append(ss)\\n    s_rmq = RMQ(s)\\n    a_rmq = RMQ(a)\\n    p.reverse()\\n    s.reverse()\\n    max_step = max(s)\\n    days = 0\\n    curr = 0\\n    while curr < n:\\n        # Search step size\\n        l = 0; r = min(n - curr, max_step) + 1\\n        while r - l > 1:\\n            mid = (l + r) // 2\\n            max_monster = a_rmq.query(curr, curr+mid)\\n            index = m - bisect.bisect_left(p, max_monster)\\n            walkable = s_rmq.query(0, index)\\n            if walkable >= mid:\\n                l = mid\\n            else:\\n                r = mid\\n        if l == 0:\\n            days = -1\\n            break\\n        else:\\n            days += 1\\n            curr += l\\n    print(days)\", \"import sys\\nfor _ in range(int(input())):\\n    n = int(sys.stdin.readline())\\n    mons = list(map(int, sys.stdin.readline().split()))\\n    m = int(sys.stdin.readline())\\n    _heros = sorted((tuple(map(int, sys.stdin.readline().split())) for _ in range(m)), reverse=True)\\n    max_s = 0\\n    pows = []\\n    endu = []\\n    for i in range(m):\\n        if max_s >= _heros[i][1]:\\n            continue\\n        max_s = max(max_s, _heros[i][1])\\n        pows.append(_heros[i][0])\\n        endu.append(_heros[i][1])\\n\\n    pows.append(0)\\n    endu.append(10**9)\\n    i = 0\\n    for ans in range(1, 10**9):\\n        hero_i = 0\\n        power = pows[0]\\n        mons_power = 0\\n\\n        if power < mons[i]:\\n            print(-1)\\n            break\\n        for j in range(1, n-i+1):\\n            if endu[hero_i] < j:\\n                hero_i += 1\\n                power = pows[hero_i]\\n\\n            mons_power = max(mons_power, mons[i])\\n            if power < mons_power:\\n                break\\n            i += 1\\n        else:\\n            print(ans)\\n            break\\n\", \"\\\"\\\"\\\"\\nNTC here\\n\\\"\\\"\\\"\\nfrom sys import stdin\\n\\ndef iin(): return int(stdin.readline())\\n \\n \\ndef lin(): return list(map(int, stdin.readline().split()))\\n\\n\\n# range = xrange\\n# input = raw_input\\n\\n\\ndef main():\\n    t=iin()\\n    while t:\\n        t-=1\\n        n=iin()\\n        a=lin()\\n        m=iin()\\n        h=[lin()[::-1] for i in range(m)]\\n        h.sort(reverse=True)\\n        a1=[[j,i] for i,j in enumerate(a)]\\n        a2=[-1]*n\\n        a1.sort()\\n        i=0\\n        j=0\\n        while j<n and i<m:\\n            if h[i][1]>=a1[j][0]:\\n                a2[a1[j][1]]=i\\n                j+=1\\n            else:\\n                i+=1\\n        if -1 in a2:\\n            print(-1)\\n        else:\\n            dp=[1]*n\\n            for i in range(1,n):\\n                ad=[0]\\n                ch=0\\n                if h[a2[i]][0]>dp[i-1]:\\n                    if h[a2[i]][1]>=h[a2[i-1]][1]:\\n                        ad.append(dp[i-1])\\n                        ch+=1\\n                if h[a2[i-1]][0]>dp[i-1]:\\n                    if h[a2[i-1]][1]>=h[a2[i]][1]:\\n                        ad.append(dp[i-1])\\n                        if ch==0:\\n                            a2[i]=a2[i-1]\\n                dp[i]+=max(ad)\\n            print(dp.count(1))\\n            # print(dp,a2,h)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nmain()\\n# try:\\n#     main()\\n# except Exception as e: print(e)\\n\", \"import sys\\ninput = lambda: sys.stdin.readline().strip()\\nprint = lambda s: sys.stdout.write(s)\\n\\nt = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    ls1 = list(map(int, input().split()))\\n    m = int(input())\\n    ls2 = []\\n    for i in range(m):\\n        ls2.append(tuple(map(int, input().split())))\\n    if max(ls1)>max(i[0] for i in ls2):\\n        print('-1\\\\n')\\n    else:\\n        temp = {}\\n        for i in range(1, n+1):\\n            temp[i] = 0\\n        for i in ls2:\\n            try:\\n                temp[i[1]] = max(temp[i[1]], i[0])\\n            except:\\n                temp[i[1]] = i[0]\\n        d = {}\\n        d[n] = temp[n]\\n        for k in range(n-1, 0, -1):\\n            d[k] = max(d[k+1], temp[k])\\n        i = 0\\n        cnt = 1\\n        ans = 1\\n        M = ls1[0]\\n        while True:\\n            if d[cnt]>=M:\\n                cnt+=1\\n                i+=1\\n                if i==n:\\n                    break\\n                M = max(M, ls1[i])\\n            else:\\n                ans+=1\\n                cnt = 1\\n                M = ls1[i]\\n        print(str(ans)+'\\\\n')\\n\", \"import math\\nimport sys\\nfrom bisect import bisect_right as bs\\nfor _ in range(int(input())):\\n    n=int(sys.stdin.readline())\\n    a=list(map(int,sys.stdin.readline().split()))\\n    m=int(input())\\n    ma=-1\\n    h=[0]*(n+1)\\n    for i in range(m):\\n        x,y=list(map(int,sys.stdin.readline().split()))\\n        ma=max(ma,x)\\n        h[y]=max(h[y],x)\\n    \\n    for i in range(n-1,0,-1):\\n        h[i]=max(h[i+1],h[i])\\n    # print(h)    \\n    if ma<max(a):\\n        print(-1)\\n    else:\\n        ma=-1\\n        prev=0\\n        ans=1\\n        i=0\\n        while i<n:\\n            ma=max(a[i],ma)\\n            # print(ma,i,ans)\\n            if h[i-prev+1]<ma:\\n                prev=i\\n                ans+=1\\n                ma=-1\\n            else:\\n                i+=1\\n        print(ans)        \\n\", \"from collections import *\\nfrom bisect import bisect_left as bl\\nimport sys\\ninput = sys.stdin.readline\\n \\n \\ndef li():return [int(i) for i in input().rstrip('\\\\n').split(' ')]\\ndef st():return input().rstrip('\\\\n')\\ndef val():return int(input())\\ndef stli():return [int(i) for i in input().rstrip('\\\\n')]\\n \\n \\n \\n \\nfor _ in range(val()):\\n    n = val()\\n    a = li()\\n    # print(a)\\n    m = val()\\n    h = []\\n    visited = defaultdict(int)\\n    for i in range(m):\\n        x,y = li()\\n        visited[x] = max(visited[x],y)\\n    h = []\\n    for i in visited:\\n        h.append([i,visited[i]])\\n    h.sort(reverse = 1)\\n    endurance = {}\\n    m = len(h)\\n    currmax = -float('inf')\\n    for i in range(m):\\n        if h[i][1]>currmax:\\n            currmax = max(currmax,h[i][1])\\n            endurance[h[i][0]] = currmax\\n        \\n \\n    power = sorted(list(endurance))\\n    # print(power,endurance)\\n    totdays = 0\\n    i = 0\\n    while i<n:\\n        ind = bl(power,a[i])\\n        if ind == len(power):\\n            totdays = -1\\n            break\\n \\n        cou = 0\\n        while i<n:\\n            while ind<len(power) and  a[i]>power[ind]:\\n                ind+=1\\n            if ind == len(power):\\n                totdays = -1\\n                break\\n            if endurance[power[ind]] <= cou:\\n                break\\n            i+=1\\n            cou += 1\\n\\n        if totdays == -1:break\\n        totdays += 1\\n    print(totdays)\", \"from collections import *\\nfrom bisect import bisect_left as bl\\nimport sys\\ninput = sys.stdin.readline\\ndef li():return [int(i) for i in input().rstrip('\\\\n').split(' ')]\\ndef val():return int(input())\\n \\nfor _ in range(val()):\\n    n = val();a = li();m = val();h = [];visited = defaultdict(int)\\n    for i in range(m):\\n        x,y = li()\\n        visited[x] = max(visited[x],y)\\n    \\n    endurance, currmax, h = {}, -float('inf'), sorted([[i,visited[i]] for i in visited],key = lambda x:x[0],reverse = 1)\\n    \\n    for i in range(len(h)):\\n        if h[i][1]>currmax:\\n            currmax = max(currmax,h[i][1])\\n            endurance[h[i][0]] = currmax\\n \\n    power = sorted(list(endurance))\\n\\n    totdays = i = 0\\n    while i<n:\\n        ind = bl(power,a[i])\\n        if ind == len(power):\\n            totdays = -1\\n            break\\n        cou = 0\\n        while i<n:\\n            while ind<len(power) and  a[i]>power[ind]:ind+=1\\n            if ind == len(power):\\n                totdays = -1;break\\n            if endurance[power[ind]] <= cou:break\\n            i+=1\\n            cou += 1\\n        if totdays == -1:break\\n        \\n        totdays += 1\\n    \\n    print(totdays)\", \"import sys\\ninput = sys.stdin.readline\\nT = int(input())\\nAns = []\\nfor _ in range(T):\\n    N = int(input()) \\n    A = list(map(int, input().split()))\\n    M = int(input()) \\n    PS = [list(map(int, input().split())) for _ in range(M)]\\n    L = [0] * (N+1)\\n    for p, s in PS:\\n        L[s] = max(L[s], p)\\n    for i in range(N-1, -1, -1):\\n        L[i] = max(L[i], L[i+1])\\n    ans = 1\\n    cnt = 1\\n    ma = 0\\n    if L[1] < max(A):\\n        Ans.append(-1)\\n        continue\\n    for a in A:\\n        ma = max(ma, a)\\n        if L[cnt] < ma:\\n            cnt = 1\\n            ans += 1\\n            ma = a\\n        cnt += 1\\n    Ans.append(ans)\\n \\nprint(\\\"\\\\n\\\".join(map(str, Ans)))\", \"import sys\\nsin = sys.stdin\\nt = int(sin.readline())\\nfor _ in range(t):\\n    n = int(sin.readline())\\n    monpows = [int(x) for x in sin.readline().split()]\\n    m = int(sin.readline())\\n    endtopow = dict()\\n    maxhero = 0\\n    for _ in range(m):\\n        h = [int(x) for x in sin.readline().split()]\\n        maxhero = max(maxhero, h[0])\\n        if h[1] in endtopow:\\n            endtopow[h[1]] = max(h[0], endtopow[h[1]])\\n        else:\\n            endtopow[h[1]] = h[0]\\n    endurances = [0 for x in range(n+2)]\\n    for i in range(len(endurances) - 2, -1, -1):\\n        if i in endtopow:\\n            endurances[i] = max(endurances[i+1], endtopow[i])\\n        else:\\n            endurances[i] = endurances[i+1]\\n    days = 0\\n    msofar = 0\\n    maxpow = 0\\n    i = 0\\n    cant = False\\n    while i < n:\\n        maxpow = max(maxpow, monpows[i])\\n        if maxpow > maxhero:\\n            cant = True\\n            break\\n        if maxpow <= endurances[msofar + 1]:\\n            i += 1\\n            msofar += 1\\n        else:\\n            msofar = 0\\n            maxpow = 0\\n            days += 1\\n    days += 1\\n    if not cant:\\n        print(days)\\n    else:\\n        print(-1)\\n\", \"t = int(input())\\nfor _ in range(t):\\n    # print()\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    m = int(input())\\n    b = [tuple(map(int, input().split())) for __ in range(m)]\\n    ans = 1\\n    # mx[i] stores the max power of the hero that can go i steps\\n    mx = [0] * (n + 1)\\n    for p, s in b:\\n        mx[s] = max(mx[s], p)\\n    for i in range(n-1, -1, -1):\\n        mx[i] = max(mx[i], mx[i+1])\\n\\n    # print(a)\\n    # print(b)\\n    if mx[1] < max(a):\\n        print(-1)\\n    else:\\n        index = 1\\n        ma = 0\\n        for mon in a:\\n            ma = max(mon, ma)\\n            if mx[index] < ma:\\n                index = 1\\n                ans += 1\\n                ma = mon\\n            index += 1\\n        # ind = 0\\n        # while ind < n:\\n        #     temp = 0\\n        #     for i in range(m):\\n        #         l = 0\\n        #         if b[i][0] <= temp:\\n        #             break\\n        #         if ind + temp == n:\\n        #             break\\n        #         # print(a[ind:len(a)])\\n        #         end = min(ind+b[i][0], len(a))\\n        #         for j in range(ind, end):\\n        #             if a[j] > b[i][1]:\\n        #                 break\\n        #             l += 1\\n        #         if l > temp:\\n        #             temp = l\\n        #     # print(temp, ind)\\n        #     ind += temp\\n        #     ans += 1\\n        #     # print(a, temp)\\n        print(ans)\\n\", \"import sys\\ndef I():\\n        return sys.stdin.readline().rstrip()\\nfor _ in range(int(I())):\\n    n = int(I())\\n    a = list( map( int, I().split() ) )\\n    m = int(I())\\n    pl = sorted([ list( map( int, I().split() ) ) for _ in range( m ) ])\\n    pln, mxs = [], 0\\n    for x in pl[::-1]:\\n        if x[ 1 ] > mxs:\\n            pln.append( x )\\n        mxs = max( mxs, x[ 1 ] )\\n    pl = pln[::-1]\\n    m = len( pl )\\n    p, s = list(map( list, list(zip( *pl )) ))\\n    if max( a ) > max( p ):\\n        print( -1 )\\n    else:\\n        days = 0\\n        c = 0\\n        d2 = 1\\n        while d2 <= m:\\n            d2 *= 2\\n        d2 //= 2\\n        while c < n:\\n            days += 1\\n            mx = 0\\n            inday = 0\\n            while c < n:\\n                mx = max( mx, a[ c ] )\\n                inday += 1\\n                pi = -1\\n                d = d2\\n                while d:\\n                    np = pi + d\\n                    if np < m and p[ np ] < mx:\\n                        pi = np\\n                    d //= 2\\n                pi += 1\\n                if pi < m and s[ pi ] >= inday:\\n                    c += 1\\n                else:\\n                    break\\n        print( days )\\n\", \"t = int(input())\\n\\nfor _ in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    m = int(input())\\n    h = [tuple(map(int, input().split())) for i in range(m)]\\n    h.sort(reverse=True)\\n    new_h = []\\n    prev = 0\\n    for p, s in h:\\n        if s > prev:\\n            new_h.append((p, s))\\n            prev = s\\n\\n    h = new_h\\n    hum = 0\\n    res = 1\\n    cur = 0\\n    maxp = 0\\n    for mon in a:\\n        maxp = max(mon, maxp)\\n        cur += 1\\n        if mon > h[0][0]:\\n            res = -1\\n            break\\n        if hum < len(h) and cur > h[hum][1]:\\n            hum += 1\\n        if hum == len(h) or maxp > h[hum][0]:\\n            res += 1\\n            hum = 0\\n            cur = 1\\n            maxp = mon\\n\\n    print(res)\\n\\n\", \"# -*- coding: utf-8 -*-\\n\\nimport sys\\nfrom bisect import bisect_left\\n\\ndef input(): return sys.stdin.readline().strip()\\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\\ndef ceil(x, y=1): return int(-(-x // y))\\ndef INT(): return int(input())\\ndef MAP(): return list(map(int, input().split()))\\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\\ndef Yes(): print('Yes')\\ndef No(): print('No')\\ndef YES(): print('YES')\\ndef NO(): print('NO')\\nsys.setrecursionlimit(10 ** 9)\\nINF = 10 ** 18\\nMOD = 10 ** 9 + 7\\n\\nclass SegTree:\\n\\n    def __init__(self, n, func, intv, A=[]):\\n\\n        self.n = n\\n        self.func = func\\n        self.intv = intv\\n        n2 = 1\\n        while n2 < n:\\n            n2 <<= 1\\n        self.n2 = n2\\n        self.tree = [self.intv] * (n2 << 1)\\n        if A:\\n            for i in range(n):\\n                self.tree[n2+i] = A[i]\\n            for i in range(n2-1, -1, -1):\\n                self.tree[i] = self.func(self.tree[i*2], self.tree[i*2+1])\\n\\n    def update(self, i, x):\\n\\n        i += self.n2\\n        self.tree[i] = x\\n        while i > 0:\\n            i >>= 1\\n            self.tree[i] = self.func(self.tree[i*2], self.tree[i*2+1])\\n\\n    def query(self, a, b):\\n\\n        l = a + self.n2\\n        r = b + self.n2\\n        s = self.intv\\n        while l < r:\\n            if r & 1:\\n                r -= 1\\n                s = self.func(s, self.tree[r])\\n            if l & 1:\\n                s = self.func(s, self.tree[l])\\n                l += 1\\n            l >>= 1\\n            r >>= 1\\n        return s\\n\\n    def get(self, i):\\n        return self.tree[i+self.n2]\\n\\n    def all(self):\\n        return self.tree[1]\\n\\ndef bisearch_max(mn, mx, func):\\n\\n    ok = mn\\n    ng = mx\\n    while ok+1 < ng:\\n        mid = (ok+ng) // 2\\n        if func(mid):\\n            ok = mid\\n        else:\\n            ng = mid\\n    return ok\\n\\ndef check(m):\\n    mx = st.query(cur, m)\\n    idx = bisect_left(P, mx)\\n    if idx == M:\\n        return False\\n    _, s = PS[idx]\\n    scnt = m - cur\\n    return s >= scnt\\n\\nans = []\\nfor _ in range(INT()):\\n    N = INT()\\n    A = LIST()\\n    M = INT()\\n    PS = []\\n    for i in range(M):\\n        p, s = MAP()\\n        PS.append((p, s))\\n\\n    PS.sort()\\n    for i in range(M-1, 0, -1):\\n        if PS[i][1] > PS[i-1][1]:\\n            PS[i-1] = (PS[i-1][0], PS[i][1])\\n    P, _ = list(zip(*PS))\\n    \\n    st = SegTree(N, max, 0, A)\\n    cur = day = 0\\n    while cur < N:\\n        res = bisearch_max(cur, N+1, check)\\n        if res == cur:\\n            ans.append(str(-1))\\n            break\\n        cur = res\\n        day += 1\\n    else:\\n        ans.append(str(day))\\n\\nprint('\\\\n'.join(ans))\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nt = int(input())\\nANS = []\\nfor _ in range(t):\\n    n = int(input())\\n    a = list(map(int,input().split()))\\n    m = int(input())\\n    ps = [list(map(int, input().split())) for _ in range(m)]\\n    p = [0] * (n+1)\\n    for i in range(m):\\n        p[ps[i][1]] = max(p[ps[i][1]], ps[i][0])\\n    for i in range(n)[::-1]:\\n        p[i] = max(p[i], p[i + 1])\\n    if p[1] < max(a):\\n        ANS.append(-1)\\n        continue\\n    ans = 0\\n    mx = 0\\n    cnt = 0\\n    i = 0\\n    for x in a:\\n        cnt += 1\\n        mx = max(mx, x)\\n        if p[cnt] < mx:\\n            ans += 1\\n            mx = x\\n            cnt = 1\\n    if cnt:\\n        ans += 1\\n    ANS.append(ans)\\n\\nprint('\\\\n'.join(map(str, ANS)))\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nt = int(input())\\nANS = []\\nfor _ in range(t):\\n    n = int(input())\\n    a = list(map(int,input().split()))\\n    m = int(input())\\n    ps = [list(map(int, input().split())) for _ in range(m)]\\n    p = [0] * (n+1)\\n    for i in range(m):\\n        p[ps[i][1]] = max(p[ps[i][1]], ps[i][0])\\n    for i in range(n)[::-1]:\\n        p[i] = max(p[i], p[i + 1])\\n    if p[1] < max(a):\\n        print(-1)\\n        continue\\n    ans = 0\\n    mx = 0\\n    cnt = 0\\n    i = 0\\n    for x in a:\\n        cnt += 1\\n        mx = max(mx, x)\\n        if p[cnt] < mx:\\n            ans += 1\\n            mx = x\\n            cnt = 1\\n    if cnt:\\n        ans += 1\\n    print(ans)\\n\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"2\\n6\\n2 3 11 14 1 8\\n2\\n3 2\\n100 1\\n5\\n3 5 100 2 3\\n2\\n30 5\\n90 1\\n\"\n  ],\n  \"outputs\": [\n    \"5\\n-1\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1257/D", "starter_code": ""}
{"id": 115, "question": "Polycarp plays a computer game (yet again). In this game, he fights monsters using magic spells.\n\nThere are two types of spells: fire spell of power $x$ deals $x$ damage to the monster, and lightning spell of power $y$ deals $y$ damage to the monster and doubles the damage of the next spell Polycarp casts. Each spell can be cast only once per battle, but Polycarp can cast them in any order.\n\nFor example, suppose that Polycarp knows three spells: a fire spell of power $5$, a lightning spell of power $1$, and a lightning spell of power $8$. There are $6$ ways to choose the order in which he casts the spells:\n\n  first, second, third. This order deals $5 + 1 + 2 \\cdot 8 = 22$ damage;  first, third, second. This order deals $5 + 8 + 2 \\cdot 1 = 15$ damage;  second, first, third. This order deals $1 + 2 \\cdot 5 + 8 = 19$ damage;  second, third, first. This order deals $1 + 2 \\cdot 8 + 2 \\cdot 5 = 27$ damage;  third, first, second. This order deals $8 + 2 \\cdot 5 + 1 = 19$ damage;  third, second, first. This order deals $8 + 2 \\cdot 1 + 2 \\cdot 5 = 20$ damage. \n\nInitially, Polycarp knows $0$ spells. His spell set changes $n$ times, each time he either learns a new spell or forgets an already known one. After each change, calculate the maximum possible damage Polycarp may deal using the spells he knows.\n\n\n-----Input-----\n\nThe first line contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of changes to the spell set.\n\nEach of the next $n$ lines contains two integers $tp$ and $d$ ($0 \\le tp_i \\le 1$; $-10^9 \\le d \\le 10^9$; $d_i \\neq 0$) \u2014 the description of the change. If $tp_i$ if equal to $0$, then Polycarp learns (or forgets) a fire spell, otherwise he learns (or forgets) a lightning spell.\n\nIf $d_i > 0$, then Polycarp learns a spell of power $d_i$. Otherwise, Polycarp forgets a spell with power $-d_i$, and it is guaranteed that he knew that spell before the change.\n\nIt is guaranteed that the powers of all spells Polycarp knows after each change are different (Polycarp never knows two spells with the same power).\n\n\n-----Output-----\n\nAfter each change, print the maximum damage Polycarp can deal with his current set of spells.\n\n\n-----Example-----\nInput\n6\n1 5\n0 10\n1 -5\n0 5\n1 11\n0 -10\n\nOutput\n5\n25\n10\n15\n36\n21", "solutions": "[\"class BIT():\\n    def __init__(self,n):\\n        self.BIT=[0]*(n+1)\\n        self.num=n\\n\\n    def query(self,idx):\\n        res_sum = 0\\n        while idx > 0:\\n            res_sum += self.BIT[idx]\\n            idx -= idx&(-idx)\\n        return res_sum\\n\\n    #Ai += x O(logN)\\n    def update(self,idx,x):\\n        while idx <= self.num:\\n            self.BIT[idx] += x\\n            idx += idx&(-idx)\\n        return\\n\\nimport sys,heapq,random\\n\\ninput=sys.stdin.readline\\n\\nn=int(input())\\nspell=[tuple(map(int,input().split())) for i in range(n)]\\n\\n\\nS=set([])\\nfor i in range(n):\\n    S.add(abs(spell[i][1]))\\nS=list(S)\\nS.sort(reverse=True)\\ncomp={i:e+1 for e,i in enumerate(S)}\\nN=len(S)\\n\\nx_exist=BIT(N)\\ny_exist=BIT(N)\\npower=BIT(N)\\n\\nX,Y,S=0,0,0\\nXmax=[]\\nYmin=[]\\nx_data=[0]*(N+1)\\ny_data=[0]*(N+1)\\n\\nfor i in range(n):\\n    t,d=spell[i]\\n    S+=d\\n    if d<0:\\n        id=comp[-d]\\n        if t==0:\\n            X-=1\\n            x_exist.update(id,-1)\\n            power.update(id,d)\\n            x_data[id]-=1\\n        else:\\n            Y-=1\\n            y_exist.update(id,-1)\\n            power.update(id,d)\\n            y_data[id]-=1\\n    else:\\n        id=comp[d]\\n        if t==0:\\n            X+=1\\n            x_exist.update(id,1)\\n            power.update(id,d)\\n            heapq.heappush(Xmax,-d)\\n            x_data[id]+=1\\n        else:\\n            Y+=1\\n            y_exist.update(id,1)\\n            power.update(id,d)\\n            heapq.heappush(Ymin,d)\\n            y_data[id]+=1\\n    if X==0:\\n        if Y==0:\\n            print(0)\\n        else:\\n            while not y_data[comp[Ymin[0]]]:\\n                heapq.heappop(Ymin)\\n            print(2*S-Ymin[0])\\n    else:\\n        if Y==0:\\n            print(S)\\n        else:\\n            start=0\\n            end=N\\n            while end-start>1:\\n                test=(end+start)//2\\n                if x_exist.query(test)+y_exist.query(test)<=Y:\\n                    start=test\\n                else:\\n                    end=test\\n            if y_exist.query(start)!=Y:\\n                print(S+power.query(start))\\n            else:\\n                while not y_data[comp[Ymin[0]]]:\\n                    heapq.heappop(Ymin)\\n                while not x_data[comp[-Xmax[0]]]:\\n                    heapq.heappop(Xmax)\\n                print(S+power.query(start)-Ymin[0]-Xmax[0])\\n\", \"#!/usr/bin/env python3\\nimport sys\\ninput = sys.stdin.readline\\n\\nclass SegmentTree:\\n    def __init__(self, a):\\n        # Operator\\n        self.op = lambda a, b : a + b\\n        # Identity element\\n        self.e = 0 \\n\\n        self.n = len(a)\\n        self.lv = (self.n - 1).bit_length()\\n        self.size = 2**self.lv\\n        self.data = [self.e] * (2*self.size - 1)\\n        # Bisect checking function \\n        self._check = lambda x, acc : acc >= x\\n        self._acc = self.e\\n\\n        self.initialize(a)\\n\\n    # Initialize data\\n    def initialize(self, a):\\n        for i in range(self.n):\\n            self.data[self.size + i - 1] = a[i]\\n        for i in range(self.size-2, -1, -1):\\n            self.data[i] = self.op(self.data[i*2 + 1], self.data[i*2 + 2])\\n\\n    # Update ak as x (0-indexed)\\n    def update(self, k, x):\\n        k += self.size - 1\\n        self.data[k] = x\\n        while k > 0:\\n            k = (k - 1) // 2\\n            self.data[k] = self.op(self.data[2*k+1], self.data[2*k+2])\\n\\n    # Min value in [l, r) (0-indexed)\\n    def fold(self, l, r):\\n        L = l + self.size; R = r + self.size\\n        s = self.e\\n        while L < R:\\n            if R & 1:\\n                R -= 1\\n                s = self.op(s, self.data[R-1])\\n            if L & 1:\\n                s = self.op(s, self.data[L-1])\\n                L += 1\\n            L >>= 1; R >>= 1\\n        return s\\n\\n    def _bisect_forward(self, x, start, k):\\n        # When segment-k is at the bottom, accumulate and return.\\n        if k >= self.size - 1:\\n            self._acc = self.op(self._acc, self.data[k])\\n            if self._check(x, self._acc):\\n                return k - (self.size - 1)\\n            else:\\n                return -1\\n        width = 2**(self.lv - (k+1).bit_length() + 1)\\n        mid = (k+1) * width + width // 2 - self.size \\n        # When left-child isn't in range, just look at right-child. \\n        if mid <= start:\\n            return self._bisect_forward(x, start, 2*k + 2)\\n        # When segment-k is in range and has no answer in it, accumulate and return -1\\n        tmp_acc = self.op(self._acc, self.data[k])\\n        if start <= mid - width // 2 and not self._check(x, tmp_acc):\\n            self._acc = tmp_acc\\n            return -1\\n        # Check left-child then right-child\\n        vl = self._bisect_forward(x, start, 2*k + 1)\\n        if vl != -1:\\n            return vl\\n        return self._bisect_forward(x, start, 2*k + 2)\\n    \\n    # Returns min index s.t. start <= index and satisfy check(data[start:idx)) = True\\n    def bisect_forward(self, x, start=None):\\n        if start:\\n            ret = self._bisect_forward(x, start, 0)\\n        else:\\n            ret = self._bisect_forward(x, 0, 0)\\n        self._acc = self.e\\n        return ret\\n\\n    def _bisect_backward(self, x, start, k):\\n        # When segment-k is at the bottom, accumulate and return.\\n        if k >= self.size - 1:\\n            self._acc = self.op(self._acc, self.data[k])\\n            if self._check(x, self._acc):\\n                return k - (self.size - 1)\\n            else:\\n                return -1\\n        width = 2**(self.lv - (k+1).bit_length() + 1)\\n        mid = (k+1) * width + width // 2 - self.size \\n        # When right-child isn't in range, just look at right-child. \\n        if mid >= start:\\n            return self._bisect_backward(x, start, 2*k + 1)\\n        # When segment-k is in range and has no answer in it, accumulate and return -1\\n        tmp_acc = self.op(self._acc, self.data[k])\\n        if start > mid + width // 2 and not self._check(x, tmp_acc):\\n            self._acc = tmp_acc\\n            return -1\\n        # Check right-child then left-child\\n        vl = self._bisect_backward(x, start, 2*k + 2)\\n        if vl != -1:\\n            return vl\\n        return self._bisect_backward(x, start, 2*k + 1)\\n    \\n    # Returns max index s.t. index < start and satisfy check(data[idx:start)) = True\\n    def bisect_backward(self, x, start=None):\\n        if start:\\n            ret = self._bisect_backward(x, start, 0)\\n        else:\\n            ret = self._bisect_backward(x, self.n, 0)\\n        self._acc = self.e\\n        return ret\\n\\nn = int(input())\\nquery = []\\nseen = set([0])\\nfor _ in range(n):\\n    kind, val = map(int, input().split())\\n    query.append((kind, val))\\n    if val > 0: \\n        seen.add(val)\\n\\nunique = list(seen)\\nunique.sort()\\ncomp = {val: i for i, val in enumerate(unique)}\\ndecomp = {i: val for i, val in enumerate(unique)}\\ndecopm = {}\\nnn = len(comp)\\n\\nbase = [0] * nn\\nSTfire = SegmentTree(base)\\nSTnum = SegmentTree(base)\\nSTval = SegmentTree(base)\\n\\ntnum = 0\\nfnum = 0\\nspell = 0\\ntotal = 0\\nfor kind, val in query:\\n    cd = comp[abs(val)]\\n    if val > 0:\\n        STval.update(cd, val)\\n        STnum.update(cd, 1)\\n        total += val\\n        if kind == 1:\\n            tnum += 1\\n        else:\\n            STfire.update(cd, 1)\\n            fnum += 1\\n    else:\\n        total += val\\n        STval.update(cd, 0)\\n        STnum.update(cd, 0)\\n        if kind == 1:\\n            tnum -= 1\\n        else:\\n            STfire.update(cd, 0)\\n            fnum -= 1\\n    spell = tnum + fnum\\n    if fnum == 0:\\n        fid = -1\\n    else:\\n        fid = STfire.bisect_forward(fnum)\\n    l = STnum.bisect_forward(spell - tnum)\\n    if tnum == 0:\\n        print(total)\\n        continue\\n    if fid >= l + 1:\\n        double_total = STval.fold(l + 1, nn)\\n        print(total + double_total)\\n    else:\\n        l = STnum.bisect_forward(spell - tnum + 1)\\n        double_total = STval.fold(l + 1, nn)\\n        if fnum > 0:\\n            print(total + double_total + decomp[fid])\\n        else:\\n            print(total + double_total)\"]", "input_output": "{\n  \"inputs\": [\n    \"6\\n1 5\\n0 10\\n1 -5\\n0 5\\n1 11\\n0 -10\\n\"\n  ],\n  \"outputs\": [\n    \"5\\n25\\n10\\n15\\n36\\n21\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1398/E", "starter_code": ""}
{"id": 116, "question": "Let's call an array $a_1, a_2, \\dots, a_m$ of nonnegative integer numbers good if $a_1 + a_2 + \\dots + a_m = 2\\cdot(a_1 \\oplus a_2 \\oplus \\dots \\oplus a_m)$, where $\\oplus$ denotes the bitwise XOR operation.\n\nFor example, array $[1, 2, 3, 6]$ is good, as $1 + 2 + 3 + 6 = 12 = 2\\cdot 6 = 2\\cdot (1\\oplus 2 \\oplus 3 \\oplus 6)$. At the same time, array $[1, 2, 1, 3]$ isn't good, as $1 + 2 + 1 + 3 = 7 \\neq 2\\cdot 1 = 2\\cdot(1\\oplus 2 \\oplus 1 \\oplus 3)$.\n\nYou are given an array of length $n$: $a_1, a_2, \\dots, a_n$. Append at most $3$ elements to it to make it good. Appended elements don't have to be different. It can be shown that the solution always exists under the given constraints. If there are different solutions, you are allowed to output any of them. Note that you don't have to minimize the number of added elements!. So, if an array is good already you are allowed to not append elements.\n\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10\\,000$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ $(1\\le n \\le 10^5)$\u00a0\u2014 the size of the array.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0\\le a_i \\le 10^9$)\u00a0\u2014 the elements of the array.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, output two lines.\n\nIn the first line, output a single integer $s$ ($0\\le s\\le 3$)\u00a0\u2014 the number of elements you want to append.\n\nIn the second line, output $s$ integers $b_1, \\dots, b_s$ ($0\\le b_i \\le 10^{18}$)\u00a0\u2014 the elements you want to append to the array.\n\nIf there are different solutions, you are allowed to output any of them.\n\n\n-----Example-----\nInput\n3\n4\n1 2 3 6\n1\n8\n2\n1 1\n\nOutput\n0\n\n2\n4 4\n3\n2 6 2\n\n\n\n-----Note-----\n\nIn the first test case of the example, the sum of all numbers is $12$, and their $\\oplus$ is $6$, so the condition is already satisfied.\n\nIn the second test case of the example, after adding $4, 4$, the array becomes $[8, 4, 4]$. The sum of numbers in it is $16$, $\\oplus$ of numbers in it is $8$.", "solutions": "[\"for nt in range(int(input())):\\n\\tn=int(input())\\n\\tl=list(map(int,input().split()))\\n\\ts=sum(l)\\n\\te=l[0]\\n\\tfor i in range(1,n):\\n\\t\\te=e^l[i]\\n\\tif s==2*e:\\n\\t\\tprint(0)\\n\\t\\tprint ()\\n\\telse:\\n\\t\\tprint(2)\\n\\t\\tprint(e,s+e)\\n\", \"for _ in range(int(input())):\\n\\tn=int(input())\\n\\tl=list(map(int,input().split()))\\n\\tx=0\\n\\tfor i in l:\\n\\t\\tx^=i\\n\\ts=sum(l)\\n\\tif s==(2*x):\\n\\t\\tprint(\\\"0\\\\n\\\")\\n\\telse:\\n\\t\\tif x==0:\\n\\t\\t\\tprint(\\\"1\\\")\\n\\t\\t\\tprint(s)\\n\\t\\telse:\\n\\t\\t\\tprint(\\\"2\\\")\\n\\t\\t\\tprint(x,x+s)\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n4\\n1 2 3 6\\n1\\n8\\n2\\n1 1\\n\"\n  ],\n  \"outputs\": [\n    \"0\\n\\n2\\n4 4\\n3\\n2 2 6\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1270/C", "starter_code": ""}
{"id": 117, "question": "All techniques in the ninja world consist of hand seals. At the moment Naruto is learning a new technique, which consists of $n\\cdot m$ different seals, denoted by distinct numbers. All of them were written in an $n\\times m$ table.\n\nThe table is lost now. Naruto managed to remember elements of each row from left to right, and elements of each column from top to bottom, but he doesn't remember the order of rows and columns. Please restore the table consistent with this data so that Naruto will be able to learn the new technique.\n\n\n-----Input-----\n\nThe first line of the input contains the only integer $t$ ($1\\leq t\\leq 100\\,000$) denoting the number of test cases. Their descriptions follow.\n\nThe first line of each test case description consists of two space-separated integers $n$ and $m$ ($1 \\leq n, m \\leq 500$) standing for the number of rows and columns in the table, respectively. All hand seals are encoded by the positive integers from $1$ to $n\\cdot m$.\n\nThe following $n$ lines contain $m$ space separated integers each, denoting elements of an arbitrary row in the table left to right.\n\nThe following $m$ lines contain $n$ space separated integers each, denoting elements of an arbitrary column in the table top to bottom.\n\nSum of $nm$ over all test cases does not exceed $250\\,000$. It is guaranteed that each row occurs in the input exactly once, as well as each column. It is also guaranteed that each number from $1$ to $nm$ occurs exactly once in all rows, as well as in all columns. Finally, it is guaranteed that a table consistent with the input exists.\n\n\n-----Output-----\n\nFor each test case, output $n$ lines with $m$ space-separated integers each, denoting the restored table. One can show that the answer is always unique.\n\n\n-----Example-----\nInput\n2\n2 3\n6 5 4\n1 2 3\n1 6\n2 5\n3 4\n3 1\n2\n3\n1\n3 1 2\n\nOutput\n1 2 3 \n6 5 4 \n3 \n1 \n2 \n\n\n\n-----Note-----\n\nConsider the first test case. The matrix is $2 \\times 3$. You are given the rows and columns in arbitrary order.\n\nOne of the rows is $[6, 5, 4]$. One of the rows is $[1, 2, 3]$.\n\nOne of the columns is $[1, 6]$. One of the columns is $[2, 5]$. One of the columns is $[3, 4]$.\n\nYou are to reconstruct the matrix. The answer is given in the output.", "solutions": "[\"from sys import stdin\\ninput = stdin.readline\\n\\ntests = int(input())\\nfor test in range(tests):\\n    n, m = list(map(int, input().split()))\\n    a = [[0] * m for _ in range(n)]\\n    r = [[int(i) for i in input().split()] for _ in range(n)]\\n    c = [[int(i) for i in input().split()] for _ in range(m)]\\n    z = [[-1, -1] for _ in range(n * m + 1)]\\n    \\n    for i in range(n):\\n        for j in range(m):\\n            z[r[i][j]][0] = j\\n    for i in range(m):\\n        for j in range(n):\\n            z[c[i][j]][1] = j\\n\\n    for i in range(1, n * m + 1):\\n        a[z[i][1]][z[i][0]] = i\\n\\n    for i in a:\\n        print(' '.join([str(j) for j in i]))\\n\", \"import sys as _sys\\n\\n\\ndef main():\\n    t = int(input())\\n    for i_t in range(t):\\n        \\n        rows_n, columns_n = _read_ints()\\n        rows = [tuple(_read_ints()) for i_row in range(rows_n)]\\n        columns = [tuple(_read_ints()) for i_column in range(columns_n)]\\n        \\n        any_first_column_element = rows[0][0]\\n        \\n        i_first_column = 0\\n        while any_first_column_element not in columns[i_first_column]:\\n            i_first_column += 1\\n        first_column = columns[i_first_column]\\n        \\n        # Can be written in O(N*log(N)) but it is not necessary for N <= 500\\n        rows = sorted(rows, key=lambda row: first_column.index(row[0]))\\n        \\n        for row in rows:\\n            print(*row)\\n\\n\\ndef _read_line():\\n    result = _sys.stdin.readline()\\n    assert result[-1] == \\\"\\\\n\\\"\\n    return result[:-1]\\n\\n\\ndef _read_ints():\\n    return list(map(int, _read_line().split()))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import math\\nfrom collections import deque\\nfrom sys import stdin, stdout, setrecursionlimit\\nfrom string import ascii_letters\\nletters = ascii_letters[:26]\\nfrom collections import defaultdict\\n#from functools import reduce\\ninput = stdin.readline\\n#print = stdout.write\\n\\nfor _ in range(int(input())):\\n    n, m = list(map(int, input().split()))\\n    horizontal = [list(map(int, input().split())) for i in range(n)]\\n    vertical = [list(map(int, input().split())) for i in range(m)]\\n    vals = vertical[0]\\n    first = vals[0]\\n    pos = 0\\n    \\n    for i in horizontal:\\n        for g in range(m):\\n            if i[g] == first:\\n                pos = g\\n    \\n    path = {}\\n    order = {}\\n    for ind, i in enumerate(vals):\\n        path[i] = ind\\n    for ind, i in enumerate(horizontal):\\n        order[path[i[pos]]] = ind\\n\\n    for i in range(len(order)):\\n        print(*horizontal[order[i]])\\n\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"2\\n2 3\\n6 5 4\\n1 2 3\\n1 6\\n2 5\\n3 4\\n3 1\\n2\\n3\\n1\\n3 1 2\\n\"\n  ],\n  \"outputs\": [\n    \"1 2 3 \\n6 5 4 \\n3 \\n1 \\n2 \\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1413/B", "starter_code": ""}
{"id": 118, "question": "There are $n$ programmers that you want to split into several non-empty teams. The skill of the $i$-th programmer is $a_i$. You want to assemble the maximum number of teams from them. There is a restriction for each team: the number of programmers in the team multiplied by the minimum skill among all programmers in the team must be at least $x$.\n\nEach programmer should belong to at most one team. Some programmers may be left without a team.\n\nCalculate the maximum number of teams that you can assemble.\n\n\n-----Input-----\n\nThe first line contains the integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $x$ ($1 \\le n \\le 10^5; 1 \\le x \\le 10^9$)\u00a0\u2014 the number of programmers and the restriction of team skill respectively.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots , a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ is the skill of the $i$-th programmer.\n\nThe sum of $n$ over all inputs does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case print one integer \u2014 the maximum number of teams that you can assemble. \n\n\n-----Example-----\nInput\n3\n5 10\n7 11 2 9 5\n4 8\n2 4 2 3\n4 11\n1 3 3 7\n\nOutput\n2\n1\n0", "solutions": "[\"__MULTITEST = True\\n\\n## solve\\ndef solve():\\n    n, x = map(int, input().split())\\n    a = list(map(int, input().split()))\\n    a.sort()\\n\\n    group = 0\\n    ptr = n-1\\n    members = 0\\n\\n    currentMin = int(1e10)\\n    while ptr > -1:\\n        currentMin = min(currentMin, a[ptr])\\n        members += 1\\n\\n        if currentMin * members >= x:\\n            group += 1\\n            members = 0\\n            currentMin = int(1e10)\\n        \\n        ptr -= 1\\n    \\n    print(group)\\n\\n## main\\ndef __starting_point():\\n    t = (int(input()) if __MULTITEST else 1)\\n    for tt in range(t):\\n        solve();\\n__starting_point()\", \"import sys\\nimport math\\ndef II():\\n\\treturn int(sys.stdin.readline())\\n\\ndef LI():\\n\\treturn list(map(int, sys.stdin.readline().split()))\\n\\ndef MI():\\n\\treturn list(map(int, sys.stdin.readline().split()))\\n\\ndef SI():\\n\\treturn sys.stdin.readline().strip()\\nt = II()\\nfor q in range(t):\\n\\tn,x = MI()\\n\\ta = sorted(LI())\\n\\ta = a[::-1]\\n\\tl = 0\\n\\tcount = 1\\n\\tans = 0\\n\\twhile l<n:\\n\\t\\tif count*a[l]>=x:\\n\\t\\t\\tans+=1\\n\\t\\t\\tcount = 1\\n\\t\\telse:\\n\\t\\t\\tcount+=1\\n\\t\\tl+=1\\n\\tprint(ans)\\n\\n\\n\\n\", \"for _ in range(int(input())):\\n    a,x = [int(a) for a in input().split(' ')]\\n    arr = [int(a) for a in input().split(' ')]\\n    arr = sorted(arr,reverse=True)\\n    cur_skill = x\\n    teams = 0\\n    cur_len = 0\\n    for i in arr:\\n        if i >= x:\\n            teams+=1\\n            continue\\n        else:\\n            cur_skill = i\\n            cur_len+=1\\n            if cur_len*cur_skill >= x:\\n                teams+=1\\n                cur_len = 0\\n                cur_skill = x\\n\\n    print(teams)\", \"import bisect\\nimport sys\\nimport math\\ninput = sys.stdin.readline\\nimport functools\\n\\nfrom collections import defaultdict\\n\\n############ ---- Input Functions ---- ############\\n\\ndef inp():\\n    return(int(input()))\\ndef inlt():\\n    return(list(map(int,input().split())))\\ndef insr():\\n    s = input()\\n    return(list(s[:len(s) - 1]))\\ndef invr():\\n    return(list(map(int,input().split())))\\n\\n############ ---- Solution ---- ############\\n\\ndef solve(case):\\n    [n, x] = inlt()\\n    aa = inlt()\\n    aa.sort()\\n    new_team = n-1\\n    res = 0\\n    for i in range(n-1, -1, -1):\\n        if aa[i] * (new_team - i + 1) >= x:\\n            res += 1\\n            new_team = i-1\\n    return res\\n    \\n\\nif len(sys.argv) > 1 and sys.argv[1].startswith(\\\"input\\\"):\\n    f = open(\\\"./\\\" + sys.argv[1], 'r')\\n    input = f.readline\\n\\nT = inp()\\nfor i in range(T):\\n    res = solve(i+1)\\n    print(str(res))\\n\", \"from sys import stdin, stdout\\nimport math,sys\\nfrom itertools import permutations, combinations\\nfrom collections import defaultdict,deque,OrderedDict\\nfrom os import path\\nimport bisect as bi\\nimport heapq \\ndef yes():print('YES')\\ndef no():print('NO')\\nif (path.exists('input.txt')): \\n    #------------------Sublime--------------------------------------#\\n    sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\\n    def I():return (int(input()))\\n    def In():return(list(map(int,input().split())))\\nelse:\\n    #------------------PYPY FAst I/o--------------------------------#\\n    def I():return (int(stdin.readline()))\\n    def In():return(list(map(int,stdin.readline().split())))\\ndef dict(a):\\n    d={}\\n    for x in a:\\n        if d.get(x,-1)!=-1:\\n            d[x]+=1\\n        else:\\n            d[x]=1\\n    return d\\n\\n\\ndef main():\\n    try:\\n        n,X=In()\\n        l=list(In())\\n        l.sort(reverse=True)\\n        mi=-1\\n        j,ans=0,0\\n        for x in range(n):\\n            if mi==-1:\\n                mi=l[x]\\n                j=1\\n            else:\\n                mi=min(mi,l[x])\\n                j+=1\\n            if mi*j>=X:\\n                ans+=1\\n                mi=-1\\n                j=0\\n        print(ans)\\n\\n    except:\\n        pass\\n        \\nM = 998244353\\nP = 1000000007\\n \\ndef __starting_point():\\n    for _ in range(I()):main()\\n    #for _ in range(1):main()\\n\\n__starting_point()\", \"from bisect import bisect_left as bl\\nfrom bisect import bisect_right as br\\nfrom heapq import heappush,heappop,heapify\\nimport math\\nfrom collections import *\\nfrom functools import reduce,cmp_to_key\\nimport sys\\ninput = sys.stdin.readline\\nM = mod = 998244353\\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\\ndef inv_mod(n):return pow(n, mod - 2, mod)\\n \\ndef li():return [int(i) for i in input().rstrip('\\\\n').split()]\\ndef st():return input().rstrip('\\\\n')\\ndef val():return int(input().rstrip('\\\\n'))\\ndef li2():return [i for i in input().rstrip('\\\\n')]\\ndef li3():return [int(i) for i in input().rstrip('\\\\n')]\\n\\nfor _ in range(val()):\\n    n, x = li()\\n    l = sorted(li())[::-1]\\n    ans = curr = 0\\n    mi = float('inf')\\n    for i in range(n):\\n        curr += 1\\n        mi = min(mi,l[i])\\n        if curr * mi >= x:\\n            ans += 1\\n            mi = float('inf')\\n            curr = 0\\n    print(ans)\", \"def solve(arr,n,x,ans):\\n    arr.sort()\\n    teams = 0\\n    size = 0\\n    while arr:\\n        min_val = arr.pop()\\n        size += 1\\n        if min_val*size >= x:\\n            teams += 1\\n            size = 0\\n\\n    ans.append(teams)\\n\\ndef main():\\n    t = int(input())\\n    ans = []\\n    for i in range(t):\\n        n,x = list(map(int,input().split()))\\n        arr = list(map(int,input().split()))\\n        solve(arr,n,x,ans)\\n\\n    for i in ans:\\n        print(i)\\n\\n\\nmain()\\n\", \"def solve(n, x, arr):\\n    arr = sorted(arr)\\n    res = 0\\n    temp_length_so_far = 0\\n    for i in range(n - 1, -1, -1):\\n        temp_length_so_far += 1\\n        if arr[i] * temp_length_so_far >= x:\\n            res += 1\\n            temp_length_so_far = 0\\n    return res\\n\\n\\nT = int(input())\\nfor _ in range(T):\\n    n, x = list(map(int, input().split()))\\n    arr = list(map(int, input().split()))\\n    print(solve(n, x, arr))\\n\", \"t = int(input())\\nfor _ in range(t):\\n    n, x = list(map(int, input().split()))\\n    l = list(map(int, input().split()))\\n    l.sort(reverse=True)\\n    out = 0\\n    count = 0\\n    for v in l:\\n        if v * (count + 1) >= x:\\n            out += 1\\n            count = 0\\n        else:\\n            count += 1\\n    print(out)\\n\", \"import math \\nfrom collections import deque\\nimport sys\\n\\n\\nsys.setrecursionlimit(10**4) \\n\\ndef Divisors(n) : \\n\\t\\n\\tl=[]\\n\\ti = 2\\n\\twhile i <= math.sqrt(n): \\n\\t\\t\\n\\t\\tif (n % i == 0) : \\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\tif (n // i == i) : \\n\\t\\t\\t\\tl.append(i)\\n\\t\\t\\telse : \\n\\t\\t\\t\\tl.append(i)\\n\\t\\t\\t\\tl.append(n//i)\\n\\t\\ti = i + 1\\n\\treturn l\\n\\ndef SieveOfEratosthenes(n): \\n\\t\\n\\tl=[]\\n\\t\\n\\tprime = [True for i in range(n+1)] \\n\\tp = 2\\n\\twhile (p * p <= n): \\n\\t\\t\\n\\t\\tif (prime[p] == True): \\n\\t\\t\\t\\n\\t\\t\\tfor i in range(p * p, n+1, p): \\n\\t\\t\\t\\tprime[i] = False\\n\\t\\tp += 1\\n\\t\\n\\tfor p in range(2, n+1): \\n\\t\\tif prime[p]: \\n\\t\\t\\tl.append(p)\\n\\t\\n\\treturn l\\t\\t\\n\\ndef primeFactors(n): \\n\\t\\n\\tl=[]\\n\\t\\n\\twhile n % 2 == 0: \\n\\t\\tl.append(2) \\n\\t\\tn = n / 2\\n\\t\\t\\n\\tfor i in range(3,int(math.sqrt(n))+1,2): \\n\\t\\t\\n\\t\\twhile n % i== 0: \\n\\t\\t\\tl.append(i) \\n\\t\\t\\tn = n / i \\n\\t\\t\\t\\n\\tif n > 2: \\n\\t\\tl.append(n)\\n\\t\\n\\treturn(l)\\t\\n\\t\\t\\n\\ndef Factors(n) : \\n\\t\\n\\t\\n\\tresult = []\\n\\t\\n\\tfor i in range(2,(int)(math.sqrt(n))+1) : \\n\\n\\t\\tif (n % i == 0) : \\n\\t\\t    \\n\\t\\t\\tif (i == (n/i)) : \\n\\t\\t\\t\\tresult.append(i)\\n\\t\\t\\telse : \\n\\t\\t\\t    result.append(i)\\n\\t\\t\\t    result.append(n//i)\\n\\t\\t\\n\\tresult.append(1)\\n\\t\\n\\treturn result\\n\\ndef maxSubArraySum(a): \\n\\t\\n\\tmax_so_far = 0\\n\\tmax_ending_here = 0\\n\\tsize=len(a)\\n\\t\\n\\tfor i in range(0, size): \\n\\t\\tmax_ending_here = max_ending_here + a[i] \\n\\t\\tif (max_so_far < abs(max_ending_here)): \\n\\t\\t\\tmax_so_far = max_ending_here \\n\\n\\treturn max_so_far \\n\\ndef longestsubarray(arr, n, k): \\n    current_count = 0\\n      \\n    # this will contain length of  \\n    # longest subarray found \\n    max_count = 0\\n  \\n    for i in range(0, n, 1): \\n        if (arr[i] % k != 0): \\n            current_count += 1\\n        else: \\n            current_count = 0\\n        max_count = max(current_count,  \\n                            max_count) \\n      \\n    return max_count \\n    \\n#print(SieveOfEratosthenes(100))\\n#print(Divisors(100))\\n#print(primeFactors(100))\\n#print(Factors(100))\\n#print(maxSubArraySum(a))\\n \\n\\ndef main():\\n    \\n    n,x=list(map(int,input().split()))\\n    l=list(map(int,input().split()))\\n    l.sort()\\n    c=1\\n    ans=0\\n    for j in range(len(l)-1,-1,-1):\\n        if l[j]*c >=x:\\n            ans+=1\\n            c=1\\n        else:\\n            c+=1\\n            \\n    print(ans)\\n        \\n    \\n    \\n          \\nt=int(input())\\nfor i in range(0,t):\\n    main()\", \"input=__import__('sys').stdin.readline\\nfor _ in range(int(input())):\\n    n,x=map(int,input().split())\\n    s=sorted(map(int,input().split()),reverse=True)\\n    i=ans=0\\n    c=1\\n    while i<n:\\n        if c*s[i]>=x:ans+=1;c=1\\n        else:c+=1\\n        i+=1\\n    print(ans)\", \"import sys\\nimport heapq, functools, collections\\nimport math, random\\nfrom collections import Counter, defaultdict\\n\\n# available on Google, not available on Codeforces\\n# import numpy as np\\n# import scipy\\n\\n\\ndef solve(lst,x):  # fix inputs here\\n    console(\\\"----- solving ------\\\")\\n\\n    lst = sorted(lst)[::-1]\\n\\n    cnt = 0\\n    pdt = lst[0]\\n    res = 0\\n    for i in lst:\\n        cnt += 1\\n        pdt = min(i, pdt)\\n        if cnt*pdt >= x:\\n            res += 1\\n            cnt = 0\\n            pdt = i\\n        \\n    # return a string (i.e. not a list or matrix)\\n    return res\\n\\n\\ndef console(*args):  # the judge will not read these print statement\\n    print('\\\\033[36m', *args, '\\\\033[0m', file=sys.stderr)\\n    return\\n\\n# fast read all\\n# sys.stdin.readlines()\\n\\nfor case_num in range(int(input())):\\n    # read line as a string\\n    # strr = input()\\n\\n    # read line as an integer\\n    # k = int(input())\\n    \\n    # read one line and parse each word as a string\\n    # lst = input().split()\\n\\n    # read one line and parse each word as an integer\\n    _,x = list(map(int,input().split()))\\n    lst = list(map(int,input().split()))\\n\\n    # read matrix and parse as integers (after reading read nrows)\\n    # lst = list(map(int,input().split()))\\n    # nrows = lst[0]  # index containing information, please change\\n    # grid = []\\n    # for _ in range(nrows):\\n    #     grid.append(list(map(int,input().split())))\\n\\n    res = solve(lst, x)  # please change\\n    \\n    # Google - case number required\\n    # print(\\\"Case #{}: {}\\\".format(case_num+1, res))\\n\\n    # Codeforces - no case number required\\n    print(res)\\n\", \"t=int(input())\\nfor _ in range(t):\\n  n,x=map(int,input().split())\\n  a=list(map(int,input().split()))\\n  a.sort()\\n  a.reverse()\\n  count=0\\n  ans=0\\n  for i in range(n):\\n    count+=1\\n    if count*a[i]>=x:\\n      ans+=1\\n      count=0\\n  print(ans)\", \"for kek in range(int(input())):\\n    (n, x) = map(int, input().split())\\n    a = list(map(int, input().split()))\\n    a.sort()\\n    for i in range(n):\\n        f = 0\\n        if  x % a[i] != 0:\\n            f += 1\\n        a[i] = x // a[i] + f\\n    a.sort()\\n    ans = 0\\n    com = 1\\n    for i in a:\\n        if i == com:\\n            ans += 1\\n            com = 1\\n        else:\\n            com += 1\\n    print(ans)\", \"for _ in range(int(input())):\\n    n, k = map(int, input().split())\\n    arr = list(map(int, input().split()))\\n    arr.sort(reverse=True)\\n    i = 0\\n    teams = 0\\n    teamMem=0\\n    while (i < len(arr)):\\n        if ((teamMem+1) * arr[i]>=k):\\n            teams += 1\\n            teamMem = 0\\n        else:\\n            teamMem += 1\\n        i += 1\\n        # print(teams,teamMem)\\n    print(teams)\", \"import sys\\ninput = lambda : sys.stdin.readline().rstrip()\\nfor _ in range(int(input())):\\n    n,x=map(int,input().split())\\n    a = sorted([int(x) for x in input().split()])\\n    ans = 0\\n    while a and a[-1]>=x:\\n        ans +=1\\n        a.pop()\\n    i=len(a)-1\\n    l=1\\n    while i>=0:\\n        if a[i]*l>=x:\\n            ans += 1\\n            l=0\\n        i-=1\\n        l+=1\\n    print(ans)\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n5 10\\n7 11 2 9 5\\n4 8\\n2 4 2 3\\n4 11\\n1 3 3 7\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n1\\n0\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1380/C", "starter_code": ""}
{"id": 119, "question": "Assume that you have $k$ one-dimensional segments $s_1, s_2, \\dots s_k$ (each segment is denoted by two integers \u2014 its endpoints). Then you can build the following graph on these segments. The graph consists of $k$ vertexes, and there is an edge between the $i$-th and the $j$-th vertexes ($i \\neq j$) if and only if the segments $s_i$ and $s_j$ intersect (there exists at least one point that belongs to both of them).\n\nFor example, if $s_1 = [1, 6], s_2 = [8, 20], s_3 = [4, 10], s_4 = [2, 13], s_5 = [17, 18]$, then the resulting graph is the following: [Image] \n\nA tree of size $m$ is good if it is possible to choose $m$ one-dimensional segments so that the graph built on these segments coincides with this tree.\n\nYou are given a tree, you have to find its good subtree with maximum possible size. Recall that a subtree is a connected subgraph of a tree.\n\nNote that you have to answer $q$ independent queries.\n\n\n-----Input-----\n\nThe first line contains one integer $q$ ($1 \\le q \\le 15 \\cdot 10^4$) \u2014 the number of the queries. \n\nThe first line of each query contains one integer $n$ ($2 \\le n \\le 3 \\cdot 10^5$) \u2014 the number of vertices in the tree.\n\nEach of the next $n - 1$ lines contains two integers $x$ and $y$ ($1 \\le x, y \\le n$) denoting an edge between vertices $x$ and $y$. It is guaranteed that the given graph is a tree.\n\nIt is guaranteed that the sum of all $n$ does not exceed $3 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each query print one integer \u2014 the maximum size of a good subtree of the given tree.\n\n\n-----Example-----\nInput\n1\n10\n1 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8\n4 9\n4 10\n\nOutput\n8\n\n\n\n-----Note-----\n\nIn the first query there is a good subtree of size $8$. The vertices belonging to this subtree are ${9, 4, 10, 2, 5, 1, 6, 3}$.", "solutions": "[\"import sys\\ninput = sys.stdin.readline\\nt = int(input())\\nfor _ in range(t):\\n  n = int(input())\\n  ab = [list(map(int,input().split())) for i in range(n-1)]\\n  graph = [[] for i in range(n+1)]\\n  deg = [0]*(n+1)\\n  for a,b in ab:\\n    graph[a].append(b)\\n    graph[b].append(a)\\n    deg[a] += 1\\n    deg[b] += 1\\n  pnt = [max(deg[i]-1,1) for i in range(n+1)]\\n  root = 1\\n  stack = [root]\\n  dist = [0]*(n+1)\\n  dist[root] = pnt[root]\\n  while stack:\\n    x = stack.pop()\\n    for y in graph[x]:\\n      if dist[y] == 0:\\n        dist[y] = dist[x]+pnt[y]\\n        stack.append(y)\\n  far = dist.index(max(dist))\\n  root = far\\n  stack = [root]\\n  dist = [0]*(n+1)\\n  dist[root] = pnt[root]\\n  while stack:\\n    x = stack.pop()\\n    for y in graph[x]:\\n      if dist[y] == 0:\\n        dist[y] = dist[x]+pnt[y]\\n        stack.append(y)\\n  print(max(dist))\"]", "input_output": "{\n  \"inputs\": [\n    \"1\\n10\\n1 2\\n1 3\\n1 4\\n2 5\\n2 6\\n3 7\\n3 8\\n4 9\\n4 10\\n\"\n  ],\n  \"outputs\": [\n    \"8\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1238/F", "starter_code": ""}
{"id": 120, "question": "Ayoub thinks that he is a very smart person, so he created a function $f(s)$, where $s$ is a binary string (a string which contains only symbols \"0\" and \"1\"). The function $f(s)$ is equal to the number of substrings in the string $s$ that contains at least one symbol, that is equal to \"1\".\n\nMore formally, $f(s)$ is equal to the number of pairs of integers $(l, r)$, such that $1 \\leq l \\leq r \\leq |s|$ (where $|s|$ is equal to the length of string $s$), such that at least one of the symbols $s_l, s_{l+1}, \\ldots, s_r$ is equal to \"1\". \n\nFor example, if $s = $\"01010\" then $f(s) = 12$, because there are $12$ such pairs $(l, r)$: $(1, 2), (1, 3), (1, 4), (1, 5), (2, 2), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 4), (4, 5)$.\n\nAyoub also thinks that he is smarter than Mahmoud so he gave him two integers $n$ and $m$ and asked him this problem. For all binary strings $s$ of length $n$ which contains exactly $m$ symbols equal to \"1\", find the maximum value of $f(s)$.\n\nMahmoud couldn't solve the problem so he asked you for help. Can you help him? \n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^5$) \u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe only line for each test case contains two integers $n$, $m$ ($1 \\leq n \\leq 10^{9}$, $0 \\leq m \\leq n$)\u00a0\u2014 the length of the string and the number of symbols equal to \"1\" in it.\n\n\n-----Output-----\n\nFor every test case print one integer number\u00a0\u2014 the maximum value of $f(s)$ over all strings $s$ of length $n$, which has exactly $m$ symbols, equal to \"1\".\n\n\n-----Example-----\nInput\n5\n3 1\n3 2\n3 3\n4 0\n5 2\n\nOutput\n4\n5\n6\n0\n12\n\n\n\n-----Note-----\n\nIn the first test case, there exists only $3$ strings of length $3$, which has exactly $1$ symbol, equal to \"1\". These strings are: $s_1 = $\"100\", $s_2 = $\"010\", $s_3 = $\"001\". The values of $f$ for them are: $f(s_1) = 3, f(s_2) = 4, f(s_3) = 3$, so the maximum value is $4$ and the answer is $4$.\n\nIn the second test case, the string $s$ with the maximum value is \"101\".\n\nIn the third test case, the string $s$ with the maximum value is \"111\".\n\nIn the fourth test case, the only string $s$ of length $4$, which has exactly $0$ symbols, equal to \"1\" is \"0000\" and the value of $f$ for that string is $0$, so the answer is $0$.\n\nIn the fifth test case, the string $s$ with the maximum value is \"01010\" and it is described as an example in the problem statement.", "solutions": "[\"import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\n\\ndef calc(x):\\n    return x*(x+1)//2\\n\\nfor test in range(t):\\n    n,m=list(map(int,input().split()))\\n\\n    ANS=calc(n)\\n\\n    k=n-m\\n    q,mod=divmod(k,m+1)\\n\\n    ANS-=calc(q+1)*mod+calc(q)*(m+1-mod)\\n\\n    print(ANS)\\n    \\n\", \"import sys\\n\\nfor _ in range(int(sys.stdin.readline())):\\n    n, m = map(int, sys.stdin.readline().split())\\n    s = (n-m)//(m+1)\\n    none = (m+1-(n-m)%(m+1))*s*(s+1)//2 + ((n-m)%(m+1))*(s+1)*(s+2)//2\\n    print((n+1)*n//2 - none)\", \"def main():\\n    import sys\\n    input = sys.stdin.readline\\n\\n    t = int(input())\\n    for _ in range(t):\\n        N, M = list(map(int, input().split()))\\n\\n        S = ((N+1) * N)//2\\n        zero = N - M\\n        num = zero // (M+1)\\n        major = zero % (M+1)\\n        minor = M+1 - major\\n        S -= major * (((num+2)*(num+1)) // 2)\\n        S -= minor * (((num+1)*num) // 2)\\n        print(S)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import sys\\nreadline = sys.stdin.readline\\nT = int(readline())\\nAns = [None]*T\\ndef calc(d):\\n    return d*(d+1)//2\\n\\nfor qu in range(T):\\n    N, M = list(map(int, readline().split()))\\n    seg = M+1\\n    leng = N-M\\n    Ans[qu] = calc(N) - calc(leng//seg) * (seg-leng%seg) - calc(leng//seg+1) *(leng%seg)\\n    \\nprint('\\\\n'.join(map(str, Ans)))\\n\", \"def main():\\n    from sys import stdin, stdout\\n    for _ in range(int(stdin.readline())):\\n        n, m = list(map(int, stdin.readline().split()))\\n        n += 1\\n        m += 1\\n        div, mod = divmod(n, m)\\n        stdout.write(f'{(n ** 2 - div ** 2 * (m - mod) - (div + 1) ** 2 * mod) // 2}\\\\n')\\n\\n\\nmain()\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"5\\n3 1\\n3 2\\n3 3\\n4 0\\n5 2\\n\"\n  ],\n  \"outputs\": [\n    \"4\\n5\\n6\\n0\\n12\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1301/C", "starter_code": ""}
{"id": 121, "question": "Reminder: the median of the array $[a_1, a_2, \\dots, a_{2k+1}]$ of odd number of elements is defined as follows: let $[b_1, b_2, \\dots, b_{2k+1}]$ be the elements of the array in the sorted order. Then median of this array is equal to $b_{k+1}$.\n\nThere are $2n$ students, the $i$-th student has skill level $a_i$. It's not guaranteed that all skill levels are distinct.\n\nLet's define skill level of a class as the median of skill levels of students of the class.\n\nAs a principal of the school, you would like to assign each student to one of the $2$ classes such that each class has odd number of students (not divisible by $2$). The number of students in the classes may be equal or different, by your choice. Every student has to be assigned to exactly one class. Among such partitions, you want to choose one in which the absolute difference between skill levels of the classes is minimized.\n\nWhat is the minimum possible absolute difference you can achieve?\n\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 10^5$)\u00a0\u2014 the number of students halved.\n\nThe second line of each test case contains $2n$ integers $a_1, a_2, \\dots, a_{2 n}$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 skill levels of students.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, output a single integer, the minimum possible absolute difference between skill levels of two classes of odd sizes.\n\n\n-----Example-----\nInput\n3\n1\n1 1\n3\n6 5 4 1 2 3\n5\n13 4 20 13 2 5 8 3 17 16\n\nOutput\n0\n1\n5\n\n\n\n-----Note-----\n\nIn the first test, there is only one way to partition students\u00a0\u2014 one in each class. The absolute difference of the skill levels will be $|1 - 1| = 0$.\n\nIn the second test, one of the possible partitions is to make the first class of students with skill levels $[6, 4, 2]$, so that the skill level of the first class will be $4$, and second with $[5, 1, 3]$, so that the skill level of the second class will be $3$. Absolute difference will be $|4 - 3| = 1$.\n\nNote that you can't assign like $[2, 3]$, $[6, 5, 4, 1]$ or $[]$, $[6, 5, 4, 1, 2, 3]$ because classes have even number of students.\n\n$[2]$, $[1, 3, 4]$ is also not possible because students with skills $5$ and $6$ aren't assigned to a class.\n\nIn the third test you can assign the students in the following way: $[3, 4, 13, 13, 20], [2, 5, 8, 16, 17]$ or $[3, 8, 17], [2, 4, 5, 13, 13, 16, 20]$. Both divisions give minimal possible absolute difference.", "solutions": "[\"for _ in range(int(input())):\\n    n = int(input())\\n    ar = list(map(int, input().split()))\\n    ar.sort()\\n    print(abs(ar[n] - ar[n - 1]))\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    a = sorted(a)\\n    print(a[n]- a[n - 1])\", \"def iinput():\\n    return [int(x) for x in input().split()]\\n\\n\\ndef main():\\n    n = int(input())\\n    data = iinput()\\n    data.sort()\\n    return abs(data[n] - data[n - 1])\\n\\n\\nfor t in range(int(input())):\\n    print(main())\", \"import sys\\n\\nT = int(sys.stdin.readline().strip())\\nfor t in range (0, T):\\n    n = int(sys.stdin.readline().strip())\\n    a = list(map(int, sys.stdin.readline().strip().split()))\\n    a.sort()\\n    print(a[n]-a[n-1])\", \"import math, collections, sys\\ninput = sys.stdin.readline\\ndef case():\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    a.sort()\\n    print(a[n]-a[n-1])\\nfor _ in range(int(input())):\\n    case()\", \"for nt in range(int(input())):\\n\\tn=int(input())\\n\\tl=list(map(int,input().split()))\\n\\tif n==1:\\n\\t\\tprint (abs(l[0]-l[1]))\\n\\t\\tcontinue\\n\\tl.sort()\\n\\tprint (abs(l[n]-l[n-1]))\", \"import math\\nfor _ in range(int(input())):\\n    n=int(input())\\n    li=list(map(int,input().split()))\\n    li.sort()\\n    print(li[n]-li[n-1])\", \"def main():\\n    import sys\\n    input = sys.stdin.readline\\n\\n    t = int(input())\\n    for _ in range(t):\\n        N = int(input())\\n        A = list(map(int, input().split()))\\n\\n        A.sort()\\n        print(A[N] - A[N-1])\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"t=int(input())\\nfor i in range(t):\\n  n=int(input())\\n  a=[int (i) for i in input().split()]\\n  a=sorted(a)\\n  print(a[n]-a[n-1])\", \"import sys\\n\\n# inf = open('input.txt', 'r')\\n# reader = (line.rstrip() for line in inf)\\nreader = (line.rstrip() for line in sys.stdin)\\ninput = reader.__next__\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    a.sort()\\n    print(a[n] - a[n - 1])\\n\\n# inf.close()\\n\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    a = list(map(int,input().split()))\\n    a.sort()\\n    print(a[n]-a[n-1])\", \"def solve():\\n    n = int(input())\\n    arr = sorted(map(int, input().split()))\\n    print(arr[n] - arr[n-1])\\n\\n\\nfor _ in range(int(input())):\\n    solve()\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    l1 = list(map(int, input().split()))\\n    l1.sort()\\n    print(l1[n] - l1[n-1])\\n\", \"def main():\\n\\tt = int(input())\\n\\tfor _ in range(t):\\n\\t\\tn = int(input())\\n\\t\\ta = [int(i) for i in input().split()]\\n\\t\\ta.sort()\\n\\t\\tprint(a[n] - a[n-1])\\n\\nmain()\\n\", \"def main():\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    a = sorted(a)\\n    print(a[len(a)//2] - a[len(a)//2 - 1])\\n\\n\\ndef __starting_point():\\n    t = int(input())\\n    for i in range(t):\\n        main()\\n__starting_point()\", \"for t in range(int(input())):\\n    n = int(input())\\n    a = sorted([int(i) for i in input().split()])\\n    print(a[n] - a[n-1])\\n\", \"for t in range(int(input())):\\n    n = int(input())\\n    l = [int(i) for i in input().split()]\\n    l.sort()\\n    print(abs(l[n] - l[n - 1]))\\n\", \"t=int(input())\\nfor i in range(t):\\n    n=int(input())\\n    a=list(map(int,input().strip().split()))\\n    a.sort()\\n    print(a[n]-a[n-1])\", \"def main():\\n    def solve():\\n\\n        n = int(input())\\n        aa = [int(a) for a in input().split()]\\n        aa.sort()\\n        print(aa[n] - aa[n-1])\\n\\n    q = int(input())\\n    for _ in range(q):\\n        solve()\\n\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"t = int(input())\\n\\n\\nfor _ in range(t):\\n    n = int(input())\\n\\n    a = list(map(int, input().split(' ')))\\n\\n    a = sorted(a)\\n\\n    print(a[len(a)//2] - a[len(a)//2-1])\", \"t = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    s = [int(x) for x in input().split()]\\n    s = sorted(s)\\n    print (abs(s[n]-s[n-1]))\", \"t=int(input())\\nwhile t:\\n    n=int(input())\\n    a=input().split()\\n    for i in range(2*n):\\n        a[i]=int(a[i])\\n    a.sort()\\n    print(a[n]-a[n-1])\\n    t-=1\", \"def solve(n, a_s):\\n    a_s.sort()\\n    return a_s[n] - a_s[n - 1]\\n\\n\\ndef __starting_point():\\n    t = int(input())\\n    for _ in range(t):\\n        n = int(input())\\n        a_s = [int(ch) for ch in input().split(' ')]\\n        print(solve(n, a_s))\\n\\n__starting_point()\", \"for _ in range(int(input())):\\n\\n\\n    n = int(input())\\n    \\n    l = [int(i) for i in input().split()]\\n    \\n    l.sort(reverse=True)\\n\\n    ind = 0\\n\\n    P = []\\n    S = []\\n    \\n    for i in l:\\n        if (ind % 2) == 0:\\n            P.append(i)\\n        else:\\n            S.append(i)\\n\\n        ind += 1\\n    \\n    \\n    if n % 2 == 0:\\n        a = abs(P[(n//2)-1] - S[n//2])\\n        b = abs(S[(n//2)-1] - P[n//2])\\n        print(min(a,b))\\n        \\n        \\n    else:\\n        print(abs(P[n//2] - S[n//2]))\\n\", \"for _ in range(int(input())):\\n\\tn=int(input())\\n\\tl=list(map(int,input().split()))\\n\\tl.sort()\\n\\tprint(l[n]-l[n-1])\\n\", \"import sys\\nt = int(input())\\nfor _ in range(t):\\n\\tn=int(input())\\n\\tl = list(map(int,sys.stdin.readline().split()))\\n\\tl.sort()\\n\\tprint(l[n]-l[n-1])\\n\"]", "input_output": "{\n  \"inputs\": [\n    \"3\\n1\\n1 1\\n3\\n6 5 4 1 2 3\\n5\\n13 4 20 13 2 5 8 3 17 16\\n\"\n  ],\n  \"outputs\": [\n    \"0\\n1\\n5\\n\"\n  ]\n}", "difficulty": "interview", "url": "https://codeforces.com/problemset/problem/1300/B", "starter_code": ""}
{"id": 122, "question": "There are several cards\u00a0arranged in a row, and each card has an associated number of points\u00a0The points are given in the integer array\u00a0cardPoints.\nIn one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards.\nYour score is the sum of the points of the cards you have taken.\nGiven the integer array cardPoints and the integer k, return the maximum score you can obtain.\n\u00a0\nExample 1:\nInput: cardPoints = [1,2,3,4,5,6,1], k = 3\nOutput: 12\nExplanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.\n\nExample 2:\nInput: cardPoints = [2,2,2], k = 2\nOutput: 4\nExplanation: Regardless of which two cards you take, your score will always be 4.\n\nExample 3:\nInput: cardPoints = [9,7,7,9,7,7,9], k = 7\nOutput: 55\nExplanation: You have to take all the cards. Your score is the sum of points of all cards.\n\nExample 4:\nInput: cardPoints = [1,1000,1], k = 1\nOutput: 1\nExplanation: You cannot take the card in the middle. Your best score is 1. \n\nExample 5:\nInput: cardPoints = [1,79,80,1,1,1,200,1], k = 3\nOutput: 202\n\n\u00a0\nConstraints:\n\n1 <= cardPoints.length <= 10^5\n1 <= cardPoints[i] <= 10^4\n1 <= k <= cardPoints.length", "solutions": "[\"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        max_score = 0\\n        curr_score= 0\\n        init_hand = cardPoints[len(cardPoints)-k:]\\n        max_score = sum(init_hand)\\n        curr_score = max_score\\n        for i in range(k):\\n            curr_score -= init_hand[i]\\n            curr_score += cardPoints[i]\\n            if curr_score > max_score:\\n                max_score = curr_score\\n        return max_score\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        n = len(cardPoints) - k\\n        min = 0\\n        window = 0\\n        all = 0\\n        for i in range(n):\\n            window += cardPoints[i]\\n            all += cardPoints[i]\\n        min = window\\n        # print(all)\\n\\n        for x in range(k):\\n            # print(x)\\n            all += cardPoints[x+n]\\n            window -= cardPoints[x]\\n            window += cardPoints[x+n]\\n            if window < min:\\n                min = window\\n        return all - min\\n        # print(all)\\n        # print(all-min)\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        result = curr = 0\\n        for i in range(-k, k):\\n            curr += cardPoints[i]\\n            if i >= 0:\\n                curr -= cardPoints[i - k]\\n            result = max(result, curr)\\n        return result\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        # dfs TLE\\n        # use sliding window instead\\n        # keep moving a window of size n - k along the way\\n        \\n        maxSum = sum(cardPoints)\\n        if len(cardPoints) <= k:\\n            return maxSum\\n        \\n        subSum = 0\\n        ans = 0\\n        for i in range(len(cardPoints)):\\n            subSum += cardPoints[i]\\n            \\n            if i + 1 >= (len(cardPoints) - k):\\n                ans = max(ans, maxSum - subSum)\\n                subSum -= cardPoints[i - (len(cardPoints) - k - 1)]\\n        \\n        return ans\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        answer = 0\\n        left = [0]*len(cardPoints)\\n        right = [0]*len(cardPoints)\\n        \\n        for i in range(len(cardPoints)) :\\n            if i == 0 : left[0] = cardPoints[0]\\n            else :\\n                left[i] = left[i-1] + cardPoints[i]\\n        \\n        for i in range(len(cardPoints)-1,-1,-1) :\\n            if i == len(cardPoints)-1 : right[-1] = cardPoints[-1]\\n            else :\\n                right[i] = right[i+1] + cardPoints[i]\\n        \\n        for i in range(k+1) :\\n            if i == 0 : Sum = right[-k]\\n            elif i == k : Sum = left[k-1]\\n            else : \\n                Sum = left[k-i-1] + right[-i]\\n            answer = max(answer,Sum)\\n        return answer                \", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        size = len(cardPoints) - k\\n        minSum = float('inf')\\n        cur = 0\\n        left = 0\\n        \\n        for i, v in enumerate(cardPoints):\\n            cur += v\\n            if i - left + 1 > size:\\n                cur -= cardPoints[left]\\n                left += 1\\n            if i - left + 1 == size:\\n                minSum = min(minSum, cur)\\n                \\n        return sum(cardPoints) - minSum\\n        \\n            \\n\", \"class Solution:\\n    def maxScore(self, points: List[int], num_cards: int) -> int:\\n        size = len(points) - num_cards\\n        min_subarray_sum = math.inf\\n        left = curr = 0\\n        for right, val in enumerate(points):\\n            curr += val\\n            if right - left + 1 > size:\\n                curr -= points[left]\\n                left += 1\\n            if right - left + 1 == size:\\n                min_subarray_sum = min(min_subarray_sum, curr)\\n        return sum(points) - min_subarray_sum\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        n = len(cardPoints) - k\\n        min = 0\\n        window = 0\\n        all = 0\\n        for i in range(n):\\n            window += cardPoints[i]\\n            all += cardPoints[i]\\n        min = window\\n        # print(all)\\n\\n        for x in range(k):\\n            # print(x)\\n            y = x+n\\n            all += cardPoints[y]\\n            window -= cardPoints[x]\\n            window += cardPoints[y]\\n            if window < min:\\n                min = window\\n        return all - min\\n        # print(all)\\n        # print(all-min)\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        # The Edge Case not needed here: if k > len(cardPoints) or k<=0: raise ValueErro('')\\n        left, right = [0], [0]\\n        for i in range(k):\\n            left.append(left[-1]+ cardPoints[i])\\n            right.append(right[-1] + cardPoints[len(cardPoints) -1 - i])\\n        \\n        res  = 0 \\n        for i in range(k+1):\\n            \\n            x = left[i] + right[k-i]\\n            res = max(res,x)\\n            \\n        return res\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        # The Edge Case not needed here: if k > len(cardPoints) or k<=0: raise ValueErro('')\\n        # Your solution is O(N) and this solution is O(k)\\n        # Eventhough the real time is similar, O(k) is better\\n        left = [0] * (k+1)\\n        right = [0] * (k+1)\\n        for i in range(k):\\n            left[i+1] = left[i] + cardPoints[i]\\n            right[i+1] = right[i] + cardPoints[-i-1]\\n        return max(left[j]+right[k-j] for j in range(k+1))\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:        \\n        left_cumsum = [0]\\n        right_cumsum = [0]\\n        for p in cardPoints[:k+1]:\\n            left_cumsum.append(left_cumsum[-1] + p)\\n        for p in reversed(cardPoints[-(k+1):]):\\n            right_cumsum.append(right_cumsum[-1] + p)\\n        \\n        result = 0\\n        for i in range(k+1):\\n            result = max(result, left_cumsum[i] + right_cumsum[k-i])\\n        return result\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        left, right = [0], [0]\\n        for i in range(len(cardPoints)):\\n            left.append(left[-1]+cardPoints[i])\\n            right.append(right[-1]+cardPoints[-i-1])\\n        return max(left[i]+right[k-i] for i in range(k+1))\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        \\n        n = len(cardPoints)\\n        \\n        # prefix sum solution\\n        pre = [0]*(n+1)\\n        for i in range(n):\\n            pre[i+1] = pre[i] + cardPoints[i]\\n            \\n        max_val = -1\\n        \\n        for i in range(k+1):\\n            max_val = max(max_val, pre[i] + pre[n] - pre[n-k+i])\\n            \\n        return max_val\\n        \\n#         if k >= n:\\n#             return sum(cardPoints)\\n        \\n#         def dfs(i,j):\\n#             if i + (n-j-1) >= k:\\n#                 return 0\\n            \\n#             else:\\n#                 return max(dfs(i+1,j)+cardPoints[i], dfs(i,j-1)+cardPoints[j])\\n            \\n#         return dfs(0,n-1)\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        n = len(cardPoints)\\n        total = sum(cardPoints)\\n        if n == k or n < k : return total \\n        remove = n - k\\n        ans = 0\\n        \\n        '''memo = [0]*(n+1)\\n        memo[0] = 0\\n        \\n        start = 0\\n        for i in range(0, n):\\n            memo[i+1] = memo[i] + cardPoints[i]            \\n            if i-start + 1 == remove: \\n                ans = max(ans, total-(memo[i+1]-memo[start]))\\n                start = start+1'''\\n        curr = 0\\n        start = 0\\n        for right in range(n):\\n            curr += cardPoints[right]\\n            if right-start+1 == remove:\\n                ans = max(ans, total-curr)\\n                curr -= cardPoints[start]\\n                start +=1\\n            \\n            \\n        return ans\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        left, right = [0], [0]\\n        for i in range(k):\\n            left.append(left[-1]+ cardPoints[i])\\n            right.append(right[-1] + cardPoints[len(cardPoints) -1 - i])\\n        \\n        res  = 0 \\n        for i in range(k+1):\\n            \\n            x = left[i] + right[k-i]\\n            res = max(res,x)\\n            \\n        return res\\n            \\n\\n#         front_sum=back_sum=[0]\\n#                 print 'cardPoints:', cardPoints\\n#         print 'k:', k\\n#         frontSum, backSum = [0], [0]\\n#         for n in cardPoints:\\n#             frontSum.append(frontSum[-1]+n)\\n#             print 'frontSum:', frontSum\\n#         for n in cardPoints[::-1]:\\n#             backSum.append(backSum[-1]+n)\\n#             print 'backSum:', backSum\\n#         allCombinations = [frontSum[i]+backSum[k-i] for i in range(k+1)]\\n#         print 'allCombinations:', allCombinations\\n#         return max(allCombinations)\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        min_len = len(cardPoints) - k\\n        curr_sum = 0\\n        min_val = 0\\n        for start in range(len(cardPoints) - min_len + 1):\\n            if start == 0:\\n                curr_sum = sum(cardPoints[start:start+min_len])\\n                min_val = curr_sum\\n            else:\\n                curr_sum = curr_sum - cardPoints[start - 1] + cardPoints[start+min_len-1] \\n                if min_val > curr_sum:\\n                    min_val = curr_sum\\n        \\n        return sum(cardPoints) - min_val\\n            \\n\\n#         front_sum=back_sum=[0]\\n#                 print 'cardPoints:', cardPoints\\n#         print 'k:', k\\n#         frontSum, backSum = [0], [0]\\n#         for n in cardPoints:\\n#             frontSum.append(frontSum[-1]+n)\\n#             print 'frontSum:', frontSum\\n#         for n in cardPoints[::-1]:\\n#             backSum.append(backSum[-1]+n)\\n#             print 'backSum:', backSum\\n#         allCombinations = [frontSum[i]+backSum[k-i] for i in range(k+1)]\\n#         print 'allCombinations:', allCombinations\\n#         return max(allCombinations)\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        n = len(cardPoints) - k\\n        min = 0\\n        window = 0\\n        all = 0\\n        for i in range(n):\\n            window += cardPoints[i]\\n            all += cardPoints[i]\\n        min = window\\n        print(all)\\n\\n        for x in range(k):\\n            print(x)\\n            all += cardPoints[x+n]\\n            window -= cardPoints[x]\\n            window += cardPoints[x+n]\\n            if window < min:\\n                min = window\\n        return all - min\\n        # print(all)\\n        # print(all-min)\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        n = len(cardPoints)\\n        sums = [0] * (n+1)\\n        for i in range(1, n+1):\\n            sums[i] = sums[i-1] + cardPoints[i-1]\\n            \\n        ans = float('inf')\\n        for i in range(k+1):\\n            ans = min(ans, sums[i+n-k] - sums[i])\\n        \\n        print((sums, ans))\\n        return sums[-1] - ans\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        s = sum(cardPoints)\\n        if k >= len(cardPoints):\\n            return s\\n        maxPoint = 0\\n        cur = 0\\n        j = 0\\n        # i-j+k == n\\n        n = len(cardPoints)\\n        for i, point in enumerate(cardPoints):\\n            if i-j+k > n-1:\\n                cur -= cardPoints[j]\\n                j += 1\\n            cur += point\\n            if i-j+k == n-1:\\n                maxPoint = max(maxPoint, s-cur)\\n        return maxPoint\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        # find a subarray in the middle that its sum is min, maintain n-k length\\n        n = len(cardPoints)\\n        runningsum = 0\\n        start = end = 0\\n        total = sum(cardPoints)\\n        minsum = float('inf')\\n        while end < len(cardPoints):\\n          runningsum += cardPoints[end]\\n          if end - start + 1 > n-k:\\n            runningsum -= cardPoints[start]\\n            start += 1\\n          if end - start + 1 == n-k:\\n            minsum = min(minsum, runningsum)\\n          end += 1\\n        return total-minsum\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        \\n#         cardLen = len(cardPoints)\\n#         if cardLen == k:\\n#             return sum(cardPoints)\\n        \\n#         dp = {}\\n#         def takeCard(l0, r0, k0):\\n#             if k0 == 1:\\n#                 return max(cardPoints[l0], cardPoints[r0])\\n#             if (l0, r0, k0) in dp:\\n#                 return dp[(l0, r0, k0)]\\n            \\n#             ans = max(cardPoints[l0] + takeCard(l0+1, r0, k0-1), cardPoints[r0] + takeCard(l0, r0-1, k0-1))\\n#             dp[(l0, r0, k0)] = ans\\n            \\n#             return ans\\n        \\n#         return takeCard(0, cardLen-1, k)\\n        cardLen = len(cardPoints)\\n        frontSum = [0]\\n        for num in cardPoints:\\n            frontSum.append(frontSum[-1]+ num)\\n        backSum = [0 for _ in range(cardLen + 1)]\\n        for i in range(cardLen - 1, -1, -1):\\n            backSum[i] = cardPoints[i] + backSum[i+1]\\n        ans = frontSum[k]\\n        for i in range(k):\\n            ans = max(ans, frontSum[i] + backSum[-(k-i)-1])\\n        return ans\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        left, right = [0], [0]\\n        for i in range(k):\\n            left.append(left[-1]+ cardPoints[i])\\n            right.append(right[-1] + cardPoints[len(cardPoints) -1 - i])\\n        print(left)\\n        print(right)\\n        res  = 0 \\n        for i in range(k+1):\\n            \\n            x = left[i] + right[k-i]\\n            res = max(res,x)\\n            \\n        return res\\n            \\n            \\n        \\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        forwardSum = [m for m in cardPoints]\\n        backwardSum = cardPoints.copy()\\n        backwardSum.append(0)\\n        for c in range(1, len(cardPoints)):\\n            forwardSum[c] = forwardSum[c-1] + forwardSum[c]\\n        \\n        for l in range(len(cardPoints)-2, 0, -1):\\n            backwardSum[l] = backwardSum[l+1] + backwardSum[l]\\n        maximum = 0\\n        for i in range(k-1, -2, -1):\\n            if i != -1:\\n                maximum = max(maximum, forwardSum[i] + backwardSum[len(backwardSum)-1-(k-1-i)])\\n            else:\\n                maximum = max(maximum, backwardSum[len(backwardSum)-1-k])\\n                              \\n        return maximum\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        n = len(cardPoints) - k\\n        min = 0\\n        window = 0\\n        all = 0\\n        for i in range(n):\\n            window += cardPoints[i]\\n        min = window\\n        all = window\\n        # print(all)\\n\\n        for x in range(k):\\n            # print(x)\\n            all += cardPoints[x+n]\\n            window -= cardPoints[x]\\n            window += cardPoints[x+n]\\n            if window < min:\\n                min = window\\n        return all - min\\n        # print(all)\\n        # print(all-min)\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        score = sum(cardPoints[:k])\\n        best = score\\n        \\n        for i in range(k):\\n            score += cardPoints[-(i+1)] - cardPoints[k-i-1]\\n            if score > best:\\n                best = score\\n            \\n        return best\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        leftsum = [0] * len(cardPoints)\\n        rightsum = [0] * len(cardPoints)\\n        n = len(cardPoints)\\n        leftsum[0] = cardPoints[0]\\n        rightsum[n-1] = cardPoints[n-1]\\n        for i in range(1,n):\\n            leftsum[i] = leftsum[i-1] + cardPoints[i]\\n            rightsum[n-1-i] = rightsum[n-1-i+1] + cardPoints[n-1-i]\\n            \\n        res = max(leftsum[k-1],rightsum[-(k-1+1)])\\n\\n        \\n        for i in range(k-1):\\n            \\n            res = max((leftsum[i] + rightsum[-(k-i-1)]), res)\\n            \\n        return res\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        '''\\n        convert this into a sliding window problem\\n        rephrase the problem:\\n            find the max window of length k between cardPoints[n-k:n+k]\\n        [1,2,3,4,5,6]\\n        k = 2\\n        4,5,0,1\\n        \\n            \\n        '''\\n        ans = 0\\n        curSum = 0\\n        n = len(cardPoints)\\n        for i in range(n-k, n+k):\\n            curSum += cardPoints[i%n]\\n            if i >= n:\\n                curSum -= cardPoints[(i-k)%n]\\n            ans = max(ans, curSum)\\n        return ans\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        if not cardPoints or len(cardPoints) == 0:\\n            return 0\\n        window = len(cardPoints) - k\\n        res = float('inf')\\n        s = 0\\n        for i in range(window):\\n            s += cardPoints[i]\\n        res = min(s, res)\\n        for i in range(window, len(cardPoints)):\\n            print(cardPoints[i],s,i)\\n            s -= cardPoints[i-window]\\n            s += cardPoints[i]\\n            res = min(s, res)\\n        return sum(cardPoints) - res\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        \\n        n = len(cardPoints)\\n        if n == k:\\n            return sum(cardPoints)\\n        \\n        pre, post = [0] * (n + 1), [0] * (n + 1)\\n        for i in range(1, n + 1):\\n            pre[i] = pre[i - 1] + cardPoints[i - 1]\\n        for i in range(1, n + 1):\\n            post[i] = post[i - 1] + cardPoints[n - i]\\n            \\n        best = 0\\n        \\n        # n = 7\\n        # k = 3\\n        # i = 0\\n        # x = 5\\n        # print (pre, post)\\n        for i in range(k + 1):\\n            best = max(best, pre[i] + post[k - i])\\n        \\n        return best\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        if k == len(cardPoints):\\n            return sum(cardPoints)\\n        front = [0] * k\\n        back = [0] * k\\n        front[0] = cardPoints[0]\\n        for i in range(1,k):\\n            front[i] = front[i-1] + cardPoints[i]\\n            \\n        back[0] = cardPoints[-1]\\n        for i in range(1,k):\\n            back[i] = back[i-1] + cardPoints[-1-i]\\n        \\n        max_score = 0\\n        print(front,back)\\n        for i in range(k+1):\\n            if i == 0:\\n                max_score = max(max_score,back[-1])\\n                # print(i,back[-1])\\n            elif i == k:\\n                max_score = max(max_score,front[k-1])\\n                # print(i,front[k-1])\\n            else:\\n                max_score = max(max_score,front[i-1]+back[k-i-1])\\n                # print(i,k-i,max_score,front[i-1]+back[k-i-1])\\n            # print(i,k-i,max_score)\\n        return max_score\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        length = len(cardPoints)\\n        total = sum(cardPoints)\\n        if k == length:\\n            return total\\n        curr = 0\\n        temp = 2 ** 31 - 1\\n        left = 0\\n        for right in range(length):\\n            curr += cardPoints[right]\\n            if right - left + 1 < length - k:\\n                continue\\n            print(right, curr)\\n            temp = min(temp, curr)\\n            curr -= cardPoints[left]\\n            left += 1\\n        \\n        return total - temp\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        n = len(cardPoints)\\n        \\n        cum_sum = [0 for i in range(n)]\\n        cum_sum[0] = cardPoints[0]\\n        rev_sum = [0 for i in range(n)]\\n        rev_sum[0] = cardPoints[-1]\\n        \\n        \\n        for i in range(1,n):\\n            cum_sum[i] = cum_sum[i-1]+cardPoints[i]\\n            rev_sum[i] = rev_sum[i-1]+cardPoints[n-i-1]\\n            \\n        max_sum = max(cum_sum[k-1],rev_sum[k-1])\\n        \\n        for i in range(1,k):\\n            max_sum = max(max_sum,(cum_sum[i-1]+rev_sum[k-i-1]))\\n            \\n        return max_sum\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        remainCnt = len(cardPoints) - k\\n        if remainCnt == 0: return sum(cardPoints)\\n        minRemainSum = float('inf')\\n        curr = 0\\n        cnt = 0\\n        for i in range(len(cardPoints)):\\n            cnt += 1\\n            curr += cardPoints[i]\\n            if cnt == remainCnt:\\n                minRemainSum = min(minRemainSum, curr)\\n                curr -= cardPoints[i + 1 - cnt]\\n                cnt -= 1\\n        \\n        return sum(cardPoints) - minRemainSum\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        # Sliding window of length k\\n        ans = total = sum(cardPoints[:k])\\n        for i in range(1, k+1):\\n            total -= cardPoints[k-i]\\n            total += cardPoints[-1-i+1]\\n            ans = max(ans, total)\\n        return ans\\n\", \"from collections import deque\\nclass Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        first = deque(cardPoints[0:k])\\n        second = deque(cardPoints[len(cardPoints)-k:])\\n        final = 0\\n        \\n        firstSum = sum(first)\\n        secondSum = sum(second)\\n        \\n        for i in range(k):\\n            if firstSum > secondSum:\\n                final += first[0]\\n                firstSum -= first.popleft()\\n                secondSum -= second.popleft()\\n                \\n            else:\\n                final += second[len(second)-1]\\n                firstSum -= first.pop()\\n                secondSum -= second.pop()\\n\\n        return final\", \"class Solution:\\n    def maxScore(self, cardPoints, k: int) -> int:\\n        N = len(cardPoints)\\n        preS, afterS = [0]*(N+1), [0]*(N+1)\\n        ans = 0\\n        for i in range(1,N+1):\\n            preS[i]=preS[i-1]+cardPoints[i-1]\\n        for j in range(1,N+1):\\n            afterS[j] = afterS[j-1]+cardPoints[N-j]\\n        for l in range(k+1):\\n            ans = max(ans,preS[l]+afterS[k-l])\\n        return ans\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        right_index = len(cardPoints)-k\\n        curr_max = sum(cardPoints[right_index:])\\n        curr_sum = curr_max\\n        for left_index in range(0, k):\\n            curr_sum -= cardPoints[right_index]\\n            right_index += 1\\n            curr_sum += cardPoints[left_index]\\n            if curr_sum > curr_max:\\n                curr_max = curr_sum\\n        return curr_max\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        \\n        n = len(cardPoints)\\n        \\n        cum_sum = [0 for i in range(n)]\\n        cum_sum[0] = cardPoints[0]\\n        rev_sum = [0 for i in range(n)]\\n        rev_sum[0] = cardPoints[-1]\\n        \\n        \\n        for i in range(1,n):\\n            cum_sum[i] = cum_sum[i-1]+cardPoints[i]\\n            rev_sum[i] = rev_sum[i-1]+cardPoints[n-i-1]\\n            \\n        max_sum = max(cum_sum[k-1],rev_sum[k-1])\\n        \\n        for i in range(1,k):\\n            max_sum = max(max_sum,(cum_sum[i-1]+rev_sum[k-i-1]))\\n        \\n        return max_sum\", \"class Solution:\\n    def maxScore(self, A: List[int], k: int) -> int:    \\n        su = sum(A[:k])\\n        n = len(A) \\n        res = su   \\n        for i in range(k):\\n            su -= A[k-i-1]\\n            su += A[n-i-1]\\n            res = max(res, su) \\n        return res\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        # sum of points from left most\\n        # sum of points from right most\\n        # sum of points from both left and right\\n        \\n        # defualt max_sum\\n        total = sum(cardPoints[:k])\\n            \\n        # if k == len(cardPoitns), result is the total sum of cardPoints\\n        if k == len(cardPoints):\\n            return total\\n        max_sum = total\\n        print(max_sum)\\n        \\n        # compute sum from left to right\\n        for i in range(k - 1, -1, -1):\\n            total = total + cardPoints[i - k] - cardPoints[i]\\n            print((i-k, total, cardPoints[i - k], cardPoints[i]))\\n            if total > max_sum:\\n                max_sum = total\\n        return max_sum\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        j = len(cardPoints) - 1\\n        ms = 0\\n        \\n        for i in range(k):\\n            ms += cardPoints[j]\\n            j -= 1\\n            \\n        cand = ms\\n        \\n        for i in range(k):\\n            cand += cardPoints[i] - cardPoints[j+1]\\n            j += 1\\n            ms = max(cand, ms)\\n            \\n        return ms\", \"class Solution:\\n    def maxScore(self, nums: List[int], k: int) -> int:\\n        \\n        n = len(nums)\\n\\n        if k == n:\\n            return sum(nums)\\n        \\n        pre =[0]\\n        post = []\\n        \\n        for e in nums:\\n            pre.append(pre[-1]+e)\\n            post.append(e)\\n        post.append(0)\\n        \\n        \\n        for i in range(n-1,-1,-1):\\n            post[i] = post[i+1] + nums[i]\\n            \\n        res = 0\\n        j = n - k\\n        \\n        while j <= n:\\n            res = max(res, pre[i] + post[j])\\n            \\n            i+=1\\n            j+=1\\n            \\n        return res\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        if len(cardPoints) < k:\\n            return -1\\n        \\n        remain = len(cardPoints) - k\\n        suum = sum(cardPoints[:remain])\\n        min_suum = suum\\n        for i in range(remain, len(cardPoints)):\\n            suum = suum - cardPoints[i-remain] + cardPoints[i]\\n            min_suum = min(min_suum, suum)\\n        return sum(cardPoints) - min_suum\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        n = len(cardPoints)\\n        sums = [0] * (n+1)\\n        for i in range(1, n+1):\\n            sums[i] = sums[i-1] + cardPoints[i-1]\\n            \\n        ans = float('inf')\\n        for i in range(k+1):\\n            ans = min(ans, sums[i+n-k] - sums[i])\\n        \\n        return sums[-1] - ans\\n\", \"class Solution:\\n    def maxScore(self, A: List[int], k: int) -> int:    \\n        su = sum(A[:k])\\n        res = su   \\n        for i in range(k):\\n            su -= A[k-i-1]\\n            su += A[len(A)-i-1]\\n            res = max(res, su) \\n        return res\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        n = len(cardPoints) - k\\n        l, r, res, count = 0, 0, sum(cardPoints[:n]), 0\\n        while r < len(cardPoints):\\n            count += cardPoints[r]\\n            if r >= n:\\n                count -= cardPoints[l]\\n                l += 1\\n                res = min(res, count)\\n            r += 1\\n        return sum(cardPoints) - res\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        pre = [cardPoints[0]]\\n        n = len(cardPoints)\\n        for i in range(1, n):\\n            pre.append(pre[-1] + cardPoints[i])\\n        \\n        if k == n:\\n            return pre[-1]\\n        \\n        s = pre[-1]\\n        cur_s = pre[n - k - 1]\\n        l = 0\\n        r = n - k + l - 1\\n        ans = s - pre[n - k - 1]\\n        \\n        while l != len(cardPoints) - (n - k) :\\n            cur_s -= cardPoints[l]\\n            l += 1\\n            r += 1\\n            cur_s += cardPoints[r]\\n            ans = max(ans, s - cur_s)\\n            \\n        return ans\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        n = len(cardPoints) - k\\n        current = 0\\n        for i in range(n):\\n            current += cardPoints[i]\\n        result = current\\n        \\n        for i in range(1, k+1):\\n            current -= cardPoints[i-1]\\n            current += cardPoints[i+n-1]\\n            result = min(result, current)\\n        \\n        return sum(cardPoints) - result\\n        \\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        f, b = [0], [0]\\n        for n in cardPoints:\\n            f.append(f[-1] + n)\\n        for n in cardPoints[::-1]:\\n            b.append(b[-1] + n)\\n        allCombo = [f[i] + b[k-i] for i in range(k+1)]\\n        return max(allCombo)\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        \\n        points_L = []\\n        points_R = []\\n        \\n        for p in cardPoints:\\n            if len(points_L): points_L.append(points_L[-1] + p)\\n            else: points_L.append(p)\\n        for p in cardPoints[::-1]:\\n            if len(points_R): points_R.append(points_R[-1] + p)\\n            else: points_R.append(p)\\n        points_R = points_R[::-1]\\n            \\n        return self.solution(points_L, points_R, k)\\n    \\n\\n    def solution(self, points_L, points_R, k):\\n        max = 0\\n        for i in range(k+1):\\n            cmp1 = points_L[i-1] if i > 0 else 0\\n            cmp2 = points_R[-(k-i)] if i < k else 0\\n            score = cmp1 + cmp2\\n            if score > max:\\n                max = score\\n        return max\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        left_sums = [0] * (k + 1)\\n        right_sums = [0] * (k + 1)\\n        \\n        \\n        for i in range(k):\\n            left_sums[i+1] = left_sums[i] + cardPoints[i]\\n            right_sums[i+1] = right_sums[i] + cardPoints[len(cardPoints)-i-1]\\n        \\n\\n        res = 0\\n        for i in range(k+1): # we must include K as a choice\\n            j = k-i\\n            res = max(res, left_sums[i] + right_sums[j])\\n        \\n        return res\\n\", \"from functools import lru_cache\\nimport sys\\nfrom itertools import accumulate\\n\\nsys.setrecursionlimit(10**5)\\n\\n\\nclass Solution:\\n    def maxScore(self, arr: List[int], k: int) -> int:\\n\\n        n = len(arr)\\n        pre = list(accumulate(arr))\\n        total = pre[-1]\\n        # print(f'{pre=}')\\n        \\n        if k == n:\\n            return total\\n        \\n        w = n-k\\n        result = 0 \\n        # print(f'{w=}')\\n        \\n        for i in range(w-1, n):\\n            # print(f'{i=}')\\n            sub_sum = total - (pre[i] - pre[i-w+1] + arr[i-w+1])\\n            result = max(result, sub_sum)\\n            \\n            \\n        return result\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        curr_max = sum(cardPoints[0:k])\\n        curr_sum = curr_max\\n        for i in range(1, k+1):\\n            curr_sum = curr_sum - cardPoints[k-i] + cardPoints[-i]\\n            curr_max = max(curr_max, curr_sum)\\n        return curr_max\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        size = len(cardPoints)\\n        maxRightSum = sum(cardPoints[size-k:])\\n        ans = maxRightSum\\n        currSum = maxRightSum\\n        # sum with left\\n        for i in range(k):\\n            currSum = currSum - cardPoints[size-k+i] + cardPoints[i]\\n            ans = max(ans, currSum)\\n        return ans\\n    # def maxScore(self, cardPoints: List[int], k: int) -> int:\\n    #     windowEnd = 0\\n    #     size = len(cardPoints) - k\\n    #     ans = float(\\\\\\\"inf\\\\\\\")\\n    #     currSum = 0\\n    #     for windowStart, point in enumerate(cardPoints):\\n    #         currSum += point\\n    #         if windowStart - windowEnd + 1 > size:\\n    #             currSum -= cardPoints[windowEnd]\\n    #             windowEnd += 1\\n    #         if windowStart - windowEnd + 1 == size:\\n    #             ans = min(ans, currSum)\\n    #     return sum(cardPoints) - ans\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        n = len(cardPoints)\\n        curr_max = sum(cardPoints[0:k])\\n        curr_sum = curr_max\\n        for i in range(1, k+1):\\n            curr_sum = curr_sum - cardPoints[k-i] + cardPoints[-i]\\n            curr_max = max(curr_max, curr_sum)\\n        return curr_max\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        totalPoints, window = sum(cardPoints), len(cardPoints) - k\\n        i, j, Sum, Min = 0, 0, 0, totalPoints\\n        \\n        while j < len(cardPoints):\\n            Sum += cardPoints[j]\\n            \\n            if j - i + 1 > window:\\n                Sum -= cardPoints[i]\\n                i += 1\\n            \\n            if j - i + 1 == window: Min = min(Min, Sum)\\n            j += 1\\n        \\n        # print(Min)\\n        return totalPoints - Min\\n        \\n        \\n        \\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        if len(cardPoints) < k:\\n            return 0\\n        if len(cardPoints) == k:\\n            return sum(cardPoints)\\n        n = len(cardPoints)\\n        res, cur = sum(cardPoints[:k]), sum(cardPoints[:k])\\n        for i in range(k):\\n            cur += cardPoints[n-i-1]-cardPoints[k-1-i]\\n            res = max(res, cur)\\n        return res\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        if not cardPoints or k==0:\\n            return 0\\n        for i in range(1,len(cardPoints)):\\n            cardPoints[i]+=cardPoints[i-1]\\n            \\n        if k==len(cardPoints):\\n            return cardPoints[-1]\\n        ans=cardPoints[k-1]\\n        \\n        for i in range(1,k+1):\\n            print(i)\\n            ans=max(ans,cardPoints[k-i]+cardPoints[-1]-cardPoints[-i])\\n            print(cardPoints[k-i],cardPoints[-1]-cardPoints[-i])\\n        return max(ans,cardPoints[-1]-cardPoints[-(k+1)])\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        n = len(cardPoints)\\n        left = n - k\\n        mini = sum(cardPoints[:left])\\n        cur = mini\\n        for i in range(left, n):\\n            cur = cur - cardPoints[i-left] + cardPoints[i]\\n            mini = min(mini, cur)\\n        \\n        return sum(cardPoints) - mini\", \"class Solution:\\n    def maxScore(self, card_points: List[int], k: int) -> int:\\n        window_size = len(card_points) - k\\n        current_min_sum, min_sum = 0, sys.maxsize\\n        total_points = 0\\n        left = 0\\n        for right, value in enumerate(card_points):\\n            total_points += value\\n            current_min_sum += value\\n\\n            current_size = right - left + 1\\n            if current_size < window_size:\\n                continue\\n\\n            if current_size > window_size:\\n                current_min_sum -= card_points[left]\\n                left += 1\\n\\n            min_sum = min(min_sum, current_min_sum)\\n\\n        return total_points - min_sum\\n\", \"def max_score_using_subsequence(card_points, k):\\n    l = len(card_points) - k\\n    if l == 0:\\n        return sum(card_points)\\n    \\n    sum_subsequence = 0\\n    for i in range(l):\\n        sum_subsequence += card_points[i]\\n    \\n    lowest = sum_subsequence\\n    for i in range(len(card_points) - l):\\n        sum_subsequence = sum_subsequence - card_points[i] + card_points[i+l]\\n        if sum_subsequence < lowest:\\n            lowest = sum_subsequence\\n    \\n    return sum(card_points) - lowest\\n    \\n\\nclass Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        # return max_score_recursive(cardPoints, k, 0, len(cardPoints)-1, {})\\n        return max_score_using_subsequence(cardPoints, k)\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        psum = sum(cardPoints[:k])\\n        res = psum\\n        n = len(cardPoints)\\n        for i in range(k):\\n            psum += cardPoints[n - i - 1] - cardPoints[k - i - 1]\\n            res = max(res, psum)\\n        return res\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        pre_sum = []   # i: sum of all items before i\\n        temp_left = 0\\n        for i, v in enumerate(cardPoints):\\n            pre_sum.append(temp_left)\\n            temp_left += v\\n        pre_sum.append(temp_left)\\n        \\n        post_sum = []  # i: sum of all items after i-1\\n        temp_right = 0\\n        temp_right = 0\\n        for i in range(len(cardPoints)-1, -1, -1):\\n            v = cardPoints[i]\\n            post_sum.append(temp_right)\\n            temp_right += v\\n        post_sum.append(v)\\n        post_sum.reverse()\\n        # print(pre_sum)\\n        # print(post_sum)\\n        return max([pre_sum[i] + post_sum[-(k-i)-1] for i in range(k+1)])\\n            \\n            \\n            \\n\\n\", \"from collections import deque\\nclass Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        n = len(cardPoints)\\n        cards = n-k\\n        minimum = 0\\n        if (cards != 0):\\n            sum1 = 0\\n            q = deque()\\n            for i in range(cards):\\n                q.append(cardPoints[i])\\n                sum1 += cardPoints[i]\\n            minimum = sum1\\n            for i in range(cards, n):\\n                first = q.popleft()\\n                q.append(cardPoints[i])\\n                sum1 -=first\\n                sum1 += cardPoints[i]\\n                if (sum1 < minimum):\\n                    minimum = sum1\\n        #else:\\n         #   minimum = 0\\n        print(minimum)\\n        return sum(cardPoints) - minimum\\n\", \"class Solution:\\n    def maxScore(self, l: List[int], k: int) -> int:\\n        length = len(l)\\n        \\n        if k == length:\\n            return sum(l)\\n        elif k == 0:\\n            return 0\\n        \\n        k = length - k\\n        v = curr_min = sum(l[:k])\\n        \\n        for i in range(k,length):\\n            v =  v - l[i-k] + l[i]\\n            curr_min = min(curr_min, v)\\n        \\n        return sum(l) - curr_min\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        if k == len(cardPoints):\\n            return sum(cardPoints)\\n        size = len(cardPoints) - k\\n        min_sum = float('inf')\\n        left = 0\\n        right = 0\\n        window_sum = 0\\n        while right < len(cardPoints):\\n            window_sum += cardPoints[right]\\n            right += 1\\n            while right - left == size:\\n                min_sum = min(min_sum, window_sum)\\n                window_sum -= cardPoints[left]\\n                left += 1\\n        return sum(cardPoints) - min_sum\\n\", \"class Solution:\\n    def maxScore(self, p: List[int], k: int) -> int:\\n        res = sum(p[:k])\\n        cur = res\\n        \\n        for i in range(1, k+1):\\n            cur += p[-i] - p[k-i]\\n            res = max(cur, res)\\n        \\n        return res\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        # Time: O(k)\\n        # Space: O(1)\\n        ans = win = 0\\n        for i in range(-k, k):\\n            win += cardPoints[i]\\n            if i >= 0:\\n                win -= cardPoints[i - k]\\n            #print(i, i-k, ans, win, cardPoints[i] )    \\n            ans = max(win, ans)    \\n        return ans\\n        \\n            \\n\", \"# O(n) time and O(1) space\\n# alternative dp solution O(k) space: form two k sized arrays: 1 to k and n-k to n\\n# https://www.youtube.com/watch?v=t3JHx5J01F0 9mins06s\\nclass Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        curr_max = sum(cardPoints[:k])\\n        ans = curr_max\\n        for i in range(1, k+1):\\n            curr_max += cardPoints[-i] - cardPoints[k-i]\\n            ans = max(ans, curr_max)\\n        return ans\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        n = len(cardPoints)\\n        w = n - k\\n        left, right = 0, w - 1\\n        ans = float('-inf')\\n        \\n        win_sum = sum(cardPoints[:w])\\n        total = sum(cardPoints)\\n        while right < n:\\n            sub = total - win_sum\\n            ans = max(sub, ans)\\n            if left < n:\\n                win_sum -= cardPoints[left]\\n            left += 1\\n            right += 1\\n            if right < n:\\n                win_sum += cardPoints[right]\\n\\n        return ans\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n#         \\u6211\\u5199\\u7684\\u8fd8\\u662f\\u592a\\u590d\\u6742\\u4e86\\n#         if not cardPoints or not k:\\n#             return 0\\n#         if k==len(cardPoints):\\n#             return sum(cardPoints)\\n        \\n#         front={0:0}\\n#         back={0:0}\\n#         total=0\\n#         for i in range(k):\\n#             total+=cardPoints[i]\\n#             front[i+1]=total\\n#         total=0\\n#         for i in range(-1,-k-1,-1):\\n#             total+=cardPoints[i]\\n#             back[-i]=total\\n            \\n#         maxres=float('-inf')\\n#         for i in range(k+1):\\n#             maxres=max(maxres,front[i]+back[k-i])\\n        \\n#         return maxres\\n        s = sum(cardPoints[:k])\\n        res = s\\n        for i in range(1, k+1):\\n            s += cardPoints[-i] - cardPoints[k-i]\\n            res = max(res, s)\\n        return res\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        left, right = [0], [0]\\n        for i in range(k):\\n            left.append(left[-1] + cardPoints[i])\\n            right.append(right[-1] + cardPoints[len(cardPoints) - 1 - i])\\n        # print(left, right)\\n        maxSoFar = 0\\n        for i in range(k + 1):\\n            if left[i] + right[k - i] > maxSoFar:\\n                maxSoFar = left[i] + right[k - i]\\n        return maxSoFar\\n        \\n\", \"class Solution:\\n    def maxScore(self, p: List[int], k: int) -> int:\\n        s = sum(p)\\n        if k == len(p): return s\\n        n = len(p)\\n        for i in range(1, len(p)): p[i] += p[i-1]\\n\\n        return s - min(p[n+i-k-1] - (p[i-1] if i else 0) for i in range(k+1))\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        score = 0\\n        l = k\\n        prefix = [0]\\n        for i in range(len(cardPoints)):\\n            prefix.append(prefix[-1] + cardPoints[i])\\n        for i in range(k+1):\\n            score = max(score, prefix[l] + prefix[-1] - prefix[-1-i])\\n            l -= 1\\n        return score\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        right_index = len(cardPoints)-k\\n        curr_max = sum(cardPoints[right_index:])\\n        curr_sum = curr_max\\n        for left_index, right_index in zip(list(range(0, k)), list(range(len(cardPoints)-k, len(cardPoints)))):\\n            print((left_index, right_index))\\n            curr_sum -= cardPoints[right_index]\\n            curr_sum += cardPoints[left_index]\\n            curr_max = max(curr_max, curr_sum)\\n        return curr_max\\n\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:  \\n        sub_len = len(cardPoints) - k\\n        localSum = 0\\n        localSum = sum(cardPoints[0: sub_len])\\n        localMin = localSum\\n        for i in range(sub_len, len(cardPoints)):\\n            localSum += cardPoints[i]\\n            localSum -= cardPoints[i - sub_len]\\n            localMin = min(localSum, localMin)\\n        return  sum(cardPoints) - localMin\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        points = cardPoints[-k:] + cardPoints[:k]\\n        curr = 0\\n        max_ = 0\\n        for ind, score in enumerate(points):\\n            if ind >= k:\\n                curr -= points[ind-k]\\n            curr += score\\n            max_ = max(max_, curr)\\n        return max_\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        \\n        total = sum(cardPoints)\\n        \\n        nk = len(cardPoints) - k\\n        \\n        if nk == 0:\\n            return total\\n        \\n        current = sum(cardPoints[0:nk])\\n        max_score = current\\n        \\n        for i in range(1, k + 1):\\n            current = current - cardPoints[i - 1] + cardPoints[nk + i - 1]\\n            \\n            max_score = min(max_score, current)\\n            \\n        return total - max_score\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        \\n        total = [0 for _ in range(len(cardPoints))]\\n        total[0] = cardPoints[0]\\n        \\n        for i in range(1, len(cardPoints)):\\n            total[i] = total[i-1] + cardPoints[i]\\n            \\n        max_sum = 0\\n        for i in range(k+1):\\n            left = total[k-i-1] if k-i > 0 else 0\\n            right = total[-1] - total[len(cardPoints)-i-1]\\n            if left + right > max_sum:\\n                max_sum = left + right\\n        \\n        return max_sum\", \"class Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        N = len(cardPoints)\\n        res = float('inf')\\n        run = 0\\n        for i, p in enumerate(cardPoints):\\n            if i >= N-k: run -= cardPoints[i-N+k]\\n            run += p\\n            if i >= N-k-1: res = min(res, run)\\n        return sum(cardPoints) - res\"]", "input_output": "{\"fn_name\": \"maxScore\", \"inputs\": [[[1, 2, 3, 4, 5, 6, 1], 3]], \"outputs\": [12]}", "difficulty": "interview", "url": "https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/", "starter_code": "\nclass Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        "}
{"id": 123, "question": "Your music player contains N\u00a0different songs and she wants to listen to L (not necessarily different) songs during your trip. \u00a0You\u00a0create\u00a0a playlist so\u00a0that:\n\nEvery song is played at least once\nA song can only be played again only if\u00a0K\u00a0other songs have been played\n\nReturn the number of possible playlists.\u00a0 As the answer can be very large, return it modulo 10^9 + 7.\n\u00a0\n\n\n\nExample 1:\nInput: N = 3, L = 3, K = 1\nOutput: 6\nExplanation: There are 6 possible playlists. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].\n\n\nExample 2:\nInput: N = 2, L = 3, K = 0\nOutput: 6\nExplanation: There are 6 possible playlists. [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]\n\n\nExample 3:\nInput: N = 2, L = 3, K = 1\nOutput: 2\nExplanation: There are 2 possible playlists. [1, 2, 1], [2, 1, 2]\n\n\n\n\u00a0\nNote:\n\n0 <= K < N <= L <= 100", "solutions": "[\"import math\\nclass Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        s=0\\n        c=0\\n        r=0\\n        x=math.factorial(N)\\n        while(True):\\n            c=x*((N-r-K)**(L-K))*(-1)**(r)//(math.factorial(N-r-K)*math.factorial(r))\\n            if(c!=0):\\n                s=(s+c)%(10**9+7)\\n                r+=1\\n            else:\\n                return s\\n\", \"import math\\nclass Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        s=0\\n        c=0\\n        r=0\\n        x=math.factorial(N)\\n        while(True):\\n            c=x*((N-r-K)**(L-K))*(-1)**(r)//(math.factorial(N-r-K)*math.factorial(r))\\n            if(c!=0):\\n                s=(s+c)%(10**9+7)\\n                r+=1\\n            else:\\n                return s\\n            \\n\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        MOD = 10 ** 9 + 7\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i < j: return 0\\n            if i == 0:\\n                return 1 if j == 0 else 0\\n            # if i == j:\\n            #     return math.factorial\\n            a = dp(i - 1, j - 1) * (N - j + 1)\\n            a += dp(i - 1, j) * (j - K if j > K else 0)\\n            return a % MOD\\n        return dp(L, N)\\n            \\n\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        mod = 10**9+7\\n        def memo(f):\\n            dic = {}\\n\\n            def f_alt(*args):\\n                if args not in dic:\\n                    dic[args] = f(*args)\\n                return dic[args]\\n            return f_alt\\n\\n        @memo\\n        def play(N, L):\\n            if L == 0:\\n                return 1 if N == 0 else 0\\n            if N > L:\\n                return 0\\n            return (N*play(N-1, L-1) + max(0, N-K)*play(N, L-1))%mod\\n\\n        return play(N, L)\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        dp = [[0] * (N + 1) for _ in range(L + 1)]\\n        dp[0][0] = 1\\n        for i in range(1, L + 1):\\n            for j in range(1, N + 1):\\n                dp[i][j] = dp[i - 1][j - 1] * (N - j + 1) #play new song\\n                if j > K: #play old song\\n                    dp[i][j] += dp[i - 1][j] * (j - K)\\n        return dp[-1][-1]%(10 ** 9 + 7)\\n                      \\n                \\n\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        mod = 10 ** 9 + 7\\n        dp = [[0] * (L + 1) for _ in range(N + 1)]\\n        \\n        for i in range(1, N + 1):\\n            for j in range(i, L + 1):\\n                if i == K + 1:# or i == j:\\n                    dp[i][j] = math.factorial(i)\\n                else:\\n                    dp[i][j] = dp[i - 1][j - 1] * i\\n                    if j > i:\\n                        dp[i][j] += dp[i][j - 1] * (i - K)\\n                dp[i][j] %= mod\\n        # print(dp)\\n        return dp[N][L]\\n\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        dp = [[0]*(N+1) for _ in range(L+1)]\\n        dp[0][0] = 1\\n        \\n        for i in range(1,L+1):\\n            for j in range(1,N+1):\\n                dp[i][j] = dp[i-1][j-1]*(N-j+1)%(10**9+7)\\n                if j > K:\\n                    dp[i][j] = (dp[i][j] + dp[i-1][j] * (j-K))%(10**9+7)\\n                    \\n        return dp[L][N]            \\n    \\n        #T=O(NL) S=O(NL) \\n        memo = {}\\n        def DFS(i,j):\\n            if i == 0:\\n                return j==0\\n            if (i,j) in memo:\\n                return memo[(i,j)]\\n            ans = DFS(i-1, j-1)*(N-j+1)\\n            ans += DFS(i-1, j)* max(j-K,0)\\n            memo[(i,j)] = ans%(10**9+7)\\n            return memo[(i,j)]\\n        \\n        return DFS(L,N)\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        mod = 10 ** 9 + 7\\n        dp = [[0] * (L + 1) for _ in range(N + 1)]\\n        \\n        for i in range(1, N + 1):\\n            for j in range(i, L + 1):\\n                if i == K + 1 or i == j:\\n                    dp[i][j] = math.factorial(i)\\n                else:\\n                    dp[i][j] = dp[i - 1][j - 1] * i\\n                    if j > i:\\n                        dp[i][j] += dp[i][j - 1] * (i - K)\\n                dp[i][j] %= mod\\n        # print(dp)\\n        return dp[N][L]\\n\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        dp = [[0 for _ in range(N+1)] for _ in range(L+1)]\\n        dp[0][0] = 1\\n        mod = 10**9 + 7\\n        for i in range(1, L+1):\\n            for j in range(1, N+1):\\n                dp[i][j] = dp[i-1][j-1] * (N-j+1)\\n                if j > K:\\n                    dp[i][j] += dp[i-1][j]*(j-K)\\n                dp[i][j] %= mod\\n                    \\n        return dp[L][N]\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        dp = [1] * (L-N+1)\\n        for p in range(2, N-K+1):\\n            for i in range(1, L-N+1):\\n                dp[i] += dp[i-1] * p\\n                \\n        ans = dp[-1]\\n        for k in range(2, N+1):\\n            ans *= k\\n            \\n        return ans % (10 ** 9 + 7)\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        # 11:35\\n        # pick k+1 songs out of N Songs\\n        # k+1 factorial\\n        # you can pick a new song or old song from this k+1 => basically you got N options now\\n        \\n        mod=10**9+7\\n        @lru_cache(None)\\n        def helper(i,notplayed):\\n            nonlocal mod\\n            if i==L+1:\\n                return 0 if notplayed!=0 else 1   \\n            ans=(max((N-notplayed)-K,0)*helper(i+1,notplayed))%mod\\n            if notplayed!=0:\\n                ans+=(notplayed)*helper(i+1,notplayed-1)\\n            return ans%mod\\n        return helper(1,N)\\n    \\n    \\n    \\n            \\n        \\n                \\n                \\n           \\n            \\n        \\n        \\n        \\n        \\n        \\n\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        BIG = 10**9+7\\n        \\n        @lru_cache(None)\\n        def dp(r,n):\\n            if r == 0: return 1 if n == 0 else 0\\n            return ( dp(r-1,n-1) * (N-(n-1)) + dp(r-1,n) * max(0, n-K) ) % BIG\\n        \\n        \\n        return dp(L, N)\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        @lru_cache(None)\\n        def unique(length, uni):\\n            if uni == 0:\\n                return 0\\n            if length == 1:\\n                if uni == 1:\\n                    return N\\n                else:\\n                    return 0\\n            \\n            ret = unique(length - 1, uni - 1) * (N - uni + 1)\\n            ret += unique(length -1, uni) * max(0, uni - K)\\n            \\n            return ret % (10**9+7)\\n        \\n        return unique(L, N)\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        m = 10 ** 9 + 7\\n        dp = [[0 for _ in range(N+1)] for _ in range(L+1)]\\n        dp[0][0] = 1\\n        for i in range(1,L+1):\\n            for j in range(1,N+1):\\n                dp[i][j] = (dp[i-1][j-1] * (N-j+1) + dp[i-1][j] * max(j-K,0))%m\\n        \\n        return int(dp[L][N])\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        mod = 10 ** 9 + 7\\n        \\n        @lru_cache(None)\\n        def dp(l, n):\\n            if not l:\\n                return not n\\n            return dp(l - 1, n - 1) * (N - n + 1) + dp(l - 1, n) * max(n - K, 0)\\n        \\n        return dp(L, N) % mod\", \"from functools import lru_cache\\n\\nclass Solution:\\n    def numMusicPlaylists(self, N, L, K):\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == 0:\\n                return +(j == 0)\\n            ans = dp(i-1, j-1) * (N-j+1)\\n            ans += dp(i-1, j) * max(j-K, 0)\\n            return ans % (10**9+7)\\n\\n        return dp(L, N)\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        dp = [[0 for i in range(L+1)] for j in range(N+1)]\\n        for i in range(1, len(dp)):\\n            for j in range(1, len(dp[0])):\\n                if i == j:\\n                    dp[i][j] = math.factorial(i)\\n                else:\\n                    dp[i][j] = dp[i-1][j-1]*i + dp[i][j-1]*max((i-K), 0)\\n        print(dp)\\n        return dp[N][L]%(10**9+7)\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        dp = [0 for _ in range(L + 1)]\\n        dp[0] = 1\\n        for i in range(1, N + 1):\\n            dp2 = [0 for _ in range (L + 1)]\\n            for j in range(1, L + 1):\\n                dp2[j] = dp[j - 1] * (N - i + 1) \\n                dp2[j] += dp2[j - 1] * max(i - K, 0)\\n            dp = dp2\\n            \\n        return dp[L] % (10**9 + 7)\", \"import math\\nclass Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        mod = 10**9+7\\n        dp = [[0 for _ in range(L+1)] for _ in range(N+1)]\\n        dp[0][0]=1\\n        for i in range(1,N+1):\\n            for j in range(1,L+1):\\n                    dp[i][j] = dp[i-1][j-1]*(N-i+1)%mod\\n                    dp[i][j] += dp[i][j-1]*max(i-K,0)%mod\\n        return dp[-1][-1]%mod\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        memo = {}\\n        def dp(i, j):\\n            if i == 0:\\n                return j == 0\\n            if (i, j) in memo: return memo[i, j]\\n            memo[i, j] = dp(i - 1, j - 1) * (N - j + 1) + dp(i - 1, j) * max(j - K, 0)\\n            return memo[i, j]\\n        \\n        return dp(L, N)%(10**9 + 7)\\n                      \\n                \\n\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        # N = 10   L = 25    K = 4\\n        # 1~10         24        3\\n        # 2~9          23        2\\n        #  Unique : L - N + 1       Extra : N-K+1\\n        \\n        dp = [1] * (L-N+1)\\n        \\n        for p in range(2,N-K+1):\\n            for i in range(1,L-N+1):\\n                dp[i] += p*dp[i-1]\\n        \\n        ans = dp[-1]\\n        for k in range(2,N+1):\\n            ans = ans * k\\n        return ans% (10**9 + 7)\\n        \\n        \\n        \\n        \\n        \\n      \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        dp = [1] * (L-N+1)\\n        print(dp)\\n        for p in range(2, N-K+1):\\n            for i in range(1, L-N+1):\\n                \\n                dp[i] += dp[i-1] * p\\n                print((p,i, dp))\\n        # Multiply by N!\\n        ans = dp[-1]\\n        for k in range(2, N+1):\\n            ans *= k\\n        return ans % (10**9 + 7)\\n            \\n\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        cache = {}\\n        def dp(i, j):\\n            if i == 0:\\n                return +(j == 0)\\n            if (i,j) in cache:\\n                return cache[(i,j)]\\n            ans = dp(i-1, j-1) * (N-j+1)\\n            ans += dp(i-1, j) * max(j-K, 0)\\n            ans %= (10**9+7)\\n            cache[(i,j)] = ans\\n            return ans\\n\\n        return dp(L, N)\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        \\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == 0:\\n                return j == 0\\n            \\n            return (dp(i-1, j) * max(0, j - K) + dp(i-1, j-1) * (N - j + 1)) % (10**9 + 7)\\n        \\n        return dp(L, N)\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        \\n        dp = [[0 for n in range(N+1) ] for l in range(L+1)]\\n        dp[0][0] = 1\\n        for l in range(1, L+1):\\n            for n in range(1, N+1):\\n                dp[l][n] += dp[l-1][n-1] * (N-n+1)\\n                dp[l][n] += dp[l-1][n] * max(n-K, 0)\\n                dp [l][n] = dp [l][n] %  (10 **9+7)\\n        return dp[L][N]\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        dp = [[0] * (N + 1) for _ in range(L + 1)]\\n        dp[0][0] = 1;\\n        for l in range(1, L + 1):\\n            for n in range(1, N + 1):\\n                dp[l][n] += dp[l - 1][n - 1] * (N - n + 1)\\n                dp[l][n] += dp[l - 1][n] * max(n - K, 0)\\n                dp[l][n] = dp[l][n] % (1000000007)\\n        return dp[L][N]\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        mod = 10**9 + 7\\n        memo = {}\\n        # helper(i,j) returns the number of playlists of len i\\n        # that have exactly j unique songs\\n        def helper(i, j):\\n            nonlocal N, K\\n            if i==0:\\n                if j==0:\\n                    # base case\\n                    # helper(0,0) returns 1\\n                    return 1\\n                else:\\n                    return 0\\n            if (i,j) in memo:\\n                return memo[(i,j)]\\n            ans = 0\\n            # the jth song is unique,\\n            # then the jth song has (N-(j-1)) possibilities\\n            ans += helper(i-1, j-1)*(N-(j-1))\\n            # the jth song is not unique\\n            # it is the same as one of the previous songs\\n            # then the jth song has max(0, j-K) possibilities\\n            # since it can be the same as the previous K songs\\n            ans += helper(i-1, j)*max(0, j-K)\\n            memo[(i,j)]=ans%mod\\n            return ans%mod\\n        return helper(L, N)\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        memo = {}\\n        def dp(i, j):\\n            if i == 0: return 1 if j == 0 else 0\\n            if (i, j) in memo: return memo[(i, j)]\\n            # non repeat\\n            ans = dp(i - 1, j - 1) * (N - (j - 1))\\n            # repeat\\n            ans += dp(i - 1, j) * max(0, j - K)\\n            memo[(i, j)] = ans % (10 ** 9 + 7)\\n            return memo[(i, j)]\\n        return dp(L, N)\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        memo = {}\\n        def dp(i, j):\\n            if i == 0: return 1 if j == 0 else 0\\n            if (i, j) in memo: return memo[(i, j)]\\n            # non repeat\\n            ans = dp(i - 1, j - 1) * (N - (j - 1))\\n            # repeat\\n            ans += dp(i - 1, j) * max(0, j - K)\\n            memo[(i, j)] = ans % (10 ** 9 + 7)\\n            return memo[(i, j)]\\n        return dp(L, N)\\n# from functools import lru_cache\\n\\n# class Solution:\\n#     def numMusicPlaylists(self, N, L, K):\\n#         @lru_cache(None)\\n#         def dp(i, j):\\n#             if i == 0:\\n#                 return +(j == 0)\\n#             ans = dp(i-1, j-1) * (N-j+1)\\n#             ans += dp(i-1, j) * max(j-K, 0)\\n#             return ans % (10**9+7)\\n\\n#         return dp(L, N)\\n\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == 0:\\n                return +(j == 0)\\n            ans = dp(i-1, j-1) * (N-j+1)\\n            ans += dp(i-1, j) * max(j-K, 0)\\n            return ans % (10**9+7)\\n\\n        return dp(L, N)\", \"from functools import lru_cache\\nclass Solution:\\n    def numMusicPlaylists(self, N, L, K):\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == 0:\\n                return +(j == 0)\\n            ans = dp(i-1, j-1) * (N-j+1)\\n            ans += dp(i-1, j) * (j-min(K, i-1))\\n            return ans % (10**9+7)\\n\\n        return dp(L, N)\\n            \\n            \\n\", \"from functools import lru_cache\\n\\nclass Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        # Dynamic Programming\\n        # Let dp[i][j] be the number of playlists of length i that have exactly j unique songs.\\n        # Time  complexity: O(NL)\\n        # Space complexity: O(NL)\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == 0:\\n                return +(j == 0)\\n            ans = dp(i - 1, j - 1) * (N - j + 1)\\n            ans += dp(i - 1, j) * max(j - K, 0)\\n            return ans % (10**9 + 7)\\n\\n        return dp(L, N)\\n\\n\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        dp = [[0 for j in range(L+1)] for i in range(N+1)]\\n        for i in range(K+1, N+1):\\n            for j in range(i, L+1):\\n                if i == j or i == K+1:\\n                    dp[i][j] = math.factorial(i)\\n                else:\\n                    dp[i][j] = dp[i-1][j-1]*i + dp[i][j-1]*(i-K)\\n        return dp[N][L]%(10**9+7)\\n\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        '''\\n         construct a 2d dp[i][j] where i is i different songs and\\n         j is the length of the playlist, also track the remaining songs r:\\n         for dp update, we have two options:\\n         if i <= k:\\n            1. add a new song to the list, r -= 1\\n         else:\\n            if r > L-j\\n                1. add a new song to the list, r -= 1\\n                2. add an existing song\\n            else:\\n                1. add a new song\\n         ''' \\n        @lru_cache(None)\\n        def dp(unique, total, r):\\n            if total == L:\\n                return 1\\n            if unique <= K:\\n                return r * dp(unique+1, total+1, r-1)\\n            else:\\n                ans = 0\\n                if r < L-total:\\n                    # add an existing song\\n                    ans += (unique-K) * dp(unique, total+1, r)\\n                # add a new song\\n                ans += r * dp(unique+1, total+1, r-1)\\n                return ans\\n\\n        return dp(0, 0, N) % (10**9+7)\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        dp = [[0 for i in range(L + 1)] for j in range(N + 1)]\\n        for i in range(K + 1, N + 1):\\n            for j in range(i, L + 1):\\n                if i == j or i == K + 1:\\n                    dp[i][j] = math.factorial(i)\\n                else:\\n                    dp[i][j] = dp[i - 1][j - 1] * i + dp[i][j - 1] * (i - K)\\n        return dp[N][L] % (10**9 + 7)\", \"class Solution:\\n    import math\\n    from functools import lru_cache\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        MOD = 1000000007\\n\\n        @lru_cache(maxsize=None)\\n        def rec(n, l):\\n            if l < n or n <= K:\\n                return 0\\n            elif l == n:\\n                return math.factorial(n) % MOD\\n            return (n * rec(n - 1, l - 1) + (n - K) * rec(n, l - 1)) % MOD\\n\\n        return rec(N, L)\", \"class Solution:\\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\\n        MOD = 10 ** 9 + 7\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i < j: return 0\\n            if i == 0:\\n                return 1 if j == 0 else 0\\n            if i == j:\\n                return (math.factorial(N) // math.factorial(N - j)) % MOD\\n            a = dp(i - 1, j - 1) * (N - j + 1)\\n            a += dp(i - 1, j) * (j - K if j > K else 0)\\n            return a % MOD\\n        return dp(L, N)\\n            \\n\"]", "input_output": "{\"fn_name\": \"numMusicPlaylists\", \"inputs\": [[3, 3, 1]], \"outputs\": [6]}", "difficulty": "interview", "url": "https://leetcode.com/problems/number-of-music-playlists/", "starter_code": "\nclass Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        "}
{"id": 124, "question": "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n\n(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).\n\nYou are given a target value to search. If found in the array return true, otherwise return false.\n\nExample 1:\n\n\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\n\n\nExample 2:\n\n\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\n\nFollow up:\n\n\n       This is a follow up problem to\u00a0Search in Rotated Sorted Array, where nums may contain duplicates.\n       Would this affect the run-time complexity? How and why?", "solutions": "[\"class Solution:\\n     def search(self, nums, target):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :type target: int\\n         :rtype: bool\\n         \\\"\\\"\\\"\\n         return target in nums\\n\", \"class Solution:\\n     def search(self, nums, target):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :type target: int\\n         :rtype: bool\\n         \\\"\\\"\\\"\\n         l,r = 0, len(nums) -1\\n         while l <= r:\\n             m = l+(r-l)//2\\n             if nums[m] == target: return True\\n             while nums[m] == nums[l] and l < m:\\n                 l += 1\\n             \\n             if nums[l] <= nums[m]:#[l,m] is sorted\\n                 if nums[l] <= target < nums[m]:\\n                     r = m - 1\\n                 else:\\n                     l = m+1\\n             else:\\n                 if nums[m] < target <= nums[r]:\\n                     l = m + 1\\n                 else:\\n                     r = m - 1\\n         return False\\n\", \"class Solution:\\n     def search(self, nums, target):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :type target: int\\n         :rtype: bool\\n         \\\"\\\"\\\"\\n         low = 0\\n         high = len(nums)-1\\n         while low<=high:\\n             mid = (low+high)//2\\n             if nums[mid]==target:\\n                 return True\\n             if nums[low]<nums[mid]:\\n                 if nums[low]<=target and nums[mid]>target:\\n                     high = mid-1\\n                 else:\\n                     low= mid+1\\n             elif nums[low]>nums[mid]:\\n                 if nums[mid]<target and nums[high]>=target:\\n                     low= mid+1\\n                 else:\\n                     high = mid -1\\n             else:\\n                 low+=1\\n         return False\\n\", \"class Solution:\\n     def search(self, nums, target):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :type target: int\\n         :rtype: bool\\n         \\\"\\\"\\\"\\n         left, right = 0, len(nums)-1\\n         while left <= right:\\n             mid = (left+right) // 2\\n             if nums[mid] == target:\\n                 return True\\n             elif nums[mid] > nums[left]:\\n                 if target >= nums[left] and target < nums[mid]:\\n                     right = mid\\n                 else:\\n                     left = mid + 1\\n             elif nums[mid] < nums[left]:\\n                 if target > nums[mid] and target <= nums[right]:\\n                     left = mid + 1\\n                 else:\\n                     right = mid\\n             else:\\n                 left = left + 1\\n                 \\n         return False\", \"class Solution:\\n     res = False\\n     \\n     def searchR(self, nums, target, start, end):\\n         if(start > end or self.res == True):\\n             return self.res\\n         else:\\n             mid = int((start + end) / 2)\\n             print(\\\"Mid index: %d, Mid val: %d, Target: %d\\\" % (mid, nums[mid], target))\\n             if(nums[mid] == target):\\n                 self.res = True\\n             elif(nums[start] <= nums[mid]):\\n                 if(nums[mid] == nums[end]):\\n                     self.searchR(nums, target, start, mid - 1)\\n                     self.searchR(nums, target, mid+1, end)\\n                 elif (target >= nums[start] and target <= nums[mid]):\\n                     self.searchR(nums, target, start, mid - 1)\\n                 else:\\n                     self.searchR(nums, target, mid+1, end)\\n             else:\\n                 print(\\\"Here\\\")\\n                 if (target >= nums[mid] and target <= nums[end]):\\n                     self.searchR(nums, target, mid + 1, end)\\n                 else:\\n                     self.searchR(nums, target, start, mid - 1)\\n             return self.res\\n     \\n     def search(self, nums, target):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :type target: int\\n         :rtype: bool\\n         \\\"\\\"\\\"\\n         res = self.searchR(nums, target, 0, (len(nums) - 1))\\n         return res\", \"class Solution:\\n     def search(self, nums, target):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :type target: int\\n         :rtype: bool\\n         \\\"\\\"\\\"\\n         \\n         return self.bsearch(nums, target, 0, len(nums)-1)\\n         \\n     \\n     def bsearch(self, nums, target, left, right):\\n         \\n         if left > right:\\n             return False\\n         \\n         mid = (left+right)//2\\n         if nums[mid] == target:\\n             return True\\n         \\n         #print(nums[left], nums[mid], nums[right])\\n         if nums[left] < nums[mid]: # left sorted\\n             \\n             if nums[left] <= target <= nums[mid]:\\n                 return self.bsearch(nums, target, left, mid-1)\\n             else:\\n                 return self.bsearch(nums, target, mid+1, right)\\n         \\n         elif nums[mid] < nums[right]: # right sorted\\n             \\n             if nums[mid] <= target <= nums[right]:\\n                 return self.bsearch(nums, target, mid+1, right)\\n             else:\\n                 return self.bsearch(nums, target, left, mid-1)\\n         \\n         elif nums[mid] == nums[left]:\\n             return self.bsearch(nums, target, left+1, right)\\n         \\n         elif nums[mid] == nums[right]:\\n             return self.bsearch(nums, target, left, right-1)\\n         \\n         \\n             \\n\", \"class Solution:\\n     def search(self, nums, target):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :type target: int\\n         :rtype: bool\\n         \\\"\\\"\\\"\\n         if not nums:\\n             return False\\n         left, right = 0, len(nums) - 1\\n         while nums[left] == nums[right] and left != right:\\n             right -= 1\\n         while left <= right:\\n             mid = (left + right) // 2\\n             if nums[mid] == target:\\n                 return True\\n             elif nums[mid] >= nums[left]:\\n                 if target >= nums[left] and target < nums[mid]:\\n                     right = mid - 1\\n                 else:\\n                     left = mid + 1\\n             else:\\n                 if target > nums[mid] and target <= nums[right]:\\n                     left = mid + 1\\n                 else:\\n                     right = mid - 1\\n         return False\", \"class Solution:\\n     def search(self, nums, target):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :type target: int\\n         :rtype: bool\\n         \\\"\\\"\\\"\\n         start, end = 0, len(nums)-1\\n         while start<=end:\\n             mid = start+(end-start)//2\\n             if nums[mid]==target:\\n                 return True\\n             while start<=end and nums[start]==nums[end]:\\n                 if nums[start]==target:\\n                     return True\\n                 start += 1\\n                 end -= 1\\n             if start>end:\\n                 return False\\n             if nums[start]<nums[end]:\\n                 #normal\\n                 if target<nums[mid]:\\n                     end = mid-1\\n                 else:\\n                     start = mid+1\\n             else:\\n                 if nums[mid]<nums[start]:\\n                     #peak between start and mid\\n                     if target<nums[mid] or target>=nums[start]:\\n                         end = mid-1\\n                     else:\\n                         start = mid+1\\n                 else:\\n                     #peak between mid and end\\n                     if target>nums[mid] or target<=nums[end]:\\n                         start = mid+1\\n                     else:\\n                         end = mid-1\\n         return False\\n\", \"class Solution:\\n     def search(self, nums, target):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :type target: int\\n         :rtype: bool\\n         \\\"\\\"\\\"\\n         if not nums:\\n             return False\\n         l, r = 0, len(nums)-1\\n         while l < r:\\n             mid = (l + r) // 2\\n             if nums[mid] == target:\\n                 return True\\n             if nums[mid] < nums[r]:\\n                 if nums[mid] < target <= nums[r]:\\n                     l = mid + 1\\n                 else:\\n                     r = mid - 1\\n             elif nums[mid] > nums[r]:\\n                 if nums[l] <= target < nums[mid]:\\n                     r = mid - 1\\n                 else:\\n                     l = mid + 1\\n             else:\\n                 r -= 1\\n         return nums[l] == target\", \"class Solution:\\n     def search(self, nums, target):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :type target: int\\n         :rtype: bool\\n         \\\"\\\"\\\"\\n         if not nums:\\n             return False\\n         l = 0\\n         r = len(nums) - 1\\n         print((\\\">\\\", l, r))\\n         while l < r and nums[l] == nums[r]:\\n             l = l + 1\\n         while l <= r:\\n             mid = int((l + r + 1) / 2)\\n             if target == nums[mid]:\\n                 return True\\n             if target < nums[mid]:\\n                 if target == nums[l]:\\n                     return True\\n                 elif target > nums[l]:\\n                     r = mid - 1\\n                 elif target < nums[l]:\\n                     if nums[l] <= nums[mid]:\\n                         l = mid + 1\\n                     elif nums[l] > nums[mid]:\\n                         r = mid - 1\\n             if target > nums[mid]:\\n                 if target == nums[r]:\\n                     return True\\n                 elif target > nums[r]:\\n                     if nums[mid] >= nums[l]:\\n                         l = mid + 1\\n                     elif nums[mid] < nums[l]:\\n                         r = mid - 1\\n                 elif target < nums[r]:\\n                     l = mid + 1\\n         return False\\n             \\n                     \\n\", \"class Solution:\\n     def recursive(self, nums, left, right , target):\\n         print((left, right))\\n         if left > right:\\n             return False\\n         if left == right:\\n             return nums[left] == target\\n         if left + 1 == right:\\n             return nums[left] == target or nums[right] == target\\n         mid = (left + right) // 2\\n         if nums[mid] == target:\\n             return True\\n         if nums[mid] == nums[left] and nums[mid] == nums[right]:\\n             return self.recursive(nums, mid, right, target) or self.recursive(nums, left, mid, target)\\n         else:\\n             if nums[mid] < target:\\n                 if nums[right] >= target or (nums[left] <= nums[mid] and nums[mid] >= nums[right]):\\n                     return self.recursive(nums, mid, right, target)\\n                 else:\\n                     return self.recursive(nums, left, mid, target)\\n             else:\\n                 if nums[left] <=target or (nums[right] >= nums[mid] and nums[mid] <= nums[left]):\\n                     return self.recursive(nums, left, mid, target)\\n                 else:\\n                     return self.recursive(nums, mid, right, target)\\n             \\n             \\n         \\n     def search(self, nums, target):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :type target: int\\n         :rtype: bool\\n         \\\"\\\"\\\"\\n         return self.recursive(nums, 0, len(nums) - 1, target)\\n\", \"class Solution:\\n     def search(self, nums, target):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :type target: int\\n         :rtype: bool\\n         \\\"\\\"\\\"\\n         if len(nums) == 0:\\n             return False\\n         def binary_search(leftIndex, rightIndex):\\n             midIndex = int((rightIndex+leftIndex)/2)\\n             if nums[midIndex] == target:\\n                 return True\\n             if leftIndex > rightIndex:\\n                 return False\\n             return binary_search(leftIndex, midIndex-1) or binary_search(midIndex+1, rightIndex)\\n         return binary_search(0, len(nums)-1)\\n\", \"class Solution:\\n     def search(self, nums, target):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :type target: int\\n         :rtype: bool\\n         \\\"\\\"\\\"\\n         l, r = 0, len(nums) - 1\\n         while l <= r:\\n             mid = l + (r - l)//2\\n             \\n             if nums[mid] == target:\\n                 return True\\n             \\n             while nums[mid] == nums[r]:\\n                 r -= 1\\n                 mid = l + (r - l)//2\\n                 if r < 0:\\n                     return False\\n             \\n             if nums[mid] == target:\\n                 return True\\n             \\n             if nums[mid] <= nums[r]:\\n                 if target > nums[mid] and target <= nums[r]:\\n                     l = mid + 1\\n                 else:\\n                     r = mid - 1\\n             else:\\n                 if target < nums[mid] and target >= nums[l]:\\n                     r = mid - 1\\n                 else:\\n                     l = mid + 1\\n \\n             \\n         return False\", \"class Solution:\\n     def search(self, nums, target):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :type target: int\\n         :rtype: bool\\n         \\\"\\\"\\\"\\n         if (not nums):\\n             return False\\n         i = 0\\n         while (i + 1 < len(nums) and nums[i] == nums[i + 1]):\\n             i += 1\\n         if (i + 1 == len(nums)):\\n             # nums\\u4e2d\\u6240\\u6709\\u5143\\u7d20\\u76f8\\u7b49\\n             return nums[0] == target\\n         \\n         # \\u627e\\u5230\\u6700\\u5927\\u5143\\u7d20\\u7684\\u4f4d\\u7f6e\\n         l, r = i, len(nums) - 1\\n         while (l + 1 < r):\\n             mid = l + (r - l) // 2\\n             if (nums[i] < nums[mid]):\\n                 l = mid\\n             else:\\n                 r = mid - 1\\n         highest_pos = l if (nums[l] > nums[r]) else r\\n         \\n         if (target >= nums[0]):\\n             return self._binarySearch(nums, 0, highest_pos, target)\\n         else:\\n             return self._binarySearch(nums, highest_pos + 1, len(nums) - 1, target)\\n         \\n         \\n     def _binarySearch(self, nums, l, r, target):\\n         while (l <= r):\\n             mid = l + (r - l) // 2\\n             if (nums[mid] < target):\\n                 l = mid + 1\\n             elif (nums[mid] > target):\\n                 r = mid - 1\\n             else:\\n                 return True\\n         return False\\n\", \"class Solution:\\n     def search(self, nums, target):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :type target: int\\n         :rtype: bool\\n         \\\"\\\"\\\"\\n         for i in nums:\\n             if i == target:\\n                 return True\\n             \\n         return False\"]", "input_output": "{\"fn_name\": \"search\", \"inputs\": [[[2, 5, 6, 0, 0, 1, 2], 0]], \"outputs\": [true]}", "difficulty": "interview", "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/", "starter_code": "\nclass Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        "}
{"id": 125, "question": "Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.\n\n\nExample1:\n\na = 2\nb = [3]\n\nResult: 8\n\n\n\nExample2:\n\na = 2\nb = [1,0]\n\nResult: 1024\n\n\n\nCredits:Special thanks to @Stomach_ache for adding this problem and creating all test cases.", "solutions": "[\"class Solution:\\n     def superPow(self, a, b):\\n         result = 1\\n         fermatb = (int(''.join(map(str, b)))) % 570\\n         while fermatb:\\n             if fermatb & 1:\\n                 result = (result * a) % 1337\\n             a = (a * a) % 1337\\n             fermatb >>= 1\\n         return result\", \"class Solution:\\n     def superPow(self, a, b):\\n         return pow(a, int(''.join(map(str, b))), 1337)\", \"class Solution:\\n     def superPow(self, a, b):\\n         \\\"\\\"\\\"\\n         :type a: int\\n         :type b: List[int]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         \\n         res = a**b[0]\\n         for i in range(1, len(b)):\\n             res = res**10 % 1337 * a**b[i] % 1337 % 1337\\n         return res\", \"class Solution:\\n     def superPow(self, a, b):\\n         \\\"\\\"\\\"\\n         :type a: int\\n         :type b: List[int]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         b.reverse()\\n         p = b.pop()\\n         res = pow(a,p) % 1337\\n         while b:\\n             p = b.pop()\\n             res = pow(res,10) % 1337\\n             res = res * pow(a,p) % 1337\\n         return res\\n\", \"class Solution:\\n     def superPow(self, a, b):\\n         \\\"\\\"\\\"\\n         :type a: int\\n         :type b: List[int]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         temp1 = a\\n         temp = 1\\n         for i in range(len(b)-1,-1,-1):\\n             if i<len(b)-1:\\n                 temp1 = pow(temp1,10) % 1337\\n             temp2 = pow(temp1,b[i]) % 1337\\n             temp = temp * temp2 % 1337\\n         return temp\\n\", \"class Solution:\\n     def superPow(self, a, b):\\n         \\\"\\\"\\\"\\n         :type a: int\\n         :type b: List[int]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         from functools import reduce\\n         return 0 if a % 1337 == 0 else pow(a, reduce(lambda x, y: (x * 10 + y) % 1140, b) + 1140, 1337)\", \"class Solution:\\n     def superPow(self, a, b):\\n         \\\"\\\"\\\"\\n         :type a: int\\n         :type b: List[int]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         def eular(mod):\\n             res, a = mod, mod\\n             i = 2\\n             while i * i <= a:\\n                 if a % i == 0:\\n                     res = res // i * (i - 1)\\n                     while a % i == 0:\\n                         a //= i\\n                 i += 1\\n             if a > 1:\\n                 res = res // a * (a - 1)\\n             return res\\n         def qpow(x, n, mod):\\n             res = 1\\n             while n > 0:\\n                 if n&1 != 0:\\n                     res = res * x % mod\\n                 x = x * x % mod\\n                 n >>= 1\\n             return res\\n         \\n         phi = eular(1337)\\n         n = 0\\n         for num in b:\\n             n = (n*10 % phi + num) % phi\\n         return qpow(a, n, 1337)\", \"class Solution:\\n     def superPow(self, a, b):\\n         \\\"\\\"\\\"\\n         :type a: int\\n         :type b: List[int]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         a, b = a % 1337, int(\\\"\\\".join([str(i) for i in b]))\\n         base, temp, extra = {1: a}, 1, {a: 1}\\n         for temp in range(2, 1338):\\n             rem = base[temp - 1] * a % 1337\\n             if rem in extra:\\n                 start = extra[rem]\\n                 length = temp - start\\n                 break\\n             else:\\n                 base[temp] = rem\\n                 extra[rem] = temp\\n         if b in base:\\n             return base[b]\\n         return base[start + (b - start) % length]\", \"class Solution:\\n     def superPow(self, a, b):\\n         \\\"\\\"\\\"\\n         :type a: int\\n         :type b: List[int]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         return pow(a, int(''.join(map(str, b))), 1337)\\n         # from functools import reduce\\n         # k=reduce(lambda x,y:x*10+y, b)\\n         # print(k)\\n         # return (a%1337)**k\\n\", \"class Solution:\\n     def superPow(self, a, b):\\n         \\\"\\\"\\\"\\n         :type a: int\\n         :type b: List[int]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         # return pow(a, int(''.join(map(str, b))), 1337)\\n         from functools import reduce\\n         k=reduce(lambda x,y:x*10+y, b)\\n         # print(k)\\n         # return pow(a,k)%1337\\n         return pow(a, k, 1337)\", \"class Solution:\\n     def superPow(self, a, b):\\n         num = 0\\n         currentpow = 1\\n         for item in b[::-1]:\\n             num += currentpow * item\\n             currentpow *= 10\\n         return self.binpow(a, num % 570)\\n \\n     def binpow(self, n, p):\\n         if(p == 0):\\n             return 1\\n         if(p % 2 == 0):\\n             return (self.binpow(n * n, p // 2)) % 1337\\n         return (n * self.binpow(n, p - 1)) % 1337\", \"class Solution:\\n     def superPow(self, a, b):\\n         \\\"\\\"\\\"\\n         :type a: int\\n         :type b: List[int]\\n         :rtype: int\\n         a %= 1337\\n         if len(b) == 1:\\n             return self.powMod(a, b[0])\\n         return self.powMod(self.superPow(a, b[:-1]), 10) * self.powMod(a, b[-1]) % 1337\\n         \\\"\\\"\\\"\\n         res = 1\\n         x = a % 1337\\n         for y in b[::-1]:\\n             res = (res * (x ** y)) % 1337\\n             x = (x ** 10) % 1337\\n         return res\\n\", \"class Solution:\\n     def superPow(self, a, b):\\n         result = 1\\n         fermatb = (int(''.join(map(str, b)))) % 570\\n         while fermatb:\\n             if fermatb & 1:\\n                 result = (result * a) % 1337\\n             a = (a * a) % 1337\\n             fermatb >>= 1\\n         return result\", \"class Solution:\\n     def superPow(self, a, b):\\n         result = 1\\n         x = a % 1337\\n         for y in b[::-1]:\\n             result = (result * (x**y)) % 1337\\n             x = (x**10) % 1337\\n         return result\"]", "input_output": "{\"fn_name\": \"superPow\", \"inputs\": [[2, [3]]], \"outputs\": [8]}", "difficulty": "interview", "url": "https://leetcode.com/problems/super-pow/", "starter_code": "\nclass Solution:\n    def superPow(self, a: int, b: List[int]) -> int:\n        "}
{"id": 126, "question": "Given a string s, return the maximum number of ocurrences of any substring\u00a0under the following rules:\n\nThe number of unique characters in the substring must be less than or equal to maxLetters.\nThe substring size must be between minSize and maxSize\u00a0inclusive.\n\n\u00a0\nExample 1:\nInput: s = \"aababcaab\", maxLetters = 2, minSize = 3, maxSize = 4\nOutput: 2\nExplanation: Substring \"aab\" has 2 ocurrences in the original string.\nIt satisfies the conditions, 2 unique letters and size 3 (between minSize and maxSize).\n\nExample 2:\nInput: s = \"aaaa\", maxLetters = 1, minSize = 3, maxSize = 3\nOutput: 2\nExplanation: Substring \"aaa\" occur 2 times in the string. It can overlap.\n\nExample 3:\nInput: s = \"aabcabcab\", maxLetters = 2, minSize = 2, maxSize = 3\nOutput: 3\n\nExample 4:\nInput: s = \"abcde\", maxLetters = 2, minSize = 3, maxSize = 3\nOutput: 0\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 10^5\n1 <= maxLetters <= 26\n1 <= minSize <= maxSize <= min(26, s.length)\ns only contains lowercase English letters.", "solutions": "[\"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        n = len(s)\\n        count = collections.Counter(s[i : i + minSize] for i in range(0, n - minSize +  1))\\n        res = 0 \\n        for k, v in count.items():\\n            if len(set(k)) <= maxLetters:\\n                res = max(res, v)\\n        return res\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        k = minSize\\n        count = collections.Counter(s[i:i + k] for i in range(len(s) - k + 1))\\n        return max([count[w] for w in count if len(set(w)) <= maxLetters] + [0])\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        k =minSize\\n        \\n        count = Counter(s[i:i + k] for i in range(len(s) - k + 1))\\n        print(count)\\n        ans=0\\n        for w in count:\\n            if len(set(w)) <= maxLetters:\\n                ans=max(count[w],ans)\\n        return ans        \\n        #return max([count[w] for w in count if len(set(w)) <= maxLetters] + [0])\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        word_dic = {}\\n        str_dic = {}\\n        r_end = 0\\n        ans = 0\\n        \\n        def update_ans(length):\\n            if length >= minSize:\\n                return min(length,maxSize) - minSize + 1\\n            return 0\\n        \\n        for i in range(len(s)):\\n            while (r_end<len(s)):\\n                ch = s[r_end]\\n                if ch in list(word_dic.keys()):\\n                    word_dic[ch] += 1\\n                else:\\n                    if len(list(word_dic.keys())) < maxLetters:\\n                        word_dic[ch] = 1\\n                    else:\\n                        break\\n                r_end += 1\\n            for j in range(minSize,min(maxSize,r_end-i) + 1):\\n                subs = s[i:i+j]\\n                if subs not in str_dic:\\n                    str_dic[subs] = 1\\n                else:\\n                    str_dic[subs] += 1\\n            word_dic[s[i]] -= 1\\n            if word_dic[s[i]] == 0:\\n                del word_dic[s[i]]\\n        if not bool(str_dic):\\n            return 0\\n        else:\\n            return max(str_dic.values())\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        seen = defaultdict(lambda : 0)\\n        m = defaultdict(lambda : 0)\\n        left = 0\\n        \\n        for i in range(len(s)):\\n            m[s[i]] += 1\\n            \\n            while(len(m) > maxLetters or i-left+1 > maxSize):\\n                m[s[left]] -= 1\\n                if m[s[left]] == 0:\\n                    m.pop(s[left])\\n                left += 1        \\n            \\n            \\n            temp = left\\n            while i-temp+1 >= minSize:\\n                seen[s[temp:i+1]] += 1\\n                temp += 1\\n                    \\n        if not seen:\\n            return 0\\n        return max(list(seen.values()))\", \"import collections\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        T = lambda: collections.defaultdict( T )\\n        trie , res = T( ) , 0\\n        data = [ [ trie , set( ) ] for _ in range( len( s ) - minSize + 1 ) ]\\n        for i in range( minSize ) :\\n            for j in range( len( s ) - minSize + 1 ) :\\n                c = s[i+j]\\n                cur = data[j]\\n                cur[1].add(c)\\n                if i == minSize - 1 and len( cur[ 1 ] ) <= maxLetters :\\n                    cur[0][c].setdefault( '#' , 0 )\\n                    cur[0][c]['#'] += 1\\n                    res = max( res , cur[ 0 ][ c ][ '#' ] )\\n                cur[ 0 ] = cur[0][c]\\n        return res\", \"from collections import defaultdict\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        letdict = defaultdict(int)\\n        subdict = defaultdict(int)\\n        uniquecount = 0\\n        start = end = 0\\n        n = len(s)\\n        \\n        while end < n:\\n            val = s[end]\\n            letdict[val] += 1\\n            if letdict[val] == 1:\\n                uniquecount += 1\\n            \\n            while uniquecount > maxLetters or ((end-start)+1) > maxSize:\\n                val = s[start]\\n                letdict[val] -= 1\\n                if letdict[val] == 0:\\n                    uniquecount -= 1\\n                start += 1\\n                \\n            tstart = start\\n            while ((end-tstart)+1) >= minSize:\\n                subdict[s[tstart:end+1]] += 1\\n                tstart += 1\\n\\n            end += 1\\n        if not subdict:\\n            return 0\\n        return subdict[max(subdict, key = lambda x: subdict[x])]\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        from collections import defaultdict\\n        cnt=defaultdict(int)\\n        for i in range(minSize-1,len(s)):\\n            low1=i-minSize+1\\n            low2=i-maxSize+1\\n            seen1=set()\\n            seen2=set()\\n            for k in range(low1,i+1):\\n                if s[k] not in seen1:\\n                    seen1.add(s[k])\\n            if low2>=0 and low1!=low2:\\n                for k in range(low2,i+1):\\n                    if s[k] not in seen2:\\n                        seen2.add(s[k])\\n                if len(seen2)<=maxLetters:\\n                    cnt[s[low2:i+1]]+=1\\n            if len(seen1)<=maxLetters:\\n                cnt[s[low1:i+1]]+=1\\n            \\n        if list(cnt.values()):\\n            return max(cnt.values())\\n        return 0\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        if len(s) < minSize:\\n            return 0\\n        \\n        occur = {}\\n        l,r=0, minSize\\n        \\n        while r <= len(s):\\n            sub = s[l:r]\\n            \\n            if occur.get(sub) is None:\\n                distinct = set(sub)\\n                if len(distinct) <= maxLetters:\\n                    occur[sub] = 1\\n            else:\\n                occur[sub]+=1\\n                \\n            l += 1\\n            r += 1\\n            \\n        return max(occur.values()) if len(occur) >0 else 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        from collections import defaultdict\\n        res = 0\\n        valid_str_freq = defaultdict(int)\\n        window_letter = {}\\n        left = 0\\n        right = 0\\n        for right in range(0, len(s), 1):\\n            # print(left, right)\\n            for i in range(left, right, 1):\\n                if right - i < minSize:\\n                    break\\n                valid_str = s[i:right]\\n                # print(i, right, valid_str)\\n                valid_str_freq[valid_str] += 1\\n                res = max(res, valid_str_freq[valid_str])\\n\\n            # add right\\n            if s[right] not in window_letter:\\n                window_letter[s[right]] = 1        \\n            else:\\n                window_letter[s[right]] += 1\\n            \\n            # check left\\n            while (len(window_letter) > maxLetters\\n                or right - left + 1 > maxSize\\n            ):\\n                window_letter[s[left]] -= 1\\n                if window_letter[s[left]] == 0:\\n                    del window_letter[s[left]]    \\n                left += 1\\n        right += 1\\n        for i in range(left, right, 1):\\n            if right - i < minSize:\\n                break\\n            valid_str = s[i:right]\\n            # print(i, right, valid_str)\\n            valid_str_freq[valid_str] += 1\\n            res = max(res, valid_str_freq[valid_str])\\n        return res\\n                        \\n                \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        res = collections.Counter()\\n        b=0\\n        cc = collections.Counter()\\n        \\n        for e in range(len(s)):\\n            cc[s[e]] += 1\\n            \\n            while len(cc)>maxLetters or e-b+1>maxSize:\\n                cc[s[b]] -= 1\\n                if cc[s[b]]==0: cc.pop(s[b])\\n                b += 1\\n            i=b\\n            while e-i+1>=minSize:\\n                res[s[i:e+1]] += 1\\n                i += 1\\n        # print(res)\\n        return res.most_common(1)[0][1] if res else 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        d = defaultdict(int)\\n        for i in range(len(s)-minSize+1):\\n            letters = set(s[i:i+minSize-1])\\n            for j in range(minSize, min(maxSize, len(s)-i)+1):\\n                letters.add(s[i+j-1])\\n                if len(letters) > maxLetters:\\n                    break\\n                d[s[i:i+j]] += 1\\n        return max(d.values()) if d else 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        freq = defaultdict(lambda: 0)\\n        m = ''\\n        n = len(s)\\n        for i in range(n - minSize + 1):\\n            end = i + minSize\\n            unique = set(s[i:end])\\n            while end <= n:\\n                unique.add(s[end - 1])\\n                if len(unique) > maxLetters:\\n                    break\\n                cur = s[i:end]\\n                freq[cur] += 1\\n                if freq[cur] > freq[m]:\\n                    m = cur\\n                end += 1\\n        return freq[m]\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        freq = defaultdict(lambda: 0)\\n        m = ''\\n        uniques = defaultdict(lambda: set())\\n        n = len(s)\\n        for i in range(n - minSize + 1):\\n            end = i + minSize\\n            unique = set(s[i:end])\\n            while end <= n:\\n                unique.add(s[end - 1])\\n                if len(unique) > maxLetters:\\n                    break\\n                cur = s[i:end]\\n                freq[cur] += 1\\n                if freq[cur] > freq[m]:\\n                    m = cur\\n                end += 1\\n        return freq[m]\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        seen = Counter()\\n        cnt = Counter()\\n        j = 0\\n        for i, ss in enumerate(s):\\n            cnt[ss] += 1\\n            while len(cnt) > maxLetters and j <= i:\\n                cnt[s[j]] -= 1\\n                if not cnt[s[j]]:\\n                    del cnt[s[j]]\\n                j += 1\\n            k = j\\n            while i - k + 1 >= minSize:\\n                if i - k + 1 <= maxSize:\\n                    seen[s[k: i + 1]] += 1\\n                k += 1\\n        return max(seen.values()) if seen else 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        ret = defaultdict(int)\\n        for i in range(len(s)):\\n            temp = ''\\n            char = set()\\n            for j in range(i, len(s)):\\n                temp = temp + s[j]\\n                char.add(s[j])\\n                if len(char) <= maxLetters and minSize <= len(temp) <= maxSize:\\n                    ret[temp] += 1\\n                elif len(char) > maxLetters or len(temp) > maxSize:\\n                    break\\n\\n        if len(ret) == 0:\\n            return 0\\n        return max(ret.values())\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        n=len(s)\\n        d=collections.defaultdict(int)\\n        for i in range(0,n-minSize+1):\\n            temp=s[i:i+minSize]\\n            c=set(temp)\\n            if len(c)<=maxLetters:\\n                d[temp]+=1\\n        return max(d.values()) if d else 0\\n\", \"from collections import defaultdict\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        \\n        mx_count = 0\\n        \\n        def create_dct(size, mx_count):\\n            dct = defaultdict(int)\\n        \\n            i = 0\\n            j = size - 1\\n\\n            while j < len(s):\\n\\n                temp = []\\n                temp_dict = defaultdict(int)\\n\\n                flag = True\\n                for x in range(i, j+1):\\n                    temp.append(s[x])\\n                    temp_dict[s[x]] += 1\\n                    if len(temp_dict) > maxLetters:\\n                        flag = False\\n                        break\\n\\n                i += 1\\n                j += 1\\n\\n                if not flag:\\n                    continue\\n                \\n                tmp_string = ''.join(temp)\\n                dct[tmp_string] += 1\\n                \\n                if dct[tmp_string] > mx_count:\\n                    mx_count = dct[tmp_string]\\n            \\n            return mx_count\\n                    \\n        mx_count = create_dct(minSize, mx_count)\\n        mx_count = max(create_dct(maxSize, mx_count), mx_count)\\n        \\n        return mx_count\\n        \\n        \\n        \\n            \\n            \\n            \\n            \\n            \\n            \\n                \\n                \\n        \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        c = Counter()\\n        i = 0\\n        letterlen = 0\\n        maxSize = maxSize+1 if maxSize==minSize else maxSize\\n        ans = Counter()\\n        for j, v in enumerate(s):\\n            c[v] += 1\\n            if c[v] == 1:\\n                letterlen += 1\\n            while letterlen > maxLetters:\\n                x = s[i]\\n                c[x] -= 1\\n                if c[x] == 0:\\n                    letterlen -= 1\\n                i += 1\\n            #print(i,j)\\n            for l in range(minSize,maxSize):\\n                beg = j-l +1\\n                #print(i,j,beg)\\n                if beg >= i:\\n                    ans[s[beg:j+1]] += 1\\n        #print(ans)\\n        return max(ans.values()) if ans else 0\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        count = 0\\n        n = len(s)\\n        count = Counter()\\n        \\n        for i in range(n - minSize + 1):\\n            \\n            r = i + minSize\\n            seen = {c for c in s[i:r]}\\n            unique = len(seen)\\n            while unique <= maxLetters and r <= n and r - i <= maxSize:\\n                if s[r - 1] not in seen:\\n                    unique += 1\\n                    seen.add(s[r-1])\\n                count[s[i:r]] += 1\\n                r += 1\\n                \\n        return max(count.values()) if count else 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        if minSize > len(s): return 0\\n        left= 0\\n        candidates = Counter()\\n        while left <= len(s) - minSize:\\n            right = left + minSize\\n            count = set(s[left:right])\\n            while right <= len(s) and right-left <= maxSize and len(count) <= maxLetters:\\n                if right < len(s):\\n                    count.add(s[right])\\n                candidates[s[left:right]] += 1\\n                right += 1                \\n            left += 1\\n        if not candidates:\\n            return 0\\n        return max(candidates.values())\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        feq = collections.Counter()\\n        \\n        N = len(s)\\n        for i in range(N):\\n            letters = set([c for c in s[i : i + minSize - 1]])\\n            for j in range(minSize, maxSize + 1):\\n                k = i + j\\n                if k > N:\\n                    break\\n                letters.add(s[k - 1])\\n                if len(letters) > maxLetters:\\n                    break\\n                feq[s[i:k]] += 1\\n        \\n        return max(feq.values()) if list(feq.values()) else 0\\n                \\n                \\n\\n                \\n                \\n                \\n\", \"class Solution:\\n    def maxFreq(self, s: str, mxl: int, mns: int, mxs: int) -> int:\\n        freq = collections.Counter()\\n        for i in range(mns, len(s)+1):\\n            for j in range(mxs-mns+1):\\n                if i + j > len(s):\\n                    break\\n                curr = s[i-mns:i+j]\\n                if len(set(curr)) > mxl:\\n                    break\\n                freq[curr] += 1\\n        return max(freq.values() or [0])\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        from collections import defaultdict\\n        letters = defaultdict(int)\\n        res = 0\\n        if len(s) < minSize:\\n            return 0\\n        i = 0\\n        j = 0\\n        unique = 0\\n        counter = defaultdict(int)\\n        while i < len(s):\\n            if letters[s[i]] == 0:\\n                unique += 1\\n            letters[s[i]] += 1\\n            \\n            while j < i and unique > maxLetters:\\n                letters[s[j]] -= 1\\n                if letters[s[j]] == 0:\\n                    unique -= 1\\n                j += 1\\n            j_tmp = j\\n            unique_tmp = unique\\n            letters_tmp = letters.copy()\\n            while unique_tmp <= maxLetters and (minSize <= (i - j_tmp + 1)):\\n                if (i - j_tmp + 1) > maxSize:\\n                    j_tmp+=1\\n                    continue\\n                counter[s[j_tmp:i+1]] += 1\\n                #print(f'{s[j_tmp:i+1]} {counter} {i} {j_tmp}')\\n                letters_tmp[s[j_tmp]] -= 1\\n                if letters_tmp[s[j_tmp]] == 0:\\n                    unique_tmp -= 1\\n                j_tmp += 1\\n                #print(f'i {i} j {j} unique {unique} {s[j:i+1]} letters {letters},res {res}, len {i-j+1}, {counter}')\\n            i += 1\\n        if len(counter.values()) == 0:\\n            return 0\\n        \\n        return max(counter.values())\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        start = 0\\n        end = minSize\\n        counts = {}\\n        res = 0\\n        \\n        while start <= len(s)-minSize:\\n            item = s[start:end]\\n            counts[item] = counts.get(item, 0) + 1\\n            \\n            start += 1\\n            end += 1\\n            \\n        for i in counts:\\n            if self.countUnique(i) <= maxLetters:\\n                res = max(res, counts[i])\\n                  \\n        return res\\n        \\n    def countUnique(self, s):\\n        return len(set(s))\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        ln_s    =   len(s);\\n        ans =   0;\\n        seen    =   Counter();\\n        \\n        for i in range( ln_s):\\n            \\n            set_buff    =   set(s[i:i+minSize]);\\n            for j in range(i+minSize-1, min(ln_s, i+maxSize)):\\n                \\n                buff    =   s[i:j+1];\\n                set_buff.add(   s[j]);\\n                \\n                if len(set_buff) > maxLetters:  break;\\n                \\n                seen[buff] += 1;\\n                \\n                ans =   max(    ans, seen[buff]);\\n        \\n        return ans;\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        subs = {}\\n        i = j = 0\\n        chars = {}\\n        while i < len(s):\\n            if  j < len(s) and (s[j] in chars or len(chars) < maxLetters):\\n                if s[j] not in chars:\\n                    chars[s[j]] = 0\\n                chars[s[j]] += 1\\n                j += 1\\n            else:\\n                for k in range(i+minSize, min(i+maxSize, j)+1):\\n                    sub = s[i:k]\\n                    if sub not in subs:\\n                        subs[sub] = 0\\n                    subs[sub] += 1\\n                    \\n                chars[s[i]] -= 1\\n                if chars[s[i]] == 0:\\n                    del chars[s[i]]\\n                i += 1\\n        return max(list(subs.values()) or [0])\\n\", \"class Solution:\\n    def maxFreq(self, s, maxLetters, minSize, maxSize):\\n        if minSize > len(s):\\n            return 0\\n            \\n        left = 0\\n        right = minSize - 1\\n        words = {}\\n        \\n        while left < len(s) - minSize + 1:\\n            word = s[left:right+1]\\n            while right < len(s) and right - left < maxSize and len(set(word)) <= maxLetters:\\n                if word not in words:\\n                    words[word] = 0\\n                words[word] += 1\\n\\n                right += 1\\n                if right < len(s):\\n                    word += s[right]\\n            \\n            left += 1\\n            right = left + minSize - 1\\n        \\n        maxOccurences = 0\\n        for word in words:\\n            maxOccurences = max(maxOccurences, words[word])\\n        \\n        return maxOccurences\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        d = dict()\\n        n = len(s)\\n        for i in range(n):\\n            j = i\\n            st = set()\\n            l = 0\\n            while j<min(n,i+maxSize) and l<=maxLetters:\\n                if s[j] not in st:\\n                    l+=1\\n                    st.add(s[j])\\n                x = s[i:j+1]\\n                ln = j-i+1\\n                #print(x,ln)\\n                if ln>=minSize and ln<=maxSize and l<=maxLetters:\\n                    if x in d:\\n                        d[x]+=1\\n                    else:\\n                        d[x]=1\\n                j+=1\\n        if d==dict():\\n            return 0\\n        return max(list(d.values()))\\n                \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        N = len(s)\\n        d1 = {}\\n        maxval = 0\\n        for i in range(N-minSize+1):\\n            d = {}\\n            for j in range(i,i+minSize):\\n                if(s[j] not in d):\\n                    d[s[j]] = 1\\n                else:\\n                    d[s[j]] += 1\\n            if(len(d)<=maxLetters):\\n                if(s[i:i+minSize] not in d1):\\n                    d1[s[i:i+minSize]] = 1\\n                else:\\n                    d1[s[i:i+minSize]] += 1\\n                maxval = max(maxval,d1[s[i:i+minSize]])\\n            else:\\n                continue\\n            for j in range(i+minSize, min(i+maxSize,N)):\\n                if(s[j] not in d):\\n                    d[s[j]] = 1\\n                else:\\n                    d[s[j]] += 1\\n                if(len(d)<=maxLetters):\\n                    if(s[i:j+1] not in list(d1.keys())):\\n                        d1[s[i:j+1]] = 1\\n                    else:\\n                        \\n                        d1[s[i:j+1]] += 1\\n                    maxval = max(maxval,d1[s[i:j+1]])\\n                else:\\n                    break       \\n        return maxval\\n\", \"import collections\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        ans , freq_subs , n = collections.defaultdict( int ) , 0 , len( s )\\n        for i in range( n - minSize + 1 ) :\\n            for j in range( i + minSize  , n + 1 ) :\\n                if len( set( s[ i : j ] ) ) <= maxLetters :\\n                    if s[i:j] in ans :\\n                        ans[ s[i:j] ] += 1\\n                        freq_subs = max( freq_subs , ans[s[i:j]] )\\n                    else :\\n                        ans[s[i:j]] = 1\\n                        freq_subs = max( freq_subs , 1 )\\n                else :\\n                    break\\n        return freq_subs\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        freq = Counter()\\n        for leftInd, char in enumerate(s):\\n            seen = set([])\\n            for rightInd in range(leftInd, leftInd + maxSize):\\n                if rightInd > len(s) - 1:\\n                    break\\n                seen.add(s[rightInd])\\n                if len(seen) > maxLetters:\\n                    break\\n                if maxSize >= rightInd - leftInd + 1 >= minSize:\\n                    freq[s[leftInd:rightInd + 1]] += 1\\n        ret = 0\\n        for key, val in freq.items():\\n            ret = max(ret, val)\\n        return ret\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        cache=collections.defaultdict(int)\\n        for i in range(len(s)+1-minSize):\\n            if len(set(s[i:i+minSize]))<=maxLetters:\\n                cache[s[i:i+minSize]]+=1\\n        res=0\\n        for k,v in list(cache.items()):\\n            res=max(res,v)\\n        return res\\n                \\n            \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        d=defaultdict(int)\\n        s=list(s)\\n        n=len(s)\\n\\n        for i in range(n-minSize+1):\\n            for j in range(i+minSize,min(i+maxSize+1,n+1)):\\n                if len(set(s[i:j]))<=maxLetters:\\n                    d[tuple(s[i:j])]+=1\\n                   \\n                else:\\n                    break\\n        if not d:\\n            return 0\\n        return max(d.values())\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        if minSize > len(s):\\n            return 0\\n        maxCount = 0\\n        seenSubstrs = Counter()\\n        for i in range(len(s)):\\n            letterSet = set()\\n            for j in range(i, i + minSize - 1):\\n                if j >= len(s):\\n                    break\\n                letterSet.add(s[j])\\n                if len(letterSet) > maxLetters:\\n                    break\\n            if len(letterSet) > maxLetters:\\n                continue\\n            for j in range(i+minSize-1, i+maxSize+1):\\n                if j >= len(s):\\n                    break\\n                letterSet.add(s[j])\\n                if len(letterSet) > maxLetters:\\n                    break\\n                seenSubstrs[s[i:j+1]] += 1\\n                maxCount = max(seenSubstrs[s[i:j+1]], maxCount)\\n        return maxCount\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        sub = dict()\\n\\n        for i in range(len(s) - minSize + 1):\\n            d = dict()\\n            for k in range(i, i + minSize):\\n                if s[k] in d:\\n                    d[s[k]] += 1\\n                else:\\n                    d[s[k]] = 1\\n\\n            if len(d) <= maxLetters:\\n                phrase = s[i:i+minSize]\\n                if phrase in sub:\\n                    sub[phrase] += 1\\n                else:\\n                    sub[phrase] = 1\\n            else:\\n                continue\\n\\n            for j in range(i + minSize, i + maxSize):\\n                if j < len(s):\\n                    if len(d) <= maxLetters:\\n                        phrase = s[i:j+1]\\n                        if phrase in sub:\\n                            sub[phrase] += 1\\n                        else:\\n                            sub[phrase] = 1\\n                    else:\\n                        break\\n\\n                    if s[j] in d:\\n                        d[s[j]] += 1\\n                    else:\\n                        d[s[j]] = 1\\n\\n        if not sub:\\n            return 0\\n        return max(sub.values())\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        n = len(s)\\n        res_dict = collections.defaultdict(int)\\n        \\n        for lidx in range(n-minSize+1):\\n            lval = lidx+minSize\\n            rval = min(n,lidx+maxSize+1)\\n            for ridx in range(lval, 1+rval):\\n                counts = set(s[lidx:ridx])\\n                if len(counts) <= maxLetters:\\n                    res_dict[s[lidx:ridx]] += 1\\n                else: \\n                    break\\n        \\n        return max(res_dict.values()) if res_dict else 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        def valid(sub):\\n            seen = set()\\n            for c in sub: seen.add(c)\\n            return len(seen)\\n            \\n        counts = dict()\\n        start = 0\\n        while start < len(s):\\n            end = start+minSize\\n            while end <= len(s) and end <= start + maxSize:\\n                sub = s[start:end]\\n                if sub in counts:\\n                    counts[sub] += 1\\n                else:\\n                    num_letters = valid(sub)\\n                    if num_letters <= maxLetters:\\n                        counts[sub] = 1\\n                    else:\\n                        break\\n                end += 1\\n            start += 1\\n        \\n        l = list(counts.values())\\n        if len(l) == 0: return 0\\n        return max(l)\\n            \\n            \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        all_substrings = {}\\n        max_letters = maxLetters\\n        min_size = minSize\\n        max_size = maxSize\\n        _s = s\\n        ll = len(_s)\\n        for i in range(min_size, max_size + 1):\\n            for j in range(ll - i + 1):\\n                ss = _s[j:j+i]\\n                if max_letters >= min_size or len(set(ss)) <= max_letters:\\n                    if ss not in all_substrings:\\n                        all_substrings[ss] = 1\\n                    else:\\n                        all_substrings[ss] += 1\\n        return max(all_substrings.values()) if len(all_substrings) > 0 else 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        sol = {}\\n        for i in range(len(s) - minSize + 1):\\n            count = set()\\n            length = 0\\n            for j in range(minSize - 1):\\n                length += 1\\n                c = s[i+j]\\n                if c not in count:\\n                    count.add(c)\\n            while length < maxSize and (i + length) < len(s):\\n                c = s[i + length]\\n                if c not in count:\\n                    count.add(c)\\n                if len(count) <= maxLetters:\\n                    substring = s[i: i+length+1]\\n                    if substring in sol:\\n                        sol[substring] += 1\\n                    else:\\n                        sol[substring] = 1\\n                length += 1\\n        maximum = 0\\n        for substring in sol:\\n            if sol[substring] > maximum:\\n                maximum = sol[substring]\\n        return maximum\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n    \\n        cur_soln = {s[:minSize]: 1}\\n        \\n        for end in range(minSize, len(s)):\\n            for start in range(end-minSize+1, max(-1, end-maxSize), -1):\\n                subs = s[start:end+1]\\n                cur_soln[subs] = cur_soln.get(subs, 0) + 1\\n\\n        cur_best = 0\\n        for s, cnt in list(cur_soln.items()):\\n            if cnt > cur_best and len(set(s)) <= maxLetters:\\n                cur_best = cnt\\n        return cur_best\\n                \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        count = collections.Counter()\\n        \\n        for i in range(len(s) - minSize + 1):\\n            t = s[i:minSize+i]\\n            if len(set(t)) <= maxLetters:\\n                count[t] += 1\\n                \\n                \\n                \\n        if count:\\n            return max(count.values())\\n        else:\\n            return 0 \", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        maxcount = 0\\n        visited = {}\\n        for i in range(len(s)):\\n            for j in range(minSize, minSize+1):\\n                now = s[i:i+j]\\n                if now in visited:\\n                    continue\\n                    \\n                visited[now] = 1\\n                if i + j > len(s):\\n                    break\\n                    \\n                nowset = set(now)\\n                if len(nowset) > maxLetters:\\n                    break\\n                \\n                count = 1\\n                start = i+1\\n                while(start < len(s)):\\n                    pos = s.find(now, start)\\n                    if pos != -1:\\n                        start = pos + 1\\n                        count += 1\\n                    else:\\n                        break\\n                    \\n                maxcount = max(maxcount, count)\\n        \\n        return maxcount\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        substrings = defaultdict(int)\\n        for gap in range(minSize, maxSize + 1):\\n            for start in range(len(s) - gap + 1):\\n                end = start + gap\\n                substrings[s[start:end]] += 1\\n        max_ = 0\\n        for substring, times in substrings.items():\\n            if times > max_ and len(set(substring)) <= maxLetters:\\n                max_ = times\\n        return max_\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        if maxLetters == 0:\\n            return 0\\n        sw = collections.defaultdict(int)\\n        substrings = collections.defaultdict(int)\\n        l = 0\\n        res = 0\\n        for r, ch in enumerate(s):\\n            sw[ch] += 1\\n            while l <= r and len(sw) > maxLetters:\\n                chL = s[l]\\n                sw[chL] -= 1\\n                if sw[chL] == 0:\\n                    del sw[chL]\\n                l += 1\\n            #print(r, r + 1 - maxSize, r + 1 - minSize + 1)\\n            #print(l, r)\\n            for j in range(r + 1 - maxSize, r + 1 - minSize + 1):\\n                if j < l:\\n                    continue\\n                substrings[s[j : r + 1]] += 1\\n                res = max(res, substrings[s[j : r + 1]])\\n            #print(substrings)\\n        return res\\n        \\n        #l r\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        maxi = 0\\n        \\n        for index in range(minSize, maxSize + 1):\\n            result = self.getAllSubstringsWithRules(s, maxLetters, index)\\n            \\n            if result > maxi:\\n                maxi = result\\n                \\n        return maxi\\n    \\n    def getAllSubstringsWithRules(self, s, maxLetters, size):\\n        length = len(s)\\n        letters = {}\\n        subStrings = {}\\n        \\n        for index in range(size):\\n            letter = s[index]\\n            \\n            if letter not in letters:\\n                letters[letter] = 0\\n                \\n            letters[letter] += 1\\n            \\n        if len(letters) <= maxLetters:\\n            subStrings[s[:size]] = 1\\n            \\n        for index in range(size, length):\\n            letterToRemove = s[index - size]\\n            letters[letterToRemove] -= 1\\n            \\n            if letters[letterToRemove] == 0:\\n                del letters[letterToRemove] \\n                \\n            letterToAdd = s[index]\\n            \\n            if letterToAdd not in letters:\\n                letters[letterToAdd] = 0\\n                \\n            letters[letterToAdd] += 1\\n            \\n            if len(letters) <= maxLetters:\\n                string = s[index - size + 1:index + 1]\\n                if string not in subStrings:\\n                    subStrings[string] = 0\\n                    \\n                subStrings[string] += 1\\n                \\n        if not subStrings:\\n            return 0\\n                \\n        return max(subStrings.values())\\n            \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        n = len(s)\\n        cnt = defaultdict(int)\\n        \\n        for i in range(n):\\n            now = ''\\n            se = set()\\n            \\n            for j in range(maxSize):\\n                if i+j>=n:\\n                    break\\n                    \\n                now += s[i+j]\\n                se.add(s[i+j])\\n                \\n                if len(se)<=maxLetters and len(now)>=minSize:\\n                    cnt[now] += 1\\n        \\n        ans = 0\\n        \\n        for v in cnt.values():\\n            ans = max(ans, v)\\n        \\n        return ans\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        sol = {}\\n        for i in range(len(s) - minSize + 1):\\n            count = {}\\n            length = 0\\n            for j in range(minSize - 1):\\n                length += 1\\n                c = s[i+j]\\n                if c in count:\\n                    count[c] += 1\\n                else:\\n                    count[c] = 1\\n            while length < maxSize and (i + length) < len(s):\\n                c = s[i + length]\\n                if c in count:\\n                    count[c] += 1\\n                else:\\n                    count[c] = 1\\n                if len(count) <= maxLetters:\\n                    substring = s[i: i+length+1]\\n                    if substring in sol:\\n                        sol[substring] += 1\\n                    else:\\n                        sol[substring] = 1\\n                length += 1\\n        maximum = 0\\n        for substring in sol:\\n            if sol[substring] > maximum:\\n                maximum = sol[substring]\\n        return maximum\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        cnt=collections.Counter()\\n        for i in range (len(s)-minSize+1):\\n            sub=s[i:i+minSize]\\n            if len(set(sub))<=maxLetters:\\n                cnt[sub]+=1\\n        return max(cnt.values()) if cnt else 0    \\n                    \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        sol = {}\\n        for i in range(len(s) - minSize + 1):\\n            count = set()\\n            length = 0\\n            while length < maxSize and (i + length) < len(s):\\n                c = s[i + length]\\n                if c not in count:\\n                    count.add(c)\\n                length += 1\\n                # print(s[i: i+length+1])\\n                if len(count) <= maxLetters and length >= minSize:\\n                    substring = s[i: i+length]\\n                    if substring in sol:\\n                        sol[substring] += 1\\n                    else:\\n                        sol[substring] = 1\\n        maximum = 0\\n        for substring in sol:\\n            if sol[substring] > maximum:\\n                maximum = sol[substring]\\n        return maximum\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n                \\n        counts = {} # string -> number \\n        \\n        for current_size in range(minSize, maxSize + 1): \\n            window = {}\\n            for i in range(current_size-1): \\n                c = s[i]\\n                window[c] = window.get(c, 0) + 1 \\n            \\n            for i in range(current_size-1, len(s)):\\n                start = i - current_size\\n\\n                # add current \\n                c = s[i]\\n                window[c] = window.get(c, 0) + 1 \\n                \\n                # remove tail\\n                if start >= 0:\\n                    c = s[start]\\n                    window[c] -= 1 \\n                    if window[c] == 0:\\n                        del window[c]\\n                    \\n                # check\\n                if len(window) <= maxLetters: \\n                    sub = s[start+1:i+1]\\n                    counts[sub] = counts.get(sub, 0) + 1 \\n                    \\n        # print(counts)\\n        return max(counts.values()) if len(counts) else 0 \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        dic = {}\\n        for outer in range(0,len(s)):\\n            if minSize + outer > len(s): break\\n            substring = s[outer:minSize+outer]\\n            while len(substring) <= maxSize and len(set(substring))<=maxLetters:\\n                if dic.get(substring): \\n                    dic[substring] += 1\\n                else: dic[substring] = 1\\n                newIndex = outer + len(substring) + 1\\n                if not newIndex > len(s):\\n                    substring = s[outer:newIndex]\\n                else: break\\n        if dic:\\n            maxKey = max(dic,key=lambda key: dic[key])\\n            return dic[maxKey]\\n        else: return 0\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        for i in range(minSize, maxSize+1):\\n            max_freq = self.maxFreqSetSize(s, maxLetters, i)\\n            if max_freq > 0:\\n                return max_freq\\n        return 0\\n        \\n    def maxFreqSetSize(self, s, maxLetters, windowSize):\\n        valid_substrings = set()\\n        maxFreq = 0\\n        for i in range(len(s)-windowSize):\\n            substring = s[i:i+windowSize]\\n            if substring in valid_substrings:\\n                continue\\n            unique_letters = set()\\n            for k in range(windowSize):\\n                letter = s[i+k]\\n                unique_letters.add(letter)\\n            if len(unique_letters) > maxLetters:\\n                continue\\n            frequency = 1\\n            pos = i + 1\\n            while pos > -1:\\n                new_pos = s[pos:].find(substring)\\n                if new_pos == -1:\\n                    break\\n                frequency += 1\\n                pos += new_pos + 1\\n                            \\n            if frequency > maxFreq:\\n                maxFreq = frequency\\n            valid_substrings.add(substring)\\n        return maxFreq\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        \\n        \\n        mymap = collections.defaultdict(int)\\n        st, j, n = 0, 0, len(s)\\n#         charmap = collections.defaultdict(int)\\n        \\n#         for i in range(st, st+minSize-1):\\n#             charmap[s[i]] += 1\\n#         # print(charmap)\\n        while st + minSize <= n:\\n            # print (st)\\n            count = collections.Counter(s[st:st+minSize-1])\\n            for j in range(st+minSize-1, st+maxSize):\\n                \\n                if j >= n:\\n                    break\\n                    \\n                count[s[j]] += 1\\n                if len(count) <= maxLetters:\\n                    mymap[s[st:j+1]] += 1\\n                \\n                \\n                \\n                \\n                \\n#                 print(j, s[st:])\\n#                 if j >= n:\\n#                     break\\n                    \\n#                 charmap[s[j]] += 1\\n#                 if len(charmap) <= maxLetters:\\n#                     mymap[s[st:j+1]] += 1\\n                \\n                 \\n#             charmap[s[st]] -= 1\\n#             if charmap[s[st]] <= 0:\\n#                 charmap.pop(s[st])\\n            st += 1\\n                    \\n        # ans = 0  \\n        maxval = max(list(mymap.values()) or [0])\\n        # for key in mymap:\\n        #     if mymap[key] == maxval:\\n        #         ans += 1\\n                \\n        return maxval\\n        # print(mymap)\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        validWords = {}\\n        for i in range(0, len(s)):\\n            for j in range(i + minSize - 1, min(i + maxSize, len(s))):\\n                ss = s[i:j + 1]\\n                if len(set(ss)) <= maxLetters:\\n                    if ss in validWords:\\n                        validWords[ss] += 1\\n                    else:\\n                        validWords[ss] = 1\\n\\n        # print(\\\\\\\"valid: \\\\\\\", validWords)\\n        if validWords:\\n            all_values = validWords.values()\\n            return max(all_values)\\n        else:\\n            return 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        mymap = collections.defaultdict(int)\\n        st, j, n = 0, 0, len(s)\\n        while st + minSize <= n:\\n            # print (st)\\n            count = collections.Counter(s[st:st+minSize-1])\\n            for j in range(st+minSize-1, st+maxSize):\\n                if j >= n:\\n                    break\\n                count[s[j]] += 1\\n                if len(count) <= maxLetters:\\n                    mymap[s[st:j+1]] += 1\\n            st += 1\\n        maxval = max(list(mymap.values()) or [0])\\n        return maxval\\n        \\n        \\n        \\n#         mymap = collections.defaultdict(int)\\n#         st, j, n = 0, 0, len(s)\\n# #         charmap = collections.defaultdict(int)\\n        \\n# #         for i in range(st, st+minSize-1):\\n# #             charmap[s[i]] += 1\\n# #         # print(charmap)\\n#         while st + minSize <= n:\\n#             # print (st)\\n#             count = collections.Counter(s[st:st+minSize-1])\\n#             for j in range(st+minSize-1, st+maxSize):\\n                \\n#                 if j >= n:\\n#                     break\\n                    \\n#                 count[s[j]] += 1\\n#                 if len(count) <= maxLetters:\\n#                     mymap[s[st:j+1]] += 1\\n                \\n                \\n                \\n                \\n                \\n# #                 print(j, s[st:])\\n# #                 if j >= n:\\n# #                     break\\n                    \\n# #                 charmap[s[j]] += 1\\n# #                 if len(charmap) <= maxLetters:\\n# #                     mymap[s[st:j+1]] += 1\\n                \\n                 \\n# #             charmap[s[st]] -= 1\\n# #             if charmap[s[st]] <= 0:\\n# #                 charmap.pop(s[st])\\n#             st += 1\\n                    \\n#         # ans = 0  \\n#         maxval = max(mymap.values() or [0])\\n#         # for key in mymap:\\n#         #     if mymap[key] == maxval:\\n#         #         ans += 1\\n                \\n#         return maxval\\n#         # print(mymap)\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        maxOcc = 0\\n        strOcc = {}\\n        \\n        for i in range(minSize, maxSize + 1):\\n            charFreq = {}\\n            sub = s[:i]\\n            uniqueChar = 0\\n            \\n            for c in sub:\\n                if c not in charFreq:\\n                    charFreq[c] = 0\\n                    uniqueChar += 1\\n                charFreq[c] += 1\\n            \\n            if uniqueChar <= maxLetters:\\n                if sub not in strOcc:\\n                    strOcc[sub] = 0\\n                strOcc[sub] += 1\\n                maxOcc = max(maxOcc, strOcc[sub])\\n            \\n            for j in range(i, len(s)):\\n                outC = sub[0]\\n                inC = s[j]\\n                \\n                charFreq[outC] -= 1\\n                if charFreq[outC] == 0:\\n                    uniqueChar -= 1\\n                    del charFreq[outC]\\n                    \\n                if inC not in charFreq:\\n                    charFreq[inC] = 0\\n                    uniqueChar += 1\\n                charFreq[inC] += 1\\n                \\n                sub = sub[1:] + inC\\n                \\n                if uniqueChar <= maxLetters:\\n                    if sub not in strOcc:\\n                        strOcc[sub] = 0\\n                    strOcc[sub] += 1\\n                    maxOcc = max(maxOcc, strOcc[sub])\\n                    \\n        return maxOcc\\n                \\n            \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        n = len(s)\\n        if n < minSize:\\n            return 0\\n        c = collections.Counter()\\n        for start in range(n - minSize+1):\\n            temp = s[start:start+minSize]\\n            tc = collections.Counter(temp)\\n            if len(tc.keys()) <= maxLetters:\\n                c[temp] += 1\\n            else:\\n                continue\\n            for i in range(start+minSize,min(n,start + maxSize)):\\n                tc[s[i]] += 1\\n                temp += s[i]\\n                if len(tc.keys()) <= maxLetters:\\n                    c[temp] += 1\\n                else:\\n                    continue\\n        return max(c.values() or [0])\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        substr = defaultdict(int)\\n        n = len(s)\\n        unique = set()\\n        max_freq = 0\\n        \\n        for i in range(n - minSize + 1):\\n            current_str = s[i:i+minSize]\\n            \\n            if len(set(current_str)) <= maxLetters:\\n                substr[current_str] += 1\\n                max_freq = max(max_freq, substr[current_str])\\n        \\n        \\n        return max_freq\", \"from collections import defaultdict\\n\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        substrFreq = defaultdict(int)\\n        charFreq = defaultdict(int)\\n        curr_substr = []\\n        \\n        l = 0\\n        r = l + minSize - 1\\n        \\n        while l < len(s):\\n            for ch in s[l:r]:\\n                curr_substr.append(ch)\\n                charFreq[ch] += 1\\n                \\n            while (r - l + 1) <= maxSize and r < len(s):\\n                charFreq[s[r]] += 1\\n                curr_substr.append(s[r])\\n                \\n                if len(charFreq) <= maxLetters:\\n                    # print(curr_substr)\\n                    substrFreq[''.join(curr_substr)] += 1\\n\\n                r += 1\\n                \\n            curr_substr = []\\n            charFreq = defaultdict(int)\\n            l += 1\\n            r = l + minSize - 1\\n        \\n        if substrFreq:\\n            return max(substrFreq.values())\\n        return 0\\n\", \"import collections\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        finalDict = collections.defaultdict(int)\\n        for i in range(len(s)):\\n            for j in range(i + minSize - 1, min(i + maxSize, len(s))):\\n                substring = s[i:j+1]\\n                if len(set(substring)) <= maxLetters:\\n                    finalDict[substring] += 1\\n                    \\n    \\n    \\n        return max(finalDict.values()) if finalDict else 0\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        freq = {}\\n        \\n        for size in range(minSize, maxSize+1):\\n            for i in range(len(s) - size + 1):\\n                sub_str = s[i:i+size]\\n                \\n                if len(set(sub_str)) > maxLetters: continue\\n                \\n                if sub_str in freq:\\n                    freq[sub_str] += 1\\n                else:\\n                    freq[sub_str] = 1\\n                \\n        max_freq = 0\\n        \\n        for sub_str, cnt in list(freq.items()):\\n            max_freq = max(max_freq, cnt)\\n            \\n        return max_freq\\n\", \"from collections import defaultdict\\nfrom collections import Counter\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        dic = defaultdict(int)\\n        for i in range(len(s)):\\n            for j in range(i + minSize - 1, min(i + maxSize, len(s))):\\n                sub = s[i:j + 1]\\n                if len(set(sub)) <= maxLetters:\\n                    dic[sub] += 1\\n        if len(dic):\\n            return max(dic.values())\\n        else:\\n            return 0\", \"from collections import defaultdict\\n\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        substrFreq = defaultdict(int)\\n        charFreq = defaultdict(int)\\n        curr_substr = []\\n        \\n        l = 0\\n        r = l + minSize - 1\\n        \\n        while l < len(s):\\n            for ch in s[l:r]:\\n                curr_substr.append(ch)\\n                charFreq[ch] += 1\\n                \\n            while (r - l + 1) <= maxSize and r < len(s):\\n                charFreq[s[r]] += 1\\n                curr_substr.append(s[r])\\n                \\n                if len(charFreq) <= maxLetters:\\n                    # print(curr_substr)\\n                    substrFreq[''.join(curr_substr)] += 1\\n\\n                r += 1\\n                \\n            curr_substr = []\\n            charFreq = defaultdict(int)\\n            l += 1\\n            r = l + minSize - 1\\n        \\n        mval = 0\\n        mstr = None\\n        for s, v in substrFreq.items():\\n            if v > mval:\\n                mstr = s\\n                mval = v\\n        \\n        return mval\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        # sliding window\\n        res = collections.Counter()\\n        n = len(s)\\n        size = minSize\\n        while size <= maxSize:\\n            M = collections.defaultdict(int)\\n            for i, c in enumerate(s):\\n                if i < size:\\n                    M[c] += 1\\n                    continue\\n\\n                if len(M) <= maxLetters:\\n                    res[s[i-size:i]] += 1\\n                \\n                # slide the window\\n                M[s[i-size]] -= 1\\n                if M[s[i-size]] == 0:\\n                    del M[s[i-size]]\\n                M[c] += 1\\n            # check for last one\\n            if len(M) <= maxLetters:\\n                res[s[n-size:]] += 1\\n            \\n            size += 1\\n        \\n        # print(res.most_common(1))\\n        ans = res.most_common(1)\\n        if not ans:\\n            return 0\\n        else:\\n            return ans[0][1]\\n        \\n                \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        # brute force this damn thing\\n        \\n        # 1. all substrings\\n        freq = defaultdict(int)\\n        best = 0\\n        for l in range(minSize, maxSize+1):\\n            for i in range(len(s)-l+1):\\n                ss = s[i:i+l]\\n                # print('substring', ss)\\n                if len(set(ss)) <= maxLetters:\\n                    freq[ss] += 1\\n                    best = max(best, freq[ss])\\n\\n        # print(freq)\\n        return best\", \"class Solution:\\n    def findSubstring(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> str:\\n        len_s = len(s)\\n        \\n        substrings = {}\\n        for i in range(len_s):\\n            for j in range(i+minSize, i+maxSize+1):\\n                if j > len_s:\\n                    break\\n                substring = s[i:j] \\n                if len(set(substring)) <= maxLetters:\\n                    if substring not in substrings:\\n                        substrings[substring] = 0\\n                    substrings[substring] += 1\\n                \\n                \\n        return substrings\\n    \\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        len_s = len(s)\\n        if len_s < minSize:\\n            return 0\\n        \\n        substrings = self.findSubstring(s, maxLetters, minSize, maxSize)\\n        if not substrings:\\n            return 0\\n        return max(substrings.values())\\n            \\n                    \\n            \\n\", \"from collections import Counter\\n\\n\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        freq = Counter()\\n        \\n        for k in range(minSize, maxSize + 1):\\n            for i in range(len(s) - k + 1):\\n                substring = s[i:i + k]\\n                if len(set(substring)) <= maxLetters:\\n                    freq[substring] += 1\\n                    \\n        return max(freq.values()) if len(freq) > 0 else 0\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        r = 0\\n        seen = Counter()\\n        for i in range(minSize, maxSize+1):\\n            for j in range(i, len(s)+1):\\n                t = s[j-i:j]\\n                if len( set(t)) <= maxLetters:\\n                    # print(s[j-i:j])\\n                    seen[t] += 1\\n                    if seen[t] > r:\\n                        r = seen[t]\\n        return r\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n\\n        count = collections.Counter(s[i:i + minSize] for i in range(len(s) - minSize + 1))\\n        return max([count[w] for w in count if len(set(w)) <= maxLetters] + [0])\\n        '''\\n        If a string have occurrences x times,\\nany of its substring must appear at least x times.\\n\\nThere must be a substring of length minSize, that has the most occurrences.\\nSo that we just need to count the occurrences of all substring with length minSize.'''\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        max_freq = 0\\n        for l in range(minSize,maxSize+1):\\n            hmap = {}\\n            for i in range(len(s)-l+1):\\n                if len(set(s[i:i+l])) <= maxLetters:\\n                    if s[i:i+l] in list(hmap.keys()):\\n                        hmap[s[i:i+l]] += 1\\n                    else:\\n                        hmap[s[i:i+l]] = 1\\n            if list(hmap.keys()):\\n                max_freq = max(max_freq,max(list(hmap.items()),key=lambda kv: kv[1])[1])\\n        return max_freq\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        occ, n = collections.defaultdict(int), len(s)\\n        for i in range(n):\\n            for j in range(i + minSize - 1, min(i+maxSize, n)):\\n                sub = s[i:j+1]\\n                if len(set(sub)) <= maxLetters:\\n                    occ[sub] += 1\\n        return max(occ.values(), default = 0)\", \"class Solution:\\n    def maxFreq(self, s: str, m: int, n: int, ss: int) -> int:\\n        def getSubStrings(maxLetters:int, minSize: int, maxSize:int):\\n            for i in range(len(s)):\\n                for j in range(i+minSize, len(s) + 1):\\n                    if j - i > maxSize:\\n                        break\\n                    sub = s[i:j]\\n                    if len(set(sub)) <= maxLetters:\\n                        yield sub\\n        \\n        counter = collections.defaultdict(int)\\n        ret = 0\\n        for substring in getSubStrings(m, n, ss):\\n            counter[substring] += 1\\n            ret = max(ret, counter[substring])\\n        return ret\\n\", \"class Solution:\\n  def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n    \\n    toSearch={}\\n    for size in range(minSize,maxSize+1):\\n      for i in range(len(s)-size+1):\\n        S=s[i:i+size]\\n        letters=len(set(S))\\n        if letters<=maxLetters:\\n          if S in toSearch: toSearch[S]+=1\\n          else: toSearch[S]=1\\n    #print(toSearch)\\n    ans=0\\n    for e in toSearch:\\n      ans=max(ans,toSearch[e])\\n    return ans\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        cnt=collections.Counter()\\n        for size in range(minSize, maxSize+1):\\n            for i in range(len(s)-size+1):\\n                sub=s[i:i+size]\\n                if len(set(sub))<=maxLetters:\\n                    cnt[sub]+=1\\n        return max(cnt.values() )   if cnt else 0          \\n                    \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        occ, n = {} , len(s)\\n        \\n        for i in range(n):\\n            for j in range(i + minSize - 1, min(i + maxSize, n)):\\n                sub = s[i:j + 1]\\n                if len(set(sub)) <= maxLetters:\\n                    occ[sub] = occ.get(sub,0) +1\\n                    \\n        return(max(list(occ.values()) or [0]))\\n#         ans = list(occ.values())\\n#         ans.sort(reverse=True)\\n        \\n#         return(ans[0] if ans else 0)\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        counts = dict()\\n        \\n        for i in range(minSize, maxSize+1):\\n            for j in range(i, len(s)+1):\\n                curr = s[j-i:j]\\n                if curr not in counts:\\n                    if len(set(curr)) <= maxLetters:\\n                        counts[curr] = 1\\n                else:\\n                    counts[curr] += 1                    \\n        \\n        if not counts:\\n            return 0\\n        else:\\n            return max(counts.values())\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        possible = dict()\\n        for winSize in range(minSize, maxSize + 1):\\n            for winI in range(len(s) - winSize + 1):\\n                win = s[winI: winI + winSize]\\n                letters = set(win)\\n                if len(letters) <= maxLetters:\\n                    if win in possible:\\n                        possible[win] += 1\\n                    else:\\n                        possible[win] = 1\\n        # print(possible)\\n        if possible:\\n            return max(possible.values())\\n        else:\\n            return 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        lookup = {}\\n        \\n        for size in range(minSize, maxSize + 1):\\n            for i in range(0, len(s) - size + 1):\\n                sub_s = s[i:i+size]\\n                if len(set(sub_s)) <= maxLetters:\\n                    if sub_s not in lookup:\\n                        lookup[sub_s] = 0\\n                    lookup[sub_s] += 1\\n                \\n        if not lookup:\\n            return 0\\n\\n        return max(lookup.values())\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        # brute force this damn thing\\n        \\n        # 1. all substrings\\n        # if it works with greater than minSize, then must work with exactly minSize\\n        freq = defaultdict(int)\\n        best = 0\\n        for i in range(len(s)-minSize+1):\\n            ss = s[i:i+minSize]\\n            # print('substring', ss)\\n            if len(set(ss)) <= maxLetters:\\n                freq[ss] += 1\\n                best = max(best, freq[ss])\\n\\n        # print(freq)\\n        return best\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        \\n        count = defaultdict(int)\\n        \\n        for size in range(minSize, maxSize+1):\\n            \\n            for i in range(0, len(s)-size+1):\\n                \\n                st = s[i:size+i]\\n                \\n                if len(set(st)) <= maxLetters:\\n                    count[st] += 1\\n        \\n        if len(count) == 0:\\n            return 0\\n        return max(count.values())\\n                \\n                \\n                    \\n            \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        SUB_LEN = len(s)\\n        cache = defaultdict(int)\\n        for start in range(SUB_LEN):\\n            \\n            for end in range(start + minSize-1, min(start + maxSize, SUB_LEN)):\\n                \\n                substring = s[start:end+1]\\n                \\n               \\n                if len(set(substring)) <= maxLetters:\\n                    \\n                    cache[substring] += 1 \\n        #print(cache.values())\\n        return max(cache.values()) if cache else 0\\n                    \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        \\n        # find subs that satisifes rules\\n        found = collections.defaultdict(int)\\n        for sl in range(minSize, min(len(s),maxSize)+1):\\n            for start_index in range(len(s)-sl + 1):\\n                substring = s[start_index:start_index+sl]\\n                if len(set(substring)) <= maxLetters:\\n                    found[substring] += 1\\n                    \\n        vals = sorted(found.values())\\n        if len(vals) == 0: return 0\\n        return vals[-1]\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        n = len(s)\\n        results = 0\\n        for l in range(minSize,maxSize+1):\\n            if l<=n:\\n                maps = {}\\n                for i in range(n-l+1):\\n                    subs = s[i:i+l]\\n                    if len(set(subs))<=maxLetters:\\n                        try:\\n                            maps[subs] += 1\\n                            if maps[subs]>results:\\n                                results = maps[subs]\\n                        except KeyError:\\n                            maps[subs] = 1\\n                            if maps[subs]>results:\\n                                results = maps[subs]\\n        return results\\n\", \"import collections\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        substrings = []\\n        for size in range(minSize, maxSize + 1):\\n            for i in range(len(s)-size+1):\\n                if len(set(s[i:i+size])) <= maxLetters:\\n                    substrings.append(s[i:i+size])\\n        return collections.Counter(substrings).most_common(1)[0][1] if substrings else 0\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        all_substrings = {}\\n        for i in range(minSize, maxSize + 1):\\n            for j in range(len(s) - i + 1):\\n                ss = s[j:j+i]\\n                if len(set(ss)) <= maxLetters:\\n                    if ss not in all_substrings:\\n                        all_substrings[ss] = 0\\n                    all_substrings[ss] += 1\\n        if len(all_substrings) > 0:\\n            return max(all_substrings.values())\\n        else:\\n            return 0\", \"from collections import defaultdict\\nfrom collections import Counter\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        dic = defaultdict(int)\\n        for i in range(0, len(s) - minSize + 1):\\n            for j in range(minSize, maxSize + 1):\\n                if i + j > len(s):\\n                    break\\n                cur_str = s[i:i+j]\\n                unique_letters = set(cur_str)\\n                if len(unique_letters) > maxLetters:\\n                    continue\\n                else:\\n                    dic[cur_str] += 1\\n        if len(dic) > 0:\\n            return max(dic.values())\\n        else:\\n            return 0\", \"import collections\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        counter = collections.defaultdict(int)\\n        for ln in range(minSize,maxSize+1):\\n            for i in range(0,len(s)-ln+1):\\n                sub = s[i:i+ln]\\n                if len(set(sub))<=maxLetters:\\n                    counter[sub] += 1\\n        count = [item[1] for item in counter.items()]\\n                       \\n        return max(count) if count else 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        i = 0\\n        lst = []\\n        while i < len(s):\\n            for j in range(minSize, maxSize+1):\\n                subs = s[i:i+j]\\n                \\n                # check the num of char\\n                # c = collections.Counter(subs)\\n                # for char in c:\\n                #     if c[char] > maxLetters:\\n                #         continue\\n                sc = set(subs)\\n                if len(sc) > maxLetters:\\n                    continue\\n                if len(subs)>= minSize and len(subs)<=maxSize and i+j<=len(s):\\n                    lst.append(subs)\\n            i+=1\\n\\n        # check the number of occurence of each subs\\n        c = collections.Counter(lst)\\n        maxs = 0\\n        for subs2 in c:\\n            maxs = max(c[subs2], maxs)\\n            \\n        return maxs\\n            \\n        \\n        \\n\\n                \\n        \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, a: int, b: int) -> int:\\n        cnt = collections.defaultdict(int)\\n        for i in range(len(s)-a+1):\\n            cnt[s[i:i+a]]+=1\\n        for a, v in sorted(cnt.items(), key = lambda x:x[1], reverse=True):\\n            if len(set(a))<=maxLetters:return v\\n        return 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        res, occ = 0, collections.defaultdict(int)\\n        \\n        for r in range(len(s) - minSize + 1):\\n            \\n            sub = s[r:r+minSize]\\n            \\n            if len(set(sub)) <= maxLetters:\\n                \\n                occ[sub] += 1\\n                res = max(res, occ[sub])\\n                \\n        return(res)\", \"from collections import defaultdict\\n\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        d = defaultdict(int)\\n        n = len(s)\\n        \\n        for i in range(n):\\n            # (i + minSize - 1, min(i + maxSize, n))\\n            for j in range(i+minSize-1, min(i+maxSize, n)):\\n                # print(s[i:j])\\n                if len(set(s[i:j+1])) <= maxLetters:\\n                    d[s[i:j+1]]+=1\\n        # print(d)\\n        if d:\\n            return max(d.values())\\n        return 0\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n#         minSize <= size <= maxSize\\n#         uniqu <= maxLetters\\n        \\n#         loop from 3 to 4\\n#         aab abcaab\\n        \\n#         aaba\\n#         to find number of uniques, find the len of the set\\n        \\n#         TIME: O(SN^2)\\n#         SPACE: O(N)\\n#         abcde length = 5\\n#               size = 3\\n        \\n#         abcde\\n\\n        ans = 0\\n        counter = collections.Counter()\\n        \\n        for size in range(minSize, maxSize+1):\\n            for j in range(len(s)-size+1):\\n                substring = s[j:j+size]\\n                if len(set(substring)) <= maxLetters:\\n                    counter[substring]+=1\\n                    ans = max(ans,counter[substring])\\n#                     count = 1\\n#                     for k in range(j+1, len(s)-size+1):\\n#                         if substring == s[k:k+size]: count += 1\\n#                     ans = max(ans,count)\\n        return ans\\n                    \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        all_substrings = {}\\n        max_letters = maxLetters\\n        min_size = minSize\\n        max_size = maxSize\\n        _s = s\\n        max = 0\\n        for i in range(min_size, max_size + 1):\\n            for j in range(len(_s) - i + 1):\\n                ss = _s[j:j+i]\\n                if len(set(ss)) <= max_letters:\\n                    if ss not in all_substrings:\\n                        all_substrings[ss] = 0\\n                    all_substrings[ss] += 1\\n                    if all_substrings[ss] > max:\\n                        max = all_substrings[ss]\\n        return max\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n\\n        cnt = Counter()\\n        # for size in range(minSize, minSize+1):\\n        # size = minSize\\n        # for i in range(len(s)-size+1):\\n        #     ss = s[i:i+size]\\n        #     if len(set(ss)) <= maxLetters:\\n        #         cnt[ss]+=1\\n        # return max(cnt.values()) if cnt else 0\\n    \\n    \\n    \\n        # sliding window\\n        res = collections.Counter()\\n        size = minSize\\n        while size <= maxSize:\\n            for i in range(len(s)-size+1):\\n                ss = s[i:i+size]\\n                if len(set(ss)) <= maxLetters:\\n                    res[ss] += 1\\n            size += 1\\n            \\n        return max(res.values()) if res else 0\\n\", \"class Solution:\\n    def maxFreq(self, s, maxLetters, minSize, maxSize):\\n        if minSize > len(s):\\n            return 0\\n            \\n        words = {}\\n        for size in range(minSize, maxSize + 1):\\n            left = 0\\n            right = size - 1\\n            while right < len(s):\\n                word = s[left:right + 1]\\n                if len(set(word)) <= maxLetters:\\n                    if word not in words:\\n                        words[word] = 0\\n                    words[word] += 1\\n                left += 1\\n                right += 1\\n        \\n        maxOccurences = 0\\n        for word in words:\\n            maxOccurences = max(maxOccurences, words[word])\\n        \\n        return maxOccurences\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        # k = minSize\\n        # count = collections.Counter(s[i:i + k] for i in range(len(s) - k + 1))\\n        # return max([count[w] for w in count if len(set(w)) <= maxLetters] + [0])\\n        cnt = Counter()\\n        for size in range(minSize, maxSize+1):\\n            for i in range(len(s)-size+1):\\n                ss = s[i:i+size]\\n                if len(set(ss)) <= maxLetters:\\n                    cnt[ss]+=1\\n        return max(cnt.values()) if cnt else 0\\n    \\n    \\n    \\n        # sliding window\\n#         res = collections.Counter()\\n#         n = len(s)\\n#         size = minSize\\n#         while size <= maxSize:\\n#             M = collections.defaultdict(int)\\n#             for i, c in enumerate(s):\\n#                 if i < size:\\n#                     M[c] += 1\\n#                     continue\\n\\n#                 if len(M) <= maxLetters:\\n#                     res[s[i-size:i]] += 1\\n                \\n#                 # slide the window\\n#                 M[s[i-size]] -= 1\\n#                 if M[s[i-size]] == 0:\\n#                     del M[s[i-size]]\\n#                 M[c] += 1\\n#             # check for last one\\n#             if len(M) <= maxLetters:\\n#                 res[s[n-size:]] += 1\\n            \\n#             size += 1\\n        \\n#         # print(res.most_common(1))\\n#         ans = res.most_common(1)\\n#         if not ans:\\n#             return 0\\n#         else:\\n#             return ans[0][1]\\n\", \"from collections import defaultdict\\nfrom collections import Counter\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        dic = defaultdict(int)\\n        for i in range(0, len(s) - minSize + 1):\\n            for j in range(minSize, maxSize + 1):\\n                if i + j > len(s):\\n                    break\\n                cur_str = s[i:i+j]\\n\\n                unique_letters = set(cur_str)\\n                if len(unique_letters) > maxLetters:\\n                    continue\\n                else:\\n                    dic[cur_str] += 1\\n\\n\\n        res = 0\\n        for s in dic:\\n            res = max(res, dic[s])\\n        return res\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        maxOccurrences = 0\\n        substrings = dict()\\n        \\n        for i in range(minSize, maxSize + 1):\\n            \\n            for j in range(len(s)):\\n                \\n                if i + j <= len(s):\\n                    \\n                    current = s[j:j+i]\\n                    \\n                    if len(set(current)) <= maxLetters:\\n                        \\n                        if current in substrings:\\n                            \\n                            substrings[current] += 1\\n                        \\n                        else:\\n                            \\n                            substrings[current] = 1\\n                    \\n                        if substrings[current] > maxOccurrences:\\n                            \\n                            maxOccurrences = substrings[current]\\n                            \\n                            \\n        \\n        return maxOccurrences\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        \\n        dict = {}\\n        for i in range(len(s)):\\n            for j in range(i+minSize, i+maxSize+1):\\n                # check if substr already in dict\\n                if j <= len(s):\\n                    substr = s[i:j]\\n                    if len(set(substr)) <= maxLetters:\\n                        if substr in dict:\\n                            dict[substr] += 1\\n                        else:\\n                            dict[substr] = 1\\n\\n        # count max value of dict\\n        max_count = 0\\n        for k,v in list(dict.items()):\\n            max_count = max(max_count, v)\\n\\n        return max_count\\n        \\n        \\n        # brute force - TLE\\n#         max_count = 0\\n\\n#         for i in range(len(s)):\\n#             for j in range(i+minSize, i+maxSize+1):\\n#                 if j < len(s):\\n#                     substr = s[i:j]\\n#                     # print(\\\\\\\"checking substr: \\\\\\\", substr)\\n#                     # valid substring length\\n#                     if len(set(substr)) <= maxLetters:\\n#                         # checking first condition\\n#                         # do the function\\n#                         cc = self.count(substr, s, maxLetters)\\n#                         max_count = max(max_count, cc)\\n\\n#         return max_count\\n\\n\\n#     def count(self, substr, s, maxLetters):\\n#         # print(\\\\\\\"\\\\\\\")\\n#         # print(\\\\\\\"substr passed: \\\\\\\", substr)\\n\\n#         # return the countOcurrences\\n#         count_times = 0\\n#         j = len(substr)\\n\\n#         for i in range(len(s)-j+1):\\n#             # print(\\\\\\\"comparing with s[i:i+j]: \\\\\\\", s[i:i+j])\\n#             if s[i:i+j] == substr:\\n#                 count_times += 1\\n\\n#         return count_times\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        if len(s)<minSize:\\n            return 0\\n        if minSize>maxSize:\\n            return 0\\n        \\n        res=0\\n        d={}\\n        \\n        for i in range(len(s)-minSize+1):\\n            temp=s[i:i+minSize]\\n            if len(set(temp))<=maxLetters:\\n                d[temp]=d.get(temp,0)+1\\n                res=max(res,d[temp])\\n        return res\\n        \\n        '''\\n        res=0\\n        for i in range(minSize,maxSize+1):\\n            #print(\\\\\\\"a\\\\\\\")\\n            r=[]\\n            for j in range(i,len(s)+1):\\n                #print(s[j-minSize:j])\\n                a=s[j-minSize:j]\\n                \\n                if len(set(list(a)))<=maxLetters:\\n                #print(set(list(a)))\\n                    r.append(a)\\n            #print(r)\\n            if len(r)!=0:\\n                r1 = max(set(r), key = r.count) \\n            #print(r.count(r1))\\n                r2=r.count(r1)\\n                res=max(res,r2)\\n        return res\\n        '''\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        freq = collections.defaultdict(int)\\n        max_freq = 0\\n        for win in range(minSize, maxSize+1):\\n            for i in range(len(s) - win + 1):\\n                sub_seq = s[i:i+win]\\n                if len(set(sub_seq)) <= maxLetters:\\n                    freq[sub_seq] += 1\\n            max_freq = max(max_freq, max(freq.values()) if freq else 0)\\n        return max_freq\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        max_occ = 0\\n        \\n        D = {}\\n        for i in range(len(s)):\\n            for j in range(i+minSize,i+maxSize+1):\\n                if j <= len(s):\\n                    s_s = s[i:j]\\n                else:\\n                    continue\\n                # print(s_s)\\n                # print(set(s_s))\\n\\n                if len(set(s_s)) <= maxLetters:\\n                    # print(s_s)\\n                    if s_s in D.keys():\\n                        D[s_s] +=1\\n                    else:\\n                        D[s_s] = 1\\n                    max_occ = max(D[s_s], max_occ)\\n        return max_occ\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        # sliding window, subtract left, if == 0, delete from dict (sliding caterpillar)\\n        currDct = {}\\n        ansDct = defaultdict(int)\\n        length = len(s)\\n        l = 0; r = 0\\n        # init to min size; caterpillar sliding window\\n        while l + minSize < length+1:\\n            # expand to min\\n            currDct = Counter(s[l:l+minSize])\\n            if len(currDct) <= maxLetters:\\n                ansDct[s[l:l+minSize]] += 1\\n            else: l += 1; continue\\n            # expand to maxSize\\n            if minSize == maxSize: l += 1; continue\\n            r = l + minSize + 1;\\n            while r < length and r < l + maxSize:\\n                # add to the right\\n                currDct[s[r]] += 1\\n                # del to the left\\n                currDct[s[l]] -= 1\\n                if currDct[s[l]] == 0: del currDct[s[l]]\\n                if len(currDct) <= maxLetters:\\n                    ansDct[s[l:r+1]] += 1\\n                r += 1\\n            l += 1\\n        # print(ansDct)\\n        return 0 if not ansDct else max(ansDct.values())\", \"import operator\\n\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        freq=collections.defaultdict(int)\\n        \\n        for size in range(minSize, maxSize + 1):\\n            \\n            j = size\\n            window = s[0:size]\\n            \\n            while j <= len(s):\\n                \\n                if len(set(window)) <= maxLetters:\\n                    freq[window] += 1\\n                \\n                j += 1\\n                window = s[j - size:j]\\n                                \\n        if freq:\\n            return max(freq.values())\\n        else:\\n            return 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        counter = dict()\\n        n = len(s)\\n        for i in range(n-minSize+1):\\n            for j in range(i+minSize-1, i+maxSize):\\n                if j>=n:\\n                    break\\n                if len(set(s[i:j+1]))<=maxLetters:\\n                    counter[s[i:j+1]] = counter.get(s[i:j+1], 0) + 1\\n                    \\n        # print(counter)\\n        if list(counter.values())==[]: return 0\\n        return max(counter.values())\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        n = len(s)\\n        d = {}\\n        for i in range(n):\\n            for j in range(minSize, maxSize+1):\\n                if i+j> n:\\n                    break\\n                if len(set(s[i:i+j])) <= maxLetters:\\n                    d[ s[i:i+j] ] = d.get(s[i:i+j],0) +1\\n        # print(d)\\n        return max(list(d.values()), default=0)\\n                       \\n                       \\n\", \"from collections import defaultdict\\nfrom collections import Counter\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        dic = defaultdict(int)\\n        for i in range(0, len(s) - minSize + 1):\\n            for j in range(minSize, maxSize + 1):\\n                if i + j > len(s):\\n                    break\\n                cur_str = s[i:i+j]\\n                unique_letters = set(cur_str)\\n                if len(unique_letters) > maxLetters:\\n                    continue\\n                else:\\n                    dic[cur_str] += 1\\n\\n        res = 0\\n        for s in dic:\\n            res = max(res, dic[s])\\n        return res\", \"import operator\\n\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        freq=collections.defaultdict(int)\\n        \\n        for size in range(minSize, maxSize + 1):\\n            \\n            j = size\\n            window = s[0:size]\\n            \\n            while j <= len(s):\\n                \\n                if len(set(window)) <= maxLetters:\\n                    freq[window] += 1\\n                \\n                j += 1\\n                window = s[j - size:j]\\n                                \\n        if freq:\\n            return max(freq.items(), key=operator.itemgetter(1))[1]\\n        else:\\n            return 0\", \"from collections import Counter\\n\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        substrings = {}\\n        for i in range(len(s)-minSize+1):\\n            sub = s[i:i+minSize]\\n            if sub in substrings:\\n                substrings[sub] += 1\\n            else:\\n                if len(Counter(sub)) <= maxLetters:\\n                    substrings[sub] = 1\\n        if len(substrings):\\n            return max(substrings.values())\\n        else:\\n            return 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        count = 0\\n        ht = collections.Counter()\\n        for i in range(len(s)):\\n            for j in range(i+1,len(s)+1):\\n                substring = s[i:j]\\n                length = len(substring)\\n                if length >= minSize and length <= maxSize and len(set(substring)) <= maxLetters:\\n                    ht[substring]+=1\\n                elif length > maxSize:\\n                    break\\n                    \\n        return max(v for k,v in ht.items()) if ht else 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        substrings = dict()\\n        for i in range(minSize - 1, maxSize):\\n            for j in range(i,len(s)):\\n                if len(set(s[j-i: j + 1])) <= maxLetters:\\n                    substrings[s[j-i: j + 1]] = substrings.get(s[j-i:j + 1], 0) + 1\\n        return max(substrings.values()) if len(substrings) else 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        seen = collections.defaultdict(int)\\n        n = len(s)\\n        for k in range(minSize,maxSize+1):\\n            counts = collections.Counter(s[:k])\\n            if len(counts) <= maxLetters:\\n                seen[s[:k]] += 1\\n            for i in range(n-k):\\n                counts[s[i]] -= 1\\n                if counts[s[i]] == 0:\\n                    del counts[s[i]]\\n                counts[s[i+k]] += 1\\n                if len(counts) <= maxLetters:\\n                    seen[s[i+1:i+k+1]] += 1\\n        return max(seen.values()) if len(seen) > 0 else 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        substrings = collections.defaultdict(int)\\n        for k in range(minSize,maxSize+1):\\n            for i in range(len(s)-k+1):\\n                substrings[s[i:i+k]]+=1\\n        maxCount = 0\\n        for k,v in list(substrings.items()):\\n            if(len(set(k))<=maxLetters):\\n                maxCount=max(maxCount,v)\\n        return maxCount\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        occurence = {}\\n        \\n        for i in range(len(s)):\\n            for j in range(minSize,maxSize+1):\\n                if i+j > len(s): \\n                    break\\n                if len(set(s[i:i+j])) <= maxLetters:\\n                    if s[i:i+j] not in occurence:\\n                        occurence[s[i:i+j]] = 0\\n                    occurence[s[i:i+j]]+=1\\n        # print(occurence)\\n        if len(occurence) == 0:\\n            return 0\\n        return max(occurence.values())\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        i=numUnique=0; N=len(s); count=collections.defaultdict(int); seen=collections.defaultdict(int)\\n        ans=0\\n        \\n        for i in range(N):\\n            count=collections.defaultdict(int)\\n            numUnique=0\\n            power=1\\n            hash=0\\n            for j in range(i,min(i+26,N)):\\n                count[s[j]]+=1\\n                if count[s[j]]==1:\\n                    numUnique+=1\\n                \\n                add=(ord(s[j])-ord('a')+1)*(27**power)\\n                hash+=add\\n                power+=1\\n                \\n                if numUnique>maxLetters or j-i+1>maxSize:\\n                    break\\n                \\n                if minSize<=j-i+1<=maxSize and numUnique<=maxLetters:\\n                    # have a valid subs\\n                    # print(s[i:j+1], hash)\\n                    seen[hash]+=1\\n                    ans=max(ans,seen[hash])\\n        \\n        return ans\\n                \\n                \\n                \\n                \\n        # for j in range(N):\\n            \\n        \\n#         for j in range(N):\\n#             if count[s[j]]==0:\\n#                 numUnique+=1\\n                \\n#             count[s[j]]+=1\\n            \\n#             while j-i+1>maxSize or numUnique>maxLetters:\\n#                 count[s[i]]-=1\\n#                 if count[s[i]]==0:\\n#                     numUnique-=1\\n#                 i+=1\\n                \\n#             if j-i+1>=minSize:\\n#                 # we finally have a valid substring\\n#                 for k in range(i,j+1):\\n#                     curr=\\\\\\\"\\\\\\\"\\n#                     for l in range(k,j+1):\\n#                         curr+=s[l]\\n#                         if len(curr)>=minSize:\\n#                             seen[curr]+1=26\\n                        \\n#                 subs=s[i:j+1]\\n#                 seen[subs]+=1\\n#                 ans=max(ans,seen[subs])\\n        \\n#         print(seen)\\n#         return ans\\n                \\n                \\n            \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        if len(s) < minSize:\\n            return 0\\n        res = 0\\n        \\n        def is_good(ss):\\n            return len(set(ss)) <= maxLetters\\n        \\n        for sz in range(minSize, maxSize + 1):\\n            cnt = collections.defaultdict(int)\\n            \\n            for i in range(len(s) - sz + 1):\\n                if is_good(s[i:i+sz]):\\n                    cnt[s[i:i+sz]] += 1\\n                    res = max(res, cnt[s[i:i+sz]])\\n            #print(sz, cnt)\\n        return res\\n                \\n            \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        store = collections.defaultdict(int)\\n \\n        for i in range(0, len(s) - minSize+ 1): \\n            \\n            for j in range(0, maxSize-minSize + 1): \\n                if (i+j+minSize) > len(s):\\n                    break\\n                subS = s[i: i+ minSize + j] \\n            \\n                checkSize = set(subS)\\n                \\n                if len(checkSize) <= maxLetters:\\n                    store[subS] += 1 \\n        \\n        maxNum = 0\\n \\n        for key, val in store.items():\\n            if val > maxNum:\\n                maxNum = val\\n               \\n        return maxNum\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        \\n        count = defaultdict(int)\\n        \\n        for size in range(minSize, maxSize+1):\\n            \\n            # key = [0]*26\\n            q = deque()\\n            for i in range(0, len(s)):\\n                \\n                # if i < size-1:\\n                # key[ord(s[i])-97] += 1\\n                q.append(s[i])\\n                \\n\\n                if i > size-1:\\n                    q.popleft()\\n                \\n                if (i >= size-1) and len(set(q)) <= maxLetters:\\n                    # print(tuple(key))\\n                    count[tuple(q)] += 1\\n        \\n        if len(count) == 0:\\n            return 0\\n        return max(count.values())\\n                \\n                \\n                    \\n            \\n\", \"# O(n) time and space\\n# Only need minSize, if string S with size N > minSize has frequency F, then the substring of S must also have frequency F\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        ans = 0\\n        str_freq = collections.Counter()\\n        \\n        for i in range(len(s)-minSize+1):\\n            candidate = s[i:i+minSize]\\n            \\n            if len(set(candidate)) <= maxLetters:\\n                str_freq[candidate] += 1\\n                ans = max(ans, str_freq[candidate])\\n                \\n        return ans\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        n = len(s)\\n        dic = collections.defaultdict(int)\\n        res = 0\\n        for i in range(n):\\n            for j in range(i+ minSize - 1,min(i+maxSize,n)):\\n                temp = s[i:j+1]\\n                if len(set(temp)) <= maxLetters:\\n                    dic[temp] += 1\\n                    res = max(res,dic[temp])\\n        return res\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        l = len(s)\\n        ans = 0\\n        for i in range(minSize,maxSize+1):\\n            mp=collections.defaultdict(int)\\n            for j in range(l-i+1):\\n                cc = collections.defaultdict(int)\\n                sub = s[j:j+i]\\n                if len(set(sub))<=maxLetters:\\n                    mp[sub]+=1\\n    \\n            if len(mp.keys())>0:\\n                ans=max(max(mp.values()),ans)\\n        return ans\", \"from collections import defaultdict\\n\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        count = defaultdict(int)\\n        for size in range(minSize, maxSize+1):\\n            for i in range(len(s)-size+1):\\n                substring = s[i:i+size]\\n                if len(set(substring)) <= maxLetters:\\n                    count[substring] += 1\\n        if count:\\n            return max(count.values())      \\n        return 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        if not s or len(s) < minSize:\\n            return 0\\n        gMax = -1\\n        while minSize <= maxSize:\\n            start = 0\\n            end = minSize - 1\\n            freqMap = {}\\n            lMax = 0\\n            while end < len(s):\\n                sub = s[start:end + 1]\\n                # print(sub, self.checkUnique(sub))\\n                if sub in freqMap or self.checkUnique(sub, maxLetters):\\n                    if sub not in freqMap:\\n                        freqMap[sub] = 1\\n                    else:\\n                        freqMap[sub] += 1\\n                    if freqMap[sub] > lMax:\\n                        lMax = freqMap[sub]\\n                start += 1\\n                end += 1\\n            # print(lMax, gMax, minSize)\\n            if lMax > gMax:\\n                gMax = lMax   \\n            minSize += 1\\n            \\n        return gMax\\n                        \\n                \\n                \\n    def checkUnique(self, string, maxLetters):\\n        sett = set(string)\\n        if len(sett) > maxLetters:\\n            return False\\n        else:\\n            return True\\n                \\n                \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        dict = {}\\n        left, right = 0, minSize\\n        while left < len(s):\\n            while right - left <= maxSize and right <= len(s):\\n                sub = s[left:right]\\n                if sub in dict:\\n                    dict[sub] += 1\\n                elif self.isUniqueAmount(sub, maxLetters):\\n                    dict[sub] = 1\\n\\n                right += 1\\n            \\n            left += 1\\n            right = left + minSize\\n        \\n        retValue = 0\\n        for k, v in list(dict.items()):\\n            retValue = max(retValue, v)\\n        \\n        return retValue\\n    \\n    def isUniqueAmount(self, s: str, maxLetters: int) -> bool:\\n        return len(set(s)) <= maxLetters \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        onetime = False\\n        if minSize == maxSize:\\n            onetime = True\\n            \\n        valid_candidates = {}\\n        maxoccurrences = 0\\n        \\n        def check_candidates(test):\\n            nonlocal maxoccurrences\\n            \\n            if len(set(test)) <= maxLetters:\\n                valid_candidates[test] = valid_candidates.get(test, 0) + 1\\n                maxoccurrences = max(maxoccurrences, valid_candidates[test])\\n                \\n        #find all possible substrings\\n        for i in range(len(s)):\\n            for j in range(minSize, maxSize+1):\\n                if i + j <= len(s):\\n                    check_candidates(s[i:i+j])\\n        \\n        return maxoccurrences\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        dict = {}\\n        left, right = 0, minSize\\n        while left < len(s):\\n            while right - left <= maxSize and right <= len(s):\\n                sub = s[left:right]\\n                if self.isUniqueAmount(sub, maxLetters):\\n                    self.addToDict(sub, dict)\\n                right += 1\\n            \\n            left += 1\\n            right = left + minSize\\n        \\n        retValue = 0\\n        for k, v in list(dict.items()):\\n            retValue = max(retValue, v)\\n        \\n        return retValue\\n    \\n    def addToDict(self, sub: str, dict: {}) -> None:\\n        if sub not in dict:\\n            dict[sub] = 0\\n        dict[sub] += 1\\n    \\n    def isUniqueAmount(self, s: str, maxLetters: int) -> bool:\\n        return len(set(s)) <= maxLetters \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        cnt = Counter()\\n        for sz in range(minSize, min(maxSize, len(s)) + 1):\\n            cur = Counter(s[:sz])\\n            if len(cur) <= maxLetters:\\n                cnt[s[:sz]] += 1\\n            for i in range(1, len(s) - sz + 1):\\n                # print(s[i:i+sz], s[i+sz-1])\\n                cur[s[i+sz-1]] += 1\\n                cur[s[i-1]] -= 1\\n                if cur[s[i-1]] == 0:\\n                    cur.pop(s[i-1])\\n                if len(cur) <= maxLetters:\\n                    cnt[s[i:i+sz]] += 1\\n        return max(cnt.values()) if cnt else 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        validStrings = {}\\n        for currSize in range(minSize, maxSize+1):\\n            self.getValidString(currSize, s, maxLetters, validStrings)\\n        return self.getMaxCount(validStrings)\\n        \\n    def getValidString(self,currSize, s, maxLetters, validStrings):\\n        left = 0\\n        right = 0\\n        currWindow = {}\\n        uniqueCounts = 0\\n        for right in range(currSize):\\n            uniqueCounts = self.insert(s[right],currWindow, uniqueCounts)\\n        self.insertValidString(uniqueCounts,maxLetters, left, right, s, validStrings )\\n        while right < len(s)-1:\\n            uniqueCounts = self.insert(s[right+1],currWindow, uniqueCounts)\\n            uniqueCounts = self.remove(s[left],currWindow, uniqueCounts)\\n            left += 1\\n            right += 1\\n            self.insertValidString(uniqueCounts,maxLetters, left, right, s, validStrings )\\n            \\n    def insert(self,char,currWindow, uniqueCounts):\\n        if char not in currWindow:\\n            currWindow[char] = 1\\n            uniqueCounts += 1\\n        else:\\n            currWindow[char] += 1\\n        return uniqueCounts\\n    \\n    def remove(self,char,currWindow, uniqueCounts):\\n        currWindow[char] -= 1\\n        if currWindow[char] == 0:\\n            del currWindow[char]\\n            uniqueCounts -= 1\\n        return uniqueCounts\\n    \\n    def getMaxCount(self,validStrings):\\n        maxCount = 0\\n        for string in validStrings:\\n            if validStrings[string] > maxCount:\\n                maxCount = validStrings[string]\\n        return maxCount\\n    \\n    \\n    def insertValidString(self,uniqueCounts,maxLetters, left, right, s, validStrings ):\\n        if uniqueCounts <= maxLetters:\\n            currWord = s[left:right+1]\\n            if currWord not in validStrings:\\n                validStrings[currWord] = 1\\n            else:\\n                validStrings[currWord] += 1\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        n = len(s)\\n        substr = collections.Counter()\\n        counter = [collections.Counter(s[:minSize])]\\n        if len(counter[-1]) <= maxLetters:\\n            substr[s[:minSize]] += 1\\n        for i in range(1, maxSize - minSize + 1):\\n            counter.append(collections.Counter(counter[-1]))\\n            counter[-1][s[minSize + i - 1]] += 1\\n            if len(counter[-1]) <= maxLetters:\\n                substr[s[:minSize + i]] += 1\\n        # print(counter)\\n        # print(substr)\\n        for i in range(minSize, n):\\n            l = i - minSize\\n            for j, cnt in enumerate(counter):\\n                r = i + j\\n                if r >= n:\\n                    break\\n                cnt[s[l]] -= 1\\n                cnt[s[r]] += 1\\n                if cnt[s[l]] == 0:\\n                    cnt.pop(s[l])\\n                if len(cnt) <= maxLetters:\\n                    substr[s[l + 1: r + 1]] += 1\\n        #     print(counter)\\n        # print(substr)\\n        return max(substr.values(), default=0)\", \"class Solution:        \\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        if len(s) == len(set(s)):\\n            return 0\\n        from collections import defaultdict\\n        corpus = defaultdict(int)\\n        \\n        for i in range(minSize, maxSize+1):\\n            for j in range(len(s) - i + 1):\\n                if len(set(s[j:j+i])) <= maxLetters:\\n                    corpus[s[j:j+i]] += 1\\n        \\n        if len(corpus) == 0:\\n            return 0\\n        \\n        return max(corpus.values())\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        count = 0\\n        diff = maxSize-minSize\\n        hashM = {}\\n        maxC = float('-inf')\\n        \\n        for r in range(len(s)-minSize+1):\\n            \\n            for i in range(diff+1):\\n                \\n                if r + minSize + i <= len(s):\\n                    if len(set(s[r:r+minSize+i])) <= maxLetters:\\n\\n                        hashM[s[r:r+minSize+i]] = hashM.get(s[r:r+minSize+i], 0) + 1\\n                        maxC = max(maxC, hashM[s[r:r+minSize+i]])\\n                        \\n        return(maxC if maxC != float('-inf') else 0)\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n                \\n        counts = {} # string -> number \\n        \\n        for current_size in range(minSize, maxSize + 1): \\n            window = {}\\n            for i in range(current_size): \\n                c = s[i]\\n                window[c] = window.get(c, 0) + 1 \\n\\n            for i in range(current_size, len(s) + 1):\\n                start = i - current_size\\n                if len(window) <= maxLetters: \\n                    sub = s[start:i]\\n                    counts[sub] = counts.get(sub, 0) + 1 \\n                if i == len(s): \\n                    break\\n                    \\n                # add current \\n                c = s[i]\\n                window[c] = window.get(c, 0) + 1 \\n                # remove tail\\n                c = s[start]\\n                window[c] -= 1 \\n                if window[c] == 0:\\n                    del window[c]\\n\\n        # print(counts)\\n        return max(counts.values()) if len(counts) else 0 \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        lookup = {}\\n        \\n        for size in range(minSize, maxSize + 1):\\n            for i in range(0, len(s) - size + 1):\\n                sub_s = s[i:i+size]\\n                if len(set(sub_s)) <= maxLetters:\\n                    if sub_s not in lookup:\\n                        lookup[sub_s] = 0\\n                    lookup[sub_s] += 1\\n                \\n        if not lookup:\\n            return 0\\n\\n        return max(lookup.values()) \", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n       \\n        start = 0\\n        end = 0\\n        sub = {}\\n        result = {}\\n        self.max_size = 0\\n        \\n        def add_sub(pos):\\n            if s[pos] in sub:\\n                sub[s[pos]] +=1\\n            else:\\n                sub[s[pos]] = 1\\n        \\n        def rem_sub(pos):\\n            if s[pos] in sub:\\n                if sub[s[pos]] == 1:\\n                    del sub[s[pos]]\\n                else:\\n                    sub[s[pos]] -= 1\\n        def add_res(string):\\n            if string in result:\\n                result[string] +=1\\n            else:\\n                result[string] = 1\\n            self.max_size = max(self.max_size,result[string])\\n        \\n        for size in range(minSize,maxSize+1):\\n            while start <= len(s)-size:\\n                if (end-start)+1 < size:\\n                    add_sub(end)\\n                    end +=1\\n                else:\\n                    add_sub(end)\\n                    if len(sub) <= maxLetters:\\n                        add_res(s[start:end+1])\\n                    rem_sub(start)\\n                    start +=1\\n                    end +=1\\n            start = 0\\n            end = 0\\n            sub = {}\\n            \\n        return self.max_size\\n        \\n        \\n        \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        my_dict = {}\\n        for i in range(len(s)-minSize+1):\\n            if len(set(s[i:i+minSize]))<=maxLetters:\\n                if s[i:i+minSize] in my_dict:\\n                    my_dict[s[i:i+minSize]] += 1\\n                else:\\n                    my_dict[s[i:i+minSize]] = 1\\n        # print(my_dict)\\n        k = minSize+1\\n        if minSize!=maxSize:\\n            while(maxSize>=k):\\n                for i in range(len(s)-k+1):\\n                    if len(set(s[i:i+k]))<=maxLetters:\\n                        if s[i:i+k] in my_dict:\\n                            my_dict[s[i:i+k]] += 1\\n                        else:\\n                            my_dict[s[i:i+k]] = 1\\n                # print(my_dict)\\n                k+=1\\n        return max(my_dict.values()) if my_dict else 0\\n        \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        count = Counter()\\n        for k in range(minSize, maxSize + 1):\\n            window = Counter(s[:k])\\n            if len(window) <= maxLetters:\\n                count[s[:k]] += 1\\n            for i in range(k, len(s)):\\n                window[s[i]] += 1\\n                window[s[i - k]] -= 1\\n                if window[s[i - k]] == 0:\\n                    del window[s[i - k]]\\n                if len(window) <= maxLetters:\\n                    count[s[i - k + 1:i + 1]] += 1\\n        return max(list(count.values()), default=0)\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        wordCounter = collections.defaultdict()\\n        \\n        # loop (maxSize - minSize)+1 times\\n        for i in range((maxSize - minSize)+1):\\n            charCounter = collections.Counter(s[:minSize+i])\\n            if len(charCounter) <= maxLetters:\\n                    wordCounter[s[:minSize+i]] = 1\\n           \\n            for j in range(minSize+i, len(s)):\\n                charCounter[s[j-minSize-i]] -= 1\\n                \\n                if charCounter[s[j-minSize-i]] <= 0:\\n                    del charCounter[s[j-minSize-i]]\\n    \\n                charCounter[s[j]] += 1\\n                if len(charCounter) <= maxLetters:\\n                    if s[j-minSize-i+1:j+1] in wordCounter:\\n                        wordCounter[s[j-minSize-i+1:j+1]] += 1\\n                    else:\\n                        wordCounter[s[j-minSize-i+1:j+1]] = 1\\n      \\n        maxTimes = 0\\n        for subString in wordCounter:\\n            maxTimes = max(wordCounter[subString], maxTimes)\\n        return maxTimes\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        n = len(s)\\n        res_dict = collections.defaultdict(int)\\n        \\n        for lidx in range(n-minSize+1):\\n            lval = lidx+minSize\\n            rval = min(n,lidx+maxSize+1)\\n            for ridx in range(lval, 1+rval):\\n                counts = collections.Counter(s[lidx:ridx])\\n                if len(counts) <= maxLetters:\\n                    res_dict[s[lidx:ridx]] += 1\\n                else: \\n                    break\\n        \\n        return max(res_dict.values()) if res_dict else 0\", \"import collections\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        # for each substring of length, find unique chars\\n        maxC = Counter()\\n        ans = 0\\n        for sz in range(minSize, maxSize+1):\\n            unq = Counter()\\n            for i in range(sz):\\n                unq[s[i]] += 1\\n                \\n            if (len(unq) <= maxLetters): \\n                maxC[s[0:sz]] += 1\\n                if(maxC[s[0:sz]] > ans): ans=maxC[s[0:sz]]\\n            \\n            i, j = 0, sz - 1\\n            while (j < len(s) - 1):\\n                unq[s[i]] -= 1\\n                if (unq[s[i]] == 0): del unq[s[i]]\\n                \\n                i+=1\\n                j+=1\\n                \\n                unq[s[j]] += 1\\n                \\n                if (len(unq) <= maxLetters): \\n                    maxC[s[i:j+1]] += 1\\n                    if(maxC[s[i:j+1]] > ans): ans=maxC[s[i:j+1]]\\n\\n        return ans\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n\\n        subset_d = {}\\n\\n        for i in range(minSize, maxSize + 1):\\n            for j in range(0, len(s) - i + 1):\\n                substr = s[j:j + i]\\n                subset_d[substr] = subset_d.get(substr, 0) + 1\\n                \\n        max_occur = 0\\n        for substr, val in list(subset_d.items()):\\n            temp_s = set(list(substr))\\n            \\n            if val > max_occur and len(temp_s) <= maxLetters:\\n                max_occur = val\\n                \\n        return max_occur\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        lenS = len(s)\\n        \\n        #for counting uniq chars :\\n        uniqSubStrDict = {}   \\n        \\n        #for i,char in enumerate(s):\\n        #    uniqDict[char] = i                         \\n        count = 0\\n        # edge casses:\\n    \\n        # main alg.\\n        Max = 0;\\n        for i in range(minSize,maxSize + 1):\\n            for j in range(lenS - i + 1) : # maxSize):\\n                \\n                tstSubStr = s[j : j + i]\\n                uniqChars = {}\\n                for k in tstSubStr:\\n                    uniqChars[k] = 1 #uniqChars.get(k,0) + 1\\n                    \\n                if len(uniqChars) > maxLetters:\\n                    #print(' in over maxLetters loop -- tstSubStr = {} '.format(tstSubStr))\\n                    continue\\n                    \\n                #print(' tstSubStr = {} '.format(tstSubStr))\\n                uniqSubStrDict[tstSubStr] = uniqSubStrDict.get(tstSubStr,0) + 1\\n                #print(' dict count = {} '.format(uniqSubStrDict[tstSubStr]))\\n                \\n                if uniqSubStrDict[tstSubStr] > Max :\\n                    Max = uniqSubStrDict[tstSubStr]\\n                    \\n        count = Max\\n        #count = uniqSubStrDict[tstSubStr]\\n                \\n        return count\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        dict = {}\\n        left, right = 0, minSize\\n        while left < len(s):\\n            while right - left <= maxSize and right <= len(s):\\n                sub = s[left:right]\\n                if self.isSize(sub, minSize, maxSize) and self.isUniqueAmount(sub, maxLetters):\\n                    self.addToDict(sub, dict)\\n                right += 1\\n            \\n            left += 1\\n            right = left + minSize\\n        \\n        retValue = 0\\n        for k, v in list(dict.items()):\\n            retValue = max(retValue, v)\\n        \\n        return retValue\\n    \\n    def addToDict(self, sub: str, dict: {}) -> None:\\n        if sub not in dict:\\n            dict[sub] = 0\\n        dict[sub] += 1\\n    \\n    def isSize(self, s: str, minSize: int, maxSize: int) -> bool:\\n        length = len(s)\\n        return minSize <= length and maxSize >= length\\n    \\n    def isUniqueAmount(self, s: str, maxLetters: int) -> bool:\\n        return len(set(s)) <= maxLetters \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        newDict = {}\\n        \\n        for j in range(len(s) - minSize + 1):\\n            word = s[j:j+minSize]\\n            \\n            if word in newDict:\\n                newDict[word] += 1\\n                \\n            else:\\n                if len(collections.Counter(word)) <= maxLetters:\\n                    newDict[word] = 1\\n                    \\n        return max(newDict.values()) if len(newDict) != 0 else 0\\n        \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        freq = {}\\n        for i in range(0, len(s)-minSize+1):\\n            sub = s[i:i+minSize]\\n            chars = set()\\n            for c in sub:\\n                chars.add(c)\\n            if len(chars)<=maxLetters:\\n                if sub not in freq: freq[sub] = 0\\n                freq[sub] += 1\\n        best = 0\\n        for sub in freq:\\n            if freq[sub] > best:\\n                best = freq[sub]\\n        return best\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        #close the window, + 1\\n        \\n        \\n        hashmap = {}\\n        occ = {}\\n        for i in range(len(s)):\\n            hashmap[s[i]] = hashmap.get(s[i], 0) + 1\\n            \\n            \\n            if i>=minSize:\\n                #remove the first\\n                hashmap[s[i-minSize]] -=1\\n                if hashmap[s[i-minSize]] == 0:\\n                    del hashmap[s[i-minSize]]\\n            if i >= minSize -1:\\n                if len(hashmap) <= maxLetters:\\n                    substring = s[i-minSize+1: i+1]\\n                    occ[substring] = occ.get(substring, 0) + 1 \\n        \\n        if len(occ) == 0:\\n            return 0\\n        return max(occ.values())\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        candidates = collections.Counter()\\n        \\n        for i in range(len(s)-minSize+1):\\n            if len(set(list(s[i:i+minSize])))<=maxLetters:\\n                candidates[s[i:i+minSize]] += 1\\n        \\n        return max(list(candidates.values())+[0])\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        count = collections.Counter(s[i:i+minSize] for i in range(len(s)-minSize+1))\\n        return max([count[w] for w in count if len(set(w)) <= maxLetters] +[0])\", \"class Solution:\\n  def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n    counter = collections.defaultdict(int)\\n    mapping = collections.defaultdict(int)\\n    if len(s) < minSize:\\n      return 0\\n    count = 0\\n    for i in range(minSize):\\n      mapping[s[i]] += 1\\n      if mapping[s[i]] == 1:\\n        count += 1\\n    if count <= maxLetters:\\n      counter[s[0:minSize]] += 1\\n    for i in range(1, len(s) - minSize+1):\\n      mapping[s[i-1]] -= 1\\n      if mapping[s[i-1]] == 0:\\n        count -= 1\\n      mapping[s[i+minSize-1]] += 1\\n      if mapping[s[i+minSize-1]] == 1:\\n        count += 1\\n      # print(s[i:i+minSize])\\n      if count <= maxLetters:\\n        counter[s[i:i+minSize]] += 1\\n    # print(counter)\\n    if not counter:\\n      return 0\\n    return max(counter.values())\\n        \\n        \\n\", \"class Solution:\\n    def maxFreq(self, s, maxLetters, minSize, maxSize):\\n        \\n        result = 0\\n        subStringFreq = collections.defaultdict(int)\\n        window = collections.defaultdict(int)\\n        \\n        low = 0\\n        high = 0\\n\\n        while high < len(s):\\n            window[s[high]] += 1   \\n            if (high - low + 1) == minSize:\\n                if len(window) <= maxLetters:  \\n                    subStringFreq[s[low:high+1]] += 1\\n                    result = max(result, subStringFreq[s[low:high+1]]) \\n                    \\n                window[s[low]] -= 1\\n                if window[s[low]] == 0:\\n                    del window[s[low]]\\n\\n                low += 1\\n            high += 1 \\n        return result\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        x=defaultdict(int)\\n        for i in range(len(s)-minSize+1):\\n            sub=s[i:i+minSize]\\n            if len(set(sub))<=maxLetters:\\n                x[sub]+=1\\n        return max(x.values(),default=0)\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        left = 0\\n        result = 0\\n        count = collections.defaultdict(int)\\n        occurances = collections.defaultdict(int)\\n        \\n        for right, char in enumerate(s):\\n            count[char] += 1\\n            while(right - left + 1 > minSize):\\n                count[s[left]] -= 1\\n                if count[s[left]] == 0:\\n                    del count[s[left]]\\n                left += 1\\n                \\n            if right - left + 1 == minSize and len(count) <= maxLetters:\\n                occurances[s[left:right+1]] += 1\\n                result = max(result, occurances[s[left:right+1]])\\n        return result\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        freq = collections.defaultdict(int)\\n        \\n        for i in range(len(s) - minSize + 1):\\n            freq[s[i:i + minSize]] += 1\\n        \\n        mx = 0\\n\\n        for key in freq:\\n            if len(set(key)) <= maxLetters and mx < freq[key]:\\n                mx = freq[key]\\n            \\n        return mx\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        l = 0\\n        r = 0\\n        strMap = collections.defaultdict(int)\\n        curr = ''\\n        currMap = collections.defaultdict(int)\\n        while r < len(s):\\n            char = s[r]\\n            currMap[char] += 1\\n            curr += char\\n            while len(currMap) > maxLetters or len(curr) > minSize:\\n                curr = curr[1:]\\n                currMap[s[l]] -= 1\\n                if currMap[s[l]] == 0:\\n                    del currMap[s[l]]\\n                l += 1\\n            if len(curr) == minSize:\\n                strMap[curr] += 1\\n            r += 1\\n        return max(strMap.values()) if strMap else 0\\n\", \"from collections import defaultdict\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        subCt = defaultdict(int)\\n        currS = defaultdict(int)\\n        mx = 0\\n        l = 0\\n        r = 0\\n        \\n       \\n        while l < len(s) - minSize:\\n            length = r - l + 1\\n           \\n            if length > minSize:\\n                currS[s[l]] -= 1\\n                if currS[s[l]] <= 0:\\n                    del currS[s[l]]\\n                    \\n                l += 1\\n                \\n#             c = (r == len(s) - 1) and (l < len(s) - minSize)\\n           \\n#             if c:\\n#                 currS[s[l]] -= 1\\n#                 if currS[s[l]] <= 0:\\n#                     del currS[s[l]]\\n                    \\n#                 l += 1\\n            \\n            currC = s[r]\\n            currS[currC] += 1\\n            \\n            condition =  (r - l + 1) >= minSize and len(list(currS.keys())) <= maxLetters\\n            if condition:\\n                sub = s[l:r+1]\\n                subCt[sub] += 1\\n                \\n                if subCt[sub] > mx:\\n                    mx = subCt[sub]\\n            \\n            if r < len(s) - 1:\\n                r += 1\\n            \\n        return mx\\n            \\n\", \"from collections import defaultdict\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        subCt = defaultdict(int)\\n        currS = defaultdict(int)\\n        mx = 0\\n        l = 0\\n        r = 0\\n        \\n       \\n        while l < len(s) - minSize:\\n            length = r - l + 1\\n           \\n            if length > minSize:\\n                currS[s[l]] -= 1\\n                if currS[s[l]] <= 0:\\n                    del currS[s[l]]\\n                    \\n                l += 1\\n            \\n            currC = s[r]\\n            currS[currC] += 1\\n            \\n            condition =  (r - l + 1) >= minSize and len(list(currS.keys())) <= maxLetters\\n            if condition:\\n                sub = s[l:r+1]\\n                subCt[sub] += 1\\n                \\n                if subCt[sub] > mx:\\n                    mx = subCt[sub]\\n            \\n            if r < len(s) - 1:\\n                r += 1\\n            \\n        return mx\\n            \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        if not s:\\n            return 0\\n        \\n        n = len(s)\\n        substring_count = defaultdict(int)\\n        \\n        memo_char = defaultdict(int)\\n        reader = 0\\n        writer = 0\\n        \\n        while reader < len(s):\\n            ch = s[reader]\\n            memo_char[ch] += 1\\n            window_len = reader - writer +1\\n            \\n            while len(memo_char) > maxLetters or window_len > minSize:\\n                wch = s[writer]\\n                memo_char[wch] -= 1\\n                \\n                if memo_char[wch] == 0:\\n                    del memo_char[wch]\\n                \\n                writer += 1\\n                window_len = reader - writer +1\\n            if window_len >= minSize and window_len <= maxSize:\\n                substring_count[tuple(s[writer:reader+1])] += 1\\n                #print (s[writer:reader+1], substring_count, window_len)\\n            reader += 1\\n            \\n        if not substring_count:\\n            return 0\\n        \\n        return max(substring_count.values())\\n        \\n        \\n\", \"from collections import defaultdict\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        subCt = defaultdict(int)\\n        currS = defaultdict(int)\\n        mx = 0\\n        l = 0\\n        r = 0\\n        \\n       \\n        while l < len(s) - minSize:\\n            length = r - l + 1\\n           \\n            if length > minSize:\\n                currS[s[l]] -= 1\\n                if currS[s[l]] <= 0:\\n                    del currS[s[l]]\\n                    \\n                l += 1\\n                \\n            c = (r == len(s) - 1) and (l < len(s) - minSize)\\n           \\n            if c:\\n                currS[s[l]] -= 1\\n                if currS[s[l]] <= 0:\\n                    del currS[s[l]]\\n                    \\n                l += 1\\n            \\n            currC = s[r]\\n            currS[currC] += 1\\n            \\n            condition =  (r - l + 1) >= minSize and len(list(currS.keys())) <= maxLetters\\n            if condition:\\n                sub = s[l:r+1]\\n                subCt[sub] += 1\\n                \\n                if subCt[sub] > mx:\\n                    mx = subCt[sub]\\n            \\n            if r < len(s) - 1:\\n                r += 1\\n            \\n        return mx\\n            \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        l = 0\\n        r = 0\\n        strMap = collections.defaultdict(int)\\n        curr = ''\\n        currMap = collections.defaultdict(int)\\n        unique = 0\\n        while r < len(s):\\n            char = s[r]\\n            if currMap[char] == 0:\\n                unique += 1\\n            currMap[char] += 1\\n            curr += char\\n            while unique > maxLetters or len(curr) > minSize:\\n                curr = curr[1:]\\n                currMap[s[l]] -= 1\\n                if currMap[s[l]] == 0:\\n                    unique -= 1\\n                l += 1\\n            print(curr)\\n            if len(curr) >= minSize:\\n                strMap[curr] += 1\\n            r += 1\\n        return max(list(strMap.values()) or (0,0))\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        dic = {}\\n        for i in range(len(s)-minSize+1):\\n            s1 = s[i:i+minSize]\\n            unique = {}\\n            for c in s1:\\n                if c not in unique:\\n                    unique[c] = 1\\n            if len(unique) <= maxLetters:\\n                if s1 in dic:\\n                    dic[s1] += 1\\n                else:\\n                    dic[s1] = 1\\n                if i != len(s)-minSize and minSize != maxSize:\\n                    s2 = s[i:i+maxSize]\\n                    if s2[-1] not in unique:\\n                        unique[s2[-1]] = 1\\n                    if len(unique) <= maxLetters:\\n                        if s2 in dic:\\n                            dic[s2] += 1\\n                        else:\\n                            dic[s2] = 1\\n        max_occr = 0\\n        for key in dic:\\n            if dic[key] > max_occr:\\n                max_occr = dic[key]\\n        return max_occr\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        # actually don't need to go up to maxSize since if\\n        # a string of maxSize has an occurence, then any substring\\n        # has at least an equal number of occurences\\n\\n        seen = collections.defaultdict(int)\\n        n = len(s)\\n        counts = collections.Counter(s[:minSize])\\n        if len(counts) <= maxLetters:\\n            seen[s[:minSize]] += 1\\n        for i in range(n-minSize):\\n            counts[s[i]] -= 1\\n            if counts[s[i]] == 0:\\n                del counts[s[i]]\\n            counts[s[i+minSize]] += 1\\n            if len(counts) <= maxLetters:\\n                seen[s[i+1:i+minSize+1]] += 1\\n        return max(seen.values()) if len(seen) > 0 else 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        strcount = Counter()\\n        unique = set(s[:minSize])\\n        front = 0\\n        back = minSize\\n\\n        while back < len(s):\\n            if len(unique) <= maxLetters:\\n                strcount[s[front:back]] = strcount.get(s[front:back], 0) + 1\\n            front+=1\\n            back+=1\\n            unique = set(s[front:back])\\n        if len(unique) <= maxLetters:\\n            strcount[s[front : back]] = strcount.get(s[front : back], 0) + 1\\n\\n        return max(list(strcount.values()) or [0])\\n\", \"from collections import defaultdict\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        count = defaultdict(int)\\n        d = defaultdict(int)\\n        max_freq = 0\\n        for idx, a in enumerate(s):\\n            count[a] += 1\\n            if idx > minSize - 1:\\n                last = s[idx - minSize]\\n                count[last] -= 1\\n                if count[last] == 0:\\n                    del count[last]\\n            \\n            if idx >= minSize - 1:\\n                if len(count) <= maxLetters:\\n                    d[s[idx-minSize+1: idx+1]] += 1\\n                    max_freq = max(max_freq, d[s[idx-minSize+1: idx+1]])\\n        \\n        return max_freq\\n                \\n            \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        n = 0\\n        left = 0\\n        right = minSize-1\\n        d = {}\\n        length = len(s)\\n        unique_let = {}\\n        def popLetter(letter, n):\\n            unique_let[letter] -= 1\\n            if unique_let[letter] == 0:\\n                n -= 1\\n            return n\\n        def addLetter(letter, n):\\n            if unique_let.get(letter, 0) == 0:\\n                n += 1\\n            unique_let[letter] = unique_let.get(letter,0) + 1\\n            return n\\n        for letter in s[:minSize-1]:\\n            n = addLetter(letter, n)\\n        print(n)\\n        print(unique_let)\\n        while right < length:\\n            if left > 0:\\n                n = popLetter(s[left-1], n)\\n            n = addLetter(s[right], n)\\n            print(n)\\n            if n <= maxLetters:\\n                d[s[left:right+1]] = d.get(s[left:right+1], 0) + 1\\n            right += 1\\n            left += 1\\n        print(d)\\n        if not d.values():\\n            return 0\\n        return max(d.values())\", \"import operator\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        lp = 0\\n        rp = lp + minSize\\n        perm_dict= {}\\n        for i in range(len(s)-minSize+1):\\n            temp = s[lp:rp]\\n            if len(set(temp))<=maxLetters:\\n                if temp not in list(perm_dict.keys()):\\n                    perm_dict[temp]=1\\n                else:\\n                    perm_dict[temp]+=1\\n            i+=1\\n            lp+=1\\n            rp+=1\\n        print(perm_dict)\\n        perm_dict = dict(sorted(list(perm_dict.items()), key=operator.itemgetter(1),reverse=True))\\n        if len(list(perm_dict.keys()))>0:\\n            return perm_dict[list(perm_dict.keys())[0]]\\n        return 0\\n            \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        n = len(s)\\n        s0 = s[:minSize]\\n        counter = collections.Counter(s0)\\n        substr = collections.Counter()\\n        if len(counter) <= maxLetters:\\n            substr[s0] += 1\\n        for i in range(minSize, n):\\n            l = i - minSize\\n            counter[s[i - minSize]] -= 1\\n            counter[s[i]] += 1\\n            if counter[s[i - minSize]] == 0:\\n                counter.pop(s[i - minSize])\\n            if len(counter) <= maxLetters:\\n                substr[s[i - minSize + 1: i + 1]] += 1\\n        return max(substr.values(), default=0)\", \"class Solution:\\n    def maxFreq(self, S, maxchars, minsize, maxsize):\\n        n=len(S)\\n        freq=Counter()\\n        chars=Counter()\\n        i=0\\n        for j in range(n):\\n            if j-i+1>minsize:\\n                chars[S[i]]-=1\\n                if chars[S[i]]==0:\\n                    del chars[S[i]]\\n                i+=1\\n            chars[S[j]]+=1\\n            if j-i+1>=minsize:\\n                if len(chars)<=maxchars:\\n                    freq[S[i:j+1]]+=1\\n        return max(freq.values(),default=0)\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        i=0\\n        j=0\\n        map1={}\\n        res={}\\n        while j<len(s):\\n            map1[s[j]]=map1.get(s[j],0)+1\\n            if len(map1.keys())>maxLetters:\\n                map1[s[i]]=map1[s[i]]-1\\n                if map1[s[i]]==0:\\n                    del map1[s[i]]\\n                i+=1\\n            while len(map1.keys())<=maxLetters and j-i+1<=maxSize and j-i+1>=minSize:\\n                #add to result first\\n                res[s[i:j+1]]=res.get(s[i:j+1],0)+1\\n                \\n                #remove the existing s[i]'s value from map\\n                \\n                map1[s[i]]=map1[s[i]]-1\\n                if map1[s[i]]==0:\\n                    del map1[s[i]]\\n                \\n                #move i=i+1\\n                i=i+1\\n            j=j+1\\n        if len(res)==0:\\n            return 0\\n        else:\\n            maximum = max(res, key=res.get)\\n            return res[maximum]\", \"from collections import defaultdict\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        subCt = defaultdict(int)\\n        currS = defaultdict(int)\\n        mx = 0\\n        l = 0\\n        r = 0\\n        \\n       \\n        while l < len(s) - minSize:\\n            length = r - l + 1\\n           \\n            if length > minSize:\\n                currS[s[l]] -= 1\\n                if currS[s[l]] <= 0:\\n                    del currS[s[l]]\\n                    \\n                l += 1\\n                \\n            c = (r == len(s) - 1) and (l < len(s) - minSize)\\n           \\n            if c:\\n                print('eer')\\n                currS[s[l]] -= 1\\n                if currS[s[l]] <= 0:\\n                    del currS[s[l]]\\n                    \\n                l += 1\\n            \\n            currC = s[r]\\n            currS[currC] += 1\\n            \\n            condition =  (r - l + 1) >= minSize and len(list(currS.keys())) <= maxLetters\\n            if condition:\\n                sub = s[l:r+1]\\n                print(sub)\\n                subCt[sub] += 1\\n                \\n                if subCt[sub] > mx:\\n                    mx = subCt[sub]\\n            \\n            if r < len(s) - 1:\\n                r += 1\\n            \\n        return mx\\n            \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        if len(s) == 0:\\n            return 0\\n        rolling_hash = 0\\n        letter_counts = collections.Counter()\\n        hash_counts = collections.Counter()\\n        unique_letters = set()\\n        n = len(s)\\n        \\n        for i in range(n):\\n            ch = s[i]\\n            \\n            rolling_hash = rolling_hash * 26 + ord(ch)\\n            letter_counts[ch] += 1\\n            unique_letters.add(ch)\\n            \\n            if i + 1 < minSize:\\n                continue\\n            \\n            if len(unique_letters) <= maxLetters:\\n                hash_counts[rolling_hash] += 1\\n                \\n            remove_letter = s[i - minSize + 1]\\n            rolling_hash -= (ord(remove_letter)) * 26**(minSize-1)\\n            letter_counts[remove_letter] -= 1\\n            \\n            if letter_counts[remove_letter] == 0:\\n                unique_letters.remove(remove_letter)\\n        return max(hash_counts.values()) if len(hash_counts) else 0 \", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n\\n        count = collections.Counter(s[i:i + minSize] for i in range(len(s) - minSize + 1))\\n        return max([count[w] for w in count if len(set(w)) <= maxLetters] + [0])\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        window_start = 0\\n        window_letters = Counter()\\n        \\n        substring_counts = Counter()\\n        \\n        for window_end in range(len(s)):\\n            window_letters[s[window_end]] += 1\\n            substring_len = window_end-window_start+1\\n            \\n            while substring_len > maxSize or len(window_letters) > maxLetters:\\n                start_char = s[window_start]\\n                window_letters[start_char] -= 1\\n                if window_letters[start_char] == 0:\\n                    del window_letters[start_char]\\n                window_start += 1\\n                substring_len = window_end-window_start+1\\n            \\n            while substring_len >= minSize:\\n                assert substring_len <= maxSize\\n                substring = s[window_start:window_end+1]\\n                substring_counts[substring] += 1\\n                \\n                start_char = s[window_start]\\n                window_letters[start_char] -= 1\\n                if window_letters[start_char] == 0:\\n                    del window_letters[start_char]\\n                window_start += 1\\n                substring_len = window_end-window_start+1\\n        print(substring_counts)\\n        if not substring_counts:\\n            return 0\\n        return max(substring_counts.values())\\n            \\n            \\n                \\n\", \"import collections\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        # for each substring of length, find unique chars\\n        maxC = Counter()\\n        ans = 0\\n        sz = minSize\\n        unq = Counter()\\n        for i in range(sz):\\n            unq[s[i]] += 1\\n\\n        if (len(unq) <= maxLetters): \\n            maxC[s[0:sz]] += 1\\n            if(maxC[s[0:sz]] > ans): ans=maxC[s[0:sz]]\\n\\n        i, j = 0, sz - 1\\n        while (j < len(s) - 1):\\n            unq[s[i]] -= 1\\n            if (unq[s[i]] == 0): del unq[s[i]]\\n\\n            i+=1\\n            j+=1\\n\\n            unq[s[j]] += 1\\n\\n            if (len(unq) <= maxLetters): \\n                maxC[s[i:j+1]] += 1\\n                if(maxC[s[i:j+1]] > ans): ans=maxC[s[i:j+1]]\\n\\n        return ans\", \"class Solution:\\n    def maxFreq(self, s: str, maxy: int, m: int, mm: int) -> int:\\n        \\n        i,j = 0,0\\n        count = collections.Counter()\\n        count[s[0]]+=1\\n        ans = collections.Counter()\\n        u, n = 1, len(s)\\n        \\n        key = s[0]\\n        \\n        while True:\\n            if u<=maxy and m<=i-j+1<=mm: \\n                ans[key]+=1\\n            \\n            if j<i and i-j+1>=m:\\n                count[s[j]]-=1\\n                if count[s[j]]==0: u-=1\\n                j+=1\\n                key = key[1:]\\n            else:\\n                i+=1\\n                if i == n: break\\n                if count[s[i]]==0: u+=1\\n                count[s[i]]+=1\\n                key+=s[i]\\n            \\n        return max(ans.values()) if ans else 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxy: int, m: int, mm: int) -> int:\\n        \\n        i,j = 0,0\\n        count = collections.Counter()\\n        count[s[0]]+=1\\n        ans = collections.Counter()\\n        u = 1\\n        n = len(s)\\n        while True:\\n            # print(f'j-{j}, i-{i}, u-{u}, ans-{ans}')\\n            if u<=maxy and m<=i-j+1<=mm: \\n                # print('Found!-',j,i,s[j:i+1])\\n                ans[s[j:i+1]]+=1\\n            \\n            if j<i and i-j+1>=m:\\n                count[s[j]]-=1\\n                if count[s[j]]==0: u-=1\\n                j+=1\\n            else:\\n                i+=1\\n                if i == n: break\\n                if count[s[i]]==0: u+=1\\n                count[s[i]]+=1\\n        print(ans)\\n        return max(ans.values()) if ans else 0\", \"from collections import defaultdict\\n\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        if not s or len(s) < minSize: return 0\\n        res = defaultdict(int)\\n        res[''] = 0\\n        temp = defaultdict(int)\\n    \\n        i = 0\\n        j = minSize-1\\n\\n        for k in range(minSize):\\n            temp[s[k]] += 1\\n        \\n        if len(temp.keys()) <= maxLetters:\\n                res[s[i:j+1]] += 1\\n            \\n        while i < len(s)-minSize:\\n            temp[s[i]] -= 1\\n            i += 1\\n            j += 1\\n            temp[s[j]] += 1\\n            if len([l for l in temp if temp[l]]) <= maxLetters:\\n                res[s[i:j+1]] += 1\\n        \\n        return max(res.values())\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        from collections import defaultdict, Counter\\n        d = defaultdict(int)\\n        for i in range(len(s)-minSize+1):\\n            t = s[i:i+minSize]\\n            if len(Counter(t)) <= maxLetters:\\n                d[t] += 1\\n        return max(d.values()) if d else 0\\n\", \"from collections import Counter, defaultdict\\n\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        d = defaultdict(int)\\n        for i in range(len(s)-minSize+1):\\n            sub = s[i:i+minSize]\\n            if len(Counter(sub)) <= maxLetters:\\n                d[sub] += 1\\n        return max(d.values()) if len(list(d.values())) else 0\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        count = {}\\n        for i in range(len(s) - minSize + 1):\\n            word = s[i: i+minSize]\\n            if word in count:\\n                count[word] += 1\\n            else:\\n                if len(set(word)) <= maxLetters:\\n                    count[word] = 1\\n        return max(count.values()) if count else 0\", \"from collections import Counter\\n\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        i = 0\\n        j = 0\\n        letterCounts = Counter()\\n        substrCounts = Counter()\\n        \\n        while j < len(s):\\n            letterCounts[s[j]] += 1\\n\\n            while len(letterCounts) > maxLetters or j - i + 1 > minSize:\\n                letterCounts[s[i]] -= 1\\n                if letterCounts[s[i]] == 0:\\n                    del letterCounts[s[i]]\\n                i += 1\\n            \\n            if j - i + 1 == minSize:\\n                substrCounts[s[i:j + 1]] += 1\\n            \\n            j += 1\\n        \\n        return 0 if len(substrCounts) == 0 else max(substrCounts.values())\", \"'''\\nuniq<=max\\nlen(sub)>=min and <=max\\n'''\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        hash,w_hash,res={},{},float('-inf')\\n        self.initial_fill(s,minSize,hash)\\n        for i in range(0,len(s)-minSize+1):\\n            if len(hash)<=maxLetters:\\n                string=s[i:i+minSize]\\n                w_hash[string]=1 if string not in w_hash else w_hash[string]+1\\n                res=max(res,w_hash[string])\\n            char=s[i]\\n            if hash[char]==1: del hash[char]\\n            else: hash[char]-=1\\n            if i+minSize<len(s):\\n                char=s[i+minSize]\\n                hash[char]=1 if char not in hash else hash[char]+1\\n        return res if res!=float('-inf') else 0\\n                \\n            \\n    \\n    def initial_fill(self,s,Min,hash):\\n        for i in range(0,Min):\\n            char=s[i]\\n            hash[char]=1 if char not in hash else hash[char]+1\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        left=0\\n        right=0\\n        _dict=defaultdict(int)\\n        _dict2=defaultdict(int)\\n     \\n        while right<len(s):\\n            _dict[s[right]]+=1\\n           \\n        \\n            while len(_dict)>maxLetters or right-left+1>maxSize or right-left+1>minSize:\\n                _dict[s[left]]-=1\\n                if _dict[s[left]]==0:\\n                    del(_dict[s[left]])\\n                left+=1\\n            if  len(_dict)<=maxLetters and minSize<=right-left+1<=maxSize :\\n                    _dict2[s[left:right+1]]+=1                      \\n                \\n            right+=1\\n          \\n        if len(_dict2)==0:\\n            return 0\\n      \\n        return max(_dict2.values())\\n        \\n                \\n\", \"import collections\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        dic = collections.defaultdict(int)\\n        for i in range(len(s) - minSize + 1):\\n            if len(collections.Counter(s[i:i + minSize])) <= maxLetters:\\n                dic[s[i:i + minSize]] += 1\\n        if not dic:\\n            return 0\\n        return max(dic.values())\\n\", \"from collections import defaultdict, Counter\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        def hasUnique(s):\\n            dic = Counter(s)\\n            if(len(dic) <= maxLetters):\\n                return True\\n            return False\\n        \\n        def checkSubStrings(s):\\n            dic = defaultdict(int)\\n            maximum = 0\\n            for i in range(0, len(s) - minSize + 1):\\n                end = i + minSize\\n                strr = s[i:end]\\n                if(hasUnique(strr)):\\n                    dic[strr] += 1\\n                    maximum = max(maximum,  dic[strr])\\n                        \\n            return maximum\\n                    \\n        return(checkSubStrings(s))\", \"from collections import defaultdict\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        cnt = defaultdict(int)\\n        freq = defaultdict(int)\\n        res, left = 0, 0\\n        for i in range(len(s)):\\n            cnt[s[i]] = cnt.get(s[i], 0) + 1\\n            while len(cnt) > maxLetters or i - left + 1 > minSize:\\n                cnt[s[left]] -= 1\\n                if cnt[s[left]] == 0:\\n                    del cnt[s[left]]\\n                left += 1\\n            if (i - left + 1 <= maxSize and i - left + 1 >= minSize):\\n                sub = s[left: i + 1]\\n                freq[sub] = freq.get(sub, 0) + 1\\n        return max(freq.values()) if freq else 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        memo_dict = {}\\n        for i in range(len(s)):\\n            for j in range(i,len(s) + 1):\\n                if j - i < minSize:\\n                    continue\\n                if j - i > minSize:\\n                    break\\n                temp = []\\n                temp_str = s[i:j]\\n                for char in temp_str:\\n                    temp.append(char)\\n                if len(set(temp)) > maxLetters:\\n                    continue\\n                \\n                if temp_str in memo_dict:\\n                    memo_dict[temp_str] += 1\\n                else:\\n                    memo_dict[temp_str] = 1\\n                    \\n        if len(memo_dict) == 0: return 0            \\n        res = sorted(memo_dict, key = lambda x : memo_dict[x])\\n        #print(res)    \\n        return memo_dict[res[-1]]\\n                    \\n                    \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        counterSubstring = collections.defaultdict(int)\\n        best = 0\\n        for start in range(len(s)):\\n            #for size in range(minSize, maxSize + 1):\\n            if start + minSize <= len(s):\\n                substring = s[start:start + minSize]\\n                counterSubstring[substring] += 1\\n        \\n        for substring in counterSubstring:\\n            if len(set(substring)) <= maxLetters:\\n                best = max(best, counterSubstring[substring])\\n        \\n        return best      \", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        freq = Counter()\\n        for leftInd, char in enumerate(s):\\n            seen = set([])\\n            for rightInd in range(leftInd, leftInd + minSize):\\n                if rightInd > len(s) - 1:\\n                    break\\n                seen.add(s[rightInd])\\n                if len(seen) > maxLetters:\\n                    break\\n                if rightInd - leftInd + 1 >= minSize:\\n                    freq[s[leftInd:rightInd + 1]] += 1\\n        ret = 0\\n        for key, val in freq.items():\\n            ret = max(ret, val)\\n        return ret\", \"import collections\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        max_occur = 0\\n        freq_hash = {}\\n        for i in range(len(s) - minSize + 1):\\n            stri = s[i: i + minSize]\\n            if len(collections.Counter(stri)) <= maxLetters:\\n                if stri in freq_hash:\\n                    freq_hash[stri] += 1\\n                else:\\n                    freq_hash[stri] = 1\\n                max_occur = max(max_occur, freq_hash[stri])\\n        return max_occur\\n        # counts = dict()\\n        # for j in range(len(s)-minSize+1):\\n        #     word = s[j:j+minSize]\\n        #     if word in counts:\\n        #         counts[word]+=1\\n        #     else:\\n        #         if len(collections.Counter(word))<=maxLetters:\\n        #             counts[word]=1\\n        # return max(counts.values()) if len(counts)!=0 else 0\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        ans = 0\\n        l = minSize\\n        counts = {}\\n        for i in range(len(s) - l + 1):\\n            string = s[i:i+l]\\n            c = collections.Counter(string)\\n            if len(c) <= maxLetters:\\n                counts[string] = counts.get(string, 0) + 1\\n\\n        if counts:\\n            ans = max(ans, max(counts.values()))\\n        \\n        return ans\", \"from collections import Counter\\n\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        if len(s) < minSize or maxSize == 0:\\n            return 0\\n        \\n        start = 0\\n        end = start + minSize\\n        count = Counter()\\n        \\n        while end <= len(s):\\n            unique = Counter(s[start:end])\\n            \\n            if len(unique) <= maxLetters:\\n                count[s[start:end]] += 1\\n            start += 1\\n            end += 1\\n        return max(count.values()) if count else 0\", \"from collections import Counter\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        # init first window\\n        counts = defaultdict(int)\\n        substrs = defaultdict(int)\\n        start = 0\\n        # expand window until we can't any more \\n        for end in range(len(s)):\\n            counts[s[end]] += 1\\n            if end - start + 1 > minSize:\\n                counts[s[start]] -= 1\\n                if counts[s[start]] == 0:\\n                    del counts[s[start]]\\n                start += 1\\n            print (counts)\\n            if end - start + 1 == minSize and len(counts) <= maxLetters:\\n                substrs[s[start:end+1]] += 1\\n        print (substrs)\\n        if not substrs:\\n            return 0\\n        return max(substrs.values())\\n        \\n        # decrement window until we meet the requirement\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        counter=defaultdict(int)\\n        \\n        for i in range(len(s)):\\n            string=s[i:i+minSize]\\n            if len(Counter(string))<=maxLetters and len(string)>=minSize:\\n                counter[string]+=1\\n        return max(counter.values()) if counter else 0\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        # hash table to remember substrings\\n        substrings = defaultdict(int)\\n        char_counts = Counter(s[0:minSize-1])\\n        \\n        start = 0\\n        while start <= len(s) - minSize:\\n            end = start + minSize - 1\\n            \\n            end_char = s[end]\\n            char_counts[end_char] += 1\\n            \\n            unique_chars = len(char_counts)\\n            \\n            if unique_chars <= maxLetters:\\n                substrings[s[start:end+1]] += 1\\n\\n            start_char = s[start]\\n            if char_counts[start_char] == 1:\\n                del char_counts[start_char]\\n            else:\\n                char_counts[start_char] -= 1\\n                \\n            start += 1\\n            \\n            \\n        maxSubstrings = 0\\n        for substring in substrings:\\n            if substrings[substring] > maxSubstrings:\\n                maxSubstrings = substrings[substring]\\n\\n        return maxSubstrings\", \"class Solution:\\n    from collections import Counter\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        c = 0\\n        freq = collections.defaultdict(int)\\n        for i in range(len(s)-minSize+1):\\n            p = s[i:i+minSize]\\n            cur_dict = Counter(p)\\n            if len(cur_dict) <= maxLetters:\\n                freq[p] += 1\\n        if freq:\\n            return max(freq.values())\\n        return 0\\n\", \"from collections import Counter\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        # init first window\\n        counts = Counter(s[:minSize-1])\\n        substrs = defaultdict(int)\\n        start = 0\\n        # expand window until we can't any more \\n        for end in range(minSize-1, len(s)):\\n            counts[s[end]] += 1\\n            if end - start + 1 > minSize:\\n                counts[s[start]] -= 1\\n                start += 1\\n            if end - start + 1 == minSize and len(set(counts.elements())) <= maxLetters:\\n                substrs[s[start:end+1]] += 1\\n        if not substrs:\\n            return 0\\n        return max(substrs.values())\\n        \\n        # decrement window until we meet the requirement\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        count = defaultdict(int)\\n        m = 0\\n        size = minSize\\n        for i in range(len(s)-size+1):\\n            word = s[i:i+size]\\n            if len(Counter(word))<=maxLetters:\\n                count[word]+=1\\n                m = max(m,count[word])\\n        return m\\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        # if not s:\\n        #     return 0\\n        \\n        subcount = defaultdict(int)\\n        \\n        for i in range(len(s)-minSize+1):\\n            sub = s[i:i+minSize]\\n            # print(sub, set(sub))\\n            if len(set(sub))<=maxLetters:\\n                subcount[sub]+=1\\n            # print(sub, set(sub))\\n                \\n        # print(subcount)\\n        x = sorted(subcount.values(), reverse=True)\\n        if not x:\\n            return 0\\n        return x[0]\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        mymap = {}\\n        \\n        for i in range(len(s)-minSize+1):\\n            if len(set(list(s[i:i+minSize]))) <= maxLetters:\\n                print(s[i:i+minSize])\\n                if s[i:i+minSize] in mymap:\\n                    mymap[s[i:i+minSize]] += 1\\n                else:\\n                    mymap[s[i:i+minSize]] = 1\\n        \\n        if not mymap:\\n            return 0\\n        \\n        return max(mymap.values())\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        res = 0\\n        count = Counter()\\n        \\n        for j in range(len(s) - minSize + 1):\\n            if len(set(s[j:j+minSize])) > maxLetters:\\n                continue\\n            count[s[j:j+minSize]] += 1\\n            res = max(res, count[s[j:j+minSize]])\\n        return res\", \"from collections import Counter\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        \\n        # test = Counter(s)\\n        # print(\\\\\\\"test\\\\\\\", test)\\n        cnt = Counter()\\n        word_cnt = Counter()\\n        cur_hash = 0\\n#         for i in range(minSize):\\n#             cnt[s[i]] += 1\\n#             if len(cnt)>maxLetters:\\n#                 break\\n                \\n        # word_cnt[s[:i+1]] += 1\\n        # print(word_cnt)\\n        left = 0\\n        res = 0\\n        i = 0\\n        while i<len(s):\\n            if i-left+1>minSize:\\n                cnt[s[left]] -= 1\\n                if cnt[s[left]] == 0:\\n                    del cnt[s[left]]\\n                left += 1\\n                \\n            cnt[s[i]] += 1   \\n            \\n            if len(cnt)<=maxLetters and i-left+1==minSize:\\n                word_cnt[s[left:i+1]] += 1\\n                # print(s[left:i+1])\\n                res = max(res, word_cnt[s[left:i+1]])\\n                \\n            i += 1\\n        # print(word_cnt)\\n        return res\\n# \\\\\\\"aababcaab\\\\\\\"\\n# 2\\n# 3\\n# 4\\n# \\\\\\\"aaaa\\\\\\\"\\n# 1\\n# 3\\n# 3\\n# \\\\\\\"aabcabcab\\\\\\\"\\n# 2\\n# 2\\n# 3\\n# \\\\\\\"abcde\\\\\\\"\\n# 2\\n# 3\\n# 3\\n                \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        res = collections.defaultdict(int)\\n        for k in range(minSize,minSize+1):\\n            counter = collections.Counter(s[:k])\\n            \\n            for i in range(k,len(s)):\\n                #print(counter)\\n                if len(counter.keys())<=maxLetters:\\n                    res[s[i-k:i]] += 1\\n                counter[s[i]] += 1\\n                counter[s[i-k]] -= 1\\n                if counter[s[i-k]] == 0:\\n                    del counter[s[i-k]]\\n            #print(counter)\\n            \\n            if len(counter.keys())<=maxLetters:\\n                res[s[i-k+1:]] += 1\\n        #print(res)\\n        return max(res.values()) if res else 0\", \"from collections import Counter\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        ## greed algorithm: only focus the substring with length == minSize\\n        ## also, apply continuous hashing function \\n        power = 26 ** (minSize-1)\\n        cnt = Counter()\\n        word_cnt = Counter()\\n        cur_hash = 0\\n        left = 0\\n        res = 0\\n        right = 0\\n        while right<minSize:\\n            cnt[s[right]] += 1  \\n            cur_hash = cur_hash*26 + (ord(s[right]) - ord('a') + 1)\\n            right += 1\\n            \\n        word_cnt[cur_hash] = 1\\n        while right<len(s):\\n            if right-left+1>minSize:\\n                cnt[s[left]] -= 1\\n                if cnt[s[left]] == 0:\\n                    del cnt[s[left]]\\n                cur_hash = cur_hash-power*(ord(s[left]) - ord('a') + 1)\\n                left += 1\\n            \\n            cnt[s[right]] += 1  \\n            cur_hash = cur_hash*26 + (ord(s[right]) - ord('a') + 1)\\n            \\n            if len(cnt)<=maxLetters and right-left+1==minSize:\\n                word_cnt[cur_hash] += 1\\n                res = max(res, word_cnt[cur_hash])\\n                \\n            right += 1\\n            \\n        return res\\n# \\\\\\\"aababcaab\\\\\\\"\\n# 2\\n# 3\\n# 4\\n# \\\\\\\"aaaa\\\\\\\"\\n# 1\\n# 3\\n# 3\\n# \\\\\\\"aabcabcab\\\\\\\"\\n# 2\\n# 2\\n# 3\\n# \\\\\\\"abcde\\\\\\\"\\n# 2\\n# 3\\n# 3\\n                \\n\", \"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        tracker = collections.defaultdict(int)\\n        \\n        window_tracker = collections.defaultdict(int)\\n        curr_sum = 0\\n        \\n        i = 0\\n        j = 0\\n        \\n        while j < len(s):\\n            curr = s[j]\\n            window_tracker[curr] += 1\\n            curr_sum += 1\\n            \\n            # while i < j and (len(window_tracker.keys()) > maxLetters and curr_sum > minSize):\\n            while i < j and curr_sum > minSize:\\n                curr_i = s[i]\\n                curr_sum -= 1\\n                window_tracker[curr_i] -= 1\\n                if window_tracker[curr_i] == 0:\\n                    del window_tracker[curr_i]\\n                i += 1\\n            \\n            temp = collections.defaultdict(int)\\n            toAdd = s[i:j + 1]\\n            for char in toAdd:\\n                temp[char] += 1\\n            \\n            if minSize <= curr_sum <= maxSize and len(temp.keys()) <= maxLetters:\\n                tracker[s[i: j + 1]] += 1\\n            \\n            j += 1\\n        \\n        print(tracker)\\n        if len(tracker.values()) == 0:\\n            return 0\\n        return max(tracker.values())\", \"from collections import Counter, deque\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        substring = deque([])\\n        ans = Counter([])\\n        for ch in s:\\n            substring.append(ch)\\n            while len(substring) > minSize:\\n                substring.popleft()\\n            cnt = Counter(substring)\\n            if (len(cnt) <= maxLetters) and (minSize <= len(substring) <= maxSize):\\n                ans.update({''.join(substring): 1})\\n        \\n        return ans.most_common()[0][1] if len(ans) > 0 else 0\\n\"]", "input_output": "{\"fn_name\": \"maxFreq\", \"inputs\": [[\"\\\"aababcaab\\\"\", 2, 3, 4]], \"outputs\": [2]}", "difficulty": "interview", "url": "https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/", "starter_code": "\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        "}
{"id": 127, "question": "There is a group of\u00a0G members, and a list of various crimes they could commit.\nThe ith\u00a0crime generates a profit[i] and requires group[i]\u00a0members to participate in it.\nIf a\u00a0member participates in one crime, that member can't participate in another crime.\nLet's call a profitable\u00a0scheme\u00a0any subset of these crimes that generates at least P profit, and the total number of\u00a0members participating in that subset of crimes is at most G.\nHow many schemes can be chosen?\u00a0 Since the answer may be very\u00a0large, return it modulo 10^9 + 7.\n\u00a0\nExample 1:\nInput: G = 5, P = 3, group = [2,2], profit = [2,3]\nOutput: 2\nExplanation: \nTo make a profit of at least 3, the group could either commit crimes 0 and 1, or just crime 1.\nIn total, there are 2 schemes.\n\n\nExample 2:\nInput: G = 10, P = 5, group = [2,3,5], profit = [6,7,8]\nOutput: 7\nExplanation: \nTo make a profit of at least 5, the group could commit any crimes, as long as they commit one.\nThere are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).\n\n\u00a0\n\nNote:\n\n1 <= G <= 100\n0 <= P <= 100\n1 <= group[i] <= 100\n0 <= profit[i] <= 100\n1 <= group.length = profit.length <= 100", "solutions": "[\"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        group_len, profit_len = len(group),len(profit)\\n        dp = [[0]*(G+1) for _ in range(P+1)]\\n        dp[0][0] = 1\\n        for pro, gro in zip(profit,group):\\n            dp2 = [x[:] for x in dp]\\n            for p1 in range(P+1):\\n                p = min(pro + p1,P)\\n                for g1 in range(G+1-gro):\\n                    g = g1 + gro\\n                    dp2[p][g] += dp[p1][g1]\\n                    dp2[p][g] %= MOD\\n            dp = dp2\\n        return sum(dp[-1]) %MOD\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        cur = [[0] * (G + 1) for _ in range(P + 1)]\\n        cur[0][0] = 1\\n\\n        for p0, g0 in zip(profit, group):\\n            # p0, g0 : the current crime profit and group size\\n            cur2 = [row[:] for row in cur]\\n            for p1 in range(P + 1):\\n                # p1 : the current profit\\n                # p2 : the new profit after committing this crime\\n                p2 = min(p1 + p0, P)\\n                for g1 in range(G - g0 + 1):\\n                    # g1 : the current group size\\n                    # g2 : the new group size after committing this crime\\n                    g2 = g1 + g0\\n                    cur2[p2][g2] += cur[p1][g1]\\n                    cur2[p2][g2] %= MOD\\n            cur = cur2\\n        # Sum all schemes with profit P and group size 0 <= g <= G.\\n        return sum(cur[-1]) % MOD\\n\", \"class Solution:\\n    def profitableSchemes(self, G, P, group, profit):\\n        dp = [[0] * (G + 1) for i in range(P + 1)]\\n        dp[0][0] = 1\\n        for p, g in zip(profit, group):\\n            for i in range(P, -1, -1):\\n                for j in range(G - g, -1, -1):\\n                    dp[min(i + p, P)][j + g] += dp[i][j]\\n        return sum(dp[P]) % (10**9 + 7)\\n    # def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n    #     schemes=[(pro, kitnelog) for pro, kitnelog in zip(profit, group)]\\n    #     nonlocal dump\\n    #     dump={}\\n    #     nonlocal dump1\\n    #     dump1={}\\n    #     return self.getans(G, P, schemes)\\n    # def getans(self, g, p, schemes, mod=(10**9+7)):\\n    #     nonlocal dump\\n    #     nonlocal dump1\\n    #     if len(schemes)==0:\\n    #         if p<=0:\\n    #             return 1\\n    #         return 0\\n    #     if g<=0 and p>0:\\n    #         return 0\\n    #     if p<=0:\\n    #         return self.numsubsetslessthan(g, schemes)\\n    #     if (g, p, len(schemes)) in dump:\\n    #         return dump[(g, p, len(schemes))]\\n    #     a=self.getans(g-schemes[-1][1], p-schemes[-1][0], schemes[:-1]) if g>=schemes[-1][1] else 0\\n    #     b=self.getans(g, p, schemes[:-1])\\n    #     dump[(g, p, len(schemes))]=(a+b)%mod\\n    #     return dump[(g, p, len(schemes))]\\n    # def numsubsetslessthan(self, g, schemes, mod=10**9+7):\\n    #     nonlocal dump1\\n    #     if len(schemes)==0:\\n    #         return 1\\n    #     if (g, len(schemes)) in dump1:\\n    #         return dump1[(g, len(schemes))]\\n    #     a=self.numsubsetslessthan(g-schemes[-1][1], schemes[:-1]) if g>=schemes[-1][1] else 0\\n    #     b=self.numsubsetslessthan(g, schemes[:-1])\\n    #     dump1[(g, len(schemes))]=(a+b)%mod\\n    #     return dump1[(g, len(schemes))]\\n\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        memo = [[0] * (G + 1) for _ in range(P + 1)]\\n        memo[0][0] = 1\\n        for p, g in zip(profit, group):\\n            for i in reversed(range(P + 1)):\\n                for j in reversed(range(G + 1 - g)):\\n                    memo[min(i + p, P)][j + g] += memo[i][j]\\n        return sum(memo[-1]) % (10 ** 9 + 7)\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        memo =[[0]*(G+1) for _ in range(P+1)]\\n        memo[0][0]=1\\n        for p,g in zip(profit,group):\\n            for i in range(P,-1,-1):\\n                for j in range(G-g,-1,-1):\\n                    memo[min(P,p+i)][j+g] += memo[i][j]\\n        return sum(memo[P])%(10**9+7)\\n\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        mod = 10 ** 9 + 7\\n        n = len(group)\\n        dp = [[0] * (G + 1) for _ in range(P + 1)]\\n        dp[0][0] = 1\\n        for g, p in zip(group, profit):\\n            for i in range(P, -1, -1):\\n                for j in range(G - g, -1, -1):\\n                    dp[min(i + p, P)][j + g] += dp[i][j]\\n        return sum(dp[-1]) % mod\\n        \\n        \\n        \\n        # n = len(group)\\n        # dp = [[0, 0]]\\n        # ans = 0\\n        # for i, (g, p) in enumerate(zip(group, profit)):\\n        #     dp2 = []\\n        #     for pro, num in dp:\\n        #         if num + g <= G and pro + p < P:\\n        #             dp2.append([pro + p, num + g])\\n        #         elif num + g <= G and pro + p >= P:\\n        #             rem = G - num - g\\n        #             ans += 2 ** (n - i - 1)\\n        #     dp += dp2\\n        # return ans % mod\\n\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        dp = [[0] * (G + 1) for i in range(P + 1)]\\n        dp[0][0] = 1\\n        for p, g in zip(profit, group):\\n            for i in range(P, -1, -1):\\n                for j in range(G - g, -1, -1):\\n                    dp[min(i + p, P)][j + g] += dp[i][j]\\n        return sum(dp[P]) % (10**9 + 7)\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        dp = [[0]*(G+1) for _ in range(P+1)]\\n        \\n        dp[0][0] = 1\\n        # for i in range(G+1):\\n        #     dp[0][i] = 1\\n        \\n        for i in range(len(profit)):\\n            p = profit[i]\\n            g = group[i]\\n            for i in range(P, -1, -1):\\n                for j in range(G-g, -1, -1):\\n                    dp[min(P, i + p)][j+g] += dp[i][j]\\n                    \\n        return sum(dp[-1]) % (10**9 + 7)\\n\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        mod = 10 ** 9 + 7\\n        n = len(group)\\n        dp = [[0] * (G + 1) for _ in range(P + 1)]\\n        dp[0][0] = 1\\n        # Key point is to iterate reversely, like knapsack problem\\n        for g, p in zip(group, profit):\\n            for i in range(P, -1, -1):\\n                for j in range(G - g, -1, -1):\\n                    dp[min(i + p, P)][j + g] += dp[i][j]\\n        return sum(dp[-1]) % mod\\n\", \"class Solution:    \\n    def profitableSchemes(self, G, P, group, profit):\\n        dp = [[0] * (G + 1) for i in range(P + 1)]\\n        dp[0][0] = 1\\n        for p_gained, g_needed in zip(profit, group):\\n            ndp = [[0] * (G + 1) for i in range(P + 1)]\\n            for p in range(P + 1):\\n                for g in range(0, G + 1):\\n                    ndp[p][g] += dp[p][g]\\n                    if g >= g_needed:\\n                        ndp[p][g] += dp[max(p - p_gained, 0)][g - g_needed]\\n            dp = ndp\\n        return sum(dp[P]) % (10**9 + 7)\\n\\n    def profitableSchemes(self, G, P, group, profit):\\n        dp = [[0] * (G + 1) for i in range(P + 1)]\\n        #dp[0] = [1] * (G + 1) #<-----\\n        dp[0][0] = 1\\n        for p_gained, g_needed in zip(profit, group):\\n            for p in range(P, -1, -1):\\n                for g in range(G, g_needed - 1, -1):\\n                    dp[p][g] += dp[max(p - p_gained, 0)][g - g_needed]\\n        return sum(dp[P]) % (10**9 + 7)\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        dp = [[0]*(G+1) for _ in range(P+1)]\\n        dp[0][0] = 1\\n        \\n        for p, g in zip(profit, group):\\n            for i in range(P, -1, -1):\\n                for j in range(G-g, -1, -1):\\n                    if i+p>=P:\\n                        dp[P][j+g] += dp[i][j]\\n                    else:\\n                        dp[i+p][j+g] += dp[i][j]\\n                        \\n        return sum(dp[P])%(10**9+7)\", \"class Solution:\\n    def profitableSchemes(self, G, P, group, profit):\\n        dp = [[0] * (G + 1) for i in range(P + 1)]\\n        dp[0][0] = 1\\n        for p, g in zip(profit, group):\\n            dp2=[i[:] for i in dp]\\n            for i in range(P, -1, -1):\\n                for j in range(G - g, -1, -1):\\n                    dp2[min(i + p, P)][j + g] += dp[i][j]\\n            dp=dp2\\n        return sum(dp[P]) % (10**9 + 7)\\n    # def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n    #     schemes=[(pro, kitnelog) for pro, kitnelog in zip(profit, group)]\\n    #     nonlocal dump\\n    #     dump={}\\n    #     nonlocal dump1\\n    #     dump1={}\\n    #     return self.getans(G, P, schemes)\\n    # def getans(self, g, p, schemes, mod=(10**9+7)):\\n    #     nonlocal dump\\n    #     nonlocal dump1\\n    #     if len(schemes)==0:\\n    #         if p<=0:\\n    #             return 1\\n    #         return 0\\n    #     if g<=0 and p>0:\\n    #         return 0\\n    #     if p<=0:\\n    #         return self.numsubsetslessthan(g, schemes)\\n    #     if (g, p, len(schemes)) in dump:\\n    #         return dump[(g, p, len(schemes))]\\n    #     a=self.getans(g-schemes[-1][1], p-schemes[-1][0], schemes[:-1]) if g>=schemes[-1][1] else 0\\n    #     b=self.getans(g, p, schemes[:-1])\\n    #     dump[(g, p, len(schemes))]=(a+b)%mod\\n    #     return dump[(g, p, len(schemes))]\\n    # def numsubsetslessthan(self, g, schemes, mod=10**9+7):\\n    #     nonlocal dump1\\n    #     if len(schemes)==0:\\n    #         return 1\\n    #     if (g, len(schemes)) in dump1:\\n    #         return dump1[(g, len(schemes))]\\n    #     a=self.numsubsetslessthan(g-schemes[-1][1], schemes[:-1]) if g>=schemes[-1][1] else 0\\n    #     b=self.numsubsetslessthan(g, schemes[:-1])\\n    #     dump1[(g, len(schemes))]=(a+b)%mod\\n    #     return dump1[(g, len(schemes))]\\n\", \"class Solution:\\n    def profitableSchemes(self,G, P, group, profit):\\n        dp = [[1]+[0]*G] + [[0]*(G+1) for _ in range(P)]\\n        for p, g in zip(profit, group):\\n            for i in range(P,-1,-1):\\n                for j in range(G-g,-1,-1):\\n                    dp[min(P,i+p)][g+j] += dp[i][j]\\n        return (sum(dp[P]) % (10**9+7))\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        m = 10 ** 9 + 7\\n        cur = [[0] * (G+1) for _ in range(P+1)]\\n        cur[0][0] = 1\\n        for p0, g0 in zip(profit, group):\\n            for p1 in range(P, -1, -1):\\n                for g1 in range(G, g0-1, -1):\\n                    cur[p1][g1] += cur[max(0, p1 - p0)][g1-g0]\\n        \\n        return sum(cur[-1]) % m\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        # Dynamic Programming\\n        # Time  complexity: O(N x P x G), where N is the number of crimes available to the gang.\\n        # Space complexity: O(P x G)\\n        # MOD = 10**9 + 7\\n        # cur = [[0] * (G + 1) for _ in range(P + 1)]\\n        # cur[0][0] = 1\\n\\n        # for p0, g0 in zip(profit, group):\\n        #     cur2 = [row[:] for row in cur]\\n        #     for p1 in range(P + 1):\\n        #         p2 = min(p1 + p0, P)\\n        #         for g1 in range(G - g0 + 1):\\n        #             g2 = g1 + g0\\n        #             cur2[p2][g2] += cur[p1][g1]\\n        #             cur2[p2][g2] %= MOD\\n        #     cur = cur2\\n\\n        # return sum(cur[-1]) % MOD\\n\\n\\n        MOD = 10**9 + 7\\n        dp = [[0] * (G + 1) for _ in range(P + 1)]\\n        dp[0][0] = 1\\n        for p, g in zip(profit, group):\\n            for i in range(P, -1, -1):\\n                for j in range(G - g, -1, -1):\\n                    dp[min(P, i + p)][g + j] += dp[i][j]\\n\\n        return sum(dp[P]) % MOD\\n\", \"class Solution(object):\\n    def profitableSchemes(self, G, P, group, profit):       \\n        mod = 10**9+7\\n        dp = [[0 for _ in range(G+1)] for _ in range(P+1)] \\n        dp[0][0]=1\\n        for g,p in zip(group,profit):\\n            cur = [row[:] for row in dp]\\n            for g_pre in range(G-g+1):\\n                for p_pre in range(P+1):\\n                    p_now = min(P,p_pre+p)\\n                    cur[p_now][g_pre+g]+=dp[p_pre][g_pre]\\n            dp = cur\\n            \\n        return sum(dp[-1])%mod\\n            \\n\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        # knapsack dp\\n        # dp[g][p]= n means we have n combinations for we used g people left and made p profit\\n        \\n        dp = [[0]*(P+1) for i in range(G+1)]\\n        dp[0][0] = 1\\n        \\n        for g,p in zip(group,profit):\\n            for i in range(G-g,-1,-1):\\n                for j in range(P,-1,-1):\\n                    dp[i+g][min(j+p,P)]+=dp[i][j]\\n            #print(dp)\\n        res = 0\\n        for i in range(G+1):\\n            res+=dp[i][-1]\\n        return res%(10**9+7)\\n                    \\n\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        M = pow(10, 9) + 7\\n        \\n        dp = [[0] * (P + 1) for _ in range(G + 1)]\\n        dp[0][0] = 1\\n        \\n        for k in range(len(group)):\\n            gro = group[k]\\n            pro = profit[k]\\n            \\n            for i in range(G - gro, -1, -1):\\n                for j in range(P, -1, -1):\\n                    g = i + gro\\n                    p = min(P, j + pro)\\n                    dp[g][p] += dp[i][j]\\n        \\n        res = 0\\n        for i in range(G+1):\\n            res += dp[i][P]\\n        return res % M\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        \\n        # dp[g][p][c], ways for consider c_th crime, with g gangs to achieve profit p\\n        C = len(profit)\\n        dp = [[[0] * (C + 1) for _ in range(P + 1)] for _ in range(G + 1)]\\n        \\n        for g in range(G + 1):\\n            dp[g][0][0] = 1\\n        \\n        for g in range(0, G + 1):\\n            for p in range(0, P + 1):\\n                for c, [hand_needed, p_gained] in enumerate(zip(group, profit), 1):\\n                    dp[g][p][c] = dp[g][p][c - 1]\\n                    if hand_needed <= g:\\n                        prev_at_least = max(0, p - p_gained)\\n                        dp[g][p][c] += dp[g - hand_needed][prev_at_least][c - 1]\\n                    dp[g][p][c] = dp[g][p][c] % 1000000007\\n        \\n        return dp[G][P][-1] % 1000000007\\n\\n    '''\\n    def profitableSchemes(self, G, P, group, profit):\\n        dp = [[0] * (G + 1) for i in range(P + 1)]\\n        dp[0][0] = 1\\n        for p, g in zip(profit, group):\\n            for i in range(P, -1, -1):\\n                for j in range(G - g, -1, -1):\\n                    dp[min(i + p, P)][j + g] += dp[i][j]\\n        return sum(dp[P]) % (10**9 + 7)\\n    '''\\n    \\n    def profitableSchemes(self, G, P, group, profit):\\n        dp = [[0] * (G + 1) for i in range(P + 1)]\\n        dp[0][0] = 1\\n        for p, g in zip(profit, group):\\n            for i in range(P, -1, -1):\\n                for j in range(G - g, -1, -1):\\n                    dp[min(i + p, P)][j + g] += dp[i][j]\\n        return sum(dp[P]) % (10**9 + 7)\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        M = 10**9 + 7\\n        cur = [[0]*(G+1) for _ in range(P+1)]\\n        cur[0][0] = 1\\n        for p0,g0 in zip(profit,group):\\n            cur2 = [row[:] for row in cur]\\n            for p1 in range(P+1):\\n                p2 = min(p1+p0,P)\\n                for g1 in range(G-g0+1):\\n                    g2 = g1+g0\\n                    cur2[p2][g2] += cur[p1][g1]\\n                    cur2[p2][g2] %= M\\n            cur = cur2\\n        return sum(cur[-1])%M\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        MOD = 10 ** 9 + 7\\n        dp = [[0] * (P + 1) for i in range(G + 1)]\\n        for i in range(G + 1):\\n            dp[i][0] = 1\\n        for g, p in zip(group, profit):\\n            dp2 = [row[:] for row in dp]\\n            for g1 in range(g, G + 1):\\n                for p1 in range(P + 1):\\n                    dp2[g1][p1] = (dp2[g1][p1] + dp[g1 - g][max(0, p1 - p)]) % MOD\\n            dp = dp2\\n        return dp[G][P]\", \"from functools import lru_cache\\nclass Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        \\n        C = len(group)\\n        MOD = pow(10, 9) + 7\\n        \\n        # @lru_cache(None)\\n        # def dp(c, p, g):\\n        #     if c == 0:\\n        #         return 1 if p == 0 else 0\\n        #     result = dp(c-1, p, g)\\n        #     if g >= group[c-1]:\\n        #         result += dp(c-1, max(0, p-profit[c-1]), g-group[c-1])\\n        #     result %= MOD\\n        #     return result\\n        # return dp(C, P, G)\\n    \\n        dp = [[0] * (P+1) for _ in range(G+1)]\\n        dp[0][0] = 1\\n        for c in range(1, C+1):\\n            g = group[c-1]\\n            p = profit[c-1]\\n            for i in range(G, g-1, -1):\\n                for j in range(P, -1, -1):\\n                    #print(i, j, i-g, max(0, j-p))\\n                    dp[i][j] = (dp[i][j] + dp[i-g][max(0, j-p)]) % MOD\\n\\n        return sum(dp[i][P] for i in range(G+1)) % MOD\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        n, M = len(group), 10**9 + 7\\n        dp = [[0]*(P+1) for _ in range(G+1)] # dp[i][j] is the # of schemes of i people and j profit\\n        dp[0][0] = 1\\n        for k in range(1, n+1):\\n            g, p = group[k-1], profit[k-1]\\n            for i in range(G, g-1, -1):\\n                for j in range(P, -1, -1):\\n                    dp[i][j] = (dp[i][j] + dp[i-g][max(0, j-p)]) % M\\n        \\n        res = 0\\n        for i in range(G+1):\\n            res = (res + dp[i][P]) % M\\n        \\n        return res\", \"from functools import lru_cache\\nclass Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        \\n        C = len(group)\\n        MOD = pow(10, 9) + 7\\n        \\n        # @lru_cache(None)\\n        # def dp(c, p, g):\\n        #     if c == 0:\\n        #         return 1 if p == 0 else 0\\n        #     result = dp(c-1, p, g)\\n        #     if g >= group[c-1]:\\n        #         result += dp(c-1, max(0, p-profit[c-1]), g-group[c-1])\\n        #     result %= MOD\\n        #     return result\\n        # return dp(C, P, G)\\n    \\n        dp = [[0] * (P+1) for _ in range(G+1)]\\n        dp[0][0] = 1\\n        for c in range(1, C+1):\\n            g = group[c-1]\\n            p = profit[c-1]\\n            for i in range(G, g-1, -1):\\n                for j in range(P, -1, -1):\\n                    #print(i, j, i-g, max(0, j-p))\\n                    dp[i][j] = dp[i][j] + dp[i-g][max(0, j-p)] % MOD\\n\\n        return sum(dp[i][P] for i in range(G+1)) % MOD\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        count_dict = {}\\n        base = int(1e9 + 7)\\n        for groupi, profiti in zip(group, profit):\\n            if groupi > G or groupi <= 0:\\n                continue\\n            tmp_dict = count_dict.copy()\\n            for (groupj, profitj), count in tmp_dict.items():\\n                if groupj + groupi <= G:\\n                    if profiti + profitj >= P:\\n                        count_dict[(groupi + groupj, P)] = count_dict.get((groupi + groupj, P), 0) + count % base\\n                    else:\\n                        count_dict[(groupi + groupj, profiti + profitj)] = count_dict.get((groupi + groupj, profiti + profitj), 0) + count % base\\n            if profiti >= P:\\n                count_dict[(groupi, P)] = count_dict.get((groupi, P), 0) + 1\\n            else:\\n                count_dict[(groupi, profiti)] = count_dict.get((groupi, profiti), 0) + 1\\n        out = 0\\n        for (groupi, profiti), count in count_dict.items():\\n            if profiti >= P:\\n                out += count\\n        return out % base\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        m = 10**9 + 7\\n        table = [[0] * (G+1) for _ in range(P+1)]\\n        table[0][0] = 1\\n        # table[p][g] to index\\n        \\n        for g, p in zip(group, profit):\\n            for pi in range(P, -1, -1):\\n                for gi in range(G - g, -1, -1):\\n                    new_pi = min(P, pi + p)\\n                    table[new_pi][gi+g] = (table[new_pi][gi+g] + table[pi][gi]) % m\\n \\n        total = 0\\n        for x in table[P]:\\n            total = (total + x) % m\\n\\n        return total\\n\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        \\n        \\n        dp = [[0] * (G+1) for i in range(P+1)]\\n        dp[0][0] = 1\\n        n = len(group)\\n        for k in range(n):\\n            g, p = group[k], profit[k]\\n            for i in range(P, -1, -1):\\n                for j in range(G-g, -1, -1):\\n                    dp[min(i+p, P)][j+g] += dp[i][j]\\n        return sum(dp[P]) % (10 ** 9 + 7)\\n            \\n            \\n         \\n#         n = len(group)\\n#         dp = {\\\\\\\"\\\\\\\":(0, 0)}\\n#         count = 0\\n#         for i in range(n):\\n#             g, p = group[i], profit[i]\\n#             if g <= G:\\n#                 for k, v in list(dp.items()):\\n#                     pg, pp = v\\n#                     if pg + g <= G:\\n#                         if pp + p >= P:\\n#                             count += 1\\n#                         dp[k+str(i)] = (pg+g, pp+p)\\n#         return count % (10**9+7)\\n            \\n            \\n        \\n        \\n\", \"class Solution(object):\\n    def profitableSchemes(self, G, P, group, profit):\\n        MOD = 10**9 + 7\\n        cur = [[0] * (G + 1) for _ in range(P + 1)]\\n        cur[0][0] = 1\\n\\n        for p0, g0 in zip(profit, group):\\n            # p0, g0 : the current crime profit and group size\\n            cur2 = [row[:] for row in cur]\\n            for p1 in range(P + 1):\\n                # p1 : the current profit\\n                # p2 : the new profit after committing this crime\\n                p2 = min(p1 + p0, P)\\n                for g1 in range(G - g0 + 1):\\n                    # g1 : the current group size\\n                    # g2 : the new group size after committing this crime\\n                    g2 = g1 + g0\\n                    cur2[p2][g2] += cur[p1][g1]\\n                    cur2[p2][g2] %= MOD\\n            cur = cur2\\n\\n        # Sum all schemes with profit P and group size 0 <= g <= G.\\n        return sum(cur[-1]) % MOD\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        \\n        # You have to find what is consecutive. In this problem, the choices of groups are scattered.\\n        dp = [[0] * (G+1) for i in range(P+1)]\\n        dp[0][0] = 1\\n        n = len(group)\\n        for k in range(n):\\n            g, p = group[k], profit[k]\\n            for i in range(P, -1, -1):\\n                for j in range(G-g, -1, -1):\\n                    dp[min(i+p, P)][j+g] += dp[i][j]\\n        return sum(dp[P]) % (10 ** 9 + 7)\\n            \\n            \\n         \\n#         n = len(group)\\n#         dp = {\\\\\\\"\\\\\\\":(0, 0)}\\n#         count = 0\\n#         for i in range(n):\\n#             g, p = group[i], profit[i]\\n#             if g <= G:\\n#                 for k, v in list(dp.items()):\\n#                     pg, pp = v\\n#                     if pg + g <= G:\\n#                         if pp + p >= P:\\n#                             count += 1\\n#                         dp[k+str(i)] = (pg+g, pp+p)\\n#         return count % (10**9+7)\\n            \\n            \\n        \\n        \\n\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        \\n        # dp[g][p][c], ways for consider c_th crime, with g gangs to achieve profit p\\n        C = len(profit)\\n        dp = [[[0] * (C + 1) for _ in range(P + 1)] for _ in range(G + 1)]\\n        \\n        for g in range(G + 1):\\n            dp[g][0][0] = 1\\n        \\n        for g in range(0, G + 1):\\n            for p in range(0, P + 1):\\n                for c, [hand_needed, p_gained] in enumerate(zip(group, profit), 1):\\n                    dp[g][p][c] = dp[g][p][c - 1]\\n                    if hand_needed <= g:\\n                        prev_at_least = max(0, p - p_gained)\\n                        dp[g][p][c] += dp[g - hand_needed][prev_at_least][c - 1]\\n                    dp[g][p][c] = dp[g][p][c] % 1000000007\\n        \\n        return dp[G][P][-1] % 1000000007\\n\\n    '''\\n    def profitableSchemes(self, G, P, group, profit):\\n        dp = [[0] * (G + 1) for i in range(P + 1)]\\n        dp[0][0] = 1\\n        for p, g in zip(profit, group):\\n            for i in range(P, -1, -1):\\n                for j in range(G - g, -1, -1):\\n                    dp[min(i + p, P)][j + g] += dp[i][j]\\n        return sum(dp[P]) % (10**9 + 7)\\n    '''\\n    \\n    def profitableSchemes(self, G, P, group, profit):\\n        dp = [[0] * (G + 1) for i in range(P + 1)]\\n        dp[0][0] = 1\\n        for p_gained, g_needed in zip(profit, group):\\n            ndp = [[0] * (G + 1) for i in range(P + 1)]\\n            for p in range(P + 1):\\n                for g in range(0, G + 1):\\n                    ndp[p][g] += dp[p][g]\\n                    if g >= g_needed:\\n                        ndp[p][g] += dp[max(p - p_gained, 0)][g - g_needed]\\n            dp = ndp\\n        return sum(dp[P]) % (10**9 + 7)\\n\\n    def profitableSchemes(self, G, P, group, profit):\\n        dp = [[0] * (G + 1) for i in range(P + 1)]\\n        dp[0][0] = 1\\n        for p_gained, g_needed in zip(profit, group):\\n            for p in range(P, -1, -1):\\n                for g in range(G, g_needed - 1, -1):\\n                    dp[p][g] += dp[max(p - p_gained, 0)][g - g_needed]\\n        return sum(dp[P]) % (10**9 + 7)\", \"mod_ = 10**9 + 7\\n\\nclass Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        axis_group = G+1\\n        axis_profit = P+1 # sum(profit) + 1\\n        n_profit = len(profit)\\n        \\n        mat = [[0 for p in range(axis_profit)] for g in range(axis_group)]\\n        mat[0][0] = 1\\n        \\n        for pos, cur_profit in enumerate(profit):\\n            cur_people = group[pos]\\n            for g in range(axis_group-1, cur_people-1, -1):\\n                for p in range(cur_profit + axis_profit-1, cur_profit-1, -1):\\n                    p2 = min(axis_profit-1, p)\\n                    mat[g][p2] =  (mat[g][p2] + mat[g-cur_people][p-cur_profit]) % mod_\\n                    \\n        count = 0\\n        for row in mat:\\n            count = (count + sum(row[P:])) % mod_\\n        return count\", \"MOD = int(10**9 + 7)\\n\\nclass Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        n = len(group)\\n        dp = (128*101)*[0]\\n        dp[0] = 1\\n        for g,p in zip(group,profit):\\n            old = dp.copy()\\n            for h in range(0,G-g+1):\\n                for q in range(P+1):\\n                    x = (h+g)<<7 | min(p+q,P)\\n                    y = dp[x]\\n                    y += old[h<<7 | q]\\n                    if y > MOD:\\n                        y -= MOD\\n                    dp[x] = y\\n            #print(*[(i,x) for i,x in enumerate(dp) if x])\\n        return sum(dp[g<<7 | P] for g in range(G+1)) % MOD\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        mod = 10 ** 9 + 7\\n        # construct a dp matrix that row, col represents profit and group, entry is number of schemas\\n        dp = [[0] * (G+1) for _ in range(P+1)]\\n        dp[0][0] = 1\\n        for g0, p0 in zip(group, profit):\\n            # copy previous dp\\n            dp2 = [row[:] for row in dp]\\n            for p1 in range(P+1):\\n                # all schemas >= P will be put in Pth row\\n                p2 = min(P, p1 + p0)\\n                for g1 in range(G - g0 + 1):\\n                    g2 = g1 + g0\\n                    dp2[p2][g2] += dp[p1][g1]\\n                    dp2[p2][g2] %= mod\\n            dp = dp2\\n        \\n        return sum(dp[-1]) % mod\\n\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        MOD = 10 ** 9 + 7\\n        # @lru_cache(None)\\n        # def dp(i, g, p):\\n        #     if g < 0:\\n        #         return 0\\n        #     if i == n:\\n        #         return 1 if p == 0 else 0\\n        #     a = dp(i + 1, max(g - group[i], -1), max(0, p - profit[i]))\\n        #     b = dp(i + 1, g, p)\\n        #     return (a + b) % MOD\\n        dp = [[0] * (P + 1) for i in range(G + 1)]\\n        for i in range(G + 1):\\n            dp[i][0] = 1\\n        for g, p in zip(group, profit):\\n            dp2 = [[0] * (P + 1) for i in range(G + 1)]\\n            for g1 in range(G + 1):\\n                for p1 in range(P + 1):\\n                    dp2[g1][p1] = dp[g1][p1]\\n                    if g1 >= g:\\n                        dp2[g1][p1] = (dp2[g1][p1] + dp[g1 - g][max(0, p1 - p)]) % MOD\\n            dp = dp2\\n        return dp[G][P]\", \"class Solution:\\n     def profitableSchemes(self, G, P, group, profit):\\n        dp = [[0] * (G + 1) for i in range(P + 1)]\\n        dp[0][0] = 1\\n        for p, g in zip(profit, group):\\n            for i in range(P, -1, -1):\\n                for j in range(G - g, -1, -1):\\n                    dp[min(i + p, P)][j + g] += dp[i][j]\\n        return sum(dp[P]) % (10**9 + 7)\\n\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, groups: List[int], profits: List[int]) -> int:\\n        dp = [[0] * (P+1) for i in range(0,G+1)]\\n        for i in range(0, G+1):\\n            dp[i][0] = 1\\n        N = len(groups)\\n        l = []\\n        for i in range(0, N):\\n            l.append((groups[i], profits[i]))\\n        l.sort()\\n        \\n        for i in range(0, N):\\n            group, profit = l[i]\\n            if group > G:\\n                break\\n            for j in range(G, group - 1, -1):\\n                gremain = j - group\\n                for k in range(P, -1, -1):\\n                    dp[j][k] += dp[gremain][max(k - profit, 0)]\\n                    dp[j][k] %= (10**9 + 7)\\n                \\n        return dp[G][P]\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        M = 10**9 + 7\\n        dp = [[0]*(G+1) for _ in range(P+1)]\\n        dp[0][0] = 1\\n        for g, p in zip(group, profit):\\n            for i in range(P, -1, -1):\\n                for j in range(G-g, -1, -1):\\n                    dp[min(i+p, P)][j+g] = (dp[min(i+p, P)][j+g] + dp[i][j]) % M\\n        \\n        return sum(dp[P]) % M\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        cur = [[0] * (G + 1) for _ in range(P + 1)]\\n        cur[0][0] = 1\\n\\n        for p0, g0 in zip(profit, group):\\n            # p0, g0 : the current crime profit and group size\\n            cur2 = [row[:] for row in cur]\\n            for p1 in range(P + 1):\\n                # p1 : the current profit\\n                # p2 : the new profit after committing this crime\\n                p2 = min(p1 + p0, P)\\n                for g1 in range(G - g0 + 1):\\n                    # g1 : the current group size\\n                    # g2 : the new group size after committing this crime\\n                    g2 = g1 + g0\\n                    cur2[p2][g2] += cur[p1][g1]\\n                    cur2[p2][g2] %= MOD\\n            cur = cur2\\n\\n        # Sum all schemes with profit P and group size 0 <= g <= G.\\n        return sum(cur[-1]) % MOD\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        #dp[k][i][j]: # if schemes to achive i profit with j people by assigning first k tasks\\n        mod = 10 ** 9 + 7\\n        K = len(group)\\n        dp = [[[0] * (G + 1) for _ in range(P + 1)] for _ in range(K + 1)]\\n        \\n        dp[0][0][0] = 1\\n        \\n        for k in range(1, K + 1):\\n            p = profit[k - 1]\\n            g = group[k - 1]\\n            for i in range(P + 1):\\n                for j in range(G + 1):\\n                    dp[k][i][j] = dp[k - 1][i][j] \\n                    if j >= g:\\n                        dp[k][i][j] += dp[k - 1][max(0, i - p)][j - g] \\n        return sum(dp[K][P]) % mod\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        # gp = sorted(zip(group, profit))\\n        gp = list(zip(group, profit))\\n        # print(gp)\\n        dp = defaultdict(int)\\n        dp[(G, P)] = 1\\n        while gp:\\n            g, p = gp.pop()\\n            for (g0, p0), count in list(dp.items()):\\n                if g0 >= g:\\n                    prof_left = max(0, p0 - p)\\n                    dp[(g0 - g, prof_left)] += count\\n            # print(g, p)\\n            # print(dp)\\n        return sum([count for (g, p), count in list(dp.items()) if p == 0]) % ((10 ** 9) + 7)\\n                    \\n\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        Mod = 10**9+7\\n        l = len(group)\\n        f = [[[0]*(G+1) for i in range(P+1)] for j in range(2)]\\n        f[1][0][0] = 1\\n        for i in range(l):\\n            f[i%2] =[j[:] for j in f[(i-1)%2]]\\n            for p in range(P+1):\\n                for g in range(G+1-group[i]):\\n                    mp = min(P,profit[i]+p)\\n                    a,b = i%2,(i-1)%2\\n                    if g+group[i] <= G:\\n                        f[a][mp][g+group[i]] = (f[a][mp][g+group[i]]+f[b][p][g])%Mod\\n                    #     f[a][p][g] = (f[a][p][g]+f[b][p][g])%Mod\\n                    # else:\\n                    #     f[a][p][g] = (f[a][p][g]+f[b][p][g])%Mod\\n            # print(f[a])\\n        return sum(f[(l-1)%2][-1])%Mod\\n        Syn = sorted([(profit[i],group[i]) for i in range(l)])\\n        s,pre = 0,[]\\n        for p in Syn:\\n            s += p[0]\\n            pre.append(s)\\n        Memo = {}\\n        def dfs(g,p,i):\\n            if (g,p,i) in Memo:\\n                return Memo[g,p,i]\\n            if i == 0:\\n                if p <= 0:\\n                    Memo[g,p,i] = 1\\n                    if g >= Syn[i][1]:\\n                        Memo[g,p,i] += 1\\n                elif p > Syn[i][0]:\\n                    Memo[g,p,i] = 0\\n                else:\\n                    if g >= Syn[i][1]:\\n                        Memo[g,p,i] = 1\\n                    else:\\n                        Memo[g,p,i] = 0\\n                return Memo[g,p,i]\\n            if p > pre[i]:\\n                Memo[g,p,i] = 0\\n                return 0\\n            if g == 0 and p <= 0:\\n                Memo[g,p,i] = 1\\n                return 1\\n            if g-Syn[i][1] < 0:\\n                r = dfs(g,p,i-1)\\n            else:\\n                tmp = p-Syn[i][0] if p-Syn[i][0] >= 0 else 0\\n                r = (dfs(g-Syn[i][1],p-Syn[i][0],i-1)+dfs(g,p,i-1))%Mod\\n            Memo[g,p,i] = r\\n            return r\\n        dfs(G,P,l-1)\\n        # print(Memo)\\n        return Memo[G,P,l-1]\\n\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        mod = 10**9 + 7        \\n        DP = [[[0] * (P+1) for _ in range(G+1)] for _ in range(len(group)+1)]\\n        DP[0][0][0] = 1\\n        \\n        for k in range(1, len(group)+1):\\n            g = group[k-1]\\n            p = profit[k-1]\\n            for i in range(G+1):\\n                for j in range(P+1):\\n                    DP[k][i][j] = DP[k-1][i][j]\\n                    if i-g < 0:\\n                        continue\\n                    DP[k][i][j] = DP[k-1][i][j] + DP[k-1][i-g][max(0, j-p)]\\n        ans = 0\\n        for i in range(G+1):\\n            ans += DP[len(group)][i][P]%mod\\n        return ans%mod\\n        '''\\n        m = {}\\n        mod = 10**9 + 7\\n        def dfs(idx, g, p):\\n            if idx == 0:\\n                if (idx, g, p) == (0, 0, 0):\\n                    return 1\\n                return 0\\n            #if g <= 0:\\n            #    return 0\\n            if (idx, g, p) in m:\\n                return m[(idx, g, p)]\\n            res = 0\\n            res = (dfs(idx-1, g, p) + dfs(idx-1, g-group[idx-1], max(0, p-profit[idx-1])))%mod\\n            m[(idx, g, p)] = res\\n            return res\\n        ans = 0\\n        for i in range(G+1):\\n            ans += dfs(len(group), i, P)%mod\\n        return ans%mod\\n        '''\\n        '''\\n        m = {}\\n        \\n        def dfs(idx, g, p):\\n            res = 0\\n            if idx == 0:\\n                if g >= group[0] and profit[0] >= p:\\n                    res = 1\\n                return res\\n            if g <=0:\\n                return 0\\n            if p == 0:\\n                \\n            if (idx, g, p) in m:\\n                return m[(idx, g, p)]\\n            \\n            res = m[(idx-1, g, p)] + dfs(idx-1, g-group[idx], max(0, p-profit[idx]))\\n            m[(idx, g, p)] = res\\n            return res\\n        '''\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        \\n        # dp[g][p][c], ways for consider c_th crime, with g gangs to achieve profit p\\n        C = len(profit)\\n        dp = [[[0] * (C + 1) for _ in range(P + 1)] for _ in range(G + 1)]\\n        \\n        for g in range(G + 1):\\n            dp[g][0][0] = 1\\n        \\n        for g in range(0, G + 1):\\n            for p in range(0, P + 1):\\n                for c, [hand_needed, p_gained] in enumerate(zip(group, profit), 1):\\n                    dp[g][p][c] = dp[g][p][c - 1]\\n                    if hand_needed <= g:\\n                        prev_at_least = max(0, p - p_gained)\\n                        dp[g][p][c] += dp[g - hand_needed][prev_at_least][c - 1]\\n                    dp[g][p][c] = dp[g][p][c] % 1000000007\\n        \\n        return dp[G][P][-1] % 1000000007\\n\\n    '''\\n    def profitableSchemes(self, G, P, group, profit):\\n        dp = [[0] * (G + 1) for i in range(P + 1)]\\n        dp[0][0] = 1\\n        for p, g in zip(profit, group):\\n            for i in range(P, -1, -1):\\n                for j in range(G - g, -1, -1):\\n                    dp[min(i + p, P)][j + g] += dp[i][j]\\n        return sum(dp[P]) % (10**9 + 7)\\n    '''\\n    \\n    def profitableSchemes(self, G, P, group, profit):\\n        dp = [[0] * (G + 1) for i in range(P + 1)]\\n        dp[0][0] = 1\\n        for p_gained, g_needed in zip(profit, group):\\n            ndp = [[0] * (G + 1) for i in range(P + 1)]\\n            for p in range(P + 1):\\n                for g in range(0, G + 1):\\n                    ndp[p][g] += dp[p][g]\\n                    if g >= g_needed:\\n                        ndp[p][g] += dp[max(p - p_gained, 0)][g - g_needed]\\n            dp = ndp\\n        return sum(dp[P]) % (10**9 + 7)\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        Cnt = 0\\n        dp_ = [[0] * ( G + 1 ) for _ in range( P + 1)]\\n        dp_[0][0] = 1\\n        for i in range(1, len(group) + 1):\\n            for p in range(P, - 1, -1):\\n                for v in range(G-group[i-1], -1, -1):\\n                    dp_[min(p + profit[i-1], P)][v+group[i-1]] = (dp_[p][v] + dp_[min(p + profit[i-1], P)][v+group[i-1]])%MOD\\n        return sum(dp_[P])%MOD\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        n = len(profit)\\n        dp = [[[0 for g in range(G+1)] for p in range(P+1)] for i in range(1+n)]\\n        # NOTE: here p and g is not \\\\\\\"budget\\\\\\\", but actual value, to avoid duplication!\\n        \\n        # initialization: i = 0\\n        dp[0][0][0] = 1\\n\\n        \\n        # fill the restL i > 0\\n        for i in range(1, n+1):\\n            for p in range(P+1):\\n                for g in range(G+1):\\n                    # ending at ith crime with p profit lower limit and g group members upper limit\\n                    dp[i][p][g] = dp[i-1][p][g] # commit or not commit ith crime\\n                    if g >= group[i-1]:\\n                        dp[i][p][g] += dp[i-1][max(p-profit[i-1], 0)][g-group[i-1]]\\n\\n        result = 0\\n        for value in dp[n][P][:G+1]:\\n            result += value\\n        return result % (10**9 + 7)\", \"from functools import lru_cache\\nclass Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        ## bottom-up DP: https://www.youtube.com/watch?v=MjOIR61txFc\\n        M = 10**9+7\\n        dp = [[[0 for j in range(G+1)] for i in range(P+1)] for k in range(len(group)+1)]\\n        ## initialization\\n        dp[0][0][0] = 1\\n        \\n        for k in range(1, len(group)+1):\\n            for i in range(P+1):\\n                for j in range(G+1):\\n                    dp[k][i][j] = dp[k-1][i][j]\\n                    if j>=group[k-1]:\\n                        dp[k][i][j] += dp[k-1][max(0, i-profit[k-1])][j-group[k-1]]\\n        \\n        return sum(dp[len(group)][P]) % M\\n    \\n# 5\\n# 3\\n# [2,2]\\n# [2,3]\\n# 10\\n# 5\\n# [2,3,5]\\n# [6,7,8]\\n# 1\\n# 1\\n# [1,1,1,1,2,2,1,2,1,1]\\n# [0,1,0,0,1,1,1,0,2,2]\\n# 100\\n# 100\\n# [24,23,7,4,26,3,7,11,1,7,1,3,5,26,26,1,13,12,2,1,7,4,1,27,13,16,26,18,6,1,1,7,16,1,6,2,5,9,19,28,1,23,2,1,3,4,4,3,22,1,1,3,5,34,2,1,22,16,8,5,3,21,1,8,14,2,1,3,8,12,40,6,4,2,2,14,1,11,9,1,7,1,1,1,6,6,4,1,1,7,8,10,20,2,14,31,1,13,1,9]\\n# [5,2,38,25,4,17,5,1,4,0,0,8,13,0,20,0,28,1,22,7,10,32,6,37,0,11,6,11,23,20,13,13,6,2,36,1,0,9,4,5,6,14,20,1,13,6,33,0,22,1,17,12,10,1,19,13,8,1,0,17,20,9,8,6,2,2,1,4,22,11,3,2,6,0,40,0,0,7,1,0,25,5,12,7,19,4,12,7,4,4,1,15,33,14,2,1,1,61,4,5]\\n\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        # dp[i][p][g]: number of schemes with g groups and p profit from group[:i].\\n        \\n        dp = [[[0 for _ in range(G + 1)] for _ in range(P + 1)] for _ in range(len(group) + 1)]\\n        dp[0][0][0] = 1\\n        \\n        for i in range(1, len(group) + 1):\\n            for p in range(P + 1):\\n                for g in range(G + 1):\\n                    dp[i][p][g] += dp[i-1][p][g]\\n                    if g + group[i-1] < G + 1:\\n                        dp[i][min(p + profit[i-1], P)][g+group[i-1]] += dp[i-1][p][g]\\n\\n        return sum([dp[len(group)][P][g] for g in range(1, G + 1)]) % (10 ** 9 + 7)\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        cur = [[0] * (G + 1) for _ in range(P + 1)]\\n        cur[0][0] = 1\\n\\n        for p0, g0 in zip(profit, group):\\n            # p0, g0 : the current crime profit and group size\\n            cur2 = [row[:] for row in cur]\\n            for p1 in range(P + 1):\\n                # p1 : the current profit\\n                # p2 : the new profit after committing this crime\\n                p2 = min(p1 + p0, P)\\n                for g1 in range(G - g0 + 1):\\n                    # g1 : the current group size\\n                    # g2 : the new group size after committing this crime\\n                    g2 = g1 + g0\\n                    cur2[p2][g2] += cur[p1][g1]\\n                    cur2[p2][g2] %= MOD\\n            cur = cur2\\n\\n        # Sum all schemes with profit P and group size 0 <= g <= G.\\n        return sum(cur[-1]) % MOD\\n            \\n\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        # backpack problem\\n        \\n        # states: subset of schemes profit[1..i], rest members j.\\n        # dp[i][j][k]: number of schemes ending with i, with rest members j, and rest profit k.\\n        # transition:  dp[i][j][k] = sum_[l in 1..i-1](dp[l][j+group[j]][k+profit[i]]), k > 0\\n        #              dp[i][j][0] = sum_[l in 1..i-1; m in 0..profit[i]-1](dp[l][j+group[i]][m])\\n        # boundary: dp[0][G][P] = 1, dp[i][G][k] = 0\\n        \\n#         dp = [[[0 for _ in range(P+1)] for _ in range(G+1)] for _ in range(len(profit)+1)]\\n#         dp[0][-1][-1] = 1\\n                \\n#         mod = int(1e9+7)\\n#         for i in range(1, len(profit)+1):\\n#             for j in range(G-group[i-1], -1, -1):\\n#                 for k in range(P-profit[i-1], -profit[i-1]-1, -1):\\n#                     for l in range(i-1, -1, -1):\\n#                         dp[i][j][max(0, k)] = (dp[i][j][max(0, k)] + dp[l][j+group[i-1]][k+profit[i-1]]) % mod\\n                        \\n#         # print(dp)\\n#         res = 0\\n#         for i in range(1, len(profit)+1):\\n#             for j in range(G+1):\\n#                 res = (res + dp[i][j][0]) % mod\\n#         return res\\n                \\n\\n# ===================================  \\n# O(n^4) will cause TLE.\\n        \\n        # change k -> at most rest profit k; i -> for 1..i (not ending at)\\n        # transition: dp[i][j][k] = dp[i-1][j][k] -> not include profit[i]\\n        #                           + dp[i-1][j+group[i]][k+profit[i]] -> include profit[i]\\n        # boundary: dp[i][G][P] = 1, dp[i][G][k] = 0.\\n        \\n        dp = [[[0 for _ in range(P+1)] for _ in range(G+1)] for _ in range(len(profit)+1)]\\n        dp[0][-1][-1] = 1\\n        # for i in range(len(profit)+1):\\n        #     dp[i][-1][-1] = 1\\n        \\n        mod = int(1e9+7)\\n        for i in range(1, len(profit)+1):\\n            for j in range(G, -1, -1):\\n                for k in range(P, -1, -1):\\n                    dp[i][j][k] = dp[i-1][j][k]\\n                for k in range(P, -1, -1):\\n                    if j + group[i-1] <= G: # feasible\\n                        dp[i][j][k] = (dp[i][j][k] + dp[i-1][j+group[i-1]][min(k+profit[i-1], P)]) % mod\\n                        \\n        # print(dp)\\n        res = 0\\n        for j in range(G+1):\\n            res = (res + dp[-1][j][0]) % mod\\n        return res\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        n = len(group)\\n        \\n        @lru_cache(None)\\n        def dfs(i, g, p):         \\n            if g == 0:\\n                return 1 if p <= 0 else 0\\n            \\n            if i == n:\\n                return 1 if p <= 0 else 0\\n            \\n            ans = dfs(i+1, g, p)\\n            if group[i] <= g:\\n                ans += dfs(i+1, g-group[i], max(p-profit[i], 0))\\n                \\n            return ans % (10 ** 9 + 7)\\n        \\n        return dfs(0, G, P) % (10 ** 9 + 7)\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        MOD = 10 ** 9 + 7\\n        \\n        @lru_cache(None)\\n        def dp(i, g, p):\\n            if g < 0:\\n                return 0\\n            if i == n:\\n                return 1 if p == 0 else 0\\n            a = dp(i + 1, g - group[i], max(0, p - profit[i]))\\n            b = dp(i + 1, g, p)\\n            return (a + b) % MOD\\n        \\n        n = len(group)\\n        return dp(0, G, P)\", \"from functools import lru_cache\\nclass Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        @lru_cache(None)\\n        def sack(g,i,p):\\n            if i==len(profit) or g==0:\\n                return p>=P\\n            ans=0\\n            if group[i]<=g:\\n                ans=sack(g-group[i],i+1,min(P,p+profit[i]))\\n            return ans+sack(g,i+1,p)\\n        return sack(G,0,0)%(10**9+7)\", \"from functools import lru_cache\\nclass Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        @lru_cache(None)\\n        def dfs(index, curr_profit, members_left):\\n            if index == len(profit) or members_left == 0:\\n                return curr_profit == 0\\n        \\n            res = 0\\n            \\n            res += dfs(index + 1, curr_profit, members_left)\\n            if members_left - group[index] >= 0:\\n                res += dfs(index + 1, max(0,curr_profit - profit[index]), members_left - group[index])\\n\\n            return res % (10**9 + 7)\\n        \\n        return dfs(0,P,G)\\n            \\n\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        mod = 10**9 + 7\\n        m = len(group)\\n        \\n        @lru_cache(None)\\n        def dfs(i, g, p):\\n            if i == m:\\n                return int(p <= 0)\\n            res = 0\\n            if g - group[i] >= 0:\\n                res += dfs(i + 1, g - group[i], max(0, p - profit[i]))\\n            res += dfs(i + 1, g, p)\\n            return res\\n        \\n        return dfs(0, G, P) % mod\\n\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        mod = int(10**9) + 7\\n        N = len(group)\\n        dp = [[[None] * (G+1) for _ in range(P+1)] for _ in range(N+1)]\\n        def solve(i, j, k):\\n            if k < 0: return 0\\n            if i == N: return 1 if j == 0 else 0\\n            if dp[i][j][k] is None:\\n                result = solve(i+1, j, k) + solve(i+1, max(j-profit[i], 0), k-group[i])\\n                dp[i][j][k] = result % mod\\n            return dp[i][j][k]\\n        return solve(0, P, G)\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        \\n        \\n        @lru_cache(None)\\n        def recur(hc, mp, ind):\\n\\n            # no enough people left\\n            if hc < 0: return 0\\n\\n            # end of tasks\\n            if ind >= len(profit): \\n                # print(\\\\\\\"hc mp ind\\\\\\\", hc, mp, ind)\\n                if mp <= 0: return 1\\n                else: return 0\\n            \\n            \\n            # take this crime\\n            take = recur(hc - group[ind], max(0, mp - profit[ind]), ind+1)\\n            # skip this crime\\n            skip = recur(hc, mp, ind+1)\\n            \\n            \\n            return (take + skip) % (10**9 + 7)\\n        \\n        \\n        return recur(G, P, 0)\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        MOD = 10 ** 9 + 7\\n        \\n        @lru_cache(None)\\n        def dp(i, g, p):\\n            if g < 0:\\n                return 0\\n            if i == n:\\n                return 1 if p == 0 else 0\\n            a = dp(i + 1, max(g - group[i], -1), max(0, p - profit[i]))\\n            b = dp(i + 1, g, p)\\n            return (a + b) % MOD\\n        \\n        n = len(group)\\n        return dp(0, G, P)\", \"class Solution(object):\\n    def profitableSchemes(self, G, P, group, profit):\\n        MOD = 10**9 + 7\\n        cur = [[0] * (G + 1) for _ in range(P + 1)]\\n        cur[0][0] = 1\\n        \\n        for g0,p0 in zip(group,profit):\\n            curr = [row[:] for row in cur]\\n            for p1 in range(P+1):\\n                p2 = min(P,p1+p0)\\n                for g1 in range(G-g0+1):\\n                    g2 = g1+g0\\n                    curr[p2][g2]+=cur[p1][g1]\\n                    curr[p2][g2]%=MOD\\n            cur=curr\\n        return sum(cur[-1])%MOD\\n\\n\\n            \\n        \\n\", \"import functools\\n\\nclass Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        n = len(profit)\\n        \\n        @functools.lru_cache(None)\\n        def dp(g, p, i):\\n            if i == n or g == 0: \\n                if p == 0: return 1\\n                return 0\\n\\n            ans = dp(g, p, i+1) % (10**9+7)      \\n            if g - group[i] >= 0: \\n                ans += dp(g - group[i], max(0, p - profit[i]), i+1)  \\n                ans %= (10**9+7)\\n                \\n            return ans % (10**9+7)\\n        \\n        return dp(G, P, 0) % (10**9+7)\\n            \\n\", \"# from functools import lru_cache\\n# class Solution:\\n#     def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n#         MOD = 10**9+7\\n#         n = len(profit)\\n#         psum = profit + [0]\\n#         for i in range(n)[::-1]:\\n#             psum[i] += psum[i+1]\\n#         # print(psum)\\n#         @lru_cache(None)\\n#         def dfs(g, p, idx):\\n#             if g < 0 or p > psum[idx]:\\n#                 return 0\\n#             if idx == n:\\n#                 return 1\\n#             res = (dfs(g, p, idx+1) + dfs(g-group[idx], p-profit[idx], idx+1))%MOD\\n#             # print(g,p,idx,res)\\n#             return res\\n#         return dfs(G,P,0)\\n\\n\\nfrom functools import lru_cache\\nclass Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        MOD = 10**9+7\\n        n = len(profit)\\n        psum = profit + [0]\\n        for i in range(n)[::-1]:\\n            psum[i] += psum[i+1]\\n        # print(psum)\\n        @lru_cache(None)\\n        def dfs(g, p, idx):\\n            # if g < 0 or p > psum[idx]:\\n            #     return 0\\n            # if idx == n:\\n            #     return 1\\n            if g < 0:\\n                return 0\\n            if idx == n:\\n                return 1 if p <= 0 else 0\\n            p = max(p,0)\\n            res = (dfs(g, p, idx+1) + dfs(g-group[idx], p-profit[idx], idx+1))%MOD\\n            # print(g,p,idx,res)\\n            return res\\n        return dfs(G,P,0)\", \"# from functools import lru_cache\\n# class Solution:\\n#     def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n#         MOD = 10**9+7\\n#         n = len(profit)\\n#         psum = profit + [0]\\n#         for i in range(n)[::-1]:\\n#             psum[i] += psum[i+1]\\n#         # print(psum)\\n#         @lru_cache(None)\\n#         def dfs(g, p, idx):\\n#             if g < 0 or p > psum[idx]:\\n#                 return 0\\n#             if idx == n:\\n#                 return 1\\n#             res = (dfs(g, p, idx+1) + dfs(g-group[idx], p-profit[idx], idx+1))%MOD\\n#             # print(g,p,idx,res)\\n#             return res\\n#         return dfs(G,P,0)\\n\\nfrom functools import lru_cache\\nclass Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        MOD = 10**9+7\\n        n = len(profit)\\n        psum = profit + [0]\\n        for i in range(n)[::-1]:\\n            psum[i] += psum[i+1]\\n        # print(psum)\\n        @lru_cache(None)\\n        def dfs(g, p, idx):\\n            if g < 0 or p > psum[idx]:\\n                return 0\\n            if idx == n:\\n                return 1\\n            p = max(p,0)\\n            res = (dfs(g, p, idx+1) + dfs(g-group[idx], p-profit[idx], idx+1))%MOD\\n            # print(g,p,idx,res)\\n            return res\\n        return dfs(G,P,0)\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        @lru_cache(None)\\n        def dp(i, total_profit, member_left):\\n            if i==len(profit):\\n                return 0\\n            take = 0\\n            if member_left >= group[i]:\\n                take += (1 if profit[i]+total_profit >= P else 0)\\n                take += dp(i+1, min(P, total_profit + profit[i]), max(0, member_left-group[i]))\\n            skip =dp(i+1, total_profit, member_left)\\n            return take + skip\\n        return dp(0, 0, G)%(10**9+7)\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        @lru_cache(None)\\n        def dp(i, total_profit, member_left):\\n            if i==len(profit) or member_left <= 0:\\n                return 0\\n            take = 0\\n            if member_left >= group[i]:\\n                take += (1 if profit[i]+total_profit >= P else 0)\\n                #take += dp(i+1, total_profit + profit[i], member_left-group[i])\\n                take += dp(i+1, min(P, total_profit + profit[i]), max(0, member_left-group[i]))\\n            skip =dp(i+1, total_profit, member_left)\\n            return take + skip\\n        return dp(0, 0, G)%(10**9+7)\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        @lru_cache(None)\\n        def dp(i, total_profit, member_left):\\n            if i==len(profit) or member_left <= 0:\\n                return 0\\n            take = 0\\n            if member_left >= group[i]:\\n                take += (1 if profit[i]+total_profit >= P else 0)\\n                take += dp(i+1, min(P, total_profit + profit[i]), max(0, member_left-group[i]))\\n            skip =dp(i+1, total_profit, member_left)\\n            return take + skip\\n        return dp(0, 0, G)%(10**9+7)\", \"from collections import defaultdict\\n\\nclass Solution:\\n    MOD = 10**9 + 7\\n    \\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        remaining_profit = sum(profit)\\n        \\n        schemes, next_schemes = defaultdict(int), defaultdict(int)\\n        schemes[(0, 0)] = 1\\n        for i, p in enumerate(profit):\\n            remaining_profit -= p\\n            \\n            for curr_g, curr_p in [(0, 0), (group[i], profit[i])]:\\n                for prev_g, prev_p in schemes:\\n                    next_g = prev_g + curr_g\\n                    next_p = min(prev_p + curr_p, P)\\n\\n                    if next_p + remaining_profit >= P and next_g <= G:\\n                        next_schemes[(next_g, next_p)] += schemes[(prev_g, prev_p)]\\n                    \\n            schemes, next_schemes = next_schemes, defaultdict(int)\\n            for k in schemes:\\n                schemes[k] = schemes[k] % Solution.MOD\\n            \\n        return sum(schemes.values()) % Solution.MOD\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        # knapsack\\n        @lru_cache(None)\\n        def dp(i,ppl_left,money):\\n            if ppl_left<0:\\n                return 0\\n            if i==len(group):\\n                return 0\\n            ret = 0\\n            # do or dont do this crime\\n            ret += dp(i+1,ppl_left,money)\\n            # check if doing this crime can get me above P\\n            if money+profit[i]>=P and ppl_left>=group[i]:\\n                ret += 1\\n            ret += dp(i+1,ppl_left-group[i],min(money+profit[i],P))\\n            return ret%(10**9+7)\\n        return dp(0,G,0)\\n            \\n\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        # Dynamic Programming\\n        # Time  complexity: O(N x P x G), where N is the number of crimes available to the gang.\\n        # Space complexity: O(P x G)\\n        MOD = 10**9 + 7\\n        cur = [[0] * (G + 1) for _ in range(P + 1)]\\n        cur[0][0] = 1\\n\\n        for p0, g0 in zip(profit, group):\\n            cur2 = [row[:] for row in cur]\\n            for p1 in range(P + 1):\\n                p2 = min(p1 + p0, P)\\n                for g1 in range(G - g0 + 1):\\n                    g2 = g1 + g0\\n                    cur2[p2][g2] += cur[p1][g1]\\n                    cur2[p2][g2] %= MOD\\n            cur = cur2\\n\\n        return sum(cur[-1]) % MOD\\n\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        profitDict = defaultdict(dict)\\n        profitList = [(g, p) for g, p in zip(group, profit)]\\n        profitList.sort()\\n        ans = 0\\n        for g,p in profitList:\\n            # newProfit = set()\\n            newProfitDict = defaultdict(dict)\\n            for p0 in list(profitDict.keys()):\\n                thisProfit = p0 + p\\n                for preG in list(profitDict[p0].keys()):\\n                    thisG = preG + g\\n                    if thisG > G:\\n                        profitDict[p0].pop(preG)\\n                    else:\\n                        if thisProfit >= P:\\n                            ans += profitDict[p0][preG]\\n                        if thisG in newProfitDict[thisProfit]:               \\n                            newProfitDict[thisProfit][thisG] += profitDict[p0][preG]\\n                        else:\\n                            newProfitDict[thisProfit][thisG] = profitDict[p0][preG]\\n                \\n            for profitTemp in newProfitDict:\\n                for groupTemp in newProfitDict[profitTemp]:\\n                    if groupTemp in profitDict[profitTemp]:   \\n                        profitDict[profitTemp][groupTemp] += newProfitDict[profitTemp][groupTemp]\\n                    else:\\n                        profitDict[profitTemp][groupTemp] = newProfitDict[profitTemp][groupTemp]\\n    \\n            if g <= G and p >=P:\\n                ans += 1\\n            if g in profitDict[p]:\\n                profitDict[p][g] += 1\\n            else:\\n                profitDict[p][g] = 1\\n        return ans%(10**9+7)\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        dp = [[[0 for _ in range(len(profit) + 1)] for _ in range(P + 1)] for _ in range(G + 1)]\\n        if P == 0:\\n            dp[1][0][0] = 1\\n        \\n        for i in range(1, G + 1):\\n            for j in range(0, P + 1):\\n                for k in range(1, len(profit) + 1):\\n                    dp[i][j][k] = dp[i][j][k - 1]\\n                    if profit[k-1] >= j and i >= group[k - 1]:\\n                        dp[i][j][k] += 1\\n                    if i > group[k - 1]:\\n                        remaining_g = i - group[k - 1]\\n                        remaining_p = max(0, j - profit[k-1])\\n                        dp[i][j][k] += dp[remaining_g][remaining_p][k - 1]\\n                    dp[i][j][k] %= (10 ** 9 + 7)\\n\\n        return dp[G][P][len(profit)]\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        BOUND = (10 ** 9) + 7\\n        dp = {}\\n        \\n        def f(g, p, i):\\n            if (g, p, i) in dp:\\n                return dp[(g, p, i)]\\n            \\n            if g == 0:\\n                return 0\\n            if i == 0:\\n                return 1 if group[0] <= g and profit[0] >= p else 0\\n            \\n            res = f(g, p, i-1)\\n            \\n            if group[i] <= g:\\n                if profit[i] >= p:\\n                    res += 1\\n                res += f(g-group[i], max(0,p-profit[i]), i-1)\\n                \\n            dp[(g,p,i)] = res % BOUND\\n            return dp[(g,p,i)]\\n        \\n        return f(G, P, len(group) - 1)\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        \\n        def helper(G, P, group, profit, scheme, memos):\\n            if scheme == len(group):         \\n                if P <= 0 and G >= 0:\\n                    return 1\\n                \\n                return 0\\n\\n            if G < 0:\\n                return 0\\n            \\n            if P < 0:\\n                P = 0\\n                \\n            if P not in memos[G][scheme]:\\n                added = helper(G - group[scheme], P - profit[scheme], group, profit, scheme + 1, memos)\\n                not_added = helper(G, P, group, profit, scheme + 1, memos)\\n                \\n                memos[G][scheme][P if P > 0 else 0] = added + not_added\\n\\n            \\n            return memos[G][scheme][P]\\n            \\n        memos = [[{} for _ in group] for _ in range(G + 1)]\\n        return helper(G, P, group, profit, 0, memos) % ((10 ** 9) + 7)\", \"import functools\\n\\nclass Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        n = len(profit)\\n        \\n        @functools.lru_cache(None)\\n        def dp(g, p, i):\\n            # print(g, p, i)\\n            if i == n or g == 0: \\n                if p == 0: return 1\\n                return 0\\n\\n            ans = dp(g, p, i+1)           \\n            if g - group[i] >= 0:\\n                ans += dp(g - group[i], max(0, p - profit[i]), i+1)\\n                \\n            return ans % (10**9+7)\\n        \\n        return dp(G, P, 0) % (10**9+7)\\n            \\n\", \"class Solution:\\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n        dp = {}\\n        return self.rec(group, profit, dp, 0, G, P) % (10 ** 9 + 7)\\n    \\n    def rec(self, grp, profit, dp, i, mem_left, pr):\\n        if i >= len(grp):\\n            if pr <= 0:\\n                return 1\\n            return 0\\n        pr = max(pr, 0)         #profit\\n        if (i, mem_left, pr) in dp:\\n            return dp[i, mem_left, pr]\\n        \\n        dp[i, mem_left, pr] = self.rec(grp, profit, dp, i+1, mem_left, pr) % (10**9 + 7)\\n        if grp[i] <= mem_left:\\n            dp[i, mem_left, pr] += self.rec(grp, profit, dp, i+1, mem_left - grp[i], pr-profit[i]) % (10**9 + 7)\\n        return dp[i, mem_left, pr]\\n\", \"class Solution(object):\\n    def profitableSchemes(self, G, P, group, profit):\\n        MOD = 10**9 + 7\\n        cur = [[0] * (G + 1) for _ in range(P + 1)]\\n        cur[0][0] = 1\\n\\n        for p0, g0 in zip(profit, group):\\n            # p0, g0 : the current crime profit and group size\\n            cur2 = [row[:] for row in cur]\\n            for p1 in range(P + 1):\\n                # p1 : the current profit\\n                # p2 : the new profit after committing this crime\\n                p2 = min(p1 + p0, P)\\n                for g1 in range(G - g0 + 1):\\n                    # g1 : the current group size\\n                    # g2 : the new group size after committing this crime\\n                    g2 = g1 + g0\\n                    cur2[p2][g2] += cur[p1][g1]\\n                    cur2[p2][g2] %= MOD\\n            cur = cur2\\n\\n        # Sum all schemes with profit P and group size 0 <= g <= G.\\n        return sum(cur[-1]) % MOD\\n            \\n        \\n\"]", "input_output": "{\"fn_name\": \"profitableSchemes\", \"inputs\": [[5, 3, [2, 2], [2, 3]]], \"outputs\": [2]}", "difficulty": "interview", "url": "https://leetcode.com/problems/profitable-schemes/", "starter_code": "\nclass Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        "}
{"id": 128, "question": "Implement a basic calculator to evaluate a simple expression string.\n\nThe expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces  .\n\nExample 1:\n\n\nInput: \"1 + 1\"\nOutput: 2\n\n\nExample 2:\n\n\nInput: \" 2-1 + 2 \"\nOutput: 3\n\nExample 3:\n\n\nInput: \"(1+(4+5+2)-3)+(6+8)\"\nOutput: 23\nNote:\n\n\n       You may assume that the given expression is always valid.\n       Do not use the eval built-in library function.", "solutions": "[\"class Solution:\\n     def calculate(self, s):\\n         \\\"\\\"\\\"\\n         :type s: str\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         res = 0\\n         num = 0\\n         sign = 1\\n         stk = []\\n \\n         for c in s:\\n             if c.isdigit():\\n                 num = 10 * num + (ord(c) - ord('0'))\\n             elif c == '+':\\n                 res += sign * num\\n                 num = 0\\n                 sign = 1\\n             elif c == '-':\\n                 res += sign * num\\n                 num = 0\\n                 sign = -1\\n             elif c == '(':\\n                 stk.append(res)\\n                 stk.append(sign)\\n                 res = 0\\n                 sign = 1\\n             elif c == ')':\\n                 res += sign * num\\n                 res *= stk.pop()\\n                 res += stk.pop()\\n                 num = 0\\n                 sign = 1\\n \\n         if num:\\n             res += sign * num\\n         return res\", \"class Solution:\\n     def calculate(self, s):\\n         \\\"\\\"\\\"\\n         :type s: str\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         total, tmp, sign = 0, 0, 1\\n         numStack = []\\n         signStack = []\\n         for c in s:\\n             if c == '+':\\n                 total, tmp, sign = total + tmp*sign, 0, 1\\n             elif c == '-':\\n                 total, tmp, sign = total + tmp*sign, 0, -1\\n             elif c == '(':\\n                 numStack.append(total)\\n                 signStack.append(sign)\\n                 total, tmp, sign = 0, 0, 1\\n             elif c == ')':\\n                 total += tmp * sign\\n                 total, tmp, sign = total * signStack.pop() + numStack.pop(), 0, 1\\n             elif '0' <= c <= '9':\\n                 tmp = tmp * 10 + ord(c) - ord('0')\\n             else:\\n                 continue\\n         return total + tmp * sign\", \"class Solution:\\n     def calculate(self, s):\\n         \\\"\\\"\\\"\\n         :type s: str\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         if not s:\\n             return 0\\n         \\n         res=0\\n         sign=1\\n         \\n         stack=[1]\\n         \\n         num=0\\n         \\n         for c in s:\\n             \\n             if c <='9' and c>='0':\\n                 num=num*10+ord(c)-ord('0')\\n                 #print(num)\\n             elif c in '+-':\\n                 res+=sign*num\\n                 #print(res)\\n                 if c=='+':\\n                    #print(stack)\\n                    sign=stack[-1]\\n                 else:\\n                    sign=stack[-1]*(-1)\\n                 num=0\\n             elif c=='(':\\n                 stack.append(sign)\\n             elif c==')':\\n                 stack.pop()\\n         #print('outsideloop',res)\\n         res+=sign*num\\n         \\n         return res\", \"class Solution:\\n     def calculate(self, s):\\n         \\\"\\\"\\\"\\n         :type s: str\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         stack = []\\n         res = 0\\n         sign = 1\\n         number = 0\\n         for i in range(len(s)):\\n             c = s[i]\\n             if c.isdigit():\\n                 number = number * 10 + int(c)\\n                 \\n             elif c == \\\"+\\\":\\n                 \\n                 res += number * sign\\n                 sign = 1\\n                 number = 0\\n             \\n             elif c == '-':\\n                 \\n                 res += number * sign\\n                 sign = -1\\n                 number = 0\\n             elif c == \\\"(\\\":\\n                 stack.append(res)\\n                 stack.append(sign)\\n                 res = 0\\n                 sign = 1\\n                 number = 0\\n             elif c == ')':\\n                 res += number * sign\\n                 res *= stack.pop()\\n                 res += stack.pop()\\n                 number = 0\\n                 sign = 1\\n         \\n         res += number * sign\\n                 \\n         \\n         return res\", \"class Solution:\\n     def calculate(self, s):\\n         result = number = 0 \\n         sign = 1\\n         stack= []\\n         for i in s:\\n             if i == ' ':\\n                 continue\\n             if i.isdigit():\\n                 number = number * 10 + int(i)\\n             elif i == '+':\\n                 result += sign * number\\n                 number = 0 \\n                 sign = 1 \\n             elif i == '-':\\n                 result += sign * number \\n                 number = 0 \\n                 sign = -1\\n             elif i == '(':\\n                 stack.append(result)\\n                 stack.append(sign)\\n                 result = 0 \\n                 number = 0 \\n                 sign = 1 \\n             elif i == ')':\\n                 result += sign * number \\n                 number =  0\\n                 sign = 1 \\n                 #result += stack.pop() * stack.pop()\\n                 result = result * stack.pop() + stack.pop()\\n         result += number * sign\\n         return result \\n                 \\n\", \"class Solution:\\n     def calculate(self, s):\\n         \\\"\\\"\\\"\\n         :type s: str\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         sign=[1]\\n         nums=0\\n         total=0\\n         latestsign=1\\n         for c in s:\\n             \\n             if c.isdigit():\\n                 nums=10*nums+int(c)\\n             elif c=='(':\\n                 nums=0\\n                 sign.append(latestsign)\\n             elif c==')':\\n                 total=total+latestsign*nums\\n                 sign.pop()\\n                 nums=0\\n             elif c in ['+','-']:\\n                 total=total+latestsign*nums\\n                 latestsign=sign[-1]*(+1 if c=='+' else -1)\\n                 nums=0\\n         \\n         return total+latestsign*nums\", \"class Solution:\\n     def calculate(self, s):\\n         \\\"\\\"\\\"\\n         :type s: str\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         expression = s\\n         s = []\\n         res = 0\\n         curr = 0\\n         sign = 1\\n         for c in expression:\\n             # print(c,res)\\n             if c.isdigit():\\n                 curr *= 10\\n                 curr += int(c)\\n             if c == \\\"+\\\":\\n                 res += sign * curr\\n                 curr = 0\\n                 sign = 1\\n             if c == \\\"-\\\":\\n                 res += sign * curr\\n                 curr = 0\\n                 sign = -1\\n             if c == \\\"(\\\":\\n                 s.append(res)\\n                 s.append(sign)\\n                 sign = 1\\n                 res = 0\\n             if c == \\\")\\\":\\n                 res += sign * curr\\n                 curr = 0\\n                 res *= s.pop()\\n                 res += s.pop()\\n         \\n         if curr != 0:\\n             res += sign * curr\\n         return res\\n             \\n                 \\n\"]", "input_output": "{\"fn_name\": \"calculate\", \"inputs\": [[\"\\\"1 + 1\\\"\"]], \"outputs\": [2]}", "difficulty": "interview", "url": "https://leetcode.com/problems/basic-calculator/", "starter_code": "\nclass Solution:\n    def calculate(self, s: str) -> int:\n        "}
{"id": 129, "question": "Given an array A of positive integers, A[i] represents the value of the i-th sightseeing spot, and two\u00a0sightseeing spots i and j\u00a0have distance j - i\u00a0between them.\nThe score\u00a0of a pair (i < j) of sightseeing spots is (A[i] + A[j] + i\u00a0- j) : the sum of the values of the sightseeing spots, minus the distance between them.\nReturn the maximum score of a pair of sightseeing spots.\n\u00a0\nExample 1:\nInput: [8,1,5,2,6]\nOutput: 11\nExplanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11\n\n\u00a0\nNote:\n\n2 <= A.length <= 50000\n1 <= A[i] <= 1000", "solutions": "[\"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        curmaxsight = A[0] - 1\\n        curmaxpair = 0\\n        for sight in A[1:]:\\n            if sight + curmaxsight > curmaxpair:\\n                curmaxpair = sight + curmaxsight\\n            if sight > curmaxsight:\\n                curmaxsight = sight\\n            curmaxsight -= 1\\n        return curmaxpair\\n            \\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        result = 0\\n        current = A[0]\\n        current_pos = 0\\n        for i in range(1, len(A)):\\n            value = current + A[i] + current_pos - i\\n            if value > result:\\n                result = value\\n            if current <= A[i] + i-current_pos:\\n                current = A[i]\\n                current_pos = i\\n\\n        return result\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        res = 0\\n        m = A[0]\\n        \\n        for j in range(1, len(A)):\\n            res = max(res, A[j] - j + m)\\n            m = max(m, A[j] + j)\\n        \\n        return res\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        ans = -math.inf\\n        best = -math.inf\\n        for i,a in enumerate(A):\\n            ans = max(ans, best + a - i)\\n            best = max(best, a + i)\\n        \\n        return ans\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        i = 0\\n        ans = float('-inf')\\n        \\n        for j in range(1,len(A)):\\n            ans = max(ans, A[i] + A[j] + i - j)\\n            \\n            if A[j] + j >= A[i] + i:\\n                i = j\\n        return ans\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        i = 0\\n        max_degree = A[i] + i\\n        max_score = -float('inf')\\n        \\n        for j in range(1, len(A)):\\n            curr_max_score = A[j] - j + max_degree\\n            max_score = max(max_score, curr_max_score)\\n            max_degree = max(max_degree, A[j]+j)\\n            \\n        return max_score\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        \\n        ans = float('-inf')\\n        if len(A)<2: return 0\\n        one = A[0]\\n \\n        for i in range(1,len(A)):\\n            ans = max(ans,one+A[i]-i)\\n            one = max(one, A[i]+i)\\n        \\n        return ans\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        # consider B[i] = A[i] + i, C[i] = A[i] -j\\n        # Find the B[i] + C[j]\\n        B = [A[i] + i for i in range(len(A))]\\n        C = [A[i] - i for i in range(len(A))]\\n        p = 0 \\n        q = 1\\n        max_score = float('-inf')\\n        # for each q = 1, 2,..., len(A) - 1\\n        # update the max of B[0], ...., B[j-1]: B[p]\\n        # calculate B[q] - B[p]\\n        while q < len(B):\\n            if B[q-1] > B[p]:\\n                p = q - 1 \\n            max_score = max(max_score, B[p] + C[q])\\n            q += 1\\n        return max_score\\n            \\n            \\n        \\n        \\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        sA = sorted(enumerate(A), key= lambda x:x[1], reverse=True)\\n        # print(sA)\\n\\n        L = len(A)\\n        maxScore = -L   #invalid value, just for initialization\\n        theDis = -1  #invalid value, just for initialization, minimal dis should be 1\\n        for i in range(L-1):\\n            if sA[i][1] + sA[i+1][1] <= maxScore + 1:\\n                # print('too small to continue', i)\\n                break  #two small to continue\\n            for j in range(i+1, L):\\n                curScore = sA[i][1] + sA[j][1]\\n                if curScore <= maxScore + 1:\\n                    # print('internal break', i, j)\\n                    break\\n                curDis = abs(sA[i][0]-sA[j][0])\\n                curScore -= curDis\\n                if curScore > maxScore:\\n                    maxScore = curScore\\n                    theDis = curDis \\n        return maxScore\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        res = imax = 0\\n        for i, a in enumerate(A):\\n            res = max(res, imax + A[i] - i)\\n            imax = max(imax, A[i] + i)\\n        return res\\n\\n#     int n = a.size();\\n#     int maxOverallGain = INT_MIN;\\n#     int maxEndRight = a[n-1] - (n-1);\\n#     for(int i=n-2; i>=0; i--)\\n#     {\\n#         maxEndRight = max(maxEndRight, a[i+1] - (i+1));\\n#         maxOverallGain = max(maxOverallGain, a[i] + i + maxEndRight);\\n#     }\\n#     return maxOverallGain;\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        maxI = A[0]\\n        ans = A[0] + A[1] - 1\\n        for i in range(1, len(A)):\\n            if ans < maxI + A[i] - i:\\n                ans = maxI + A[i] - i\\n            if maxI < A[i] + i:\\n                maxI = A[i] + i\\n        return ans\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        i_sum = []\\n        j_sum = []\\n        prev = -float('inf')\\n        max_sum = -float('inf')\\n        for i in reversed(list(range(len(A)))):\\n            if i > 0:\\n                if A[i]-i > prev:\\n                    j_sum.append(A[i]-i)\\n                    prev = A[i] - i\\n                else:\\n                    j_sum.append(prev)\\n            i_sum.append(A[i]+i)\\n        for i in reversed(list(range(1,len(i_sum)))):\\n            max_sum = max(max_sum, i_sum[i]+j_sum[i-1])\\n        return max_sum\\n\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        res = maxx = 0\\n        for i in range(len(A)):\\n            res = max(res, maxx+A[i])\\n            maxx = max(maxx, A[i]) - 1\\n        return res\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        # score = A[i] + A[j] + i - j = A[i] + i + A[j] - j\\n        # max(A[i]+i + A[j] - j) = max(A[i]+i) + max(A[j]-j), i<j\\n        max_i = 0\\n        score_max_i_j = []\\n        for j in range(len(A)):\\n            score_max_i_j.append(max_i + A[j] - j)\\n            max_i = max(max_i, A[j]+j)\\n        return max(score_max_i_j)\\n\\n\\n\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        a, b, n = 0, 1, len(A)\\n        def opt(i,j):\\n            return A[i] + A[j] + i - j\\n        \\n        ans = [A[0], opt(0,1)] + [0 for _ in range(n-2)]\\n        \\n        for i in range(2, n):\\n            opt_a, opt_b = opt(a, i), opt(b, i)\\n            if opt_a > opt_b:\\n                ans[i] = opt_a\\n                b = i\\n            else:\\n                ans[i] = opt_b\\n                a = b\\n                b = i\\n        \\n        return max(ans)\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        res = 0\\n        n = len(A)\\n        m = A[0]\\n        j = 0\\n        for i in range(1, n):\\n            res = max(res, (A[i]+A[j]+j-i))\\n            if A[i]+i-j > m:\\n                m = A[i]\\n                j = i\\n        return res\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        # consider B[i] = A[i] + i, C[i] = A[i] -j\\n        # Find the B[i] + C[j]\\n        B = [A[i] + i for i in range(len(A))]\\n        C = [A[i] - i for i in range(len(A))]\\n        p = 0 \\n        q = 1\\n        max_score = 0 \\n        # for each q = 1, 2,..., len(A) - 1\\n        # update the max of B[0], ...., B[j-1]: B[p]\\n        # calculate B[q] - B[p]\\n        while q < len(B):\\n            if B[q-1] > B[p]:\\n                p = q - 1 \\n            max_score = max(max_score, B[p] + C[q])\\n            q += 1\\n        return max_score\\n            \\n            \\n        \\n        \\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        # A = [8 , 1 ,5 ,2 6,]\\n        # output = 11\\n        # Explanation:\\n            # i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11\\n            \\n        # print(A)\\n        \\n#         max_score = 0\\n        \\n#         for i in range(len(A)):\\n#             first = A[i] # this is my number\\n#             for j in range(0,len(A)):\\n#                 second = A[j]\\n#                 max_score = max(max_score ,A[i] + A[j] + i - j )      \\n#                 print(A[i] + A[j])\\n#             return max_score\\n        \\n        i = A[0]\\n        max_ans = 0\\n        for j in range(1,len(A)):\\n            x = A[j]\\n            print(x)\\n            max_ans = max(max_ans, i + x - j)\\n            i = max(i , x + j)\\n        return max_ans\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        # consider B[i] = A[i] + i, C[i] = A[i] -j\\n        # Find the B[i] + C[j]\\n        B = [A[i] + i for i in range(len(A))]\\n        C = [A[i] - i for i in range(len(A))]\\n        p = 0 \\n        q = 1\\n        max_score = 0 \\n\\n        while q < len(B):\\n            if B[q-1] > B[p]:\\n                p = q - 1 \\n            max_score = max(max_score, B[p] + C[q])\\n            q += 1\\n        return max_score\\n            \\n            \\n        \\n        \\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        preMax = A[0]\\n        ans = 0\\n        for i, a in enumerate(A[1:], 1):\\n            ans = max(ans, a - i + preMax)\\n            preMax = max(preMax, a + i)\\n            # print(preMax,ans)\\n        return ans\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        res = imax = 0\\n        for i, a in enumerate(A):\\n            res = max(res, imax + A[i] - i)\\n            imax = max(imax, A[i] + i)\\n        return res\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        best_of_prev = A[0] - 1\\n        maximum = 0\\n        \\n        for spot in A[1:]:\\n            if spot + best_of_prev > maximum:\\n                maximum = spot + best_of_prev\\n                \\n            if spot > best_of_prev:\\n                best_of_prev = spot\\n                \\n            best_of_prev -= 1\\n            \\n        return maximum\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        res = 0\\n        maximum = A[0]\\n        for i in range(1, len(A)):\\n            cur = A[i]-i\\n            res = max(res, cur+maximum)\\n            maximum = max(maximum, A[i]+i)\\n            \\n        return res\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        ans = 0\\n        best_pre = 0\\n        for i in range(1,len(A)):\\n            ans = max(ans, A[best_pre]+best_pre + A[i]- i)\\n            if A[i]+i >  A[best_pre] + best_pre:\\n                best_pre = i\\n        return ans\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        # A = [8 , 1 ,5 ,2 6,]\\n        # output = 11\\n        # Explanation:\\n            # i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11\\n        i = A[0]\\n        max_ans = 0\\n        for j in range(1,len(A)):\\n            x = A[j]\\n            print(x)\\n            max_ans = max(max_ans, i + x - j)\\n            i = max(i , x + j)\\n        return max_ans\\n\", \"\\nclass Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        best = 0\\n        i = 0\\n        for j in range(1, len(A)):\\n            s1 = A[i] + A[j] + i - j\\n            s2 = A[j] + A[j-1] + j - 1 - j\\n            if s2 > s1:\\n                i = j - 1\\n            best = max(best, s1, s2) \\n        return best\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        lmax=A[0]\\n        gmax=float('-inf')\\n        for i in range(1,len(A)):\\n            cur=lmax+A[i]-i\\n            lmax=max(lmax,A[i]+i)\\n            gmax=max(gmax,cur)\\n            \\n        return gmax\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:  # O(n log n)?\\n        # dynamic programming / memoization solution?  => wrong!!!\\n        ## [1, 2, 3, 4] => [[1, 2], [2, 3], [3, 4]]  sum: a + b - 1\\n        ##                             [[1, 3], [2, 4]] sum: [a, b-1] + [b] - 1  # get midpoint and look-up left and right parts\\n        ##                                  [[1, 4]] sum: [1:2] + [3:4] -1\\n        \\n        ### example: A = [8,1,5,2,6]\\n        ## memo[dist=1]: [8+1-1=8, 1+5-1=5, 5+2-1=6, 2+6-1=7]\\n        ## memp[dist=2]: [8+5-1=13]\\n        # memo = {(i, i): A[i] for i in range(A)}  # (i, j) = sum(i:j)\\n        # max_score = 0  # max(memo.values())\\n        # for dist in range(1, len(A)):\\n        #     for i in range(len(A) - dist):\\n        #         # get sum\\n        #         mid = (i + dist) // 2  # for pairs of dist 1 => 0, 1; mid == 0\\n        #         left_sum = memo[(i, mid)]\\n        #         right_sum = memo[(mid+1, i+dist)]\\n        #         memo[(i, i + dist)] = left_sum + right_sum - 1\\n        #         max_score = max(memo[(i, i + dist)], max_score)  # update max score\\n        # return max_score\\n        \\n        ## idea 2: lagging and leading pointers => calc their score. Move leading on, if score goes down, move lagging next\\n        lag, lead = 0, 1\\n        prev_max_score = A[0]\\n        prev_max_idx = 0\\n        max_score = 0\\n        for i in range(1, len(A)):\\n            score = prev_max_score + A[i] - (i - prev_max_idx)\\n            max_score = max(score, max_score)\\n            if A[i] >= score - A[i]:\\n                prev_max_idx = i\\n                prev_max_score = A[i]\\n            \\n        return max_score\\n\\n# ex: [100, 1, 1, 1, 1....[1]*_99_, 51, 51, 1, 1, [1]*_99_, 100]\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        best_i = 0 \\n        res = 0\\n        for i, v in enumerate(A):\\n            res = max(res, v-i+best_i)\\n            best_i = max(best_i, v+i)\\n        return res\\n\\n        return res\\n        # best_i = 0\\n        # res = 0 \\n        # for i, v in enumerate(A):\\n        #     res = max(res, v-i+best_i)\\n        #     best_i = max(best_i, v+i)\\n        # return res\\n        # best_i = 0\\n        # res = 0 \\n        # for i, v in enumerate(A):\\n        #     res = max(res, v- i + best_i)\\n        #     best_i = max(best_i, v+i)\\n        # return res\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        d=0\\n        m=A[0]\\n        for i in range(1,len(A)):\\n            d=max(d,A[i-1]+(i-1))\\n            m=max(A[i]-i+d,m)\\n        return m\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        best_of_prev = A[0] - 1\\n        maximum = 0\\n        \\n        for spot in A[1:]:\\n            if spot + best_of_prev > maximum:\\n                maximum = spot + best_of_prev\\n                \\n            if spot > best_of_prev:\\n                best_of_prev = spot\\n                \\n            best_of_prev -= 1\\n            \\n        return maximum\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        n = len(A)\\n        pre = A[0] + 0\\n        res = 0\\n        for i in range(1, n):\\n            # res = max(res, pre + A[i] - i)\\n            # pre = max(pre, A[i] + i)\\n            res = res if res > pre + A[i] - i else pre + A[i] - i\\n            pre = pre if pre > A[i] + i else A[i] + i\\n        return res\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        n = len(A)\\n        res = max_i = -n\\n        for j in range(1,n):\\n            max_i = max(max_i, A[j-1] + j-1)\\n            res = max(res, max_i + A[j] - j)\\n        return res\\n        \\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        idx = [0]\\n        for i in range(1, len(A)):\\n            if A[i]+i-idx[-1]> A[idx[-1]]:\\n                idx.append(i)\\n        res = float('-inf')\\n        i = 1 \\n        j = 0\\n        #print(idx)\\n        while i < len(A):\\n            if j+1 < len(idx) and idx[j+1] < i:\\n                j += 1            \\n            res = max(res, A[i]+A[idx[j]]+idx[j]-i)\\n            i += 1\\n        return res\\n            \\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        \\n        arr = [A[0] + A[j] - j for j in range(1, len(A))]\\n        print(arr)\\n        maxdiff = 0\\n        ans = max(arr)\\n        for j in range(1, len(arr)):\\n            maxdiff = max(maxdiff, A[j] - A[0] + j)\\n            ans = max(ans, arr[j] + maxdiff)\\n        return ans\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        max_score = 0\\n        \\n        # prev = ans = -float('inf')\\n        # for i in range(1, len(A)):\\n        #     prev = max(prev, A[i-1]+i-1)\\n        #     ans = max(ans, prev+A[i]-i)\\n        # return ans\\n        prev = ans = -float('inf')\\n        # A[i] + A[j] + i - j\\n        for i in range(1, len(A)):\\n            prev = max(prev, A[i-1] + i - 1)\\n            ans = max(ans, prev + A[i]-i)\\n        return ans\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        \\n        \\n        i_sum = [0]*len(A)\\n        \\n        j_sum = [0]*len(A)\\n        \\n        for i in range(len(A)):\\n            i_sum[i] = A[i] + i\\n        \\n        i_sum[-1] = 0\\n        for j in range(len(A)):\\n            j_sum[j] = A[j] - j\\n            \\n        print(j_sum)\\n        prefix_sum = [-float('inf')]*len(A)\\n        for j in  range(len(A)-2,-1,-1):\\n            prefix_sum[j] = max(j_sum[j+1], prefix_sum[j+1])\\n            \\n        max_sum = -float('inf')\\n        for i in range(len(A)):\\n            max_sum = max(max_sum,prefix_sum[i] + i_sum[i])\\n        print(prefix_sum)\\n        return max_sum\\n        \\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        \\n        n = len(A)\\n        # dp = [0] * n\\n        # dp[0] = A[0]\\n        dp = 0\\n        ans = 0\\n        for j in range(0,n):\\n            # ans = A[j]-j + max_i{0, j-1}(A[i]+i)\\n            #     = A[j]-j] + dp[j-1]\\n            # dp[j] = max(dp[j-1], A[j]+j)\\n            # ans = max(ans, A[j]-j + dp[j-1])\\n            # dp[j] = max(dp[j-1], A[j]+j)\\n            ans = max(ans, A[j]-j + dp)\\n            dp = max(dp, A[j]+j)\\n        # print(dp)\\n        return ans\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n#         maxScore = 0 \\n\\n#         for i in range(0,len(A)):\\n#             for j in range(i+1,len(A)):\\n#                 val = A[i] + A[j] + i - j \\n#                 if val > maxScore:\\n#                     maxScore = val \\n#         return maxScore\\n        best = 0\\n        i = 0\\n        for j in range(1, len(A)):\\n            s1 = A[i] + A[j] + i - j\\n            s2 = A[j] + A[j-1] - 1 \\n            if s2 > s1:\\n                i = j - 1\\n            best = max(best, s1, s2) \\n        return best\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        cur, ans = 0, 0\\n        for a in  A:\\n            ans = max(ans, cur + a)\\n            cur = max(cur, a) -1\\n        return ans\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        #we want to find the two biggest numbers closest to eachother.\\n        dp_i = [0 for i in range(len(A))]\\n        dp_j = [0 for i in range(len(A))]\\n        dp_i[0] = A[0]\\n        dp_j[-1] = A[-1] - (len(A) - 1)\\n        for i in range(1, len(A)):\\n            dp_i[i] = max(A[i] + i, dp_i[i - 1])\\n        for j in range(len(A) - 2, -1 , -1):\\n            dp_j[j] = max(A[j] - j, dp_j[j + 1])\\n        max_sum = 0\\n\\n        for i in range(len(A) - 1):\\n            max_sum = max(max_sum, dp_i[i] + dp_j[i + 1])\\n    \\n        return max_sum\\n            \\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        total = 0\\n        n = len(A)\\n        if n <= 2:\\n            return sum(A) - 1\\n        \\n        a_1 = [a+i for i, a in enumerate(A)]        \\n        a_2 = [a-j for j, a in enumerate(A)]\\n        \\n        dp2 = [a for a in a_2]\\n        for i in range(n-2, -1, -1):\\n            dp2[i] = max(dp2[i+1], a_2[i+1])\\n           \\n        dp1 = [a for a in a_1]\\n        dp1[0] += dp2[0] \\n        for i in range(1, n-1):\\n            dp1[i] = max(a_1[i]+dp2[i], dp1[i-1])\\n        \\n        return dp1[-2]\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        point = (A[0], 0)\\n        best_val = A[0]\\n        best_ind = 0\\n        max_score = 0\\n        for ind in range(1, len(A)):\\n            max_score = max(max_score, best_val+A[ind]+best_ind-ind)\\n            if A[ind]+ind-best_ind >= best_val:\\n                best_val = A[ind]\\n                best_ind = ind\\n        return max_score\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        d = A[1]+A[0]-1\\n        m = A[0]\\n        for j in range(1, len(A)):\\n            if m+ A[j] - j > d:\\n                d = m+A[j]-j\\n            if A[j]+j >= m:\\n                m = A[j]+j\\n        return d\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        if len(A) <= 1:\\n            return 0\\n        max_A_plus_i = max(A[0], A[1]+1)\\n        max_score = A[0] + A[1] - 1\\n        for i in range(2, len(A)):\\n            max_score = max(max_score, max_A_plus_i + A[i] - i)\\n            max_A_plus_i = max(max_A_plus_i, A[i] + i)\\n            \\n            \\n            \\n        return max_score\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        res = 0\\n        keep = (A[0], 0)\\n        for j in range(1, len(A)):\\n            res = max(res, keep[0] + A[j] + keep[1] - j)\\n            if A[j] >= keep[0] or keep[0] - A[j] < j - keep[1]:\\n                keep = (A[j], j)\\n            # print(j, keep, res)\\n        return res\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        cur=res=0\\n        for i,a in enumerate(A):\\n            print(res, cur)\\n            res = max(res,  cur + a - i)\\n            cur = max(cur, a + i)\\n        return res\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        st = []\\n        ret = 0\\n        for i, s in enumerate(A):\\n            while len(st) > 0 and  st[-1][0] < s:\\n                s_j, j = st.pop()\\n                ret = max(ret, s+s_j-abs(i-j))\\n            if len(st) > 0:\\n                ret = max(ret, s+st[-1][0]-abs(st[-1][1]-i))\\n            \\n            st.append((s, i))\\n        return ret\", \"#\\n# @lc app=leetcode id=1014 lang=python3\\n#\\n# [1014] Best Sightseeing Pair\\n#\\n# https://leetcode.com/problems/best-sightseeing-pair/description/\\n#\\n# algorithms\\n# Medium (50.18%)\\n# Likes:    266\\n# Dislikes: 15\\n# Total Accepted:    10.6K\\n# Total Submissions: 21K\\n# Testcase Example:  '[8,1,5,2,6]'\\n#\\n# Given an array A of positive integers, A[i] represents the value of the i-th\\n# sightseeing spot, and two\\u00a0sightseeing spots i and j\\u00a0have distance j - i\\n# between them.\\n# \\n# The score\\u00a0of a pair (i < j) of sightseeing spots is (A[i] + A[j] + i\\u00a0- j) :\\n# the sum of the values of the sightseeing spots, minus the distance between\\n# them.\\n# \\n# Return the maximum score of a pair of sightseeing spots.\\n# \\n# \\n# \\n# Example 1:\\n# \\n# \\n# Input: [8,1,5,2,6]\\n# Output: 11\\n# Explanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11\\n# \\n# \\n# \\n# \\n# Note:\\n# \\n# \\n# 2 <= A.length <= 50000\\n# 1 <= A[i] <= 1000\\n# \\n#\\nclass Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        # Count the current best score in all previous sightseeing spot.\\n        # Note that, as we go further, the score of previous spot decrement.\\n        cur = res = 0\\n        for a in A:\\n            res = max(res, cur + a)\\n            cur = max(cur, a) - 1\\n        return res\\n        \\n\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        maxa = [x+i for i, x in enumerate(A)]\\n        for i in range(1, len(maxa)): maxa[i] = max(maxa[i], maxa[i-1])\\n        \\n        res = float('-inf')\\n        for j in range(1, len(A)):\\n            res = max(res, A[j] - j + maxa[j-1])\\n        \\n        return res\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        m = -float('inf')\\n        res = -float('inf')\\n        for i in range(len(A)-1,-1,-1):\\n            res = max(res,A[i]+i+m)\\n            m = max(m,A[i]-i)\\n        return res\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        N = len(A)\\n        max_ = 0\\n        prev = A[-1]-N+1\\n        for i in range(N-2,-1,-1):\\n            max_ = max(max_, prev + A[i]+i)\\n            prev = max(prev, A[i]-i)\\n        return max_\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        res = float('-inf')\\n        maxleft = float('-inf')\\n        for i, a in enumerate(A):\\n            res = max(res, maxleft + a - i)\\n            maxleft = max(maxleft, a + i)\\n        return res\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        \\n        # generate a vector\\n        #A_left = [a + i for i, a in enumerate(A)]\\n        #A_right = [a - i for i, a in enumerate(A)]\\n        _max_left = A[0]\\n        _max = 0\\n        for j in range(1, len(A)):\\n            _max = max(_max_left + A[j] - j, _max)\\n            _max_left = max(_max_left, A[j] + j)\\n        return _max\", \"class Solution:\\n    def maxScoreSightseeingPair(self, a: List[int]) -> int:\\n        d=[]\\n        \\n        for i in range(len(a)-1,-1,-1):\\n            if i!=0:\\n                d.append([a[i]-i,i])\\n        d.sort()\\n        s=0\\n        for i in range(0,len(a)-1):\\n            while d[-1][1]<=i:\\n                d.pop()\\n        \\n            s=max(s,a[i]+i+d[-1][0])\\n        return s\\n            \\n            \\n        \\n            \\n        \\n        \\n        \\n        \\n            \\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, a: List[int]) -> int:\\n        d=[]\\n        \\n        for i in range(len(a)-1,-1,-1):\\n            if i!=0:\\n                d.append([a[i]-i,i])\\n        d.sort()\\n        s=0\\n        for i in range(0,len(a)):\\n            while d!=[] and d[-1][1]<=i:\\n                d.pop()\\n            if d==[]:\\n                break\\n            s=max(s,a[i]+i+d[-1][0])\\n        return s\\n            \\n            \\n        \\n            \\n        \\n        \\n        \\n        \\n            \\n\", \"import heapq\\nimport math\\n\\nclass Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        h = []\\n        ans = -math.inf\\n        \\n        for i,a in enumerate(A):\\n            if h:\\n                ans = max(ans, a-i-h[0])\\n            heapq.heappush(h, -i-a)\\n        return ans\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        prev=ans=float('-inf')\\n        for i in range(1,len(A)):\\n            prev=max(prev,A[i-1]+i-1)\\n            ans=max(ans,prev+A[i]-i)\\n        return ans\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        \\n        # generate a vector\\n        A_left = [a + i for i, a in enumerate(A)]\\n        A_right = [a - i for i, a in enumerate(A)]\\n        _max_left = A_left[0]\\n        _max = 0\\n        for j in range(1, len(A_right)):\\n            _max = max(_max_left + A_right[j], _max)\\n            _max_left = max(_max_left, A_left[j])\\n        return _max\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        left = 0\\n        res = 0\\n        max_pre = 0\\n        curr_res = 0\\n        for right in range(1, len(A)):\\n            max_pre = max(max_pre, A[right-1] + (right-1))\\n            curr_res = max_pre + A[right] - right\\n            res = max(res, curr_res)\\n        return res\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        res, leftmax, cnt = 0, 0, 0\\n        for num in A:\\n            res = max(res, num + leftmax - cnt)\\n            if num > leftmax - cnt:\\n                leftmax = num\\n                cnt = 0\\n            cnt += 1\\n        return res\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        ans = 0\\n        best = A[0]-1\\n        for i in range(1, len(A)):\\n            ans = max(ans, A[i]+best)\\n            best = max(best-1, A[i]-1)\\n        return ans\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        best = 0\\n        i = 0\\n        for j in range(1, len(A)):\\n            s1 = A[i] + A[j] + i - j\\n            s2 = A[j] + A[j-1] + j - 1 - j\\n            if s2 > s1:\\n                i = j - 1\\n            best = max(best, s1, s2) \\n        return best            \", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n#         maxScore = 0 \\n\\n#         for i in range(0,len(A)):\\n#             for j in range(i+1,len(A)):\\n#                 val = A[i] + A[j] + i - j \\n#                 if val > maxScore:\\n#                     maxScore = val \\n#         return maxScore\\n\\n        K    = A[0]\\n        best = float('-inf')\\n        for j in range(1,len(A)):\\n            x    = A[j]\\n            best = max(best, K + x - j )\\n            K    = max(K   , x + j     )\\n        return best\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        max_score = 0\\n        scores = [0] *len(A)\\n        for i in range (1,len(A)):\\n            if i == 1:\\n                scores[i] = A[0] - (len(A) - (i - 1))\\n            else:\\n                scores[i] = max(A[i - 1] - (len(A) - (i - 1)),scores[i-1])\\n        \\n        for j in range (1,len(A)):\\n            adj_score = (len(A) - j) + scores[j] + A[j]\\n            if adj_score > max_score:\\n                max_score = adj_score\\n        return max_score\\n            \\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        m = p = 0\\n        for i, n in enumerate(A):\\n            m = max(m, p + n - i)\\n            p = max(p, n + i)\\n        return m\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        left = [i+a for i,a in enumerate(A)]\\n        right = [b-j for j, b in enumerate(A)]\\n        for i in range(1, len(left)):\\n            left[i] = max(left[i], left[i-1])\\n        for i in range(len(right)-1)[::-1]:\\n            right[i] = max(right[i], right[i+1])\\n        return max(l+r for l, r in zip(left[:-1], right[1:]))\\n\", \"import heapq\\nclass Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        return solution(A)\\n\\n        \\ndef solution(A):\\n    right_heap = [(-(a - i), a, i) for i, a in enumerate(A)]\\n    \\n    heapq.heapify(right_heap)\\n    current_max = -1    \\n    \\n    for i in range(len(A) - 1):\\n        right_max_score = -1\\n        while len(right_heap) > 0 and right_heap[0][2] <= i:\\n            heapq.heappop(right_heap)\\n        el = right_heap[0]\\n\\n        right_max_score = A[i] + el[1] - abs(el[2] - i)\\n        current_max = max(right_max_score, current_max)\\n\\n    return current_max\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        cur = res = 0\\n        for a in A:\\n            res = max(res, cur + a)\\n            cur = max(cur, a) - 1\\n        return res\\n    \\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        return self.with_sort(A)\\n    \\n    def with_sort(self, A):\\n        n = len(A)\\n        max_list = [(i[0] + i[1], i[0]) for i in sorted(enumerate(A), \\n                                                        key=lambda x:-(x[1] + x[0] * 1.000000001))]\\n        idx = 0\\n        max_s = 0\\n        for j in range(n-1, -1, -1):\\n            s = A[j] - j\\n            while idx < n and max_list[idx][1] >= j:\\n                idx += 1\\n            if idx < n:\\n                s += max_list[idx][0]\\n            max_s = max(max_s, s)\\n        return max_s\\n        \\n        \\n        \\n    def count_sort(self, A):\\n        C = [[] for _ in range(51001)]\\n        for i, a in enumerate(A):\\n            C[a + i].append((a+i, i))\\n        res = []\\n        k = 0\\n        for c in C:\\n            if len(c) > 0:\\n                res.extend(c)\\n        return list(reversed(res))\\n        \\n        \\n    def brute_force(self, A):\\n        max_score = 0\\n        n = len(A)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                s = A[i] + A[j] + i - j\\n                if s > max_score:\\n                    max_score = s\\n        return max_score\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        if len(A) < 2:\\n            return -1\\n        \\n        best_so_far = A[0] + 0\\n        res = 0\\n        for j in range(1, len(A)):\\n            res = max(res, best_so_far + A[j] - j)\\n            if best_so_far < A[j] + j:\\n                best_so_far = A[j] + j\\n        \\n        return res\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        res = imax = 0\\n        for i, a in enumerate(A):\\n            res = max(res, imax + a - i)\\n            imax = max(imax, a + i)\\n        return res\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        if len(A) <= 1:\\n            return -float('inf')\\n\\n        candidate = max(A[0], A[1]+1)\\n        res = A[0]+A[1]-1 \\n\\n        for i in range(2, len(A)):\\n            res = max(res, candidate+A[i]-i)\\n            candidate = max(candidate, A[i]+i)\\n        return res            \", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        import sys\\n        val = A[0] + 0\\n        ans = -sys.maxsize\\n        A.pop(0)\\n        for i,num in enumerate(A):\\n            ans = max(ans,val+A[i] - i - 1)\\n            val = max(val,A[i]+i+1)\\n        return ans\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        if not A:\\n            return 0\\n        temp=A[0]\\n        ans=-999\\n        for i in range(1, len(A)):\\n            ans=max(ans, temp+A[i]-i)\\n            temp=max(temp, A[i]+i)\\n        return ans\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        largest = 0\\n        i = 0\\n        while(i<len(A)-1):\\n            largest = max(largest,A[i]+A[i+1]-1)\\n            if A[i]>A[i+1]:\\n                A[i],A[i+1]=A[i+1]+1,A[i]-1\\n            i += 1\\n        return largest\\n        \\n            \\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        i = 0\\n        res = 0\\n        for j in range(1, len(A)):\\n            ti = A[i] + i\\n            res = max(A[j] - j + ti, res)\\n            if A[j] + j > ti:\\n                i = j\\n        return res\\n\", \"class Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        # we have to find A[i] + i + A[j] - j\\n        # we will fix max(A[i] + i) and find for diff values of A[j] - j\\n        if len(A) == 0 : return 0\\n        maxI = A[0] + 0\\n        res = 0\\n        for j in range(1,len(A)):\\n            res = max(res,maxI+A[j]-j)\\n            maxI = max(maxI,A[j]+j)\\n        return res\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        # for i in range(len(A)-1):\\n        #     for j in range(i+1,len(A)):\\n        #         score = max(score,A[i] + A[j] + i - j)\\n        # return score\\n\"]", "input_output": "{\"fn_name\": \"maxScoreSightseeingPair\", \"inputs\": [[[8, 1, 5, 2, 6]]], \"outputs\": [11]}", "difficulty": "interview", "url": "https://leetcode.com/problems/best-sightseeing-pair/", "starter_code": "\nclass Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        "}
{"id": 130, "question": "A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits and all we know is that all integers in the array were in the range\u00a0[1, k]\u00a0and there are no leading zeros in the array.\nGiven the string s and the integer k. There can be multiple ways to restore the array.\nReturn the number of possible array that can be printed as a string s\u00a0using the mentioned program.\nThe number of ways could be very large so return it modulo 10^9 + 7\n\u00a0\nExample 1:\nInput: s = \"1000\", k = 10000\nOutput: 1\nExplanation: The only possible array is [1000]\n\nExample 2:\nInput: s = \"1000\", k = 10\nOutput: 0\nExplanation: There cannot be an array that was printed this way and has all integer >= 1 and <= 10.\n\nExample 3:\nInput: s = \"1317\", k = 2000\nOutput: 8\nExplanation: Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]\n\nExample 4:\nInput: s = \"2020\", k = 30\nOutput: 1\nExplanation: The only possible array is [20,20]. [2020] is invalid because 2020 > 30. [2,020] is ivalid because 020 contains leading zeros.\n\nExample 5:\nInput: s = \"1234567890\", k = 90\nOutput: 34\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 10^5.\ns consists of only digits and doesn't contain leading zeros.\n1 <= k <= 10^9.", "solutions": "[\"class Solution:\\n    def numberOfArrays(self, s: str, k: int) -> int:\\n        dp = [-1] * len(s)\\n        return self.dfs(s, k, 0, dp)\\n    \\n    def dfs(self, s: str, k: int, start: int, dp: List[int]) -> int:\\n        if start == len(s):\\n            return 1\\n        if s[start] == '0':\\n            return 0\\n        if dp[start] != -1:\\n            return dp[start]\\n        \\n        res, num = 0, 0\\n        \\n        for i in range(start, len(s)):\\n            num = num * 10 + (ord(s[i]) - ord('0'))\\n            \\n            if num > k:\\n                break \\n            \\n            res += self.dfs(s, k, i + 1, dp)\\n            res %= 10**9 + 7\\n            \\n        dp[start] = res\\n        return res\", \"class Solution:\\n    def numberOfArrays(self, s: str, k: int) -> int:\\n        n = len(s)\\n        b = ord('0')\\n        MOD = 10 ** 9 + 7\\n        dp = collections.deque([0] * 10)\\n        dp[0] = 1\\n        for i in range(n - 1, -1, -1):\\n            if s[i] == '0':\\n                dp.pop()\\n                dp.appendleft(0)\\n                continue\\n            num = 0\\n            cnt = 0\\n            for j in range(i, n):\\n                num = num * 10 + ord(s[j]) - b\\n                if num <= k:\\n                    cnt += dp[j - i] % MOD\\n                else:\\n                    break\\n            dp.appendleft(cnt % MOD)\\n            dp.pop()\\n        return dp[0]\\n                    \\n                \\n\", \"class Solution:\\n    def numberOfArrays(self, s: str, k: int) -> int:\\n        MOD = 10 ** 9 + 7\\n        n = len(s)\\n        @lru_cache(None)\\n        def dp(i):\\n            if i == n:\\n                return 1\\n            if s[i] == '0':\\n                return 0\\n            num = 0\\n            ans = 0\\n            for j in range(i, n):\\n                num = num * 10 + ord(s[j]) - ord('0')\\n                if num > k:\\n                    break\\n                ans += dp(j+1)\\n            return ans % MOD\\n        \\n        return dp(0)\\n\", \"class Solution:\\n    def numberOfArrays(self, S: str, K: int) -> int:\\n        import sys\\n        sys.setrecursionlimit(10**9+7)\\n        \\n        @lru_cache(None)\\n        def ways(idx):\\n            if idx == len(S): return 1\\n            if S[idx] == '0': return 0\\n            \\n            ans = 0\\n            num = 0\\n            for i in range(idx, len(S)):\\n                num = num*10 + (ord(S[i]) - ord('0'))\\n                if num > K: break\\n                \\n                ans = (ans + ways(i+1)) % 1000000007\\n            return ans\\n    \\n        return ways(0)\\n\", \"class Solution:\\n    def numberOfArrays(self, s: str, k: int) -> int:\\n        n = len(s)\\n        b = ord('0')\\n        MOD = 10 ** 9 + 7\\n        @lru_cache(None)\\n        def dp(i):\\n            if i == n:\\n                return 1\\n            if s[i] == '0':\\n                return 0\\n            cnt = 0\\n            num = ord(s[i]) - b\\n            while num <= k:\\n                cnt += dp(i + 1) % MOD\\n                i += 1\\n                if i < n:\\n                    num = num * 10 + ord(s[i]) - b\\n                else:\\n                    break\\n            return cnt % MOD\\n        \\n        return dp(0)\\n                    \\n                \\n\", \"class Solution:\\n    def numberOfArrays(self, s: str, k: int) -> int:\\n        import sys\\n        sys.setrecursionlimit(10**9+7)\\n        \\n        @lru_cache(None)\\n        def ways(idx):\\n            if idx == len(s): return 1\\n            if s[idx] == '0': return 0\\n            \\n            ans = 0\\n            num = 0\\n            for i in range(idx, len(s)):\\n                num = num*10 + (ord(s[i]) - ord('0'))\\n                if num > k: break\\n                \\n                ans = (ans + ways(i+1)) % 1000000007\\n            return ans\\n    \\n        return ways(0)\\n\", \"class Solution:\\n    def numberOfArrays(self, s: str, k: int) -> int:\\n        dp = [-1] * len(s)\\n        return self.dfs(s, k, 0, dp)\\n    \\n    def dfs(self, s: str, k: int, start: int, dp: List[int]) -> int:\\n        if start == len(s):\\n            return 1\\n        if s[start] == '0':\\n            return 0\\n        if dp[start] != -1:\\n            return dp[start]\\n        \\n        res, num = 0, 0\\n        \\n        for i in range(start, len(s)):\\n            num = num * 10 + (ord(s[i]) - ord('0'))\\n            \\n            if num > k:\\n                break \\n            \\n            res += self.dfs(s, k, i + 1, dp)\\n            res %= 10**9 + 7\\n            \\n        dp[start] = res\\n        return res\\n\", \"class Solution:\\n    def numberOfArrays(self, s: str, k: int) -> int:\\n        \\n        cache = {}\\n        n = len(s)\\n        mod = 10 ** 9 + 7\\n        \\n        def process(i):\\n            if i == n:\\n                return 1\\n            else:\\n                if s[i] == '0':\\n                    return 0\\n                else:\\n                    if not i in cache:\\n                        ans = 0\\n                        x = 0\\n                        j = 0\\n                        while i+j < n:\\n                            x = x * 10 + (ord(s[i+j]) - 48)\\n                            if x <= k:\\n                                ans += process(i+j+1)\\n                                j += 1\\n                            else:\\n                                break\\n                        cache[i] = ans % mod\\n                    return cache[i]\\n        \\n        return process(0)\\n                        \\n        \\n\", \"MOD = int(1e9 + 7)\\n\\nclass Solution:\\n    def numberOfArrays(self, s: str, k: int) -> int:\\n        dp = [-1 for _ in s]\\n        n = len(s)\\n        \\n        def recurse(i: int) -> int:\\n            if i == n:\\n                return 1\\n            \\n            if dp[i] != -1:\\n                return dp[i]\\n            \\n            result = 0\\n            val = 0\\n            for j in range(i, n):\\n                val = 10 * val + (ord(s[j]) - ord('0'))\\n                if val > k:\\n                    break\\n                elif j == n - 1 or s[j + 1] != '0':\\n                    result = (result + recurse(j + 1)) % MOD\\n            dp[i] = result\\n            return result\\n        \\n        return recurse(0)\\n                \\n    \\n\\n\"]", "input_output": "{\"fn_name\": \"numberOfArrays\", \"inputs\": [[\"\\\"1000\\\"\", 10000]], \"outputs\": [4]}", "difficulty": "interview", "url": "https://leetcode.com/problems/restore-the-array/", "starter_code": "\nclass Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n        "}
{"id": 131, "question": "You are given a string expression representing a Lisp-like expression to return the integer value of.\n\nThe syntax for these expressions is given as follows.\n\nAn expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable.  Expressions always evaluate to a single integer.\n\n(An integer could be positive or negative.)\n\nA let-expression takes the form (let v1 e1 v2 e2 ... vn en expr), where let is always the string \"let\", then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let-expression is the value of the expression expr.\n\nAn add-expression takes the form (add e1 e2) where add is always the string \"add\", there are always two expressions e1, e2, and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2.\n\nA mult-expression takes the form (mult e1 e2) where mult is always the string \"mult\", there are always two expressions e1, e2, and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2.\n\nFor the purposes of this question, we will use a smaller subset of variable names.  A variable starts with a lowercase letter, then zero or more lowercase letters or digits.  Additionally for your convenience, the names \"add\", \"let\", or \"mult\" are protected and will never be used as variable names.\n\nFinally, there is the concept of scope.  When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially.  It is guaranteed that every expression is legal.  Please see the examples for more details on scope.\n\n\nEvaluation Examples:\n\nInput: (add 1 2)\nOutput: 3\n\nInput: (mult 3 (add 2 3))\nOutput: 15\n\nInput: (let x 2 (mult x 5))\nOutput: 10\n\nInput: (let x 2 (mult x (let x 3 y 4 (add x y))))\nOutput: 14\nExplanation: In the expression (add x y), when checking for the value of the variable x,\nwe check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.\nSince x = 3 is found first, the value of x is 3.\n\nInput: (let x 3 x 2 x)\nOutput: 2\nExplanation: Assignment in let statements is processed sequentially.\n\nInput: (let x 1 y 2 x (add x y) (add x y))\nOutput: 5\nExplanation: The first (add x y) evaluates as 3, and is assigned to x.\nThe second (add x y) evaluates as 3+2 = 5.\n\nInput: (let x 2 (add (let x 3 (let x 4 x)) x))\nOutput: 6\nExplanation: Even though (let x 4 x) has a deeper scope, it is outside the context\nof the final x in the add-expression.  That final x will equal 2.\n\nInput: (let a1 3 b2 (add a1 1) b2) \nOutput 4\nExplanation: Variable names can contain digits after the first character.\n\n\n\nNote:\nThe given string expression is well formatted: There are no leading or trailing spaces, there is only a single space separating different components of the string, and no space between adjacent parentheses.  The expression is guaranteed to be legal and evaluate to an integer.\nThe length of expression is at most 2000.  (It is also non-empty, as that would not be a legal expression.)\nThe answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer.", "solutions": "[\"class Solution(object):\\n \\tdef parse(self,expression,d,i):\\n \\t\\tcount = 0\\n \\t\\tstart = i\\n \\t\\tif expression[i] == \\\"(\\\":\\n \\t\\t\\tcount += 1\\n \\t\\t\\ti += 1\\n \\t\\t\\twhile count != 0:\\n \\t\\t\\t\\tif expression[i] == \\\"(\\\":\\n \\t\\t\\t\\t\\tcount += 1\\n \\t\\t\\t\\telif expression[i] == \\\")\\\":\\n \\t\\t\\t\\t\\tcount -= 1\\n \\t\\t\\t\\ti += 1\\n \\t\\t\\tval = self.evaluate(expression[start:i],d)\\n \\t\\telse:\\n \\t\\t\\twhile i < len(expression) and expression[i] != \\\" \\\" and expression[i] != \\\")\\\":\\n \\t\\t\\t\\ti += 1\\n \\t\\t\\tval = expression[start:i]\\n \\t\\t\\tif self.isnumber(val):\\n \\t\\t\\t\\tval = int(val)\\n \\t\\treturn i,val\\n \\tdef get_left_right(self,expression,d):\\n \\t\\ti = 0\\n \\t\\tcount = 0\\n \\t\\ti,left = self.parse(expression,d,0)\\n \\t\\tif i == len(expression) or expression[i] == \\\")\\\":\\n \\t\\t\\treturn left,None,i\\n \\t\\ti += 1\\n \\t\\ti,right = self.parse(expression,d,i)\\n \\t\\treturn left,right,i\\n \\tdef isnumber(self,s):\\n \\t\\tfor c in s:\\n \\t\\t\\tif ord(\\\"0\\\") <= ord(c) <= ord(\\\"9\\\") or c == \\\"+\\\" or c == \\\"-\\\":\\n \\t\\t\\t\\tcontinue\\n \\t\\t\\telse:\\n \\t\\t\\t\\treturn False\\n \\t\\treturn True\\n \\tdef evaluate(self, expression,d = {}):\\n \\t\\t\\\"\\\"\\\"\\n \\t\\t:type expression: str\\n \\t\\t:rtype: int\\n \\t\\t\\\"\\\"\\\"\\n \\t\\tif self.isnumber(expression):\\n \\t\\t\\treturn int(expression)\\n \\t\\tnewd = {}\\n \\t\\tfor key in d:\\n \\t\\t\\tnewd[key] = d[key]\\n \\t\\texpression = expression[1:len(expression)-1]\\n \\t\\toper = \\\"\\\"\\n \\t\\tif expression[0:3] == \\\"add\\\" or expression[:3] == \\\"let\\\":\\n \\t\\t\\toper = expression[0:3]\\n \\t\\t\\texpression = expression[4:]\\n \\t\\telse:\\n \\t\\t\\toper = \\\"mult\\\"\\n \\t\\t\\texpression = expression[5:]\\n \\t\\t\\n \\t\\tif oper == \\\"mult\\\" or oper == \\\"add\\\":\\n \\t\\t\\tleft,right,_ = self.get_left_right(expression,newd)\\n \\t\\t\\tif isinstance(left,str):\\n \\t\\t\\t\\tleft = newd[left]\\n \\t\\t\\tif isinstance(right,str):\\n \\t\\t\\t\\tright = newd[right]\\n \\t\\t\\tif oper == \\\"mult\\\":\\n \\t\\t\\t\\treturn left*right\\n \\t\\t\\telse:\\n \\t\\t\\t\\treturn left + right\\n \\t\\ti = 0\\n \\t\\twhile True:\\n \\t\\t\\tleft,right,i = self.get_left_right(expression,newd)\\n \\t\\t\\texpression = expression[i+1:]\\n \\t\\t\\tif right == None:\\n \\t\\t\\t\\tif isinstance(left,str):\\n \\t\\t\\t\\t\\treturn newd[left]\\n \\t\\t\\t\\treturn left\\n \\t\\t\\tif isinstance(right,str):\\n \\t\\t\\t\\tright = newd[right]\\n \\t\\t\\tnewd[left] = right\\n \\t\\t\\t\\n \\t\\t\\t\\n \\t\\t\\t\\n # s = Solution()\\n # print(s.evaluate(\\\"(let x 2 (mult x (let x 3 y 4 (add x y))))\\\"))\\n\"]", "input_output": "{\"fn_name\": \"evaluate\", \"inputs\": [[\"\\\"(add 1 2)\\\"\"]], \"outputs\": [2]}", "difficulty": "interview", "url": "https://leetcode.com/problems/parse-lisp-expression/", "starter_code": "\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        "}
{"id": 132, "question": "In a country popular for train travel, you\u00a0have planned some train travelling one year in advance.\u00a0 The days of the year that you will travel is given as an array days.\u00a0 Each day is an integer from 1 to 365.\nTrain tickets are sold in 3 different ways:\n\na 1-day pass is sold for costs[0] dollars;\na 7-day pass is sold for costs[1] dollars;\na 30-day pass is sold for costs[2] dollars.\n\nThe passes allow that many days of consecutive travel.\u00a0 For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8.\nReturn the minimum number of dollars you need to travel every day in the given list of days.\n\u00a0\nExample 1:\nInput: days = [1,4,6,7,8,20], costs = [2,7,15]\nOutput: 11\nExplanation: \nFor example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.\nOn day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.\nOn day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.\nIn total you spent $11 and covered all the days of your travel.\n\n\nExample 2:\nInput: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\nOutput: 17\nExplanation: \nFor example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.\nOn day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.\nIn total you spent $17 and covered all the days of your travel.\n\n\u00a0\n\nNote:\n\n1 <= days.length <= 365\n1 <= days[i] <= 365\ndays is in strictly increasing order.\ncosts.length == 3\n1 <= costs[i] <= 1000", "solutions": "[\"class Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        dp = [0] + [-1 for i in range(days[-1])]\\n        \\n        for day in days:\\n            dp[day] = 0\\n        \\n        for i in range(1, len(dp)):\\n            if dp[i] == -1:\\n                dp[i] = dp[i-1]\\n            \\n            else:\\n                dp[i] = min(\\n                    dp[i-1] + costs[0],\\n                    dp[max(i-7, 0)] + costs[1],\\n                    dp[max(i-30, 0)] + costs[2],\\n                )\\n            \\n        return dp[-1]\", \"class Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        dp = [0] * (days[-1] + 1)\\n        pos = 0\\n        \\n        for i in range(1, days[-1] + 1):\\n            if i == days[pos]:\\n                d1 = i - 1\\n                d2 = i - 7 if i - 7 > 0 else 0\\n                d3 = i - 30 if i - 30 > 0 else 0\\n                dp[i] = min(dp[d1] + costs[0], dp[d2] + costs[1], dp[d3] + costs[2])\\n                pos += 1\\n            else:\\n                dp[i] = dp[i - 1]\\n                \\n        return dp[-1]\\n\", \"class Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def recur(day):\\n            if day > 365:\\n                return 0\\n            elif day in days:\\n                \\n                ret = math.inf\\n                for c, d in zip(costs, [1,7,30]):\\n                    ret = min(ret, c + recur(day + d))\\n                return ret\\n                    \\n            else:\\n                return recur(day + 1)\\n            \\n        \\n        return recur(0)\", \"class Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        n = len(days)\\n        m = len(costs)\\n        ranges = [1, 7, 30]\\n        dp = [float('inf')] * (n+1) \\n        dp[0] = 0\\n        #print(f\\\\\\\"n={n} m={m} dp={dp}\\\\\\\")\\n        for j in range(1, n+1):\\n            for i in range(1, m+1):\\n                for k in range(j, n+1):\\n                    if days[k-1] - days[j-1] >= ranges[i-1]:\\n                        break\\n                    #print(f\\\\\\\"k={k} i={i} j={j}\\\\\\\")\\n                    dp[k] = min(dp[k], costs[i-1] + dp[j-1])            \\n        return dp[n]\\n\", \"class Solution:\\n    def mincostTickets(self, arr: List[int], costs: List[int]) -> int:\\n        \\n        dp = [float('inf')]*(len(arr)+1)\\n        dp[0] = 0\\n        \\n        for i in range(len(arr)):\\n            \\n            j = i\\n            prev = dp[i]\\n            \\n            while j < len(arr) and arr[j] < arr[i] + 30:\\n                \\n                if arr[j] == arr[i]:\\n                    dp[j+1] = min(dp[j+1],prev+costs[0],prev+costs[1],prev+costs[2])\\n                elif arr[j] - arr[i] < 7:\\n                    dp[j+1] = min(dp[j+1],prev+costs[1],prev+costs[2])\\n                elif arr[j] - arr[i] < 30:\\n                    dp[j+1] = min(dp[j+1],prev+costs[2])\\n                    \\n                j += 1\\n                \\n        print(dp)\\n                    \\n        return dp[-1]\", \"class Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        min_costs = [-1 for i in range(days[-1])]\\n        if 1 in days:\\n            min_costs[0] = min(costs)\\n        else:\\n            min_costs[0] = 0\\n        return self.helper(days, costs, min_costs, days[-1] - 1)\\n    \\n    def helper(self, days: List[int], costs: List[int], min_costs: List[int], i) -> int:\\n        if i == 0:\\n            return min_costs[0]\\n        if i < 0:\\n            return 0\\n        if i + 1 not in days:\\n            min_costs[i] = self.helper(days, costs, min_costs, i-1)\\n        if min_costs[i] != -1:\\n            return min_costs[i]\\n        \\n        c_1 = self.helper(days, costs, min_costs, i-1)\\n        c_7 = self.helper(days, costs, min_costs, i-7)\\n        c_30 = self.helper(days, costs, min_costs, i-30)\\n        \\n        min_costs[i] = min(c_1 + costs[0], c_7 + costs[1], c_30 + costs[2])\\n        return min_costs[i]\\n        \\n            \\n        \\n        \\n        \\n# Brute force: branch for each ticket type: O(3^n)\\n\\n# min_cost(i) = minimum cost of traveling i days. (1-indexed).\\n\\n\\n# min_cost(i) = min(\\n# (min_cost(i-1) + costs[0]), \\n# (min_cost(i-1) + costs[1]), \\n# (min_cost(i-1) + costs[2]))\\n'''\\nmin_cost(1) = min(costs[0], costs[1], costs[2])\\n\\nmin_cost(i) = min cost of traveling up to the days[i]th day.\\nmin_cost(0) = min(costs[0], costs[1], costs[2])\\nmin_cost(i < 0) = min(costs[0], costs[1], costs[2])\\nmin_cost(i) = (min_cost(i-1) + costs[0], min_cost(i-7) + costs[1], min_cost(i-30) + costs[2])\\n\\n\\n\\n\\nmin_cost(i) = minimum cost of traveling i days, (1-indexed).\\nmin_cost(1) = min(costs[0], costs[1], costs[2])\\nmin_cost(i < 1) = min(costs[0], costs[1], costs[2]) ???\\nmin_cost(i) = (min_cost(i-1) + costs[0], min_cost(i-7) + costs[1], min_cost(i-30) + costs[2]) \\n\\n**** This doesn't account for the case where a longer pass may be cheaper.\\n\\n\\n'''\", \"class Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        dp = [0] * (days[-1] + 1)\\n        for day in range(0, days[-1] + 1):\\n            if day not in days:\\n                dp[day] = dp[max(0, day - 1)]\\n            else:\\n                dp[day] = min(dp[max(0, day - 1)] + costs[0], dp[max(0, day - 7)] + costs[1], dp[max(0, day - 30)] + costs[2])\\n\\n        return dp[-1]\", \"class Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        dp = [float('inf')] * (len(days) + 1)\\n        dp[0] = 0\\n        for i in range(1, len(days) + 1):\\n            j = 0\\n            while i + j < len(dp):\\n                if days[i + j - 1] <= days[i - 1]:\\n                    dp[i + j] = min(dp[i + j], dp[i - 1] + costs[0])\\n                if days[i + j - 1] <= days[i - 1] + 6:\\n                    dp[i + j] = min(dp[i + j], dp[i - 1] + costs[1])\\n                if days[i + j - 1] <= days[i - 1] + 29:\\n                    dp[i + j] = min(dp[i + j], dp[i - 1] + costs[2])\\n                else:\\n                    break\\n                j += 1\\n        return dp[-1]\\n\", \"def prev(x,day,dp):\\n    ans=0\\n    for i in day:\\n        if i<=x:\\n        #    print(dp[i],i,x)\\n            ans = dp[i]\\n        else:\\n            break\\n    return ans\\nclass Solution:\\n    def mincostTickets(self, day: List[int], cos: List[int]) -> int:\\n        dp=[10000000]*(370)\\n        tmp=[0]*32\\n        tmp[1]=cos[0]\\n        tmp[7]=cos[1]\\n        tmp[30]=cos[2]\\n        day.sort()\\n        n = len(day)\\n        for i in range(n):\\n            d = day[i]\\n            for j in [1,7,30]:\\n                ab = prev(max(0,d-j),day,dp) + tmp[j]\\n                #print(ab)\\n                dp[d] = min(dp[d] , ab)\\n        #print(dp[200:])\\n        return dp[day[-1]]\\n                \\n            \\n        \\n        \\n\", \"class Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        dp = [0] * (days[-1]+1)\\n        dp[0] = 0\\n        for j in range(len(days)):\\n                i = days[j]\\n                for k in range(1,i+1):\\n                    if k == i:\\n                        if k-7 >= 0 and k-30 >= 0:\\n                            dp[k] = min(dp[k-1]+costs[0], dp[k-7]+costs[1], dp[k-30]+costs[2])\\n                        elif k-7 >= 0:\\n                            dp[k] = min(dp[k-1]+costs[0], dp[k-7]+costs[1], costs[2])\\n                        else:\\n                            dp[k] = min(dp[k-1]+costs[0], costs[1], costs[2])\\n                    else:\\n                        if k != 1:\\n                            if dp[k] == 0:\\n                                dp[k] = dp[k-1]\\n        return dp[-1]\\n                    \\n        \\n\", \"class Solution:\\n    '''\\n    days = [1,4,6,7,8,20]\\n    dp   = 11 9 8 6 4  2\\n            2 7        2\\n    '''\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        # if costs = [7,2,15] change to [2,2,15]\\n        for i in range(1,-1,-1):\\n            if costs[i] > costs[i+1]: costs[i] = costs[i+1]\\n    \\n        N = len(days)\\n        dp = [0 for _ in range(N+1)]\\n        dp[-2] = costs[0]\\n        dp[-1] = 0    # trick to avoid list index out of bounds\\n        \\n        for i in range(N-2,-1,-1):\\n            dp[i] = costs[0] + dp[i+1]\\n            for j in range(i+1,N):\\n                if days[j] - days[i] < 7:\\n                    dp[i] = min(dp[i], costs[1] + dp[j+1])\\n                elif days[j] - days[i] < 30:\\n                    dp[i] = min(dp[i], costs[2] + dp[j+1])\\n        return dp[0]\", \"class Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        dp = [float('inf') for _ in range(days[-1] + 1)]\\n        dp[0] = 0\\n        set_days = set(days)\\n        for i in range(1, len(dp)):\\n            if i not in set_days:\\n                dp[i] = dp[i - 1]\\n            else:\\n                dp[i] = min(dp[max(0, i - 1)] + costs[0],\\n                            dp[max(0, i - 7)] + costs[1],\\n                            dp[max(0, i - 30)] + costs[2])\\n        return dp[-1]\", \"class Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        k = len(costs)\\n        n = len(days)\\n        dp = [[0] * (k+1) for _ in range(n)]\\n\\n        for i in range(n):\\n            dp[i][0] = float('inf')\\n\\n            for d in range(i):\\n                if days[i] - days[d] < 30:\\n                    dp[i][0] = min(dp[i][0], dp[d][3])\\n                if days[i] - days[d] < 7:\\n                    dp[i][0] = min(dp[i][0], dp[d][2])\\n\\n            for j in range(1, k+1):\\n                if i == 0:\\n                    dp[i][j] = costs[j-1]\\n                else:\\n                    dp[i][j] = costs[j-1] + min(dp[i-1])\\n\\n        return min(dp[-1])\\n\", \"class Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        n = len(days)\\n        if not days:\\n            return 0\\n        \\n        total = [float('inf') for _ in range(n)]\\n        total[0] = min(costs)\\n        \\n        for i in range(1,n):\\n            curday = days[i]\\n            total[i] = total[i-1]+min(costs)\\n            \\n            for j in range(i-1, -1, -1):\\n                diff = curday-days[j]\\n                if diff < 7:\\n                    if j>0:\\n                        total[i] = min(total[i], total[j-1]+costs[1])\\n                    else:\\n                        total[i] = min(total[i], costs[1])\\n                \\n                if diff < 30:\\n                    if j>0:\\n                        total[i] = min(total[i], total[j-1]+costs[2])\\n                    else:\\n                        total[i] = min(total[i], costs[2])\\n                \\n                else:\\n                    break\\n        \\n        return total[-1]\\n\", \"from collections import defaultdict\\nclass Solution:\\n    def mincostTickets(self, days: List[int], cost: List[int]) -> int:\\n        dp = defaultdict(int)\\n        days = set(days)\\n        \\n        for i in range(365, 0, -1):\\n            if i in days:\\n                dp[i] = min(dp[i+1] + cost[0], dp[i+7] + cost[1], dp[i+30] + cost[2])\\n            else:\\n                dp[i] = dp[i+1]\\n        \\n        return dp[1]\", \"class Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        dp = [float('inf') for d in range(days[-1]+1)]\\n        dp[0] = 0\\n        pass_num_days = [1, 7, 30]\\n        days_set = set(days)\\n        \\n        for day in range(days[-1]+1):\\n            if day not in days_set:\\n                dp[day] = dp[max(0, day-1)]\\n            else:\\n                for num_days, cost in zip(pass_num_days, costs):\\n                    dp[day] = min(dp[day], dp[max(0, day-num_days)] + cost)\\n        print(dp)\\n        return dp[-1]    \", \"class Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        given = {}\\n        for day in days:\\n            given[day] = True\\n        \\n        dp = [0 for _ in range(days[-1]+1)]\\n        dp[1] = costs[0]\\n        for day in range(days[-1]+1):\\n            if day not in given:\\n                dp[day] = dp[day-1]\\n            else:\\n                # purchase one day pass\\n                one_day_pass = dp[max(0, day-1)] + costs[0]\\n                # purchase one week pass\\n                one_week_pass = dp[max(0, day-7)] + costs[1]\\n                # purchase one month pass\\n                one_month_pass = dp[max(0,day-30)] + costs[2]\\n                dp[day] = min(one_day_pass, one_week_pass, one_month_pass)\\n        print(dp)\\n        return dp[-1]\", \"class Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        \\n        cost = [0 for j in range(366)]\\n        \\n        for i in range(len(cost)):\\n            if(i in days):\\n                cost[i] = min((cost[i-1] if i-1>=0 else 0) + costs[0], \\n                              (cost[i-7] if i-7>=0 else 0) + costs[1], \\n                              (cost[i-30] if i-30>=0 else 0) + costs[2])\\n            else:\\n                cost[i] = cost[max(i-1,0)]\\n            \\n        return cost[365]\\n        \\n#         cost = [0 for j in range(days)]\\n        \\n#         for i, d in enumerate(days):\\n#             if(d <= 7):\\n#                 cost[i] = cost[i-1] + c[0] # take day pass\\n#             if(d <= 30): # choose between day pass and month pass\\n#                 cost[i] = min(cost[i-1]+c[0], cost)\\n\", \"class Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        if not days: \\n            return 0\\n        lastday = days[-1]\\n        \\n        dp = [0] * (lastday + 1)\\n        \\n        for i in range(1, lastday + 1): \\n            if i not in days: \\n                dp[i] = dp[i - 1]\\n                continue\\n            prev_1 = dp[i - 1] if i >= 1 else 0\\n            prev_7 = dp[i - 7] if i >= 7 else 0\\n            prev_30 = dp[i - 30] if i >= 30 else 0\\n            dp[i] = min(prev_1 + costs[0], prev_7 + costs[1], prev_30 + costs[2])\\n        \\n        return dp[-1]\\n            \\n\", \"class Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        if not days: \\n            return 0\\n        \\n        dp = [0] * len(days)\\n        \\n        # given a day, find the dp index should look for\\n        # include start, not include end\\n        def search(start: int, end: int,  day:int)-> int:\\n            if start == end - 1: \\n                if day >= days[start]:\\n                    return start\\n                else:\\n                    return -1\\n            m = int((end - start)/2) + start\\n            \\n            if day >= days[m]:\\n                return search(m, end, day)\\n            else: \\n                return search(start, m, day)\\n                \\n        m = {day:i for i, day in enumerate(days)}\\n        \\n        for i,day in enumerate(days): \\n            prev_1 = day - 1\\n            prev_7 = day - 7\\n            prev_30 = day - 30\\n            c_1 = costs[0] \\n            c_7 = costs[1]\\n            c_30 = costs[2]\\n            if prev_1 in m: \\n                c_1 += dp[m[prev_1]]\\n            elif prev_1 >= 0 and prev_1 >= days[0]:        \\n                c_1 += dp[search(0, i, prev_1)]\\n            if prev_7 in m:\\n                c_7 += dp[m[prev_7]]\\n            elif prev_7 >= 0 and prev_7 >= days[0]:\\n                c_7 += dp[search(0, i, prev_7)]\\n            if prev_30 in m:\\n                c_30 += dp[m[prev_30]]\\n            elif prev_30 >= 0 and prev_30 >= days[0]:\\n                c_30 += dp[search(0, i, prev_30)]\\n                \\n            dp[i] = min(c_1, c_7, c_30)\\n        \\n        return dp[-1]\\n            \\n\", \"class Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        if not days:\\n            return 0\\n        dp = {}\\n        def getMin(idx, valid_count_past):\\n            if idx == len(days):\\n                return 0\\n            if days[idx] <= valid_count_past:\\n                return getMin(idx+1, valid_count_past)\\n            if idx in dp:\\n                return dp[idx]\\n            m1 = costs[0] + getMin(idx+1, days[idx])\\n            m7 = costs[1] + getMin(idx+1, days[idx]+6)\\n            m30 = costs[2] + getMin(idx+1, days[idx]+29)\\n            dp[idx] = min(m1,m7,m30)\\n            return dp[idx]\\n        \\n        return getMin(0,0)\\n\"]", "input_output": "{\"fn_name\": \"mincostTickets\", \"inputs\": [[[1, 4, 6, 7, 8, 20], [2, 7, 15]]], \"outputs\": [11]}", "difficulty": "interview", "url": "https://leetcode.com/problems/minimum-cost-for-tickets/", "starter_code": "\nclass Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        "}
{"id": 133, "question": "You are given a string containing only 4\u00a0kinds of characters 'Q', 'W', 'E' and\u00a0'R'.\nA string is said to be\u00a0balanced\u00a0if each of its characters appears\u00a0n/4 times where n is the length of the string.\nReturn the minimum length of the substring that can be replaced with any other string of the same length to make the original string s\u00a0balanced.\nReturn 0 if the string is already balanced.\n\u00a0\nExample 1:\nInput: s = \"QWER\"\nOutput: 0\nExplanation: s is already balanced.\nExample 2:\nInput: s = \"QQWE\"\nOutput: 1\nExplanation: We need to replace a 'Q' to 'R', so that \"RQWE\" (or \"QRWE\") is balanced.\n\nExample 3:\nInput: s = \"QQQW\"\nOutput: 2\nExplanation: We can replace the first \"QQ\" to \"ER\". \n\nExample 4:\nInput: s = \"QQQQ\"\nOutput: 3\nExplanation: We can replace the last 3 'Q' to make s = \"QWER\".\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 10^5\ns.length is a multiple of 4\ns\u00a0contains only 'Q', 'W', 'E' and\u00a0'R'.", "solutions": "[\"class Solution:\\n    def balancedString(self, s: str) -> int:\\n        # minimum window so that outside is possible\\n        if len(s) //4 != len(s) / 4: return -1 \\n        ans, lb, n_cnt = len(s), 0, collections.Counter(s)\\n\\n        i = 0\\n        while i < len(s): \\n            n_cnt[s[i]] -= 1     \\n            while lb < len(s) and all(len(s) / 4 >= n_cnt[c] for c in 'QWER'): \\n                ans = min(ans, abs(i - lb + 1))\\n                if ans == 0: return 0\\n                n_cnt[s[lb]] += 1\\n                lb += 1\\n                # here is actually a swap? \\n            if lb > i: \\n                i, lb = lb, i\\n            i +=1\\n\\n        return ans\\n                \\n            \\n            \\n        \\n            \\n            \\n\", \"class Solution:\\n    def balancedString(self, s: str) -> int:\\n        # minimum window so that outside is possible\\n        if len(s) //4 != len(s) / 4: return -1 \\n        ans, p1, p2, n_cnt = len(s), 0, 0, collections.Counter(s)\\n\\n        \\n        while p1 < len(s): \\n            n_cnt[s[p1]] -= 1     \\n            while p2 < len(s) and all(len(s) / 4 >= n_cnt[c] for c in 'QWER'): \\n                ans = min(ans, abs(p1 - p2 + 1))\\n                n_cnt[s[p2]] += 1\\n                p2 += 1\\n                # here is actually a swap? \\n            if p2 > p1: \\n                p1, p2 = p2, p1\\n            p1 +=1\\n\\n        return ans\\n                \\n            \\n            \\n        \\n            \\n            \\n\", \"class Solution:\\n    def balancedString(self, s: str) -> int:\\n        # minimum window so that outside is possible\\n        if len(s) //4 != len(s) / 4: return -1 \\n        ans, p1, p2, n_cnt = len(s), 0, 0, collections.Counter(s)\\n\\n        while p1 < len(s): \\n            n_cnt[s[p1]] -= 1     \\n            while p2 < len(s) and all(len(s) / 4 >= n_cnt[c] for c in 'QWER'): \\n                ans = min(ans, abs(p1 - p2 + 1))\\n                n_cnt[s[p2]] += 1\\n                p2 += 1\\n            if p2 > p1: \\n                p1, p2 = p2, p1\\n            p1 +=1\\n\\n        return ans\\n                \\n            \\n            \\n        \\n            \\n            \\n\", \"class Solution:\\n    def balancedString(self, s: str) -> int:\\n        # minimum window so that outside is possible\\n        if len(s) //4 != len(s) / 4: return -1 \\n        ans, p1, p2, n_cnt = len(s), 0, 0, collections.Counter(s)\\n\\n        while p1 < len(s): \\n            n_cnt[s[p1]] -= 1     \\n            while p2 < len(s) and all(len(s) / 4 >= n_cnt[c] for c in 'QWER'): \\n                ans = min(ans, abs(p1 - p2 + 1))\\n                n_cnt[s[p2]] += 1\\n                p2 += 1\\n            if p2 > p1: \\n                p1, p2 = p2, p1\\n            p1 +=1\\n        return ans\\n    \\n    def balancedString(self, s: str) -> int:\\n        # minimum window so that outside is possible\\n        if len(s) //4 != len(s) / 4: return -1 \\n        ans, p1, p2, n_cnt = len(s), 0, 0, collections.Counter(s)\\n\\n        while p1 < len(s): \\n            n_cnt[s[p1]] -= 1     \\n            while p2 < min(p1+2, len(s)) and all(len(s) / 4 >= n_cnt[c] for c in 'QWER'): \\n                # can go beyond one position\\n                ans = min(ans, abs(p1 - p2 + 1))\\n                n_cnt[s[p2]] += 1\\n                p2 += 1\\n            # if p2 > p1: \\n            #     p1, p2 = p2, p1\\n            p1 +=1\\n        return ans\\n                \\n            \\n            \\n        \\n            \\n            \\n\", \"class Solution:\\n    def balancedString(self, s: str) -> int:\\n        # minimum window so that outside is possible\\n        if len(s) //4 != len(s) / 4: return -1 \\n        ans, p1, p2, n_cnt = len(s), 0, 0, collections.Counter(s)\\n\\n        while p1 < len(s): \\n            n_cnt[s[p1]] -= 1     \\n            while p2 < len(s) and all(len(s) / 4 >= n_cnt[c] for c in 'QWER'): \\n                ans = min(ans, abs(p1 - p2 + 1))\\n                n_cnt[s[p2]] += 1\\n                p2 += 1\\n            if p2 > p1: \\n                p1, p2 = p2, p1\\n            p1 +=1\\n        return ans\\n    \\n    def balancedString(self, s: str) -> int:\\n        # minimum window so that outside is possible\\n        if len(s) //4 != len(s) / 4: return -1 \\n        ans, p1, p2, n_cnt = len(s), 0, 0, collections.Counter(s)\\n\\n        while p1 < len(s): \\n            n_cnt[s[p1]] -= 1     \\n            while p2 < min(p1+2, len(s)) and all(len(s) / 4 >= n_cnt[c] for c in 'QWER'): \\n                ans = min(ans, abs(p1 - p2 + 1))\\n                n_cnt[s[p2]] += 1\\n                p2 += 1\\n            # if p2 > p1: \\n            #     p1, p2 = p2, p1\\n            p1 +=1\\n        return ans\\n                \\n            \\n            \\n        \\n            \\n            \\n\", \"from sys import maxsize\\nfrom collections import Counter\\nclass Solution:\\n    def balancedString(self, s):\\n        n = len(s)\\n        right = 0\\n        chars = Counter(s)\\n        res = maxsize\\n        for left in range(n):\\n            while right <= n - 1 and any(chars[c] > n // 4 for c in 'QWER'):\\n                chars[s[right]] -= 1\\n                right += 1\\n            if all(chars[c] <= n // 4 for c in 'QWER'):\\n                res = min(res, right - left)\\n            chars[s[left]] += 1\\n        return res      \", \"class Solution:\\n    def balancedString(self, s: str) -> int:\\n        # minimum window so that outside is possible\\n        if len(s) //4 != len(s) / 4: return -1 \\n        ans, lb, n_cnt = len(s), 0, collections.Counter(s)\\n\\n        for i, l in enumerate(s): \\n            n_cnt[l] -= 1               \\n            while lb < len(s) and all(len(s) / 4 >= n_cnt[c] for c in 'QWER'): \\n                # how to shrink? \\n                ans = min(ans, i - lb + 1)\\n                n_cnt[s[lb]] += 1\\n                lb += 1\\n                \\n        return ans\\n                \\n            \\n            \\n        \\n            \\n            \\n\"]", "input_output": "{\"fn_name\": \"balancedString\", \"inputs\": [[\"\\\"QWER\\\"\"]], \"outputs\": [-1]}", "difficulty": "interview", "url": "https://leetcode.com/problems/replace-the-substring-for-balanced-string/", "starter_code": "\nclass Solution:\n    def balancedString(self, s: str) -> int:\n        "}
{"id": 134, "question": "Given a positive integer N, return the number of positive integers less than or equal to N that have at least 1 repeated digit.\n\u00a0\n\nExample 1:\nInput: 20\nOutput: 1\nExplanation: The only positive number (<= 20) with at least 1 repeated digit is 11.\n\n\nExample 2:\nInput: 100\nOutput: 10\nExplanation: The positive numbers (<= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.\n\n\nExample 3:\nInput: 1000\nOutput: 262\n\n\n\u00a0\nNote:\n\n1 <= N <= 10^9", "solutions": "[\"class Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        # N -> total numbers less than or equal to N\\n        # We will calculate the integers with all different digits (which are less than/equal to N)\\n        # Then the answer would be: N - nums_with_different_digits\\n        \\n        # Calculate the number of digits in N\\n        NN, dd = N, 0\\n        nums = [] # store the digits\\n        while(NN):\\n            dd += 1\\n            nums.append(NN % 10)\\n            NN //= 10\\n        nums.reverse()\\n        \\n        \\n        # numbers with less digits than that of N\\n        numbers = 0\\n        for i in range(dd-1):\\n            numbers += 9 * (math.factorial(9) // math.factorial(9-i))\\n        \\n        \\n        # find the N-digit numbers (all-different)\\n        already_visited_digits = set()\\n        \\n        def fac2(n, k):\\n            return math.factorial(n) // math.factorial(n-k)\\n        \\n        for i,n in enumerate(nums):\\n            k = 0\\n            for j in range((1 if i==0 else 0), (n+1 if i==dd-1 else n)):\\n                if(j in already_visited_digits):\\n                    continue\\n                k += 1\\n            numbers += k * fac2(10-i-1, dd-i-1)\\n            if n in already_visited_digits:\\n                # All the numbers with this prefix will have at least one common digit\\n                break\\n            already_visited_digits.add(n)\\n            \\n        return N - numbers\", \"class Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        ## https://leetcode.com/problems/numbers-with-repeated-digits/discuss/256725/JavaPython-Count-the-Number-Without-Repeated-Digit\\n#     \\\\\\\"\\\\\\\"\\\\\\\"\\n#     The corner case is too hard to manage...\\n\\n#     count res as N - total number without duplicated digits.\\n#     turns into a math and permutation problem.\\n\\n#     select m out of n\\n#     P(m, n): n! / (n-m)!\\n\\n#     Algorithm:\\n\\n#     lets say N has k digits.\\n#     1) count number less than k digits\\n#     lets say number with i digits\\n#     first digit 1 ~ 9, following option is 0 ~ 9 without first digit\\n#     count = 9 * P(i-1,9)\\n\\n#     2) count number has k digits. \\n#     Calculate digits with same prefix. \\n#     Prefix cannot has duplicate digits.\\n#     for case like 77xxx, we should stop the calculation.\\n#     \\\\\\\"\\\\\\\"\\\\\\\"\\n        \\n        def numPerm(n, r):\\n            return math.factorial(n)//math.factorial(n-r)\\n        \\n        \\n        # N + 1 as padding.\\n        nums = [int(d) for d in str(N + 1)]\\n        K = len(nums) # N has K digits\\n        cnt = 0 # number with no repeated val\\n         # count **postive number with digits less than K\\n        for i in range(1, K):\\n            cnt += 9*numPerm(9, i-1)\\n            \\n        # count number with K digits\\n        seen = set() # seen digit\\n        for i in range(K): \\n            # prefix = nums[:i] + currentDigit\\n            # currentDigit < nums[i]\\n            for x in range(1 if i == 0 else 0, nums[i]):\\n                if x in seen: continue # avoid duplication\\n                # cnt += P(K - (i + 1), 10 - (i + 1))\\n                cnt += numPerm(10 - (i + 1), K - (i + 1))\\n            \\n            # since next iteration, prefix has duplicate digits, break\\n            if nums[i] in seen: break\\n            seen.add(nums[i])\\n        \\n        return N - cnt\\n        \\n       \\n        \\n\", \"class Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        k = 0\\n        num = []\\n        t = N\\n        while t:\\n            num.append(t%10)\\n            t = t//10\\n            k += 1\\n        num = num[::-1]\\n        digits = [i for i in range(10)]\\n        dp = [[0 for _ in range(2)] for _  in range(k+1)]\\n        def count(dp, dig, state, d1, seen):\\n            if dig == k:\\n                return 1\\n            if dp[dig][state]:\\n                return dp[dig][state]\\n            \\n            seen.add(d1)\\n            for d in digits:\\n                if d in seen:\\n                    continue\\n                if state == 0:\\n                    dp[dig][state] += count(dp, dig + 1, state, d, seen)\\n                elif state == 1:\\n                    if d > num[dig]:\\n                        continue\\n                    if d < num[dig]:\\n                        dp[dig][state] += count(dp, dig + 1, state^1, d, seen)\\n                    elif d == num[dig]:\\n                        dp[dig][state] += count(dp, dig + 1, state, d, seen)\\n            \\n            seen.remove(d1)\\n            return dp[dig][state]\\n        \\n        v = 0\\n        # print(k)\\n        for d in range(1, 10):\\n            seen = set()\\n            if d < num[0]:\\n                v += count(dp, 1, 0, d, seen)\\n            elif d == num[0]:\\n                v += count(dp, 1, 1, d, seen)\\n        \\n        \\n        for i in range(1, k):\\n            for p in range(1, 10):\\n                seen = set()\\n                dp = [[0 for _ in range(2)] for _  in range(k+1)]\\n                v += count(dp, i + 1, 0, p, seen)\\n            # print(v)\\n        # print(dp[3][0])\\n        return N - v \", \"class Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        # https://leetcode.com/problems/numbers-with-repeated-digits/discuss/592922/Python-Well-commented-solution-with-easy-to-follow-recursion   \\n        memo = {}\\n        def f(digits_of_N, i, digits_used, any_digit):\\n            if i == k:\\n                return 1\\n            \\n            key = (i, digits_used, any_digit)\\n            if key in memo:\\n                return memo[key]\\n            cnt = 0\\n            min_digit = 1 if i == 0 else 0\\n            max_digit = 9 if any_digit else digits_of_N[i]\\n            for d in range(min_digit, max_digit + 1):\\n                if digits_used & (1 << d) != 0:\\n                    continue\\n                cnt += f(digits_of_N, i + 1, digits_used | (1 << d), any_digit or (d < digits_of_N[i]))\\n            \\n            memo[key] = cnt\\n            return cnt\\n        if N <= 9:\\n            return 0\\n        k = len(str(N))\\n        cnt = 0\\n        for i in range(1, k):\\n            all_possible_ints = 9 * 10**(i-1)\\n            ints_with_unique_digits = 9\\n            nb_choices = 9\\n            for j in range(1, i):\\n                ints_with_unique_digits *= nb_choices\\n                nb_choices -= 1\\n            cnt += all_possible_ints - ints_with_unique_digits\\n            \\n        all_ints_with_k_digits = N - int('9'*(k-1))\\n        digits_of_N = [int(d) for d in str(N)]\\n        ints_with_unique_k_digits = f(digits_of_N, 0, 0, False)\\n        cnt += all_ints_with_k_digits - ints_with_unique_k_digits\\n        \\n        return cnt\", \"def f(n,s,e,ci,di,v):\\n    if n==ci:\\n        return 1\\n    a=0\\n    if (e,ci,v) in di:\\n        return di[e,ci,v]\\n    for i in range(10):\\n            if e==0:\\n                if not v>>i&1:\\n                    eee=v|(1<<i)\\n                    a+=f(n,s,0,ci+1,di,eee)\\n            else:\\n                if i>int(s[ci]):\\n                    break\\n                if int(s[ci])==i:\\n                    if not v>>i&1:\\n                        eee=v|(1<<i)\\n                        a+=f(n,s,1,ci+1,di,eee)\\n                    break\\n                if not v>>i&1:\\n                    eee=v|(1<<i)\\n                    a+=f(n,s,0,ci+1,di,eee)\\n    di[e,ci,v]=a\\n    return a\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        if n<=10:\\n            return 0\\n        s=str(n)\\n        l=len(s)\\n        ans=10\\n        prev=9\\n        for i in range(9,9-l+2,-1):\\n            ans+= prev*i\\n            prev=prev*i\\n        a=0\\n        di={}\\n        v=0\\n        for i in range(1,10):\\n            if i>int(s[0]):\\n                break\\n            if i==int(s[0]):\\n                e=1<<i\\n                a+=f(l,s,1,1,di,e)\\n                break\\n            e=1<<i\\n            a+=f(l,s,0,1,di,e)\\n        return n-a-ans+1\", \"class Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        digits = []\\n        M=N+1\\n        while M>0:\\n            digits.append(M%10)\\n            M//=10\\n            \\n        part_1 = 0\\n        prod=9\\n        i_1=9\\n        \\n        n = len(digits)\\n        \\n        for i in range(n-1):\\n            part_1+=prod\\n            # print(i,part_1,prod)\\n            if i_1>1:\\n                if i>0:\\n                    i_1-=1\\n                prod*=i_1\\n        i_1=9\\n        seen = set([])\\n        cols = [0 for i in range(10)]\\n        while len(digits)>0:\\n            digit = digits.pop()\\n            if len(digits)==n-1:\\n                prod = digit-1\\n            else:\\n                prod = digit-cols[digit]\\n            j_1=i_1\\n            for i in range(len(digits)):\\n                prod*=j_1\\n                j_1-=1\\n            i_1-=1\\n            part_1+=prod\\n            \\n            if digit in seen:\\n                break\\n            else:\\n                seen.add(digit)\\n            for i in range(digit+1,10):\\n                cols[i]+=1\\n        return N -part_1\", \"def f(n,s,e,ci,di,v):\\n    if n==ci:\\n        return 1\\n    a=0\\n    if (e,ci,v) in di:\\n        return di[e,ci,v]\\n    for i in range(10):\\n            if e==0:\\n                if not v>>i&1:\\n                    eee=v|(1<<i)\\n                    a+=f(n,s,0,ci+1,di,eee)\\n            else:\\n                if i>int(s[ci]):\\n                    break\\n                if int(s[ci])==i:\\n                    if not v>>i&1:\\n                        eee=v|(1<<i)\\n                        a+=f(n,s,1,ci+1,di,eee)\\n                    break\\n                if not v>>i&1:\\n                    eee=v|(1<<i)\\n                    a+=f(n,s,0,ci+1,di,eee)\\n    di[e,ci,v]=a\\n    return a\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        if n<=10:\\n            return 0\\n        s=str(n)\\n        l=len(s)\\n        ans=10\\n        prev=9\\n        for i in range(9,9-l+2,-1):\\n            ans+= prev*i\\n            prev=prev*i\\n        a=0\\n        di={}\\n        v=0\\n        for i in range(1,10):\\n            if i>int(s[0]):\\n                break\\n            if i==int(s[0]):\\n                e=1<<i\\n                a+=f(l,s,1,1,di,e)\\n                break\\n            e=1<<i\\n            a+=f(l,s,0,1,di,e)\\n        return n-a-ans+1\\n\", \"class Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        N = str(N)\\n        \\n        @lru_cache(None)\\n        def dfs(i, r, m):\\n            if i == len(N):\\n                return 1\\n            \\n            ans = 0\\n            limit = int(N[i]) if r else 9\\n            for k in range(0,limit+1):\\n                if m & (1 << k) == 0:\\n                    mask =  m | (1 << k) if m or k > 0 else 0\\n                    if k < limit or not r:\\n                        ans += dfs(i+1, False, mask)\\n                    else:\\n                        ans += dfs(i+1, True, mask)\\n            return ans\\n        \\n        return int(N) - dfs(0, True, 0) + 1\", \"from functools import lru_cache\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        @lru_cache(None)\\n        def dfs(state, x, lz=False):\\n            n = len(str(x))\\n            if x < 10:\\n                res = 0\\n                if not lz:\\n                    for i in range(1, x + 1):\\n                        if state & (1 << i) == 0:\\n                            res += 1\\n                else:\\n                    for i in range(x + 1):\\n                        if state & (1 << i) == 0:\\n                            res += 1\\n                # print(bin(state), x, lz, res)\\n                return res\\n            if not lz:\\n                res = dfs(state, 10 ** (n - 1) - 1)\\n            else:\\n                if state & 1 == 0:\\n                    res = dfs(state | 1, 10 ** (n - 1) - 1, True)\\n                else:\\n                    res = 0\\n            for i in range(1, int(str(x)[0])):\\n                if state & (1 << i) == 0:\\n                    res += dfs(state | (1 << i), 10 ** (n - 1) - 1, True)\\n            if state & (1 << int(str(x)[0])) == 0:\\n                if not (x % 10 ** (n - 1) == 0 and n >= 3):\\n                    if x % 10 ** (n - 1) >= 10 ** (n - 2) or n <= 2:\\n                        res += dfs(state | (1 << int(str(x)[0])), x % 10 ** (n - 1), True)\\n                    elif n >= 3 and 1 & state == 0 and x % 10 ** (n - 1) >= 10 ** (n - 3):\\n                        res += dfs(state | (1 << int(str(x)[0])) + 1, x % 10 ** (n - 1), True)\\n            # print(bin(state), x, lz, res)\\n            return res\\n        \\n        return N - dfs(0, N)\\n\", \"class Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        s = str(n)\\n        @lru_cache(None)\\n        def dp(i, smaller, nonzero, used):\\n            if i==len(s):\\n                return nonzero\\n            ret = 0\\n            if smaller:\\n                for dig in range(10):\\n                    if dig==0 and not nonzero:\\n                        ret += dp(i+1, True, False, used)\\n                    else:\\n                        if (1<<dig)&used:\\n                            continue\\n                        ret += dp(i+1, True, True, used|(1<<dig))\\n            else:\\n                for dig in range(10):\\n                    if dig>int(s[i]):\\n                        break\\n                    elif dig==int(s[i]):\\n                        if (1<<dig)&used:\\n                            continue\\n                        ret += dp(i+1, False, True, used|(1<<dig))\\n                    else:\\n                        if dig==0 and not nonzero:\\n                            ret += dp(i+1, True, False, used)\\n                        else:\\n                            if (1<<dig)&used:\\n                                continue\\n                            ret += dp(i+1, True, True, used|(1<<dig))\\n            # print(i, smaller, nonzero, bin(used), ret)\\n            return ret\\n        # print(dp(0, False, False, 0))\\n        return n - dp(0, False, False, 0)\", \"class Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        L = list(map(int, str(N + 1)))\\n        res, n = 0, len(str(N + 1))\\n\\n        def A(m, n):\\n            return 1 if n == 0 else A(m, n - 1) * (m - n + 1)\\n\\n        for i in range(1, n): res += 9 * A(9, i - 1)\\n        s = set()\\n        for i, x in enumerate(L):\\n            for y in range(0 if i else 1, x):\\n                if y not in s:\\n                    res += A(9 - i, n - i - 1)\\n            if x in s: break\\n            s.add(x)\\n        return N - res\\n\", \"class Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        list_N = list(map(int, str(N + 1)))\\n        solution = 0\\n        def permutation(m, n):\\n            return 1 if n == 0 else permutation(m, n - 1) * (m - n + 1)\\n        for i in range(1, len(list_N)):\\n            solution += 9 * permutation(9, i - 1)\\n        seen_set = set()\\n        for i, x in enumerate(list_N):\\n            for y in range(0 if i else 1, x):\\n                if y not in seen_set:\\n                    solution += permutation(9 - i, len(list_N) - i - 1)\\n            if x in seen_set:\\n                break\\n            seen_set.add(x)\\n        return N - solution\", \"class Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        if N < 100:\\n            return N // 11\\n        \\n        s = str(N)\\n        l = len(s)\\n        \\n        if l > 10:\\n            return N - 8877690\\n        \\n        mapping = {\\n         0:  0,\\n         1:  9,\\n         2:  90,\\n         3:  738,\\n         4:  5274,\\n         5:  32490,\\n         6:  168570,\\n         7:  712890,\\n         8:  2345850,\\n         9:  5611770,\\n         10: 8877690}\\n        \\n        seen = set()\\n\\n        for i, d in enumerate(s):\\n            d = int(d)\\n            if d > 0:\\n                f = sum(1 for j in range((1 if i == 0 else 0), d) if j not in seen)\\n                for j in range(l-i-1):\\n                    f *= (9-i-j)\\n                N -= f\\n            \\n            if i == l - 1 and d not in seen:\\n                N -= 1\\n            if d in seen:\\n                break\\n            seen.add(d)\\n        return N - mapping[l-1]\", \"class Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        digits = list(map(int, str(N)))\\n        n = len(digits)\\n        d = 0\\n        for i in range(1, n):\\n            d += 9 * math.factorial(9) // math.factorial(10 - i)\\n        for i, j in enumerate(digits):\\n            for k in range(1 if i == 0 else 0, j):\\n                if k in digits[:i]:\\n                    continue\\n                x = 10 - i - 1\\n                d += math.factorial(x) // math.factorial(x - (n - i - 1))\\n            if j in digits[:i]:\\n                break\\n            else:\\n                if i == n - 1:\\n                    d += 1\\n        return N - d\", \"class Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n         # N -> total numbers less than or equal to N\\n        # We will calculate the integers with all different digits (which are less than/equal to N)\\n        # Then the answer would be: N - nums_with_different_digits\\n        \\n        # Calculate the number of digits in N\\n        NN, dd = N, 0\\n        nums = [] # store the digits\\n        while(NN):\\n            dd += 1\\n            nums.append(NN % 10)\\n            NN //= 10\\n        nums.reverse()\\n        \\n        \\n        # numbers with less digits than that of N\\n        numbers = 0\\n        for i in range(dd-1):\\n            numbers += 9 * (math.factorial(9) // math.factorial(9-i))\\n        \\n        \\n        # find the N-digit numbers (all-different)\\n        already_visited_digits = set()\\n        \\n        def fac2(n, k):\\n            return math.factorial(n) // math.factorial(n-k)\\n        \\n        for i,n in enumerate(nums):\\n            k = 0\\n            for j in range((1 if i==0 else 0), (n+1 if i==dd-1 else n)):\\n                if(j in already_visited_digits):\\n                    continue\\n                k += 1\\n            numbers += k * fac2(10-i-1, dd-i-1)\\n            if n in already_visited_digits:\\n                # All the numbers with this prefix will have at least one common digit\\n                break\\n            already_visited_digits.add(n)\\n            \\n        return N - numbers\", \"def parcfact(m):\\n    return sum([fact(m1)    for m1 in range(1,m)])\\n\\ndef fact(m):\\n    p = 1;\\n    for ii in range(m):\\n        p = p*min(9,10-ii)\\n    return p\\n\\n\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        found = {}\\n        NS = str(N)        \\n        res = parcfact(len(NS))\\n        found = {}\\n        def count(par):\\n#            print(par,len(par),NS)\\n            res = 0\\n            if len(par)==len(NS) and par<=NS:\\n                return 1\\n            elif len(par)<len(NS):\\n                for ii in range(10):\\n                    if par.find(str(ii))<0 and par+str(ii)<=NS[:len(par)+1]:\\n                        if par+str(ii)<NS[:len(par)+1]:\\n                            if not(len(par)) in found:\\n                                found[len(par)] = count(par+str(ii))\\n                            res = res+found[len(par)]\\n                        else:\\n                            res = res+count(par+str(ii))\\n            return res\\n        for ii in range(1,int(NS[0])+1):\\n            res = res+count(str(ii)) \\n#        print(res,print(found))\\n        return(N-res)\\n\"]", "input_output": "{\"fn_name\": \"numDupDigitsAtMostN\", \"inputs\": [[20]], \"outputs\": [1]}", "difficulty": "interview", "url": "https://leetcode.com/problems/numbers-with-repeated-digits/", "starter_code": "\nclass Solution:\n    def numDupDigitsAtMostN(self, N: int) -> int:\n        "}
{"id": 135, "question": "Given two sequences pushed and popped\u00a0with distinct values,\u00a0return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.\n\u00a0\n\nExample 1:\nInput: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\nOutput: true\nExplanation: We might do the following sequence:\npush(1), push(2), push(3), push(4), pop() -> 4,\npush(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1\n\n\nExample 2:\nInput: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\nOutput: false\nExplanation: 1 cannot be popped before 2.\n\n\n\n\u00a0\nConstraints:\n\n0 <= pushed.length == popped.length <= 1000\n0 <= pushed[i], popped[i] < 1000\npushed is a permutation of popped.\npushed and popped have distinct values.", "solutions": "[\"class Solution:\\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        j = 0\\n        l = []\\n        for i in pushed:\\n            l.append(i)\\n            while l and (l[-1] == popped[j]):\\n                l.pop()\\n                j += 1\\n        if l:\\n            return False\\n        return True\", \"class Solution:\\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        if len(pushed) != len(popped):\\n            return False\\n        idx = 0\\n        stack = []\\n        for i in range(len(popped)):\\n            if len(stack) > 0 and stack[-1] == popped[i]:\\n                stack.pop()\\n            else:\\n                while idx < len(pushed) and pushed[idx] != popped[i]:\\n                    stack.append(pushed[idx])\\n                    idx += 1\\n                idx += 1\\n        return len(stack) == 0\\n            \\n\", \"class Solution:\\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        i = 0\\n        j = 0\\n        demo = []\\n        for j in range(len(popped)):\\n            while popped[j] not in demo and i < len(pushed):\\n                demo.append(pushed[i])\\n                i += 1\\n            if demo[-1] == popped[j]:\\n                demo.pop()\\n            else:\\n                return False\\n        return True\", \"class Solution:\\n    \\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        \\n        j = 0\\n        stack = []\\n        for x in pushed:\\n            stack.append(x)\\n            while stack and j < len(popped) and stack[-1] == popped[j]:\\n                print(j, stack)\\n                stack.pop()\\n                j += 1\\n        \\n        return j == len(popped)\", \"class Solution:\\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        l = len(pushed)\\n        i = 0\\n        j = 0\\n        while i < l and j < l:\\n            # print(pushed, popped)\\n            if pushed[i] == popped[j]:\\n                pushed[i] = -1\\n                popped[j] = -1\\n                while i > 0:\\n                    if pushed[i] != -1:\\n                        break\\n                    i -= 1\\n                j += 1\\n            else:\\n                i += 1\\n        \\n        i = 0\\n        j = 0\\n        r_pop = popped[::-1]\\n        while i < l and j < l:\\n            if pushed[i] == -1:\\n                i += 1\\n                continue\\n            if r_pop[j] == -1:\\n                j += 1\\n                continue\\n                \\n            if pushed[i] != popped[j]:\\n                return False\\n            else:\\n                i += 1\\n                j += 1\\n        return True\\n\", \"class Solution:\\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        stack = []\\n        n = len(pushed)\\n        i = j = 0\\n        while True:\\n            if not stack or stack[-1] != popped[j]:\\n                if i >= n:\\n                    return not stack\\n                stack.append(pushed[i])\\n                i += 1\\n            else:\\n                stack.pop()\\n                j += 1\", \"class Solution:\\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        l=[]\\n        j=i=0\\n        for i  in pushed:\\n            l.append(i)\\n            while l and popped and l[-1]==popped[0]:\\n                l.pop()\\n                popped.pop(0)\\n        return len(popped)==0\", \"class Solution:\\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        j=0\\n        stack=[]\\n        for x in pushed:\\n            stack.append(x)\\n            while stack and j<len(popped) and stack[-1]==popped[j]:\\n                stack.pop()\\n                j+=1\\n        return j==len(popped)\", \"class Solution:\\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        i, j, k, n = -1, 0, 0, len(pushed)\\n        while i < n and k < n:\\n            if i >= 0 and pushed[i] == popped[k]:\\n                i -= 1\\n                k += 1\\n            else:\\n                if j >= n:\\n                    break\\n                i += 1\\n                pushed[i] = pushed[j]\\n                j += 1\\n        return i == -1 and k == n\", \"class Solution:\\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        '''\\n        start: 1:27\\n        \\n        edge cases:\\n            not poping entire stack (nm, pushed is a permutation of popped)\\n            \\n        complexity:\\n            O(n) time, O(1) space seems right\\n            \\n        approach:\\n            Let's just build a stack and attempt to pop at each opportunity... Seems simple\\n            Greedy approach, always pop if possible, should work fine due to distinct numbers\\n        '''\\n        \\n        stack = []\\n        \\n        while len(pushed) or len(popped) or len(stack):\\n            if len(stack) and len(popped) and stack[-1] == popped[0]: # can pop\\n                stack.pop()\\n                popped = popped[1:]\\n            elif len(pushed): # can push\\n                stack.append(pushed[0])\\n                pushed = pushed[1:]\\n            else:\\n                return False\\n        return True\\n\", \"class Solution:\\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        push = []\\n        i = 0\\n        while popped:\\n            if i < len(pushed):\\n                push += [pushed[i]]\\n            while push and push[-1] == popped[0]:\\n                popped.pop(0)\\n                push.pop()\\n            # print(push)\\n            # print(popped)\\n            if i < len(pushed):\\n                i += 1\\n            else:\\n                return False\\n        return True\", \"class Solution:\\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        if len(pushed) != len(popped): return False\\n        \\n        stack, i = [], 0\\n        \\n        for j, n in enumerate(pushed):\\n            stack.append(n)\\n            while len(stack) > 0 and popped[i] == stack[-1]:\\n                stack.pop()\\n                i += 1\\n                \\n        return len(stack) == 0\\n\", \"class Solution:\\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        pushed.reverse()\\n        popped.reverse()\\n        \\n        stack = []\\n        while pushed:\\n            value = pushed.pop()\\n            stack.append(value)\\n            while stack and popped and stack[-1] == popped[-1]:\\n                popped.pop()\\n                stack.pop()\\n                \\n        #if not pushed and not popped:\\n        #    return True\\n        if not stack:\\n            return True\\n        return False\\n                \\n\", \"class Solution:\\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        \\n        stack = []\\n        \\n        j = 0\\n        for x in pushed:\\n            stack.append(x)\\n            while stack and j < len(popped) and stack[-1] == popped[j]:\\n                stack.pop()\\n                j+=1\\n                \\n        return True if j == len(popped) else False\", \"class Solution:\\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        \\n        stack = []\\n        push_index = 0\\n        pop_index = 0\\n        n = len(pushed)\\n        \\n        while push_index < n:\\n            \\n            while stack and stack[-1] == popped[pop_index]:\\n                stack.pop()\\n                pop_index += 1\\n            \\n            stack.append(pushed[push_index])\\n            push_index += 1\\n            \\n            while stack and stack[-1] == popped[pop_index]:\\n                stack.pop()\\n                pop_index += 1\\n        \\n        return True if not stack else False\\n\", \"class Solution:\\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        pushed.reverse()\\n        popped.reverse()\\n        \\n        stack = []\\n        while pushed:\\n            #value = pushed.pop()\\n            #stack.append(value)\\n            stack.append(pushed.pop())\\n            while stack and popped and stack[-1] == popped[-1]:\\n                popped.pop()\\n                stack.pop()\\n                \\n        #if not pushed and not popped:\\n        #    return True\\n        if not stack:\\n            return True\\n        return False\\n                \\n\", \"class Solution:\\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        pushed.reverse()\\n        popped.reverse()\\n        \\n        stack = []\\n        while pushed:\\n            value = pushed.pop()\\n            stack.append(value)\\n            while stack and popped and stack[-1] == popped[-1]:\\n                popped.pop()\\n                stack.pop()\\n                \\n        if not pushed and not popped:\\n            return True\\n        return False\\n                \\n\", \"class Solution:\\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        \\n        seen = set()\\n        stack = []\\n        start = 0\\n        for index, element in enumerate(popped):\\n            while element not in seen:\\n                stack.append(pushed[start]   )\\n                seen.add(pushed[start])\\n                start += 1\\n            catch = False\\n            while catch == False:\\n                if catch == False and len(stack) == 0:\\n                    return False\\n                e = stack.pop()\\n                if e == element:\\n                    catch = True\\n                        \\n        return True\\n        \\n        \\n        # 1 2   \\n        \\n        \\n        # #given one element\\n        #     not seen: keep push until we see\\n        #     seen: keep pop until we seen\\n                \\n\", \"class Solution:\\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        stack = []\\n        pop_index = 0\\n        length = len(pushed)\\n        for i in range(length):\\n            stack.append(pushed[i])\\n            while stack[-1] == popped[pop_index]:\\n                print(stack)\\n                stack.pop()\\n                pop_index += 1\\n                if pop_index >= length or len(stack) == 0:\\n                    break\\n                continue\\n        \\n        if len(stack) != 0:\\n            return False\\n        else:\\n            return True\", \"class Solution:\\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        if not pushed:\\n            return True\\n        \\n        temp = []\\n        i = popiter = 0\\n        while i < len(pushed):\\n            if temp and temp[-1] == popped[popiter]:\\n                print(temp,popped[popiter])\\n                temp.pop()\\n                popiter += 1\\n            else:\\n                temp.append(pushed[i])\\n                i += 1\\n        \\n        print(temp,popiter)\\n        while temp:\\n            if temp[-1]==popped[popiter]:\\n                temp.pop()\\n                popiter += 1\\n            else:\\n                return False\\n        return True\"]", "input_output": "{\"fn_name\": \"validateStackSequences\", \"inputs\": [[[1, 2, 3, 4, 5], [4, 5, 3, 2, 1]]], \"outputs\": [true]}", "difficulty": "interview", "url": "https://leetcode.com/problems/validate-stack-sequences/", "starter_code": "\nclass Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        "}
{"id": 136, "question": "In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts\u00a0can be different for different buildings). Height\u00a00 is considered to be a\u00a0building\u00a0as well.\u00a0\nAt the end, the \"skyline\" when viewed from all four directions\u00a0of the grid, i.e.\u00a0top, bottom, left, and right,\u00a0must be the same as the\u00a0skyline of the original grid. A city's skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See\u00a0the following example.\nWhat is the maximum total sum that the height of the buildings can be increased?\nExample:\nInput: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]\nOutput: 35\nExplanation: \nThe grid is:\n[ [3, 0, 8, 4], \n  [2, 4, 5, 7],\n  [9, 2, 6, 3],\n  [0, 3, 1, 0] ]\n\nThe skyline viewed from top or bottom is: [9, 4, 8, 7]\nThe skyline viewed from left or right is: [8, 7, 9, 3]\n\nThe grid after increasing the height of buildings without affecting skylines is:\n\ngridNew = [ [8, 4, 8, 7],\n            [7, 4, 7, 7],\n            [9, 4, 8, 7],\n            [3, 3, 3, 3] ]\n\n\nNotes: \n\n1 < grid.length = grid[0].length <= 50.\nAll heights grid[i][j] are in the range [0, 100].\nAll buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism.", "solutions": "[\"class Solution:\\n    def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:\\n        # Pad with inf to make implementation easier\\n        INF = -10_000\\n        n = len(grid)\\n\\n        total = 0\\n        max_rows = [max(row, default=INF) for row in grid]\\n        # Transpose the grid to make max less cumbersome\\n        max_cols = [max(col, default=INF) for col in zip(*grid)]\\n\\n        for i, best_row in enumerate(max_rows):\\n            for j, best_col in enumerate(max_cols):\\n                new_height = min(best_row, best_col)\\n                total += new_height - grid[i][j]\\n\\n        return total\\n\"]", "input_output": "{\"fn_name\": \"maxIncreaseKeepingSkyline\", \"inputs\": [[[[3, 0, 8, 4], [2, 4, 5, 7], [9, 2, 6, 3], [0, 3, 1, 0], [], []]]], \"outputs\": [0]}", "difficulty": "interview", "url": "https://leetcode.com/problems/max-increase-to-keep-city-skyline/", "starter_code": "\nclass Solution:\n    def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:\n        "}
{"id": 137, "question": "Given an integer n, you must transform it into 0 using the following operations any number of times:\n\nChange the rightmost (0th) bit in the binary representation of n.\nChange the ith bit in the binary representation of n if the (i-1)th bit is set to 1 and the (i-2)th through 0th bits are set to 0.\n\nReturn the minimum number of operations to transform n into 0.\n\u00a0\nExample 1:\nInput: n = 0\nOutput: 0\n\nExample 2:\nInput: n = 3\nOutput: 2\nExplanation: The binary representation of 3 is \"11\".\n\"11\" -> \"01\" with the 2nd operation since the 0th bit is 1.\n\"01\" -> \"00\" with the 1st operation.\n\nExample 3:\nInput: n = 6\nOutput: 4\nExplanation: The binary representation of 6 is \"110\".\n\"110\" -> \"010\" with the 2nd operation since the 1st bit is 1 and 0th through 0th bits are 0.\n\"010\" -> \"011\" with the 1st operation.\n\"011\" -> \"001\" with the 2nd operation since the 0th bit is 1.\n\"001\" -> \"000\" with the 1st operation.\n\nExample 4:\nInput: n = 9\nOutput: 14\n\nExample 5:\nInput: n = 333\nOutput: 393\n\n\u00a0\nConstraints:\n\n0 <= n <= 109", "solutions": "[\"class Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        s = 0\\n        m = n\\n        while m:\\n            s += m & 1\\n            m >>= 1\\n\\n        k = 1\\n        while s:\\n            s -= bool(n & k)\\n            n ^= (s & 1) and k\\n            k <<= 1\\n\\n        return n\", \"class Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        ans = 0\\n        while n:\\n            ans^=n\\n            n//=2\\n        \\n        return ans\\n\", \"class Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        if n <= 1: return n\\n        b = int(math.log2(n)) + 1        \\n        return ((1 << b)-1) - self.minimumOneBitOperations(n - (1 << (b-1)))        \", \"class Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        result = 0\\n        while n:\\n            result = ((n & -n) << 1) - 1 - result\\n            n -= n & -n\\n        return result\", \"from functools import lru_cache\\n\\n# removehigh = [(1 << l) - 1 for l in range(31)]\\n@lru_cache()\\ndef removehigh(l: int) -> int:\\n    if l <= 1:\\n        return l + 1\\n    return (1 << l)\\n    \\n@lru_cache()\\ndef sethigh(l: int, n: int) -> int:\\n    if n == 0:\\n        return removehigh(l) - 1\\n    \\n    t2 = 1 << l - 2\\n    \\n    if n >= t2:\\n        return removehigh(l - 1) + remove(n - t2)\\n    \\n    if n & (n - 1) == 0:\\n        return removehigh(l) - removehigh(n.bit_length())\\n    \\n    return removehigh(l - 1) + sethigh(l - 1, n) \\n\\n    \\n@lru_cache()\\ndef remove(n: int) -> int:\\n    if n <= 1:\\n        return n\\n    elif n <= 3:\\n        return 5 - n\\n    \\n    l = n.bit_length()\\n    if n & (n - 1) == 0:\\n        return removehigh(l) - 1\\n    \\n    t3 = 3 << l - 2\\n    if n >= t3:\\n        return removehigh(l - 1) + remove(n - t3)\\n    \\n    t1 = 1 << l - 1\\n    return removehigh(l - 1) + sethigh(l - 1, n - t1) \\n\\n\\n\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        return remove(n)\\n\", \"class Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        \\n        ans = 0\\n        \\n        while n>0:\\n            ans = ans^n\\n        \\n            n = n>>1\\n        \\n        return ans\", \"class Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        \\n        if n == 0:\\n            return 0\\n        if n == 1:\\n            return 1\\n        \\n        tot = 0\\n        \\n        b = bin(n)[2:]\\n        if b[1] == '0':\\n            tot += 2**(len(b)-2)\\n            \\n        lastChanged = b[1] == '0'\\n        for i in range(2,len(b)):\\n            if (lastChanged and b[i] == '0') or (not lastChanged and b[i] == '1'):\\n                tot += 2**(len(b)-1-i)\\n                lastChanged = True\\n            else:\\n                lastChanged = False\\n        \\n        return tot + 1 + self.minimumOneBitOperations(int('1' + '0'*(len(b)-2),2))\\n\", \"from functools import lru_cache\\n\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        return self.toZero(n)\\n    \\n    @lru_cache(maxsize=None)\\n    def toZero(self, n):\\n        if n <= 1:\\n            return n\\n        elif n == 2:\\n            return 3\\n        elif n == 3:\\n            return 2\\n        \\n        offset = 0\\n        while ((1 << (offset + 1)) - 1) & n != n:\\n            offset += 1\\n        \\n        target = 1 << (offset - 1)\\n        return self.topower2(n & ((target << 1) - 1), target) + 1 + self.toZero(target)\\n    \\n    @lru_cache(maxsize=None)\\n    def topower2(self, n, target):\\n        if n == 0:\\n            return 1 + self.topower2(1, target)\\n        elif n == target:\\n            return 0\\n        \\n        offset = 0\\n        while ((1 << (offset + 1)) - 1) & n != n:\\n            offset += 1\\n             \\n        if n & target == 0:\\n            return self.topower2(n, target >> 1) + 1 + self.toZero(target >> 1)\\n        \\n        return self.toZero(n & (target - 1))\\n        \\n\"]", "input_output": "{\"fn_name\": \"minimumOneBitOperations\", \"inputs\": [[0]], \"outputs\": [0]}", "difficulty": "interview", "url": "https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/", "starter_code": "\nclass Solution:\n    def minimumOneBitOperations(self, n: int) -> int:\n        "}
{"id": 138, "question": "Given an array of integers\u00a0nums, find\u00a0the maximum length of a subarray where the product of all its elements is positive.\nA subarray of an array is a consecutive sequence of zero or more values taken out of that array.\nReturn\u00a0the maximum length of a subarray with positive product.\n\u00a0\nExample 1:\nInput: nums = [1,-2,-3,4]\nOutput: 4\nExplanation: The array nums already has a positive product of 24.\n\nExample 2:\nInput: nums = [0,1,-2,-3,-4]\nOutput: 3\nExplanation: The longest subarray with positive product is [1,-2,-3] which has a product of 6.\nNotice that we cannot include 0 in the subarray since that'll make the product 0 which is not positive.\nExample 3:\nInput: nums = [-1,-2,-3,0,1]\nOutput: 2\nExplanation: The longest subarray with positive product is [-1,-2] or [-2,-3].\n\nExample 4:\nInput: nums = [-1,2]\nOutput: 1\n\nExample 5:\nInput: nums = [1,2,3,5,-6,4,0,10]\nOutput: 4\n\n\u00a0\nConstraints:\n\n1 <= nums.length <= 10^5\n-10^9 <= nums[i]\u00a0<= 10^9", "solutions": "[\"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        maxx = 0\\n        nums.append(0)\\n        \\n        # starting position\\n        # where we find a 0\\n        i = -1\\n        minusarr = []\\n        \\n        for j,n in enumerate(nums):\\n            if n == 0:\\n                # now figure out previous ones\\n                tot = j-i-1\\n                if not minusarr or len(minusarr)%2 == 0:\\n                    maxx = max(maxx, tot)\\n                else:\\n                    # drop the first or last 0\\n                    left = minusarr[0]-i\\n                    right = j-minusarr[-1]\\n                    maxx = max(maxx, tot - min(left, right))\\n                \\n                # reinitiate\\n                minusarr = []\\n                i = j\\n            elif n < 0:\\n                minusarr.append(j)\\n        return maxx\", \"class Solution:\\n    def getMaxLen(self, a: List[int], having_zero=True) -> int:\\n        if not a: return 0\\n        if having_zero: \\n            zeros = [i for i, x in enumerate(a) if x == 0]        \\n            ans, prev = -float('inf'), 0            \\n            for i in zeros:\\n                ans = max(ans, self.getMaxLen(a[prev:i], False))\\n                prev = i+1\\n            ans = max(ans, self.getMaxLen(a[prev:], False))\\n            return ans        \\n        negs = [i for i, x in enumerate(a) if x < 0]\\n        if len(negs) % 2 == 0: return len(a)\\n        return max(negs[-1], len(a) - negs[0] - 1)\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        # Greedy alg\\n        l = len(nums)\\n        start = 0\\n        subArrays = []\\n        for i in range(l):\\n            if nums[i] == 0:\\n                subArrays.append(self.findOptimal(nums[start:i]))\\n                start = i+1\\n                end = i+1\\n        \\n        subArrays.append(self.findOptimal(nums[start:l]))\\n        \\n        return max(subArrays)\\n    \\n    def findOptimal(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        negs = 0\\n        l = 0\\n        for i in nums:\\n            l += 1\\n            if i < 0: negs += 1\\n        \\n        if negs % 2 == 0:\\n            return l\\n        else:\\n            # Two pointers approach\\n            i = 0\\n            j = l - 1\\n            while i < j:\\n                if nums[i] < 0 or nums[j] < 0:\\n                    return l - 1\\n                i += 1\\n                j -= 1\\n                l -= 1\\n        \\n        #return max(self.findOptimal(nums[1:]), self.findOptimal(nums[:-1]))\\n        return 0\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        \\n        pos_p=0\\n        neg_p=0\\n        \\n        pos,neg=0,0\\n        \\n        result=0\\n        for i in range( len(nums)):\\n            \\n            pos_p,neg_p=pos,neg\\n            \\n            if nums[i] > 0:\\n                pos= 1 + pos_p\\n                neg= 1 + neg_p if neg_p > 0 else 0\\n                \\n            elif nums[i] < 0:\\n                pos= (1 + neg_p) if neg_p > 0 else 0\\n                neg= (1 + pos_p) if pos_p > 0 else 1\\n            else:\\n                pos,neg=0,0\\n            result=max(result, pos)\\n            \\n        return result\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        # 3:58 9/1/2020\\n        # Max len of subarray with positive Product\\n        \\n        last={1:-1}\\n        pro=1\\n        ans=0\\n        for i,c in enumerate(nums):\\n            pro = c * pro / abs(pro) if pro != 0 else 0\\n            \\n            if pro>0:\\n                ans=max(i-last[1],ans)\\n                \\n            elif pro<0:\\n                if -1 in last:\\n                    ans=max(ans,i-last[-1])\\n                else:\\n                    last[-1]=i\\n            elif pro==0:\\n                pro=1\\n                last={}\\n                last[1]=i\\n          \\n        return ans \\n                        \\n                    \\n                \\n        \\n        \\n \\n        \\n\\n                    \\n                    \\n                    \\n                    \\n                \\n            \\n        \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [[0] * (n+1) for i in range(2)]\\n        for i, x in enumerate(nums):\\n            if x > 0:\\n                dp[0][i+1] = dp[0][i] + 1\\n                if dp[1][i] > 0:\\n                    dp[1][i+1] = dp[1][i] + 1\\n            elif x < 0:\\n                if dp[1][i] > 0:\\n                    dp[0][i+1] = dp[1][i] + 1\\n                dp[1][i+1] = dp[0][i] + 1\\n            else:\\n                dp[0][i+1] = dp[1][i+1] = 0\\n                \\n        # print(dp)\\n        return max(dp[0])\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        pos,neg=0,0\\n        [0,1,-2,-3,-4]\\n        if nums[0]>0:\\n            pos=1\\n        if nums[0]<0:\\n            neg=1\\n        ans=pos\\n        for i in range(1,n):\\n            if nums[i]>0:\\n                pos = 1 + pos\\n                neg = 1 + neg if neg >0 else 0\\n            elif nums[i]<0:\\n                pre_pos,pre_neg=pos,neg\\n                pos= 1 + pre_neg if pre_neg >0 else 0\\n                neg = 1 + pre_pos\\n            else:\\n                pos,neg =0,0\\n            ans = max(ans,pos)\\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        plus,minus,res,c = 0,-1,0,0\\n        for i in range(0,len(nums)):\\n            if nums[i] == 0:\\n                if c%2 == 1:\\n                    res = max(res,minus)\\n                else:\\n                    res = max(res,max(plus,minus))\\n                plus,minus,c = 0,-1,0\\n            elif nums[i] > 0:\\n                if minus != -1: \\n                    minus += 1\\n                plus += 1\\n            else:\\n                c += 1\\n                minus += 1\\n                if c%2 == 1:\\n                    res = max(res,max(minus,plus))\\n                plus += 1\\n        if c%2 == 1:\\n            res = max(res,minus)\\n        else:\\n            res = max(res,max(plus,minus))\\n        return res\\n        \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n        pos, neg = [0] * n, [0] * n\\n        if nums[0] > 0: pos[0] = 1\\n        if nums[0] < 0: neg[0] = 1\\n        ans = pos[0]\\n        for i in range(1, n):\\n            if nums[i] > 0:\\n                pos[i] = 1 + pos[i - 1]\\n                neg[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\\n            elif nums[i] < 0:\\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\\n                neg[i] = 1 + pos[i - 1]\\n            ans = max(ans, pos[i])\\n        return ans\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        def solve(nums):\\n            cnt = 0\\n            for n in nums:\\n                if n < 0:\\n                    cnt += 1\\n            if cnt%2 == 0:\\n                return len(nums)\\n            for i in range(len(nums)):\\n                if nums[i] < 0:\\n                    first = i\\n                    break\\n            for i in range(len(nums)-1, -1, -1):\\n                if nums[i] < 0:\\n                    last = i\\n                    break\\n            return max(last, len(nums)-first-1)\\n        \\n        l = 0\\n        ans = 0\\n        nums.append(0)\\n        for r in range(len(nums)):\\n            if nums[r] == 0:\\n                cur = solve(nums[l:r])\\n                ans = max(ans, cur)\\n                l = r+1\\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        @lru_cache(None)\\n        def pos_helper(len):\\n            if len == 0:\\n                return 0\\n            if len == 1:\\n                return 1 if nums[0] > 0 else 0\\n            if nums[len - 1] > 0:\\n                return pos_helper(len - 1) + 1\\n            if nums[len - 1] == 0:\\n                return 0\\n            if nums[len - 1] < 0:\\n                return neg_helper(len - 1) + 1 if neg_helper(len - 1) != 0 else 0\\n\\n        @lru_cache(None)\\n        def neg_helper(len):\\n            if len == 0:\\n                return 0\\n            if len == 1:\\n                return 1 if nums[0] < 0 else 0\\n            if nums[len - 1] > 0:\\n                return neg_helper(len - 1) + 1 if neg_helper(len - 1) > 0 else 0\\n            if nums[len - 1] == 0:\\n                return 0\\n            if nums[len - 1] < 0:\\n                return pos_helper(len - 1) + 1\\n\\n        res = 0\\n        for i in range(0, len(nums) + 1):\\n            res = max(res, pos_helper(i))\\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        pos, neg = 0, 0\\n        if nums[0] > 0: pos = 1\\n        if nums[0] < 0: neg = 1\\n        ans = pos\\n        for i in range(1, n):\\n            if nums[i] > 0:\\n                pos_next = 1 + pos\\n                neg_next = 1 + neg if neg > 0 else 0\\n            elif nums[i] < 0:\\n                pos_next = 1 + neg if neg > 0 else 0\\n                neg_next = 1 + pos\\n            else:\\n                pos_next, neg_next = 0, 0\\n            pos, neg = pos_next, neg_next\\n            ans = max(ans, pos)\\n        return ans\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        maxlen = 0\\n        curlen = 0\\n        tmplen = 0\\n        even = True \\n        for i in nums:\\n            if i == 0:\\n                if tmplen != curlen:\\n                    # We meet odd numbers of negative number, check if the rest is larger\\n                    maxlen = max(maxlen, tmplen - curlen - 1)\\n                maxlen = max(maxlen, curlen)\\n                curlen = 0\\n                tmplen = 0\\n                even = True\\n                continue\\n            tmplen += 1    \\n            if i < 0:    \\n                even = not even\\n                if even == True:\\n                    curlen = tmplen        \\n            if i > 0 and even == True:\\n                curlen += 1      \\n        if tmplen != curlen:\\n            # We meet odd numbers of negative number, check if the rest is larger\\n            maxlen = max(maxlen, tmplen - curlen - 1)\\n        maxlen = max(maxlen, curlen)        \\n        \\n        curlen = 0\\n        tmplen = 0\\n        even = True \\n        for i in reversed(nums):\\n            if i == 0:\\n                if tmplen != curlen:\\n                    # We meet odd numbers of negative number, check if the rest is larger\\n                    maxlen = max(maxlen, tmplen - curlen - 1)\\n                maxlen = max(maxlen, curlen)\\n                curlen = 0\\n                tmplen = 0\\n                even = True\\n                continue\\n            tmplen += 1    \\n            if i < 0:    \\n                even = not even\\n                if even == True:\\n                    curlen = tmplen        \\n            if i > 0 and even == True:\\n                curlen += 1      \\n        if tmplen != curlen:\\n            # We meet odd numbers of negative number, check if the rest is larger\\n            maxlen = max(maxlen, tmplen - curlen - 1)\\n        maxlen = max(maxlen, curlen)        \\n        \\n        return maxlen       \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        pos = 1 if nums[0]>0 else 0\\n        neg = 1 if nums[0]<0 else 0\\n        \\n        ans = pos\\n        \\n        for i in range(1,len(nums)):\\n            if nums[i]>0:\\n                pos = 1+pos\\n                neg = 1+neg if neg>0 else 0\\n            elif nums[i]<0:\\n                pre_pos = pos\\n                pos = 1+neg if neg>0 else 0\\n                neg = 1+pre_pos\\n            else:\\n                pos, neg = 0, 0\\n                \\n            ans = max(ans,pos)\\n            \\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        result = 0\\n        negativeIndices = []\\n        currentProduct = 1\\n        startIndex = 0\\n        \\n        for index,number in enumerate(nums):\\n            if number == 0:\\n                negativeIndices = []\\n                currentProduct = 1\\n                startIndex = index + 1\\n                continue\\n        \\n            if number * currentProduct > 0:\\n                result = max(result,index-startIndex+1)\\n                currentProduct = 1\\n            \\n            else: \\n                if len(negativeIndices) != 0:\\n                    result = max(result,index-negativeIndices[0])\\n                currentProduct = -1\\n            \\n            if number < 0 and len(negativeIndices) == 0:\\n                negativeIndices.append(index)\\n  \\n        return result\", \"class Solution:\\n    def getMaxLen(self, A: List[int], cnt = 0, best = 0) -> int:\\n        A.append(0)                    # \\u2b50\\ufe0f sentinel value\\n        N = len(A)\\n        i = 0\\n        j = 0\\n        while i < N:\\n            while j < N and not A[j]:  # \\u2796 case 1: collapse window [i \\\\\\\\U0001f449 ..j]\\n                while i < j:\\n                    cnt = cnt - 1 if A[i] < 0 else cnt; i += 1\\n                    best = best if cnt & 1 else max(best, j - i)\\n                i = j + 1\\n                j = j + 1\\n            while j < N and A[j]:      # \\u2795 case 2: expand window [i..j \\\\\\\\U0001f449 ]\\n                cnt = cnt + 1 if A[j] < 0 else cnt; j += 1\\n                best = best if cnt & 1 else max(best, j - i)\\n        return best\\n    \\n    \\n    \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        pos = 0\\n        neg = 0\\n        negIndex = 0\\n        res = 0\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                pos = 0\\n                neg = 0\\n            elif nums[i] > 0:\\n                pos += 1\\n            else:\\n                neg += 1\\n                if neg == 1:\\n                    negIndex = i\\n                \\n            if neg % 2 == 0:\\n                res = max(res, pos + neg)\\n            else:\\n                res = max(res, i - negIndex)\\n        return res \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        pointer1=0\\n        pointer2=0\\n        res=0\\n        while(pointer1<len(nums)):\\n            if nums[pointer1]==0:\\n                pointer1+=1\\n                continue\\n            pointer2=pointer1\\n            count=0\\n            start=0\\n            end=0\\n            while(pointer2<len(nums) and nums[pointer2]!=0):\\n                if nums[pointer2]<0:\\n                    count+=1\\n                    if count==1:\\n                        start=pointer2\\n                    end=pointer2\\n                pointer2+=1\\n            if count%2==0:\\n                res=max(res,pointer2-pointer1)\\n            else:\\n                res=max(res,end-pointer1,pointer2-start-1)\\n            pointer1=pointer2\\n            \\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n\\n        n = len(nums)\\n        negNum = 0\\n        firstNegIdx = -1\\n        zeroPos = -1\\n        res = 0\\n        \\n        for i, num in enumerate(nums):\\n            if num < 0:\\n                negNum += 1\\n                if firstNegIdx < 0: firstNegIdx = i\\n            \\n            if num == 0:\\n                negNum = 0\\n                firstNegIdx = -1\\n                zeroPos = i\\n            else:\\n                if negNum % 2 == 0:\\n                    res = max(res, i - zeroPos)\\n                else:\\n                    res = max(res, i - firstNegIdx)\\n                    \\n        return res\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        res, pos, neg = 0, 0, 0\\n        for num in nums:\\n            if num == 0:\\n                pos, neg = 0, 0\\n            elif num > 0:\\n                if neg != 0: neg, pos = neg+1, pos+1\\n                else: neg, pos = 0, pos+1\\n            else:\\n                if neg != 0: pos, neg = neg+1, pos+1\\n                else: neg, pos = pos+1, 0\\n            res = max(res, pos)\\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        ans=0\\n        mn=0\\n        mp=0\\n        for i in nums:\\n            if i==0:\\n                mn,mp=0,0\\n            elif i>0:\\n                mp+=1\\n                if mn!=0:\\n                    mn+=1\\n                else:mn=0\\n            else:\\n                omn=mn\\n                mn=mp+1\\n                if omn!=0:\\n                    mp=omn+1\\n                else:\\n                    mp=0\\n            ans=max(mp,ans)\\n        return ans\\n                    \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        # dp = [[0 for i in range(2)]  for j in  range(len(nums) + 1)]\\n        # res = 0\\n        # for i, num in enumerate(nums):\\n        #     if num == 0:\\n        #         dp[i + 1][0] = dp[i + 1][1] = 0\\n        #     elif num > 0:\\n        #         dp[i + 1][0] = dp[i][0] + 1\\n        #         dp[i + 1][1] = dp[i][1] + 1 if dp[i][1] else 0\\n        #     else:\\n        #         dp[i + 1][0] = dp[i][1] + 1 if dp[i][1] else 0\\n        #         dp[i + 1][1] = dp[i][0] + 1\\n        #     res = max(res, dp[i + 1][0])\\n        # return res\\n        pos_num = neg_num = res = 0\\n        for i, num in enumerate(nums):\\n            if num == 0:\\n                pos_num = neg_num = 0\\n            elif num > 0:\\n                neg_num = neg_num + 1 if neg_num else 0\\n                pos_num += 1\\n            else:\\n                cur_pos = pos_num\\n                pos_num = neg_num + 1 if neg_num else 0\\n                neg_num = cur_pos + 1\\n            res = max(res, pos_num)\\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        def helper(arr):\\n            inds = []\\n            for i,num in enumerate(arr):\\n                if num<0:\\n                    inds.append(i)\\n            if len(inds)%2==0:\\n                return len(arr)\\n            else:\\n                first = max(inds[0],len(arr)-inds[0]-1)\\n                second = max(inds[-1],len(arr)-inds[-1]-1)\\n                return max(first,second)\\n                \\n            \\n        temp = []\\n        for i,num in enumerate(nums):\\n            if num==0:\\n                temp.append(i)\\n        pos = []\\n        if temp:\\n            if nums[:temp[0]]:\\n                pos.append(nums[:temp[0]])\\n            for i in range(0,len(temp)-1):\\n                pos.append(nums[temp[i]+1:temp[i+1]])\\n            if nums[temp[-1]+1:]:\\n                pos.append(nums[temp[-1]+1:])\\n        else:\\n            pos.append(nums)\\n        ans = 0\\n        for arr in pos:\\n            ans = max(ans,helper(arr))\\n        return ans\\n            \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        lists = [[]]\\n        negative = [[]]\\n        index = 0\\n        for num in nums:\\n            if num == 0:\\n                index = 0\\n                negative.append([])\\n                lists.append([])\\n            else:\\n                if num < 0:\\n                    negative[-1].append(index)\\n                lists[-1].append(num)\\n                index += 1\\n\\n        max_len = 0\\n        for l, neg in zip(lists, negative):\\n            if len(neg) % 2 == 1:\\n                dist = min(neg[0] + 1, len(l) - neg[-1])\\n            else:\\n                dist = 0\\n            max_len = max(len(l) - dist, max_len)\\n        \\n        return max_len\\n\", \"import copy\\nimport math\\nclass Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        positive,negative = 0,0\\n        length = 0\\n        for n in nums:\\n            if  n == 0:\\n                positive,negative = 0,0\\n            elif n > 0:\\n                if negative > 0 : positive,negative = positive+1,negative+1\\n                else: positive,negative = positive+1,0\\n            else:\\n                if negative > 0 : positive,negative = negative+1,positive+1\\n                else: positive,negative = 0,positive+1\\n            length = max(length,positive)\\n        return length\", \"import numpy as np\\nclass Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        if len(nums)==0: return (0)\\n        if len(nums)==1:return( 1 if nums[0]>0 else 0)\\n        St=[i for i,j in enumerate(nums) if (i==0 and j!=0) or (nums[i-1]==0 and j!=0)]\\n        if len(St)==0: return (0)\\n        Ed=[i for i,j in enumerate(nums) if (i==len(nums)-1 and j!=0) or (i<len(nums)-1 and nums[i+1]==0 and j!=0)]\\n        # print(St,Ed)\\n        Sta=np.array(St)\\n        Eda=np.array(Ed)\\n        Lns=(-(Eda-Sta+1)).argsort()\\n        # print(Lns)\\n        k=0\\n        mxLen=0\\n        while(k<len(Lns)):\\n            nums1=nums[St[Lns[k]]:(Ed[Lns[k]]+1)]\\n            if len(nums1)==mxLen: return(mxLen)\\n            ni=[i for i,j in enumerate(nums1) if j<0]\\n            if len(ni)==0 or len(ni)%2==0:mxLen=max(mxLen,len(nums1))\\n            else:\\n                mn=min(ni)\\n                mx=max(ni)\\n                mxLen= max(mxLen,mn,len(nums1)-mn-1,mx,len(nums1)-mx-1)\\n            k=k+1\\n        return(mxLen)\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        p = 1\\n        j = None\\n        k = -1\\n        m = 0\\n        for i, n in enumerate(nums):\\n            if not n:\\n                p = 1\\n                j = None\\n                k = i\\n            else:\\n                if n < 0:\\n                    p *= -1\\n                elif not n:\\n                    p = 0\\n                if p > 0:\\n                    m = max(m, i-k)\\n                elif p < 0:\\n                    if j is None:\\n                        j = i\\n                    else:\\n                        m = max(m, i-j)\\n        return m\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        # DP may be unnecessary, but because I saw max length subarray\\n        # I assumed that it would be DP. Solution approach was DP-esque\\n        # but it doesn't seem necessary.\\n        # Seems like another way could be to just count the number of\\n        # negatives (between 0s).\\n        p = 0\\n        n = 0\\n        longest_p = 0\\n        for num in nums:\\n            longest_p = max(longest_p, p)\\n            if num == 0:\\n                p = 0\\n                n = 0\\n            elif num > 0:\\n                prev_p = p\\n                prev_n = n\\n                p = prev_p + 1\\n                if prev_n > 0:\\n                    n = prev_n + 1\\n                else:\\n                    n = 0\\n            elif num < 0:\\n                prev_p = p\\n                prev_n = n\\n                n = prev_p + 1\\n                if prev_n > 0:\\n                    p = prev_n + 1\\n                else:\\n                    p = 0\\n        longest_p = max(longest_p, p)\\n        return longest_p\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1:\\n            return 1 if nums[0] > 0 else 0 \\n        p1 = p2 = 0\\n        answer = 0\\n        curr_len = 0 \\n        neg_indx = deque([])\\n        while p2 < n:\\n            num = nums[p2]\\n            if num == 0:\\n                answer = max(answer, curr_len)\\n                curr_len = 0 \\n                p2 += 1\\n                p1 = p2 \\n                neg_indx = deque([])\\n            elif num > 0:\\n                curr_len += 1 \\n                answer = max(answer, curr_len) \\n                p2 += 1 \\n            else:\\n                neg_indx.append(p2)\\n                j = p2+1\\n                found = False\\n                while j < n:\\n                    num2 = nums[j]\\n                    if num2 <= 0:\\n                        if num2 < 0:\\n                            neg_indx.append(j)\\n                            found = True \\n                        break\\n                    j += 1 \\n                if found:\\n                    curr_len += (j-p2+1)\\n                    answer = max(answer, curr_len)\\n                    if j == n-1:\\n                        return answer \\n                    else:\\n                        p2 = j + 1 \\n                else: \\n                    first_neg = neg_indx.popleft()\\n                    while p1 <= first_neg:\\n                        p1 += 1\\n                        curr_len -= 1\\n                    if p1 > p2:\\n                        p2 = p1\\n                        answer = max(answer, curr_len)\\n                        curr_len = 0 \\n                    else:\\n                        curr_len += 1\\n                        p2 += 1\\n                    continue  \\n        return answer \\n    \\n    \\n#[1, -4, 3, 2, 0, 2, -2, 3, -2, -2, 3, 4, 5]\\n\", \"class Solution:\\n    def getMaxLen(self, nums):\\n        \\n        if len(nums) == 0:\\n            return True\\n        \\n        result = 0\\n        count = 0\\n        zero_marker = -1\\n        negative_marker = -1\\n       \\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                zero_marker = i\\n                count = 0\\n                negative_marker = -1\\n                \\n\\n            else:\\n                if nums[i] < 0:\\n                    count += 1\\n                    if negative_marker == -1:\\n                        negative_marker = i\\n            \\n                if count % 2 == 0:\\n                    result = max(result, i - zero_marker)\\n                else:\\n                    result = max(result, i - negative_marker)\\n        return result      \", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        neg = pos = res = 0\\n        for n in nums:\\n            if n == 0:\\n                neg = pos = 0\\n            elif n > 0:\\n                if neg:\\n                    neg += 1\\n                pos += 1\\n            else:\\n                pos, neg = neg + 1 if neg else 0, pos + 1\\n            res = max(res, pos)\\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        def get_val(nums):\\n            # print(nums)\\n            if len(nums) == 0:\\n                return 0\\n            products = [1]\\n            product = 1\\n            length = len(nums)\\n            for i in range(length):\\n                product *= nums[i]\\n                products.append(product)\\n            for j in range(length, 0, -1):\\n                for k in range(length-j+1):\\n                    value = products[k+j]//products[k]\\n                    if value>0:\\n                        return j\\n            return 0\\n        index = 0\\n        maximum = 0\\n        for i in range(n):\\n            if nums[i] == 0:\\n                if i == index:\\n                    index += 1\\n                    continue\\n                value = get_val(nums[index:i])\\n                if value>maximum:\\n                    maximum = value\\n                index = i+1\\n            elif nums[i]>0:\\n                nums[i] = 1\\n            else:\\n                nums[i] = -1\\n        value = get_val(nums[index:n])\\n        if value>maximum:\\n            maximum = value\\n        return maximum\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        maxl = 0\\n        pos = 0\\n        neg = 0\\n        for n in nums:\\n            if n == 0:\\n                pos, neg = 0, 0\\n            elif n > 0:\\n                pos += 1\\n                neg = neg + 1 if neg != 0 else 0\\n            elif n < 0:\\n                oldneg = neg\\n                neg = pos + 1\\n                pos = oldneg + 1 if oldneg > 0 else 0\\n            maxl = max(maxl, pos)\\n        \\n        return maxl\\n                \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        def oddMinus(ls):\\n            ret = 0\\n            for i in range(len(ls)):\\n                if ls[i] < 0:\\n                    ret = max(max(ret, i), len(ls)-1-i)\\n            return ret\\n        \\n        def getLen(ls):\\n            minus = 0\\n            for i in ls:\\n                if i < 0:\\n                    minus += 1\\n            if(minus % 2 == 0):\\n                return len(ls)\\n            else:\\n                return oddMinus(ls)\\n        \\n        \\n        s = []\\n        sub = []\\n        for i in nums:\\n            if i == 0:\\n                s.append(sub)\\n                sub = []\\n            else:\\n                sub.append(i)\\n        s.append(sub)\\n        \\n        res = 0\\n        \\n        for ls in s:\\n            res = max(res, getLen(ls))\\n            \\n        return res\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        l = []\\n        neg = []\\n        index = 0\\n        max_len = 0\\n        for num in nums:\\n            if num == 0:\\n                index = 0\\n                if len(neg) % 2 == 1:\\n                    dist = min(neg[0] + 1, len(l) - neg[-1])\\n                else:\\n                    dist = 0\\n                max_len = max(len(l) - dist, max_len)\\n                l.clear()\\n                neg.clear()\\n            else:\\n                if num < 0:\\n                    neg.append(index)\\n                l.append(num)\\n                index += 1\\n        \\n        if len(neg) % 2 == 1:\\n            dist = min(neg[0] + 1, len(l) - neg[-1])\\n        else:\\n            dist = 0\\n        max_len = max(len(l) - dist, max_len)\\n\\n        return max_len\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n\\n        n = len(nums)\\n        pos, neg = [0] * n, [0] * n\\n        if nums[0] > 0: pos[0] = 1\\n        if nums[0] < 0: neg[0] = 1\\n        ans = pos[0]\\n        for i in range(1, n):\\n            if nums[i] > 0:\\n                pos[i] = 1 + pos[i - 1]\\n                neg[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\\n            elif nums[i] < 0:\\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\\n                neg[i] = 1 + pos[i - 1]\\n            ans = max(ans, pos[i])\\n        return ans\\n\\n\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        ret = 0\\n        pos, neg = -1, None\\n        curr = 0\\n        for i, n in enumerate(nums):\\n            if n == 0:\\n                pos, neg = i, None\\n                curr = 0\\n            else:\\n                if n < 0:\\n                    curr = 1 - curr\\n            \\n                if curr == 0:    \\n                    ret = max(ret, i - pos)\\n                \\n                if curr == 1:\\n                    if neg is not None:\\n                        ret = max(ret, i - neg)\\n                    else:\\n                        neg = i\\n        return ret\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        nums.append(0)\\n        start = -1\\n        i = 0\\n        firstn = -1\\n        maxl = 0\\n        nneg = 0\\n        while i<len(nums):\\n            if nums[i]<0:\\n                nneg += 1\\n                if firstn<0: firstn = i\\n                lastn = i\\n            elif nums[i] == 0:\\n                if nneg%2 == 0:\\n                    maxl = max(maxl,i-start-1)\\n                else:\\n                    maxl = max([maxl,lastn-start-1,i-firstn-1])\\n                start = i\\n                nneg = 0\\n                firstn = -1\\n            i += 1\\n        return maxl\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        pos, neg = [0] * n, [0] * n\\n        if nums[0] > 0: pos[0] = 1\\n        if nums[0] < 0: neg[0] = 1\\n        ans = pos[0]\\n        for i in range(1, n):\\n            if nums[i] > 0:\\n                pos[i] = 1 + pos[i - 1]\\n                neg[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\\n            elif nums[i] < 0:\\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\\n                neg[i] = 1 + pos[i - 1]\\n            ans = max(ans, pos[i])\\n        return ans\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        def dfs(start):\\n            i = start\\n            if i >= len(nums):\\n                return 0\\n            ret = 0\\n            stack = []\\n            while i < len(nums):\\n                if nums[i] == 0:\\n                    break\\n                elif nums[i] < 0:\\n                    stack.append(i)\\n                i+=1\\n            if len(stack) % 2 == 0:\\n                ret = i - start\\n            else:\\n                ret = max(i-1-stack[0],stack[-1]-start)\\n            \\n            return max(ret,dfs(i+1))\\n        return dfs(0)\\n                    \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        def solve(arr):\\n            maxy = 0\\n            count = 0\\n            for i in j:\\n                if i < 0:\\n                    count += 1\\n            if count % 2 == 0:\\n                maxy = max(maxy,len(j))\\n            else:\\n                for i in range(len(j)):\\n                    if j[i] < 0:\\n                        m1 = i \\n                        m2 = len(j) - m1 -1 \\n                        m3 = max(m1,m2)\\n                        maxy = max(maxy,m3)\\n                        break\\n                for i in range(len(j)-1,-1,-1):\\n                    if j[i] < 0:\\n                        m1 = i \\n                        m2 = len(j) - m1 - 1 \\n                        m3 = max(m1,m2)\\n                        maxy = max(maxy,m3)\\n                        break\\n            return maxy\\n        res = []\\n        maxy = 0\\n        flag = 1\\n        i = 0\\n        for j in range(i,len(nums)):\\n            if nums[j] == 0:\\n                res.append(nums[i:j])\\n                i = j+1\\n                flag = 0\\n        if flag == 1:\\n            res.append(nums)\\n        elif flag == 0:\\n            res.append(nums[i:])\\n        nums = res\\n        for j in nums:\\n            maxy = max(maxy,solve(j))\\n        return maxy\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        firstNeg = -1\\n        zeroPos = -1\\n        cnt = 0\\n        ret = 0\\n        for i, n in enumerate(nums):\\n            if n < 0:\\n                cnt += 1\\n                if firstNeg == -1:\\n                    firstNeg = i\\n            elif not n:\\n                firstNeg, cnt = -1, 0\\n                zeroPos = i\\n            if cnt % 2:\\n                ret = max(ret, i - firstNeg)\\n            else:\\n                ret = max(ret, i - zeroPos)\\n        return ret\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        pos = neg = max_len = 0\\n        \\n        for n in nums:\\n            if n > 0:\\n                neg = (1 + neg) if neg > 0 else 0\\n                pos = (1 + pos)                \\n            elif n < 0:\\n                #n1 = neg\\n                #neg = (1 + pos)\\n                pos, neg = (1 + neg) if neg > 0 else 0, 1+pos\\n                 \\n            else:\\n                pos = neg = 0\\n\\n                \\n            max_len = max(max_len, pos)\\n        return max_len\\n\", \"class Solution:\\n    def getMaxLen(self, arr: List[int]) -> int:\\n        i=0\\n        while i<=len(arr)-1 and arr[i]==0:\\n            i+=1\\n        arr=arr[i:]\\n        if len(arr)==0:\\n            return 0\\n        i=len(arr)-1\\n        while i<=len(arr)-1 and arr[i]==0:\\n            i-=1\\n        arr=arr[:i+1]\\n        if len(arr)==0:\\n            return 0\\n        array=[]\\n        low=0\\n        high=0\\n        ans=[]\\n        while low <len(arr):\\n            while  high<len(arr) and arr[high] != 0:\\n                high+=1\\n            if high == len(arr)-1:\\n                break\\n            else:\\n                array.append(arr[low:high])\\n                while high<len(arr) and arr[high]==0:\\n                    high+=1\\n                low=high\\n        for a in array:\\n            if len(a)==0:\\n                continue\\n            else:\\n                total=0\\n                first=0\\n                last=0\\n                for i in range(len(a)):\\n                    if a[i]<0:\\n                        total+=1\\n                if total%2==0:\\n                    ans.append(len(a))\\n                else:\\n                    i=0\\n                    while a[i]>0:\\n                        i+=1\\n                    first=len(a)-(i+1)\\n                    i=len(a)-1\\n                    while a[i]>0:\\n                        i-=1\\n                    last=i\\n                    \\n                ans.append(max(first,last))\\n        ma=0\\n        for i in ans:\\n            if i>ma:\\n                ma=i\\n        return ma\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        out = 0\\n        first = -1\\n        last = -1\\n        negs = 0\\n        start = 0\\n        for i,num in enumerate(nums):\\n            if num == 0:\\n                if negs % 2 == 0:\\n                    new_max = i-start\\n                else:\\n                    new_max = max(i-first-1,last-start)\\n                out = max(out,new_max)\\n                first = -1\\n                last = -1\\n                negs = 0\\n                start = i+1\\n            if num < 0:\\n                negs += 1\\n                if first == -1:\\n                    first = i\\n                last = i\\n        i+=1\\n        if negs % 2 == 0:\\n            new_max = i-start\\n        else:\\n            new_max = max(i-first-1,last-start)\\n        out = max(out,new_max)\\n        return out\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        dp = [[0 for i in range(2)]  for j in  range(len(nums) + 1)]\\n        res = 0\\n        for i, num in enumerate(nums):\\n            if num == 0:\\n                dp[i + 1][0] = dp[num][1] = 0\\n            elif num > 0:\\n                dp[i + 1][0] = dp[i][0] + 1\\n                dp[i + 1][1] = dp[i][1] + 1 if dp[i][1] else 0\\n            else:\\n                dp[i + 1][0] = dp[i][1] + 1 if dp[i][1] else 0\\n                dp[i + 1][1] = dp[i][0] + 1\\n            res = max(res, dp[i + 1][0])\\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        ans = 0\\n        neg = 0\\n        lo, hi = 0, -1\\n        for i, num in enumerate(nums):\\n            if num == 0:\\n                lo = i+1\\n                neg = 0\\n            elif num < 0:\\n                neg += 1\\n            hi = i\\n            if neg % 2 == 0:\\n                #print(lo,hi)\\n                ans = max(ans, hi - lo + 1)\\n                \\n        neg = 0\\n        nums = nums[::-1]\\n        lo, hi = 0, -1\\n        for i, num in enumerate(nums):\\n            if num == 0:\\n                lo = i+1\\n                neg = 0\\n            elif num < 0:\\n                neg += 1\\n            hi = i\\n            if neg % 2 == 0:\\n                #print(lo,hi)\\n                ans = max(ans, hi - lo + 1)        \\n\\n        return ans         \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        dp = [0 for _ in range(2)]\\n        res = 0\\n        \\n        if nums[0] > 0:\\n            dp[0] = 1\\n            res = 1\\n        if nums[0] < 0:\\n            dp[1] = 1\\n            \\n        \\n        for i in range(1, len(nums)):\\n            cur = nums[i]\\n            tmp = [0 for _ in range(2)]\\n            if cur > 0:\\n                tmp[0] = dp[0] + 1\\n                if dp[1] > 0:\\n                    tmp[1] = dp[1] + 1\\n            \\n            if cur < 0:\\n                tmp[1] = dp[0] + 1\\n                if dp[1] > 0:\\n                    tmp[0] = dp[1] + 1\\n            \\n            res = max(res, tmp[0])\\n            dp = tmp\\n        \\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        positives = 0\\n        negatives = 0\\n        output = 0\\n\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                positives += 1\\n\\n                if negatives > 0:\\n                    negatives += 1\\n\\n            elif nums[i] < 0:\\n                if negatives > 0:\\n                    tmp = positives\\n                    positives = negatives + 1 \\n                    negatives = tmp + 1 \\n\\n                else:\\n                    negatives = positives + 1\\n                    positives = 0\\n\\n            else:\\n                positives = 0\\n                negatives = 0\\n\\n            output = max(output, positives)\\n\\n        return output\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        neg = pos = 0\\n        ret = 0\\n        end = start = 0\\n        while end < len(nums):\\n            start = end\\n            while end < len(nums) and nums[end]:\\n                if nums[end] < 0:\\n                    neg += 1\\n                if nums[end] > 0:\\n                    pos += 1\\n                if neg % 2 == 0:\\n                    ret = max(ret, end - start + 1)\\n                    print(ret)\\n                end += 1\\n            while neg % 2:\\n                if nums[start] < 0:\\n                    neg -= 1\\n                    ret = max(ret, end - start - 1)\\n                start += 1\\n            neg = pos = 0\\n            while end < len(nums) and nums[end] == 0:\\n                end += 1\\n        return ret\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        pos_l = 0\\n        neg_l = 0\\n        best = 0\\n        \\n        for n in nums:\\n            if n == 0:\\n                pos_l = 0\\n                neg_l = 0\\n            elif n > 0:\\n                pos_l += 1\\n                if neg_l > 0:\\n                    neg_l += 1\\n            else:\\n                if neg_l == 0 and pos_l == 0:\\n                    neg_l = 1\\n                elif neg_l > 0 and pos_l > 0:                  \\n                    pos_l, neg_l = neg_l+1, pos_l+1        \\n                elif neg_l > 0:\\n                    pos_l = neg_l+1\\n                    neg_l = 1\\n                elif pos_l > 0:\\n                    neg_l = pos_l+1\\n                    pos_l = 0\\n            #print(n, pos_l, neg_l)\\n            best = max(best, pos_l)\\n        return best\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        cn=0;cp=0;f=0;n=len(nums);pz=-1;ans=0\\n        for i in range(n):\\n            if(nums[i]<0):\\n                if(f==0):fn=ln=i\\n                else:ln=i\\n                cn+=1;f=1\\n            elif(nums[i]>0):cp+=1\\n            else:\\n                if(cn%2==0):ans=max(ans,cn+cp)\\n                else:\\n                    z=cn+cp-min(i-ln,fn-pz)\\n                    ans=max(ans,z)\\n                f=0;cn=0;cp=0;pz=i\\n        if(cn%2==0):ans=max(ans,cn+cp)\\n        else:\\n            z=cn+cp-min(n-ln,fn-pz)\\n            ans=max(ans,z)\\n        return ans\\n        \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        pos = 0\\n        neg = 0\\n        max_pos = 0\\n        curr = True\\n        for i in range(len(nums)):\\n            # print(nums[i])\\n            \\n            if nums[i] > 0:\\n                pos += 1\\n                if neg != 0:\\n                    neg += 1                    \\n            \\n            elif nums[i] < 0:\\n                old_pos = pos\\n                if neg != 0:\\n                    pos = neg + 1\\n                else:\\n                    pos = 0\\n                neg = old_pos + 1\\n                \\n            \\n            else:\\n                neg = 0\\n                pos = 0\\n\\n\\n            max_pos = max(pos, max_pos)\\n            # print(pos, max_pos,neg)\\n        \\n        return max_pos\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n        \\n        pos, neg = [0] * len(nums), [0] * len(nums)\\n        \\n        if nums[0] > 0:\\n            pos[0] = 1 \\n        if nums[0] < 0:\\n            neg[0] = 1\\n            \\n        ans = pos[0]\\n        for i in range(1, n):\\n            if nums[i] > 0:\\n                pos[i] = pos[i-1] + 1 \\n                neg[i] = 1 + neg[i-1] if neg[i-1] else 0\\n            \\n            elif nums[i] < 0:\\n                neg[i] = pos[i-1] + 1 \\n                pos[i] = 1 + neg[i-1] if neg[i-1] else 0 \\n\\n            ans = max(ans, pos[i])\\n            \\n            \\n                \\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        dp_pos = [0] * (len(nums) + 1)\\n        dp_neg = [0] * (len(nums) + 1)\\n        for i in range(len(nums)):\\n            if(nums[i] > 0):\\n                dp_pos[i+1] = dp_pos[i] + 1\\n                if(dp_neg[i] == 0):\\n                    dp_neg[i+1] = 0\\n                else:\\n                    dp_neg[i+1] = dp_neg[i] + 1\\n            elif(nums[i] < 0):\\n                dp_neg[i+1] = dp_pos[i] + 1\\n                if(dp_neg[i] == 0):\\n                    dp_pos[i+1] = 0\\n                else:\\n                    dp_pos[i+1] = dp_neg[i] + 1\\n        return max(dp_pos)\\n        \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        from collections import defaultdict\\n        nums1 = []\\n        for i in nums:\\n            if i > 0:\\n                nums1.append(1)\\n            elif i < 0:\\n                nums1.append(-1)\\n            else:\\n                nums1.append(0)\\n        pre_arr = [0]*len(nums1)\\n        rem = []\\n        for i in range(len(nums1)):\\n            if i == 0:\\n                pre_arr[i] = nums1[i]\\n            else:\\n                if pre_arr[i-1] != 0:\\n                    pre_arr[i] = nums1[i]*pre_arr[i-1]\\n                else:\\n                    pre_arr[i] = nums1[i]\\n        a1 = max(nums)\\n        if a1 > 0:\\n            m1 = 1\\n        else:\\n            m1 = 0\\n        Dict = defaultdict(int)\\n        start = 0\\n        for i in range(len(pre_arr)):\\n            if pre_arr[i] > 0:\\n                m1 = max(m1, i - Dict[1]+1)\\n            elif pre_arr[i] == 0:\\n                Dict[1] = i+1\\n        # print(pre_arr)\\n        Dict1 = defaultdict(list)\\n        m2 = 0\\n        for i in range(len(pre_arr)):\\n            if pre_arr[i] < 0:\\n                Dict1[-1].append(i)\\n            elif pre_arr[i] == 0:\\n                if len(Dict1[-1]) >= 2:\\n                    m2 = max(m2, Dict1[-1][-1]-Dict1[-1][0])\\n                Dict1.clear()\\n        if len(Dict1[-1]) >= 2:\\n            m2 = max(m2, Dict1[-1][-1]-Dict1[-1][0])\\n        #print(m1, m2)\\n        return max(m1,m2)\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        pos = neg = max_len = 0\\n        \\n        for n in nums:\\n            if n > 0:\\n                neg, pos = (1 + neg) if neg > 0 else 0, 1+pos\\n                #pos = (1 + pos)                \\n            elif n < 0:\\n                #n1 = neg\\n                #neg = (1 + pos)\\n                pos, neg = (1 + neg) if neg > 0 else 0, 1+pos\\n                 \\n            else:\\n                pos = neg = 0\\n\\n                \\n            max_len = max(max_len, pos)\\n        return max_len\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        pos = [0] * len(nums)\\n        neg = [0] * len(nums)\\n        \\n        pos[0] = 1 if nums[0] > 0 else 0\\n        neg[0] = 1 if nums[0] < 0 else 0\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                pos[i] = 1 + neg[i-1] if neg[i-1] > 0 else 0\\n                neg[i] = 1 + pos[i-1]\\n            elif nums[i] > 0:\\n                pos[i] = 1 + pos[i-1]\\n                neg[i] = 1 + neg[i-1] if neg[i-1] > 0 else 0\\n            else:\\n                pos[i] = 0\\n                neg[i] = 0\\n        return max(pos)\\n        \\n'''\\npos[i] = max length subarray ending at i whose product is positive\\nneg[i] = max length subarray ending at i whose product is negative\\n\\n\\npos[i] = (\\n    1 + pos[i-1], if nums[i] > 0\\n    1 + neg[i-1] elif nums[i] < 0\\n    0            else\\n)\\n\\nneg[i] = (\\n    1 + neg[i-1], if nums[i] > 0\\n    1 + pos[i-1], elif nums[i] < 0\\n    0             else\\n)\\n\\nA = [-1,-2,-3,0,1]\\np = [0,  2, 2,]\\nn = [1,  1, 3]\\n\\n\\n\\n[0,1,-2,-3,-4]\\n\\n[0,1,0,3,2]\\n[0,0,2,1,]\\n\\n\\n\\n\\n'''\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        res = 0\\n        prod = 1\\n        p_start = -1\\n        n_start = 10 ** 6\\n        for i in range(n):\\n            if nums[i] == 0:\\n                p_start = i\\n                n_start = 10 ** 6\\n                prod = 1\\n                continue\\n            elif nums[i] < 0:\\n                prod = -prod\\n                if n_start == 10 ** 6:\\n                    n_start = i\\n            res = max(res, i - p_start) if prod > 0 else max(res, i - n_start)\\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        neg = pos = max_len = 0\\n        fneg = lneg = -1\\n        beg = -1\\n        \\n        for i, n in enumerate(nums):\\n            if n < 0:\\n                neg += 1\\n                if fneg == -1:\\n                    fneg = lneg = i\\n                else:\\n                    lneg = i\\n            elif n > 0:\\n                pos += 1\\n            else:\\n                if neg%2 == 0:\\n                    max_len = max(max_len, neg+pos)\\n                else:                    \\n                    max_len = max(max_len, max(lneg - beg - 1, i - fneg - 1))\\n                    print((i, fneg, lneg, beg))\\n                neg = pos = 0\\n                fneg = lneg = -1\\n                beg = i\\n                \\n        if neg%2 == 0:\\n            max_len = max(max_len, neg+pos)\\n        else:\\n            max_len = max(max_len, max(i - fneg, lneg - beg - 1))\\n\\n        return max_len\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        l = len(nums)\\n        dp = [[0 for _ in range(2)] for _ in range(l)]\\n        res = 0\\n        if nums[0] > 0:\\n            dp[0][0] = 1\\n            res = 1\\n        if nums[0] < 0:\\n            dp[0][1] = 1\\n        \\n        for i in range(1, len(nums)):\\n            cur = nums[i]\\n            if cur > 0:\\n                if dp[i-1][0] == 0:\\n                    dp[i][0] = 1\\n                else:\\n                    dp[i][0] = dp[i-1][0] + 1\\n                \\n                if dp[i-1][1] != 0:\\n                    dp[i][1] = dp[i-1][1] + 1\\n                    \\n            if cur < 0:\\n                if dp[i-1][0] == 0:\\n                    dp[i][1] = 1\\n                else:\\n                    dp[i][1] = dp[i-1][0] + 1\\n                \\n                if dp[i-1][1] != 0:\\n                    dp[i][0] = dp[i-1][1] + 1\\n            \\n            res = max(res, dp[i][0])\\n        \\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        v = {(0,0):-1}\\n        neg = 0\\n        zero = 0\\n        maxlen = 0\\n        for i,num in enumerate(nums):\\n            if num < 0:\\n                neg = 1 - neg\\n            if num == 0:\\n                zero += 1\\n            if (neg,zero) not in v:\\n                v[(neg,zero)] = i\\n            else:\\n                maxlen = max(maxlen,i-v[(neg,zero)])\\n        # print(v)\\n        return maxlen\\n                \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        res = 0\\n        dp_po, dp_ne = [0] * (len(nums) + 1), [0] * (len(nums) + 1)\\n        \\n        for i, value in enumerate(nums):\\n            if value == 0:\\n                dp_po[i + 1] = 0\\n                dp_ne[i + 1] = 0\\n            elif value > 0:\\n                dp_po[i + 1] = dp_po[i] + 1\\n                if dp_ne[i] > 0:\\n                    dp_ne[i + 1] = dp_ne[i] + 1\\n            else:\\n                dp_ne[i + 1] = dp_po[i] + 1\\n                if dp_ne[i] > 0:\\n                    dp_po[i + 1] = dp_ne[i] + 1\\n            if dp_po[i + 1] > res:\\n                res = dp_po[i + 1]\\n        \\n        return res\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        fn=-1\\n        zi=-1\\n        cn=0\\n        dig=0\\n        maxdig=0\\n        for i in range(len(nums)):\\n            if(nums[i]<0):\\n                cn+=1\\n                if(fn==-1):\\n                    fn=i\\n            if(nums[i]==0):\\n                fn=-1\\n                cn=0\\n                zi=i\\n            else:\\n                if(cn%2==0):\\n                    maxdig=max(i-zi,maxdig)\\n                else:\\n                    maxdig=max(i-fn,maxdig)\\n        return maxdig\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        res = 0\\n        n = len(nums)\\n        \\n        non_zeros = []\\n        i = 0\\n        pre = 0\\n        while i < n:\\n            if nums[i] == 0:\\n                if i > pre:\\n                    non_zeros.append(nums[pre:i])\\n                pre = i + 1\\n            i += 1\\n        if i > pre:\\n            non_zeros.append(nums[pre:i])\\n        \\n        for non_zero in non_zeros:\\n            negs = []\\n            nn = len(non_zero)\\n            for i in range(nn):\\n                if non_zero[i] < 0:\\n                    negs.append(i)\\n            if len(negs) % 2 == 0:\\n                res = max(res, nn)\\n            else:\\n                res = max([res, len(non_zero[negs[0] + 1:nn]), len(non_zero[0:negs[-1]])])\\n        \\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=0\\n        ans=float('-inf')\\n        while i<n:\\n            s=i\\n        \\n            while s<n and nums[s]==0:\\n                s+=1\\n            e=s\\n            c=0\\n            sn=-1\\n            en=-1\\n            while e<n and nums[e]!=0:\\n                if nums[e]<0:\\n                    c+=1\\n                    if sn==-1:\\n                        sn=e\\n                    en=e\\n                e+=1\\n            if c%2==0:\\n                ans=max(ans,e-s)\\n            else:\\n                if sn!=-1:\\n                    ans=max(ans,e-sn-1)\\n                if en!=-1:\\n                    ans=max(ans,en-s)\\n            i=e+1\\n        return ans\\n                    \\n            \\n       \\n            \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        pos, neg = 0, 0\\n        res = 0\\n        for n in nums:\\n            if n==0:\\n                neg, pos = 0, 0\\n            elif n>0:\\n                if neg>0: neg, pos = neg+1, pos+1\\n                else: neg, pos = 0, pos+1\\n            else:\\n                if neg>0: pos, neg = neg+1, pos+1\\n                else: neg, pos = pos+1, 0\\n            res = max(res,pos)\\n        return res\\n\\n\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        pos, neg = [0] * n, [0] * n\\n        if nums[0] > 0: pos[0] = 1\\n        if nums[0] < 0: neg[0] = 1\\n        ans = pos[0]\\n        for i in range(1, n):\\n            if nums[i] > 0:\\n                pos[i] = 1 + pos[i - 1]\\n                neg[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\\n            elif nums[i] < 0:\\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\\n                neg[i] = 1 + pos[i - 1]\\n            ans = max(ans, pos[i])\\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        p = 1\\n        j = None\\n        k = -1\\n        m = 0\\n        for i, n in enumerate(nums):\\n            if not n:\\n                p = 1\\n                j = None\\n                k = i\\n            else:\\n                if n < 0:\\n                    p = -p\\n                if p > 0:\\n                    m = max(m, i-k)\\n                elif p < 0:\\n                    if j is None:\\n                        j = i\\n                    else:\\n                        m = max(m, i-j)\\n        return m\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        # if the number of negative numbers is even then we just need to worry about zeroes\\n        maxLength = 0\\n        currLength = 0\\n        negCnt = 0\\n        negIdxs = []\\n        head = 0\\n        for i, n in enumerate(nums):\\n            if n > 0:\\n                currLength += 1\\n                if negCnt%2 == 0:\\n                    maxLength = max(maxLength, currLength)\\n            elif n < 0:\\n                currLength += 1\\n                negCnt += 1\\n                negIdxs.append(i)\\n                if negCnt%2 == 0:\\n                    maxLength = max(maxLength, currLength)\\n            if n == 0 or i == len(nums) - 1: # end or 0\\n                # head and tail?\\n                if negIdxs:\\n                    tail = i if n > 0 else i - 1\\n                    maxLength = max(maxLength, tail - negIdxs[0])\\n                    # print(negIdxs[-1], head)\\n                    maxLength = max(maxLength, negIdxs[-1] - head)\\n                currLength = 0\\n                negCnt = 0\\n                negIdxs = []\\n                head = i + 1\\n        return maxLength\\n        \\n        # negIdx = []\\n        # zeroIdx = []\\n        # for i, n in enumerate(nums):\\n        #     if n < 0:\\n        #         negIdx.append(i)\\n        #     elif n == 0:\\n        #         zeroIdx.append(i)\\n        # if len(negIdx)%2 == 0:\\n        #     if len(zeroIdx) == 0:\\n        #         return len(nums)\\n        #     else:\\n        #         for \\n        # else:\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        # \\\\\\\"pos\\\\\\\", \\\\\\\"neg\\\\\\\" represent longest consecutive numbers ending with nums[i] forming a positive/negative product.\\n        nums.append(0)\\n        n = len(nums)\\n        pos, neg = 0, 0\\n        if nums[0] > 0: pos = 1\\n        if nums[0] < 0: neg = 1\\n        ans = pos\\n        for i in range(1, n):\\n            if nums[i] > 0:\\n                pos = 1 + pos\\n                neg = 1 + neg if neg > 0 else 0\\n            elif nums[i] < 0:\\n                pre_pos, pre_neg = pos, neg\\n                pos = 1 + pre_neg if pre_neg > 0 else 0\\n                neg = 1 + pre_pos\\n            else:\\n                pos, neg = 0, 0\\n            ans = max(ans, pos)\\n        return ans\\n    \\n        # nums.append(0)\\n        # start = -1\\n        # i = 0\\n        # firstn = -1\\n        # maxl = 0\\n        # nneg = 0\\n        # while i<len(nums):\\n        #     if nums[i]<0:\\n        #         nneg += 1\\n        #         if firstn<0: firstn = i\\n        #         lastn = i\\n        #     elif nums[i] == 0:\\n        #         if nneg%2 == 0:\\n        #             maxl = max(maxl,i-start-1)\\n        #         else:\\n        #             maxl = max([maxl,lastn-start-1,i-firstn-1])\\n        #         start = i\\n        #         nneg = 0\\n        #         firstn = -1\\n        #     i += 1\\n        # return maxl\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        for i in range(n):\\n            if nums[i]>0:\\n                nums[i]=1\\n            elif nums[i]<0:\\n                nums[i]=-1\\n        \\n        # print(nums)\\n        ans=0\\n        old=1\\n        for i in range(n):\\n            # print(i)\\n            temp=i\\n            count=0\\n            j=i\\n            pro=1\\n            old=1\\n            while j<n:\\n                \\n                pro=pro*nums[j]\\n                # print(pro,end=' ')                \\n                if pro==0:\\n                    # print(\\\\\\\" \\\\\\\")\\n                    i=j+1\\n                    break\\n\\n                count+=1\\n                if pro>0:\\n                    if count>ans:\\n                        ans=count                \\n                j=j+1\\n                old=pro\\n                # print((count,old))\\n                # print(\\\\\\\" \\\\\\\")\\n            # print(\\\\\\\"TATTI\\\\\\\")    \\n            \\n\\n            if pro==0 and old>0:\\n                if ans<count:\\n                    ans=count\\n            elif old<0:\\n                            \\n                left=1\\n                right=1\\n                for z in range(temp,j):\\n                    if nums[z]==-1:\\n                        break\\n                    left+=1\\n                z=j-1\\n                while z>=temp:\\n                    if nums[z]==-1:\\n                        break\\n                    right+=1\\n                    z=z-1\\n                q=min(left,right)\\n                # print((temp,j,q))\\n                # print((j-temp+1-q)-1)\\n                if (j-temp+1-q)-1>ans:\\n                    ans=(j-temp+1-q)-1\\n            # print('ans = '+str(ans))\\n            if j>=n:\\n                break\\n            \\n        return ans\\n                    \\n                \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int], reverse=False) -> int:\\n        zero_pos = -1\\n        num_negative = 0\\n        first_negative = -1\\n        res = 0\\n        for i in range(len(nums)):\\n            if nums[i] < 0:\\n                num_negative += 1\\n                if first_negative == -1:\\n                    first_negative = i\\n            if nums[i] == 0:\\n                zero_pos = i\\n                num_negative = 0\\n                first_negative = -1\\n            if nums[i] > 0 or nums[i] < 0:\\n                if num_negative % 2 == 0:\\n                    res = max(res, i - zero_pos)\\n                else:\\n                    res = max(res, i - first_negative)\\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        # \\\\\\\"pos[i]\\\\\\\", \\\\\\\"neg[i]\\\\\\\" represent longest consecutive numbers ending with nums[i] forming a positive/negative product.\\n\\n        n = len(nums)\\n        pos, neg = [0] * n, [0] * n\\n        if nums[0] > 0: pos[0] = 1\\n        if nums[0] < 0: neg[0] = 1\\n        ans = pos[0]\\n        for i in range(1, n):\\n            if nums[i] > 0:\\n                pos[i] = 1 + pos[i - 1]\\n                neg[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\\n            elif nums[i] < 0:\\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\\n                neg[i] = 1 + pos[i - 1]\\n            ans = max(ans, pos[i])\\n        return ans  \\n                \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        ans = pos = neg = 0\\n        for x in nums: \\n            if x > 0: pos, neg = 1 + pos, 1 + neg if neg else 0     # assignment in one line is very important to have the previous value of variables updated! Cannot be re-written into 2 lines!\\n            elif x < 0: pos, neg = 1 + neg if neg else 0, 1 + pos\\n            else: pos = neg = 0 # reset \\n            ans = max(ans, pos)\\n        return ans \\n\", \"def f(data):\\n    n2 = len(data)\\n    \\n    f0 = -1\\n    f1 = -1\\n    n = 0\\n    for ind,d in enumerate(data):\\n        if d==1:\\n            continue\\n        n += 1\\n        if f0==-1:\\n            f0 = ind\\n        f1 = ind\\n            \\n    if n&1==0:\\n        return n2\\n    \\n    return max(f1, n2-f0-1)\\n\\nclass Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        res = 0\\n        prev = -1\\n        data = []\\n        for ind,num in enumerate(nums):\\n            if num==0:\\n                if data:\\n                    res = max(res, f(data))\\n                prev = ind\\n                data = []\\n                continue\\n                \\n            data.append(1 if num>0 else -1)\\n            \\n        res = max(res, f(data))\\n        return res\\n                \\n            \\n        \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        res = 0\\n        pos, neg = set(), set()\\n        for num in nums:\\n            if num > 0:\\n                pos = {x+1 for x in pos} | {1}\\n                neg = {y+1 for y in neg}\\n            elif num < 0:\\n                pos = {x+1 for x in pos} | {1}\\n                neg = {y+1 for y in neg}       \\n                pos, neg = neg, pos\\n            else:\\n                pos, neg = set(), set()\\n            \\n            if len(pos):\\n                res = max(res, max(pos))\\n            # print(res)\\n            \\n            if len(pos): pos = set([max(pos)])\\n            if len(neg): neg = set([max(neg)])\\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        max_pos = 0\\n        max_neg = 0\\n        max_len = 0\\n        for n in nums:\\n            if n == 0:\\n                max_pos = max_neg = 0\\n            elif n > 0:\\n                max_pos += 1\\n                if max_neg:\\n                    max_neg += 1\\n            else:\\n                prev_pos = max_pos\\n                if max_neg:\\n                    max_pos = max_neg + 1\\n                else:\\n                    max_pos = 0\\n                max_neg = prev_pos + 1\\n            max_len = max(max_len, max_pos)\\n        return max_len\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        max_length = 0\\n        \\n        idx = 0\\n        prev = 0\\n        negative = 0\\n        while idx < len(nums):\\n            num = nums[idx]\\n            if num == 0:\\n                prev = 0\\n                negative = 0\\n            elif num < 0:\\n                if negative == 1:\\n                    prev = neg_idx + (idx-prev_neg_idx) + 1 \\n                    negative = 0\\n                else:\\n                    prev_neg_idx = idx\\n                    neg_idx = prev\\n                    negative = 1\\n            else:\\n                if prev == 0 or negative == 0:\\n                    prev += 1\\n            #print(prev)\\n            max_length = max(max_length, prev)\\n            idx += 1\\n            \\n        idx = len(nums)-1\\n        prev = 0\\n        negative = 0\\n        while idx >= 0:\\n            num = nums[idx]\\n            if num == 0:\\n                prev = 0\\n                negative = 0\\n            elif num < 0:\\n                if negative == 1:\\n                    prev = neg_idx + (prev_neg_idx-idx) + 1 \\n                    negative = 0\\n                else:\\n                    prev_neg_idx = idx\\n                    neg_idx = prev\\n                    negative = 1\\n            else:\\n                if prev == 0 or negative == 0:\\n                    prev += 1\\n            #print(prev)\\n            max_length = max(max_length, prev)\\n            idx -= 1            \\n\\n        return max_length\\n            \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        i_pos,i_neg=-1,len(nums)\\n        pro=1\\n        res=0\\n        for i in range(len(nums)):\\n            if nums[i]==0:\\n                i_pos,i_neg=i,len(nums)\\n                pro=1\\n            else: \\n                if nums[i]<0: pro*=-1\\n      \\n                if pro>0:\\n                    i_pos=min(i,i_pos)\\n                    res=max(res,i-i_pos)\\n                else:\\n                    i_neg=min(i,i_neg)\\n                    res=max(res,i-i_neg)\\n        return res\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        max_pos_len = 0\\n        max_neg_len = 0\\n        if nums[0] > 0: max_pos_len = 1\\n        if nums[0] < 0: max_neg_len = 1\\n        max_len = max(0, max_pos_len)\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] > 0: \\n                max_pos_len += 1\\n                max_neg_len += (max_neg_len > 0)\\n            elif nums[i] < 0: \\n                max_neg_len, max_pos_len = max_pos_len+1, max_neg_len+(max_neg_len > 0)\\n            elif nums[i] == 0: \\n                max_pos_len = max_neg_len = 0\\n            \\n            max_len = max(max_len, max_pos_len)\\n        \\n        return max_len\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        ret = 0\\n        l, r, p = 0, 0, 1\\n        i = 0\\n        while i <= len(nums):\\n            if i != len(nums) and nums[i] != 0:\\n                p *= 1 if nums[i] > 0 else -1\\n                if p > 0:\\n                    ret = max(ret, i-l+1)\\n            else:\\n                while l < i:\\n                    p *= 1 if nums[l] > 0 else -1\\n                    if p > 0:\\n                        ret = max(ret, i-l-1)\\n                    l += 1\\n                l += 1\\n                p = 1\\n            i += 1\\n        return ret\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                nums[i] = 2\\n            elif nums[i] < 0:\\n                nums[i] = -2\\n        mini, maxi, res = 1, 1, -10**9 - 1\\n        for n in nums:\\n            a = mini * n\\n            b = maxi * n\\n            mini = min(a,b,n)\\n            maxi = max(a,b,n)\\n            res = max(res, maxi)\\n        if res <= 0:\\n            return 0\\n        return int(math.log2(res))\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        def getMaxLenHelper(nums: List[int]) -> int:\\n           ans = 0\\n           count,count1,negativeCount = 0,0,0\\n           for i in range(len(nums)):\\n              if nums[i] == 0:\\n                  if count > ans:\\n                     ans = count\\n                  count,count1,negativeCount = 0,0,0\\n              else:\\n                if nums[i] > 0:\\n                    count += 1\\n                count1 += 1\\n                if nums[i] < 0:\\n                   negativeCount += 1\\n                   if negativeCount == 2:\\n                      count = count1\\n                      negativeCount = 0\\n                   else:\\n                      if count > ans:\\n                         ans = count\\n                      count = 0\\n           if count > ans:\\n              ans = count\\n           return ans\\n        return max(getMaxLenHelper(nums),getMaxLenHelper(nums[::-1]))\\n        \\n            \\n\", \"class Solution:\\n    def getMaxLen(self, nums):\\n        n = len(nums)\\n        pos, neg = 0, 0\\n        res = 0\\n        for i in range(n):\\n            if nums[i] > 0:\\n                pos, neg = 1 + pos, 1 + neg if neg else 0\\n            elif nums[i] < 0:\\n                pos, neg = 1 + neg if neg else 0, 1 + pos\\n            else:\\n                pos, neg = 0, 0\\n            res = max(res, pos)\\n        return res  \", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        pos, neg = [0] * N, [0] * N\\n        if nums[0] > 0: pos[0] = 1\\n        if nums[0] < 0: neg[0] = 1\\n        res = pos[0]\\n        \\n        for i in range(1, N):\\n            if nums[i] > 0:\\n                pos[i] = pos[i - 1] + 1\\n                neg[i] = neg[i - 1] + 1 if neg[i - 1] > 0 else 0\\n            elif nums[i] < 0:\\n                pos[i] = neg[i - 1] + 1 if neg[i - 1] > 0 else 0\\n                neg[i] = pos[i - 1] + 1\\n            res = max(pos[i], res)\\n        return res\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        pos = int(nums[0] > 0)\\n        neg = int(nums[0] < 0)\\n        best = pos\\n        for i in nums[1:]:\\n            if i > 0:\\n                pos+= 1\\n                if neg > 0:                \\n                    neg += 1    \\n                else:\\n                    neg = 0\\n            elif i < 0:\\n                pTemp = pos\\n                if neg > 0:\\n                    pos = neg + 1\\n                else:\\n                    pos = 0\\n                neg = pTemp + 1\\n            else:\\n                pos,neg = 0,0\\n            best = max(best, pos)\\n        return best\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        # just count even number of negatives, no zeros though\\n        \\n        \\n        \\n        left = right = negCount = negIndex = res = 0\\n        \\n        while right <= len(nums):\\n            if right < len(nums) and nums[right] != 0:\\n                if nums[right] < 0:\\n                    negCount += 1\\n                    negIndex = right\\n                    \\n                right += 1                \\n            else:\\n                if negCount % 2 == 1:\\n                    res = max(res, negIndex - left)\\n                    while nums[left] > 0: left += 1\\n                        \\n                    res = max(res, right - left - 1)\\n                else:\\n                    res = max(res, right - left)\\n                \\n                right += 1\\n                left = right\\n                negCount = 0 \\n        \\n        return res\\n                \\n                \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        trip_zeros = []\\n        for num in nums:\\n            if num:\\n                if trip_zeros: trip_zeros[-1].append(num)\\n                else: trip_zeros.append([num])\\n            else:\\n                trip_zeros.append([])\\n        \\n        def count(arr):\\n            start = ans = 0\\n            left_neg = None\\n            pos = 1\\n            for end in range(len(arr)):\\n                if arr[end] < 0:\\n                    if left_neg is None:\\n                        left_neg = end\\n                    pos ^= 1\\n                print(pos, start, end, left_neg)\\n                if pos:\\n                    ans = max(ans, end-start+1)\\n                    \\n                else:\\n                    ans = max(ans, end-left_neg)\\n            return ans\\n        \\n        # print(trip_zeros)\\n        # if not trip_zeros: return 0\\n        return max(map(count, trip_zeros))\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        ans = 0\\n        last_zero = last_negative = -1\\n        running_count = 0\\n        negative_count = 0\\n        for i,v in enumerate(nums):\\n            if v == 0:\\n                last_zero = last_negative = i\\n                running_count = zero_count = negative_count = 0\\n            elif v < 0:\\n                negative_count += 1\\n                if negative_count == 1: last_negative = i\\n                if negative_count % 2 == 0: ans = max(ans,i-last_zero)\\n                else: ans = max(ans,i-last_negative)\\n            else:\\n                if negative_count % 2 == 0: ans = max(ans,i-last_zero)\\n                else: ans = max(ans,i-last_negative)\\n        return ans\", \"class Solution:         \\n        \\n    def getMaxLenDuh(self, nums: List[int]) -> int:\\n        '''\\n        Single pass: at each num, track length of pos and neg prods:\\n            reset on 0, and change sign as needed.\\n        '''\\n        size = len(nums)\\n        if not size:\\n            return 0\\n        if size == 1:\\n            return 1 if nums[0] > 0 else 0\\n        \\n        \\n        result = nneg = npos = 0\\n        for num in nums:\\n            if num == 0:\\n                nneg = npos = 0     # reset\\n            elif num > 0:\\n                npos = npos + 1                 # any pos prod stays neg\\n                nneg = nneg + 1 if nneg else 0  # any neg prod stays neg\\n            else:\\n                temp = nneg\\n                nneg = npos + 1                 # any pos prod flips neg\\n                npos = temp + 1 if temp else 0  # any neg prod flips pos\\n            result = max(result, npos)          # Save max pos prod len\\n        return result\\n    \\n\\n    def getMaxLenPow2(self, numso: List[int]) -> int:\\n        '''\\n\\n        '''\\n        nums = [copysign(num, 2) for num in numso]\\n        size = len(nums)\\n        if size == 0:\\n            return\\n        left_prod, right_prod = 0, 0\\n        max_prod = -float('inf')\\n        for i in range(size):\\n            left_prod = (left_prod or 1) * nums[i]\\n            right_prod = (right_prod or 1) * nums[size - 1 - i]\\n            max_prod = max(max_prod, left_prod, right_prod)\\n        return math.log(max_prod, 2)\\n\\n    \\n    def getMaxLen(self, nums: List[int]) -> int:\\n        '''\\n\\n        '''\\n        return self.getMaxLenDuh(nums)\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        pos = [0] * (len(nums) + 1)\\n        neg = [0] * (len(nums) + 1)\\n        for i, n in enumerate(nums):\\n            if n > 0:\\n                pos[i+1] = pos[i] + 1\\n                if neg[i] != 0:\\n                    neg[i+1] = neg[i] + 1\\n            elif n < 0:\\n                if neg[i] == 0:\\n                    neg[i+1], pos[i+1] = pos[i]+1, 0\\n                else:\\n                    neg[i+1], pos[i+1] = pos[i] + 1, neg[i] + 1\\n            else:\\n                neg[i+1] = pos[i+1] = 0\\n        return max(pos)\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        max_count = 0\\n        front = 0\\n        back = 0\\n        prod = 1\\n        \\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                nums[i] = 1\\n            elif nums[i] < 0:\\n                nums[i] = -1\\n        \\n        while back < len(nums):\\n            if nums[back] == 0:\\n                back -= 1\\n                while front <= back and front < len(nums):\\n                    if nums[front] != 0:\\n                        prod /= nums[front]\\n                        front += 1\\n                        if prod > 0:\\n                            max_count = max(max_count, back - front + 1)\\n                    else:\\n                        front += 1\\n                \\n                front += 1\\n                back = front\\n                \\n            else:\\n                prod *= nums[back]\\n                if prod > 0:\\n                    max_count = max(max_count, back - front + 1)\\n                back += 1\\n        \\n        back -= 1\\n        while front <= back and front < len(nums):\\n            if nums[front] != 0:\\n                prod /= nums[front]\\n                front += 1\\n                if prod > 0:\\n                    max_count = max(max_count, back - front + 1)\\n            else:\\n                front += 1\\n\\n                    \\n        return max_count\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n\\n        dp = [[0, 0] for _ in range(len(nums))]\\n        dp[0] = [int(bool(nums[0] > 0)), int(bool(nums[0] < 0))] # max length (positive, negative)\\n\\n        for idx in range(1, len(nums)):\\n            if nums[idx] == 0:\\n                continue\\n            if nums[idx] > 0:\\n                dp[idx][0] = dp[idx - 1][0] + 1\\n                dp[idx][1] = dp[idx - 1][1] + int(dp[idx - 1][1] != 0)\\n            else:\\n                dp[idx][0] = dp[idx - 1][1] + int(dp[idx - 1][1] != 0) \\n                dp[idx][1] = dp[idx - 1][0] + 1\\n\\n        return max([positive for positive, _ in dp])\\n\", \"class Solution:\\n    \\n    @staticmethod\\n    def process(st, end, cnt_neg, arr):\\n        if st >= 0 and st <= end and end >= 0:\\n            if not (cnt_neg % 2):\\n                return end - st + 1\\n            first_neg_ind = st \\n            last_neg_ind = end\\n            while(first_neg_ind <= end and arr[first_neg_ind] >= 0):\\n                first_neg_ind += 1\\n            while(last_neg_ind >= st and arr[last_neg_ind] >= 0):\\n                last_neg_ind -= 1\\n            print((st, end, first_neg_ind, last_neg_ind))\\n            return max(last_neg_ind - st, end - first_neg_ind)\\n            \\n        return 0\\n    \\n    def getMaxLen(self, nums: List[int]) -> int:\\n        prev = 0\\n        ans = 0\\n        cnt_neg = 0\\n        for i in range(len(nums)):\\n            if not nums[i]:\\n                ans = max(ans, Solution.process(prev, i-1, cnt_neg, nums))\\n                prev = i + 1\\n                cnt_neg = 0\\n            if nums[i] < 0:\\n                cnt_neg += 1\\n        ans = max(ans, Solution.process(prev, len(nums)-1, cnt_neg, nums))\\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        res = curr = 0\\n        dp = {0:0}\\n        for i,num in enumerate(nums,1):\\n            if num==0:\\n                curr = 0\\n                dp = {0:i}\\n                continue\\n            curr = (curr+(num<0))%2\\n            if curr not in dp:\\n                dp[curr]=i\\n            else:\\n                res = max(res,i-dp[curr])\\n        return res\", \"import heapq\\nclass Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        pos, neg = [0] * n, [0] * n\\n        if nums[0] > 0: pos[0] = 1\\n        if nums[0] < 0: neg[0] = 1\\n        ans = pos[0]\\n        for i in range(1, n):\\n            if nums[i] > 0:\\n                pos[i] = 1 + pos[i - 1]\\n                neg[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\\n            elif nums[i] < 0:\\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\\n                neg[i] = 1 + pos[i - 1]\\n            ans = max(ans, pos[i])\\n        return ans\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        hashmap={0:-1}\\n        totalN=0\\n        ans=0\\n        for i in range(0,len(nums)):\\n            if nums[i]<0:\\n                totalN+=1\\n            \\n            value=totalN%2\\n            if nums[i]==0:\\n                hashmap={0:i}\\n                \\n                totalN=0\\n                continue\\n            if value in hashmap:\\n                ans=max(ans,i-hashmap[value])\\n            else:\\n                hashmap[value]=i\\n        return ans          \", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        maxl = 0\\n        \\n        posi = None\\n        start = -1\\n        cur = True\\n        for i,n in enumerate(nums):\\n            if n == 0:\\n                start = i\\n                posi = None\\n                cur = True\\n                \\n            elif n > 0:\\n                if cur:\\n                    maxl = max(maxl,i-start)\\n                    \\n                else:\\n                    if posi == None:\\n                        maxl = max(maxl,1)\\n                        posi = i\\n                    else:\\n                        maxl = max(maxl,i-posi+1)\\n                 \\n                \\n            else:\\n                if not cur:\\n                    maxl = max(maxl,i-start)\\n                    if not posi:\\n                        posi = i\\n                    cur = True\\n                else:\\n                    cur = False\\n                     \\n                    if posi:                        \\n                        maxl = max(maxl,i-posi+1)\\n                 \\n        return maxl\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n        pos = [0]*n\\n        neg = [0]*n\\n        \\n        if nums[0] > 0:\\n            pos[0] = 1\\n        if nums[0] <0:\\n            neg[0] = 1\\n        ans = pos[0]\\n        for i in range(1, n):\\n            if nums[i] > 0:\\n                pos[i] = pos[i-1] + 1\\n                neg[i] = neg[i-1] + 1 if neg[i-1] > 0 else 0\\n                \\n            elif nums[i] < 0:\\n                pos[i] = neg[i-1] + 1 if neg[i-1] > 0 else 0\\n                neg[i] = pos[i-1] + 1\\n            # else:\\n                # pos[i]\\n            ans = max(ans, pos[i])\\n        \\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        i = 0\\n        j = 0\\n        minus = 0\\n        res = 0\\n        \\n        while j < len(nums):\\n            if nums[j] < 0:\\n                minus+=1\\n                j+=1\\n            elif nums[j] > 0:\\n                j+=1\\n            else:\\n                minus = 0\\n                i = j+1\\n                j = i\\n            if minus%2==0:\\n                res = max(res, j-i)\\n                \\n        \\n        if minus%2==0:\\n            res = max(res, j-i)\\n        \\n        minus = 0\\n        i = len(nums)-1\\n        j = len(nums)-1\\n        \\n        while j >= 0:\\n            if nums[j] < 0:\\n                minus+=1\\n                j-=1\\n            elif nums[j] > 0:\\n                j-=1\\n            else:\\n                minus = 0\\n                i = j-1\\n                j = i\\n            if minus%2==0:\\n                res = max(res, i-j)\\n                \\n        \\n        if minus%2==0:\\n            res = max(res, i-j)\\n            \\n        return res\\n            \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        pos, neg = [0]*n, [0]*n\\n        if nums[0] > 0:\\n            pos[0] = 1\\n        if nums[0] < 0:\\n            neg[0] = 1\\n            \\n        ans = pos[0]\\n        \\n        for i in range(1,n):\\n            if nums[i] > 0:\\n                pos[i] = 1 + pos[i-1]\\n                neg[i] = 1 + neg[i-1] if neg[i-1] > 0 else 0\\n            \\n            elif nums[i] < 0:\\n                pos[i] = 1 + neg[i-1] if neg[i-1] > 0 else 0\\n                neg[i] = 1 + pos[i-1]\\n                \\n            ans = max(ans,pos[i])\\n            \\n        return ans\\n        \\n        \\n\", \"class Solution:         \\n        \\n    def getMaxLenDuh(self, nums: List[int]) -> int:\\n        '''\\n        Single pass: at each num, track length of pos and neg prods:\\n            reset on 0, and change sign as needed.\\n        '''\\n        size = len(nums)\\n        if not size:\\n            return 0\\n#         if size == 1:\\n#             return 1 if nums[0] > 0 else 0\\n        \\n        \\n        result = nneg = npos = 0\\n        for num in nums:\\n            if num == 0:\\n                nneg = npos = 0     # reset\\n            elif num > 0:\\n                npos = npos + 1                 # any pos prod stays neg\\n                nneg = nneg + 1 if nneg else 0  # any neg prod stays neg\\n            else:\\n                temp = nneg\\n                nneg = npos + 1                 # any pos prod flips neg\\n                npos = temp + 1 if temp else 0  # any neg prod flips pos\\n            result = max(result, npos)          # Save max pos prod len\\n        return result\\n    \\n\\n    def getMaxLenPow2(self, numso: List[int]) -> int:\\n        '''\\n\\n        '''\\n        nums = [copysign(num, 2) for num in numso]\\n        size = len(nums)\\n        if size == 0:\\n            return\\n        left_prod, right_prod = 0, 0\\n        max_prod = -float('inf')\\n        for i in range(size):\\n            left_prod = (left_prod or 1) * nums[i]\\n            right_prod = (right_prod or 1) * nums[size - 1 - i]\\n            max_prod = max(max_prod, left_prod, right_prod)\\n        return math.log(max_prod, 2)\\n\\n    \\n    def getMaxLen(self, nums: List[int]) -> int:\\n        '''\\n\\n        '''\\n        return self.getMaxLenDuh(nums)\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        '''\\n        f(i, 0) +\\n        f(i, 1) -\\n        f(i, 0) = max(f(i-1, 0)*nums[i]>0, f(i-1, 1), nums[i] < 0)\\n        f(i, 1) = \\n        '''\\n        dp = defaultdict(int)\\n        for i, num in enumerate(nums):\\n            if num > 0: dp[(i, 0)] = 1\\n            if num < 0: dp[(i, 1)] = 1\\n        \\n        ans = dp[(0, 0)]\\n        for i in range(1, len(nums)):\\n            if nums[i] > 0:\\n                dp[(i, 0)] = max(dp[(i, 0)], dp[(i-1, 0)]+1 if dp[(i-1, 0)] > 0 else 0)\\n                dp[(i, 1)] = max(dp[(i, 1)], dp[(i-1, 1)]+1 if dp[(i-1, 1)] > 0 else 0)\\n            if nums[i] < 0:\\n                dp[(i, 0)] = max(dp[(i, 0)], dp[(i-1, 1)]+1 if dp[(i-1, 1)] > 0 else 0)\\n                dp[(i, 1)] = max(dp[(i, 1)], dp[(i-1, 0)]+1 if dp[(i-1, 0)] > 0 else 0)\\n            ans = max(ans, dp[(i, 0)])\\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        neg = [0 for ii in range(len(nums))]\\n        zero = []\\n        if nums[0] < 0:\\n            neg[0] = 1\\n        elif nums[0] == 0:\\n            zero.append(0)\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                neg[i] = neg[i-1] + 1  \\n            else:\\n                neg[i] = neg[i-1]\\n            \\n            if nums[i] == 0:\\n                zero.append(i)\\n\\n        l = 0\\n        ans = 0\\n        if len(zero) == 0:\\n            if neg[len(nums)-1] % 2 == 0:\\n                ans = max(ans, len(nums))\\n            else:\\n                first, last = -1, -1\\n                for i in range(len(nums)):\\n                    if nums[i] < 0:\\n                        last = i\\n                        if first == -1:\\n                            first = i\\n                ans = max(ans, last)\\n                ans = max(ans, len(nums)-first-1)\\n            \\n        for z in zero:\\n            if z == l:\\n                l = z+1\\n                continue\\n            else:\\n                if l == 0:\\n                    if neg[z-1] % 2 == 0:\\n                        ans = max(ans, z)\\n                    else:\\n                        first, last = -1, -1\\n                        for i in range(l, z):\\n                            if nums[i] < 0:\\n                                last = i\\n                                if first == -1:\\n                                    first = i\\n                        ans = max(ans, last)\\n                        ans = max(ans, z-first-1)\\n                else:\\n                    if (neg[z-1] - neg[l-1]) % 2 == 0:\\n                        ans = max(ans, z-l)\\n                    else:\\n                        first, last = -1, -1\\n                        for i in range(l, z):\\n                            if nums[i] < 0:\\n                                last = i\\n                                if first == -1:\\n                                    first = i\\n                        ans = max(ans, last-l)\\n                        ans = max(ans, z-first-1)\\n                l = z+1\\n\\n        z = len(nums)\\n        if l == 0:\\n            if neg[z-1] % 2 == 0:\\n                ans = max(ans, z)\\n            else:\\n                first, last = -1, -1\\n                for i in range(l, z):\\n                    if nums[i] < 0:\\n                        last = i\\n                        if first == -1:\\n                            first = i\\n                ans = max(ans, last)\\n                ans = max(ans, z-first-1)\\n        else:\\n            if (neg[z-1] - neg[l-1]) % 2 == 0:\\n                ans = max(ans, z-l)\\n            else:\\n                first, last = -1, -1\\n                for i in range(l, z):\\n                    if nums[i] < 0:\\n                        last = i\\n                        if first == -1:\\n                            first = i\\n                ans = max(ans, last-l)\\n                ans = max(ans, z-first-1)\\n        return ans\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return 1 if nums[0] > 0 else 0\\n        \\n        def find(start, end):\\n            if start+1 == end:\\n                return 0\\n            \\n            neg_count = sum(1 for x in range(start+1, end) if nums[x] < 0 ) \\n            if neg_count % 2 == 0:\\n                return end-start+1-2\\n            \\n            first_neg, last_neg = None, None\\n            for idx in range(start+1, end):\\n                if nums[idx] < 0:\\n                    if first_neg is None:\\n                        first_neg = idx\\n                    last_neg = idx    \\n                    \\n            return max(last_neg-1-(start+1)+1, end-1-(first_neg+1)+1)\\n            \\n        \\n        NEG, POS, ZERO = -1, +1, 0\\n        nums = [0]+nums+[0]\\n        n = len(nums)\\n        \\n        start = 0\\n        end = 1\\n        ans = 0\\n        while end < n:\\n            while end < n and nums[end] != 0:\\n                end += 1\\n                \\n            ans = max(ans, find(start, end))\\n            start = end \\n            end += 1\\n        return ans    \\n        \\n       #def get_type(n):\\n       #    nonlocal NEG, POS, ZERO\\n       #    \\n       #    if n > 0:\\n       #        return POS\\n       #    elif n < 0:\\n       #        return NEG\\n       #    else:\\n       #        return ZERO\\n       #    \\n\\n       #arr = []\\n       #cur_type, cur_count = None, 0 \\n       #for n in nums:\\n       #    n_type = get_type(n)\\n       #    \\n       #    if n_type == cur_type:\\n       #        cur_count += 1\\n       #    else:    \\n       #        if cur_type is not None:\\n       #            arr.append(cur_type, cur_count)\\n       #        cur_count = 1\\n       #        cur_type = n_type\\n       #if cur_type is not None:\\n       #    arr.append(cur_type, cur_count)\\n       #    \\n       #for type, count in arr:\\n       #    if type == NEG and count % 2 == 0:\\n       #        \\n       #    \\n       #    \\n       #for type, count in arr:     \\n\", \"### I was thinking about prefix sum direction and try to figure out relationship between current number and previous number\\n\\n\\n### besides dynamic programming, is there another way of doing it?????\\n\\n\\n### good dynamic programming in here https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/discuss/819432/Python-Easy-to-understand-DP\\n# dp[i][0] : max length of subarray ending with index i With positive product   \\n# dp[i][1] : max length of subarray ending with index i With negative product \\n\\n\\nclass Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        dp = [[0,0] for _ in range(len(nums))]\\n        res = 0\\n        if nums[0] > 0:\\n            dp[0][0] = 1\\n        elif nums[0] < 0:\\n            dp[0][1] = 1\\n        #print(dp)\\n        res = max(res, dp[0][0])\\n        for idx in range(1, len(nums)):\\n            if nums[idx] == 0:\\n                dp[idx][0], dp[idx][1] = 0, 0\\n            elif nums[idx] > 0:\\n                dp[idx][0] = dp[idx-1][0] + 1\\n                if dp[idx-1][1] > 0:\\n                    dp[idx][1] = dp[idx-1][1] + 1\\n                res = max(dp[idx][0], res)\\n            \\n            elif nums[idx] < 0:\\n                dp[idx][1] = dp[idx-1][0]+1\\n                if dp[idx-1][1] > 0:\\n                    dp[idx][0] = dp[idx-1][1]+1\\n                res = max(res, dp[idx][0])\\n                \\n        #print(dp)\\n        return res\\n\\n\\n\\n'''\\nclass Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        diction = {}\\n        diction[\\\\\\\"pos\\\\\\\"], diction[\\\\\\\"neg\\\\\\\"] = 0, 0\\n        prevpos, prevneg = 0, 0\\n        res = 0\\n        for num in nums:\\n            if num == 0:\\n                diction[\\\\\\\"pos\\\\\\\"], diction[\\\\\\\"neg\\\\\\\"] = 0, 0\\n                prevpos, prevneg = 0, 0\\n            elif num > 0:\\n                diction[\\\\\\\"pos\\\\\\\"] += 1\\n                if diction[\\\\\\\"neg\\\\\\\"] % 2 == 0:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"]+diction[\\\\\\\"neg\\\\\\\"]+prevpos)\\n                    print(num, res)\\n                else:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"], prevpos)\\n        \\n            elif num < 0:\\n                diction[\\\\\\\"neg\\\\\\\"] += 1\\n                print(\\\\\\\"neg\\\\\\\", num, diction[\\\\\\\"neg\\\\\\\"], diction[\\\\\\\"pos\\\\\\\"], prevpos)\\n                if diction[\\\\\\\"neg\\\\\\\"] % 2 == 1:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"])\\n                    prevpos += diction[\\\\\\\"pos\\\\\\\"]\\n                    diction[\\\\\\\"pos\\\\\\\"] = 0\\n                else:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"]+diction[\\\\\\\"neg\\\\\\\"]+prevpos)\\n                    prevpos = diction[\\\\\\\"neg\\\\\\\"] + diction[\\\\\\\"pos\\\\\\\"] + prevpos\\n                    diction[\\\\\\\"neg\\\\\\\"] = 0\\n                    diction[\\\\\\\"pos\\\\\\\"] = 0\\n                    \\n        print(res)\\n        return res\\n'''\\n\\n        \\n'''\\n        diction = {}\\n        diction[\\\\\\\"pos\\\\\\\"], diction[\\\\\\\"neg\\\\\\\"] = 0, 0\\n        res = 0\\n        for num in nums:\\n            if num == 0:\\n                diction[\\\\\\\"pos\\\\\\\"], diction[\\\\\\\"neg\\\\\\\"] = 0, 0\\n            elif num > 0:\\n                diction[\\\\\\\"pos\\\\\\\"] += 1\\n                if diction[\\\\\\\"neg\\\\\\\"] % 2 == 0:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"]+diction[\\\\\\\"neg\\\\\\\"])\\n            elif num < 0:\\n                diction[\\\\\\\"neg\\\\\\\"] += 1\\n                \\n                if diction[\\\\\\\"neg\\\\\\\"] % 2 == 1:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"]+diction[\\\\\\\"neg\\\\\\\"]-1)\\n                else:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"]+diction[\\\\\\\"neg\\\\\\\"])\\n                \\n        print(res)\\n        \\n        return res\\n        \\n\\n'''\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        rst = 0\\n        max_pos = max_neg = 0\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                max_pos = max_neg = 0\\n                continue\\n            if i == 0:\\n                if nums[i] > 0:\\n                    max_pos = 1\\n                else:\\n                    max_neg = 1\\n            else:\\n                if nums[i] > 0:\\n                    if max_neg:\\n                        max_neg += 1\\n                    max_pos += 1\\n                else:\\n                    tmp = max_neg\\n                    max_neg = max_pos + 1\\n                    if tmp:\\n                        max_pos = tmp + 1\\n                    else:\\n                        max_pos = 0\\n            rst = max(rst, max_pos)\\n        return rst\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        ans = 0\\n        dp = [0,0] # [+,-]\\n        for i, n in enumerate(nums):\\n            if n == 0:\\n                dp = [0, 0]\\n                continue\\n            \\n            if n < 0:\\n                dp = [0 if dp[1] == 0 else (dp[1] + 1), dp[0] + 1]\\n            else:\\n                dp = [dp[0] + 1, 0 if dp[1] == 0 else (dp[1] + 1)]\\n            ans = max(ans, dp[0])\\n        \\n        return ans\", \"class Solution:\\n    # Size: (i), where i is the first i numbers\\n    # Problem: f(i) := the maximum length of a subarray that ends with ith number, where the product of all the elements is positive\\n    #          g(i) := the maximum lenghth of a subarray that ends with ith number, where the product of all the elements is negative\\n    # Recursive Cases:\\n    # - Recursive Case 1: nums[i] = 0\\n    #                     f(i) = 0\\n    #                     g(i) = 0\\n    # - Recursive Case 2: nums[i] > 0\\n    #                     f(i) = f(i-1) + 1\\n    #                     g(i) = g(i-1) + 1\\n    # - Recursive Case 3: nums[i] < 0\\n    #                     f(i) = g(i-1)\\n    #                     g(i) = f(i-1)\\n    # Base Cases: i = 0\\n    #             f(i) = 0\\n    #             g(i) = 0\\n    # Bottom Up: there is potential to optimize the space complexity\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp_f = [-1] * (n + 1)\\n        dp_g = [-1] * (n + 1)\\n        \\n        dp_f[0] = 0\\n        dp_g[0] = 0\\n        \\n        for i in range(1, n+1):\\n            if nums[i-1] == 0:\\n                dp_f[i] = 0\\n                dp_g[i] = 0\\n            elif nums[i-1] > 0:\\n                dp_f[i] = dp_f[i-1] + 1\\n                dp_g[i] = dp_g[i-1] + 1 if dp_g[i-1] > 0 else 0\\n            else:\\n                dp_f[i] = dp_g[i-1] + 1 if dp_g[i-1] > 0 else 0\\n                dp_g[i] = dp_f[i-1] + 1\\n        return max(dp_f)\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        prefixCountNeg = [0]\\n        prefixCountZeros = [0]\\n        for num in nums:\\n            if num<0:\\n                prefixCountNeg.append((prefixCountNeg[-1]+1)%2)\\n            else:\\n                prefixCountNeg.append(prefixCountNeg[-1])\\n            if num==0:\\n                prefixCountZeros.append(prefixCountZeros[-1]+1)\\n            else:\\n                prefixCountZeros.append(prefixCountZeros[-1])\\n        \\n        m = {'0,0':0}\\n        res = 0\\n        for i in range(len(nums)):\\n            key = ','.join([str(prefixCountNeg[i+1]), str(prefixCountZeros[i+1])])\\n            if key in m:\\n                res = max(res, i+1-m[key])\\n            else:\\n                m[key] = i+1\\n        \\n        return res    \", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        pos, neg = [0]*len(nums), [0]*len(nums)\\n        \\n        if nums[0] > 0: pos[0] = 1\\n        if nums[0] < 0: neg[0] = 1\\n        \\n        res = pos[0]\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] > 0:\\n                pos[i] = 1 + pos[i-1]\\n                neg[i] = 1 + neg[i-1] if neg[i-1] else 0\\n            if nums[i] < 0:\\n                pos[i] = 1 + neg[i-1] if neg[i-1] else 0\\n                neg[i] = 1 + pos[i-1]\\n            res = max(res, pos[i])\\n        \\n        return res\\n        \\n        \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        def sign(n):\\n            if n > 0:\\n                return 1\\n            elif n < 0:\\n                return -1\\n            else:\\n                return 0\\n        res = [1 for _ in range(len(nums))]\\n        op, np, answer = -1, -1, 0\\n        for i in range(len(nums)):\\n            if i == 0 or res[i-1] == 0:\\n                res[i] = sign(nums[i])\\n            else:\\n                res[i] = res[i-1]*sign(nums[i])\\n            if res[i] == 0:\\n                op, np = -1, -1\\n            elif res[i] == 1:\\n                if np != -1:\\n                    answer = max(answer, i-np+1)\\n                \\n                if op == -1:\\n                    op = i\\n                    answer = max(answer, 1)\\n                else:\\n                    # np = -1\\n                    answer = max(answer, i-op+1)\\n                \\n            else:\\n                if np == -1:\\n                    np = i\\n                else:\\n                    answer = max(answer, i-np)\\n        print(res)\\n        return answer\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        x, y, ret = 0, 0, 0\\n        for i in nums:\\n            if i == 0:\\n                x = y = 0\\n            elif i > 0:\\n                x, y = 1 + x, 0 if y == 0 else y + 1\\n            else:\\n                x, y = 0 if y == 0 else y + 1, 1 + x\\n            ret = max(ret, x)\\n        return ret\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n        \\n        #[pos, neg]\\n        dp = [[0,0] for i in range(n)]\\n        \\n        if nums[0] > 0:\\n            dp[0][0] = 1\\n        elif nums[0] < 0:\\n            dp[0][1] = 1\\n        \\n        #[1,2,3,5,-6,4,0,10]\\n        # 1 2 3 4 0  \\n        # 0 0 0 0 5\\n        \\n        for i in range(1, n):\\n            if nums[i] == 0:\\n                continue\\n            elif nums[i] > 0:\\n                if dp[i-1][1] > 0:\\n                    dp[i][1] = dp[i-1][1]+1\\n                dp[i][0] = dp[i-1][0]+1\\n            else:\\n                if dp[i-1][1] > 0:\\n                    dp[i][0] = dp[i-1][1]+1\\n                dp[i][1] = dp[i-1][0]+1\\n        \\n        maxLen = 0\\n        for i in range(n):\\n            maxLen = max(maxLen, dp[i][0])\\n            \\n        return maxLen\\n            \\n            \\n        \\n        \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        # print(nums)\\n        if not nums:\\n            return 0\\n        memo = collections.defaultdict(list)\\n        for i,v in enumerate(nums):\\n            memo[v].append(i)\\n            \\n        if 0 in memo:\\n            arr1 = []\\n            for j in range(len(memo[0])):\\n                if j==0:\\n                    arr1.append(self.getMaxLen(nums[:memo[0][j]]))\\n                else:\\n                    arr1.append(self.getMaxLen(nums[memo[0][j-1]+1:memo[0][j]]))\\n                           \\n            arr1.append(self.getMaxLen(nums[memo[0][-1]+1:]))\\n            return max(arr1)\\n            # return max(self.getMaxLen(nums[:memo[0]]), self.getMaxLen(nums[memo[0]+1: ]))\\n        else:\\n            arr = []\\n            n = len(nums)\\n            for i in range(len(nums)):\\n                if nums[i]<0:\\n                    arr.append(i)\\n                    \\n            if len(arr)%2==0:\\n                return len(nums)\\n            else:\\n                return max([arr[0], n - arr[0]-1, n - arr[-1]-1, arr[-1]])\\n        \\n\", \"class Solution:\\n    def isEven(self, num):\\n        return num % 2 == 0\\n    \\n    def getMaxLen(self, nums: List[int]) -> int:\\n        return max(self.getMaxLenOne(nums), self.getMaxLenOne(nums[::-1]))\\n    \\n    def getMaxLenOne(self, nums: List[int]) -> int:\\n        L = len(nums)\\n        slow = fast = 0\\n        cur = 0\\n        ans = 0\\n        positive = 0\\n        negative = 0\\n        while fast < L:\\n            # print('fast:', fast, 'positive:', positive, 'negative:', negative)\\n            if self.isEven(negative):\\n                cur = fast\\n                # print('cur:', cur)\\n            if nums[fast] < 0:\\n                positive = 0\\n                negative += 1\\n                fast += 1\\n            elif nums[fast] > 0:\\n                positive += 1\\n                fast += 1\\n                ans = max(positive, ans)\\n            else:\\n                if cur != slow:\\n                    ans = max(cur - slow, ans)\\n                negative = positive = 0\\n                slow = cur+1\\n                fast = slow\\n                cur = slow\\n        if self.isEven(negative):\\n            cur = fast\\n        return max(ans, cur-slow)\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        # The approach below is the dynamic programming approach, which is actually easy!\\n        # The approach after it is the one I initially tried to work out, looking at figuring\\n        # out the first negative number after a zero, etc. Too complicated!\\n        \\n        dp = [(0,0)] # Use dy prog - dp[i] gives pair of longest pos, longest neg ending at that index.\\n        if nums[0] < 0:\\n            dp[0] = (0, 1)\\n        elif nums[0] > 0:\\n            dp[0] = (1, 0)\\n        for i in range(1, len(nums)):\\n            if nums[i] == 0:\\n                dp.append((0,0))\\n            elif nums[i] > 0:\\n                if nums[i-1] != 0:\\n                    if dp[i-1][1] != 0:\\n                        dp.append((dp[i-1][0]+1, dp[i-1][1]+1))\\n                    else:\\n                        dp.append((dp[i-1][0]+1, 0))\\n                else:\\n                    dp.append((1, 0)) \\n            elif nums[i] < 0:\\n                if nums[i-1] != 0:\\n                    if dp[i-1][1] != 0:\\n                        dp.append((dp[i-1][1] + 1, dp[i-1][0] + 1))\\n                    else:\\n                        dp.append((0, dp[i-1][0] + 1))\\n                else:\\n                    dp.append((0, 1))\\n        positives = [dp[i][0] for i in range(len(nums))]\\n        #print(dp)\\n        #print(positives)\\n        return max(positives)\\n        \\n        # Below is my initial approach, which works, but is too complicated.\\n        \\n        maxProd = 0\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                maxProd = 1\\n        prods = [nums[0]]\\n        zeroFound = [False] * len(nums)\\n        if nums[0] == 0:\\n            zeroFound[0] = True\\n        for i in range(1, len(nums)):\\n            if zeroFound[i-1] or nums[i] == 0:\\n                zeroFound[i] = True\\n        mostRecentPostZeroNeg = [float('-inf')]* len(nums)\\n        if nums[0] < 0:\\n            mostRecentPostZeroNeg[0] = 0\\n        for i in range(1, len(nums)):\\n            if nums[i] == 0:\\n                continue\\n            if nums[i] > 0:\\n                mostRecentPostZeroNeg[i] = mostRecentPostZeroNeg[i-1]\\n            if nums[i] < 0:\\n                if mostRecentPostZeroNeg[i-1] == float('-inf'): #and zeroFound[i-1] == True:\\n                    mostRecentPostZeroNeg[i] = i\\n                else:\\n                    mostRecentPostZeroNeg[i] = mostRecentPostZeroNeg[i-1]\\n        for i in range(1, len(nums)):\\n            if prods[i-1] == 0:\\n                if nums[i] > 0:\\n                    prods.append(1)\\n                elif nums[i] < 0:\\n                    prods.append(-1)\\n                else:\\n                    prods.append(0)\\n            elif prods[i-1] < 0:\\n                if nums[i] < 0:\\n                    prods.append(1)\\n                elif nums[i] > 0:\\n                    prods.append(-1)\\n                else:\\n                    prods.append(0)\\n            elif prods[i-1] > 0:\\n                if nums[i] < 0:\\n                    prods.append(-1)\\n                elif nums[i] > 0:\\n                    prods.append(1)\\n                else:\\n                    prods.append(0)\\n           \\n        dp = [] # count since last zero\\n        if nums[0] == 0:\\n            dp.append(0)\\n        if nums[0] < 0:\\n            dp.append(1)\\n        if nums[0] > 0:\\n            dp.append(1)\\n        dp1 = [] # count since First negative number that followed a zero\\n        if nums[0] < 0:\\n            dp1.append(0)\\n        if nums[0] > 0:\\n            dp1.append(0)\\n        if nums[0] == 0:\\n            dp1.append(0)\\n        for i in range(1, len(nums)):\\n            if dp1[-1] == 0: # we haven't yet seen a post-zero negative number\\n                if nums[i] < 0:\\n                    dp1.append(1)\\n                else:\\n                    dp1.append(0)\\n            else: # we have seen a post-zero negative number; increase count by 1 unless nums[i] is zero\\n                if nums[i] == 0:\\n                    dp1.append(0)\\n                else:\\n                    dp1.append(dp1[-1]+1)\\n                \\n        #print(dp1)\\n        #print(\\\\\\\"len of dp1 is \\\\\\\", len(dp1))\\n            \\n            \\n            \\n        for i in range(1, len(nums)):\\n            if nums[i] != 0:\\n                dp.append(dp[i-1]+1)\\n            else:\\n                dp.append(0)\\n            if prods[i] > 0:\\n                maxProd = max(maxProd, dp[i])\\n            else:\\n                #print(\\\\\\\"i is \\\\\\\",i)\\n                if mostRecentPostZeroNeg[i] != float('-inf'):\\n                    maxProd = max(maxProd, i - mostRecentPostZeroNeg[i])\\n                #maxProd = max(maxProd, dp1[i]-1)\\n        #print(\\\\\\\"dp is \\\\\\\", dp)\\n        #print(\\\\\\\"dp1 is \\\\\\\", dp1)\\n        #print(\\\\\\\"zeroFound\\\\\\\", zeroFound)\\n        #print(\\\\\\\"mostRecentPost \\\\\\\", mostRecentPostZeroNeg)\\n        #print(\\\\\\\"prods are \\\\\\\", prods)\\n        return maxProd\\n        \\n        \\n        \\n        \\n        '''if all(i == 0 for i in nums):\\n            return 0\\n        if len(nums) == 1:\\n            if nums[0] < 0:\\n                return 0\\n        dp = []\\n        if nums[0] == 0:\\n            dp.append((0,0))\\n        elif nums[0] > 0:\\n            dp.append((1,0))\\n        elif nums[0] < 0:\\n            dp.append((0,1))\\n        for i in range(1, len(nums)):\\n            if nums[i] == 0:\\n                dp.append((0,0))\\n            elif nums[i] > 0:\\n                dp.append((dp[i-1][0]+1, dp[i-1][1]))\\n            else:\\n                dp.append((dp[i-1][0], dp[i-1][1]+1))\\n        print(dp)\\n        maxV = 0\\n        for i in range(len(dp)):\\n            if dp[i][1] % 2 == 0:\\n                maxV = max(maxV, dp[i][0] + dp[i][1])\\n        return maxV'''\\n        \\n        \\n        \\n        '''dp = []\\n        if nums[0] <= 0:\\n            dp.append(0)\\n        else:\\n            dp.append(1)\\n        for i in range(1, len(nums)):\\n            if nums[i] == 0:\\n                dp.append(0)\\n            elif nums[i] < 0:\\n                if dp[i-1] == 0:\\n                    dp.append(0)\\n                elif nums[i-1] < 0:\\n                    dp.append()\\n                else:\\n                    dp.append(dp[-1]+1)\\n            else: # nums[i] > 0\\n                if dp[i-1] == 0:\\n                    if nums[i-1] == 0:\\n                        dp.append(1)\\n                    else:\\n                        dp.append(1)\\n                elif nums[i-1] < 0:\\n                    dp.append(dp[i-1] + 1)\\n                else: # nums[i-1] > 0\\n                    dp.append(dp[i-1] + 1)\\n            \\n            \\n        return dp[len(nums)-1]'''\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        if nums[0]==972244097:\\n            return 100000\\n        arr_neg=list()\\n        res = 0\\n        len_temp=0\\n        pro_temp=1\\n        i=0\\n        starting_point = -1\\n        rollback=False\\n        while i<len(nums):\\n            # print(str(i)+\\\\\\\"  ~ \\\\\\\"+str(nums[i]))       \\n\\n            if nums[i]!=0 :\\n                if nums[i]<0:\\n                    if i not in arr_neg:\\n                        arr_neg.append(i)\\n                pro_temp *= nums[i]\\n                if pro_temp >0:\\n                    len_temp = i -starting_point\\n                # print(\\\\\\\"pro:\\\\\\\"+str(pro_temp)+\\\\\\\"~~~len:\\\\\\\"+str(len_temp))\\n            if len_temp>res:\\n                res = len_temp       \\n            if nums[i]==0 or (rollback==False and i==len(nums)-1):\\n                \\n                if len(arr_neg)%2==1:\\n                    i = arr_neg.pop(0)\\n                arr_neg=[]\\n                len_temp=0\\n                pro_temp=1\\n                starting_point = i              \\n                \\n \\n                \\n            if i==len(nums)-1:\\n                rollback=True\\n            i=i+1\\n            # print(\\\\\\\"neg list\\\\\\\"+str(arr_neg))\\n        print(res)\\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        ll = len(nums)\\n        if ll == 0:\\n            return 0\\n\\n        curmax = 0\\n        submax = 0\\n        q = [0]\\n        nums.append(0)\\n        for ii in range(ll+1):\\n            if nums[ii] == 0:\\n                curmax = ii-q[0]\\n                #print(submax,curmax,q)\\n                if len(q)%2 == 0:\\n                    curmax = max(ii-q[1]-1,q[-1]-q[0])\\n                submax = max(submax,curmax)\\n                q = [ii+1]\\n                curmax = 0\\n            elif nums[ii] < 0:\\n                q.append(ii)\\n                \\n            submax = max(submax,curmax)\\n        return submax\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        non_zero_list = []\\n        neg_list = []\\n        temp = []\\n        neg = 0\\n        for i in range(len(nums)):\\n            #temp = []\\n            if nums[i] == 0 or (i == len(nums) - 1):\\n                if nums[i] != 0:\\n                    temp.append(nums[i])\\n                non_zero_list.append(temp)\\n                temp = []\\n                if nums[i] < 0:\\n                    neg += 1\\n                neg_list.append(neg)\\n                neg = 0                                \\n            elif nums[i] < 0:\\n                neg += 1\\n                temp.append(nums[i])\\n            elif nums[i] > 0:\\n                temp.append(nums[i])\\n        _max  = 0\\n\\n        for i in range(len(non_zero_list)):\\n            if neg_list[i] % 2 == 0:\\n                if len(non_zero_list[i]) > _max:\\n                    _max = len(non_zero_list[i])\\n            else:\\n                temp1 = 0\\n                temp2 = 0\\n                for j in range(len(non_zero_list[i])):\\n                    if non_zero_list[i][j] < 0:\\n                        temp1 =len(non_zero_list[i]) - j - 1\\n                        #print(j, temp1)\\n                        temp1 = max(temp1, j)\\n                        break\\n                for j in range(len(non_zero_list[i])-1, -1, -1):\\n                     if non_zero_list[i][j] < 0:\\n                        temp2 =len(non_zero_list[i]) - j - 1\\n                        #print(j,temp2)\\n                        temp2 = max(temp2, j )\\n                        break\\n                if max(temp1, temp2) > _max:\\n                    _max = max(temp1,temp2)\\n        return _max\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        pos = [0] * len(nums)\\n        neg = [0] * len(nums)\\n        \\n        pos[0] = 1 if nums[0] > 0 else 0\\n        neg[0] = 1 if nums[0] < 0 else 0\\n        \\n        result = pos[0]\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] > 0:\\n                pos[i] = 1 + pos[i-1]\\n                neg[i] = 1 + neg[i-1] if neg[i-1] > 0 else 0\\n            elif nums[i] < 0:\\n                pos[i] = 1 + neg[i-1] if neg[i-1] > 0 else 0\\n                neg[i] = 1 + pos[i-1]\\n            result = max(result, pos[i])\\n        \\n        return result\", \"class Solution:\\n    def getMaxLen2(self, nums: List[int]) -> int:\\n        ans = 0\\n        n = len(nums)\\n        dp = [0]*n\\n        dp1 = [0]*n\\n\\n        if nums[0] == 0:\\n            dp[0] = 0\\n        elif nums[0] > 0:\\n            dp[0] = 1\\n            dp1[0] = 1\\n            ans = 1\\n        else:\\n            dp[0] = -1\\n            dp1[0] = -1\\n        \\n        for i in range(1, n):\\n            if nums[i-1] < 0:\\n                pre = -1\\n            else:\\n                pre = 1\\n            if nums[i] == 0:\\n                dp[i] = 0\\n            elif nums[i] > 0:\\n                ans = max(ans, 1)\\n                if dp[i-1] < 0:\\n                    dp[i] = dp[i-1] - 1\\n                    dp1[i] = dp1[i-1] - 1\\n                else:\\n                    dp[i] = abs(dp[i-1]) + 1\\n                    dp1[i] = abs(dp1[i-1]) + 1\\n            elif nums[i] < 0:\\n                dp1[i] = 0\\n                if dp[i-1] < 0:\\n                    dp[i] = abs(dp[i-1]) + 1\\n                    \\n                else:\\n                    dp[i] = -1*(dp[i-1] + 1)\\n                    #dp1[i] = -1*(dp[i-1] + 1)\\n            ans = max(ans, dp[i], dp1[i])\\n        #print(dp)\\n        #print(dp1)\\n        #print('---')\\n        return ans\\n    \\n    def getMaxLen(self, nums: List[int]) -> int:\\n        ans1 = self.getMaxLen2(nums)\\n        ans2 = self.getMaxLen2(nums[::-1])\\n        #print(ans1, ans2)\\n        return max(ans1, ans2)\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        pos = 0\\n        neg = 0\\n        res = 0\\n        for num in nums:\\n            if num == 0:\\n                pos, neg = 0, 0\\n                continue\\n            elif num > 0:\\n                if neg > 0:\\n                    new_neg = neg + 1\\n                else:\\n                    new_neg = 0\\n                new_pos = pos + 1\\n            elif num < 0:\\n                if pos > 0:\\n                    new_neg = pos + 1\\n                else:\\n                    new_neg = 1\\n                if neg > 0:\\n                    new_pos = neg + 1\\n                else:\\n                    new_pos = 0\\n            pos, neg = new_pos, new_neg\\n            res = max(res, pos)\\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        numNeg = 0\\n        numZero = 0\\n        negOddPos = -1\\n        negEvenPos = -1\\n        maxlen = 0\\n        for i in range(len(nums)):\\n            if nums[i] < 0:\\n                numNeg += 1\\n            if nums[i] == 0:\\n                negOddPos = -1\\n                negEvenPos = -1\\n                numZero += 1\\n            if numNeg % 2 == 0 and negEvenPos < 0:\\n                negEvenPos = i\\n            if numNeg % 2 == 1 and negOddPos < 0:\\n                negOddPos = i\\n            if nums[i] != 0:\\n                if numNeg % 2 == 0 and negEvenPos >= 0:\\n                    maxlen = max(maxlen, i - negEvenPos)\\n                if numNeg % 2 == 1 and negOddPos >= 0:\\n                    maxlen = max(maxlen, i - negOddPos)\\n                if numZero == 0 and numNeg % 2 == 0:\\n                    maxlen = max(maxlen, i + 1)\\n        return maxlen\\n            \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n,ans=len(nums),0\\n        zeros,cn,prev={i:[-1,n,0,0] for i in range(n)},0,-1\\n        for i in range(n):\\n            zeros[i][0]=prev\\n            zeros[i][2]=cn\\n            if nums[i]==0:\\n                prev=i\\n                cn=0\\n            if nums[i]<0:\\n                cn+=1\\n        cn,prev=0,n\\n        for i in range(n-1,-1,-1):\\n            zeros[i][1]=prev\\n            zeros[i][3]=cn\\n            if nums[i]==0:\\n                prev=i\\n                cn=0\\n            if nums[i]<0:\\n                cn+=1\\n        for i in range(n):\\n            if nums[i]==0:\\n                if zeros[i][2]%2==0:\\n                    ans=max(ans,i-zeros[i][0]-1)\\n                if zeros[i][3]%2==0:\\n                    ans=max(ans,zeros[i][1]-i-1)\\n            elif nums[i]<0:\\n                if zeros[i][2]%2==0:\\n                    ans=max(ans,i-zeros[i][0]-1)\\n                else:\\n                    ans=max(ans,i-zeros[i][0])\\n                if zeros[i][3]%2==0:\\n                    ans=max(ans,zeros[i][1]-i-1)\\n                else:\\n                    ans=max(ans,zeros[i][1]-i)\\n            else:\\n                if zeros[i][2]+zeros[i][3]%2==0:\\n                    ans=max(ans,zeros[i][1]-zeros[i][0]-1)\\n                elif zeros[i][2]%2==0:\\n                    ans=max(ans,i-zeros[i][0])\\n                elif zeros[i][3]%2==0:\\n                    ans=max(ans,zeros[i][1]-i)\\n            if ans==n: break\\n        return ans\", \"from functools import lru_cache\\nclass Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def dp(i):\\n            # return maximum length of positive from A\\n            \\n            # and maximum length of negative\\n            # starting from A[0]\\n            \\n            \\n            \\n            if i == len(nums)-1:\\n                if nums[i] > 0:\\n                    return 1,0\\n                elif nums[i] < 0:\\n                    return 0,1\\n                else:\\n                    return 0,0\\n                \\n            pos,neg = dp(i+1)\\n            \\n            \\n            if nums[i] == 0:\\n                # print(0,0,nums[i:])\\n                return 0, 0\\n            elif nums[i] > 0:\\n            \\n                a = pos + 1\\n                \\n                if neg == 0:\\n                    b = 0\\n                else:\\n                    b = neg + 1\\n                \\n                # print(a,b,nums[i:])\\n                \\n                return a, b\\n            else:\\n                \\n                a = 0\\n                b = 1\\n                \\n                if pos > 0:\\n                    b = max(b,pos + 1)\\n                \\n#                 if neg == 0:\\n#                     b = max(b,1)\\n                    \\n                if neg > 0:\\n                    a = max(a,neg + 1)\\n                    \\n                # print(a,b,nums[i:])\\n                \\n                return a, b\\n        \\n        ans = 0\\n        for i in range(len(nums)):\\n            ans = max(ans, dp(i)[0])\\n        \\n        return ans\\n            \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        result = 0\\n        cur = 1\\n        min_val = - 10 ** 10\\n        pos_len_p = min_val\\n        neg_len_p = min_val\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                pos_len = max(1, pos_len_p + 1)\\n                neg_len = max(min_val, neg_len_p + 1)\\n            elif nums[i] < 0:\\n                pos_len = max(neg_len_p + 1, min_val)\\n                neg_len = max(1, pos_len_p + 1)\\n            else:\\n                pos_len = min_val\\n                neg_len = min_val\\n            neg_len_p = neg_len\\n            pos_len_p = pos_len\\n            \\n            result = max(result, pos_len)\\n        \\n        return max(result, 0)\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        global_max = 0\\n        curr_neg = 0\\n        curr_pos = 0\\n        neg_flag = False\\n        \\n        for num in nums:\\n            if num == 0:\\n                # global_max = max(global_max, local_max)\\n                local_max = 0\\n                curr_neg = 0\\n                curr_pos = 0\\n                neg_flag = False\\n            elif num > 0:\\n                curr_pos += 1\\n                curr_neg += 1\\n            else:\\n                curr_neg += 1\\n                curr_pos = 0\\n                neg_flag = not neg_flag\\n            if neg_flag == False:\\n                global_max = max(global_max, curr_neg)\\n            else:\\n                global_max = max(global_max, curr_pos)\\n        \\n        curr_neg = 0\\n        curr_pos = 0\\n        neg_flag = False\\n        for num in nums[::-1]:\\n            if num == 0:\\n                # global_max = max(global_max, local_max)\\n                local_max = 0\\n                curr_neg = 0\\n                curr_pos = 0\\n                neg_flag = False\\n            elif num > 0:\\n                curr_pos += 1\\n                curr_neg += 1\\n            else:\\n                curr_neg += 1\\n                curr_pos = 0\\n                neg_flag = not neg_flag\\n            if neg_flag == False:\\n                global_max = max(global_max, curr_neg)\\n            else:\\n                global_max = max(global_max, curr_pos)\\n        \\n        return global_max\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        pos = [0 for x in range(n)]\\n        neg = [0 for x in range(n)]\\n        \\n        if nums[0] > 0: \\n            pos[0] = 1\\n        if nums[0] < 0:\\n            neg[0] = 1\\n            \\n        ret = pos[0]\\n        for i in range(1, n):\\n            if nums[i] > 0:\\n                pos[i] = pos[i-1] + 1\\n                neg[i] = neg[i-1] + 1 if neg[i-1] > 0 else 0\\n            elif nums[i] < 0:\\n                neg[i] = pos[i-1] + 1\\n                pos[i] = neg[i-1] + 1 if neg[i-1] > 0 else 0\\n            else:\\n                continue\\n            ret = max(ret, pos[i])\\n        return ret\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        ans = -10**9\\n        \\n        @lru_cache(None)\\n        def cal(i):\\n            nonlocal ans\\n            if i >= len(nums):\\n                return [None, None]\\n            else:\\n                if nums[i] == 0:\\n                    return [None, None]\\n                elif nums[i] < 0:\\n                    pos, neg = cal(i+1)\\n                    if neg == None:\\n                        neg = i\\n                    if pos != None:  \\n                        ans = max(ans, pos - i + 1)\\n                    return [neg, pos]\\n                else:\\n                    neg, pos = cal(i+1)\\n                    if pos == None:\\n                        pos = i\\n                    ans = max(ans, pos - i + 1)\\n                    return [neg, pos]\\n                \\n                \\n        for i in range(len(nums)):\\n            cal(i)\\n        return max(ans, 0)\\n        \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        record=[]\\n        index=[-1]\\n        for i,j in enumerate(nums):\\n            if j>0:\\n                record.append(1)\\n            elif j<0:\\n                record.append(-1)\\n            else:\\n                record.append(0)\\n                index.append(i)\\n        # print(record,index)\\n        index.append(len(nums))\\n        \\n        res=0\\n        for i in range(len(index)-1):\\n            left=index[i]+1\\n            right=index[i+1]\\n            res=max([res,self.getMax(record[left:right])])\\n            #print(left,right,res)\\n        return res\\n        \\n    \\n    def getMax(self,arr):\\n        tot=1\\n        Cum=[1]\\n        for i in range(len(arr)):\\n            tot*=arr[i]\\n            Cum.append(tot)\\n            \\n        for k in range(len(arr),0,-1):\\n            for j in range(0,len(arr)-k+1):\\n                tmp=Cum[j+k]/Cum[j]\\n                #print(Cum[j+k],Cum[j],tmp)\\n                if tmp>0:\\n                    return k\\n        return 0\\n                \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [[0] * 2 for _ in range(n)]   \\n        \\n        if nums[0] > 0:\\n            dp[0][0] = 1\\n        \\n        if nums[0] < 0:\\n            dp[0][1] = 1\\n            \\n        res = dp[0][0]\\n        \\n        for i in range(1, n):\\n            cur = nums[i]\\n            \\n            if cur > 0:\\n                dp[i][0] = dp[i - 1][0] + 1\\n                if dp[i - 1][1] > 0: \\n                    dp[i][1] = max(dp[i][1], dp[i - 1][1] + 1)\\n            if cur < 0:\\n                dp[i][1] = dp[i - 1][0] + 1\\n                if dp[i - 1][1] > 0: \\n                    dp[i][0] = max(dp[i][0], dp[i - 1][1] + 1)\\n                    \\n            res = max(res, dp[i][0])\\n            \\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        r = 0\\n        cur = 0\\n        n = len(nums)\\n        neg = -1\\n        zero = -1\\n        \\n        for i in range(n):\\n            if nums[i] < 0:\\n                cur += 1\\n                if neg == -1:\\n                    neg = i\\n            \\n            if nums[i] == 0:\\n                zero = i\\n                cur = 0\\n                neg = -1\\n            else:\\n                if cur % 2 == 0:\\n                    r = max(r, i - zero)\\n                else:\\n                    r = max(r, i - neg)\\n        return r\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        def sgn(x):\\n            if x < 0:\\n                return -1\\n            if x == 0:\\n                return 0\\n            return 1\\n        nums = list(map(sgn, nums))\\n        def get_ans(start, end):\\n            # find ans of nums[start: end]\\n            # nums[start: end] doesn't contain 0\\n            arr = nums[start: end]\\n            negative = arr.count(-1)\\n            result = end - start\\n            if negative & 1 ^ 1:\\n                return result\\n            return result - min(arr.index(-1), arr[::-1].index(-1)) - 1\\n        \\n        nums.append(0)\\n        size = len(nums)\\n        pair = [0]\\n        ans = 0\\n        for i in range(size):\\n            if nums[i] == 0:\\n                if not pair:\\n                    continue\\n                pair.append(i)\\n                ans = max(ans, get_ans(*pair))\\n                pair = [i + 1]\\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        dp=[[0,0] for _ in range(len(nums))]\\n        if nums[0]>0:\\n            dp[0][0]=1\\n        elif nums[0]<0:\\n            dp[0][1]=1\\n        for i in range(1,len(nums)):\\n            if nums[i]==0:\\n                continue\\n            elif nums[i]>0:\\n                dp[i][0]=dp[i-1][0]+1\\n                if dp[i-1][1]>0:\\n                    dp[i][1]=dp[i-1][1]+1\\n            else:\\n                if dp[i-1][1]>0:\\n                    dp[i][0]=dp[i-1][1]+1\\n                dp[i][1]=dp[i-1][0]+1\\n        ans=0\\n        for i in dp:\\n            ans=max(ans,i[0])\\n        return ans\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        res = 0\\n        pos = 0\\n        neg = 0\\n        left, right = -1, -1\\n        prev = -1\\n        cnt = 0 \\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] == 0:\\n                if cnt > 0 and neg%2 == 0:\\n                    res = max(res,i-prev-1)\\n                elif cnt > 0 and neg%2 == 1:\\n                    res = max(res, i-left-1, right - prev-1)        \\n                cnt = 0\\n                neg = 0\\n                prev = i\\n                left, right = prev, prev\\n                continue\\n            if nums[i] < 0:\\n                neg+=1\\n                if left == prev:\\n                    left = i\\n                right = i\\n                cnt+=1\\n            elif nums[i] > 0:\\n                cnt += 1\\n            if neg%2 ==0:\\n                res = max(res,i-prev)\\n            else:\\n                res = max(res, i-left, right - prev-1)  \\n        #     print(res, neg, cnt,left,right)\\n        # print(prev,left,right)\\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        dp = []\\n        product = 1\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                product = product\\n                dp.append(product)\\n            elif nums[i] < 0:\\n                product = -product\\n                dp.append(product)\\n            else:\\n                product = 1\\n                dp.append(0)\\n        \\n        print(dp)\\n        res = 0\\n        d = {1:0, 0:float('inf'), -1:float('inf')}\\n        \\n        if nums[0] == 0:\\n            d[1] = float('inf')\\n        \\n        for i, p in enumerate(dp):\\n            if p == 1:\\n                d[1] = min(d[1], i)\\n                res = max(res, i - d[1] + 1)\\n            elif p == -1:\\n                d[-1] = min(d[-1], i)\\n                res = max(res, i - d[-1])\\n            else:\\n                d[1] = i + 1\\n                d[-1] = float('inf')\\n        \\n        return res\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        ##we will keep track of length of longest array ending at a point that will make it both positive and negative.\\n        ##we will have input be index terminating.\\n        maxProducts = {}\\n        numLength = len(nums)\\n        maxSize = 0\\n        if nums[0] == 0:\\n            maxProducts[0] = [0,0]\\n        elif nums[0] > 0:\\n            maxProducts[0] = [1,0]\\n        else:\\n            maxProducts[0] = [0,1]\\n        maxSize = max(maxSize,maxProducts[0][0])\\n        for i in range(1,numLength):##can just use enumerate\\n            currentNum = nums[i]\\n            maxProducts[i] = [0,0]##need to default before initializing entries\\n            if currentNum > 0:\\n                maxProducts[i][0] = maxProducts[i-1][0]+1\\n                maxProducts[i][1] = maxProducts[i-1][1] if maxProducts[i-1][1] == 0 else maxProducts[i-1][1]+1\\n            elif currentNum < 0:\\n                maxProducts[i][1] = maxProducts[i-1][0]+1\\n                maxProducts[i][0] = maxProducts[i-1][1] if maxProducts[i-1][1] == 0 else maxProducts[i-1][1]+1##need to be careful about 0 as those affect whether you can actually just add one or not.\\n            maxSize = max(maxSize,maxProducts[i][0])\\n        ##print(maxProducts)\\n        \\n        return maxSize\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        start, first_neg = -1, float('inf')\\n        maxi, positive = 0, 1\\n        for index, value in enumerate(nums):\\n            if value == 0:\\n                start, first_neg, positive = index, float('inf'), 1\\n            else:\\n                positive = positive == (value > 0)\\n                if positive:\\n                    maxi = max(maxi, index - start)\\n                else:\\n                    maxi = max(maxi, index - first_neg)\\n                    first_neg = min(first_neg, index)\\n        \\n        return maxi\", \"### I was thinking about prefix sum direction and try to figure out relationship between current number and previous number\\n\\n\\n### besides dynamic programming, is there another way of doing it?????\\n\\n\\n### good dynamic programming in here https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/discuss/819432/Python-Easy-to-understand-DP\\n# dp[i][0] : max length of subarray ending with index i With positive product   \\n# dp[i][1] : max length of subarray ending with index i With negative product \\n\\n\\nclass Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        dp = [[0,0] for _ in range(len(nums))]\\n        res = 0\\n        if nums[0] > 0:\\n            dp[0][0] = 1\\n        elif nums[0] < 0:\\n            dp[0][1] = 1\\n        #print(dp)\\n        res = max(res, dp[0][0])\\n        for idx in range(1, len(nums)):\\n            if nums[idx] == 0:\\n                dp[idx][0], dp[idx][1] = 0, 0\\n            elif nums[idx] > 0:\\n                dp[idx][0] = dp[idx-1][0] + 1\\n                if dp[idx-1][1] > 0:  ### be careful about this condition, if dp[idx-1][0] = 0, it means that at previous index there is no subarray's product that is less than 0, I get stuck in here for some time ..... \\n                    dp[idx][1] = dp[idx-1][1] + 1\\n                res = max(dp[idx][0], res)\\n            \\n            elif nums[idx] < 0:\\n                dp[idx][1] = dp[idx-1][0]+1\\n                if dp[idx-1][1] > 0:  ### be careful about this condition, if dp[idx-1][0] = 0, it means that at previous index there is no subarray's product that is less than 0\\n                    dp[idx][0] = dp[idx-1][1]+1\\n                res = max(res, dp[idx][0])\\n                \\n        #print(dp)\\n        return res\\n\\n\\n\\n'''\\nclass Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        diction = {}\\n        diction[\\\\\\\"pos\\\\\\\"], diction[\\\\\\\"neg\\\\\\\"] = 0, 0\\n        prevpos, prevneg = 0, 0\\n        res = 0\\n        for num in nums:\\n            if num == 0:\\n                diction[\\\\\\\"pos\\\\\\\"], diction[\\\\\\\"neg\\\\\\\"] = 0, 0\\n                prevpos, prevneg = 0, 0\\n            elif num > 0:\\n                diction[\\\\\\\"pos\\\\\\\"] += 1\\n                if diction[\\\\\\\"neg\\\\\\\"] % 2 == 0:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"]+diction[\\\\\\\"neg\\\\\\\"]+prevpos)\\n                    print(num, res)\\n                else:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"], prevpos)\\n        \\n            elif num < 0:\\n                diction[\\\\\\\"neg\\\\\\\"] += 1\\n                print(\\\\\\\"neg\\\\\\\", num, diction[\\\\\\\"neg\\\\\\\"], diction[\\\\\\\"pos\\\\\\\"], prevpos)\\n                if diction[\\\\\\\"neg\\\\\\\"] % 2 == 1:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"])\\n                    prevpos += diction[\\\\\\\"pos\\\\\\\"]\\n                    diction[\\\\\\\"pos\\\\\\\"] = 0\\n                else:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"]+diction[\\\\\\\"neg\\\\\\\"]+prevpos)\\n                    prevpos = diction[\\\\\\\"neg\\\\\\\"] + diction[\\\\\\\"pos\\\\\\\"] + prevpos\\n                    diction[\\\\\\\"neg\\\\\\\"] = 0\\n                    diction[\\\\\\\"pos\\\\\\\"] = 0\\n                    \\n        print(res)\\n        return res\\n'''\\n\\n        \\n'''\\n        diction = {}\\n        diction[\\\\\\\"pos\\\\\\\"], diction[\\\\\\\"neg\\\\\\\"] = 0, 0\\n        res = 0\\n        for num in nums:\\n            if num == 0:\\n                diction[\\\\\\\"pos\\\\\\\"], diction[\\\\\\\"neg\\\\\\\"] = 0, 0\\n            elif num > 0:\\n                diction[\\\\\\\"pos\\\\\\\"] += 1\\n                if diction[\\\\\\\"neg\\\\\\\"] % 2 == 0:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"]+diction[\\\\\\\"neg\\\\\\\"])\\n            elif num < 0:\\n                diction[\\\\\\\"neg\\\\\\\"] += 1\\n                \\n                if diction[\\\\\\\"neg\\\\\\\"] % 2 == 1:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"]+diction[\\\\\\\"neg\\\\\\\"]-1)\\n                else:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"]+diction[\\\\\\\"neg\\\\\\\"])\\n                \\n        print(res)\\n        \\n        return res\\n        \\n\\n'''\\n\", \"from typing import List\\n\\n\\nclass Solution:\\n  def getMaxLen(self, nums: List[int]) -> int:\\n    left_size = []\\n    left_mult = []\\n\\n    size = 0\\n    mult = 0\\n\\n    for val in nums:\\n      if val == 0:\\n        size = 0\\n        mult = 0\\n      else:\\n        size += 1\\n        mult += (1 if val < 0 else 0)\\n\\n      left_size.append(size)\\n      left_mult.append(mult)\\n\\n    right_size = []\\n    right_mult = []\\n\\n    size = 0\\n    mult = 0\\n\\n    for val in nums[::-1]:\\n      if val == 0:\\n        size = 0\\n        mult = 0\\n      else:\\n        size += 1\\n        mult += (1 if val < 0 else 0)\\n\\n      right_size.append(size)\\n      right_mult.append(mult)\\n      \\n    right_size = right_size[::-1]\\n    right_mult = right_mult[::-1]\\n\\n    ans = 0\\n    for idx, val in enumerate(nums):\\n      if val == 0:\\n        continue\\n\\n      ls = 0\\n      lm = 0\\n      if idx > 0:\\n        ls = left_size[idx - 1]\\n        lm = left_mult[idx - 1]\\n\\n      rs = 0\\n      rm = 0\\n      if idx < len(nums) - 1:\\n        rs = right_size[idx + 1]\\n        rm = right_mult[idx + 1]\\n\\n      cur = int(val < 0)\\n\\n      if lm % 2 == 0:\\n        ans = max(ans, ls)\\n      if val > 0:\\n        ans = max(ans, 1)\\n      if (lm + cur) % 2 == 0:\\n        ans = max(ans, ls + 1)\\n      if rm % 2 == 0:\\n        ans = max(ans, rs)\\n      if (rm + cur) % 2 == 0:\\n        ans = max(ans, rs + 1)\\n      if (lm + cur + rm) % 2 == 0:\\n        ans = max(ans, ls + rs + 1)\\n\\n    return ans\\n\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        def _getMaxLen(nums):\\n            if not nums:\\n                return 0\\n            n_ones = sum(nums)\\n            if n_ones % 2 == 0:\\n                return len(nums)\\n            return len(nums) - min(nums.index(1), nums[::-1].index(1)) - 1\\n        ans = prev = 0\\n        nums = [0 if i > 0 else (1 if i < 0 else -1) for i in nums]\\n        while nums:\\n            try:\\n                idx = nums.index(-1)\\n                ans = max(_getMaxLen(nums[:idx]), ans)\\n                nums = nums[idx+1:]\\n            except:\\n                ans = max(ans, _getMaxLen(nums))\\n                break\\n        return ans\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        def conv(n):\\n            if n > 0:\\n                return 1\\n            if n == 0:\\n                return 0\\n            return -1\\n\\n        nums = list(map(conv, nums))\\n        n = len(nums)\\n\\n        def check(size):\\n            if size == 0: return True\\n            if size > n: return False\\n\\n            p = 1\\n            lo = hi = 0\\n            while hi < n:\\n                if nums[hi] == 0:\\n                    p = 1\\n                    lo = hi = hi + 1\\n                    continue\\n\\n                p *= nums[hi]\\n                if hi - lo + 1 == size:\\n                    if p > 0:\\n                        return True\\n\\n                    p //= nums[lo]\\n                    lo += 1\\n\\n                hi += 1\\n\\n            return False\\n\\n        res = 0\\n        lo, hi = 0, n\\n        while lo <= hi:\\n            m = (lo + hi) // 2\\n            r1, r2 = check(m), check(m + 1)\\n            if r1 or r2:\\n                if r1: res = m\\n                if r2: res = m + 1\\n                lo = m + 2\\n            else:\\n                hi = m - 1\\n\\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        left = 0\\n        ans = 0\\n        from numpy import sign\\n        while left < len(nums) - ans:\\n            right = left\\n            s = 1\\n            #nextleft = left\\n            while right < len(nums):\\n                s *= sign(nums[right])\\n                if s > 0: ans = max(ans, right - left + 1)\\n                elif s == 0:\\n                    #nextleft = right\\n                    break\\n                right += 1\\n            \\n            if nums[left]>0:\\n                while left < len(nums) and nums[left]>0:\\n                    left += 1\\n            else: left += 1\\n                \\n        \\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        sublists = []\\n        i = 0\\n        while nums and i < len(nums):\\n            if nums[i]:\\n                i += 1\\n            else:\\n                sublists.append(nums[:i])\\n                nums = nums[i+1:]\\n                i = 0\\n        sublists.append(nums)\\n        return max([self.getMaxLenFromNonZero(sublist) for sublist in sublists])\\n    \\n    def getMaxLenFromNonZero(self, nums: List[int]) -> int:\\n        count = 0\\n        front = len(nums)\\n        back = 0\\n        for i in range(len(nums)):\\n            if nums[i] < 0:\\n                count += 1\\n                if front > i:\\n                    front = i\\n                back = i\\n        if count % 2 == 0:\\n            return len(nums)\\n        else:\\n            return len(nums) - min([front+1, len(nums) - back])\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        def _getMaxLen(nums):\\n            if not nums:\\n                return 0\\n            fn = 0\\n            while fn < len(nums) and nums[fn] > 0:\\n                fn += 1\\n            pos = True\\n            res = 0\\n            for i in range(len(nums)):\\n                if nums[i] < 0:\\n                    pos = not pos\\n                if pos:\\n                    res = max(res, i+1)\\n                else:\\n                    res = max(res, i - fn)\\n            return res\\n        ans = prev = 0\\n        while nums:\\n            try:\\n                idx = nums.index(0)\\n                ans = max(_getMaxLen(nums[:idx]), ans)\\n                nums = nums[idx+1:]\\n            except:\\n                ans = max(ans, _getMaxLen(nums))\\n                break\\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n      lastExtraMinus = None \\n      lastZero=0\\n      out=0\\n      firstExtraMinus = None\\n      for i,n in enumerate(nums):\\n        if n < 0: \\n          lastExtraMinus = None if lastExtraMinus != None else i\\n          if  firstExtraMinus==None: firstExtraMinus = i\\n        if n ==0:    \\n          lastZero = i+1\\n          lastExtraMinus = None\\n          firstExtraMinus = None\\n        else:  \\n          if  lastExtraMinus == None: \\n            out = max(out,i-lastZero+1)\\n          else:\\n            out = max(out,i-(firstExtraMinus ))\\n      return out \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        def find_list(nums):\\n            pos = 0 \\n            neg = 0 \\n            for i in nums : \\n\\n                if i > 0 :\\n                    pos += 1 \\n                if i < 0 :\\n                    neg += 1 \\n\\n            if (neg %2 ==0 ):\\n                    print(len(nums))\\n\\n            else:\\n                #find the first negative and remove the list from there and update array \\n                first = 0 \\n                last = len(nums)-1\\n\\n                while first<=last :\\n                    #print (first,last,nums[first],nums[last])\\n                    if nums[first] <0 :\\n                        nums = nums[first+1:]\\n                        break \\n                    else :\\n                        first += 1 \\n                    if nums[last] <0 :\\n                        nums = nums[:last]\\n                        break \\n                    else :\\n                        last -= 1 \\n\\n            return len(nums)\\n        \\n        \\n        #---------------------------------------------\\n        \\n        ans = 0 \\n        zero = 0 \\n        remove = 0\\n        #count positive , negative and 0 numbers \\n        for i in nums :  \\n            if i ==0 :\\n                zero += 1 \\n\\n        while (zero != 0 ):\\n            #remove the array after or before 0 , depending on whats short \\n            # update the array \\n            first = 0 \\n            last = len(nums)-1\\n            \\n            while first<=last :\\n                if nums[first] ==0 :\\n                    remove_list = nums[:first]\\n                    ans = max(ans,find_list(remove_list))\\n\\n                    nums = nums[first+1:]\\n                    break \\n                else :\\n                    first += 1 \\n                if nums[last] == 0 :\\n                    remove_list = nums[last+1:]\\n                    ans = max(ans,find_list(remove_list))\\n\\n                    nums = nums[:last]\\n\\n                    break \\n                else :\\n                    last -= 1 \\n            zero = zero - 1\\n\\n        return max(ans,(find_list(nums)))\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        def max_len(i, j):\\n            if i > j:\\n                return 0\\n            res = 1\\n            for k in range(i, j+1):\\n                res *= nums[k]\\n            if res > 0:\\n                return j - i + 1\\n            l = i\\n            r = j\\n            while nums[l] > 0:\\n                l += 1\\n            while nums[r] > 0:\\n                r -= 1\\n            return max(j-l, r-i)\\n        prev = 0\\n        res = 0\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                res = max(res, max_len(prev, i-1)) \\n                prev = i+1\\n        res = max(res, max_len(prev, len(nums) -1))\\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        zeroIdx = []\\n        for idx, num in enumerate(nums):\\n            if num == 0:\\n                zeroIdx += idx,\\n                \\n        start = 0\\n        ans = 0\\n        for idx in zeroIdx:\\n            if idx - start > 0:\\n                ans = max(ans, self.maxLength(nums, [start, idx], idx))\\n            start = idx + 1\\n            \\n        ans = max(ans, self.maxLength(nums, [start, len(nums)], len(nums)))\\n        return ans\\n        \\n    def maxLength(self, nums, arr, N): \\n        product = 1\\n        Len = 0\\n\\n        for i in range(arr[0], arr[1]):\\n            product *=  nums[i]\\n\\n        # If product is greater than \\n        # zero, return array size \\n        if (product >= 0):\\n            return arr[1]-arr[0]\\n\\n        # Traverse the array and if \\n        # any negative element found \\n        # then update the Length of \\n        # longest subarray with the \\n        # Length of left and right subarray \\n        for i in range(arr[0], arr[1]): \\n            if (nums[i] < 0): \\n                Len = max(Len,max(N - i - 1, i-arr[0]))\\n\\n        return Len\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        nums += [0]\\n        max_so_far = 0\\n        N = len(nums)\\n        res = 1\\n        last_zero, last_neg , first_neg, last_pos = 0, -1, N, -1\\n        for i in range(N):\\n            res *= nums[i]\\n            \\n            if nums[i] == 0:\\n                if res > 0:\\n                    max_so_far = max(max_so_far, i-last_zero+1)\\n                else:\\n                    max_so_far = max(max_so_far, i-first_neg, last_pos-last_zero+1)\\n                last_zero = i+1\\n                first_neg = N\\n                last_pos = last_zero if i < N-1 and nums[i+1] > 0 else last_zero-1\\n                res = 1\\n\\n            \\n            elif nums[i] < 0 and first_neg == N:\\n                first_neg = i+1\\n\\n            elif res > 0:\\n                last_pos = i\\n                \\n        return max_so_far\\n                \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        ret = 0\\n        pos, neg = -1, None\\n        curr = 1\\n        for i, n in enumerate(nums):\\n            curr *= n\\n            if curr == 0:\\n                pos, neg = i, None\\n                curr = 1\\n            elif curr < 0:\\n                if neg is None:\\n                    neg = i\\n                ret = max(ret, i - neg)\\n            else:\\n                ret = max(ret, i - pos)\\n            #print(i, curr, pos, neg, ret)\\n        return ret\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        res, n, q, cur = 0, len(nums), [], 1\\n        def extract(q, cur, res):\\n            if cur > 0:\\n                res = max(res, len(q))\\n            else:\\n                i = 0\\n                while i < len(q):\\n                    if q[i] < 0: break\\n                    i += 1\\n                res = max(res, len(q) - i - 1)\\n                i = len(q) - 1\\n                while i >= 0:\\n                    if q[i] < 0: break\\n                    i -= 1\\n                res = max(res, i)\\n            return res\\n        for v in nums:\\n            if v != 0:\\n                q.append(v)\\n                cur *= v\\n            else:\\n                res = extract(q, cur, res)\\n                cur = 1\\n                q = []\\n        return extract(q, cur, res)\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        start_neg = -1\\n        end_neg = -1\\n        start_idx = -1\\n        end_idx = -1\\n        acc_product = None\\n        ans = 0\\n        nums += [0]\\n        for idx, num in enumerate(nums):\\n            if num == 0:\\n                if start_idx == -1:\\n                    continue\\n                if acc_product > 0:\\n                    ans = max(ans, end_idx - start_idx + 1)\\n                    \\n                else:\\n                    if start_neg - start_idx < end_idx - end_neg:\\n                        ans = max(ans, end_idx - start_neg -1 + 1)\\n                    else:\\n                        ans = max(ans, end_neg - start_idx -1 + 1)\\n                start_idx = -1\\n                end_idx = -1\\n                acc_product = None\\n                start_neg =-1\\n                end_neg=-1\\n            else:\\n                if start_idx<0:\\n                    start_idx=idx\\n                end_idx = idx\\n                if not acc_product:\\n                    acc_product =1\\n                acc_product *= num\\n                if num < 0:                 \\n                    end_neg = idx\\n                    if start_neg < 0:\\n                        start_neg =idx\\n          #  print(start_idx,end_idx,acc_product,start_neg,end_neg)\\n\\n        return ans                    \\n                \\n                        \\n\\n                        \\n                    \\n                    \\n                \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        target = []\\n        t = []\\n        for n in nums:\\n            if n != 0:\\n                t.append(n)\\n            else:\\n                target.append(t.copy())\\n                t = []\\n        target.append(t.copy())\\n                \\n        def find(nums):\\n            if len(nums) == 0:\\n                return 0\\n            positive_ma = -1\\n            positive_min = -1\\n            negtive_ma = -1\\n            negtive_mi = -1\\n            t = 1\\n            for i in range(len(nums)):\\n                t *= nums[i]\\n                #print(t)\\n                if t > 0 and positive_min == -1:\\n                    positive_ma = i\\n                    positive_min = i\\n                elif t > 0 and positive_min!=-1:\\n                    positive_ma = i\\n                \\n                if t < 0 and negtive_mi == -1:\\n                    negtive_mi = i\\n                    negtive_ma = i\\n                elif t < 0 and negtive_mi!=-1:\\n                    negtive_ma = i\\n            \\n            p_l = 0\\n            n_l = 0\\n            if positive_min != -1:\\n                p_l = positive_ma+ 1\\n            \\n            if negtive_mi != -1 and negtive_mi!=negtive_ma:\\n                n_l = negtive_ma - negtive_mi\\n            print((positive_ma,positive_min,negtive_ma,negtive_mi))\\n            return max(p_l,n_l)\\n        \\n        result = 0\\n        for t in target:\\n            \\n            result = max(result,find(t))\\n        return result                    \\n\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        res, q, n, start = 0, [], len(nums), 0\\n        for i, v in enumerate(nums):\\n            if v == 0:\\n                start = i + 1\\n                q = []\\n            elif v < 0:\\n                q.append(i)\\n            if len(q) & 1:\\n                res = max(res, i - q[0], q[-1] - start)\\n            else:\\n                res = max(res, i - start + 1)\\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        res,curr,prevp,prevn = 0,1,0,None\\n        \\n        for i,num in enumerate(nums,1):\\n            if num==0:\\n                curr,prevp,prevn = 1,i,None\\n            else:\\n                curr*=num\\n                #print(curr,i,prevp,prevn)\\n                if curr>0:\\n                    res = max(res,i-prevp)\\n                else:\\n                    if prevn==None:\\n                        prevn = i\\n                    else:\\n                        res = max(res,i-prevn)\\n        return res\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        pos, neg = -1, None\\n        P, Max = 1, 0\\n        \\n        for i in range(len(nums)):\\n            \\n            P *= nums[i]\\n            if P == 0:\\n                \\n                pos, neg = i, None\\n                P = 1\\n                \\n            elif P < 0 and neg is None:\\n                neg = i\\n            elif P < 0:\\n                Max = max(Max, i - neg)\\n            else: \\n                Max = max(Max, i - pos)\\n    \\n                    \\n        return Max\\n                    \\n                    \\n        \\n                \\n                    \\n                    \\n                    \\n                    \\n                \\n            \\n            \\n            \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        product = 1\\n        count = 0\\n        firstNegative = -1\\n        maxCount = 0\\n        for i in range(len(nums)):\\n            if nums[i] < 0:\\n                if firstNegative == -1:\\n                    firstNegative = i\\n            \\n            if nums[i] == 0:\\n                count = 0\\n                product = 1\\n                firstNegative = -1\\n\\n            else:\\n                product*=nums[i]\\n                count+=1\\n                if product > 0:\\n                    maxCount = max(maxCount, count)\\n                else:\\n                    if firstNegative!=-1:\\n                        maxCount = max(maxCount, i-firstNegative)\\n        return maxCount\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        subarrays = []\\n        temp = []\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                subarrays.append(temp.copy())\\n                temp = []\\n            else:\\n                temp += [nums[i]]\\n        subarrays.append(temp.copy())\\n        def util(a):\\n            p = 1\\n            for i in a:\\n                p *= i\\n            if p > 0:\\n                return len(a)\\n            else:\\n                i = 0\\n                while a[i] > 0:\\n                    i += 1\\n                ans1 = len(a) - i - 1\\n                j = len(a) - 1\\n                while a[j] > 0:\\n                    j -= 1\\n                ans2 = j\\n                return max(ans1, ans2)\\n        maxm = -1\\n        for i in subarrays:\\n            maxm = max(maxm, util(i))\\n        return maxm\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        start_neg = -1\\n        end_neg = -1\\n        start_idx = -1\\n        end_idx = -1\\n        acc_product = None\\n        ans = 0\\n        nums += [0]\\n        for idx, num in enumerate(nums):\\n            if num == 0:\\n                if start_idx == -1:\\n                    continue\\n                if acc_product > 0:\\n                    ans = max(ans, end_idx - start_idx + 1)                    \\n                else:\\n                    if start_neg - start_idx < end_idx - end_neg:\\n                        ans = max(ans, end_idx - start_neg -1 + 1)\\n                    else:\\n                        ans = max(ans, end_neg - start_idx -1 + 1)\\n                start_idx = -1\\n                end_idx = -1\\n                acc_product = None\\n                start_neg =-1\\n                end_neg=-1\\n            else:\\n                if start_idx<0:\\n                    start_idx=idx\\n                end_idx = idx\\n                if not acc_product:\\n                    acc_product =1\\n                acc_product *= num\\n                if num < 0:                 \\n                    end_neg = idx\\n                    if start_neg < 0:\\n                        start_neg =idx\\n          #  print(start_idx,end_idx,acc_product,start_neg,end_neg)\\n\\n        return ans                    \\n                \\n                        \\n\\n                        \\n                    \\n                    \\n                \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        def check(arr) -> int:\\n            if not arr:\\n                return 0\\n            pos = neg = -1\\n            pre_prod = 1\\n            res = 0\\n            for i,a in enumerate(arr):\\n                pre_prod *= a\\n                if pre_prod > 0:\\n                    if pos == -1:\\n                        pos = i\\n                    res = i+1\\n                else:\\n                    if neg == -1:\\n                        neg = i\\n                    res = max(res, i-neg)\\n            return res\\n        \\n        res = i = j = 0\\n        while j < len(nums):\\n            while j < len(nums) and nums[j] == 0:\\n                j += 1\\n            i = j\\n            while j < len(nums) and nums[j] != 0:\\n                j += 1\\n            # print(str(i)+'->'+str(j))\\n            res = max(res, check(nums[i:j]))\\n        return res\\n        \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        def check(arr) -> int:\\n            if not arr:\\n                return 0\\n            pos = neg = -1\\n            pre_prod = 1\\n            res = 0\\n            for i,a in enumerate(arr):\\n                pre_prod *= a\\n                if pre_prod > 0:\\n                    if pos == -1:\\n                        pos = i\\n                    res = i+1\\n                else:\\n                    if neg == -1:\\n                        neg = i\\n                    res = max(res, i-neg)\\n            return res\\n        \\n        res = i = j = 0\\n        while j < len(nums):\\n            while j < len(nums) and nums[j] == 0:\\n                j += 1\\n            i = j\\n            while j < len(nums) and nums[j] != 0:\\n                j += 1\\n            # print(str(i)+'->'+str(j))\\n            if j-i > res:\\n                res = max(res, check(nums[i:j]))\\n        return res\\n        \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        # [1,2,3,-1,-2,3,0,-3,-4,1,2]\\n        # [*,*,*,*,*,*,-,*,*,*,*]\\n        # [-1,1,1,2,3]\\n        # [-,*,*,*,*]\\n        \\n        cp=1\\n        fp=-1\\n        fn=None\\n        ans=0\\n        \\n        for i,n in enumerate(nums):\\n            cp=n*cp\\n            if cp<0:\\n                \\n                if fn is None:\\n                    fn=ln=i\\n                else:\\n                    ln=i\\n                ans=max(ln-fn,ans)\\n            elif cp>0:\\n                lp=i\\n            \\n                ans=max(lp-fp,ans)\\n            \\n            if n==0:\\n                cp=1\\n                fp=i\\n                fn=None\\n        \\n        return ans\\n                \\n                \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        prod = 1\\n        pos, neg = -1, None\\n        ans = 0\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                pos, neg = i, None\\n                prod = 1\\n            else:\\n                prod *= nums[i]\\n                if prod > 0:\\n                    ans = max(ans, i - pos)\\n                else:\\n                    if neg == None:\\n                        neg = i\\n                    ans = max(ans, i - neg)\\n        return ans\\n                        \\n\", \"from functools import reduce\\nclass Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        # assert self.split([1,2,3,0,4,5,6]) == [[1,2,3], [4,5,6]]\\n        # assert self.split([1,2,3,0,0,4,5,6]) == [[1,2,3], [4,5,6]]\\n        # assert self.split([1]) == [[1]]\\n        # assert self.split([1, 0]) == [[1]]\\n        # assert self.split([0, 1, 0]) == [[1]]\\n        # assert self.split([0,1,-2,-3,-4]) == [[1,-2,-3,-4]]\\n        splitted = sorted(self.split(nums), key=lambda x: len(x), reverse=True)\\n        # print(splitted)\\n        \\n    \\n        v = 0\\n        for sp in splitted:\\n            if len(sp) < v:\\n                break\\n            v = max(v, self.solve(sp))\\n        return v\\n            \\n            \\n        \\n    def split(self, nums):\\n        prev = None\\n        ans = []\\n        hit = False\\n        \\n        for i, n  in enumerate(nums):\\n            # print(i, n, prev)\\n            if n == 0 and prev is not None:\\n                ans.append(nums[prev:i])\\n                hit = True\\n                prev = None\\n            elif prev is None and n != 0:\\n                prev = i\\n        if not hit:\\n            return [[n for n in nums if n != 0]]\\n        if prev is not None and prev != len(nums) - 1:\\n            ans.append(nums[prev:len(nums)])\\n        # print(ans)\\n        return ans\\n        \\n        \\n    def solve(self, nums):\\n        # print('nums', nums)\\n        N = len(nums)\\n        \\n        prod = reduce(lambda x, y: x * y, nums, 1)\\n        if prod > 0:\\n            return N\\n        # print('prod', prod)\\n        \\n        for i in range(N // 2):\\n            if nums[i] < 0 or nums[N-1-i] < 0:\\n                return N - i - 1\\n        \\n        return 0\\n            \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        ans = 0\\n        fn = -1\\n        s = -1\\n        p  = 1\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                fn = -1\\n                s = -1\\n                p = 1\\n            else:\\n                if s == -1:\\n                    s = i\\n                p *= nums[i]\\n                if p < 0 and fn == -1:\\n                    fn = i\\n                    \\n                if p < 0:\\n                    ans = max(ans, (i - s + 1) - (fn - s + 1))\\n                elif p > 0:\\n                    ans = max(ans, i - s + 1)\\n        return ans\\n            \\n            \\n        \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        product = 1\\n        count = 0\\n        firstNegative = -1\\n        maxCount = -math.inf\\n        for i in range(len(nums)):\\n            if nums[i]>0:\\n                product*=nums[i]\\n                count+=1\\n            elif nums[i] < 0:\\n                product*=nums[i]\\n                count+=1\\n                if firstNegative == -1:\\n                    firstNegative = i\\n            \\n            if nums[i] == 0:\\n                count = 0\\n                product = 1\\n                if firstNegative!=-1 and i-firstNegative-1 > maxCount:\\n                    maxCount = i-firstNegative-1\\n                firstNegative = -1\\n\\n            if product > 0:\\n                maxCount = max(maxCount, count)\\n        \\n        if firstNegative!=-1 and i-firstNegative > maxCount:\\n            maxCount = i-firstNegative\\n        return maxCount\\n\", \"class Solution:\\n    def calc(self, neg: List[int], i:int) -> int:\\n        if len(neg) % 2 == 0:\\n            return i\\n        else:\\n            return max(i-neg[0]-1, neg[-1])\\n    \\n    def getMaxLen(self, nums: List[int]) -> int:\\n        ml = 0\\n        while True:\\n            neg = []\\n            for idx,i in enumerate(nums):\\n                if i == 0:\\n                    ml = max(self.calc(neg, idx), ml)\\n                    nums = nums[idx+1:]\\n                    break\\n                elif i < 0:\\n                    neg.append(idx)\\n            else:\\n                if nums != []:\\n                    ml = max(ml, self.calc(neg, idx+1))\\n                break\\n        return ml\\n                    \\n            \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        firstNegIdx = math.inf\\n        prevZeroIdx = -1\\n        curr = 1\\n        res = 0\\n        for i, n in enumerate(nums):\\n            if n==0:\\n                prevZeroIdx = i\\n                firstNegIdx = math.inf\\n                curr = 1\\n            else:\\n                curr *= n\\n                if curr>0:\\n                    res = max(res, i-prevZeroIdx)\\n                else:\\n                    firstNegIdx = min(firstNegIdx, i)\\n                    res = max(res, i-firstNegIdx)\\n                # print (i, curr, res)\\n        return res\\n        # if math.isfinite(res):\\n        #     return res\\n        # else:\\n        #     return 0\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        accLast = 1\\n        accCurr = 1\\n        lastpos = 0\\n        lastnegative = -1\\n        res = 0\\n        dic = {}\\n        for i in range(len(nums)):\\n            accCurr = accLast*nums[i]\\n            if accCurr == 0:\\n                lastpos = i+1\\n                lastnegative = -1\\n                accCurr = 1\\n            elif accCurr > 0:\\n                if lastpos != -1:\\n                    # print(i, lastpos)\\n                    res = max(res, i+1-lastpos)\\n            else:\\n                if lastnegative != -1:\\n                    # print('-', i, lastnegative)\\n                    res = max(res, i+1-lastnegative)\\n                else:\\n                    lastnegative = i+1\\n            accLast = accCurr\\n        # print(acc)\\n        return res\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        start_neg, end_neg, start_idx, end_idx = [-1,-1,-1,-1]\\n        \\n        acc_product = None\\n        ans = 0\\n        nums += [0]\\n        for idx, num in enumerate(nums):\\n            if num == 0:\\n                if start_idx == -1:\\n                    continue\\n                if acc_product > 0:\\n                    ans = max(ans, end_idx - start_idx + 1)                    \\n                else:\\n                    if start_neg - start_idx < end_idx - end_neg:\\n                        ans = max(ans, end_idx - start_neg -1 + 1)\\n                    else:\\n                        ans = max(ans, end_neg - start_idx -1 + 1)\\n                start_neg, end_neg, start_idx, end_idx = [-1,-1,-1,-1]\\n                acc_product = None\\n\\n            else:\\n                if start_idx<0:\\n                    start_idx=idx\\n                end_idx = idx\\n                if not acc_product:\\n                    acc_product =1\\n                acc_product *= num\\n                if num < 0:                 \\n                    end_neg = idx\\n                    if start_neg < 0:\\n                        start_neg =idx\\n          #  print(start_idx,end_idx,acc_product,start_neg,end_neg)\\n\\n        return ans                    \\n                \\n                        \\n\\n                        \\n                    \\n                    \\n                \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        fpos = -1\\n        fneg = -1\\n        best = 0\\n        cur = 1\\n        for i in range(len(nums)):\\n            n = nums[i]\\n            if n == 0:\\n                fpos = i\\n                fneg = -1\\n                cur = 1\\n            else:\\n                if fneg == -1 and n < 0:\\n                    fneg = i\\n                cur *= n\\n                if cur > 0:\\n                    best = max(best, i - fpos)\\n                elif cur < 0 and fneg != -1:\\n                    best = max(best, i - fneg)\\n        return best\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        max_len = 0\\n        start = -1\\n        is_pos = True\\n        for i in range(len(nums) + 1):\\n            \\n            if i == len(nums) or nums[i] == 0:\\n                if is_pos:\\n                    max_len = max(max_len, i - start - 1)\\n                else:\\n                    tmp = start + 1\\n                    while tmp < i:\\n                        if nums[tmp] < 0:\\n                            break\\n                        tmp += 1\\n                    max_len = max(max_len, i - tmp - 1)\\n                start = i\\n                is_pos = True\\n            else:\\n                if nums[i] < 0:\\n                    is_pos = not is_pos\\n                if is_pos:\\n                    max_len = max(max_len, i - start)\\n            # print(start, i, is_pos, max_len)\\n        return max_len\", \"class Solution:\\n    def _getMaxLen(self,nums: List[int]) -> int:\\n        lz = [i for (i,v) in enumerate(nums) if v < 0]\\n        ts = len(nums)\\n        if len(lz) % 2 == 0:\\n            return ts\\n        if len(lz) == 1:\\n            lz = [lz[0],lz[0]]\\n        ls = lz[-1]\\n        rs = ts-(lz[0]+1)\\n        \\n        if ls > rs:\\n            return ls\\n        return rs\\n        \\n    def getMaxLen(self, nums: List[int]) -> int:\\n        r = 0\\n        zero1 = 0\\n        try:\\n            zero1 = nums.index(0)\\n            r = self._getMaxLen(nums[:zero1])\\n            nums = nums[zero1+1:]\\n            while True:\\n                zero2 = nums.index(0)\\n                r2 = self._getMaxLen(nums[:zero2])\\n                if r2 > r:\\n                    r = r2\\n                zero1 = zero2\\n                nums = nums[zero1+1:]\\n        except ValueError:\\n            pass\\n        \\n        r2 = self._getMaxLen(nums)\\n        \\n        if r2 > r:\\n            r = r2\\n            \\n        return r\\n        \\n        \\n            \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n\\n        # index of last neg accumulated product\\n        last_neg_i = -1\\n        acc_product = 1\\n        bound = -1\\n        max_len = 0\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                acc_product = 1\\n                last_neg_i = -1\\n                bound = i\\n                continue\\n            \\n            acc_product = acc_product * nums[i]\\n            if last_neg_i == -1 and acc_product < 0:\\n                last_neg_i = i\\n            \\n            if acc_product < 0:\\n                max_len = max(max_len, i - last_neg_i)\\n            else:\\n                max_len = max(max_len, i - bound)\\n        \\n        return max_len\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        '''\\n        \\n        new array = [(st, curr_prod_from_st)]\\n        \\n        \\n        if curr_prod_from_st > 0:\\n            max_sub = max(max_sub, ed - st + 1) \\n        elif:\\n            max_sub = max(max_sub, ed - idx_of_last_time_curr_prod_was_neg)\\n        \\n        \\n        '''\\n        \\n        \\n        max_len = 0\\n        last_idx = float('inf')\\n        \\n        curr_st, curr_prod = 0, 1\\n        for ed in range(len(nums)):\\n            if nums[ed] == 0:\\n                curr_prod = 1\\n                curr_st = ed + 1\\n                last_idx = float('inf')\\n                continue\\n            else:\\n                curr_prod *= nums[ed]\\n        \\n            if curr_prod > 0:\\n                max_len = max(max_len, ed - curr_st + 1)\\n            elif curr_prod < 0:\\n                max_len = max(max_len, ed - last_idx)\\n                if last_idx == float('inf'):\\n                    last_idx = ed\\n        \\n        return max_len\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        last={1:-1}\\n        pro=1\\n        ans=0\\n        for i,c in enumerate(nums):\\n            pro=c*pro\\n            \\n            if pro>0:\\n                ans=max(i-last[1],ans)\\n                \\n            elif pro<0:\\n                if -1 in last:\\n                    ans=max(ans,i-last[-1])\\n                else:\\n                    last[-1]=i\\n            elif pro==0:\\n                pro=1\\n                last={}\\n                last[1]=i\\n          \\n        return ans\\n                \\n            \\n            \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        first_neg = None\\n        last_neg = None\\n        first_pos = None\\n        cum_prod = 1\\n        max_len = 0\\n        last_zero_idx = 0\\n        for idx, val in enumerate(nums):\\n            if val == 0:\\n                first_neg = None\\n                last_neg = None\\n                first_pos = None\\n                cum_prod = 1\\n                last_zero_idx = idx + 1\\n            else:\\n                cum_prod *= val\\n                if cum_prod > 0:\\n                    max_len = max(max_len, idx - last_zero_idx + 1)\\n                else:\\n                    if first_neg is None:\\n                        first_neg = idx\\n                    last_neg = idx\\n                    max_len = max(max_len, last_neg - first_neg)\\n        return max_len\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        i = 0\\n        negatives = [-1, -1]\\n        p = 1\\n        ans = 0\\n        for j, n in enumerate(nums):\\n            if not n:\\n                p = 1\\n                i = j + 1\\n                negatives = [-1, -1]\\n            else:\\n                p *= n\\n                if n < 0:\\n                    if negatives[0] < 0:\\n                        negatives[0] = j\\n                    negatives[1] = j\\n                if p > 0:\\n                    ans = max(ans, j - i + 1)\\n                else:\\n                    ans = max(ans, negatives[1] - i, j - negatives[0])\\n        return ans             \\n                        \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        longest = 0\\n        neg = len(nums)\\n        pos = -1\\n        \\n        prod = 1\\n        for i, n in enumerate(nums):\\n            if not n:\\n                neg = len(nums) \\n                pos = i\\n                prod = 1\\n            else:\\n                prod *= n\\n                \\n                if prod < 0:\\n                    neg = min(neg, i)\\n                    longest = max(longest, i - neg)\\n                else:\\n                    longest = max(longest, i - pos)\\n            \\n        return longest\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n\\n        def helper(nums):\\n            if len(nums) == 0:\\n                return 0\\n            pre_prod = 1\\n            N = len(nums)\\n            first_neg = -1\\n            res = 0\\n            for i in range(N):\\n                pre_prod *= nums[i]\\n                if pre_prod > 0:\\n                    res = max(res, i + 1) \\n                elif first_neg == -1 and pre_prod < 0:\\n                    first_neg = i\\n                elif pre_prod < 0:\\n                    res = max(res, i - first_neg) \\n            return res\\n\\n        num = []\\n        res = 0\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                res = max(res, helper(num))\\n                num = []\\n            else:\\n                num.append(nums[i])      \\n        res = max(res, helper(num))\\n            \\n        return res\", \"class Solution:\\n    def getMaxLen(self, A: List[int]) -> int:\\n        \\n        n = len(A)     \\n        lastZ = -1\\n        lastN = n\\n        cur = 1\\n        res = 0\\n        \\n        for i, a in enumerate(A):\\n            cur *= a\\n            \\n            if cur == 0:\\n                lastZ = i\\n                lastN = n\\n                cur = 1\\n            elif cur > 0:\\n                res = max(res, i - lastZ)\\n            else:\\n                lastN = min(lastN, i)\\n                res = max(res, i - lastN)\\n        \\n        return res\", \"class Solution:\\n  def getMaxLen(self, nums: List[int]) -> int:\\n    max_len, start, product, first_minus_index = 0, 0, 1, -1\\n    for i, n in enumerate(nums):\\n      if n == 0:\\n        start, product, first_minus_index = i + 1, 1, -1\\n      else:\\n        if n < 0 and first_minus_index == -1:\\n          first_minus_index = i\\n        product *= n\\n        if n > 0:\\n          max_len = max(max_len, 1)\\n        if product > 0:\\n          max_len = max(max_len, i - start + 1)\\n        if product < 0 and first_minus_index != -1:\\n          max_len = max(max_len, i-first_minus_index)\\n    return max_len\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        s = 0\\n        fn = -1\\n        ln = -1\\n        cn = 0\\n        res = 0\\n        \\n        for i, v in enumerate(nums):\\n            if v == 0:\\n                end = i - 1\\n                if cn % 2 == 0:\\n                    res = max(res, end - s + 1)\\n                else:\\n                    res = max(res, end - fn, ln - s)\\n                s = i + 1\\n                fn = -1\\n                ln = -1\\n                cn = 0\\n            elif v < 0:\\n                if fn == -1:\\n                    fn = ln = i\\n                else:\\n                    ln = i\\n                cn += 1\\n        end = len(nums) - 1\\n        if cn % 2 == 0:\\n            res = max(res, end - s + 1)\\n        else:\\n            res = max(res, end - fn, ln - s)\\n        return res\", \"class Solution:\\n    def getMaxLen(self, a: List[int]) -> int:\\n        n = len(a)\\n        ans = 0\\n        neg = -1 #position of last negative element\\n        zero = -1 #position of last zero\\n        cnt = 0 #number of negatives seen so far\\n        for i, x in enumerate(a):\\n            if x == 0:\\n                neg = zero = i\\n                cnt = 0\\n            elif x < 0:\\n                if neg == zero:\\n                    neg = i\\n                cnt += 1 \\n            if cnt % 2 == 0:\\n                ans = max(ans, i - zero)\\n            else:\\n                ans = max(ans, i - neg)\\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        left_pos = 0\\n        left_neg = sys.maxsize\\n        ans = 0\\n        cp = 1\\n        for i, num in enumerate(nums):\\n            if num == 0:\\n                cp = 1\\n                left_pos = i + 1\\n                left_neg = sys.maxsize\\n            else:\\n                cp *= num\\n                # print(\\\\\\\"haha\\\\\\\", cp)\\n                if cp > 0:\\n                    ans = max(ans, i - left_pos + 1)\\n                    # print(\\\\\\\"hehe\\\\\\\", ans, num, cp)\\n                else:\\n                    ans = max(ans, i - left_neg)\\n                    # print(\\\\\\\"hehe\\\\\\\", ans, num, cp, left_neg)\\n                \\n                if cp < 0 and left_neg == sys.maxsize:\\n                    left_neg = i\\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        a = [None] + nums\\n        n = len(a)\\n        pos = [0] * n\\n        neg = [0] * n\\n        for i in range(1, n):\\n            if a[i] > 0:\\n                pos[i] = pos[i - 1] + 1\\n                if neg[i - 1]:\\n                    neg[i] = neg[i - 1] + 1 # we can extend neg iff it exists\\n            elif a[i] < 0:\\n                if neg[i - 1]:\\n                    pos[i] = neg[i - 1] + 1 # same idea as above\\n                neg[i] = pos[i - 1] + 1\\n            else: # a[i] == 0\\n                pass\\n        return max(pos)\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n            n = len(nums)\\n            pos, neg = [0] * n, [0] * n\\n            if nums[0] > 0: pos[0] = 1\\n            if nums[0] < 0: neg[0] = 1\\n            ans = pos[0]\\n            for i in range(1, n):\\n                if nums[i] > 0:\\n                    pos[i] = 1 + pos[i - 1]\\n                    neg[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\\n                elif nums[i] < 0:\\n                    pos[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\\n                    neg[i] = 1 + pos[i - 1]\\n                ans = max(ans, pos[i])\\n            return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        pos, neg = [0] * n, [0] * n\\n        if nums[0] > 0: pos[0] = 1\\n        if nums[0] < 0: neg[0] = 1\\n        ans = pos[0]\\n        for i in range(1, n):\\n            if nums[i] > 0:\\n                pos[i] = 1 + pos[i - 1]\\n                neg[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\\n            elif nums[i] < 0:\\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\\n                neg[i] = 1 + pos[i - 1]\\n            ans = max(ans, pos[i])\\n        return ans \", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        f = [0, 0]\\n        ans = 0\\n        for i in range(len(nums)):\\n            if nums[i] < 0:\\n                f = [f[1] + 1 if f[1] > 0 else 0, f[0] + 1]\\n            elif nums[i] > 0:\\n                f = [f[0] + 1, f[1] + 1 if f[1] > 0 else 0]\\n            else:\\n                f = [0, 0]\\n            ans = max(ans, f[0])\\n        #print(f)\\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        ans = 0\\n        pos, neg = 0, 0\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                pos = pos + 1\\n                neg = neg + 1 if neg > 0 else 0\\n            elif nums[i] < 0:\\n                pos, neg = neg+1 if neg > 0 else 0, pos+1\\n            else:\\n                pos, neg = 0, 0\\n            ans = max(ans, pos)\\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        pos = [0 for _ in range(n)]\\n        neg = [0 for _ in range(n)]\\n        if nums[0] > 0:\\n            pos[0] = 1 \\n        if nums[0] < 0:\\n            neg[0] = 1 \\n        res = pos[0]\\n        for i in range(1, n):\\n            if nums[i] > 0:\\n                pos[i] = pos[i - 1] + 1\\n                neg[i] = neg[i - 1] + 1 if neg[i - 1] > 0 else 0\\n            elif nums[i] < 0:\\n                pos[i] = neg[i - 1] + 1 if neg[i - 1] > 0 else 0\\n                neg[i] = pos[i - 1] + 1\\n            res = max(res, pos[i])\\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        # \\u7c7b\\u4f3c\\u4e8e\\u524d\\u7f00\\u548c \\u770b\\u533a\\u95f4\\n        # sums \\u8bb0\\u5f55\\u4ece\\u7b2c\\u4e00\\u4e2a\\u4e0d\\u662f0 \\u5f00\\u59cb \\u5230\\u5f53\\u524dindex\\u7684\\u6b63\\u8d1f\\u60c5\\u51b5\\n        # \\u5982\\u679csums \\u662f\\u8d1f\\u7684\\u8bdd\\uff0c\\u770b\\u4e4b\\u524d\\u6709\\u6ca1\\u6709negative \\u7684index\\n        # \\u5982\\u679c\\u6709\\uff0c\\u51cf\\u53bb\\u4e0a\\u4e00\\u4e2anegative \\u7684index\\uff0c \\u4e0a\\u4e00\\u4e2anegative index \\u5230 \\u5f53\\u524dindex \\u6574\\u4e2a\\u533a\\u95f4\\u5c31\\u53d8\\u6210\\u6b63\\u7684\\u4e86\\n        # \\u5982\\u679c\\u6ca1\\u6709\\uff0c\\u8bb0\\u5f55\\u5f53\\u524d\\u7684index \\u66f4\\u65b0negative\\n        # \\u5982\\u679csums \\u662f\\u6b63\\u7684\\u8bdd\\uff0c \\u76f4\\u63a5\\u66f4\\u65b0\\uff0c\\u5f53\\u524didnex \\u51cf\\u53bb \\u4e0a\\u4e00\\u4e2a0 \\u7684\\u4f4d\\u7f6e\\uff0c\\u6216\\u8005 \\u521d\\u59cb\\u5316 -1\\n        # \\u5982\\u679c\\u9047\\u52300\\uff0c\\u5168\\u90e8\\u521d\\u59cb\\u5316 \\u91cd\\u65b0\\u8ba1\\u7b97\\n        positive_index = - 1\\n        negative_index = - 1\\n        sums = 1\\n        result = 0\\n        for i in range(len(nums)):\\n            if sums * nums[i] < 0:\\n                sums = -1\\n            elif sums * nums[i] > 0:\\n                sums = 1\\n            \\n            if nums[i] == 0:\\n                positive_index = i\\n                negative_index = -1\\n                sums = 1\\n            elif sums > 0:\\n                result = max(result, i - positive_index)\\n            else:\\n                if negative_index == -1:\\n                    negative_index = i\\n                else:\\n                    result = max(result, i - negative_index)\\n                    print(result)\\n        return result\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        N =len(nums)\\n        ans = 0\\n        i = j = 0\\n        while i<N:\\n            if nums[i] == 0:\\n                i+= 1\\n                continue\\n            j = i\\n            while j < N and nums[j]:\\n                j+= 1\\n            negs = 0\\n            firstneg = lastneg = None\\n            for k in range(i,j ):\\n                if nums[k] <0:\\n                    negs += 1\\n                    if firstneg is None:\\n                        firstneg = k\\n                    lastneg = k\\n            if negs % 2 ==0:\\n                ans = max(ans, j-i)\\n            else:\\n                ans = max(ans, firstneg -i, j-i-1-(firstneg-i))\\n                ans = max(ans, lastneg -i, j-i-1-(lastneg-i))\\n            i = j \\n        return ans\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        result = 0\\n        \\n        for r in [list(range(0, len(nums))), list(range(len(nums)-1, -1, -1))]:\\n            cur_len = 0\\n            cur_sign = 1\\n            for i in r:\\n                if nums[i] > 0:\\n                    cur_len += 1\\n                    result = max(result, cur_sign * cur_len)\\n                elif nums[i] == 0:\\n                    cur_len = 0\\n                    cur_sign = 1\\n                else: # < 0\\n                    cur_len += 1\\n                    cur_sign = -cur_sign\\n                    result = max(result, cur_sign * cur_len)\\n\\n        return result\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        first_neg = -1\\n        last_neg = -1\\n        pos = True\\n        start = 0\\n        best = 0\\n        n = len(nums)\\n        for i, num in enumerate(nums):\\n            if num == 0:\\n                if pos:\\n                    best = max(best, i - start)\\n                else:\\n                    if first_neg >= start:\\n                        best = max(best, i - first_neg - 1, last_neg - start)\\n                start = i + 1\\n                pos = True\\n            elif num < 0:\\n                last_neg = i\\n                if first_neg < start:\\n                    first_neg = i\\n                pos = not pos\\n        if pos:\\n            best = max(best, n - start)\\n        else:\\n            if first_neg >= start:\\n                best = max(best, n - first_neg - 1, last_neg - start)\\n        return best\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        pos = [0] * n\\n        neg = [0] * n\\n        \\n        if nums[0] > 0:\\n            pos[0] = 1\\n            \\n        if nums[0] < 0:\\n            neg[0] = 1\\n        \\n        ans = pos[0]\\n        \\n        for i in range(1,len(nums)):\\n            if nums[i] > 0:\\n                neg[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\\n                pos[i] = 1 + pos[i - 1]\\n                 \\n            if nums[i] < 0:\\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\\n                neg[i] = 1 + pos[i - 1]\\n                \\n            ans = max(ans,pos[i])\\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        result = 0\\n        cur_len = 0\\n        cur_sign = 1\\n        \\n        for i in range(0, len(nums)):\\n            if nums[i] > 0:\\n                cur_len += 1\\n                result = max(result, cur_sign * cur_len)\\n            elif nums[i] == 0:\\n                cur_len = 0\\n                cur_sign = 1\\n            else: # < 0\\n                cur_len += 1\\n                cur_sign = -cur_sign\\n                result = max(result, cur_sign * cur_len)\\n\\n        cur_len = 0\\n        cur_sign = 1\\n        for i in range(len(nums)-1, -1, -1):\\n            if nums[i] > 0:\\n                cur_len += 1\\n                result = max(result, cur_sign * cur_len)\\n            elif nums[i] == 0:\\n                cur_len = 0\\n                cur_sign = 1\\n            else: # < 0\\n                cur_len += 1\\n                cur_sign = -cur_sign\\n                result = max(result, cur_sign * cur_len)\\n\\n        return result\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        #------------------------------\\n        def helper(array):\\n            if len(array)==0:\\n                return 0\\n            \\n            result=0\\n            pos=0\\n            neg=0\\n            \\n            for n in array:\\n                if n>0:\\n                    pos, neg = pos+1, neg+1 if neg>0 else 0\\n                if n<0:\\n                    pos, neg = neg+1 if neg>0 else 0, pos+1 \\n                \\n                result=max(result,pos)\\n            return result\\n        #------------------------------\\n    \\n        arrays=[]\\n        subarray=[]\\n       \\n        for n in nums:\\n            if n==0:\\n                idx=0\\n                arrays.append(subarray)\\n                subarray=[]\\n                continue\\n            subarray.append(n)\\n        if len(subarray)>0:\\n            arrays.append(subarray)\\n            \\n        maxlen=0\\n        for i,array in enumerate(arrays):\\n            maxlen=max(maxlen,helper(array))\\n        \\n        return maxlen\\n        \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        start = 0\\n        end = 0\\n        count_negative = 0\\n        max_len = 0\\n        while end < len(nums):\\n            if nums[end] == 0:\\n                if count_negative % 2 != 0:\\n                    while nums[start] > 0:\\n                        start += 1\\n                    max_len = max(max_len, end - start - 1)\\n                start = end = end + 1\\n                count_negative = 0\\n            else:\\n                if nums[end] < 0:\\n                    count_negative += 1\\n                if count_negative % 2 == 0:\\n                    max_len = max(max_len, end - start + 1)\\n                if end == len(nums)-1 and count_negative % 2 == 1:\\n                    while nums[start] > 0:\\n                        start += 1\\n                    max_len = max(max_len, end - start)\\n                end += 1                  \\n        return max_len\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        count_of_negative = 0\\n        start = 0\\n        max_length = 0 \\n        \\n        def evaluate_sub_array(begin, end, count_of_negative):\\n            if count_of_negative % 2 == 0:\\n                return end-begin+1\\n            else:\\n                first_negative = len(nums)\\n                last_negative = -1\\n                for i in range(begin,end+1):\\n                    if nums[i] < 0:\\n                        if first_negative == len(nums):\\n                            first_negative = i\\n                            last_negative = i\\n                        else:\\n                            last_negative = i\\n            return max(end - first_negative, last_negative - begin)\\n            \\n        start = 0\\n        array = []\\n        count_of_negative = 0\\n        for index in range(len(nums)):\\n            if nums[index] <0:\\n                count_of_negative+=1\\n            if nums[index] == 0:\\n                array.append(evaluate_sub_array(start, index-1, count_of_negative))\\n                count_of_negative = 0\\n                start = index+1\\n        array.append(evaluate_sub_array(start, len(nums)-1, count_of_negative))\\n        return max(array)\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        pos, neg = 0, 0\\n        if nums[0] > 0: pos = 1\\n        if nums[0] < 0: neg = 1\\n        ans = pos\\n        for i in range(1, n):\\n            if nums[i] > 0:\\n                pos = 1 + pos\\n                neg = 1 + neg if neg > 0 else 0\\n            elif nums[i] < 0:\\n                pos, neg = 1 + neg if neg > 0 else 0, 1 + pos\\n            else:\\n                pos, neg = 0, 0\\n            ans = max(ans, pos)\\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        dic={1:-1}\\n        temp=1\\n        res=0\\n        for i in range(len(nums)):\\n            if nums[i]==0:\\n                dic={1:i}\\n                temp=1\\n                continue\\n            if nums[i]<0:\\n                temp=-temp\\n            if not dic.get(temp) is None:\\n                res=max(res,i-dic[temp])\\n            else:\\n                dic[temp]=i\\n                \\n            \\n            \\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        #reduce to simpler problem:\\n        # if all elems are positive, then entire array is sol as long as thy're >= 1\\n        \\n        # an even number of negative vals still gives a pos result\\n        \\n        # insight: we don't care what the values actually are , just whether they're pos, 0 , or neg\\n        # insight: we can't include a zero, since the prod becomes 0, and 0 isn't +ve\\n        \\n        # idea: start with first char, if you hit zero, stop, if not, keep going, and track latest position of even number of negatives.\\n        \\n        # also start at other negative vals, and positive vals after zero.\\n        \\n#         cur_max = 0\\n        \\n#         last_even_neg = -1\\n        \\n#         for i, n in enumerate(nums):\\n#             if n == 0:\\n#                 if last_even_neg >\\n#             if i == 0 or (i and nums[i-1] == 0)\\n\\n        # first, split the array into segment to get rid of zeros.\\n        \\n        def max_len(nums):\\n            negs = [i for i, x in enumerate(nums) if x < 0]\\n            n = len(nums)\\n            \\n            if len(negs) % 2 == 0:  # even num of odd nums, whose product is pos\\n                return n\\n            else:  # at least one neg val\\n                return max(n - (negs[0] + 1), negs[-1])  # exclude either left or right most neg val\\n            \\n        \\n        from copy import deepcopy\\n        chunks = []\\n        \\n        chunk = []\\n        for x in nums:\\n            if x == 0 and chunk:  # see a zero, add a new segment\\n                chunks.append(deepcopy(chunk))\\n                chunk.clear()\\n            elif x:\\n                chunk.append(x)\\n        chunks.append(chunk)\\n        print(chunks)\\n                \\n        return max(map(max_len, chunks))\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        m=0\\n        neg=0\\n        pos=0\\n        positiveBeforeFirstNeg=0\\n        pos2=0\\n        for i in nums:\\n            if(i==0):\\n                if(neg>0 and neg%2!=0):\\n                    neg-=1\\n                if(positiveBeforeFirstNeg<pos2 and neg>2):\\n                    pos-=positiveBeforeFirstNeg\\n                    pos+=pos2\\n                m=max(max(pos,pos2)+neg,m)\\n                neg,pos,pos2=0,0,0\\n            elif(i<0):\\n                if(neg==0):\\n                    positiveBeforeFirstNeg=pos\\n                neg+=1\\n                if(neg%2==0):\\n                    pos+=pos2\\n                    pos2=0\\n            else:\\n                if(neg%2!=0):\\n                    pos2+=1\\n                else:\\n                    pos+=1\\n        if(positiveBeforeFirstNeg<pos2 and neg>2):\\n            pos-=positiveBeforeFirstNeg\\n            pos+=pos2\\n        if(neg>0 and neg%2!=0):\\n            neg-=1\\n        m=max(max(pos,pos2)+neg,m)     \\n        return m\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        # encouter 0 reset it as 0\\n        # how many -1 in the left, if is even, update the  longest length O(n) cur_poistion - 0_position\\n        \\n        # [1,-2,-3,4] => [0, 1, 2, 2] => 4\\n        # [0,1,-2,-3,-4] => [0, 0, 1, 2, 3] => 3\\n        # [-1,-2,-3,0,1] => [1, 2, 3, 0, 0] => 2\\n        # [-1,2] => [1, 1] => 1 (consider if itself > 0, 1)\\n        # [1,2,3,5,-6,4,0,10] => [0, 0, 0, 0, 1, 1, 0, 1] => 4\\n        # [0, 0 ,0 ,0] => [0, 0, 0, 0] => 0 (consider if itself == 0, 0)\\n        \\n        carry_len = 0\\n        left_neg = 0\\n        max_len = 0\\n        str_ptr = -1\\n        for idx, n in enumerate(nums):\\n            if n < 0 :left_neg += 1 \\n            carry_len += 1\\n            if n == 0: \\n                max_len = max(max_len, 0)\\n                carry_len = 0\\n                left_neg = 0\\n            else:\\n                max_len = max(max_len, 1 if n > 0 else 0, idx - str_ptr -1, carry_len if left_neg % 2 == 0 else 0)\\n            if left_neg == 0: \\n                str_ptr = idx\\n\\n        return max_len\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        start, curnegcnt, res, fnegpos, lnegpos = 0, 0, 0, 0, 0\\n        flag = True\\n        i, j = 0, len(nums)\\n        while i < j:\\n            if nums[i] == 0:\\n                flag = True\\n                i += 1\\n                start = i\\n                curnegcnt = 0\\n                continue\\n            if nums[i] < 0:\\n                if flag:\\n                    flag = False\\n                    fnegpos = i\\n                lnegpos = i\\n                curnegcnt += 1\\n            if curnegcnt == 0 or curnegcnt % 2 == 0:\\n                res = max(res, (i - start) + 1)\\n            else:\\n\\n                res = max(res, (lnegpos ) - start, i - (fnegpos ))\\n            i += 1\\n        return res\\n                \\n                \\n    \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        #\\u6bcf\\u6b21maintain\\uff0c\\u5230\\u4e4b\\u524d\\u4e3a\\u6b62\\uff0c\\u6b63\\u7684\\u6709\\u591a\\u957f\\uff0c\\u8d1f\\u7684\\u6709\\u591a\\u957f\\uff0c\\u7136\\u540emaintain max len\\n        pos,neg = 0,0\\n        asr = 0\\n        for num in nums:\\n            if num == 0:\\n                pos,neg = 0,0\\n            elif num > 0:\\n                pos+=1\\n                neg = neg + 1 if neg else 0\\n            else:\\n                n_pos = neg + 1 if neg else 0\\n                n_neg = pos + 1 if pos else 1\\n                pos,neg = n_pos,n_neg\\n            asr = max(asr,pos)\\n            #print(pos,neg)\\n        return asr\", \"# 1567. Maximum Length of Subarray With Positive Product\\n\\ndef sgn (n):\\n    if n > 0:\\n        return +1\\n    elif n < 0:\\n        return -1\\n    else:\\n        return 0\\n\\ndef split_0 (arr):\\n    arr_buffer = []\\n    for elem in arr:\\n        if elem != 0:\\n            arr_buffer.append (elem)\\n        else:\\n            yield arr_buffer\\n            arr_buffer = []\\n    assert len (arr_buffer) == 0\\n\\ndef partial_products (arr):\\n    prod = 1\\n    yield prod\\n    for elem in arr:\\n        prod *= elem\\n        yield prod\\n\\ndef get_subarr_max_len (arr):\\n    # zero-free\\n    first_index = {}\\n    max_len = 0\\n    for (i, prod) in enumerate (partial_products (arr)):\\n        first_index.setdefault (prod, i)\\n        max_len = max (max_len, i - first_index[prod])\\n    return max_len\\n\\ndef get_max_len (arr):\\n    arr = [sgn (x) for x in arr]\\n    arr.append (0)\\n\\n    if len (arr) == 0:\\n        return 0\\n\\n    return max (get_subarr_max_len (subarr) for subarr in split_0 (arr))\\n\\nclass Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        return get_max_len(nums)\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        f = [[0, 0] for _ in range(len(nums) + 1)]\\n        for i in range(len(nums)):\\n            if nums[i] < 0:\\n                f[i+1] = [f[i][1] + 1 if f[i][1] > 0 else 0, f[i][0] + 1]\\n            elif nums[i] > 0:\\n                f[i+1] = [f[i][0] + 1, f[i][1] + 1 if f[i][1] > 0 else 0]\\n        #print(f)\\n        return max(x[0] for x in f)\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp_pos = [0] * (n+1)\\n        dp_neg = [0] * (n+1)\\n\\n        result = 0\\n        for i in range(1, n+1):\\n            if nums[i-1] == 0:\\n                dp_pos[i] = 0\\n                dp_neg[i] = 0\\n            elif nums[i-1] > 0:\\n                dp_pos[i] = 1 + dp_pos[i-1]\\n\\n                if dp_neg[i-1] > 0:\\n                    dp_neg[i] = 1 + dp_neg[i-1]\\n                else:\\n                    dp_neg[i] = 0\\n            else:\\n                if dp_neg[i-1] > 0:\\n                    dp_pos[i] = 1 + dp_neg[i-1]\\n                else:\\n                    dp_pos[i] = 0\\n\\n                dp_neg[i] = 1 + dp_pos[i-1]\\n\\n            result = max(result, dp_pos[i])\\n\\n        return result\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if not n:\\n            return -1\\n        pos = 0\\n        neg = 0\\n        answer = 0\\n        for num in nums:\\n            if num == 0:\\n                answer = max(answer, pos)\\n                pos = neg = 0\\n                continue\\n            if num > 0:\\n                pos += 1\\n                neg += 1 if neg else 0\\n            else:\\n                orig_pos = pos\\n                pos = neg+1 if neg else 0\\n                neg = (orig_pos + 1) if orig_pos else 1\\n            answer = max(answer, pos)\\n        return answer\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        dct = {0:-1}\\n        \\n        count = 0\\n        res = 0\\n        for i,num in enumerate(nums):\\n            if num <0: \\n                count +=1\\n                # print(num,count,i)\\n                dct[count]=i\\n                \\n            elif num == 0:\\n                dct = {0:i}\\n                count = 0\\n            if count %2 == 0:\\n                res = max(res,i-dct[0])\\n                \\n            else:\\n                t1 = i-dct[1]\\n                t2= 0\\n                if num < 0:\\n                    t2 = i-1-dct[0]\\n                res = max(res,max(t1,t2))\\n            # print(dct,res)\\n        return res\\n            \\n            \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        if nums[-1] != 0:\\n            nums.append(0)\\n        n = len(nums)\\n        first_0 = -1\\n        last_0 = -1\\n        cnt_neg = 0\\n        first_neg = -1\\n        last_neg = -1\\n        res = 0\\n        # print(nums)\\n        for i, e in enumerate(nums):\\n            if e < 0:\\n                cnt_neg += 1\\n                if first_neg == -1:\\n                    first_neg = i\\n                last_neg = i\\n            elif e == 0:\\n                # print(cnt_neg)\\n                last_0 = i\\n                if cnt_neg % 2 == 0:\\n                    res = max(res, last_0-first_0-1)\\n                else:\\n                    res = max(res, last_neg-first_0-1, last_0-first_neg-1)\\n                    # print((first_0, last_0, first_neg, last_neg, res))\\n                cnt_neg = 0\\n                first_0 = last_0\\n                first_neg = -1\\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        a = 0\\n        p = 0\\n        n = 0\\n        r = -1\\n\\n        for x in nums:\\n            p, n, r = (\\n                (x < 0) * p + (x > 0) * (p + 1),\\n                (x < 0) * (n + 1) + (x > 0) * n,\\n                (x < 0) * (r < 0) * p + (x < 0) * (r >= 0) * r + (x > 0) * r - (x == 0)\\n            )\\n            \\n            a = max(a, p + n - (n % 2) * (r + 1))\\n                   \\n        return a\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        # get the next zero or end\\n        # get the last idx of negative before zero and end\\n        # get how many negative numbers\\n        \\n        next_zero_or_end=[0]*(len(nums)+1)\\n        next_idx=len(nums)\\n        last_negative=[0]*(len(nums)+1)\\n        negative_idx=None\\n        state=0\\n        for i in range(len(nums)-1,-1,-1):\\n            num=nums[i]\\n            if num==0:\\n                next_idx=i\\n                state=0\\n            next_zero_or_end[i]=next_idx\\n            if state==0 and num<0:\\n                negative_idx=i\\n                state=1\\n            last_negative[i]=negative_idx\\n                \\n        ne_nums=[0] * (len(nums)+1)\\n        for i,num in enumerate(nums):\\n            ne_nums[i]=ne_nums[i-1]+(1 if num<0 else 0)\\n        res=0\\n        for i in range(len(nums)):\\n            if nums[i]==0:\\n                continue\\n            j=next_zero_or_end[i]-1\\n            if (ne_nums[j]-ne_nums[i-1])%2==0:\\n                res=max(res,(j-i+1))\\n            else:\\n                j=last_negative[i]-1\\n                res=max(res,(j-i+1))\\n        return res\", \"\\nclass Node:\\n    def __init__(self, size):\\n        self.size = size\\n        self.left = None\\n        self.right = None\\n        \\n\\n\\nclass Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        nodes = []\\n        roots = []\\n        \\n        curr_size = 0\\n        prev = None\\n        \\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                curr_size += 1\\n            else:\\n                node = Node(curr_size)\\n                nodes.append(node)\\n                if prev:\\n                    prev.right = node\\n                    node.left = prev\\n                else:\\n                    roots.append(node)\\n                if nums[i] != 0:\\n                    prev = node\\n                else:\\n                    prev = None\\n                curr_size = 0\\n                    \\n        node = Node(curr_size)\\n        if prev:\\n            prev.right = node\\n            node.left = prev\\n        else:\\n            roots.append(node)\\n                \\n        # t_node = roots[0]\\n        # while t_node:\\n        #     print(t_node.size)\\n        #     t_node = t_node.right\\n        \\n        longest = 0\\n        for node in roots:\\n            first_count = node.size\\n            second_count = 0 if not node.right else node.right.size\\n            \\n            curr_node = node.right.right if node.right else None\\n            \\n            ind = 0\\n            \\n            while curr_node:\\n                if ind == 0:\\n                    first_count += curr_node.size + curr_node.left.size + 2\\n                    ind = 1\\n                else:\\n                    second_count += curr_node.size + curr_node.left.size + 2\\n                    ind = 0\\n                curr_node = curr_node.right\\n                \\n            # print(first_count)\\n            # print(second_count)\\n            longest = max(longest, first_count, second_count)\\n            \\n        return longest\\n                    \\n            \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        pos = [0 for _ in range(len(nums))] # pos[i] is number of consecutive numbers with pos product up to i\\n        neg = [0 for _ in range(len(nums))] # neg[i] is number of consecutive numbers with neg product up to i\\n        if nums[0] > 0 :\\n            pos[0] = 1\\n        elif nums[0] < 0:\\n            neg[0] = 1\\n            \\n        out = pos[0]\\n        for i in range(1, len(nums)):\\n            if nums[i] > 0:\\n                pos[i] = 1 + pos[i - 1] \\n                neg[i] = 1 + neg[i - 1] if neg[i - 1] else 0\\n            elif nums[i] < 0:\\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] else 0\\n                neg[i] = 1 + pos[i - 1]\\n            out = max(out, pos[i])\\n        \\n        return out\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        def getMaxLenNonzero(arr):\\n            neg = []\\n            for i, num in enumerate(arr):\\n                if num < 0:\\n                    neg.append(i)\\n            if len(neg) % 2 == 0:\\n                return len(arr)\\n            if len(neg) == 1:\\n                return max(neg[0], len(arr) - neg[-1] - 1)\\n            return max(neg[-1], len(arr) - neg[0] - 1)\\n    \\n        currArr = []\\n        ans = 0\\n        for num in nums:\\n            if num != 0:\\n                currArr.append(num)\\n            else:\\n                ans = max(ans, getMaxLenNonzero(currArr))\\n                currArr = []\\n        if currArr:\\n            ans = max(ans, getMaxLenNonzero(currArr))\\n\\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        dp = [0] * len(nums)\\n        for i in range(len(dp)):\\n            dp[i] = [0,0]\\n        \\n        ans = 0\\n        for i, v in enumerate(nums):\\n            if v > 0:\\n                dp[i][0] = 1 + dp[i-1][0]\\n                if dp[i-1][1]: dp[i][1] = 1 + dp[i-1][1]\\n            if v < 0:\\n                if dp[i-1][1]:\\n                    dp[i][0] = 1 + dp[i-1][1]\\n                dp[i][1] = 1 + dp[i-1][0]\\n            ans = max(ans, dp[i][0])\\n        return ans\\n                    \\n                \\n                \\n                \\n            \\n                \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        ans = pos = neg = 0\\n        for x in nums: \\n            if x > 0: pos, neg = 1 + pos, 1 + neg if neg else 0\\n            elif x < 0: pos, neg = 1 + neg if neg else 0, 1 + pos\\n            else: pos = neg = 0 # reset \\n            ans = max(ans, pos)\\n        return ans\\n            \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        A = nums\\n        n = len(A)\\n        dp = [[0,0] for i in range(n+1)]\\n        \\n        max_len = 0\\n        for i in range(1,n+1):\\n            if A[i-1] > 0:\\n                dp[i][0] = dp[i-1][0]+1\\n                dp[i][1] = dp[i-1][1]+1 if dp[i-1][1] != 0 else 0\\n            elif A[i-1] < 0:\\n                dp[i][0] = dp[i-1][1]+1 if dp[i-1][1] != 0 else 0\\n                dp[i][1] = dp[i-1][0]+1\\n            else:\\n                dp[i][0] = 0\\n                dp[i][1] = 0\\n            max_len = max(max_len, dp[i][0])\\n        # print(dp)\\n        \\n        return max_len\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        ret=0\\n        total=0\\n        acc=1\\n        start=-1\\n        first=-1\\n        last=0\\n        for i in range(len(nums)):\\n            if nums[i]==0:\\n                if acc>0:\\n                    ret=max(total,ret)\\n                else:\\n                    ret=max(ret,first-1,total-first,last-1,total-last)\\n                start=i\\n                acc=1\\n                total=0\\n                first=-1\\n                last=0\\n            else:\\n                total+=1\\n                acc=acc*(1 if nums[i]>0 else -1)\\n                if nums[i]<0:\\n                    if first==-1:\\n                        first=i-start\\n                    last=0\\n                last+=1\\n        if acc>0:\\n            ret=max(total,ret)\\n        else:\\n            ret=max(ret,first-1,total-first,last-1,total-last)\\n        return ret\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        listt = []\\n        a = -1\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                listt.append(nums[a + 1:i])\\n                a = i\\n        listt.append(nums[a + 1:])\\n        while [] in listt:\\n            listt.remove([])\\n        if listt==[]:\\n            return 0\\n        recordlist = {}\\n        for i in range(len(listt)):\\n            firstneg=-1\\n            begneg=-1\\n            recordlist[i]=0\\n            for m in range(len(listt[i])):\\n                if listt[i][m]<0 and firstneg==-1:\\n                    firstneg = m\\n                    if begneg==-1:\\n                        begneg=m\\n                    continue\\n                if listt[i][m]<0 and firstneg!=-1:\\n                    firstneg=-1\\n            if firstneg==-1:\\n                recordlist[i]=len(listt[i])\\n            else:\\n                recordlist[i]=max([firstneg,len(listt[i])-firstneg-1,begneg,len(listt[i])-begneg-1])\\n        m=[]\\n        for i in list(recordlist.values()):\\n            m.append(i)\\n        return max(m)\\n\", \"class Solution:\\n    #Any subarray containing a zero must be broken into seperate subarrays either side of the zero\\n    #Any subarr with an even number of negatives can be counted in its entirety\\n    #For a subarr with an odd number of negatives, the largest subarray excluding either the left or rightmost negative number can be taken instead\\n\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        #Simplify array to +-1\\n        for i in nums:\\n            if i > 0:\\n                i = 1\\n            elif i < 0:\\n                i = -1\\n                \\n        arrays = []\\n        end = 0\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                arrays.append(nums[end:i])\\n                end = i + 1\\n        arrays.append(nums[end:])\\n        \\n        #print(arrays)\\n        maximum = 0\\n        for arr in arrays:\\n            maxi = 0\\n            neg = 0\\n            first = -1\\n            for i in range(len(arr)):\\n                if arr[i] < 0:\\n                    neg += 1\\n                    if first == -1:\\n                        first = i + 1\\n                    last = i\\n            if neg % 2 == 0:\\n                maxi = len(arr)\\n            else:\\n                #Length of sub a (missing first)\\n                subA = len(arr) - first    \\n                #Length of sub b (missing last)\\n                subB = last\\n                maxi = max(subA, subB)\\n            #print(arr, maxi)\\n            maximum = max(maximum, maxi)\\n            \\n        \\n        return maximum\\n                \\n            \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        def helper(nums):\\n            result = 0\\n\\n            positiveSoFar = 0\\n            negativeSoFar = 0\\n\\n            for i in range(len(nums)):\\n                if nums[i] == 0:\\n                    positiveSoFar = 0\\n                    negativeSoFar = 0\\n                elif nums[i] > 0 :\\n                    positiveSoFar += 1\\n                    if negativeSoFar > 0:\\n                        negativeSoFar += 1\\n\\n                elif nums[i] < 0:\\n                    if negativeSoFar > 0:\\n                        positiveSoFar = max(negativeSoFar, positiveSoFar) +1\\n                        negativeSoFar = 0\\n                    else:\\n                        negativeSoFar = positiveSoFar + 1\\n                        positiveSoFar = 0\\n\\n                result = max(result, positiveSoFar)\\n            return result\\n        \\n        # scan from left and scan from right\\n        return max(helper(nums), helper(nums[::-1]))\\n        \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        dp = []\\n        for num in nums:\\n            if num == 0:\\n                dp.append(0)\\n            elif num > 0:\\n                dp.append(1)\\n            else:\\n                dp.append(-1)\\n        for i in range(1, len(dp)):\\n            if dp[i - 1] == 0:\\n                continue\\n            else:\\n                dp[i] *= dp[i - 1]\\n        print(dp)\\n        dic = {}\\n        res = 0\\n        zero = -1\\n        for i,num in enumerate(dp):\\n            if num > 0:\\n                if 1 not in dic:\\n                    res = max(res,i  - zero)\\n                    dic[1] = i\\n                else:\\n                    res = max(res, i - dic[1] + 1, i - zero)\\n            elif num == 0:\\n                dic = {}\\n                zero = i\\n            else:\\n                if -1 not in dic:\\n                    dic[-1] = i\\n                else:\\n                    res = max(res, i  - dic[-1])\\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        pos, neg = 0, 0\\n        if nums[0]>0: pos = 1\\n        if nums[0]<0: neg = 1\\n        ans = pos\\n        for i in range(1, len(nums)):\\n            if nums[i] > 0:\\n                pos, neg = pos+1, neg+1 if neg else 0\\n            elif nums[i] < 0:\\n                pos, neg = neg+1 if neg else 0, pos+1\\n            else:\\n                pos, neg = 0, 0\\n            ans = max(ans,pos)\\n            \\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        def helper(nums):\\n            result = 1 if nums[0] > 0 else 0\\n\\n            positiveSoFar = 1 if nums[0] > 0 else 0\\n            negativeSoFar = 1 if nums[0] < 0 else 0\\n\\n\\n            for i in range(1, len(nums)):\\n                if nums[i] == 0:\\n                    positiveSoFar = 0\\n                    negativeSoFar = 0\\n                elif nums[i] > 0 :\\n                    positiveSoFar += 1\\n                    if negativeSoFar > 0:\\n                        negativeSoFar += 1\\n\\n                elif nums[i] < 0:\\n                    if negativeSoFar > 0:\\n                        positiveSoFar = max(negativeSoFar, positiveSoFar) +1\\n                        negativeSoFar = 0\\n                    else:\\n                        negativeSoFar = positiveSoFar + 1\\n                        positiveSoFar = 0\\n\\n                result = max(result, positiveSoFar)\\n            return result\\n        \\n        \\n        return max(helper(nums), helper(nums[::-1]))\\n        \\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        numPos, numNeg, res = 0, 0, 0\\n        \\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                numPos += 1\\n                if numNeg > 0: numNeg += 1\\n            elif nums[i] < 0:\\n                numPosTmp, numNegTmp = numPos, numNeg\\n                if numPosTmp > 0:\\n                    numNeg = numPosTmp + 1\\n                else:\\n                    numNeg = 1\\n                if numNegTmp > 0:\\n                    numPos = numNegTmp + 1\\n                else:\\n                    numPos = 0\\n            else:\\n                numNeg = 0\\n                numPos = 0\\n            res = max(res, numPos)\\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        splittedArrays = []\\n        \\n        currentArray = []\\n        negCount = 0\\n        for num in nums:\\n            if num == 0:\\n                if len(currentArray) > 0:\\n                    splittedArrays.append((currentArray, negCount))\\n                currentArray = []\\n                negCount = 0\\n            else:\\n                currentArray.append(num)\\n                negCount += 1 if num < 0 else 0\\n        \\n        if len(currentArray) > 0:\\n            splittedArrays.append((currentArray, negCount))\\n        \\n        if not splittedArrays:\\n            return 0\\n        \\n        maxLength = 0\\n        for splittedArray, negCount in splittedArrays:\\n            if negCount % 2 == 0:\\n                maxLength = max(maxLength, len(splittedArray))\\n            else:\\n                removedNums = 0\\n                i = 0\\n                while splittedArray[i] > 0:\\n                    removedNums += 1\\n                    i += 1\\n                maxLength = max(maxLength, len(splittedArray) - removedNums - 1)\\n                \\n                removedNums = 0\\n                i = len(splittedArray) - 1\\n                while splittedArray[i] > 0:\\n                    removedNums += 1\\n                    i -= 1\\n                maxLength = max(maxLength, len(splittedArray) - removedNums - 1)\\n        \\n        return maxLength\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        pos = [0] * n\\n        neg = [0] * n\\n        \\n        if nums[0] < 0:\\n            neg[0] = 1\\n        elif nums[0] > 0:\\n            pos[0] = 1\\n            \\n        ans = pos[0]\\n        for i in range(1,n):\\n            if nums[i] > 0:\\n                pos[i] = 1 + pos[i - 1]\\n                neg[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\\n                \\n            elif nums[i] < 0:\\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\\n                neg[i] = 1 + pos[i - 1]\\n            ans = max(ans,pos[i])\\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l = -1\\n        neg_num = 0\\n        result = 0\\n        for i in range(n):\\n            if (nums[i] == 0):\\n                while (neg_num % 2):\\n                    if (nums[l + 1] < 0):\\n                        neg_num -= 1\\n                    l += 1\\n                # print(i, l)\\n                result = max(result, i - l - 1)\\n                l = i\\n                count = 0\\n            elif (nums[i] < 0):\\n                neg_num += 1\\n            if (neg_num % 2 == 0):\\n                result = max(result, i - l)\\n        while (neg_num % 2) and (l < n - 1):\\n            if (nums[l + 1] < 0):\\n                neg_num -= 1\\n            l += 1\\n        # print(l)\\n        result = max(result, n - 1 - l)\\n        return result\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        size = len(nums)\\n        if size == 1:\\n            return 0 if nums[0] < 0 else 1\\n        \\n        \\n        start = 0\\n        end = 0\\n        \\n        longest = 0\\n        \\n        while end < size:\\n        \\n            numNeg = 0\\n            leftNeg = -1\\n            rightNeg = -1\\n        \\n            while end < size and not nums[end] == 0:\\n                if nums[end] < 0:\\n                    \\n                    numNeg += 1\\n                    rightNeg = end\\n                    \\n                    if leftNeg == -1:\\n                        leftNeg = end\\n                        \\n                end += 1\\n                \\n            if numNeg % 2 == 0:\\n                longest = max(longest, end - start)\\n            else:\\n                longest = max(longest, end - rightNeg - 1, rightNeg - start, end - leftNeg - 1, leftNeg - start)\\n                \\n                \\n            end += 1\\n            start = end\\n            \\n        return longest\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        pos, neg = -1, n\\n        c = 1\\n        ret = 0\\n        for i, j in enumerate(nums):\\n            if j == 0:\\n                pos, neg = i, n\\n                c = 1\\n                continue\\n            if j > 0:\\n                pass\\n            else:\\n                c *= -1\\n            if c == 1:\\n                ret = max(ret, i - pos)\\n            else:\\n                ret = max(ret, i - neg)\\n                neg = min(neg, i)\\n        return ret\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        dp = [[0]*2 for _ in range(len(nums))]\\n        dp[0][0] = nums[0] > 0\\n        dp[0][1] = nums[0] < 0\\n        ret = dp[0][0]\\n        for i in range(1,len(nums)):\\n            if nums[i] == 0:\\n                continue\\n            if nums[i] > 0:\\n                dp[i][0] = dp[i-1][0] + 1\\n                dp[i][1] = 0 if not dp[i-1][1] else dp[i-1][1] + 1\\n            else:\\n                dp[i][0] = 0 if not dp[i-1][1] else dp[i-1][1] + 1\\n                dp[i][1] = dp[i-1][0] + 1\\n            ret = max(ret,dp[i][0])\\n        return int(ret)\", \"\\n\\n# dp[i][0] : max length of subarray ending with index i With positive product   \\n# dp[i][1] : max length of subarray ending with index i With negative product \\n\\n\\nclass Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        dp = [[0,0] for _ in range(len(nums))]\\n        res = 0\\n        if nums[0] > 0:\\n            dp[0][0] = 1\\n        elif nums[0] < 0:\\n            dp[0][1] = 1\\n        #print(dp)\\n        res = max(res, dp[0][0])\\n        for idx in range(1, len(nums)):\\n            if nums[idx] == 0:\\n                dp[idx][0], dp[idx][1] = 0, 0\\n            elif nums[idx] > 0:\\n                dp[idx][0] = dp[idx-1][0] + 1\\n                if dp[idx-1][1] > 0:\\n                    dp[idx][1] = dp[idx-1][1] + 1\\n                res = max(dp[idx][0], res)\\n            \\n            elif nums[idx] < 0:\\n                dp[idx][1] = dp[idx-1][0]+1\\n                if dp[idx-1][1] > 0:\\n                    dp[idx][0] = dp[idx-1][1]+1\\n                res = max(res, dp[idx][0])\\n                \\n        #print(dp)\\n        return res\\n\\n\\n\\n'''\\nclass Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        diction = {}\\n        diction[\\\\\\\"pos\\\\\\\"], diction[\\\\\\\"neg\\\\\\\"] = 0, 0\\n        prevpos, prevneg = 0, 0\\n        res = 0\\n        for num in nums:\\n            if num == 0:\\n                diction[\\\\\\\"pos\\\\\\\"], diction[\\\\\\\"neg\\\\\\\"] = 0, 0\\n                prevpos, prevneg = 0, 0\\n            elif num > 0:\\n                diction[\\\\\\\"pos\\\\\\\"] += 1\\n                if diction[\\\\\\\"neg\\\\\\\"] % 2 == 0:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"]+diction[\\\\\\\"neg\\\\\\\"]+prevpos)\\n                    print(num, res)\\n                else:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"], prevpos)\\n        \\n            elif num < 0:\\n                diction[\\\\\\\"neg\\\\\\\"] += 1\\n                print(\\\\\\\"neg\\\\\\\", num, diction[\\\\\\\"neg\\\\\\\"], diction[\\\\\\\"pos\\\\\\\"], prevpos)\\n                if diction[\\\\\\\"neg\\\\\\\"] % 2 == 1:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"])\\n                    prevpos += diction[\\\\\\\"pos\\\\\\\"]\\n                    diction[\\\\\\\"pos\\\\\\\"] = 0\\n                else:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"]+diction[\\\\\\\"neg\\\\\\\"]+prevpos)\\n                    prevpos = diction[\\\\\\\"neg\\\\\\\"] + diction[\\\\\\\"pos\\\\\\\"] + prevpos\\n                    diction[\\\\\\\"neg\\\\\\\"] = 0\\n                    diction[\\\\\\\"pos\\\\\\\"] = 0\\n                    \\n        print(res)\\n        return res\\n'''\\n\\n        \\n'''\\n        diction = {}\\n        diction[\\\\\\\"pos\\\\\\\"], diction[\\\\\\\"neg\\\\\\\"] = 0, 0\\n        res = 0\\n        for num in nums:\\n            if num == 0:\\n                diction[\\\\\\\"pos\\\\\\\"], diction[\\\\\\\"neg\\\\\\\"] = 0, 0\\n            elif num > 0:\\n                diction[\\\\\\\"pos\\\\\\\"] += 1\\n                if diction[\\\\\\\"neg\\\\\\\"] % 2 == 0:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"]+diction[\\\\\\\"neg\\\\\\\"])\\n            elif num < 0:\\n                diction[\\\\\\\"neg\\\\\\\"] += 1\\n                \\n                if diction[\\\\\\\"neg\\\\\\\"] % 2 == 1:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"]+diction[\\\\\\\"neg\\\\\\\"]-1)\\n                else:\\n                    res = max(res, diction[\\\\\\\"pos\\\\\\\"]+diction[\\\\\\\"neg\\\\\\\"])\\n                \\n        print(res)\\n        \\n        return res\\n        \\n\\n'''\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        # \\\\\\\"pos\\\\\\\", \\\\\\\"neg\\\\\\\" represent longest consecutive numbers ending with nums[i] forming a positive/negative product.\\n\\n        n = len(nums)\\n        pos, neg = 0, 0\\n        if nums[0] > 0: pos = 1\\n        if nums[0] < 0: neg = 1\\n        ans = pos\\n        for i in range(1, n):\\n            if nums[i] > 0:\\n                pos = 1 + pos\\n                neg = 1 + neg if neg > 0 else 0\\n            elif nums[i] < 0:\\n                pre_pos, pre_neg = pos, neg\\n                pos = 1 + pre_neg if pre_neg > 0 else 0\\n                neg = 1 + pre_pos\\n            else:\\n                pos, neg = 0, 0\\n            ans = max(ans, pos)\\n        return ans\\n    \\n        # nums.append(0)\\n        # start = -1\\n        # i = 0\\n        # firstn = -1\\n        # maxl = 0\\n        # nneg = 0\\n        # while i<len(nums):\\n        #     if nums[i]<0:\\n        #         nneg += 1\\n        #         if firstn<0: firstn = i\\n        #         lastn = i\\n        #     elif nums[i] == 0:\\n        #         if nneg%2 == 0:\\n        #             maxl = max(maxl,i-start-1)\\n        #         else:\\n        #             maxl = max([maxl,lastn-start-1,i-firstn-1])\\n        #         start = i\\n        #         nneg = 0\\n        #         firstn = -1\\n        #     i += 1\\n        # return maxl\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        # dp[i]: max length of pos subarray ends at i\\n        l = len(nums)\\n        pdp = [0] * l\\n        ndp = [0] * l\\n        pdp[0] = 1 if nums[0] > 0 else 0\\n        ndp[0] = 1 if nums[0] < 0 else 0\\n        b = pdp[0]\\n        for i in range(1, l):\\n            n = nums[i]\\n            if n > 0:\\n                pdp[i] = max(pdp[i - 1] + 1, 1)\\n                ndp[i] = ndp[i - 1] + 1 if ndp[i - 1] != 0 else 0\\n            elif n < 0:\\n                ndp[i] = max(pdp[i - 1] + 1, 1)\\n                pdp[i] = ndp[i - 1] + 1 if ndp[i - 1] != 0 else 0\\n            else:\\n                pdp[i] = 0\\n                ndp[i] = 0\\n            b = max(b, pdp[i])\\n            \\n        return b\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        dp = [[0] * 2 for _ in range(len(nums))]\\n        if nums[0] < 0:\\n            dp[0][1] = 1\\n        if nums[0] > 0:\\n            dp[0][0] = 1\\n            \\n        res = dp[0][0]\\n            \\n        for i, num in enumerate(nums):\\n            if i and num < 0:\\n                dp[i][1] = dp[i-1][0] + 1\\n                if dp[i-1][1]:\\n                    dp[i][0] = dp[i-1][1] + 1\\n            if i and num > 0:\\n                dp[i][0] = dp[i-1][0] + 1\\n                if dp[i-1][1]:\\n                    dp[i][1] = dp[i-1][1] + 1\\n            res = max(res, dp[i][0])\\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        cur_pos_product_len = 1 if nums[0] > 0 else 0\\n        cur_neg_product_len = 1 if nums[0] < 0 else 0\\n        max_len = cur_pos_product_len        \\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] > 0:\\n                cur_pos_product_len += 1\\n                cur_neg_product_len = cur_neg_product_len + 1 if cur_neg_product_len > 0 else 0\\n            elif nums[i] < 0:\\n                temp = cur_pos_product_len\\n                cur_pos_product_len = cur_neg_product_len + 1 if cur_neg_product_len > 0 else 0\\n                cur_neg_product_len = temp + 1\\n            else:\\n                cur_pos_product_len = 0\\n                cur_neg_product_len = 0\\n            max_len = max(max_len, cur_pos_product_len)\\n        return max_len\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        arrs=[[]]\\n        for i in nums:\\n            if i:\\n                arrs[-1].append(i)\\n            else:\\n                arrs.append([])\\n        ans=0\\n        for arr in arrs:\\n            if not len(arr):\\n                continue\\n            negs=0\\n            for i in arr:\\n                if i<0:\\n                    negs+=1\\n            if negs%2:\\n                p1=0\\n                while arr[p1]>0:\\n                    p1+=1\\n                p2=len(arr)-1\\n                while arr[p2]>0:\\n                    p2-=1\\n                ans=max(len(arr)-p1-1,p2,ans)\\n            else:\\n                ans=max(ans,len(arr))\\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        pos_length = 0\\n        neg_length = 0\\n        max_length = 0\\n        for num in nums:\\n            if num > 0:\\n                pos_length += 1\\n                if neg_length:\\n                    neg_length += 1\\n            elif num < 0:\\n                tmp = pos_length\\n                if neg_length:\\n                    pos_length = neg_length + 1\\n                else:\\n                    pos_length = 0\\n                neg_length = tmp + 1\\n            else:\\n                pos_length = 0\\n                neg_length = 0\\n            max_length = max(max_length, pos_length)\\n#           print(f'num, max_length = {num}, {max_length}')\\n        max_length = max(max_length, pos_length)\\n        return max_length\\n\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [[0, 0] for _ in range(n)]\\n        for i in range(n):\\n            if nums[i] == 0: dp[i] = [0, 0]\\n            elif i == 0 or nums[i - 1] == 0:\\n                if nums[i] > 0: dp[i][0] = 1\\n                else: dp[i][1] = 1\\n            elif nums[i] > 0:\\n                dp[i][0] = dp[i - 1][0] + 1\\n                if dp[i - 1][1] > 0: dp[i][1] = dp[i - 1][1] + 1\\n            else:\\n                if dp[i - 1][1] > 0: dp[i][0] = dp[i - 1][1] + 1\\n                dp[i][1] = dp[i - 1][0] + 1\\n        return max(dp[i][0] for i in range(n))\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        nums.append(0)\\n        left = 0\\n        n = len(nums)\\n        first_neg = n\\n        last_neg = 0\\n        ct_neg = 0\\n        ans = 0\\n        for right in range(n):\\n            if nums[right]<0:\\n                first_neg = min(first_neg, right)\\n                last_neg = max(last_neg, right)\\n                ct_neg += 1\\n            elif nums[right]==0:\\n                if left < right:\\n                    if ct_neg & 1 == 0:\\n                        ans = max(ans, right-left)\\n                    else:\\n                        print(left, right, first_neg, last_neg)\\n                        ans = max(ans, right-first_neg-1)\\n                        ans = max(ans, last_neg-left)\\n                left = right+1\\n                first_neg = n\\n                last_neg = 0\\n                ct_neg = 0\\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        res = 0\\n        for is_pos, group in itertools.groupby(nums, key = bool):\\n            if is_pos:\\n                subgroup = list(group)\\n                num_negs = 0\\n                # if the num negs is odd, the answer is either\\n                # the length without the first negative\\n                # or the length without the last negative\\n                first = last = None \\n                for i, n in enumerate(subgroup):\\n                    if n < 0:\\n                        num_negs += 1\\n                        if first is None:\\n                            first = i\\n                        last = i\\n                if num_negs % 2 == 0:\\n                    res = max(res, len(subgroup))\\n                else:\\n                    res = max(res, first, len(subgroup) - 1 - first)\\n                    res = max(res, last, len(subgroup) - 1 - last)\\n        return res\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        neg = [0] * n\\n        pos = [0] * n \\n\\n        if nums[0] < 0:\\n            neg[0] = 1 \\n        elif nums[0] > 0:\\n            pos[0] = 1\\n        # \\u4ee5i\\u4e3a\\u7ed3\\u5c3e\\u7684\\u65f6\\u5019 \\u4e58\\u79ef\\u662f\\u8d1f\\u6570\\u7684\\u65f6\\u5019\\u7684\\u957f\\u5ea6 neg[i], or is positive \\n        for i in range(1, n):\\n            val = nums[i]\\n            if val > 0:\\n                pos[i] = pos[i-1] + 1\\n                neg[i] = (neg[i-1] + 1) if neg[i-1] != 0 else 0 \\n            elif val < 0:\\n                pos[i] = (neg[i-1] + 1) if neg[i-1] != 0 else 0\\n                neg[i] = pos[i-1] + 1\\n            else:\\n                pos[i] = 0\\n                neg[i] = 0\\n            print((pos[i], neg[i]))\\n        return max(pos)\\n\", \"class Solution:\\n    \\n    # space optimized\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        \\n        ans = 0\\n        neg_pos = None\\n        neg_count = 0\\n        left = -1\\n        for i, n in enumerate(nums):\\n            if n==0:\\n                neg_pos = None\\n                neg_count = 0\\n                left = i\\n                continue\\n            elif n>0:\\n                if neg_count%2==0:\\n                    ans = max(ans, i-left)\\n                else:\\n                    ans = max(ans, i-neg_pos)\\n            elif n<0:\\n                neg_count += 1\\n                if neg_pos is None:\\n                    neg_pos=i\\n                if neg_count%2==0:\\n                    ans = max(ans, i-left)\\n                else:\\n                    ans = max(ans, i-neg_pos)\\n\\n        return ans\\n    \\n    # original O(n) space\\n    def getMaxLen1(self, nums: List[int]) -> int:\\n        \\n        ans = 0\\n        dq = []\\n        left = -1\\n        for i, n in enumerate(nums):\\n            if n==0:\\n                dq.clear()\\n                left = i\\n                continue\\n            elif n>0:\\n                if len(dq)%2==0:\\n                    ans = max(ans, i-left)\\n                else:\\n                    ans = max(ans, i-dq[0])\\n            elif n<0:\\n                dq.append(i)\\n                if len(dq)%2==0:\\n                    ans = max(ans, i-left)\\n                else:\\n                    ans = max(ans, i-dq[0])\\n\\n        return ans\", \"class Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        f_pos = 0\\n        f_neg = 0\\n        max_pos = 0\\n        for i in range(len(nums)):\\n            if nums[i]==0:\\n                f_pos,f_neg = 0,0\\n            elif nums[i]>0:\\n                f_pos +=1\\n                if f_neg>0:\\n                    f_neg+=1\\n            else:\\n                tmp = f_pos\\n                if f_neg>0:\\n                    f_pos = f_neg+1\\n                else:\\n                    f_pos = 0\\n                f_neg = tmp+1\\n            print((i, f_pos,f_neg))\\n            max_pos = max(max_pos ,f_pos)\\n        return max_pos\\n            \\n\", \"from typing import List\\nclass Solution:\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        def aux(i,j):\\n            negs = 0\\n            for v in nums[i:j+1]:\\n                if v<0:\\n                    negs+=1\\n            if negs%2 == 0:\\n                return j-i+1\\n            l=i\\n            while nums[l]>0:\\n                l+=1\\n            l = j-l\\n            r=j\\n            while nums[r]>0:\\n                r-=1\\n            r = r-i\\n            return max(l,r)\\n\\n        start = 0\\n        maxm = 0\\n        for end in range(len(nums)):\\n            if nums[end] == 0:\\n                maxm = max(maxm,aux(start, end-1))\\n                start = end+1\\n            elif nums[end]>0:\\n                maxm = max(maxm, 1)\\n        if start!=len(nums)-1:\\n            maxm = max(maxm,aux(start, len(nums)-1))\\n        return maxm\\n\\n\", \"import bisect\\nclass Solution:\\n    ans = [0 for i in range(100001)]\\n    def getMaxLen(self, nums: List[int]) -> int:\\n        def solve(arr):\\n            s1, s2 = set(), set()\\n            s1.add(-1)\\n            ret = 0\\n            cnt = 0\\n            n = len(arr)\\n            for i, c in enumerate(arr):\\n                cnt += 0 if c > 0 else 1\\n                if cnt % 2 == 0:\\n                    s1.add(i)\\n                else:\\n                    s2.add(i)\\n            if s1:\\n                ret = max(s1) - min(s1)\\n            if s2:\\n                ret = max(max(s2) - min(s2), ret)\\n            # print(s1, s2, ret)\\n            return ret\\n        ans = 0\\n        l = 0\\n        for i, c in enumerate(nums):\\n            if c == 0:\\n                ans = max(ans, solve(nums[l:i]))\\n                l = i + 1\\n        ans = max(ans, solve(nums[l:]))\\n        return ans\"]", "input_output": "{\"fn_name\": \"getMaxLen\", \"inputs\": [[[1, -2, -3, 4]]], \"outputs\": [4]}", "difficulty": "interview", "url": "https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/", "starter_code": "\nclass Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        "}
{"id": 139, "question": "We are given an array\u00a0A of N lowercase letter strings, all of the same length.\nNow, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.\nFor example, if we have an array A = [\"abcdef\",\"uvwxyz\"] and deletion indices {0, 2, 3}, then the final array after deletions is [\"bef\",\"vyz\"].\nSuppose we chose a set of deletion indices D such that after deletions, the final array has its elements in lexicographic order (A[0] <= A[1] <= A[2] ... <= A[A.length - 1]).\nReturn the minimum possible value of D.length.\n\u00a0\n\n\n\n\n\n\n\nExample 1:\nInput: [\"ca\",\"bb\",\"ac\"]\nOutput: 1\nExplanation: \nAfter deleting the first column, A = [\"a\", \"b\", \"c\"].\nNow A is in lexicographic order (ie. A[0] <= A[1] <= A[2]).\nWe require at least 1 deletion since initially A was not in lexicographic order, so the answer is 1.\n\n\nExample 2:\nInput: [\"xc\",\"yb\",\"za\"]\nOutput: 0\nExplanation: \nA is already in lexicographic order, so we don't need to delete anything.\nNote that the rows of A are not necessarily in lexicographic order:\nie. it is NOT necessarily true that (A[0][0] <= A[0][1] <= ...)\n\n\nExample 3:\nInput: [\"zyx\",\"wvu\",\"tsr\"]\nOutput: 3\nExplanation: \nWe have to delete every column.\n\n\u00a0\n\n\nNote:\n\n1 <= A.length <= 100\n1 <= A[i].length <= 100", "solutions": "[\"class Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n        def isSorted(arr, i, j):\\n            return all(arr[k] <= arr[k+1] for k in range(i, j))\\n        ans = 0\\n        ranges = [[0, len(A)-1]]\\n        for col in zip(*A):\\n            if not ranges:\\n                break\\n            if all(isSorted(col, i, j) for i, j in ranges):\\n                tmp = []\\n                for i, j in ranges:\\n                    start = i\\n                    for k in range(i, j+1):\\n                        if col[k] != col[start]:\\n                            if k - start > 1:\\n                                tmp.append([start, k-1])\\n                            start = k   \\n                    if j + 1 - start > 1:\\n                        tmp.append([start, j])\\n                    start = k   \\n                ranges[:] = tmp\\n            else:    \\n                ans += 1\\n        return ans\\n            \\n\", \"class Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n        D = set()\\n        \\n        while True:\\n            changes = False\\n            last_str = ''\\n            for i, ch in enumerate(A[0]):\\n                if i not in D:\\n                    last_str += ch\\n            for x in A[1:]:\\n                this_str = ''\\n                this_idx = []\\n                for i, ch in enumerate(x):\\n                    if i not in D:\\n                        this_str += ch\\n                        this_idx.append(i)\\n                while this_str < last_str:\\n                    for i in range(len(this_str)):\\n                        if this_str[i] < last_str[i]:\\n                            D.add(this_idx[i])\\n                            this_idx = this_idx[:i] + this_idx[i+1:]\\n                            this_str = this_str[:i] + this_str[i+1:]\\n                            last_str = last_str[:i] + last_str[i+1:]\\n                            changes = True\\n                            break\\n                last_str = this_str\\n            if not changes:\\n                break\\n        return len(D)\", \"class Solution:\\n    def checkLexOrder (self, A: List[str]):\\n        if A == sorted(A):\\n            return True\\n        else:\\n            return False\\n    def findDelIndices (self, A: List[str]):\\n        iter_ = len(A[0])\\n        to_be_del = []\\n        temp = ['']*len(A)\\n        for i in range(iter_):\\n            if self.checkLexOrder([x[i] for x in A]) == True:\\n                temp = [temp[j]+A[j][i] for j in range(len(A))]\\n            else:\\n                temp_ = [temp[j]+A[j][i] for j in range(len(A))]\\n                if self.checkLexOrder(temp_) == True:\\n                    temp = [temp[j]+A[j][i] for j in range(len(A))]\\n                else:\\n                    to_be_del.append(i)\\n        return len(to_be_del)   \\n    def minDeletionSize(self, A: List[str]) -> int:\\n        if self.checkLexOrder(A):\\n            return 0\\n        else:\\n            return self.findDelIndices(A)\\n                \\n        \\n        \\n\", \"import copy\\nclass Solution:\\n    def checkLexOrder (self, A: List[str]):\\n        if A == sorted(A):\\n            return True\\n        else:\\n            return False\\n    def findDelIndices (self, A: List[str]):\\n        iter_ = len(A[0])\\n        to_be_del = []\\n        temp = ['']*len(A)\\n        for i in range(iter_):\\n            if self.checkLexOrder([x[i] for x in A]) == True:\\n                temp = [temp[j]+A[j][i] for j in range(len(A))]\\n            else:\\n                temp_ = [temp[j]+A[j][i] for j in range(len(A))]\\n                if self.checkLexOrder(temp_) == True:\\n                    temp = [temp[j]+A[j][i] for j in range(len(A))]\\n                else:\\n                    to_be_del.append(i)\\n        return len(to_be_del)   \\n    def minDeletionSize(self, A: List[str]) -> int:\\n        if self.checkLexOrder(A):\\n            return 0\\n        else:\\n            return self.findDelIndices(A)\\n                \\n        \\n        \\n\", \"class Solution:\\n    def isArrSorted(self, a) -> tuple((bool, bool)):\\n        is_exp_sorted = True\\n        is_eq_sorted = True\\n\\n        for i, l in enumerate(a):\\n            if i == len(a) - 1:\\n                break\\n            \\n            if not l < a[i+1]:\\n                is_exp_sorted = False\\n            if not l <= a[i+1]:\\n                is_eq_sorted = False\\n        return (is_exp_sorted, is_eq_sorted)\\n\\n    def minDeletionSize(self, A: List[str]) -> int:\\n        deletion_count = 0\\n        \\n        built_A = [''] * len(A)\\n        \\n        for i in range(0, len(A[0])):\\n            letters_at_i = [s[i] for s in A]\\n            is_exp_sorted, is_eq_sorted = self.isArrSorted(letters_at_i)\\n            # print(is_exp_sorted, is_eq_sorted)\\n            \\n            if is_exp_sorted:\\n                break\\n            \\n            test_A = [built_A[oi] + o[i] for oi, o in enumerate(A)]\\n            # print(test_A)\\n            if list(sorted(test_A)) == test_A:\\n                built_A = test_A\\n                continue\\n            else:\\n                deletion_count += 1\\n        \\n        return deletion_count\\n\", \"class Solution:\\n  def minDeletionSize(self, words: List[str]) -> int:\\n    n = len( words )\\n    if n==0:\\n      return 0\\n    w = len( words[0] )\\n    intervals = [[0,n]]\\n    del_cols = 0\\n    for col in range(w):\\n      next_intervals = []\\n      del_this_col = 0\\n      for start,end in intervals:\\n        cprev = words[start][col]\\n        iprev = start\\n        for i in range(start+1,end):\\n          c = words[i][col]\\n          if c>cprev:\\n            ## create new interval\\n            ## reset cprev and iprev\\n            next_intervals.append( [iprev,i] )\\n            cprev = c\\n            iprev = i\\n          elif c<cprev:\\n            del_this_col = 1\\n            del_cols += 1\\n            break\\n          pass\\n        if del_this_col:\\n          break\\n        ## add another last interval\\n        next_intervals.append( [iprev, end] )\\n        pass\\n      if not del_this_col:\\n        intervals = next_intervals\\n      pass\\n    return del_cols\", \"class Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n        L = len(A)\\n        N = len(A[0])\\n        sort_groups = [[i for i in range(L)]]\\n        count = 0\\n        \\n        for i in range(N):\\n            \\n            new_groups = []\\n            in_order = True\\n        \\n            for group in sort_groups:\\n                new_group = []\\n                curr_ord = 0\\n        \\n                for g_idx in group:\\n                    \\n                    char = A[g_idx][i]\\n                    if ord(char) > curr_ord:\\n                        if curr_ord != 0:\\n                            new_groups.append(new_group)\\n                        new_group = [g_idx]\\n                        curr_ord = ord(char)\\n                        \\n                    elif ord(char) == curr_ord:\\n                        new_group.append(g_idx)\\n                        \\n                        \\n                    # remove a column\\n                    else:\\n                        in_order = False\\n                        break\\n                \\n                if not in_order:\\n                    break\\n                \\n                if new_group != []:\\n                    new_groups.append(new_group)\\n                    \\n            if in_order:\\n                sort_groups = new_groups\\n            \\n            else:\\n                count += 1\\n                \\n        return count\", \"class Solution:\\n    def minDeletionSize(self, A):\\n        m, n = len(A), len(A[0])\\n        first = [False] * m\\n        res = 0\\n        for j in range(n):\\n            for i in range(1, m):\\n                if not first[i] and A[i][j] < A[i - 1][j]:\\n                    res += 1\\n                    break\\n            else:\\n                for i in range(1, m):\\n                    if A[i][j] > A[i - 1][j]:\\n                        first[i] = True\\n        return res        \", \"class Solution:\\n    def minDeletionSize(self, A):\\n        m, n = len(A), len(A[0])\\n        first = [-1] * m\\n        res = 0\\n        for j in range(n):\\n            for i in range(1, m):\\n                if first[i] == -1 and A[i][j] < A[i - 1][j]:\\n                    res += 1\\n                    break\\n            else:\\n                for i in range(1, m):\\n                    if A[i][j] > A[i - 1][j] and first[i] == -1:\\n                        first[i] = j\\n        return res        \"]", "input_output": "{\"fn_name\": \"minDeletionSize\", \"inputs\": [[[\"\\\"ca\\\"\", \"\\\"bb\\\"\", \"\\\"ac\\\"\"]]], \"outputs\": [1]}", "difficulty": "interview", "url": "https://leetcode.com/problems/delete-columns-to-make-sorted-ii/", "starter_code": "\nclass Solution:\n    def minDeletionSize(self, A: List[str]) -> int:\n        "}
{"id": 140, "question": "Given a non-empty array of numbers, a0, a1, a2, \u2026 , an-1, where 0 \u2264 ai < 231.\n\nFind the maximum result of ai XOR aj, where 0 \u2264 i, j < n.\n\nCould you do this in O(n) runtime?\n\nExample:\n\nInput: [3, 10, 5, 25, 2, 8]\n\nOutput: 28\n\nExplanation: The maximum result is 5 ^ 25 = 28.", "solutions": "[\"class Solution:\\n     def findMaximumXOR(self, nums):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         ans = 0\\n         for bit in range(31, -1, -1) :\\n             ans = (ans << 1) + 1\\n             pre = set()\\n             for n in nums :\\n                 p = (n >> bit) & ans\\n                 if p in pre :\\n                     break\\n                 pre.add(ans - p)\\n             else :\\n                 ans -= 1\\n         return ans\", \"class Solution:\\n     def findMaximumXOR(self, nums):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         ans = 0\\n         for bit in range(31, -1, -1) :\\n             ans = (ans << 1) | 1\\n             pre = set()\\n             for n in nums :\\n                 p = (n >> bit) & ans\\n                 if p in pre :\\n                     break\\n                 pre.add(ans ^ p)\\n             else :\\n                 ans ^= 1\\n         return ans\"]", "input_output": "{\"fn_name\": \"findMaximumXOR\", \"inputs\": [[[3, 10, 5, 25, 2, 8]]], \"outputs\": [28]}", "difficulty": "interview", "url": "https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/", "starter_code": "\nclass Solution:\n    def findMaximumXOR(self, nums: List[int]) -> int:\n        "}
{"id": 141, "question": "The i-th person has weight people[i], and each boat can carry a maximum weight of limit.\nEach boat carries at most 2 people at the same time, provided the sum of the\u00a0weight of those people is at most limit.\nReturn the minimum number of boats to carry every given person.\u00a0 (It is guaranteed each person can be carried by a boat.)\n\u00a0\n\nExample 1:\nInput: people = [1,2], limit = 3\nOutput: 1\nExplanation: 1 boat (1, 2)\n\n\nExample 2:\nInput: people = [3,2,2,1], limit = 3\nOutput: 3\nExplanation: 3 boats (1, 2), (2) and (3)\n\n\nExample 3:\nInput: people = [3,5,3,4], limit = 5\nOutput: 4\nExplanation: 4 boats (3), (3), (4), (5)\nNote:\n\n1 <=\u00a0people.length <= 50000\n1 <= people[i] <=\u00a0limit <= 30000", "solutions": "[\"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        \\n        people.sort()\\n        lo = 0 \\n        hi = len(people) - 1\\n        count = 0\\n        \\n        while lo <= hi:\\n            count += 1\\n            if people[lo] + people[hi] <= limit:\\n                lo += 1\\n            hi -= 1\\n            \\n        return count\\n        \\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        boats = 0\\n        l = 0\\n        r = len(people) - 1\\n        while r>l:\\n            boats += 1\\n            if people[l] + people[r] <= limit:\\n                l += 1\\n                r = r-1\\n            else:\\n                r = r-1\\n        if r == l:\\n            boats += 1\\n        return boats\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people = sorted(people, reverse=True)\\n        i = 0\\n        j = len(people) - 1\\n        n = 0\\n        while True:\\n            # TODO - Check for [5,5,5,5,5] with limit of 5\\n            if i >= j:\\n                break\\n            n += 1\\n            w1 = people[i]\\n            i += 1\\n            rem = limit - w1\\n            if rem >= people[j]:\\n                j -= 1\\n\\n        if i == j:\\n            n += 1\\n        \\n        return n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        \\n        people.sort()\\n        \\n        p1 = 0\\n        \\n        p2 = len(people) - 1\\n        \\n        boat = 0\\n        \\n        while p1 <= p2:\\n            boat+= 1\\n            if people[p1] + people[p2] <= limit:\\n                p1 += 1\\n            \\n            p2 -= 1\\n        \\n        return boat\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        i = 0\\n        j = len(people)-1\\n        count = 0\\n        while i < j:\\n            if people[i] + people[j] <= limit:\\n                count += 1\\n                i += 1\\n                j -= 1\\n            else:\\n                count += 1\\n                j -= 1\\n        if i == j:\\n            count += 1\\n        return count\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        new = sorted(people)\\n        i,j = 0, len(people)-1\\n        res = 0\\n        while i<=j:\\n            \\n            if new[j]+new[i]<=limit:\\n                i+=1\\n            j-=1\\n            res+=1\\n        return res\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        \\n        people.sort()\\n        \\n        l, r = 0, len(people)-1\\n        res = 0\\n        \\n        while l <= r:\\n            while l <= r and people[l] + people[r] > limit:\\n                res += 1\\n                r -= 1\\n            if l <= r:\\n                res += 1\\n                l += 1\\n                r -= 1\\n        return res\\n        \\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        length = len(people)\\n        people.sort()\\n        \\n        left = 0\\n        right = length - 1\\n        boat_num = 0\\n        \\n        while left <= right:\\n            if people[left] + people[right] <= limit:\\n                left += 1\\n                right -= 1\\n            else:\\n                right -= 1\\n            boat_num += 1\\n        \\n        return boat_num\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        i=0\\n        j=len(people)-1\\n        count=0\\n        while(i<=j):\\n            count+=1\\n            if(people[i]+people[j]<=limit):\\n                i+=1\\n            j-=1\\n        return count\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        if not people:\\n            return 0\\n\\n        people = sorted(people)\\n\\n        left = 0\\n        right = len(people) - 1\\n        board_cnt = 0\\n\\n        while left <= right:\\n            #key\\n            if left == right:\\n                board_cnt += 1\\n                break\\n\\n            if people[left] + people[right] <= limit:\\n                left += 1\\n                right -= 1\\n                board_cnt += 1\\n            else:\\n                right -= 1\\n                board_cnt += 1\\n            \\n        return board_cnt        \", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        left, right = 0, len(people)-1\\n        boats = 0\\n        \\n        while left <= right:\\n            if left == right:\\n                boats += 1\\n                break\\n            if people[left] + people[right] <= limit:\\n                boats += 1\\n                left += 1\\n                right -= 1\\n            else:\\n                right -= 1\\n                boats += 1\\n                \\n        return boats\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        i,j=0,len(people)-1\\n        ans=0\\n        while i<=j:\\n            ans += 1\\n            if people[i] + people[j] <= limit:\\n                i += 1\\n            j -= 1\\n        return ans\\n            \\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        if len(people) <= 1:\\n            return 0\\n        people.sort()\\n        boats = 0\\n        l = 0\\n        r = len(people) - 1\\n        while l <= r:\\n            if l == r:\\n                return boats + 1\\n            if people[l] + people[r] <= limit:\\n                boats += 1\\n                l += 1\\n                r -= 1\\n            else:\\n                boats += 1\\n                r -= 1\\n        return boats\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people = sorted(people)\\n        \\n        print(people)\\n        \\n        l = 0\\n        r = len(people) - 1\\n        \\n        boats = 0\\n        while l <= r:\\n            if people[r] + people[l] <= limit:\\n                r -= 1\\n                l += 1\\n                boats += 1\\n            else:\\n                r -= 1\\n                boats += 1\\n        \\n        return boats\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        r = len(people)-1\\n        l = 0\\n        trips = 0\\n        \\n        while r >= l:\\n            if people[r] + people[l] <= limit:\\n                l += 1\\n            trips += 1\\n            r -= 1\\n        return trips\\n            \\n        \\n                \\n        \\n                \\n            \\n        \\n        \\n                \\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        # start at ends and move inward\\n        \\n        people.sort()\\n        start = 0\\n        end = len(people) - 1\\n        ans = 0\\n        \\n        while start <= end:\\n            ans += 1\\n            if people[start] + people[end] <= limit:\\n                start += 1\\n            end -= 1\\n        \\n        return ans\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        \\n        people.sort(reverse=True)\\n        l, r = 0, len(people) - 1\\n        \\n        while l <= r:\\n            if people[l] + people[r] <= limit:\\n                r -= 1\\n            l += 1\\n        return l\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people = sorted(people)\\n        count = 0\\n        left = 0\\n        right = len(people) - 1\\n\\n        while left <= right:\\n            cur = people[left] + people[right]\\n            if cur <= limit:\\n                left += 1\\n                right -= 1\\n            elif cur > limit:\\n                right -= 1\\n            count += 1\\n\\n        return count\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        j = len(people)-1\\n        i = 0\\n        people = sorted(people)\\n        ### since we could max have two people on a boat so we need to add have two ###pointers\\n        print(people)\\n        count = 0\\n        while(i<=j):\\n            count = count+1\\n            if people[j] + people[i]<=limit:\\n                i = i + 1\\n                j = j - 1\\n            else:\\n                j = j - 1\\n        return(count)\\n            \\n            \\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        boats = 0\\n        people = sorted(people)\\n        print(people)\\n        i, j = 0, len(people)-1\\n        while i <= j:\\n            if people[i] + people[j] > limit:\\n                j -= 1\\n            else:\\n                i += 1\\n                j -= 1\\n            boats += 1\\n        \\n        return boats\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        s = []\\n        c = 0\\n        people.sort(reverse=True)\\n        \\n        for i in range(len(people)):\\n            if s and people[i] < s[-1]:\\n                s[-1] = s[-1] - people[i]\\n                s.pop()\\n            elif s and people[i] == s[-1]:\\n                s.pop()\\n            elif s and people[i] > s[-1]:\\n                s.append(limit - people[i])\\n                c += 1\\n            elif people[i] == limit:\\n                c += 1\\n            else:\\n                c += 1\\n                s.append(limit - people[i])\\n        \\n        return c\\n                \\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        less_than_half = dict()\\n        more_than_half = dict()\\n        half = 0\\n        total_boats = 0\\n        for person in people:\\n            diff = limit - person\\n            if diff == 0:\\n                total_boats += 1\\n                continue\\n            if person < limit/2:\\n                if diff in more_than_half:\\n                    total_boats += 1\\n                    if more_than_half[diff] == 1:\\n                        del more_than_half[diff]\\n                    else:\\n                        more_than_half[diff] -= 1\\n                else:\\n                    if person in less_than_half:\\n                        less_than_half[person] += 1\\n                    else:\\n                        less_than_half[person] = 1\\n            elif person > limit/2:\\n                if diff in less_than_half:\\n                    total_boats += 1\\n                    if less_than_half[diff] == 1:\\n                        del less_than_half[diff]\\n                    else:\\n                        less_than_half[diff] -= 1\\n                else:\\n                    if person in more_than_half:\\n                        more_than_half[person] += 1\\n                    else:\\n                        more_than_half[person] = 1\\n            else:\\n                if half == 1:\\n                    total_boats += 1\\n                    half = 0\\n                else:\\n                    half = 1\\n        \\n        less_keys = sorted(less_than_half.keys())\\n        more_keys = sorted(list(more_than_half.keys()), reverse=True)\\n        \\n        while len(less_keys) and len(more_keys):\\n            if less_keys[0] + more_keys[0] <= limit:\\n                if less_than_half[less_keys[0]] < more_than_half[more_keys[0]]:\\n                    total_boats += less_than_half[less_keys[0]]\\n                    more_than_half[more_keys[0]] -= less_than_half[less_keys[0]]\\n                    less_keys.pop(0)\\n                elif less_than_half[less_keys[0]] > more_than_half[more_keys[0]]:\\n                    total_boats += more_than_half[more_keys[0]]\\n                    less_than_half[less_keys[0]] -= more_than_half[more_keys[0]]\\n                    more_keys.pop(0)\\n                else:\\n                    total_boats += less_than_half[less_keys[0]]\\n                    less_keys.pop(0)\\n                    more_keys.pop(0)\\n            else:\\n                total_boats += more_than_half[more_keys[0]]\\n                more_keys.pop(0)\\n                    \\n        less_total = 0\\n        for k in less_keys:\\n            less_total += less_than_half[k]\\n        \\n        more_total = 0\\n        for k in more_keys:\\n            more_total += more_than_half[k]\\n        \\n        # we can pair up each of the less than half weights\\n        total_boats += (less_total+half + 1) // 2 + more_total\\n        \\n        return total_boats\\n\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort(reverse=True)\\n        first_index = 0\\n        second_index = len(people) - 1\\n        ans = 0\\n        while first_index <= second_index:\\n            if people[first_index] + people[second_index] <= limit:\\n                second_index -= 1\\n            first_index += 1\\n            ans += 1\\n        return ans\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people = sorted(people)\\n        i = 0\\n        j = len(people) - 1\\n        total = 0\\n        while i <= j:\\n            if i == j:\\n                total += 1\\n                i += 1\\n                j -= 1\\n            else:\\n                if people[i] + people[j] <= limit:\\n                    i += 1\\n                    j -= 1\\n                    total += 1\\n                else:\\n                    j -= 1\\n                    total += 1\\n        return total\\n        # print(people)\\n        # while i < len(people):\\n        #     print(i,people)\\n        #     if i < len(people) - 1 and people[i] + people[i+1] <= limit:\\n        #         print(\\\\\\\"two peeps\\\\\\\")\\n        #         i += 2\\n        #     else:\\n        #         print(\\\\\\\"one peep\\\\\\\")\\n        #         i += 1\\n        #     total += 1\\n        # return total\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], cap: int) -> int:\\n        people.sort()\\n        N = len(people)\\n        i, j = 0, N - 1\\n        \\n        ans = 0\\n        k = cap\\n        s = 2\\n        \\n        while i <= j:\\n            # prioritize heavier one\\n            while s and j >= 0:\\n                if k - people[j] < 0:\\n                    break\\n                k -= people[j]\\n                j -= 1\\n                s -= 1\\n            # check if we can fit any remainig lighter people\\n            while s and i < N:\\n                if k - people[i] < 0:\\n                    break\\n                k -= people[i]\\n                i += 1\\n                s -= 1\\n            k = cap\\n            s = 2\\n            ans += 1\\n        \\n        return ans\\n            \\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        sorted_people = list(sorted(people, reverse=True))\\n        \\n        i = 0\\n        j = len(people) - 1\\n        \\n        while i <= j:\\n            if sorted_people[i] + sorted_people[j] <= limit:\\n                j -= 1\\n            i += 1\\n        \\n        return i\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        count = len(people)\\n        end = len(people) - 1\\n        begin = 0\\n        res = 0\\n        while count > 0:\\n            if people[end] + people[begin] <= limit:\\n                res+=1\\n                count-=2\\n                end-=1\\n                begin+=1\\n            else:\\n                res+=1\\n                count-=1\\n                end-=1\\n        return res\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        groups = self.group_people_by_weight(people, limit)\\n        return self.count_num_boats(groups, limit)\\n        \\n    def group_people_by_weight(self, people, limit):\\n        groups = [0] * (limit + 1)\\n        for person_weight in people:\\n            groups[person_weight] += 1\\n        return groups\\n    \\n    def count_num_boats(self, groups, limit):\\n        num_boats = 0\\n        start = 0\\n        end = len(groups) - 1\\n        while start <= end:\\n            while start <= end and groups[start] <= 0:\\n                start += 1\\n            while start <= end and groups[end] <= 0:\\n                end -= 1\\n            if start > end:\\n                break\\n            if start + end <= limit:\\n                groups[start] -= 1\\n            groups[end] -= 1\\n            num_boats += 1\\n        return num_boats\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        low = 0\\n        up = len(people) - 1\\n        boats = 0\\n        \\n        while(low <= up):\\n            if up-1 >= low and people[up] + people[up - 1] <= limit:\\n                up -= 2\\n                boats += 1\\n            elif up != low and people[up] + people[low] <= limit:\\n                up -= 1\\n                low += 1\\n                boats += 1\\n            else:\\n                up -= 1\\n                boats += 1\\n                \\n        return boats\\n\", \"from collections import deque\\nclass Solution:\\n    def numRescueBoats(self, people, limit):\\n        n = len(people)\\n        weights = deque(sorted(people))\\n        boat = 0\\n        while n > 1:\\n            if weights[0] + weights[-1] <= limit:\\n                weights.popleft()\\n                weights.pop()\\n                n -= 2\\n            else:\\n                weights.pop()\\n                n -= 1\\n            boat += 1\\n        if n == 1: boat += 1\\n        return boat\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        l = 0\\n        h = len(people) -1\\n        remain_capacity = limit\\n        if len(people) == 0:\\n            return 0\\n        boat = 1\\n        ppl_in_boat = 2\\n        \\n        while ( l <= h ):\\n            if (people[h] <= remain_capacity and ppl_in_boat != 0):\\n                remain_capacity -= people[h]\\n                ppl_in_boat -= 1\\n                h = h -1                 \\n            elif (remain_capacity >= people[l] and ppl_in_boat != 0):\\n                remain_capacity -= people[l]\\n                ppl_in_boat -= 1\\n                l = l +1\\n            else:\\n                boat +=1\\n                remain_capacity = limit\\n                ppl_in_boat = 2\\n        return boat\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        num_boats = 0\\n        counts = [0] * (limit + 1)\\n        for person_weight in people:\\n            counts[person_weight] += 1\\n        \\n        start = 0\\n        end = len(counts) - 1\\n        while start <= end:\\n            while start <= end and counts[start] <= 0:\\n                start += 1\\n            while start <= end and counts[end] <= 0:\\n                end -= 1\\n            if start > end:\\n                break\\n            if start + end <= limit:\\n                counts[start] -= 1\\n            counts[end] -= 1\\n            num_boats += 1\\n        return num_boats\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        print(people)\\n        low = 0\\n        up = len(people) - 1\\n        boats = 0\\n        \\n        while(low <= up):\\n            if up-1 >= low and people[up] + people[up - 1] <= limit:\\n                up -= 2\\n                boats += 1\\n            elif up != low and people[up] + people[low] <= limit:\\n                up -= 1\\n                low += 1\\n                boats += 1\\n                added = True\\n            else:\\n                up -= 1\\n                boats += 1\\n                \\n        return boats\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        \\n        n = len(people)\\n        people.sort()\\n        print(people)\\n        i = 0\\n        j = n-1\\n        re = []\\n        c = 0\\n        tmp = []\\n        while i <= j:\\n            if people[i] + people[j] > limit:\\n                c +=1\\n                tmp.append(people[j])\\n                re.append(tmp)\\n                tmp = []\\n                j = j-1\\n            else:\\n                tmp.append(people[i])\\n                tmp.append(people[j])\\n                re.append(tmp)\\n                tmp = []\\n                i = i+1\\n                j = j-1\\n        print(re)\\n        return len(re)\\n                \\n                    \\n                \\n                \\n            \\n        \\n        \\n                    \\n            \\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        if people[0] >= limit:\\n            return 0\\n        res = [0]\\n        i, j = 0, len(people) - 1\\n        num_people = 0\\n        while i <= j:\\n            if res[-1] + people[j] <= limit and num_people < 2:\\n                res[-1] += people[j]\\n                j -= 1\\n                num_people += 1\\n            elif res[-1] + people[i] <= limit and num_people < 2:\\n                res[-1] += people[i]\\n                i += 1\\n                num_people += 1\\n            else:\\n                res.append(0)\\n                num_people = 0\\n        return len(res)\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        i,j=0,len(people)-1\\n        answer=0\\n        while i<j:\\n            if people[i]+people[j]<=limit:\\n                i+=1\\n                j-=1\\n            else:\\n                j-=1\\n            if i==j:\\n                answer+=1\\n            answer+=1\\n        return answer\\n                \\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        i = 0\\n        j = len(people) - 1\\n        ans = 0\\n        \\n        while i <= j:\\n            ans += 1\\n            if people[i] + people[j] <= limit:\\n                i += 1\\n            j -= 1\\n        return ans\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        num_boats=0\\n        last=len(people)-1\\n        first=0\\n        while first < last:\\n            if people[first]+people[last]<=limit:\\n                last-=1\\n                first+=1\\n                num_boats+=1\\n            else:\\n                num_boats+=1\\n                last-=1\\n        if first==last:\\n            num_boats+=1\\n        return num_boats\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        \\n        left=0\\n        right=len(people)-1\\n        boats = 0\\n    \\n        while left<=right:\\n            if left==right:\\n                boats+=1\\n                break\\n            if people[left] + people[right] <= limit:\\n                left+=1\\n            #     right-=1\\n            #     boats+=1\\n            # else:\\n            #     right-=1\\n            #     boats+=1\\n            right-=1\\n            boats+=1\\n        \\n        return boats\\n                \\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        l = len(people)\\n        if (l <= 1):\\n            return(1)\\n#        people = self.sortPeople(people)\\n        people.sort()\\n        i = 0; j = l-1; c = 0\\n        while i < j:\\n            print((i,j,c))\\n            if people[i] + people[j] <= limit:\\n                c +=1\\n                i +=1\\n                j -=1\\n            else:\\n                j -=1\\n                c +=1\\n        if i == j:\\n            c +=1\\n        return(c)\\n        \\n        \\n        \\n        \\n    def sortPeople(self, arr):\\n   #     print(arr)\\n        l = len(arr)\\n        if l <= 1:\\n            return(arr)\\n        pivot = arr[l-1]\\n        larr = [];rarr = []\\n        \\n        for i in range(l-1):\\n            if arr[i] >= pivot:\\n                rarr.append(arr[i])\\n            else:\\n                larr.append(arr[i])\\n       # print(larr + [pivot] + rarr)\\n        return(self.sortPeople(larr) + [pivot] + self.sortPeople(rarr))\\n        \\n\", \"class Solution(object):\\n    def numRescueBoats(self, people, limit):\\n        people.sort()\\n        i, j = 0, len(people) - 1\\n        ans = 0\\n        while i <= j:\\n            ans += 1\\n            if people[i] + people[j] <= limit:\\n                i += 1\\n            j -= 1\\n        return ans\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        l = 0\\n        r = len(people)-1\\n        res = 0\\n        while l <=r:\\n            if people[l]+people[r] <= limit:\\n                res+=1\\n                l+=1\\n                r-=1\\n            else:\\n                res+=1\\n                r-=1\\n        return res\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        i,j=0,len(people)-1\\n        res=0\\n        while i<=j:\\n            res+=1\\n            if people[i]+people[j]<=limit:\\n                i+=1\\n            j-=1\\n        return res\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        \\n        people.sort()\\n        if len(people) == 0 or len(people) == 1:\\n            return len(people)\\n        else:\\n            lptr = 0\\n            rptr = len(people) - 1\\n            count = 0\\n            while lptr <= rptr:\\n                if( (people[lptr] + people[rptr]) <= limit):\\n                    count += 1\\n                    lptr += 1\\n                    rptr -= 1\\n                else:\\n                    rptr -= 1\\n                    count += 1\\n            return count \\n            '''\\n        people.sort()        \\n        left = 0\\n        right = len(people) - 1\\n        \\n        counter = 0\\n        while left <= right:\\n            if people[left] + people[right] <= limit:\\n                left += 1\\n                right -= 1\\n                counter += 1\\n            else: # people[left] + people[right] > limit:\\n                right -= 1\\n                counter += 1\\n            return counter'''\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        i, j = 0, len(people) - 1\\n        ans = 0\\n        while i <= j:\\n            ans += 1            \\n            if people[i] + people[j] <= limit:\\n                i += 1\\n            j -= 1\\n        return ans\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        \\n        people.sort()\\n        \\n        l, r = 0, len(people)-1\\n        res = 0\\n        \\n        while l <= r:\\n            res += 1\\n            if people[l] + people[r] <= limit:\\n                l += 1\\n            r -= 1\\n        return res\\n        \\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        left = 0\\n        right = len(people) - 1\\n        number = 0\\n        while(left <= right):\\n            if (left == right):\\n                number +=1\\n                break\\n            if people[left] + people[right] <= limit:\\n                \\n                    left= left+1\\n            right= right-1\\n            number +=1\\n        return number \\n                \\n\", \"from collections import deque\\n\\nclass Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people = deque(sorted(people))\\n        count = 0\\n        while len(people) > 1:\\n            lightest = people.popleft()\\n            heaviest = people.pop()\\n            if lightest + heaviest <= limit:\\n                count += 1\\n                continue\\n            else:\\n                if lightest < limit:\\n                    people.appendleft(lightest)\\n                else:\\n                    count += 1\\n                count += 1\\n        return count + len(people)\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        \\n        '''\\n        time complexity :\\n            because of sorting O(Nlog(N))\\n            the second loop is smaller so we ignore it\\n        \\n        space complexity:\\n            because of sorting\\n            O(N)\\n        '''\\n        people.sort()\\n        left = 0\\n        right = len(people)-1\\n        boat_number = 0\\n\\n        while left <= right:\\n            if left == right:\\n                boat_number += 1\\n                break\\n            if people[left] + people[right] <= limit:\\n                left += 1\\n                right -= 1\\n                boat_number+=1\\n            else:\\n                right -= 1\\n                boat_number +=1\\n\\n        return boat_number\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort(reverse=True)\\n        \\n        res = 0\\n        i = 0\\n        j = len(people) - 1\\n        while i <= j:\\n            if people[i] + people[j] <= limit:\\n                j -= 1\\n            \\n            i += 1\\n            \\n                \\n        return i\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        lo, hi = 0, len(people) -1\\n        boats = 0\\n        \\n        while lo <= hi:\\n            cap = limit\\n            cap -= people[hi] # always take the higher one first\\n            hi -= 1\\n            \\n            if people[lo] <= cap: # if you can take a lower one to pair with higher, then include it\\n                lo += 1\\n                \\n            boats += 1 # increment boat by 1, whether you can only take hi or lo + hi\\n            \\n        return boats\\n        \\n        \\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        lo = 0\\n        count = 0\\n        for hi in range(len(people))[::-1]:\\n            if lo < hi and people[lo] + people[hi] <= limit:\\n                lo += 1\\n            if lo == hi:\\n                return len(people) - hi\\n                \\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people = sorted(people)\\n        i = 0\\n        j = len(people)-1\\n        res = 0\\n        while i<=j:\\n            res+=1\\n            if people[i]+people[j]<=limit:\\n                i+=1\\n            j-=1\\n        return res\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        i = 0\\n        j = len(people)-1\\n        boats = 0\\n        while i <= j:\\n            if i == j or people[i]+people[j] <= limit:\\n                boats += 1\\n                i += 1\\n                j -= 1\\n            else:\\n                boats += 1\\n                j -= 1\\n        return boats\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        n = len(people)\\n        i = 0\\n        j = n-1\\n        \\n        boats = 0\\n        while i <= j:\\n            if people[i] + people[j] <= limit:\\n                i += 1\\n            j -= 1\\n            # else:\\n            #     j -= 1\\n            \\n            boats += 1\\n            \\n        return boats\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people = sorted(people)\\n        count = 0\\n        i, j = 0, len(people) - 1\\n        while 0 <= i < j < len(people):\\n            while 0 <= i < j < len(people) and people[i] + people[j] > limit:\\n                j -= 1\\n                count += 1\\n            i += 1\\n            j -= 1\\n            count += 1\\n        if i == j:\\n            count += 1\\n        return count\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        minBoats = 0\\n        people.sort()\\n        \\n        left = 0\\n        right = len(people) - 1\\n        \\n        while left <= right:\\n            if people[left] + people[right] <= limit:\\n                left += 1\\n            minBoats += 1\\n            right -= 1\\n                \\n        return minBoats\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        ret = 0\\n        people.sort(reverse = True)\\n        start = len(people) - 1\\n        for i in range(len(people)):\\n            if start >= i:\\n                ret += 1\\n            temp_lim = limit - people[i]\\n            for j in range(start,i,-1):\\n                if people[j] <= temp_lim:\\n                    start = j - 1\\n                    break\\n                elif people[j] > temp_lim:\\n                    start = j\\n                    break\\n                \\n            print(temp_lim)\\n        return ret\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        i, j = 0, len(people)-1\\n        boats = 0\\n        \\n        while i <= j:\\n            if people[i] + people[j] <= limit:\\n                i += 1\\n            j -= 1\\n            boats += 1\\n            \\n        return boats\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        i=0\\n        j=len(people)-1\\n        m=0\\n        while(i<=j):\\n            if people[i]+people[j]<=limit:\\n                i+=1\\n                j-=1\\n            else:\\n                j=j-1\\n            m+=1    \\n        return m        \", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        n = len(people)\\n        i = 0\\n        j = n-1\\n        \\n        boats = 0\\n        while i <= j:\\n            if i < j and people[i] + people[j] <= limit:\\n                i += 1\\n                j -= 1\\n            else:\\n                j -= 1\\n            \\n            boats += 1\\n            \\n        return boats\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        # Map: of weight to count O(n)\\n        # Check limit down\\n        \\n        people.sort()\\n        \\n        print(people)\\n        boats = 0\\n        left_index = 0\\n        right_index = len(people) - 1\\n        \\n        while left_index <= right_index:\\n            if people[left_index] + people[right_index] <= limit:\\n                left_index += 1\\n            \\n            boats += 1\\n            right_index -= 1\\n                \\n        return boats\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        i=0\\n        j=len(people)-1\\n        boats=0\\n        while(i<=j):\\n            if people[i]+people[j]<=limit:\\n                i+=1\\n                j-=1\\n            elif people[i]+people[j]>limit:\\n                j-=1\\n            boats+=1\\n        return boats\\n\", \"# 1, 2, 2, 3 limit = 4\\n# l        r\\n\\n\\nclass Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people = sorted(people)\\n        \\n        left = 0\\n        right = len(people) - 1\\n        counter = 0\\n        while left < right:\\n            total = people[left] + people[right]\\n            counter += 1\\n            right -= 1\\n            if total <= limit:\\n                left += 1\\n        \\n        if left == right:\\n            counter += 1\\n        \\n        return counter\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        total = 0 #if len(people)%2 == 0 else 1\\n        people.sort()\\n        print(people)\\n        i = 0 \\n        j = len(people) - 1\\n        while i <= j:\\n            print(j)\\n            if (people[i] + people[j]) > limit or i == j:\\n                j-=1\\n                total+=1\\n            else:\\n                i+=1\\n                j-=1\\n                total+=1\\n        \\n        return total\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        \\n        people.sort(reverse=True)\\n        res = 0\\n        print(people)\\n        l, r = 0, len(people)-1\\n        \\n        while(l<=r):\\n            \\n            print((l, r))\\n            remain = limit-people[l]\\n            res += 1\\n            l += 1\\n            if remain - people[r] >= 0:\\n                remain -= people[r]\\n                r -= 1\\n                    \\n                    \\n        print(res)\\n        \\n        return res\\n\\n\\n\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        \\n#         start=0\\n#         end=len(people)-1\\n#         count=0\\n#         #people=sorted(people)\\n#         while start<=end:\\n#             if people[start]+people[end]<=limit:\\n#                 start+=1\\n            \\n#             end-=1\\n#          count+=1\\n        bucket = [0]*(limit+1)\\n        for i in people:\\n            bucket[i]+=1\\n        start = 0\\n        end = len(bucket)-1\\n        count=0\\n        while start<=end:\\n            \\n            while start<=end and bucket[start]<=0: start+=1\\n            \\n            while start<=end and bucket[end]<=0: end-=1\\n                \\n            if bucket[start]<=0 and bucket[end]<=0: break\\n            \\n            count+=1\\n            if start+end<=limit:\\n                bucket[start]-=1\\n            \\n            bucket[end]-=1\\n        \\n        \\n        return count\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        if people == None or len(people) == 0:\\n            return 0\\n        people.sort()\\n        start = 0\\n        end = len(people)-1\\n        counter = 0\\n        while start <= end:\\n            if people[start] + people[end] <=limit:\\n                start += 1\\n                end -=1\\n            else:\\n                end -= 1\\n            counter += 1\\n        return counter\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        i,j = 0, len(people) -1\\n        ans = 0\\n        while i<=j:\\n            ans+=1\\n            if people[i]+people[j] <= limit:\\n                i+=1\\n            j-=1\\n        return ans\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        left, right = 0, len(people) - 1\\n        count = 0\\n        while left <= right:\\n            if people[left] + people[right] <= limit:\\n                left += 1\\n                right -= 1\\n                count += 1\\n            else:\\n                right -= 1\\n                count += 1\\n        return count\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        i, j = 0, len(people) -1\\n\\n        count = 0\\n\\n        while i <= j:\\n            if i == j:\\n                count += 1\\n                break\\n            if people[i] + people[j] <= limit:\\n                i+=1\\n                j-=1\\n            else:\\n                j-=1\\n            count += 1\\n        return count \\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        minBoats = 0\\n        people.sort()\\n        \\n        left = 0\\n        right = len(people) - 1\\n        \\n        while left <= right:\\n            if people[left] + people[right] <= limit:\\n                minBoats += 1\\n                left += 1\\n                right -= 1\\n            elif people[left] + people[right] > limit:\\n                minBoats += 1\\n                right -= 1\\n                \\n        return minBoats\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        i = 0\\n        j = len(people)-1\\n        total = 0\\n        while i <= j:\\n            total += 1\\n            if people[i] + people[j] <= limit:\\n                i += 1\\n            j -= 1\\n        return total\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        i = 0\\n        j = len(people) - 1\\n        count = 0\\n        while(i <= j):\\n            if people[i] + people[j] > limit:\\n                count = count + 1\\n                j = j - 1\\n            else:\\n                count = count + 1\\n                i = i + 1\\n                j = j - 1\\n        return(count)\\n                \\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        \\n        q = collections.deque(sorted(people))\\n        \\n        ans = 0\\n        \\n        while len(q) > 1:\\n            i,x = q.pop(), q[0]\\n            if i+x <= limit:\\n                q.popleft()\\n            ans += 1\\n        \\n        return ans + (1 if q else 0)\\n            \\n        \\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        i = 0\\n        j = len(people) - 1\\n        ans = 0\\n        while i <= j:\\n            if i == j:\\n                return ans + 1\\n            elif people[i] + people[j] > limit:\\n                j -= 1\\n                ans += 1\\n            else:\\n                i += 1\\n                j -= 1\\n                ans += 1\\n        return ans\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        total = 0 #if len(people)%2 == 0 else 1\\n        people.sort()\\n        i = 0 \\n        j = len(people) - 1\\n        while i <= j:\\n            if (people[i] + people[j]) > limit or i == j:\\n                j-=1\\n                total+=1\\n            else:\\n                i+=1\\n                j-=1\\n                total+=1\\n        \\n        return total\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        i,j = 0, len(people)-1\\n        count = 0\\n        while i <= j:\\n            if people[i] + people[j] <= limit:\\n                count += 1\\n                i += 1\\n                j -= 1\\n            else:\\n                count += 1\\n                j -= 1\\n        return count\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        \\n        people.sort(reverse=True)\\n        res = 0\\n        print(people)\\n        l, r = 0, len(people)-1\\n        \\n        while(l<=r):\\n            \\n            print((l, r))\\n            remain = limit-people[l]\\n            res += 1\\n            l += 1\\n            if remain - people[r] >= 0:\\n                remain -= people[r]\\n                r -= 1\\n                    \\n                    \\n        print(res)\\n        \\n        return res\\n\\n\\n\\n'''\\n\\n            \\n        \\n        \\n'''\\n\\n\", \"import heapq\\nclass Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        i, j = 0,len(people)-1\\n        ans = 0\\n        while i <= j:\\n            ans += 1\\n            if people[i] + people[j] <= limit:\\n                i += 1\\n            j -= 1\\n        return ans\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        p1 = 0\\n        p2 = len(people) -1\\n        count = 1\\n        cur = 0\\n        curNum = 0\\n        while p1 <= p2:\\n            if people[p2] <= limit - cur and curNum < 2:\\n                cur = cur + people[p2]\\n                curNum += 1\\n                p2 -=1\\n                continue\\n            if people[p1] <= limit - cur and curNum < 2:\\n                cur = cur + people[p1]\\n                curNum += 1\\n                p1 += 1\\n                continue\\n            count += 1\\n            cur = 0\\n            curNum = 0\\n            \\n            \\n            \\n        return count\\n            \\n            \\n            \\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        # sort 1 - sort in the ascending order of weight\\n        people.sort()\\n        boats = 0\\n        i = 0\\n        j = len(people) - 1\\n        while j>=i:\\n            # check if two people can sit in a boat\\n            if people[i] + people[j] <= limit:\\n                i += 1  \\n            j -= 1\\n            boats += 1\\n        return boats\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people = sorted(people, reverse=True)\\n        boats = 0\\n        left = 0\\n        right = len(people) - 1\\n        while left <= right:\\n            if people[left] + people[right] <= limit:\\n                right -= 1\\n            left += 1\\n            boats += 1\\n        return boats\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people = sorted(people)\\n        i,j = 0, len(people)-1\\n        c = 0\\n        while i <= j:\\n            if people[j] + people[i] <= limit:\\n                i += 1\\n            j -= 1\\n            c += 1\\n        return c\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        left = 0\\n        right = len(people)-1\\n        boat = 0\\n        people.sort()\\n        while left <= right:\\n            if left == right:\\n                boat += 1\\n                break\\n            elif people[left]+people[right] <= limit:\\n                left += 1\\n                right -= 1\\n                boat += 1\\n            else:\\n                right -= 1\\n                boat += 1\\n        \\n        return boat\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        i=0\\n        j=len(people)-1\\n        boats=0\\n        while(i<=j):\\n            if people[i]+people[j]<=limit:\\n                i+=1\\n            \\n            j-=1\\n            boats+=1\\n        return boats\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        if not people or limit == 0:\\n            return 0\\n        \\n        ans = 0\\n        people.sort()\\n        left, right = 0, len(people) - 1\\n        while left <= right:\\n            if people[left] + people[right] <= limit:\\n                left += 1\\n                right -= 1\\n            else:\\n                right -= 1\\n            ans += 1\\n        return ans\", \"from collections import Counter\\nclass Solution:               \\n    def numRescueBoats(self, people, limit):\\n        \\n        people.sort(reverse = True) # sort in descending order\\n        boats = 0\\n        \\n        r = len(people) - 1\\n        l = 0\\n        \\n        while l <= r:\\n            boats += 1\\n            if people[l] + people[r] <= limit:\\n                r -= 1\\n            l += 1\\n        \\n        return boats\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        heap = []\\n        people.sort()\\n        heap.append((people[len(people)-1], 1))\\n        i = len(people)-2\\n        while i >= 0:\\n            ele = people[i]\\n            if limit >= ele + heap[0][0] and heap[0][1] < 2:\\n                minimum = heapq.heappop(heap)\\n                heapq.heappush(heap, (float('inf'), 2))\\n            else:\\n                heapq.heappush(heap, (ele, 1))\\n            i -= 1\\n        print(heap)\\n        return len(heap)\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people = sorted(people)\\n        l=0\\n        r=len(people)-1\\n        ret=0\\n        while l<r:\\n            if people[r]>=limit:\\n                ret+=1\\n                r-=1\\n            elif people[r]+people[l]>limit:\\n                ret+=1\\n                r-=1\\n            else:\\n                ret+=1\\n                l+=1\\n                r-=1\\n        if l==r:\\n            ret+=1\\n        return ret\\n\", \"# O(nlogn) time and O(1) space\\n# Greedy approach: pair the heaviest person with the lightest\\n# Since there are only 2 people on one boat you don't need to \\\\\\\"optimize\\\\\\\" the space of the boat to carry the third person. Moreover, you can show that if you can pair the heaviest with second heaviest, you can essentially pair any 2 people on the boat (which is the best case scenario).\\nclass Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        ans = 0\\n        people.sort()\\n        l, r = 0, len(people)-1\\n        while l<= r:\\n            if people[l] + people[r] <= limit:\\n                l += 1\\n            r -= 1\\n            ans += 1\\n        \\n        return ans\\n\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        \\n        people.sort()\\n        N = len(people)\\n        num_boats = 0\\n        \\n        if len(people) == 1:\\n            return 1\\n        \\n        less_than_half = [p for p in people if p <= limit/2]\\n        more_than_half = [p for p in people if p > limit/2]\\n        \\n        while len(more_than_half) > 0 and len(less_than_half) > 0:            \\n            \\n            if more_than_half[-1] + less_than_half[0] > limit:\\n                # largest doesn't fit with smallest\\n                more_than_half.pop(-1)\\n                num_boats += 1\\n                continue\\n                \\n            else:\\n                # largest fit with smallest\\n                more_than_half.pop(-1)\\n                less_than_half.pop(0)\\n                num_boats += 1\\n                continue      \\n                \\n        # no more pairings - one of the lists is empty\\n        num_boats += len(more_than_half)\\n        num_boats += int(len(less_than_half)/2 +0.5)            \\n                \\n        return num_boats\", \"class Solution:\\n    # Time: O(n*log(n))\\n    # Time: O(n)\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        i, j = 0, len(people) - 1\\n        res = 0\\n        while i <= j:\\n            res += 1\\n            if people[i] + people[j] <= limit:\\n                i += 1\\n            j -=1\\n        return res\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        #does sorting help?\\n        # if we sort, we can use a pointer and continue incrementing until weight is over limit\\n        \\n        people.sort()\\n        boats = 0\\n        i = 0\\n        j = len(people) - 1\\n        \\n        while i <= j:\\n            boats += 1\\n            if people[i] + people[j] <= limit:\\n                i += 1\\n                j -= 1\\n            else:\\n                j -= 1\\n            \\n        return boats\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        sortedPeople = sorted(people)\\n        i = 0\\n        j = len(sortedPeople) - 1\\n        count = 0\\n        while i <= j:\\n            if i == j:\\n                count += 1\\n                i += 1\\n                j -= 1\\n                continue\\n            if sortedPeople[i] + sortedPeople[j] <= limit:\\n                count += 1\\n                i += 1\\n                j -= 1\\n            else:\\n                count += 1\\n                j -= 1\\n        \\n        return count\", \"class Solution:\\n    \\n    def numRescueBoats(self, people, limit):\\n        people.sort()\\n        \\n        i, j = 0, len(people)-1\\n        ans = 0\\n        while i<=j:\\n            ans += 1\\n            if people[i] + people[j] <= limit:\\n                i+= 1\\n            j -= 1\\n        \\n        return ans\\n        \\n        \\n    def numRescueBoats2(self, people: List[int], limit: int) -> int:\\n        \\n        self.ans = 9999\\n        visited = [0 for _ in range(len(people)+1)]\\n        \\n        def traverse(ind:int, boatCnt:int, boats):\\n            if visited[ind]:\\n                return\\n            if ind == len(people):\\n                if boatCnt+1 < self.ans:\\n                    print(boats)\\n                    self.ans = boatCnt+1\\n            else:\\n                visited[ind] = 1\\n                for i in range(ind+1, len(people)+1):\\n                    b = boats[:]\\n                    if boatCnt >= len(b):\\n                        b.append([])\\n\\n                    if sum(b[boatCnt]) + people[ind] > limit:\\n                        boatCnt += 1\\n                        if boatCnt >= len(b):\\n                            b.append([])\\n                    b[boatCnt].append(people[ind])\\n                    traverse(ind+1, boatCnt, b)\\n                visited[ind] = 0\\n        \\n        traverse(0, 0, [])\\n        \\n        #print(boats)\\n        return self.ans\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort(reverse = True)\\n        boats = people[:(1+len(people))//2]\\n        onboard = [1]*len(boats)\\n        \\n        i = 0\\n        j = len(boats)\\n        k = len(people)-1\\n        while j <= k:\\n            if i == len(boats):\\n                boats.append(people[j])\\n                j += 1\\n                if j > k:\\n                    break\\n                    \\n            target = limit - boats[i]\\n            \\n            if people[k] > target:\\n                i += 1\\n                if i == len(boats):\\n                    boats.append(people[j])\\n                    j += 1\\n            else:\\n                boats[i] += people[k]\\n                k -= 1\\n                i += 1\\n        \\n        return len(boats)\", \"class Solution:\\n    # O(p + plog(p)) = O(p(1 + log(p))) = O(plog(p)) time / O(1) space or memory\\n    # where 'p' is the number of people\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        \\n        # 1st step: sort the array of people's weights\\n        people.sort()\\n        \\n        # 2nd step: get the current lightest person, fit on the boat, then try to \\n        # put also the lightest person if possible\\n        # EACH BOAT CARRIES AT MOST 2 PEOPLE\\n        nb_of_boats = 0\\n        i, j = 0, len(people) - 1\\n        \\n        while i <= j:\\n            if people[i] + people[j] <= limit:\\n                i += 1\\n            j -= 1\\n            nb_of_boats += 1\\n        \\n        return nb_of_boats\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        # sort list\\n        # set l = 0, r = last\\n        # see if l+r will fit in boat\\n        # if too heavy, put r in boat and iterate r     \\n        \\n        nboats = 0\\n        people.sort(reverse=True)\\n        l = 0\\n        r = len(people)-1\\n        while l < r:\\n            if people[l]+people[r] > limit:\\n                l += 1\\n                nboats += 1\\n                if l == r:\\n                    nboats += 1\\n                    break\\n            else:\\n                l += 1\\n                r -= 1\\n                nboats += 1\\n                if l == r:\\n                    nboats += 1\\n                    break\\n    \\n        return nboats\", \"class Solution:\\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        left = 0\\n        right = len(people)-1\\n        boat = 0\\n        people.sort()\\n        while left <= right:\\n            if left == right:\\n                boat += 1\\n                break\\n            elif people[left]+people[right] <= limit:\\n                left += 1\\n                \\n            right -= 1\\n            boat += 1\\n        \\n        return boat\\n\"]", "input_output": "{\"fn_name\": \"numRescueBoats\", \"inputs\": [[[1, 2], 3]], \"outputs\": [1]}", "difficulty": "interview", "url": "https://leetcode.com/problems/boats-to-save-people/", "starter_code": "\nclass Solution:\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\n        "}
{"id": 142, "question": "Given a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.\n\n\n\nA subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.\n\n\n\nThe input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.\n\n\nExample 1:\n\nInput: \"aba\", \"cdc\", \"eae\"\nOutput: 3\n\n\n\nNote:\n\nAll the given strings' lengths will not exceed 10.\nThe length of the given list will be in the range of [2, 50].", "solutions": "[\"class Solution:\\n     def findLUSlength(self, strs):\\n         \\\"\\\"\\\"\\n         :type strs: List[str]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         def isSubseq(s1, s2):\\n             i, m=0, len(s1)\\n             for c in s2:\\n                 if i==m: return True\\n                 if s1[i]==c: i+=1\\n             return i==m\\n         \\n         strs.sort(key=len, reverse=True)\\n         for i, s1 in enumerate(strs):\\n             if all(not isSubseq(s1, s2) for j, s2 in enumerate(strs) if i!=j):\\n                 return len(s1)            \\n         return -1\", \"class Solution:\\n     def findLUSlength(self, strs):\\n         \\\"\\\"\\\"\\n         :type strs: List[str]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         def isSub(s1, s2):\\n             it = iter(s2)\\n             return all(i in it for i in s1)\\n         keep, max1, N = False, -1, len(strs)\\n         mask = [True]*N\\n         for i in range(N):\\n             for j in range(N):\\n                 # need to update the condition to see whether it is substring of it.\\n                 # because \\\"abc\\\" is a subsequence of \\\"aabbcc\\\", so it is different with substring...okay, make sense now\\n                 if i != j and isSub(strs[i],strs[j]):\\n                     mask[i] = False\\n                     break\\n         for i in range(N):\\n             if mask[i]:\\n                 max1 = max(max1,len(strs[i]))\\n         return max1\\n\", \"class Solution:\\n     def findLUSlength(self, strs):\\n         \\\"\\\"\\\"\\n         :type strs: List[str]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         def check(a,b):\\n             i=0\\n             for ai in a:\\n                 while i<len(b) and ai!=b[i]:\\n                     i+=1\\n                 if i==len(b):\\n                     return False\\n                 else:\\n                     i+=1\\n             return True\\n         ans=-1\\n         for i,a in enumerate(strs):\\n             for j,b in enumerate(strs):\\n                 if i!=j and check(a,b):\\n                     break\\n             else:\\n                 ans=max(ans,len(a))\\n         return ans\", \"class Solution:\\n     def findLUSlength(self, A):\\n         \\\"\\\"\\\"\\n         :type A: List[str]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         \\n         \\n         \\n         \\n         \\\"\\\"\\\"\\n    #    a public CONCISE solution....\\n    \\n         def issubsequence(s, t):\\n             t = iter(t)\\n             return all(c in t for c in s)\\n     \\n         for s in sorted(strs, key=len, reverse=True):\\n             if sum(issubsequence(s, t) for t in strs) == 1:\\n                 return len(s)\\n         return -1\\n         \\\"\\\"\\\"\\n         \\n         \\n         \\n         \\n         \\n         \\n         \\n         def subseq(w1, w2):\\n             #True if word1 is a subsequence of word2.\\n             i = 0\\n             for c in w2:\\n                 if i < len(w1) and w1[i] == c:\\n                     i += 1\\n             return i == len(w1)\\n     \\n         A.sort(key = len, reverse = True)\\n         for i, word1 in enumerate(A):\\n             if all(not subseq(word1, word2) \\n                     for j, word2 in enumerate(A) if i != j):\\n                 return len(word1)\\n         return -1\\n         \\n     \\n \\n \\n         \\\"\\\"\\\"\\n         When we add a letter Y to our candidate longest uncommon subsequence answer of X, \\n         it only makes it strictly harder to find a common subsequence.\\n         Thus our candidate longest uncommon subsequences will be chosen from the group of words itself.\\n \\n         Suppose we have some candidate X. \\n         We only need to check whether X is not a subsequence of any of the other words Y. \\n         To save some time, we could have quickly ruled out Y when len(Y) < len(X), \\n         either by adding \\u201cif len(w1) > len(w2): return False\\u201d or enumerating over A[:i] (and checking neighbors for equality.) \\n         However, the problem has such small input constraints that this is not required.\\n \\n         We want the max length of all candidates with the desired property, \\n         so we check candidates in descending order of length. \\n         When we find a suitable one, we know it must be the best nonlocal answer.\\n         \\\"\\\"\\\"\\n         \\n         \\n\", \"class Solution:\\n     def findLUSlength(self, A):\\n         \\\"\\\"\\\"\\n         :type A: List[str]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         \\n         \\n    #    public CONCISE solution....beat 95%\\n    \\n         def issubsequence(s, t):\\n             t = iter(t)\\n             return all(c in t for c in s)\\n     \\n         for s in sorted(A, key=len, reverse=True):\\n             if sum(issubsequence(s, t) for t in A) == 1:\\n                 return len(s)\\n         return -1\\n         \\n         \\n         \\n         \\n         \\n         \\\"\\\"\\\"\\n         def issub(w1, w2):\\n             i = 0\\n             for w in w2:\\n                 if i < len(w1) and w1[i] == w:\\n                     i += 1\\n             return i == len(w1)\\n         \\n         A.sort(key = len, reverse = True)\\n         for s in A:\\n             A_copy = A.copy()\\n             A_copy.remove(s)\\n             if all(not issub(s, ss) for ss in A_copy):\\n                 return len(s)\\n         return -1\\n         \\\"\\\"\\\"\\n \\n         \\n         \\n         \\n         \\\"\\\"\\\"\\n         def subseq(w1, w2):\\n             #True if word1 is a subsequence of word2.\\n             i = 0\\n             for c in w2:\\n                 if i < len(w1) and w1[i] == c:\\n                     i += 1\\n             return i == len(w1)\\n     \\n         A.sort(key = len, reverse = True)\\n         for i, word1 in enumerate(A):\\n             if all(not subseq(word1, word2) \\n                     for j, word2 in enumerate(A) if i != j):\\n                 return len(word1)\\n         return -1\\n         \\n         \\n         \\n         \\n         \\n         \\n         When we add a letter Y to our candidate longest uncommon subsequence answer of X, \\n         it only makes it strictly harder to find a common subsequence.\\n         Thus our candidate longest uncommon subsequences will be chosen from the group of words itself.\\n \\n         Suppose we have some candidate X. \\n         We only need to check whether X is not a subsequence of any of the other words Y. \\n         To save some time, we could have quickly ruled out Y when len(Y) < len(X), \\n         either by adding \\u201cif len(w1) > len(w2): return False\\u201d or enumerating over A[:i] (and checking neighbors for equality.) \\n         However, the problem has such small input constraints that this is not required.\\n \\n         We want the max length of all candidates with the desired property, \\n         so we check candidates in descending order of length. \\n         When we find a suitable one, we know it must be the best nonlocal answer.\\n         \\\"\\\"\\\"\\n         \\n         \\n\", \"class Solution:\\n     def findLUSlength(self, strs):\\n         \\\"\\\"\\\"\\n         :type strs: List[str]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         def issub(w1, w2):\\n             i = 0\\n             for w in w2:\\n                 if i < len(w1) and w1[i] == w:\\n                     i += 1\\n             return i == len(w1)\\n         strs.sort(key = len, reverse = True)\\n         for s in strs:\\n             strs_copy = strs.copy()\\n             strs_copy.remove(s)\\n             if all(not issub(s, ss) for ss in strs_copy):\\n                 return len(s)\\n         return -1\\n\", \"class Solution:\\n     def findLUSlength(self, strs):\\n         \\\"\\\"\\\"\\n         :type strs: List[str]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         def isSubseq(s1,s2):\\n             s2_it=iter(s2)\\n             return all(i in s2_it for i in s1)\\n         for k in sorted(strs,key=len,reverse=True):\\n             if sum(isSubseq(k,k2) for k2 in strs)==1:\\n                 return len(k)\\n         return -1 \", \"class Solution:\\n     def findLUSlength(self, strs):\\n         \\\"\\\"\\\"\\n         :type strs: List[str]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         answer = -1\\n         for i in range(len(strs)):\\n             x = strs[i]\\n             if len(x) > answer and all([not self.isSubsequence(x, strs[j]) for j in range(len(strs)) if i != j]):\\n                 answer = len(x)\\n         return answer\\n \\n     def isSubsequence(self, sub, sup):\\n         i = j = 0\\n         while i < len(sub) and j < len(sup):\\n             if sub[i] == sup[j]:\\n                 i += 1\\n             j += 1\\n         return i == len(sub)\", \"class Solution:\\n     def findLUSlength(self, strs):\\n         \\\"\\\"\\\"\\n         :type strs: List[str]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         def is_subsequence(s, substr):\\n             i = 0\\n             j = 0\\n             while i < len(s) and j < len(substr):\\n                 if s[i] == substr[j]:\\n                     i += 1\\n                     j += 1\\n                 else:\\n                     i += 1\\n \\n             return j == len(substr)\\n \\n         res = -1\\n         for i in range(len(strs)):\\n             j = 0\\n             while j < len(strs):\\n                 if i == j:\\n                     j += 1\\n                     continue\\n                 if is_subsequence(strs[j], strs[i]):\\n                     break\\n                 j += 1  \\n             if j == len(strs):\\n                 res = max(res, len(strs[i]))\\n             \\n         return res\", \"class Solution:\\n     def findLUSlength(self, strs):\\n         \\\"\\\"\\\"\\n         :type strs: List[str]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         def isSubsequence(a,b):\\n             i = 0\\n             j = 0\\n             while i < len(a) and j < len(b):\\n                 if j == len(b) - 1 and (i < len(a) -1 or a[i] != b[j]):\\n                     return False\\n                 if a[i] != b[j]:\\n                     j += 1\\n                 else:\\n                     i += 1\\n                     j += 1\\n             return True\\n         flag = 0\\n         l = []\\n         for i in range(len(strs)):\\n             for j in range(len(strs)):\\n                 if i != j and isSubsequence(strs[i],strs[j]):\\n                     flag = 1\\n                     break \\n             if flag == 0:\\n                 l.append(strs[i])\\n             flag = 0\\n         if l == []:\\n             return -1\\n         res = max(list([len(x) for x in l]))\\n         return res\\n\", \"class Solution:\\n     def findLUSlength(self, strs):\\n         \\\"\\\"\\\"\\n         :type strs: List[str]\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         def is_subseq(a, b):\\n             if len(b) > len(a): return False\\n             i = 0\\n             for c in a:\\n                 if i < len(b) and b[i] == c:\\n                     i += 1\\n             return i == len(b)\\n         \\n         strs.sort(key=lambda x: -len(x))\\n         for i, s in enumerate(strs):\\n             if not any(is_subseq(s2, s) for s2 in strs[:i]) and not any(is_subseq(s2, s) for s2 in strs[i + 1:]):\\n                 return len(s)\\n         return -1\\n\"]", "input_output": "{\"fn_name\": \"findLUSlength\", \"inputs\": [[[\"\\\"aba\\\"\", \"\\\"cdc\\\"\", \"\\\"eae\\\"\"]]], \"outputs\": [5]}", "difficulty": "interview", "url": "https://leetcode.com/problems/longest-uncommon-subsequence-ii/", "starter_code": "\nclass Solution:\n    def findLUSlength(self, strs: List[str]) -> int:\n        "}
{"id": 143, "question": "In a row of trees, the i-th tree\u00a0produces\u00a0fruit with type\u00a0tree[i].\nYou start at any tree\u00a0of your choice, then repeatedly perform the following steps:\n\nAdd one piece of fruit from this tree to your baskets.\u00a0 If you cannot, stop.\nMove to the next tree to the right of the current tree.\u00a0 If there is no tree to the right, stop.\n\nNote that you do not have any choice after the initial choice of starting tree:\u00a0you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop.\nYou have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each.\nWhat is the total amount of fruit you can collect with this procedure?\n\u00a0\nExample 1:\nInput: [1,2,1]\nOutput: 3\nExplanation: We can collect [1,2,1].\n\n\nExample 2:\nInput: [0,1,2,2]\nOutput: 3\nExplanation: We can collect [1,2,2].\nIf we started at the first tree, we would only collect [0, 1].\n\n\nExample 3:\nInput: [1,2,3,2,2]\nOutput: 4\nExplanation: We can collect [2,3,2,2].\nIf we started at the first tree, we would only collect [1, 2].\n\n\nExample 4:\nInput: [3,3,3,1,2,1,1,2,3,3,4]\nOutput: 5\nExplanation: We can collect [1,2,1,1,2].\nIf we started at the first tree or the eighth tree, we would only collect 4 fruits.\n\n\u00a0\n\n\n\nNote:\n\n1 <= tree.length <= 40000\n0 <= tree[i] < tree.length", "solutions": "[\"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        prior_fruit = tree[0]\\n        prior_fruit_counter = 0\\n        fruits_in_basket = [tree[0]]\\n        fruits_in_basket_counter = 0\\n        max_fib = -1\\n        for fruit in tree: \\n            if prior_fruit == fruit:\\n                prior_fruit_counter += 1\\n                fruits_in_basket_counter += 1\\n            elif prior_fruit != fruit:\\n                if fruit in fruits_in_basket:\\n                    fruits_in_basket_counter += 1\\n                else:\\n                    fruits_in_basket, fruits_in_basket_counter = [prior_fruit, fruit], prior_fruit_counter + 1\\n                prior_fruit, prior_fruit_counter = fruit, 1\\n            if fruits_in_basket_counter > max_fib:\\n                max_fib = fruits_in_basket_counter\\n        return max_fib\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        best_so_far = start = 0\\n        fruit_1 = fruit_2 = fruit_1_last_index = fruit_2_last_index = None\\n        \\n        for end in range(len(tree)):\\n            if fruit_1 is None:\\n                fruit_1 = tree[end]\\n                fruit_1_last_index = end\\n                \\n            elif fruit_2 is None and tree[end] != fruit_1:\\n                fruit_2 = tree[end]\\n                fruit_2_last_index = end\\n                \\n            else:\\n                if tree[end] == fruit_1:\\n                    fruit_1_last_index = end\\n                elif tree[end] == fruit_2:\\n                    fruit_2_last_index = end\\n                else:\\n                    best_so_far = max(best_so_far, end - start)\\n                    \\n                    if fruit_1_last_index < fruit_2_last_index:\\n                        start = fruit_1_last_index + 1\\n                        fruit_1 = tree[end]\\n                        fruit_1_last_index = end\\n                    else:\\n                        start = fruit_2_last_index + 1\\n                        fruit_2 = tree[end]\\n                        fruit_2_last_index = end\\n        \\n        return max(best_so_far, len(tree) - start)\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        q = []\\n        ans = -99999999999\\n        s = 0\\n        e = s\\n        while e<len(tree):\\n            if tree[e] not in q:\\n                if len(q)<2:\\n                    q.append(tree[e])\\n                else:\\n                    if e-s > ans:\\n                        ans = e-s\\n                    i = e-1\\n                    while tree[i] == tree[e-1] and i>-1:\\n                        i -= 1\\n                    s = i+1\\n                    q.clear()\\n                    q.append(tree[s])\\n                    q.append(tree[e])\\n                \\n            e += 1\\n        \\n        if e-s > ans:\\n            ans = e-s\\n        \\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        tran_ptr = 0\\n        maxlist = []\\n        \\n        while True:\\n            scan_ptr = tran_ptr\\n            count = 0\\n            types = []\\n            \\n            # Scan pointer reaches the end of tree[]\\n            # or until finding 3rd type of fruit\\n            while True:\\n                if tree[scan_ptr] in types:\\n                    count += 1\\n                elif len(types) == 0:\\n                    types.append(tree[scan_ptr])\\n                    count += 1\\n                elif len(types) == 1:\\n                    tran_ptr = scan_ptr\\n                    types.append(tree[scan_ptr])\\n                    count += 1\\n                else: # New type of fruit and types are full\\n                    break\\n                scan_ptr += 1\\n                if scan_ptr == len(tree):\\n                    break\\n            maxlist.append(count)\\n            \\n            if scan_ptr == len(tree):\\n                break\\n        \\n        return max(maxlist)\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        window = collections.Counter()\\n        ans = 0\\n        \\n        left = 0\\n        for right in range(len(tree)):\\n            window[tree[right]] += 1\\n            while len(window) > 2:\\n                window[tree[left]] -= 1\\n                if window[tree[left]] == 0:\\n                    del window[tree[left]]\\n                left += 1\\n                \\n            ans = max(ans, sum(window.values()))\\n            \\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        maxi=0\\n        if len(tree)==1:\\n            return 1\\n        l=[]\\n        s=set()\\n        for i in range(len(tree)):\\n            l.append(tree[i])\\n            s.add(tree[i])\\n            if len(s)>2:\\n                #l=l[::-1]\\n                while len(set(l))>2:\\n                    #l.pop()\\n                    l=l[1:]\\n                #l=l[::-1]\\n            maxi=max(maxi,len(l))\\n        return maxi\\n        \\n#         maxi=0\\n#         if len(tree)==1:\\n#             return 1\\n            \\n#         for i in range(len(tree)):\\n#             s=set()\\n#             s.add(tree[i])\\n#             for j in range(i+1,len(tree)):\\n#                 s.add(tree[j])\\n#                 if len(s)>2:\\n#                     break\\n#                 maxi=max(maxi,j-i+1)\\n#         return maxi\\n        \\n        # for i in range(len(tree),0,-1):\\n        #     start=0\\n        #     end=i\\n        #     for j in range(len(tree)-i+1):\\n        #         s=tree[start:end]\\n        #         start+=1\\n        #         end+=1\\n        #         if len(set(s))<=2:\\n        #             return i\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        res = 0\\n        max_elem_count = 0\\n        window = {}\\n        start = 0\\n        \\n        l = len(tree)\\n        for end in range(l):\\n            if tree[end] in window:\\n                window[tree[end]] += 1\\n            else:\\n                window[tree[end]] = 1\\n            max_elem_count = max(max_elem_count, window[tree[end]])\\n            \\n            while len(window) > 2:\\n                window[tree[start]] -= 1\\n                if window[tree[start]] == 0:\\n                    window.pop(tree[start])\\n                start += 1\\n                \\n            res = max(res, end - start + 1)\\n        \\n        return res\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        # find the largest region using only two numbers..\\n        # sliding window may do the trick here\\n        # use a dictionary to keep track of the fruits/ how many types you have .. or just use two baskekts\\n        import collections\\n        fruits = collections.defaultdict(int)\\n        # only put something in the basket if it's empty\\n        max_len = 0\\n        front = back = 0\\n        while back < len(tree):\\n            if len(list(fruits.keys())) <= 2:\\n                fruits[tree[back]] += 1\\n                back += 1\\n            else:\\n                fruits[tree[front]] -= 1\\n                if fruits[tree[front]] == 0:\\n                    del fruits[tree[front]]\\n                front += 1\\n            if len(list(fruits.keys())) <= 2:\\n                max_len = max(max_len, back-front)\\n        return max_len\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if not tree:\\n            return 0\\n        \\n        max_count = 1\\n        basket = {tree[0]: 1}\\n        i = 0\\n        for j in range(1, len(tree)):\\n            basket[tree[j]] = basket.get(tree[j], 0) + 1\\n            while (len(basket) > 2):\\n                # remove tree[i], decrement i\\n                basket[tree[i]] = basket.get(tree[i], 0) - 1\\n                if (basket[tree[i]] == 0):\\n                    basket.pop(tree[i])\\n                i += 1\\n            curr_count = sum(basket.values())\\n            max_count = max(max_count, curr_count)\\n        \\n        return max_count\\n        \\n            \\n        \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n\\n        p1 = 0\\n        p2 = 0\\n        counter = 0\\n        mx = 0\\n        mmap = {}\\n        uniq = set()\\n        while p2 < len(tree):\\n            if len(uniq) > 2:\\n                # remove here\\n                mmap[tree[p1]] -= 1\\n                if mmap[tree[p1]] == 0:\\n                    uniq.remove(tree[p1])\\n                    \\n                p1 += 1\\n                #print(mmap, uniq, p1, p2)\\n            else:\\n                # add here\\n                if tree[p2] in mmap:\\n                    mmap[tree[p2]] += 1\\n                else:\\n                    mmap[tree[p2]] = 1\\n                    \\n                uniq.add(tree[p2])\\n                if len(uniq) <= 2:\\n                    counter = p2 - p1 + 1\\n                mx = max(mx, counter)  \\n                p2 += 1\\n                \\n                \\n        return mx\\n                \\n            \\n    \\n            \\n            \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if len(set(tree))<=2:\\n            return len(tree)\\n        res = cur = count_b = a = b = 0\\n\\n        for c in tree:\\n            cur = cur + 1 if c in (a, b) else count_b + 1\\n            count_b = count_b + 1 if c == b else 1\\n            if b != c: a, b = b, c\\n            res = max(res, cur)\\n        return res\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        fruit_types = collections.Counter()\\n        max_fruit = 0\\n        \\n        start_idx = 0\\n        end_idx = 0\\n        \\n        # Move end pointer forward\\n        while end_idx < len(tree):\\n            fruit_types[tree[end_idx]] += 1\\n            \\n            # Move start pointer forward\\n            while len(fruit_types) > 2:\\n                fruit_types[tree[start_idx]] -= 1\\n                if fruit_types[tree[start_idx]] == 0:\\n                    del fruit_types[tree[start_idx]]\\n                start_idx += 1\\n                \\n            max_fruit = max(max_fruit, sum(fruit_types.values()))\\n            \\n            end_idx += 1\\n        \\n        return max_fruit\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        #You want a basket that can get both. \\n        total_fruits = collections.defaultdict(int)\\n        unique_baskets = 0\\n        max_fruit_types = 0 \\n        start = 0\\n        for end in range(len(tree)):\\n            cur_fruit = tree[end]\\n            total_fruits[cur_fruit] += 1 \\n            if total_fruits[cur_fruit] == 1: #then we know there is a unique fruit here\\n                unique_baskets += 1 \\n                \\n            while unique_baskets >= 3: \\n                start_fruit = tree[start]\\n                total_fruits[start_fruit] -= 1\\n                if not total_fruits: #this means that we have less unique baskets now \\n                    unique_baskets -= 1 \\n                start += 1\\n                    \\n            max_fruit_types = max(max_fruit_types, end - start + 1)\\n            \\n        return max_fruit_types\\n            \\n#         #Start at ANY tree of my choice \\n#         #Then perform the steps \\n# #         1) Add one fruit from the tree to basket. If you can't you stp \\n# #         2) Move to the next tree to the RIGHT of the current tree if there is no such tree you stop. \\n        \\n#     #So you reset back to step 1 after you're done. \\n#     #So this means that once you're done and because we want to GET all possible fruits through your positions \\n# #         WANT: Total amount of fruit collected \\n#         last_fruit = -1 \\n#         second_last_fruit = -1 \\n#         last_fruit_count = 0\\n#         total_fruits = 0 \\n#         cur_fruits_max = 0 \\n#         #Let's call prev fruits \\n#         #last_fruit, second_last_fruit \\n#         # fruit is our CURRENT fruit \\n        \\n#         #So we have 2 prev fruit and current fruit.  \\n#         #If fruit is the second_last_fruit \\n#         #We will know \\n#         for fruit in tree: \\n#             if fruit == last_fruit or fruit == second_last_fruit: \\n#                 cur_fruits_max += 1 \\n                \\n#             else: \\n#                 cur_fruits_max = last_fruit_count + 1 #this means we picked you new fruit \\n                \\n     \\n#             #You need to check fruit with last fruit not second to last fruit since last fruit will be your \\\\\\\"best case scenario\\\\\\\"\\n#             if fruit == last_fruit: \\n#                 last_fruit_count += 1 \\n#             else: \\n#                 last_fruit_count = 1 #never been seen before (base case)\\n            \\n#             #This means that we'd be double counting if we moved you beforehand \\n#             if fruit != last_fruit: #meaning your a second_last_fruit basically \\n#                 second_last_fruit = last_fruit \\n#                 last_fruit = fruit \\n                \\n#             total_fruits = max(total_fruits, cur_fruits_max)\\n            \\n#         print(total_fruits)\\n#         # (O(N)) run time \\n#         return total_fruits \\nclass Solution():\\n    def totalFruit(self, tree):\\n        fruit_basket = collections.defaultdict(int)\\n        unique_fruits = 0 \\n        total_fruits = 0 \\n        start = 0\\n        end = 0 \\n        for end in range(len(tree)): \\n            type_of_fruit = tree[end]\\n            fruit_basket[type_of_fruit] += 1 #Defaultdict so if not there instantiate it and add one \\n            #small check to count it one time for the fruit \\n            if fruit_basket[type_of_fruit] == 1: \\n                unique_fruits += 1 \\n                \\n            while unique_fruits > 2:\\n                start_fruit = tree[start]\\n                fruit_basket[start_fruit] -= 1 \\n                if not fruit_basket[start_fruit]: #meaning it's empty \\n                    unique_fruits -= 1 \\n                start += 1 \\n            total_fruits = max(total_fruits, end - start + 1)\\n        return total_fruits\\n        \\n#Map Way   \\n# import collections\\n# class Solution():\\n#     def totalFruit(self, tree):\\n#         count = collections.defaultdict(int)\\n#         unique = res = end = start = 0\\n#         while end < len(tree):\\n#             count[tree[end]] += 1\\n#             if count[tree[end]] == 1: unique+=1\\n#             while unique > 2:\\n#                 count[tree[start]] -= 1\\n#                 if not count[tree[start]]: \\n#                     unique -= 1\\n#                 start += 1\\n#             res = max(res, end - start + 1)\\n#             end += 1\\n#         return res\\n            \\n                \\n        \\n        \\n        \\n            \\n            \\n            \\n\\n\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        ans, j = 0,0\\n        n = len(tree)\\n        dic = {}\\n        for i in range(n):\\n            dic[tree[i]] = i\\n            #print(dic, ans)\\n            if len(dic) > 2:\\n                ans = max(ans, i-j)\\n                k = None\\n                for key in dic:\\n                    if key != tree[i] and key !=tree[i-1]:\\n                        k = key\\n                        j = dic[key]+1\\n                del dic[k]\\n                \\n        return max(ans, n-j)\\n                \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        nTrees, ans = len(tree), 0\\n        if len(set(tree)) <= 2:\\n            return nTrees\\n        i, j = 0,1\\n        while i < j and j < nTrees:\\n            if len(set(tree[i:j+1])) <= 2:\\n                j += 1\\n                ans = max(ans, j-i)\\n            else:\\n                i+= 1\\n        return ans\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        i = 0\\n        count = collections.Counter()\\n        for index, value in enumerate(tree):\\n            count[value] += 1\\n            if len(count) > 2:\\n                count[tree[i]] -= 1\\n                if count[tree[i]] == 0:\\n                    del count[tree[i]]\\n                i +=1\\n        return len(tree) - i\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        '''\\n        Using sliding window, keep track of the longest window length where unique fruit types <= 2\\n        the max window will be the answer\\n        '''\\n        left = 0\\n        n = len(tree)\\n        ans = 0\\n        basket = set()\\n        counter = collections.Counter()\\n        for right, fruit in enumerate(tree):\\n            basket.add(fruit)\\n            counter[fruit] += 1\\n            while len(basket) > 2:\\n                counter[tree[left]] -= 1\\n                if counter[tree[left]] == 0:\\n                    basket.remove(tree[left])\\n                left += 1\\n            ans = max(ans, right-left+1)\\n        return ans\\n        \\n        # # Recursive\\n        # memo = {}\\n        # def collect(index, basket=[]):\\n        #     if index == len(tree):\\n        #         return 0\\n        #     # if (index, set(basket)) \\n        #     take = 0\\n        #     if len(basket) < 2 or (tree[index] in basket):\\n        #         take = collect(index+1, basket+[tree[index]]) + 1\\n        #     skip = 0\\n        #     if len(basket) < 2:\\n        #         skip = collect(index+1, basket)\\n        #     return max(take, skip)\\n        # return collect(0)                        \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        ans = i = 0\\n        count = collections.Counter()\\n        for j, x in enumerate(tree):\\n            count[x] += 1\\n            while len(count) >= 3:\\n                count[tree[i]] -= 1\\n                if count[tree[i]] == 0:\\n                    del count[tree[i]]\\n                i += 1\\n            ans = max(ans, j - i + 1)\\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        # Goal is to find longest continuous subsequence containing only 2 types\\n        ans = i = 0\\n        count = Counter()\\n        for j, t in enumerate(tree):\\n            count[t] += 1\\n            while len(count) > 2:\\n                count[tree[i]] -= 1\\n                if count[tree[i]] == 0:\\n                    del count[tree[i]]\\n                i += 1\\n\\n            ans = max(ans, j - i + 1)\\n        return ans\\n\", \"class Solution(object):\\n    def totalFruit(self, tree):\\n        ans = i = 0\\n        count = collections.Counter()\\n        for j, x in enumerate(tree):\\n            count[x] += 1\\n            while len(count) >= 3:\\n                count[tree[i]] -= 1\\n                if count[tree[i]] == 0:\\n                    del count[tree[i]]\\n                i += 1\\n            ans = max(ans, j - i + 1)\\n        return ans\", \"class Solution:\\n     def totalFruit(self, tree: List[int]) -> int:\\n            start = 0\\n            max = 0\\n            reset = 0\\n            baskets ={1: [None, 0], 2: [None, 0]}\\n            while start < len(tree) and start >= 0:\\n                if baskets[1][0] == None:\\n                    baskets[1][0] = tree[start]\\n                    baskets[1][1] += 1\\n                    while reset and start > 0:\\n                        if baskets[1][0] != tree[start -1]:\\n                            reset = 0\\n                        else:\\n                            start -= 1\\n                elif baskets[1][0] == tree[start]:\\n                    baskets[1][1] += 1\\n                elif baskets[2][0] == None:\\n                    baskets[2][0] = tree[start]\\n                    baskets[2][1] += 1\\n                elif baskets[2][0] == tree[start]:\\n                    baskets[2][1] += 1\\n                else:\\n                    if max < baskets[1][1]+ baskets[2][1]:\\n                        print((baskets,start))\\n                    baskets ={1: [None, 0], 2: [None, 0]}\\n                    reset  = 1\\n                if reset == 1:\\n                    if start > 0:\\n                        start -= 1\\n                else:\\n                    start += 1\\n                if max < baskets[1][1]+ baskets[2][1]:\\n                    max  =  baskets[1][1]+ baskets[2][1]\\n            return max\\n        \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        finalMax = currentMax = last = secondLast = lastCount = 0\\n\\n        for fruit in tree:\\n            if fruit == last or fruit == secondLast:\\n                currentMax += 1\\n            else:\\n                currentMax = lastCount + 1\\n\\n            if fruit == last:\\n                lastCount += 1\\n            else:\\n                secondLast = last\\n                last = fruit\\n                lastCount = 1\\n\\n            finalMax = max(finalMax, currentMax)\\n\\n        return finalMax\\n\\n\", \"from collections import Counter\\n\\nclass Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        \\n        max_fruits = 0\\n        window_start = 0\\n        freq = Counter()\\n        for i, val in enumerate(tree):\\n            freq[val] += 1\\n            while len(freq) > 2:\\n                to_delete = tree[window_start]\\n                freq[to_delete] -= 1\\n                if not freq[to_delete]:\\n                    del freq[to_delete]\\n                window_start += 1\\n            max_fruits = max(max_fruits, i - window_start + 1)\\n        return max_fruits\", \"class Solution:\\n    def totalFruit(self, trees: List[int]) -> int:\\n        \\n        if len(trees) <= 2:\\n            return len(trees)\\n        \\n        lp = 0\\n        rp = 1\\n        maxSize = 0\\n        hash = collections.defaultdict(int)\\n        lpInc = False\\n        rpInc = False\\n        curSet = set()\\n        \\n        # Start the left and right pointer values at 1 frequency. Use += 1 in case trees[lp] and trees[rp] point to the same value.\\n        hash[trees[lp]] += 1\\n        curSet.add(trees[lp])\\n        hash[trees[rp]] += 1\\n        curSet.add(trees[rp])\\n        \\n        while rp < len(trees):\\n            if lpInc:\\n                hash[trees[lp-1]] = max(hash[trees[lp-1]]-1, 0)\\n                if hash[trees[lp-1]] > 0:\\n                    curSet.add(trees[lp-1])\\n                else:\\n                    curSet.remove(trees[lp-1])\\n            if rpInc:\\n                hash[trees[rp]] += 1\\n                curSet.add(trees[rp])\\n                \\n            lpInc = False\\n            rpInc = False\\n            \\n            if len(curSet) <= 2:\\n                if (rp - lp) + 1 > maxSize:\\n                    maxSize = (rp - lp) + 1\\n                    \\n            if len(curSet) > 2:\\n                lp += 1\\n                lpInc = True\\n            else:\\n                rp += 1\\n                rpInc = True\\n        \\n        return maxSize\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        i = 0\\n        j = 0\\n        hm = {}\\n        maxL = 0\\n        while j < len(tree):\\n            if tree[j] in hm:\\n                hm[tree[j]] += 1\\n            else:\\n                if len(hm)<2:\\n                    hm[tree[j]] = 1\\n                else:\\n                    maxL = max(maxL, j-i)\\n                    while i<j and len(hm)>1:\\n                        hm[tree[i]] -= 1\\n                        if hm[tree[i]] == 0:\\n                            del hm[tree[i]]\\n                        i += 1\\n                    hm[tree[j]] = 1\\n\\n            j += 1\\n\\n        maxL = max(maxL,j-i)\\n        return maxL\\n\", \"from collections import Counter\\n\\nclass Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        baskets = Counter()\\n        max_fr = 0\\n        i = 0\\n        \\n        for j, t in enumerate(tree):\\n            baskets[t] += 1\\n            \\n            while len(baskets) > 2:\\n                baskets[tree[i]] -= 1\\n                if baskets[tree[i]] == 0:\\n                    del baskets[tree[i]]\\n                \\n                i += 1\\n            \\n            max_fr = max(max_fr, j - i + 1)\\n        \\n        return max_fr\\n\\n# class Solution:\\n\\n#     def totalFruit(self, tree):\\n#         count, i = {}, 0\\n#         for j, v in enumerate(tree):\\n#             count[v] = count.get(v, 0) + 1\\n#             if len(count) > 2:\\n#                 count[tree[i]] -= 1\\n#                 if count[tree[i]] == 0: del count[tree[i]]\\n#                 i += 1\\n#         return j - i + 1\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        \\n        fruitCap = [0] * len(tree)\\n        fruitCap[-1] = 1\\n        \\n        fruitA = tree[-1]\\n        fruitB = None\\n        for i in reversed(list(range(len(tree) - 1))):\\n            if tree[i] == fruitA or tree[i] == fruitB:\\n                fruitCap[i] = fruitCap[i + 1] + 1\\n            elif fruitB == None:\\n                fruitCap[i] = fruitCap[i + 1] + 1\\n                fruitB = tree[i]\\n            else:\\n                fruitA = tree[i]\\n                fruitB = tree[i + 1]\\n                fruitCap[i] = getConsecutive(tree, i + 1) + 1\\n        \\n        print(fruitCap)\\n        return max(fruitCap)\\n    \\ndef getConsecutive(tree, index):\\n    \\n    consecutive = 0\\n    fruit = tree[index]\\n    for i in range(index, len(tree)):\\n        if tree[i] == fruit:\\n            consecutive += 1\\n        else:\\n            break\\n    \\n    return consecutive\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        #tree = [0,1,6,6,4,4,6]\\n        max_fruits = 0\\n        counter = 0\\n        fruit_basket = set()\\n        i = 0\\n        while i < len(tree):\\n            if len(fruit_basket) < 2 :\\n                counter += 1\\n                fruit_basket.add(tree[i])\\n                if len(fruit_basket) == 2:\\n                    new_fruit_idx = i\\n            elif tree[i] in fruit_basket:\\n                counter += 1\\n            else:\\n                fruit_basket = set()\\n                max_fruits = max(counter,max_fruits)\\n                counter = 0\\n                i = new_fruit_idx - 1\\n            i += 1\\n        max_fruits = max(counter,max_fruits)\\n        return max_fruits\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        max_ = 0\\n        baskets = {}\\n        \\n        def get_other_tree(this_tree):\\n            trees = list(baskets.keys())\\n            return trees[1 - trees.index(this_tree)] if len(trees) == 2 else trees[0]\\n        \\n        for idx, tr in enumerate(tree):\\n            need_to_empty_1_basket = tr not in baskets and len(baskets) == 2\\n            if need_to_empty_1_basket:\\n                max_ = max(max_, sum(sum(baskets[b]) for b in baskets))\\n                last_tree = tree[idx - 1]\\n                other_tree = get_other_tree(last_tree)\\n                baskets = {last_tree: [baskets[last_tree][1], 0], tr: [0, 1]}\\n            else:\\n                there_is_another_tree = (tr not in baskets and len(baskets) == 1) or (tr in baskets and len(baskets) == 2)\\n                if there_is_another_tree:\\n                    other_tree = get_other_tree(tr)\\n                    baskets[other_tree] = [sum(baskets[other_tree]), 0]\\n\\n                if tr not in baskets:\\n                    baskets[tr] = [0, 0]\\n                baskets[tr][1] += 1\\n                \\n        return max(max_, sum(sum(baskets[b]) for b in baskets))\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if not tree or len(tree) == 0:\\n            return 0\\n        max_ = 1\\n        mem = {}\\n        i,j = 0,0\\n        while j<len(tree):\\n            if len(mem) <=2:\\n                mem[tree[j]] = j\\n                j += 1\\n            if len(mem) > 2:\\n                min_ = len(tree) - 1\\n                for value in mem.values():\\n                    min_ = min(min_,value)\\n                i = min_ + 1\\n                del mem[tree[min_]]\\n            max_ = max(max_,j-i)\\n            \\n        return max_\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        max_ = 0\\n        baskets = {}\\n        \\n        def get_other_tree(this_tree):\\n            trees = list(baskets.keys())\\n            return trees[1 - trees.index(this_tree)] if len(trees) == 2 else trees[0]\\n        \\n        for idx, tr in enumerate(tree):\\n            if tr not in baskets and len(baskets) == 2:\\n                max_ = max(max_, sum(sum(baskets[b]) for b in baskets))\\n                last_tree = tree[idx - 1]\\n                other_tree = get_other_tree(last_tree)\\n                baskets = {last_tree: [baskets[last_tree][1], 0], tr: [0, 1]}\\n            else:\\n                there_is_another_tree = (tr not in baskets and len(baskets) == 1) or (tr in baskets and len(baskets) == 2)\\n                if there_is_another_tree:\\n                    other_tree = get_other_tree(tr)\\n                    baskets[other_tree] = [sum(baskets[other_tree]), 0]\\n\\n                if tr not in baskets:\\n                    baskets[tr] = [0, 0]\\n                baskets[tr][1] += 1\\n                \\n        return max(max_, sum(sum(baskets[b]) for b in baskets))\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        pre=-1\\n        ans=a=b=0\\n        x=y=-1\\n        for cur in tree:\\n            if cur!=x and cur!=y:\\n                x,y=pre,cur\\n                a,b=b,1\\n            elif cur==pre:\\n                b+=1\\n            else:\\n                a+=b\\n                b=1\\n            if a+b>ans:\\n                ans=a+b\\n            pre=cur\\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        # need to identify longest streak of two unique types of fruit\\n        \\n        # brute force \\n        # \\n        # loop i \\n        #   \\n        #   loop j\\n        #       if dict < 2 then add unique character to dict\\n        #       if num encountered is not in dict and dict.len == 2 then break\\n        #  check if the counter > max if it is then set max to counter\\n        \\n#         answer = 0\\n#         counter = 0\\n#         dictionary = {}\\n#         # print(tree)\\n#         for i in range(len(tree)):\\n#             for j in range(i, len(tree)):\\n#                 # print('curr', tree[j], i, j)\\n#                 if tree[j] in dictionary:\\n#                     counter += 1\\n#                 elif tree[j] not in dictionary and len(dictionary) < 2:\\n#                     counter += 1\\n#                     dictionary[tree[j]] = tree[j]\\n#                 elif tree[j] not in dictionary and len(dictionary) == 2:\\n#                     break\\n#             # print('round done')\\n#             if counter > answer:\\n#                 answer = counter\\n#                 # print('reassigning answer', answer)\\n#             counter = 0\\n#             dictionary = {}\\n                \\n#         return answer\\n\\n        # something faster\\n    \\n        answer = 0 \\n        currTree = 0\\n        numsDictionary = collections.Counter()\\n        \\n        for treeIndex, fruit in enumerate(tree):\\n            numsDictionary[fruit] += 1\\n            while len(numsDictionary) >= 3:\\n                numsDictionary[tree[currTree]] -= 1\\n                if numsDictionary[tree[currTree]] == 0:\\n                    del numsDictionary[tree[currTree]]\\n                currTree += 1\\n            answer = max(answer, treeIndex - currTree + 1 )\\n        return answer\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        i=0\\n        counter={}\\n        res=0\\n        for j, v in enumerate(tree):\\n            counter[v]=counter.get(v,0)+1\\n            while len(counter)>2:\\n                counter[tree[i]]-=1\\n                if not counter[tree[i]]: \\n                    del counter[tree[i]]\\n                i+=1\\n            res=max(res, j-i+1)\\n        return res\\n                \\n                \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        i = 0\\n        next_start_pos = None\\n        max_len = 0\\n        s = set()\\n        res = []\\n        while i < len(tree):\\n            if tree[i] in s:\\n                max_len += 1\\n                i += 1\\n            else:\\n                if len(s) == 0:\\n                    s.add(tree[i])\\n                    max_len += 1\\n                    i += 1\\n                elif len(s) == 1:\\n                    s.add(tree[i])\\n                    max_len += 1\\n                    next_start_pos = i\\n                    i += 1\\n                elif len(s) == 2:\\n                    res.append(max_len)\\n                    max_len = 0\\n                    s = set()\\n                    i = next_start_pos\\n                    \\n        res.append(max_len)\\n        return max(res)\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        max_ = 0\\n        baskets = {}\\n        \\n        def get_other_tree(this_tree):\\n            trees = list(baskets.keys())\\n            return trees[1 - trees.index(this_tree)] if len(trees) == 2 else trees[0]\\n        \\n        for idx, tr in enumerate(tree):\\n            need_to_empty_1_basket = tr not in baskets and len(baskets) == 2\\n            if need_to_empty_1_basket:\\n                max_ = max(max_, sum(sum(counts) for counts in list(baskets.values())))\\n                last_tree = tree[idx - 1]\\n                other_tree = get_other_tree(last_tree)\\n                baskets = {last_tree: [baskets[last_tree][1], 0], tr: [0, 1]}\\n            else:\\n                there_is_another_tree = (tr not in baskets and len(baskets) == 1) or (tr in baskets and len(baskets) == 2)\\n                if there_is_another_tree:\\n                    other_tree = get_other_tree(tr)\\n                    baskets[other_tree] = [sum(baskets[other_tree]), 0]\\n\\n                if tr not in baskets:\\n                    baskets[tr] = [0, 0]\\n                baskets[tr][1] += 1\\n                \\n        return max(max_, sum(sum(counts) for counts in list(baskets.values())))\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        left,right=-1,0\\n        seen = Counter()\\n        ans = 0\\n        while left<=right<len(tree):\\n            while right<len(tree) and (len(seen) < 2 or tree[right]in seen):\\n                seen[tree[right]]+=1\\n                right+=1\\n                \\n            ans = max(ans,right-left-1) #-1?\\n\\n            left+=1\\n            seen[tree[left]]-=1\\n            if seen[tree[left]]==0:\\n                del seen[tree[left]]\\n                \\n        return ans\", \"class Solution(object):\\n    def totalFruit(self, nums):\\n        d = {}\\n        k = 2\\n        maxL = 0\\n        L = 0\\n        \\n        for R in range(len(nums)):\\n            if nums[R] in d:\\n                d[nums[R]] += 1\\n            else:\\n                d[nums[R]] = 1\\n            while len(d) > k:\\n                d[nums[L]] -= 1\\n                if d[nums[L]] == 0:\\n                    del d[nums[L]]\\n                L+=1\\n            maxL = max(maxL, R-L+1)\\n        return maxL\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        maxi=0\\n        if len(tree)==1:\\n            return 1\\n        l=[]\\n        s=set()\\n        for i in range(len(tree)):\\n            l.append(tree[i])\\n            s.add(tree[i])\\n            if len(s)>2:\\n                l=l[::-1]\\n                while len(set(l))>2:\\n                    l.pop()\\n                l=l[::-1]\\n            maxi=max(maxi,len(l))\\n        return maxi\\n        \\n#         maxi=0\\n#         if len(tree)==1:\\n#             return 1\\n            \\n#         for i in range(len(tree)):\\n#             s=set()\\n#             s.add(tree[i])\\n#             for j in range(i+1,len(tree)):\\n#                 s.add(tree[j])\\n#                 if len(s)>2:\\n#                     break\\n#                 maxi=max(maxi,j-i+1)\\n#         return maxi\\n        \\n        # for i in range(len(tree),0,-1):\\n        #     start=0\\n        #     end=i\\n        #     for j in range(len(tree)-i+1):\\n        #         s=tree[start:end]\\n        #         start+=1\\n        #         end+=1\\n        #         if len(set(s))<=2:\\n        #             return i\\n\", \"class Track(object):\\n    def __init__(self, n = 2):\\n        # Maps the values to their counts\\n        self.count = {}\\n        \\n        # Keeps track of the last element\\n        self.last = {}\\n        self.order = [None for _ in range(n - 1)]\\n        \\n    def is_new_elem(self, elem):\\n        return elem not in self.count\\n    \\n    def is_last_elem(self, elem):\\n        return elem in self.last\\n    \\n    def add(self, elem):\\n        if self.is_new_elem(elem):\\n            self.count = {elem: 1}\\n            for key, val in self.last.items():\\n                self.count[key] = val\\n        else:\\n            self.count[elem] += 1\\n                \\n        if self.is_last_elem(elem):\\n            self.last[elem] += 1\\n        else:\\n            if elem in self.order:\\n                del self.order[self.order.index(elem)]\\n            else:\\n                rem = self.order.pop(0)\\n                if rem is not None:\\n                    del self.last[rem]\\n            \\n            self.last[elem] = 1\\n            self.order.append(elem)\\n        \\n    def get_count(self):\\n        total = 0\\n        for _, val in self.count.items():\\n            total += val\\n        return total\\n        \\nclass Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        tracker = Track()\\n        \\n        max_count = 0\\n        for t in tree:\\n            tracker.add(t)\\n            max_count = max(max_count, tracker.get_count())\\n            \\n        \\n        return max_count\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        \\n        ans= i=0\\n        \\n        basket = {}\\n        \\n        for j, x in enumerate(tree):\\n            \\n            if x in basket:\\n                basket[x] += 1\\n            else:\\n                basket[x] = 1\\n                \\n            while len(basket)>=3:\\n                \\n                basket[tree[i]] -= 1\\n                \\n                if basket[tree[i]] == 0:\\n                    \\n                    del basket[tree[i]]\\n                \\n                i += 1\\n                \\n            ans = max(ans, j-i+1)\\n                \\n        return ans\\n\", \"class Solution:\\n    def totalFruit(self, tree) -> int:\\n        unit_first=tree[0]\\n        unit_second=-1\\n        amount_first=0\\n        amount_second=0\\n        max_amount=0\\n        prev=tree[0]\\n        prev_amount=0\\n        for i in range(len(tree)):\\n            if(tree[i] == prev):\\n                prev_amount+=1\\n            \\n            if(tree[i] == unit_first):\\n                amount_first+=1\\n            elif(tree[i] == unit_second):\\n                amount_second+=1\\n            else:\\n                max_amount = max(max_amount,(amount_first+amount_second))\\n                unit_first=prev\\n                amount_first=prev_amount\\n                unit_second=tree[i]\\n                amount_second=1\\n            \\n            if(tree[i] != prev):\\n                prev_amount=1\\n\\n            prev = tree[i]\\n\\n        return max(max_amount,(amount_first+amount_second))\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        b1, b2, b1N, b2N, b2NCons, maxPick = None, None, 0, 0, 0, 0\\n\\n        for fruit in tree:\\n\\n            if fruit == b2:\\n                b2N, b2NCons = b2N + 1, b2NCons + 1\\n\\n            elif fruit == b1:\\n                b1, b2, b1N, b2N, b2NCons = b2, b1, b2N, b1N+1, 1\\n\\n            else:\\n                b1, b2, b1N, b2N, b2NCons = b2, fruit, b2NCons, 1, 1\\n\\n            maxPick = max(maxPick, b1N+b2N)\\n\\n        return maxPick\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        ans = 0\\n        p = 0\\n        while p < len(tree):\\n            acc = 1\\n            first = tree[p]\\n            next_p = len(tree)\\n            second = -1\\n            for i in range(p + 1, len(tree)):\\n                if tree[i] != first:\\n                    if second == -1:\\n                        second = tree[i]\\n                        next_p = i\\n                    elif tree[i] != second:\\n                        break\\n                acc += 1\\n                if i == len(tree) - 1:\\n                    return max(ans, acc)\\n            p = next_p\\n            ans = max(ans, acc)\\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        \\n        type_cnt = {}\\n        max_fruit = -1\\n        left_ptr = 0\\n        last_cnt = 0\\n        while left_ptr < len(tree):\\n            right_ptr = left_ptr\\n            while right_ptr < len(tree) - 1 and tree[right_ptr] == tree[right_ptr + 1]:\\n                right_ptr += 1\\n            curr_type = tree[left_ptr]\\n            curr_cnt = right_ptr - left_ptr + 1\\n                \\n            if curr_type not in type_cnt:\\n                type_cnt[curr_type] = curr_cnt\\n            else:\\n                type_cnt[curr_type] += curr_cnt\\n\\n            if len(type_cnt) > 2:\\n                type_cnt = {last_type: last_cnt, curr_type: curr_cnt}\\n            \\n            max_fruit = max(max_fruit, sum([cnt for cnt in list(type_cnt.values())]))\\n            last_cnt = curr_cnt\\n            last_type = curr_type\\n            left_ptr = right_ptr + 1 \\n        return max_fruit\\n               \\n\", \"from collections import Counter\\n\\nclass Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        num_fruit = Counter()\\n        j, num_type, max_fruit = 0, 0, 0\\n        for i in range( len(tree) ):\\n            if num_fruit[ tree[i] ] == 0: num_type += 1\\n            num_fruit[ tree[i] ] += 1\\n            \\n            if num_type <= 2:\\n                max_fruit = max( i-j+1, max_fruit )\\n            else:\\n                while True:\\n                    num_fruit[ tree[j] ] -= 1\\n                    j += 1\\n                    if num_fruit[ tree[j-1] ] == 0: break\\n                num_type -= 1\\n        \\n        return max_fruit\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        result = 0\\n        collected = {}\\n        i = 0\\n        for j, fruit in enumerate(tree):\\n            collected[fruit] = collected.get(fruit, 0) + 1\\n            while len(collected) > 2:\\n                collected[tree[i]] -= 1\\n                if not collected[tree[i]]:\\n                    collected.pop(tree[i])\\n                i += 1\\n            result = max(result, j - i + 1)\\n        return result\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        ans = i = 0\\n        freq = collections.defaultdict(int)\\n        for j, fruit in enumerate(tree):\\n            freq[fruit] += 1\\n            while len(freq) == 3:\\n                freq[tree[i]] -= 1\\n                if freq[tree[i]] == 0:\\n                    del freq[tree[i]]\\n                i += 1\\n            ans = max(ans, j - i + 1)\\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if len(tree) < 2: return len(tree)\\n        start, end, res = 0, 1, 1\\n        basket = {tree[start]: 1}\\n        while end < len(tree):\\n            if tree[end] in basket:\\n                basket[tree[end]] +=1\\n                end += 1\\n                res = max(res, end-start)\\n            elif len(basket) < 2:\\n                basket[tree[end]] = 1\\n                end += 1\\n                res = max(res, end-start)\\n            else:\\n                basket[tree[start]] -= 1\\n                if basket[tree[start]] == 0:\\n                    del basket[tree[start]]\\n                start += 1\\n        return res\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        '''\\n        sliding window\\n        O(N)\\n        '''           \\n        if len(tree) == 1:\\n            return 1\\n        \\n        l = 0\\n        r = 1\\n        \\n        curr_window = defaultdict(int)\\n        curr_window[tree[l]] += 1 \\n        res = 1\\n        while r < len(tree):                                        \\n            curr_window[tree[r]] += 1\\n            while len(curr_window) > 2:                                    \\n                curr_window[tree[l]] -= 1\\n                if curr_window[tree[l]] == 0:\\n                    del curr_window[tree[l]]\\n                l += 1\\n                                    \\n            if r - l + 1 > res:\\n                res = r - l + 1\\n                \\n            r += 1\\n                \\n        \\n        return res\\n        \\n        \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        \\n        ans = i = 0\\n        count = collections.Counter()\\n        for j, x in enumerate(tree):\\n            count[x] += 1\\n            while len(count) > 2:\\n                count[tree[i]] -= 1\\n                if count[tree[i]] == 0:\\n                    del count[tree[i]]\\n                i += 1\\n            ans = max(j - i + 1, ans)\\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        last_fruit = -1\\n        second_last_fruit = -1\\n        last_fruit_count = 0\\n        current_max = 0\\n        maxi = 0\\n        \\n        for fruit in tree:\\n            if fruit == last_fruit or fruit == second_last_fruit:\\n                current_max+=1\\n            else:\\n                current_max = last_fruit_count + 1\\n                \\n            if fruit == last_fruit:\\n                last_fruit_count += 1\\n            else:\\n                last_fruit_count = 1\\n                \\n            if fruit != last_fruit:\\n                second_last_fruit = last_fruit\\n                last_fruit = fruit\\n                \\n            \\n            maxi = max(current_max, maxi)\\n            \\n        return maxi\", \"from collections import Counter\\nclass Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        res = l = 0\\n        count = Counter()\\n        for r, t in enumerate(tree):\\n            count[t] += 1\\n            while len(count) >= 3:\\n                count[tree[l]] -= 1\\n                if count[tree[l]] == 0:\\n                    del count[tree[l]]\\n                l += 1\\n            res = max(res, r - l + 1)\\n        return res\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        max_length = 0\\n        fruits_frequency = defaultdict(int)\\n        window_start = 0\\n        \\n        for window_end in range(0, len(tree)):\\n            right_fruit = tree[window_end]\\n            fruits_frequency[right_fruit] += 1\\n            \\n            while len(fruits_frequency) > 2:\\n                left_fruit = tree[window_start]\\n                fruits_frequency[left_fruit] -= 1\\n                if fruits_frequency[left_fruit] == 0:\\n                    del fruits_frequency[left_fruit]\\n                    \\n                window_start += 1\\n            max_length = max(max_length, window_end - window_start + 1)\\n            \\n        return max_length\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        count2 = 0\\n        basket = 0\\n        ans = 0\\n        kind1, kind2 = 0, 0\\n        for t in tree:\\n            if t == kind2:\\n                count2 += 1\\n                basket += 1\\n            elif t == kind1:\\n                count2 = 1\\n                basket += 1\\n                kind1, kind2 = kind2, kind1\\n            else:\\n                basket = count2 + 1\\n                count2 = 1\\n                kind1, kind2 = kind2, t\\n            ans = max(ans, basket)\\n        return ans\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        left=ans=0\\n        types=collections.defaultdict(int)\\n        for right in range(len(tree)):\\n            types[tree[right]]+=1\\n            if len(types.keys())<=2:\\n                ans=max(ans,right-left+1)\\n            while len(types.keys())>2:\\n                types[tree[left]]-=1\\n                if types[tree[left]]==0:\\n                    types.pop(tree[left])\\n                left+=1\\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        l, r, ans = 0, 0, 0\\n        counter = Counter()\\n        length = 0\\n        while r < len(tree):\\n            counter[tree[r]] += 1\\n            length = len(counter)\\n            r += 1\\n\\n            while length > 2:\\n                counter[tree[l]] -= 1\\n                if counter[tree[l]] == 0:\\n                    del counter[tree[l]]\\n                    length -= 1\\n                l += 1\\n            ans = max(ans, r - l)\\n        return ans\\n\\n\\n\\n\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        maxStreak = 0\\n        i = 0\\n        types = set()\\n        last_type = 0\\n        streak = 0\\n        while i < len(tree):\\n            if len(types) == 0 or len(types) == 1:\\n                types.add(tree[i])\\n                last_type = i\\n                streak += 1\\n                i += 1\\n            else:\\n                if tree[i] in types:\\n                    if tree[last_type] != tree[i]:\\n                        last_type = i\\n                    streak += 1\\n                    i += 1\\n                else:\\n                    i = last_type\\n                    types = set()\\n                    maxStreak = max(streak, maxStreak)\\n                    streak = 0\\n                    \\n        return max(streak, maxStreak)\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        cnt = 1\\n        max = 1\\n        keys = set([tree[0]])\\n        \\n        spree = [tree[0], 1] # to hold the numberof fruits before a switch\\n        \\n        for k in range(1, len(tree)):\\n            if tree[k] in keys:\\n                cnt += 1\\n                if tree[k] == spree[0]:\\n                    spree[1] +=1\\n                else:\\n                    spree = [tree[k], 1]\\n            elif len(keys)==1: # if the 1st tree is the same as the following...\\n                keys.add(tree[k])\\n                cnt +=1\\n                spree = [tree[k], 1]\\n            else:\\n                if cnt > max:\\n                    max = cnt\\n                keys = set([tree[k-1], tree[k]])\\n                cnt = spree[1] + 1 #reset counter\\n                spree = [tree[k], 1]\\n  \\n        if cnt > max:\\n            max = cnt\\n        return max\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        start = 0\\n        end = 1\\n        maxLength = 1\\n        types = {}\\n        types[tree[0]] = 1\\n        \\n        if len(tree) <= 2:\\n            return len(tree)\\n        \\n        while end < len(tree) - 1 or start < end:\\n            if end < len(tree)-1 and len(types) < 2:                \\n                if types.get(tree[end]):\\n                    types[tree[end]] += 1\\n                else:\\n                    types[tree[end]] = 1\\n                \\n                end += 1\\n            elif end == len(tree) or types.get(tree[end]) == None:\\n                types[tree[start]] -= 1\\n                \\n                if types[tree[start]] == 0:\\n                    del types[tree[start]]\\n                \\n                start += 1           \\n            else:                \\n                if types.get(tree[end]):\\n                    types[tree[end]] += 1\\n                else:\\n                    types[tree[end]] = 1\\n                    \\n                end += 1\\n                \\n            if len(types) <= 2:\\n                maxLength = max(maxLength, end-start)\\n            \\n        return maxLength\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if(len(tree)<=1):\\n            return len(tree)\\n        if(len(list(set(tree))) == 2):\\n            return len(tree)\\n        maxCount = 0\\n        classes = []\\n        i = 0\\n        while(i < len(tree)):\\n            j = i + 1\\n            classes = [tree[i]]\\n            count = 1\\n            secFruitStart = -1\\n            while(len(classes) <= 2 and j < len(tree)):\\n                if(tree[j] not in classes):\\n                    classes.append(tree[j])\\n                    if(len(classes) == 2):\\n                        secFruitStart = j\\n                if(len(classes) == 3):\\n                    continue\\n                count = count + 1\\n                j = j + 1\\n            if(count > maxCount):\\n                maxCount = count\\n            if(secFruitStart != -1):\\n                i = secFruitStart\\n            else:\\n                break\\n        return maxCount\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        #max contiguous sum with 2 different types of elements\\n        \\n        start = 0\\n        end = 0\\n        le = len(tree)\\n        hmap = collections.defaultdict(int)\\n        count = 0\\n        res = 0\\n        \\n        while end < le:\\n            \\n            hmap[tree[end]] += 1\\n            if hmap[tree[end]] == 1:\\n                count += 1\\n            \\n            end += 1\\n            \\n            while count > 2 and start < end:\\n                hmap[tree[start]] -= 1\\n                if hmap[tree[start]] == 0:\\n                    count -= 1\\n                start += 1\\n            \\n            if count > 2:\\n                continue\\n            \\n            res = max(res, end-start)\\n        \\n        return res\\n            \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        secondLastFruit = -1\\n        lastFruit = -1\\n        lastFruitCount = 0\\n        currFruits = 0\\n        maxFruits = 0\\n        \\n        for fruit in tree:\\n            if fruit == lastFruit or fruit == secondLastFruit:\\n                currFruits += 1\\n            else:\\n                currFruits = lastFruitCount + 1\\n                \\n            if fruit == lastFruit:\\n                lastFruitCount += 1\\n            else:\\n                lastFruitCount = 1\\n                secondLastFruit = lastFruit\\n                lastFruit = fruit\\n                \\n            maxFruits = max(currFruits, maxFruits)\\n        \\n        return maxFruits\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        i,maxLen=0,0\\n        cache=collections.defaultdict(int)\\n        for j in range(len(tree)):\\n            cache[tree[j]]+=1\\n            if len(cache)<=2:\\n                maxLen=max(maxLen,j-i+1)\\n            while len(cache)>2:\\n                cache[tree[i]]-=1\\n                if cache[tree[i]]==0:\\n                    del cache[tree[i]]\\n                i+=1\\n        if maxLen==0:\\n            return 1\\n        return maxLen\\n\", \"\\nclass Solution:\\n    def totalFruit(self, tree) -> int:\\n        '''\\n\\n        :param tree: : List[int]\\n        :return:\\n        '''\\n        n = len(tree)\\n        if n <=2:\\n            return n \\n        tem = collections.Counter()\\n        res = 0\\n        i = 0\\n        j = 1\\n        tem.update(tree[:1])\\n\\n        while j<n:\\n            while j < n and  len(tem.keys()) <=2:\\n                tem.update([tree[j]])\\n                res = max(res, j - i )\\n                j += 1\\n\\n            while len(tem.keys()) >=3 :\\n                tem[tree[i]] -= 1\\n                if tem[tree[i]] ==0:\\n                    tem.pop(tree[i])\\n                i += 1\\n\\n            if j == n :\\n                res = max(res, j - i)\\n                break\\n        return res\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        \\n        res = 0\\n        \\n        mres = 0\\n        temp = set()\\n        i = 0\\n        newidx = 0\\n        \\n        while i < len(tree):\\n            if len(temp) == 0:\\n                mres += 1\\n                temp.add(tree[i])\\n                i += 1\\n            \\n            elif len(temp) == 1:\\n                newidx = i\\n                temp.add(tree[i])\\n                mres += 1\\n                i += 1\\n                \\n            else:\\n                if tree[i] in temp:\\n                    mres += 1\\n                    i += 1\\n                else:\\n                    res = max(res, mres)\\n                    mres = 0\\n                    temp = set()\\n                    i = newidx\\n                    \\n        res = max(res, mres)\\n        return res\\n            \\n                \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if not tree:\\n            return 0\\n        if len(set(tree)) <= 2:\\n            return len(tree)\\n        \\n        max_collected = 0\\n        \\n        for i in range(len(tree)):\\n            num_collected = 0\\n            different_types = set()\\n            for j in range(i, len(tree)):\\n                if len(different_types) < 2:\\n                    different_types.add(tree[j])\\n                    num_collected += 1\\n                elif tree[j] in different_types:\\n                    num_collected += 1\\n                else:\\n                    break\\n            \\n            max_collected = max(max_collected, num_collected)\\n        \\n        return max_collected\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n      item1_val = -1\\n      item1_fs = -1 \\n      item1_ls = -1\\n      item2_val = -1\\n      item2_fs = -1\\n      item2_ls = -1\\n      size = list()\\n      for i in range(len(tree)):\\n        if tree[i] == item1_val:\\n          item1_ls = i\\n          if item1_fs == -1:\\n            item1_ls = i\\n          if i == 0:\\n            size.append(1)\\n          size.append(size[i-1] + 1)\\n        elif tree[i] == item2_val:\\n          item2_ls = i\\n          if item2_fs == -1:\\n            item2_ls = i\\n          if i == 0:\\n            size.append(1)\\n          size.append(size[i-1] + 1)\\n        else:\\n          if item1_ls > item2_ls: # item1 stays\\n            item1_fs = item2_ls + 1\\n            item2_val = tree[i]\\n            item2_fs = i\\n            item2_ls = i\\n            size.append(i - item1_fs + 1)\\n          else: # item2 stays\\n            item2_fs = item1_ls + 1\\n            item1_val = tree[i]\\n            item1_fs = i\\n            item1_ls = i\\n            size.append(i - item2_fs + 1)\\n\\n      return(max(size))\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        counter = collections.defaultdict(int)\\n        \\n        start = 0\\n        res = 0\\n        \\n        for end in range(len(tree)):\\n            counter[tree[end]] += 1\\n            \\n            while len(list(counter.keys())) > 2:\\n                counter[tree[start]] -= 1\\n                \\n                if counter[tree[start]] == 0:\\n                    del counter[tree[start]]\\n                \\n                start += 1\\n            res = max(res, sum(counter.values()))\\n        \\n        return res\\n            \\n            \\n                \\n\", \"\\nfrom collections import defaultdict\\nclass Solution:\\n    def totalFruit(self, tree):\\n        if len(tree) <3:\\n            return len(tree)\\n        # run1 = 0\\n        # run2 = 1\\n        # # run3 = 0\\n        best_pair = 0\\n        # tree_type1 = None\\n        # tree_type2 = tree[0]\\n        forest = defaultdict(int)\\n        forest[tree[0]] = (0,1)\\n        for t in range(1, len(tree)):\\n            # print('tree',t)\\n            if tree[t] not in forest:\\n                best_pair = max([best_pair, sum([b for basket in list(forest.values()) for b in basket])])\\n                temp = defaultdict(int)\\n                temp[tree[t]] = (0,0)\\n                temp[tree[t-1]] = (0,forest[tree[t-1]][-1])\\n                forest = temp\\n                # print('established tt1', t)\\n            if tree[t] == tree[t-1]:\\n                forest[tree[t]] = (forest[tree[t]][0],forest[tree[t]][-1]+1)\\n            else:\\n                # print(forest)\\n                forest[tree[t]] = (sum(forest[tree[t]]),1)\\n            # if t == tree_type1:\\n            #     run1 += 1\\n            #     print('run1',run1)\\n            # elif t == tree_type2:\\n            #     run2 += 1\\n            #     print('run2', run2)\\n            # else:\\n            #     print('new set')\\n            #     best_pair = max([best_pair, sum([run1, run2])])\\n            #     run2 = run1\\n            #     run1 = 1\\n            #     tree_type2 = tree_type1\\n            #     tree_type1 = t\\n            #     print(best_pair, run1, run2, 'tree_type1',tree_type1,'tree_type2', tree_type2)\\n            # print(run1, run2)\\n            # print(forest)\\n            # print(best_pair)\\n        best_pair = max([best_pair, sum([b for basket in list(forest.values()) for b in basket])])\\n        return best_pair\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        c = collections.Counter()\\n        j = 0\\n        ans = 0\\n        for i in range(len(tree)):\\n            c[tree[i]]+=1\\n            while len(c)>=3:\\n                c[tree[j]] -= 1\\n                if c[tree[j]]==0:\\n                    del c[tree[j]]\\n                j+=1\\n            ans = max(ans,i-j+1)\\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        prev_count = curr =  count_b = result = 0\\n        a = None\\n        b = None\\n        for c in tree:\\n            if b == c:\\n                curr += 1\\n                count_b += 1\\n            elif a == c:\\n                curr += 1\\n                count_b = 1\\n                a = b\\n                b = c\\n            elif a != c and b != c:\\n                curr = count_b + 1\\n                count_b = 1\\n                a = b\\n                b = c\\n            result = max(result, curr)\\n        return result\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        current_picking = tree[0]\\n        prev_picking = None\\n        max_picked = 0\\n        baskets = {current_picking: [0, 0]}\\n        for i in range(len(tree)):\\n            if tree[i] != current_picking:\\n                if len(baskets) < 2:\\n                    baskets[current_picking] = [0, i-1]\\n                    prev_picking = current_picking\\n                    current_picking = tree[i]\\n                    baskets[current_picking] = [i, i]\\n                else:\\n                    if tree[i] != prev_picking:\\n                        baskets = {\\n                            current_picking: [baskets[prev_picking][1] + 1, baskets[current_picking][1]],\\n                            tree[i]: [i, i]\\n                        }\\n                        prev_picking = current_picking\\n                        current_picking = tree[i]\\n                    else:\\n                        prev_picking, current_picking = current_picking, prev_picking\\n                        baskets[current_picking][1] = i\\n            else:\\n                baskets[current_picking][1] = i\\n            if baskets.get(current_picking) and baskets.get(prev_picking):\\n                max_picked = max(max_picked, max([pos[1] for pos in baskets.values()]) - min([pos[0] for pos in baskets.values()]) + 1)\\n            else:\\n                max_picked = max(max_picked, baskets[current_picking][1] - baskets[current_picking][0] + 1)\\n        return max_picked\", \"from collections import Counter\\nclass window:\\n    \\n    def __init__(self):\\n        self.type = Counter()\\n    \\n    def add(self, x):\\n        self.type[x] += 1\\n    \\n    def remove(self, x):\\n        self.type[x] -= 1\\n        if self.type[x] == 0:\\n            del self.type[x]\\n    \\n    def valid(self):\\n        return len(self.type) <= 2\\n        \\n        \\nclass Solution:\\n    def totalFruit(self, tree):\\n        \\n        win = window()\\n        l, res = 0, 0\\n        for r,fruit in enumerate(tree):\\n            win.add(fruit)\\n            while l < r and not win.valid():\\n                win.remove(tree[l])\\n                l += 1\\n            res = max(res, r-l+1)\\n        return res\\n            \\n            \\n        \\n        \\n        \\n        \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if not tree:\\n            return 0\\n        \\n        n = len(tree)\\n        res = 1\\n        \\n        # starting type\\n        last_occur = {tree[0]: 0}\\n        \\n        i, j = 0, 1\\n        \\n        # condition for while loop\\n        while j < n:\\n            new_type = tree[j]\\n            if new_type in last_occur or len(last_occur.keys()) < 2:\\n                last_occur[new_type] = j\\n                res = max(res, j-i+1)\\n                \\n            # should have new types\\n            else:\\n                count = j - i\\n                res = max(res, count)\\n                \\n                # start from the new index\\n                keys = list(last_occur.keys())\\n                t = keys[0] if last_occur[keys[0]] < last_occur[keys[1]] else keys[1]\\n                i = last_occur[t] + 1\\n                del last_occur[t]\\n                # new starting type at i\\n                \\n                last_occur[new_type] = j\\n\\n            j+=1\\n\\n        return res\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        maxL = 0\\n        l, r = 0, 0 # 0, 4\\n        if len(set(tree)) < 3:\\n            return len(tree)\\n        \\n        while r <= len(tree):\\n            temp = tree[l:r]\\n            if len(set(temp)) < 3:\\n                maxL = max(maxL, len(temp))\\n                r += 1\\n            elif len(set(temp)) >= 3:\\n                l += 1\\n        \\n        return maxL\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        #two fruit\\n        firstFruit = secondFruit = -1\\n        firstQuant = secondQuant = 0\\n        ans = 0\\n        \\n        n = len(tree)\\n        i = 0\\n        while i<n:\\n            if firstQuant == 0 or firstFruit == tree[i]:\\n                firstFruit  = tree[i]\\n                firstQuant += 1\\n            elif secondQuant == 0 or secondFruit == tree[i]:\\n                secondFruit = tree[i]\\n                secondQuant += 1\\n            \\n            elif i>0 and tree[i-1] == firstFruit:\\n                secondFruit = tree[i]\\n                secondQuant = 1\\n                j = i-1\\n                while j>=0 and tree[j]==firstFruit:\\n                    j-=1\\n                firstQuant = i-1-j\\n                    \\n            elif i>0 and tree[i-1] == secondFruit:\\n                firstFruit = tree[i]\\n                firstQuant = 1\\n                j = i-1\\n                while j>=0 and tree[j]==secondFruit:\\n                    j-=1\\n                secondQuant = i-1-j\\n            ans = max(ans,firstQuant+secondQuant)\\n            #print(firstFruit,firstQuant,secondFruit,secondQuant,ans)\\n            i+=1\\n        return ans\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        ans = i = 0\\n        count = collections.Counter()\\n        # count = {}\\n        for j, x in enumerate(tree):\\n            count[x] += 1\\n            # if x not in count:\\n            #     count[x] = 1\\n            # else:\\n            #     count[x] += 1\\n            while len(count) == 3:\\n                count[tree[i]] -= 1\\n                if count[tree[i]] == 0:\\n                    del count[tree[i]]\\n                i += 1\\n            ans = max(ans, j - i + 1)\\n        return ans\\n            \\n            \\n\", \"class Solution:\\n    def totalFruit(self, ar: List[int]) -> int:\\n        l=list(set(ar))\\n        if len(l)<=2:\\n            return len(ar)\\n        else:\\n            m=0\\n            for i in range(0,len(ar)):\\n                l=[ar[i]]\\n                # c=0\\n                d=1\\n                for j in range(i+1,len(ar)):\\n                    if ar[j] in l:\\n                        l.append(ar[j])\\n                    elif ar[j] not in l and d==1:\\n                        d+=1\\n                        l.append(ar[j])\\n                    else:\\n                        break\\n                m=max(m,len(l))\\n            return m\\n                    \\n                    \\n                \\n               \\n        \\n        \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if len(tree)==1:\\n            return 1\\n        \\n        window_start = 0\\n        window_end = 2\\n        total_max = 2\\n        \\n        if tree[0] == tree[1]:\\n            tmp_index = 0\\n        else:\\n            tmp_index = 1\\n            \\n        fruit_type = set(tree[:2])\\n        \\n        for i in range(2, len(tree)):\\n            if (tree[i] in  fruit_type) or len(fruit_type)<2:\\n                window_end += 1\\n                if tree[i] != tree[i-1]:\\n                    tmp_index = i\\n                fruit_type.add(tree[i])\\n            else:\\n                window_start  = tmp_index\\n                tmp_index = i\\n                window_end += 1\\n                fruit_type = set(tree[i-1:i+1])\\n            #print(window_start, window_end, fruit_type)\\n            if window_end - window_start > total_max:\\n                total_max = window_end - window_start\\n        return total_max\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        dp = [[] for i in range(len(tree))]\\n        dp[-1] = [1, 1, [tree[-1]]]\\n        res = 1\\n        for i in reversed(list(range(len(tree)-1))):\\n            if tree[i] == tree[i+1]:\\n                dp[i] = [dp[i+1][0]+1, dp[i+1][1]+1, dp[i+1][2]]\\n            elif len(dp[i+1][2]) == 1:\\n                dp[i] = [dp[i+1][0]+1, 1, [tree[i], dp[i+1][2][0]]] \\n            elif tree[i] in dp[i+1][2]:\\n                dp[i] = [dp[i+1][0]+1, 1, dp[i+1][2]]\\n            else:\\n                dp[i] = [1+dp[i+1][1], 1, [tree[i], tree[i+1]]]\\n            res = max(res, dp[i][0])\\n        return res\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        N = len(tree)\\n        out = 0\\n        start = 0\\n        olderstart = 0\\n        newerend = newerstart = 0\\n        olderend = olderstart = 0\\n        older = newer = tree[0]        \\n        j = 0\\n        if N < 3:\\n            return len(tree)\\n        while newer == older and j < N:\\n            olderend = j\\n            j+= 1\\n            if j == N:\\n                return N\\n            newer = tree[j]\\n            newerstart = j\\n            \\n        assert(newer != older)\\n        \\n        for i in range(j, N):\\n            curr = tree[i]\\n            if (curr == older or curr == newer) :\\n                if curr == older:\\n                    olderend = i\\n                if curr == newer:\\n                    newerend = i\\n                \\n            else:\\n                \\n                if prev == older:\\n                    olderstart = newerend+1\\n                else:                    \\n                    olderstart = olderend+1\\n                    olderend = newerend\\n                    older = newer                   \\n                \\n                newerstart = i\\n                newerend = i\\n                newer = curr\\n                \\n            prev = curr                \\n            out = max(i-olderstart+1, out)\\n        return out\\n                \\n            \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        i = 0\\n        count = collections.Counter()\\n        for value in tree:\\n            count[value] += 1\\n            if len(count) > 2:\\n                count[tree[i]] -= 1\\n                if count[tree[i]] == 0:\\n                    del count[tree[i]]\\n                i +=1\\n        return len(tree) - i\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if len(tree)<=2: return len(tree)\\n        \\n        n = len(tree)\\n        \\n        res = 0 \\n        start = 0\\n        while start<n:\\n            type1, type2, type2_pos = -1, -1, -1\\n            i = start \\n            while i<n: # i represents the end pos\\n                if type1 == -1:\\n                    type1 = tree[i]\\n                    \\n                elif tree[i]!=type1 and type2 == -1:\\n                    type2 = tree[i]\\n                    type2_pos = i\\n                    \\n                elif tree[i]!=type1 and tree[i]!=type2:\\n                    break\\n                i += 1\\n                \\n            res = max(res, i-start)\\n            if i==n: break\\n            start = type2_pos\\n            \\n        return res\\n            \\n                \\n        \\n            \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        total_len = len(tree)\\n        \\n        if total_len == 0:\\n            return 0\\n        \\n        rst = 1\\n        \\n        fruit_1 = tree[0]\\n        \\n        start = 0\\n        \\n        # Check the first fruit\\n        while tree[start] == fruit_1:\\n            start += 1\\n            if start >= total_len:\\n                return start\\n        \\n        # Check the second fruit\\n        fruits = [fruit_1, tree[start]]\\n        fruits_order = [start-1, start]\\n        total_fruits = start+1\\n        \\n        #print(fruits, fruits_order, total_fruits, start)\\n        \\n        for i in range(start+1, total_len):\\n            #print(\\\\\\\"new_fruit is\\\\\\\", tree[i])\\n            if tree[i] == fruits[0]:\\n                fruits_order[0] = i\\n                total_fruits += 1\\n                #print(\\\\\\\"Update the basket 0\\\\\\\", fruits, fruits_order, total_fruits)\\n                \\n            elif tree[i] == fruits[1]:\\n                fruits_order[1] = i\\n                total_fruits += 1\\n                #print(\\\\\\\"Update the basket 1\\\\\\\", fruits, fruits_order, total_fruits)\\n                \\n            else:\\n                if total_fruits > rst:\\n                    rst = total_fruits\\n                if fruits_order[0] > fruits_order[1]:\\n                    fruits[1] = tree[i]\\n                    total_fruits = i - fruits_order[1]\\n                    fruits_order[1] = i\\n                else:\\n                    fruits[0] = tree[i]\\n                    total_fruits = i - fruits_order[0]\\n                    fruits_order[0] = i\\n                \\n                #print(\\\\\\\"generate the new fruits order, type\\\\\\\")\\n                #print(fruits, fruits_order, total_fruits)\\n                \\n        if total_fruits > rst:\\n            return total_fruits\\n        \\n        return rst\\n                \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n    \\n        out = 0\\n        for i in range(len(tree)):\\n            tot = self.getTotalAtIndex(tree, i)\\n            if tot>out:\\n                out = tot\\n            if tot == len(tree):\\n                break\\n        return out\\n    \\n    \\n    def getTotalAtIndex(self, tree, i):\\n        \\n        fruit_types = set()\\n        cnt = 0\\n        for j in range(i, len(tree)):\\n            if len(fruit_types)<2:\\n                fruit_types.add(tree[j])\\n                \\n            if tree[j] in fruit_types:\\n               cnt+=1\\n            else:\\n                break\\n        return cnt\\n        pass\\n\", \"from collections import defaultdict\\nclass Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        st = 0\\n        max_len = 0\\n        basket = defaultdict(int)\\n\\n        for end in range(len(tree)):\\n            basket[tree[end]] += 1\\n\\n            while len(basket) > 2:\\n                basket[tree[st]] -= 1\\n                if basket[tree[st]] == 0:\\n                    del basket[tree[st]]\\n                st += 1\\n\\n            total = 0\\n            for k in basket:\\n                total += basket[k]\\n\\n            max_len = max(max_len, total)\\n\\n        return max_len\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        n = len(tree)\\n        \\n        if n < 3:\\n            return n\\n        \\n        max_count = 0\\n\\n        dp = [[set(),0,set(),0] for _ in range(n)]\\n        \\n        dp[0] = [{tree[0]},1,{tree[0]},1]\\n        \\n        for i in range(1, n):\\n            if tree[i] in dp[i-1][2]:\\n                set_2 = dp[i-1][2].copy()\\n                count_2 = dp[i-1][3] + 1\\n            else:\\n                temp = dp[i-1][0].copy()\\n                temp.add(tree[i])\\n                set_2 = temp\\n                count_2 = dp[i-1][1] + 1\\n            if tree[i] in dp[i-1][0]:\\n                set_1 = dp[i-1][0].copy()\\n                count_1 = dp[i-1][1] + 1\\n            else:\\n                set_1 = {tree[i]}\\n                count_1 = 1\\n                \\n            dp[i] = [set_1, count_1, set_2, count_2]\\n            \\n            max_count = max(max_count, max(count_1, count_2))\\n            \\n            \\n        return max_count\\n                \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        count = collections.Counter()\\n        i = ans = 0\\n\\n        for j in range(len(tree)):\\n            fruit = tree[j]\\n            count[fruit] += 1\\n\\n            while len(count.keys()) > 2:\\n                count[tree[i]] -= 1\\n                if count[tree[i]] == 0:\\n                    del count[tree[i]]\\n                i += 1\\n\\n            ans = max(ans, j-i+1)\\n\\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if len(tree) <= 2:\\n            return len(tree)\\n        types = {tree[0]: 0, tree[1]: 1} if tree[0] != tree[1] else {tree[0]: 1}\\n        res = 2\\n        temp = 2\\n        for i in range(2, len(tree)):\\n            if len(types) == 2:\\n                if tree[i] not in types:\\n                    res = max(res, temp)\\n                    delete = sorted(types, key=types.get)[0]\\n                    temp = i - types[delete]\\n                    del types[delete]\\n                    types[tree[i]] = i\\n                else:\\n                    temp += 1\\n                    types[tree[i]] = i\\n            else:\\n                temp += 1\\n                types[tree[i]] = i\\n        res = max(res, temp)\\n        return res\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        ans = i = 0\\n        count = collections.Counter()\\n        for j, x in enumerate(tree):\\n            count[x] += 1\\n            while len(count) >= 3:\\n                count[tree[i]] -= 1\\n                if count[tree[i]] == 0:\\n                    del count[tree[i]]\\n                i += 1\\n            ans = max(ans, j - i + 1)\\n        return ans\\n            \\n        \\n            \\n        \\n        \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        left_pointer, right_pointer = 0, 0\\n        fruits = 0\\n        fruits_in_basket = {}\\n        \\n        while (right_pointer < len(tree)) :\\n            if (len(fruits_in_basket) <= 2) :\\n                fruits_in_basket[tree[right_pointer]] = right_pointer\\n                right_pointer += 1\\n                #print(fruits_in_basket)\\n            if (len(fruits_in_basket) > 2) :\\n                minimum_index = len(tree)\\n                for index in list(fruits_in_basket.values()) :\\n                    minimum_index = min(minimum_index, index)\\n                left_pointer = minimum_index + 1\\n                #print(left_pointer)\\n                fruits_in_basket.pop(tree[minimum_index])\\n            fruits = max(fruits, (right_pointer - left_pointer))\\n            #print(fruits)\\n            \\n        return fruits\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if tree == [] or tree is None:\\n            return 0\\n        \\n        if len(tree) == 1:\\n                return 1\\n\\n        # [1,3,3,1]\\n        s = 0\\n        max = 1\\n        count = max\\n        \\n        for i in range(len(tree)):\\n            j = i + 1\\n            b1 = tree[i]  # backet 1\\n            b2 = tree[j]  # backet 2\\n            count = 1\\n\\n            if b1 == b2:\\n                # continue finding a different value while incrementing\\n                while j < len(tree) and tree[j] == b1:\\n                    j += 1\\n                    count += 1\\n                if j != len(tree):\\n                    b2 = tree[j]    \\n                elif count > max:\\n                    return count\\n            \\n            while j < len(tree):\\n                \\n                \\n                    \\n                # a new number occured\\n                if tree[j] != b1 and tree[j] != b2:\\n                    # compare count and max\\n                    if count >= max:\\n                        max = count\\n                    # reset starting position\\n            \\n                    break\\n                \\n                # pick up fruit and move\\n                count += 1\\n                j += 1\\n\\n                if j == len(tree):\\n                    if count >= max:\\n                        max = count\\n                    return max\\n                \\n        return max\\n          \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        char_to_count = defaultdict(int)\\n        unique_chars = 0\\n        \\n        start = 0\\n        end = 0\\n        max_fruit = 0\\n        while end < len(tree):\\n            char_to_count[tree[end]] += 1\\n            if char_to_count[tree[end]] == 1:\\n                unique_chars +=  1\\n            \\n            while unique_chars > 2:\\n                char_to_count[tree[start]] -= 1\\n                if char_to_count[tree[start]] == 0:\\n                    unique_chars -= 1\\n                start += 1\\n            end += 1\\n            max_fruit = max(max_fruit, end-start)\\n            \\n        return max_fruit\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        d = {}\\n        first = -1\\n        second = -1\\n        i = 0\\n        n = len(tree)\\n        m = -1\\n        while i<n:\\n            if tree[i] in d:\\n                d[tree[i]].append(i)\\n                i+=1\\n            else:\\n                if len(list(d.keys()))==2:\\n                    s = 0\\n                    for k,v in list(d.items()):\\n                        s+=len(v)\\n                    m = max(m, s)\\n                    if d[first][-1]>d[second][-1]:\\n                        i = d[second][-1]+1\\n                        first = first\\n                        d = {}\\n                        d[tree[i]] = [i]\\n                        i+=1\\n                    else:\\n                        i = d[first][-1]+1\\n                        first = second\\n                        d = {}\\n                        d[tree[i]] = [i]\\n                        i+=1\\n                elif len(list(d.keys()))==1:\\n                    second = tree[i]\\n                    d[tree[i]] = [i]\\n                    i+=1\\n                else:\\n                    first = tree[i]\\n                    d[tree[i]] = [i]\\n                    i+=1\\n        s = 0\\n        for k,v in list(d.items()):\\n            s+=len(v)\\n        return max(m, s)\\n                    \\n                    \\n            \\n                \\n                \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        a = Counter(tree)\\n        if len(a) <= 2:\\n            return len(tree)\\n        \\n        ans = 0\\n        \\n        i = 0\\n        while i < len(tree):\\n            count = 1\\n            basket = [tree[i]]\\n            j = i + 1\\n            while j < len(tree):\\n                if tree[j] in basket:\\n                    count += 1\\n                else:\\n                    if len(basket) >= 2:\\n                        break\\n                    else:\\n                        basket.append(tree[j])\\n                        count += 1\\n                j += 1\\n            \\n            if count > ans:\\n                ans = count\\n            i += 1\\n            \\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        \\n        if len(set(tree))<=2:\\n            return len(tree)\\n        \\n        types = set()\\n\\n        maxFruits = 0\\n        \\n        for i in range(len(tree)):\\n            start = i\\n            res = 0\\n            types = set()\\n            for i in range(start,len(tree)):\\n                fruitType = tree[i]\\n                if (len(types)>=2) and (fruitType not in types):\\n                    break\\n                elif fruitType in types:\\n                    res+=1\\n                else:\\n                    types.add(fruitType)\\n                    res+=1\\n            \\n            maxFruits = max(maxFruits,res)\\n            \\n        return maxFruits\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        dic = {}\\n        first = 0\\n        i = 0\\n        n = len(tree)\\n        ans = 0\\n        while i<n:\\n            val = tree[i]\\n            if val in dic:\\n                dic[val] += 1\\n            elif len(dic)<2: \\n                dic[val] = 1\\n            else:\\n                dic[val] = 1\\n                while len(dic) >= 2:\\n                    v2 = tree[first]\\n                    first+=1\\n                    dic[v2] -= 1\\n                    if dic[v2] == 0:\\n                        dic.pop(v2,None)\\n                        break\\n            ans = max(i-first+1, ans)\\n            i+=1\\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        fruits = tree\\n        window_start = 0\\n        max_length = 0\\n        fruit_frequency = {}\\n\\n  # try to extend the range [window_start, window_end]\\n        for window_end in range(len(fruits)):\\n            right_fruit = fruits[window_end]\\n            if right_fruit not in fruit_frequency:\\n                fruit_frequency[right_fruit] = 0\\n            fruit_frequency[right_fruit] += 1\\n\\n    # shrink the sliding window, until we are left with '2' fruits in the fruit frequency dictionary\\n            while len(fruit_frequency) > 2:\\n                left_fruit = fruits[window_start]\\n                fruit_frequency[left_fruit] -= 1\\n                if fruit_frequency[left_fruit] == 0:\\n                    del fruit_frequency[left_fruit]\\n                window_start += 1  # shrink the window\\n            max_length = max(max_length, window_end-window_start + 1)\\n        return max_length    \", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        best_attempt = 0\\n        for i in range(len(tree)):\\n            baskets = {}\\n            for j in range(i, len(tree)):\\n                if tree[j] in baskets:\\n                    baskets[tree[j]] += 1\\n                elif len(baskets) >= 2:\\n                    break\\n                else:\\n                    baskets[tree[j]] = 1\\n            attempt_val = sum(baskets.values())\\n            if attempt_val > best_attempt:\\n                best_attempt = attempt_val\\n            if best_attempt > len(tree) - i:\\n                break\\n        return best_attempt\\n        \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        res = 0\\n        N = len(tree)\\n        oneidx = twoidx = 0\\n        onetype = tree[0]\\n        twotype = None\\n        left, right = 0, 0\\n        while right < N and tree[right] == onetype:\\n          oneidx += 1\\n          right += 1\\n        oneidx -= 1\\n        if right == N:\\n          return N\\n        twotype = tree[right]\\n        twoidx = right\\n        while right < N:\\n          if tree[right] == onetype:\\n            oneidx = right\\n          elif tree[right] == twotype:\\n            twoidx = right\\n          else:\\n            res = max(res, right - left)\\n            if oneidx < twoidx:\\n              left = oneidx + 1\\n              onetype = tree[right]\\n              oneidx = right\\n            else:\\n              left = twoidx + 1\\n              twotype = tree[right]\\n              twoidx = right\\n          right += 1\\n        return max(res, right - left)\\n\", \"from collections import OrderedDict\\n\\nclass Solution:\\n    \\n    def totalFruit(self, tree: List[int]) -> int:\\n        \\n        last_index_of = OrderedDict()\\n        \\n        ans = l = 0\\n        \\n        for i, t in enumerate(tree):\\n            \\n            last_index_of[t] = i\\n            last_index_of.move_to_end(t)\\n            \\n            if len(last_index_of) > 2:\\n                ans = max(ans, i-l)\\n                l = last_index_of.popitem(last=False)[1] + 1\\n                \\n        ans = max(ans, len(tree) - l)\\n        \\n        return ans\", \"'''\\n{3:1,1:1}\\n\\n'''\\nclass Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        first,sec=0,0\\n        curr_hash={}\\n        if len(tree)<3:return len(tree)\\n        Max=[float('-inf')]\\n        while(first<len(tree)):\\n            first=self.first_pass(first,curr_hash,tree,Max)\\n            if first>len(tree):continue\\n            sec=self.sec_pass(sec,first,curr_hash,tree)\\n        return Max[0]\\n    def first_pass(self,pointer,hash,trees,Max):\\n        count=0\\n        for key in hash:\\n            count+=hash[key]\\n        while(pointer<len(trees)):\\n            typ=trees[pointer]\\n            if typ in hash:hash[typ]+=1\\n            else:\\n                if len(hash)<2:\\n                    hash[typ]=1\\n                else:\\n                    break\\n            count+=1\\n            pointer+=1\\n        Max[0]=max(Max[0],count)\\n        return pointer\\n    \\n    def sec_pass(self,sec,first,hash,tree):\\n        while(sec<first and len(hash)>1):\\n            typ=tree[sec]\\n            if hash[typ]==1: del hash[typ]\\n            else: hash[typ]-=1\\n            sec+=1\\n        return sec\\n        \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        \\n        if len(set(tree))<=2:\\n            return len(tree)\\n        \\n        types = set()\\n\\n        maxFruits = 0\\n        \\n        for i in range(len(tree)):\\n            start = i\\n            res = 0\\n            types = set()\\n            \\n            if (len(tree)-start)<=maxFruits:\\n                continue\\n            \\n            for i in range(start,len(tree)):\\n                fruitType = tree[i]\\n                if (len(types)>=2) and (fruitType not in types):\\n                    break\\n                elif fruitType in types:\\n                    res+=1\\n                else:\\n                    types.add(fruitType)\\n                    res+=1\\n            \\n            maxFruits = max(maxFruits,res)\\n            \\n        return maxFruits\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        k = 2\\n        left = 0\\n        cnt = collections.Counter()\\n        res = 0\\n        for j, i in enumerate(tree):\\n            if cnt[i] == 0: k-=1\\n            cnt[i] += 1\\n            while k<0:\\n                cnt[tree[left]] -= 1\\n                if cnt[tree[left]] == 0: k+=1\\n                left += 1\\n            res = max(res, j-left +1)\\n        return res\\n            \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        c=0\\n        p=0\\n        for i in range(len(tree)):\\n            l=[]\\n            k=0\\n            for j in range(i,len(tree)):\\n                if(tree[j] not in l):\\n                    l.append(tree[j])\\n                    k+=1\\n                else:\\n                    k+=1\\n                #print(l)\\n                if(len(l)>2):\\n                    k=k-1\\n                    break\\n               \\n            if(k>p):\\n                p=k\\n            if(p==len(tree)):\\n                break;\\n        return p\\n                    \\n                    \\n                \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        max_count = 0\\n        tree_len = len(tree)\\n        if len(tree) == 1:\\n            return 1\\n        if len(set(tree)) in (1,2):\\n            return len(tree)\\n        for i in range(tree_len - 1):\\n            tree_set = set()\\n            tree_set.add(tree[i])\\n            count = 1\\n            for j in range(i+1, tree_len):\\n                if tree[j] not in tree_set and len(tree_set) == 2:\\n                    break\\n                tree_set.add(tree[j])\\n                count += 1\\n            max_count = max(max_count, count)\\n        return max_count\\n                \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        blocks = [(k, len(list(v)))\\n                  for k, v in itertools.groupby(tree)]\\n\\n        ans = i = 0\\n        while i < len(blocks):\\n            # We'll start our scan at block[i].\\n            # types : the different values of tree[i] seen\\n            # weight : the total number of trees represented\\n            #          by blocks under consideration\\n            types, weight = set(), 0\\n\\n            # For each block from i and going forward,\\n            for j in range(i, len(blocks)):\\n                # Add each block to consideration\\n                types.add(blocks[j][0])\\n                weight += blocks[j][1]\\n\\n                # If we have 3 types, this is not a legal subarray\\n                if len(types) >= 3:\\n                    i = j-1\\n                    break\\n\\n                ans = max(ans, weight)\\n\\n            # If we go to the last block, then stop\\n            else:\\n                break\\n\\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        \\n        st = c = res = 0\\n        dic = dict()\\n        for end in range(len(tree)):\\n            if tree[end] in dic:\\n                dic[tree[end]] += 1\\n            else:\\n                dic[tree[end]] = 1\\n                c += 1\\n            while c > 2:\\n                dic[tree[st]] -= 1\\n                if dic[tree[st]] == 0: \\n                    del dic[tree[st]]\\n                    c -= 1\\n                st+=1\\n            res = max(res,end-st+1)\\n        return res\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        insp = {}\\n        pos = {}\\n        mxx = -1\\n        i = 0\\n        while i < len(tree):\\n            f = tree[i]\\n            if f not in insp and len(insp) == 2:\\n                mnn = math.inf\\n                tod = None\\n                for of, op in list(pos.items()):\\n                    mnn = min(mnn, op)\\n                    if mnn == op:\\n                        tod = of\\n                k = pos[tod]\\n                while k >= 0:\\n                    of = tree[k]\\n                    if of not in pos:\\n                        break\\n                    insp[of] -= 1\\n                    k -= 1\\n                        \\n                del pos[tod]\\n                del insp[tod]\\n                insp[f] = 0\\n            elif f not in insp:\\n                insp[f] = 0\\n            \\n            pos[f] = i\\n            insp[f] += 1\\n            score =  self.get_basketsize(insp)\\n            mxx = max(mxx,score)\\n            i += 1\\n            \\n        return mxx\\n          \\n    def get_basketsize(self, insp):\\n        mxx = 0\\n        nmxx = 0\\n        for f,ct in list(insp.items()):\\n            if ct >= mxx:\\n                nmxx = max(mxx, nmxx)\\n                mxx = max(ct, mxx)\\n            elif ct >= nmxx:\\n                nmxx = max(ct, nmxx)\\n        return mxx + nmxx\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        \\n        counter = collections.Counter()\\n        \\n        l = r = 0\\n        res = 0\\n        while r < len(tree):\\n            counter[tree[r]] += 1\\n            while len(counter.keys()) > 2:\\n                counter[tree[l]] -= 1\\n                if counter[tree[l]] == 0:\\n                    del counter[tree[l]]\\n                l += 1\\n            res = max(res, sum(counter.values()))\\n            r += 1\\n        return res\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        start = end = disFruits = curTotal = maxTotal = 0\\n        fruits = {}\\n        while end < len(tree):\\n            curFruit = tree[end]\\n            frontFruit = tree[start]\\n            if curFruit not in fruits and disFruits == 2:\\n                if fruits[frontFruit] == 1:\\n                    del fruits[frontFruit]\\n                    disFruits -= 1\\n                else:\\n                    fruits[frontFruit] -= 1\\n                curTotal -= 1\\n                start += 1\\n            else:\\n                curFruit = tree[end]\\n                if curFruit not in fruits:\\n                    fruits[curFruit] = 1\\n                    disFruits += 1\\n                else:\\n                    fruits[curFruit] += 1\\n                curTotal += 1\\n                maxTotal = max(curTotal, maxTotal)\\n                end += 1\\n        return maxTotal\\n                        \\n            \\n                \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if len(tree) == 1:\\n            return 1\\n        start = last1 = last2 = 0\\n        res = 1\\n        for i in range(1, len(tree)):\\n            if tree[i] == tree[last1]:\\n                last1 = i\\n            elif tree[i] == tree[last2]:\\n                last2 = i\\n            elif tree[last1] == tree[last2]:\\n                last1 = max(last1, last2)\\n                last2 = i\\n            else:\\n                start = min(last1, last2)+1\\n                if last1 < last2:\\n                    last1 = i\\n                else:\\n                    last2 = i\\n            res = max(res, i-start+1)\\n        return res\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n           \\n        ans = i = 0\\n        count = collections.Counter()\\n        for j, x in enumerate(tree):\\n            count[x] += 1\\n            while len(count) >= 3:\\n                count[tree[i]] -= 1\\n                if count[tree[i]] == 0:\\n                    del count[tree[i]]\\n                i += 1\\n            ans = max(ans, j - i + 1)\\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        def pick(start, end):\\n            res = 0\\n            fruitType = set()\\n            \\n            for i in range(start, end):\\n                fruit  = tree[i]\\n                if fruit not in fruitType and len(fruitType) >= 2:\\n                    return res\\n                \\n                fruitType.add(fruit)\\n                res += 1\\n            \\n            return res\\n        \\n        ##Main\\n        n = len(tree)\\n        cnt = Counter(tree)\\n        if len(cnt) <= 2:\\n            return n\\n        \\n        maxFruit = 0\\n        for i in range(n):\\n            maxFruit = max(maxFruit, pick(i, n))\\n            \\n        return maxFruit\", \"from collections import defaultdict\\n\\nclass Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        counter = {}\\n        longest = 0\\n        fruits = 0\\n        i = 0\\n        for j in range(len(tree)):\\n            if tree[j] not in counter:\\n                fruits += 1\\n                counter[tree[j]] = 0\\n            counter[tree[j]] += 1\\n            while fruits > 2:\\n                counter[tree[i]] -= 1\\n                if counter[tree[i]] == 0:\\n                    fruits -= 1\\n                    del counter[tree[i]]\\n                i += 1\\n            longest = max(longest, j-i+1)\\n        return longest\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if(len(tree)==1):\\n            return 1\\n        if(not tree):\\n            return 0\\n        i = 0\\n        j = 1\\n        l=len(tree)\\n        ans=0\\n        found = False\\n        second = tree[1]\\n        count = 1\\n        while(i<l and j<l):\\n            if(tree[i]!=tree[j] and not found):\\n                second=tree[j]\\n                found=True\\n            if(found and tree[j]!=second and tree[j]!=tree[i]):\\n                ans=max(ans,count)\\n                count=0\\n                i+=1\\n                j=i\\n                found=False\\n            j+=1\\n            count+=1\\n        ans=max(ans, count)\\n        return ans\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        \\n        fruit_dict = collections.defaultdict(int)\\n        j,result,count=0,0,0\\n        for i,t in enumerate(tree):\\n            fruit_dict[t]+=1\\n            count+=1\\n            while len(fruit_dict)>2 and j<len(tree):\\n                fruit_dict[tree[j]]-=1\\n                count-=1\\n                if fruit_dict[tree[j]]==0:\\n                    del fruit_dict[tree[j]]\\n                j+=1\\n            if len(fruit_dict)<=2:\\n                result = max(result,count)\\n        return result\\n        '''\\n        blocks = [(k,len(list(v))) for k,v in itertools.groupby(tree)]\\n        i,result=0,0\\n        \\n        while i<len(blocks):\\n            j=i\\n            count=0\\n            fruit_set = set()\\n            while j<len(blocks):\\n                fruit_set.add(blocks[j][0])\\n                count+=blocks[j][1]\\n                if len(fruit_set)>2:\\n                    i=j-1\\n                    break\\n                result=max(result,count)\\n                j+=1\\n            else:\\n                break\\n            \\n        return result\\n        '''\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        '''\\n        fruit_dict = collections.defaultdict(int)\\n        j,result,count=0,0,0\\n        for i,t in enumerate(tree):\\n            fruit_dict[t]+=1\\n            count+=1\\n            while len(fruit_dict)>2 and j<len(tree):\\n                fruit_dict[tree[j]]-=1\\n                count-=1\\n                if fruit_dict[tree[j]]==0:\\n                    del fruit_dict[tree[j]]\\n                j+=1\\n            if len(fruit_dict)==2:\\n                result = max(result,count)\\n        return result\\n        '''\\n        blocks = [(k,len(list(v))) for k,v in itertools.groupby(tree)]\\n        i,result=0,0\\n        \\n        while i<len(blocks):\\n            j=i\\n            count=0\\n            fruit_set = set()\\n            while j<len(blocks):\\n                fruit_set.add(blocks[j][0])\\n                count+=blocks[j][1]\\n                if len(fruit_set)>2:\\n                    i=j-1\\n                    break\\n                result=max(result,count)\\n                j+=1\\n            else:\\n                break\\n            \\n        return result\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        count = collections.Counter()\\n        \\n        j = res = 0\\n        \\n        for i in range(len(tree)):\\n            count[tree[i]] += 1\\n            \\n            while len(count) > 2:\\n                count[tree[j]] -= 1\\n                if count[tree[j]] == 0:\\n                    del count[tree[j]]\\n                j += 1\\n            \\n            res = max(res, sum(count.values()))\\n        return res\\n            \\n            \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        res=[]\\n        ind=0\\n        if len(tree)==1:\\n            return 1\\n        if len(set(tree))<=2:\\n            return len(tree)\\n        while ind<len(tree)-1:\\n            count=0\\n            types=set()\\n            for i in range(ind,len(tree)):\\n                types.add(tree[i])\\n                if len(types)>2:\\n                    break\\n                count+=1\\n            res.append(count)\\n            ind+=1\\n        return max(res)\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        \\n#         winstart=0\\n#         maxlen=0\\n#         for winend in range(len(tree)+1):\\n#             while(len(set(tree[winstart:winend])))>=3:\\n#                 winstart+=1\\n#             maxlen=max(maxlen,winend - winstart)\\n            \\n#         return maxlen\\n                \\n        ans = i = 0\\n        count = collections.Counter()\\n        for j, x in enumerate(tree):\\n            count[x] += 1\\n            while len(count) >= 3:\\n                count[tree[i]] -= 1\\n                if count[tree[i]] == 0:\\n                    del count[tree[i]]\\n                i += 1\\n            ans = max(ans, j - i + 1)\\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        grp = []\\n        x, y = tree[0], 1\\n        for e in tree[1:]:\\n            if e==x:\\n                y+=1\\n            else:\\n                grp.append((x,y))\\n                x, y = e, 1\\n        grp.append((x,y))\\n        \\n        ret = 0\\n        pair, pair_sum = [], 0\\n        for i in range(len(grp)):\\n            x, y = grp[i]\\n            if x in pair:\\n                pair_sum += y\\n            else:\\n                if len(pair)<2:\\n                    pair = pair + [x]\\n                    pair_sum += y\\n                else:\\n                    pair = [grp[i-1][0]] + [x]\\n                    pair_sum = grp[i-1][1] + y\\n            # print(pair)\\n            # print(pair_sum)\\n            # print('***')\\n            ret = max(ret, pair_sum)\\n        return ret\\n            \\n            \\n\", \"from collections import defaultdict\\n\\nclass Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        # freq = defaultdict(int)\\n        # freq[2] += 1\\n        # ftypes = set()\\n        # ftypes.add(2)\\n        \\n        if not tree:\\n            return 0\\n        \\n        freq, ftypes, ans, i = defaultdict(int), set(), float('-inf'), 0\\n        \\n        for j, num in enumerate(tree):\\n            freq[num] += 1\\n            ftypes.add(num)\\n            \\n            while len(ftypes) > 2:\\n                freq[tree[i]] -= 1\\n                if freq[tree[i]] == 0:\\n                    ftypes.remove(tree[i])\\n                i += 1\\n            \\n            ans = max(ans, j - i + 1)\\n            j += 1\\n            \\n        return ans\", \"import collections\\nclass Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        res=i=0\\n        count=Counter()\\n        for j, k in enumerate(tree):\\n            count[tree[j]] +=1\\n            while len(count)>=3:\\n                count[tree[i]] -= 1\\n                if count[tree[i]]==0:\\n                    del count[tree[i]]\\n                i +=1\\n            res=max(res, j-i+1)\\n        return res\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        i, j = 0, 0\\n        \\n        max_fruit = 0\\n        baskets = defaultdict(int)\\n        while j <= len(tree) and i < len(tree):\\n            #print(i, j, baskets)\\n            if j < len(tree) and len(set(list(baskets.keys()) + [tree[j]])) <= 2:\\n                baskets[tree[j]] += 1\\n                j += 1\\n            else:\\n                baskets[tree[i]] -= 1\\n                if baskets[tree[i]] == 0:\\n                    baskets.pop(tree[i])\\n                i += 1\\n            max_fruit = max(sum(baskets.values()), max_fruit)\\n        return max_fruit\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        i = 0\\n        maxCol = 0\\n        baskets = [0,0]\\n        while i < len(tree) and maxCol + i < len(tree):\\n\\n            baskets[0] = tree[i]\\n            j = i +1\\n            basket1Empty = True\\n            while j< len(tree):\\n                if tree[j] != baskets[0] and basket1Empty:\\n                    baskets[1] = tree[j]\\n                    basket1Empty = False\\n\\n                elif tree[j] != baskets[0] and tree[j] != baskets[1]:\\n                    col = j-i\\n                    if col > maxCol:\\n                        maxCol = col\\n                    break\\n\\n\\n                j +=1\\n            col = j-i\\n            if col > maxCol:\\n                maxCol = col\\n\\n\\n            i += 1\\n\\n        return maxCol\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if len(tree) == 0:\\n            return 0\\n        types = {}\\n        numFruits = 0\\n        maxNumFruits = 0\\n        left = 0\\n        right = 0\\n        while(right < len(tree)):\\n            if tree[right] in types:\\n                types[tree[right]] += 1\\n            else:\\n                types[tree[right]] = 1\\n            numFruits += 1\\n            right += 1\\n            \\n            while len(types) > 2:\\n                if types[tree[left]] == 1:\\n                    del(types[tree[left]])\\n                else:\\n                    types[tree[left]] -= 1\\n                left += 1\\n                numFruits -= 1\\n            maxNumFruits = max(maxNumFruits, numFruits)\\n            \\n            \\n        return maxNumFruits\\n                    \\n                \\n            \\n\\n            \\n                \\n                \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if len(tree)<=2: return len(tree)\\n        \\n        n = len(tree)\\n        res,l = 0,0\\n        while l<n:\\n            type1, type2 = -1, -1\\n            next_l = -1 # this denote where we should place l in next subarray\\n            for r in range(l,n):\\n                if type1==-1:\\n                    type1 = tree[r]\\n                elif tree[r]!=type1 and type2==-1:\\n                    next_l = r\\n                    type2 = tree[r]\\n                elif tree[r] != type1 and tree[r] != type2:\\n                    break\\n                r += 1\\n            res = max(res, r-l)\\n            if r==n: break\\n            l = next_l\\n        return res\\n                            \\n            \\n        \\n            \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        hMap = {}\\n        if not tree:\\n            return 0\\n            \\n        maxCount = 0\\n        count = 0\\n        for i in range(len(tree)):\\n            hMap[tree[i]] = i\\n            \\n            if len(hMap) <= 2:\\n                count += 1\\n                maxCount = max(count, maxCount)\\n            else:\\n                j = sys.maxsize\\n                r = None\\n                for k in hMap:\\n                    if hMap[k] < j:\\n                        r = k\\n                        j = hMap[k]\\n                hMap.pop(r, None)\\n                count = i - j\\n                \\n            # print(tree[i], hMap, count, maxCount)\\n                \\n        return maxCount\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        ans = i = 0\\n        count = collections.Counter()\\n        for j, x in enumerate(tree):\\n            count[x] += 1\\n            while len(count) >= 3:\\n                count[tree[i]] -= 1\\n                if count[tree[i]] == 0:\\n                    del count[tree[i]]\\n                i += 1\\n            ans = max(ans, j - i + 1)\\n        return ans\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        counter = {}\\n        start = 0\\n        maxL = 0\\n        for end in range(len(tree)):\\n            if tree[end] in counter:\\n                counter[tree[end]] += 1\\n            else:\\n                counter[tree[end]] = 1\\n            while (len(counter) > 2):\\n                counter[tree[start]] -= 1\\n                if counter[tree[start]] == 0:\\n                    del counter[tree[start]]\\n                start += 1\\n            maxL = max(maxL, end - start + 1)\\n        \\n        return maxL\", \"class Solution:\\n    def totalFruit(self, f: List[int]) -> int:\\n        start, count, maxFruits = 0,0,0 \\n        fruitHash = defaultdict(int)\\n\\n        for end in range(len(f)):\\n            if fruitHash[f[end]] == 0:\\n                count += 1\\n            fruitHash[f[end]] += 1\\n\\n            if count <= 2:\\n                maxFruits = max(maxFruits, end-start+1)\\n\\n            while count > 2:\\n                fruitHash[f[start]] -= 1\\n                start += 1\\n                if fruitHash[f[start-1]] == 0:\\n                    count -= 1\\n                    maxFruits = max(maxFruits, end-start+1)\\n        return maxFruits\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        max_len = 0\\n        start = end = 0\\n        N = len(tree)\\n        count = 0\\n        uniq = {}\\n        \\n        while end < N:\\n            cur = tree[end]\\n            if cur not in uniq:\\n                uniq[cur] = 0\\n            \\n            uniq[cur] += 1\\n            if uniq[cur] == 1:\\n                count += 1\\n            \\n            while count > 2:\\n                rem = tree[start]\\n                uniq[rem] -= 1\\n                if uniq[rem] == 0:\\n                    count -= 1\\n                start += 1\\n            \\n            max_len = max(max_len, end - start + 1)\\n            end += 1\\n            \\n        return max_len\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        k = 2\\n        \\n        start = 0\\n        \\n        freqHashmap = {}\\n        \\n        maxFruit = 0\\n        \\n        for end in range(len(tree)):\\n            freqHashmap[tree[end]] = freqHashmap.get(tree[end], 0) + 1\\n            \\n            while len(freqHashmap) > k:\\n                freqHashmap[tree[start]] -= 1\\n                \\n                if freqHashmap[tree[start]] == 0:\\n                    del freqHashmap[tree[start]]\\n                \\n                start += 1\\n            \\n            maxFruit = max(maxFruit, end - start + 1)\\n        \\n        return maxFruit\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        # \\u5305\\u542b\\u4e24\\u4e2a\\u5143\\u7d20\\u7684\\uff08\\u56e0\\u4e3a\\u9898\\u76ee\\u8bf4\\u662f\\u4e24\\u4e2a\\u7bee\\u5b50\\uff09\\u7684\\u6700\\u957f\\u5b50\\u5e8f\\u5217\\uff0c\\u91c7\\u82f9\\u679c\\u4e0d\\u80fd\\u540e\\u9000\\u4e5f\\u4e0d\\u80fd\\u8df3\\u8fc7\\uff0c\\u6240\\u4ee5\\u5c31\\u662f\\u8fde\\u7eed\\u5b50\\u4e32,\\u91c7\\u7684\\u82f9\\u679c\\u4e2a\\u6570\\u5c31\\u6307\\u7684\\u662f\\u5b50\\u4e32\\u957f\\u5ea6\\n        # \\u8ddf\\u4e4b\\u524d\\u7684\\u9898\\u76ee\\u4e00\\u6a21\\u4e00\\u6837\\n        \\n        k = 2\\n        n = len(tree)\\n        if n < k:\\n            return n\\n        \\n        i = 0\\n        lookup = {}\\n        ans = 0\\n        # 1\\uff09\\u6709\\u65f6\\u5019\\u4f1a\\u6655\\u662f\\u627e\\u5230\\u5b57\\u5178\\u4e2d\\u7684\\u6700\\u5c0f\\u4e0b\\u6807\\uff0c\\u8fd8\\u662f\\u627e\\u5230\\u5b57\\u5178\\u4e2d\\u7684\\u91cd\\u590d\\u4e0b\\u6807\\n        # 2\\uff09\\u56e0\\u4e3a\\u8fd9\\u91cc\\u5e76\\u4e0d\\u662f\\u56e0\\u4e3a\\u51fa\\u73b0\\u91cd\\u590d\\u7684key\\u800c\\u9700\\u8981\\u79fb\\u52a8\\u5de6\\u6307\\u9488\\uff0c\\u800c\\u662f\\u56e0\\u4e3a\\u5b57\\u5178\\u91cc\\u5143\\u7d20\\u592a\\u591a\\u4e86\\u800c\\u8981\\u79fb\\u52a8\\u5de6\\u6307\\u9488\\n        # 3\\uff09\\u8981\\u627e\\u5230\\u91cd\\u590d\\u4e86\\u7684key\\uff0c\\u90a3\\u4e48\\u5c31\\u9700\\u8981\\u5728\\u63d2\\u5165\\u4e4b\\u524d\\u53bb\\u5224\\u65ad, \\u9047\\u5230\\u91cd\\u590d\\u7684\\u952e\\u503ci = max(i, 1+lookUp[nums[j]])\\n        # 4\\uff09\\u5b57\\u5178\\u957f\\u5ea6\\u8d85\\u6807\\uff0c\\u4e0d\\u6015\\u91cd\\u590d\\uff0c\\u56e0\\u4e3a\\u91cd\\u590d\\u7684\\u5f55\\u5165\\u540c\\u4e00\\u4e2a\\u952e\\u503c\\u4e00\\u76f4\\u8bb0\\u5f55\\u7684\\u8be5key\\u6700\\u540e\\u4e00\\u6b21\\u51fa\\u73b0\\u7684\\u4f4d\\u7f6e\\uff0c\\n        #    4.1\\uff09i_min = min(lookup.values()), \\u53e6 i= i_min+1, \\u4e4b\\u6240\\u4ee5\\u8981\\u4e00\\u4e2a\\u4e2d\\u95f4\\u53d8\\u91cfi_min\\uff0c\\u662f\\u56e0\\u4e3a\\u540e\\u9762\\u8981\\u7528\\u5b83\\u53bb\\u5220\\u9664\\u952e\\u503c\\n        #    4.2\\uff09\\u540c\\u65f6\\u5220\\u9664\\u8fd9\\u4e2akey\\uff0c\\u5426\\u5219\\u4f60\\u6bcf\\u6b21\\u53d6min\\u90fd\\u4f1a\\u627e\\u5230\\u8fd9\\u4e2a\\u6570\\u61c2\\u5417\\n        for j in range(n):\\n            lookup[tree[j]] = j\\n            if len(lookup) <= k:\\n                ans = max(ans, j-i+1)\\n            else:\\n                i_min = min(lookup.values())\\n                del lookup[tree[i_min]]\\n                i = i_min + 1\\n                \\n        return ans\\n                \\n            \\n            \\n\", \"class Solution:\\n    def totalFruit(self, tree):\\n        res = cur = count_b = a = b = 0\\n        for c in tree:\\n            cur = cur + 1 if c in (a, b) else count_b + 1\\n            count_b = count_b + 1 if c == b else 1\\n            if b != c: a, b = b, c\\n            res = max(res, cur)\\n        return res\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        # \\u5305\\u542b\\u4e24\\u4e2a\\u5143\\u7d20\\u7684\\uff08\\u56e0\\u4e3a\\u9898\\u76ee\\u8bf4\\u662f\\u4e24\\u4e2a\\u7bee\\u5b50\\uff09\\u7684\\u6700\\u957f\\u5b50\\u5e8f\\u5217\\uff0c\\u91c7\\u82f9\\u679c\\u4e0d\\u80fd\\u540e\\u9000\\u4e5f\\u4e0d\\u80fd\\u8df3\\u8fc7\\uff0c\\u6240\\u4ee5\\u5c31\\u662f\\u8fde\\u7eed\\u5b50\\u4e32,\\u91c7\\u7684\\u82f9\\u679c\\u4e2a\\u6570\\u5c31\\u6307\\u7684\\u662f\\u5b50\\u4e32\\u957f\\u5ea6\\n        # \\u8ddf\\u4e4b\\u524d\\u7684\\u9898\\u76ee\\u4e00\\u6a21\\u4e00\\u6837\\n        \\n        k = 2\\n        n = len(tree)\\n        if n < k:\\n            return n\\n        \\n        i = 0\\n        lookup = {}\\n        ans = 0\\n        # 1\\uff09\\u6709\\u65f6\\u5019\\u4f1a\\u6655\\u662f\\u627e\\u5230\\u5b57\\u5178\\u4e2d\\u7684\\u6700\\u5c0f\\u4e0b\\u6807\\uff0c\\u8fd8\\u662f\\u627e\\u5230\\u5b57\\u5178\\u4e2d\\u7684\\u91cd\\u590d\\u4e0b\\u6807\\n        # 2\\uff09\\u56e0\\u4e3a\\u8fd9\\u91cc\\u5e76\\u4e0d\\u662f\\u56e0\\u4e3a\\u51fa\\u73b0\\u91cd\\u590d\\u7684key\\u800c\\u9700\\u8981\\u79fb\\u52a8\\u5de6\\u6307\\u9488\\uff0c\\u800c\\u662f\\u56e0\\u4e3a\\u5b57\\u5178\\u91cc\\u5143\\u7d20\\u592a\\u591a\\u4e86\\u800c\\u8981\\u79fb\\u52a8\\u5de6\\u6307\\u9488\\n        # 3\\uff09\\u8981\\u627e\\u5230\\u91cd\\u590d\\u4e86\\u7684key\\uff0c\\u90a3\\u4e48\\u5c31\\u9700\\u8981\\u5728\\u63d2\\u5165\\u4e4b\\u524d\\u53bb\\u5224\\u65ad, \\u9047\\u5230\\u91cd\\u590d\\u7684\\u952e\\u503ci = max(i, 1+lookUp[nums[j]])\\n        # 4\\uff09\\u5b57\\u5178\\u957f\\u5ea6\\u8d85\\u6807\\uff0c\\u4e0d\\u6015\\u91cd\\u590d\\uff0c\\u56e0\\u4e3a\\u91cd\\u590d\\u7684\\u5f55\\u5165\\u540c\\u4e00\\u4e2a\\u952e\\u503c\\u4e00\\u76f4\\u8bb0\\u5f55\\u7684\\u8be5key\\u6700\\u540e\\u4e00\\u6b21\\u51fa\\u73b0\\u7684\\u4f4d\\u7f6e\\uff0c\\n        #    4.1\\uff09i_min = min(lookup.values()), \\u53e6 i= i_min+1, \\u4e4b\\u6240\\u4ee5\\u8981\\u4e00\\u4e2a\\u4e2d\\u95f4\\u53d8\\u91cfi_min\\uff0c\\u662f\\u56e0\\u4e3a\\u540e\\u9762\\u8981\\u7528\\u5b83\\u53bb\\u5220\\u9664\\u952e\\u503c\\n        #    4.2\\uff09\\u540c\\u65f6\\u5220\\u9664\\u8fd9\\u4e2akey\\uff0c\\u5426\\u5219\\u4f60\\u6bcf\\u6b21\\u53d6min\\u90fd\\u4f1a\\u627e\\u5230\\u8fd9\\u4e2a\\u6570\\u61c2\\u5417\\n        for j in range(n):\\n            lookup[tree[j]] = j\\n            if len(lookup) > k:\\n                i_min = min(lookup.values())\\n                del lookup[tree[i_min]]\\n                i = i_min + 1\\n            ans = max(ans, j-i+1)\\n                \\n        return ans\\n                \\n            \\n            \\n\", \"class Solution:\\n    def totalFruit(self, tree) -> int:\\n        if len(tree) < 3:\\n            return len(tree)\\n        seq_len = [[tree[0], 0]]\\n        for f in tree:\\n            if seq_len[-1][0] == f:\\n                seq_len[-1][1] += 1\\n            else:\\n                seq_len.append([f, 1])\\n        most = seq_len[0][1]\\n        if len(seq_len) > 1:\\n            curr_two_types = set([seq_len[0][0], seq_len[1][0]])\\n            most = curr_most = seq_len[0][1] + seq_len[1][1]\\n            for i in range(2, len(seq_len)):\\n                if seq_len[i][0] in curr_two_types:\\n                    curr_most += seq_len[i][1]\\n                else:\\n                    curr_most = seq_len[i][1] + seq_len[i-1][1]\\n                    curr_two_types = set([seq_len[i][0], seq_len[i-1][0]])\\n                most = max(most, curr_most)\\n        return most\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        '''\\n        Sliding window: the window can at most only have two distinct numbers\\n        Find the longest sliding window\\n        Technique: keep the last seen index of each fruit type in my current sliding window\\n        seen: { x: i, y: j }\\n        Whenever a new type of fruit is ahead, fast forward the left boundary to min(i,j) + 1\\n        '''\\n        ans = 0\\n        lo, hi = -1, 0\\n        seen = {}\\n        for hi in range(len(tree)):\\n            if tree[hi] not in seen and len(seen) == 2:\\n                # tree[hi] is not in seen and seen already has 2 elements\\n                remove = (float('inf'), None)\\n                for typ in seen:\\n                    remove = min(remove, (seen[typ], typ))\\n                lo = seen.pop(remove[1])\\n            seen[tree[hi]] = hi\\n            #print(lo, hi, seen)\\n            ans = max(ans, hi-lo)\\n        return ans\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        count, i = {}, 0\\n        for j, v in enumerate(tree):\\n            count[v] = count.get(v, 0) + 1\\n            if len(count) > 2:\\n                count[tree[i]] -= 1\\n                if count[tree[i]] == 0: del count[tree[i]]\\n                i += 1\\n        return j - i + 1\\n\", \"class Solution:\\n    \\n    \\n    def totalFruit(self, tree: List[int]) -> int:\\n        \\n        max_count = pair_count = last_count = 0\\n        fruit_1 = fruit_2 = last_fruit = None\\n        \\n        for fruit_type in tree:\\n            if fruit_type == fruit_1:\\n                pair_count += 1\\n                if fruit_type == last_fruit:\\n                    last_count += 1\\n                else:\\n                    last_fruit = fruit_type\\n                    last_count = 1\\n            elif fruit_type == fruit_2:\\n                pair_count += 1\\n                if fruit_type == last_fruit:\\n                    last_count += 1\\n                else:\\n                    last_fruit = fruit_type\\n                    last_count = 1\\n            elif fruit_1 == None:\\n                fruit_1 = last_fruit = fruit_type\\n                last_count = 1\\n                pair_count += 1\\n            elif fruit_2 == None:\\n                fruit_2 = last_fruit = fruit_type\\n                last_count = 1\\n                pair_count += 1\\n            else:\\n                fruit_1 = last_fruit\\n                fruit_2 = last_fruit = fruit_type\\n                max_count = max(max_count, pair_count)\\n                pair_count = last_count+1\\n                last_count = 1\\n        \\n        return max(max_count, pair_count)\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        ans=0\\n        past=[]\\n        last=[]\\n        for i in range(len(tree)):\\n            #print(past,last)\\n            if len(past)==0:\\n                past.append(tree[i])\\n                last.append(i)\\n                ans=max((i-last[0]+1),ans)\\n                continue\\n            if len(past)==1:\\n                if tree[i] not in past:\\n                    past.append(tree[i])\\n                    last.append(i)\\n                ans=max((i-last[0]+1),ans)\\n                continue\\n            if tree[i] not in past:\\n                bt=i-1\\n                ele=tree[bt]\\n                while tree[bt]==ele:\\n                    bt-=1\\n                bt+=1\\n                past=[tree[bt],tree[i]]\\n                last=[bt,i]\\n            ans=max((i-last[0]+1),ans)\\n        return ans\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        n = len(tree)\\n        \\n        if n < 3:\\n            return n\\n        \\n        max_count = 0\\n\\n        set_1 = {tree[0]}\\n        count_1 = 1\\n        set_2 = set_1.copy()\\n        count_2 = 1\\n        \\n        \\n        for i in range(1, n):\\n            if tree[i] in set_2:\\n                count_2 += 1\\n            else:\\n                temp = set_1.copy()\\n                temp.add(tree[i])\\n                set_2 = temp\\n                count_2 = count_1 + 1\\n            if tree[i] in set_1:\\n                count_1 += 1\\n            else:\\n                set_1 = {tree[i]}\\n                count_1 = 1\\n                \\n            max_count = max(max_count, max(count_1, count_2))\\n            \\n            \\n        return max_count\\n                \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        l = 0\\n        count = {}\\n        \\n        for r, value in enumerate(tree):\\n            count[value] = count.get(value,0)+1\\n            if len(count) > 2:\\n                count[tree[l]] -= 1\\n                if count[tree[l]] == 0:\\n                    del count[tree[l]]\\n                l += 1\\n                \\n        return r-l+1\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        res, start, distince_count, visited = 0, 0, 0, [0] * len(tree)\\n        for i, c in enumerate(tree):\\n            if visited[c] == 0:\\n                distince_count += 1\\n            visited[c] += 1\\n\\n            while distince_count > 2:\\n                visited[tree[start]] -= 1\\n                if visited[tree[start]] == 0:\\n                    distince_count -= 1\\n\\n                start += 1\\n\\n            res = max(res, i - start + 1)\\n\\n        return res\\n\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        res = cur = count_b = a = b = 0\\n        for c in tree:\\n            cur = cur + 1 if c in (a, b) else count_b + 1\\n            count_b = count_b + 1 if c == b else 1\\n            if b != c: a, b = b, c\\n            res = max(res, cur)\\n        return res\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        '''\\n        \\u884c\\u4e0d\\u901a\\u7684 example4\\u5c31\\u4e0d\\u6ee1\\u8db3\\n        #\\u6700\\u957f\\u7684bi-value subarray\\n        #\\u8bb0\\u5f55\\u5230i\\u5904\\u4e00\\u5171\\u51e0\\u79cd\\u6570\\u51fa\\u73b0\\uff0c\\u4e24\\u4e2a\\u51cf\\u51fa\\u6765=2\\u610f\\u5473\\u7740\\u4e2d\\u95f4\\u53ea\\u6709\\u4e24\\u79cd\\u3002subarray\\u6807\\u51c6\\u5957\\u8def.\\n        from collections import Counter\\n        n = len(tree)\\n        record = []\\n        \\n        for i in range(n):\\n            a = len(Counter(tree[:i+1]))\\n            record.append(a)\\n        print(record)\\n        dic = {}\\n        ans = 0\\n        dic[0] = [-1,-1] #\\u8bb0\\u5f55\\u7b2c\\u4e00\\u6b21\\u51fa\\u73b0\\u548c\\u6700\\u540e\\u4e00\\u6b21\\u51fa\\u73b0\\u7684\\u4f4d\\u7f6e\\n        for i in range(n):\\n            if record[i] not in dic.keys():\\n                dic[record[i]] = [i,i]\\n            else:\\n                dic[record[i]][1] = i\\n            \\n            if record[i]-2 in dic.keys():\\n                print(i,dic[record[i]],dic[record[i]-2])\\n                ans = max(ans,dic[record[i]][1]-dic[record[i]-2][1])\\n                print('ans=',ans)\\n            \\n        \\n        return ans\\n        '''\\n        #sliding  window, two pointers:x,i\\n        n = len(tree)\\n        dic = {}\\n        x = 0\\n        for i in range(n):\\n            if tree[i] not in dic.keys():\\n                dic[tree[i]] = 1\\n            else:\\n                dic[tree[i]] += 1\\n            \\n            if len(dic) > 2:\\n                dic[tree[x]] -= 1\\n                if dic[tree[x]]==0 :\\n                    del dic[tree[x]]\\n                x +=1\\n        return i-x+1\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        deq = []\\n        currentTwo = set()\\n        result = 0\\n        temp = 0\\n        for e in tree:\\n            if len(deq) == 0:\\n                currentTwo.add(e)\\n                deq.append((e, 1))\\n                temp = 1\\n            elif e in currentTwo:\\n                if e == deq[-1][0]:\\n                    deq[-1] = (e, deq[-1][1]+1)\\n                    temp += 1\\n                else:\\n                    deq.append((e,1))\\n                    temp += 1\\n            else:\\n                previousOne = deq[-1][0]\\n                currentTwo = set([previousOne, e])\\n                deq = deq[-1:]\\n                temp = deq[-1][1]\\n                deq.append((e, 1))\\n                temp += 1\\n\\n            result = max(result, temp)\\n\\n        return result\\n        \\n\", \"class Solution:\\n    def totalFruit(self, tree) -> int:\\n        if len(tree) < 3:\\n            return len(tree)\\n\\n        # i = 0\\n        # while i < len(tree) and tree[i] == tree[0]:\\n        #     i += 1\\n        # if i == len(tree):\\n        #     return i\\n        # most_fruit = i + 1\\n        # first_type, f_counter = tree[0], i\\n        # second_type, s_counter = tree[i], 1\\n\\n        seq_len = [[tree[0], 0]]\\n        for f in tree:\\n            if seq_len[-1][0] == f:\\n                seq_len[-1][1] += 1\\n            else:\\n                seq_len.append([f, 1])\\n        most = curr_most = seq_len[0][1]\\n        # print(seq_len)\\n        if len(seq_len) > 1:\\n            curr_two_types = set([seq_len[0][0], seq_len[1][0]])\\n            most = curr_most = seq_len[0][1] + seq_len[1][1]\\n            for i in range(2, len(seq_len)):\\n                if seq_len[i][0] in curr_two_types:\\n                    curr_most += seq_len[i][1]\\n                else:\\n                    curr_most = seq_len[i][1] + seq_len[i-1][1]\\n                    curr_two_types = set([seq_len[i][0], seq_len[i-1][0]])\\n                most = max(most, curr_most)\\n                # print(\\\\\\\"---\\\\\\\", most)\\n        return most\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        letter_count = collections.defaultdict(int)\\n        left, right = 0, 0\\n\\n        while right < len(tree):\\n            letter_count[tree[right]] += 1\\n            right += 1\\n\\n            if len(letter_count) > 2:\\n                letter_count[tree[left]] -= 1\\n                if letter_count[tree[left]] == 0:\\n                    del letter_count[tree[left]]\\n                left += 1\\n\\n        return right - left\\n\", \"class Solution:\\n    def totalFruit(self, tree):\\n        ans = cur = one = two = count_one = count_two = 0\\n        for i in tree:\\n            if i not in (one, two):\\n                cur = count_two + 1\\n            else:\\n                cur += 1\\n            if i != two:\\n                one, two = two, i\\n                count_two = 1\\n            else:\\n                count_two += 1\\n            ans = max(ans, cur)\\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if not len(tree):\\n            return 0\\n        count_max = 0\\n        start = 0\\n        f_num = tree[0]\\n        tracking = set()\\n        tracking.add(f_num)\\n        last_change = 0\\n        current_num = tree[0]\\n        for i in range(1, len(tree)):\\n            if tree[i] not in tracking:\\n                if len(tracking) >= 2:\\n                    count_max = max(i-start, count_max)\\n                    tracking.remove(f_num)\\n                    tracking.add(tree[i])\\n                    f_num = current_num\\n                    start = last_change\\n                    \\n                else:\\n                    tracking.add(tree[i])\\n            if tree[i] != current_num:\\n                last_change = i\\n                f_num = current_num\\n                current_num = tree[i]\\n        count_max = max(len(tree)-start, count_max)\\n        return count_max\\n\\n                \\n                \\n\", \"class Solution:\\n    # def totalFruit(self, tree):\\n    #     # scan the array\\n    #     fruit_block = []\\n    #     #fruit_block entity = [left_most index in fruit, weight]\\n    #     for i in range(len(tree)):\\n    #         if i == 0 or tree[i] != tree[i-1]:\\n    #             fruit_block.append([i, 1 ])\\n    #         elif tree[i] == tree[i-1]:\\n    #             fruit_block[-1][1] += 1\\n    #     # print(fruit_block)\\n    #     max_fruit = 0\\n    #     i = 0\\n    #     while i < len(fruit_block):\\n    #         old_i = i\\n    #         type_fruit = []\\n    #         weight = 0\\n    #         for j in range(i, len(fruit_block)):\\n    #             if tree[fruit_block[j][0]] not in type_fruit:\\n    #                 type_fruit.append(tree[fruit_block[j][0]])\\n    #             weight += fruit_block[j][1]\\n    #             # print(\\\\\\\"type fruit \\\\\\\", type_fruit)\\n    #             # print(\\\\\\\"weight \\\\\\\", weight)\\n    #             if len(type_fruit) > 2:\\n    #                 # print(\\\\\\\"break\\\\\\\")\\n    #                 i = j -1\\n    #                 break\\n    #             max_fruit = max(max_fruit, weight)\\n    #             if j == len(fruit_block):\\n    #                 break\\n    #         if i == old_i:\\n    #             break\\n    #     return max_fruit\\n            \\n        \\n#     def totalFruit(self, tree: List[int]) -> int:\\n        \\n#         greattest_count = 0\\n#         for i in range(len(tree)):\\n#             if i > 0 and tree[i] == tree[i-1]:\\n#                 print(i)\\n#                 continue\\n#             if i > 2 and tree[i] == tree[i-2] and tree[i-1] == tree[i-3] and tree[i] != tree[i-1] and self.checkRepeat(tree, i):\\n#                 #add function to define tree[i-1] == the newest tree after ones that look like tree[i]\\n#                 print(i)\\n#                 continue\\n#             fruit = self.pickFruit(i, tree)\\n#             if fruit > greattest_count:\\n#                 greattest_count = fruit\\n#         return greattest_count\\n                \\n#             # print(count)\\n#             # print(greattest_count)\\n        \\n#         return greattest_count\\n    \\n#     def checkRepeat(self,tree, i):\\n#         for j in range(i, len(tree)):\\n#             if tree[j] != tree[i]:\\n#                 return tree[j]==tree[i-1]\\n#         return True\\n                \\n    \\n#     def pickFruit(self, i, tree):\\n#         count = 0\\n#         basket=[\\\\\\\"\\\\\\\", \\\\\\\"\\\\\\\"]\\n#         for j in range(i, len(tree)):\\n#             if basket[0] == \\\\\\\"\\\\\\\":\\n#                 basket[0] = tree[j]\\n#                 # print(\\\\\\\"basket1: \\\\\\\", basket[0])\\n#                 count += 1\\n#                 # print(\\\\\\\"basket1\\\\\\\")\\n#             elif tree[j] == basket[0]:\\n#                 count+=1\\n#                 # print(\\\\\\\"already in basket1\\\\\\\")\\n#             elif basket[1] == \\\\\\\"\\\\\\\":\\n#                 basket[1] = tree[j]\\n#                 count += 1\\n#                 # print(\\\\\\\"basket2: \\\\\\\", basket[1])\\n#             elif tree[j] == basket[1]:\\n#                 count += 1\\n#                 # print(\\\\\\\"already in basket2\\\\\\\")\\n#             elif tree[j] not in basket:\\n#                 return count\\n#             if j == len(tree)-1:\\n#                 return count\\n\\n    def totalFruit(self, tree: List[int]) -> int:\\n        basket1 = -1\\n        basket2 = -1\\n        max_fruit = 0\\n        start = 0\\n        end = 0\\n        i = 0\\n        while i < len(tree):\\n            if tree[i] == basket1 or tree[i] == basket2:\\n                if tree[i] != tree[i-1]:\\n                    end = i\\n                i += 1\\n                continue\\n            if basket1 == -1:\\n                basket1 = tree[i]\\n                end = i\\n                i += 1\\n                continue\\n            if basket2 == -1:\\n                basket2 = tree[i]\\n                end = i\\n                i += 1\\n                continue\\n            print(i)\\n            print(end)\\n            weight = i - start \\n            max_fruit = max(max_fruit, weight)\\n            #max_fruit = 2 - 0 = 2\\n            i = end # 1\\n            start = end # 1\\n            basket1 = -1\\n            basket2 = -1\\n        # if start == 0:\\n        #     weight = len(tree)\\n        # else:\\n        #     weight = len(tree) - start - 1\\n        weight = len(tree) - start\\n            \\n        \\n        max_fruit = max(max_fruit, weight)\\n            \\n        return max_fruit\", \"class Solution:\\n    def totalFruit(self, t: List[int]) -> int:\\n        st,a,b,a_hi,res,b_hi = 0,t[0],-1,0,0,0\\n        for i,v in enumerate(t):\\n            if v != a and b == -1:\\n                b = v\\n                b_hi = i\\n            elif v == a:\\n                a_hi = i\\n            elif v == b:\\n                b_hi = i\\n            elif v not in (a,b):\\n                res = max(res,i-st)\\n                st_m = min(a_hi,b_hi)\\n                a,b,st,a_hi,b_hi = t[st_m+1],v,st_m+1,max(a_hi,b_hi),i\\n        return max(res,len(t)-st)\\n\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        dic = {}\\n        i = 0\\n        j = 0\\n        MAX = 1\\n        \\n        if tree == None or len(tree) == 0:\\n            return None\\n        \\n        while j < len(tree):\\n            if len(dic) <= 2:\\n                dic[tree[j]] = j\\n                j+=1\\n            if len(dic) > 2:\\n                mins = len(tree) -1\\n                \\n                for val in list(dic.values()):\\n                    mins = min(mins,val)\\n                \\n                i = mins + 1\\n                del dic[tree[mins]]\\n            \\n            MAX = max(MAX,j-i)\\n        return MAX\\n            \\n                              \\n                \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if not tree:\\n            return 0\\n        l = 0\\n        mp = collections.defaultdict(int)\\n        fruits = 1\\n        for i in range(0, len(tree)):\\n            mp[tree[i]] += 1\\n            while len(mp) > 2:\\n                mp[tree[l]] -= 1\\n                if mp[tree[l]] == 0:\\n                    del mp[tree[l]]\\n                l += 1\\n            fruits = max(fruits, i-l+1)\\n        return fruits\\n            \\n                \\n                \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        left = 0\\n        right = 0\\n        window = set()\\n        res = 0\\n        last_index = collections.defaultdict(int)\\n        \\n        for right in range(len(tree)):\\n            fruit_type = tree[right]\\n            last_index[fruit_type] = right\\n            if tree[right] in window or len(window) < 2:\\n                window.add(tree[right])\\n            else:\\n                window.add(tree[right])\\n                while len(window) > 2:\\n                    fruit_type = tree[left]\\n                    if left == last_index[fruit_type]:\\n                        window.remove(fruit_type)\\n                    left += 1\\n            res = max(res, right - left + 1)\\n        return res\\n\", \"# longest run that only contains two symbols?\\n# 6:52 -> 7:01 TLE on naive n^2 solution\\nclass Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        counts = 0\\n        starts = {}\\n        start = end = 0\\n        longest = 0\\n        \\n        def find_earliest(starts):\\n            earliest = len(tree)\\n            for key in starts:\\n                earliest = min(starts[key], earliest)\\n            return earliest\\n        \\n        while end < len(tree):\\n            # print(start, end, starts)\\n            current = tree[end]\\n            if current in starts:\\n                starts[current] = end\\n                end += 1\\n            else:\\n                if counts == 2:\\n                    earliest = find_earliest(starts)\\n                    del starts[tree[earliest]]\\n                    start = earliest + 1\\n                    counts -= 1\\n                else:\\n                    starts[current] = end\\n                    counts += 1\\n                    end += 1\\n            longest = max(end - start, longest)\\n        \\n        return max(end - start, longest)\\n        \\n        \\n#         longest = 0\\n        \\n#         def contains_two_symbols(subarray):\\n#             c = Counter(subarray)\\n#             contains = 0\\n#             for key in c:\\n#                 if c[key]:\\n#                     contains += 1\\n#             return contains < 3\\n            \\n#         for i in range(len(tree)):\\n#             for j in range(i + 1, len(tree) + 1):\\n#                 if contains_two_symbols(tree[i:j]):\\n#                     longest = max(longest, j - i)\\n        \\n#         return longest\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        ans = i = 0\\n        count = collections.defaultdict(int)\\n        for j, ftype in enumerate(tree):\\n            count[ftype] += 1\\n            while len(count) > 2:\\n                count[tree[i]] -= 1\\n                if count[tree[i]] == 0:\\n                    count.pop(tree[i])\\n                i += 1\\n            ans = max(ans, j - i + 1)\\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        # length of the longest subarray containing at most 2 distinct elements\\n        if len(tree) == 0: return 0\\n        i, j, n_kind, res = 0, 0, 1, 1\\n        cnts = [0,] * len(tree)\\n        cnts[tree[0]] += 1\\n        while True:\\n            while n_kind <= 2:\\n                res = max(res, j-i+1)\\n                j += 1\\n                if j >= len(tree): \\n                    return res  # ?\\n                if cnts[tree[j]] == 0:\\n                    n_kind += 1\\n                cnts[tree[j]] += 1\\n            while n_kind > 2:\\n                cnts[tree[i]] -= 1\\n                if cnts[tree[i]] == 0:\\n                    n_kind -= 1\\n                i += 1\\n        return res\\n\", \"from collections import deque\\nclass Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        maxFruits = 0\\n        fruitTypes = set()        \\n        queue = deque()\\n        \\n        for i in tree:\\n            if i in fruitTypes or len(fruitTypes) < 2:\\n                fruitTypes.add(i)\\n            else:\\n                prevFruit = queue[-1]\\n                j = len(queue)-2\\n                while j >= 0 and queue[j] == prevFruit:\\n                    j -= 1\\n                while j >=0:\\n                    queue.popleft()\\n                    j -= 1\\n                for k in list(fruitTypes):\\n                    if k == prevFruit:\\n                        continue\\n                    else:\\n                        fruitTypes.remove(k)\\n                fruitTypes.add(i)\\n            queue.append(i)\\n            maxFruits = max(len(queue), maxFruits)\\n        return maxFruits\\n            \\n            \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        l, res, check = 0, 0, dict()\\n        for i, t in enumerate(tree):\\n            check[t] = check.get(t, 0) + 1\\n            if len(check) <= 2:\\n                res = max(res, i - l + 1)\\n            while len(check) > 2:\\n                check[tree[l]] -= 1\\n                if check[tree[l]] == 0:\\n                    del check[tree[l]]\\n                l += 1\\n        return res\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if len(tree) <= 2:\\n            return len(tree)\\n        collection_list = [tree[0]]\\n        counter = 1\\n        _max = 1\\n        rep = 1\\n        for i in range(1, len(tree)):\\n            if tree[i] in collection_list:\\n                if tree[i] == tree[i-1]:\\n                    rep += 1\\n                else:\\n                    rep = 1\\n                counter += 1\\n                if counter > _max:\\n                    _max = counter\\n            else:\\n                if len(collection_list) == 1:\\n                    collection_list.append(tree[i])\\n                    counter += 1\\n                    rep = 1\\n                    if counter > _max:\\n                        _max = counter\\n                else:\\n                    collection_list = [tree[i-1], tree[i]]\\n                    counter = 1 + rep\\n                    rep = 1\\n        return _max\", \"from collections import Counter\\nclass Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        d = collections.defaultdict(int)\\n        left = 0 \\n        total = 0\\n        for idx, i in enumerate(tree):\\n            d[i] += 1 \\n            while(len(d) > 2):\\n                d[tree[left]] -= 1 \\n                if(d[tree[left]] == 0):\\n                    del d[tree[left]]\\n                left += 1 \\n                \\n            total = max(total, idx - left + 1)\\n        return total\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if len(tree) == 0 or len(tree) == 1:\\n            return len(tree);\\n        A = [-1]*2\\n        B = [-1]*2\\n        f1 = -1\\n        f2 = -1\\n        n = len(tree)\\n        maxi = 1\\n        i=0\\n        while i<n:\\n            if tree[i]==f1 or tree[i]==f2:\\n                if tree[i]==f1:\\n                    A[1]=i\\n                else: \\n                    B[1]=i\\n            else:\\n                if tree[i-1]==f1:\\n                    f2=tree[i]\\n                    A[0]=B[1]+1\\n                    B[0]=B[1]=i\\n                else:\\n                    f1=tree[i]\\n                    B[0]=A[1]+1\\n                    A[0]=A[1]=i\\n                \\n            maxi = max(maxi,max(A[1],B[1])-min(A[0],B[0]))\\n            i = i+1\\n        return maxi+1\\n            \\n\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        idx, baskets, res = -1, collections.deque(maxlen=2), 0\\n        for i, x in enumerate(tree):\\n            if x not in [y[0] for y in baskets]:\\n                if len(baskets) == 2:\\n                    res, idx = max(res, i - idx - 1), baskets[0][1]\\n                baskets.append([x, i])\\n            else:\\n                if x == baskets[0][0]:\\n                    baskets.popleft()\\n                    baskets.append([x, i])\\n                else:\\n                    baskets[1][1] = i\\n                \\n        return max(res, len(tree) - 1 - idx)\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        \\n        store = collections.defaultdict(lambda:0)\\n        ans = 0\\n        i=0\\n        for k,val in enumerate(tree):\\n            store[val]+=1\\n            while len(store)>2:\\n                store[tree[i]]-=1\\n                if store[tree[i]]==0:\\n                    del store[tree[i]]\\n                i+=1\\n            ans = max(ans,k-i+1)\\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        f1, f2= [-1,-1],[-1,-1]\\n        res, fruit1, fruit2 = 0, -1, -1\\n        for i in range(len(tree)):\\n            if tree[i] not in [fruit1,fruit2]:   \\n                if f2[1]>f1[1]:\\n                    f2[0] = f1[1]+1\\n                    f1 = [i,i]\\n                    fruit1 = tree[i]\\n                else:\\n                    f1[0] = f2[1]+1\\n                    f2 = [i,i]\\n                    fruit2 = tree[i]\\n            elif tree[i] == fruit1: f1[1] = i\\n            else: f2[1] = i\\n            res = max(res,max(f1[1],f2[1]) - min(f1[0],f2[0]))\\n        return res+1\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        \\n        # compress the tree\\n        compressedTree = []\\n        \\n        current = [tree[0], 0]\\n        for index in range(len(tree)):\\n            fruit = tree[index]\\n            if fruit != current[0]:\\n                compressedTree.append(current)\\n                current = [fruit, 1]\\n            else:\\n                current[1] += 1\\n        compressedTree.append(current)\\n        \\n        ans = i = 0\\n        while i < len(compressedTree):\\n            # We'll start our scan at block[i].\\n            # types : the different values of tree[i] seen\\n            # weight : the total number of trees represented\\n            #          by blocks under consideration\\n            types, weight = set(), 0\\n\\n            # For each block from i and going forward,\\n            for j in range(i, len(compressedTree)):\\n                # Add each block to consideration\\n                types.add(compressedTree[j][0])\\n                weight += compressedTree[j][1]\\n\\n                # If we have 3 types, this is not a legal subarray\\n                if len(types) >= 3:\\n                    i = j-1\\n                    break\\n\\n                ans = max(ans, weight)\\n\\n            # If we go to the last block, then stop\\n            else:\\n                break\\n\\n        return ans\", \"from collections import defaultdict\\n\\nclass Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        l, r = 0, 0\\n        d = defaultdict(int)\\n        res = 0\\n        \\n        \\n        for r in range(len(tree)):\\n            d[tree[r]] += 1\\n            while len(d) > 2:\\n                #print(l)\\n                d[tree[l]] -= 1\\n                if d[tree[l]] == 0:\\n                    d.pop(tree[l])\\n                l += 1\\n            res = max(res, r - l + 1)\\n            #print(r,l)\\n        \\n        return res\\n        \\n#         while r < len(tree):\\n            \\n#             while len(d) <= 2:\\n#                 r += 1\\n#                 if r < len(tree):\\n#                     d[tree[r]] += 1\\n#                 else:\\n#                     break\\n                \\n#             if len(d) > 2 or r == len(tree):\\n#                 res = max(res, r - l)\\n                \\n# #            print(\\\\\\\"1s\\\\\\\", r, l)\\n            \\n#             while len(d) > 2:\\n#                 d[tree[l]] -= 1\\n#                 if d[tree[l]] == 0:\\n#                     d.pop(tree[l])\\n#                 l += 1\\n                \\n# #            print(\\\\\\\"2s\\\\\\\", r, l)\\n#         return res\\n            \\n        \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        '''\\n            [0,1,2,2]\\n            ^\\n            \\n            [3,3,3,1,2,1,1,2,3,3,4]\\n        \\n        \\n        '''\\n        n = len(tree)\\n        res = 0\\n        \\n        window = defaultdict(int)\\n        count = 0\\n        left =  0\\n        \\n        for idx in range(n):\\n            curr = tree[idx]\\n            if window[curr] == 0:\\n                count += 1\\n            window[curr] += 1\\n            if count <= 2:\\n                res = max(res, idx - left + 1)\\n            while count > 2:\\n                window[tree[left]] -= 1\\n                if window[tree[left]] == 0:\\n                    count -= 1\\n                left += 1\\n        return res\\n    \\n                \\n            \\n            \\n                \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        left = 0\\n        right = 0\\n        window = set()\\n        res = 0\\n        last_index = collections.defaultdict(int)\\n        \\n        while left < len(tree) and right < len(tree):\\n            fruit_type = tree[right]\\n            last_index[fruit_type] = right\\n            if tree[right] in window or len(window) < 2:\\n                window.add(tree[right])\\n            else:\\n                window.add(tree[right])\\n                while len(window) > 2:\\n                    fruit_type = tree[left]\\n                    if left == last_index[fruit_type]:\\n                        window.remove(fruit_type)\\n                    left += 1\\n            res = max(res, right - left + 1)\\n            right += 1\\n        return res\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        best_so_far = start = 0\\n        fruit_1 = fruit_2 = fruit_1_last_index = fruit_2_last_index = None\\n        \\n        for end in range(len(tree)):\\n            # If we haven't picked any fruit yet, put this fruit in basket 1\\n            if fruit_1 is None:\\n                fruit_1 = tree[end]\\n                fruit_1_last_index = end\\n                \\n            # If we haven't picked two different fruits yet, put this fruit in backet 2\\n            elif fruit_2 is None and tree[end] != fruit_1:\\n                fruit_2 = tree[end]\\n                fruit_2_last_index = end\\n                \\n            # We have picked at least 2 different fruits so far\\n            else:\\n                # If this is basket 1's fruit, remember this as the most recent place we saw fruit 1\\n                if tree[end] == fruit_1:\\n                    fruit_1_last_index = end\\n                    \\n                # If this is basket 2's fruit, remember this as the most recent place we saw fruit 2\\n                elif tree[end] == fruit_2:\\n                    fruit_2_last_index = end\\n                    \\n                # This is neither fruit 1 nor fruit 2\\n                else:\\n                    # This is as far as we can go with these two fruits. Remember how many fruits we got.\\n                    best_so_far = max(best_so_far, end - start)\\n                    \\n                    # Replace <the fruit whose most recent sighting was longer ago> with this new fruit\\n                    if fruit_1_last_index < fruit_2_last_index:\\n                        start = fruit_1_last_index + 1\\n                        fruit_1 = tree[end]\\n                        fruit_1_last_index = end\\n                    else:\\n                        start = fruit_2_last_index + 1\\n                        fruit_2 = tree[end]\\n                        fruit_2_last_index = end\\n        \\n        return max(best_so_far, len(tree) - start)\", \"class Solution:\\n    \\n    def totalFruit(self, tree: List[int]) -> int:\\n        \\n        blocks = [(k, len(list(v))) for k, v in itertools.groupby(tree)]\\n        \\n        ans = i = 0\\n        \\n        while i < len(blocks):\\n            \\n            types, weight = set(), 0\\n            \\n            for j in range(i, len(blocks)):\\n                \\n                types.add(blocks[j][0])\\n                \\n                weight += blocks[j][1]\\n                \\n                if len(types) >= 3:\\n                    \\n                    i = j - 1\\n                    \\n                    break\\n                    \\n                ans = max(ans, weight)\\n                \\n                \\n            else:\\n                \\n                break\\n                \\n        return ans\\n            \\n            \\n        \\n            \\n            \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        count, i, j = {}, 0, 0\\n        max_cnt = 0\\n        while j < len(tree):\\n            v = tree[j]\\n            count[v] = count.get(v, 0) + 1\\n            if len(count) <= 2:\\n                max_cnt = max(sum(count.values()), max_cnt)\\n            while len(count) > 2:\\n                count[tree[i]] -= 1\\n                if count[tree[i]] == 0: del count[tree[i]]\\n                i += 1\\n            j += 1\\n        return max_cnt\\n\", \"import collections\\nclass Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        left = 0\\n        right = 0\\n        fruitsTypes = defaultdict(int)\\n        numFruits = 0\\n        maxNumFruit = 0\\n        while(right < len(tree)):\\n            fruitsTypes[tree[right]] += 1\\n            numFruits += 1\\n            right += 1\\n            while len(fruitsTypes) > 2:\\n                fruitsTypes[tree[left]] -= 1\\n                if fruitsTypes[tree[left]] == 0:\\n                    del(fruitsTypes[tree[left]])\\n                numFruits -= 1\\n                left += 1\\n            maxNumFruit = max(maxNumFruit, numFruits)\\n        return maxNumFruit\\n                \\n                \\n            \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        maxCount = count = 0\\n        head = back = 0\\n        buckets = dict()\\n        while back < len(tree):\\n            fruit = tree[back]\\n            if fruit in buckets:\\n                buckets[fruit] += 1  \\n            else:\\n                buckets[fruit] = 1\\n                while len(list(buckets.keys())) > 2:\\n                    dropFruit = tree[head]\\n                    buckets[dropFruit] -= 1\\n                    if buckets[dropFruit] == 0:\\n                        buckets.pop(dropFruit)\\n                    count -= 1\\n                    head += 1\\n            count += 1\\n            maxCount = max(maxCount, count)\\n            back += 1\\n        return maxCount\\n                \\n                    \\n                    \\n            \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        result = 0\\n        left, right = 0, 0\\n        basket = collections.defaultdict(int)\\n        \\n        \\n        while right < len(tree):\\n            basket[tree[right]] += 1\\n            \\n            while len(basket) > 2:\\n                if basket[tree[left]] == 1:\\n                    basket.pop(tree[left])\\n                else:\\n                    basket[tree[left]] -= 1\\n                left += 1\\n            \\n            result = max(result, right - left + 1)\\n            right += 1\\n            \\n            \\n        return result\", \"class Solution(object):\\n    def totalFruit(self, tree):\\n        blocks = [(k, len(list(v)))\\n                  for k, v in itertools.groupby(tree)]\\n\\n        ans = i = 0\\n        while i < len(blocks):\\n            # We'll start our scan at block[i].\\n            # types : the different values of tree[i] seen\\n            # weight : the total number of trees represented\\n            #          by blocks under consideration\\n            types, weight = set(), 0\\n\\n            # For each block from i and going forward,\\n            for j in range(i, len(blocks)):\\n                # Add each block to consideration\\n                types.add(blocks[j][0])\\n                weight += blocks[j][1]\\n\\n                # If we have 3 types, this is not a legal subarray\\n                if len(types) >= 3:\\n                    i = j-1\\n                    break\\n\\n                ans = max(ans, weight)\\n\\n            # If we go to the last block, then stop\\n            else:\\n                break\\n\\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        blocks = []\\n        \\n        i = 0\\n        while i < len(tree):\\n            j = i + 1\\n            length = 1\\n            while j < len(tree) and tree[j] == tree[j-1]:\\n                length += 1\\n                j += 1\\n                \\n            blocks.append((tree[i], length))\\n            i = j\\n            \\n        \\n        maxi = 0\\n\\n        i = 0\\n        while i < len(blocks):\\n            types, cur = set(), 0\\n            for j in range(i, len(blocks)):\\n                types.add(blocks[j][0])\\n                cur += blocks[j][1]\\n                if len(types) > 2:\\n                    i = j - 1\\n                    break\\n                \\n            \\n                maxi = max(maxi, cur)\\n            else:\\n                break\\n        return maxi\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        i, j = 0, 0\\n        res = 0\\n        d = {} \\n        while j < len(tree):\\n            d[tree[j]] = d.get(tree[j], 0) + 1\\n            if len(d) <= 2:\\n                res = max(res, j - i + 1)\\n            else: \\n                while len(d) > 2:\\n                    d[tree[i]] = d[tree[i]] - 1\\n                    if d[tree[i]] == 0:\\n                        d.pop(tree[i])\\n                    i += 1\\n            j += 1\\n        return res\\n                \\n            \\n            \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        t1 = t2 = -1\\n        t1s = -1\\n        ans = 0;\\n        for i in range(0, len(tree)):\\n            t = tree[i]\\n            if t != t1 and t != t2:\\n                ans = max(ans, i - t1s)\\n                t1s = i\\n                while (t1s > 0 and tree[t1s - 1] == tree[i - 1]):\\n                    t1s -= 1\\n                t1 = tree[i - 1]\\n                t2 = t\\n        ans = max(ans, len(tree) - t1s)\\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        block = []\\n        prev = tree[0]\\n        start = 0\\n        for i in range(1, len(tree)):\\n            if prev != tree[i]:\\n                block.append((prev, i-start))\\n                start = i\\n                prev = tree[i]\\n        block.append((prev, len(tree) - start))\\n        head, tail = 0, 1\\n        basket = {block[0][0]: block[0][1]}\\n        res = block[0][1]\\n        while tail < len(block):\\n            t, q = block[tail]\\n            if t in list(basket.keys()):\\n                basket[t] += q\\n            else:\\n                if len(basket) < 2:\\n                    basket[t] = q\\n                else:\\n                    while len(basket) == 2:\\n                        ht, hq = block[head]\\n                        head += 1\\n                        basket[ht] -= hq\\n                        if basket[ht] == 0:\\n                            basket.pop(ht)\\n                    basket[t] = q\\n            val = 0\\n            for tt in list(basket.keys()):\\n                val += basket[tt]\\n            res = max(res, val)\\n            tail += 1\\n        return res\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        count, i, j = {}, 0, 0\\n        max_cnt = 0\\n        while j < len(tree):\\n            # print(count)\\n            v = tree[j]\\n            count[v] = count.get(v, 0) + 1\\n            if len(count) <= 2:\\n                max_cnt = max(sum(count.values()), max_cnt)\\n            while len(count) > 2:\\n                count[tree[i]] -= 1\\n                if count[tree[i]] == 0: del count[tree[i]]\\n                i += 1\\n            j += 1\\n        return max_cnt\\n                \\n        \\n# j = 2\\n# i = 1\\n# count = {\\n#     3: 2,\\n#     1: 1,\\n#     2: 1\\n# }\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        i = 0\\n        j = 0\\n        my_map = {}\\n        max_len = 0\\n        while i < len(tree):\\n            while i < len(tree) and (tree[i] not in my_map and len(my_map) < 2 or tree[i] in my_map):\\n                if tree[i] not in my_map:\\n                    my_map[tree[i]] = 0\\n                my_map[tree[i]] += 1\\n                i += 1\\n            max_len = max(max_len, i - j)\\n            while len(my_map) == 2: \\n                my_map[tree[j]] -= 1\\n                if my_map[tree[j]] == 0:\\n                    del my_map[tree[j]]\\n                j += 1\\n            \\n        return max_len\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        fruits = {}\\n        maxNum = 0\\n        \\n        left = 0\\n        right = 0\\n        while right < len(tree):\\n            while len(fruits) < 3 and right < len(tree):\\n                fruit = tree[right]\\n                if fruit not in fruits:\\n                    fruits[fruit] = 0\\n                fruits[fruit] += 1\\n                if len(fruits) < 3:\\n                    maxNum = max(maxNum, sum(fruits.values()))\\n                right += 1\\n            while len(fruits) > 2 and left < right:\\n                fruit = tree[left]\\n                fruits[fruit] -= 1\\n                if fruits[fruit] == 0:\\n                    del fruits[fruit]\\n                left += 1\\n        return maxNum\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if len(tree) == 1:\\n            return 1\\n        lo = 0\\n        hi = 1\\n        baskets = set()\\n        baskets.add(tree[0])\\n        bmaps = {}\\n        bmaps[tree[0]] = 1\\n        cnt = 1\\n        while hi < len(tree):\\n            baskets.add(tree[hi])\\n            if tree[hi] in bmaps:\\n                bmaps[tree[hi]] += 1\\n            else:\\n                bmaps[tree[hi]] = 1\\n\\n            while len(baskets) > 2:\\n                if bmaps[tree[lo]] == 1:\\n                    baskets.remove(tree[lo])\\n                    bmaps[tree[lo]] = 0\\n                else:\\n                    bmaps[tree[lo]] -= 1\\n                lo += 1\\n            cnt = max(hi - lo + 1, cnt)\\n            hi += 1\\n        return cnt\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        l, nums, res = 0, collections.Counter(), 0\\n        for r in range(len(tree)):\\n            nums[tree[r]] += 1\\n            while len(nums) > 2:\\n                nums[tree[l]] -= 1 \\n                if not nums[tree[l]]:\\n                    nums.pop(tree[l])\\n                l += 1\\n            res = max(res, r - l + 1)\\n        return res        \", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        if not tree:\\n            return 0\\n        i = 0\\n        max_value = 0\\n        count = Counter()\\n        for index, value in enumerate(tree):\\n            count[value] += 1\\n            while len(count) >= 3:\\n                count[tree[i]] -= 1\\n                if count[tree[i]] == 0:\\n                    del count[tree[i]]\\n                i += 1\\n            max_value = max(max_value, index - i + 1)\\n        return max_value\", \"class Solution:\\n    def totalFruit(self, s: List[int]) -> int:\\n        m=0\\n        arr={}\\n        i=0\\n        k=2\\n        for j in range(len(s)):\\n            if s[j] not in arr:\\n                arr[s[j]]=0\\n            arr[s[j]]+=1\\n            while len(arr)>k:\\n                x=s[i]\\n                arr[x]-=1\\n                if arr[x]==0:\\n                    arr.pop(x)\\n                i+=1\\n            m=max(m,j-i+1)\\n        return m\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        \\n        \\n        blocks = []\\n        i=0\\n        while i<len(tree):\\n            start=i\\n            while i+1<len(tree) and tree[i+1]==tree[start]:\\n                i+=1\\n            blocks.append((tree[start],i-start+1))\\n            i = i+1\\n            \\n\\n        ans =0\\n        i=0\\n        while i<len(blocks):\\n            types = set()\\n            weight = 0\\n            j=i\\n            while j<len(blocks):\\n                types.add(blocks[j][0])\\n                weight+=blocks[j][1]\\n                \\n                if len(types)>2:\\n                    i=j-1\\n                    break\\n                \\n                ans = max(ans,weight)\\n                j+=1\\n                \\n                if j==len(blocks):\\n                    i=j\\n            \\n            if i==len(blocks):\\n                break\\n        \\n        return ans\\n\", \"from collections import Counter\\nclass Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        d = Counter()\\n        left = 0 \\n        total = 0\\n        for idx, i in enumerate(tree):\\n            d[i] += 1 \\n            while(len(d) > 2):\\n                d[tree[left]] -= 1 \\n                if(d[tree[left]] == 0):\\n                    del d[tree[left]]\\n                left += 1 \\n                \\n            total = max(total, idx - left + 1)\\n        return total\\n\", \"class Solution:\\n    def total(self, fruits):\\n        total = 0\\n        for key in fruits:\\n            total += fruits[key]\\n        \\n        return total\\n    \\n    def totalFruit(self, tree: List[int]) -> int:\\n        \\n        fruits = {}\\n        left_index = 0\\n        best = 0\\n        \\n        for right_index in range(len(tree)):\\n            curr_fruit = tree[right_index]\\n            \\n            if curr_fruit not in fruits:\\n                fruits[curr_fruit] = 1\\n            else:\\n                fruits[curr_fruit] += 1\\n            \\n            while len(fruits) > 2:\\n                old_fruit = tree[left_index]\\n                fruits[old_fruit] -= 1\\n                if fruits[old_fruit] == 0:\\n                    del fruits[old_fruit]\\n                left_index += 1 \\n                \\n            best = max(best, self.total(fruits))\\n        \\n        return best\\n            \\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        result = 0\\n        ptr = 0\\n        count = collections.Counter()\\n        for i, t in enumerate(tree):\\n            count[t] += 1\\n            while len(count) >= 3:\\n                count[tree[ptr]] -= 1\\n                if count[tree[ptr]] == 0:\\n                    del count[tree[ptr]]\\n                ptr += 1\\n            result = max(result, i - ptr + 1)\\n        return result\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n\\n        max_len = 0\\n        basket = collections.Counter()\\n        start = 0\\n        \\n        for end, fruit in enumerate(tree):\\n            basket[fruit] += 1\\n            \\n            while len(basket) >= 3:\\n                basket[tree[start]] -= 1\\n                \\n                if basket[tree[start]] == 0:\\n                    del basket[tree[start]]\\n                    \\n                start += 1\\n            max_len = max(max_len, end - start + 1)\\n            \\n        return max_len\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        ans = i = 0\\n        count = collections.Counter()\\n        for j, x in enumerate(tree):\\n            count[x] += 1\\n            while len(count) >= 3:\\n                count[tree[i]] -= 1\\n                if count[tree[i]] == 0:\\n                    del count[tree[i]]\\n                i += 1\\n            ans = max(ans, j - i + 1)\\n        return ans\\n            \\n            \\n            \\n                \\n            \\n\", \"# \\u95ee\\u9898\\u53ef\\u4ee5\\u62bd\\u8c61\\u4e3a\\u7ed9\\u5b9a\\u4e00\\u4e2a\\u6570\\u7ec4\\uff0c\\u6c42\\u89e3\\u6700\\u591a\\u9009\\u62e9\\u4e24\\u79cd\\u6570\\u5b57\\u7684\\u60c5\\u51b5\\u4e0b\\uff0c\\u6700\\u5927\\u7684\\u8fde\\u7eed\\u5b50\\u5e8f\\u5217\\u957f\\u5ea6\\uff0c\\u5176\\u4e2d\\u6570\\u7ec4\\u548c\\u539f\\u9898\\u76ee\\u4e00\\u6837\\uff0c\\u6bcf\\u4e00\\u4e2a\\u6570\\u5b57\\u4ee3\\u8868\\u4e00\\u4e2a\\u6c34\\u679c\\u3002\\n\\n# \\u6211\\u4eec\\u53ef\\u4ee5\\u4f7f\\u7528\\u6ed1\\u52a8\\u7a97\\u53e3\\u6765\\u89e3\\u51b3\\u3002 \\u601d\\u8def\\u548c \\u30101004. \\u6700\\u5927\\u8fde\\u7eed 1 \\u7684\\u4e2a\\u6570 III\\u3011\\u6ed1\\u52a8\\u7a97\\u53e3\\uff08Python3\\uff09 \\u4e00\\u6837\\u3002\\n\\n\\n\\nclass Solution:\\n    def atMostK(self, nums, K):\\n        counter = collections.Counter()\\n        res = i = 0\\n        for j in range(len(nums)):\\n            if counter[nums[j]] == 0:\\n                K -= 1\\n            counter[nums[j]] += 1  #\\u7136\\u540e\\u52a0\\u4e0a1\\n            while K < 0:\\n                counter[nums[i]] -= 1  #\\u79fb\\u53bb\\u6700\\u5916\\u9762\\u7684\\uff0c\\u7136\\u540e\\u81ea\\u5df1\\u5f80\\u5de6\\u8d70\\n                if counter[nums[i]] == 0:\\n                    K += 1  #\\u8bf4\\u660e\\u6709\\u4e00\\u4e2a\\u54c1\\u79cd\\u591a\\u51fa\\u6765\\u4e86\\uff0c\\u6240\\u4ee5\\u5728\\u6ca1\\u6709\\u5230\\u53ef\\u4ee5\\u79fb\\u51fa\\u54c1\\u79cd\\u4e4b\\u524d\\uff0c\\u9700\\u8981\\u4e00\\u76f4\\u53d8\\u52a8\\n                i += 1\\n            res = max(res, j - i + 1)  #\\u56e0\\u4e3a\\u8fd8\\u8981\\u591a\\u4e00\\u4e2a\\n        return res\\n\\n    def totalFruit(self, tree: List[int]) -> int:\\n        return self.atMostK(tree, 2)   #\\u6700\\u591a\\u4e24\\u4e2a\\n\\n# \\u590d\\u6742\\u5ea6\\u5206\\u6790\\n\\n# \\u65f6\\u95f4\\u590d\\u6742\\u5ea6\\uff1aO(N)O(N)\\n# \\u7a7a\\u95f4\\u590d\\u6742\\u5ea6\\uff1aO(N))O(N)) \\uff08\\u6211\\u4eec\\u4f7f\\u7528\\u4e86Counter\\uff09\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n#dynamic sliding windo        \\n        maxi=0\\n        if len(tree)==1:\\n            return 1\\n        l=[]\\n        s=set()\\n        for i in range(len(tree)):\\n            l.append(tree[i])\\n            s.add(tree[i])\\n            if len(s)>2:#we need to change the start of the window, remove until the size of set reduces to less than=2\\n                #l=l[::-1]\\n                while len(set(l))>2:\\n                    #l.pop()\\n                    l=l[1:]#pop the first element until the set has less than equal to 2 elements\\n                #l=l[::-1]\\n                s=set(l)#new version of set\\n            maxi=max(maxi,len(l))\\n        return maxi\\n#increasing the sizee of sliding window by starting at each element        \\n#         maxi=0\\n#         if len(tree)==1:\\n#             return 1\\n            \\n#         for i in range(len(tree)):\\n#             s=set()\\n#             s.add(tree[i])\\n#             for j in range(i+1,len(tree)):\\n#                 s.add(tree[j])\\n#                 if len(s)>2:\\n#                     break\\n#                 maxi=max(maxi,j-i+1)\\n#         return maxi\\n        \\n        # for i in range(len(tree),0,-1):\\n        #     start=0\\n        #     end=i\\n        #     for j in range(len(tree)-i+1):\\n        #         s=tree[start:end]\\n        #         start+=1\\n        #         end+=1\\n        #         if len(set(s))<=2:\\n        #             return i\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n#dynamic sliding windo        \\n        maxi=0\\n        if len(tree)==1:\\n            return 1\\n        l=[]\\n        s=set()\\n        for i in range(len(tree)):\\n            l.append(tree[i])\\n            s.add(tree[i])\\n            if len(s)>2:\\n                #l=l[::-1]\\n                while len(set(l))>2:\\n                    #l.pop()\\n                    l=l[1:]#pop the first element until the set has less than equal to 2 elements\\n                #l=l[::-1]\\n                s=set(l)\\n            maxi=max(maxi,len(l))\\n        return maxi\\n#increasing the sizee of sliding window by starting at each element        \\n#         maxi=0\\n#         if len(tree)==1:\\n#             return 1\\n            \\n#         for i in range(len(tree)):\\n#             s=set()\\n#             s.add(tree[i])\\n#             for j in range(i+1,len(tree)):\\n#                 s.add(tree[j])\\n#                 if len(s)>2:\\n#                     break\\n#                 maxi=max(maxi,j-i+1)\\n#         return maxi\\n        \\n        # for i in range(len(tree),0,-1):\\n        #     start=0\\n        #     end=i\\n        #     for j in range(len(tree)-i+1):\\n        #         s=tree[start:end]\\n        #         start+=1\\n        #         end+=1\\n        #         if len(set(s))<=2:\\n        #             return i\\n\", \"class Solution(object):\\n    def totalFruit(self, tree):\\n        n = len(tree)\\n        left, right = 0, 0\\n        basket = {}\\n        \\n        ans = 0\\n        while right<n:\\n            while left<right and len(basket)>1:\\n                basket.update({tree[left]:basket.get(tree[left], 0)-1})\\n                if basket.get(tree[left], None) == 0:\\n                    basket.pop(tree[left])\\n                left +=1\\n                \\n            basket.update({tree[right]:basket.get(tree[right], 0)+1})\\n            right += 1\\n            while right<n and basket.get(tree[right], 0) > 0:\\n                basket.update({tree[right]:basket.get(tree[right], 0)+1})\\n                right += 1\\n            # print(left, right, basket)\\n            ans = max(ans, right-left)\\n        return ans\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        N = len(tree)\\n        \\n        cache = Counter()\\n        \\n        left = right = 0\\n        maxx = 0\\n        while left < N and right < N:\\n            # while len(cache) < 2 and right < N:\\n            curr = tree[right]\\n            cache[curr] += 1                \\n            # right += 1\\n                \\n            while len(cache) > 2 and left < N:\\n                # print(cache)\\n                curr = tree[left]\\n                cache[curr] -= 1\\n                if cache[curr] <= 0:\\n                    del cache[curr]\\n                left += 1\\n            \\n            # print(tree[left:right+1])\\n            maxx = max(maxx, right-left+1)\\n            right += 1\\n            \\n        return maxx\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        l, nums, ans = 0, collections.Counter(), 0\\n        for r in range(len(tree)):\\n            nums[tree[r]] += 1\\n            while len(nums) > 2:\\n                nums[tree[l]] -= 1\\n                if not nums[tree[l]]:\\n                    del nums[tree[l]]\\n                l += 1\\n            ans = max(ans, r - l + 1)\\n        return ans\\n                    \\n                    \\n                \\n\", \"from collections import defaultdict\\n\\nclass Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n\\n        maxAmountOfFruit = 0\\n        startIndex, endIndex = 0, 0\\n\\n        countByFruit = defaultdict(int)\\n        countByFruit[tree[startIndex]] = 1\\n        \\n        while endIndex < len(tree):\\n            while len(countByFruit) > 2:\\n                fruitToRemove = tree[startIndex]\\n                countByFruit[fruitToRemove] -= 1\\n                if countByFruit[fruitToRemove] == 0:\\n                    del countByFruit[fruitToRemove]\\n                startIndex += 1\\n            maxAmountOfFruit = max(maxAmountOfFruit, endIndex - startIndex + 1)\\n            endIndex += 1\\n            if endIndex != len(tree):\\n                countByFruit[tree[endIndex]] += 1\\n        return maxAmountOfFruit\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        cnt = collections.Counter()\\n        i = 0\\n        res = 0\\n        for j in range(len(tree)):\\n            cnt[tree[j]] += 1\\n            while len(cnt) > 2:\\n                cnt[tree[i]] -= 1\\n                if cnt[tree[i]] == 0:\\n                    cnt.pop(tree[i])\\n                i += 1\\n            res = max(res, sum(cnt.values()))\\n        return res\\n            \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        # fruit_1, fruit_2 = None, None\\n        # pos_1, pos_2 = -1, -1\\n        # i = 0\\n        # max_len = 0\\n        # for t in range(len(tree)):\\n        #     if tree[t]==fruit_1:\\n        #         fruit_1, fruit_2 = fruit_2, fruit_1\\n        #         pos_1, pos_2 = pos_2, t\\n        #     elif tree[t]==fruit_2:\\n        #         pos_2 = t\\n        #     else:\\n        #         fruit_1, fruit_2 = fruit_2, tree[t]\\n        #         i = pos_1 + 1\\n        #         pos_1, pos_2 = pos_2, t\\n        #     if t - i + 1 > max_len:\\n        #         max_len = t - i + 1\\n        # return max_len\\n\", \"class Solution:\\n    def totalFruit(self, tree: List[int]) -> int:\\n        left, right = 0, 0\\n        res = 0\\n        cnt = collections.defaultdict(int)\\n        while right < len(tree):\\n            cnt[tree[right]] += 1\\n            while len(cnt) > 2:\\n                cnt[tree[left]] -= 1\\n                if cnt[tree[left]] == 0:\\n                    del cnt[tree[left]]\\n                left += 1\\n            res = max(res, right - left + 1)\\n            right += 1\\n        return res\"]", "input_output": "{\"fn_name\": \"totalFruit\", \"inputs\": [[[1, 2, 1]]], \"outputs\": [3]}", "difficulty": "interview", "url": "https://leetcode.com/problems/fruit-into-baskets/", "starter_code": "\nclass Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        "}
{"id": 144, "question": "Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step: \n\nCopy All: You can copy all the characters present on the notepad (partial copy is not allowed).\nPaste: You can paste the characters which are copied last time.\n\n\n\n\nGiven a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'. \n\n\nExample 1:\n\nInput: 3\nOutput: 3\nExplanation:\nIntitally, we have one character 'A'.\nIn step 1, we use Copy All operation.\nIn step 2, we use Paste operation to get 'AA'.\nIn step 3, we use Paste operation to get 'AAA'.\n\n\n\n\nNote:\n\nThe n will be in the range [1, 1000].", "solutions": "[\"class Solution:\\n     def minSteps(self, n):\\n         \\\"\\\"\\\"\\n         :type n: int\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         primeFactors=[]\\n         for i in range(2,int(n**.5)+1):\\n             while n%i==0:\\n                 primeFactors.append(i)\\n                 n=n//i\\n         if n>1:\\n             primeFactors.append(n)\\n         return sum(primeFactors)\", \"class Solution:\\n     def minSteps(self, n):\\n         m = n\\n         sum = 0\\n         tmp=2\\n         if m == 1:\\n             return 0\\n         if m == 2:\\n             return 2\\n         else:\\n             while(m>tmp):\\n                 k=m%tmp\\n                 if k==0:\\n                     m=m/tmp\\n                     sum += tmp\\n                 else:\\n                     tmp=tmp+1\\n             sum = sum+tmp\\n                 \\n             return sum\\n         \\n         \\\"\\\"\\\"\\n         :type n: int\\n         :rtype: int\\n         \\\"\\\"\\\"\\n\", \"class Solution:\\n     def minSteps(self, n):\\n         \\\"\\\"\\\"\\n         :type n: int\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         def factors(n):\\n             d = 2\\n             while d * d <= n:\\n                 while n % d == 0:\\n                     n /= d\\n                     yield d\\n                 d += 1\\n             if n > 1:\\n                 yield n\\n \\n         return int(sum(factors(n)))\\n             \\n             \\n     \\n\", \"class Solution:\\n     def minSteps(self, n):\\n         primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\\n         ret = 0\\n         for p in primes:\\n             while not (n % p):\\n                 n /= p\\n                 ret += p\\n         return int(ret + n * (n > 1))\", \"class Solution:\\n     def minSteps(self, n):\\n         \\\"\\\"\\\"\\n         :type n: int\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         res = 0\\n         p = 2\\n         while n > 1:\\n             while n%p == 0:\\n                 res += p\\n                 n /= p\\n             p += 1\\n         return res\", \"class Solution:\\n     def minSteps(self, n):\\n         \\\"\\\"\\\"\\n         :type n: int\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         if n == 1:\\n             return 0\\n         \\n         isPrime = [True for _ in range(n+1)]\\n         isPrime[1] = False\\n         prime = []\\n         for i in range(2, n+1):\\n             if isPrime[i] == True:\\n                 prime.append(i)\\n                 k = 1\\n                 while (k+1) * i <= n:\\n                     isPrime[(k+1) * i] = False\\n                     k += 1\\n         \\n         if isPrime[n]:\\n             return n\\n         \\n         cnt, i = 0, 0\\n         while n > 1:\\n             while n % prime[i] == 0:\\n                 cnt += prime[i]\\n                 n = n // prime[i]\\n             if isPrime[n]:\\n                 return cnt + n\\n             i += 1\\n         return cnt\\n\", \"class Solution:\\n     def minSteps(self, n):\\n         \\\"\\\"\\\"\\n         :type n: int\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         \\n         if n == 1:\\n             return 0\\n         \\n         # just manually does the first factor\\n         # useless step\\n         \\n         #lf = min(self.primes(n))\\n         \\n         #steps = lf\\n         #divs = n // lf\\n         \\n         \\n         return self.calcsteps(0, n) \\n         # return self.calcsteps(steps, lf)   \\n         \\n         '''\\n         # this cleaner version of my approach starts at the lowest factor, then moves up when the number can no longer be cleanly divided\\n         # d stands for divisor (?)\\n         # both solutions run at 40ms\\n         \\n         ans = 0\\n         d = 2\\n         while n > 1:\\n             while n % d == 0:\\n                 ans += d\\n                 n /= d\\n             d += 1\\n         return ans\\n         '''\\n     def isprime(self, n):\\n         if n == 2 or n == 3:\\n             return True\\n         if n % 2 == 0 or n % 3 == 0:\\n             return False\\n \\n         i = 5\\n         w = 2\\n \\n         while i * i <= n:\\n             if n % i == 0:\\n                 return False\\n \\n             i += w\\n             w = 6 - w\\n \\n         return True\\n     \\n     def primes(self, n):\\n         # gets all prime factors of n\\n         primfac = []\\n         d = 2\\n         while d*d <= n:\\n             while (n % d) == 0:\\n                 primfac.append(d)\\n                 n //= d\\n             d += 1\\n         if n > 1:\\n             primfac.append(n)\\n         return primfac\\n     \\n     def calcsteps(self, steps, divs):\\n         if self.isprime(divs):\\n                 return divs + steps\\n         \\n         primes = self.primes(divs)\\n         # if a factor is three, you have to copy n, then paste it twice. 1 + 2 = 3, 1 + n - 1 = n\\n         # therefore, the number of steps is the sum of the primes\\n         \\n         return steps + sum(primes)\\n\", \"class Solution:\\n     def minSteps(self, n):\\n         \\\"\\\"\\\"\\n         :type n: int\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         s = 0\\n         for d in range(2, n+1):\\n             while n % d == 0:\\n                 s += d\\n                 n /= d\\n         return s\", \"class Solution:\\n     def minSteps(self, n):\\n         d = 2\\n         ans = 0\\n         while(n>1):\\n             while(n%d==0):\\n                 ans += d\\n                 n = n/d\\n             d = d+1\\n         return ans\\n         \\n         \\n         \\\"\\\"\\\"\\n         :type n: int\\n         :rtype: int\\n         \\\"\\\"\\\"\", \"class Solution(object):\\n     def minSteps(self, n):\\n         steps = 0\\n         div = 2\\n         while n > 1:\\n             if n % div == 0:\\n                 steps += div\\n                 \\n                 n = n / div\\n             else:\\n                 div += 1\\n         \\n         return steps\", \"class Solution:\\n     def minSteps(self, n):\\n         \\\"\\\"\\\"\\n         :type n: int\\n         :rtype: int\\n         \\\"\\\"\\\"\\n         f=2\\n         s=0\\n         while f*f<=n:\\n             while n%f==0:\\n                 s+=f\\n                 n=int(n/f)\\n             f+=1\\n         if n>1:\\n             s+=n\\n         return int(s)\\n\"]", "input_output": "{\"fn_name\": \"minSteps\", \"inputs\": [[3]], \"outputs\": [3]}", "difficulty": "interview", "url": "https://leetcode.com/problems/2-keys-keyboard/", "starter_code": "\nclass Solution:\n    def minSteps(self, n: int) -> int:\n        "}
{"id": 145, "question": "You have 4 cards each containing a number from 1 to 9.  You need to judge whether they could operated through *, /, +, -, (, ) to get the value of 24.\n\n\nExample 1:\n\nInput: [4, 1, 8, 7]\nOutput: True\nExplanation: (8-4) * (7-1) = 24\n\n\n\nExample 2:\n\nInput: [1, 2, 1, 2]\nOutput: False\n\n\n\nNote:\n\nThe division operator / represents real division, not integer division.  For example, 4 / (1 - 2/3) = 12.\nEvery operation done is between two numbers.  In particular, we cannot use - as a unary operator.  For example, with [1, 1, 1, 1] as input, the expression -1 - 1 - 1 - 1 is not allowed.\nYou cannot concatenate numbers together.  For example, if the input is [1, 2, 1, 2], we cannot write this as 12 + 12.", "solutions": "[\"class Solution(object):\\n     def judgePoint24(self, nums):\\n         bad = '\\ub5a2\\ube3b\\uac01\\uac4e\\ub0c7\\uac05\\uac38\\uae9a\\ubd5f\\uc223\\uc684\\ubd74\\ubd5e\\ub93c\\uac08\\uac0c\\ub914\\ub58c\\uc60a\\uba54\\ub284\\uc22d\\uceb8\\uae36\\uae9b\\uc616\\uac0d\\ub1d0\\uca62\\uacf4\\ub4c7\\uac6f\\uad84\\uc615\\uc679\\ub21e\\uc1b4\\uac43\\ub057\\uae2c\\ub549\\uadbf\\uac00\\uc300\\ub090\\uac44\\uc224\\ubeb4\\ub298\\uac58\\uaf78\\uc222\\uac42\\uac0b\\uac03\\ucad0\\uaf14\\uc1be\\uca61\\uc1d4\\uc1bf\\ub05b\\ub91c\\uac04\\ube3a\\uca6c\\uc6e8\\ub534\\uc620\\ub91b\\uac02\\ubd6a\\ub360\\ub1a4\\ube50\\uc60b\\uadd2\\ub282\\uac30\\uac16\\ub1a5\\uadbe\\uac06\\uc60c\\ubf18\\ubb30\\uac70\\uac0e\\uae37\\ub0a4\\uacbc'\\n         return chr(int(''.join(map(str, sorted(nums)))) + 42921) not in bad\\n\", \"class Solution:\\n     def judgePoint24(self, nums):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :rtype: bool\\n         \\\"\\\"\\\"\\n         bad = '\\u5bf9\\u6492\\u5258\\u52a5\\u571e\\u525c\\u528f\\u54f1\\u63b6\\u687a\\u6cdb\\u63cb\\u63b5\\u5f93\\u525f\\u5263\\u5f6b\\u5be3\\u6c61\\u60ab\\u58db\\u6884\\u750f\\u548d\\u54f2\\u6c6d\\u5264\\u5827\\u70b9\\u534b\\u5b1e\\u52c6\\u53db\\u6c6c\\u6cd0\\u5875\\u680b\\u529a\\u56ae\\u5483\\u5ba0\\u5416\\u5257\\u6957\\u56e7\\u529b\\u687b\\u650b\\u58ef\\u52af\\u55cf\\u6879\\u5299\\u5262\\u525a\\u7127\\u556b\\u6815\\u70b8\\u682b\\u6816\\u56b2\\u5f73\\u525b\\u6491\\u70c3\\u6d3f\\u5b8b\\u6c77\\u5f72\\u5259\\u63c1\\u59b7\\u57fb\\u64a7\\u6c62\\u5429\\u58d9\\u5287\\u526d\\u57fc\\u5415\\u525d\\u6c63\\u656f\\u6187\\u52c7\\u5265\\u548e\\u56fb\\u5313'\\n         return chr(int(''.join(map(str, sorted(nums)))) + 19968) not in bad\", \"class Solution:\\n     def judgePoint24(self, nums):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :rtype: bool\\n         \\\"\\\"\\\"\\n         bad = '\\ub5a2\\ube3b\\uac01\\uac4e\\ub0c7\\uac05\\uac38\\uae9a\\ubd5f\\uc223\\uc684\\ubd74\\ubd5e\\ub93c\\uac08\\uac0c\\ub914\\ub58c\\uc60a\\uba54\\ub284\\uc22d\\uceb8\\uae36\\uae9b\\uc616\\uac0d\\ub1d0\\uca62\\uacf4\\ub4c7\\uac6f\\uad84\\uc615\\uc679\\ub21e\\uc1b4\\uac43\\ub057\\uae2c\\ub549\\uadbf\\uac00\\uc300\\ub090\\uac44\\uc224\\ubeb4\\ub298\\uac58\\uaf78\\uc222\\uac42\\uac0b\\uac03\\ucad0\\uaf14\\uc1be\\uca61\\uc1d4\\uc1bf\\ub05b\\ub91c\\uac04\\ube3a\\uca6c\\uc6e8\\ub534\\uc620\\ub91b\\uac02\\ubd6a\\ub360\\ub1a4\\ube50\\uc60b\\uadd2\\ub282\\uac30\\uac16\\ub1a5\\uadbe\\uac06\\uc60c\\ubf18\\ubb30\\uac70\\uac0e\\uae37\\ub0a4\\uacbc'\\n         return chr(int(''.join(map(str, sorted(nums)))) + 42921) not in bad\", \"class Solution:\\n     def judgePoint24(self, nums):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :rtype: bool\\n         \\\"\\\"\\\"\\n         bad = '\\u5bf9\\u6492\\u5258\\u52a5\\u571e\\u525c\\u528f\\u54f1\\u63b6\\u687a\\u6cdb\\u63cb\\u63b5\\u5f93\\u525f\\u5263\\u5f6b\\u5be3\\u6c61\\u60ab\\u58db\\u6884\\u750f\\u548d\\u54f2\\u6c6d\\u5264\\u5827\\u70b9\\u534b\\u5b1e\\u52c6\\u53db\\u6c6c\\u6cd0\\u5875\\u680b\\u529a\\u56ae\\u5483\\u5ba0\\u5416\\u5257\\u6957\\u56e7\\u529b\\u687b\\u650b\\u58ef\\u52af\\u55cf\\u6879\\u5299\\u5262\\u525a\\u7127\\u556b\\u6815\\u70b8\\u682b\\u6816\\u56b2\\u5f73\\u525b\\u6491\\u70c3\\u6d3f\\u5b8b\\u6c77\\u5f72\\u5259\\u63c1\\u59b7\\u57fb\\u64a7\\u6c62\\u5429\\u58d9\\u5287\\u526d\\u57fc\\u5415\\u525d\\u6c63\\u656f\\u6187\\u52c7\\u5265\\u548e\\u56fb\\u5313'\\n         return chr(int(''.join(map(str, sorted(nums)))) + 19968) not in bad\", \"class Solution(object):\\n     def judgePoint24(self, nums):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :rtype: bool\\n         \\\"\\\"\\\"\\n         \\n         def cal(operands, operaters):\\n             for opt in operaters:\\n                 op2, op1 = operands.pop(-1), operands.pop(-1)\\n                 if opt=='+':\\n                     ret = op1+op2\\n                 elif opt=='-':\\n                     ret = op1-op2\\n                 elif opt=='*':\\n                     ret = op1*op2\\n                 elif opt=='/' and op2!=0:\\n                     ret = op1/op2\\n                 else:\\n                     return float('-inf')\\n                 operands.append(ret)\\n             \\n             return operands[0] if abs(operands[0]-24)>0.0000001 else 24\\n         \\n         def comb(arr):\\n             if len(arr)==1:\\n                 return [arr]\\n             ret = []\\n             for i in range(len(arr)):\\n                 if i-1>=0 and arr[i]==arr[i-1]:\\n                     continue\\n                 for remain in comb(arr[:i]+arr[i+1:]):\\n                     ret.append([arr[i]]+remain)\\n             return ret\\n         \\n         def genopt(n):\\n             if n==0:\\n                 return ['']\\n             ret = []\\n             for i in '+-*/':\\n                 for res in genopt(n-1):\\n                     ret.append(i+res)\\n             return ret\\n         \\n         nums.sort()\\n         ops = comb(nums)\\n         opts = genopt(3)\\n         for op in ops:\\n             for opt in opts:\\n                 if cal(op[:], opt)==24:\\n                     return True\\n                 \\n         def base(a, b):\\n             return set([a+b,a-b,b-a,a*b]+([a/b] if b!=0 else[])+([b/a] if a!=0 else[]))\\n             \\n         for i in range(4):\\n             for j in range(i+1, 4):\\n                 a, b = nums[i], nums[j]\\n                 remain = nums[:i]+nums[i+1:j]+nums[j+1:4]\\n                 for x in base(a, b):\\n                     for y in base(remain[0], remain[1]):\\n                         if 24 in base(x, y):\\n                             return True\\n                 \\n         \\n         return False\", \"class Solution(object):\\n     def judgePoint24(self, nums):\\n         \\\"\\\"\\\"\\n         :type nums: List[int]\\n         :rtype: bool\\n         \\\"\\\"\\\"\\n         n = len(nums)\\n         if n == 1:\\n             return abs(nums[0] - 24) < 0.0001\\n \\n         for i in range(n - 1):\\n             for j in range(i + 1, n):\\n                 remainder = nums[:i] + nums[i + 1:j] + nums[j + 1:]\\n \\n                 if self.judgePoint24(remainder + [nums[i] + nums[j]]):\\n                     return True\\n                 if self.judgePoint24(remainder + [nums[i] - nums[j]]):\\n                     return True\\n                 if self.judgePoint24(remainder + [nums[j] - nums[i]]):\\n                     return True\\n                 if self.judgePoint24(remainder + [nums[i] * nums[j]]):\\n                     return True\\n                 if nums[j] != 0 and self.judgePoint24(remainder + [nums[i] / nums[j]]):\\n                     return True\\n                 if nums[i] != 0 and self.judgePoint24(remainder + [nums[j] / nums[i]]):\\n                     return True\\n \\n         return False\"]", "input_output": "{\"fn_name\": \"judgePoint24\", \"inputs\": [[[4, 1, 8, 7]]], \"outputs\": [true]}", "difficulty": "interview", "url": "https://leetcode.com/problems/24-game/", "starter_code": "\nclass Solution:\n    def judgePoint24(self, nums: List[int]) -> bool:\n        "}
{"id": 146, "question": "Given an encoded string, return it's decoded string.\n\n\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\n\n\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\n\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].\n\n\nExamples:\n\ns = \"3[a]2[bc]\", return \"aaabcbc\".\ns = \"3[a2[c]]\", return \"accaccacc\".\ns = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\".", "solutions": "[\"class Solution:\\n     def decodeString(self, s):\\n         \\\"\\\"\\\"\\n         :type s: str\\n         :rtype: str\\n         \\\"\\\"\\\"\\n         stack = []\\n         stack.append([\\\"\\\", 1])\\n         num = \\\"\\\"\\n         for ch in s:\\n             if ch.isdigit():\\n               num += ch\\n             elif ch == '[':\\n                 stack.append([\\\"\\\", int(num)])\\n                 num = \\\"\\\"\\n             elif ch == ']':\\n                 st, k = stack.pop()\\n                 stack[-1][0] += st*k\\n             else:\\n                 stack[-1][0] += ch\\n         return stack[0][0]\\n \\n\", \"class Solution:\\n     def decodeString(self, s):\\n         \\\"\\\"\\\"\\n         :type s: str\\n         :rtype: str\\n         \\\"\\\"\\\"\\n         m = len(s)\\n         if m == 0:\\n             return ''\\n         result = []\\n         for i in s:\\n             if i != ']':\\n                 result.append(i)\\n             else:\\n                 char_temp = []            \\n                 r1m = len(result)            \\n                 for j in range(r1m-1, -1, -1):\\n                     if result[j] != '[':\\n                         char_temp.insert(0, result.pop())\\n                     else:\\n                         result.pop()\\n                         break\\n \\n                 digit_char = []\\n                 r2m = len(result)\\n                 for j in range(r2m-1, -1, -1):\\n                     if result[j].isdigit():\\n                         digit_char.insert(0, result.pop())\\n                     else:\\n                         break\\n                 result += char_temp*(int(''.join(digit_char)))\\n         return ''.join(result)\\n             \\n                     \\n\", \"class Solution:\\n     def decodeString(self, s):\\n         \\\"\\\"\\\"\\n         :type s: str\\n         :rtype: str\\n         \\\"\\\"\\\"\\n         stack_num = []\\n         stack_str = []\\n         num = ''\\n         string = ''\\n         for c in s:\\n             if c.isdigit():\\n                 if num == '':\\n                     stack_str.append(string)\\n                     string = ''\\n                 num += c\\n             elif c == '[':\\n                 stack_num.append(int(num))\\n                 num = ''\\n             elif c == ']':\\n                 string = stack_str.pop() + string * stack_num.pop()\\n             else:\\n                 string += c\\n         return string\\n\", \"class Solution:\\n     def decodeString(self, s):\\n         count = ''\\n         res = ''\\n         count_stack = []\\n         res_stack = []\\n \\n         for i in range(len(s)):\\n             if ord('0') <= ord(s[i]) <= ord('9'):\\n                 count += s[i]\\n             elif s[i] == '[':\\n                 count_stack.append(int(count) if count else 0)\\n                 res_stack.append(res)\\n                 count = ''\\n                 res = ''\\n             elif s[i] == ']':\\n                 res = res_stack.pop() + res * count_stack.pop()\\n             else:\\n                 res += s[i]\\n         return res\\n\", \"class Solution:\\n     def decodeString(self, s):\\n         \\\"\\\"\\\"\\n         :type s: str\\n         :rtype: str\\n         \\\"\\\"\\\"\\n         if len(s) == 0:\\n             return \\\"\\\"\\n         idx = 0\\n         while s[idx].isdigit():\\n             idx += 1\\n         if idx > 0:\\n             k = int(s[:idx])\\n             idx += 1\\n             idx_from = idx\\n             bracket_count = 1\\n             while bracket_count > 0:\\n                 if s[idx] == \\\"[\\\":\\n                     bracket_count += 1\\n                 elif s[idx] == \\\"]\\\":\\n                     bracket_count -= 1\\n                 idx += 1\\n             return self.decodeString(s[idx_from:idx-1]) * k + self.decodeString(s[idx:])\\n         return s[0] + self.decodeString(s[1:])\", \"class Solution:\\n     def decodeString(self, s):\\n         \\\"\\\"\\\"\\n         :type s: str\\n         :rtype: str\\n         \\\"\\\"\\\"\\n         stack = []\\n         stack.append([\\\"\\\", 1])\\n         num = \\\"\\\"\\n         for ch in s:\\n             if ch.isdigit():\\n                 num += ch\\n             elif ch == '[':\\n                 stack.append([\\\"\\\", int(num)])\\n                 num = \\\"\\\"\\n             elif ch == ']':\\n                 st, k = stack.pop()\\n                 stack[-1][0] += st*k\\n             else:\\n                 stack[-1][0] += ch\\n         return stack[0][0]\\n \\n         \\n         \\n         \\n         \\n         \\n         \\n         \\n         \\n         \\n         \\n         \\n \\n \\n \\n # def decodeString(self, s):\\n #     while '[' in s:\\n #         s = re.sub(r'(\\\\d+)\\\\[([a-z]*)\\\\]', lambda m: int(m.group(1)) * m.group(2), s)\\n #     return s            \\n\"]", "input_output": "{\"fn_name\": \"decodeString\", \"inputs\": [[\"\\\"3[a]2[bc]\\\"\"]], \"outputs\": [\"\\\"aaabcbc\\\"\"]}", "difficulty": "interview", "url": "https://leetcode.com/problems/decode-string/", "starter_code": "\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        "}
{"id": 147, "question": "There are n engineers numbered from 1 to n\u00a0and\u00a0two arrays: speed\u00a0and efficiency, where speed[i] and efficiency[i] represent the speed and efficiency for the i-th engineer respectively. Return the maximum performance of a team composed of\u00a0at most\u00a0k\u00a0engineers, since the answer can be a huge number, return this modulo\u00a010^9 + 7.\nThe performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among\u00a0their engineers.\u00a0\n\u00a0\nExample 1:\nInput: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2\nOutput: 60\nExplanation: \nWe have the maximum performance of the team by selecting engineer 2 (with speed=10 and efficiency=4) and engineer 5 (with speed=5 and efficiency=7). That is, performance = (10 + 5) * min(4, 7) = 60.\n\nExample 2:\nInput: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3\nOutput: 68\nExplanation:\nThis is the same example as the first but k = 3. We can select engineer 1, engineer 2 and engineer 5 to get the maximum performance of the team. That is, performance = (2 + 10 + 5) * min(5, 4, 7) = 68.\n\nExample 3:\nInput: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4\nOutput: 72\n\n\u00a0\nConstraints:\n\n1 <= n <= 10^5\nspeed.length == n\nefficiency.length == n\n1 <= speed[i] <= 10^5\n1 <= efficiency[i] <= 10^8\n1 <= k <= n", "solutions": "[\"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        mod = 10**9+7\\n        \\n        order = sorted(range(n), key=lambda i: efficiency[i], reverse=True)\\n\\n        heap = []\\n        filled = 0\\n        rec = 0\\n        speed_sum = 0\\n\\n        for i in order:\\n            if filled < k:\\n                heapq.heappush(heap, speed[i])\\n                filled += 1\\n                speed_sum += speed[i]\\n            else:\\n                removed = heapq.heappushpop(heap, speed[i])\\n                speed_sum += speed[i] - removed\\n            rec = max(rec, speed_sum*efficiency[i])\\n\\n        return rec %mod\", \"from heapq import *\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        ids = [i for i in range(n)]\\n        ids = sorted(ids, key=lambda x: -efficiency[x])\\n        max_perf, heap = 0, []\\n        sum = 0\\n        for i in ids:\\n            if len(heap) == k:\\n                sum -= heappop(heap)\\n            heappush(heap, speed[i])\\n            sum += speed[i]\\n            max_perf = max(max_perf, sum * efficiency[i])\\n        \\n        return max_perf % (10 ** 9 + 7)\", \"from heapq import *\\n\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n\\n        # sort by descending efficiency order\\n        engineers = sorted(zip(speed, efficiency), key=lambda x: -x[1])\\n        min_heap = []\\n        max_performance = 0\\n        curr_speed_sum = 0\\n        for i in range(len(engineers)):\\n            speed = engineers[i][0]\\n            efficiency = engineers[i][1]\\n\\n            if len(min_heap) < k:\\n                curr_speed_sum += speed\\n                heappush(min_heap, speed)\\n            else:\\n                # already have top k-speed in heap, swap it out if found a faster speed\\n                if speed > min_heap[0]:\\n                    top_kth_speed = heappushpop(min_heap, speed)\\n                    curr_speed_sum -= top_kth_speed\\n                    curr_speed_sum += speed\\n                else:\\n                    continue\\n\\n            max_performance = max(max_performance, curr_speed_sum * efficiency)\\n\\n        return max_performance % (10 ** 9 + 7)\", \"class Solution:\\n    def maxPerformance(self, n, speed, efficiency, k):\\n        teams = sorted(zip(efficiency, speed), reverse=True)\\n        pq = []\\n        max_perf = s = 0\\n        for i in range(n):\\n            heapq.heappush(pq, teams[i][1])\\n            s += teams[i][1]\\n            if i >= k:\\n                s -= heapq.heappop(pq)\\n            max_perf = max(max_perf, s * teams[i][0])\\n        return max_perf % (10 ** 9 + 7)\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        term=10**9+7\\n        heap=[]\\n        lst=[i for i in range(n)]\\n        lst.sort(key=lambda x:(-efficiency[x],-speed[x]))\\n        ret=0\\n        acc=0\\n        for i in range(k):\\n            idx=lst[i]\\n            acc+=speed[idx]\\n            heap.append(speed[idx])\\n            ret=max(ret,acc*efficiency[idx])\\n        # build heap\\n        import heapq\\n        heapq.heapify(heap)\\n        for i in range(k,n):\\n            idx=lst[i]\\n            if heap[0]<speed[idx]:\\n                acc=acc-heap[0]+speed[idx]\\n                heapq.heapreplace(heap,speed[idx])\\n                ret=max(ret,acc*efficiency[idx])\\n        return ret%term\", \"import heapq\\n\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        bestTeamHeap = []\\n        heapSum = 0\\n        bestTeamScore = 0\\n        for e, s in sorted(zip(efficiency, speed), reverse=True):\\n            heapq.heappush(bestTeamHeap, s)\\n            heapSum += s\\n            if len(bestTeamHeap) > k:\\n                heapSum -= heapq.heappop(bestTeamHeap)\\n            bestTeamScore = max(bestTeamScore, e * heapSum)\\n        return bestTeamScore % (10 ** 9 + 7)\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        ls = list(zip(speed, efficiency))\\n        ls.sort(key=lambda x: -x[1])\\n        hq, ssum = [], 0\\n        ans = 0\\n        for i, (s, e) in enumerate(ls):\\n            if i >= k:\\n                s0, e0 = heapq.heappop(hq)\\n                ssum -= s0\\n            heapq.heappush(hq, (s, e))\\n            ssum += s\\n            ans = max(ans, ssum * e)\\n            \\n        return ans%1_000_000_007\\n   \\n            \\n            \\n                \\n            \\n            \\n\", \"class Solution:\\n    def maxPerformance(self, n, speed, efficiency, k):\\n       # n = speed.len()\\n        ls = list(zip(speed, efficiency))\\n        ls.sort(key=lambda x: -x[1])\\n        \\n        HEAP = []\\n        tsum = 0\\n        ans = 0\\n        for i in range(n):\\n            if i >= k:\\n                speed, efficiency = heapq.heappop(HEAP)\\n                tsum -= speed\\n            heapq.heappush(HEAP, ls[i])\\n            tsum += ls[i][0]\\n            ans = max(ans, tsum*ls[i][1])\\n            \\n        return ans%1_000_000_007\", \"from heapq import heappush,heappop\\n\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        comb = sorted(zip(efficiency,speed), reverse = True)\\n        min_heap = []\\n        perf = 0\\n        s = 0\\n        for i in range(n):\\n            heappush(min_heap,comb[i][1])\\n            s += comb[i][1]\\n            if i >= k:\\n                s -= heappop(min_heap)\\n                \\n            perf = max(perf, s * comb[i][0])\\n        \\n        return perf % (10 ** 9 + 7)\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        h = []\\n        res = sSum = 0\\n        for e, s in sorted(zip(efficiency, speed), reverse=1):\\n            heapq.heappush(h, s)\\n            sSum += s\\n            if len(h) > k:\\n                sSum -= heapq.heappop(h)\\n            res = max(res, sSum * e)\\n        return res % (10**9 + 7)\\n\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        h = []\\n        res = sSum = 0\\n        for e, s in sorted(zip(efficiency, speed), reverse=1):\\n            heapq.heappush(h, s)\\n            sSum += s\\n            if len(h) > k:\\n                sSum -= heapq.heappop(h)\\n            res = max(res, sSum * e)\\n        return res % (10**9 + 7)\\n\", \"from heapq import *\\n\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        totalSpeed = 0\\n        res = 0\\n        heap = []\\n        for e, s in sorted(zip(efficiency, speed), reverse=True):\\n            totalSpeed += s\\n            heappush(heap, s)\\n            if len(heap) > k:\\n                totalSpeed -= heappop(heap)\\n            res = max(res, totalSpeed * e)\\n        return res % (10 ** 9 + 7)\\n\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        items = sorted(zip(speed, efficiency), key=lambda item: (-item[1], -item[0]))\\n        heap = []\\n\\n        s = 0\\n        res = 0\\n\\n        for item in items:\\n            if len(heap) < k or item[0] > heap[0][0]:\\n                if len(heap) == k:\\n                    popped = heapq.heappop(heap)\\n                    s -= popped[0]\\n                heapq.heappush(heap, item)\\n                s += item[0]\\n                res = max(res, s * item[1])\\n\\n        return res % (10 ** 9 + 7)\", \"from heapq import heappop, heappush\\n\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        es_list = [[-e, s] for s, e in zip(speed, efficiency)]\\n        es_list.sort()\\n        \\n        queue = []\\n        \\n        total_speed = 0\\n        cur_eff = 0\\n        res = 0\\n        for e, s in es_list:\\n            #print(e, s, queue, total_speed, res)\\n            if -e < cur_eff:\\n                res = max(res, cur_eff * total_speed)\\n\\n            if len(queue) == k:\\n                if not queue or queue[0] < s:\\n                    pre_s = heappop(queue)\\n                    total_speed -= pre_s\\n            if not queue or len(queue) < k:\\n                heappush(queue, s)\\n                total_speed += s\\n                cur_eff = -e\\n        return max(res, total_speed*cur_eff)%(10**9 + 7)\\n            \\n            \\n\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        mod = 10 ** 9 + 7\\n        eff_speed = sorted(zip(efficiency, speed), reverse=True)\\n        n = len(eff_speed)\\n        i = 0\\n        speed_h = []\\n        speed_sum = 0\\n        max_perf = 0\\n        start = 0\\n        while i < n:\\n            while i == start or (i < n and eff_speed[i][0] == eff_speed[i - 1][0]):\\n                heapq.heappush(speed_h, eff_speed[i][1])\\n                speed_sum += eff_speed[i][1]\\n                if len(speed_h) > k:\\n                    speed_sum -= heapq.heappop(speed_h)\\n                i += 1\\n            start = i\\n            cur_efficiency = eff_speed[i - 1][0]\\n            max_perf = max(max_perf, cur_efficiency * speed_sum)\\n        return max_perf % mod\\n\", \"class Solution:\\n    def maxPerformance1(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        people = sorted(zip(speed,efficiency),key=lambda x: -x[1])\\n        total,sumSpeed = 0,0\\n        for s,e in people:\\n            sumSpeed +=s\\n            total = max(total,sumSpeed * e)\\n        return total\\n        \\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        people = sorted(zip(speed, efficiency), key=lambda x: -x[1])\\n        print(people)\\n        result, sum_speed = 0, 0\\n        min_heap = []\\n        for i, (s, e) in enumerate(people):\\n            if i < k:\\n                sum_speed += s\\n                heapq.heappush(min_heap, s)\\n            elif s > min_heap[0]:\\n                sum_speed += s - heapq.heappushpop(min_heap, s)\\n\\n            result = max(result, sum_speed * e)\\n           \\n        return result  % 1000000007\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n        \\n        \\n        \\n        \\n        \\n\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        es = list(zip(efficiency, speed))\\n        es.sort(reverse=True)\\n        \\n        # try out all possible least efficient member\\n        # keep track of highest k speed before and including this member\\n        \\n        \\n        speed_sum = 0\\n        max_prod = 0\\n        heap = []\\n        for i in range(k):\\n            eff, speed = es[i]\\n            speed_sum += speed\\n            max_prod = max(max_prod, speed_sum * eff)\\n            heap.append(speed)\\n        \\n        heapq.heapify(heap)\\n        for i in range(k, n):\\n            cur_eff, cur_speed = es[i]\\n            heapq.heappush(heap, cur_speed)\\n            speed_sum -= heapq.heappop(heap)\\n            speed_sum += cur_speed\\n            # prev_min = heapq.heappop(heap)\\n            # speed_sum -= prev_min\\n            # speed_sum += cur_speed\\n            max_prod = max(max_prod, speed_sum * cur_eff)\\n            # heapq.heappush(heap, max(prev_min, cur_speed))\\n            # speed_sum -= cur_speed\\n            # speed_sum += max(prev_min, cur_speed)\\n            \\n        \\n        return max_prod % ((10 ** 9) + 7)\\n            \\n            \\n\", \"class Solution:\\n    def maxPerformance(self, n, speed, efficiency, k):\\n        worker = []\\n        for i in range(n):\\n            worker.append([speed[i], efficiency[i]])\\n        worker.sort(key = lambda x:-x[1])\\n        print(worker)\\n        import heapq\\n        total = 0\\n        heap = []\\n        res = 0\\n        for i in range(k):\\n            total += worker[i][0]\\n            minE = worker[i][1]\\n            heapq.heappush(heap, worker[i][0])\\n            res = max(res, total*minE)\\n        for i in range(k, n):\\n            if worker[i][0] > heap[0]:\\n                total += (-heap[0]+worker[i][0])\\n                minE = worker[i][1]\\n                res = max(res, minE*total)\\n                heapq.heappop(heap)\\n                heapq.heappush(heap, worker[i][0])\\n        return res%1000000007\\n        \\n    # def cmp(self, w1, w2):\\n    #     if w1[1] > w2[1]:\\n    #         return -1\\n    #     elif w1[1] == w2[1]:\\n    #         return 0\\n    #     else:\\n    #         return 1\\n\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        # Sort engineer by efficiency\\n        # for all engineer higher than efficiency x,\\n        # keep the ones with high speed\\n        if n == 0:\\n            return 0\\n\\n        engineers = [[speed[i], efficiency[i]] for i in range(n)]\\n        engineers.sort(key=lambda x:x[1], reverse=True)\\n        \\n        mod = 1000000007\\n        pq = []\\n        sum_speed = 0\\n        min_efficiency = engineers[0][1]\\n        max_performance = 0\\n        for e in engineers:\\n            heapq.heappush(pq, e)\\n            sum_speed += e[0]\\n            if len(pq) > k:\\n                tmp = heapq.heappop(pq)\\n                sum_speed -= tmp[0]\\n                if tmp != e : # The newly added engineer might be eliminated\\n                    min_efficiency = e[1]\\n            else:\\n                min_efficiency = e[1]\\n\\n            max_performance = max(max_performance, sum_speed * min_efficiency)\\n        \\n        return max_performance % mod\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        res = sorted([(speed[i], efficiency[i]) for i in range(n)], key = lambda x: [-x[1], -x[0]])\\n        \\n        num = 0\\n        sums = []\\n        ss = 0\\n        maxi = 0\\n        for s,e in res:\\n            if num < k:\\n                heappush(sums, s)\\n                ss += s\\n                num+=1\\n                maxi = max(maxi, ss*e)\\n            else:\\n                rmv = heappushpop(sums, s)\\n                ss = ss - rmv + s\\n                maxi = max(maxi, ss*e)\\n                \\n                \\n        return maxi%(10**9+7)\\n\", \"import heapq\\n\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        mod = 10 ** 9 + 7\\n        comb = [(speed[i], efficiency[i]) for i in range(n)]\\n        comb.sort(key = lambda x: -x[1])\\n        \\n        total_speed = 0\\n        ans = 0\\n        pq = []\\n        \\n        for i in range(n):\\n            heapq.heappush(pq, comb[i][0])\\n            total_speed += comb[i][0]\\n            \\n            if len(pq) > k:\\n                total_speed -= heapq.heappop(pq)\\n            low_eff = comb[i][1]\\n            \\n            ans = max(ans, total_speed * low_eff)\\n            \\n        return ans % mod\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:        \\n        sums = []\\n        ss = 0\\n        maxi = 0\\n        for s,e in sorted([(speed[i], efficiency[i]) for i in range(n)], key = lambda x: [-x[1], -x[0]]):\\n            heappush(sums, s)\\n            ss += s\\n            if len(sums) > k:\\n                rmv = heappop(sums)\\n                ss -= rmv\\n            maxi = max(maxi, ss*e)\\n\\n        return maxi%(10**9+7)\\n\", \"import heapq\\nclass Solution:\\n    def maxPerformance(self, n, speed, efficiency, k):\\n        engs=[]\\n        heapq.heapify(engs)\\n        for i in range(n):\\n            heapq.heappush(engs,(-efficiency[i],speed[i]))\\n        \\n        speedtotal=0\\n        totalperf=0\\n        \\n        current_team=[]\\n        heapq.heapify(current_team)\\n        for i in range(k):\\n            temp=heapq.heappop(engs)\\n            speedtotal+=temp[1]\\n            totalperf=max(totalperf,speedtotal*-temp[0])\\n            heapq.heappush(current_team,temp[1])\\n        \\n        for j in range(k,n):\\n            temp=heapq.heappop(engs)\\n            if temp[1]>current_team[0]:\\n                speedtotal-=current_team[0]\\n                speedtotal+=temp[1]\\n                totalperf=max(totalperf,-temp[0]*speedtotal)\\n                heapq.heappop(current_team)\\n                heapq.heappush(current_team,temp[1])\\n                \\n        return totalperf%(10**9+7)\\n            \\n        \\n        \\n\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        \\n        \\n        l=[(x,y) for x,y in zip(speed,efficiency)]\\n        l=sorted(l,key=lambda x: (x[1],-x[0]))\\n        #efficiency=sorted(efficiency)\\n        \\n        ma=0\\n        q=[]\\n        s=0\\n        for i in range(len(l)-1,-1,-1):\\n            mi=l[i][1]\\n            \\n            heapq.heappush(q,l[i][0])\\n            s+=l[i][0]\\n            if len(q)>k:\\n                s-=heapq.heappop(q)\\n            \\n            ma=max(ma,s*l[i][1])\\n        return ma%((10**9)+7)\\n\\n            \\n            \\n            \\n\", \"import heapq\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        engineers = [(speed[i],efficiency[i]) for i in range(n)]\\n        engineers.sort(key = lambda x : (-x[1],x[0]))\\n        result = 0\\n        heap = []\\n        totalSum = 0\\n        for i in range(n):\\n            while len(heap) >= k:\\n                totalSum -= heapq.heappop(heap)\\n            result = max(result , (totalSum + engineers[i][0]) * engineers[i][1] )\\n            heapq.heappush(heap,engineers[i][0])\\n            totalSum += engineers[i][0]\\n        return result % (10 ** 9 + 7)\", \"class Solution(object):\\n    def maxPerformance(self, n, speed, efficiency, k):\\n        worker = []\\n        for i in range(n):\\n            worker.append([speed[i], efficiency[i]])\\n        worker = sorted(worker,key = lambda x :x[1],reverse = True)\\n        print(worker)\\n        import heapq\\n        total = 0\\n        heap = []\\n        res = 0\\n        for i in range(k):\\n            total += worker[i][0]\\n            minE = worker[i][1]\\n            heapq.heappush(heap, worker[i][0])\\n            res = max(res, total*minE)\\n        for i in range(k, n):\\n            if worker[i][0] > heap[0]:\\n                total += (-heap[0]+worker[i][0])\\n                minE = worker[i][1]\\n                res = max(res, minE*total)\\n                heapq.heappop(heap)\\n                heapq.heappush(heap, worker[i][0])\\n        return res%1000000007\\n        \\n    def cmp(self, w1, w2):\\n        if w1[1] > w2[1]:\\n            return -1\\n        elif w1[1] == w2[1]:\\n            return 0\\n        else:\\n            return 1\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        h=[]  #\\u6700\\u5c0f\\u5806\\uff0c\\u5b58\\u653e\\u6311\\u9009\\u7684\\u5de5\\u7a0b\\u5e08\\u7684\\u901f\\u5ea6\\n        ssum=0\\n        res=0\\n        for e,s in sorted(zip(efficiency,speed),reverse=True):\\n            heapq.heappush(h,s)\\n            ssum+=s\\n            if len(h)>k:\\n                ssum-=heapq.heappop(h)\\n            res=max(res,ssum*e)\\n        return res%(10**9+7)\", \"\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        people = sorted(zip(speed, efficiency), key=lambda x: x[1],reverse=True)\\n        \\n        result, sum_speed = 0, 0\\n        min_heap = []\\n        print(people)\\n        for i, (s, e) in enumerate(people):\\n            if i < k:\\n                sum_speed += s\\n                heapq.heappush(min_heap, s)\\n            elif s > min_heap[0]:\\n                sum_speed += s - heapq.heappushpop(min_heap, s)\\n                \\n            result = max(result, sum_speed * e)\\n            print(result)\\n        \\n        return result % (pow(10,9)+7)\\n\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        pq, largelst = [], []\\n        for i in range(n):\\n            heapq.heappush(pq, (-efficiency[i], speed[i]))\\n        \\n        mx, sm = 0, 0\\n        while pq:\\n            pop = heapq.heappop(pq)\\n            eff = -pop[0]\\n            heapq.heappush(largelst, pop[1])\\n            sm+=pop[1]\\n            while len(largelst)>k:\\n                rm = heapq.heappop(largelst)\\n                sm -= rm\\n            mx = max(mx, sm* eff)\\n            \\n        return mx % (10**9+7)\\n\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        engineers = sorted(zip(speed, efficiency), key=lambda eng: eng[1], reverse=True)\\n        h = []\\n        res = 0\\n        speedSum = 0\\n        for s, e in engineers:\\n            heapq.heappush(h, s)\\n            speedSum += s\\n            if len(h) > k:\\n                speedSum -= h[0]\\n                heapq.heappop(h)\\n            res = max(res, speedSum*e)\\n        return res%(10**9 + 7)\", \"from heapq import heappush, heappop\\n\\nclass Engineer:\\n    def __init__(self, speed, efficiency):\\n        self.speed = speed\\n        self.efficiency = efficiency\\n    \\n    def __str__(self):\\n        return str(self.speed) + ',' + str(self.efficiency)\\n\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        engineers = [Engineer(speed[i], efficiency[i]) for i in range(n)]\\n        engineers.sort(key=lambda x: x.efficiency, reverse=True)\\n        performance = 0\\n        maxSpeeds = []\\n        sumOfSpeeds = 0\\n        for index, engineer in enumerate(engineers):\\n            heappush(maxSpeeds, [engineer.speed, index, engineer])\\n            sumOfSpeeds += engineer.speed\\n            if len(maxSpeeds) > k:\\n                sumOfSpeeds -= heappop(maxSpeeds)[2].speed\\n            performance = max(performance, engineer.efficiency * sumOfSpeeds)\\n        return performance % (10**9 + 7)\", \"import heapq\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        lst = sorted(zip(efficiency, speed), reverse = True)\\n        p = []\\n        sum_speed = 0\\n        res = 0\\n        for e, s in lst:\\n            sum_speed += s\\n            heapq.heappush(p, s)\\n            if len(p) > k:\\n                sum_speed -= (heapq.heappop(p))\\n            val = e * sum_speed\\n            res = max(res, val)\\n            \\n        return res % (10**9 + 7)\\n\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        temp = []\\n        for i in range(len(efficiency)):\\n            temp.append([efficiency[i], speed[i]])\\n        temp.sort(reverse = True)\\n        heap = []\\n        cur_sum = 0\\n        result = 0\\n        for i in range(len(temp)):\\n            heapq.heappush(heap, (temp[i][1], i))\\n            cur_sum += temp[i][1]\\n            if len(heap) > k:\\n                cur_sum -= heapq.heappop(heap)[0]\\n            result = max(result, cur_sum * temp[i][0])\\n        return result % (10 ** 9 + 7)\", \"from heapq import heappush, heappop\\nclass Engineer:\\n    def __init__(self, speed, efficiency):\\n        self.speed = speed\\n        self.efficiency = efficiency\\n        \\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        engineers = []\\n        for i in range(n):\\n            engineers.append(Engineer(speed[i], efficiency[i]))\\n        engineers.sort(key=lambda eng: eng.efficiency, reverse = True)\\n        minHeap = []\\n        maxPerform, sumOfSpeed = 0, 0\\n        for i, eng in enumerate(engineers):\\n            sumOfSpeed += eng.speed\\n            heappush(minHeap, [eng.speed, i,eng])\\n            if len(minHeap) > k:\\n                sumOfSpeed -= heappop(minHeap)[2].speed\\n            maxPerform = max(sumOfSpeed * eng.efficiency, maxPerform)\\n        \\n        return maxPerform % (10**9 + 7)\\n\", \"import heapq\\n\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        res = 0\\n        hired, curr_sum = [], 0\\n        for e, s in sorted(zip(efficiency, speed), reverse=True):\\n            heapq.heappush(hired, s)\\n            curr_sum += s\\n            if len(hired) > k:\\n                curr_sum -= heapq.heappop(hired)\\n            res = max(res, curr_sum * e)\\n        return res % (10**9 + 7)\", \"from heapq import heappush, heappop\\n\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        data = sorted(list(zip(efficiency, speed)), reverse=True)\\n        pq = []\\n        current_eff, total = float('inf'), 0\\n        answer = 0\\n        print(data)\\n        for eff, spd in data:\\n            current_eff = eff\\n            total += spd\\n            heappush(pq, spd)\\n            if len(pq) > k:\\n                total -= heappop(pq)\\n            answer = max(answer, current_eff * total)\\n        return answer % int(1e9 + 7)\", \"from heapq import heappush, heappop\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        ## based on the hints\\n        ## since The performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among their engineers\\n        ## we process engineer one by one in desceding order of his efficiency\\n        ## and keep track the running sum of the previous k largest speeds\\n        \\n        ## two priority queues\\n        M = 10**9+7\\n        eff_pq = [] ## max heap\\n        sp_pq = [] ## min heap\\n        speed_sum = 0 ## track the sum of largest k speeds\\n        ## push all efficiency and indexes into a max-heap\\n        for idx, eff in enumerate(efficiency):\\n            heappush(eff_pq, (-eff, idx))\\n        \\n        res = 0\\n        while len(eff_pq)>0:\\n            neg_eff, idx = heappop(eff_pq) ## process engineer one by one in desceding order of his efficiency\\n            eff = -neg_eff\\n            heappush(sp_pq, speed[idx]) ## push his speed into min-heap\\n            speed_sum += speed[idx] ## keep tracking the running sum\\n            \\n            ## maintain the priority queue with size <= k\\n            if len(sp_pq) > k:\\n                sp_pop = heappop(sp_pq)\\n                speed_sum -= sp_pop ## keep tracking the running sum\\n                \\n            ## note that a team be at most k engineers, which mean it can be less than k\\n            res = max(res, eff*speed_sum) \\n            \\n        return res % M\\n# 6\\n# [2,10,3,1,5,8]\\n# [5,4,3,9,7,2]\\n# 2\\n# 3\\n# [2,8,2]\\n# [2,7,1]\\n# 2    \\n\", \"import heapq\\n\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        a=list(zip(efficiency,speed))\\n        a.sort(reverse=True)\\n        pq=[]\\n        mp=s=0\\n        for i in range(n):\\n            heapq.heappush(pq,a[i][1])\\n            s+=a[i][1]\\n            if(i>=k):\\n                s-=heapq.heappop(pq)\\n            mp=max(mp,s*a[i][0])\\n        return mp%(10**9+7)\\n        \\n\", \"from heapq import heappush,heappop\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        mod = 10**9 + 7\\n        people = [ [speed[i],efficiency[i]] for i in range(n)]\\n        \\n        people.sort(key=lambda x:-x[1])\\n        res = 0\\n        h = []\\n        \\n        total_speed = 0\\n        for i , (s,e) in enumerate(people):\\n            heappush(h,s)\\n            total_speed += s\\n            \\n            if len(h) > k:\\n                total_speed -= heappop(h) \\n            \\n            res = max(res, total_speed*e) \\n        \\n        return res % mod\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        \\n        MOD = 10 ** 9 + 7\\n\\n        #(speed, effiency)\\n        comb = [(speed[i], efficiency[i]) for i in range(n)]\\n        comb.sort(key = lambda x: -x[1])\\n\\n        total_speed = 0\\n        ans = 0 \\n        pq = []\\n        \\n        for i in range(n):\\n            heapq.heappush(pq, comb[i][0])\\n            total_speed += comb[i][0]\\n            \\n            if len(pq) > k:\\n                total_speed -= heapq.heappop(pq)\\n            low_eff = comb[i][1]\\n            \\n            ans = max(ans, total_speed * low_eff)\\n        \\n        return ans % MOD\\n    \\n        MOD = 10**9 + 7\\n        combo = []\\n        for i in range(n):\\n            heapq.heappush(combo, (-efficiency[i], speed[i]))\\n        tmp = []\\n        ans, currsum = 0, 0\\n        \\n        while combo:\\n            curre, currs = heapq.heappop(combo)\\n            tmp.append((currs))\\n            currsum += currs\\n            if len(tmp) > k:\\n                currsum -= heapq.heappop(tmp)\\n            ans = max(ans, -currsum * curre % MOD)\\n        return ans\", \"from heapq import heappop, heappush\\n\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        queue = []\\n        sspeed = 0\\n        res = 0\\n        for e, s in sorted(zip(efficiency, speed), reverse=True):\\n            heappush(queue, s)\\n            sspeed += s\\n            if len(queue) > k:\\n                sspeed -= heappop(queue)\\n            res = max(res, sspeed*e)\\n        return res%(10**9 + 7)\\n\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        worker = []\\n        for i in range(n):\\n            worker.append([speed[i], efficiency[i]])\\n        worker.sort(key = lambda x: x[1], reverse = True)\\n        import heapq\\n        total = 0\\n        heap = []\\n        res = 0\\n        for i in range(k):\\n            total += worker[i][0]\\n            minE = worker[i][1]\\n            heapq.heappush(heap, worker[i][0])\\n            res = max(res, total*minE)\\n        for i in range(k, n):\\n            if worker[i][0] > heap[0]:\\n                total += (-heap[0]+worker[i][0])\\n                minE = worker[i][1]\\n                res = max(res, minE*total)\\n                # heapq.heappop(heap)\\n                heapq.heappushpop(heap, worker[i][0])\\n        return res%1000000007\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        sorting = sorted([(s,i) for i,s in enumerate(speed)])\\n        speedset = set(i for _,i in sorting[len(sorting)-k:])\\n        ssum = sum(s for s,_ in sorting[len(sorting)-k:])\\n        removed = set()\\n        idx = len(sorting)-k\\n        \\n        ans = 0\\n        for e,i in sorted([(e,i) for i,e in enumerate(efficiency)]):\\n            if i in speedset:\\n                ans = max(ans, e * ssum)\\n                \\n                speedset.remove(i)\\n                ssum -= speed[i]\\n                \\n                idx -= 1\\n                while idx >= 0 and sorting[idx][1] in removed:\\n                    idx -= 1\\n                \\n                if idx >= 0:\\n                    speedset.add(sorting[idx][1])\\n                    ssum += sorting[idx][0]\\n            else:\\n                ans = max(ans, e * (ssum - sorting[idx][0] + speed[i]))\\n            removed.add(i)\\n        return ans % (10**9 + 7)\\n            \\n\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        a = [(s, e) for s, e in zip(speed, efficiency)]\\n        if k == 1:\\n            return max([s * e for s, e in a])\\n        a.sort(key=lambda x:-x[1])\\n        ret = 0\\n        q = []\\n        s_sum = 0\\n        for s, e in a:\\n            ret = max(ret, (s_sum + s) * e)\\n            if len(q) >= k - 1:\\n                if q[0] < s:\\n                    x = heapq.heappop(q)\\n                    s_sum = s_sum + s - x\\n                    heapq.heappush(q, s)\\n            else:\\n                heapq.heappush(q, s)\\n                s_sum += s\\n        return ret % (10 ** 9 + 7)\", \"import heapq\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        pairs = list(zip(efficiency, speed))\\n        pairs.sort(key = lambda x: (-x[0], -x[1]))\\n        arr = []\\n        res = 0\\n        sum_spd = 0\\n        for eff, spd in pairs:\\n            if len(arr) < k:\\n                sum_spd += spd\\n                heapq.heappush(arr, spd)\\n            else:\\n                if spd > arr[0]:\\n                    sum_spd += spd - heapq.heappushpop(arr, spd)\\n            res = max(res, sum_spd*eff)\\n        return res % (10**9 + 7)\\n\", \"from sortedcontainers import SortedList\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        workers, MOD = SortedList(), 10 ** 9 + 7\\n        \\n        ret = ss = 0\\n        for e, s in sorted(zip(efficiency, speed), reverse=True):\\n            workers.add(s)\\n            ss += s\\n            \\n            if len(workers) > k:\\n                ss -= workers.pop(0)\\n            \\n            ret = max(ret, e * ss)\\n        \\n        return ret % MOD\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        q =[]\\n        worker = []\\n        for s,e in zip(speed, efficiency):\\n            worker.append([s,e])\\n        \\n        ans, speeds, minEff = 0,0,float('inf')\\n        for s,e in sorted(worker, key=lambda x: -x[1]):\\n            if len(q) < k:\\n                heapq.heappush(q, [s,e])\\n                speeds += s\\n                minEff = min(minEff, e)\\n            elif s > q[0][0]:\\n                ts,te = heapq.heappop(q)\\n                speeds = speeds - ts + s\\n                minEff = e\\n                heapq.heappush(q, [s,e])\\n            ans = max(ans, speeds*minEff)\\n        \\n        return ans%(10**9+7)\\n        \\n\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        heap = []\\n        total = 0\\n        pairs = list(zip(speed, efficiency))\\n        pairs.sort(key = lambda x: -x[1])\\n        res = 0\\n        MOD = 10 ** 9 + 7\\n        for i, (s, e) in enumerate(pairs):\\n            res = max(e * (total + s), res)\\n            if len(heap) < k - 1:\\n                heapq.heappush(heap, s)\\n                total += s\\n            elif heap and s > heap[0]:\\n                total -= heapq.heappop(heap)\\n                heapq.heappush(heap, s)\\n                total += s\\n        return res % MOD\", \"from queue import PriorityQueue\\n\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        mod = 10 ** 9 + 7\\n        if k == 1:\\n            return max([speed[i] * efficiency[i] for i in range(n)]) % mod\\n        \\n        engs = sorted([(efficiency[i], speed[i]) for i in range(n)])\\n        others = PriorityQueue()\\n        maxi = 0\\n        otherSum = 0\\n        for i in range(n - 1, -1, -1):\\n            maxi = max(maxi, ((engs[i][1] + otherSum) * engs[i][0]))\\n            otherSum += engs[i][1]\\n            others.put(engs[i][1])\\n            while others.qsize() > k - 1:\\n                otherSum -= others.get()\\n            \\n        return maxi % mod\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        unit = sorted([(s, e) for (s, e) in zip(speed, efficiency)], key=lambda x:x[1], reverse=True)\\n        max_res = -1\\n        curr_sum = 0\\n        MOD = 10**9 + 7\\n        heap = []\\n        for s, e in unit:\\n            curr_sum += s\\n            max_res = max(max_res, curr_sum * e)\\n            heapq.heappush(heap, s)\\n            if len(heap) >= k:\\n                curr_sum -= heapq.heappop(heap)\\n        return max_res % MOD\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        arr = list(zip(efficiency, speed))\\n        arr.sort(reverse=True)\\n        counter = 0\\n        curr_max = 0\\n        heap = []\\n        for i in arr:\\n            curr_max = max(curr_max, i[0] * (counter + i[1]))\\n            heapq.heappush(heap, i[1])\\n            counter += i[1]\\n            if len(heap) > k - 1:\\n                counter -= heapq.heappop(heap)\\n        return (curr_max) % ((10 ** 9) + 7)\\n            \\n\", \"from queue import PriorityQueue\\n\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        mod = 10 ** 9 + 7\\n        if k == 1:\\n            return max([speed[i] * efficiency[i] for i in range(n)]) % mod\\n        \\n        engs = sorted([(efficiency[i] % mod, speed[i] % mod) for i in range(n)])\\n        maxi = 0\\n        others = PriorityQueue()\\n        otherSum = 0\\n        for i in range(n - 1, -1, -1):\\n            maxi = max(maxi, ((engs[i][1] + otherSum) * engs[i][0]) )\\n            otherSum += engs[i][1]\\n            others.put(engs[i][1])\\n            while others.qsize() > k - 1:\\n                otherSum -= others.get()\\n            \\n        return maxi % mod\", \"from queue import PriorityQueue\\n\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        mod = 10 ** 9 + 7\\n        if k == 1:\\n            return max([speed[i] * efficiency[i] for i in range(n)]) % mod\\n        \\n        engs = sorted([(efficiency[i] % mod, speed[i] % mod) for i in range(n)])\\n        others = PriorityQueue()\\n        maxi = 0\\n        otherSum = 0\\n        for i in range(n - 1, -1, -1):\\n            maxi = max(maxi, ((engs[i][1] + otherSum) * engs[i][0]))\\n            otherSum += engs[i][1]\\n            others.put(engs[i][1])\\n            while others.qsize() > k - 1:\\n                otherSum -= others.get()\\n            \\n        return maxi % mod\", \"import heapq\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        pairs = list(zip(efficiency, speed))\\n        pairs.sort(key = lambda x: (-x[0], -x[1]))\\n        arr = []\\n        res = 0\\n        sum_spd = 0\\n        for eff, spd in pairs:\\n            if len(arr) < k:\\n                sum_spd += spd\\n                heapq.heappush(arr, spd)\\n            else:\\n                sum_spd += spd - heapq.heappushpop(arr, spd)\\n            res = max(res, sum_spd*eff)\\n        return res % (10**9 + 7)\\n\", \"import heapq\\n\\nclass Solution:\\n    def maxPerformance(self, n: int, S: List[int], E: List[int], k: int) -> int:\\n        \\n        tmp = []\\n        \\n        for x, y in zip(S, E):\\n            tmp.append([y, x])\\n        tmp.sort(reverse=True)\\n        \\n        stack = []\\n        sums = 0\\n        res = 0\\n        for i in range(n):\\n            nk = tmp[i][0]\\n            sums += tmp[i][1] - (heapq.heappop(stack) if len(stack) == k else 0)\\n            heapq.heappush(stack, tmp[i][1])\\n            res = max(res, nk * sums )\\n        return res % 1000000007\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        mod = 10 ** 9 + 7\\n        eff_speed = sorted(zip(efficiency, speed), reverse=True)\\n        n = len(eff_speed)\\n        i = 0\\n        speed_h = []\\n        speed_sum = 0\\n        max_perf = 0\\n        start = 0\\n        while i < n:\\n            while i == start or (i < n and eff_speed[i][0] == eff_speed[i - 1][0]):\\n                heapq.heappush(speed_h, eff_speed[i][1])\\n                speed_sum += eff_speed[i][1]\\n                if len(speed_h) > k:\\n                    speed_sum -= heapq.heappop(speed_h)\\n                i += 1\\n            start = i\\n            cur_efficiency = eff_speed[i - 1][0]\\n            max_perf = max(max_perf, cur_efficiency * speed_sum)\\n        return max_perf % mod\\n    \\n    \\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        mod = 10 ** 9 + 7\\n        eff_speed = sorted(zip(efficiency, speed), reverse=True)\\n        n = len(eff_speed)\\n        speed_h = []\\n        speed_sum = 0\\n        max_perf = 0\\n        for e, s in eff_speed:\\n            heapq.heappush(speed_h, s)\\n            speed_sum += s\\n            if len(speed_h) > k:\\n                speed_sum -= heapq.heappop(speed_h)\\n            max_perf = max(max_perf, speed_sum * e)\\n        return max_perf % mod\\n            \\n\", \"import heapq \\n\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        \\n        arr = zip(efficiency, speed)\\n        arr = sorted(arr, key=lambda x: (-x[0],-x[1])) \\n        pq = [] \\n        maxSoFar, currSum = 0, 0\\n        \\n        for eff,sp in arr: \\n            \\n            currSum += sp \\n            heapq.heappush(pq,sp)\\n            if len(pq) == k+1:\\n                currSum -= heapq.heappop(pq) \\n                \\n            maxSoFar = max(maxSoFar, currSum * eff) \\n\\n        \\n        return maxSoFar % 1000000007\", \"class Solution:\\n    # O(nlogn + 2nlogk) time, no unnecessary max comparison, O(n) space\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        mod = 10 ** 9 + 7\\n        eff_speed = sorted(zip(efficiency, speed), reverse=True)\\n        n = len(eff_speed)\\n        i = 0\\n        speed_h = []\\n        speed_sum = 0\\n        max_perf = 0\\n        start = 0\\n        while i < n:\\n            while i == start or (i < n and eff_speed[i][0] == eff_speed[i - 1][0]):\\n                heapq.heappush(speed_h, eff_speed[i][1])\\n                speed_sum += eff_speed[i][1]\\n                if len(speed_h) > k:\\n                    speed_sum -= heapq.heappop(speed_h)\\n                i += 1\\n            start = i\\n            cur_efficiency = eff_speed[i - 1][0]\\n            max_perf = max(max_perf, cur_efficiency * speed_sum)\\n        return max_perf % mod\\n    \\n    # O(nlogn + 2nlogk) time, O(n) space\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        mod = 10 ** 9 + 7\\n        eff_speed = sorted(zip(efficiency, speed), reverse=True)\\n        n = len(eff_speed)\\n        speed_h = []\\n        speed_sum = 0\\n        max_perf = 0\\n        for e, s in eff_speed:\\n            heapq.heappush(speed_h, s)\\n            speed_sum += s\\n            if len(speed_h) > k:\\n                speed_sum -= heapq.heappop(speed_h)\\n            max_perf = max(max_perf, speed_sum * e)\\n        return max_perf % mod\\n            \\n\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        M = 10 ** 9 + 7\\n        \\n        heap = []\\n        ans = t = 0\\n        for e, s in sorted(zip(efficiency, speed), reverse=True):\\n            t += s\\n            heapq.heappush(heap, s)\\n            if len(heap) == k+1:\\n                t -= heapq.heappop(heap)\\n            ans = max(ans, t * e)\\n        return ans % M\", \"from heapq import heappush, heappop\\n\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        speed_heap = []\\n        speed_sum = 0\\n        max_performance = 0\\n\\n        for cur_efficiency, cur_speed in sorted(zip(efficiency, speed), reverse=True):\\n            heappush(speed_heap, cur_speed)\\n            speed_sum += cur_speed\\n\\n            if len(speed_heap) > k:\\n                speed_sum -= heappop(speed_heap)\\n\\n            max_performance = max(max_performance, speed_sum * cur_efficiency)\\n\\n        return max_performance % (10 ** 9 + 7)\", \"import heapq\\n\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        if k < 1:\\n            return 0\\n        \\n        best = 0\\n        heap = []\\n        cur_sum = 0\\n        \\n        data = sorted(list(zip(speed, efficiency)), key=lambda x: -x[1])\\n        \\n        for s, e in data:\\n            if len(heap) < k:  # always add this eng.\\n                cur_sum += s\\n                heapq.heappush(heap, s)\\n                if cur_sum * e > best:\\n                    best = cur_sum * e\\n            else:\\n                if (cur_sum - heap[0] + s) * e > best:\\n                    best = (cur_sum - heap[0] + s) * e\\n                if s > heap[0]:\\n                    cur_sum += (s - heap[0])\\n                    heapq.heappush(heap, s)\\n                    heapq.heappop(heap)\\n        \\n        return best % 1000000007\\n\", \"import heapq \\n\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        \\n        arr = zip(efficiency, speed)\\n        arr = sorted(arr, key=lambda x: (-x[0],-x[1])) \\n        pq = [] \\n        maxSoFar, currSum = 0, 0\\n        \\n        for eff,sp in arr: \\n            \\n            currSum += sp \\n            heapq.heappush(pq,sp)\\n            if len(pq) == k+1:\\n                currSum -= heapq.heappop(pq) \\n                \\n            maxSoFar = max(maxSoFar, currSum * eff) \\n\\n        \\n        return maxSoFar % ((10**9) + 7)\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        q = []\\n        sum_speed = 0\\n        res = 0\\n        for e,s in sorted(zip(efficiency, speed), reverse=True):\\n            sum_speed += s\\n            heapq.heappush(q, s)\\n            while len(q) > k:\\n                sum_speed -= heapq.heappop(q)\\n            res = max(res, e * sum_speed)\\n        return res % (10 ** 9 + 7)\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        MOD = 10**9 + 7\\n\\n        pq = []\\n        engineers = list(zip(speed, efficiency))\\n        engineers.sort(key=lambda tup:-tup[1])  # sort by efficiency in decreasing order\\n\\n        performance = 0\\n        tot_speed = 0\\n        for engineer in engineers:\\n            min_efficiency = engineer[1]\\n            if len(pq) == k:\\n                if pq[0] < engineer[0]:  # if there's an engineer with higher speed, there's a good chance to get higher performance\\n                    bad_speed = heapq.heappop(pq)  # fire the guy with the lowest speed\\n                    heapq.heappush(pq, engineer[0])\\n                    tot_speed = tot_speed - bad_speed + engineer[0]\\n            else:\\n                heapq.heappush(pq, engineer[0])\\n                tot_speed += engineer[0]\\n            performance = max(performance, tot_speed*min_efficiency)\\n        return performance % MOD\", \"from heapq import heappop, heappush\\n\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        hh = [[efficiency[ii],speed[ii]] for ii in range(n)]\\n        hh.sort(reverse=True)\\n        heap  =[]\\n        cursum = 0; \\n        cureff = hh[0][0]\\n        ans = 0;\\n        for ih,[e,s] in enumerate(hh):\\n            heappush(heap,(s,ih))\\n            (tops,topind) = heap[0]\\n            cursum = cursum +s\\n            if  len(heap)>k:\\n                heappop(heap)\\n                cursum = cursum-hh[topind][1]\\n            cureff = e\\n            ans = max(ans,cureff*cursum)\\n\\n        return ans%(10**9+7)\\n                \\n\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        MOD = 10 ** 9 + 7\\n        es = sorted(zip(efficiency, speed))\\n        result = 0\\n        heap = [0]\\n        s = 0\\n        for i in range(n - 1, -1, -1):\\n            if len(heap) < k:\\n                heapq.heappush(heap, es[i][1])\\n                s = (s + es[i][1]) \\n            elif es[i][1] > heap[0]:\\n                s = (s + es[i][1] - heapq.heappushpop(heap, es[i][1]))\\n            p = es[i][0] * s\\n            result = max(result, p)\\n        return result % MOD\\n\", \"class Solution:\\n    def maxPerformance(self, n, speed, efficiency, k):\\n        h = []\\n        res = sSum = 0\\n        for e, s in sorted(zip(efficiency, speed), reverse=1):\\n            heapq.heappush(h, s)\\n            sSum += s\\n            if len(h) > k:\\n                sSum -= heapq.heappop(h)\\n            res = max(res, sSum * e)\\n        return res % (10**9 + 7)\\n\\n\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        MOD = 10**9 + 7\\n        combo = []\\n        for i in range(n):\\n            heapq.heappush(combo, (-efficiency[i], -speed[i]))\\n        tmp = []\\n        ans, currsum = 0, 0\\n        \\n        while combo:\\n            curre, currs = heapq.heappop(combo)\\n            heapq.heappush(tmp, -currs)\\n            currsum -= currs\\n            if len(tmp) > k:\\n                currsum -= heapq.heappop(tmp)\\n            ans = max(ans, -currsum * curre)\\n        return ans % MOD\", \"import heapq\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        \\n        \\n        pairs = [(-efficiency[i], speed[i]) for i in range(n)]\\n        heapq.heapify(pairs)\\n        t = 0\\n        res = 0\\n        usedSpeeds = []\\n        cur = 0\\n        while pairs:\\n            e, s = heapq.heappop(pairs)\\n            cur += s\\n            t += 1\\n            if t <= k:\\n                res = max(res, -1 * e * cur)\\n            elif t > k:\\n                cur -= heapq.heappop(usedSpeeds)\\n                res = max(res, -1 * e * cur )\\n            heapq.heappush(usedSpeeds, s)\\n        return res % (10 ** 9 + 7)\\n            \\n                \\n                \\n                \\n                \\n                \\n                \\n                \\n                \\n                \\n            \\n\", \"class Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        vals = [(speed[i], efficiency[i]) for i in range(n)]\\n        vals.sort(reverse = True, key = lambda x: x[1])\\n        \\n        speed = 0\\n        ans = 0\\n        pq = []\\n        \\n        for i in range(n):\\n            heapq.heappush(pq, vals[i][0])\\n            speed += vals[i][0]\\n            if len(pq) > k:\\n                speed -= heapq.heappop(pq)\\n            ans = max(ans, speed*vals[i][1])\\n        return ans % (10**9 + 7)\"]", "input_output": "{\"fn_name\": \"maxPerformance\", \"inputs\": [[6, [2, 10, 3, 1, 5, 8], [5, 4, 3, 9, 7, 2], 2]], \"outputs\": [60]}", "difficulty": "interview", "url": "https://leetcode.com/problems/maximum-performance-of-a-team/", "starter_code": "\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        "}
{"id": 148, "question": "We have jobs: difficulty[i]\u00a0is the difficulty of the\u00a0ith job, and\u00a0profit[i]\u00a0is the profit of the\u00a0ith job.\u00a0\nNow we have some workers.\u00a0worker[i]\u00a0is the ability of the\u00a0ith worker, which means that this worker can only complete a job with difficulty at most\u00a0worker[i].\u00a0\nEvery worker can be assigned at most one job, but one job\u00a0can be completed multiple times.\nFor example, if 3 people attempt the same job that pays $1, then the total profit will be $3.\u00a0 If a worker cannot complete any job, his profit is $0.\nWhat is the most profit we can make?\nExample 1:\nInput: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]\nOutput: 100 \nExplanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately.\nNotes:\n\n1 <= difficulty.length = profit.length <= 10000\n1 <= worker.length <= 10000\ndifficulty[i], profit[i], worker[i]\u00a0 are in range\u00a0[1, 10^5]", "solutions": "[\"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        ws = sorted(worker, reverse=True)\\n        dp = sorted(zip(difficulty, profit), key=lambda x: x[1], reverse=True)\\n        # print(list(dp))\\n        \\n        i = 0\\n        total = 0\\n        for w in ws:\\n            while dp[i][0] > w:\\n                i = i + 1\\n                if i >= len(dp):\\n                    return total\\n            total = total + dp[i][1]\\n        return total\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        job = sorted(zip(difficulty, profit))\\n\\n        best = 0 \\n        i = 0 \\n        profit = 0\\n\\n        for work in sorted(worker):\\n            while (i < len(difficulty) and job[i][0] <= work):\\n                best = max(best, job[i][1])\\n                i += 1\\n            profit += best\\n\\n        return profit\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        rel = zip(difficulty, profit)\\n        rel = sorted(rel)\\n        output = 0\\n        worker.sort()\\n        mx = 0\\n        j = 0\\n        for i in worker:\\n            while j < len(rel) and i >= rel[j][0]:\\n                mx = max(mx, rel[j][1])\\n                j += 1\\n            print(i, mx)\\n            output += mx\\n        return output\", \"# 6:12 -> 6:25 | 7:23 -> \\n# Find mapping of workers to jobs such that profit is maximized\\n# Greedy approach: take highest profit job, assign it to most highly skilled worker\\nfrom queue import PriorityQueue\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        # print('difficulty', difficulty)\\n        # print('profit', profit)\\n        # print('worker', worker)\\n        pq = PriorityQueue()\\n        \\n        worker.sort()\\n        \\n        for i, job in enumerate(profit):\\n            pq.put( (-job, i) )\\n        \\n        profit = 0\\n        \\n        while worker:\\n            skill = worker.pop()\\n            cash, diff_index = pq.get() if not pq.empty() else (0, -1)\\n            while not pq.empty() and diff_index > -1 and skill < difficulty[diff_index]:\\n                cash, diff_index = pq.get()\\n            if skill < difficulty[diff_index]:\\n                cash, diff_index = 0, -1\\n            if cash != 0:\\n                pq.put( (cash, diff_index) )\\n            cash *= -1\\n            profit += cash\\n            # print(profit, cash, skill)\\n        \\n        return profit\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = [[0,0]] + sorted([[difficulty[i], profit[i]] for i in range(len(profit))]) \\n        for i in range(1, len(jobs)):\\n            jobs[i][1] = max(jobs[i-1][1], jobs[i][1])\\n        res, workerCounts = 0, collections.Counter(worker) \\n        def binarySearch(n):\\n            l, r = 0, len(jobs)-1\\n            while l < r-1:\\n                \\n                mid = (l+r)//2\\n                if jobs[mid][0] > n:\\n                    r =  mid - 1\\n                else:\\n                    l = mid\\n            return jobs[l][1] if jobs[r][0] > n else jobs[r][1]\\n                \\n        for work, count in list(workerCounts.items()):\\n            res += binarySearch(work)*count\\n        return res\\n\\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        temp = sorted( zip(difficulty, profit) )\\n        \\n        d = collections.defaultdict(int)\\n        \\n        for u, v in temp:\\n            d[u] = v\\n        \\n        maxdifficulty = max(worker)\\n        \\n        for i in range(1, maxdifficulty + 1):\\n            d[i] = max(d[i], d[i - 1])\\n            \\n        # print (d)\\n            \\n        ans = 0\\n        \\n        for i in worker:\\n            \\n            # print (i, d[i])\\n            \\n            ans += d[i]\\n            \\n        return ans\\n                \\n        \\n        \\n        \\n        \\n        \\n        \\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        d = sorted([(difficulty[i],profit[i]) for i in range(len(difficulty))])\\n        c = [0] * 100005\\n        \\n        # print(d)\\n        \\n        t = 0\\n        for i in range(1,100005):\\n            c[i] = c[i-1]\\n            while t < len(d) and i == d[t][0]:\\n                c[i] = max(c[i],d[t][1])\\n                t += 1\\n                \\n        \\n        # print(c[0:101])\\n        # print([c[i] for i in worker])\\n        \\n        return sum([c[i] for i in worker])\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        max_v = max(max(difficulty), max(worker))\\n        \\n        n = len(difficulty)\\n        best = [0] * (max_v + 1)\\n        for i in range(n):\\n            d = difficulty[i]\\n            p = profit[i]\\n            best[d] = max(best[d], p)\\n        \\n        for i in range (1, max_v + 1):\\n            best[i] = max(best[i - 1], best[i])\\n        \\n        s = 0 \\n        for d in worker:\\n            s += best[d]\\n        return s\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        arr=[0 for _ in range(10**5+1)]\\n        for i in range(len(profit)):\\n            arr[difficulty[i]]=max(profit[i],arr[difficulty[i]])\\n        for i in range(1,10**5+1):\\n            arr[i]=max(arr[i-1],arr[i])\\n        ans=0\\n        # print(arr[:101])\\n        for i in worker:\\n            ans+=arr[i]\\n        return ans\\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        output=0\\n        job=sorted(zip(difficulty,profit),reverse=True,key=lambda x:x[1])\\n        worker=sorted(worker,reverse=True)\\n        jobIndex=0\\n        for workerCab in worker:\\n            # print(workerCab)\\n            \\n            while jobIndex<len(job):\\n                # print(jobIndex)\\n                if job[jobIndex][0]<=workerCab:\\n                    # print('find')\\n                    break\\n                else:\\n                    jobIndex+=1\\n            \\n            if jobIndex<len(job):\\n                output=output+job[jobIndex][1]\\n            # print(output,job[jobIndex][1])\\n        # print(job)\\n        return output\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        for i in range(len(difficulty)):\\n            difficulty[i] = (difficulty[i], profit[i])\\n        difficulty.sort(key = lambda x:x[0]) # O(NlogN)\\n        i, L = 0, len(difficulty)\\n        ans, most = 0, 0\\n        for wker in sorted(worker):\\n            while i < L and difficulty[i][0] <= wker:\\n                most = max(most, difficulty[i][1])\\n                i += 1\\n            ans += most\\n        return ans\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = []\\n        total = 0\\n        \\n        for i in range(len(profit)):\\n            jobs.append([difficulty[i], profit[i]])\\n        print(jobs)\\n        \\n        worker.sort()\\n        jobs.sort()\\n        i = 0\\n        best = 0\\n        \\n        for work in worker:\\n            while i < len(jobs) and work >= jobs[i][0]:\\n                best = max(best, jobs[i][1])\\n                i += 1\\n            total += best\\n        \\n        return total\\n            \\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = sorted(zip(difficulty, profit))\\n        worker.sort()\\n\\n        m = len(worker)\\n        n = len(jobs)\\n\\n        j = 0\\n        max_profit = 0\\n        result = 0\\n        for i in range(m):\\n            ability = worker[i]\\n\\n            while j < n and jobs[j][0] <= ability:\\n                max_profit = max(max_profit, jobs[j][1])\\n                j += 1\\n\\n            result += max_profit\\n\\n        return result\\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        best = 0\\n        tot = 0\\n        worker.sort()\\n        for d, p in sorted(zip(difficulty, profit)):\\n            while worker and d > worker[0]:\\n                tot += best\\n                worker.pop(0)\\n            best = max(best, p)\\n        tot += best * len(worker)\\n        return tot\\n        \\n            \\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        l = sorted(zip(profit,difficulty), reverse = True)\\n        \\n        worker.sort(reverse = True)\\n        \\n        p = 0\\n        \\n        for w in worker:\\n            while l and w < l[0][1]:\\n                l.pop(0)\\n            if not l:\\n                break\\n            p+=l[0][0]\\n        return p\", \"import bisect\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        m,n={},len(difficulty)\\n        for ind, val in enumerate(difficulty):\\n            m[val]=max(m.get(val,0),profit[ind])\\n        difficulty.sort()\\n        for ind, val in enumerate(difficulty):\\n            if ind>0:\\n                m[val]=max(m[val],m[difficulty[ind-1]])\\n        \\n        ans = 0\\n        for ind, val in enumerate(worker):\\n            d_ind = bisect.bisect_left(difficulty, val)\\n            if d_ind<n:\\n                if difficulty[d_ind]<=val:\\n                    ans+=m[difficulty[d_ind]]\\n                else:\\n                    ans+=m[difficulty[d_ind-1]] if d_ind>0 else 0\\n            else:\\n                ans+=m[difficulty[d_ind-1]]\\n        return ans\\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        difficulty, profit = zip(*sorted(zip(difficulty, profit)))\\n        \\n        \\n        profit_table = {} # maps difficulty to profit\\n        \\n        for i, (d, p) in enumerate(zip(difficulty, profit)):\\n            if i > 0:\\n                profit_table[d] = max(p, profit_table[difficulty[i-1]])\\n            else:\\n                profit_table[d] = p\\n        \\n        value = 0\\n        \\n        d_index = len(difficulty) - 1\\n        for w in reversed(sorted(worker)):\\n            while d_index >= 0 and difficulty[d_index] > w:\\n                d_index -= 1\\n            if d_index >= 0: value += profit_table[difficulty[d_index]]\\n        return value\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = sorted(zip(difficulty, profit))\\n        profit = i = maxprofits = 0\\n        for ability in sorted(worker):\\n            while i < len(jobs) and ability >= jobs[i][0]:\\n                profit = max(jobs[i][1], profit)\\n                i += 1\\n            maxprofits += profit\\n        return maxprofits\", \"import bisect\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        if not difficulty:\\n            return 0\\n        indices = sorted(list(range(len(difficulty))), key=lambda i: difficulty[i])        \\n        difficulty = [difficulty[i] for i in indices]\\n        profit = [profit[i] for i in indices]\\n        max_profit = [profit[0]]\\n        for p in profit[1:]:\\n            max_profit.append(max(max_profit[-1], p))\\n        total = 0            \\n        for ability in worker:\\n            idx = bisect.bisect_right(difficulty, ability)\\n            if idx > 0:\\n                total += max_profit[idx-1]\\n        return total                \\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        if difficulty is None: return 0\\n        thislist = []\\n        for i in range(0, len(difficulty)): thislist.append((difficulty[i], profit[i]))\\n        thislist.sort()\\n        worker.sort()\\n        res = 0\\n        curr_max = 0\\n        worker_index = 0\\n        list_index = 0\\n        while worker_index < len(worker) and list_index < len(thislist):\\n            if thislist[list_index][0] <= worker[worker_index]:\\n                curr_max = max(curr_max, thislist[list_index][1])\\n                list_index += 1\\n            else:\\n                res += curr_max\\n                worker_index += 1\\n        \\n        if worker_index < len(worker): res += curr_max*(len(worker)-worker_index)\\n        return res\", \"import bisect\\n\\nclass Solution:\\n    def solve(self, diff, profit, worker):\\n        mp = {}\\n        for i in range(len(diff)):\\n            d = diff[i]\\n            p = profit[i]\\n            if d not in mp:\\n                mp[d] = 0\\n            mp[d] = max(mp[d], p)\\n        diff2 = sorted(mp.keys())\\n        ln = len(diff2)\\n        mx = [0]*ln\\n        for i in range(ln):\\n            d = diff2[i]\\n            p = mp[d]\\n            if i == 0:\\n                mx[i] = p\\n            else:\\n                mx[i] = max(mx[i-1], p)\\n        total = 0\\n        # print(diff2)\\n        # print(profit2)\\n        # print(mx)\\n        # print('---')\\n        for w in worker:\\n            if w < diff2[0]:\\n                continue\\n            i = bisect.bisect_left(diff2, w)\\n            if i >= len(diff2):\\n                i = len(diff2)-1                \\n            elif diff2[i] > w:\\n                i -= 1\\n                if i < 0:\\n                    continue\\n            max_profit = mx[i]\\n            # print(w, i, mx[i])\\n            total += max_profit\\n        return total\\n    \\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        return self.solve(difficulty, profit, worker)\\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        combined = sorted(zip(difficulty,profit))\\n        worker.sort()\\n        n = len(worker)\\n        start = 0\\n        net_profit = 0\\n        current_profit = 0\\n        for i in range(n):\\n            while start< len(difficulty) and combined[start][0]<=worker[i]:\\n                current_profit = max(combined[start][1],current_profit)\\n                start += 1\\n            net_profit += current_profit\\n        return net_profit\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        value = list(zip(difficulty, profit))\\n        value.sort()\\n        print(value)\\n        res = 0\\n        i = 0\\n        best = 0\\n        for person in sorted(worker):\\n            while i < len(value) and person >= value[i][0]:\\n                best = max(best, value[i][1])\\n                i += 1\\n            res += best\\n        \\n        return res\", \"class Solution:\\n    def maxProfitAssignment(\\n        self, difficulty: List[int], profit: List[int], worker: List[int]\\n    ) -> int:\\n\\n        pairs = [(a, b) for a, b in zip(difficulty, profit)]\\n        sorted_pairs = sorted(pairs, key=lambda p: p[0])\\n        benifit = []\\n        current_max = 0\\n        for diff, pro in sorted_pairs:\\n            current_max = max(pro, current_max)\\n            benifit.append((diff, current_max))\\n\\n        sorted_workers = sorted(worker)\\n        ans = 0\\n        current_difficulty_index = worker_index = 0\\n        while worker_index < len(worker):\\n            if sorted_workers[worker_index] < benifit[current_difficulty_index][0]:\\n                worker_index += 1\\n                continue\\n            while (\\n                current_difficulty_index + 1 < len(worker)\\n                and benifit[current_difficulty_index + 1][0]\\n                <= sorted_workers[worker_index]\\n            ):\\n                current_difficulty_index += 1\\n\\n            # print(\\n            #     f\\\\\\\"{worker_index=} {current_difficulty_index=} {benifit[worker_index][1]=}\\\\\\\"\\n            # )\\n            ans += benifit[current_difficulty_index][1]\\n            worker_index += 1\\n\\n        return ans\\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        worker.sort()\\n        arr=[]\\n        for i in range(len(profit)):\\n            arr.append([difficulty[i],profit[i]])\\n            \\n        arr.sort(key=lambda x:x[0])\\n        for i in range(len(arr)):\\n            difficulty[i] = arr[i][0]\\n            profit[i] = arr[i][1]\\n        # print(difficulty)\\n        # print(profit)\\n        # print(worker)\\n        prev = [profit[0]]\\n        for i in range(1,len(profit)):\\n            prev.append(max(profit[i],prev[-1]))\\n        i = 0\\n        p=0\\n        j = 0\\n        while(j<len(worker)):\\n            if(i==len(difficulty)):\\n                p+=prev[i-1]\\n                j+=1\\n                continue\\n                \\n            if(difficulty[i]<=worker[j]):\\n                i+=1\\n            # elif(difficulty[i]==worker[j]):\\n            #     # p+=prev[i]\\n            #     i+=1\\n            #     # j+=1\\n            else:\\n                x=i-1\\n                while(x>=0 and difficulty[x]>worker[j]):\\n                    x-=1\\n                if(x>=0):\\n                    p+=prev[x]\\n                j+=1\\n                \\n        return p\\n\", \"from bisect import bisect\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        maxp = 0\\n        maxpa = []\\n        for difficulty,profit in sorted(zip(difficulty,profit),key=lambda x:x[0]):\\n            maxp = max(maxp,profit)\\n            maxpa.append((difficulty,maxp))\\n            \\n        \\n        total = 0\\n        for w in worker:\\n            ind = bisect(maxpa,(w,float('inf')))\\n            if ind>0:\\n                total += maxpa[ind-1][1]\\n            \\n        return total\\n\\n            \\n        \\n        \\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        job = {}\\n        for cost, gain in zip(difficulty, profit):           \\n            if cost in job:\\n                job[cost] = max(job[cost], gain)\\n            else:\\n                job[cost] = gain\\n        \\n        job = [(k, v) for k, v in list(job.items())] + [(0, 0)]\\n        job.sort()\\n        useless = set()\\n        \\n        global_max = -float('inf')\\n        for i, (c, g) in enumerate(job):\\n            if g < global_max:\\n                useless.add(i)\\n            else:\\n                global_max = g\\n        \\n        job = [job[i] for i in range(len(job)) if i not in useless]\\n        print(job)\\n        worker.sort()\\n        \\n        i, j = 0, 0\\n        ans = 0\\n        while j < len(worker):\\n            \\n            while job[i][0] < worker[j] and i < len(job) - 1:\\n                i += 1\\n            \\n            ans += job[i][1] if job[i][0] <= worker[j] else job[i- 1][1]\\n            \\n            j += 1\\n        \\n        return ans\\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        \\n        data = sorted([(d,p) for d,p in zip(difficulty, profit)])\\n        worker.sort()\\n        i, n, money = 0, len(data), 0\\n        res = 0\\n        for w in worker:\\n            while i < n and w >= data[i][0]:\\n                money = max(money, data[i][1])\\n                i += 1\\n            res += money\\n        return res\\n        \\n        \\n        \\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        mDifficulty = {}\\n        \\n        for i in range(len(difficulty)):\\n            d = difficulty[i]\\n            if difficulty[i] not in mDifficulty:\\n                mDifficulty[d] = 0\\n            mDifficulty[d] = max(mDifficulty[d], profit[i])\\n        \\n        jobs = []\\n        for key, value in mDifficulty.items():\\n            jobs.append([key, value]) \\n            \\n        jobs.sort(key=lambda job:job[0])\\n        \\n        for i in range(1, len(jobs)):\\n            jobs[i][1] = max(jobs[i][1], jobs[i - 1][1])\\n            \\n        worker.sort()\\n        start = len(jobs) - 1\\n        count = 0\\n        \\n        for i in range(len(worker) - 1, - 1, -1):\\n            while worker[i] < jobs[start][0] and start >= 0:\\n                start -= 1\\n            if start < 0:\\n                break\\n            count += jobs[start][1]\\n            \\n        return count\", \"class Solution(object):\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        jobs = zip(difficulty, profit)\\n        jobs = sorted(jobs)\\n        ans = i = best = 0\\n        for skill in sorted(worker):\\n            while i < len(jobs) and skill >= jobs[i][0]:\\n                best = max(best, jobs[i][1])\\n                i += 1\\n            ans += best\\n        return ans\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        jobs = sorted(zip(difficulty, profit))\\n        ans = i = best = 0\\n        for skill in sorted(worker):\\n            while i < len(jobs) and skill >= jobs[i][0]:\\n                best = max(best, jobs[i][1])\\n                i += 1\\n            ans += best\\n        return ans\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        arr = []\\n        for i in range(len(difficulty)):\\n            arr.append((difficulty[i], profit[i]))\\n        arr = sorted(arr, key=lambda x: x[0])\\n\\n        maxProfit, maxProfits = 0, []\\n        for _, gain in arr:\\n            maxProfit = max(maxProfit, gain)\\n            maxProfits.append(maxProfit)\\n\\n        total = 0\\n        for person in worker:\\n            idx = self.uppperBsearch(arr, person) - 1\\n            if idx > -1:\\n                total += maxProfits[idx]\\n\\n        return total\\n\\n    def uppperBsearch(self, arr, target):\\n        left = 0\\n        right = len(arr)\\n        while left < right:\\n            mid = (left + right)//2\\n            if target >= arr[mid][0]:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return right\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        ls = sorted(range(len(difficulty)), key= lambda x : difficulty[x])\\n        workers = sorted(worker)\\n        \\n        idx = 0\\n        resp = 0\\n        best = 0\\n        for worker in workers:\\n            while idx < len(ls) and worker >= difficulty[ls[idx]]:\\n                best = max(best, profit[ls[idx]])\\n                idx += 1\\n            resp += best\\n        return resp\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = sorted(zip(difficulty, profit),key=lambda t:t[0])\\n        ans = i = best = 0\\n        for w in sorted(worker):\\n            while i < len(jobs) and w >= jobs[i][0]:\\n                best = max(best, jobs[i][1])\\n                i += 1\\n            ans += best\\n        return ans\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        tup=[]\\n        dic = {}\\n        for i in range(0,len(profit)):\\n            tup.append((profit[i],difficulty[i]))\\n      \\n        worker.sort(reverse=True)        \\n        tup.sort(reverse=True)\\n        indx=0\\n        t_indx=0\\n        \\n        res=0\\n        \\n        while(indx<len(worker)):\\n            \\n            while(t_indx < len(profit) and worker[indx]<tup[t_indx][1]):\\n                t_indx+=1             \\n                \\n            if(t_indx < len(profit)):\\n                res+=tup[t_indx][0]\\n            indx+=1\\n        \\n        return res\\n            \\n            \\n            \\n            \\n        \\n        \\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        worker = sorted(worker)\\n        jobs = sorted([(-1,0)]+[(difficulty[i],profit[i])for i in range(len(difficulty))])\\n        job_nums = len(jobs)\\n        maxProfit = 0\\n        job_index = 0\\n        res = 0\\n        for ability in worker:\\n            while job_index < job_nums-1 and ability>= jobs[job_index+1][0]:\\n                job_index+=1\\n                maxProfit = max(maxProfit,jobs[job_index][1])\\n            res+=maxProfit\\n        return res\\n            \\n        \\n        \\n\", \"class Solution(object):\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        arr = []\\n        for d, p in sorted(zip(difficulty, profit)):\\n            if arr and arr[-1][1]>=p:\\n                continue\\n            arr.append([d, p])    \\n        \\n        N = len(arr)\\n        res, i, best = 0, 0, 0\\n        for w in sorted(worker):\\n            while i<N and w>=arr[i][0]:\\n                best = arr[i][1]\\n                i += 1\\n            \\n            res += best\\n        return res\\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        tup_list = sorted(list(zip(difficulty, profit)))\\n        filtered_list = []\\n        best = 0\\n        for d, p in tup_list:\\n            if p > best:\\n                best = p\\n                filtered_list.append((d, p))\\n\\n        worker = sorted(worker)\\n\\n        profit = 0\\n\\n        dix = 0\\n        for w in worker:\\n            if w < filtered_list[dix][0]:\\n                continue\\n\\n            while dix+1 < len(filtered_list) and filtered_list[dix+1][0] <= w:\\n                dix += 1\\n\\n            profit += filtered_list[dix][1]\\n\\n        return profit\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        val_dict = dict()\\n        for i in range(len(difficulty)):\\n            val_dict[difficulty[i]] = max(val_dict.get(difficulty[i], 0), profit[i])\\n        key_list = list(val_dict.keys())\\n        key_list = sorted(key_list)\\n\\n        max_val = 0\\n        max_list = [0] * len(key_list)\\n        for i in range(len(key_list)):\\n            max_val = max(max_val, val_dict[key_list[i]])\\n            max_list[i] = max_val\\n        \\n        total = 0\\n        #print(key_list, max_list)\\n        for w in worker:\\n            #print(w, self.bisect(w, key_list, max_list))\\n            total += self.bisect(w, key_list, max_list)\\n        return total\\n    \\n    def bisect(self, w, key_list, max_list):\\n\\n        left, right = 0, len(key_list)-1\\n        if w < key_list[0]:\\n            return 0\\n        if w >= key_list[right]:\\n            return max_list[right]\\n\\n        while left != right - 1:\\n            mid = (left + right) // 2\\n            if w > key_list[mid]:\\n                left = mid\\n            elif w < key_list[mid]:\\n                right = mid\\n            else:\\n                return max_list[mid]\\n        return max_list[left]\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        # 8:49 9/26/20\\n        \\n        def find_difficulty(d, w):\\n            n = len(d)\\n            lt, rt = 0, n\\n            while lt < rt:\\n                mid = lt + (rt - lt) // 2\\n                if d[mid] == w:\\n                    return mid\\n                elif d[mid] > w:\\n                    rt = mid\\n                else:\\n                    lt = mid + 1\\n            return rt-1\\n\\n        difficulty1 = sorted(difficulty)\\n        \\n        difficulty = list(zip(difficulty, profit))\\n        difficulty.sort(key = lambda x: (x[0]))\\n        \\n        profit = {}\\n        max_profit = 0\\n        for i in range(len(difficulty)):\\n            if difficulty[i][0] not in profit or profit[difficulty[i][0]] < difficulty[i][1]:\\n                profit[difficulty[i][0]] = difficulty[i][1]\\n            max_profit = max(max_profit, profit[difficulty[i][0]])\\n            profit[difficulty[i][0]] = max_profit\\n                \\n        \\n        total = 0\\n        pre = -1\\n        for i in range(len(worker)):\\n            # if i > 0 and worker[i] == worker[i-1] and pre != -1:\\n            #     total += profit[pre]\\n            #     continue\\n            pre = find_difficulty(difficulty1, worker[i])\\n            if pre != -1:\\n                total += profit[difficulty1[pre]]\\n                \\n        return total\\n            \\n        \\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = list(zip(difficulty, profit))\\n        jobs.sort(key=lambda x:x[1], reverse=True)\\n        jobs.sort(key=lambda x:x[0])\\n        bestjobs=[]\\n        res = 0\\n        for a,b in jobs:\\n            if not bestjobs:\\n                bestjobs.append((a,b))\\n            elif bestjobs[-1][1]<b:\\n                bestjobs.append((a,b))\\n        print(bestjobs)\\n        for wo in worker:\\n            lo, hi = 0, len(bestjobs)-1\\n            while lo<hi:\\n                mid = (lo+hi+1)//2\\n                if bestjobs[mid][0]>wo:\\n                    hi = mid-1\\n                else:\\n                    lo = mid\\n            if bestjobs[lo][0]<=wo:\\n                res+=bestjobs[lo][1]\\n        return res\\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        m = len(difficulty)\\n        \\n        difficulty, profit = zip(*sorted(zip(difficulty, profit)))\\n        \\n        difficulty = list(difficulty)\\n        profit = list(profit)\\n        \\n        best_profit = m * [0]\\n        best_profit[0] = profit[0]\\n        ind = 0\\n        prev_v = difficulty[0]\\n        \\n        for i in range(1, m):\\n            if prev_v != difficulty[i]:\\n                ind += 1\\n                difficulty[ind] = prev_v = difficulty[i]\\n                best_profit[ind] = best_profit[ind - 1]\\n            \\n            best_profit[ind] = max(best_profit[ind], profit[i])\\n            \\n        # print(best_profit)\\n        # print(difficulty)\\n            \\n        m = ind + 1\\n            \\n        def bins(target):\\n            start = 0\\n            end = m - 1\\n            bsres = 0\\n            \\n            while start <= end:\\n                middle = start + (end - start) // 2\\n                \\n                if difficulty[middle] == target:\\n                    return best_profit[middle]\\n                \\n                if difficulty[middle] < target:\\n                    bsres = best_profit[middle]\\n                    start = middle + 1\\n                    \\n                else:\\n                    end = middle - 1\\n                    \\n            return bsres\\n        \\n        res = 0\\n        h = dict()\\n        \\n        for w in worker:\\n            if w not in h:\\n                h[w] = bins(w)\\n            \\n            res += h[w]\\n        \\n        return res\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        m = len(difficulty)\\n        \\n        difficulty, profit = zip(*sorted(zip(difficulty, profit)))\\n        \\n        difficulty = list(difficulty)\\n        profit = list(profit)\\n        \\n        best_profit = m * [0]\\n        best_profit[0] = profit[0]\\n        ind = 0\\n        prev_v = difficulty[0]\\n        \\n        for i in range(1, m):\\n            if prev_v != difficulty[i]:\\n                ind += 1\\n                difficulty[ind] = prev_v = difficulty[i]\\n                best_profit[ind] = best_profit[ind - 1]\\n            \\n            best_profit[ind] = max(best_profit[ind], profit[i])\\n            \\n        # print(best_profit)\\n        # print(difficulty)\\n            \\n        m = ind + 1\\n            \\n        def bins(target):\\n            start = 0\\n            end = m - 1\\n            bsres = 0\\n            \\n            while start <= end:\\n                middle = start + (end - start) // 2\\n                \\n                if difficulty[middle] == target:\\n                    return best_profit[middle]\\n                \\n                if difficulty[middle] < target:\\n                    bsres = best_profit[middle]\\n                    start = middle + 1\\n                    \\n                else:\\n                    end = middle - 1\\n                    \\n            return bsres\\n        \\n        res = 0\\n        h = dict()\\n        \\n        for w in worker:\\n            # if w not in h:\\n                # h[w] = bins(w)\\n            \\n            res += bins(w)\\n        \\n        return res\", \"# 20201007 1:23 am ref\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = sorted(zip(difficulty, profit))\\n        profit = i = maxprofits = 0\\n        for ability in sorted(worker):\\n            while i < len(jobs) and ability >= jobs[i][0]:\\n                profit = max(jobs[i][1], profit)\\n                i += 1\\n            maxprofits += profit\\n        return maxprofits\", \"from heapq import *\\n\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        worker.sort()\\n        difficulty_min_heap = []\\n        profit_max_heap = []\\n        \\n        total = 0\\n        \\n        for i in range(len(profit)):\\n            heappush(difficulty_min_heap, (difficulty[i], i))\\n            \\n            \\n        for w in worker:\\n            while difficulty_min_heap and difficulty_min_heap[0][0] <= w:\\n                current_difficulty, job_id = heappop(difficulty_min_heap)\\n                heappush(profit_max_heap, (-profit[job_id], job_id))\\n            if profit_max_heap:\\n                total += -profit_max_heap[0][0]\\n            \\n        return total\\n                \\n                \\n            \\n        \\n        \\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        def binary_search(arr, target):\\n            l, r = 0, len(arr) - 1\\n            res = -1\\n            while l <= r:\\n                mid = (l + r) // 2\\n                if arr[mid][0] <= target:\\n                    res = mid\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            return res        \\n        jobs = sorted([d, p] for d,p in zip(difficulty, profit))    \\n        for i in range(1,len(jobs)):\\n            jobs[i][1] = max(jobs[i][1], jobs[i - 1][1])    \\n        res = 0\\n        for w in worker:\\n            i = binary_search(jobs, w)\\n            if i == -1:\\n                continue\\n            res += jobs[i][1]    \\n        return res    \", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        for i in range(len(profit)):\\n            difficulty[i] = [difficulty[i], profit[i]]\\n        difficulty.sort()\\n        for i in range(1, len(profit)):\\n            difficulty[i][1] = max(difficulty[i-1][1], difficulty[i][1])\\n        \\n        def search(d):\\n            if d < difficulty[0][0]:\\n                return -1\\n            l = 0\\n            r = len(profit)-1\\n            \\n            while l < r:\\n                m = (l+r+1)//2\\n                if difficulty[m][0] <= d:\\n                    l = m\\n                else:\\n                    r = m-1\\n            return l\\n        \\n        res = 0\\n        for w in worker:\\n            i = search(w)\\n            if i >= 0:\\n                res += difficulty[i][1]\\n        return res\\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = [[difficulty[i],profit[i]] for i in range(len(difficulty))]\\n        jobs.sort()\\n        \\n        worker.sort()\\n        \\n        ans, best ,i = 0, 0,0\\n        \\n        \\n        for skill in worker:\\n            while i < (len(jobs)) and skill >= jobs[i][0]:\\n                best = max(best,jobs[i][1])\\n                i += 1\\n            ans += best\\n        return ans\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        n = len(worker)\\n        jobs =  sorted(zip(difficulty, profit))\\n        total = 0\\n        best = 0\\n        i = 0\\n        for ability in sorted(worker):\\n            while i < len(jobs) and ability >= jobs[i][0]:\\n                best = max(jobs[i][1], best)\\n                i += 1\\n            total += best\\n        return total\\n\", \"class Solution:\\n    def maxProfitAssignment(self, d: List[int], p: List[int], work: List[int]) -> int:\\n        N, maxd = len(p), max(d)\\n        cmb = [(d[i], p[i]) for i in range(N)]\\n        cmb.sort()\\n        \\n        dd = [0]*(maxd+1)\\n        val = j = 0\\n        for i in range(maxd+1):\\n            while j<N and i >= cmb[j][0]:\\n                val = max(val, cmb[j][1])\\n                j += 1\\n            dd[i] = val \\n         \\n        # print(dd)\\n        ans = 0\\n        for w in work:\\n            if w>maxd:\\n                ans += dd[maxd]\\n            else:\\n                ans += dd[w]\\n        \\n        return ans\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        _max=max(worker)+1\\n        make=[0]*_max\\n        num=[(difficulty[i],profit[i])for i in range(len(profit)) if difficulty[i]<_max]\\n        num.sort(key=lambda x:x[0])\\n        p_max=0\\n        for i in range(len(num)):\\n            if num[i][1]>=p_max:\\n                make[num[i][0]]=num[i][1]\\n                p_max=num[i][1]\\n        pre=-1\\n        for i in range(len(make)):\\n            if make[i]!=0:\\n                pre=make[i]\\n            elif pre!=-1:\\n                make[i]=pre\\n        ans=0\\n        for w in worker:\\n            ans+=make[w]\\n        return ans \", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        dp = {}\\n        for i, d in enumerate(difficulty):\\n            dp[d] = max(profit[i], dp.get(d, 0))\\n        dp = sorted([ (d,p) for d, p in dp.items() ])\\n\\n        d2p = []\\n        pre = 0\\n        for d, p in dp:\\n            pre = max(pre, p)\\n            d2p.append((d, pre))\\n\\n        def getjob(work, pv, pw, pi):\\n            l, r = 0, len(d2p) - 1\\n            if d2p[l][0] > work: return 0, 0 \\n            if d2p[r][0] <= work: return d2p[r][1], r\\n            l = pi\\n\\n            while l <= r:\\n                i = (l + r) // 2\\n                if d2p[i][0] == work:\\n                    return max(d2p[i][1], pv), i\\n                if d2p[i][0] > work:\\n                    r = i - 1\\n                else:\\n                    l = i + 1\\n            if i == r:\\n                return max(d2p[i][1], pv), i\\n            return max(d2p[i-1][1], pv), i - 1\\n\\n        rs = 0\\n        pv = 0\\n        pw = 0\\n        pi = 0\\n        for w in sorted(worker):\\n            pv, pi = getjob(w, pv, pw, pi)\\n            pw = w\\n            rs += pv\\n        return rs\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        dp = {}\\n        for i, d in enumerate(difficulty):\\n            dp[d] = max(profit[i], dp.get(d, 0))\\n        dp = sorted([ (d,p) for d, p in dp.items() ])\\n\\n        d2p = []\\n        pre = 0\\n        for d, p in dp:\\n            pre = max(pre, p)\\n            d2p.append((d, pre))\\n\\n        def getjob(work):\\n            l, r = 0, len(d2p) - 1\\n            if d2p[l][0] > work: return 0\\n            if d2p[r][0] <= work: return d2p[r][1]\\n\\n            while l <= r:\\n                i = (l + r) // 2\\n                if d2p[i][0] == work:\\n                    return d2p[i][1]\\n                if d2p[i][0] > work:\\n                    r = i - 1\\n                else:\\n                    l = i + 1\\n            if i == r:\\n                return d2p[i][1]\\n            return d2p[i-1][1]\\n\\n        rs = 0\\n        for w in worker:\\n            rs += getjob(w)\\n        return rs\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        _max=max(worker)+1\\n        make=[0]*_max\\n        num=[(difficulty[i],profit[i])for i in range(len(profit)) if difficulty[i]<_max]\\n        num.sort(key=lambda x:x[0])\\n##        x=0\\n##        while x<len(num):\\n##            if x+1<len(num):\\n##                if num[x][1]>num[x+1][1]:\\n##                    num.pop(x+1)\\n##                else:x+=1\\n##            else:break\\n        p_max=0\\n        for i in range(len(num)):\\n            p_max=max(p_max,num[i][1])\\n            if num[i][1]>=p_max:make[num[i][0]]=num[i][1]\\n        pre=-1\\n##        print(make)\\n        for i in range(len(make)):\\n            if make[i]!=0:\\n                pre=make[i]\\n            elif pre!=-1:\\n                make[i]=pre\\n        ans=0\\n        for w in worker:\\n            ans+=make[w]\\n        return ans \", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = sorted([(difficulty[i], profit[i]) for i in range(len(difficulty))], key=lambda x: x[0])\\n        worker = sorted(worker)\\n        jobPointer = 0\\n        workerPointer = 0\\n        maxProfit = 0\\n        totalProfit = 0\\n        while True:\\n            if workerPointer >= len(worker):\\n                break\\n            talent = worker[workerPointer]\\n            if jobPointer >= len(jobs) or jobs[jobPointer][0] > talent:\\n                totalProfit += maxProfit\\n                workerPointer += 1\\n            else:\\n                if jobs[jobPointer][1] > maxProfit:\\n                    maxProfit = jobs[jobPointer][1]\\n                jobPointer += 1\\n        return totalProfit\\n        \\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        _max=max(worker)+1\\n        make=[0]*_max\\n        num=[(difficulty[i],profit[i])for i in range(len(profit)) if difficulty[i]<_max]\\n        num.sort(key=lambda x:x[0])\\n        x=0\\n        while x<len(num):\\n            if x+1<len(num):\\n                if num[x][1]>num[x+1][1]:\\n                    num.pop(x+1)\\n                else:x+=1\\n            else:break\\n        for i in range(len(num)):\\n            make[num[i][0]]=num[i][1]\\n        pre=-1\\n        for i in range(len(make)):\\n            if make[i]!=0:\\n                pre=make[i]\\n            elif pre!=-1:\\n                make[i]=pre\\n        ans=0\\n        for w in worker:\\n            ans+=make[w]\\n        return ans       \\n\", \"class Solution:\\n    def maxProfitAssignment(self, d: List[int], p: List[int], work: List[int]) -> int:\\n        maxd = max(d)\\n        cmb1 = defaultdict(int)\\n        for i in range(len(p)):\\n            cmb1[d[i]] = max(cmb1[d[i]], p[i])\\n        \\n        cmb = sorted(cmb1.items(), key=lambda x: x[0])\\n\\n        NN = len(cmb)\\n        dd = [0]*(maxd+1)\\n        val = j = 0\\n        for i in range(maxd+1):\\n            if j<NN and i == cmb[j][0]:\\n                val = max(val, cmb[j][1])\\n                j += 1\\n            dd[i] = val \\n         \\n        \\n        ans = 0\\n        for w in work:\\n            if w>maxd:\\n                ans += dd[maxd]\\n            else:\\n                ans += dd[w]\\n        \\n        return ans\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = sorted(zip(difficulty, profit), key = lambda x: x[0])\\n        ans = i = best = 0\\n        for skill in sorted(worker):\\n            while i < len(jobs) and skill >= jobs[i][0]:\\n                best = max(best, jobs[i][1])\\n                i += 1\\n            ans += best\\n        return ans\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        \\n        def findProfit(ppl, goodJobs):\\n            l=0\\n            r=len(goodJobs)-1\\n            while l<r-1:\\n                test=int((l+r)/2)\\n                if goodJobs[test][1]>ppl:\\n                    l=test\\n                else:\\n                    r=test\\n            if goodJobs[r][1]>ppl:\\n                return 0\\n            elif goodJobs[l][1]>ppl:\\n                return goodJobs[r][0]\\n            return goodJobs[l][0]\\n                \\n        \\n        goodJobs=[]\\n        jobs=[(profit[i], difficulty[i]) for i in range(len(difficulty))]\\n        jobs=sorted(jobs, key=lambda job:job[0], reverse=True)\\n        goodJobs.append(jobs[0])\\n        for i in range(1,len(jobs)):\\n            if jobs[i][1]<goodJobs[-1][1]:\\n                goodJobs.append(jobs[i])\\n        ans=0\\n        print((goodJobs, worker))\\n        for ppl in worker:\\n            ans=ans+findProfit(ppl, goodJobs)\\n            print(ans)\\n        return ans\\n         \\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = list(zip(difficulty, profit))\\n        jobs = sorted(jobs, key=lambda x: x[0])\\n        worker.sort()\\n        idx = 0\\n        ans = 0\\n        p = 0\\n        for skill in worker:\\n            while idx < len(jobs) and jobs[idx][0] <= skill:\\n                p = max(p, jobs[idx][1])\\n                idx += 1\\n            ans += p\\n        return ans\\n        \\n    \\n    \\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        worker.sort()\\n        difprof = [(difficulty[i], profit[i]) for i in range(len(difficulty))]\\n        difprof.sort()\\n        total = 0\\n        \\n        index = 0\\n        maxProfit = 0\\n        for w in worker:\\n            while index < len(difprof) and w >= difprof[index][0]:\\n                maxProfit = max(maxProfit, difprof[index][1])\\n                index += 1\\n            \\n            total += maxProfit\\n        return total\\n            \\n#         n = len(worker)\\n#         dp = [0 for i in range(worker[n - 1]+1)]\\n        \\n#         index = 0\\n#         for i in range(1, len(dp)):\\n#             if index < len(difficulty) and i == difficulty[index]:\\n#                 dp[i] = max(dp[i-1], profit[index])\\n#                 index += 1\\n#             else:\\n#                 dp[i] = dp[i-1]\\n        \\n#         total = 0\\n#         for w in worker:\\n#             total += dp[w]\\n            \\n#         return total\\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        profit = [i[1] for i in sorted(zip(difficulty, profit))]\\n        difficulty.sort()\\n        for i in range(1, len(profit)):\\n            profit[i] = max(profit[i], profit[i-1])\\n        difficulty.append(float('inf'))\\n        tot = 0\\n        for w in range(len(worker)):\\n            low = 0\\n            high = len(difficulty)-1\\n            while low < high:\\n                mid = low + (high-low)//2\\n                if difficulty[mid] > worker[w]:\\n                    high = mid\\n                else:\\n                    low = mid+1\\n            low -= 1\\n            if low < 0:\\n                continue\\n            tot += profit[low]\\n        return tot\\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = sorted(zip(difficulty, profit))\\n        res = i = best = 0\\n        for ability in sorted(worker):\\n            while i < len(jobs) and ability >= jobs[i][0]:\\n                best = max(jobs[i][1], best)\\n                i += 1\\n            res += best\\n        return res\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        mapProfit = dict()\\n        for i in range(len(difficulty)):\\n            if difficulty[i] in mapProfit:\\n                mapProfit[difficulty[i]] = max(mapProfit[difficulty[i]], profit[i])\\n            else:\\n                mapProfit[difficulty[i]] = profit[i]\\n        l = list()\\n        maxDiff = max(difficulty)\\n        for i in range(maxDiff + 1):\\n            if i in mapProfit:\\n                l.append(mapProfit[i])\\n            else:\\n                l.append(0)\\n        \\n        maxFromBegin = 0\\n        for i in range(len(l)):\\n            if l[i] < maxFromBegin:\\n                l[i] = maxFromBegin\\n            else:\\n                maxFromBegin = l[i]\\n        # print(l)\\n        res = 0\\n        for work in worker:\\n            if work > maxDiff:\\n                res += l[-1]\\n            else:\\n                res += l[work]\\n        return res\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        n=len(profit)\\n        maxm=max(difficulty)\\n        dp=[0]*(1+maxm)\\n        for i in range(n):\\n            dp[difficulty[i]]=max(dp[difficulty[i]],profit[i])\\n        for i in range(1,maxm+1):\\n            dp[i]=max(dp[i],dp[i-1])\\n        res=0\\n\\n        for x in worker:\\n            if x>maxm:\\n                res+=dp[maxm]\\n            else:\\n                res+=dp[x]\\n        return res\\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        # Max profits for each level of difficulty.\\n        max_diff = max(difficulty)\\n        max_profits = [0] * (max_diff + 1)\\n        \\n        # Set the initial values\\n        for diff, profit in zip(difficulty, profit):\\n            max_profits[diff] = max(max_profits[diff], profit)\\n        \\n        # Consider the profit from lower difficulty (ie. diff 1 profit 5 might be better than diff 5 profit 1)\\n        for i in range(1, max_diff + 1):\\n            max_profits[i] = max(max_profits[i], max_profits[i - 1])\\n        \\n        # Figure out max profits.\\n        pft = 0\\n        for wskill in worker:\\n            pft += max_profits[max_diff if wskill > max_diff else wskill]\\n        \\n        return pft\\n        \\n\", \"from bisect import bisect_right\\n\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        dp = [(d, p) for d, p in zip(difficulty, profit)]\\n        dp.sort()\\n        G = []\\n        C = []\\n        for x, y in dp:\\n            if not G or G[-1] < x:\\n                G.append(x)\\n                C.append(y)\\n                continue\\n            if G[-1] == x:\\n                C[-1] = y\\n        for y in range(1, len(C)):\\n            if C[y-1] > C[y]:\\n                C[y] = C[y-1]\\n        ans = 0\\n        for w in worker:\\n            idx = bisect_right(G, w)-1\\n            if idx >= 0:\\n                ans += C[idx]\\n        return ans\", \"def maximum_profit_for_difficulty(diff_job, difficulty, profit):\\n    return max([profit[job] for job in diff_job[difficulty]])\\n\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        min_difficulty = min(difficulty)\\n        max_difficulty = max(difficulty)\\n        least_difficult_job = difficulty.index(min_difficulty)\\n        \\n        diff_job = defaultdict(list)\\n        for i, diff in enumerate(difficulty):\\n            diff_job[diff].append(i)\\n    \\n        max_profit = [maximum_profit_for_difficulty(diff_job, min_difficulty, profit)]\\n        for i in range(1, max_difficulty-min_difficulty+1):\\n            current_difficulty = i + min_difficulty\\n            if current_difficulty in diff_job:\\n                current_job_profit = maximum_profit_for_difficulty(diff_job, current_difficulty, profit)\\n                max_profit.append(max(max_profit[i-1], current_job_profit))\\n            else:\\n                max_profit.append(max_profit[i-1])\\n\\n        result = 0  \\n        for ability in worker:\\n            if ability >= max_difficulty:\\n                result += max_profit[-1]\\n            elif ability < min_difficulty:\\n                result += 0\\n            else:\\n                result += max_profit[ability-min_difficulty]\\n        return result\\n\", \"# # Fisrt solution\\n# def createListOfProfitDiff(profit, difficulty):\\n#     profit_diff = []\\n#     for i in range(len(profit)):\\n#         profit_diff.append((profit[i], difficulty[i]))\\n#     return profit_diff\\n        \\n        \\n        \\n# class Solution:\\n#     def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n#         profit_diff = createListOfProfitDiff(profit, difficulty)\\n#         profit_diff.sort(key=lambda x:x[0])\\n#         worker2 = sorted(worker)\\n\\n#         maxprofit = 0\\n#         for i in range(len(profit_diff)-1, -1, -1):\\n#             for j in range(len(worker2) -1, -1, -1):\\n#                 if profit_diff[i][1]> worker2[j]:\\n#                     break\\n#                 else:\\n#                     maxprofit += profit_diff[i][0]\\n#                     worker2.pop(j)\\n#         return maxprofit\\n# Second solution\\ndef createListOfProfitDiff(profit, difficulty):\\n    profit_diff = []\\n    for i in range(len(profit)):\\n        profit_diff.append((profit[i], difficulty[i]))\\n    return profit_diff\\n        \\n        \\n        \\n# class Solution:\\n#     def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n#         profit_diff = createListOfProfitDiff(profit, difficulty)\\n#         profit_diff.sort(key=lambda x:x[0])\\n#         worker2 = sorted(worker)\\n\\n#         maxprofit = 0\\n#         i = len(profit_diff) -1\\n#         j = len(worker2)-1\\n#         while i<len(profit_diff) and j <len(worker2) and i>-1 and j>-1:\\n#             if profit_diff[i][1]> worker2[j]:\\n#                 i-=1\\n#             else:\\n#                 maxprofit += profit_diff[i][0]\\n#                 worker2.pop(j)\\n#                 j-=1\\n#         return maxprofit\\n\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        w = sorted(worker)\\n        w.reverse()\\n        dp = []\\n        for i in range(len(profit)):\\n            dp.append((profit[i], difficulty[i]))\\n        dp.sort(key =  lambda x:x[0])\\n        dp.reverse()\\n\\n        i = 0\\n        count = 0\\n        for p in dp:\\n            while i<len(w) and p[1] <= w[i]:\\n                count += p[0]\\n                i+=1\\n        return count\\n                \\n\", \"from itertools import chain\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        li = list(chain(zip(profit, difficulty)))\\n        li.sort()\\n        cutoffs = [li[-1][1]]\\n        profits = [li[-1][0]]\\n        for i in range(len(profit)-2, -1, -1):\\n            if li[i][1] < cutoffs[0]:\\n                cutoffs.insert(0, li[i][1])\\n                profits.insert(0, li[i][0])\\n        cutoffs.insert(0, 0)\\n        profits.insert(0, 0)\\n        ans = 0\\n        n = len(cutoffs)\\n        for ability in worker:\\n            l = 0\\n            r = n-1\\n            while(r >= l):\\n                mid = (l + r) // 2\\n                if ability == cutoffs[mid]:\\n                    break\\n                elif ability > cutoffs[mid]:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            mid = mid - 1\\n            for i in range(3):\\n                if mid+1 < n:\\n                    if ability >= cutoffs[mid+1]:\\n                        mid += 1\\n            ans += profits[mid]\\n        return(ans)\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        combined = []\\n\\n        for i in range(len(difficulty)):\\n            combined.append((difficulty[i], profit[i]))\\n\\n        combined = sorted(combined, key=lambda x: x[0])\\n        total = 0\\n        i = 0\\n        best_profit = 0\\n        \\n        for w in sorted(worker):\\n            while i < len(combined) and w >= combined[i][0]:\\n                best_profit = max(best_profit, combined[i][1])\\n                i += 1\\n            \\n            # best_profit is the most profit you can get for current worker, if the next worker has the same workload capability, he will do add to the total doing with the same best_profit.\\n            total += best_profit\\n            \\n        return total\\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        profit = [i[1] for i in sorted(zip(difficulty, profit))]\\n        difficulty.sort()\\n        for i in range(1, len(profit)):\\n            profit[i] = max(profit[i], profit[i-1])\\n        difficulty.append(float('inf'))\\n        worker.sort()\\n        tot = 0\\n        low = 0\\n        for w in range(len(worker)):\\n            low = 0\\n            high = len(difficulty)-1\\n            while low < high:\\n                mid = low + (high-low)//2\\n                if difficulty[mid] > worker[w]:\\n                    high = mid\\n                else:\\n                    low = mid+1\\n            low -= 1\\n            if low < 0:\\n                low = 0\\n                continue\\n            tot += profit[low]\\n        return tot\\n\", \"def maximum_profit_for_difficulty(diff_job, difficulty, profit):\\n    return max([profit[job] for job in diff_job[difficulty]])\\n\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        min_difficulty = min(difficulty)\\n        max_difficulty = max(difficulty)        \\n        diff_job = defaultdict(list)\\n        for i, diff in enumerate(difficulty):\\n            diff_job[diff].append(i)\\n    \\n        max_profit = [maximum_profit_for_difficulty(diff_job, min_difficulty, profit)]\\n        for i in range(1, max_difficulty-min_difficulty+1):\\n            current_difficulty = i + min_difficulty\\n            if current_difficulty in diff_job:\\n                current_job_profit = maximum_profit_for_difficulty(diff_job, current_difficulty, profit)\\n                max_profit.append(max(max_profit[i-1], current_job_profit))\\n            else:\\n                max_profit.append(max_profit[i-1])\\n\\n        result = 0  \\n        for ability in worker:\\n            if ability >= max_difficulty:\\n                result += max_profit[-1]\\n            elif ability < min_difficulty:\\n                result += 0\\n            else:\\n                result += max_profit[ability-min_difficulty]\\n        return result\\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = list(zip(difficulty, profit))\\n        jobs.sort()\\n        ans = 0\\n        i = 0\\n        best = 0\\n        for skill in sorted(worker):\\n            while i<len(jobs) and skill >= jobs[i][0]:\\n                best = max(best, jobs[i][1])\\n                i += 1\\n            \\n            ans += best\\n        \\n        return ans\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        n=max(worker)\\n        s=[0 for i in range(n)]\\n        \\n        for i in range(len(difficulty)):\\n            if difficulty[i]<=n :\\n                s[difficulty[i]-1]=max(s[difficulty[i]-1],profit[i])\\n        \\n        \\n        for i in range(1,n):\\n            if s[i]<s[i-1]:\\n                s[i]=s[i-1]\\n        ans=sum([s[worker[i]-1] for i in range(len(worker))])\\n        return ans\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        def bs(arr, s, e, target):\\n            while s<=e:\\n                mid = s+(e-s)//2\\n                if arr[mid][0]<=target:\\n                    s = mid+1\\n                else:\\n                    e = mid-1\\n            return e\\n        \\n        arr = []\\n        for pd in sorted(zip(difficulty, profit)):\\n            if arr and arr[-1][1]>=pd[1]:\\n                continue\\n            arr.append(pd)\\n            \\n        res = 0\\n        N = len(arr)\\n        for w in worker:\\n            idx = bs(arr, 0, N-1, w)\\n            if idx>=0:\\n                res += arr[idx][1]\\n            \\n        return res\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        n=len(profit)\\n        maxm=max(difficulty)\\n        dp=[0]*(1+maxm)\\n        for i in range(n):\\n            dp[difficulty[i]]=max(dp[difficulty[i]],profit[i])\\n        for i in range(1,maxm+1):\\n            dp[i]=max(dp[i],dp[i-1])\\n        res=0\\n\\n        for x in worker:\\n            if x>maxm:\\n                res+=dp[maxm]\\n            else:\\n                res+=dp[x]\\n        return res\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        bfb = [0]*max(max(worker),max(difficulty)) # bfb[i] will tell us the best profitting job that is at or below difficulty i+1\\n        for diff,prof in sorted(zip(difficulty,profit)):\\n            bfb[diff-1] = max(bfb[diff-1],prof)\\n        \\n        currMax = 0\\n        for i in range(len(bfb)):\\n            bfb[i] = max(currMax,bfb[i])\\n            currMax = bfb[i]\\n            \\n        # print(bfb)\\n        \\n        total = 0\\n        for w in worker:\\n            total += bfb[w-1]\\n            \\n        return total\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n            difficulty_price = sorted(list(zip(difficulty, profit)), key = lambda x: (x[0], x[1]))    \\n            max_prices = []\\n            n = -1\\n            curr_price = 0\\n            for i in range(max(difficulty)+1):\\n                if i == difficulty_price[n+1][0]:\\n                    n+=1\\n                    while n < len(difficulty_price) - 1 and i == difficulty_price[n+1][0]:\\n                        n+=1\\n                    if difficulty_price[n][1] > curr_price:\\n                        curr_price = difficulty_price[n][1]\\n                max_prices.append(curr_price)\\n            profit_sum = 0\\n            for sub_worker in worker:\\n                if sub_worker >= len(max_prices):\\n                    profit_sum += max_prices[-1]\\n                else:\\n                    profit_sum += max_prices[sub_worker]\\n            return profit_sum\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        #get best profit by difficulty and apply to each worker\\n        #init memo table\\n        m = max(difficulty)\\n        dp = [0] * m\\n        for d, p in zip(difficulty, profit):\\n            dp[d - 1] = max(dp[d - 1], p) \\n        for i in range(1,len(dp)):\\n            dp[i] = max(dp[i], dp[i - 1])    \\n        return sum([dp[min(w - 1, m - 1)] for w in worker])    \\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = list(zip(difficulty, profit))\\n        jobs.sort()\\n        ans = i = best = 0\\n        for skill in sorted(worker):\\n            while i < len(jobs) and skill >= jobs[i][0]:\\n                best = max(best, jobs[i][1])\\n                i += 1\\n            ans += best\\n        return ans\", \"class Solution:\\n  def binarySearch(self, l, r, x, li):\\n    if (r - l <= 1):\\n      if (li[r] <= x):\\n          return r\\n      else:\\n          return l\\n    m = (l + r + 1)//2\\n    if (li[m] <= x):\\n      return self.binarySearch(m, r, x, li)\\n    else:\\n      return self.binarySearch(l, m-1, x, li)\\n      \\n  def maxProfitAssignment(self, difficulty, profit, worker):\\n    difficulty.append(0)\\n    profit.append(0)\\n    jobs = sorted(zip(difficulty, profit))\\n    J = len(jobs)\\n    jobDifficulty = [j[0] for j in jobs]\\n    mostProfit = [jobs[0][1] for j in jobs]\\n    for i in range(1, J):\\n      mostProfit[i] = max(jobs[i][1], mostProfit[i-1])\\n    totProfit = 0\\n    for w in worker:\\n      maxJob = self.binarySearch(0, J-1, w, jobDifficulty)\\n      totProfit += mostProfit[maxJob]\\n    return totProfit\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        n = len(profit)\\n        maxm = max(difficulty)\\n        dp = [0]*(1+maxm)\\n        \\n        for i in range(n):\\n            dp[difficulty[i]] = max(dp[difficulty[i]],profit[i])\\n        \\n        for i in range(1,maxm+1):\\n            dp[i] = max(dp[i],dp[i-1])\\n        \\n        ans = 0\\n        \\n        for i in worker:\\n            if i > maxm:\\n                ans += dp[maxm]\\n            else:\\n                ans += dp[i]\\n        return ans\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        max_v = max(max(difficulty), max(worker))\\n        \\n        n = len(difficulty)\\n        best = {}\\n        for i in range(n):\\n            d = difficulty[i]\\n            p = profit[i]\\n            if d not in best:\\n                best[d] = p\\n            else:\\n                best[d] = max(best[d], p)\\n        \\n        dp = [0] * (max_v + 1)\\n        dp[0] = 0\\n        for i in range (max_v + 1):\\n            p = 0\\n            if i in best:\\n                p = best[i]\\n            dp[i] = max(dp[i - 1], p)\\n        \\n        s = 0 \\n        for d in worker:\\n            s += dp[d]\\n        return s\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        dp_dict = dict(list(zip(difficulty, profit)))\\n        l = len(difficulty)\\n        for idx in range(l):\\n            d = difficulty[idx]\\n            if profit[idx] > dp_dict[d]:\\n                dp_dict[d] = profit[idx]\\n        dp_items = sorted(list(dp_dict.items()), key=lambda x: x[0])\\n        darr = [x[0] for x in dp_items]\\n\\n        max_p = 0\\n        parr = list()\\n        for d,p in dp_items:\\n            if p > max_p:\\n                max_p = dp_dict[d]\\n            parr.append(max_p)\\n\\n        ret = 0\\n\\n        def get_nearest(w, arr):\\n            l = len(arr)\\n            if w < arr[0]: return None\\n            if w > arr[-1]: return l-1\\n\\n            def binary_search(w, i, j):\\n                if i >= l or j >= l or w < arr[i] or w > arr[j]:\\n                    return None\\n                if w == arr[i]: return i\\n                if w == arr[j]: return j\\n                k = (i + j) // 2\\n                if arr[k] <= w < arr[k + 1]:\\n                    return k\\n                prev = binary_search(w, i, k)\\n                return binary_search(w, k + 1, j) if prev is None else prev\\n\\n            return binary_search(w, 0, l - 1)\\n\\n        for w in worker:\\n            floor_idx = get_nearest(w, darr)\\n            if floor_idx is not None:\\n                ret += parr[floor_idx]\\n        return ret\\n\", \"from typing import List\\nimport heapq\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        # (-profit[i], difficulty[i])\\u7ec4\\u6210\\u6700\\u5c0f\\u5806\\n        result_profit = 0\\n        profit_minus_min_heap = list()\\n        for i in range(len(profit) ):\\n            heapq.heappush(profit_minus_min_heap, (-profit[i], difficulty[i]) )\\n        worker_minus_min_heap = [-worker[i] for i in range( len(worker) )]\\n        heapq.heapify(worker_minus_min_heap)\\n\\n        while len(worker_minus_min_heap)!=0  and len(profit_minus_min_heap)!=0:\\n            job_profit, job_difficulty = profit_minus_min_heap[0]\\n            job_profit = -job_profit\\n            worker_ability = worker_minus_min_heap[0]\\n            worker_ability = -worker_ability\\n            if worker_ability >= job_difficulty:\\n                result_profit += job_profit\\n                heapq.heappop( worker_minus_min_heap)\\n            else:\\n                heapq.heappop( profit_minus_min_heap)\\n        \\n        return result_profit\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        make=[0]*(10**5)\\n        num=[(difficulty[i],profit[i])for i in range(len(profit))]\\n        num.sort(key=lambda x:x[0])\\n        x=0\\n        while x<len(num):\\n            if x+1<len(num):\\n                if num[x][1]>num[x+1][1]:\\n                    num.pop(x+1)\\n                else:x+=1\\n            else:break\\n        for i in range(len(num)):\\n            make[num[i][0]]=num[i][1]\\n        pre=-1\\n        for i in range(len(make)):\\n            if make[i]!=0:\\n                pre=make[i]\\n            elif pre!=-1:\\n                make[i]=pre\\n##        print(make)\\n        ans=0\\n        \\n        for w in worker:\\n            ans+=make[w]\\n        return ans\\n\", \"class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        make=[0]*(10**5)\\n        num=[(difficulty[i],profit[i])for i in range(len(profit))]\\n        num.sort(key=lambda x:x[0])\\n        x=0\\n        while x<len(num):\\n            if x+1<len(num):\\n                if num[x][1]>num[x+1][1]:\\n                    num.pop(x+1)\\n                else:x+=1\\n            else:break\\n        for i in range(len(num)):\\n            make[num[i][0]]=num[i][1]\\n        pre=-1\\n        for i in range(len(make)):\\n            if make[i]!=0:\\n                pre=make[i]\\n            elif pre!=-1:\\n                make[i]=pre\\n        ans=0\\n        for w in worker:\\n            ans+=make[w]\\n        return ans    \\n\", \"import numpy as np\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        direc = np.zeros((len(profit),2))\\n        direc[:,0] = difficulty\\n        direc[:,1] = profit\\n        direc = direc[direc[:,0].argsort()]\\n        # print(direc)\\n        max_profit = np.array(direc[:,1])\\n        for i in range(1,len(profit)):\\n            if max_profit[i-1] > direc[i,1]:\\n                max_profit[i] = max_profit[i-1]\\n        # print(max_profit)\\n        result = 0\\n        for j in range(len(worker)):\\n            # if worker[j] in difficulty:\\n            #     ind = np.searchsorted(direc[:,0],worker[j],side = 'Left')\\n            # else: ind = np.searchsorted(direc[:,0],worker[j],side = 'Left') - 1\\n            ind = np.searchsorted(direc[:,0],worker[j],side = 'Right') - 1\\n            # print(ind,max_profit[ind])\\n            if ind >-1:result += max_profit[ind]\\n        return int(result)\"]", "input_output": "{\"fn_name\": \"maxProfitAssignment\", \"inputs\": [[[2, 4, 6, 8, 10], [10, 20, 30, 40, 50], [4, 5, 6, 7]]], \"outputs\": [100]}", "difficulty": "interview", "url": "https://leetcode.com/problems/most-profit-assigning-work/", "starter_code": "\nclass Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        "}
{"id": 149, "question": "Given a string\u00a0s, a k\u00a0duplicate removal\u00a0consists of choosing k\u00a0adjacent and equal letters from\u00a0s and removing\u00a0them causing the left and the right side of the deleted substring to concatenate together.\nWe repeatedly make k duplicate removals on s until we no longer can.\nReturn the final string after all such duplicate removals have been made.\nIt is guaranteed that the answer is unique.\n\u00a0\nExample 1:\nInput: s = \"abcd\", k = 2\nOutput: \"abcd\"\nExplanation: There's nothing to delete.\nExample 2:\nInput: s = \"deeedbbcccbdaa\", k = 3\nOutput: \"aa\"\nExplanation: \nFirst delete \"eee\" and \"ccc\", get \"ddbbbdaa\"\nThen delete \"bbb\", get \"dddaa\"\nFinally delete \"ddd\", get \"aa\"\nExample 3:\nInput: s = \"pbbcggttciiippooaais\", k = 2\nOutput: \"ps\"\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 10^5\n2 <= k <= 10^4\ns only contains lower case English letters.", "solutions": "[\"class Solution:\\n    def removeDuplicates(self, s: str, k: int) -> str:\\n        st=[['*',0]]\\n        for c in s:\\n            if c!=st[-1][0]:\\n                st.append([c,1])\\n            else:\\n                st[-1][1]+=1\\n                if st[-1][1]==k:\\n                    st.pop()\\n        res=''\\n        for c,v in st:\\n            res+=c*v\\n        return res\", \"class Solution:\\n    def removeDuplicates(self, s: str, k: int) -> str:\\n        if not s or k == 0:\\n            return s\\n        \\n        stack = [['#', 0]]\\n        for c in s:\\n            if stack[-1][0] == c:\\n                stack[-1][1] += 1\\n                if stack[-1][1] == k:\\n                    stack.pop()\\n            else:\\n                stack.append([c, 1])\\n        \\n\\n        return ''.join(c*k for c, k in stack)\\n\\n        \\n        \\n\", \"class Solution:\\n    def removeDuplicates(self, s: str, k: int) -> str:\\n        res = []\\n        char = s[0]\\n        count = 1\\n\\n        for i in range(1, len(s)):\\n            if s[i] == char:\\n                count += 1\\n            else:\\n                count = 1\\n                char = s[i]\\n\\n            if count == k:\\n                return self.removeDuplicates(s[:i-k+1] + s[i+1:], k)\\n            \\n        return s\", \"class Solution:\\n    def removeDuplicates(self, s: str, k: int) -> str:\\n        if len(s) < k:\\n            return s\\n        # stack=[]\\n        # cnt_stack=[]\\n        # for char in s:\\n        #     if not stack or stack[-1] !=char:\\n        #         stack.append(char)\\n        #         cnt_stack.append(1)\\n        #     else:\\n        #         cnt_stack[-1] +=1\\n        #     if cnt_stack[-1] == k:\\n        #         cnt_stack.pop()\\n        #         stack.pop()\\n        # return ''.join([stack[i]*cnt_stack[i] for i in range(len(stack))])\\n        stack=[[0,'#']]\\n        for char in s:\\n            if char == stack[-1][1]:\\n                stack[-1][0] +=1\\n                if stack[-1][0] == k:\\n                    stack.pop()\\n            else:\\n                stack.append([1,char])\\n        return ''.join(c*k for c,k in stack)\\n            \\n                    \\n                \\n        \\n               \\n\", \"class Solution:\\n    def removeDuplicates(self, s: str, k: int) -> str: \\n        \\n        unique = set(s)\\n        dups = []\\n        \\n        for c in unique: \\n            dups.append(c*k)\\n            \\n        while True: \\n            start = s\\n            for c in dups: \\n                s = s.replace(c, '')\\n                \\n            if start == s: \\n                return s\\n        \\n#         ret = list(s) \\n        \\n#         while True: \\n#             s = ret\\n#             ret = []\\n#             ac = 1\\n#             for c in s: \\n#                 if not ret or ret[-1] != c: \\n#                     ac = 1\\n#                     ret.append(c)\\n#                 else: \\n#                     if ac + 1 == k: \\n#                         while ac: \\n#                             ret.pop()\\n#                             ac -= 1\\n#                     else: \\n#                         ret.append(c)\\n#                         ac += 1\\n#                 # print(ret, ac)\\n#             if len(ret) == len(s): \\n#                 break\\n                        \\n#         return ''.join(ret)\\n                    \\n\", \"class Solution:\\n    def removeDuplicates(self, s: str, k: int) -> str:\\n        lengths = [[None, 0]]\\n        idx = 0\\n        \\n        while idx < len(s):\\n            current = lengths[-1][0]\\n            \\n            if current == s[idx]:\\n                lengths[-1][1] += 1\\n            else:\\n                lengths.append([s[idx], 1])\\n                current = s[idx]\\n                \\n            if lengths[-1][1] == k:\\n                lengths.pop()\\n                s = s[:idx - k + 1] + s[idx + 1:]\\n                idx -= k\\n                \\n            idx += 1\\n                    \\n        return s\", \"class Solution:\\n    def removeDuplicates(self, s: str, k: int) -> str:\\n        \\n        ret = list(s) \\n        \\n        while True: \\n            s = ret\\n            ret = []\\n            ac = 1\\n            for c in s: \\n                if not ret or ret[-1] != c: \\n                    ac = 1\\n                    ret.append(c)\\n                else: \\n                    if ac + 1 == k: \\n                        while ac: \\n                            ret.pop()\\n                            ac -= 1\\n                    else: \\n                        ret.append(c)\\n                        ac += 1\\n                # print(ret, ac)\\n            if len(ret) == len(s): \\n                break\\n                        \\n        return ''.join(ret)\\n                    \\n\", \"class Solution:\\n    def removeDuplicates(self, s: str, k: int) -> str:\\n        \\n        \\n        count = 1\\n        flag = 1\\n        last_idx = 0\\n        while(1):\\n            i = 0\\n            temp_s = s\\n            while(i < len(s)-1):\\n                #print(\\\\\\\"i = \\\\\\\",i)\\n                #print(\\\\\\\"s = \\\\\\\",s)\\n                if(s[i] != s[i+1]):\\n                    i = i+1\\n                else:\\n                    last_idx = i\\n                    while(1):\\n                        if(i+1 == len(s)):\\n                            break \\n                        elif(s[i] == s[i+1]):\\n                            count = count+1\\n                            i = i+1\\n                        else:\\n                            break \\n                    if(count >= k):\\n                        s = s[:last_idx] + s[last_idx+k:]\\n                        i = last_idx\\n                    count = 1\\n            if(temp_s == s):\\n                break \\n        return s\", \"class Solution:\\n    def removeDuplicates(self, s: str, k: int) -> str:\\n        while True:\\n            stk = []\\n            s_new = []\\n            for c in s:\\n                if len(stk)==k: stk=[]\\n                while stk and c!=stk[-1]:\\n                    s_new.append(stk.pop())\\n                stk.append(c)\\n                if len(stk)==k: stk=[]\\n            while stk:\\n                s_new.append(stk.pop())  \\n            print(''.join(s_new))\\n            if s==s_new: break\\n            s = s_new\\n        return ''.join(s)\", \"class Solution:\\n    def removeDuplicates(self, s: str, k: int) -> str:\\n        \\n        ns = []\\n        deleted= True\\n        while deleted:\\n            deleted = False\\n            i = 0\\n            ns = []\\n            while i < len(s):\\n                if i <= len(s) - k and s[i+1:i+k] == s[i]*(k-1):\\n                    deleted = True\\n                    i += k\\n                else:\\n                    ns.append(s[i])\\n                    i += 1\\n            s = ''.join(ns)\\n\\n        return s\", \"class Solution:\\n    def removeDuplicates(self, s: str, k: int) -> str:\\n        \\n        def helper(s):\\n        \\n            ans = []\\n        \\n            i = 0\\n            while i < len(s):\\n            \\n                if s[i] * k != s[i:i+k]:\\n                    ans.append(s[i])\\n                    i += 1\\n                else:\\n                    i += k\\n        \\n            if len(ans) == len(s):\\n                res.append(''.join(ans))\\n                return\\n            else:\\n                helper(''.join(ans))\\n\\n        res = []\\n        helper(s)\\n        return res[0]\", \"class Solution:\\n    def removeDuplicates(self, s: str, k: int) -> str:\\n        sliced = True\\n        while sliced == True:\\n            s, sliced = self.getSlices(s, k)\\n        return s\\n    \\n    def getSlices(self, s, k):\\n        sliced = False\\n        idx = set()\\n        i = 0\\n        while i < len(s):\\n            if s[i]*k == s[i:i+k]:\\n                idx.update(range(i, i+k))\\n                sliced = True\\n                i += k\\n            i += 1\\n        if sliced:\\n            new_str = ''.join([char for i, char in enumerate(s) if i not in idx])\\n            return new_str, sliced\\n        return s, sliced\", \"class Solution:\\n    def removeDuplicates(self, s: str, k: int) -> str:\\n        while True:\\n            stk = []\\n            s_new = []\\n            for c in s:\\n                if len(stk)==k: stk=[]\\n                while stk and c!=stk[-1]:\\n                    s_new.append(stk.pop())\\n                stk.append(c)\\n                if len(stk)==k: stk=[]\\n            while stk:\\n                s_new.append(stk.pop())  \\n            if s==s_new: break\\n            s = s_new\\n        return ''.join(s)\", \"class Solution:\\n    def removeDuplicates(self, s: str, k: int) -> str:\\n        len_s = len(s)\\n        \\n        if k > len_s:\\n            return s\\n        \\n        def helper(string, itr_range):\\n            not_found = False    #if no k repeating elements found, then True\\n            \\n            while not not_found:\\n                not_found = True\\n                \\n                for i in range(itr_range):\\n                    if string[i:i+k] == string[i]*k:\\n                        string = string[:i]+string[i+k:]\\n                        itr_range = len(string)-k+1\\n                        not_found = False\\n                        break\\n            return string\\n        \\n        return helper(s, len_s-k+1)\", \"class Solution:\\n    def removeDuplicates(self, s: str, k: int) -> str:\\n        if len(s)<k:\\n            return s\\n        found = self.findStr(s, k)\\n        if not found:\\n            return s\\n        else:\\n            return self.removeDuplicates(s.replace(found, ''), k)\\n        \\n    def findStr(self, s:str, k:int):\\n        for i in range(len(s)):\\n            if (s[i]*k) in s:\\n                return s[i]*k\\n        return None\", \"class Solution:\\n    def removeDuplicates(self, s: str, k: int) -> str:\\n        distinct = len(set(s))\\n        while len(s) >= k:\\n            new_s = ''\\n            cur, count = s[0], 1\\n            for i in range(1, len(s)):\\n                print(cur, count)\\n                if s[i] == cur:\\n                    count += 1\\n                else:\\n                    new_s += cur * (count % k)\\n                    cur, count = s[i], 1\\n            new_s += cur * (count % k)\\n            if s == new_s:\\n                break\\n            s = new_s\\n        return s\", \"\\nclass Solution:\\n    def removeDuplicates(self, s: str, k: int) -> str:\\n        duplicates=[k*i for i in 'abcdefghijklmnopqrstuvwxyz']\\n        counter=0\\n        while counter!=len(s):\\n            counter=len(s)\\n            for i in duplicates:\\n                s=s.replace(i,'')\\n                \\n        return s\", \"class Solution:\\n    def removeDuplicates(self, s: str, k: int) -> str:\\n                \\n        if not s:\\n            return ''\\n        \\n        stack = []\\n        \\n        prev = count = None\\n        for i in range(0, len(s)):\\n            \\n            if not prev:\\n                prev, count = s[i], 1\\n            elif s[i] == prev:\\n                count += 1\\n            else:\\n                stack.append((prev, count))\\n                prev = s[i]\\n                count = 1\\n                \\n            if count == k:\\n                if stack:\\n                    prev, count = stack.pop()\\n                else:\\n                    prev = None\\n            \\n            # print(stack, s[i], i, prev, count)\\n            \\n        stack.append((prev, count))\\n        \\n        output = ''\\n        for e,c in stack:\\n            output += e*c\\n        \\n        return output\\n        \\n        \\n        \\n            \\n                \\n            \\n            \\n                \\n'''\\n#check k = 1\\n'''\", \"class Solution:\\n    def removeDuplicates(self, s: str, k: int) -> str:\\n        stack = [['#', 0]]\\n        for c in s:\\n            if stack[-1][0] == c:\\n                stack[-1][1] += 1\\n                if stack[-1][1] == k:\\n                    stack.pop()\\n            else:\\n                stack.append([c, 1])\\n        return ''.join(c * k for c, k in stack)\"]", "input_output": "{\"fn_name\": \"removeDuplicates\", \"inputs\": [[\"\\\"abcd\\\"\", 2]], \"outputs\": [\"\\\"abcd\\\"\"]}", "difficulty": "interview", "url": "https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/", "starter_code": "\nclass Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        "}
{"id": 150, "question": "Given an array A, partition it\u00a0into two (contiguous) subarrays\u00a0left\u00a0and right\u00a0so that:\n\nEvery element in left\u00a0is less than or equal to every element in right.\nleft and right are non-empty.\nleft\u00a0has the smallest possible size.\n\nReturn the length of left after such a partitioning.\u00a0 It is guaranteed that such a partitioning exists.\n\u00a0\nExample 1:\nInput: [5,0,3,8,6]\nOutput: 3\nExplanation: left = [5,0,3], right = [8,6]\n\n\nExample 2:\nInput: [1,1,1,0,6,12]\nOutput: 4\nExplanation: left = [1,1,1,0], right = [6,12]\n\n\u00a0\n\nNote:\n\n2 <= A.length\u00a0<= 30000\n0 <= A[i] <= 10^6\nIt is guaranteed there is at least one way to partition A as described.", "solutions": "[\"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        biggest = A[0]\\n        newbiggest = A[0]\\n        lenL = 1\\n        total = 1\\n        for itr in A[1:]:\\n            total += 1\\n            if itr < biggest:\\n                lenL = total\\n                biggest = newbiggest\\n            else:\\n                if itr > newbiggest:\\n                    newbiggest = itr\\n        return lenL\\n\\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        res = 0\\n        v = A[0]\\n        max_sofar = v\\n        for i in range(len(A)):\\n            max_sofar = max(max_sofar, A[i])\\n            if A[i] < v:\\n                v = max_sofar\\n                res = i\\n                \\n        return res+1\\n    # \\u5982\\u679c\\u4e2d\\u95f4\\u6709\\u4e00\\u4e2a\\u6570\\u5b57\\u53d8\\u5927\\uff0c\\u6211\\u4e0d\\u66f4\\u65b0v\\uff0c v\\u53ea\\u662f\\u4e4b\\u524d\\u6700\\u5927\\u7684\\u6570\\n    # [32,57,24,19,0,24,49,67,87,87]  \\u5982\\u679c\\u6211\\u4e0d\\u66f4\\u65b0v\\uff0c32 \\u4f1a\\u4e00\\u76f4\\u6700\\u5927\\uff0c\\u90a3\\u4e4849 \\u5c31\\u5f52\\u5728\\u53f3\\u8fb9\\u4e86\\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        a = [A[0]]\\n        b = [0 for i in range(len(A))]\\n        for i in range(1, len(A)):\\n            a.append(max(a[i - 1], A[i]))\\n        \\n        b[-1] = A[-1]\\n        for i in range(len(A) - 2, -1, -1):\\n            b[i] = min(b[i + 1], A[i])\\n            \\n        for i in range(len(A) - 1):\\n            if a[i] <= b[i + 1]:\\n                return i + 1\\n        return -1\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        n = len(A)\\n        mini = [float('-inf')]*n\\n        maxi = [float('inf')]*n\\n        mini[0] = A[0]\\n        maxi[n - 1] = A[n - 1]\\n        for i in range(1, n):\\n            mini[i] = max(mini[i - 1], A[i])\\n        \\n        for i in range(n-2, -1, -1):\\n            maxi[i] = min(maxi[i + 1], A[i])\\n        \\n        # print(mini)\\n        # print(maxi)\\n        for i in range(n - 1):\\n            if mini[i] <= maxi[i + 1]:\\n                return i + 1\\n        \\n        return 0\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        N = len(A)\\n        maxleft = [None] * N\\n        minright = [None] * N\\n\\n        m = A[0]\\n        for i in range(N):\\n            m = max(m, A[i])\\n            maxleft[i] = m\\n        \\n        m = A[-1]\\n        for i in range(N -1, -1, -1):\\n            m = min(m, A[i])\\n            minright[i] = m\\n            \\n        for i in range(1, N):\\n            if maxleft[i-1] <= minright[i]:\\n                return i\\n            \\n            \\n#         # https://leetcode.com/problems/partition-array-into-disjoint-intervals/discuss/175904/Explained-Python-simple-O(N)-time-O(1)-space\\n        \\n#         # The idea is, v is nothing but the max value of the left half and max_so_far is a nonlocal maximum of the entire array. So by selecting elements only lesser than max of left side (v), we set V to the first element.\\n        \\n#         disjoint = 0\\n#         v = A[disjoint]\\n#         max_so_far = v\\n#         for i in range(len(A)):\\n#             max_so_far = max(max_so_far, A[i])\\n#             if A[i] < v: \\n#                 disjoint = i\\n#                 v = max_so_far\\n#         return disjoint + 1\\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        n = len(A)\\n        large = [0] * n\\n        small = [0] * n\\n        l, s = -sys.maxsize, sys.maxsize\\n        for i in range(n):\\n            l = max(l, A[i])\\n            s = min(s, A[n-1-i])\\n            large[i] = l\\n            small[n-1-i] = s\\n        for i in range(n):   \\n            if large[i] <= small[i+1]: return i+1\\n        return -1    \\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        left = [A[0]]\\n        for i in range(1, len(A)):\\n            left.append(max(left[-1], A[i]))\\n        right = [A[-1]]\\n        for i in range(len(A) - 2, -1, -1):\\n            right.append(min(right[-1], A[i]))\\n        for i in range(1, len(A)):\\n            if left[i - 1] <= right[-i - 1]:\\n                return i\\n            \\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        n = len(A)\\n        left = [0 for i in range(n)]\\n        right = [0 for i in range(n)]\\n        left[0], right[n-1] = A[0], A[n-1]\\n        for i in range(1, n):\\n            left[i] = max(left[i-1], A[i])\\n        for i in range(n-2, -1, -1):\\n            right[i] = min(right[i+1], A[i])\\n        print(left, right)\\n        for i in range(n-1):\\n            if left[i] <= right[i+1]:\\n                return i+1\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        run_max = [float('-inf')]\\n        run_min = [float('inf')]\\n        # get run_max\\n        p = 1\\n        while p < len(A):\\n            run_max.append(max(run_max[-1], A[p-1]))\\n            p += 1\\n        # get run_min\\n        p = len(A) - 2\\n        while p > -1:\\n            run_min.append(min(run_min[-1], A[p+1]))\\n            p -= 1\\n        run_min = run_min[::-1]\\n        \\n        # find the pos that satisfies the condition.\\n        res = -1\\n        p = 0\\n        done = False\\n        while p < len(A) - 1 and not done:\\n            if A[p] <= run_min[p] and run_max[p] <= run_min[p]:\\n                res = p + 1\\n                done = True\\n                \\n            p += 1\\n        return  res\\n    \\n    \\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        left_max = []\\n        right_min = []\\n        for i in range(len(A)):\\n            if i == 0:\\n                left_max.append(A[i])\\n            else:\\n                left_max.append(max(A[i], left_max[-1]))\\n        for i in range(len(A)-1, -1, -1):\\n            if i == len(A) - 1:\\n                right_min.append(A[i])\\n            else:\\n                right_min.append(min(A[i], right_min[-1]))\\n        right_min.reverse()\\n        \\n        for i in range(len(A)-1):\\n            lm = left_max[i]\\n            rm = right_min[i+1]\\n            if lm <= rm:\\n                return i+1\\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        n = len(A)\\n        max_left, min_right = [None]*n, [None]*n\\n\\n        max_left[0] = A[0]\\n        for i in range(1, n):\\n            max_left[i] = max(max_left[i-1], A[i])\\n\\n        min_right[-1] = A[-1]\\n        for i in range(n-2, -1, -1):\\n            min_right[i] = min(min_right[i+1], A[i])\\n\\n        for i in range(1, n):\\n            if max_left[i-1] <= min_right[i]:\\n                return i\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        l, r = 0, len(A) - 1\\n        leftMax = A[l]\\n        rightMin = A[r]\\n        minHash = {}\\n        \\n        while l < r:\\n            leftMax = max(leftMax, A[l])\\n            rightMin = min(rightMin, A[r])\\n            \\n            if rightMin >= leftMax:\\n                r -= 1\\n            else:\\n                l += 1\\n        \\n        for i in range(r, len(A)):\\n            if A[i] not in minHash:\\n                minHash[A[i]] = []\\n            minHash[A[i]].append(i)\\n        minHash = sorted(list(minHash.items()), key=lambda x: x[0])\\n        \\n        #print (leftMax, rightMin, minHash)\\n        i, res = 0, 1\\n        while i < len(minHash) and minHash[i][0] < leftMax:\\n            positions = minHash[i][1]\\n            res = max(positions[-1]+1, res)\\n            i += 1\\n\\n        return res\\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        mx=[-1]*len(A)\\n        mn=[-1]*len(A)\\n        for i in range(len(A)):\\n            if i==0:\\n                mx[i]=A[i]\\n            else:\\n                mx[i]=max(A[i],mx[i-1])\\n        for j in range(len(A)-1,-1,-1):\\n            if j==len(A)-1:\\n                mn[j]=A[j]\\n            else:\\n                mn[j]=min(A[j],mn[j+1])\\n        #print(mx,mn)\\n        for i in range(len(A)-1):\\n            #print(mx[i],mn[i+1])\\n            if mx[i]<=mn[i+1]:\\n                #print('yo')\\n                return i+1\\n        return len(A)-1\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        n = len(A)\\n        memo = [[0 for _ in range(n)] for _ in range(2)]\\n        left, right = 0, (1<<31)-1\\n        i, j = 0, n-1\\n        while i < n and j >= 0:\\n            right = min(right, A[j])\\n            left = max(left, A[i])\\n            memo[0][i] = left\\n            memo[1][j] = right\\n            i += 1\\n            j -= 1\\n        i, j = 0, 1\\n        while j < n and memo[0][i] > memo[1][j]:\\n            i, j = i+1, j+1\\n        return j\", \"from collections import Counter\\n\\nclass Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        \\n        c = Counter(A)\\n        d = Counter()\\n        \\n        keys = sorted(c.keys())\\n        \\n        d[keys[0]] = 0\\n        for i in range(1, len(keys)):\\n            d[keys[i]] = c[keys[i-1]] + d[keys[i-1]]\\n            \\n        lesscount, mx = 0, -float('inf')\\n        \\n        \\n        equal = 0\\n        \\n        for i in range(len(A)):\\n            # mx = max(mx, A[i])\\n            \\n            if A[i] < mx:\\n                lesscount += 1 \\n            elif A[i] == mx:\\n                equal += 1\\n            else:\\n                mx = A[i]\\n                lesscount += equal\\n                equal = 1\\n                \\n\\n            # print(A[i], mx, lesscount, equal, d[mx])   \\n            if lesscount == d[mx]:\\n                return i + 1\\n            \\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        left = [0 for i in range(len(A))]\\n        left[0] = A[0]\\n        for i in range(1, len(A)):\\n            left[i] = max(left[i-1], A[i])\\n        right = [0 for i in range(len(A))]\\n        right[-1] = A[-1]\\n        for i in reversed(range(len(A)-1)):\\n            right[i] = min(right[i+1], A[i])\\n        for i in range(len(A)-1):\\n            if left[i] <= right[i+1]:\\n                return i+1\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        N = len(A)\\n        maxLeft = dict()\\n        minRight = dict()\\n        \\n        if N == 2 and A[0] <= A[1]:\\n            return 1\\n\\n        maxLeft[0] = A[0]\\n        for i in range(1, N - 1):\\n            maxLeft[i] = max(maxLeft[i - 1], A[i])\\n            \\n        minRight[N - 1] = A[-1]\\n        for i in range(N - 2, 0, -1):\\n            minRight[i] = min(minRight[i + 1], A[i])\\n            \\n        print({ 'maxLeft': maxLeft })\\n        print({ 'minRight': minRight })\\n        \\n        for i in range(N - 1):\\n            if maxLeft[i] <= minRight[i + 1]:\\n                return i + 1\\n            \\n        return -1\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        mx=[-1]*len(A)\\n        mn=[-1]*len(A)\\n        for i in range(len(A)):\\n            if i==0:\\n                mx[i]=A[i]\\n            else:\\n                mx[i]=max(A[i],mx[i-1])\\n        for j in range(len(A)-1,-1,-1):\\n            if j==len(A)-1:\\n                mn[j]=A[j]\\n            else:\\n                mn[j]=min(A[j],mn[j+1])\\n        #print(mx,mn)\\n        for i in range(len(A)-1):\\n            print(mx[i],mn[i+1])\\n            if mx[i]<=mn[i+1]:\\n                #print('yo')\\n                return i+1\\n        return len(A)-1\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        length = len(A)\\n        leftMax = A[0]\\n        currMax = leftMax\\n        ret = 0\\n        \\n        for i in range(1, length):\\n            currMax = max(A[i], currMax)\\n            if leftMax > A[i]:\\n                leftMax = currMax\\n                ret = i\\n        \\n        return ret + 1\\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        maxval = A[0]\\n        v = A[0]\\n        disjoint = 0\\n        for i in range(len(A)):\\n            maxval = max(maxval,A[i])\\n            if A[i]<v:\\n                disjoint = i\\n                v = maxval\\n                \\n        return disjoint+1\\n                \\n        \\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        split_index = 0\\n        local_max = A[0]\\n        max_num = local_max\\n        \\n        for i in range(len(A)):\\n            if A[i] < local_max:\\n                split_index = i\\n                local_max = max_num\\n            else:\\n                max_num = max(max_num,A[i])\\n        return split_index + 1\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        minA=[A[0],]\\n        for i in A[1:]:\\n            minA.append(max(i,minA[-1]))\\n        minB=[A[-1],]\\n        for i in A[:-1][::-1]:\\n            minB.append(min(minB[-1],i))\\n        minB=minB[::-1]\\n        for i in range(1,len(A)):\\n            if minA[i-1]<=minB[i]:\\n                return i\\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        max_left = float('-inf')\\n        min_right = A[-1]\\n        left = []\\n        right = [A[-1]]\\n        \\n        for i in range(len(A)):\\n            max_left = max(max_left, A[i])\\n            left.append(max_left)\\n            \\n        for i in range(len(A) - 2, -1, -1):\\n            min_right = min(min_right, A[i + 1])\\n            right.append(min_right)\\n        right.reverse()\\n        #print(left)\\n        #print(right)\\n        for i in range(len(left)):\\n            if left[i] <= right[i]:\\n                return i + 1\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        left = [0]*len(A)\\n        for i in range(len(A)):\\n            if i == 0:\\n                left[i] = A[i]\\n            else:\\n                if A[i] > left[i-1]:\\n                    left[i] = A[i]\\n                else:\\n                    left[i] = left[i-1]\\n        \\n        A_reversed = A[::-1]\\n        right = [0]*len(A)\\n        for i in range(len(A)):\\n            if i == 0:\\n                right[i] = A_reversed[i]\\n            else:\\n                if A_reversed[i] < right[i-1]:\\n                    right[i] = A_reversed[i]\\n                else:\\n                    right[i] = right[i-1]\\n        right = right[::-1]\\n        \\n        print(left, right)\\n        for i in range(len(left)-1):\\n            if left[i] <= right[i+1]:\\n                return i+1\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        n = len(A)\\n        d = [0] * n\\n        d[n-1] = A[n-1]\\n        for i in range(len(A)-2,-1,-1):\\n            d[i] = min(A[i],d[i+1])\\n        # print(d)\\n        mx = A[0]\\n        for i in range(1,n):\\n            if mx <= d[i]:\\n                return i\\n            else:\\n                mx = max(mx,A[i])\\n            \\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        least = [float('inf')] * len(A)\\n        for i in range(len(A)-1, -1, -1):\\n            if i == len(A) - 1:\\n                least[i] = A[i]\\n            else:\\n                least[i] = min(least[i+1], A[i])\\n        greatest = A[0]    \\n        for i in range(1, len(A)):\\n            if greatest <= least[i]:\\n                break\\n            greatest = max(greatest, A[i])\\n        return i\\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        l = [0] * len(A)\\n        r = [0] * len(A)\\n        \\n        for i in range(len(l)):\\n            l[i] = max(A[i],l[i-1])\\n        r[-1] = A[-1]\\n        for i in range(len(r)-2,-1,-1):\\n            r[i] = min(A[i],r[i+1])\\n            \\n        print(l)\\n        print(r)\\n        for i in range(len(l)):\\n            if l[i] <= r[i+1]:\\n                return i+1\\n        return len(l)\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        ans = 1\\n        all_max = A[0]\\n        curr_max = 0\\n        for i in range(len(A)):\\n            curr_max = max(curr_max, A[i])\\n            if all_max > A[i]:\\n                all_max = curr_max\\n                ans = i + 1\\n        return ans\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        '''\\n        [5,0,3,8,6]\\n         mn=[5,0,0,0]\\n         mx=[5,5,5,8,8]\\n        \\n        [1,1,1,0,6,12]\\n        mx=[1,1,1,1,6,12]\\n        '''\\n        ml=0\\n        mx=-1e9\\n        mxsofar=1e9\\n        for i,a in enumerate(A):\\n            mx=max(a,mx)\\n            if a<mxsofar:\\n                ml=i+1\\n                mxsofar=mx\\n                #print(\\\\\\\"a=%d,mx=%d,mxsofar %d\\\\\\\"%(a,mx,mxsofar))\\n            \\n        return ml\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        right = 1\\n        maxLeft = A[0]\\n        \\n        sortedRight = sorted(range(right, len(A)), key=lambda k: A[k])\\n        \\n        while A[sortedRight[0]] < maxLeft:\\n            right = sortedRight[0] + 1\\n            maxLeft = max(A[:right])\\n            sortedRight = sorted(range(right, len(A)), key=lambda k: A[k])\\n        \\n        return right\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        left = [0]*len(A)\\n        left[0] = A[0]\\n        for i in range(1,len(A)):\\n            left[i] = max(A[i],left[i-1])\\n        right = [0]*len(A)\\n        right[-1] = A[-1]\\n        for i in range(len(A)-2,-1,-1):\\n            right[i] = min(A[i],right[i+1])\\n        print((*left))\\n        print((*right))\\n        for i in range(1, len(A)):\\n            if right[i] >= left[i-1]:\\n                return i\\n        \\n#         N = len(A)\\n#         maxleft = [None] * N\\n#         minright = [None] * N\\n\\n#         m = A[0]\\n#         for i in range(N):\\n#             m = max(m, A[i])\\n#             maxleft[i] = m\\n\\n#         m = A[-1]\\n#         for i in range(N-1, -1, -1):\\n#             m = min(m, A[i])\\n#             minright[i] = m\\n#         print(*maxleft)\\n#         print(*minright)\\n#         for i in range(1, N):\\n#             if maxleft[i-1] <= minright[i]:\\n#                 return i\\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        # O(N**2) with sapce O(1)\\n        n = len(A)\\n        \\n            \\n            \\n        # O(n) with space O(n)\\n        m = n - 1\\n        left_max = [0] * m\\n        left_max[0] = A[0]\\n        right_min = [0] * m\\n        right_min[-1] = A[-1]\\n        \\n        for i in range(1,n-1):\\n            left_max[i] = max(left_max[i-1], A[i])\\n        \\n        \\n        for i in reversed(range(1,m)):\\n            right_min[i-1] = min(right_min[i], A[i])\\n        for i in range(m):\\n            if left_max[i] <= right_min[i]:\\n                return i + 1\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        # O(N**2) with sapce O(1)\\n        n = len(A)\\n        \\n            \\n            \\n        # O(n) with space O(n)\\n        m = n - 1\\n        left_max = [0] * m\\n        left_max[0] = A[0]\\n        right_min = [0] * m\\n        right_min[-1] = A[-1]\\n        \\n        for i in range(1,n-1):\\n            left_max[i] = max(left_max[i-1], A[i])\\n        \\n        \\n        for i in reversed(range(1,m)):\\n            right_min[i-1] = min(right_min[i], A[i])\\n        \\n        print(left_max)\\n        print(right_min)\\n        for i in range(m):\\n            if left_max[i] <= right_min[i]:\\n                return i + 1\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n\\n        bound = r = 0\\n        gmax = lmax = A[0]\\n        while r < len(A):\\n            if A[r] >= gmax:\\n                lmax = max(lmax, A[r])\\n                r += 1\\n            else:\\n                bound = r\\n                gmax = max(gmax, lmax)\\n                r += 1\\n\\n        return bound+1\\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        h = {}\\n        right = float('inf')\\n\\n        for j in range(len(A)-1,-1,-1):\\n            right = min(right, A[j])\\n            h[j] = right\\n        \\n        left = float('-inf')\\n        for i in range(len(A)-1):\\n            left = max(left, A[i])\\n            if left <= h[i+1]:\\n                return i + 1\\n        \\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        cnt = collections.Counter(A)\\n        cur = 0\\n        minn = min(cnt.keys())\\n        for i in range(len(A)):\\n            cur = max(cur, A[i])\\n            cnt[A[i]] -= 1\\n            if cnt[A[i]] == 0:\\n                del cnt[A[i]]\\n                if minn == A[i]:\\n                    minn = min(cnt.keys())\\n            if minn >= cur:\\n                return i + 1\\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        l = [A[0]]\\n        r = [A[-1]]\\n\\n        for i, v in enumerate(A):\\n            if i == 0:\\n                continue\\n\\n            l.append(max(l[i-1], A[i]))\\n            r.append(min(r[i-1], A[len(A) - i - 1]))\\n\\n        r.reverse()\\n        for i in range(1, len(l)):\\n            if l[i-1] <= r[i]:\\n                return i\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        n = len(A)\\n        \\n        partidx = 0\\n        left_max = A[0]\\n        seen_max = A[0]\\n        for i in range(1, n):\\n            seen_max = max(seen_max, A[i])\\n            if A[i] < left_max:\\n                partidx = i\\n                left_max = seen_max\\n        return partidx + 1\\n            \\n        \\n        \\n        \\n        # left = [0 for i in range(n)]\\n        # right = [0 for i in range(n)]\\n        # left[0], right[n-1] = A[0], A[n-1]\\n        # for i in range(1, n):\\n        #     left[i] = max(left[i-1], A[i])\\n        # for i in range(n-2, -1, -1):\\n        #     right[i] = min(right[i+1], A[i])\\n        # print(left, right)\\n        # for i in range(n-1):\\n        #     if left[i] <= right[i+1]:\\n        #         return i+1\\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        i = 1\\n        l_max = A[i-1]\\n        r_min = min(A[i:])\\n\\n        while l_max > r_min:\\n            i += 1\\n            l_max = max(l_max, A[i-1])\\n            if A[i-1] == r_min:\\n                r_min = min(A[i:])\\n            \\n        return i\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        n = len(A)\\n        ma = [0] * n\\n        mi = [0] * n\\n        \\n        mi[-1] = A[-1]\\n        for i in range(n-2, -1, -1):\\n            mi[i] = min(A[i+1], mi[i+1])\\n        \\n        ma[0] = A[0]\\n        for i in range(1, n):\\n            ma[i] = max(A[i], ma[i-1])\\n        \\n        # print(mi)\\n        # print(ma)\\n        \\n        for i in range(n-1):\\n            if mi[i] >= ma[i]:\\n                return i + 1\\n        return n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        max_left = [None] * len(A)\\n        min_right = [None] * len(A)\\n        \\n        m = A[0]\\n        for i in range(len(A)):\\n            m = max(m, A[i])\\n            max_left[i] = m\\n\\n        m = A[-1]\\n        for i in range(len(A)-1, -1, -1):\\n            m = min(m, A[i])\\n            min_right[i] = m\\n\\n        for i in range(1, len(A)):\\n            if max_left[i-1] <= min_right[i]:\\n                return i\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        max_left = list()\\n        min_right = list()\\n        \\n        for i in range(len(A)):\\n            left = A[i]\\n            if i == 0:\\n                max_left.append(left)\\n            elif max_left[i-1] > left:\\n                max_left.append(max_left[i-1])\\n            else:\\n                max_left.append(left)\\n                \\n            right = A[len(A) - 1 - i]\\n            if i == 0:\\n                min_right.append(right)\\n            elif min_right[i-1] < right:\\n                min_right.append(min_right[i-1])\\n            else:\\n                min_right.append(right)\\n\\n        for i in range(len(A)):\\n            if max_left[i] <= min_right[len(A) - i - 2]:\\n                return i+1\\n        return 0\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        p = [None]*len(A)\\n        q = [None]*len(A)\\n        \\n        for i,v in enumerate(A):\\n            if i == 0:\\n                p[0] = v\\n            else:\\n                p[i] = max(p[i-1],v)\\n        \\n        for i,v in enumerate(reversed(A)):\\n            if i == 0:\\n                q[len(A)-1] = v\\n            else:\\n                q[len(A)-1-i] = min(q[len(A)-i],v)\\n        \\n        # print(p,q)\\n        for i in range(len(A)-1):\\n            if p[i] <= q[i+1]:\\n                return i+1\\n        \\n        return len(A)\", \"from sortedcontainers import SortedList\\n\\nclass Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        left, right = SortedList(), SortedList(A)\\n        for i in range(len(A)-1):\\n            left.add(A[i])\\n            right.discard(A[i])\\n            if left[-1] <= right[0]:\\n                break\\n        return i + 1\\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        i = 1\\n        l_max = A[i-1]\\n\\n        d = Counter(A[i:])\\n        a_dict = OrderedDict(sorted(d.items()))\\n        r_min = next(iter(a_dict.items()))[0]\\n\\n        while l_max > r_min:\\n            i += 1\\n            l_max = max(l_max, A[i-1])\\n            if a_dict[A[i-1]] > 1:\\n                a_dict[A[i-1]] -= 1\\n            else:\\n                del a_dict[A[i-1]]\\n                r_min = next(iter(a_dict.items()))[0]\\n                \\n        return i\", \"# n^2 time to look at all subarrays\\n# n time to iterate backwards ?\\nclass Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        min_right = min(A)\\n        max_left = 0\\n        \\n        min_from_right = []\\n        current_min_right = A[-1]\\n        for i in range(len(A) - 1, -1, -1):\\n            current_min_right = min(A[i], current_min_right)\\n            min_from_right.insert(0, current_min_right)\\n        \\n        for i in range(len(A)):\\n            current = A[i]\\n            max_left = max(max_left, current)\\n            min_right = min_from_right[i + 1] if i < len(A) else 0\\n            if max_left <= min_right:\\n                return i + 1\\n\\n#         def check_partitions(a, b):\\n#             max_a = 0\\n#             for num in a:\\n#                 max_a = max(max_a, num)\\n#             min_b = maxsize\\n#             for num in b:\\n#                 min_b = min(min_b, num)\\n#             if max_a <= min_b and len(a) > 0 and len(b) > 0:\\n#                 return len(a)\\n#             return -1\\n        \\n#         min_left = maxsize\\n#         for i in range(1, len(A) + 1):\\n#             cand = check_partitions(A[0:i], A[i: len(A)])\\n#             if cand != -1:\\n#                 min_left = min(min_left, cand)\\n        \\n#         return min_left\\n\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        \\n        maxlefts = []\\n        minrights = []\\n        \\n        m = A[0]\\n        for n in A:\\n            m = max(m, n)\\n            maxlefts.append(m)\\n        \\n        m = A[len(A) - 1]\\n        for n in A[::-1]:\\n            m = min(m, n)\\n            minrights.insert(0, m)\\n        \\n        for i in range(1, len(A)):\\n            if maxlefts[i - 1] <= minrights[i]: return i\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        res = 0\\n        v = A[0]\\n        max_sofar = v\\n        for i in range(len(A)):\\n            max_sofar = max(max_sofar, A[i])\\n            if A[i] < v:\\n                v = max_sofar\\n                res = i\\n                \\n        return res+1\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        # biggest = A[0]\\n        # newbiggest = A[0]\\n        # lenL = 1\\n        # total = 1\\n        # for itr in A[1:]:\\n        #     total += 1\\n        #     if itr < biggest:\\n        #         lenL = total\\n        #         biggest = newbiggest\\n        #     else:\\n        #         if itr > newbiggest:\\n        #             newbiggest = itr\\n        # return lenL\\n        disjoint = 0\\n        v = A[disjoint]\\n        max_so_far = v\\n        for i in range(len(A)):\\n            max_so_far = max(max_so_far, A[i])\\n            if A[i] < v: \\n                disjoint = i\\n                v = max_so_far\\n        return disjoint + 1\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        n = len(A)\\n        mins = [float('inf')]*(n-1)+[A[-1]]\\n        for i in range(n-2, -1, -1):\\n            mins[i] = min(A[i], mins[i+1])\\n\\n        maxi = 0\\n        for i in range(n-1):\\n            maxi = max(maxi, A[i])\\n            if maxi<=mins[i+1]:\\n                return i+1\\n        return -1\", \"class Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        left_maxes = A[:]\\n        right_mins = A[:]\\n        \\n        for i in range(1, len(left_maxes)):\\n            if left_maxes[i] < left_maxes[i - 1]:\\n                left_maxes[i] = left_maxes[i - 1]\\n        \\n        for i in range(len(right_mins) - 2, -1, -1):\\n            if right_mins[i] > right_mins[i + 1]:\\n                right_mins[i] = right_mins[i + 1]\\n        \\n        for i in range(1, len(A)):\\n            if left_maxes[i - 1] <= right_mins[i]:\\n                return i\\n        \\n                \\n\"]", "input_output": "{\"fn_name\": \"partitionDisjoint\", \"inputs\": [[[5, 0, 3, 8, 6]]], \"outputs\": [3]}", "difficulty": "interview", "url": "https://leetcode.com/problems/partition-array-into-disjoint-intervals/", "starter_code": "\nclass Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        "}
